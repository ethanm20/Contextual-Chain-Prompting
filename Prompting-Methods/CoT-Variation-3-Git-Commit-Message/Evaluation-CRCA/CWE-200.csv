,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,G1_Clarity_C3_C5,G2_Relevance_C3_C5,G3_Completeness_C3_C5,G4_Actionability_C3_C5
0,0,6181,6181,,Remote,Not required,,CVE-2012-6113,https://www.cvedetails.com/cve/CVE-2012-6113/,CWE-200,Low,Partial,,,2013-01-19,5.0,"The openssl_encrypt function in ext/openssl/openssl.c in PHP 5.3.9 through 5.3.13 does not initialize a certain variable, which allows remote attackers to obtain sensitive information from process memory by providing zero bytes of input data.",2013-02-02,+Info,0,https://git.php.net/?p=php-src.git;a=commit;h=270a406ac94b5fc5cc9ef59fc61e3b4b95648a3e,270a406ac94b5fc5cc9ef59fc61e3b4b95648a3e,,0,,,"PHP_FUNCTION(openssl_x509_parse)
{
	zval ** zcert;
	X509 * cert = NULL;
	long certresource = -1;
	int i;
	zend_bool useshortnames = 1;
	char * tmpstr;
	zval * subitem;
	X509_EXTENSION *extension;
	char *extname;
	BIO  *bio_out;
	BUF_MEM *bio_buf;
	char buf[256];

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""Z|b"", &zcert, &useshortnames) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	array_init(return_value);

	if (cert->name) {
		add_assoc_string(return_value, ""name"", cert->name, 1);
	}
/*	add_assoc_bool(return_value, ""valid"", cert->valid); */

	add_assoc_name_entry(return_value, ""subject"", 		X509_get_subject_name(cert), useshortnames TSRMLS_CC);
	/* hash as used in CA directories to lookup cert by subject name */
	{
		char buf[32];
		snprintf(buf, sizeof(buf), ""%08lx"", X509_subject_name_hash(cert));
		add_assoc_string(return_value, ""hash"", buf, 1);
	}
	
	add_assoc_name_entry(return_value, ""issuer"", 		X509_get_issuer_name(cert), useshortnames TSRMLS_CC);
	add_assoc_long(return_value, ""version"", 			X509_get_version(cert));

	add_assoc_string(return_value, ""serialNumber"", i2s_ASN1_INTEGER(NULL, X509_get_serialNumber(cert)), 1); 

	add_assoc_asn1_string(return_value, ""validFrom"", 	X509_get_notBefore(cert));
	add_assoc_asn1_string(return_value, ""validTo"", 		X509_get_notAfter(cert));

	add_assoc_long(return_value, ""validFrom_time_t"", 	asn1_time_to_time_t(X509_get_notBefore(cert) TSRMLS_CC));
	add_assoc_long(return_value, ""validTo_time_t"", 		asn1_time_to_time_t(X509_get_notAfter(cert) TSRMLS_CC));

	tmpstr = (char *)X509_alias_get0(cert, NULL);
	if (tmpstr) {
		add_assoc_string(return_value, ""alias"", tmpstr, 1);
	}
/*
	add_assoc_long(return_value, ""signaturetypeLONG"", X509_get_signature_type(cert));
	add_assoc_string(return_value, ""signaturetype"", OBJ_nid2sn(X509_get_signature_type(cert)), 1);
	add_assoc_string(return_value, ""signaturetypeLN"", OBJ_nid2ln(X509_get_signature_type(cert)), 1);
*/
	MAKE_STD_ZVAL(subitem);
	array_init(subitem);

	/* NOTE: the purposes are added as integer keys - the keys match up to the X509_PURPOSE_SSL_XXX defines
	   in x509v3.h */
	for (i = 0; i < X509_PURPOSE_get_count(); i++) {
		int id, purpset;
		char * pname;
		X509_PURPOSE * purp;
		zval * subsub;

		MAKE_STD_ZVAL(subsub);
		array_init(subsub);

		purp = X509_PURPOSE_get0(i);
		id = X509_PURPOSE_get_id(purp);

		purpset = X509_check_purpose(cert, id, 0);
		add_index_bool(subsub, 0, purpset);

		purpset = X509_check_purpose(cert, id, 1);
		add_index_bool(subsub, 1, purpset);

		pname = useshortnames ? X509_PURPOSE_get0_sname(purp) : X509_PURPOSE_get0_name(purp);
		add_index_string(subsub, 2, pname, 1);

		/* NOTE: if purpset > 1 then it's a warning - we should mention it ? */

		add_index_zval(subitem, id, subsub);
	}
	add_assoc_zval(return_value, ""purposes"", subitem);

	MAKE_STD_ZVAL(subitem);
	array_init(subitem);


	for (i = 0; i < X509_get_ext_count(cert); i++) {
		extension = X509_get_ext(cert, i);
		if (OBJ_obj2nid(X509_EXTENSION_get_object(extension)) != NID_undef) {
			extname = (char *)OBJ_nid2sn(OBJ_obj2nid(X509_EXTENSION_get_object(extension)));
		} else {
			OBJ_obj2txt(buf, sizeof(buf)-1, X509_EXTENSION_get_object(extension), 1);
			extname = buf;
		}
		bio_out = BIO_new(BIO_s_mem());
		if (X509V3_EXT_print(bio_out, extension, 0, 0)) {
			BIO_get_mem_ptr(bio_out, &bio_buf);
			add_assoc_stringl(subitem, extname, bio_buf->data, bio_buf->length, 1);
		} else {
			add_assoc_asn1_string(subitem, extname, X509_EXTENSION_get_data(extension));
		}
		BIO_free(bio_out);
	}
	add_assoc_zval(return_value, ""extensions"", subitem);

	if (certresource == -1 && cert) {
		X509_free(cert);
	}
}
","PHP_FUNCTION(openssl_x509_parse)
{
	zval ** zcert;
	X509 * cert = NULL;
	long certresource = -1;
	int i;
	zend_bool useshortnames = 1;
	char * tmpstr;
	zval * subitem;
	X509_EXTENSION *extension;
	char *extname;
	BIO  *bio_out;
	BUF_MEM *bio_buf;
	char buf[256];

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""Z|b"", &zcert, &useshortnames) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	array_init(return_value);

	if (cert->name) {
		add_assoc_string(return_value, ""name"", cert->name, 1);
	}
/*	add_assoc_bool(return_value, ""valid"", cert->valid); */

	add_assoc_name_entry(return_value, ""subject"", 		X509_get_subject_name(cert), useshortnames TSRMLS_CC);
	/* hash as used in CA directories to lookup cert by subject name */
	{
		char buf[32];
		snprintf(buf, sizeof(buf), ""%08lx"", X509_subject_name_hash(cert));
		add_assoc_string(return_value, ""hash"", buf, 1);
	}
	
	add_assoc_name_entry(return_value, ""issuer"", 		X509_get_issuer_name(cert), useshortnames TSRMLS_CC);
	add_assoc_long(return_value, ""version"", 			X509_get_version(cert));

	add_assoc_string(return_value, ""serialNumber"", i2s_ASN1_INTEGER(NULL, X509_get_serialNumber(cert)), 1); 

	add_assoc_asn1_string(return_value, ""validFrom"", 	X509_get_notBefore(cert));
	add_assoc_asn1_string(return_value, ""validTo"", 		X509_get_notAfter(cert));

	add_assoc_long(return_value, ""validFrom_time_t"", 	asn1_time_to_time_t(X509_get_notBefore(cert) TSRMLS_CC));
	add_assoc_long(return_value, ""validTo_time_t"", 		asn1_time_to_time_t(X509_get_notAfter(cert) TSRMLS_CC));

	tmpstr = (char *)X509_alias_get0(cert, NULL);
	if (tmpstr) {
		add_assoc_string(return_value, ""alias"", tmpstr, 1);
	}
/*
	add_assoc_long(return_value, ""signaturetypeLONG"", X509_get_signature_type(cert));
	add_assoc_string(return_value, ""signaturetype"", OBJ_nid2sn(X509_get_signature_type(cert)), 1);
	add_assoc_string(return_value, ""signaturetypeLN"", OBJ_nid2ln(X509_get_signature_type(cert)), 1);
*/
	MAKE_STD_ZVAL(subitem);
	array_init(subitem);

	/* NOTE: the purposes are added as integer keys - the keys match up to the X509_PURPOSE_SSL_XXX defines
	   in x509v3.h */
	for (i = 0; i < X509_PURPOSE_get_count(); i++) {
		int id, purpset;
		char * pname;
		X509_PURPOSE * purp;
		zval * subsub;

		MAKE_STD_ZVAL(subsub);
		array_init(subsub);

		purp = X509_PURPOSE_get0(i);
		id = X509_PURPOSE_get_id(purp);

		purpset = X509_check_purpose(cert, id, 0);
		add_index_bool(subsub, 0, purpset);

		purpset = X509_check_purpose(cert, id, 1);
		add_index_bool(subsub, 1, purpset);

		pname = useshortnames ? X509_PURPOSE_get0_sname(purp) : X509_PURPOSE_get0_name(purp);
		add_index_string(subsub, 2, pname, 1);

		/* NOTE: if purpset > 1 then it's a warning - we should mention it ? */

		add_index_zval(subitem, id, subsub);
	}
	add_assoc_zval(return_value, ""purposes"", subitem);

	MAKE_STD_ZVAL(subitem);
	array_init(subitem);


	for (i = 0; i < X509_get_ext_count(cert); i++) {
		extension = X509_get_ext(cert, i);
		if (OBJ_obj2nid(X509_EXTENSION_get_object(extension)) != NID_undef) {
			extname = (char *)OBJ_nid2sn(OBJ_obj2nid(X509_EXTENSION_get_object(extension)));
		} else {
			OBJ_obj2txt(buf, sizeof(buf)-1, X509_EXTENSION_get_object(extension), 1);
			extname = buf;
		}
		bio_out = BIO_new(BIO_s_mem());
		if (X509V3_EXT_print(bio_out, extension, 0, 0)) {
			BIO_get_mem_ptr(bio_out, &bio_buf);
			add_assoc_stringl(subitem, extname, bio_buf->data, bio_buf->length, 1);
		} else {
			add_assoc_asn1_string(subitem, extname, X509_EXTENSION_get_data(extension));
		}
		BIO_free(bio_out);
	}
	add_assoc_zval(return_value, ""extensions"", subitem);

	if (certresource == -1 && cert) {
		X509_free(cert);
	}
}
",C,,,8d748e5de519867d9b6ce40e3ea28a209b07768f,"@@ -4677,7 +4677,7 @@ PHP_FUNCTION(openssl_encrypt)
        int data_len, method_len, password_len, iv_len = 0, max_iv_len;
        const EVP_CIPHER *cipher_type;
        EVP_CIPHER_CTX cipher_ctx;
-       int i, outlen, keylen;
+       int i = 0, outlen, keylen;
        unsigned char *outbuf, *key;
        zend_bool free_iv;",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/openssl/openssl.c;h=779a91db9c90efaa8b812e9063ca7a2e8d0f9c57;hb=779a91db9c90efaa8b812e9063ca7a2e8d0f9c57,https://git.php.net/?p=php-src.git;a=blob;f=ext/openssl/openssl.c;h=7c5afc55d73e8e4deb60587e0823cf3548aade3e;hb=7c5afc55d73e8e4deb60587e0823cf3548aade3e,0,"PHP_FUNCTION(openssl_x509_parse)
{
	zval ** zcert;
	X509 * cert = NULL;
	long certresource = -1;
	int i;
	zend_bool useshortnames = 1;
	char * tmpstr;
	zval * subitem;
	X509_EXTENSION *extension;
	char *extname;
	BIO  *bio_out;
	BUF_MEM *bio_buf;
	char buf[256];

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""Z|b"", &zcert, &useshortnames) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	array_init(return_value);

	if (cert->name) {
		add_assoc_string(return_value, ""name"", cert->name, 1);
	}
/*	add_assoc_bool(return_value, ""valid"", cert->valid); */

	add_assoc_name_entry(return_value, ""subject"", 		X509_get_subject_name(cert), useshortnames TSRMLS_CC);
	/* hash as used in CA directories to lookup cert by subject name */
	{
		char buf[32];
		snprintf(buf, sizeof(buf), ""%08lx"", X509_subject_name_hash(cert));
		add_assoc_string(return_value, ""hash"", buf, 1);
	}
	
	add_assoc_name_entry(return_value, ""issuer"", 		X509_get_issuer_name(cert), useshortnames TSRMLS_CC);
	add_assoc_long(return_value, ""version"", 			X509_get_version(cert));

	add_assoc_string(return_value, ""serialNumber"", i2s_ASN1_INTEGER(NULL, X509_get_serialNumber(cert)), 1); 

	add_assoc_asn1_string(return_value, ""validFrom"", 	X509_get_notBefore(cert));
	add_assoc_asn1_string(return_value, ""validTo"", 		X509_get_notAfter(cert));

	add_assoc_long(return_value, ""validFrom_time_t"", 	asn1_time_to_time_t(X509_get_notBefore(cert) TSRMLS_CC));
	add_assoc_long(return_value, ""validTo_time_t"", 		asn1_time_to_time_t(X509_get_notAfter(cert) TSRMLS_CC));

	tmpstr = (char *)X509_alias_get0(cert, NULL);
	if (tmpstr) {
		add_assoc_string(return_value, ""alias"", tmpstr, 1);
	}
/*
	add_assoc_long(return_value, ""signaturetypeLONG"", X509_get_signature_type(cert));
	add_assoc_string(return_value, ""signaturetype"", OBJ_nid2sn(X509_get_signature_type(cert)), 1);
	add_assoc_string(return_value, ""signaturetypeLN"", OBJ_nid2ln(X509_get_signature_type(cert)), 1);
*/
	MAKE_STD_ZVAL(subitem);
	array_init(subitem);

	/* NOTE: the purposes are added as integer keys - the keys match up to the X509_PURPOSE_SSL_XXX defines
	   in x509v3.h */
	for (i = 0; i < X509_PURPOSE_get_count(); i++) {
		int id, purpset;
		char * pname;
		X509_PURPOSE * purp;
		zval * subsub;

		MAKE_STD_ZVAL(subsub);
		array_init(subsub);

		purp = X509_PURPOSE_get0(i);
		id = X509_PURPOSE_get_id(purp);

		purpset = X509_check_purpose(cert, id, 0);
		add_index_bool(subsub, 0, purpset);

		purpset = X509_check_purpose(cert, id, 1);
		add_index_bool(subsub, 1, purpset);

		pname = useshortnames ? X509_PURPOSE_get0_sname(purp) : X509_PURPOSE_get0_name(purp);
		add_index_string(subsub, 2, pname, 1);

		/* NOTE: if purpset > 1 then it's a warning - we should mention it ? */

		add_index_zval(subitem, id, subsub);
	}
	add_assoc_zval(return_value, ""purposes"", subitem);

	MAKE_STD_ZVAL(subitem);
	array_init(subitem);


	for (i = 0; i < X509_get_ext_count(cert); i++) {
		extension = X509_get_ext(cert, i);
		if (OBJ_obj2nid(X509_EXTENSION_get_object(extension)) != NID_undef) {
			extname = (char *)OBJ_nid2sn(OBJ_obj2nid(X509_EXTENSION_get_object(extension)));
		} else {
			OBJ_obj2txt(buf, sizeof(buf)-1, X509_EXTENSION_get_object(extension), 1);
			extname = buf;
		}
		bio_out = BIO_new(BIO_s_mem());
		if (X509V3_EXT_print(bio_out, extension, 0, 0)) {
			BIO_get_mem_ptr(bio_out, &bio_buf);
			add_assoc_stringl(subitem, extname, bio_buf->data, bio_buf->length, 1);
		} else {
			add_assoc_asn1_string(subitem, extname, X509_EXTENSION_get_data(extension));
		}
		BIO_free(bio_out);
	}
	add_assoc_zval(return_value, ""extensions"", subitem);

	if (certresource == -1 && cert) {
		X509_free(cert);
	}
}
",6181,"PHP_FUNCTION(openssl_encrypt)
{
	zend_bool raw_output = 0;
	char *data, *method, *password, *iv = """";
        int data_len, method_len, password_len, iv_len = 0, max_iv_len;
        const EVP_CIPHER *cipher_type;
        EVP_CIPHER_CTX cipher_ctx;
       int i, outlen, keylen;
        unsigned char *outbuf, *key;
        zend_bool free_iv;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sss|bs"", &data, &data_len, &method, &method_len, &password, &password_len, &raw_output, &iv, &iv_len) == FAILURE) {
		return;
	}
	cipher_type = EVP_get_cipherbyname(method);
	if (!cipher_type) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unknown cipher algorithm"");
		RETURN_FALSE;
	}

	keylen = EVP_CIPHER_key_length(cipher_type);
	if (keylen > password_len) {
		key = emalloc(keylen);
		memset(key, 0, keylen);
		memcpy(key, password, password_len);
	} else {
		key = (unsigned char*)password;
	}

	max_iv_len = EVP_CIPHER_iv_length(cipher_type);
	if (iv_len <= 0 && max_iv_len > 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Using an empty Initialization Vector (iv) is potentially insecure and not recommended"");
	}
	free_iv = php_openssl_validate_iv(&iv, &iv_len, max_iv_len TSRMLS_CC);

	outlen = data_len + EVP_CIPHER_block_size(cipher_type);
	outbuf = emalloc(outlen + 1);

	EVP_EncryptInit(&cipher_ctx, cipher_type, NULL, NULL);
	if (password_len > keylen) {
		EVP_CIPHER_CTX_set_key_length(&cipher_ctx, password_len);
	}
	EVP_EncryptInit_ex(&cipher_ctx, NULL, NULL, key, (unsigned char *)iv);
	if (data_len > 0) {
		EVP_EncryptUpdate(&cipher_ctx, outbuf, &i, (unsigned char *)data, data_len);
	}
	outlen = i;
	if (EVP_EncryptFinal(&cipher_ctx, (unsigned char *)outbuf + i, &i)) {
		outlen += i;
		if (raw_output) {
			outbuf[outlen] = '\0';
			RETVAL_STRINGL((char *)outbuf, outlen, 0);
		} else {
			int base64_str_len;
			char *base64_str;

			base64_str = (char*)php_base64_encode(outbuf, outlen, &base64_str_len);
			efree(outbuf);
			RETVAL_STRINGL(base64_str, base64_str_len, 0);
		}
	} else {
		efree(outbuf);
		RETVAL_FALSE;
	}
	if (key != (unsigned char*)password) {
		efree(key);
	}
	if (free_iv) {
		efree(iv);
	}
	EVP_CIPHER_CTX_cleanup(&cipher_ctx);
}
","PHP_FUNCTION(openssl_x509_parse)
{
	zval ** zcert;
	X509 * cert = NULL;
	long certresource = -1;
	int i;
	zend_bool useshortnames = 1;
	char * tmpstr;
	zval * subitem;
	X509_EXTENSION *extension;
	char *extname;
	BIO  *bio_out;
	BUF_MEM *bio_buf;
	char buf[256];

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""Z|b"", &zcert, &useshortnames) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	array_init(return_value);

	if (cert->name) {
		add_assoc_string(return_value, ""name"", cert->name, 1);
	}
/*	add_assoc_bool(return_value, ""valid"", cert->valid); */

	add_assoc_name_entry(return_value, ""subject"", 		X509_get_subject_name(cert), useshortnames TSRMLS_CC);
	/* hash as used in CA directories to lookup cert by subject name */
	{
		char buf[32];
		snprintf(buf, sizeof(buf), ""%08lx"", X509_subject_name_hash(cert));
		add_assoc_string(return_value, ""hash"", buf, 1);
	}
	
	add_assoc_name_entry(return_value, ""issuer"", 		X509_get_issuer_name(cert), useshortnames TSRMLS_CC);
	add_assoc_long(return_value, ""version"", 			X509_get_version(cert));

	add_assoc_string(return_value, ""serialNumber"", i2s_ASN1_INTEGER(NULL, X509_get_serialNumber(cert)), 1); 

	add_assoc_asn1_string(return_value, ""validFrom"", 	X509_get_notBefore(cert));
	add_assoc_asn1_string(return_value, ""validTo"", 		X509_get_notAfter(cert));

	add_assoc_long(return_value, ""validFrom_time_t"", 	asn1_time_to_time_t(X509_get_notBefore(cert) TSRMLS_CC));
	add_assoc_long(return_value, ""validTo_time_t"", 		asn1_time_to_time_t(X509_get_notAfter(cert) TSRMLS_CC));

	tmpstr = (char *)X509_alias_get0(cert, NULL);
	if (tmpstr) {
		add_assoc_string(return_value, ""alias"", tmpstr, 1);
	}
/*
	add_assoc_long(return_value, ""signaturetypeLONG"", X509_get_signature_type(cert));
	add_assoc_string(return_value, ""signaturetype"", OBJ_nid2sn(X509_get_signature_type(cert)), 1);
	add_assoc_string(return_value, ""signaturetypeLN"", OBJ_nid2ln(X509_get_signature_type(cert)), 1);
*/
	MAKE_STD_ZVAL(subitem);
	array_init(subitem);

	/* NOTE: the purposes are added as integer keys - the keys match up to the X509_PURPOSE_SSL_XXX defines
	   in x509v3.h */
	for (i = 0; i < X509_PURPOSE_get_count(); i++) {
		int id, purpset;
		char * pname;
		X509_PURPOSE * purp;
		zval * subsub;

		MAKE_STD_ZVAL(subsub);
		array_init(subsub);

		purp = X509_PURPOSE_get0(i);
		id = X509_PURPOSE_get_id(purp);

		purpset = X509_check_purpose(cert, id, 0);
		add_index_bool(subsub, 0, purpset);

		purpset = X509_check_purpose(cert, id, 1);
		add_index_bool(subsub, 1, purpset);

		pname = useshortnames ? X509_PURPOSE_get0_sname(purp) : X509_PURPOSE_get0_name(purp);
		add_index_string(subsub, 2, pname, 1);

		/* NOTE: if purpset > 1 then it's a warning - we should mention it ? */

		add_index_zval(subitem, id, subsub);
	}
	add_assoc_zval(return_value, ""purposes"", subitem);

	MAKE_STD_ZVAL(subitem);
	array_init(subitem);


	for (i = 0; i < X509_get_ext_count(cert); i++) {
		extension = X509_get_ext(cert, i);
		if (OBJ_obj2nid(X509_EXTENSION_get_object(extension)) != NID_undef) {
			extname = (char *)OBJ_nid2sn(OBJ_obj2nid(X509_EXTENSION_get_object(extension)));
		} else {
			OBJ_obj2txt(buf, sizeof(buf)-1, X509_EXTENSION_get_object(extension), 1);
			extname = buf;
		}
		bio_out = BIO_new(BIO_s_mem());
		if (X509V3_EXT_print(bio_out, extension, 0, 0)) {
			BIO_get_mem_ptr(bio_out, &bio_buf);
			add_assoc_stringl(subitem, extname, bio_buf->data, bio_buf->length, 1);
		} else {
			add_assoc_asn1_string(subitem, extname, X509_EXTENSION_get_data(extension));
		}
		BIO_free(bio_out);
	}
	add_assoc_zval(return_value, ""extensions"", subitem);

	if (certresource == -1 && cert) {
		X509_free(cert);
	}
}
","The provided PHP function `openssl_encrypt` implements data encryption using the OpenSSL library. It accepts parameters for the data to be encrypted, the encryption method, a password for key generation, an optional initialization vector (IV), and a flag indicating whether to return raw output. The function validates the cipher method and generates a key based on the provided password, ensuring the IV is secure. It initializes the encryption context, processes the data, and handles padding. The encrypted output can be returned either as raw binary data or as a Base64-encoded string, depending on the specified flag. Finally, it cleans up allocated resources.","The code implements a function for encrypting data using a specified encryption algorithm from a cryptographic library. It takes input data, an encryption method, a password for key generation, and an optional initialization vector. The function validates the encryption method and generates a key based on the password, ensuring the initialization vector is secure. It initializes the encryption process, encrypts the data, and handles any necessary padding. The encrypted output can be returned either as raw binary data or as a Base64-encoded string, while also managing memory and cleaning up resources after processing.","The vulnerability in the original code arises from the lack of proper validation and error handling when parsing and processing the X.509 certificate, which could lead to potential memory leaks or dereferencing null pointers if the certificate is invalid or improperly formatted. Specifically, the function does not check if the certificate is successfully retrieved before proceeding with operations like accessing its subject or issuer names. In the fixed code, additional checks are implemented to ensure that the certificate is valid before accessing its properties, thereby preventing potential crashes and ensuring safer memory management by freeing resources only when necessary.","The vulnerability in the original code stems from inadequate validation of input data, particularly when handling X.509 certificates, which could lead to dereferencing null pointers or accessing invalid memory. This lack of checks could result in crashes or undefined behavior if the certificate is malformed or not properly parsed. In the revised code, additional validation steps were introduced to ensure that the certificate is valid before any operations are performed on it. This change enhances error handling and memory management, preventing potential crashes and ensuring that resources are only freed when appropriate, thereby improving overall stability and security.","The vulnerability was fixed by adding checks to ensure that the certificate is valid before accessing its properties. Specifically, the code now verifies the result of the `php_openssl_x509_from_zval` function, which retrieves the certificate, and only proceeds if the certificate is not null. This prevents dereferencing a null pointer when accessing attributes like the subject and issuer names. Additionally, the code ensures that resources are properly managed by freeing the certificate only when it is no longer needed, as indicated by the check on `certresource`, thus enhancing both stability and security.","The vulnerability was addressed by implementing additional validation checks to ensure that the certificate is properly parsed and valid before any operations are performed on it. This prevents the code from attempting to access properties of a null or invalid certificate, which could lead to crashes or undefined behavior. Furthermore, the revised code includes safeguards for resource management, ensuring that memory is only freed when it is safe to do so. These changes enhance the overall robustness of the code, improving error handling and preventing potential security issues related to improper certificate handling.","5,4","0,0","2,4","4,4"
1,1,177746,177746,,Remote,Not required,,CVE-2015-7665,https://www.cvedetails.com/cve/CVE-2015-7665/,CWE-200,Low,Partial,,,2015-12-27,5.0,"Tails before 1.7 includes the wget program but does not prevent automatic fallback from passive FTP to active FTP, which allows remote FTP servers to discover the Tor client IP address by reading a (1) PORT or (2) EPRT command.  NOTE: within wget itself, the automatic fallback is not considered a vulnerability by CVE.",2016-11-28,+Info,10,https://git.savannah.gnu.org/cgit/wget.git/commit/?id=075d7556964f5a871a73c22ac4b69f5361295099,075d7556964f5a871a73c22ac4b69f5361295099,,5,,,"getftp (struct url *u, wgint passed_expected_bytes, wgint *qtyread,
        wgint restval, ccon *con, int count, wgint *last_expected_bytes,
        FILE *warc_tmp)
{
  int csock, dtsock, local_sock, res;
  uerr_t err = RETROK;          /* appease the compiler */
  FILE *fp;
   char *respline, *tms;
   const char *user, *passwd, *tmrate;
   int cmd = con->cmd;
   wgint expected_bytes = 0;
   bool got_expected_bytes = false;
   bool rest_failed = false;
  bool rest_failed = false;
  int flags;
  wgint rd_size, previous_rd_size = 0;
  char type_char;
  bool try_again;
  bool list_a_used = false;

  assert (con != NULL);
  assert (con->target != NULL);

  /* Debug-check of the sanity of the request by making sure that LIST
     and RETR are never both requested (since we can handle only one
     at a time.  */
  assert (!((cmd & DO_LIST) && (cmd & DO_RETR)));
  /* Make sure that at least *something* is requested.  */
  assert ((cmd & (DO_LIST | DO_CWD | DO_RETR | DO_LOGIN)) != 0);

  *qtyread = restval;

  user = u->user;
  passwd = u->passwd;
  search_netrc (u->host, (const char **)&user, (const char **)&passwd, 1);
  user = user ? user : (opt.ftp_user ? opt.ftp_user : opt.user);
  if (!user) user = ""anonymous"";
  passwd = passwd ? passwd : (opt.ftp_passwd ? opt.ftp_passwd : opt.passwd);
  if (!passwd) passwd = ""-wget@"";

  dtsock = -1;
  local_sock = -1;
  con->dltime = 0;

  if (!(cmd & DO_LOGIN))
    csock = con->csock;
  else                          /* cmd & DO_LOGIN */
    {
      char    *host = con->proxy ? con->proxy->host : u->host;
      int      port = con->proxy ? con->proxy->port : u->port;

      /* Login to the server: */

      /* First: Establish the control connection.  */

      csock = connect_to_host (host, port);
      if (csock == E_HOST)
          return HOSTERR;
      else if (csock < 0)
          return (retryable_socket_connect_error (errno)
                  ? CONERROR : CONIMPOSSIBLE);

      if (cmd & LEAVE_PENDING)
        con->csock = csock;
      else
        con->csock = -1;

      /* Second: Login with proper USER/PASS sequence.  */
      logprintf (LOG_VERBOSE, _(""Logging in as %s ... ""),
                 quotearg_style (escape_quoting_style, user));
      if (opt.server_response)
        logputs (LOG_ALWAYS, ""\n"");
      if (con->proxy)
        {
          /* If proxy is in use, log in as username@target-site. */
          char *logname = concat_strings (user, ""@"", u->host, (char *) 0);
          err = ftp_login (csock, logname, passwd);
          xfree (logname);
        }
      else
        err = ftp_login (csock, user, passwd);

      /* FTPRERR, FTPSRVERR, WRITEFAILED, FTPLOGREFUSED, FTPLOGINC */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPSRVERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""Error in server greeting.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPLOGREFUSED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""The server refuses login.\n""));
          fd_close (csock);
          con->csock = -1;
          return FTPLOGREFUSED;
        case FTPLOGINC:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""Login incorrect.\n""));
          fd_close (csock);
          con->csock = -1;
          return FTPLOGINC;
        case FTPOK:
          if (!opt.server_response)
            logputs (LOG_VERBOSE, _(""Logged in!\n""));
          break;
        default:
          abort ();
        }
      /* Third: Get the system type */
      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> SYST ... "");
      err = ftp_syst (csock, &con->rs, &con->rsu);
      /* FTPRERR */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPSRVERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Server error, can't determine system type.\n""));
          break;
        case FTPOK:
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }
      if (!opt.server_response && err != FTPSRVERR)
        logputs (LOG_VERBOSE, _(""done.    ""));

      /* 2013-10-17 Andrea Urbani (matfanjol)
         According to the system type I choose which
         list command will be used.
         If I don't know that system, I will try, the
         first time of each session, ""LIST -a"" and
         ""LIST"". (see __LIST_A_EXPLANATION__ below) */
      switch (con->rs)
        {
        case ST_VMS:
          /* About ST_VMS there is an old note:
             2008-01-29  SMS.  For a VMS FTP server, where ""LIST -a"" may not
             fail, but will never do what is desired here,
             skip directly to the simple ""LIST"" command
             (assumed to be the last one in the list).  */
          DEBUGP ((""\nVMS: I know it and I will use \""LIST\"" as standard list command\n""));
          con->st |= LIST_AFTER_LIST_A_CHECK_DONE;
          con->st |= AVOID_LIST_A;
          break;
        case ST_UNIX:
          if (con->rsu == UST_MULTINET)
            {
              DEBUGP ((""\nUNIX MultiNet: I know it and I will use \""LIST\"" ""
                       ""as standard list command\n""));
              con->st |= LIST_AFTER_LIST_A_CHECK_DONE;
              con->st |= AVOID_LIST_A;
            }
          else if (con->rsu == UST_TYPE_L8)
            {
              DEBUGP ((""\nUNIX TYPE L8: I know it and I will use \""LIST -a\"" ""
                       ""as standard list command\n""));
              con->st |= LIST_AFTER_LIST_A_CHECK_DONE;
              con->st |= AVOID_LIST;
            }
          break;
        default:
          break;
        }

      /* Fourth: Find the initial ftp directory */

      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> PWD ... "");
      err = ftp_pwd (csock, &con->id);
      /* FTPRERR */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPSRVERR :
          /* PWD unsupported -- assume ""/"". */
          xfree (con->id);
          con->id = xstrdup (""/"");
          break;
        case FTPOK:
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }

#if 0
      /* 2004-09-17 SMS.
         Don't help me out.  Please.
         A reasonably recent VMS FTP server will cope just fine with
         UNIX file specifications.  This code just spoils things.
         Discarding the device name, for example, is not a wise move.
         This code was disabled but left in as an example of what not
         to do.
      */

      /* VMS will report something like ""PUB$DEVICE:[INITIAL.FOLDER]"".
         Convert it to ""/INITIAL/FOLDER"" */
      if (con->rs == ST_VMS)
        {
          char *path = strchr (con->id, '[');
          char *pathend = path ? strchr (path + 1, ']') : NULL;
          if (!path || !pathend)
            DEBUGP ((""Initial VMS directory not in the form [...]!\n""));
          else
            {
              char *idir = con->id;
              DEBUGP ((""Preprocessing the initial VMS directory\n""));
              DEBUGP ((""  old = '%s'\n"", con->id));
              /* We do the conversion in-place by copying the stuff
                 between [ and ] to the beginning, and changing dots
                 to slashes at the same time.  */
              *idir++ = '/';
              for (++path; path < pathend; path++, idir++)
                *idir = *path == '.' ? '/' : *path;
              *idir = '\0';
              DEBUGP ((""  new = '%s'\n\n"", con->id));
            }
        }
#endif /* 0 */

      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.\n""));

      /* Fifth: Set the FTP type.  */
      type_char = ftp_process_type (u->params);
      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> TYPE %c ... "", type_char);
      err = ftp_type (csock, type_char);
      /* FTPRERR, WRITEFAILED, FTPUNKNOWNTYPE */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPUNKNOWNTYPE:
          logputs (LOG_VERBOSE, ""\n"");
          logprintf (LOG_NOTQUIET,
                     _(""Unknown type `%c', closing control connection.\n""),
                     type_char);
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPOK:
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }
      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.  ""));
    } /* do login */

  if (cmd & DO_CWD)
    {
      if (!*u->dir)
        logputs (LOG_VERBOSE, _(""==> CWD not needed.\n""));
      else
        {
          const char *targ = NULL;
          int cwd_count;
          int cwd_end;
          int cwd_start;

          char *target = u->dir;

          DEBUGP ((""changing working directory\n""));

          /* Change working directory.  To change to a non-absolute
             Unix directory, we need to prepend initial directory
             (con->id) to it.  Absolute directories ""just work"".

             A relative directory is one that does not begin with '/'
             and, on non-Unix OS'es, one that doesn't begin with
             ""[a-z]:"".

             This is not done for OS400, which doesn't use
             ""/""-delimited directories, nor does it support directory
             hierarchies.  ""CWD foo"" followed by ""CWD bar"" leaves us
             in ""bar"", not in ""foo/bar"", as would be customary
             elsewhere.  */

            /* 2004-09-20 SMS.
               Why is this wise even on UNIX?  It certainly fouls VMS.
               See below for a more reliable, more universal method.
            */

            /* 2008-04-22 MJC.
               I'm not crazy about it either. I'm informed it's useful
               for misconfigured servers that have some dirs in the path
               with +x but -r, but this method is not RFC-conformant. I
               understand the need to deal with crappy server
               configurations, but it's far better to use the canonical
               method first, and fall back to kludges second.
            */

          if (target[0] != '/'
              && !(con->rs != ST_UNIX
                   && c_isalpha (target[0])
                   && target[1] == ':')
              && (con->rs != ST_OS400)
              && (con->rs != ST_VMS))
            {
              int idlen = strlen (con->id);
              char *ntarget, *p;

              /* Strip trailing slash(es) from con->id. */
              while (idlen > 0 && con->id[idlen - 1] == '/')
                --idlen;
              p = ntarget = (char *)alloca (idlen + 1 + strlen (u->dir) + 1);
              memcpy (p, con->id, idlen);
              p += idlen;
              *p++ = '/';
              strcpy (p, target);

              DEBUGP ((""Prepended initial PWD to relative path:\n""));
              DEBUGP ((""   pwd: '%s'\n   old: '%s'\n  new: '%s'\n"",
                       con->id, target, ntarget));
              target = ntarget;
            }

#if 0
          /* 2004-09-17 SMS.
             Don't help me out.  Please.
             A reasonably recent VMS FTP server will cope just fine with
             UNIX file specifications.  This code just spoils things.
             Discarding the device name, for example, is not a wise
             move.
             This code was disabled but left in as an example of what
             not to do.
          */

          /* If the FTP host runs VMS, we will have to convert the absolute
             directory path in UNIX notation to absolute directory path in
             VMS notation as VMS FTP servers do not like UNIX notation of
             absolute paths.  ""VMS notation"" is [dir.subdir.subsubdir]. */

          if (con->rs == ST_VMS)
            {
              char *tmpp;
              char *ntarget = (char *)alloca (strlen (target) + 2);
              /* We use a converted initial dir, so directories in
                 TARGET will be separated with slashes, something like
                 ""/INITIAL/FOLDER/DIR/SUBDIR"".  Convert that to
                 ""[INITIAL.FOLDER.DIR.SUBDIR]"".  */
              strcpy (ntarget, target);
              assert (*ntarget == '/');
              *ntarget = '[';
              for (tmpp = ntarget + 1; *tmpp; tmpp++)
                if (*tmpp == '/')
                  *tmpp = '.';
              *tmpp++ = ']';
              *tmpp = '\0';
              DEBUGP ((""Changed file name to VMS syntax:\n""));
              DEBUGP ((""  Unix: '%s'\n  VMS: '%s'\n"", target, ntarget));
              target = ntarget;
            }
#endif /* 0 */

          /* 2004-09-20 SMS.
             A relative directory is relative to the initial directory.
             Thus, what _is_ useful on VMS (and probably elsewhere) is
             to CWD to the initial directory (ideally, whatever the
             server reports, _exactly_, NOT badly UNIX-ixed), and then
             CWD to the (new) relative directory.  This should probably
             be restructured as a function, called once or twice, but
             I'm lazy enough to take the badly indented loop short-cut
             for now.
          */

          /* Decide on one pass (absolute) or two (relative).
             The VMS restriction may be relaxed when the squirrely code
             above is reformed.
          */
          if ((con->rs == ST_VMS) && (target[0] != '/'))
            {
              cwd_start = 0;
              DEBUGP ((""Using two-step CWD for relative path.\n""));
            }
          else
            {
              /* Go straight to the target. */
              cwd_start = 1;
            }

          /* At least one VMS FTP server (TCPware V5.6-2) can switch to
             a UNIX emulation mode when given a UNIX-like directory
             specification (like ""a/b/c"").  If allowed to continue this
             way, LIST interpretation will be confused, because the
             system type (SYST response) will not be re-checked, and
             future UNIX-format directory listings (for multiple URLs or
             ""-r"") will be horribly misinterpreted.

             The cheap and nasty work-around is to do a ""CWD []"" after a
             UNIX-like directory specification is used.  (A single-level
             directory is harmless.)  This puts the TCPware server back
             into VMS mode, and does no harm on other servers.

             Unlike the rest of this block, this particular behavior
             _is_ VMS-specific, so it gets its own VMS test.
          */
          if ((con->rs == ST_VMS) && (strchr( target, '/') != NULL))
            {
              cwd_end = 3;
              DEBUGP ((""Using extra \""CWD []\"" step for VMS server.\n""));
            }
          else
            {
              cwd_end = 2;
            }

          /* 2004-09-20 SMS. */
          /* Sorry about the deviant indenting.  Laziness. */

          for (cwd_count = cwd_start; cwd_count < cwd_end; cwd_count++)
            {
              switch (cwd_count)
                {
                  case 0:
                    /* Step one (optional): Go to the initial directory,
                       exactly as reported by the server.
                    */
                    targ = con->id;
                    break;

                  case 1:
                    /* Step two: Go to the target directory.  (Absolute or
                       relative will work now.)
                    */
                    targ = target;
                    break;

                  case 2:
                    /* Step three (optional): ""CWD []"" to restore server
                       VMS-ness.
                    */
                    targ = ""[]"";
                    break;

                  default:
                    logprintf (LOG_ALWAYS, _(""Logically impossible section reached in getftp()""));
                    logprintf (LOG_ALWAYS, _(""cwd_count: %d\ncwd_start: %d\ncwd_end: %d\n""),
                                             cwd_count, cwd_start, cwd_end);
                    abort ();
                }

              if (!opt.server_response)
                logprintf (LOG_VERBOSE, ""==> CWD (%d) %s ... "", cwd_count,
                           quotearg_style (escape_quoting_style, target));

              err = ftp_cwd (csock, targ);

              /* FTPRERR, WRITEFAILED, FTPNSFOD */
              switch (err)
                {
                  case FTPRERR:
                    logputs (LOG_VERBOSE, ""\n"");
                    logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
                    fd_close (csock);
                    con->csock = -1;
                    return err;
                  case WRITEFAILED:
                    logputs (LOG_VERBOSE, ""\n"");
                    logputs (LOG_NOTQUIET,
                             _(""Write failed, closing control connection.\n""));
                    fd_close (csock);
                    con->csock = -1;
                    return err;
                  case FTPNSFOD:
                    logputs (LOG_VERBOSE, ""\n"");
                    logprintf (LOG_NOTQUIET, _(""No such directory %s.\n\n""),
                               quote (u->dir));
                    fd_close (csock);
                    con->csock = -1;
                    return err;
                  case FTPOK:
                    break;
                  default:
                    abort ();
                }

              if (!opt.server_response)
                logputs (LOG_VERBOSE, _(""done.\n""));

            } /* for */

          /* 2004-09-20 SMS. */

        } /* else */
    }
  else /* do not CWD */
    logputs (LOG_VERBOSE, _(""==> CWD not required.\n""));

  if ((cmd & DO_RETR) && passed_expected_bytes == 0)
    {
      if (opt.verbose)
        {
          if (!opt.server_response)
            logprintf (LOG_VERBOSE, ""==> SIZE %s ... "",
                       quotearg_style (escape_quoting_style, u->file));
        }

      err = ftp_size (csock, u->file, &expected_bytes);
      /* FTPRERR */
      switch (err)
        {
        case FTPRERR:
        case FTPSRVERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPOK:
          got_expected_bytes = true;
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }
        if (!opt.server_response)
          {
            logprintf (LOG_VERBOSE, ""%s\n"",
                    expected_bytes ?
                    number_to_static_string (expected_bytes) :
                    _(""done.\n""));
          }
    }

  if (cmd & DO_RETR && restval > 0 && restval == expected_bytes)
    {
      /* Server confirms that file has length restval. We should stop now.
         Some servers (f.e. NcFTPd) return error when receive REST 0 */
      logputs (LOG_VERBOSE, _(""File has already been retrieved.\n""));
      fd_close (csock);
      con->csock = -1;
      return RETRFINISHED;
    }

  do
  {
  try_again = false;
  /* If anything is to be retrieved, PORT (or PASV) must be sent.  */
  if (cmd & (DO_LIST | DO_RETR))
    {
      if (opt.ftp_pasv)
        {
          ip_address passive_addr;
          int        passive_port;
          err = ftp_do_pasv (csock, &passive_addr, &passive_port);
          /* FTPRERR, WRITEFAILED, FTPNOPASV, FTPINVPASV */
          switch (err)
            {
            case FTPRERR:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              return err;
            case WRITEFAILED:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET,
                       _(""Write failed, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              return err;
            case FTPNOPASV:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""Cannot initiate PASV transfer.\n""));
              break;
            case FTPINVPASV:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""Cannot parse PASV response.\n""));
              break;
            case FTPOK:
              break;
            default:
              abort ();
            }   /* switch (err) */
          if (err==FTPOK)
            {
              DEBUGP ((""trying to connect to %s port %d\n"",
                      print_address (&passive_addr), passive_port));
              dtsock = connect_to_ip (&passive_addr, passive_port, NULL);
              if (dtsock < 0)
                {
                  int save_errno = errno;
                  fd_close (csock);
                  con->csock = -1;
                  logprintf (LOG_VERBOSE, _(""couldn't connect to %s port %d: %s\n""),
                             print_address (&passive_addr), passive_port,
                             strerror (save_errno));
                           ? CONERROR : CONIMPOSSIBLE);
                 }
 
               if (!opt.server_response)
                 logputs (LOG_VERBOSE, _(""done.    ""));
            }
          else
            return err;
 
          /*
           * We do not want to fall back from PASSIVE mode to ACTIVE mode !
           * The reason is the PORT command exposes the client's real IP address
           * to the server. Bad for someone who relies on privacy via a ftp proxy.
           */
        }
      else
         {
           err = ftp_do_port (csock, &local_sock);
           /* FTPRERR, WRITEFAILED, bindport (FTPSYSERR), HOSTERR,
              logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case WRITEFAILED:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET,
                       _(""Write failed, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case CONSOCKERR:
              logputs (LOG_VERBOSE, ""\n"");
              logprintf (LOG_NOTQUIET, ""socket: %s\n"", strerror (errno));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case FTPSYSERR:
              logputs (LOG_VERBOSE, ""\n"");
              logprintf (LOG_NOTQUIET, _(""Bind error (%s).\n""),
                         strerror (errno));
              fd_close (dtsock);
              return err;
            case FTPPORTERR:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""Invalid PORT.\n""));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case FTPOK:
              break;
            default:
              abort ();
            } /* port switch */
          if (!opt.server_response)
            logputs (LOG_VERBOSE, _(""done.    ""));
        } /* dtsock == -1 */
    } /* cmd & (DO_LIST | DO_RETR) */

  /* Restart if needed.  */
  if (restval && (cmd & DO_RETR))
    {
      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> REST %s ... "",
                   number_to_static_string (restval));
      err = ftp_rest (csock, restval);

      /* FTPRERR, WRITEFAILED, FTPRESTFAIL */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPRESTFAIL:
          logputs (LOG_VERBOSE, _(""\nREST failed, starting from scratch.\n""));
          rest_failed = true;
          break;
        case FTPOK:
          break;
        default:
          abort ();
        }
      if (err != FTPRESTFAIL && !opt.server_response)
        logputs (LOG_VERBOSE, _(""done.    ""));
    } /* restval && cmd & DO_RETR */

  if (cmd & DO_RETR)
    {
      /* If we're in spider mode, don't really retrieve anything except
         the directory listing and verify whether the given ""file"" exists.  */
      if (opt.spider)
        {
          bool exists = false;
          struct fileinfo *f;
          uerr_t _res = ftp_get_listing (u, con, &f);
          /* Set the DO_RETR command flag again, because it gets unset when
             calling ftp_get_listing() and would otherwise cause an assertion
             failure earlier on when this function gets repeatedly called
             (e.g., when recursing).  */
          con->cmd |= DO_RETR;
          if (_res == RETROK)
            {
              while (f)
                {
                  if (!strcmp (f->name, u->file))
                    {
                      exists = true;
                      break;
                    }
                  f = f->next;
                }
              if (exists)
                {
                  logputs (LOG_VERBOSE, ""\n"");
                  logprintf (LOG_NOTQUIET, _(""File %s exists.\n""),
                             quote (u->file));
                }
              else
                {
                  logputs (LOG_VERBOSE, ""\n"");
                  logprintf (LOG_NOTQUIET, _(""No such file %s.\n""),
                             quote (u->file));
                }
            }
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return RETRFINISHED;
        }

      if (opt.verbose)
        {
          if (!opt.server_response)
            {
              if (restval)
                logputs (LOG_VERBOSE, ""\n"");
              logprintf (LOG_VERBOSE, ""==> RETR %s ... "",
                         quotearg_style (escape_quoting_style, u->file));
            }
        }

      err = ftp_retr (csock, u->file);
      /* FTPRERR, WRITEFAILED, FTPNSFOD */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPNSFOD:
          logputs (LOG_VERBOSE, ""\n"");
          logprintf (LOG_NOTQUIET, _(""No such file %s.\n\n""),
                     quote (u->file));
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPOK:
          break;
        default:
          abort ();
        }

      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.\n""));

      if (! got_expected_bytes)
        expected_bytes = *last_expected_bytes;
    } /* do retrieve */

  if (cmd & DO_LIST)
    {
      if (!opt.server_response)
        logputs (LOG_VERBOSE, ""==> LIST ... "");
      /* As Maciej W. Rozycki (macro@ds2.pg.gda.pl) says, `LIST'
         without arguments is better than `LIST .'; confirmed by
         RFC959.  */
      err = ftp_list (csock, NULL, con->st&AVOID_LIST_A, con->st&AVOID_LIST, &list_a_used);

      /* FTPRERR, WRITEFAILED */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPNSFOD:
          logputs (LOG_VERBOSE, ""\n"");
          logprintf (LOG_NOTQUIET, _(""No such file or directory %s.\n\n""),
                     quote ("".""));
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPOK:
          break;
        default:
          abort ();
        }
      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.\n""));

      if (! got_expected_bytes)
        expected_bytes = *last_expected_bytes;
    } /* cmd & DO_LIST */

  if (!(cmd & (DO_LIST | DO_RETR)) || (opt.spider && !(cmd & DO_LIST)))
    return RETRFINISHED;

  /* Some FTP servers return the total length of file after REST
     command, others just return the remaining size. */
  if (passed_expected_bytes && restval && expected_bytes
      && (expected_bytes == passed_expected_bytes - restval))
    {
      DEBUGP ((""Lying FTP server found, adjusting.\n""));
      expected_bytes = passed_expected_bytes;
    }

  /* If no transmission was required, then everything is OK.  */
  if (!pasv_mode_open)  /* we are not using pasive mode so we need
                              to accept */
     }
","getftp (struct url *u, wgint passed_expected_bytes, wgint *qtyread,
        wgint restval, ccon *con, int count, wgint *last_expected_bytes,
        FILE *warc_tmp)
{
  int csock, dtsock, local_sock, res;
  uerr_t err = RETROK;          /* appease the compiler */
  FILE *fp;
   char *respline, *tms;
   const char *user, *passwd, *tmrate;
   int cmd = con->cmd;
  bool pasv_mode_open = false;
   wgint expected_bytes = 0;
   bool got_expected_bytes = false;
   bool rest_failed = false;
  bool rest_failed = false;
  int flags;
  wgint rd_size, previous_rd_size = 0;
  char type_char;
  bool try_again;
  bool list_a_used = false;

  assert (con != NULL);
  assert (con->target != NULL);

  /* Debug-check of the sanity of the request by making sure that LIST
     and RETR are never both requested (since we can handle only one
     at a time.  */
  assert (!((cmd & DO_LIST) && (cmd & DO_RETR)));
  /* Make sure that at least *something* is requested.  */
  assert ((cmd & (DO_LIST | DO_CWD | DO_RETR | DO_LOGIN)) != 0);

  *qtyread = restval;

  user = u->user;
  passwd = u->passwd;
  search_netrc (u->host, (const char **)&user, (const char **)&passwd, 1);
  user = user ? user : (opt.ftp_user ? opt.ftp_user : opt.user);
  if (!user) user = ""anonymous"";
  passwd = passwd ? passwd : (opt.ftp_passwd ? opt.ftp_passwd : opt.passwd);
  if (!passwd) passwd = ""-wget@"";

  dtsock = -1;
  local_sock = -1;
  con->dltime = 0;

  if (!(cmd & DO_LOGIN))
    csock = con->csock;
  else                          /* cmd & DO_LOGIN */
    {
      char    *host = con->proxy ? con->proxy->host : u->host;
      int      port = con->proxy ? con->proxy->port : u->port;

      /* Login to the server: */

      /* First: Establish the control connection.  */

      csock = connect_to_host (host, port);
      if (csock == E_HOST)
          return HOSTERR;
      else if (csock < 0)
          return (retryable_socket_connect_error (errno)
                  ? CONERROR : CONIMPOSSIBLE);

      if (cmd & LEAVE_PENDING)
        con->csock = csock;
      else
        con->csock = -1;

      /* Second: Login with proper USER/PASS sequence.  */
      logprintf (LOG_VERBOSE, _(""Logging in as %s ... ""),
                 quotearg_style (escape_quoting_style, user));
      if (opt.server_response)
        logputs (LOG_ALWAYS, ""\n"");
      if (con->proxy)
        {
          /* If proxy is in use, log in as username@target-site. */
          char *logname = concat_strings (user, ""@"", u->host, (char *) 0);
          err = ftp_login (csock, logname, passwd);
          xfree (logname);
        }
      else
        err = ftp_login (csock, user, passwd);

      /* FTPRERR, FTPSRVERR, WRITEFAILED, FTPLOGREFUSED, FTPLOGINC */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPSRVERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""Error in server greeting.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPLOGREFUSED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""The server refuses login.\n""));
          fd_close (csock);
          con->csock = -1;
          return FTPLOGREFUSED;
        case FTPLOGINC:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""Login incorrect.\n""));
          fd_close (csock);
          con->csock = -1;
          return FTPLOGINC;
        case FTPOK:
          if (!opt.server_response)
            logputs (LOG_VERBOSE, _(""Logged in!\n""));
          break;
        default:
          abort ();
        }
      /* Third: Get the system type */
      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> SYST ... "");
      err = ftp_syst (csock, &con->rs, &con->rsu);
      /* FTPRERR */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPSRVERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Server error, can't determine system type.\n""));
          break;
        case FTPOK:
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }
      if (!opt.server_response && err != FTPSRVERR)
        logputs (LOG_VERBOSE, _(""done.    ""));

      /* 2013-10-17 Andrea Urbani (matfanjol)
         According to the system type I choose which
         list command will be used.
         If I don't know that system, I will try, the
         first time of each session, ""LIST -a"" and
         ""LIST"". (see __LIST_A_EXPLANATION__ below) */
      switch (con->rs)
        {
        case ST_VMS:
          /* About ST_VMS there is an old note:
             2008-01-29  SMS.  For a VMS FTP server, where ""LIST -a"" may not
             fail, but will never do what is desired here,
             skip directly to the simple ""LIST"" command
             (assumed to be the last one in the list).  */
          DEBUGP ((""\nVMS: I know it and I will use \""LIST\"" as standard list command\n""));
          con->st |= LIST_AFTER_LIST_A_CHECK_DONE;
          con->st |= AVOID_LIST_A;
          break;
        case ST_UNIX:
          if (con->rsu == UST_MULTINET)
            {
              DEBUGP ((""\nUNIX MultiNet: I know it and I will use \""LIST\"" ""
                       ""as standard list command\n""));
              con->st |= LIST_AFTER_LIST_A_CHECK_DONE;
              con->st |= AVOID_LIST_A;
            }
          else if (con->rsu == UST_TYPE_L8)
            {
              DEBUGP ((""\nUNIX TYPE L8: I know it and I will use \""LIST -a\"" ""
                       ""as standard list command\n""));
              con->st |= LIST_AFTER_LIST_A_CHECK_DONE;
              con->st |= AVOID_LIST;
            }
          break;
        default:
          break;
        }

      /* Fourth: Find the initial ftp directory */

      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> PWD ... "");
      err = ftp_pwd (csock, &con->id);
      /* FTPRERR */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPSRVERR :
          /* PWD unsupported -- assume ""/"". */
          xfree (con->id);
          con->id = xstrdup (""/"");
          break;
        case FTPOK:
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }

#if 0
      /* 2004-09-17 SMS.
         Don't help me out.  Please.
         A reasonably recent VMS FTP server will cope just fine with
         UNIX file specifications.  This code just spoils things.
         Discarding the device name, for example, is not a wise move.
         This code was disabled but left in as an example of what not
         to do.
      */

      /* VMS will report something like ""PUB$DEVICE:[INITIAL.FOLDER]"".
         Convert it to ""/INITIAL/FOLDER"" */
      if (con->rs == ST_VMS)
        {
          char *path = strchr (con->id, '[');
          char *pathend = path ? strchr (path + 1, ']') : NULL;
          if (!path || !pathend)
            DEBUGP ((""Initial VMS directory not in the form [...]!\n""));
          else
            {
              char *idir = con->id;
              DEBUGP ((""Preprocessing the initial VMS directory\n""));
              DEBUGP ((""  old = '%s'\n"", con->id));
              /* We do the conversion in-place by copying the stuff
                 between [ and ] to the beginning, and changing dots
                 to slashes at the same time.  */
              *idir++ = '/';
              for (++path; path < pathend; path++, idir++)
                *idir = *path == '.' ? '/' : *path;
              *idir = '\0';
              DEBUGP ((""  new = '%s'\n\n"", con->id));
            }
        }
#endif /* 0 */

      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.\n""));

      /* Fifth: Set the FTP type.  */
      type_char = ftp_process_type (u->params);
      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> TYPE %c ... "", type_char);
      err = ftp_type (csock, type_char);
      /* FTPRERR, WRITEFAILED, FTPUNKNOWNTYPE */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPUNKNOWNTYPE:
          logputs (LOG_VERBOSE, ""\n"");
          logprintf (LOG_NOTQUIET,
                     _(""Unknown type `%c', closing control connection.\n""),
                     type_char);
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPOK:
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }
      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.  ""));
    } /* do login */

  if (cmd & DO_CWD)
    {
      if (!*u->dir)
        logputs (LOG_VERBOSE, _(""==> CWD not needed.\n""));
      else
        {
          const char *targ = NULL;
          int cwd_count;
          int cwd_end;
          int cwd_start;

          char *target = u->dir;

          DEBUGP ((""changing working directory\n""));

          /* Change working directory.  To change to a non-absolute
             Unix directory, we need to prepend initial directory
             (con->id) to it.  Absolute directories ""just work"".

             A relative directory is one that does not begin with '/'
             and, on non-Unix OS'es, one that doesn't begin with
             ""[a-z]:"".

             This is not done for OS400, which doesn't use
             ""/""-delimited directories, nor does it support directory
             hierarchies.  ""CWD foo"" followed by ""CWD bar"" leaves us
             in ""bar"", not in ""foo/bar"", as would be customary
             elsewhere.  */

            /* 2004-09-20 SMS.
               Why is this wise even on UNIX?  It certainly fouls VMS.
               See below for a more reliable, more universal method.
            */

            /* 2008-04-22 MJC.
               I'm not crazy about it either. I'm informed it's useful
               for misconfigured servers that have some dirs in the path
               with +x but -r, but this method is not RFC-conformant. I
               understand the need to deal with crappy server
               configurations, but it's far better to use the canonical
               method first, and fall back to kludges second.
            */

          if (target[0] != '/'
              && !(con->rs != ST_UNIX
                   && c_isalpha (target[0])
                   && target[1] == ':')
              && (con->rs != ST_OS400)
              && (con->rs != ST_VMS))
            {
              int idlen = strlen (con->id);
              char *ntarget, *p;

              /* Strip trailing slash(es) from con->id. */
              while (idlen > 0 && con->id[idlen - 1] == '/')
                --idlen;
              p = ntarget = (char *)alloca (idlen + 1 + strlen (u->dir) + 1);
              memcpy (p, con->id, idlen);
              p += idlen;
              *p++ = '/';
              strcpy (p, target);

              DEBUGP ((""Prepended initial PWD to relative path:\n""));
              DEBUGP ((""   pwd: '%s'\n   old: '%s'\n  new: '%s'\n"",
                       con->id, target, ntarget));
              target = ntarget;
            }

#if 0
          /* 2004-09-17 SMS.
             Don't help me out.  Please.
             A reasonably recent VMS FTP server will cope just fine with
             UNIX file specifications.  This code just spoils things.
             Discarding the device name, for example, is not a wise
             move.
             This code was disabled but left in as an example of what
             not to do.
          */

          /* If the FTP host runs VMS, we will have to convert the absolute
             directory path in UNIX notation to absolute directory path in
             VMS notation as VMS FTP servers do not like UNIX notation of
             absolute paths.  ""VMS notation"" is [dir.subdir.subsubdir]. */

          if (con->rs == ST_VMS)
            {
              char *tmpp;
              char *ntarget = (char *)alloca (strlen (target) + 2);
              /* We use a converted initial dir, so directories in
                 TARGET will be separated with slashes, something like
                 ""/INITIAL/FOLDER/DIR/SUBDIR"".  Convert that to
                 ""[INITIAL.FOLDER.DIR.SUBDIR]"".  */
              strcpy (ntarget, target);
              assert (*ntarget == '/');
              *ntarget = '[';
              for (tmpp = ntarget + 1; *tmpp; tmpp++)
                if (*tmpp == '/')
                  *tmpp = '.';
              *tmpp++ = ']';
              *tmpp = '\0';
              DEBUGP ((""Changed file name to VMS syntax:\n""));
              DEBUGP ((""  Unix: '%s'\n  VMS: '%s'\n"", target, ntarget));
              target = ntarget;
            }
#endif /* 0 */

          /* 2004-09-20 SMS.
             A relative directory is relative to the initial directory.
             Thus, what _is_ useful on VMS (and probably elsewhere) is
             to CWD to the initial directory (ideally, whatever the
             server reports, _exactly_, NOT badly UNIX-ixed), and then
             CWD to the (new) relative directory.  This should probably
             be restructured as a function, called once or twice, but
             I'm lazy enough to take the badly indented loop short-cut
             for now.
          */

          /* Decide on one pass (absolute) or two (relative).
             The VMS restriction may be relaxed when the squirrely code
             above is reformed.
          */
          if ((con->rs == ST_VMS) && (target[0] != '/'))
            {
              cwd_start = 0;
              DEBUGP ((""Using two-step CWD for relative path.\n""));
            }
          else
            {
              /* Go straight to the target. */
              cwd_start = 1;
            }

          /* At least one VMS FTP server (TCPware V5.6-2) can switch to
             a UNIX emulation mode when given a UNIX-like directory
             specification (like ""a/b/c"").  If allowed to continue this
             way, LIST interpretation will be confused, because the
             system type (SYST response) will not be re-checked, and
             future UNIX-format directory listings (for multiple URLs or
             ""-r"") will be horribly misinterpreted.

             The cheap and nasty work-around is to do a ""CWD []"" after a
             UNIX-like directory specification is used.  (A single-level
             directory is harmless.)  This puts the TCPware server back
             into VMS mode, and does no harm on other servers.

             Unlike the rest of this block, this particular behavior
             _is_ VMS-specific, so it gets its own VMS test.
          */
          if ((con->rs == ST_VMS) && (strchr( target, '/') != NULL))
            {
              cwd_end = 3;
              DEBUGP ((""Using extra \""CWD []\"" step for VMS server.\n""));
            }
          else
            {
              cwd_end = 2;
            }

          /* 2004-09-20 SMS. */
          /* Sorry about the deviant indenting.  Laziness. */

          for (cwd_count = cwd_start; cwd_count < cwd_end; cwd_count++)
            {
              switch (cwd_count)
                {
                  case 0:
                    /* Step one (optional): Go to the initial directory,
                       exactly as reported by the server.
                    */
                    targ = con->id;
                    break;

                  case 1:
                    /* Step two: Go to the target directory.  (Absolute or
                       relative will work now.)
                    */
                    targ = target;
                    break;

                  case 2:
                    /* Step three (optional): ""CWD []"" to restore server
                       VMS-ness.
                    */
                    targ = ""[]"";
                    break;

                  default:
                    logprintf (LOG_ALWAYS, _(""Logically impossible section reached in getftp()""));
                    logprintf (LOG_ALWAYS, _(""cwd_count: %d\ncwd_start: %d\ncwd_end: %d\n""),
                                             cwd_count, cwd_start, cwd_end);
                    abort ();
                }

              if (!opt.server_response)
                logprintf (LOG_VERBOSE, ""==> CWD (%d) %s ... "", cwd_count,
                           quotearg_style (escape_quoting_style, target));

              err = ftp_cwd (csock, targ);

              /* FTPRERR, WRITEFAILED, FTPNSFOD */
              switch (err)
                {
                  case FTPRERR:
                    logputs (LOG_VERBOSE, ""\n"");
                    logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
                    fd_close (csock);
                    con->csock = -1;
                    return err;
                  case WRITEFAILED:
                    logputs (LOG_VERBOSE, ""\n"");
                    logputs (LOG_NOTQUIET,
                             _(""Write failed, closing control connection.\n""));
                    fd_close (csock);
                    con->csock = -1;
                    return err;
                  case FTPNSFOD:
                    logputs (LOG_VERBOSE, ""\n"");
                    logprintf (LOG_NOTQUIET, _(""No such directory %s.\n\n""),
                               quote (u->dir));
                    fd_close (csock);
                    con->csock = -1;
                    return err;
                  case FTPOK:
                    break;
                  default:
                    abort ();
                }

              if (!opt.server_response)
                logputs (LOG_VERBOSE, _(""done.\n""));

            } /* for */

          /* 2004-09-20 SMS. */

        } /* else */
    }
  else /* do not CWD */
    logputs (LOG_VERBOSE, _(""==> CWD not required.\n""));

  if ((cmd & DO_RETR) && passed_expected_bytes == 0)
    {
      if (opt.verbose)
        {
          if (!opt.server_response)
            logprintf (LOG_VERBOSE, ""==> SIZE %s ... "",
                       quotearg_style (escape_quoting_style, u->file));
        }

      err = ftp_size (csock, u->file, &expected_bytes);
      /* FTPRERR */
      switch (err)
        {
        case FTPRERR:
        case FTPSRVERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPOK:
          got_expected_bytes = true;
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }
        if (!opt.server_response)
          {
            logprintf (LOG_VERBOSE, ""%s\n"",
                    expected_bytes ?
                    number_to_static_string (expected_bytes) :
                    _(""done.\n""));
          }
    }

  if (cmd & DO_RETR && restval > 0 && restval == expected_bytes)
    {
      /* Server confirms that file has length restval. We should stop now.
         Some servers (f.e. NcFTPd) return error when receive REST 0 */
      logputs (LOG_VERBOSE, _(""File has already been retrieved.\n""));
      fd_close (csock);
      con->csock = -1;
      return RETRFINISHED;
    }

  do
  {
  try_again = false;
  /* If anything is to be retrieved, PORT (or PASV) must be sent.  */
  if (cmd & (DO_LIST | DO_RETR))
    {
      if (opt.ftp_pasv)
        {
          ip_address passive_addr;
          int        passive_port;
          err = ftp_do_pasv (csock, &passive_addr, &passive_port);
          /* FTPRERR, WRITEFAILED, FTPNOPASV, FTPINVPASV */
          switch (err)
            {
            case FTPRERR:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              return err;
            case WRITEFAILED:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET,
                       _(""Write failed, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              return err;
            case FTPNOPASV:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""Cannot initiate PASV transfer.\n""));
              break;
            case FTPINVPASV:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""Cannot parse PASV response.\n""));
              break;
            case FTPOK:
              break;
            default:
              abort ();
            }   /* switch (err) */
          if (err==FTPOK)
            {
              DEBUGP ((""trying to connect to %s port %d\n"",
                      print_address (&passive_addr), passive_port));
              dtsock = connect_to_ip (&passive_addr, passive_port, NULL);
              if (dtsock < 0)
                {
                  int save_errno = errno;
                  fd_close (csock);
                  con->csock = -1;
                  logprintf (LOG_VERBOSE, _(""couldn't connect to %s port %d: %s\n""),
                             print_address (&passive_addr), passive_port,
                             strerror (save_errno));
                           ? CONERROR : CONIMPOSSIBLE);
                 }
 
              pasv_mode_open = true;  /* Flag to avoid accept port */
               if (!opt.server_response)
                 logputs (LOG_VERBOSE, _(""done.    ""));
            } /* err==FTP_OK */
        }
 
      if (!pasv_mode_open)   /* Try to use a port command if PASV failed */
         {
           err = ftp_do_port (csock, &local_sock);
           /* FTPRERR, WRITEFAILED, bindport (FTPSYSERR), HOSTERR,
              logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case WRITEFAILED:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET,
                       _(""Write failed, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case CONSOCKERR:
              logputs (LOG_VERBOSE, ""\n"");
              logprintf (LOG_NOTQUIET, ""socket: %s\n"", strerror (errno));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case FTPSYSERR:
              logputs (LOG_VERBOSE, ""\n"");
              logprintf (LOG_NOTQUIET, _(""Bind error (%s).\n""),
                         strerror (errno));
              fd_close (dtsock);
              return err;
            case FTPPORTERR:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""Invalid PORT.\n""));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case FTPOK:
              break;
            default:
              abort ();
            } /* port switch */
          if (!opt.server_response)
            logputs (LOG_VERBOSE, _(""done.    ""));
        } /* dtsock == -1 */
    } /* cmd & (DO_LIST | DO_RETR) */

  /* Restart if needed.  */
  if (restval && (cmd & DO_RETR))
    {
      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> REST %s ... "",
                   number_to_static_string (restval));
      err = ftp_rest (csock, restval);

      /* FTPRERR, WRITEFAILED, FTPRESTFAIL */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPRESTFAIL:
          logputs (LOG_VERBOSE, _(""\nREST failed, starting from scratch.\n""));
          rest_failed = true;
          break;
        case FTPOK:
          break;
        default:
          abort ();
        }
      if (err != FTPRESTFAIL && !opt.server_response)
        logputs (LOG_VERBOSE, _(""done.    ""));
    } /* restval && cmd & DO_RETR */

  if (cmd & DO_RETR)
    {
      /* If we're in spider mode, don't really retrieve anything except
         the directory listing and verify whether the given ""file"" exists.  */
      if (opt.spider)
        {
          bool exists = false;
          struct fileinfo *f;
          uerr_t _res = ftp_get_listing (u, con, &f);
          /* Set the DO_RETR command flag again, because it gets unset when
             calling ftp_get_listing() and would otherwise cause an assertion
             failure earlier on when this function gets repeatedly called
             (e.g., when recursing).  */
          con->cmd |= DO_RETR;
          if (_res == RETROK)
            {
              while (f)
                {
                  if (!strcmp (f->name, u->file))
                    {
                      exists = true;
                      break;
                    }
                  f = f->next;
                }
              if (exists)
                {
                  logputs (LOG_VERBOSE, ""\n"");
                  logprintf (LOG_NOTQUIET, _(""File %s exists.\n""),
                             quote (u->file));
                }
              else
                {
                  logputs (LOG_VERBOSE, ""\n"");
                  logprintf (LOG_NOTQUIET, _(""No such file %s.\n""),
                             quote (u->file));
                }
            }
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return RETRFINISHED;
        }

      if (opt.verbose)
        {
          if (!opt.server_response)
            {
              if (restval)
                logputs (LOG_VERBOSE, ""\n"");
              logprintf (LOG_VERBOSE, ""==> RETR %s ... "",
                         quotearg_style (escape_quoting_style, u->file));
            }
        }

      err = ftp_retr (csock, u->file);
      /* FTPRERR, WRITEFAILED, FTPNSFOD */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPNSFOD:
          logputs (LOG_VERBOSE, ""\n"");
          logprintf (LOG_NOTQUIET, _(""No such file %s.\n\n""),
                     quote (u->file));
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPOK:
          break;
        default:
          abort ();
        }

      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.\n""));

      if (! got_expected_bytes)
        expected_bytes = *last_expected_bytes;
    } /* do retrieve */

  if (cmd & DO_LIST)
    {
      if (!opt.server_response)
        logputs (LOG_VERBOSE, ""==> LIST ... "");
      /* As Maciej W. Rozycki (macro@ds2.pg.gda.pl) says, `LIST'
         without arguments is better than `LIST .'; confirmed by
         RFC959.  */
      err = ftp_list (csock, NULL, con->st&AVOID_LIST_A, con->st&AVOID_LIST, &list_a_used);

      /* FTPRERR, WRITEFAILED */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPNSFOD:
          logputs (LOG_VERBOSE, ""\n"");
          logprintf (LOG_NOTQUIET, _(""No such file or directory %s.\n\n""),
                     quote ("".""));
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPOK:
          break;
        default:
          abort ();
        }
      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.\n""));

      if (! got_expected_bytes)
        expected_bytes = *last_expected_bytes;
    } /* cmd & DO_LIST */

  if (!(cmd & (DO_LIST | DO_RETR)) || (opt.spider && !(cmd & DO_LIST)))
    return RETRFINISHED;

  /* Some FTP servers return the total length of file after REST
     command, others just return the remaining size. */
  if (passed_expected_bytes && restval && expected_bytes
      && (expected_bytes == passed_expected_bytes - restval))
    {
      DEBUGP ((""Lying FTP server found, adjusting.\n""));
      expected_bytes = passed_expected_bytes;
    }

  /* If no transmission was required, then everything is OK.  */
  if (!pasv_mode_open)  /* we are not using pasive mode so we need
                              to accept */
     }
",C,"            }
          else
            return err;
          /*
           * We do not want to fall back from PASSIVE mode to ACTIVE mode !
           * The reason is the PORT command exposes the client's real IP address
           * to the server. Bad for someone who relies on privacy via a ftp proxy.
           */
        }
      else
","  bool pasv_mode_open = false;
              pasv_mode_open = true;  /* Flag to avoid accept port */
            } /* err==FTP_OK */
        }
      if (!pasv_mode_open)   /* Try to use a port command if PASV failed */
",7578e47d4957b019d90bbe77bcab98113a8923bc,"@@ -252,7 +252,6 @@ getftp (struct url *u, wgint passed_expected_bytes, wgint *qtyread,
   char *respline, *tms;
   const char *user, *passwd, *tmrate;
   int cmd = con->cmd;
-  bool pasv_mode_open = false;
   wgint expected_bytes = 0;
   bool got_expected_bytes = false;
   bool rest_failed = false;
@@ -883,13 +882,19 @@ Error in server response, closing control connection.\n""));
                           ? CONERROR : CONIMPOSSIBLE);
                 }
 
-              pasv_mode_open = true;  /* Flag to avoid accept port */
               if (!opt.server_response)
                 logputs (LOG_VERBOSE, _(""done.    ""));
-            } /* err==FTP_OK */
-        }
+            }
+          else
+            return err;
 
-      if (!pasv_mode_open)   /* Try to use a port command if PASV failed */
+          /*
+           * We do not want to fall back from PASSIVE mode to ACTIVE mode !
+           * The reason is the PORT command exposes the client's real IP address
+           * to the server. Bad for someone who relies on privacy via a ftp proxy.
+           */
+        }
+      else
         {
           err = ftp_do_port (csock, &local_sock);
           /* FTPRERR, WRITEFAILED, bindport (FTPSYSERR), HOSTERR,
@@ -1148,8 +1153,8 @@ Error in server response, closing control connection.\n""));
     }
 
   /* If no transmission was required, then everything is OK.  */
-  if (!pasv_mode_open)  /* we are not using pasive mode so we need
-                              to accept */
+  if (!opt.ftp_pasv)  /* we are not using passive mode so we need
+                         to accept */
     {
       /* Wait for the server to connect to the address we're waiting
          at.  */",savannah,https://git.savannah.gnu.org/cgit/wget.git/tree/src/ftp.c?id=075d7556964f5a871a73c22ac4b69f5361295099,https://git.savannah.gnu.org/cgit/wget.git/tree/src/ftp.c?id=7578e47d4957b019d90bbe77bcab98113a8923bc,1,"getftp (struct url *u, wgint passed_expected_bytes, wgint *qtyread,
        wgint restval, ccon *con, int count, wgint *last_expected_bytes,
        FILE *warc_tmp)
{
  int csock, dtsock, local_sock, res;
  uerr_t err = RETROK;          /* appease the compiler */
  FILE *fp;
   char *respline, *tms;
   const char *user, *passwd, *tmrate;
   int cmd = con->cmd;
//flaw_line_below:
  bool pasv_mode_open = false;
   wgint expected_bytes = 0;
   bool got_expected_bytes = false;
   bool rest_failed = false;
  bool rest_failed = false;
  int flags;
  wgint rd_size, previous_rd_size = 0;
  char type_char;
  bool try_again;
  bool list_a_used = false;

  assert (con != NULL);
  assert (con->target != NULL);

  /* Debug-check of the sanity of the request by making sure that LIST
     and RETR are never both requested (since we can handle only one
     at a time.  */
  assert (!((cmd & DO_LIST) && (cmd & DO_RETR)));
  /* Make sure that at least *something* is requested.  */
  assert ((cmd & (DO_LIST | DO_CWD | DO_RETR | DO_LOGIN)) != 0);

  *qtyread = restval;

  user = u->user;
  passwd = u->passwd;
  search_netrc (u->host, (const char **)&user, (const char **)&passwd, 1);
  user = user ? user : (opt.ftp_user ? opt.ftp_user : opt.user);
  if (!user) user = ""anonymous"";
  passwd = passwd ? passwd : (opt.ftp_passwd ? opt.ftp_passwd : opt.passwd);
  if (!passwd) passwd = ""-wget@"";

  dtsock = -1;
  local_sock = -1;
  con->dltime = 0;

  if (!(cmd & DO_LOGIN))
    csock = con->csock;
  else                          /* cmd & DO_LOGIN */
    {
      char    *host = con->proxy ? con->proxy->host : u->host;
      int      port = con->proxy ? con->proxy->port : u->port;

      /* Login to the server: */

      /* First: Establish the control connection.  */

      csock = connect_to_host (host, port);
      if (csock == E_HOST)
          return HOSTERR;
      else if (csock < 0)
          return (retryable_socket_connect_error (errno)
                  ? CONERROR : CONIMPOSSIBLE);

      if (cmd & LEAVE_PENDING)
        con->csock = csock;
      else
        con->csock = -1;

      /* Second: Login with proper USER/PASS sequence.  */
      logprintf (LOG_VERBOSE, _(""Logging in as %s ... ""),
                 quotearg_style (escape_quoting_style, user));
      if (opt.server_response)
        logputs (LOG_ALWAYS, ""\n"");
      if (con->proxy)
        {
          /* If proxy is in use, log in as username@target-site. */
          char *logname = concat_strings (user, ""@"", u->host, (char *) 0);
          err = ftp_login (csock, logname, passwd);
          xfree (logname);
        }
      else
        err = ftp_login (csock, user, passwd);

      /* FTPRERR, FTPSRVERR, WRITEFAILED, FTPLOGREFUSED, FTPLOGINC */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPSRVERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""Error in server greeting.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPLOGREFUSED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""The server refuses login.\n""));
          fd_close (csock);
          con->csock = -1;
          return FTPLOGREFUSED;
        case FTPLOGINC:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""Login incorrect.\n""));
          fd_close (csock);
          con->csock = -1;
          return FTPLOGINC;
        case FTPOK:
          if (!opt.server_response)
            logputs (LOG_VERBOSE, _(""Logged in!\n""));
          break;
        default:
          abort ();
        }
      /* Third: Get the system type */
      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> SYST ... "");
      err = ftp_syst (csock, &con->rs, &con->rsu);
      /* FTPRERR */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPSRVERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Server error, can't determine system type.\n""));
          break;
        case FTPOK:
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }
      if (!opt.server_response && err != FTPSRVERR)
        logputs (LOG_VERBOSE, _(""done.    ""));

      /* 2013-10-17 Andrea Urbani (matfanjol)
         According to the system type I choose which
         list command will be used.
         If I don't know that system, I will try, the
         first time of each session, ""LIST -a"" and
         ""LIST"". (see __LIST_A_EXPLANATION__ below) */
      switch (con->rs)
        {
        case ST_VMS:
          /* About ST_VMS there is an old note:
             2008-01-29  SMS.  For a VMS FTP server, where ""LIST -a"" may not
             fail, but will never do what is desired here,
             skip directly to the simple ""LIST"" command
             (assumed to be the last one in the list).  */
          DEBUGP ((""\nVMS: I know it and I will use \""LIST\"" as standard list command\n""));
          con->st |= LIST_AFTER_LIST_A_CHECK_DONE;
          con->st |= AVOID_LIST_A;
          break;
        case ST_UNIX:
          if (con->rsu == UST_MULTINET)
            {
              DEBUGP ((""\nUNIX MultiNet: I know it and I will use \""LIST\"" ""
                       ""as standard list command\n""));
              con->st |= LIST_AFTER_LIST_A_CHECK_DONE;
              con->st |= AVOID_LIST_A;
            }
          else if (con->rsu == UST_TYPE_L8)
            {
              DEBUGP ((""\nUNIX TYPE L8: I know it and I will use \""LIST -a\"" ""
                       ""as standard list command\n""));
              con->st |= LIST_AFTER_LIST_A_CHECK_DONE;
              con->st |= AVOID_LIST;
            }
          break;
        default:
          break;
        }

      /* Fourth: Find the initial ftp directory */

      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> PWD ... "");
      err = ftp_pwd (csock, &con->id);
      /* FTPRERR */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPSRVERR :
          /* PWD unsupported -- assume ""/"". */
          xfree (con->id);
          con->id = xstrdup (""/"");
          break;
        case FTPOK:
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }

#if 0
      /* 2004-09-17 SMS.
         Don't help me out.  Please.
         A reasonably recent VMS FTP server will cope just fine with
         UNIX file specifications.  This code just spoils things.
         Discarding the device name, for example, is not a wise move.
         This code was disabled but left in as an example of what not
         to do.
      */

      /* VMS will report something like ""PUB$DEVICE:[INITIAL.FOLDER]"".
         Convert it to ""/INITIAL/FOLDER"" */
      if (con->rs == ST_VMS)
        {
          char *path = strchr (con->id, '[');
          char *pathend = path ? strchr (path + 1, ']') : NULL;
          if (!path || !pathend)
            DEBUGP ((""Initial VMS directory not in the form [...]!\n""));
          else
            {
              char *idir = con->id;
              DEBUGP ((""Preprocessing the initial VMS directory\n""));
              DEBUGP ((""  old = '%s'\n"", con->id));
              /* We do the conversion in-place by copying the stuff
                 between [ and ] to the beginning, and changing dots
                 to slashes at the same time.  */
              *idir++ = '/';
              for (++path; path < pathend; path++, idir++)
                *idir = *path == '.' ? '/' : *path;
              *idir = '\0';
              DEBUGP ((""  new = '%s'\n\n"", con->id));
            }
        }
#endif /* 0 */

      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.\n""));

      /* Fifth: Set the FTP type.  */
      type_char = ftp_process_type (u->params);
      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> TYPE %c ... "", type_char);
      err = ftp_type (csock, type_char);
      /* FTPRERR, WRITEFAILED, FTPUNKNOWNTYPE */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPUNKNOWNTYPE:
          logputs (LOG_VERBOSE, ""\n"");
          logprintf (LOG_NOTQUIET,
                     _(""Unknown type `%c', closing control connection.\n""),
                     type_char);
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPOK:
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }
      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.  ""));
    } /* do login */

  if (cmd & DO_CWD)
    {
      if (!*u->dir)
        logputs (LOG_VERBOSE, _(""==> CWD not needed.\n""));
      else
        {
          const char *targ = NULL;
          int cwd_count;
          int cwd_end;
          int cwd_start;

          char *target = u->dir;

          DEBUGP ((""changing working directory\n""));

          /* Change working directory.  To change to a non-absolute
             Unix directory, we need to prepend initial directory
             (con->id) to it.  Absolute directories ""just work"".

             A relative directory is one that does not begin with '/'
             and, on non-Unix OS'es, one that doesn't begin with
             ""[a-z]:"".

             This is not done for OS400, which doesn't use
             ""/""-delimited directories, nor does it support directory
             hierarchies.  ""CWD foo"" followed by ""CWD bar"" leaves us
             in ""bar"", not in ""foo/bar"", as would be customary
             elsewhere.  */

            /* 2004-09-20 SMS.
               Why is this wise even on UNIX?  It certainly fouls VMS.
               See below for a more reliable, more universal method.
            */

            /* 2008-04-22 MJC.
               I'm not crazy about it either. I'm informed it's useful
               for misconfigured servers that have some dirs in the path
               with +x but -r, but this method is not RFC-conformant. I
               understand the need to deal with crappy server
               configurations, but it's far better to use the canonical
               method first, and fall back to kludges second.
            */

          if (target[0] != '/'
              && !(con->rs != ST_UNIX
                   && c_isalpha (target[0])
                   && target[1] == ':')
              && (con->rs != ST_OS400)
              && (con->rs != ST_VMS))
            {
              int idlen = strlen (con->id);
              char *ntarget, *p;

              /* Strip trailing slash(es) from con->id. */
              while (idlen > 0 && con->id[idlen - 1] == '/')
                --idlen;
              p = ntarget = (char *)alloca (idlen + 1 + strlen (u->dir) + 1);
              memcpy (p, con->id, idlen);
              p += idlen;
              *p++ = '/';
              strcpy (p, target);

              DEBUGP ((""Prepended initial PWD to relative path:\n""));
              DEBUGP ((""   pwd: '%s'\n   old: '%s'\n  new: '%s'\n"",
                       con->id, target, ntarget));
              target = ntarget;
            }

#if 0
          /* 2004-09-17 SMS.
             Don't help me out.  Please.
             A reasonably recent VMS FTP server will cope just fine with
             UNIX file specifications.  This code just spoils things.
             Discarding the device name, for example, is not a wise
             move.
             This code was disabled but left in as an example of what
             not to do.
          */

          /* If the FTP host runs VMS, we will have to convert the absolute
             directory path in UNIX notation to absolute directory path in
             VMS notation as VMS FTP servers do not like UNIX notation of
             absolute paths.  ""VMS notation"" is [dir.subdir.subsubdir]. */

          if (con->rs == ST_VMS)
            {
              char *tmpp;
              char *ntarget = (char *)alloca (strlen (target) + 2);
              /* We use a converted initial dir, so directories in
                 TARGET will be separated with slashes, something like
                 ""/INITIAL/FOLDER/DIR/SUBDIR"".  Convert that to
                 ""[INITIAL.FOLDER.DIR.SUBDIR]"".  */
              strcpy (ntarget, target);
              assert (*ntarget == '/');
              *ntarget = '[';
              for (tmpp = ntarget + 1; *tmpp; tmpp++)
                if (*tmpp == '/')
                  *tmpp = '.';
              *tmpp++ = ']';
              *tmpp = '\0';
              DEBUGP ((""Changed file name to VMS syntax:\n""));
              DEBUGP ((""  Unix: '%s'\n  VMS: '%s'\n"", target, ntarget));
              target = ntarget;
            }
#endif /* 0 */

          /* 2004-09-20 SMS.
             A relative directory is relative to the initial directory.
             Thus, what _is_ useful on VMS (and probably elsewhere) is
             to CWD to the initial directory (ideally, whatever the
             server reports, _exactly_, NOT badly UNIX-ixed), and then
             CWD to the (new) relative directory.  This should probably
             be restructured as a function, called once or twice, but
             I'm lazy enough to take the badly indented loop short-cut
             for now.
          */

          /* Decide on one pass (absolute) or two (relative).
             The VMS restriction may be relaxed when the squirrely code
             above is reformed.
          */
          if ((con->rs == ST_VMS) && (target[0] != '/'))
            {
              cwd_start = 0;
              DEBUGP ((""Using two-step CWD for relative path.\n""));
            }
          else
            {
              /* Go straight to the target. */
              cwd_start = 1;
            }

          /* At least one VMS FTP server (TCPware V5.6-2) can switch to
             a UNIX emulation mode when given a UNIX-like directory
             specification (like ""a/b/c"").  If allowed to continue this
             way, LIST interpretation will be confused, because the
             system type (SYST response) will not be re-checked, and
             future UNIX-format directory listings (for multiple URLs or
             ""-r"") will be horribly misinterpreted.

             The cheap and nasty work-around is to do a ""CWD []"" after a
             UNIX-like directory specification is used.  (A single-level
             directory is harmless.)  This puts the TCPware server back
             into VMS mode, and does no harm on other servers.

             Unlike the rest of this block, this particular behavior
             _is_ VMS-specific, so it gets its own VMS test.
          */
          if ((con->rs == ST_VMS) && (strchr( target, '/') != NULL))
            {
              cwd_end = 3;
              DEBUGP ((""Using extra \""CWD []\"" step for VMS server.\n""));
            }
          else
            {
              cwd_end = 2;
            }

          /* 2004-09-20 SMS. */
          /* Sorry about the deviant indenting.  Laziness. */

          for (cwd_count = cwd_start; cwd_count < cwd_end; cwd_count++)
            {
              switch (cwd_count)
                {
                  case 0:
                    /* Step one (optional): Go to the initial directory,
                       exactly as reported by the server.
                    */
                    targ = con->id;
                    break;

                  case 1:
                    /* Step two: Go to the target directory.  (Absolute or
                       relative will work now.)
                    */
                    targ = target;
                    break;

                  case 2:
                    /* Step three (optional): ""CWD []"" to restore server
                       VMS-ness.
                    */
                    targ = ""[]"";
                    break;

                  default:
                    logprintf (LOG_ALWAYS, _(""Logically impossible section reached in getftp()""));
                    logprintf (LOG_ALWAYS, _(""cwd_count: %d\ncwd_start: %d\ncwd_end: %d\n""),
                                             cwd_count, cwd_start, cwd_end);
                    abort ();
                }

              if (!opt.server_response)
                logprintf (LOG_VERBOSE, ""==> CWD (%d) %s ... "", cwd_count,
                           quotearg_style (escape_quoting_style, target));

              err = ftp_cwd (csock, targ);

              /* FTPRERR, WRITEFAILED, FTPNSFOD */
              switch (err)
                {
                  case FTPRERR:
                    logputs (LOG_VERBOSE, ""\n"");
                    logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
                    fd_close (csock);
                    con->csock = -1;
                    return err;
                  case WRITEFAILED:
                    logputs (LOG_VERBOSE, ""\n"");
                    logputs (LOG_NOTQUIET,
                             _(""Write failed, closing control connection.\n""));
                    fd_close (csock);
                    con->csock = -1;
                    return err;
                  case FTPNSFOD:
                    logputs (LOG_VERBOSE, ""\n"");
                    logprintf (LOG_NOTQUIET, _(""No such directory %s.\n\n""),
                               quote (u->dir));
                    fd_close (csock);
                    con->csock = -1;
                    return err;
                  case FTPOK:
                    break;
                  default:
                    abort ();
                }

              if (!opt.server_response)
                logputs (LOG_VERBOSE, _(""done.\n""));

            } /* for */

          /* 2004-09-20 SMS. */

        } /* else */
    }
  else /* do not CWD */
    logputs (LOG_VERBOSE, _(""==> CWD not required.\n""));

  if ((cmd & DO_RETR) && passed_expected_bytes == 0)
    {
      if (opt.verbose)
        {
          if (!opt.server_response)
            logprintf (LOG_VERBOSE, ""==> SIZE %s ... "",
                       quotearg_style (escape_quoting_style, u->file));
        }

      err = ftp_size (csock, u->file, &expected_bytes);
      /* FTPRERR */
      switch (err)
        {
        case FTPRERR:
        case FTPSRVERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPOK:
          got_expected_bytes = true;
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }
        if (!opt.server_response)
          {
            logprintf (LOG_VERBOSE, ""%s\n"",
                    expected_bytes ?
                    number_to_static_string (expected_bytes) :
                    _(""done.\n""));
          }
    }

  if (cmd & DO_RETR && restval > 0 && restval == expected_bytes)
    {
      /* Server confirms that file has length restval. We should stop now.
         Some servers (f.e. NcFTPd) return error when receive REST 0 */
      logputs (LOG_VERBOSE, _(""File has already been retrieved.\n""));
      fd_close (csock);
      con->csock = -1;
      return RETRFINISHED;
    }

  do
  {
  try_again = false;
  /* If anything is to be retrieved, PORT (or PASV) must be sent.  */
  if (cmd & (DO_LIST | DO_RETR))
    {
      if (opt.ftp_pasv)
        {
          ip_address passive_addr;
          int        passive_port;
          err = ftp_do_pasv (csock, &passive_addr, &passive_port);
          /* FTPRERR, WRITEFAILED, FTPNOPASV, FTPINVPASV */
          switch (err)
            {
            case FTPRERR:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              return err;
            case WRITEFAILED:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET,
                       _(""Write failed, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              return err;
            case FTPNOPASV:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""Cannot initiate PASV transfer.\n""));
              break;
            case FTPINVPASV:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""Cannot parse PASV response.\n""));
              break;
            case FTPOK:
              break;
            default:
              abort ();
            }   /* switch (err) */
          if (err==FTPOK)
            {
              DEBUGP ((""trying to connect to %s port %d\n"",
                      print_address (&passive_addr), passive_port));
              dtsock = connect_to_ip (&passive_addr, passive_port, NULL);
              if (dtsock < 0)
                {
                  int save_errno = errno;
                  fd_close (csock);
                  con->csock = -1;
                  logprintf (LOG_VERBOSE, _(""couldn't connect to %s port %d: %s\n""),
                             print_address (&passive_addr), passive_port,
                             strerror (save_errno));
                           ? CONERROR : CONIMPOSSIBLE);
                 }
 
//flaw_line_below:
              pasv_mode_open = true;  /* Flag to avoid accept port */
               if (!opt.server_response)
                 logputs (LOG_VERBOSE, _(""done.    ""));
//flaw_line_below:
            } /* err==FTP_OK */
//flaw_line_below:
        }
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//          else
//fix_flaw_line_below:
//            return err;
 
//flaw_line_below:
      if (!pasv_mode_open)   /* Try to use a port command if PASV failed */
//fix_flaw_line_below:
//          /*
//fix_flaw_line_below:
//           * We do not want to fall back from PASSIVE mode to ACTIVE mode !
//fix_flaw_line_below:
//           * The reason is the PORT command exposes the client's real IP address
//fix_flaw_line_below:
//           * to the server. Bad for someone who relies on privacy via a ftp proxy.
//fix_flaw_line_below:
//           */
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//      else
         {
           err = ftp_do_port (csock, &local_sock);
           /* FTPRERR, WRITEFAILED, bindport (FTPSYSERR), HOSTERR,
              logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case WRITEFAILED:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET,
                       _(""Write failed, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case CONSOCKERR:
              logputs (LOG_VERBOSE, ""\n"");
              logprintf (LOG_NOTQUIET, ""socket: %s\n"", strerror (errno));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case FTPSYSERR:
              logputs (LOG_VERBOSE, ""\n"");
              logprintf (LOG_NOTQUIET, _(""Bind error (%s).\n""),
                         strerror (errno));
              fd_close (dtsock);
              return err;
            case FTPPORTERR:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""Invalid PORT.\n""));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case FTPOK:
              break;
            default:
              abort ();
            } /* port switch */
          if (!opt.server_response)
            logputs (LOG_VERBOSE, _(""done.    ""));
        } /* dtsock == -1 */
    } /* cmd & (DO_LIST | DO_RETR) */

  /* Restart if needed.  */
  if (restval && (cmd & DO_RETR))
    {
      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> REST %s ... "",
                   number_to_static_string (restval));
      err = ftp_rest (csock, restval);

      /* FTPRERR, WRITEFAILED, FTPRESTFAIL */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPRESTFAIL:
          logputs (LOG_VERBOSE, _(""\nREST failed, starting from scratch.\n""));
          rest_failed = true;
          break;
        case FTPOK:
          break;
        default:
          abort ();
        }
      if (err != FTPRESTFAIL && !opt.server_response)
        logputs (LOG_VERBOSE, _(""done.    ""));
    } /* restval && cmd & DO_RETR */

  if (cmd & DO_RETR)
    {
      /* If we're in spider mode, don't really retrieve anything except
         the directory listing and verify whether the given ""file"" exists.  */
      if (opt.spider)
        {
          bool exists = false;
          struct fileinfo *f;
          uerr_t _res = ftp_get_listing (u, con, &f);
          /* Set the DO_RETR command flag again, because it gets unset when
             calling ftp_get_listing() and would otherwise cause an assertion
             failure earlier on when this function gets repeatedly called
             (e.g., when recursing).  */
          con->cmd |= DO_RETR;
          if (_res == RETROK)
            {
              while (f)
                {
                  if (!strcmp (f->name, u->file))
                    {
                      exists = true;
                      break;
                    }
                  f = f->next;
                }
              if (exists)
                {
                  logputs (LOG_VERBOSE, ""\n"");
                  logprintf (LOG_NOTQUIET, _(""File %s exists.\n""),
                             quote (u->file));
                }
              else
                {
                  logputs (LOG_VERBOSE, ""\n"");
                  logprintf (LOG_NOTQUIET, _(""No such file %s.\n""),
                             quote (u->file));
                }
            }
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return RETRFINISHED;
        }

      if (opt.verbose)
        {
          if (!opt.server_response)
            {
              if (restval)
                logputs (LOG_VERBOSE, ""\n"");
              logprintf (LOG_VERBOSE, ""==> RETR %s ... "",
                         quotearg_style (escape_quoting_style, u->file));
            }
        }

      err = ftp_retr (csock, u->file);
      /* FTPRERR, WRITEFAILED, FTPNSFOD */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPNSFOD:
          logputs (LOG_VERBOSE, ""\n"");
          logprintf (LOG_NOTQUIET, _(""No such file %s.\n\n""),
                     quote (u->file));
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPOK:
          break;
        default:
          abort ();
        }

      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.\n""));

      if (! got_expected_bytes)
        expected_bytes = *last_expected_bytes;
    } /* do retrieve */

  if (cmd & DO_LIST)
    {
      if (!opt.server_response)
        logputs (LOG_VERBOSE, ""==> LIST ... "");
      /* As Maciej W. Rozycki (macro@ds2.pg.gda.pl) says, `LIST'
         without arguments is better than `LIST .'; confirmed by
         RFC959.  */
      err = ftp_list (csock, NULL, con->st&AVOID_LIST_A, con->st&AVOID_LIST, &list_a_used);

      /* FTPRERR, WRITEFAILED */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPNSFOD:
          logputs (LOG_VERBOSE, ""\n"");
          logprintf (LOG_NOTQUIET, _(""No such file or directory %s.\n\n""),
                     quote ("".""));
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPOK:
          break;
        default:
          abort ();
        }
      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.\n""));

      if (! got_expected_bytes)
        expected_bytes = *last_expected_bytes;
    } /* cmd & DO_LIST */

  if (!(cmd & (DO_LIST | DO_RETR)) || (opt.spider && !(cmd & DO_LIST)))
    return RETRFINISHED;

  /* Some FTP servers return the total length of file after REST
     command, others just return the remaining size. */
  if (passed_expected_bytes && restval && expected_bytes
      && (expected_bytes == passed_expected_bytes - restval))
    {
      DEBUGP ((""Lying FTP server found, adjusting.\n""));
      expected_bytes = passed_expected_bytes;
    }

  /* If no transmission was required, then everything is OK.  */
  if (!pasv_mode_open)  /* we are not using pasive mode so we need
                              to accept */
     }
",177746,"getftp (struct url *u, wgint passed_expected_bytes, wgint *qtyread,
        wgint restval, ccon *con, int count, wgint *last_expected_bytes,
        FILE *warc_tmp)
{
  int csock, dtsock, local_sock, res;
  uerr_t err = RETROK;          /* appease the compiler */
  FILE *fp;
   char *respline, *tms;
   const char *user, *passwd, *tmrate;
   int cmd = con->cmd;
  bool pasv_mode_open = false;
   wgint expected_bytes = 0;
   bool got_expected_bytes = false;
   bool rest_failed = false;
  bool rest_failed = false;
  int flags;
  wgint rd_size, previous_rd_size = 0;
  char type_char;
  bool try_again;
  bool list_a_used = false;

  assert (con != NULL);
  assert (con->target != NULL);

  /* Debug-check of the sanity of the request by making sure that LIST
     and RETR are never both requested (since we can handle only one
     at a time.  */
  assert (!((cmd & DO_LIST) && (cmd & DO_RETR)));
  /* Make sure that at least *something* is requested.  */
  assert ((cmd & (DO_LIST | DO_CWD | DO_RETR | DO_LOGIN)) != 0);

  *qtyread = restval;

  user = u->user;
  passwd = u->passwd;
  search_netrc (u->host, (const char **)&user, (const char **)&passwd, 1);
  user = user ? user : (opt.ftp_user ? opt.ftp_user : opt.user);
  if (!user) user = ""anonymous"";
  passwd = passwd ? passwd : (opt.ftp_passwd ? opt.ftp_passwd : opt.passwd);
  if (!passwd) passwd = ""-wget@"";

  dtsock = -1;
  local_sock = -1;
  con->dltime = 0;

  if (!(cmd & DO_LOGIN))
    csock = con->csock;
  else                          /* cmd & DO_LOGIN */
    {
      char    *host = con->proxy ? con->proxy->host : u->host;
      int      port = con->proxy ? con->proxy->port : u->port;

      /* Login to the server: */

      /* First: Establish the control connection.  */

      csock = connect_to_host (host, port);
      if (csock == E_HOST)
          return HOSTERR;
      else if (csock < 0)
          return (retryable_socket_connect_error (errno)
                  ? CONERROR : CONIMPOSSIBLE);

      if (cmd & LEAVE_PENDING)
        con->csock = csock;
      else
        con->csock = -1;

      /* Second: Login with proper USER/PASS sequence.  */
      logprintf (LOG_VERBOSE, _(""Logging in as %s ... ""),
                 quotearg_style (escape_quoting_style, user));
      if (opt.server_response)
        logputs (LOG_ALWAYS, ""\n"");
      if (con->proxy)
        {
          /* If proxy is in use, log in as username@target-site. */
          char *logname = concat_strings (user, ""@"", u->host, (char *) 0);
          err = ftp_login (csock, logname, passwd);
          xfree (logname);
        }
      else
        err = ftp_login (csock, user, passwd);

      /* FTPRERR, FTPSRVERR, WRITEFAILED, FTPLOGREFUSED, FTPLOGINC */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPSRVERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""Error in server greeting.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPLOGREFUSED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""The server refuses login.\n""));
          fd_close (csock);
          con->csock = -1;
          return FTPLOGREFUSED;
        case FTPLOGINC:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""Login incorrect.\n""));
          fd_close (csock);
          con->csock = -1;
          return FTPLOGINC;
        case FTPOK:
          if (!opt.server_response)
            logputs (LOG_VERBOSE, _(""Logged in!\n""));
          break;
        default:
          abort ();
        }
      /* Third: Get the system type */
      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> SYST ... "");
      err = ftp_syst (csock, &con->rs, &con->rsu);
      /* FTPRERR */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPSRVERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Server error, can't determine system type.\n""));
          break;
        case FTPOK:
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }
      if (!opt.server_response && err != FTPSRVERR)
        logputs (LOG_VERBOSE, _(""done.    ""));

      /* 2013-10-17 Andrea Urbani (matfanjol)
         According to the system type I choose which
         list command will be used.
         If I don't know that system, I will try, the
         first time of each session, ""LIST -a"" and
         ""LIST"". (see __LIST_A_EXPLANATION__ below) */
      switch (con->rs)
        {
        case ST_VMS:
          /* About ST_VMS there is an old note:
             2008-01-29  SMS.  For a VMS FTP server, where ""LIST -a"" may not
             fail, but will never do what is desired here,
             skip directly to the simple ""LIST"" command
             (assumed to be the last one in the list).  */
          DEBUGP ((""\nVMS: I know it and I will use \""LIST\"" as standard list command\n""));
          con->st |= LIST_AFTER_LIST_A_CHECK_DONE;
          con->st |= AVOID_LIST_A;
          break;
        case ST_UNIX:
          if (con->rsu == UST_MULTINET)
            {
              DEBUGP ((""\nUNIX MultiNet: I know it and I will use \""LIST\"" ""
                       ""as standard list command\n""));
              con->st |= LIST_AFTER_LIST_A_CHECK_DONE;
              con->st |= AVOID_LIST_A;
            }
          else if (con->rsu == UST_TYPE_L8)
            {
              DEBUGP ((""\nUNIX TYPE L8: I know it and I will use \""LIST -a\"" ""
                       ""as standard list command\n""));
              con->st |= LIST_AFTER_LIST_A_CHECK_DONE;
              con->st |= AVOID_LIST;
            }
          break;
        default:
          break;
        }

      /* Fourth: Find the initial ftp directory */

      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> PWD ... "");
      err = ftp_pwd (csock, &con->id);
      /* FTPRERR */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPSRVERR :
          /* PWD unsupported -- assume ""/"". */
          xfree (con->id);
          con->id = xstrdup (""/"");
          break;
        case FTPOK:
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }

#if 0
      /* 2004-09-17 SMS.
         Don't help me out.  Please.
         A reasonably recent VMS FTP server will cope just fine with
         UNIX file specifications.  This code just spoils things.
         Discarding the device name, for example, is not a wise move.
         This code was disabled but left in as an example of what not
         to do.
      */

      /* VMS will report something like ""PUB$DEVICE:[INITIAL.FOLDER]"".
         Convert it to ""/INITIAL/FOLDER"" */
      if (con->rs == ST_VMS)
        {
          char *path = strchr (con->id, '[');
          char *pathend = path ? strchr (path + 1, ']') : NULL;
          if (!path || !pathend)
            DEBUGP ((""Initial VMS directory not in the form [...]!\n""));
          else
            {
              char *idir = con->id;
              DEBUGP ((""Preprocessing the initial VMS directory\n""));
              DEBUGP ((""  old = '%s'\n"", con->id));
              /* We do the conversion in-place by copying the stuff
                 between [ and ] to the beginning, and changing dots
                 to slashes at the same time.  */
              *idir++ = '/';
              for (++path; path < pathend; path++, idir++)
                *idir = *path == '.' ? '/' : *path;
              *idir = '\0';
              DEBUGP ((""  new = '%s'\n\n"", con->id));
            }
        }
#endif /* 0 */

      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.\n""));

      /* Fifth: Set the FTP type.  */
      type_char = ftp_process_type (u->params);
      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> TYPE %c ... "", type_char);
      err = ftp_type (csock, type_char);
      /* FTPRERR, WRITEFAILED, FTPUNKNOWNTYPE */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPUNKNOWNTYPE:
          logputs (LOG_VERBOSE, ""\n"");
          logprintf (LOG_NOTQUIET,
                     _(""Unknown type `%c', closing control connection.\n""),
                     type_char);
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPOK:
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }
      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.  ""));
    } /* do login */

  if (cmd & DO_CWD)
    {
      if (!*u->dir)
        logputs (LOG_VERBOSE, _(""==> CWD not needed.\n""));
      else
        {
          const char *targ = NULL;
          int cwd_count;
          int cwd_end;
          int cwd_start;

          char *target = u->dir;

          DEBUGP ((""changing working directory\n""));

          /* Change working directory.  To change to a non-absolute
             Unix directory, we need to prepend initial directory
             (con->id) to it.  Absolute directories ""just work"".

             A relative directory is one that does not begin with '/'
             and, on non-Unix OS'es, one that doesn't begin with
             ""[a-z]:"".

             This is not done for OS400, which doesn't use
             ""/""-delimited directories, nor does it support directory
             hierarchies.  ""CWD foo"" followed by ""CWD bar"" leaves us
             in ""bar"", not in ""foo/bar"", as would be customary
             elsewhere.  */

            /* 2004-09-20 SMS.
               Why is this wise even on UNIX?  It certainly fouls VMS.
               See below for a more reliable, more universal method.
            */

            /* 2008-04-22 MJC.
               I'm not crazy about it either. I'm informed it's useful
               for misconfigured servers that have some dirs in the path
               with +x but -r, but this method is not RFC-conformant. I
               understand the need to deal with crappy server
               configurations, but it's far better to use the canonical
               method first, and fall back to kludges second.
            */

          if (target[0] != '/'
              && !(con->rs != ST_UNIX
                   && c_isalpha (target[0])
                   && target[1] == ':')
              && (con->rs != ST_OS400)
              && (con->rs != ST_VMS))
            {
              int idlen = strlen (con->id);
              char *ntarget, *p;

              /* Strip trailing slash(es) from con->id. */
              while (idlen > 0 && con->id[idlen - 1] == '/')
                --idlen;
              p = ntarget = (char *)alloca (idlen + 1 + strlen (u->dir) + 1);
              memcpy (p, con->id, idlen);
              p += idlen;
              *p++ = '/';
              strcpy (p, target);

              DEBUGP ((""Prepended initial PWD to relative path:\n""));
              DEBUGP ((""   pwd: '%s'\n   old: '%s'\n  new: '%s'\n"",
                       con->id, target, ntarget));
              target = ntarget;
            }

#if 0
          /* 2004-09-17 SMS.
             Don't help me out.  Please.
             A reasonably recent VMS FTP server will cope just fine with
             UNIX file specifications.  This code just spoils things.
             Discarding the device name, for example, is not a wise
             move.
             This code was disabled but left in as an example of what
             not to do.
          */

          /* If the FTP host runs VMS, we will have to convert the absolute
             directory path in UNIX notation to absolute directory path in
             VMS notation as VMS FTP servers do not like UNIX notation of
             absolute paths.  ""VMS notation"" is [dir.subdir.subsubdir]. */

          if (con->rs == ST_VMS)
            {
              char *tmpp;
              char *ntarget = (char *)alloca (strlen (target) + 2);
              /* We use a converted initial dir, so directories in
                 TARGET will be separated with slashes, something like
                 ""/INITIAL/FOLDER/DIR/SUBDIR"".  Convert that to
                 ""[INITIAL.FOLDER.DIR.SUBDIR]"".  */
              strcpy (ntarget, target);
              assert (*ntarget == '/');
              *ntarget = '[';
              for (tmpp = ntarget + 1; *tmpp; tmpp++)
                if (*tmpp == '/')
                  *tmpp = '.';
              *tmpp++ = ']';
              *tmpp = '\0';
              DEBUGP ((""Changed file name to VMS syntax:\n""));
              DEBUGP ((""  Unix: '%s'\n  VMS: '%s'\n"", target, ntarget));
              target = ntarget;
            }
#endif /* 0 */

          /* 2004-09-20 SMS.
             A relative directory is relative to the initial directory.
             Thus, what _is_ useful on VMS (and probably elsewhere) is
             to CWD to the initial directory (ideally, whatever the
             server reports, _exactly_, NOT badly UNIX-ixed), and then
             CWD to the (new) relative directory.  This should probably
             be restructured as a function, called once or twice, but
             I'm lazy enough to take the badly indented loop short-cut
             for now.
          */

          /* Decide on one pass (absolute) or two (relative).
             The VMS restriction may be relaxed when the squirrely code
             above is reformed.
          */
          if ((con->rs == ST_VMS) && (target[0] != '/'))
            {
              cwd_start = 0;
              DEBUGP ((""Using two-step CWD for relative path.\n""));
            }
          else
            {
              /* Go straight to the target. */
              cwd_start = 1;
            }

          /* At least one VMS FTP server (TCPware V5.6-2) can switch to
             a UNIX emulation mode when given a UNIX-like directory
             specification (like ""a/b/c"").  If allowed to continue this
             way, LIST interpretation will be confused, because the
             system type (SYST response) will not be re-checked, and
             future UNIX-format directory listings (for multiple URLs or
             ""-r"") will be horribly misinterpreted.

             The cheap and nasty work-around is to do a ""CWD []"" after a
             UNIX-like directory specification is used.  (A single-level
             directory is harmless.)  This puts the TCPware server back
             into VMS mode, and does no harm on other servers.

             Unlike the rest of this block, this particular behavior
             _is_ VMS-specific, so it gets its own VMS test.
          */
          if ((con->rs == ST_VMS) && (strchr( target, '/') != NULL))
            {
              cwd_end = 3;
              DEBUGP ((""Using extra \""CWD []\"" step for VMS server.\n""));
            }
          else
            {
              cwd_end = 2;
            }

          /* 2004-09-20 SMS. */
          /* Sorry about the deviant indenting.  Laziness. */

          for (cwd_count = cwd_start; cwd_count < cwd_end; cwd_count++)
            {
              switch (cwd_count)
                {
                  case 0:
                    /* Step one (optional): Go to the initial directory,
                       exactly as reported by the server.
                    */
                    targ = con->id;
                    break;

                  case 1:
                    /* Step two: Go to the target directory.  (Absolute or
                       relative will work now.)
                    */
                    targ = target;
                    break;

                  case 2:
                    /* Step three (optional): ""CWD []"" to restore server
                       VMS-ness.
                    */
                    targ = ""[]"";
                    break;

                  default:
                    logprintf (LOG_ALWAYS, _(""Logically impossible section reached in getftp()""));
                    logprintf (LOG_ALWAYS, _(""cwd_count: %d\ncwd_start: %d\ncwd_end: %d\n""),
                                             cwd_count, cwd_start, cwd_end);
                    abort ();
                }

              if (!opt.server_response)
                logprintf (LOG_VERBOSE, ""==> CWD (%d) %s ... "", cwd_count,
                           quotearg_style (escape_quoting_style, target));

              err = ftp_cwd (csock, targ);

              /* FTPRERR, WRITEFAILED, FTPNSFOD */
              switch (err)
                {
                  case FTPRERR:
                    logputs (LOG_VERBOSE, ""\n"");
                    logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
                    fd_close (csock);
                    con->csock = -1;
                    return err;
                  case WRITEFAILED:
                    logputs (LOG_VERBOSE, ""\n"");
                    logputs (LOG_NOTQUIET,
                             _(""Write failed, closing control connection.\n""));
                    fd_close (csock);
                    con->csock = -1;
                    return err;
                  case FTPNSFOD:
                    logputs (LOG_VERBOSE, ""\n"");
                    logprintf (LOG_NOTQUIET, _(""No such directory %s.\n\n""),
                               quote (u->dir));
                    fd_close (csock);
                    con->csock = -1;
                    return err;
                  case FTPOK:
                    break;
                  default:
                    abort ();
                }

              if (!opt.server_response)
                logputs (LOG_VERBOSE, _(""done.\n""));

            } /* for */

          /* 2004-09-20 SMS. */

        } /* else */
    }
  else /* do not CWD */
    logputs (LOG_VERBOSE, _(""==> CWD not required.\n""));

  if ((cmd & DO_RETR) && passed_expected_bytes == 0)
    {
      if (opt.verbose)
        {
          if (!opt.server_response)
            logprintf (LOG_VERBOSE, ""==> SIZE %s ... "",
                       quotearg_style (escape_quoting_style, u->file));
        }

      err = ftp_size (csock, u->file, &expected_bytes);
      /* FTPRERR */
      switch (err)
        {
        case FTPRERR:
        case FTPSRVERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPOK:
          got_expected_bytes = true;
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }
        if (!opt.server_response)
          {
            logprintf (LOG_VERBOSE, ""%s\n"",
                    expected_bytes ?
                    number_to_static_string (expected_bytes) :
                    _(""done.\n""));
          }
    }

  if (cmd & DO_RETR && restval > 0 && restval == expected_bytes)
    {
      /* Server confirms that file has length restval. We should stop now.
         Some servers (f.e. NcFTPd) return error when receive REST 0 */
      logputs (LOG_VERBOSE, _(""File has already been retrieved.\n""));
      fd_close (csock);
      con->csock = -1;
      return RETRFINISHED;
    }

  do
  {
  try_again = false;
  /* If anything is to be retrieved, PORT (or PASV) must be sent.  */
  if (cmd & (DO_LIST | DO_RETR))
    {
      if (opt.ftp_pasv)
        {
          ip_address passive_addr;
          int        passive_port;
          err = ftp_do_pasv (csock, &passive_addr, &passive_port);
          /* FTPRERR, WRITEFAILED, FTPNOPASV, FTPINVPASV */
          switch (err)
            {
            case FTPRERR:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              return err;
            case WRITEFAILED:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET,
                       _(""Write failed, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              return err;
            case FTPNOPASV:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""Cannot initiate PASV transfer.\n""));
              break;
            case FTPINVPASV:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""Cannot parse PASV response.\n""));
              break;
            case FTPOK:
              break;
            default:
              abort ();
            }   /* switch (err) */
          if (err==FTPOK)
            {
              DEBUGP ((""trying to connect to %s port %d\n"",
                      print_address (&passive_addr), passive_port));
              dtsock = connect_to_ip (&passive_addr, passive_port, NULL);
              if (dtsock < 0)
                {
                  int save_errno = errno;
                  fd_close (csock);
                  con->csock = -1;
                  logprintf (LOG_VERBOSE, _(""couldn't connect to %s port %d: %s\n""),
                             print_address (&passive_addr), passive_port,
                             strerror (save_errno));
                           ? CONERROR : CONIMPOSSIBLE);
                 }
 
              pasv_mode_open = true;  /* Flag to avoid accept port */
               if (!opt.server_response)
                 logputs (LOG_VERBOSE, _(""done.    ""));
            } /* err==FTP_OK */
        }
 
      if (!pasv_mode_open)   /* Try to use a port command if PASV failed */
         {
           err = ftp_do_port (csock, &local_sock);
           /* FTPRERR, WRITEFAILED, bindport (FTPSYSERR), HOSTERR,
              logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case WRITEFAILED:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET,
                       _(""Write failed, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case CONSOCKERR:
              logputs (LOG_VERBOSE, ""\n"");
              logprintf (LOG_NOTQUIET, ""socket: %s\n"", strerror (errno));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case FTPSYSERR:
              logputs (LOG_VERBOSE, ""\n"");
              logprintf (LOG_NOTQUIET, _(""Bind error (%s).\n""),
                         strerror (errno));
              fd_close (dtsock);
              return err;
            case FTPPORTERR:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""Invalid PORT.\n""));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case FTPOK:
              break;
            default:
              abort ();
            } /* port switch */
          if (!opt.server_response)
            logputs (LOG_VERBOSE, _(""done.    ""));
        } /* dtsock == -1 */
    } /* cmd & (DO_LIST | DO_RETR) */

  /* Restart if needed.  */
  if (restval && (cmd & DO_RETR))
    {
      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> REST %s ... "",
                   number_to_static_string (restval));
      err = ftp_rest (csock, restval);

      /* FTPRERR, WRITEFAILED, FTPRESTFAIL */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPRESTFAIL:
          logputs (LOG_VERBOSE, _(""\nREST failed, starting from scratch.\n""));
          rest_failed = true;
          break;
        case FTPOK:
          break;
        default:
          abort ();
        }
      if (err != FTPRESTFAIL && !opt.server_response)
        logputs (LOG_VERBOSE, _(""done.    ""));
    } /* restval && cmd & DO_RETR */

  if (cmd & DO_RETR)
    {
      /* If we're in spider mode, don't really retrieve anything except
         the directory listing and verify whether the given ""file"" exists.  */
      if (opt.spider)
        {
          bool exists = false;
          struct fileinfo *f;
          uerr_t _res = ftp_get_listing (u, con, &f);
          /* Set the DO_RETR command flag again, because it gets unset when
             calling ftp_get_listing() and would otherwise cause an assertion
             failure earlier on when this function gets repeatedly called
             (e.g., when recursing).  */
          con->cmd |= DO_RETR;
          if (_res == RETROK)
            {
              while (f)
                {
                  if (!strcmp (f->name, u->file))
                    {
                      exists = true;
                      break;
                    }
                  f = f->next;
                }
              if (exists)
                {
                  logputs (LOG_VERBOSE, ""\n"");
                  logprintf (LOG_NOTQUIET, _(""File %s exists.\n""),
                             quote (u->file));
                }
              else
                {
                  logputs (LOG_VERBOSE, ""\n"");
                  logprintf (LOG_NOTQUIET, _(""No such file %s.\n""),
                             quote (u->file));
                }
            }
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return RETRFINISHED;
        }

      if (opt.verbose)
        {
          if (!opt.server_response)
            {
              if (restval)
                logputs (LOG_VERBOSE, ""\n"");
              logprintf (LOG_VERBOSE, ""==> RETR %s ... "",
                         quotearg_style (escape_quoting_style, u->file));
            }
        }

      err = ftp_retr (csock, u->file);
      /* FTPRERR, WRITEFAILED, FTPNSFOD */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPNSFOD:
          logputs (LOG_VERBOSE, ""\n"");
          logprintf (LOG_NOTQUIET, _(""No such file %s.\n\n""),
                     quote (u->file));
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPOK:
          break;
        default:
          abort ();
        }

      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.\n""));

      if (! got_expected_bytes)
        expected_bytes = *last_expected_bytes;
    } /* do retrieve */

  if (cmd & DO_LIST)
    {
      if (!opt.server_response)
        logputs (LOG_VERBOSE, ""==> LIST ... "");
      /* As Maciej W. Rozycki (macro@ds2.pg.gda.pl) says, `LIST'
         without arguments is better than `LIST .'; confirmed by
         RFC959.  */
      err = ftp_list (csock, NULL, con->st&AVOID_LIST_A, con->st&AVOID_LIST, &list_a_used);

      /* FTPRERR, WRITEFAILED */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPNSFOD:
          logputs (LOG_VERBOSE, ""\n"");
          logprintf (LOG_NOTQUIET, _(""No such file or directory %s.\n\n""),
                     quote ("".""));
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPOK:
          break;
        default:
          abort ();
        }
      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.\n""));

      if (! got_expected_bytes)
        expected_bytes = *last_expected_bytes;
    } /* cmd & DO_LIST */

  if (!(cmd & (DO_LIST | DO_RETR)) || (opt.spider && !(cmd & DO_LIST)))
    return RETRFINISHED;

  /* Some FTP servers return the total length of file after REST
     command, others just return the remaining size. */
  if (passed_expected_bytes && restval && expected_bytes
      && (expected_bytes == passed_expected_bytes - restval))
    {
      DEBUGP ((""Lying FTP server found, adjusting.\n""));
      expected_bytes = passed_expected_bytes;
    }

  /* If no transmission was required, then everything is OK.  */
  if (!pasv_mode_open)  /* we are not using pasive mode so we need
                              to accept */
     }
","getftp (struct url *u, wgint passed_expected_bytes, wgint *qtyread,
        wgint restval, ccon *con, int count, wgint *last_expected_bytes,
        FILE *warc_tmp)
{
  int csock, dtsock, local_sock, res;
  uerr_t err = RETROK;          /* appease the compiler */
  FILE *fp;
   char *respline, *tms;
   const char *user, *passwd, *tmrate;
   int cmd = con->cmd;
   wgint expected_bytes = 0;
   bool got_expected_bytes = false;
   bool rest_failed = false;
  bool rest_failed = false;
  int flags;
  wgint rd_size, previous_rd_size = 0;
  char type_char;
  bool try_again;
  bool list_a_used = false;

  assert (con != NULL);
  assert (con->target != NULL);

  /* Debug-check of the sanity of the request by making sure that LIST
     and RETR are never both requested (since we can handle only one
     at a time.  */
  assert (!((cmd & DO_LIST) && (cmd & DO_RETR)));
  /* Make sure that at least *something* is requested.  */
  assert ((cmd & (DO_LIST | DO_CWD | DO_RETR | DO_LOGIN)) != 0);

  *qtyread = restval;

  user = u->user;
  passwd = u->passwd;
  search_netrc (u->host, (const char **)&user, (const char **)&passwd, 1);
  user = user ? user : (opt.ftp_user ? opt.ftp_user : opt.user);
  if (!user) user = ""anonymous"";
  passwd = passwd ? passwd : (opt.ftp_passwd ? opt.ftp_passwd : opt.passwd);
  if (!passwd) passwd = ""-wget@"";

  dtsock = -1;
  local_sock = -1;
  con->dltime = 0;

  if (!(cmd & DO_LOGIN))
    csock = con->csock;
  else                          /* cmd & DO_LOGIN */
    {
      char    *host = con->proxy ? con->proxy->host : u->host;
      int      port = con->proxy ? con->proxy->port : u->port;

      /* Login to the server: */

      /* First: Establish the control connection.  */

      csock = connect_to_host (host, port);
      if (csock == E_HOST)
          return HOSTERR;
      else if (csock < 0)
          return (retryable_socket_connect_error (errno)
                  ? CONERROR : CONIMPOSSIBLE);

      if (cmd & LEAVE_PENDING)
        con->csock = csock;
      else
        con->csock = -1;

      /* Second: Login with proper USER/PASS sequence.  */
      logprintf (LOG_VERBOSE, _(""Logging in as %s ... ""),
                 quotearg_style (escape_quoting_style, user));
      if (opt.server_response)
        logputs (LOG_ALWAYS, ""\n"");
      if (con->proxy)
        {
          /* If proxy is in use, log in as username@target-site. */
          char *logname = concat_strings (user, ""@"", u->host, (char *) 0);
          err = ftp_login (csock, logname, passwd);
          xfree (logname);
        }
      else
        err = ftp_login (csock, user, passwd);

      /* FTPRERR, FTPSRVERR, WRITEFAILED, FTPLOGREFUSED, FTPLOGINC */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPSRVERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""Error in server greeting.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPLOGREFUSED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""The server refuses login.\n""));
          fd_close (csock);
          con->csock = -1;
          return FTPLOGREFUSED;
        case FTPLOGINC:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""Login incorrect.\n""));
          fd_close (csock);
          con->csock = -1;
          return FTPLOGINC;
        case FTPOK:
          if (!opt.server_response)
            logputs (LOG_VERBOSE, _(""Logged in!\n""));
          break;
        default:
          abort ();
        }
      /* Third: Get the system type */
      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> SYST ... "");
      err = ftp_syst (csock, &con->rs, &con->rsu);
      /* FTPRERR */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPSRVERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Server error, can't determine system type.\n""));
          break;
        case FTPOK:
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }
      if (!opt.server_response && err != FTPSRVERR)
        logputs (LOG_VERBOSE, _(""done.    ""));

      /* 2013-10-17 Andrea Urbani (matfanjol)
         According to the system type I choose which
         list command will be used.
         If I don't know that system, I will try, the
         first time of each session, ""LIST -a"" and
         ""LIST"". (see __LIST_A_EXPLANATION__ below) */
      switch (con->rs)
        {
        case ST_VMS:
          /* About ST_VMS there is an old note:
             2008-01-29  SMS.  For a VMS FTP server, where ""LIST -a"" may not
             fail, but will never do what is desired here,
             skip directly to the simple ""LIST"" command
             (assumed to be the last one in the list).  */
          DEBUGP ((""\nVMS: I know it and I will use \""LIST\"" as standard list command\n""));
          con->st |= LIST_AFTER_LIST_A_CHECK_DONE;
          con->st |= AVOID_LIST_A;
          break;
        case ST_UNIX:
          if (con->rsu == UST_MULTINET)
            {
              DEBUGP ((""\nUNIX MultiNet: I know it and I will use \""LIST\"" ""
                       ""as standard list command\n""));
              con->st |= LIST_AFTER_LIST_A_CHECK_DONE;
              con->st |= AVOID_LIST_A;
            }
          else if (con->rsu == UST_TYPE_L8)
            {
              DEBUGP ((""\nUNIX TYPE L8: I know it and I will use \""LIST -a\"" ""
                       ""as standard list command\n""));
              con->st |= LIST_AFTER_LIST_A_CHECK_DONE;
              con->st |= AVOID_LIST;
            }
          break;
        default:
          break;
        }

      /* Fourth: Find the initial ftp directory */

      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> PWD ... "");
      err = ftp_pwd (csock, &con->id);
      /* FTPRERR */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPSRVERR :
          /* PWD unsupported -- assume ""/"". */
          xfree (con->id);
          con->id = xstrdup (""/"");
          break;
        case FTPOK:
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }

#if 0
      /* 2004-09-17 SMS.
         Don't help me out.  Please.
         A reasonably recent VMS FTP server will cope just fine with
         UNIX file specifications.  This code just spoils things.
         Discarding the device name, for example, is not a wise move.
         This code was disabled but left in as an example of what not
         to do.
      */

      /* VMS will report something like ""PUB$DEVICE:[INITIAL.FOLDER]"".
         Convert it to ""/INITIAL/FOLDER"" */
      if (con->rs == ST_VMS)
        {
          char *path = strchr (con->id, '[');
          char *pathend = path ? strchr (path + 1, ']') : NULL;
          if (!path || !pathend)
            DEBUGP ((""Initial VMS directory not in the form [...]!\n""));
          else
            {
              char *idir = con->id;
              DEBUGP ((""Preprocessing the initial VMS directory\n""));
              DEBUGP ((""  old = '%s'\n"", con->id));
              /* We do the conversion in-place by copying the stuff
                 between [ and ] to the beginning, and changing dots
                 to slashes at the same time.  */
              *idir++ = '/';
              for (++path; path < pathend; path++, idir++)
                *idir = *path == '.' ? '/' : *path;
              *idir = '\0';
              DEBUGP ((""  new = '%s'\n\n"", con->id));
            }
        }
#endif /* 0 */

      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.\n""));

      /* Fifth: Set the FTP type.  */
      type_char = ftp_process_type (u->params);
      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> TYPE %c ... "", type_char);
      err = ftp_type (csock, type_char);
      /* FTPRERR, WRITEFAILED, FTPUNKNOWNTYPE */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPUNKNOWNTYPE:
          logputs (LOG_VERBOSE, ""\n"");
          logprintf (LOG_NOTQUIET,
                     _(""Unknown type `%c', closing control connection.\n""),
                     type_char);
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPOK:
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }
      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.  ""));
    } /* do login */

  if (cmd & DO_CWD)
    {
      if (!*u->dir)
        logputs (LOG_VERBOSE, _(""==> CWD not needed.\n""));
      else
        {
          const char *targ = NULL;
          int cwd_count;
          int cwd_end;
          int cwd_start;

          char *target = u->dir;

          DEBUGP ((""changing working directory\n""));

          /* Change working directory.  To change to a non-absolute
             Unix directory, we need to prepend initial directory
             (con->id) to it.  Absolute directories ""just work"".

             A relative directory is one that does not begin with '/'
             and, on non-Unix OS'es, one that doesn't begin with
             ""[a-z]:"".

             This is not done for OS400, which doesn't use
             ""/""-delimited directories, nor does it support directory
             hierarchies.  ""CWD foo"" followed by ""CWD bar"" leaves us
             in ""bar"", not in ""foo/bar"", as would be customary
             elsewhere.  */

            /* 2004-09-20 SMS.
               Why is this wise even on UNIX?  It certainly fouls VMS.
               See below for a more reliable, more universal method.
            */

            /* 2008-04-22 MJC.
               I'm not crazy about it either. I'm informed it's useful
               for misconfigured servers that have some dirs in the path
               with +x but -r, but this method is not RFC-conformant. I
               understand the need to deal with crappy server
               configurations, but it's far better to use the canonical
               method first, and fall back to kludges second.
            */

          if (target[0] != '/'
              && !(con->rs != ST_UNIX
                   && c_isalpha (target[0])
                   && target[1] == ':')
              && (con->rs != ST_OS400)
              && (con->rs != ST_VMS))
            {
              int idlen = strlen (con->id);
              char *ntarget, *p;

              /* Strip trailing slash(es) from con->id. */
              while (idlen > 0 && con->id[idlen - 1] == '/')
                --idlen;
              p = ntarget = (char *)alloca (idlen + 1 + strlen (u->dir) + 1);
              memcpy (p, con->id, idlen);
              p += idlen;
              *p++ = '/';
              strcpy (p, target);

              DEBUGP ((""Prepended initial PWD to relative path:\n""));
              DEBUGP ((""   pwd: '%s'\n   old: '%s'\n  new: '%s'\n"",
                       con->id, target, ntarget));
              target = ntarget;
            }

#if 0
          /* 2004-09-17 SMS.
             Don't help me out.  Please.
             A reasonably recent VMS FTP server will cope just fine with
             UNIX file specifications.  This code just spoils things.
             Discarding the device name, for example, is not a wise
             move.
             This code was disabled but left in as an example of what
             not to do.
          */

          /* If the FTP host runs VMS, we will have to convert the absolute
             directory path in UNIX notation to absolute directory path in
             VMS notation as VMS FTP servers do not like UNIX notation of
             absolute paths.  ""VMS notation"" is [dir.subdir.subsubdir]. */

          if (con->rs == ST_VMS)
            {
              char *tmpp;
              char *ntarget = (char *)alloca (strlen (target) + 2);
              /* We use a converted initial dir, so directories in
                 TARGET will be separated with slashes, something like
                 ""/INITIAL/FOLDER/DIR/SUBDIR"".  Convert that to
                 ""[INITIAL.FOLDER.DIR.SUBDIR]"".  */
              strcpy (ntarget, target);
              assert (*ntarget == '/');
              *ntarget = '[';
              for (tmpp = ntarget + 1; *tmpp; tmpp++)
                if (*tmpp == '/')
                  *tmpp = '.';
              *tmpp++ = ']';
              *tmpp = '\0';
              DEBUGP ((""Changed file name to VMS syntax:\n""));
              DEBUGP ((""  Unix: '%s'\n  VMS: '%s'\n"", target, ntarget));
              target = ntarget;
            }
#endif /* 0 */

          /* 2004-09-20 SMS.
             A relative directory is relative to the initial directory.
             Thus, what _is_ useful on VMS (and probably elsewhere) is
             to CWD to the initial directory (ideally, whatever the
             server reports, _exactly_, NOT badly UNIX-ixed), and then
             CWD to the (new) relative directory.  This should probably
             be restructured as a function, called once or twice, but
             I'm lazy enough to take the badly indented loop short-cut
             for now.
          */

          /* Decide on one pass (absolute) or two (relative).
             The VMS restriction may be relaxed when the squirrely code
             above is reformed.
          */
          if ((con->rs == ST_VMS) && (target[0] != '/'))
            {
              cwd_start = 0;
              DEBUGP ((""Using two-step CWD for relative path.\n""));
            }
          else
            {
              /* Go straight to the target. */
              cwd_start = 1;
            }

          /* At least one VMS FTP server (TCPware V5.6-2) can switch to
             a UNIX emulation mode when given a UNIX-like directory
             specification (like ""a/b/c"").  If allowed to continue this
             way, LIST interpretation will be confused, because the
             system type (SYST response) will not be re-checked, and
             future UNIX-format directory listings (for multiple URLs or
             ""-r"") will be horribly misinterpreted.

             The cheap and nasty work-around is to do a ""CWD []"" after a
             UNIX-like directory specification is used.  (A single-level
             directory is harmless.)  This puts the TCPware server back
             into VMS mode, and does no harm on other servers.

             Unlike the rest of this block, this particular behavior
             _is_ VMS-specific, so it gets its own VMS test.
          */
          if ((con->rs == ST_VMS) && (strchr( target, '/') != NULL))
            {
              cwd_end = 3;
              DEBUGP ((""Using extra \""CWD []\"" step for VMS server.\n""));
            }
          else
            {
              cwd_end = 2;
            }

          /* 2004-09-20 SMS. */
          /* Sorry about the deviant indenting.  Laziness. */

          for (cwd_count = cwd_start; cwd_count < cwd_end; cwd_count++)
            {
              switch (cwd_count)
                {
                  case 0:
                    /* Step one (optional): Go to the initial directory,
                       exactly as reported by the server.
                    */
                    targ = con->id;
                    break;

                  case 1:
                    /* Step two: Go to the target directory.  (Absolute or
                       relative will work now.)
                    */
                    targ = target;
                    break;

                  case 2:
                    /* Step three (optional): ""CWD []"" to restore server
                       VMS-ness.
                    */
                    targ = ""[]"";
                    break;

                  default:
                    logprintf (LOG_ALWAYS, _(""Logically impossible section reached in getftp()""));
                    logprintf (LOG_ALWAYS, _(""cwd_count: %d\ncwd_start: %d\ncwd_end: %d\n""),
                                             cwd_count, cwd_start, cwd_end);
                    abort ();
                }

              if (!opt.server_response)
                logprintf (LOG_VERBOSE, ""==> CWD (%d) %s ... "", cwd_count,
                           quotearg_style (escape_quoting_style, target));

              err = ftp_cwd (csock, targ);

              /* FTPRERR, WRITEFAILED, FTPNSFOD */
              switch (err)
                {
                  case FTPRERR:
                    logputs (LOG_VERBOSE, ""\n"");
                    logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
                    fd_close (csock);
                    con->csock = -1;
                    return err;
                  case WRITEFAILED:
                    logputs (LOG_VERBOSE, ""\n"");
                    logputs (LOG_NOTQUIET,
                             _(""Write failed, closing control connection.\n""));
                    fd_close (csock);
                    con->csock = -1;
                    return err;
                  case FTPNSFOD:
                    logputs (LOG_VERBOSE, ""\n"");
                    logprintf (LOG_NOTQUIET, _(""No such directory %s.\n\n""),
                               quote (u->dir));
                    fd_close (csock);
                    con->csock = -1;
                    return err;
                  case FTPOK:
                    break;
                  default:
                    abort ();
                }

              if (!opt.server_response)
                logputs (LOG_VERBOSE, _(""done.\n""));

            } /* for */

          /* 2004-09-20 SMS. */

        } /* else */
    }
  else /* do not CWD */
    logputs (LOG_VERBOSE, _(""==> CWD not required.\n""));

  if ((cmd & DO_RETR) && passed_expected_bytes == 0)
    {
      if (opt.verbose)
        {
          if (!opt.server_response)
            logprintf (LOG_VERBOSE, ""==> SIZE %s ... "",
                       quotearg_style (escape_quoting_style, u->file));
        }

      err = ftp_size (csock, u->file, &expected_bytes);
      /* FTPRERR */
      switch (err)
        {
        case FTPRERR:
        case FTPSRVERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          return err;
        case FTPOK:
          got_expected_bytes = true;
          /* Everything is OK.  */
          break;
        default:
          abort ();
        }
        if (!opt.server_response)
          {
            logprintf (LOG_VERBOSE, ""%s\n"",
                    expected_bytes ?
                    number_to_static_string (expected_bytes) :
                    _(""done.\n""));
          }
    }

  if (cmd & DO_RETR && restval > 0 && restval == expected_bytes)
    {
      /* Server confirms that file has length restval. We should stop now.
         Some servers (f.e. NcFTPd) return error when receive REST 0 */
      logputs (LOG_VERBOSE, _(""File has already been retrieved.\n""));
      fd_close (csock);
      con->csock = -1;
      return RETRFINISHED;
    }

  do
  {
  try_again = false;
  /* If anything is to be retrieved, PORT (or PASV) must be sent.  */
  if (cmd & (DO_LIST | DO_RETR))
    {
      if (opt.ftp_pasv)
        {
          ip_address passive_addr;
          int        passive_port;
          err = ftp_do_pasv (csock, &passive_addr, &passive_port);
          /* FTPRERR, WRITEFAILED, FTPNOPASV, FTPINVPASV */
          switch (err)
            {
            case FTPRERR:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              return err;
            case WRITEFAILED:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET,
                       _(""Write failed, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              return err;
            case FTPNOPASV:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""Cannot initiate PASV transfer.\n""));
              break;
            case FTPINVPASV:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""Cannot parse PASV response.\n""));
              break;
            case FTPOK:
              break;
            default:
              abort ();
            }   /* switch (err) */
          if (err==FTPOK)
            {
              DEBUGP ((""trying to connect to %s port %d\n"",
                      print_address (&passive_addr), passive_port));
              dtsock = connect_to_ip (&passive_addr, passive_port, NULL);
              if (dtsock < 0)
                {
                  int save_errno = errno;
                  fd_close (csock);
                  con->csock = -1;
                  logprintf (LOG_VERBOSE, _(""couldn't connect to %s port %d: %s\n""),
                             print_address (&passive_addr), passive_port,
                             strerror (save_errno));
                           ? CONERROR : CONIMPOSSIBLE);
                 }
 
               if (!opt.server_response)
                 logputs (LOG_VERBOSE, _(""done.    ""));
            }
          else
            return err;
 
          /*
           * We do not want to fall back from PASSIVE mode to ACTIVE mode !
           * The reason is the PORT command exposes the client's real IP address
           * to the server. Bad for someone who relies on privacy via a ftp proxy.
           */
        }
      else
         {
           err = ftp_do_port (csock, &local_sock);
           /* FTPRERR, WRITEFAILED, bindport (FTPSYSERR), HOSTERR,
              logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case WRITEFAILED:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET,
                       _(""Write failed, closing control connection.\n""));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case CONSOCKERR:
              logputs (LOG_VERBOSE, ""\n"");
              logprintf (LOG_NOTQUIET, ""socket: %s\n"", strerror (errno));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case FTPSYSERR:
              logputs (LOG_VERBOSE, ""\n"");
              logprintf (LOG_NOTQUIET, _(""Bind error (%s).\n""),
                         strerror (errno));
              fd_close (dtsock);
              return err;
            case FTPPORTERR:
              logputs (LOG_VERBOSE, ""\n"");
              logputs (LOG_NOTQUIET, _(""Invalid PORT.\n""));
              fd_close (csock);
              con->csock = -1;
              fd_close (dtsock);
              fd_close (local_sock);
              return err;
            case FTPOK:
              break;
            default:
              abort ();
            } /* port switch */
          if (!opt.server_response)
            logputs (LOG_VERBOSE, _(""done.    ""));
        } /* dtsock == -1 */
    } /* cmd & (DO_LIST | DO_RETR) */

  /* Restart if needed.  */
  if (restval && (cmd & DO_RETR))
    {
      if (!opt.server_response)
        logprintf (LOG_VERBOSE, ""==> REST %s ... "",
                   number_to_static_string (restval));
      err = ftp_rest (csock, restval);

      /* FTPRERR, WRITEFAILED, FTPRESTFAIL */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPRESTFAIL:
          logputs (LOG_VERBOSE, _(""\nREST failed, starting from scratch.\n""));
          rest_failed = true;
          break;
        case FTPOK:
          break;
        default:
          abort ();
        }
      if (err != FTPRESTFAIL && !opt.server_response)
        logputs (LOG_VERBOSE, _(""done.    ""));
    } /* restval && cmd & DO_RETR */

  if (cmd & DO_RETR)
    {
      /* If we're in spider mode, don't really retrieve anything except
         the directory listing and verify whether the given ""file"" exists.  */
      if (opt.spider)
        {
          bool exists = false;
          struct fileinfo *f;
          uerr_t _res = ftp_get_listing (u, con, &f);
          /* Set the DO_RETR command flag again, because it gets unset when
             calling ftp_get_listing() and would otherwise cause an assertion
             failure earlier on when this function gets repeatedly called
             (e.g., when recursing).  */
          con->cmd |= DO_RETR;
          if (_res == RETROK)
            {
              while (f)
                {
                  if (!strcmp (f->name, u->file))
                    {
                      exists = true;
                      break;
                    }
                  f = f->next;
                }
              if (exists)
                {
                  logputs (LOG_VERBOSE, ""\n"");
                  logprintf (LOG_NOTQUIET, _(""File %s exists.\n""),
                             quote (u->file));
                }
              else
                {
                  logputs (LOG_VERBOSE, ""\n"");
                  logprintf (LOG_NOTQUIET, _(""No such file %s.\n""),
                             quote (u->file));
                }
            }
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return RETRFINISHED;
        }

      if (opt.verbose)
        {
          if (!opt.server_response)
            {
              if (restval)
                logputs (LOG_VERBOSE, ""\n"");
              logprintf (LOG_VERBOSE, ""==> RETR %s ... "",
                         quotearg_style (escape_quoting_style, u->file));
            }
        }

      err = ftp_retr (csock, u->file);
      /* FTPRERR, WRITEFAILED, FTPNSFOD */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPNSFOD:
          logputs (LOG_VERBOSE, ""\n"");
          logprintf (LOG_NOTQUIET, _(""No such file %s.\n\n""),
                     quote (u->file));
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPOK:
          break;
        default:
          abort ();
        }

      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.\n""));

      if (! got_expected_bytes)
        expected_bytes = *last_expected_bytes;
    } /* do retrieve */

  if (cmd & DO_LIST)
    {
      if (!opt.server_response)
        logputs (LOG_VERBOSE, ""==> LIST ... "");
      /* As Maciej W. Rozycki (macro@ds2.pg.gda.pl) says, `LIST'
         without arguments is better than `LIST .'; confirmed by
         RFC959.  */
      err = ftp_list (csock, NULL, con->st&AVOID_LIST_A, con->st&AVOID_LIST, &list_a_used);

      /* FTPRERR, WRITEFAILED */
      switch (err)
        {
        case FTPRERR:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET, _(""\
Error in server response, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case WRITEFAILED:
          logputs (LOG_VERBOSE, ""\n"");
          logputs (LOG_NOTQUIET,
                   _(""Write failed, closing control connection.\n""));
          fd_close (csock);
          con->csock = -1;
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPNSFOD:
          logputs (LOG_VERBOSE, ""\n"");
          logprintf (LOG_NOTQUIET, _(""No such file or directory %s.\n\n""),
                     quote ("".""));
          fd_close (dtsock);
          fd_close (local_sock);
          return err;
        case FTPOK:
          break;
        default:
          abort ();
        }
      if (!opt.server_response)
        logputs (LOG_VERBOSE, _(""done.\n""));

      if (! got_expected_bytes)
        expected_bytes = *last_expected_bytes;
    } /* cmd & DO_LIST */

  if (!(cmd & (DO_LIST | DO_RETR)) || (opt.spider && !(cmd & DO_LIST)))
    return RETRFINISHED;

  /* Some FTP servers return the total length of file after REST
     command, others just return the remaining size. */
  if (passed_expected_bytes && restval && expected_bytes
      && (expected_bytes == passed_expected_bytes - restval))
    {
      DEBUGP ((""Lying FTP server found, adjusting.\n""));
      expected_bytes = passed_expected_bytes;
    }

  /* If no transmission was required, then everything is OK.  */
  if (!pasv_mode_open)  /* we are not using pasive mode so we need
                              to accept */
     }
","The `getftp` function facilitates FTP operations, including login, directory navigation, and file retrieval. It begins by establishing a control connection to the FTP server, authenticating with user credentials, and determining the server's system type. Depending on the command flags, it may change directories, check file sizes, and initiate data connections using either passive or active modes. The function handles various server responses, logging errors and managing connections accordingly. It also supports resuming file transfers and can verify file existence in spider mode, ensuring robust interaction with FTP servers while adhering to protocol standards.","The code implements a function that manages FTP operations, including establishing a connection to the server, authenticating users, and navigating directories. It handles various commands such as listing files and retrieving them, while also checking for expected file sizes and supporting resuming interrupted transfers. The function adapts to different server types and configurations, ensuring compatibility with both passive and active data transfer modes. It logs server responses and errors, maintaining robust communication with the FTP server, and can verify the existence of files when operating in a specific mode designed for web crawling.","The vulnerability in the original code arises from the lack of proper validation and error handling during the FTP login process, particularly when handling user credentials. If the user or password is not set correctly, the code defaults to using ""anonymous"" for the user and ""-wget@"" for the password, which could lead to unauthorized access if not properly managed. The fixed code enhances security by ensuring that user credentials are explicitly checked and validated before proceeding with the login, thereby preventing potential unauthorized access and improving overall robustness against credential-related vulnerabilities.","The vulnerability in the original code stems from inadequate handling of user credentials during the FTP login process, which could allow unauthorized access if the user or password is not properly set. The code defaults to using generic credentials if specific ones are not provided, increasing the risk of exploitation. The fixed code addresses this issue by implementing stricter validation and error handling for user credentials, ensuring that only valid and explicitly defined credentials are used for authentication. This enhancement significantly reduces the risk of unauthorized access and improves the overall security of the FTP connection.","The vulnerability was fixed by enhancing the validation of user credentials in the login process. The code now checks if the user and password are explicitly set before proceeding with the login attempt. If the user is not defined, it defaults to a more secure option rather than using ""anonymous"" without validation. Additionally, the code ensures that the login function handles errors more robustly, logging specific error messages for cases like incorrect login or server refusal. This is achieved through improved error handling in the switch statement that processes the result of the login attempt, ensuring better security and feedback.","The vulnerability was addressed by implementing stricter checks for user credentials before initiating the login process. The code now ensures that valid credentials are provided, reducing reliance on default values that could lead to unauthorized access. Additionally, enhanced error handling was introduced to capture and log specific issues during the login attempt, such as incorrect credentials or server refusals. This approach not only improves security by preventing unauthorized logins but also provides clearer feedback on authentication failures, allowing for better troubleshooting and user awareness of potential issues.","4,4","5,5","5, 4","4,3"
2,2,177839,177839,,Remote,Not required,,CVE-2015-5330,https://www.cvedetails.com/cve/CVE-2015-5330/,CWE-200,Low,Partial,,,2015-12-29,5.0,"ldb before 1.1.24, as used in the AD LDAP server in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3, mishandles string lengths, which allows remote attackers to obtain sensitive information from daemon heap memory by sending crafted packets and then reading (1) an error message or (2) a database value.",2016-12-30,+Info,4,https://git.samba.org/?p=samba.git;a=commit;h=538d305de91e34a2938f5f219f18bf0e1918763f,538d305de91e34a2938f5f219f18bf0e1918763f,,1,,,"_PUBLIC_ codepoint_t next_codepoint_handle_ext(
			struct smb_iconv_handle *ic,
			const char *str, size_t len,
			charset_t src_charset,
			size_t *bytes_consumed)
{
	/* it cannot occupy more than 4 bytes in UTF16 format */
	uint8_t buf[4];
	smb_iconv_t descriptor;
	size_t ilen_orig;
	size_t ilen;
        size_t olen;
        char *outbuf;
 

       if (((str[0] & 0x80) == 0) && (src_charset == CH_DOS ||
                                      src_charset == CH_UNIX ||
                                      src_charset == CH_UTF8)) {
                *bytes_consumed = 1;
                return (codepoint_t)str[0];
        }
	 * This is OK as we only support codepoints up to 1M (U+100000)
	 */
	ilen_orig = MIN(len, 5);
	ilen = ilen_orig;

	descriptor = get_conv_handle(ic, src_charset, CH_UTF16);
	if (descriptor == (smb_iconv_t)-1) {
		*bytes_consumed = 1;
		return INVALID_CODEPOINT;
	}

	/*
	 * this looks a little strange, but it is needed to cope with
	 * codepoints above 64k (U+1000) which are encoded as per RFC2781.
	 */
	olen = 2;
	outbuf = (char *)buf;
	smb_iconv(descriptor, &str, &ilen, &outbuf, &olen);
	if (olen == 2) {
		olen = 4;
		outbuf = (char *)buf;
		smb_iconv(descriptor,  &str, &ilen, &outbuf, &olen);
		if (olen == 4) {
			/* we didn't convert any bytes */
			*bytes_consumed = 1;
			return INVALID_CODEPOINT;
		}
		olen = 4 - olen;
	} else {
		olen = 2 - olen;
	}

	*bytes_consumed = ilen_orig - ilen;

	if (olen == 2) {
		return (codepoint_t)SVAL(buf, 0);
	}
	if (olen == 4) {
		/* decode a 4 byte UTF16 character manually */
		return (codepoint_t)0x10000 +
			(buf[2] | ((buf[3] & 0x3)<<8) |
			 (buf[0]<<10) | ((buf[1] & 0x3)<<18));
	}

	/* no other length is valid */
	return INVALID_CODEPOINT;
}
","_PUBLIC_ codepoint_t next_codepoint_handle_ext(
			struct smb_iconv_handle *ic,
			const char *str, size_t len,
			charset_t src_charset,
			size_t *bytes_consumed)
{
	/* it cannot occupy more than 4 bytes in UTF16 format */
	uint8_t buf[4];
	smb_iconv_t descriptor;
	size_t ilen_orig;
	size_t ilen;
        size_t olen;
        char *outbuf;
 
       if ((str[0] & 0x80) == 0) {
                *bytes_consumed = 1;
                return (codepoint_t)str[0];
        }
	 * This is OK as we only support codepoints up to 1M (U+100000)
	 */
	ilen_orig = MIN(len, 5);
	ilen = ilen_orig;

	descriptor = get_conv_handle(ic, src_charset, CH_UTF16);
	if (descriptor == (smb_iconv_t)-1) {
		*bytes_consumed = 1;
		return INVALID_CODEPOINT;
	}

	/*
	 * this looks a little strange, but it is needed to cope with
	 * codepoints above 64k (U+1000) which are encoded as per RFC2781.
	 */
	olen = 2;
	outbuf = (char *)buf;
	smb_iconv(descriptor, &str, &ilen, &outbuf, &olen);
	if (olen == 2) {
		olen = 4;
		outbuf = (char *)buf;
		smb_iconv(descriptor,  &str, &ilen, &outbuf, &olen);
		if (olen == 4) {
			/* we didn't convert any bytes */
			*bytes_consumed = 1;
			return INVALID_CODEPOINT;
		}
		olen = 4 - olen;
	} else {
		olen = 2 - olen;
	}

	*bytes_consumed = ilen_orig - ilen;

	if (olen == 2) {
		return (codepoint_t)SVAL(buf, 0);
	}
	if (olen == 4) {
		/* decode a 4 byte UTF16 character manually */
		return (codepoint_t)0x10000 +
			(buf[2] | ((buf[3] & 0x3)<<8) |
			 (buf[0]<<10) | ((buf[1] & 0x3)<<18));
	}

	/* no other length is valid */
	return INVALID_CODEPOINT;
}
",C,"
       if (((str[0] & 0x80) == 0) && (src_charset == CH_DOS ||
                                      src_charset == CH_UNIX ||
                                      src_charset == CH_UTF8)) {
","       if ((str[0] & 0x80) == 0) {
",a118d4220ed85749c07fb43c1229d9e2fecbea6b,"@@ -16669,7 +16669,10 @@ _PUBLIC_ codepoint_t next_codepoint_handle_ext(
        size_t olen;
        char *outbuf;
 
-       if ((str[0] & 0x80) == 0) {
+
+       if (((str[0] & 0x80) == 0) && (src_charset == CH_DOS ||
+                                      src_charset == CH_UNIX ||
+                                      src_charset == CH_UTF8)) {
                *bytes_consumed = 1;
                return (codepoint_t)str[0];
        }",samba,https://git.samba.org/?p=samba.git;a=blob;f=lib/util/charset/codepoints.c;h=3d444a6df31902c8dafc762b9b8bfec83ec40da7;hb=3d444a6df31902c8dafc762b9b8bfec83ec40da7,https://git.samba.org/?p=samba.git;a=blob;f=lib/util/charset/codepoints.c;h=99d209ff1c32fa19c59bc3efef1bffad390fc264;hb=99d209ff1c32fa19c59bc3efef1bffad390fc264,1,"_PUBLIC_ codepoint_t next_codepoint_handle_ext(
			struct smb_iconv_handle *ic,
			const char *str, size_t len,
			charset_t src_charset,
			size_t *bytes_consumed)
{
	/* it cannot occupy more than 4 bytes in UTF16 format */
	uint8_t buf[4];
	smb_iconv_t descriptor;
	size_t ilen_orig;
	size_t ilen;
        size_t olen;
        char *outbuf;
 
//flaw_line_below:
       if ((str[0] & 0x80) == 0) {
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//       if (((str[0] & 0x80) == 0) && (src_charset == CH_DOS ||
//fix_flaw_line_below:
//                                      src_charset == CH_UNIX ||
//fix_flaw_line_below:
//                                      src_charset == CH_UTF8)) {
                *bytes_consumed = 1;
                return (codepoint_t)str[0];
        }
	 * This is OK as we only support codepoints up to 1M (U+100000)
	 */
	ilen_orig = MIN(len, 5);
	ilen = ilen_orig;

	descriptor = get_conv_handle(ic, src_charset, CH_UTF16);
	if (descriptor == (smb_iconv_t)-1) {
		*bytes_consumed = 1;
		return INVALID_CODEPOINT;
	}

	/*
	 * this looks a little strange, but it is needed to cope with
	 * codepoints above 64k (U+1000) which are encoded as per RFC2781.
	 */
	olen = 2;
	outbuf = (char *)buf;
	smb_iconv(descriptor, &str, &ilen, &outbuf, &olen);
	if (olen == 2) {
		olen = 4;
		outbuf = (char *)buf;
		smb_iconv(descriptor,  &str, &ilen, &outbuf, &olen);
		if (olen == 4) {
			/* we didn't convert any bytes */
			*bytes_consumed = 1;
			return INVALID_CODEPOINT;
		}
		olen = 4 - olen;
	} else {
		olen = 2 - olen;
	}

	*bytes_consumed = ilen_orig - ilen;

	if (olen == 2) {
		return (codepoint_t)SVAL(buf, 0);
	}
	if (olen == 4) {
		/* decode a 4 byte UTF16 character manually */
		return (codepoint_t)0x10000 +
			(buf[2] | ((buf[3] & 0x3)<<8) |
			 (buf[0]<<10) | ((buf[1] & 0x3)<<18));
	}

	/* no other length is valid */
	return INVALID_CODEPOINT;
}
",177839,"_PUBLIC_ codepoint_t next_codepoint_handle_ext(
			struct smb_iconv_handle *ic,
			const char *str, size_t len,
			charset_t src_charset,
			size_t *bytes_consumed)
{
	/* it cannot occupy more than 4 bytes in UTF16 format */
	uint8_t buf[4];
	smb_iconv_t descriptor;
	size_t ilen_orig;
	size_t ilen;
        size_t olen;
        char *outbuf;
 
       if ((str[0] & 0x80) == 0) {
                *bytes_consumed = 1;
                return (codepoint_t)str[0];
        }
	 * This is OK as we only support codepoints up to 1M (U+100000)
	 */
	ilen_orig = MIN(len, 5);
	ilen = ilen_orig;

	descriptor = get_conv_handle(ic, src_charset, CH_UTF16);
	if (descriptor == (smb_iconv_t)-1) {
		*bytes_consumed = 1;
		return INVALID_CODEPOINT;
	}

	/*
	 * this looks a little strange, but it is needed to cope with
	 * codepoints above 64k (U+1000) which are encoded as per RFC2781.
	 */
	olen = 2;
	outbuf = (char *)buf;
	smb_iconv(descriptor, &str, &ilen, &outbuf, &olen);
	if (olen == 2) {
		olen = 4;
		outbuf = (char *)buf;
		smb_iconv(descriptor,  &str, &ilen, &outbuf, &olen);
		if (olen == 4) {
			/* we didn't convert any bytes */
			*bytes_consumed = 1;
			return INVALID_CODEPOINT;
		}
		olen = 4 - olen;
	} else {
		olen = 2 - olen;
	}

	*bytes_consumed = ilen_orig - ilen;

	if (olen == 2) {
		return (codepoint_t)SVAL(buf, 0);
	}
	if (olen == 4) {
		/* decode a 4 byte UTF16 character manually */
		return (codepoint_t)0x10000 +
			(buf[2] | ((buf[3] & 0x3)<<8) |
			 (buf[0]<<10) | ((buf[1] & 0x3)<<18));
	}

	/* no other length is valid */
	return INVALID_CODEPOINT;
}
","_PUBLIC_ codepoint_t next_codepoint_handle_ext(
			struct smb_iconv_handle *ic,
			const char *str, size_t len,
			charset_t src_charset,
			size_t *bytes_consumed)
{
	/* it cannot occupy more than 4 bytes in UTF16 format */
	uint8_t buf[4];
	smb_iconv_t descriptor;
	size_t ilen_orig;
	size_t ilen;
        size_t olen;
        char *outbuf;
 

       if (((str[0] & 0x80) == 0) && (src_charset == CH_DOS ||
                                      src_charset == CH_UNIX ||
                                      src_charset == CH_UTF8)) {
                *bytes_consumed = 1;
                return (codepoint_t)str[0];
        }
	 * This is OK as we only support codepoints up to 1M (U+100000)
	 */
	ilen_orig = MIN(len, 5);
	ilen = ilen_orig;

	descriptor = get_conv_handle(ic, src_charset, CH_UTF16);
	if (descriptor == (smb_iconv_t)-1) {
		*bytes_consumed = 1;
		return INVALID_CODEPOINT;
	}

	/*
	 * this looks a little strange, but it is needed to cope with
	 * codepoints above 64k (U+1000) which are encoded as per RFC2781.
	 */
	olen = 2;
	outbuf = (char *)buf;
	smb_iconv(descriptor, &str, &ilen, &outbuf, &olen);
	if (olen == 2) {
		olen = 4;
		outbuf = (char *)buf;
		smb_iconv(descriptor,  &str, &ilen, &outbuf, &olen);
		if (olen == 4) {
			/* we didn't convert any bytes */
			*bytes_consumed = 1;
			return INVALID_CODEPOINT;
		}
		olen = 4 - olen;
	} else {
		olen = 2 - olen;
	}

	*bytes_consumed = ilen_orig - ilen;

	if (olen == 2) {
		return (codepoint_t)SVAL(buf, 0);
	}
	if (olen == 4) {
		/* decode a 4 byte UTF16 character manually */
		return (codepoint_t)0x10000 +
			(buf[2] | ((buf[3] & 0x3)<<8) |
			 (buf[0]<<10) | ((buf[1] & 0x3)<<18));
	}

	/* no other length is valid */
	return INVALID_CODEPOINT;
}
","The `next_codepoint_handle_ext` function processes a string to extract the next Unicode codepoint, handling both single-byte and multi-byte UTF-16 encodings. It first checks if the initial character is a single-byte character; if so, it returns that character as a codepoint. For multi-byte characters, it uses a conversion descriptor to decode the input string into a buffer, accommodating characters above U+10000. The function updates the number of bytes consumed and returns the corresponding codepoint or an invalid codepoint if the conversion fails or if the input does not conform to expected lengths.","This function extracts the next Unicode codepoint from a given string, supporting both single-byte and multi-byte UTF-16 encodings. It first checks if the initial character is a single-byte character, returning it directly if so. For multi-byte characters, the function utilizes a conversion mechanism to decode the input into a buffer, accommodating characters beyond the basic multilingual plane. It tracks the number of bytes consumed during the process and returns the corresponding codepoint, or indicates an invalid codepoint if the conversion fails or if the input does not meet expected criteria.","The vulnerability in the original code stemmed from the lack of charset validation when processing single-byte characters, which could lead to incorrect handling of input strings, especially when the source charset was not compatible. The fixed code addresses this by adding a condition that checks if the source charset is either DOS, UNIX, or UTF-8 before returning the single-byte character. This ensures that only valid charsets are processed, preventing potential misuse or unexpected behavior when handling different encodings. Consequently, the code now safely handles single-byte characters while maintaining proper charset validation.","The vulnerability in the original code arose from insufficient validation of the input string's charset when processing single-byte characters, which could lead to incorrect codepoint extraction and potential security issues. The fixed code addresses this by introducing a check to ensure that the source charset is one of the specified valid types before allowing the extraction of a single-byte character. This added validation prevents the function from incorrectly handling unsupported charsets, thereby enhancing the robustness of the code and mitigating risks associated with improper input processing.","The vulnerability was fixed by modifying the condition that checks for single-byte character processing. In the updated code, the check now includes a validation of the `src_charset` to ensure it is either `CH_DOS`, `CH_UNIX`, or `CH_UTF8` before returning the single-byte character. This prevents the function from incorrectly processing unsupported charsets, which could lead to invalid codepoint extraction. By enforcing this charset validation, the code enhances its robustness and security, ensuring that only valid input is handled appropriately, thus mitigating the risk of unexpected behavior or vulnerabilities.","The vulnerability was fixed by adding a validation step that checks the source character set before processing single-byte characters. The updated code ensures that only specific, supported character sets are allowed for single-byte character extraction. This additional check prevents the function from incorrectly handling unsupported or potentially malicious input, which could lead to improper codepoint extraction and security issues. By enforcing this validation, the code now robustly handles input, ensuring that only valid data is processed, thereby reducing the risk of unexpected behavior and enhancing overall security.","4, 4","4,4","4,4","4,4"
3,3,177840,177840,,Remote,Not required,,CVE-2015-5330,https://www.cvedetails.com/cve/CVE-2015-5330/,CWE-200,Low,Partial,,,2015-12-29,5.0,"ldb before 1.1.24, as used in the AD LDAP server in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3, mishandles string lengths, which allows remote attackers to obtain sensitive information from daemon heap memory by sending crafted packets and then reading (1) an error message or (2) a database value.",2016-12-30,+Info,17,https://git.samba.org/?p=samba.git;a=commit;h=7f51ec8c4ed9ba1f53d722e44fb6fb3cde933b72 ,7f51ec8c4ed9ba1f53d722e44fb6fb3cde933b72,,19,,," static int ldb_dn_escape_internal(char *dst, const char *src, int len)
 {
       char c;
        char *d;
       int i;
        d = dst;
 
       for (i = 0; i < len; i++){
               c = src[i];
               switch (c) {
                case ' ':
                       if (i == 0 || i == len - 1) {
                                /* if at the beginning or end
                                 * of the string then escape */
                                *d++ = '\\';
                               *d++ = c;
                        } else {
                                /* otherwise don't escape */
                               *d++ = c;
                        }
                        break;
 
				/* if at the beginning or end
				 * of the string then escape */
				*d++ = '\\';
				*d++ = *p++;					 
			} else {
				/* otherwise don't escape */
				*d++ = *p++;
			}
			break;
                case '?':
                        /* these must be escaped using \c form */
                        *d++ = '\\';
                       *d++ = c;
                        break;
 
               case ';':
               case '\r':
               case '\n':
               case '=':
               case '\0': {
                        /* any others get \XX form */
                        unsigned char v;
                        const char *hexbytes = ""0123456789ABCDEF"";
                       v = (const unsigned char)c;
                        *d++ = '\\';
                        *d++ = hexbytes[v>>4];
                        *d++ = hexbytes[v&0xF];
                        break;
                }
               default:
                       *d++ = c;
                }
        }
"," static int ldb_dn_escape_internal(char *dst, const char *src, int len)
 {
       const char *p, *s;
        char *d;
       size_t l;
       p = s = src;
        d = dst;
 
       while (p - src < len) {
               p += strcspn(p, "",=\n\r+<>#;\\\"" "");
               if (p - src == len) /* found no escapable chars */
                       break;
               /* copy the part of the string before the stop */
               memcpy(d, s, p - s);
               d += (p - s); /* move to current position */
               switch (*p) {
                case ' ':
                       if (p == src || (p-src)==(len-1)) {
                                /* if at the beginning or end
                                 * of the string then escape */
                                *d++ = '\\';
                               *d++ = *p++;                                     
                        } else {
                                /* otherwise don't escape */
                               *d++ = *p++;
                        }
                        break;
 
				/* if at the beginning or end
				 * of the string then escape */
				*d++ = '\\';
				*d++ = *p++;					 
			} else {
				/* otherwise don't escape */
				*d++ = *p++;
			}
			break;
                case '?':
                        /* these must be escaped using \c form */
                        *d++ = '\\';
                       *d++ = *p++;
                        break;
 
               default: {
                        /* any others get \XX form */
                        unsigned char v;
                        const char *hexbytes = ""0123456789ABCDEF"";
                       v = *(const unsigned char *)p;
                        *d++ = '\\';
                        *d++ = hexbytes[v>>4];
                        *d++ = hexbytes[v&0xF];
                       p++;
                        break;
                }
                }
               s = p; /* move forward */
        }
",C,"       char c;
       int i;
       for (i = 0; i < len; i++){
               c = src[i];
               switch (c) {
                       if (i == 0 || i == len - 1) {
                               *d++ = c;
                               *d++ = c;
                       *d++ = c;
               case ';':
               case '\r':
               case '\n':
               case '=':
               case '\0': {
                       v = (const unsigned char)c;
               default:
                       *d++ = c;
","       const char *p, *s;
       size_t l;
       p = s = src;
       while (p - src < len) {
               p += strcspn(p, "",=\n\r+<>#;\\\"" "");
               if (p - src == len) /* found no escapable chars */
                       break;
               /* copy the part of the string before the stop */
               memcpy(d, s, p - s);
               d += (p - s); /* move to current position */
               switch (*p) {
                       if (p == src || (p-src)==(len-1)) {
                               *d++ = *p++;                                     
                               *d++ = *p++;
                       *d++ = *p++;
               default: {
                       v = *(const unsigned char *)p;
                       p++;
               s = p; /* move forward */
",aa6c27148b9d3f8c1e4fdd5dd46bfecbbd0ca465,"@@ -189,33 +189,23 @@ struct ldb_dn *ldb_dn_new_fmt(TALLOC_CTX *mem_ctx,
 /* see RFC2253 section 2.4 */
 static int ldb_dn_escape_internal(char *dst, const char *src, int len)
 {
-       const char *p, *s;
+       char c;
        char *d;
-       size_t l;
-
-       p = s = src;
+       int i;
        d = dst;
 
-       while (p - src < len) {
-               p += strcspn(p, "",=\n\r+<>#;\\\"" "");
-
-               if (p - src == len) /* found no escapable chars */
-                       break;
-
-               /* copy the part of the string before the stop */
-               memcpy(d, s, p - s);
-               d += (p - s); /* move to current position */
-               
-               switch (*p) {
+       for (i = 0; i < len; i++){
+               c = src[i];
+               switch (c) {
                case ' ':
-                       if (p == src || (p-src)==(len-1)) {
+                       if (i == 0 || i == len - 1) {
                                /* if at the beginning or end
                                 * of the string then escape */
                                *d++ = '\\';
-                               *d++ = *p++;                                     
+                               *d++ = c;
                        } else {
                                /* otherwise don't escape */
-                               *d++ = *p++;
+                               *d++ = c;
                        }
                        break;
 
@@ -231,30 +221,30 @@ static int ldb_dn_escape_internal(char *dst, const char *src, int len)
                case '?':
                        /* these must be escaped using \c form */
                        *d++ = '\\';
-                       *d++ = *p++;
+                       *d++ = c;
                        break;
 
-               default: {
+               case ';':
+               case '\r':
+               case '\n':
+               case '=':
+               case '\0': {
                        /* any others get \XX form */
                        unsigned char v;
                        const char *hexbytes = ""0123456789ABCDEF"";
-                       v = *(const unsigned char *)p;
+                       v = (const unsigned char)c;
                        *d++ = '\\';
                        *d++ = hexbytes[v>>4];
                        *d++ = hexbytes[v&0xF];
-                       p++;
                        break;
                }
+               default:
+                       *d++ = c;
                }
-               s = p; /* move forward */
        }
 
-       /* copy the last part (with zero) and return */
-       l = len - (s - src);
-       memcpy(d, s, l + 1);
-
        /* return the length of the resulting string */
-       return (l + (d - dst));
+       return (d - dst);
 }
 
 char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)",samba,https://git.samba.org/?p=samba.git;a=blob;f=lib/ldb/common/ldb_dn.c;h=d39eb8caec1b208f269d20f97512eed875165fd7;hb=d39eb8caec1b208f269d20f97512eed875165fd7,https://git.samba.org/?p=samba.git;a=blob;f=lib/ldb/common/ldb_dn.c;h=85f89c1b06daf70ec77306158863dba9942e6b7a;hb=85f89c1b06daf70ec77306158863dba9942e6b7a,1," static int ldb_dn_escape_internal(char *dst, const char *src, int len)
 {
//flaw_line_below:
       const char *p, *s;
//fix_flaw_line_below:
//       char c;
        char *d;
//flaw_line_below:
       size_t l;
//flaw_line_below:

//flaw_line_below:
       p = s = src;
//fix_flaw_line_below:
//       int i;
        d = dst;
 
//flaw_line_below:
       while (p - src < len) {
//flaw_line_below:
               p += strcspn(p, "",=\n\r+<>#;\\\"" "");
//flaw_line_below:

//flaw_line_below:
               if (p - src == len) /* found no escapable chars */
//flaw_line_below:
                       break;
//flaw_line_below:

//flaw_line_below:
               /* copy the part of the string before the stop */
//flaw_line_below:
               memcpy(d, s, p - s);
//flaw_line_below:
               d += (p - s); /* move to current position */
//flaw_line_below:
               
//flaw_line_below:
               switch (*p) {
//fix_flaw_line_below:
//       for (i = 0; i < len; i++){
//fix_flaw_line_below:
//               c = src[i];
//fix_flaw_line_below:
//               switch (c) {
                case ' ':
//flaw_line_below:
                       if (p == src || (p-src)==(len-1)) {
//fix_flaw_line_below:
//                       if (i == 0 || i == len - 1) {
                                /* if at the beginning or end
                                 * of the string then escape */
                                *d++ = '\\';
//flaw_line_below:
                               *d++ = *p++;                                     
//fix_flaw_line_below:
//                               *d++ = c;
                        } else {
                                /* otherwise don't escape */
//flaw_line_below:
                               *d++ = *p++;
//fix_flaw_line_below:
//                               *d++ = c;
                        }
                        break;
 
				/* if at the beginning or end
				 * of the string then escape */
				*d++ = '\\';
				*d++ = *p++;					 
			} else {
				/* otherwise don't escape */
				*d++ = *p++;
			}
			break;
                case '?':
                        /* these must be escaped using \c form */
                        *d++ = '\\';
//flaw_line_below:
                       *d++ = *p++;
//fix_flaw_line_below:
//                       *d++ = c;
                        break;
 
//flaw_line_below:
               default: {
//fix_flaw_line_below:
//               case ';':
//fix_flaw_line_below:
//               case '\r':
//fix_flaw_line_below:
//               case '\n':
//fix_flaw_line_below:
//               case '=':
//fix_flaw_line_below:
//               case '\0': {
                        /* any others get \XX form */
                        unsigned char v;
                        const char *hexbytes = ""0123456789ABCDEF"";
//flaw_line_below:
                       v = *(const unsigned char *)p;
//fix_flaw_line_below:
//                       v = (const unsigned char)c;
                        *d++ = '\\';
                        *d++ = hexbytes[v>>4];
                        *d++ = hexbytes[v&0xF];
//flaw_line_below:
                       p++;
                        break;
                }
//fix_flaw_line_below:
//               default:
//fix_flaw_line_below:
//                       *d++ = c;
                }
//flaw_line_below:
               s = p; /* move forward */
        }
",177840," static int ldb_dn_escape_internal(char *dst, const char *src, int len)
 {
       const char *p, *s;
        char *d;
       size_t l;
       p = s = src;
        d = dst;
 
       while (p - src < len) {
               p += strcspn(p, "",=\n\r+<>#;\\\"" "");
               if (p - src == len) /* found no escapable chars */
                       break;
               /* copy the part of the string before the stop */
               memcpy(d, s, p - s);
               d += (p - s); /* move to current position */
               switch (*p) {
                case ' ':
                       if (p == src || (p-src)==(len-1)) {
                                /* if at the beginning or end
                                 * of the string then escape */
                                *d++ = '\\';
                               *d++ = *p++;                                     
                        } else {
                                /* otherwise don't escape */
                               *d++ = *p++;
                        }
                        break;
 
				/* if at the beginning or end
				 * of the string then escape */
				*d++ = '\\';
				*d++ = *p++;					 
			} else {
				/* otherwise don't escape */
				*d++ = *p++;
			}
			break;
                case '?':
                        /* these must be escaped using \c form */
                        *d++ = '\\';
                       *d++ = *p++;
                        break;
 
               default: {
                        /* any others get \XX form */
                        unsigned char v;
                        const char *hexbytes = ""0123456789ABCDEF"";
                       v = *(const unsigned char *)p;
                        *d++ = '\\';
                        *d++ = hexbytes[v>>4];
                        *d++ = hexbytes[v&0xF];
                       p++;
                        break;
                }
                }
               s = p; /* move forward */
        }
"," static int ldb_dn_escape_internal(char *dst, const char *src, int len)
 {
       char c;
        char *d;
       int i;
        d = dst;
 
       for (i = 0; i < len; i++){
               c = src[i];
               switch (c) {
                case ' ':
                       if (i == 0 || i == len - 1) {
                                /* if at the beginning or end
                                 * of the string then escape */
                                *d++ = '\\';
                               *d++ = c;
                        } else {
                                /* otherwise don't escape */
                               *d++ = c;
                        }
                        break;
 
				/* if at the beginning or end
				 * of the string then escape */
				*d++ = '\\';
				*d++ = *p++;					 
			} else {
				/* otherwise don't escape */
				*d++ = *p++;
			}
			break;
                case '?':
                        /* these must be escaped using \c form */
                        *d++ = '\\';
                       *d++ = c;
                        break;
 
               case ';':
               case '\r':
               case '\n':
               case '=':
               case '\0': {
                        /* any others get \XX form */
                        unsigned char v;
                        const char *hexbytes = ""0123456789ABCDEF"";
                       v = (const unsigned char)c;
                        *d++ = '\\';
                        *d++ = hexbytes[v>>4];
                        *d++ = hexbytes[v&0xF];
                        break;
                }
               default:
                       *d++ = c;
                }
        }
","The `ldb_dn_escape_internal` function processes a source string (`src`) and copies it to a destination string (`dst`), escaping specific characters based on defined rules. It iterates through the source string up to a specified length (`len`), identifying characters that require escaping, such as spaces, question marks, and others. If a character is at the beginning or end of the string, it is prefixed with a backslash. For other characters, it uses a hexadecimal representation. The function ensures that the destination string is properly constructed with escaped characters while maintaining the original content where no escaping is needed.","The provided code processes a source string to create a modified version in a destination string, where certain characters are escaped according to specific rules. It scans through the source string, identifying characters that need to be escaped, such as spaces and question marks, and handles them differently based on their position in the string. Characters at the beginning or end are prefixed with a backslash, while others are converted to a hexadecimal format. The function ensures that the output string retains the original content while appropriately escaping designated characters to prevent misinterpretation.","The vulnerability in the original code arises from improper handling of character escaping, particularly with the use of pointer arithmetic and the potential for buffer overflows. The original implementation relied on pointer manipulation, which could lead to accessing out-of-bounds memory if the source string contained unexpected characters. In the fixed code, the logic was simplified by using a loop with an index variable to directly access characters in the source string, ensuring that all characters are processed safely within the specified length. This change mitigates the risk of buffer overflows and improves overall code clarity and safety.","The vulnerability in the original code stems from improper handling of character escaping, which could lead to buffer overflows and memory access violations due to reliance on pointer arithmetic. This approach allowed for potential out-of-bounds access when processing the source string, especially if it contained unexpected characters. The fixed code addresses this issue by implementing a more straightforward loop that uses an index to access characters directly, ensuring that all operations remain within the bounds of the specified length. This change enhances safety by preventing out-of-bounds memory access and improving the overall clarity of the code.","The vulnerability was fixed by replacing the pointer arithmetic with a straightforward loop that uses an index variable to iterate through the source string. In the updated code, the loop iterates using an index variable, ensuring that each character is accessed safely within the specified length. This eliminates the risk of accessing out-of-bounds memory, as the index is constrained by the loop condition. Additionally, the handling of characters is simplified, with each character processed directly, allowing for clearer logic in escaping specific characters like spaces and question marks, thus enhancing the overall safety and reliability of the function.","The vulnerability was fixed by restructuring the code to eliminate reliance on pointer arithmetic, which could lead to out-of-bounds memory access. Instead, a loop was introduced that uses an index to directly access each character in the source string, ensuring that all operations remain within the defined length. This approach not only prevents potential buffer overflows but also simplifies the logic for character processing and escaping. By clearly defining how each character is handled based on its position, the revised code enhances safety and clarity, reducing the risk of unintended memory access issues.","4, 5","4,4","4,4","4, 4"
4,4,177841,177841,,Remote,Not required,,CVE-2015-5330,https://www.cvedetails.com/cve/CVE-2015-5330/,CWE-200,Low,Partial,,,2015-12-29,5.0,"ldb before 1.1.24, as used in the AD LDAP server in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3, mishandles string lengths, which allows remote attackers to obtain sensitive information from daemon heap memory by sending crafted packets and then reading (1) an error message or (2) a database value.",2016-12-30,+Info,2,https://git.samba.org/?p=samba.git;a=commit;h=a118d4220ed85749c07fb43c1229d9e2fecbea6b,a118d4220ed85749c07fb43c1229d9e2fecbea6b,,1,,,"_PUBLIC_ char *strupper_talloc_n_handle(struct smb_iconv_handle *iconv_handle,
					TALLOC_CTX *ctx, const char *src, size_t n)
{
	size_t size=0;
	char *dest;

	if (!src) {
		return NULL;
	}

	/* this takes advantage of the fact that upper/lower can't
	   change the length of a character by more than 1 byte */
	dest = talloc_array(ctx, char, 2*(n+1));
	if (dest == NULL) {
                return NULL;
        }
 
       while (n && *src) {
                size_t c_size;
                codepoint_t c = next_codepoint_handle_ext(iconv_handle, src, n,
                                                          CH_UNIX, &c_size);
                src += c_size;
               n -= c_size;
 
                c = toupper_m(c);
		if (c_size == -1) {
			talloc_free(dest);
			return NULL;
		}
		size += c_size;
	}

	dest[size] = 0;

	/* trim it so talloc_append_string() works */
	dest = talloc_realloc(ctx, dest, char, size+1);

	talloc_set_name_const(dest, dest);

	return dest;
}
","_PUBLIC_ char *strupper_talloc_n_handle(struct smb_iconv_handle *iconv_handle,
					TALLOC_CTX *ctx, const char *src, size_t n)
{
	size_t size=0;
	char *dest;

	if (!src) {
		return NULL;
	}

	/* this takes advantage of the fact that upper/lower can't
	   change the length of a character by more than 1 byte */
	dest = talloc_array(ctx, char, 2*(n+1));
	if (dest == NULL) {
                return NULL;
        }
 
       while (n-- && *src) {
                size_t c_size;
                codepoint_t c = next_codepoint_handle_ext(iconv_handle, src, n,
                                                          CH_UNIX, &c_size);
                src += c_size;
 
                c = toupper_m(c);
		if (c_size == -1) {
			talloc_free(dest);
			return NULL;
		}
		size += c_size;
	}

	dest[size] = 0;

	/* trim it so talloc_append_string() works */
	dest = talloc_realloc(ctx, dest, char, size+1);

	talloc_set_name_const(dest, dest);

	return dest;
}
",C,"       while (n && *src) {
               n -= c_size;
","       while (n-- && *src) {
",ba5dbda6d0174a59d221c45cca52ecd232820d48,"@@ -110,11 +110,12 @@ _PUBLIC_ char *strupper_talloc_n_handle(struct smb_iconv_handle *iconv_handle,
                return NULL;
        }
 
-       while (n-- && *src) {
+       while (n && *src) {
                size_t c_size;
                codepoint_t c = next_codepoint_handle_ext(iconv_handle, src, n,
                                                          CH_UNIX, &c_size);
                src += c_size;
+               n -= c_size;
 
                c = toupper_m(c);",samba,https://git.samba.org/?p=samba.git;a=blob;f=lib/util/charset/util_unistr.c;h=2cc87186daecbb3c421f1cef37b43d2a66e41cca;hb=2cc87186daecbb3c421f1cef37b43d2a66e41cca,https://git.samba.org/?p=samba.git;a=blob;f=lib/util/charset/util_unistr.c;h=f2992695f65e78a1c2fbbe96d0f63b1593ee912d;hb=f2992695f65e78a1c2fbbe96d0f63b1593ee912d,1,"_PUBLIC_ char *strupper_talloc_n_handle(struct smb_iconv_handle *iconv_handle,
					TALLOC_CTX *ctx, const char *src, size_t n)
{
	size_t size=0;
	char *dest;

	if (!src) {
		return NULL;
	}

	/* this takes advantage of the fact that upper/lower can't
	   change the length of a character by more than 1 byte */
	dest = talloc_array(ctx, char, 2*(n+1));
	if (dest == NULL) {
                return NULL;
        }
 
//flaw_line_below:
       while (n-- && *src) {
//fix_flaw_line_below:
//       while (n && *src) {
                size_t c_size;
                codepoint_t c = next_codepoint_handle_ext(iconv_handle, src, n,
                                                          CH_UNIX, &c_size);
                src += c_size;
//fix_flaw_line_below:
//               n -= c_size;
 
                c = toupper_m(c);
		if (c_size == -1) {
			talloc_free(dest);
			return NULL;
		}
		size += c_size;
	}

	dest[size] = 0;

	/* trim it so talloc_append_string() works */
	dest = talloc_realloc(ctx, dest, char, size+1);

	talloc_set_name_const(dest, dest);

	return dest;
}
",177841,"_PUBLIC_ char *strupper_talloc_n_handle(struct smb_iconv_handle *iconv_handle,
					TALLOC_CTX *ctx, const char *src, size_t n)
{
	size_t size=0;
	char *dest;

	if (!src) {
		return NULL;
	}

	/* this takes advantage of the fact that upper/lower can't
	   change the length of a character by more than 1 byte */
	dest = talloc_array(ctx, char, 2*(n+1));
	if (dest == NULL) {
                return NULL;
        }
 
       while (n-- && *src) {
                size_t c_size;
                codepoint_t c = next_codepoint_handle_ext(iconv_handle, src, n,
                                                          CH_UNIX, &c_size);
                src += c_size;
 
                c = toupper_m(c);
		if (c_size == -1) {
			talloc_free(dest);
			return NULL;
		}
		size += c_size;
	}

	dest[size] = 0;

	/* trim it so talloc_append_string() works */
	dest = talloc_realloc(ctx, dest, char, size+1);

	talloc_set_name_const(dest, dest);

	return dest;
}
","_PUBLIC_ char *strupper_talloc_n_handle(struct smb_iconv_handle *iconv_handle,
					TALLOC_CTX *ctx, const char *src, size_t n)
{
	size_t size=0;
	char *dest;

	if (!src) {
		return NULL;
	}

	/* this takes advantage of the fact that upper/lower can't
	   change the length of a character by more than 1 byte */
	dest = talloc_array(ctx, char, 2*(n+1));
	if (dest == NULL) {
                return NULL;
        }
 
       while (n && *src) {
                size_t c_size;
                codepoint_t c = next_codepoint_handle_ext(iconv_handle, src, n,
                                                          CH_UNIX, &c_size);
                src += c_size;
               n -= c_size;
 
                c = toupper_m(c);
		if (c_size == -1) {
			talloc_free(dest);
			return NULL;
		}
		size += c_size;
	}

	dest[size] = 0;

	/* trim it so talloc_append_string() works */
	dest = talloc_realloc(ctx, dest, char, size+1);

	talloc_set_name_const(dest, dest);

	return dest;
}
","The provided code defines a function `strupper_talloc_n_handle` that converts a given string (`src`) to uppercase, utilizing a specified character encoding handle (`iconv_handle`) and a memory context (`ctx`). It first checks if the input string is null, returning null if so. The function allocates memory for the destination string, ensuring it can accommodate the uppercase conversion. It processes each character in the source string, converting it to uppercase while handling potential encoding issues. Finally, it trims the allocated memory to the actual size used and returns the newly created uppercase string.","The code defines a function that converts a specified portion of a string to uppercase while managing character encoding and memory allocation. It begins by checking if the input string is null, returning null if it is. The function allocates sufficient memory for the uppercase string, ensuring it can handle potential character size variations. It processes each character, converting it to uppercase and checking for encoding errors. After processing, it adjusts the allocated memory to fit the actual size of the resulting string and returns the newly created uppercase string, ensuring proper memory management throughout the process.","The vulnerability in the original code arises from the incorrect handling of the loop condition, which could lead to an infinite loop if the input string contains characters that are not properly processed, as the decrement of `n` was missing. This oversight could result in excessive memory allocation or buffer overflows. In the fixed code, the loop condition was modified to ensure that `n` is decremented by the size of the processed character (`c_size`) during each iteration. This change ensures that the loop terminates correctly, preventing potential infinite loops and improving the overall safety and reliability of the function.","The vulnerability in the original code stemmed from improper handling of the loop condition, which could lead to an infinite loop if the input string contained characters that were not processed correctly. This oversight risked excessive memory allocation and potential buffer overflows. In the revised code, the loop was adjusted to ensure that the remaining character count was decremented appropriately after each character was processed. This modification guarantees that the loop terminates as expected, thereby enhancing the function's safety and reliability by preventing infinite loops and ensuring proper memory management throughout the execution.","The vulnerability was fixed by modifying the loop condition to correctly decrement the remaining character count after processing each character. In the original code, the loop continued as long as `n` was non-zero, which could lead to an infinite loop if the character processing did not consume any characters. In the updated code, `n` is decremented by `c_size` after each call to `next_codepoint_handle_ext`, ensuring that the loop terminates correctly when all characters are processed. This change prevents potential infinite loops and ensures that memory is managed safely throughout the function's execution.","The vulnerability was addressed by ensuring that the loop correctly updates the count of remaining characters after each character is processed. In the original implementation, the loop could continue indefinitely if the character processing did not consume any characters, leading to potential memory issues. The fix involved adjusting the loop logic to decrement the remaining character count appropriately after each iteration. This change guarantees that the loop will terminate as expected, thereby preventing infinite loops and enhancing the overall safety and reliability of the function by ensuring proper memory management throughout its execution.","4,4","5,5","4,4","4,5"
5,5,177845,177845,,Remote,Not required,,CVE-2015-5330,https://www.cvedetails.com/cve/CVE-2015-5330/,CWE-200,Low,Partial,,,2015-12-29,5.0,"ldb before 1.1.24, as used in the AD LDAP server in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3, mishandles string lengths, which allows remote attackers to obtain sensitive information from daemon heap memory by sending crafted packets and then reading (1) an error message or (2) a database value.",2016-12-30,+Info,4,https://git.samba.org/?p=samba.git;a=commit;h=f36cb71c330a52106e36028b3029d952257baf15,f36cb71c330a52106e36028b3029d952257baf15,,1,,,"static bool ldb_dn_explode(struct ldb_dn *dn)
{
	char *p, *ex_name = NULL, *ex_value = NULL, *data, *d, *dt, *t;
	bool trim = true;
	bool in_extended = true;
	bool in_ex_name = false;
	bool in_ex_value = false;
	bool in_attr = false;
	bool in_value = false;
	bool in_quote = false;
	bool is_oid = false;
	bool escape = false;
	unsigned int x;
	size_t l = 0;
	int ret;
	char *parse_dn;
	bool is_index;

	if ( ! dn || dn->invalid) return false;

	if (dn->components) {
		return true;
	}

	if (dn->ext_linearized) {
		parse_dn = dn->ext_linearized;
	} else {
		parse_dn = dn->linearized;
	}

	if ( ! parse_dn ) {
		return false;
	}

	is_index = (strncmp(parse_dn, ""DN=@INDEX:"", 10) == 0);

	/* Empty DNs */
	if (parse_dn[0] == '\0') {
		return true;
	}

	/* Special DNs case */
	if (dn->special) {
		return true;
	}

	/* make sure we free this if allocated previously before replacing */
	LDB_FREE(dn->components);
	dn->comp_num = 0;

	LDB_FREE(dn->ext_components);
	dn->ext_comp_num = 0;

	/* in the common case we have 3 or more components */
	/* make sure all components are zeroed, other functions depend on it */
	dn->components = talloc_zero_array(dn, struct ldb_dn_component, 3);
	if ( ! dn->components) {
		return false;
	}

	/* Components data space is allocated here once */
	data = talloc_array(dn->components, char, strlen(parse_dn) + 1);
	if (!data) {
		return false;
	}

	p = parse_dn;
	t = NULL;
	d = dt = data;

	while (*p) {
		if (in_extended) {

			if (!in_ex_name && !in_ex_value) {

				if (p[0] == '<') {
					p++;
					ex_name = d;
					in_ex_name = true;
					continue;
				} else if (p[0] == '\0') {
					p++;
					continue;
				} else {
					in_extended = false;
					in_attr = true;
					dt = d;

					continue;
				}
			}

			if (in_ex_name && *p == '=') {
				*d++ = '\0';
				p++;
				ex_value = d;
				in_ex_name = false;
				in_ex_value = true;
				continue;
			}

			if (in_ex_value && *p == '>') {
				const struct ldb_dn_extended_syntax *ext_syntax;
				struct ldb_val ex_val = {
					.data = (uint8_t *)ex_value,
					.length = d - ex_value
				};

				*d++ = '\0';
				p++;
				in_ex_value = false;

				/* Process name and ex_value */

				dn->ext_components = talloc_realloc(dn,
								    dn->ext_components,
								    struct ldb_dn_ext_component,
								    dn->ext_comp_num + 1);
				if ( ! dn->ext_components) {
					/* ouch ! */
					goto failed;
				}

				ext_syntax = ldb_dn_extended_syntax_by_name(dn->ldb, ex_name);
				if (!ext_syntax) {
					/* We don't know about this type of extended DN */
					goto failed;
				}

				dn->ext_components[dn->ext_comp_num].name = talloc_strdup(dn->ext_components, ex_name);
				if (!dn->ext_components[dn->ext_comp_num].name) {
					/* ouch */
					goto failed;
				}
				ret = ext_syntax->read_fn(dn->ldb, dn->ext_components,
							  &ex_val, &dn->ext_components[dn->ext_comp_num].value);
				if (ret != LDB_SUCCESS) {
					ldb_dn_mark_invalid(dn);
					goto failed;
				}

				dn->ext_comp_num++;

				if (*p == '\0') {
					/* We have reached the end (extended component only)! */
					talloc_free(data);
					return true;

				} else if (*p == ';') {
					p++;
					continue;
				} else {
					ldb_dn_mark_invalid(dn);
					goto failed;
				}
			}

			*d++ = *p++;
			continue;
		}
		if (in_attr) {
			if (trim) {
				if (*p == ' ') {
					p++;
					continue;
				}

				/* first char */
				trim = false;

				if (!isascii(*p)) {
					/* attr names must be ascii only */
					ldb_dn_mark_invalid(dn);
					goto failed;
				}

				if (isdigit(*p)) {
					is_oid = true;
				} else
				if ( ! isalpha(*p)) {
					/* not a digit nor an alpha,
 					 * invalid attribute name */
					ldb_dn_mark_invalid(dn);
					goto failed;
				}

				/* Copy this character across from parse_dn,
				 * now we have trimmed out spaces */
				*d++ = *p++;
				continue;
			}

			if (*p == ' ') {
				p++;
				/* valid only if we are at the end */
				trim = true;
				continue;
			}

			if (trim && (*p != '=')) {
				/* spaces/tabs are not allowed */
				ldb_dn_mark_invalid(dn);
				goto failed;
			}

			if (*p == '=') {
				/* attribute terminated */
				in_attr = false;
				in_value = true;
				trim = true;
				l = 0;

				/* Terminate this string in d
				 * (which is a copy of parse_dn
				 *  with spaces trimmed) */
				*d++ = '\0';
				dn->components[dn->comp_num].name = talloc_strdup(dn->components, dt);
				if ( ! dn->components[dn->comp_num].name) {
					/* ouch */
					goto failed;
				}

				dt = d;

				p++;
				continue;
			}

			if (!isascii(*p)) {
				/* attr names must be ascii only */
				ldb_dn_mark_invalid(dn);
				goto failed;
			}

			if (is_oid && ( ! (isdigit(*p) || (*p == '.')))) {
				/* not a digit nor a dot,
				 * invalid attribute oid */
				ldb_dn_mark_invalid(dn);
				goto failed;
			} else
			if ( ! (isalpha(*p) || isdigit(*p) || (*p == '-'))) {
				/* not ALPHA, DIGIT or HYPHEN */
				ldb_dn_mark_invalid(dn);
				goto failed;
			}

			*d++ = *p++;
			continue;
		}

		if (in_value) {
			if (in_quote) {
				if (*p == '\""') {
					if (p[-1] != '\\') {
						p++;
						in_quote = false;
						continue;
					}
				}
				*d++ = *p++;
				l++;
				continue;
			}

			if (trim) {
				if (*p == ' ') {
					p++;
					continue;
				}

				/* first char */
				trim = false;

				if (*p == '\""') {
					in_quote = true;
					p++;
					continue;
				}
			}

			switch (*p) {

			/* TODO: support ber encoded values
			case '#':
			*/

			case ',':
				if (escape) {
					*d++ = *p++;
					l++;
					escape = false;
					continue;
				}
				/* ok found value terminator */

				if ( t ) {
					/* trim back */
					d -= (p - t);
					l -= (p - t);
				}

				in_attr = true;
				in_value = false;
				trim = true;
 
                                p++;
                                *d++ = '\0';
                               dn->components[dn->comp_num].value.data = \
                                       (uint8_t *)talloc_memdup(dn->components, dt, l + 1);
                                dn->components[dn->comp_num].value.length = l;
                                if ( ! dn->components[dn->comp_num].value.data) {
                                        /* ouch ! */
                                        goto failed;
                                }
                               talloc_set_name_const(dn->components[dn->comp_num].value.data,
                                                     (const char *)dn->components[dn->comp_num].value.data);
 
                                dt = d;
 
									dn->components,
									struct ldb_dn_component,
									dn->comp_num + 1);
					if ( ! dn->components) {
						/* ouch ! */
						goto failed;
					}
					/* make sure all components are zeroed, other functions depend on this */
					memset(&dn->components[dn->comp_num], '\0', sizeof(struct ldb_dn_component));
				}

				continue;

			case '+':
			case '=':
				/* to main compatibility with earlier
				versions of ldb indexing, we have to
				accept the base64 encoded binary index
				values, which contain a '+' or '='
				which should normally be escaped */
				if (is_index) {
					if ( t ) t = NULL;
					*d++ = *p++;
					l++;
					break;
				}
				/* fall through */
			case '\""':
			case '<':
			case '>':
			case ';':
				/* a string with not escaped specials is invalid (tested) */
				if ( ! escape) {
					ldb_dn_mark_invalid(dn);
					goto failed;
				}
				escape = false;

				*d++ = *p++;
				l++;

				if ( t ) t = NULL;
				break;

			case '\\':
				if ( ! escape) {
					escape = true;
					p++;
					continue;
				}
				escape = false;

				*d++ = *p++;
				l++;

				if ( t ) t = NULL;
				break;

			default:
				if (escape) {
					if (isxdigit(p[0]) && isxdigit(p[1])) {
						if (sscanf(p, ""%02x"", &x) != 1) {
							/* invalid escaping sequence */
							ldb_dn_mark_invalid(dn);
							goto failed;
						}
						p += 2;
						*d++ = (unsigned char)x;
					} else {
						*d++ = *p++;
					}

					escape = false;
					l++;
					if ( t ) t = NULL;
					break;
				}

				if (*p == ' ') {
					if ( ! t) t = p;
				} else {
					if ( t ) t = NULL;
				}

				*d++ = *p++;
				l++;

				break;
			}

		}
	}
","static bool ldb_dn_explode(struct ldb_dn *dn)
{
	char *p, *ex_name = NULL, *ex_value = NULL, *data, *d, *dt, *t;
	bool trim = true;
	bool in_extended = true;
	bool in_ex_name = false;
	bool in_ex_value = false;
	bool in_attr = false;
	bool in_value = false;
	bool in_quote = false;
	bool is_oid = false;
	bool escape = false;
	unsigned int x;
	size_t l = 0;
	int ret;
	char *parse_dn;
	bool is_index;

	if ( ! dn || dn->invalid) return false;

	if (dn->components) {
		return true;
	}

	if (dn->ext_linearized) {
		parse_dn = dn->ext_linearized;
	} else {
		parse_dn = dn->linearized;
	}

	if ( ! parse_dn ) {
		return false;
	}

	is_index = (strncmp(parse_dn, ""DN=@INDEX:"", 10) == 0);

	/* Empty DNs */
	if (parse_dn[0] == '\0') {
		return true;
	}

	/* Special DNs case */
	if (dn->special) {
		return true;
	}

	/* make sure we free this if allocated previously before replacing */
	LDB_FREE(dn->components);
	dn->comp_num = 0;

	LDB_FREE(dn->ext_components);
	dn->ext_comp_num = 0;

	/* in the common case we have 3 or more components */
	/* make sure all components are zeroed, other functions depend on it */
	dn->components = talloc_zero_array(dn, struct ldb_dn_component, 3);
	if ( ! dn->components) {
		return false;
	}

	/* Components data space is allocated here once */
	data = talloc_array(dn->components, char, strlen(parse_dn) + 1);
	if (!data) {
		return false;
	}

	p = parse_dn;
	t = NULL;
	d = dt = data;

	while (*p) {
		if (in_extended) {

			if (!in_ex_name && !in_ex_value) {

				if (p[0] == '<') {
					p++;
					ex_name = d;
					in_ex_name = true;
					continue;
				} else if (p[0] == '\0') {
					p++;
					continue;
				} else {
					in_extended = false;
					in_attr = true;
					dt = d;

					continue;
				}
			}

			if (in_ex_name && *p == '=') {
				*d++ = '\0';
				p++;
				ex_value = d;
				in_ex_name = false;
				in_ex_value = true;
				continue;
			}

			if (in_ex_value && *p == '>') {
				const struct ldb_dn_extended_syntax *ext_syntax;
				struct ldb_val ex_val = {
					.data = (uint8_t *)ex_value,
					.length = d - ex_value
				};

				*d++ = '\0';
				p++;
				in_ex_value = false;

				/* Process name and ex_value */

				dn->ext_components = talloc_realloc(dn,
								    dn->ext_components,
								    struct ldb_dn_ext_component,
								    dn->ext_comp_num + 1);
				if ( ! dn->ext_components) {
					/* ouch ! */
					goto failed;
				}

				ext_syntax = ldb_dn_extended_syntax_by_name(dn->ldb, ex_name);
				if (!ext_syntax) {
					/* We don't know about this type of extended DN */
					goto failed;
				}

				dn->ext_components[dn->ext_comp_num].name = talloc_strdup(dn->ext_components, ex_name);
				if (!dn->ext_components[dn->ext_comp_num].name) {
					/* ouch */
					goto failed;
				}
				ret = ext_syntax->read_fn(dn->ldb, dn->ext_components,
							  &ex_val, &dn->ext_components[dn->ext_comp_num].value);
				if (ret != LDB_SUCCESS) {
					ldb_dn_mark_invalid(dn);
					goto failed;
				}

				dn->ext_comp_num++;

				if (*p == '\0') {
					/* We have reached the end (extended component only)! */
					talloc_free(data);
					return true;

				} else if (*p == ';') {
					p++;
					continue;
				} else {
					ldb_dn_mark_invalid(dn);
					goto failed;
				}
			}

			*d++ = *p++;
			continue;
		}
		if (in_attr) {
			if (trim) {
				if (*p == ' ') {
					p++;
					continue;
				}

				/* first char */
				trim = false;

				if (!isascii(*p)) {
					/* attr names must be ascii only */
					ldb_dn_mark_invalid(dn);
					goto failed;
				}

				if (isdigit(*p)) {
					is_oid = true;
				} else
				if ( ! isalpha(*p)) {
					/* not a digit nor an alpha,
 					 * invalid attribute name */
					ldb_dn_mark_invalid(dn);
					goto failed;
				}

				/* Copy this character across from parse_dn,
				 * now we have trimmed out spaces */
				*d++ = *p++;
				continue;
			}

			if (*p == ' ') {
				p++;
				/* valid only if we are at the end */
				trim = true;
				continue;
			}

			if (trim && (*p != '=')) {
				/* spaces/tabs are not allowed */
				ldb_dn_mark_invalid(dn);
				goto failed;
			}

			if (*p == '=') {
				/* attribute terminated */
				in_attr = false;
				in_value = true;
				trim = true;
				l = 0;

				/* Terminate this string in d
				 * (which is a copy of parse_dn
				 *  with spaces trimmed) */
				*d++ = '\0';
				dn->components[dn->comp_num].name = talloc_strdup(dn->components, dt);
				if ( ! dn->components[dn->comp_num].name) {
					/* ouch */
					goto failed;
				}

				dt = d;

				p++;
				continue;
			}

			if (!isascii(*p)) {
				/* attr names must be ascii only */
				ldb_dn_mark_invalid(dn);
				goto failed;
			}

			if (is_oid && ( ! (isdigit(*p) || (*p == '.')))) {
				/* not a digit nor a dot,
				 * invalid attribute oid */
				ldb_dn_mark_invalid(dn);
				goto failed;
			} else
			if ( ! (isalpha(*p) || isdigit(*p) || (*p == '-'))) {
				/* not ALPHA, DIGIT or HYPHEN */
				ldb_dn_mark_invalid(dn);
				goto failed;
			}

			*d++ = *p++;
			continue;
		}

		if (in_value) {
			if (in_quote) {
				if (*p == '\""') {
					if (p[-1] != '\\') {
						p++;
						in_quote = false;
						continue;
					}
				}
				*d++ = *p++;
				l++;
				continue;
			}

			if (trim) {
				if (*p == ' ') {
					p++;
					continue;
				}

				/* first char */
				trim = false;

				if (*p == '\""') {
					in_quote = true;
					p++;
					continue;
				}
			}

			switch (*p) {

			/* TODO: support ber encoded values
			case '#':
			*/

			case ',':
				if (escape) {
					*d++ = *p++;
					l++;
					escape = false;
					continue;
				}
				/* ok found value terminator */

				if ( t ) {
					/* trim back */
					d -= (p - t);
					l -= (p - t);
				}

				in_attr = true;
				in_value = false;
				trim = true;
 
                                p++;
                                *d++ = '\0';
                               dn->components[dn->comp_num].value.data = (uint8_t *)talloc_strdup(dn->components, dt);
                                dn->components[dn->comp_num].value.length = l;
                                if ( ! dn->components[dn->comp_num].value.data) {
                                        /* ouch ! */
                                        goto failed;
                                }
 
                                dt = d;
 
									dn->components,
									struct ldb_dn_component,
									dn->comp_num + 1);
					if ( ! dn->components) {
						/* ouch ! */
						goto failed;
					}
					/* make sure all components are zeroed, other functions depend on this */
					memset(&dn->components[dn->comp_num], '\0', sizeof(struct ldb_dn_component));
				}

				continue;

			case '+':
			case '=':
				/* to main compatibility with earlier
				versions of ldb indexing, we have to
				accept the base64 encoded binary index
				values, which contain a '+' or '='
				which should normally be escaped */
				if (is_index) {
					if ( t ) t = NULL;
					*d++ = *p++;
					l++;
					break;
				}
				/* fall through */
			case '\""':
			case '<':
			case '>':
			case ';':
				/* a string with not escaped specials is invalid (tested) */
				if ( ! escape) {
					ldb_dn_mark_invalid(dn);
					goto failed;
				}
				escape = false;

				*d++ = *p++;
				l++;

				if ( t ) t = NULL;
				break;

			case '\\':
				if ( ! escape) {
					escape = true;
					p++;
					continue;
				}
				escape = false;

				*d++ = *p++;
				l++;

				if ( t ) t = NULL;
				break;

			default:
				if (escape) {
					if (isxdigit(p[0]) && isxdigit(p[1])) {
						if (sscanf(p, ""%02x"", &x) != 1) {
							/* invalid escaping sequence */
							ldb_dn_mark_invalid(dn);
							goto failed;
						}
						p += 2;
						*d++ = (unsigned char)x;
					} else {
						*d++ = *p++;
					}

					escape = false;
					l++;
					if ( t ) t = NULL;
					break;
				}

				if (*p == ' ') {
					if ( ! t) t = p;
				} else {
					if ( t ) t = NULL;
				}

				*d++ = *p++;
				l++;

				break;
			}

		}
	}
",C,"                               dn->components[dn->comp_num].value.data = \
                                       (uint8_t *)talloc_memdup(dn->components, dt, l + 1);
                               talloc_set_name_const(dn->components[dn->comp_num].value.data,
                                                     (const char *)dn->components[dn->comp_num].value.data);
","                               dn->components[dn->comp_num].value.data = (uint8_t *)talloc_strdup(dn->components, dt);
",538d305de91e34a2938f5f219f18bf0e1918763f,"@@ -586,12 +586,15 @@ static bool ldb_dn_explode(struct ldb_dn *dn)
 
                                p++;
                                *d++ = '\0';
-                               dn->components[dn->comp_num].value.data = (uint8_t *)talloc_strdup(dn->components, dt);
+                               dn->components[dn->comp_num].value.data = \
+                                       (uint8_t *)talloc_memdup(dn->components, dt, l + 1);
                                dn->components[dn->comp_num].value.length = l;
                                if ( ! dn->components[dn->comp_num].value.data) {
                                        /* ouch ! */
                                        goto failed;
                                }
+                               talloc_set_name_const(dn->components[dn->comp_num].value.data,
+                                                     (const char *)dn->components[dn->comp_num].value.data);
 
                                dt = d;
 
@@ -707,11 +710,13 @@ static bool ldb_dn_explode(struct ldb_dn *dn)
        *d++ = '\0';
        dn->components[dn->comp_num].value.length = l;
        dn->components[dn->comp_num].value.data =
-                               (uint8_t *)talloc_strdup(dn->components, dt);
+               (uint8_t *)talloc_memdup(dn->components, dt, l + 1);
        if ( ! dn->components[dn->comp_num].value.data) {
                /* ouch */
                goto failed;
        }
+       talloc_set_name_const(dn->components[dn->comp_num].value.data,
+                             (const char *)dn->components[dn->comp_num].value.data);
 
        dn->comp_num++;",samba,https://git.samba.org/?p=samba.git;a=blob;f=lib/ldb/common/ldb_dn.c;h=dfd3b5844cf04dedd7555017ec158c2ab7f0f1b5;hb=dfd3b5844cf04dedd7555017ec158c2ab7f0f1b5,https://git.samba.org/?p=samba.git;a=blob;f=lib/ldb/common/ldb_dn.c;h=6f9903e3e65de68b9624ffb19cd09f02cdbf3225;hb=6f9903e3e65de68b9624ffb19cd09f02cdbf3225,1,"static bool ldb_dn_explode(struct ldb_dn *dn)
{
	char *p, *ex_name = NULL, *ex_value = NULL, *data, *d, *dt, *t;
	bool trim = true;
	bool in_extended = true;
	bool in_ex_name = false;
	bool in_ex_value = false;
	bool in_attr = false;
	bool in_value = false;
	bool in_quote = false;
	bool is_oid = false;
	bool escape = false;
	unsigned int x;
	size_t l = 0;
	int ret;
	char *parse_dn;
	bool is_index;

	if ( ! dn || dn->invalid) return false;

	if (dn->components) {
		return true;
	}

	if (dn->ext_linearized) {
		parse_dn = dn->ext_linearized;
	} else {
		parse_dn = dn->linearized;
	}

	if ( ! parse_dn ) {
		return false;
	}

	is_index = (strncmp(parse_dn, ""DN=@INDEX:"", 10) == 0);

	/* Empty DNs */
	if (parse_dn[0] == '\0') {
		return true;
	}

	/* Special DNs case */
	if (dn->special) {
		return true;
	}

	/* make sure we free this if allocated previously before replacing */
	LDB_FREE(dn->components);
	dn->comp_num = 0;

	LDB_FREE(dn->ext_components);
	dn->ext_comp_num = 0;

	/* in the common case we have 3 or more components */
	/* make sure all components are zeroed, other functions depend on it */
	dn->components = talloc_zero_array(dn, struct ldb_dn_component, 3);
	if ( ! dn->components) {
		return false;
	}

	/* Components data space is allocated here once */
	data = talloc_array(dn->components, char, strlen(parse_dn) + 1);
	if (!data) {
		return false;
	}

	p = parse_dn;
	t = NULL;
	d = dt = data;

	while (*p) {
		if (in_extended) {

			if (!in_ex_name && !in_ex_value) {

				if (p[0] == '<') {
					p++;
					ex_name = d;
					in_ex_name = true;
					continue;
				} else if (p[0] == '\0') {
					p++;
					continue;
				} else {
					in_extended = false;
					in_attr = true;
					dt = d;

					continue;
				}
			}

			if (in_ex_name && *p == '=') {
				*d++ = '\0';
				p++;
				ex_value = d;
				in_ex_name = false;
				in_ex_value = true;
				continue;
			}

			if (in_ex_value && *p == '>') {
				const struct ldb_dn_extended_syntax *ext_syntax;
				struct ldb_val ex_val = {
					.data = (uint8_t *)ex_value,
					.length = d - ex_value
				};

				*d++ = '\0';
				p++;
				in_ex_value = false;

				/* Process name and ex_value */

				dn->ext_components = talloc_realloc(dn,
								    dn->ext_components,
								    struct ldb_dn_ext_component,
								    dn->ext_comp_num + 1);
				if ( ! dn->ext_components) {
					/* ouch ! */
					goto failed;
				}

				ext_syntax = ldb_dn_extended_syntax_by_name(dn->ldb, ex_name);
				if (!ext_syntax) {
					/* We don't know about this type of extended DN */
					goto failed;
				}

				dn->ext_components[dn->ext_comp_num].name = talloc_strdup(dn->ext_components, ex_name);
				if (!dn->ext_components[dn->ext_comp_num].name) {
					/* ouch */
					goto failed;
				}
				ret = ext_syntax->read_fn(dn->ldb, dn->ext_components,
							  &ex_val, &dn->ext_components[dn->ext_comp_num].value);
				if (ret != LDB_SUCCESS) {
					ldb_dn_mark_invalid(dn);
					goto failed;
				}

				dn->ext_comp_num++;

				if (*p == '\0') {
					/* We have reached the end (extended component only)! */
					talloc_free(data);
					return true;

				} else if (*p == ';') {
					p++;
					continue;
				} else {
					ldb_dn_mark_invalid(dn);
					goto failed;
				}
			}

			*d++ = *p++;
			continue;
		}
		if (in_attr) {
			if (trim) {
				if (*p == ' ') {
					p++;
					continue;
				}

				/* first char */
				trim = false;

				if (!isascii(*p)) {
					/* attr names must be ascii only */
					ldb_dn_mark_invalid(dn);
					goto failed;
				}

				if (isdigit(*p)) {
					is_oid = true;
				} else
				if ( ! isalpha(*p)) {
					/* not a digit nor an alpha,
 					 * invalid attribute name */
					ldb_dn_mark_invalid(dn);
					goto failed;
				}

				/* Copy this character across from parse_dn,
				 * now we have trimmed out spaces */
				*d++ = *p++;
				continue;
			}

			if (*p == ' ') {
				p++;
				/* valid only if we are at the end */
				trim = true;
				continue;
			}

			if (trim && (*p != '=')) {
				/* spaces/tabs are not allowed */
				ldb_dn_mark_invalid(dn);
				goto failed;
			}

			if (*p == '=') {
				/* attribute terminated */
				in_attr = false;
				in_value = true;
				trim = true;
				l = 0;

				/* Terminate this string in d
				 * (which is a copy of parse_dn
				 *  with spaces trimmed) */
				*d++ = '\0';
				dn->components[dn->comp_num].name = talloc_strdup(dn->components, dt);
				if ( ! dn->components[dn->comp_num].name) {
					/* ouch */
					goto failed;
				}

				dt = d;

				p++;
				continue;
			}

			if (!isascii(*p)) {
				/* attr names must be ascii only */
				ldb_dn_mark_invalid(dn);
				goto failed;
			}

			if (is_oid && ( ! (isdigit(*p) || (*p == '.')))) {
				/* not a digit nor a dot,
				 * invalid attribute oid */
				ldb_dn_mark_invalid(dn);
				goto failed;
			} else
			if ( ! (isalpha(*p) || isdigit(*p) || (*p == '-'))) {
				/* not ALPHA, DIGIT or HYPHEN */
				ldb_dn_mark_invalid(dn);
				goto failed;
			}

			*d++ = *p++;
			continue;
		}

		if (in_value) {
			if (in_quote) {
				if (*p == '\""') {
					if (p[-1] != '\\') {
						p++;
						in_quote = false;
						continue;
					}
				}
				*d++ = *p++;
				l++;
				continue;
			}

			if (trim) {
				if (*p == ' ') {
					p++;
					continue;
				}

				/* first char */
				trim = false;

				if (*p == '\""') {
					in_quote = true;
					p++;
					continue;
				}
			}

			switch (*p) {

			/* TODO: support ber encoded values
			case '#':
			*/

			case ',':
				if (escape) {
					*d++ = *p++;
					l++;
					escape = false;
					continue;
				}
				/* ok found value terminator */

				if ( t ) {
					/* trim back */
					d -= (p - t);
					l -= (p - t);
				}

				in_attr = true;
				in_value = false;
				trim = true;
 
                                p++;
                                *d++ = '\0';
//flaw_line_below:
                               dn->components[dn->comp_num].value.data = (uint8_t *)talloc_strdup(dn->components, dt);
//fix_flaw_line_below:
//                               dn->components[dn->comp_num].value.data = \
//fix_flaw_line_below:
//                                       (uint8_t *)talloc_memdup(dn->components, dt, l + 1);
                                dn->components[dn->comp_num].value.length = l;
                                if ( ! dn->components[dn->comp_num].value.data) {
                                        /* ouch ! */
                                        goto failed;
                                }
//fix_flaw_line_below:
//                               talloc_set_name_const(dn->components[dn->comp_num].value.data,
//fix_flaw_line_below:
//                                                     (const char *)dn->components[dn->comp_num].value.data);
 
                                dt = d;
 
									dn->components,
									struct ldb_dn_component,
									dn->comp_num + 1);
					if ( ! dn->components) {
						/* ouch ! */
						goto failed;
					}
					/* make sure all components are zeroed, other functions depend on this */
					memset(&dn->components[dn->comp_num], '\0', sizeof(struct ldb_dn_component));
				}

				continue;

			case '+':
			case '=':
				/* to main compatibility with earlier
				versions of ldb indexing, we have to
				accept the base64 encoded binary index
				values, which contain a '+' or '='
				which should normally be escaped */
				if (is_index) {
					if ( t ) t = NULL;
					*d++ = *p++;
					l++;
					break;
				}
				/* fall through */
			case '\""':
			case '<':
			case '>':
			case ';':
				/* a string with not escaped specials is invalid (tested) */
				if ( ! escape) {
					ldb_dn_mark_invalid(dn);
					goto failed;
				}
				escape = false;

				*d++ = *p++;
				l++;

				if ( t ) t = NULL;
				break;

			case '\\':
				if ( ! escape) {
					escape = true;
					p++;
					continue;
				}
				escape = false;

				*d++ = *p++;
				l++;

				if ( t ) t = NULL;
				break;

			default:
				if (escape) {
					if (isxdigit(p[0]) && isxdigit(p[1])) {
						if (sscanf(p, ""%02x"", &x) != 1) {
							/* invalid escaping sequence */
							ldb_dn_mark_invalid(dn);
							goto failed;
						}
						p += 2;
						*d++ = (unsigned char)x;
					} else {
						*d++ = *p++;
					}

					escape = false;
					l++;
					if ( t ) t = NULL;
					break;
				}

				if (*p == ' ') {
					if ( ! t) t = p;
				} else {
					if ( t ) t = NULL;
				}

				*d++ = *p++;
				l++;

				break;
			}

		}
	}
",177845,"static bool ldb_dn_explode(struct ldb_dn *dn)
{
	char *p, *ex_name = NULL, *ex_value = NULL, *data, *d, *dt, *t;
	bool trim = true;
	bool in_extended = true;
	bool in_ex_name = false;
	bool in_ex_value = false;
	bool in_attr = false;
	bool in_value = false;
	bool in_quote = false;
	bool is_oid = false;
	bool escape = false;
	unsigned int x;
	size_t l = 0;
	int ret;
	char *parse_dn;
	bool is_index;

	if ( ! dn || dn->invalid) return false;

	if (dn->components) {
		return true;
	}

	if (dn->ext_linearized) {
		parse_dn = dn->ext_linearized;
	} else {
		parse_dn = dn->linearized;
	}

	if ( ! parse_dn ) {
		return false;
	}

	is_index = (strncmp(parse_dn, ""DN=@INDEX:"", 10) == 0);

	/* Empty DNs */
	if (parse_dn[0] == '\0') {
		return true;
	}

	/* Special DNs case */
	if (dn->special) {
		return true;
	}

	/* make sure we free this if allocated previously before replacing */
	LDB_FREE(dn->components);
	dn->comp_num = 0;

	LDB_FREE(dn->ext_components);
	dn->ext_comp_num = 0;

	/* in the common case we have 3 or more components */
	/* make sure all components are zeroed, other functions depend on it */
	dn->components = talloc_zero_array(dn, struct ldb_dn_component, 3);
	if ( ! dn->components) {
		return false;
	}

	/* Components data space is allocated here once */
	data = talloc_array(dn->components, char, strlen(parse_dn) + 1);
	if (!data) {
		return false;
	}

	p = parse_dn;
	t = NULL;
	d = dt = data;

	while (*p) {
		if (in_extended) {

			if (!in_ex_name && !in_ex_value) {

				if (p[0] == '<') {
					p++;
					ex_name = d;
					in_ex_name = true;
					continue;
				} else if (p[0] == '\0') {
					p++;
					continue;
				} else {
					in_extended = false;
					in_attr = true;
					dt = d;

					continue;
				}
			}

			if (in_ex_name && *p == '=') {
				*d++ = '\0';
				p++;
				ex_value = d;
				in_ex_name = false;
				in_ex_value = true;
				continue;
			}

			if (in_ex_value && *p == '>') {
				const struct ldb_dn_extended_syntax *ext_syntax;
				struct ldb_val ex_val = {
					.data = (uint8_t *)ex_value,
					.length = d - ex_value
				};

				*d++ = '\0';
				p++;
				in_ex_value = false;

				/* Process name and ex_value */

				dn->ext_components = talloc_realloc(dn,
								    dn->ext_components,
								    struct ldb_dn_ext_component,
								    dn->ext_comp_num + 1);
				if ( ! dn->ext_components) {
					/* ouch ! */
					goto failed;
				}

				ext_syntax = ldb_dn_extended_syntax_by_name(dn->ldb, ex_name);
				if (!ext_syntax) {
					/* We don't know about this type of extended DN */
					goto failed;
				}

				dn->ext_components[dn->ext_comp_num].name = talloc_strdup(dn->ext_components, ex_name);
				if (!dn->ext_components[dn->ext_comp_num].name) {
					/* ouch */
					goto failed;
				}
				ret = ext_syntax->read_fn(dn->ldb, dn->ext_components,
							  &ex_val, &dn->ext_components[dn->ext_comp_num].value);
				if (ret != LDB_SUCCESS) {
					ldb_dn_mark_invalid(dn);
					goto failed;
				}

				dn->ext_comp_num++;

				if (*p == '\0') {
					/* We have reached the end (extended component only)! */
					talloc_free(data);
					return true;

				} else if (*p == ';') {
					p++;
					continue;
				} else {
					ldb_dn_mark_invalid(dn);
					goto failed;
				}
			}

			*d++ = *p++;
			continue;
		}
		if (in_attr) {
			if (trim) {
				if (*p == ' ') {
					p++;
					continue;
				}

				/* first char */
				trim = false;

				if (!isascii(*p)) {
					/* attr names must be ascii only */
					ldb_dn_mark_invalid(dn);
					goto failed;
				}

				if (isdigit(*p)) {
					is_oid = true;
				} else
				if ( ! isalpha(*p)) {
					/* not a digit nor an alpha,
 					 * invalid attribute name */
					ldb_dn_mark_invalid(dn);
					goto failed;
				}

				/* Copy this character across from parse_dn,
				 * now we have trimmed out spaces */
				*d++ = *p++;
				continue;
			}

			if (*p == ' ') {
				p++;
				/* valid only if we are at the end */
				trim = true;
				continue;
			}

			if (trim && (*p != '=')) {
				/* spaces/tabs are not allowed */
				ldb_dn_mark_invalid(dn);
				goto failed;
			}

			if (*p == '=') {
				/* attribute terminated */
				in_attr = false;
				in_value = true;
				trim = true;
				l = 0;

				/* Terminate this string in d
				 * (which is a copy of parse_dn
				 *  with spaces trimmed) */
				*d++ = '\0';
				dn->components[dn->comp_num].name = talloc_strdup(dn->components, dt);
				if ( ! dn->components[dn->comp_num].name) {
					/* ouch */
					goto failed;
				}

				dt = d;

				p++;
				continue;
			}

			if (!isascii(*p)) {
				/* attr names must be ascii only */
				ldb_dn_mark_invalid(dn);
				goto failed;
			}

			if (is_oid && ( ! (isdigit(*p) || (*p == '.')))) {
				/* not a digit nor a dot,
				 * invalid attribute oid */
				ldb_dn_mark_invalid(dn);
				goto failed;
			} else
			if ( ! (isalpha(*p) || isdigit(*p) || (*p == '-'))) {
				/* not ALPHA, DIGIT or HYPHEN */
				ldb_dn_mark_invalid(dn);
				goto failed;
			}

			*d++ = *p++;
			continue;
		}

		if (in_value) {
			if (in_quote) {
				if (*p == '\""') {
					if (p[-1] != '\\') {
						p++;
						in_quote = false;
						continue;
					}
				}
				*d++ = *p++;
				l++;
				continue;
			}

			if (trim) {
				if (*p == ' ') {
					p++;
					continue;
				}

				/* first char */
				trim = false;

				if (*p == '\""') {
					in_quote = true;
					p++;
					continue;
				}
			}

			switch (*p) {

			/* TODO: support ber encoded values
			case '#':
			*/

			case ',':
				if (escape) {
					*d++ = *p++;
					l++;
					escape = false;
					continue;
				}
				/* ok found value terminator */

				if ( t ) {
					/* trim back */
					d -= (p - t);
					l -= (p - t);
				}

				in_attr = true;
				in_value = false;
				trim = true;
 
                                p++;
                                *d++ = '\0';
                               dn->components[dn->comp_num].value.data = (uint8_t *)talloc_strdup(dn->components, dt);
                                dn->components[dn->comp_num].value.length = l;
                                if ( ! dn->components[dn->comp_num].value.data) {
                                        /* ouch ! */
                                        goto failed;
                                }
 
                                dt = d;
 
									dn->components,
									struct ldb_dn_component,
									dn->comp_num + 1);
					if ( ! dn->components) {
						/* ouch ! */
						goto failed;
					}
					/* make sure all components are zeroed, other functions depend on this */
					memset(&dn->components[dn->comp_num], '\0', sizeof(struct ldb_dn_component));
				}

				continue;

			case '+':
			case '=':
				/* to main compatibility with earlier
				versions of ldb indexing, we have to
				accept the base64 encoded binary index
				values, which contain a '+' or '='
				which should normally be escaped */
				if (is_index) {
					if ( t ) t = NULL;
					*d++ = *p++;
					l++;
					break;
				}
				/* fall through */
			case '\""':
			case '<':
			case '>':
			case ';':
				/* a string with not escaped specials is invalid (tested) */
				if ( ! escape) {
					ldb_dn_mark_invalid(dn);
					goto failed;
				}
				escape = false;

				*d++ = *p++;
				l++;

				if ( t ) t = NULL;
				break;

			case '\\':
				if ( ! escape) {
					escape = true;
					p++;
					continue;
				}
				escape = false;

				*d++ = *p++;
				l++;

				if ( t ) t = NULL;
				break;

			default:
				if (escape) {
					if (isxdigit(p[0]) && isxdigit(p[1])) {
						if (sscanf(p, ""%02x"", &x) != 1) {
							/* invalid escaping sequence */
							ldb_dn_mark_invalid(dn);
							goto failed;
						}
						p += 2;
						*d++ = (unsigned char)x;
					} else {
						*d++ = *p++;
					}

					escape = false;
					l++;
					if ( t ) t = NULL;
					break;
				}

				if (*p == ' ') {
					if ( ! t) t = p;
				} else {
					if ( t ) t = NULL;
				}

				*d++ = *p++;
				l++;

				break;
			}

		}
	}
","static bool ldb_dn_explode(struct ldb_dn *dn)
{
	char *p, *ex_name = NULL, *ex_value = NULL, *data, *d, *dt, *t;
	bool trim = true;
	bool in_extended = true;
	bool in_ex_name = false;
	bool in_ex_value = false;
	bool in_attr = false;
	bool in_value = false;
	bool in_quote = false;
	bool is_oid = false;
	bool escape = false;
	unsigned int x;
	size_t l = 0;
	int ret;
	char *parse_dn;
	bool is_index;

	if ( ! dn || dn->invalid) return false;

	if (dn->components) {
		return true;
	}

	if (dn->ext_linearized) {
		parse_dn = dn->ext_linearized;
	} else {
		parse_dn = dn->linearized;
	}

	if ( ! parse_dn ) {
		return false;
	}

	is_index = (strncmp(parse_dn, ""DN=@INDEX:"", 10) == 0);

	/* Empty DNs */
	if (parse_dn[0] == '\0') {
		return true;
	}

	/* Special DNs case */
	if (dn->special) {
		return true;
	}

	/* make sure we free this if allocated previously before replacing */
	LDB_FREE(dn->components);
	dn->comp_num = 0;

	LDB_FREE(dn->ext_components);
	dn->ext_comp_num = 0;

	/* in the common case we have 3 or more components */
	/* make sure all components are zeroed, other functions depend on it */
	dn->components = talloc_zero_array(dn, struct ldb_dn_component, 3);
	if ( ! dn->components) {
		return false;
	}

	/* Components data space is allocated here once */
	data = talloc_array(dn->components, char, strlen(parse_dn) + 1);
	if (!data) {
		return false;
	}

	p = parse_dn;
	t = NULL;
	d = dt = data;

	while (*p) {
		if (in_extended) {

			if (!in_ex_name && !in_ex_value) {

				if (p[0] == '<') {
					p++;
					ex_name = d;
					in_ex_name = true;
					continue;
				} else if (p[0] == '\0') {
					p++;
					continue;
				} else {
					in_extended = false;
					in_attr = true;
					dt = d;

					continue;
				}
			}

			if (in_ex_name && *p == '=') {
				*d++ = '\0';
				p++;
				ex_value = d;
				in_ex_name = false;
				in_ex_value = true;
				continue;
			}

			if (in_ex_value && *p == '>') {
				const struct ldb_dn_extended_syntax *ext_syntax;
				struct ldb_val ex_val = {
					.data = (uint8_t *)ex_value,
					.length = d - ex_value
				};

				*d++ = '\0';
				p++;
				in_ex_value = false;

				/* Process name and ex_value */

				dn->ext_components = talloc_realloc(dn,
								    dn->ext_components,
								    struct ldb_dn_ext_component,
								    dn->ext_comp_num + 1);
				if ( ! dn->ext_components) {
					/* ouch ! */
					goto failed;
				}

				ext_syntax = ldb_dn_extended_syntax_by_name(dn->ldb, ex_name);
				if (!ext_syntax) {
					/* We don't know about this type of extended DN */
					goto failed;
				}

				dn->ext_components[dn->ext_comp_num].name = talloc_strdup(dn->ext_components, ex_name);
				if (!dn->ext_components[dn->ext_comp_num].name) {
					/* ouch */
					goto failed;
				}
				ret = ext_syntax->read_fn(dn->ldb, dn->ext_components,
							  &ex_val, &dn->ext_components[dn->ext_comp_num].value);
				if (ret != LDB_SUCCESS) {
					ldb_dn_mark_invalid(dn);
					goto failed;
				}

				dn->ext_comp_num++;

				if (*p == '\0') {
					/* We have reached the end (extended component only)! */
					talloc_free(data);
					return true;

				} else if (*p == ';') {
					p++;
					continue;
				} else {
					ldb_dn_mark_invalid(dn);
					goto failed;
				}
			}

			*d++ = *p++;
			continue;
		}
		if (in_attr) {
			if (trim) {
				if (*p == ' ') {
					p++;
					continue;
				}

				/* first char */
				trim = false;

				if (!isascii(*p)) {
					/* attr names must be ascii only */
					ldb_dn_mark_invalid(dn);
					goto failed;
				}

				if (isdigit(*p)) {
					is_oid = true;
				} else
				if ( ! isalpha(*p)) {
					/* not a digit nor an alpha,
 					 * invalid attribute name */
					ldb_dn_mark_invalid(dn);
					goto failed;
				}

				/* Copy this character across from parse_dn,
				 * now we have trimmed out spaces */
				*d++ = *p++;
				continue;
			}

			if (*p == ' ') {
				p++;
				/* valid only if we are at the end */
				trim = true;
				continue;
			}

			if (trim && (*p != '=')) {
				/* spaces/tabs are not allowed */
				ldb_dn_mark_invalid(dn);
				goto failed;
			}

			if (*p == '=') {
				/* attribute terminated */
				in_attr = false;
				in_value = true;
				trim = true;
				l = 0;

				/* Terminate this string in d
				 * (which is a copy of parse_dn
				 *  with spaces trimmed) */
				*d++ = '\0';
				dn->components[dn->comp_num].name = talloc_strdup(dn->components, dt);
				if ( ! dn->components[dn->comp_num].name) {
					/* ouch */
					goto failed;
				}

				dt = d;

				p++;
				continue;
			}

			if (!isascii(*p)) {
				/* attr names must be ascii only */
				ldb_dn_mark_invalid(dn);
				goto failed;
			}

			if (is_oid && ( ! (isdigit(*p) || (*p == '.')))) {
				/* not a digit nor a dot,
				 * invalid attribute oid */
				ldb_dn_mark_invalid(dn);
				goto failed;
			} else
			if ( ! (isalpha(*p) || isdigit(*p) || (*p == '-'))) {
				/* not ALPHA, DIGIT or HYPHEN */
				ldb_dn_mark_invalid(dn);
				goto failed;
			}

			*d++ = *p++;
			continue;
		}

		if (in_value) {
			if (in_quote) {
				if (*p == '\""') {
					if (p[-1] != '\\') {
						p++;
						in_quote = false;
						continue;
					}
				}
				*d++ = *p++;
				l++;
				continue;
			}

			if (trim) {
				if (*p == ' ') {
					p++;
					continue;
				}

				/* first char */
				trim = false;

				if (*p == '\""') {
					in_quote = true;
					p++;
					continue;
				}
			}

			switch (*p) {

			/* TODO: support ber encoded values
			case '#':
			*/

			case ',':
				if (escape) {
					*d++ = *p++;
					l++;
					escape = false;
					continue;
				}
				/* ok found value terminator */

				if ( t ) {
					/* trim back */
					d -= (p - t);
					l -= (p - t);
				}

				in_attr = true;
				in_value = false;
				trim = true;
 
                                p++;
                                *d++ = '\0';
                               dn->components[dn->comp_num].value.data = \
                                       (uint8_t *)talloc_memdup(dn->components, dt, l + 1);
                                dn->components[dn->comp_num].value.length = l;
                                if ( ! dn->components[dn->comp_num].value.data) {
                                        /* ouch ! */
                                        goto failed;
                                }
                               talloc_set_name_const(dn->components[dn->comp_num].value.data,
                                                     (const char *)dn->components[dn->comp_num].value.data);
 
                                dt = d;
 
									dn->components,
									struct ldb_dn_component,
									dn->comp_num + 1);
					if ( ! dn->components) {
						/* ouch ! */
						goto failed;
					}
					/* make sure all components are zeroed, other functions depend on this */
					memset(&dn->components[dn->comp_num], '\0', sizeof(struct ldb_dn_component));
				}

				continue;

			case '+':
			case '=':
				/* to main compatibility with earlier
				versions of ldb indexing, we have to
				accept the base64 encoded binary index
				values, which contain a '+' or '='
				which should normally be escaped */
				if (is_index) {
					if ( t ) t = NULL;
					*d++ = *p++;
					l++;
					break;
				}
				/* fall through */
			case '\""':
			case '<':
			case '>':
			case ';':
				/* a string with not escaped specials is invalid (tested) */
				if ( ! escape) {
					ldb_dn_mark_invalid(dn);
					goto failed;
				}
				escape = false;

				*d++ = *p++;
				l++;

				if ( t ) t = NULL;
				break;

			case '\\':
				if ( ! escape) {
					escape = true;
					p++;
					continue;
				}
				escape = false;

				*d++ = *p++;
				l++;

				if ( t ) t = NULL;
				break;

			default:
				if (escape) {
					if (isxdigit(p[0]) && isxdigit(p[1])) {
						if (sscanf(p, ""%02x"", &x) != 1) {
							/* invalid escaping sequence */
							ldb_dn_mark_invalid(dn);
							goto failed;
						}
						p += 2;
						*d++ = (unsigned char)x;
					} else {
						*d++ = *p++;
					}

					escape = false;
					l++;
					if ( t ) t = NULL;
					break;
				}

				if (*p == ' ') {
					if ( ! t) t = p;
				} else {
					if ( t ) t = NULL;
				}

				*d++ = *p++;
				l++;

				break;
			}

		}
	}
","The `ldb_dn_explode` function processes a distinguished name (DN) structure, parsing its components from a linearized string representation. It begins by validating the input DN and checking for existing components. If the DN is empty or marked as special, it returns early. The function allocates memory for components and iteratively parses the DN string, identifying attributes and values while handling extended syntax and various formatting rules, such as trimming spaces and managing quotes. It populates the DN structure with parsed components, marking the DN as invalid if any parsing errors occur, and ultimately returns a boolean indicating success or failure.","The provided code defines a function that parses a distinguished name from a string representation, extracting its components into a structured format. It begins by validating the input and checking for existing components, returning early if certain conditions are met. The function allocates memory for the components and processes the string character by character, identifying attributes and their corresponding values while adhering to specific formatting rules. It handles special cases, such as extended syntax and whitespace trimming, and marks the structure as invalid if any errors occur during parsing, ultimately returning a success or failure status.","The vulnerability in the original code arises from improper handling of memory allocation and potential buffer overflows when parsing distinguished names. Specifically, the code did not ensure that the allocated memory for component values was sufficient, which could lead to writing beyond allocated bounds if the input was larger than expected. In the fixed code, the allocation for component values is improved by using a function that duplicates the memory with the correct length, ensuring that the allocated space is adequate. Additionally, the code now sets a name for the allocated memory, enhancing memory management and tracking, which helps prevent memory-related vulnerabilities.","The vulnerability in the original code stemmed from inadequate memory management during the parsing process, which could lead to buffer overflows when handling input data. This oversight allowed for the possibility of writing beyond allocated memory boundaries, potentially causing crashes or security breaches. The fixed code addressed this issue by implementing a more robust memory allocation strategy that ensures sufficient space is allocated for component values based on their actual length. Additionally, the updated code includes mechanisms for better tracking and managing allocated memory, thereby enhancing overall stability and security against memory-related vulnerabilities.","The vulnerability was fixed by replacing the original memory allocation for component values with a safer approach using the `talloc_memdup` function, which duplicates the memory while ensuring the correct length is allocated based on the parsed data. This change prevents buffer overflows by guaranteeing that the allocated space is sufficient for the component values. Additionally, the code now sets a name for the allocated memory using `talloc_set_name_const`, which aids in tracking and managing memory more effectively. These improvements enhance the overall robustness of the memory handling during the parsing process.","The vulnerability was addressed by implementing a more secure memory allocation strategy that ensures adequate space is allocated for component values based on their actual length. This change prevents potential buffer overflows by guaranteeing that the allocated memory can accommodate the parsed data without exceeding boundaries. Additionally, the updated code includes mechanisms for better tracking and managing the allocated memory, which enhances overall stability and reduces the risk of memory-related issues. These improvements collectively strengthen the code's resilience against vulnerabilities associated with improper memory handling during the parsing process.","5,4","5, 5","4, 4","4,5"
6,6,177846,177846,,Remote,Not required,,CVE-2015-5330,https://www.cvedetails.com/cve/CVE-2015-5330/,CWE-200,Low,Partial,,,2015-12-29,5.0,"ldb before 1.1.24, as used in the AD LDAP server in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3, mishandles string lengths, which allows remote attackers to obtain sensitive information from daemon heap memory by sending crafted packets and then reading (1) an error message or (2) a database value.",2016-12-30,+Info,8,https://git.samba.org/?p=samba.git;a=commit;h=0454b95657846fcecf0f51b6f1194faac02518bd,0454b95657846fcecf0f51b6f1194faac02518bd,,2,,," char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
 {
        char *dst;
       size_t len;
        if (!value.length)
                return NULL;
 
	/* allocate destination string, it will be at most 3 times the source */
	dst = talloc_array(mem_ctx, char, value.length * 3 + 1);
	if ( ! dst) {
		talloc_free(dst);
                return NULL;
        }
 
       len = ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
 
       dst = talloc_realloc(mem_ctx, dst, char, len + 1);
       if ( ! dst) {
               talloc_free(dst);
               return NULL;
       }
       dst[len] = '\0';
        return dst;
 }
"," char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
 {
        char *dst;
        if (!value.length)
                return NULL;
 
	/* allocate destination string, it will be at most 3 times the source */
	dst = talloc_array(mem_ctx, char, value.length * 3 + 1);
	if ( ! dst) {
		talloc_free(dst);
                return NULL;
        }
 
       ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
       dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);
 
        return dst;
 }
",C,"       size_t len;
       len = ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
       dst = talloc_realloc(mem_ctx, dst, char, len + 1);
       if ( ! dst) {
               talloc_free(dst);
               return NULL;
       }
       dst[len] = '\0';
","       ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
       dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);
",7f51ec8c4ed9ba1f53d722e44fb6fb3cde933b72,"@@ -250,7 +250,7 @@ static int ldb_dn_escape_internal(char *dst, const char *src, int len)
 char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
 {
        char *dst;
-
+       size_t len;
        if (!value.length)
                return NULL;
 
@@ -261,10 +261,14 @@ char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
                return NULL;
        }
 
-       ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
-
-       dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);
+       len = ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
 
+       dst = talloc_realloc(mem_ctx, dst, char, len + 1);
+       if ( ! dst) {
+               talloc_free(dst);
+               return NULL;
+       }
+       dst[len] = '\0';
        return dst;
 }",samba,https://git.samba.org/?p=samba.git;a=blob;f=lib/ldb/common/ldb_dn.c;h=6f9903e3e65de68b9624ffb19cd09f02cdbf3225;hb=6f9903e3e65de68b9624ffb19cd09f02cdbf3225,https://git.samba.org/?p=samba.git;a=blob;f=lib/ldb/common/ldb_dn.c;h=d39eb8caec1b208f269d20f97512eed875165fd7;hb=d39eb8caec1b208f269d20f97512eed875165fd7,1," char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
 {
        char *dst;
//flaw_line_below:

//fix_flaw_line_below:
//       size_t len;
        if (!value.length)
                return NULL;
 
	/* allocate destination string, it will be at most 3 times the source */
	dst = talloc_array(mem_ctx, char, value.length * 3 + 1);
	if ( ! dst) {
		talloc_free(dst);
                return NULL;
        }
 
//flaw_line_below:
       ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
//flaw_line_below:

//flaw_line_below:
       dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);
//fix_flaw_line_below:
//       len = ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
 
//fix_flaw_line_below:
//       dst = talloc_realloc(mem_ctx, dst, char, len + 1);
//fix_flaw_line_below:
//       if ( ! dst) {
//fix_flaw_line_below:
//               talloc_free(dst);
//fix_flaw_line_below:
//               return NULL;
//fix_flaw_line_below:
//       }
//fix_flaw_line_below:
//       dst[len] = '\0';
        return dst;
 }
",177846," char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
 {
        char *dst;
        if (!value.length)
                return NULL;
 
	/* allocate destination string, it will be at most 3 times the source */
	dst = talloc_array(mem_ctx, char, value.length * 3 + 1);
	if ( ! dst) {
		talloc_free(dst);
                return NULL;
        }
 
       ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
       dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);
 
        return dst;
 }
"," char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
 {
        char *dst;
       size_t len;
        if (!value.length)
                return NULL;
 
	/* allocate destination string, it will be at most 3 times the source */
	dst = talloc_array(mem_ctx, char, value.length * 3 + 1);
	if ( ! dst) {
		talloc_free(dst);
                return NULL;
        }
 
       len = ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
 
       dst = talloc_realloc(mem_ctx, dst, char, len + 1);
       if ( ! dst) {
               talloc_free(dst);
               return NULL;
       }
       dst[len] = '\0';
        return dst;
 }
","The function `ldb_dn_escape_value` is designed to escape a given value for use in a distinguished name (DN) context, ensuring that special characters are properly handled. It first checks if the input value has a length; if not, it returns NULL. The function allocates memory for a destination string that can be up to three times the length of the input value, using a memory context for efficient allocation. It then calls `ldb_dn_escape_internal` to perform the actual escaping of the input data. Finally, it reallocates the destination string to fit the escaped content and returns the resulting string.","The provided code defines a function that processes a given input value to ensure it is safe for use in a distinguished name context by escaping special characters. It first checks if the input is empty and returns a null value if so. The function allocates memory for a new string that can accommodate the original input expanded by a factor of three. It then performs the necessary escaping on the input data and adjusts the allocated memory to fit the newly formatted string. Finally, the function returns the processed string, ready for further use.","The vulnerability in the original code arises from the potential for memory mismanagement, particularly when the destination string is reallocated without ensuring that the length of the escaped string is correctly calculated and handled. In the fixed code, the length of the escaped string is explicitly stored in the variable `len` after calling the escaping function. This ensures that the subsequent reallocation of memory for `dst` is based on the actual length of the escaped content. Additionally, the fixed code includes a null-termination step for the destination string, enhancing safety and preventing buffer overflows or undefined behavior.","The vulnerability in the original code stems from inadequate handling of memory allocation and string termination, which could lead to buffer overflows or undefined behavior. Specifically, the code did not properly account for the length of the escaped string when reallocating memory, risking the potential for accessing uninitialized memory. In the revised code, the length of the escaped string is explicitly calculated and used for memory reallocation, ensuring that the allocated space is sufficient. Additionally, the fixed code includes a step to explicitly terminate the string, enhancing safety and preventing potential vulnerabilities related to string manipulation.","The vulnerability was fixed by introducing a variable to store the length of the escaped string after calling the escaping function, which is assigned to `len`. This ensures that the subsequent reallocation of memory for `dst` uses the correct length, specifically `len + 1`, to accommodate the null terminator. Additionally, the code now includes a check to ensure that the reallocation was successful, preventing potential null pointer dereferences. Finally, the code explicitly sets `dst[len]` to `'\0'`, ensuring that the string is properly terminated, which mitigates risks associated with buffer overflows and undefined behavior.","The vulnerability was addressed by ensuring that the length of the escaped string is accurately calculated and used for memory reallocation. This prevents the allocation of insufficient memory, which could lead to buffer overflows. Additionally, the revised code includes a check to confirm that the memory reallocation was successful, thereby avoiding potential null pointer dereferences. Furthermore, the code explicitly terminates the string, ensuring that it is properly formatted and reducing the risk of undefined behavior during string manipulation. These changes collectively enhance the safety and reliability of the memory handling process.","4,5","5,5","4,5","4,5"
7,7,177861,177861,,Local,Not required,,CVE-2011-1943,https://www.cvedetails.com/cve/CVE-2011-1943/,CWE-200,Low,Partial,,,2011-06-14,2.1,"The destroy_one_secret function in nm-setting-vpn.c in libnm-util in the NetworkManager package 0.8.999-3.git20110526 in Fedora 15 creates a log entry containing a certificate password, which allows local users to obtain sensitive information by reading a log file.",2017-08-16,+Info,0,https://cgit.freedesktop.org/NetworkManager/NetworkManager/commit/?id=78ce088843d59d4494965bfc40b30a2e63d065f6,78ce088843d59d4494965bfc40b30a2e63d065f6,,1,,,"destroy_one_secret (gpointer data)
{
 	char *secret = (char *) data;
 
 	/* Don't leave the secret lying around in memory */
 	memset (secret, 0, strlen (secret));
 	g_free (secret);
 }
","destroy_one_secret (gpointer data)
{
 	char *secret = (char *) data;
 
 	/* Don't leave the secret lying around in memory */
g_message (""%s: destroying %s"", __func__, secret);
 	memset (secret, 0, strlen (secret));
 	g_free (secret);
 }
",C,,"g_message (""%s: destroying %s"", __func__, secret);
",4a0c7d9dd4226a29440a96d0f487407a7c9ec3e6,"@@ -457,7 +457,6 @@ destroy_one_secret (gpointer data)
 	char *secret = (char *) data;
 
 	/* Don't leave the secret lying around in memory */
-g_message (""%s: destroying %s"", __func__, secret);
 	memset (secret, 0, strlen (secret));
 	g_free (secret);
 }",NetworkManager,https://cgit.freedesktop.org/NetworkManager/NetworkManager/tree/libnm-util/nm-setting-vpn.c?id=78ce088843d59d4494965bfc40b30a2e63d065f6,https://cgit.freedesktop.org/NetworkManager/NetworkManager/tree/libnm-util/nm-setting-vpn.c?id=4a0c7d9dd4226a29440a96d0f487407a7c9ec3e6,1,"destroy_one_secret (gpointer data)
{
 	char *secret = (char *) data;
 
 	/* Don't leave the secret lying around in memory */
//flaw_line_below:
g_message (""%s: destroying %s"", __func__, secret);
 	memset (secret, 0, strlen (secret));
 	g_free (secret);
 }
",177861,"destroy_one_secret (gpointer data)
{
 	char *secret = (char *) data;
 
 	/* Don't leave the secret lying around in memory */
g_message (""%s: destroying %s"", __func__, secret);
 	memset (secret, 0, strlen (secret));
 	g_free (secret);
 }
","destroy_one_secret (gpointer data)
{
 	char *secret = (char *) data;
 
 	/* Don't leave the secret lying around in memory */
 	memset (secret, 0, strlen (secret));
 	g_free (secret);
 }
","The `destroy_one_secret` function is designed to securely delete a sensitive string, referred to as a ""secret,"" from memory. It takes a pointer to the secret as input, casts it to a character pointer, and logs a message indicating the destruction process. To prevent any potential exposure of the secret, the function first overwrites the memory containing the secret with zeros using `memset`, effectively erasing its contents. Finally, it frees the allocated memory for the secret using `g_free`, ensuring that the memory is properly released and reducing the risk of sensitive data being recovered.","The provided code defines a function that securely handles the deletion of a sensitive string stored in memory. It begins by logging a message to indicate the process of destroying the sensitive data. To ensure that the information is not left accessible, the function overwrites the memory where the string is stored with zeros, effectively erasing its contents. After this step, it releases the allocated memory to prevent any potential memory leaks. This approach enhances security by minimizing the risk of sensitive data being recovered after it is no longer needed.","The vulnerability in the original code stemmed from the lack of proper logging before the sensitive string was erased, which could lead to the secret being exposed in memory before it was securely destroyed. In the fixed code, the logging statement was removed, ensuring that the sensitive data was not inadvertently revealed during the destruction process. By directly overwriting the memory with zeros using `memset` before freeing it with `g_free`, the updated code enhances security by preventing any potential leakage of the secret, thereby mitigating the risk of sensitive information being accessed after the function execution.","The vulnerability in the original code arose from the logging of sensitive information before it was securely erased, which could expose the data in memory to unauthorized access. This logging step created a potential security risk, as the sensitive string could be read from the logs or memory before being overwritten. In the revised code, the logging was removed, ensuring that the sensitive data was not disclosed at any point during the destruction process. By directly overwriting the memory with zeros before releasing it, the updated implementation effectively mitigates the risk of sensitive information leakage, enhancing overall security.","The vulnerability was fixed by removing the logging statement that displayed the sensitive string before it was destroyed. In the original code, the logging function `g_message` could potentially expose the secret in memory, creating a security risk. In the updated code, this logging was eliminated, ensuring that the sensitive data remained confidential throughout the destruction process. Additionally, the use of `memset` to overwrite the memory with zeros before calling `g_free` further enhanced security by ensuring that the contents of the secret were erased before the memory was released, thereby preventing any chance of data recovery.","The vulnerability was fixed by eliminating the logging of sensitive information prior to its destruction, which could have exposed the data in memory. By removing this logging step, the updated code ensured that the sensitive data remained confidential throughout the entire process. Additionally, the implementation now directly overwrites the memory containing the sensitive information with zeros before releasing it, effectively erasing its contents. This approach not only prevents any potential leakage of the data but also enhances overall security by ensuring that the sensitive information cannot be recovered after it is no longer needed.","5, 5","5, 5","4,4","4,4"
8,8,177890,177890,,Remote,Not required,Partial,CVE-2015-3195,https://www.cvedetails.com/cve/CVE-2015-3195/,CWE-200,Low,,,,2015-12-06,5.0,"The ASN1_TFLG_COMBINE implementation in crypto/asn1/tasn_dec.c in OpenSSL before 0.9.8zh, 1.0.0 before 1.0.0t, 1.0.1 before 1.0.1q, and 1.0.2 before 1.0.2e mishandles errors caused by malformed X509_ATTRIBUTE data, which allows remote attackers to obtain sensitive information from process memory by triggering a decoding failure in a PKCS#7 or CMS application.",2019-06-14,+Info,4,https://git.openssl.org/?p=openssl.git;a=commit;h=cc598f321fbac9c04da5766243ed55d55948637d,cc598f321fbac9c04da5766243ed55d55948637d,,1,,,"int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
                     const ASN1_ITEM *it,
                     int tag, int aclass, char opt, ASN1_TLC *ctx)
{
    const ASN1_TEMPLATE *tt, *errtt = NULL;
    const ASN1_COMPAT_FUNCS *cf;
    const ASN1_EXTERN_FUNCS *ef;
    const ASN1_AUX *aux = it->funcs;
    ASN1_aux_cb *asn1_cb;
    const unsigned char *p = NULL, *q;
    unsigned char *wp = NULL;   /* BIG FAT WARNING! BREAKS CONST WHERE USED */
    unsigned char imphack = 0, oclass;
    char seq_eoc, seq_nolen, cst, isopt;
    long tmplen;
    int i;
     int otag;
     int ret = 0;
     ASN1_VALUE **pchptr, *ptmpval;
    int combine = aclass & ASN1_TFLG_COMBINE;
    aclass &= ~ASN1_TFLG_COMBINE;
     if (!pval)
         return 0;
     if (aux && aux->asn1_cb)
        asn1_cb = 0;

    switch (it->itype) {
    case ASN1_ITYPE_PRIMITIVE:
        if (it->templates) {
            /*
             * tagging or OPTIONAL is currently illegal on an item template
             * because the flags can't get passed down. In practice this
             * isn't a problem: we include the relevant flags from the item
             * template in the template itself.
             */
            if ((tag != -1) || opt) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
                        ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
                goto err;
            }
            return asn1_template_ex_d2i(pval, in, len,
                                        it->templates, opt, ctx);
        }
        return asn1_d2i_ex_primitive(pval, in, len, it,
                                     tag, aclass, opt, ctx);
        break;

    case ASN1_ITYPE_MSTRING:
        p = *in;
        /* Just read in tag and class */
        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,
                              &p, len, -1, 0, 1, ctx);
        if (!ret) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        /* Must be UNIVERSAL class */
        if (oclass != V_ASN1_UNIVERSAL) {
            /* If OPTIONAL, assume this is OK */
            if (opt)
                return -1;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_NOT_UNIVERSAL);
            goto err;
        }
        /* Check tag matches bit map */
        if (!(ASN1_tag2bit(otag) & it->utype)) {
            /* If OPTIONAL, assume this is OK */
            if (opt)
                return -1;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_WRONG_TAG);
            goto err;
        }
        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);

    case ASN1_ITYPE_EXTERN:
        /* Use new style d2i */
        ef = it->funcs;
        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, ctx);

    case ASN1_ITYPE_COMPAT:
        /* we must resort to old style evil hackery */
        cf = it->funcs;

        /* If OPTIONAL see if it is there */
        if (opt) {
            int exptag;
            p = *in;
            if (tag == -1)
                exptag = it->utype;
            else
                exptag = tag;
            /*
             * Don't care about anything other than presence of expected tag
             */

            ret = asn1_check_tlen(NULL, NULL, NULL, NULL, NULL,
                                  &p, len, exptag, aclass, 1, ctx);
            if (!ret) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
                goto err;
            }
            if (ret == -1)
                return -1;
        }

        /*
         * This is the old style evil hack IMPLICIT handling: since the
         * underlying code is expecting a tag and class other than the one
         * present we change the buffer temporarily then change it back
         * afterwards. This doesn't and never did work for tags > 30. Yes
         * this is *horrible* but it is only needed for old style d2i which
         * will hopefully not be around for much longer. FIXME: should copy
         * the buffer then modify it so the input buffer can be const: we
         * should *always* copy because the old style d2i might modify the
         * buffer.
         */

        if (tag != -1) {
            wp = *(unsigned char **)in;
            imphack = *wp;
            if (p == NULL) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
                goto err;
            }
            *wp = (unsigned char)((*p & V_ASN1_CONSTRUCTED)
                                  | it->utype);
        }

        ptmpval = cf->asn1_d2i(pval, in, len);

        if (tag != -1)
            *wp = imphack;

        if (ptmpval)
            return 1;

        ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
        goto err;

    case ASN1_ITYPE_CHOICE:
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
            goto auxerr;
        if (*pval) {
            /* Free up and zero CHOICE value if initialised */
            i = asn1_get_choice_selector(pval, it);
            if ((i >= 0) && (i < it->tcount)) {
                tt = it->templates + i;
                pchptr = asn1_get_field_ptr(pval, tt);
                ASN1_template_free(pchptr, tt);
                asn1_set_choice_selector(pval, -1, it);
            }
        } else if (!ASN1_item_ex_new(pval, it)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }
        /* CHOICE type, try each possibility in turn */
        p = *in;
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            pchptr = asn1_get_field_ptr(pval, tt);
            /*
             * We mark field as OPTIONAL so its absence can be recognised.
             */
            ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx);
            /* If field not present, try the next one */
            if (ret == -1)
                continue;
            /* If positive return, read OK, break loop */
            if (ret > 0)
                break;
            /* Otherwise must be an ASN1 parsing error */
            errtt = tt;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        /* Did we fall off the end without reading anything? */
        if (i == it->tcount) {
            /* If OPTIONAL, this is OK */
            if (opt) {
                /* Free and zero it */
                ASN1_item_ex_free(pval, it);
                return -1;
            }
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_NO_MATCHING_CHOICE_TYPE);
            goto err;
        }

        asn1_set_choice_selector(pval, i, it);
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
            goto auxerr;
        *in = p;
        return 1;

    case ASN1_ITYPE_NDEF_SEQUENCE:
    case ASN1_ITYPE_SEQUENCE:
        p = *in;
        tmplen = len;

        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */
        if (tag == -1) {
            tag = V_ASN1_SEQUENCE;
            aclass = V_ASN1_UNIVERSAL;
        }
        /* Get SEQUENCE length and update len, p */
        ret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,
                              &p, len, tag, aclass, opt, ctx);
        if (!ret) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        } else if (ret == -1)
            return -1;
        if (aux && (aux->flags & ASN1_AFLG_BROKEN)) {
            len = tmplen - (p - *in);
            seq_nolen = 1;
        }
        /* If indefinite we don't do a length check */
        else
            seq_nolen = seq_eoc;
        if (!cst) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
            goto err;
        }

        if (!*pval && !ASN1_item_ex_new(pval, it)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
            goto auxerr;

        /* Free up and zero any ADB found */
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            if (tt->flags & ASN1_TFLG_ADB_MASK) {
                const ASN1_TEMPLATE *seqtt;
                ASN1_VALUE **pseqval;
                seqtt = asn1_do_adb(pval, tt, 1);
                pseqval = asn1_get_field_ptr(pval, seqtt);
                ASN1_template_free(pseqval, seqtt);
            }
        }

        /* Get each field entry */
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            const ASN1_TEMPLATE *seqtt;
            ASN1_VALUE **pseqval;
            seqtt = asn1_do_adb(pval, tt, 1);
            if (!seqtt)
                goto err;
            pseqval = asn1_get_field_ptr(pval, seqtt);
            /* Have we ran out of data? */
            if (!len)
                break;
            q = p;
            if (asn1_check_eoc(&p, len)) {
                if (!seq_eoc) {
                    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_UNEXPECTED_EOC);
                    goto err;
                }
                len -= p - q;
                seq_eoc = 0;
                q = p;
                break;
            }
            /*
             * This determines the OPTIONAL flag value. The field cannot be
             * omitted if it is the last of a SEQUENCE and there is still
             * data to be read. This isn't strictly necessary but it
             * increases efficiency in some cases.
             */
            if (i == (it->tcount - 1))
                isopt = 0;
            else
                isopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);
            /*
             * attempt to read in field, allowing each to be OPTIONAL
             */

            ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx);
            if (!ret) {
                errtt = seqtt;
                goto err;
            } else if (ret == -1) {
                /*
                 * OPTIONAL component absent. Free and zero the field.
                 */
                ASN1_template_free(pseqval, seqtt);
                continue;
            }
            /* Update length */
            len -= p - q;
        }

        /* Check for EOC if expecting one */
        if (seq_eoc && !asn1_check_eoc(&p, len)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MISSING_EOC);
            goto err;
        }
        /* Check all data read */
        if (!seq_nolen && len) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_LENGTH_MISMATCH);
            goto err;
        }

        /*
         * If we get here we've got no more data in the SEQUENCE, however we
         * may not have read all fields so check all remaining are OPTIONAL
         * and clear any that are.
         */
        for (; i < it->tcount; tt++, i++) {
            const ASN1_TEMPLATE *seqtt;
            seqtt = asn1_do_adb(pval, tt, 1);
            if (!seqtt)
                goto err;
            if (seqtt->flags & ASN1_TFLG_OPTIONAL) {
                ASN1_VALUE **pseqval;
                pseqval = asn1_get_field_ptr(pval, seqtt);
                ASN1_template_free(pseqval, seqtt);
            } else {
                errtt = seqtt;
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_FIELD_MISSING);
                goto err;
            }
        }
        /* Save encoding */
        if (!asn1_enc_save(pval, *in, p - *in, it))
            goto auxerr;
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
            goto auxerr;
        *in = p;
        return 1;

    default:
        return 0;
    }
 auxerr:
    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);
  auxerr:
     ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);
  err:
    if (combine == 0)
        ASN1_item_ex_free(pval, it);
     if (errtt)
         ERR_add_error_data(4, ""Field="", errtt->field_name,
                            "", Type="", it->sname);
}
","int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
                     const ASN1_ITEM *it,
                     int tag, int aclass, char opt, ASN1_TLC *ctx)
{
    const ASN1_TEMPLATE *tt, *errtt = NULL;
    const ASN1_COMPAT_FUNCS *cf;
    const ASN1_EXTERN_FUNCS *ef;
    const ASN1_AUX *aux = it->funcs;
    ASN1_aux_cb *asn1_cb;
    const unsigned char *p = NULL, *q;
    unsigned char *wp = NULL;   /* BIG FAT WARNING! BREAKS CONST WHERE USED */
    unsigned char imphack = 0, oclass;
    char seq_eoc, seq_nolen, cst, isopt;
    long tmplen;
    int i;
     int otag;
     int ret = 0;
     ASN1_VALUE **pchptr, *ptmpval;
     if (!pval)
         return 0;
     if (aux && aux->asn1_cb)
        asn1_cb = 0;

    switch (it->itype) {
    case ASN1_ITYPE_PRIMITIVE:
        if (it->templates) {
            /*
             * tagging or OPTIONAL is currently illegal on an item template
             * because the flags can't get passed down. In practice this
             * isn't a problem: we include the relevant flags from the item
             * template in the template itself.
             */
            if ((tag != -1) || opt) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
                        ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
                goto err;
            }
            return asn1_template_ex_d2i(pval, in, len,
                                        it->templates, opt, ctx);
        }
        return asn1_d2i_ex_primitive(pval, in, len, it,
                                     tag, aclass, opt, ctx);
        break;

    case ASN1_ITYPE_MSTRING:
        p = *in;
        /* Just read in tag and class */
        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,
                              &p, len, -1, 0, 1, ctx);
        if (!ret) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        /* Must be UNIVERSAL class */
        if (oclass != V_ASN1_UNIVERSAL) {
            /* If OPTIONAL, assume this is OK */
            if (opt)
                return -1;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_NOT_UNIVERSAL);
            goto err;
        }
        /* Check tag matches bit map */
        if (!(ASN1_tag2bit(otag) & it->utype)) {
            /* If OPTIONAL, assume this is OK */
            if (opt)
                return -1;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_WRONG_TAG);
            goto err;
        }
        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);

    case ASN1_ITYPE_EXTERN:
        /* Use new style d2i */
        ef = it->funcs;
        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, ctx);

    case ASN1_ITYPE_COMPAT:
        /* we must resort to old style evil hackery */
        cf = it->funcs;

        /* If OPTIONAL see if it is there */
        if (opt) {
            int exptag;
            p = *in;
            if (tag == -1)
                exptag = it->utype;
            else
                exptag = tag;
            /*
             * Don't care about anything other than presence of expected tag
             */

            ret = asn1_check_tlen(NULL, NULL, NULL, NULL, NULL,
                                  &p, len, exptag, aclass, 1, ctx);
            if (!ret) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
                goto err;
            }
            if (ret == -1)
                return -1;
        }

        /*
         * This is the old style evil hack IMPLICIT handling: since the
         * underlying code is expecting a tag and class other than the one
         * present we change the buffer temporarily then change it back
         * afterwards. This doesn't and never did work for tags > 30. Yes
         * this is *horrible* but it is only needed for old style d2i which
         * will hopefully not be around for much longer. FIXME: should copy
         * the buffer then modify it so the input buffer can be const: we
         * should *always* copy because the old style d2i might modify the
         * buffer.
         */

        if (tag != -1) {
            wp = *(unsigned char **)in;
            imphack = *wp;
            if (p == NULL) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
                goto err;
            }
            *wp = (unsigned char)((*p & V_ASN1_CONSTRUCTED)
                                  | it->utype);
        }

        ptmpval = cf->asn1_d2i(pval, in, len);

        if (tag != -1)
            *wp = imphack;

        if (ptmpval)
            return 1;

        ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
        goto err;

    case ASN1_ITYPE_CHOICE:
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
            goto auxerr;
        if (*pval) {
            /* Free up and zero CHOICE value if initialised */
            i = asn1_get_choice_selector(pval, it);
            if ((i >= 0) && (i < it->tcount)) {
                tt = it->templates + i;
                pchptr = asn1_get_field_ptr(pval, tt);
                ASN1_template_free(pchptr, tt);
                asn1_set_choice_selector(pval, -1, it);
            }
        } else if (!ASN1_item_ex_new(pval, it)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }
        /* CHOICE type, try each possibility in turn */
        p = *in;
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            pchptr = asn1_get_field_ptr(pval, tt);
            /*
             * We mark field as OPTIONAL so its absence can be recognised.
             */
            ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx);
            /* If field not present, try the next one */
            if (ret == -1)
                continue;
            /* If positive return, read OK, break loop */
            if (ret > 0)
                break;
            /* Otherwise must be an ASN1 parsing error */
            errtt = tt;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        /* Did we fall off the end without reading anything? */
        if (i == it->tcount) {
            /* If OPTIONAL, this is OK */
            if (opt) {
                /* Free and zero it */
                ASN1_item_ex_free(pval, it);
                return -1;
            }
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_NO_MATCHING_CHOICE_TYPE);
            goto err;
        }

        asn1_set_choice_selector(pval, i, it);
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
            goto auxerr;
        *in = p;
        return 1;

    case ASN1_ITYPE_NDEF_SEQUENCE:
    case ASN1_ITYPE_SEQUENCE:
        p = *in;
        tmplen = len;

        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */
        if (tag == -1) {
            tag = V_ASN1_SEQUENCE;
            aclass = V_ASN1_UNIVERSAL;
        }
        /* Get SEQUENCE length and update len, p */
        ret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,
                              &p, len, tag, aclass, opt, ctx);
        if (!ret) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        } else if (ret == -1)
            return -1;
        if (aux && (aux->flags & ASN1_AFLG_BROKEN)) {
            len = tmplen - (p - *in);
            seq_nolen = 1;
        }
        /* If indefinite we don't do a length check */
        else
            seq_nolen = seq_eoc;
        if (!cst) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
            goto err;
        }

        if (!*pval && !ASN1_item_ex_new(pval, it)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
            goto auxerr;

        /* Free up and zero any ADB found */
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            if (tt->flags & ASN1_TFLG_ADB_MASK) {
                const ASN1_TEMPLATE *seqtt;
                ASN1_VALUE **pseqval;
                seqtt = asn1_do_adb(pval, tt, 1);
                pseqval = asn1_get_field_ptr(pval, seqtt);
                ASN1_template_free(pseqval, seqtt);
            }
        }

        /* Get each field entry */
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            const ASN1_TEMPLATE *seqtt;
            ASN1_VALUE **pseqval;
            seqtt = asn1_do_adb(pval, tt, 1);
            if (!seqtt)
                goto err;
            pseqval = asn1_get_field_ptr(pval, seqtt);
            /* Have we ran out of data? */
            if (!len)
                break;
            q = p;
            if (asn1_check_eoc(&p, len)) {
                if (!seq_eoc) {
                    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_UNEXPECTED_EOC);
                    goto err;
                }
                len -= p - q;
                seq_eoc = 0;
                q = p;
                break;
            }
            /*
             * This determines the OPTIONAL flag value. The field cannot be
             * omitted if it is the last of a SEQUENCE and there is still
             * data to be read. This isn't strictly necessary but it
             * increases efficiency in some cases.
             */
            if (i == (it->tcount - 1))
                isopt = 0;
            else
                isopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);
            /*
             * attempt to read in field, allowing each to be OPTIONAL
             */

            ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx);
            if (!ret) {
                errtt = seqtt;
                goto err;
            } else if (ret == -1) {
                /*
                 * OPTIONAL component absent. Free and zero the field.
                 */
                ASN1_template_free(pseqval, seqtt);
                continue;
            }
            /* Update length */
            len -= p - q;
        }

        /* Check for EOC if expecting one */
        if (seq_eoc && !asn1_check_eoc(&p, len)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MISSING_EOC);
            goto err;
        }
        /* Check all data read */
        if (!seq_nolen && len) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_LENGTH_MISMATCH);
            goto err;
        }

        /*
         * If we get here we've got no more data in the SEQUENCE, however we
         * may not have read all fields so check all remaining are OPTIONAL
         * and clear any that are.
         */
        for (; i < it->tcount; tt++, i++) {
            const ASN1_TEMPLATE *seqtt;
            seqtt = asn1_do_adb(pval, tt, 1);
            if (!seqtt)
                goto err;
            if (seqtt->flags & ASN1_TFLG_OPTIONAL) {
                ASN1_VALUE **pseqval;
                pseqval = asn1_get_field_ptr(pval, seqtt);
                ASN1_template_free(pseqval, seqtt);
            } else {
                errtt = seqtt;
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_FIELD_MISSING);
                goto err;
            }
        }
        /* Save encoding */
        if (!asn1_enc_save(pval, *in, p - *in, it))
            goto auxerr;
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
            goto auxerr;
        *in = p;
        return 1;

    default:
        return 0;
    }
 auxerr:
    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);
  auxerr:
     ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);
  err:
    ASN1_item_ex_free(pval, it);
     if (errtt)
         ERR_add_error_data(4, ""Field="", errtt->field_name,
                            "", Type="", it->sname);
}
",C,"    int combine = aclass & ASN1_TFLG_COMBINE;
    aclass &= ~ASN1_TFLG_COMBINE;
    if (combine == 0)
        ASN1_item_ex_free(pval, it);
","    ASN1_item_ex_free(pval, it);
",fb4f46763fed3c600db21974577061b611b6fa46,"@@ -180,6 +180,8 @@ int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
     int otag;
     int ret = 0;
     ASN1_VALUE **pchptr, *ptmpval;
+    int combine = aclass & ASN1_TFLG_COMBINE;
+    aclass &= ~ASN1_TFLG_COMBINE;
     if (!pval)
         return 0;
     if (aux && aux->asn1_cb)
@@ -500,7 +502,8 @@ int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
  auxerr:
     ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);
  err:
-    ASN1_item_ex_free(pval, it);
+    if (combine == 0)
+        ASN1_item_ex_free(pval, it);
     if (errtt)
         ERR_add_error_data(4, ""Field="", errtt->field_name,
                            "", Type="", it->sname);
@@ -689,7 +692,7 @@ static int asn1_template_noexp_d2i(ASN1_VALUE **val,
     } else {
         /* Nothing special */
         ret = ASN1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item),
-                               -1, 0, opt, ctx);
+                               -1, tt->flags & ASN1_TFLG_COMBINE, opt, ctx);
         if (!ret) {
             ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_NESTED_ASN1_ERROR);
             goto err;",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/asn1/tasn_dec.c;h=9256049d1588143b4189065ad9359a07b3272ef0;hb=9256049d1588143b4189065ad9359a07b3272ef0,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/asn1/tasn_dec.c;h=febf6059cbe5aaf7e7424ba3b17e6f5fb336a5a9;hb=febf6059cbe5aaf7e7424ba3b17e6f5fb336a5a9,1,"int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
                     const ASN1_ITEM *it,
                     int tag, int aclass, char opt, ASN1_TLC *ctx)
{
    const ASN1_TEMPLATE *tt, *errtt = NULL;
    const ASN1_COMPAT_FUNCS *cf;
    const ASN1_EXTERN_FUNCS *ef;
    const ASN1_AUX *aux = it->funcs;
    ASN1_aux_cb *asn1_cb;
    const unsigned char *p = NULL, *q;
    unsigned char *wp = NULL;   /* BIG FAT WARNING! BREAKS CONST WHERE USED */
    unsigned char imphack = 0, oclass;
    char seq_eoc, seq_nolen, cst, isopt;
    long tmplen;
    int i;
     int otag;
     int ret = 0;
     ASN1_VALUE **pchptr, *ptmpval;
//fix_flaw_line_below:
//    int combine = aclass & ASN1_TFLG_COMBINE;
//fix_flaw_line_below:
//    aclass &= ~ASN1_TFLG_COMBINE;
     if (!pval)
         return 0;
     if (aux && aux->asn1_cb)
        asn1_cb = 0;

    switch (it->itype) {
    case ASN1_ITYPE_PRIMITIVE:
        if (it->templates) {
            /*
             * tagging or OPTIONAL is currently illegal on an item template
             * because the flags can't get passed down. In practice this
             * isn't a problem: we include the relevant flags from the item
             * template in the template itself.
             */
            if ((tag != -1) || opt) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
                        ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
                goto err;
            }
            return asn1_template_ex_d2i(pval, in, len,
                                        it->templates, opt, ctx);
        }
        return asn1_d2i_ex_primitive(pval, in, len, it,
                                     tag, aclass, opt, ctx);
        break;

    case ASN1_ITYPE_MSTRING:
        p = *in;
        /* Just read in tag and class */
        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,
                              &p, len, -1, 0, 1, ctx);
        if (!ret) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        /* Must be UNIVERSAL class */
        if (oclass != V_ASN1_UNIVERSAL) {
            /* If OPTIONAL, assume this is OK */
            if (opt)
                return -1;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_NOT_UNIVERSAL);
            goto err;
        }
        /* Check tag matches bit map */
        if (!(ASN1_tag2bit(otag) & it->utype)) {
            /* If OPTIONAL, assume this is OK */
            if (opt)
                return -1;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_WRONG_TAG);
            goto err;
        }
        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);

    case ASN1_ITYPE_EXTERN:
        /* Use new style d2i */
        ef = it->funcs;
        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, ctx);

    case ASN1_ITYPE_COMPAT:
        /* we must resort to old style evil hackery */
        cf = it->funcs;

        /* If OPTIONAL see if it is there */
        if (opt) {
            int exptag;
            p = *in;
            if (tag == -1)
                exptag = it->utype;
            else
                exptag = tag;
            /*
             * Don't care about anything other than presence of expected tag
             */

            ret = asn1_check_tlen(NULL, NULL, NULL, NULL, NULL,
                                  &p, len, exptag, aclass, 1, ctx);
            if (!ret) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
                goto err;
            }
            if (ret == -1)
                return -1;
        }

        /*
         * This is the old style evil hack IMPLICIT handling: since the
         * underlying code is expecting a tag and class other than the one
         * present we change the buffer temporarily then change it back
         * afterwards. This doesn't and never did work for tags > 30. Yes
         * this is *horrible* but it is only needed for old style d2i which
         * will hopefully not be around for much longer. FIXME: should copy
         * the buffer then modify it so the input buffer can be const: we
         * should *always* copy because the old style d2i might modify the
         * buffer.
         */

        if (tag != -1) {
            wp = *(unsigned char **)in;
            imphack = *wp;
            if (p == NULL) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
                goto err;
            }
            *wp = (unsigned char)((*p & V_ASN1_CONSTRUCTED)
                                  | it->utype);
        }

        ptmpval = cf->asn1_d2i(pval, in, len);

        if (tag != -1)
            *wp = imphack;

        if (ptmpval)
            return 1;

        ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
        goto err;

    case ASN1_ITYPE_CHOICE:
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
            goto auxerr;
        if (*pval) {
            /* Free up and zero CHOICE value if initialised */
            i = asn1_get_choice_selector(pval, it);
            if ((i >= 0) && (i < it->tcount)) {
                tt = it->templates + i;
                pchptr = asn1_get_field_ptr(pval, tt);
                ASN1_template_free(pchptr, tt);
                asn1_set_choice_selector(pval, -1, it);
            }
        } else if (!ASN1_item_ex_new(pval, it)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }
        /* CHOICE type, try each possibility in turn */
        p = *in;
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            pchptr = asn1_get_field_ptr(pval, tt);
            /*
             * We mark field as OPTIONAL so its absence can be recognised.
             */
            ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx);
            /* If field not present, try the next one */
            if (ret == -1)
                continue;
            /* If positive return, read OK, break loop */
            if (ret > 0)
                break;
            /* Otherwise must be an ASN1 parsing error */
            errtt = tt;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        /* Did we fall off the end without reading anything? */
        if (i == it->tcount) {
            /* If OPTIONAL, this is OK */
            if (opt) {
                /* Free and zero it */
                ASN1_item_ex_free(pval, it);
                return -1;
            }
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_NO_MATCHING_CHOICE_TYPE);
            goto err;
        }

        asn1_set_choice_selector(pval, i, it);
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
            goto auxerr;
        *in = p;
        return 1;

    case ASN1_ITYPE_NDEF_SEQUENCE:
    case ASN1_ITYPE_SEQUENCE:
        p = *in;
        tmplen = len;

        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */
        if (tag == -1) {
            tag = V_ASN1_SEQUENCE;
            aclass = V_ASN1_UNIVERSAL;
        }
        /* Get SEQUENCE length and update len, p */
        ret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,
                              &p, len, tag, aclass, opt, ctx);
        if (!ret) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        } else if (ret == -1)
            return -1;
        if (aux && (aux->flags & ASN1_AFLG_BROKEN)) {
            len = tmplen - (p - *in);
            seq_nolen = 1;
        }
        /* If indefinite we don't do a length check */
        else
            seq_nolen = seq_eoc;
        if (!cst) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
            goto err;
        }

        if (!*pval && !ASN1_item_ex_new(pval, it)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
            goto auxerr;

        /* Free up and zero any ADB found */
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            if (tt->flags & ASN1_TFLG_ADB_MASK) {
                const ASN1_TEMPLATE *seqtt;
                ASN1_VALUE **pseqval;
                seqtt = asn1_do_adb(pval, tt, 1);
                pseqval = asn1_get_field_ptr(pval, seqtt);
                ASN1_template_free(pseqval, seqtt);
            }
        }

        /* Get each field entry */
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            const ASN1_TEMPLATE *seqtt;
            ASN1_VALUE **pseqval;
            seqtt = asn1_do_adb(pval, tt, 1);
            if (!seqtt)
                goto err;
            pseqval = asn1_get_field_ptr(pval, seqtt);
            /* Have we ran out of data? */
            if (!len)
                break;
            q = p;
            if (asn1_check_eoc(&p, len)) {
                if (!seq_eoc) {
                    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_UNEXPECTED_EOC);
                    goto err;
                }
                len -= p - q;
                seq_eoc = 0;
                q = p;
                break;
            }
            /*
             * This determines the OPTIONAL flag value. The field cannot be
             * omitted if it is the last of a SEQUENCE and there is still
             * data to be read. This isn't strictly necessary but it
             * increases efficiency in some cases.
             */
            if (i == (it->tcount - 1))
                isopt = 0;
            else
                isopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);
            /*
             * attempt to read in field, allowing each to be OPTIONAL
             */

            ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx);
            if (!ret) {
                errtt = seqtt;
                goto err;
            } else if (ret == -1) {
                /*
                 * OPTIONAL component absent. Free and zero the field.
                 */
                ASN1_template_free(pseqval, seqtt);
                continue;
            }
            /* Update length */
            len -= p - q;
        }

        /* Check for EOC if expecting one */
        if (seq_eoc && !asn1_check_eoc(&p, len)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MISSING_EOC);
            goto err;
        }
        /* Check all data read */
        if (!seq_nolen && len) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_LENGTH_MISMATCH);
            goto err;
        }

        /*
         * If we get here we've got no more data in the SEQUENCE, however we
         * may not have read all fields so check all remaining are OPTIONAL
         * and clear any that are.
         */
        for (; i < it->tcount; tt++, i++) {
            const ASN1_TEMPLATE *seqtt;
            seqtt = asn1_do_adb(pval, tt, 1);
            if (!seqtt)
                goto err;
            if (seqtt->flags & ASN1_TFLG_OPTIONAL) {
                ASN1_VALUE **pseqval;
                pseqval = asn1_get_field_ptr(pval, seqtt);
                ASN1_template_free(pseqval, seqtt);
            } else {
                errtt = seqtt;
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_FIELD_MISSING);
                goto err;
            }
        }
        /* Save encoding */
        if (!asn1_enc_save(pval, *in, p - *in, it))
            goto auxerr;
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
            goto auxerr;
        *in = p;
        return 1;

    default:
        return 0;
    }
 auxerr:
    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);
  auxerr:
     ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);
  err:
//flaw_line_below:
    ASN1_item_ex_free(pval, it);
//fix_flaw_line_below:
//    if (combine == 0)
//fix_flaw_line_below:
//        ASN1_item_ex_free(pval, it);
     if (errtt)
         ERR_add_error_data(4, ""Field="", errtt->field_name,
                            "", Type="", it->sname);
}
",177890,"int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
                     const ASN1_ITEM *it,
                     int tag, int aclass, char opt, ASN1_TLC *ctx)
{
    const ASN1_TEMPLATE *tt, *errtt = NULL;
    const ASN1_COMPAT_FUNCS *cf;
    const ASN1_EXTERN_FUNCS *ef;
    const ASN1_AUX *aux = it->funcs;
    ASN1_aux_cb *asn1_cb;
    const unsigned char *p = NULL, *q;
    unsigned char *wp = NULL;   /* BIG FAT WARNING! BREAKS CONST WHERE USED */
    unsigned char imphack = 0, oclass;
    char seq_eoc, seq_nolen, cst, isopt;
    long tmplen;
    int i;
     int otag;
     int ret = 0;
     ASN1_VALUE **pchptr, *ptmpval;
     if (!pval)
         return 0;
     if (aux && aux->asn1_cb)
        asn1_cb = 0;

    switch (it->itype) {
    case ASN1_ITYPE_PRIMITIVE:
        if (it->templates) {
            /*
             * tagging or OPTIONAL is currently illegal on an item template
             * because the flags can't get passed down. In practice this
             * isn't a problem: we include the relevant flags from the item
             * template in the template itself.
             */
            if ((tag != -1) || opt) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
                        ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
                goto err;
            }
            return asn1_template_ex_d2i(pval, in, len,
                                        it->templates, opt, ctx);
        }
        return asn1_d2i_ex_primitive(pval, in, len, it,
                                     tag, aclass, opt, ctx);
        break;

    case ASN1_ITYPE_MSTRING:
        p = *in;
        /* Just read in tag and class */
        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,
                              &p, len, -1, 0, 1, ctx);
        if (!ret) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        /* Must be UNIVERSAL class */
        if (oclass != V_ASN1_UNIVERSAL) {
            /* If OPTIONAL, assume this is OK */
            if (opt)
                return -1;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_NOT_UNIVERSAL);
            goto err;
        }
        /* Check tag matches bit map */
        if (!(ASN1_tag2bit(otag) & it->utype)) {
            /* If OPTIONAL, assume this is OK */
            if (opt)
                return -1;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_WRONG_TAG);
            goto err;
        }
        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);

    case ASN1_ITYPE_EXTERN:
        /* Use new style d2i */
        ef = it->funcs;
        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, ctx);

    case ASN1_ITYPE_COMPAT:
        /* we must resort to old style evil hackery */
        cf = it->funcs;

        /* If OPTIONAL see if it is there */
        if (opt) {
            int exptag;
            p = *in;
            if (tag == -1)
                exptag = it->utype;
            else
                exptag = tag;
            /*
             * Don't care about anything other than presence of expected tag
             */

            ret = asn1_check_tlen(NULL, NULL, NULL, NULL, NULL,
                                  &p, len, exptag, aclass, 1, ctx);
            if (!ret) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
                goto err;
            }
            if (ret == -1)
                return -1;
        }

        /*
         * This is the old style evil hack IMPLICIT handling: since the
         * underlying code is expecting a tag and class other than the one
         * present we change the buffer temporarily then change it back
         * afterwards. This doesn't and never did work for tags > 30. Yes
         * this is *horrible* but it is only needed for old style d2i which
         * will hopefully not be around for much longer. FIXME: should copy
         * the buffer then modify it so the input buffer can be const: we
         * should *always* copy because the old style d2i might modify the
         * buffer.
         */

        if (tag != -1) {
            wp = *(unsigned char **)in;
            imphack = *wp;
            if (p == NULL) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
                goto err;
            }
            *wp = (unsigned char)((*p & V_ASN1_CONSTRUCTED)
                                  | it->utype);
        }

        ptmpval = cf->asn1_d2i(pval, in, len);

        if (tag != -1)
            *wp = imphack;

        if (ptmpval)
            return 1;

        ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
        goto err;

    case ASN1_ITYPE_CHOICE:
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
            goto auxerr;
        if (*pval) {
            /* Free up and zero CHOICE value if initialised */
            i = asn1_get_choice_selector(pval, it);
            if ((i >= 0) && (i < it->tcount)) {
                tt = it->templates + i;
                pchptr = asn1_get_field_ptr(pval, tt);
                ASN1_template_free(pchptr, tt);
                asn1_set_choice_selector(pval, -1, it);
            }
        } else if (!ASN1_item_ex_new(pval, it)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }
        /* CHOICE type, try each possibility in turn */
        p = *in;
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            pchptr = asn1_get_field_ptr(pval, tt);
            /*
             * We mark field as OPTIONAL so its absence can be recognised.
             */
            ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx);
            /* If field not present, try the next one */
            if (ret == -1)
                continue;
            /* If positive return, read OK, break loop */
            if (ret > 0)
                break;
            /* Otherwise must be an ASN1 parsing error */
            errtt = tt;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        /* Did we fall off the end without reading anything? */
        if (i == it->tcount) {
            /* If OPTIONAL, this is OK */
            if (opt) {
                /* Free and zero it */
                ASN1_item_ex_free(pval, it);
                return -1;
            }
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_NO_MATCHING_CHOICE_TYPE);
            goto err;
        }

        asn1_set_choice_selector(pval, i, it);
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
            goto auxerr;
        *in = p;
        return 1;

    case ASN1_ITYPE_NDEF_SEQUENCE:
    case ASN1_ITYPE_SEQUENCE:
        p = *in;
        tmplen = len;

        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */
        if (tag == -1) {
            tag = V_ASN1_SEQUENCE;
            aclass = V_ASN1_UNIVERSAL;
        }
        /* Get SEQUENCE length and update len, p */
        ret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,
                              &p, len, tag, aclass, opt, ctx);
        if (!ret) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        } else if (ret == -1)
            return -1;
        if (aux && (aux->flags & ASN1_AFLG_BROKEN)) {
            len = tmplen - (p - *in);
            seq_nolen = 1;
        }
        /* If indefinite we don't do a length check */
        else
            seq_nolen = seq_eoc;
        if (!cst) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
            goto err;
        }

        if (!*pval && !ASN1_item_ex_new(pval, it)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
            goto auxerr;

        /* Free up and zero any ADB found */
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            if (tt->flags & ASN1_TFLG_ADB_MASK) {
                const ASN1_TEMPLATE *seqtt;
                ASN1_VALUE **pseqval;
                seqtt = asn1_do_adb(pval, tt, 1);
                pseqval = asn1_get_field_ptr(pval, seqtt);
                ASN1_template_free(pseqval, seqtt);
            }
        }

        /* Get each field entry */
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            const ASN1_TEMPLATE *seqtt;
            ASN1_VALUE **pseqval;
            seqtt = asn1_do_adb(pval, tt, 1);
            if (!seqtt)
                goto err;
            pseqval = asn1_get_field_ptr(pval, seqtt);
            /* Have we ran out of data? */
            if (!len)
                break;
            q = p;
            if (asn1_check_eoc(&p, len)) {
                if (!seq_eoc) {
                    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_UNEXPECTED_EOC);
                    goto err;
                }
                len -= p - q;
                seq_eoc = 0;
                q = p;
                break;
            }
            /*
             * This determines the OPTIONAL flag value. The field cannot be
             * omitted if it is the last of a SEQUENCE and there is still
             * data to be read. This isn't strictly necessary but it
             * increases efficiency in some cases.
             */
            if (i == (it->tcount - 1))
                isopt = 0;
            else
                isopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);
            /*
             * attempt to read in field, allowing each to be OPTIONAL
             */

            ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx);
            if (!ret) {
                errtt = seqtt;
                goto err;
            } else if (ret == -1) {
                /*
                 * OPTIONAL component absent. Free and zero the field.
                 */
                ASN1_template_free(pseqval, seqtt);
                continue;
            }
            /* Update length */
            len -= p - q;
        }

        /* Check for EOC if expecting one */
        if (seq_eoc && !asn1_check_eoc(&p, len)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MISSING_EOC);
            goto err;
        }
        /* Check all data read */
        if (!seq_nolen && len) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_LENGTH_MISMATCH);
            goto err;
        }

        /*
         * If we get here we've got no more data in the SEQUENCE, however we
         * may not have read all fields so check all remaining are OPTIONAL
         * and clear any that are.
         */
        for (; i < it->tcount; tt++, i++) {
            const ASN1_TEMPLATE *seqtt;
            seqtt = asn1_do_adb(pval, tt, 1);
            if (!seqtt)
                goto err;
            if (seqtt->flags & ASN1_TFLG_OPTIONAL) {
                ASN1_VALUE **pseqval;
                pseqval = asn1_get_field_ptr(pval, seqtt);
                ASN1_template_free(pseqval, seqtt);
            } else {
                errtt = seqtt;
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_FIELD_MISSING);
                goto err;
            }
        }
        /* Save encoding */
        if (!asn1_enc_save(pval, *in, p - *in, it))
            goto auxerr;
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
            goto auxerr;
        *in = p;
        return 1;

    default:
        return 0;
    }
 auxerr:
    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);
  auxerr:
     ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);
  err:
    ASN1_item_ex_free(pval, it);
     if (errtt)
         ERR_add_error_data(4, ""Field="", errtt->field_name,
                            "", Type="", it->sname);
}
","int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
                     const ASN1_ITEM *it,
                     int tag, int aclass, char opt, ASN1_TLC *ctx)
{
    const ASN1_TEMPLATE *tt, *errtt = NULL;
    const ASN1_COMPAT_FUNCS *cf;
    const ASN1_EXTERN_FUNCS *ef;
    const ASN1_AUX *aux = it->funcs;
    ASN1_aux_cb *asn1_cb;
    const unsigned char *p = NULL, *q;
    unsigned char *wp = NULL;   /* BIG FAT WARNING! BREAKS CONST WHERE USED */
    unsigned char imphack = 0, oclass;
    char seq_eoc, seq_nolen, cst, isopt;
    long tmplen;
    int i;
     int otag;
     int ret = 0;
     ASN1_VALUE **pchptr, *ptmpval;
    int combine = aclass & ASN1_TFLG_COMBINE;
    aclass &= ~ASN1_TFLG_COMBINE;
     if (!pval)
         return 0;
     if (aux && aux->asn1_cb)
        asn1_cb = 0;

    switch (it->itype) {
    case ASN1_ITYPE_PRIMITIVE:
        if (it->templates) {
            /*
             * tagging or OPTIONAL is currently illegal on an item template
             * because the flags can't get passed down. In practice this
             * isn't a problem: we include the relevant flags from the item
             * template in the template itself.
             */
            if ((tag != -1) || opt) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
                        ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
                goto err;
            }
            return asn1_template_ex_d2i(pval, in, len,
                                        it->templates, opt, ctx);
        }
        return asn1_d2i_ex_primitive(pval, in, len, it,
                                     tag, aclass, opt, ctx);
        break;

    case ASN1_ITYPE_MSTRING:
        p = *in;
        /* Just read in tag and class */
        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,
                              &p, len, -1, 0, 1, ctx);
        if (!ret) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        /* Must be UNIVERSAL class */
        if (oclass != V_ASN1_UNIVERSAL) {
            /* If OPTIONAL, assume this is OK */
            if (opt)
                return -1;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_NOT_UNIVERSAL);
            goto err;
        }
        /* Check tag matches bit map */
        if (!(ASN1_tag2bit(otag) & it->utype)) {
            /* If OPTIONAL, assume this is OK */
            if (opt)
                return -1;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_WRONG_TAG);
            goto err;
        }
        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);

    case ASN1_ITYPE_EXTERN:
        /* Use new style d2i */
        ef = it->funcs;
        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, ctx);

    case ASN1_ITYPE_COMPAT:
        /* we must resort to old style evil hackery */
        cf = it->funcs;

        /* If OPTIONAL see if it is there */
        if (opt) {
            int exptag;
            p = *in;
            if (tag == -1)
                exptag = it->utype;
            else
                exptag = tag;
            /*
             * Don't care about anything other than presence of expected tag
             */

            ret = asn1_check_tlen(NULL, NULL, NULL, NULL, NULL,
                                  &p, len, exptag, aclass, 1, ctx);
            if (!ret) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
                goto err;
            }
            if (ret == -1)
                return -1;
        }

        /*
         * This is the old style evil hack IMPLICIT handling: since the
         * underlying code is expecting a tag and class other than the one
         * present we change the buffer temporarily then change it back
         * afterwards. This doesn't and never did work for tags > 30. Yes
         * this is *horrible* but it is only needed for old style d2i which
         * will hopefully not be around for much longer. FIXME: should copy
         * the buffer then modify it so the input buffer can be const: we
         * should *always* copy because the old style d2i might modify the
         * buffer.
         */

        if (tag != -1) {
            wp = *(unsigned char **)in;
            imphack = *wp;
            if (p == NULL) {
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
                goto err;
            }
            *wp = (unsigned char)((*p & V_ASN1_CONSTRUCTED)
                                  | it->utype);
        }

        ptmpval = cf->asn1_d2i(pval, in, len);

        if (tag != -1)
            *wp = imphack;

        if (ptmpval)
            return 1;

        ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
        goto err;

    case ASN1_ITYPE_CHOICE:
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
            goto auxerr;
        if (*pval) {
            /* Free up and zero CHOICE value if initialised */
            i = asn1_get_choice_selector(pval, it);
            if ((i >= 0) && (i < it->tcount)) {
                tt = it->templates + i;
                pchptr = asn1_get_field_ptr(pval, tt);
                ASN1_template_free(pchptr, tt);
                asn1_set_choice_selector(pval, -1, it);
            }
        } else if (!ASN1_item_ex_new(pval, it)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }
        /* CHOICE type, try each possibility in turn */
        p = *in;
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            pchptr = asn1_get_field_ptr(pval, tt);
            /*
             * We mark field as OPTIONAL so its absence can be recognised.
             */
            ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx);
            /* If field not present, try the next one */
            if (ret == -1)
                continue;
            /* If positive return, read OK, break loop */
            if (ret > 0)
                break;
            /* Otherwise must be an ASN1 parsing error */
            errtt = tt;
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        /* Did we fall off the end without reading anything? */
        if (i == it->tcount) {
            /* If OPTIONAL, this is OK */
            if (opt) {
                /* Free and zero it */
                ASN1_item_ex_free(pval, it);
                return -1;
            }
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_NO_MATCHING_CHOICE_TYPE);
            goto err;
        }

        asn1_set_choice_selector(pval, i, it);
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
            goto auxerr;
        *in = p;
        return 1;

    case ASN1_ITYPE_NDEF_SEQUENCE:
    case ASN1_ITYPE_SEQUENCE:
        p = *in;
        tmplen = len;

        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */
        if (tag == -1) {
            tag = V_ASN1_SEQUENCE;
            aclass = V_ASN1_UNIVERSAL;
        }
        /* Get SEQUENCE length and update len, p */
        ret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,
                              &p, len, tag, aclass, opt, ctx);
        if (!ret) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        } else if (ret == -1)
            return -1;
        if (aux && (aux->flags & ASN1_AFLG_BROKEN)) {
            len = tmplen - (p - *in);
            seq_nolen = 1;
        }
        /* If indefinite we don't do a length check */
        else
            seq_nolen = seq_eoc;
        if (!cst) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
            goto err;
        }

        if (!*pval && !ASN1_item_ex_new(pval, it)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
            goto err;
        }

        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
            goto auxerr;

        /* Free up and zero any ADB found */
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            if (tt->flags & ASN1_TFLG_ADB_MASK) {
                const ASN1_TEMPLATE *seqtt;
                ASN1_VALUE **pseqval;
                seqtt = asn1_do_adb(pval, tt, 1);
                pseqval = asn1_get_field_ptr(pval, seqtt);
                ASN1_template_free(pseqval, seqtt);
            }
        }

        /* Get each field entry */
        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
            const ASN1_TEMPLATE *seqtt;
            ASN1_VALUE **pseqval;
            seqtt = asn1_do_adb(pval, tt, 1);
            if (!seqtt)
                goto err;
            pseqval = asn1_get_field_ptr(pval, seqtt);
            /* Have we ran out of data? */
            if (!len)
                break;
            q = p;
            if (asn1_check_eoc(&p, len)) {
                if (!seq_eoc) {
                    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_UNEXPECTED_EOC);
                    goto err;
                }
                len -= p - q;
                seq_eoc = 0;
                q = p;
                break;
            }
            /*
             * This determines the OPTIONAL flag value. The field cannot be
             * omitted if it is the last of a SEQUENCE and there is still
             * data to be read. This isn't strictly necessary but it
             * increases efficiency in some cases.
             */
            if (i == (it->tcount - 1))
                isopt = 0;
            else
                isopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);
            /*
             * attempt to read in field, allowing each to be OPTIONAL
             */

            ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx);
            if (!ret) {
                errtt = seqtt;
                goto err;
            } else if (ret == -1) {
                /*
                 * OPTIONAL component absent. Free and zero the field.
                 */
                ASN1_template_free(pseqval, seqtt);
                continue;
            }
            /* Update length */
            len -= p - q;
        }

        /* Check for EOC if expecting one */
        if (seq_eoc && !asn1_check_eoc(&p, len)) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MISSING_EOC);
            goto err;
        }
        /* Check all data read */
        if (!seq_nolen && len) {
            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_LENGTH_MISMATCH);
            goto err;
        }

        /*
         * If we get here we've got no more data in the SEQUENCE, however we
         * may not have read all fields so check all remaining are OPTIONAL
         * and clear any that are.
         */
        for (; i < it->tcount; tt++, i++) {
            const ASN1_TEMPLATE *seqtt;
            seqtt = asn1_do_adb(pval, tt, 1);
            if (!seqtt)
                goto err;
            if (seqtt->flags & ASN1_TFLG_OPTIONAL) {
                ASN1_VALUE **pseqval;
                pseqval = asn1_get_field_ptr(pval, seqtt);
                ASN1_template_free(pseqval, seqtt);
            } else {
                errtt = seqtt;
                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_FIELD_MISSING);
                goto err;
            }
        }
        /* Save encoding */
        if (!asn1_enc_save(pval, *in, p - *in, it))
            goto auxerr;
        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
            goto auxerr;
        *in = p;
        return 1;

    default:
        return 0;
    }
 auxerr:
    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);
  auxerr:
     ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);
  err:
    if (combine == 0)
        ASN1_item_ex_free(pval, it);
     if (errtt)
         ERR_add_error_data(4, ""Field="", errtt->field_name,
                            "", Type="", it->sname);
}
","The `ASN1_item_ex_d2i` function is designed to decode ASN.1 encoded data into a structured format based on the provided ASN.1 item type. It takes a pointer to an ASN.1 value, an input buffer, its length, and various parameters that define the expected structure, including tags and classes. The function handles different ASN.1 types such as primitive, constructed sequences, and choices, performing necessary checks for tags, classes, and optional fields. It also manages memory allocation and deallocation for the decoded structures, ensuring proper error handling and callbacks for auxiliary functions during the decoding process.","The provided code implements a function that decodes ASN.1 encoded data into a structured format based on specified item types. It processes various ASN.1 constructs, including primitive types, sequences, and choices, while validating tags and classes. The function manages memory for the decoded structures, ensuring proper allocation and deallocation. It also handles optional fields and checks for errors during the decoding process, providing feedback when expected data is missing or mismatched. Additionally, it supports callbacks for auxiliary processing, enhancing flexibility in handling different ASN.1 data representations.","The vulnerability in the original code stemmed from improper handling of memory and potential misuse of the input buffer, particularly in the section dealing with implicit tagging. Specifically, the code modified the input buffer directly without ensuring it was safe to do so, which could lead to undefined behavior or memory corruption. In the fixed code, the handling of the `aclass` variable was improved by isolating the `ASN1_TFLG_COMBINE` flag, ensuring that it was cleared before further processing. This change helps prevent unintended side effects when combining flags, thereby enhancing the overall stability and security of the decoding process.","The vulnerability in the original code was due to improper handling of memory and potential buffer manipulation, particularly when modifying the input buffer directly without adequate safeguards. This could lead to undefined behavior or memory corruption, especially in scenarios involving implicit tagging. The fix involved isolating specific flags to ensure they were cleared before further processing, which mitigated the risk of unintended side effects. By refining the handling of these flags, the updated code enhances stability and security, ensuring that memory operations are performed safely and that the integrity of the input data is maintained throughout the decoding process.","The vulnerability was fixed by modifying the handling of the `aclass` variable to isolate the `ASN1_TFLG_COMBINE` flag. In the updated code, the `combine` variable is introduced to store the combined flag value, and `aclass` is cleared of the `ASN1_TFLG_COMBINE` flag before further processing. This change ensures that the flag does not interfere with subsequent operations, preventing unintended side effects during the decoding process. Additionally, the condition for freeing memory is adjusted to check the `combine` variable, ensuring that memory is only freed when appropriate, thus enhancing the overall stability and security of the function.","The vulnerability was addressed by refining the handling of specific flags related to memory management and input processing. The updated code introduced a mechanism to isolate and clear a particular flag before further operations, ensuring that it does not interfere with subsequent logic. This change prevents unintended side effects that could arise from improper flag combinations. Additionally, the conditions for freeing memory were adjusted to ensure that memory is only released when appropriate, thereby enhancing the overall stability and security of the function while safeguarding against potential memory corruption or undefined behavior.","3, 4","2, 2","2,4","3,4"
9,9,177893,177893,,Remote,Not required,,CVE-2015-3193,https://www.cvedetails.com/cve/CVE-2015-3193/,CWE-200,Low,Partial,,,2015-12-06,5.0,"The Montgomery squaring implementation in crypto/bn/asm/x86_64-mont5.pl in OpenSSL 1.0.2 before 1.0.2e on the x86_64 platform, as used by the BN_mod_exp function, mishandles carry propagation and produces incorrect output, which makes it easier for remote attackers to obtain sensitive private-key information via an attack against use of a (1) Diffie-Hellman (DH) or (2) Diffie-Hellman Ephemeral (DHE) ciphersuite.",2017-11-29,+Info,18,https://git.openssl.org/?p=openssl.git;a=commit;h=d73cc256c8e256c32ed959456101b73ba9842f72,d73cc256c8e256c32ed959456101b73ba9842f72,,0,,,"int test_mod_exp(BIO *bp, BN_CTX *ctx)
{
    BIGNUM *a, *b, *c, *d, *e;
    int i;

    a = BN_new();
    b = BN_new();
    c = BN_new();
    d = BN_new();
    e = BN_new();

    BN_one(a);
    BN_one(b);
    BN_zero(c);
    if (BN_mod_exp(d, a, b, c, ctx)) {
        fprintf(stderr, ""BN_mod_exp with zero modulus succeeded!\n"");
        return 0;
    }

    BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */
    for (i = 0; i < num2; i++) {
        BN_bntest_rand(a, 20 + i * 5, 0, 0);
        BN_bntest_rand(b, 2 + i, 0, 0);

        if (!BN_mod_exp(d, a, b, c, ctx))
            return (0);

        if (bp != NULL) {
            if (!results) {
                BN_print(bp, a);
                BIO_puts(bp, "" ^ "");
                BN_print(bp, b);
                BIO_puts(bp, "" % "");
                BN_print(bp, c);
                BIO_puts(bp, "" - "");
            }
            BN_print(bp, d);
            BIO_puts(bp, ""\n"");
        }
        BN_exp(e, a, b, ctx);
        BN_sub(e, e, d);
        BN_div(a, b, e, c, ctx);
        if (!BN_is_zero(b)) {
            fprintf(stderr, ""Modulo exponentiation test failed!\n"");
             return 0;
         }
     }

    /* Regression test for carry propagation bug in sqr8x_reduction */
    BN_hex2bn(&a, ""050505050505"");
    BN_hex2bn(&b, ""02"");
    BN_hex2bn(&c,
        ""4141414141414141414141274141414141414141414141414141414141414141""
        ""4141414141414141414141414141414141414141414141414141414141414141""
        ""4141414141414141414141800000000000000000000000000000000000000000""
        ""0000000000000000000000000000000000000000000000000000000000000000""
        ""0000000000000000000000000000000000000000000000000000000000000000""
        ""0000000000000000000000000000000000000000000000000000000001"");
    BN_mod_exp(d, a, b, c, ctx);
    BN_mul(e, a, a, ctx);
    if (BN_cmp(d, e)) {
        fprintf(stderr, ""BN_mod_exp and BN_mul produce different results!\n"");
        return 0;
    }

     BN_free(a);
     BN_free(b);
     BN_free(c);
    BN_zero(c);
    if (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {
        fprintf(stderr, ""BN_mod_exp_mont_consttime with zero modulus ""
                ""succeeded\n"");
        return 0;
    }

    BN_set_word(c, 16);
    if (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {
        fprintf(stderr, ""BN_mod_exp_mont_consttime with even modulus ""
                ""succeeded\n"");
        return 0;
    }

    BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */
    for (i = 0; i < num2; i++) {
        BN_bntest_rand(a, 20 + i * 5, 0, 0);
        BN_bntest_rand(b, 2 + i, 0, 0);

        if (!BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL))
            return (00);

        if (bp != NULL) {
            if (!results) {
                BN_print(bp, a);
                BIO_puts(bp, "" ^ "");
                BN_print(bp, b);
                BIO_puts(bp, "" % "");
                BN_print(bp, c);
                BIO_puts(bp, "" - "");
            }
            BN_print(bp, d);
            BIO_puts(bp, ""\n"");
        }
        BN_exp(e, a, b, ctx);
        BN_sub(e, e, d);
        BN_div(a, b, e, c, ctx);
        if (!BN_is_zero(b)) {
            fprintf(stderr, ""Modulo exponentiation test failed!\n"");
            return 0;
        }
    }
    BN_free(a);
    BN_free(b);
    BN_free(c);
    BN_free(d);
    BN_free(e);
    return (1);
}
","int test_mod_exp(BIO *bp, BN_CTX *ctx)
{
    BIGNUM *a, *b, *c, *d, *e;
    int i;

    a = BN_new();
    b = BN_new();
    c = BN_new();
    d = BN_new();
    e = BN_new();

    BN_one(a);
    BN_one(b);
    BN_zero(c);
    if (BN_mod_exp(d, a, b, c, ctx)) {
        fprintf(stderr, ""BN_mod_exp with zero modulus succeeded!\n"");
        return 0;
    }

    BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */
    for (i = 0; i < num2; i++) {
        BN_bntest_rand(a, 20 + i * 5, 0, 0);
        BN_bntest_rand(b, 2 + i, 0, 0);

        if (!BN_mod_exp(d, a, b, c, ctx))
            return (0);

        if (bp != NULL) {
            if (!results) {
                BN_print(bp, a);
                BIO_puts(bp, "" ^ "");
                BN_print(bp, b);
                BIO_puts(bp, "" % "");
                BN_print(bp, c);
                BIO_puts(bp, "" - "");
            }
            BN_print(bp, d);
            BIO_puts(bp, ""\n"");
        }
        BN_exp(e, a, b, ctx);
        BN_sub(e, e, d);
        BN_div(a, b, e, c, ctx);
        if (!BN_is_zero(b)) {
            fprintf(stderr, ""Modulo exponentiation test failed!\n"");
             return 0;
         }
     }
     BN_free(a);
     BN_free(b);
     BN_free(c);
    BN_zero(c);
    if (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {
        fprintf(stderr, ""BN_mod_exp_mont_consttime with zero modulus ""
                ""succeeded\n"");
        return 0;
    }

    BN_set_word(c, 16);
    if (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {
        fprintf(stderr, ""BN_mod_exp_mont_consttime with even modulus ""
                ""succeeded\n"");
        return 0;
    }

    BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */
    for (i = 0; i < num2; i++) {
        BN_bntest_rand(a, 20 + i * 5, 0, 0);
        BN_bntest_rand(b, 2 + i, 0, 0);

        if (!BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL))
            return (00);

        if (bp != NULL) {
            if (!results) {
                BN_print(bp, a);
                BIO_puts(bp, "" ^ "");
                BN_print(bp, b);
                BIO_puts(bp, "" % "");
                BN_print(bp, c);
                BIO_puts(bp, "" - "");
            }
            BN_print(bp, d);
            BIO_puts(bp, ""\n"");
        }
        BN_exp(e, a, b, ctx);
        BN_sub(e, e, d);
        BN_div(a, b, e, c, ctx);
        if (!BN_is_zero(b)) {
            fprintf(stderr, ""Modulo exponentiation test failed!\n"");
            return 0;
        }
    }
    BN_free(a);
    BN_free(b);
    BN_free(c);
    BN_free(d);
    BN_free(e);
    return (1);
}
",C,"
    /* Regression test for carry propagation bug in sqr8x_reduction */
    BN_hex2bn(&a, ""050505050505"");
    BN_hex2bn(&b, ""02"");
    BN_hex2bn(&c,
        ""4141414141414141414141274141414141414141414141414141414141414141""
        ""4141414141414141414141414141414141414141414141414141414141414141""
        ""4141414141414141414141800000000000000000000000000000000000000000""
        ""0000000000000000000000000000000000000000000000000000000000000000""
        ""0000000000000000000000000000000000000000000000000000000000000000""
        ""0000000000000000000000000000000000000000000000000000000001"");
    BN_mod_exp(d, a, b, c, ctx);
    BN_mul(e, a, a, ctx);
    if (BN_cmp(d, e)) {
        fprintf(stderr, ""BN_mod_exp and BN_mul produce different results!\n"");
        return 0;
    }

",,cc598f321fbac9c04da5766243ed55d55948637d,"@@ -1016,6 +1016,24 @@ int test_mod_exp(BIO *bp, BN_CTX *ctx)
             return 0;
         }
     }
+
+    /* Regression test for carry propagation bug in sqr8x_reduction */
+    BN_hex2bn(&a, ""050505050505"");
+    BN_hex2bn(&b, ""02"");
+    BN_hex2bn(&c,
+        ""4141414141414141414141274141414141414141414141414141414141414141""
+        ""4141414141414141414141414141414141414141414141414141414141414141""
+        ""4141414141414141414141800000000000000000000000000000000000000000""
+        ""0000000000000000000000000000000000000000000000000000000000000000""
+        ""0000000000000000000000000000000000000000000000000000000000000000""
+        ""0000000000000000000000000000000000000000000000000000000001"");
+    BN_mod_exp(d, a, b, c, ctx);
+    BN_mul(e, a, a, ctx);
+    if (BN_cmp(d, e)) {
+        fprintf(stderr, ""BN_mod_exp and BN_mul produce different results!\n"");
+        return 0;
+    }
+
     BN_free(a);
     BN_free(b);
     BN_free(c);",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/bn/bntest.c;h=1e35988022bbcb49ae1b5c267e8479a713ca9a59;hb=d73cc256c8e256c32ed959456101b73ba9842f72,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/bn/bntest.c;h=8b8a15220e18a739aa24232997b66a72de81bcb9,1,"int test_mod_exp(BIO *bp, BN_CTX *ctx)
{
    BIGNUM *a, *b, *c, *d, *e;
    int i;

    a = BN_new();
    b = BN_new();
    c = BN_new();
    d = BN_new();
    e = BN_new();

    BN_one(a);
    BN_one(b);
    BN_zero(c);
    if (BN_mod_exp(d, a, b, c, ctx)) {
        fprintf(stderr, ""BN_mod_exp with zero modulus succeeded!\n"");
        return 0;
    }

    BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */
    for (i = 0; i < num2; i++) {
        BN_bntest_rand(a, 20 + i * 5, 0, 0);
        BN_bntest_rand(b, 2 + i, 0, 0);

        if (!BN_mod_exp(d, a, b, c, ctx))
            return (0);

        if (bp != NULL) {
            if (!results) {
                BN_print(bp, a);
                BIO_puts(bp, "" ^ "");
                BN_print(bp, b);
                BIO_puts(bp, "" % "");
                BN_print(bp, c);
                BIO_puts(bp, "" - "");
            }
            BN_print(bp, d);
            BIO_puts(bp, ""\n"");
        }
        BN_exp(e, a, b, ctx);
        BN_sub(e, e, d);
        BN_div(a, b, e, c, ctx);
        if (!BN_is_zero(b)) {
            fprintf(stderr, ""Modulo exponentiation test failed!\n"");
             return 0;
         }
     }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    /* Regression test for carry propagation bug in sqr8x_reduction */
//fix_flaw_line_below:
//    BN_hex2bn(&a, ""050505050505"");
//fix_flaw_line_below:
//    BN_hex2bn(&b, ""02"");
//fix_flaw_line_below:
//    BN_hex2bn(&c,
//fix_flaw_line_below:
//        ""4141414141414141414141274141414141414141414141414141414141414141""
//fix_flaw_line_below:
//        ""4141414141414141414141414141414141414141414141414141414141414141""
//fix_flaw_line_below:
//        ""4141414141414141414141800000000000000000000000000000000000000000""
//fix_flaw_line_below:
//        ""0000000000000000000000000000000000000000000000000000000000000000""
//fix_flaw_line_below:
//        ""0000000000000000000000000000000000000000000000000000000000000000""
//fix_flaw_line_below:
//        ""0000000000000000000000000000000000000000000000000000000001"");
//fix_flaw_line_below:
//    BN_mod_exp(d, a, b, c, ctx);
//fix_flaw_line_below:
//    BN_mul(e, a, a, ctx);
//fix_flaw_line_below:
//    if (BN_cmp(d, e)) {
//fix_flaw_line_below:
//        fprintf(stderr, ""BN_mod_exp and BN_mul produce different results!\n"");
//fix_flaw_line_below:
//        return 0;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     BN_free(a);
     BN_free(b);
     BN_free(c);
    BN_zero(c);
    if (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {
        fprintf(stderr, ""BN_mod_exp_mont_consttime with zero modulus ""
                ""succeeded\n"");
        return 0;
    }

    BN_set_word(c, 16);
    if (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {
        fprintf(stderr, ""BN_mod_exp_mont_consttime with even modulus ""
                ""succeeded\n"");
        return 0;
    }

    BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */
    for (i = 0; i < num2; i++) {
        BN_bntest_rand(a, 20 + i * 5, 0, 0);
        BN_bntest_rand(b, 2 + i, 0, 0);

        if (!BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL))
            return (00);

        if (bp != NULL) {
            if (!results) {
                BN_print(bp, a);
                BIO_puts(bp, "" ^ "");
                BN_print(bp, b);
                BIO_puts(bp, "" % "");
                BN_print(bp, c);
                BIO_puts(bp, "" - "");
            }
            BN_print(bp, d);
            BIO_puts(bp, ""\n"");
        }
        BN_exp(e, a, b, ctx);
        BN_sub(e, e, d);
        BN_div(a, b, e, c, ctx);
        if (!BN_is_zero(b)) {
            fprintf(stderr, ""Modulo exponentiation test failed!\n"");
            return 0;
        }
    }
    BN_free(a);
    BN_free(b);
    BN_free(c);
    BN_free(d);
    BN_free(e);
    return (1);
}
",177893,"int test_mod_exp(BIO *bp, BN_CTX *ctx)
{
    BIGNUM *a, *b, *c, *d, *e;
    int i;

    a = BN_new();
    b = BN_new();
    c = BN_new();
    d = BN_new();
    e = BN_new();

    BN_one(a);
    BN_one(b);
    BN_zero(c);
    if (BN_mod_exp(d, a, b, c, ctx)) {
        fprintf(stderr, ""BN_mod_exp with zero modulus succeeded!\n"");
        return 0;
    }

    BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */
    for (i = 0; i < num2; i++) {
        BN_bntest_rand(a, 20 + i * 5, 0, 0);
        BN_bntest_rand(b, 2 + i, 0, 0);

        if (!BN_mod_exp(d, a, b, c, ctx))
            return (0);

        if (bp != NULL) {
            if (!results) {
                BN_print(bp, a);
                BIO_puts(bp, "" ^ "");
                BN_print(bp, b);
                BIO_puts(bp, "" % "");
                BN_print(bp, c);
                BIO_puts(bp, "" - "");
            }
            BN_print(bp, d);
            BIO_puts(bp, ""\n"");
        }
        BN_exp(e, a, b, ctx);
        BN_sub(e, e, d);
        BN_div(a, b, e, c, ctx);
        if (!BN_is_zero(b)) {
            fprintf(stderr, ""Modulo exponentiation test failed!\n"");
             return 0;
         }
     }
     BN_free(a);
     BN_free(b);
     BN_free(c);
    BN_zero(c);
    if (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {
        fprintf(stderr, ""BN_mod_exp_mont_consttime with zero modulus ""
                ""succeeded\n"");
        return 0;
    }

    BN_set_word(c, 16);
    if (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {
        fprintf(stderr, ""BN_mod_exp_mont_consttime with even modulus ""
                ""succeeded\n"");
        return 0;
    }

    BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */
    for (i = 0; i < num2; i++) {
        BN_bntest_rand(a, 20 + i * 5, 0, 0);
        BN_bntest_rand(b, 2 + i, 0, 0);

        if (!BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL))
            return (00);

        if (bp != NULL) {
            if (!results) {
                BN_print(bp, a);
                BIO_puts(bp, "" ^ "");
                BN_print(bp, b);
                BIO_puts(bp, "" % "");
                BN_print(bp, c);
                BIO_puts(bp, "" - "");
            }
            BN_print(bp, d);
            BIO_puts(bp, ""\n"");
        }
        BN_exp(e, a, b, ctx);
        BN_sub(e, e, d);
        BN_div(a, b, e, c, ctx);
        if (!BN_is_zero(b)) {
            fprintf(stderr, ""Modulo exponentiation test failed!\n"");
            return 0;
        }
    }
    BN_free(a);
    BN_free(b);
    BN_free(c);
    BN_free(d);
    BN_free(e);
    return (1);
}
","int test_mod_exp(BIO *bp, BN_CTX *ctx)
{
    BIGNUM *a, *b, *c, *d, *e;
    int i;

    a = BN_new();
    b = BN_new();
    c = BN_new();
    d = BN_new();
    e = BN_new();

    BN_one(a);
    BN_one(b);
    BN_zero(c);
    if (BN_mod_exp(d, a, b, c, ctx)) {
        fprintf(stderr, ""BN_mod_exp with zero modulus succeeded!\n"");
        return 0;
    }

    BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */
    for (i = 0; i < num2; i++) {
        BN_bntest_rand(a, 20 + i * 5, 0, 0);
        BN_bntest_rand(b, 2 + i, 0, 0);

        if (!BN_mod_exp(d, a, b, c, ctx))
            return (0);

        if (bp != NULL) {
            if (!results) {
                BN_print(bp, a);
                BIO_puts(bp, "" ^ "");
                BN_print(bp, b);
                BIO_puts(bp, "" % "");
                BN_print(bp, c);
                BIO_puts(bp, "" - "");
            }
            BN_print(bp, d);
            BIO_puts(bp, ""\n"");
        }
        BN_exp(e, a, b, ctx);
        BN_sub(e, e, d);
        BN_div(a, b, e, c, ctx);
        if (!BN_is_zero(b)) {
            fprintf(stderr, ""Modulo exponentiation test failed!\n"");
             return 0;
         }
     }

    /* Regression test for carry propagation bug in sqr8x_reduction */
    BN_hex2bn(&a, ""050505050505"");
    BN_hex2bn(&b, ""02"");
    BN_hex2bn(&c,
        ""4141414141414141414141274141414141414141414141414141414141414141""
        ""4141414141414141414141414141414141414141414141414141414141414141""
        ""4141414141414141414141800000000000000000000000000000000000000000""
        ""0000000000000000000000000000000000000000000000000000000000000000""
        ""0000000000000000000000000000000000000000000000000000000000000000""
        ""0000000000000000000000000000000000000000000000000000000001"");
    BN_mod_exp(d, a, b, c, ctx);
    BN_mul(e, a, a, ctx);
    if (BN_cmp(d, e)) {
        fprintf(stderr, ""BN_mod_exp and BN_mul produce different results!\n"");
        return 0;
    }

     BN_free(a);
     BN_free(b);
     BN_free(c);
    BN_zero(c);
    if (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {
        fprintf(stderr, ""BN_mod_exp_mont_consttime with zero modulus ""
                ""succeeded\n"");
        return 0;
    }

    BN_set_word(c, 16);
    if (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {
        fprintf(stderr, ""BN_mod_exp_mont_consttime with even modulus ""
                ""succeeded\n"");
        return 0;
    }

    BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */
    for (i = 0; i < num2; i++) {
        BN_bntest_rand(a, 20 + i * 5, 0, 0);
        BN_bntest_rand(b, 2 + i, 0, 0);

        if (!BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL))
            return (00);

        if (bp != NULL) {
            if (!results) {
                BN_print(bp, a);
                BIO_puts(bp, "" ^ "");
                BN_print(bp, b);
                BIO_puts(bp, "" % "");
                BN_print(bp, c);
                BIO_puts(bp, "" - "");
            }
            BN_print(bp, d);
            BIO_puts(bp, ""\n"");
        }
        BN_exp(e, a, b, ctx);
        BN_sub(e, e, d);
        BN_div(a, b, e, c, ctx);
        if (!BN_is_zero(b)) {
            fprintf(stderr, ""Modulo exponentiation test failed!\n"");
            return 0;
        }
    }
    BN_free(a);
    BN_free(b);
    BN_free(c);
    BN_free(d);
    BN_free(e);
    return (1);
}
","The `test_mod_exp` function performs a series of tests on modular exponentiation using the OpenSSL BIGNUM library. It initializes several BIGNUM variables and checks the behavior of the `BN_mod_exp` and `BN_mod_exp_mont_consttime` functions with various inputs, including edge cases like zero and even moduli. The function generates random values for the base and exponent, computes the modular exponentiation, and verifies the results against direct exponentiation. If any test fails, it outputs an error message. The results can be printed to a BIO object if provided, and all allocated BIGNUMs are freed before the function returns a success indicator.","The provided code implements a series of tests to validate the functionality of modular exponentiation operations. It initializes multiple large number variables and checks how the operations handle special cases, such as zero and even moduli. The code generates random values for the base and exponent, performs modular exponentiation, and compares the results with direct exponentiation calculations to ensure correctness. If any test fails, an error message is displayed. Additionally, results can be printed to a specified output stream, and all allocated resources are properly released before the function concludes with a success status.","The vulnerability in the original code arises from the handling of zero and even moduli during modular exponentiation, which can lead to incorrect results or unexpected behavior. Specifically, the function incorrectly allows operations with a zero modulus, as indicated by the success message when `BN_mod_exp` is called with a zero modulus. The fixed code addresses this issue by adding checks to ensure that operations with zero or even moduli are properly handled, preventing the functions from succeeding in these cases. This change enhances the robustness of the code by ensuring that only valid modulus values are used in calculations.","The vulnerability in the original code stems from the improper handling of zero and even modulus values during modular exponentiation, which could lead to incorrect results or unexpected behavior. Specifically, the code allowed operations to succeed with a zero modulus, which is mathematically invalid. The fixed code addresses this issue by implementing checks that prevent operations from proceeding when the modulus is zero or even, ensuring that only valid modulus values are used in calculations. This change enhances the overall reliability and correctness of the modular exponentiation functionality, preventing potential errors in cryptographic computations.","The vulnerability was fixed by adding checks to ensure that operations with zero and even modulus values are not allowed. In the updated code, after initializing the modulus variable, the function checks if `BN_mod_exp` is called with a zero modulus, and if so, it outputs an error message and returns early. Additionally, the code verifies that the modulus is not even before proceeding with the modular exponentiation operations. These changes prevent the functions from succeeding with invalid modulus values, thereby enhancing the correctness and security of the modular exponentiation process.","The vulnerability was addressed by implementing checks that prevent the execution of modular exponentiation operations when the modulus is zero or even. The updated code includes conditions that immediately halt the process and return an error message if an invalid modulus is detected. This ensures that the calculations only proceed with valid modulus values, thereby eliminating the risk of incorrect results or undefined behavior. By enforcing these constraints, the code enhances its reliability and security, particularly in cryptographic contexts where accurate mathematical operations are crucial.","4, 4","5,5","4,4","4,4"
10,10,177897,177897,,Remote,Not required,,CVE-2013-1824,https://www.cvedetails.com/cve/CVE-2013-1824/,CWE-200,Medium,Partial,,,2013-09-16,4.3,"The SOAP parser in PHP before 5.3.22 and 5.4.x before 5.4.12 allows remote attackers to read arbitrary files via a SOAP WSDL file containing an XML external entity declaration in conjunction with an entity reference, related to an XML External Entity (XXE) issue in the soap_xmlParseFile and soap_xmlParseMemory functions.",2019-04-22,+Info,1,https://git.php.net/?p=php-src.git;a=commit;h=188c196d4da60bdde9190d2fc532650d17f7af2d,188c196d4da60bdde9190d2fc532650d17f7af2d,,1,,,"xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;
	zend_bool old_allow_url_fopen;

/*
	xmlInitParser();
*/

	old_allow_url_fopen = PG(allow_url_fopen);
	PG(allow_url_fopen) = 1;
	ctxt = xmlCreateFileParserCtxt(filename);
        PG(allow_url_fopen) = old_allow_url_fopen;
        if (ctxt) {
                ctxt->keepBlanks = 0;
               ctxt->options &= ~XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
		ctxt->sax->error = NULL;
		/*ctxt->sax->fatalError = NULL;*/
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
	return ret;
}
","xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;
	zend_bool old_allow_url_fopen;

/*
	xmlInitParser();
*/

	old_allow_url_fopen = PG(allow_url_fopen);
	PG(allow_url_fopen) = 1;
	ctxt = xmlCreateFileParserCtxt(filename);
        PG(allow_url_fopen) = old_allow_url_fopen;
        if (ctxt) {
                ctxt->keepBlanks = 0;
               ctxt->options -= XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
		ctxt->sax->error = NULL;
		/*ctxt->sax->fatalError = NULL;*/
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
	return ret;
}
",C,"               ctxt->options &= ~XML_PARSE_DTDLOAD;
","               ctxt->options -= XML_PARSE_DTDLOAD;
",afe98b7829d50806559acac9b530acb8283c3bf4,"@@ -92,7 +92,7 @@ xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)
        PG(allow_url_fopen) = old_allow_url_fopen;
        if (ctxt) {
                ctxt->keepBlanks = 0;
-               ctxt->options -= XML_PARSE_DTDLOAD;
+               ctxt->options &= ~XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
@@ -134,7 +134,7 @@ xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)
 */
        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);
        if (ctxt) {
-               ctxt->options -= XML_PARSE_DTDLOAD;
+               ctxt->options &= ~XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/soap/php_xml.c;h=006db854e439af8cdb8fa748465ffb42bf0485f0;hb=006db854e439af8cdb8fa748465ffb42bf0485f0,https://git.php.net/?p=php-src.git;a=blob;f=ext/soap/php_xml.c;h=a69d071164fe78c52eeff3b0fa2b7b33f61e0234;hb=a69d071164fe78c52eeff3b0fa2b7b33f61e0234,1,"xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;
	zend_bool old_allow_url_fopen;

/*
	xmlInitParser();
*/

	old_allow_url_fopen = PG(allow_url_fopen);
	PG(allow_url_fopen) = 1;
	ctxt = xmlCreateFileParserCtxt(filename);
        PG(allow_url_fopen) = old_allow_url_fopen;
        if (ctxt) {
                ctxt->keepBlanks = 0;
//flaw_line_below:
               ctxt->options -= XML_PARSE_DTDLOAD;
//fix_flaw_line_below:
//               ctxt->options &= ~XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
		ctxt->sax->error = NULL;
		/*ctxt->sax->fatalError = NULL;*/
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
	return ret;
}
",177897,"xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;
	zend_bool old_allow_url_fopen;

/*
	xmlInitParser();
*/

	old_allow_url_fopen = PG(allow_url_fopen);
	PG(allow_url_fopen) = 1;
	ctxt = xmlCreateFileParserCtxt(filename);
        PG(allow_url_fopen) = old_allow_url_fopen;
        if (ctxt) {
                ctxt->keepBlanks = 0;
               ctxt->options -= XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
		ctxt->sax->error = NULL;
		/*ctxt->sax->fatalError = NULL;*/
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
	return ret;
}
","xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;
	zend_bool old_allow_url_fopen;

/*
	xmlInitParser();
*/

	old_allow_url_fopen = PG(allow_url_fopen);
	PG(allow_url_fopen) = 1;
	ctxt = xmlCreateFileParserCtxt(filename);
        PG(allow_url_fopen) = old_allow_url_fopen;
        if (ctxt) {
                ctxt->keepBlanks = 0;
               ctxt->options &= ~XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
		ctxt->sax->error = NULL;
		/*ctxt->sax->fatalError = NULL;*/
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
	return ret;
}
","The `soap_xmlParseFile` function is designed to parse an XML file specified by the `filename` parameter. It initializes a parser context, temporarily allows URL file access, and creates a file parser context for the specified XML file. The function configures the SAX (Simple API for XML) handlers to manage whitespace and comments, while disabling DTD loading for security. After parsing, it checks if the document is well-formed; if so, it retrieves the parsed document and sets its URL if not already defined. If parsing fails, it cleans up and returns `NULL`. Finally, it cleans up the parser context and any allocated resources.","The provided code defines a function that parses an XML file specified by a filename. It temporarily modifies a setting to allow file access over URLs and creates a context for parsing the XML file. The function configures handlers to manage whitespace and comments while disabling a specific feature for security. After attempting to parse the document, it checks if the XML is well-formed; if it is, the parsed document is returned, and its URL is set if not already defined. If parsing fails, it cleans up resources and returns a null value, ensuring proper memory management throughout.","The vulnerability in the original code stemmed from the use of the `PG(allow_url_fopen)` setting, which was temporarily enabled without proper validation, potentially allowing remote file inclusion or XML External Entity (XXE) attacks. This could lead to unauthorized access to sensitive files or services. In the fixed code, the change from `ctxt->options -= XML_PARSE_DTDLOAD` to `ctxt->options &= ~XML_PARSE_DTDLOAD` ensures that DTD loading is explicitly disabled, enhancing security by preventing the parser from processing external entities. This modification mitigates the risk of XXE attacks while maintaining the intended functionality of the XML parsing process.","The vulnerability in the original code arose from the potential for XML External Entity (XXE) attacks, which could occur due to the improper handling of external entities when parsing XML files. This could allow an attacker to read sensitive files or perform other malicious actions by exploiting the parser's ability to access external resources. The fix involved explicitly disabling the loading of Document Type Definitions (DTDs), which mitigated the risk of processing external entities. This change enhanced the security of the XML parsing process by ensuring that the parser would not inadvertently access or process untrusted external content.","The vulnerability was fixed by changing the way DTD loading was handled in the parser context. The original code used `ctxt->options -= XML_PARSE_DTDLOAD`, which could lead to unintended consequences if the option was not set correctly. The fix replaced this with `ctxt->options &= ~XML_PARSE_DTDLOAD`, explicitly disabling DTD loading. This ensures that the parser does not process external entities, thereby mitigating the risk of XML External Entity (XXE) attacks. By making this change, the code enhances security while maintaining the intended functionality of parsing XML documents safely.","The vulnerability was fixed by explicitly disabling the loading of Document Type Definitions (DTDs) in the XML parser configuration. This change ensures that the parser does not process external entities, which could be exploited in XML External Entity (XXE) attacks. By modifying the parser's options to prevent DTD loading, the code mitigates the risk of unauthorized access to sensitive files or services that could occur through malicious XML content. This enhancement improves the overall security of the XML parsing process while preserving its intended functionality.","4, 4","5,5","4,4","4,4"
11,11,177898,177898,,Remote,Not required,,CVE-2013-1824,https://www.cvedetails.com/cve/CVE-2013-1824/,CWE-200,Medium,Partial,,,2013-09-16,4.3,"The SOAP parser in PHP before 5.3.22 and 5.4.x before 5.4.12 allows remote attackers to read arbitrary files via a SOAP WSDL file containing an XML external entity declaration in conjunction with an entity reference, related to an XML External Entity (XXE) issue in the soap_xmlParseFile and soap_xmlParseMemory functions.",2019-04-22,+Info,1,https://git.php.net/?p=php-src.git;a=commit;h=188c196d4da60bdde9190d2fc532650d17f7af2d,188c196d4da60bdde9190d2fc532650d17f7af2d,,1,,,"xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;

/*
	xmlInitParser();
 */
        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);
        if (ctxt) {
               ctxt->options &= ~XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
		ctxt->sax->error = NULL;
		/*ctxt->sax->fatalError = NULL;*/
#if LIBXML_VERSION >= 20703
		ctxt->options |= XML_PARSE_HUGE;
#endif
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

/*
	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
*/
	return ret;
}
","xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;

/*
	xmlInitParser();
 */
        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);
        if (ctxt) {
               ctxt->options -= XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
		ctxt->sax->error = NULL;
		/*ctxt->sax->fatalError = NULL;*/
#if LIBXML_VERSION >= 20703
		ctxt->options |= XML_PARSE_HUGE;
#endif
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

/*
	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
*/
	return ret;
}
",C,"               ctxt->options &= ~XML_PARSE_DTDLOAD;
","               ctxt->options -= XML_PARSE_DTDLOAD;
",afe98b7829d50806559acac9b530acb8283c3bf4,"@@ -92,7 +92,7 @@ xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)
        PG(allow_url_fopen) = old_allow_url_fopen;
        if (ctxt) {
                ctxt->keepBlanks = 0;
-               ctxt->options -= XML_PARSE_DTDLOAD;
+               ctxt->options &= ~XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
@@ -134,7 +134,7 @@ xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)
 */
        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);
        if (ctxt) {
-               ctxt->options -= XML_PARSE_DTDLOAD;
+               ctxt->options &= ~XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/soap/php_xml.c;h=006db854e439af8cdb8fa748465ffb42bf0485f0;hb=006db854e439af8cdb8fa748465ffb42bf0485f0,https://git.php.net/?p=php-src.git;a=blob;f=ext/soap/php_xml.c;h=a69d071164fe78c52eeff3b0fa2b7b33f61e0234;hb=a69d071164fe78c52eeff3b0fa2b7b33f61e0234,1,"xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;

/*
	xmlInitParser();
 */
        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);
        if (ctxt) {
//flaw_line_below:
               ctxt->options -= XML_PARSE_DTDLOAD;
//fix_flaw_line_below:
//               ctxt->options &= ~XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
		ctxt->sax->error = NULL;
		/*ctxt->sax->fatalError = NULL;*/
#if LIBXML_VERSION >= 20703
		ctxt->options |= XML_PARSE_HUGE;
#endif
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

/*
	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
*/
	return ret;
}
",177898,"xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;

/*
	xmlInitParser();
 */
        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);
        if (ctxt) {
               ctxt->options -= XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
		ctxt->sax->error = NULL;
		/*ctxt->sax->fatalError = NULL;*/
#if LIBXML_VERSION >= 20703
		ctxt->options |= XML_PARSE_HUGE;
#endif
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

/*
	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
*/
	return ret;
}
","xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;

/*
	xmlInitParser();
 */
        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);
        if (ctxt) {
               ctxt->options &= ~XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
		ctxt->sax->error = NULL;
		/*ctxt->sax->fatalError = NULL;*/
#if LIBXML_VERSION >= 20703
		ctxt->options |= XML_PARSE_HUGE;
#endif
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

/*
	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
*/
	return ret;
}
","The function `soap_xmlParseMemory` is designed to parse an XML document from a memory buffer, specified by `buf` and its size `buf_size`. It initializes a parser context and configures it to ignore whitespace and comments while disabling DTD loading for security. The function then attempts to parse the document, checking if it is well-formed. If successful, it assigns the parsed document to the return variable and sets its URL if a directory is provided. If parsing fails, it cleans up by freeing the document and context. Finally, it returns the parsed document or `NULL` if an error occurred.","The provided code defines a function that parses an XML document from a memory buffer, allowing for the processing of XML data without relying on external files. It initializes a context for parsing, configuring it to ignore certain elements like whitespace and comments while ensuring that DTD loading is disabled for security reasons. The function attempts to parse the document and checks its well-formedness. If successful, it assigns the parsed document to a return variable and sets its URL based on the context's directory. In case of failure, it cleans up resources and returns a null value.","The vulnerability in the original code stemmed from the use of the expression `ctxt->options -= XML_PARSE_DTDLOAD`, which could lead to unintended behavior if the DTD loading option was not properly disabled, potentially exposing the application to XML External Entity (XXE) attacks. In the fixed code, this was addressed by changing the expression to `ctxt->options &= ~XML_PARSE_DTDLOAD`, which explicitly clears the DTD loading option, ensuring it is disabled regardless of its previous state. This change enhances security by preventing the parser from processing external entities, thereby mitigating the risk of XXE vulnerabilities.","The vulnerability in the original code arose from an improper handling of a security feature that disables DTD loading, which could leave the application susceptible to XML External Entity (XXE) attacks. This oversight allowed for the possibility of processing external entities, potentially leading to data exposure or denial of service. The fix involved a modification that explicitly ensured the DTD loading option was disabled, regardless of its previous state. This change strengthened the security posture of the code by preventing the parser from accessing external entities, thereby mitigating the risk associated with XXE vulnerabilities.","The vulnerability was fixed by changing the expression that modifies the parser's options from `ctxt->options -= XML_PARSE_DTDLOAD` to `ctxt->options &= ~XML_PARSE_DTDLOAD`. This adjustment ensures that the DTD loading option is explicitly disabled, regardless of its previous state, thereby preventing any potential for XML External Entity (XXE) attacks. By using the bitwise AND operation with the negation of the DTD loading option, the code guarantees that this security feature is consistently applied, enhancing the overall safety of the XML parsing process and protecting against unauthorized access to external entities.","The vulnerability was fixed by modifying the way the code disables the DTD loading feature, ensuring it is explicitly turned off regardless of its previous state. This change involved using a bitwise operation that guarantees the security setting is consistently applied, thereby preventing the parser from processing external entities. By implementing this fix, the code effectively mitigates the risk of XML External Entity (XXE) attacks, which could lead to unauthorized data access or other security issues. The adjustment enhances the overall robustness of the XML parsing process, ensuring safer handling of potentially malicious input.","4,4","5,5","5,5","5,5"
12,12,177899,177899,,Remote,Not required,,CVE-2013-1824,https://www.cvedetails.com/cve/CVE-2013-1824/,CWE-200,Medium,Partial,,,2013-09-16,4.3,"The SOAP parser in PHP before 5.3.22 and 5.4.x before 5.4.12 allows remote attackers to read arbitrary files via a SOAP WSDL file containing an XML external entity declaration in conjunction with an entity reference, related to an XML External Entity (XXE) issue in the soap_xmlParseFile and soap_xmlParseMemory functions.",2019-04-22,+Info,1,https://git.php.net/?p=php-src.git;a=commit;h=afe98b7829d50806559acac9b530acb8283c3bf4,afe98b7829d50806559acac9b530acb8283c3bf4,,0,,,"xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;
	zend_bool old_allow_url_fopen;

/*
	xmlInitParser();
*/

	old_allow_url_fopen = PG(allow_url_fopen);
	PG(allow_url_fopen) = 1;
	ctxt = xmlCreateFileParserCtxt(filename);
        PG(allow_url_fopen) = old_allow_url_fopen;
        if (ctxt) {
                ctxt->keepBlanks = 0;
               ctxt->options -= XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
		/*ctxt->sax->fatalError = NULL;*/
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
	return ret;
}
","xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;
	zend_bool old_allow_url_fopen;

/*
	xmlInitParser();
*/

	old_allow_url_fopen = PG(allow_url_fopen);
	PG(allow_url_fopen) = 1;
	ctxt = xmlCreateFileParserCtxt(filename);
        PG(allow_url_fopen) = old_allow_url_fopen;
        if (ctxt) {
                ctxt->keepBlanks = 0;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
		/*ctxt->sax->fatalError = NULL;*/
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
	return ret;
}
",C,"               ctxt->options -= XML_PARSE_DTDLOAD;
",,cc4c318b0c71e1a9c9cf803b5ee5d437344d64db,"@@ -92,6 +92,7 @@ xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)
        PG(allow_url_fopen) = old_allow_url_fopen;
        if (ctxt) {
                ctxt->keepBlanks = 0;
+               ctxt->options -= XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
@@ -133,6 +134,7 @@ xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)
 */
        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);
        if (ctxt) {
+               ctxt->options -= XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/soap/php_xml.c;h=a69d071164fe78c52eeff3b0fa2b7b33f61e0234;hb=a69d071164fe78c52eeff3b0fa2b7b33f61e0234,https://git.php.net/?p=php-src.git;a=blob;f=ext/soap/php_xml.c;h=65abed171a37be1896679bf87b3f2f77bfa903ff;hb=65abed171a37be1896679bf87b3f2f77bfa903ff,1,"xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;
	zend_bool old_allow_url_fopen;

/*
	xmlInitParser();
*/

	old_allow_url_fopen = PG(allow_url_fopen);
	PG(allow_url_fopen) = 1;
	ctxt = xmlCreateFileParserCtxt(filename);
        PG(allow_url_fopen) = old_allow_url_fopen;
        if (ctxt) {
                ctxt->keepBlanks = 0;
//fix_flaw_line_below:
//               ctxt->options -= XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
		/*ctxt->sax->fatalError = NULL;*/
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
	return ret;
}
",177899,"xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;
	zend_bool old_allow_url_fopen;

/*
	xmlInitParser();
*/

	old_allow_url_fopen = PG(allow_url_fopen);
	PG(allow_url_fopen) = 1;
	ctxt = xmlCreateFileParserCtxt(filename);
        PG(allow_url_fopen) = old_allow_url_fopen;
        if (ctxt) {
                ctxt->keepBlanks = 0;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
		/*ctxt->sax->fatalError = NULL;*/
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
	return ret;
}
","xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;
	zend_bool old_allow_url_fopen;

/*
	xmlInitParser();
*/

	old_allow_url_fopen = PG(allow_url_fopen);
	PG(allow_url_fopen) = 1;
	ctxt = xmlCreateFileParserCtxt(filename);
        PG(allow_url_fopen) = old_allow_url_fopen;
        if (ctxt) {
                ctxt->keepBlanks = 0;
               ctxt->options -= XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
		/*ctxt->sax->fatalError = NULL;*/
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
	return ret;
}
","The `soap_xmlParseFile` function is designed to parse an XML file specified by the `filename` parameter. It initializes a parser context, temporarily allows URL fopen functionality, and creates a file parser context for the given XML file. The function sets up custom handlers for whitespace and comments, then parses the document. If the document is well-formed, it retrieves the parsed document and assigns its URL based on the context's directory if not already set. If parsing fails, it cleans up by freeing the document. Finally, it cleans up the parser context and returns the parsed document or NULL if unsuccessful.","The provided code defines a function that parses an XML file specified by a filename. It temporarily modifies a setting to allow file access over URLs and creates a context for parsing the XML file. The function sets up handlers for whitespace and comments, then processes the document. If the document is well-formed, it retrieves the parsed content and assigns a URL based on the directory if not already present. In case of parsing failure, it cleans up by freeing the allocated resources. Finally, it returns the parsed document or indicates failure if the parsing was unsuccessful.","The vulnerability in the original code arises from the lack of proper handling of external entities and DTDs during XML parsing, which could lead to XML External Entity (XXE) attacks. Specifically, the code did not disable DTD loading, allowing potentially malicious external entities to be processed. The fix was implemented by modifying the parser context options, specifically subtracting the `XML_PARSE_DTDLOAD` option. This change prevents the parser from loading DTDs, thereby mitigating the risk of XXE attacks and ensuring that only the internal structure of the XML document is processed, enhancing the overall security of the function.","The vulnerability in the original code stemmed from the potential for XML External Entity (XXE) attacks, as it allowed the parsing of external DTDs and entities without restrictions. This could enable an attacker to exploit the XML parser to access sensitive files or perform denial-of-service attacks. The fix involved modifying the parser's configuration to disable the loading of DTDs, thereby preventing the processing of external entities. This change significantly enhances security by ensuring that only the internal content of the XML document is parsed, thus mitigating the risk of external entity exploitation.","The vulnerability was fixed by modifying the parser context options to disable DTD loading. Specifically, the code subtracted the `XML_PARSE_DTDLOAD` option from the `ctxt->options`, which prevents the parser from processing external DTDs and entities. This change ensures that the XML parser does not fetch or evaluate any external resources, thereby mitigating the risk of XML External Entity (XXE) attacks. By implementing this fix, the function enhances its security posture, ensuring that only the internal structure of the XML document is parsed and reducing the potential for exploitation.","The vulnerability was fixed by adjusting the parser's configuration to prevent the loading of external Document Type Definitions (DTDs). This was achieved by disabling the option that allows the parser to process external entities, thereby eliminating the risk of XML External Entity (XXE) attacks. By ensuring that the parser only handles internal content, the fix effectively mitigates the potential for exploitation through unauthorized access to sensitive files or denial-of-service attacks. This enhancement significantly improves the security of the XML parsing process, safeguarding against malicious input.","4,3","5,5","5,5","5,4"
13,13,177900,177900,,Remote,Not required,,CVE-2013-1824,https://www.cvedetails.com/cve/CVE-2013-1824/,CWE-200,Medium,Partial,,,2013-09-16,4.3,"The SOAP parser in PHP before 5.3.22 and 5.4.x before 5.4.12 allows remote attackers to read arbitrary files via a SOAP WSDL file containing an XML external entity declaration in conjunction with an entity reference, related to an XML External Entity (XXE) issue in the soap_xmlParseFile and soap_xmlParseMemory functions.",2019-04-22,+Info,1,https://git.php.net/?p=php-src.git;a=commit;h=afe98b7829d50806559acac9b530acb8283c3bf4,afe98b7829d50806559acac9b530acb8283c3bf4,,0,,,"xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;

/*
	xmlInitParser();
*/
 */
        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);
        if (ctxt) {
               ctxt->options -= XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
#if LIBXML_VERSION >= 20703
		ctxt->options |= XML_PARSE_HUGE;
#endif
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

/*
	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
*/
	return ret;
}
","xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;

/*
	xmlInitParser();
*/
 */
        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);
        if (ctxt) {
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
#if LIBXML_VERSION >= 20703
		ctxt->options |= XML_PARSE_HUGE;
#endif
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

/*
	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
*/
	return ret;
}
",C,"               ctxt->options -= XML_PARSE_DTDLOAD;
",,cc4c318b0c71e1a9c9cf803b5ee5d437344d64db,"@@ -92,6 +92,7 @@ xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)
        PG(allow_url_fopen) = old_allow_url_fopen;
        if (ctxt) {
                ctxt->keepBlanks = 0;
+               ctxt->options -= XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
@@ -133,6 +134,7 @@ xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)
 */
        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);
        if (ctxt) {
+               ctxt->options -= XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/soap/php_xml.c;h=a69d071164fe78c52eeff3b0fa2b7b33f61e0234;hb=a69d071164fe78c52eeff3b0fa2b7b33f61e0234,https://git.php.net/?p=php-src.git;a=blob;f=ext/soap/php_xml.c;h=65abed171a37be1896679bf87b3f2f77bfa903ff;hb=65abed171a37be1896679bf87b3f2f77bfa903ff,1,"xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;

/*
	xmlInitParser();
*/
 */
        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);
        if (ctxt) {
//fix_flaw_line_below:
//               ctxt->options -= XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
#if LIBXML_VERSION >= 20703
		ctxt->options |= XML_PARSE_HUGE;
#endif
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

/*
	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
*/
	return ret;
}
",177900,"xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;

/*
	xmlInitParser();
*/
 */
        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);
        if (ctxt) {
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
#if LIBXML_VERSION >= 20703
		ctxt->options |= XML_PARSE_HUGE;
#endif
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

/*
	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
*/
	return ret;
}
","xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)
{
	xmlParserCtxtPtr ctxt = NULL;
	xmlDocPtr ret;

/*
	xmlInitParser();
*/
 */
        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);
        if (ctxt) {
               ctxt->options -= XML_PARSE_DTDLOAD;
                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;
                ctxt->sax->comment = soap_Comment;
                ctxt->sax->warning = NULL;
#if LIBXML_VERSION >= 20703
		ctxt->options |= XML_PARSE_HUGE;
#endif
		xmlParseDocument(ctxt);
		if (ctxt->wellFormed) {
			ret = ctxt->myDoc;
			if (ret->URL == NULL && ctxt->directory != NULL) {
				ret->URL = xmlCharStrdup(ctxt->directory);
			}
		} else {
			ret = NULL;
			xmlFreeDoc(ctxt->myDoc);
			ctxt->myDoc = NULL;
		}
		xmlFreeParserCtxt(ctxt);
	} else {
		ret = NULL;
	}

/*
	xmlCleanupParser();
*/

/*
	if (ret) {
		cleanup_xml_node((xmlNodePtr)ret);
	}
*/
	return ret;
}
","The `soap_xmlParseMemory` function is designed to parse an XML document from a memory buffer, specified by `buf` and its size `buf_size`. It initializes a parser context and sets custom SAX (Simple API for XML) handlers for handling whitespace and comments. If the parsing is successful and the document is well-formed, it retrieves the parsed document and assigns a URL if the document lacks one but the context has a directory. If parsing fails, it cleans up by freeing the document and context. The function ultimately returns a pointer to the parsed XML document or `NULL` if parsing fails.","The provided code defines a function that parses an XML document from a memory buffer, handling the parsing process through a dedicated context. It sets up custom handlers to manage whitespace and comments during parsing. If the document is successfully parsed and is well-formed, the function retrieves the resulting document and assigns a URL if it is missing but a directory is available. In cases of failure, it ensures proper cleanup by freeing any allocated resources. Ultimately, the function returns a pointer to the parsed document or indicates failure by returning a null value.","The vulnerability in the original code stemmed from the lack of control over DTD (Document Type Definition) loading, which could lead to XML External Entity (XXE) attacks, allowing an attacker to access sensitive files or perform other malicious actions. In the fixed code, the vulnerability was addressed by modifying the parser context options to disable DTD loading by subtracting the `XML_PARSE_DTDLOAD` option. This change ensures that the parser does not process external entities, thereby mitigating the risk of XXE attacks while still allowing the parsing of well-formed XML documents.","The vulnerability in the original code was related to the potential for XML External Entity (XXE) attacks, which could allow an attacker to exploit the XML parser to access sensitive files or execute malicious actions by loading external DTDs. The fix involved modifying the parser's configuration to disable the loading of DTDs, thereby preventing the parser from processing external entities. This change effectively mitigated the risk of XXE attacks while still allowing the parsing of well-formed XML documents, enhancing the overall security of the XML processing functionality.","The vulnerability was fixed by modifying the parser context options to disable DTD loading, specifically by subtracting the `XML_PARSE_DTDLOAD` option from `ctxt->options`. This change prevents the parser from processing external entities, which are often exploited in XML External Entity (XXE) attacks. By ensuring that the parser does not load DTDs, the code mitigates the risk of unauthorized access to sensitive files or other malicious actions. This adjustment enhances the security of the XML parsing process while still allowing the handling of well-formed XML documents.","The vulnerability was fixed by adjusting the parser's configuration to disable the loading of external DTDs, which are often a vector for XML External Entity (XXE) attacks. This adjustment prevents the parser from processing any external entities, thereby mitigating the risk of unauthorized access to sensitive files or executing malicious actions. By ensuring that the parser operates without the capability to load DTDs, the code enhances the security of the XML processing functionality while still allowing for the parsing of well-formed XML documents. This change significantly reduces the potential attack surface.","4,4","5,5","4,4","4, 4"
14,14,177916,177916,,Remote,Not required,,CVE-2013-1643,https://www.cvedetails.com/cve/CVE-2013-1643/,CWE-200,Low,Partial,,,2013-03-06,5.0,"The SOAP parser in PHP before 5.3.23 and 5.4.x before 5.4.13 allows remote attackers to read arbitrary files via a SOAP WSDL file containing an XML external entity declaration in conjunction with an entity reference, related to an XML External Entity (XXE) issue in the soap_xmlParseFile and soap_xmlParseMemory functions.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-1824.",2014-01-27,+Info,1,https://git.php.net/?p=php-src.git;a=commit;h=8e76d0404b7f664ee6719fd98f0483f0ac4669d6,8e76d0404b7f664ee6719fd98f0483f0ac4669d6,,0,,,"static PHP_GINIT_FUNCTION(libxml)
{
        libxml_globals->stream_context = NULL;
        libxml_globals->error_buffer.c = NULL;
        libxml_globals->error_list = NULL;
       libxml_globals->entity_loader_disabled = 0;
 }
","static PHP_GINIT_FUNCTION(libxml)
{
        libxml_globals->stream_context = NULL;
        libxml_globals->error_buffer.c = NULL;
        libxml_globals->error_list = NULL;
 }
",C,"       libxml_globals->entity_loader_disabled = 0;
",,afc1debb2f48938e98ec35dbc6545b331b1c3096,"@@ -261,6 +261,7 @@ static PHP_GINIT_FUNCTION(libxml)
        libxml_globals->stream_context = NULL;
        libxml_globals->error_buffer.c = NULL;
        libxml_globals->error_list = NULL;
+       libxml_globals->entity_loader_disabled = 0;
 }
 
 /* Channel libxml file io layer through the PHP streams subsystem.
@@ -348,16 +349,15 @@ static int php_libxml_streams_IO_close(void *context)
 }
 
 static xmlParserInputBufferPtr
-php_libxml_input_buffer_noload(const char *URI, xmlCharEncoding enc)
-{
-       return NULL;
-}
-
-static xmlParserInputBufferPtr
 php_libxml_input_buffer_create_filename(const char *URI, xmlCharEncoding enc)
 {
        xmlParserInputBufferPtr ret;
        void *context = NULL;
+       TSRMLS_FETCH();
+
+       if (LIBXML(entity_loader_disabled)) {
+               return NULL;
+       }
 
        if (URI == NULL)
                return(NULL);
@@ -834,28 +834,25 @@ static PHP_FUNCTION(libxml_clear_errors)
 }
 /* }}} */
 
+PHP_LIBXML_API zend_bool php_libxml_disable_entity_loader(zend_bool disable TSRMLS_DC)
+{
+       zend_bool old = LIBXML(entity_loader_disabled);
+
+       LIBXML(entity_loader_disabled) = disable;
+       return old;
+}
+
 /* {{{ proto bool libxml_disable_entity_loader([boolean disable]) 
    Disable/Enable ability to load external entities */
 static PHP_FUNCTION(libxml_disable_entity_loader)
 {
        zend_bool disable = 1;
-       xmlParserInputBufferCreateFilenameFunc old;
 
        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|b"", &disable) == FAILURE) {
                return;
        }
 
-       if (disable == 0) {
-               old = xmlParserInputBufferCreateFilenameDefault(php_libxml_input_buffer_create_filename);
-       } else {
-               old = xmlParserInputBufferCreateFilenameDefault(php_libxml_input_buffer_noload);
-       }
-
-       if (old == php_libxml_input_buffer_noload) {
-               RETURN_TRUE;
-       }
-
-       RETURN_FALSE;
+       RETURN_BOOL(php_libxml_disable_entity_loader(disable TSRMLS_CC));
 }
 /* }}} */",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/libxml/libxml.c;h=920a90c634922e788fdee9b789aab803fbdd0f51;hb=8e76d0404b7f664ee6719fd98f0483f0ac4669d6,https://git.php.net/?p=php-src.git;a=blob;f=ext/libxml/libxml.c;h=5db1f31ea958b9a7e06e282e743106611648d940,1,"static PHP_GINIT_FUNCTION(libxml)
{
        libxml_globals->stream_context = NULL;
        libxml_globals->error_buffer.c = NULL;
        libxml_globals->error_list = NULL;
//fix_flaw_line_below:
//       libxml_globals->entity_loader_disabled = 0;
 }
",177916,"static PHP_GINIT_FUNCTION(libxml)
{
        libxml_globals->stream_context = NULL;
        libxml_globals->error_buffer.c = NULL;
        libxml_globals->error_list = NULL;
 }
","static PHP_GINIT_FUNCTION(libxml)
{
        libxml_globals->stream_context = NULL;
        libxml_globals->error_buffer.c = NULL;
        libxml_globals->error_list = NULL;
       libxml_globals->entity_loader_disabled = 0;
 }
","The provided code defines a static function, `PHP_GINIT_FUNCTION(libxml)`, which initializes global variables for the libxml extension in PHP. Within this function, it sets the `stream_context` to `NULL`, indicating that no stream context is currently defined. Additionally, it initializes the `error_buffer` structure's character pointer `c` to `NULL`, and the `error_list` pointer is also set to `NULL`, effectively clearing any previous error states. This setup ensures that the libxml extension starts with a clean state, ready to handle XML processing without residual data from prior operations.","The code defines a function that initializes global settings for a specific PHP extension related to XML processing. It sets various global state variables to a default state, ensuring that no previous configurations or error states persist. This includes clearing any existing context for stream operations and resetting buffers that handle error messages. By establishing these initial conditions, the function prepares the extension for fresh operations, allowing it to process XML data without interference from prior executions, thus promoting stability and reliability in handling XML-related tasks.","The vulnerability in the original code stemmed from the lack of initialization for the `entity_loader_disabled` variable, which could lead to unintended behavior or security issues when processing XML data, such as XML External Entity (XXE) attacks. In the fixed code, this variable is explicitly set to `0`, ensuring that the entity loader is enabled by default. This change mitigates the risk by providing a clear and defined state for the entity loader, preventing potential exploitation through uninitialized variables and enhancing the overall security posture of the XML processing functionality within the PHP extension.","The vulnerability in the original code arose from the failure to initialize a critical setting related to entity loading, which could expose the system to security risks, such as XML External Entity (XXE) attacks. This lack of initialization meant that the system could behave unpredictably, potentially allowing malicious XML content to be processed improperly. In the revised code, this setting is explicitly initialized to a safe default value, ensuring that the entity loader operates in a controlled manner. This fix enhances security by preventing unintended behavior and safeguarding against exploitation through uninitialized configurations.","The vulnerability was fixed by explicitly initializing the `entity_loader_disabled` variable to `0` in the updated code. This change ensures that the entity loader is enabled by default, which helps prevent potential security risks associated with uninitialized variables, such as XML External Entity (XXE) attacks. By setting this variable, the code establishes a clear and defined state for entity loading, thereby mitigating the risk of processing malicious XML content. This enhancement improves the overall security of the XML processing functionality within the PHP extension, ensuring safer handling of XML data.","The vulnerability was addressed by explicitly setting a critical configuration related to entity loading to a safe default value. This change ensures that the system operates with a defined state, preventing potential security risks associated with uninitialized settings, such as allowing malicious content to be processed improperly. By establishing this default, the code enhances the security posture of the XML processing functionality, effectively mitigating the risk of exploitation through uninitialized variables. This fix promotes safer handling of XML data and reinforces the overall integrity of the system against potential attacks.","5,4","3, 3","3, 4","4,4"
15,15,178013,178013,,Remote,Not required,,CVE-2018-11469,https://www.cvedetails.com/cve/CVE-2018-11469/,CWE-200,Medium,Partial,,,2018-05-25,4.3,"Incorrect caching of responses to requests including an Authorization header in HAProxy 1.8.0 through 1.8.9 (if cache enabled) allows attackers to achieve information disclosure via an unauthenticated remote request, related to the proto_http.c check_request_for_cacheability function.",2019-06-11,+Info,9,https://git.haproxy.org/?p=haproxy-1.8.git;a=commit;h=17514045e5d934dede62116216c1b016fe23dd06,17514045e5d934dede62116216c1b016fe23dd06,,0,,,"void check_request_for_cacheability(struct stream *s, struct channel *chn)
{
	struct http_txn *txn = s->txn;
	char *p1, *p2;
	char *cur_ptr, *cur_end, *cur_next;
	int pragma_found;
	int cc_found;
	int cur_idx;

	if ((txn->flags & (TX_CACHEABLE|TX_CACHE_IGNORE)) == TX_CACHE_IGNORE)
		return; /* nothing more to do here */

	cur_idx = 0;
	pragma_found = cc_found = 0;
	cur_next = chn->buf->p + hdr_idx_first_pos(&txn->hdr_idx);

	while ((cur_idx = txn->hdr_idx.v[cur_idx].next)) {
		struct hdr_idx_elem *cur_hdr;
		int val;

		cur_hdr  = &txn->hdr_idx.v[cur_idx];
		cur_ptr  = cur_next;
		cur_end  = cur_ptr + cur_hdr->len;
		cur_next = cur_end + cur_hdr->cr + 1;

		/* We have one full header between cur_ptr and cur_end, and the
		 * next header starts at cur_next.
		 */

		val = http_header_match2(cur_ptr, cur_end, ""Pragma"", 6);
		if (val) {
			if ((cur_end - (cur_ptr + val) >= 8) &&
			    strncasecmp(cur_ptr + val, ""no-cache"", 8) == 0) {
				pragma_found = 1;
				continue;
                        }
                }
 
               /* Don't use the cache and don't try to store if we found the
                * Authorization header */
               val = http_header_match2(cur_ptr, cur_end, ""Authorization"", 13);
               if (val) {
                       txn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;
                       txn->flags |= TX_CACHE_IGNORE;
                       continue;
               }

                val = http_header_match2(cur_ptr, cur_end, ""Cache-control"", 13);
                if (!val)
                        continue;
		p2 = p1;
		while (p2 < cur_end && *p2 != '=' && *p2 != ',' && !isspace((unsigned char)*p2))
			p2++;

		/* we have a complete value between p1 and p2. We don't check the
		 * values after max-age, max-stale nor min-fresh, we simply don't
		 * use the cache when they're specified.
		 */
		if (((p2 - p1 == 7) && strncasecmp(p1, ""max-age"",   7) == 0) ||
		    ((p2 - p1 == 8) && strncasecmp(p1, ""no-cache"",  8) == 0) ||
		    ((p2 - p1 == 9) && strncasecmp(p1, ""max-stale"", 9) == 0) ||
		    ((p2 - p1 == 9) && strncasecmp(p1, ""min-fresh"", 9) == 0)) {
			txn->flags |= TX_CACHE_IGNORE;
			continue;
		}

		if ((p2 - p1 == 8) && strncasecmp(p1, ""no-store"", 8) == 0) {
			txn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;
			continue;
		}
	}

	/* RFC7234#5.4:
	 *   When the Cache-Control header field is also present and
	 *   understood in a request, Pragma is ignored.
	 *   When the Cache-Control header field is not present in a
	 *   request, caches MUST consider the no-cache request
	 *   pragma-directive as having the same effect as if
	 *   ""Cache-Control: no-cache"" were present.
	 */
	if (!cc_found && pragma_found)
		txn->flags |= TX_CACHE_IGNORE;
}
","void check_request_for_cacheability(struct stream *s, struct channel *chn)
{
	struct http_txn *txn = s->txn;
	char *p1, *p2;
	char *cur_ptr, *cur_end, *cur_next;
	int pragma_found;
	int cc_found;
	int cur_idx;

	if ((txn->flags & (TX_CACHEABLE|TX_CACHE_IGNORE)) == TX_CACHE_IGNORE)
		return; /* nothing more to do here */

	cur_idx = 0;
	pragma_found = cc_found = 0;
	cur_next = chn->buf->p + hdr_idx_first_pos(&txn->hdr_idx);

	while ((cur_idx = txn->hdr_idx.v[cur_idx].next)) {
		struct hdr_idx_elem *cur_hdr;
		int val;

		cur_hdr  = &txn->hdr_idx.v[cur_idx];
		cur_ptr  = cur_next;
		cur_end  = cur_ptr + cur_hdr->len;
		cur_next = cur_end + cur_hdr->cr + 1;

		/* We have one full header between cur_ptr and cur_end, and the
		 * next header starts at cur_next.
		 */

		val = http_header_match2(cur_ptr, cur_end, ""Pragma"", 6);
		if (val) {
			if ((cur_end - (cur_ptr + val) >= 8) &&
			    strncasecmp(cur_ptr + val, ""no-cache"", 8) == 0) {
				pragma_found = 1;
				continue;
                        }
                }
 
                val = http_header_match2(cur_ptr, cur_end, ""Cache-control"", 13);
                if (!val)
                        continue;
		p2 = p1;
		while (p2 < cur_end && *p2 != '=' && *p2 != ',' && !isspace((unsigned char)*p2))
			p2++;

		/* we have a complete value between p1 and p2. We don't check the
		 * values after max-age, max-stale nor min-fresh, we simply don't
		 * use the cache when they're specified.
		 */
		if (((p2 - p1 == 7) && strncasecmp(p1, ""max-age"",   7) == 0) ||
		    ((p2 - p1 == 8) && strncasecmp(p1, ""no-cache"",  8) == 0) ||
		    ((p2 - p1 == 9) && strncasecmp(p1, ""max-stale"", 9) == 0) ||
		    ((p2 - p1 == 9) && strncasecmp(p1, ""min-fresh"", 9) == 0)) {
			txn->flags |= TX_CACHE_IGNORE;
			continue;
		}

		if ((p2 - p1 == 8) && strncasecmp(p1, ""no-store"", 8) == 0) {
			txn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;
			continue;
		}
	}

	/* RFC7234#5.4:
	 *   When the Cache-Control header field is also present and
	 *   understood in a request, Pragma is ignored.
	 *   When the Cache-Control header field is not present in a
	 *   request, caches MUST consider the no-cache request
	 *   pragma-directive as having the same effect as if
	 *   ""Cache-Control: no-cache"" were present.
	 */
	if (!cc_found && pragma_found)
		txn->flags |= TX_CACHE_IGNORE;
}
",C,"               /* Don't use the cache and don't try to store if we found the
                * Authorization header */
               val = http_header_match2(cur_ptr, cur_end, ""Authorization"", 13);
               if (val) {
                       txn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;
                       txn->flags |= TX_CACHE_IGNORE;
                       continue;
               }

",,dd08a40b58f0dd3e0ed0b954fc2f3f3984cd3ec6,"@@ -7724,6 +7724,15 @@ void check_request_for_cacheability(struct stream *s, struct channel *chn)
                        }
                }
 
+               /* Don't use the cache and don't try to store if we found the
+                * Authorization header */
+               val = http_header_match2(cur_ptr, cur_end, ""Authorization"", 13);
+               if (val) {
+                       txn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;
+                       txn->flags |= TX_CACHE_IGNORE;
+                       continue;
+               }
+
                val = http_header_match2(cur_ptr, cur_end, ""Cache-control"", 13);
                if (!val)
                        continue;",haproxy,https://git.haproxy.org/?p=haproxy-1.8.git;a=blob;f=src/proto_http.c;h=beb012bc0188dda79b01b9cb34fd9e2824f8cc9e;hb=17514045e5d934dede62116216c1b016fe23dd06,https://git.haproxy.org/?p=haproxy-1.8.git;a=blob;f=src/proto_http.c;h=b384cef149655b1d92533544c3850078eec2bc6a,1,"void check_request_for_cacheability(struct stream *s, struct channel *chn)
{
	struct http_txn *txn = s->txn;
	char *p1, *p2;
	char *cur_ptr, *cur_end, *cur_next;
	int pragma_found;
	int cc_found;
	int cur_idx;

	if ((txn->flags & (TX_CACHEABLE|TX_CACHE_IGNORE)) == TX_CACHE_IGNORE)
		return; /* nothing more to do here */

	cur_idx = 0;
	pragma_found = cc_found = 0;
	cur_next = chn->buf->p + hdr_idx_first_pos(&txn->hdr_idx);

	while ((cur_idx = txn->hdr_idx.v[cur_idx].next)) {
		struct hdr_idx_elem *cur_hdr;
		int val;

		cur_hdr  = &txn->hdr_idx.v[cur_idx];
		cur_ptr  = cur_next;
		cur_end  = cur_ptr + cur_hdr->len;
		cur_next = cur_end + cur_hdr->cr + 1;

		/* We have one full header between cur_ptr and cur_end, and the
		 * next header starts at cur_next.
		 */

		val = http_header_match2(cur_ptr, cur_end, ""Pragma"", 6);
		if (val) {
			if ((cur_end - (cur_ptr + val) >= 8) &&
			    strncasecmp(cur_ptr + val, ""no-cache"", 8) == 0) {
				pragma_found = 1;
				continue;
                        }
                }
 
//fix_flaw_line_below:
//               /* Don't use the cache and don't try to store if we found the
//fix_flaw_line_below:
//                * Authorization header */
//fix_flaw_line_below:
//               val = http_header_match2(cur_ptr, cur_end, ""Authorization"", 13);
//fix_flaw_line_below:
//               if (val) {
//fix_flaw_line_below:
//                       txn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;
//fix_flaw_line_below:
//                       txn->flags |= TX_CACHE_IGNORE;
//fix_flaw_line_below:
//                       continue;
//fix_flaw_line_below:
//               }
//fix_flaw_line_below:
//
                val = http_header_match2(cur_ptr, cur_end, ""Cache-control"", 13);
                if (!val)
                        continue;
		p2 = p1;
		while (p2 < cur_end && *p2 != '=' && *p2 != ',' && !isspace((unsigned char)*p2))
			p2++;

		/* we have a complete value between p1 and p2. We don't check the
		 * values after max-age, max-stale nor min-fresh, we simply don't
		 * use the cache when they're specified.
		 */
		if (((p2 - p1 == 7) && strncasecmp(p1, ""max-age"",   7) == 0) ||
		    ((p2 - p1 == 8) && strncasecmp(p1, ""no-cache"",  8) == 0) ||
		    ((p2 - p1 == 9) && strncasecmp(p1, ""max-stale"", 9) == 0) ||
		    ((p2 - p1 == 9) && strncasecmp(p1, ""min-fresh"", 9) == 0)) {
			txn->flags |= TX_CACHE_IGNORE;
			continue;
		}

		if ((p2 - p1 == 8) && strncasecmp(p1, ""no-store"", 8) == 0) {
			txn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;
			continue;
		}
	}

	/* RFC7234#5.4:
	 *   When the Cache-Control header field is also present and
	 *   understood in a request, Pragma is ignored.
	 *   When the Cache-Control header field is not present in a
	 *   request, caches MUST consider the no-cache request
	 *   pragma-directive as having the same effect as if
	 *   ""Cache-Control: no-cache"" were present.
	 */
	if (!cc_found && pragma_found)
		txn->flags |= TX_CACHE_IGNORE;
}
",178013,"void check_request_for_cacheability(struct stream *s, struct channel *chn)
{
	struct http_txn *txn = s->txn;
	char *p1, *p2;
	char *cur_ptr, *cur_end, *cur_next;
	int pragma_found;
	int cc_found;
	int cur_idx;

	if ((txn->flags & (TX_CACHEABLE|TX_CACHE_IGNORE)) == TX_CACHE_IGNORE)
		return; /* nothing more to do here */

	cur_idx = 0;
	pragma_found = cc_found = 0;
	cur_next = chn->buf->p + hdr_idx_first_pos(&txn->hdr_idx);

	while ((cur_idx = txn->hdr_idx.v[cur_idx].next)) {
		struct hdr_idx_elem *cur_hdr;
		int val;

		cur_hdr  = &txn->hdr_idx.v[cur_idx];
		cur_ptr  = cur_next;
		cur_end  = cur_ptr + cur_hdr->len;
		cur_next = cur_end + cur_hdr->cr + 1;

		/* We have one full header between cur_ptr and cur_end, and the
		 * next header starts at cur_next.
		 */

		val = http_header_match2(cur_ptr, cur_end, ""Pragma"", 6);
		if (val) {
			if ((cur_end - (cur_ptr + val) >= 8) &&
			    strncasecmp(cur_ptr + val, ""no-cache"", 8) == 0) {
				pragma_found = 1;
				continue;
                        }
                }
 
                val = http_header_match2(cur_ptr, cur_end, ""Cache-control"", 13);
                if (!val)
                        continue;
		p2 = p1;
		while (p2 < cur_end && *p2 != '=' && *p2 != ',' && !isspace((unsigned char)*p2))
			p2++;

		/* we have a complete value between p1 and p2. We don't check the
		 * values after max-age, max-stale nor min-fresh, we simply don't
		 * use the cache when they're specified.
		 */
		if (((p2 - p1 == 7) && strncasecmp(p1, ""max-age"",   7) == 0) ||
		    ((p2 - p1 == 8) && strncasecmp(p1, ""no-cache"",  8) == 0) ||
		    ((p2 - p1 == 9) && strncasecmp(p1, ""max-stale"", 9) == 0) ||
		    ((p2 - p1 == 9) && strncasecmp(p1, ""min-fresh"", 9) == 0)) {
			txn->flags |= TX_CACHE_IGNORE;
			continue;
		}

		if ((p2 - p1 == 8) && strncasecmp(p1, ""no-store"", 8) == 0) {
			txn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;
			continue;
		}
	}

	/* RFC7234#5.4:
	 *   When the Cache-Control header field is also present and
	 *   understood in a request, Pragma is ignored.
	 *   When the Cache-Control header field is not present in a
	 *   request, caches MUST consider the no-cache request
	 *   pragma-directive as having the same effect as if
	 *   ""Cache-Control: no-cache"" were present.
	 */
	if (!cc_found && pragma_found)
		txn->flags |= TX_CACHE_IGNORE;
}
","void check_request_for_cacheability(struct stream *s, struct channel *chn)
{
	struct http_txn *txn = s->txn;
	char *p1, *p2;
	char *cur_ptr, *cur_end, *cur_next;
	int pragma_found;
	int cc_found;
	int cur_idx;

	if ((txn->flags & (TX_CACHEABLE|TX_CACHE_IGNORE)) == TX_CACHE_IGNORE)
		return; /* nothing more to do here */

	cur_idx = 0;
	pragma_found = cc_found = 0;
	cur_next = chn->buf->p + hdr_idx_first_pos(&txn->hdr_idx);

	while ((cur_idx = txn->hdr_idx.v[cur_idx].next)) {
		struct hdr_idx_elem *cur_hdr;
		int val;

		cur_hdr  = &txn->hdr_idx.v[cur_idx];
		cur_ptr  = cur_next;
		cur_end  = cur_ptr + cur_hdr->len;
		cur_next = cur_end + cur_hdr->cr + 1;

		/* We have one full header between cur_ptr and cur_end, and the
		 * next header starts at cur_next.
		 */

		val = http_header_match2(cur_ptr, cur_end, ""Pragma"", 6);
		if (val) {
			if ((cur_end - (cur_ptr + val) >= 8) &&
			    strncasecmp(cur_ptr + val, ""no-cache"", 8) == 0) {
				pragma_found = 1;
				continue;
                        }
                }
 
               /* Don't use the cache and don't try to store if we found the
                * Authorization header */
               val = http_header_match2(cur_ptr, cur_end, ""Authorization"", 13);
               if (val) {
                       txn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;
                       txn->flags |= TX_CACHE_IGNORE;
                       continue;
               }

                val = http_header_match2(cur_ptr, cur_end, ""Cache-control"", 13);
                if (!val)
                        continue;
		p2 = p1;
		while (p2 < cur_end && *p2 != '=' && *p2 != ',' && !isspace((unsigned char)*p2))
			p2++;

		/* we have a complete value between p1 and p2. We don't check the
		 * values after max-age, max-stale nor min-fresh, we simply don't
		 * use the cache when they're specified.
		 */
		if (((p2 - p1 == 7) && strncasecmp(p1, ""max-age"",   7) == 0) ||
		    ((p2 - p1 == 8) && strncasecmp(p1, ""no-cache"",  8) == 0) ||
		    ((p2 - p1 == 9) && strncasecmp(p1, ""max-stale"", 9) == 0) ||
		    ((p2 - p1 == 9) && strncasecmp(p1, ""min-fresh"", 9) == 0)) {
			txn->flags |= TX_CACHE_IGNORE;
			continue;
		}

		if ((p2 - p1 == 8) && strncasecmp(p1, ""no-store"", 8) == 0) {
			txn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;
			continue;
		}
	}

	/* RFC7234#5.4:
	 *   When the Cache-Control header field is also present and
	 *   understood in a request, Pragma is ignored.
	 *   When the Cache-Control header field is not present in a
	 *   request, caches MUST consider the no-cache request
	 *   pragma-directive as having the same effect as if
	 *   ""Cache-Control: no-cache"" were present.
	 */
	if (!cc_found && pragma_found)
		txn->flags |= TX_CACHE_IGNORE;
}
","The `check_request_for_cacheability` function evaluates HTTP request headers to determine if the response can be cached. It first checks if caching is ignored based on transaction flags. It then iterates through the headers, looking for ""Pragma"" and ""Cache-Control"" directives. If ""Pragma: no-cache"" is found, it sets a flag to ignore caching. The function also checks for specific ""Cache-Control"" directives like ""max-age"", ""no-cache"", ""max-stale"", and ""min-fresh"", which, if present, also lead to ignoring the cache. Finally, it ensures that if ""Cache-Control"" is absent but ""Pragma"" is present, caching is still ignored.","The function analyzes HTTP request headers to determine whether the response can be cached. It begins by checking if caching should be ignored based on specific flags. The function then iterates through the headers, searching for directives that indicate caching preferences. If certain conditions are met, such as the presence of specific directives that restrict caching, it updates the transaction flags accordingly. Additionally, it ensures that if a particular directive is absent but another is present, the caching behavior is still adjusted to prevent caching. This process helps manage how responses are cached based on client requests.","The vulnerability in the original code stemmed from the lack of handling for the ""Authorization"" header, which could lead to sensitive information being cached unintentionally. This oversight could allow unauthorized access to cached responses containing private data. The fixed code addresses this vulnerability by explicitly checking for the ""Authorization"" header. If found, it updates the transaction flags to ensure that caching is disabled and that the response is not stored. This change enhances security by preventing the caching of responses that may contain sensitive user credentials or information, thereby mitigating the risk of data exposure.","The vulnerability in the original code arose from the failure to account for the presence of sensitive headers, specifically the ""Authorization"" header, which could lead to the caching of responses containing confidential information. This oversight posed a risk of unauthorized access to cached data. The revised code rectifies this issue by introducing a check for the ""Authorization"" header. When detected, it modifies the caching behavior to ensure that such responses are neither cached nor stored, thereby enhancing security and preventing the potential exposure of sensitive user credentials or information in cached responses.","The vulnerability was fixed by adding a check for the ""Authorization"" header within the header processing loop. When the code detects this header using the `http_header_match2` function, it updates the transaction flags by clearing the `TX_CACHEABLE` and `TX_CACHE_COOK` flags and setting the `TX_CACHE_IGNORE` flag. This ensures that any response containing sensitive authorization information is not cached or stored. By implementing this check, the code effectively prevents the caching of potentially sensitive data, thereby enhancing the security of the application and protecting user credentials from unauthorized access.","The vulnerability was addressed by incorporating a specific check for the presence of sensitive headers that could contain confidential information. When such a header is detected, the code modifies the caching behavior to ensure that responses containing this information are neither cached nor stored. This adjustment involves updating the relevant flags to prevent any caching of responses that may expose sensitive data. By implementing this safeguard, the code effectively enhances security, ensuring that potentially sensitive user credentials or information are protected from unauthorized access through cached responses.","5,5","5,5","4,4","4,4"
16,16,178120,178120,,Local,Not required,,CVE-2016-6836,https://www.cvedetails.com/cve/CVE-2016-6836/,CWE-200,Low,Partial,,,2016-12-09,2.1,The vmxnet3_complete_packet function in hw/net/vmxnet3.c in QEMU (aka Quick Emulator) allows local guest OS administrators to obtain sensitive host memory information by leveraging failure to initialize the txcq_descr object.,2018-12-01,+Info,1,https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf,fdda170e50b8af062cf5741e12c4fb5e57a2eacf,,0,,,"static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)
{
    struct Vmxnet3_TxCompDesc txcq_descr;
    PCIDevice *d = PCI_DEVICE(s);
 
     VMXNET3_RING_DUMP(VMW_RIPRN, ""TXC"", qidx, &s->txq_descr[qidx].comp_ring);
 
    memset(&txcq_descr, 0, sizeof(txcq_descr));
     txcq_descr.txdIdx = tx_ridx;
     txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);

    /* Flush changes in TX descriptor before changing the counter value */
    smp_wmb();

    vmxnet3_inc_tx_completion_counter(s, qidx);
    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);
}
","static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)
{
    struct Vmxnet3_TxCompDesc txcq_descr;
    PCIDevice *d = PCI_DEVICE(s);
 
     VMXNET3_RING_DUMP(VMW_RIPRN, ""TXC"", qidx, &s->txq_descr[qidx].comp_ring);
 
     txcq_descr.txdIdx = tx_ridx;
     txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);

    /* Flush changes in TX descriptor before changing the counter value */
    smp_wmb();

    vmxnet3_inc_tx_completion_counter(s, qidx);
    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);
}
",C,"    memset(&txcq_descr, 0, sizeof(txcq_descr));
",,c89d416a2b0fb6a21224186b10af4c4a3feee31b,"@@ -531,6 +531,7 @@ static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)
 
     VMXNET3_RING_DUMP(VMW_RIPRN, ""TXC"", qidx, &s->txq_descr[qidx].comp_ring);
 
+    memset(&txcq_descr, 0, sizeof(txcq_descr));
     txcq_descr.txdIdx = tx_ridx;
     txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/net/vmxnet3.c;h=92f6af9620f17af9f26520d18c50896ac9eaa546;hb=92f6af9620f17af9f26520d18c50896ac9eaa546,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/net/vmxnet3.c;h=90f69436687167907a4e927e1429702c543ec2d2;hb=90f69436687167907a4e927e1429702c543ec2d2,1,"static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)
{
    struct Vmxnet3_TxCompDesc txcq_descr;
    PCIDevice *d = PCI_DEVICE(s);
 
     VMXNET3_RING_DUMP(VMW_RIPRN, ""TXC"", qidx, &s->txq_descr[qidx].comp_ring);
 
//fix_flaw_line_below:
//    memset(&txcq_descr, 0, sizeof(txcq_descr));
     txcq_descr.txdIdx = tx_ridx;
     txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);

    /* Flush changes in TX descriptor before changing the counter value */
    smp_wmb();

    vmxnet3_inc_tx_completion_counter(s, qidx);
    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);
}
",178120,"static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)
{
    struct Vmxnet3_TxCompDesc txcq_descr;
    PCIDevice *d = PCI_DEVICE(s);
 
     VMXNET3_RING_DUMP(VMW_RIPRN, ""TXC"", qidx, &s->txq_descr[qidx].comp_ring);
 
     txcq_descr.txdIdx = tx_ridx;
     txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);

    /* Flush changes in TX descriptor before changing the counter value */
    smp_wmb();

    vmxnet3_inc_tx_completion_counter(s, qidx);
    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);
}
","static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)
{
    struct Vmxnet3_TxCompDesc txcq_descr;
    PCIDevice *d = PCI_DEVICE(s);
 
     VMXNET3_RING_DUMP(VMW_RIPRN, ""TXC"", qidx, &s->txq_descr[qidx].comp_ring);
 
    memset(&txcq_descr, 0, sizeof(txcq_descr));
     txcq_descr.txdIdx = tx_ridx;
     txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);

    /* Flush changes in TX descriptor before changing the counter value */
    smp_wmb();

    vmxnet3_inc_tx_completion_counter(s, qidx);
    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);
}
","The `vmxnet3_complete_packet` function is responsible for completing the transmission of a packet in a VMXNET3 network driver. It takes a pointer to the VMXNET3 state, an index for the transmit queue, and the index of the transmit descriptor that has been processed. The function initializes a transmission completion descriptor, updates the descriptor index and generation number, and ensures memory writes are completed before incrementing the transmission completion counter. Finally, it triggers an interrupt to notify the system that the packet has been successfully transmitted, facilitating further processing or acknowledgment of the transmission.","The function is designed to finalize the transmission of a network packet within a virtualized network driver. It begins by preparing a descriptor that indicates which packet has been processed. The function ensures that all previous changes to the transmission descriptor are completed before updating the completion count for the transmitted packets. After incrementing this count, it triggers an interrupt to inform the system that the packet transmission is complete, allowing for further actions or acknowledgments to be processed. This mechanism is essential for maintaining efficient communication in a virtualized networking environment.","The vulnerability in the original code stemmed from the lack of proper initialization of the transmission completion descriptor, which could lead to the use of uninitialized memory and potentially expose sensitive data or cause undefined behavior. In the fixed code, the addition of the `memset(&txcq_descr, 0, sizeof(txcq_descr));` line ensures that the descriptor is explicitly initialized to zero before being used. This change mitigates the risk of using stale or garbage values, thereby enhancing the security and stability of the packet completion process in the network driver.","The vulnerability in the original code arose from the failure to initialize a critical data structure, which could lead to the use of uninitialized memory. This oversight posed risks such as exposing sensitive information or causing unpredictable behavior during execution. The fix involved explicitly setting the data structure to zero before it was utilized, ensuring that all fields contained known values. This change effectively mitigated the risk associated with uninitialized memory, enhancing the overall security and reliability of the code by preventing potential exploitation or erratic behavior during packet processing.","The vulnerability was fixed by adding a line of code that initializes the transmission completion descriptor to zero using `memset(&txcq_descr, 0, sizeof(txcq_descr));`. This ensures that all fields within the descriptor are set to a known state before they are used, preventing the potential use of uninitialized memory. By doing this, the code eliminates the risk of accessing stale or garbage values, which could lead to undefined behavior or security issues. This explicit initialization enhances the reliability and security of the packet completion process in the network driver.","The vulnerability was addressed by incorporating an explicit initialization step for a critical data structure before its use. This step involved setting all fields of the structure to zero, ensuring that no uninitialized memory was accessed during execution. By doing so, the code mitigated the risks associated with using stale or garbage values, which could lead to unpredictable behavior or security vulnerabilities. This fix enhances the overall reliability and security of the code, ensuring that the data structure contains known values and preventing potential exploitation during the packet processing workflow.","5,5","5,5","4,3","4,5"
17,17,178185,178185,,Local,Not required,,CVE-2016-5337,https://www.cvedetails.com/cve/CVE-2016-5337/,CWE-200,Low,Partial,,,2016-06-14,2.1,The megasas_ctrl_get_info function in hw/scsi/megasas.c in QEMU allows local guest OS administrators to obtain sensitive host memory information via vectors related to reading device control information.,2018-12-01,+Info,1,https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6,844864fbae66935951529408831c2f22367a57b6,,0,,,"static int megasas_ctrl_get_info(MegasasState *s, MegasasCmd *cmd)
{
    PCIDevice *pci_dev = PCI_DEVICE(s);
    PCIDeviceClass *pci_class = PCI_DEVICE_GET_CLASS(pci_dev);
    MegasasBaseClass *base_class = MEGASAS_DEVICE_GET_CLASS(s);
    struct mfi_ctrl_info info;
    size_t dcmd_size = sizeof(info);
    BusChild *kid;
    int num_pd_disks = 0;

    memset(&info, 0x0, dcmd_size);
    if (cmd->iov_size < dcmd_size) {
        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,
                                            dcmd_size);
        return MFI_STAT_INVALID_PARAMETER;
    }

    info.pci.vendor = cpu_to_le16(pci_class->vendor_id);
    info.pci.device = cpu_to_le16(pci_class->device_id);
    info.pci.subvendor = cpu_to_le16(pci_class->subsystem_vendor_id);
    info.pci.subdevice = cpu_to_le16(pci_class->subsystem_id);

    /*
     * For some reason the firmware supports
     * only up to 8 device ports.
     * Despite supporting a far larger number
     * of devices for the physical devices.
     * So just display the first 8 devices
     * in the device port list, independent
     * of how many logical devices are actually
     * present.
     */
    info.host.type = MFI_INFO_HOST_PCIE;
    info.device.type = MFI_INFO_DEV_SAS3G;
    info.device.port_count = 8;
    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {
        SCSIDevice *sdev = SCSI_DEVICE(kid->child);
        uint16_t pd_id;

        if (num_pd_disks < 8) {
            pd_id = ((sdev->id & 0xFF) << 8) | (sdev->lun & 0xFF);
            info.device.port_addr[num_pd_disks] =
                cpu_to_le64(megasas_get_sata_addr(pd_id));
        }
        num_pd_disks++;
    }

    memcpy(info.product_name, base_class->product_name, 24);
    snprintf(info.serial_number, 32, ""%s"", s->hba_serial);
    snprintf(info.package_version, 0x60, ""%s-QEMU"", qemu_hw_version());
    memcpy(info.image_component[0].name, ""APP"", 3);
    snprintf(info.image_component[0].version, 10, ""%s-QEMU"",
             base_class->product_version);
    memcpy(info.image_component[0].build_date, ""Apr  1 2014"", 11);
    memcpy(info.image_component[0].build_time, ""12:34:56"", 8);
    info.image_component_count = 1;
    if (pci_dev->has_rom) {
        uint8_t biosver[32];
        uint8_t *ptr;
 
         ptr = memory_region_get_ram_ptr(&pci_dev->rom);
         memcpy(biosver, ptr + 0x41, 31);
        biosver[31] = 0;
         memcpy(info.image_component[1].name, ""BIOS"", 4);
         memcpy(info.image_component[1].version, biosver,
                strlen((const char *)biosver));
    }
    info.current_fw_time = cpu_to_le32(megasas_fw_time());
    info.max_arms = 32;
    info.max_spans = 8;
    info.max_arrays = MEGASAS_MAX_ARRAYS;
    info.max_lds = MFI_MAX_LD;
    info.max_cmds = cpu_to_le16(s->fw_cmds);
    info.max_sg_elements = cpu_to_le16(s->fw_sge);
    info.max_request_size = cpu_to_le32(MEGASAS_MAX_SECTORS);
    if (!megasas_is_jbod(s))
        info.lds_present = cpu_to_le16(num_pd_disks);
    info.pd_present = cpu_to_le16(num_pd_disks);
    info.pd_disks_present = cpu_to_le16(num_pd_disks);
    info.hw_present = cpu_to_le32(MFI_INFO_HW_NVRAM |
                                   MFI_INFO_HW_MEM |
                                   MFI_INFO_HW_FLASH);
    info.memory_size = cpu_to_le16(512);
    info.nvram_size = cpu_to_le16(32);
    info.flash_size = cpu_to_le16(16);
    info.raid_levels = cpu_to_le32(MFI_INFO_RAID_0);
    info.adapter_ops = cpu_to_le32(MFI_INFO_AOPS_RBLD_RATE |
                                    MFI_INFO_AOPS_SELF_DIAGNOSTIC |
                                    MFI_INFO_AOPS_MIXED_ARRAY);
    info.ld_ops = cpu_to_le32(MFI_INFO_LDOPS_DISK_CACHE_POLICY |
                               MFI_INFO_LDOPS_ACCESS_POLICY |
                               MFI_INFO_LDOPS_IO_POLICY |
                               MFI_INFO_LDOPS_WRITE_POLICY |
                               MFI_INFO_LDOPS_READ_POLICY);
    info.max_strips_per_io = cpu_to_le16(s->fw_sge);
    info.stripe_sz_ops.min = 3;
    info.stripe_sz_ops.max = ctz32(MEGASAS_MAX_SECTORS + 1);
    info.properties.pred_fail_poll_interval = cpu_to_le16(300);
    info.properties.intr_throttle_cnt = cpu_to_le16(16);
    info.properties.intr_throttle_timeout = cpu_to_le16(50);
    info.properties.rebuild_rate = 30;
    info.properties.patrol_read_rate = 30;
    info.properties.bgi_rate = 30;
    info.properties.cc_rate = 30;
    info.properties.recon_rate = 30;
    info.properties.cache_flush_interval = 4;
    info.properties.spinup_drv_cnt = 2;
    info.properties.spinup_delay = 6;
    info.properties.ecc_bucket_size = 15;
    info.properties.ecc_bucket_leak_rate = cpu_to_le16(1440);
    info.properties.expose_encl_devices = 1;
    info.properties.OnOffProperties = cpu_to_le32(MFI_CTRL_PROP_EnableJBOD);
    info.pd_ops = cpu_to_le32(MFI_INFO_PDOPS_FORCE_ONLINE |
                               MFI_INFO_PDOPS_FORCE_OFFLINE);
    info.pd_mix_support = cpu_to_le32(MFI_INFO_PDMIX_SAS |
                                       MFI_INFO_PDMIX_SATA |
                                       MFI_INFO_PDMIX_LD);

    cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);
    return MFI_STAT_OK;
}
","static int megasas_ctrl_get_info(MegasasState *s, MegasasCmd *cmd)
{
    PCIDevice *pci_dev = PCI_DEVICE(s);
    PCIDeviceClass *pci_class = PCI_DEVICE_GET_CLASS(pci_dev);
    MegasasBaseClass *base_class = MEGASAS_DEVICE_GET_CLASS(s);
    struct mfi_ctrl_info info;
    size_t dcmd_size = sizeof(info);
    BusChild *kid;
    int num_pd_disks = 0;

    memset(&info, 0x0, dcmd_size);
    if (cmd->iov_size < dcmd_size) {
        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,
                                            dcmd_size);
        return MFI_STAT_INVALID_PARAMETER;
    }

    info.pci.vendor = cpu_to_le16(pci_class->vendor_id);
    info.pci.device = cpu_to_le16(pci_class->device_id);
    info.pci.subvendor = cpu_to_le16(pci_class->subsystem_vendor_id);
    info.pci.subdevice = cpu_to_le16(pci_class->subsystem_id);

    /*
     * For some reason the firmware supports
     * only up to 8 device ports.
     * Despite supporting a far larger number
     * of devices for the physical devices.
     * So just display the first 8 devices
     * in the device port list, independent
     * of how many logical devices are actually
     * present.
     */
    info.host.type = MFI_INFO_HOST_PCIE;
    info.device.type = MFI_INFO_DEV_SAS3G;
    info.device.port_count = 8;
    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {
        SCSIDevice *sdev = SCSI_DEVICE(kid->child);
        uint16_t pd_id;

        if (num_pd_disks < 8) {
            pd_id = ((sdev->id & 0xFF) << 8) | (sdev->lun & 0xFF);
            info.device.port_addr[num_pd_disks] =
                cpu_to_le64(megasas_get_sata_addr(pd_id));
        }
        num_pd_disks++;
    }

    memcpy(info.product_name, base_class->product_name, 24);
    snprintf(info.serial_number, 32, ""%s"", s->hba_serial);
    snprintf(info.package_version, 0x60, ""%s-QEMU"", qemu_hw_version());
    memcpy(info.image_component[0].name, ""APP"", 3);
    snprintf(info.image_component[0].version, 10, ""%s-QEMU"",
             base_class->product_version);
    memcpy(info.image_component[0].build_date, ""Apr  1 2014"", 11);
    memcpy(info.image_component[0].build_time, ""12:34:56"", 8);
    info.image_component_count = 1;
    if (pci_dev->has_rom) {
        uint8_t biosver[32];
        uint8_t *ptr;
 
         ptr = memory_region_get_ram_ptr(&pci_dev->rom);
         memcpy(biosver, ptr + 0x41, 31);
         memcpy(info.image_component[1].name, ""BIOS"", 4);
         memcpy(info.image_component[1].version, biosver,
                strlen((const char *)biosver));
    }
    info.current_fw_time = cpu_to_le32(megasas_fw_time());
    info.max_arms = 32;
    info.max_spans = 8;
    info.max_arrays = MEGASAS_MAX_ARRAYS;
    info.max_lds = MFI_MAX_LD;
    info.max_cmds = cpu_to_le16(s->fw_cmds);
    info.max_sg_elements = cpu_to_le16(s->fw_sge);
    info.max_request_size = cpu_to_le32(MEGASAS_MAX_SECTORS);
    if (!megasas_is_jbod(s))
        info.lds_present = cpu_to_le16(num_pd_disks);
    info.pd_present = cpu_to_le16(num_pd_disks);
    info.pd_disks_present = cpu_to_le16(num_pd_disks);
    info.hw_present = cpu_to_le32(MFI_INFO_HW_NVRAM |
                                   MFI_INFO_HW_MEM |
                                   MFI_INFO_HW_FLASH);
    info.memory_size = cpu_to_le16(512);
    info.nvram_size = cpu_to_le16(32);
    info.flash_size = cpu_to_le16(16);
    info.raid_levels = cpu_to_le32(MFI_INFO_RAID_0);
    info.adapter_ops = cpu_to_le32(MFI_INFO_AOPS_RBLD_RATE |
                                    MFI_INFO_AOPS_SELF_DIAGNOSTIC |
                                    MFI_INFO_AOPS_MIXED_ARRAY);
    info.ld_ops = cpu_to_le32(MFI_INFO_LDOPS_DISK_CACHE_POLICY |
                               MFI_INFO_LDOPS_ACCESS_POLICY |
                               MFI_INFO_LDOPS_IO_POLICY |
                               MFI_INFO_LDOPS_WRITE_POLICY |
                               MFI_INFO_LDOPS_READ_POLICY);
    info.max_strips_per_io = cpu_to_le16(s->fw_sge);
    info.stripe_sz_ops.min = 3;
    info.stripe_sz_ops.max = ctz32(MEGASAS_MAX_SECTORS + 1);
    info.properties.pred_fail_poll_interval = cpu_to_le16(300);
    info.properties.intr_throttle_cnt = cpu_to_le16(16);
    info.properties.intr_throttle_timeout = cpu_to_le16(50);
    info.properties.rebuild_rate = 30;
    info.properties.patrol_read_rate = 30;
    info.properties.bgi_rate = 30;
    info.properties.cc_rate = 30;
    info.properties.recon_rate = 30;
    info.properties.cache_flush_interval = 4;
    info.properties.spinup_drv_cnt = 2;
    info.properties.spinup_delay = 6;
    info.properties.ecc_bucket_size = 15;
    info.properties.ecc_bucket_leak_rate = cpu_to_le16(1440);
    info.properties.expose_encl_devices = 1;
    info.properties.OnOffProperties = cpu_to_le32(MFI_CTRL_PROP_EnableJBOD);
    info.pd_ops = cpu_to_le32(MFI_INFO_PDOPS_FORCE_ONLINE |
                               MFI_INFO_PDOPS_FORCE_OFFLINE);
    info.pd_mix_support = cpu_to_le32(MFI_INFO_PDMIX_SAS |
                                       MFI_INFO_PDMIX_SATA |
                                       MFI_INFO_PDMIX_LD);

    cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);
    return MFI_STAT_OK;
}
",C,"        biosver[31] = 0;
",,6214a11ac167b1e866c04a81360286d186f04d82,"@@ -773,6 +773,7 @@ static int megasas_ctrl_get_info(MegasasState *s, MegasasCmd *cmd)
 
         ptr = memory_region_get_ram_ptr(&pci_dev->rom);
         memcpy(biosver, ptr + 0x41, 31);
+        biosver[31] = 0;
         memcpy(info.image_component[1].name, ""BIOS"", 4);
         memcpy(info.image_component[1].version, biosver,
                strlen((const char *)biosver));",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/scsi/megasas.c;h=a9ffc326826e5d4964733b26238e556fd56bd6d6;hb=844864fbae66935951529408831c2f22367a57b6,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/scsi/megasas.c;h=cc66d361862d54b0d375110b67c5eeb1464f142e,1,"static int megasas_ctrl_get_info(MegasasState *s, MegasasCmd *cmd)
{
    PCIDevice *pci_dev = PCI_DEVICE(s);
    PCIDeviceClass *pci_class = PCI_DEVICE_GET_CLASS(pci_dev);
    MegasasBaseClass *base_class = MEGASAS_DEVICE_GET_CLASS(s);
    struct mfi_ctrl_info info;
    size_t dcmd_size = sizeof(info);
    BusChild *kid;
    int num_pd_disks = 0;

    memset(&info, 0x0, dcmd_size);
    if (cmd->iov_size < dcmd_size) {
        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,
                                            dcmd_size);
        return MFI_STAT_INVALID_PARAMETER;
    }

    info.pci.vendor = cpu_to_le16(pci_class->vendor_id);
    info.pci.device = cpu_to_le16(pci_class->device_id);
    info.pci.subvendor = cpu_to_le16(pci_class->subsystem_vendor_id);
    info.pci.subdevice = cpu_to_le16(pci_class->subsystem_id);

    /*
     * For some reason the firmware supports
     * only up to 8 device ports.
     * Despite supporting a far larger number
     * of devices for the physical devices.
     * So just display the first 8 devices
     * in the device port list, independent
     * of how many logical devices are actually
     * present.
     */
    info.host.type = MFI_INFO_HOST_PCIE;
    info.device.type = MFI_INFO_DEV_SAS3G;
    info.device.port_count = 8;
    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {
        SCSIDevice *sdev = SCSI_DEVICE(kid->child);
        uint16_t pd_id;

        if (num_pd_disks < 8) {
            pd_id = ((sdev->id & 0xFF) << 8) | (sdev->lun & 0xFF);
            info.device.port_addr[num_pd_disks] =
                cpu_to_le64(megasas_get_sata_addr(pd_id));
        }
        num_pd_disks++;
    }

    memcpy(info.product_name, base_class->product_name, 24);
    snprintf(info.serial_number, 32, ""%s"", s->hba_serial);
    snprintf(info.package_version, 0x60, ""%s-QEMU"", qemu_hw_version());
    memcpy(info.image_component[0].name, ""APP"", 3);
    snprintf(info.image_component[0].version, 10, ""%s-QEMU"",
             base_class->product_version);
    memcpy(info.image_component[0].build_date, ""Apr  1 2014"", 11);
    memcpy(info.image_component[0].build_time, ""12:34:56"", 8);
    info.image_component_count = 1;
    if (pci_dev->has_rom) {
        uint8_t biosver[32];
        uint8_t *ptr;
 
         ptr = memory_region_get_ram_ptr(&pci_dev->rom);
         memcpy(biosver, ptr + 0x41, 31);
//fix_flaw_line_below:
//        biosver[31] = 0;
         memcpy(info.image_component[1].name, ""BIOS"", 4);
         memcpy(info.image_component[1].version, biosver,
                strlen((const char *)biosver));
    }
    info.current_fw_time = cpu_to_le32(megasas_fw_time());
    info.max_arms = 32;
    info.max_spans = 8;
    info.max_arrays = MEGASAS_MAX_ARRAYS;
    info.max_lds = MFI_MAX_LD;
    info.max_cmds = cpu_to_le16(s->fw_cmds);
    info.max_sg_elements = cpu_to_le16(s->fw_sge);
    info.max_request_size = cpu_to_le32(MEGASAS_MAX_SECTORS);
    if (!megasas_is_jbod(s))
        info.lds_present = cpu_to_le16(num_pd_disks);
    info.pd_present = cpu_to_le16(num_pd_disks);
    info.pd_disks_present = cpu_to_le16(num_pd_disks);
    info.hw_present = cpu_to_le32(MFI_INFO_HW_NVRAM |
                                   MFI_INFO_HW_MEM |
                                   MFI_INFO_HW_FLASH);
    info.memory_size = cpu_to_le16(512);
    info.nvram_size = cpu_to_le16(32);
    info.flash_size = cpu_to_le16(16);
    info.raid_levels = cpu_to_le32(MFI_INFO_RAID_0);
    info.adapter_ops = cpu_to_le32(MFI_INFO_AOPS_RBLD_RATE |
                                    MFI_INFO_AOPS_SELF_DIAGNOSTIC |
                                    MFI_INFO_AOPS_MIXED_ARRAY);
    info.ld_ops = cpu_to_le32(MFI_INFO_LDOPS_DISK_CACHE_POLICY |
                               MFI_INFO_LDOPS_ACCESS_POLICY |
                               MFI_INFO_LDOPS_IO_POLICY |
                               MFI_INFO_LDOPS_WRITE_POLICY |
                               MFI_INFO_LDOPS_READ_POLICY);
    info.max_strips_per_io = cpu_to_le16(s->fw_sge);
    info.stripe_sz_ops.min = 3;
    info.stripe_sz_ops.max = ctz32(MEGASAS_MAX_SECTORS + 1);
    info.properties.pred_fail_poll_interval = cpu_to_le16(300);
    info.properties.intr_throttle_cnt = cpu_to_le16(16);
    info.properties.intr_throttle_timeout = cpu_to_le16(50);
    info.properties.rebuild_rate = 30;
    info.properties.patrol_read_rate = 30;
    info.properties.bgi_rate = 30;
    info.properties.cc_rate = 30;
    info.properties.recon_rate = 30;
    info.properties.cache_flush_interval = 4;
    info.properties.spinup_drv_cnt = 2;
    info.properties.spinup_delay = 6;
    info.properties.ecc_bucket_size = 15;
    info.properties.ecc_bucket_leak_rate = cpu_to_le16(1440);
    info.properties.expose_encl_devices = 1;
    info.properties.OnOffProperties = cpu_to_le32(MFI_CTRL_PROP_EnableJBOD);
    info.pd_ops = cpu_to_le32(MFI_INFO_PDOPS_FORCE_ONLINE |
                               MFI_INFO_PDOPS_FORCE_OFFLINE);
    info.pd_mix_support = cpu_to_le32(MFI_INFO_PDMIX_SAS |
                                       MFI_INFO_PDMIX_SATA |
                                       MFI_INFO_PDMIX_LD);

    cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);
    return MFI_STAT_OK;
}
",178185,"static int megasas_ctrl_get_info(MegasasState *s, MegasasCmd *cmd)
{
    PCIDevice *pci_dev = PCI_DEVICE(s);
    PCIDeviceClass *pci_class = PCI_DEVICE_GET_CLASS(pci_dev);
    MegasasBaseClass *base_class = MEGASAS_DEVICE_GET_CLASS(s);
    struct mfi_ctrl_info info;
    size_t dcmd_size = sizeof(info);
    BusChild *kid;
    int num_pd_disks = 0;

    memset(&info, 0x0, dcmd_size);
    if (cmd->iov_size < dcmd_size) {
        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,
                                            dcmd_size);
        return MFI_STAT_INVALID_PARAMETER;
    }

    info.pci.vendor = cpu_to_le16(pci_class->vendor_id);
    info.pci.device = cpu_to_le16(pci_class->device_id);
    info.pci.subvendor = cpu_to_le16(pci_class->subsystem_vendor_id);
    info.pci.subdevice = cpu_to_le16(pci_class->subsystem_id);

    /*
     * For some reason the firmware supports
     * only up to 8 device ports.
     * Despite supporting a far larger number
     * of devices for the physical devices.
     * So just display the first 8 devices
     * in the device port list, independent
     * of how many logical devices are actually
     * present.
     */
    info.host.type = MFI_INFO_HOST_PCIE;
    info.device.type = MFI_INFO_DEV_SAS3G;
    info.device.port_count = 8;
    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {
        SCSIDevice *sdev = SCSI_DEVICE(kid->child);
        uint16_t pd_id;

        if (num_pd_disks < 8) {
            pd_id = ((sdev->id & 0xFF) << 8) | (sdev->lun & 0xFF);
            info.device.port_addr[num_pd_disks] =
                cpu_to_le64(megasas_get_sata_addr(pd_id));
        }
        num_pd_disks++;
    }

    memcpy(info.product_name, base_class->product_name, 24);
    snprintf(info.serial_number, 32, ""%s"", s->hba_serial);
    snprintf(info.package_version, 0x60, ""%s-QEMU"", qemu_hw_version());
    memcpy(info.image_component[0].name, ""APP"", 3);
    snprintf(info.image_component[0].version, 10, ""%s-QEMU"",
             base_class->product_version);
    memcpy(info.image_component[0].build_date, ""Apr  1 2014"", 11);
    memcpy(info.image_component[0].build_time, ""12:34:56"", 8);
    info.image_component_count = 1;
    if (pci_dev->has_rom) {
        uint8_t biosver[32];
        uint8_t *ptr;

        ptr = memory_region_get_ram_ptr(&pci_dev->rom);
        memcpy(biosver, ptr + 0x41, 31);
        memcpy(info.image_component[1].name, ""BIOS"", 4);
        memcpy(info.image_component[1].version, biosver,
               strlen((const char *)biosver));
        info.image_component_count++;
    }
    info.current_fw_time = cpu_to_le32(megasas_fw_time());
    info.max_arms = 32;
    info.max_spans = 8;
    info.max_arrays = MEGASAS_MAX_ARRAYS;
    info.max_lds = MFI_MAX_LD;
    info.max_cmds = cpu_to_le16(s->fw_cmds);
    info.max_sg_elements = cpu_to_le16(s->fw_sge);
    info.max_request_size = cpu_to_le32(MEGASAS_MAX_SECTORS);
    if (!megasas_is_jbod(s))
        info.lds_present = cpu_to_le16(num_pd_disks);
    info.pd_present = cpu_to_le16(num_pd_disks);
    info.pd_disks_present = cpu_to_le16(num_pd_disks);
    info.hw_present = cpu_to_le32(MFI_INFO_HW_NVRAM |
                                   MFI_INFO_HW_MEM |
                                   MFI_INFO_HW_FLASH);
    info.memory_size = cpu_to_le16(512);
    info.nvram_size = cpu_to_le16(32);
    info.flash_size = cpu_to_le16(16);
    info.raid_levels = cpu_to_le32(MFI_INFO_RAID_0);
    info.adapter_ops = cpu_to_le32(MFI_INFO_AOPS_RBLD_RATE |
                                    MFI_INFO_AOPS_SELF_DIAGNOSTIC |
                                    MFI_INFO_AOPS_MIXED_ARRAY);
    info.ld_ops = cpu_to_le32(MFI_INFO_LDOPS_DISK_CACHE_POLICY |
                               MFI_INFO_LDOPS_ACCESS_POLICY |
                               MFI_INFO_LDOPS_IO_POLICY |
                               MFI_INFO_LDOPS_WRITE_POLICY |
                               MFI_INFO_LDOPS_READ_POLICY);
    info.max_strips_per_io = cpu_to_le16(s->fw_sge);
    info.stripe_sz_ops.min = 3;
    info.stripe_sz_ops.max = ctz32(MEGASAS_MAX_SECTORS + 1);
    info.properties.pred_fail_poll_interval = cpu_to_le16(300);
    info.properties.intr_throttle_cnt = cpu_to_le16(16);
    info.properties.intr_throttle_timeout = cpu_to_le16(50);
    info.properties.rebuild_rate = 30;
    info.properties.patrol_read_rate = 30;
    info.properties.bgi_rate = 30;
    info.properties.cc_rate = 30;
    info.properties.recon_rate = 30;
    info.properties.cache_flush_interval = 4;
    info.properties.spinup_drv_cnt = 2;
    info.properties.spinup_delay = 6;
    info.properties.ecc_bucket_size = 15;
    info.properties.ecc_bucket_leak_rate = cpu_to_le16(1440);
    info.properties.expose_encl_devices = 1;
    info.properties.OnOffProperties = cpu_to_le32(MFI_CTRL_PROP_EnableJBOD);
    info.pd_ops = cpu_to_le32(MFI_INFO_PDOPS_FORCE_ONLINE |
                               MFI_INFO_PDOPS_FORCE_OFFLINE);
    info.pd_mix_support = cpu_to_le32(MFI_INFO_PDMIX_SAS |
                                       MFI_INFO_PDMIX_SATA |
                                       MFI_INFO_PDMIX_LD);

    cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);
    return MFI_STAT_OK;
}","static int megasas_ctrl_get_info(MegasasState *s, MegasasCmd *cmd)
{
    PCIDevice *pci_dev = PCI_DEVICE(s);
    PCIDeviceClass *pci_class = PCI_DEVICE_GET_CLASS(pci_dev);
    MegasasBaseClass *base_class = MEGASAS_DEVICE_GET_CLASS(s);
    struct mfi_ctrl_info info;
    size_t dcmd_size = sizeof(info);
    BusChild *kid;
    int num_pd_disks = 0;

    memset(&info, 0x0, dcmd_size);
    if (cmd->iov_size < dcmd_size) {
        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,
                                            dcmd_size);
        return MFI_STAT_INVALID_PARAMETER;
    }

    info.pci.vendor = cpu_to_le16(pci_class->vendor_id);
    info.pci.device = cpu_to_le16(pci_class->device_id);
    info.pci.subvendor = cpu_to_le16(pci_class->subsystem_vendor_id);
    info.pci.subdevice = cpu_to_le16(pci_class->subsystem_id);

    /*
     * For some reason the firmware supports
     * only up to 8 device ports.
     * Despite supporting a far larger number
     * of devices for the physical devices.
     * So just display the first 8 devices
     * in the device port list, independent
     * of how many logical devices are actually
     * present.
     */
    info.host.type = MFI_INFO_HOST_PCIE;
    info.device.type = MFI_INFO_DEV_SAS3G;
    info.device.port_count = 8;
    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {
        SCSIDevice *sdev = SCSI_DEVICE(kid->child);
        uint16_t pd_id;

        if (num_pd_disks < 8) {
            pd_id = ((sdev->id & 0xFF) << 8) | (sdev->lun & 0xFF);
            info.device.port_addr[num_pd_disks] =
                cpu_to_le64(megasas_get_sata_addr(pd_id));
        }
        num_pd_disks++;
    }

    memcpy(info.product_name, base_class->product_name, 24);
    snprintf(info.serial_number, 32, ""%s"", s->hba_serial);
    snprintf(info.package_version, 0x60, ""%s-QEMU"", qemu_hw_version());
    memcpy(info.image_component[0].name, ""APP"", 3);
    snprintf(info.image_component[0].version, 10, ""%s-QEMU"",
             base_class->product_version);
    memcpy(info.image_component[0].build_date, ""Apr  1 2014"", 11);
    memcpy(info.image_component[0].build_time, ""12:34:56"", 8);
    info.image_component_count = 1;
    if (pci_dev->has_rom) {
        uint8_t biosver[32];
        uint8_t *ptr;
 
         ptr = memory_region_get_ram_ptr(&pci_dev->rom);
         memcpy(biosver, ptr + 0x41, 31);
        biosver[31] = 0;
         memcpy(info.image_component[1].name, ""BIOS"", 4);
         memcpy(info.image_component[1].version, biosver,
                strlen((const char *)biosver));
    }
    info.current_fw_time = cpu_to_le32(megasas_fw_time());
    info.max_arms = 32;
    info.max_spans = 8;
    info.max_arrays = MEGASAS_MAX_ARRAYS;
    info.max_lds = MFI_MAX_LD;
    info.max_cmds = cpu_to_le16(s->fw_cmds);
    info.max_sg_elements = cpu_to_le16(s->fw_sge);
    info.max_request_size = cpu_to_le32(MEGASAS_MAX_SECTORS);
    if (!megasas_is_jbod(s))
        info.lds_present = cpu_to_le16(num_pd_disks);
    info.pd_present = cpu_to_le16(num_pd_disks);
    info.pd_disks_present = cpu_to_le16(num_pd_disks);
    info.hw_present = cpu_to_le32(MFI_INFO_HW_NVRAM |
                                   MFI_INFO_HW_MEM |
                                   MFI_INFO_HW_FLASH);
    info.memory_size = cpu_to_le16(512);
    info.nvram_size = cpu_to_le16(32);
    info.flash_size = cpu_to_le16(16);
    info.raid_levels = cpu_to_le32(MFI_INFO_RAID_0);
    info.adapter_ops = cpu_to_le32(MFI_INFO_AOPS_RBLD_RATE |
                                    MFI_INFO_AOPS_SELF_DIAGNOSTIC |
                                    MFI_INFO_AOPS_MIXED_ARRAY);
    info.ld_ops = cpu_to_le32(MFI_INFO_LDOPS_DISK_CACHE_POLICY |
                               MFI_INFO_LDOPS_ACCESS_POLICY |
                               MFI_INFO_LDOPS_IO_POLICY |
                               MFI_INFO_LDOPS_WRITE_POLICY |
                               MFI_INFO_LDOPS_READ_POLICY);
    info.max_strips_per_io = cpu_to_le16(s->fw_sge);
    info.stripe_sz_ops.min = 3;
    info.stripe_sz_ops.max = ctz32(MEGASAS_MAX_SECTORS + 1);
    info.properties.pred_fail_poll_interval = cpu_to_le16(300);
    info.properties.intr_throttle_cnt = cpu_to_le16(16);
    info.properties.intr_throttle_timeout = cpu_to_le16(50);
    info.properties.rebuild_rate = 30;
    info.properties.patrol_read_rate = 30;
    info.properties.bgi_rate = 30;
    info.properties.cc_rate = 30;
    info.properties.recon_rate = 30;
    info.properties.cache_flush_interval = 4;
    info.properties.spinup_drv_cnt = 2;
    info.properties.spinup_delay = 6;
    info.properties.ecc_bucket_size = 15;
    info.properties.ecc_bucket_leak_rate = cpu_to_le16(1440);
    info.properties.expose_encl_devices = 1;
    info.properties.OnOffProperties = cpu_to_le32(MFI_CTRL_PROP_EnableJBOD);
    info.pd_ops = cpu_to_le32(MFI_INFO_PDOPS_FORCE_ONLINE |
                               MFI_INFO_PDOPS_FORCE_OFFLINE);
    info.pd_mix_support = cpu_to_le32(MFI_INFO_PDMIX_SAS |
                                       MFI_INFO_PDMIX_SATA |
                                       MFI_INFO_PDMIX_LD);

    cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);
    return MFI_STAT_OK;
}
","The `megasas_ctrl_get_info` function retrieves and populates controller information for a MegaRAID SAS device. It initializes a structure with PCI device details, including vendor and device IDs, and gathers information about connected physical disks, limiting the count to eight. The function also fills in various operational parameters, firmware details, and RAID capabilities. It checks the command's input/output vector size for validity and prepares the data for transfer. Finally, it updates the command's size and returns a status code indicating success or failure, ensuring the controller's operational state and configuration are accurately reported.","The code defines a function that gathers and returns detailed information about a MegaRAID SAS controller. It initializes a data structure with essential device attributes, including vendor and device identifiers, and collects information about connected physical disks, capping the count at eight. The function checks the validity of the input size and populates various operational parameters, firmware details, and RAID capabilities. After preparing the data for transfer, it updates the command's size and returns a status code to indicate whether the operation was successful or encountered an error, ensuring accurate reporting of the controller's state and configuration.","The vulnerability in the original code stemmed from a potential buffer overflow when copying the BIOS version string into the `info.image_component[1].version` field, as it did not ensure that the string was null-terminated after copying. This could lead to reading beyond the allocated memory, causing undefined behavior. The fix introduced a null-termination step by explicitly setting the last byte of the `biosver` array to zero after copying the BIOS version, ensuring that the string is properly terminated and preventing any overflow or memory corruption issues during subsequent operations.","The vulnerability in the original code was due to a potential buffer overflow when copying a string, as it did not ensure that the copied data was properly null-terminated. This oversight could lead to reading beyond the allocated memory, resulting in undefined behavior or crashes. The fix addressed this issue by explicitly adding a null-termination step after copying the string, ensuring that it would not exceed the intended buffer size. This change effectively mitigated the risk of memory corruption and ensured safe handling of string data in subsequent operations, enhancing the overall stability and security of the code.","The vulnerability was fixed by adding a null-termination step for the `biosver` array after copying the BIOS version string from the memory region. Specifically, the code now includes a line that sets the last byte of the `biosver` array to zero, ensuring that the string is properly terminated. This change prevents any potential buffer overflow when the BIOS version is subsequently copied into the `info.image_component[1].version` field, thereby safeguarding against reading beyond the allocated memory and ensuring that string operations behave correctly without causing undefined behavior or crashes.","The vulnerability was fixed by ensuring that the copied string is properly null-terminated after being retrieved from memory. This was accomplished by explicitly setting the last byte of the buffer to zero following the copy operation. By implementing this safeguard, the code prevents any potential buffer overflow or reading beyond the allocated memory, which could lead to undefined behavior or crashes. This change enhances the stability and security of the code by ensuring that string operations are performed safely, thereby mitigating risks associated with improper memory handling.","4,4","5,5","4,4","5,5"
18,18,178197,178197,,Remote,Not required,,CVE-2018-6790,https://www.cvedetails.com/cve/CVE-2018-6790/,CWE-200,Low,Partial,,,2018-02-06,5.0,"An issue was discovered in KDE Plasma Workspace before 5.12.0. dataengines/notifications/notificationsengine.cpp allows remote attackers to discover client IP addresses via a URL in a notification, as demonstrated by the src attribute of an IMG element.",2019-08-06,+Info,8,https://cgit.kde.org/plasma-workspace.git/commit/?id=8164beac15ea34ec0d1564f0557fe3e742bdd938,8164beac15ea34ec0d1564f0557fe3e742bdd938,,7,,,"uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,
                                 const QString &app_icon, const QString &summary, const QString &body,
                                 const QStringList &actions, const QVariantMap &hints, int timeout)
{
    uint partOf = 0;
    const QString appRealName = hints[QStringLiteral(""x-kde-appname"")].toString();
    const QString eventId = hints[QStringLiteral(""x-kde-eventId"")].toString();
    const bool skipGrouping = hints[QStringLiteral(""x-kde-skipGrouping"")].toBool();

    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {
        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();
    }

     qDebug() << ""Currrent active notifications:"" << m_activeNotifications;
     qDebug() << ""Guessing partOf as:"" << partOf;
     qDebug() << "" New Notification: "" << summary << body << timeout << ""& Part of:"" << partOf;
    QString bodyFinal = NotificationSanitizer::parse(body);
 
     if (partOf > 0) {
         const QString source = QStringLiteral(""notification %1"").arg(partOf);
         Plasma::DataContainer *container = containerForSource(source);
         if (container) {
            const QString previousBody = container->data()[QStringLiteral(""body"")].toString();
            if (previousBody != bodyFinal) {
                // FIXME: This will just append the entire old XML document to another one, leading to:
                // <?xml><html>old</html><br><?xml><html>new</html>
                // It works but is not very clean.
                bodyFinal = previousBody + QStringLiteral(""<br/>"") + bodyFinal;
             }
 
             replaces_id = partOf;
            CloseNotification(partOf);
        }
    }

    uint id = replaces_id ? replaces_id : m_nextId++;

    if (m_alwaysReplaceAppsList.contains(app_name)) {
        if (m_notificationsFromReplaceableApp.contains(app_name)) {
            id = m_notificationsFromReplaceableApp.value(app_name);
        } else {
            m_notificationsFromReplaceableApp.insert(app_name, id);
        }
    }

    QString appname_str = app_name;
    if (appname_str.isEmpty()) {
        appname_str = i18n(""Unknown Application"");
    }

    bool isPersistent = timeout == 0;

 
     const int AVERAGE_WORD_LENGTH = 6;
     const int WORD_PER_MINUTE = 250;
    int count = summary.length() + body.length() - strlen(""<?xml version=\""1.0\""><html></html>"");
 
        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;

        timeout = 2000 + qMax(timeout, 3000);
    }
","uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,
                                 const QString &app_icon, const QString &summary, const QString &body,
                                 const QStringList &actions, const QVariantMap &hints, int timeout)
{
    uint partOf = 0;
    const QString appRealName = hints[QStringLiteral(""x-kde-appname"")].toString();
    const QString eventId = hints[QStringLiteral(""x-kde-eventId"")].toString();
    const bool skipGrouping = hints[QStringLiteral(""x-kde-skipGrouping"")].toBool();

    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {
        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();
    }

     qDebug() << ""Currrent active notifications:"" << m_activeNotifications;
     qDebug() << ""Guessing partOf as:"" << partOf;
     qDebug() << "" New Notification: "" << summary << body << timeout << ""& Part of:"" << partOf;
    QString _body;
 
     if (partOf > 0) {
         const QString source = QStringLiteral(""notification %1"").arg(partOf);
         Plasma::DataContainer *container = containerForSource(source);
         if (container) {
            _body = container->data()[QStringLiteral(""body"")].toString();
            if (_body != body) {
                _body.append(""\n"").append(body);
            } else {
                _body = body;
             }
 
             replaces_id = partOf;
            CloseNotification(partOf);
        }
    }

    uint id = replaces_id ? replaces_id : m_nextId++;

    if (m_alwaysReplaceAppsList.contains(app_name)) {
        if (m_notificationsFromReplaceableApp.contains(app_name)) {
            id = m_notificationsFromReplaceableApp.value(app_name);
        } else {
            m_notificationsFromReplaceableApp.insert(app_name, id);
        }
    }

    QString appname_str = app_name;
    if (appname_str.isEmpty()) {
        appname_str = i18n(""Unknown Application"");
    }

    bool isPersistent = timeout == 0;

 
     const int AVERAGE_WORD_LENGTH = 6;
     const int WORD_PER_MINUTE = 250;
    int count = summary.length() + body.length();
 
        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;

        timeout = 2000 + qMax(timeout, 3000);
    }
",CPP,"    QString bodyFinal = NotificationSanitizer::parse(body);
            const QString previousBody = container->data()[QStringLiteral(""body"")].toString();
            if (previousBody != bodyFinal) {
                // FIXME: This will just append the entire old XML document to another one, leading to:
                // <?xml><html>old</html><br><?xml><html>new</html>
                // It works but is not very clean.
                bodyFinal = previousBody + QStringLiteral(""<br/>"") + bodyFinal;
    int count = summary.length() + body.length() - strlen(""<?xml version=\""1.0\""><html></html>"");
","    QString _body;
            _body = container->data()[QStringLiteral(""body"")].toString();
            if (_body != body) {
                _body.append(""\n"").append(body);
            } else {
                _body = body;
    int count = summary.length() + body.length();
",9db872df82c258315c6ebad800af59e81ffb9212,"@@ -202,18 +202,19 @@ uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,
     qDebug() << ""Currrent active notifications:"" << m_activeNotifications;
     qDebug() << ""Guessing partOf as:"" << partOf;
     qDebug() << "" New Notification: "" << summary << body << timeout << ""& Part of:"" << partOf;
-    QString _body;
+    QString bodyFinal = NotificationSanitizer::parse(body);
 
     if (partOf > 0) {
         const QString source = QStringLiteral(""notification %1"").arg(partOf);
         Plasma::DataContainer *container = containerForSource(source);
         if (container) {
             // append the body text
-            _body = container->data()[QStringLiteral(""body"")].toString();
-            if (_body != body) {
-                _body.append(""\n"").append(body);
-            } else {
-                _body = body;
+            const QString previousBody = container->data()[QStringLiteral(""body"")].toString();
+            if (previousBody != bodyFinal) {
+                // FIXME: This will just append the entire old XML document to another one, leading to:
+                // <?xml><html>old</html><br><?xml><html>new</html>
+                // It works but is not very clean.
+                bodyFinal = previousBody + QStringLiteral(""<br/>"") + bodyFinal;
             }
 
             replaces_id = partOf;
@@ -246,7 +247,7 @@ uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,
 
     const int AVERAGE_WORD_LENGTH = 6;
     const int WORD_PER_MINUTE = 250;
-    int count = summary.length() + body.length();
+    int count = summary.length() + body.length() - strlen(""<?xml version=\""1.0\""><html></html>"");
 
     // -1 is ""server default"", 0 is persistent with ""server default"" display time,
     // anything more should honor the setting
@@ -261,9 +262,6 @@ uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,
 
     const QString source = QStringLiteral(""notification %1"").arg(id);
 
-    QString bodyFinal = (partOf == 0 ? body : _body);
-    bodyFinal = NotificationSanitizer::parse(bodyFinal);
-
     Plasma::DataEngine::Data notificationData;
     notificationData.insert(QStringLiteral(""id""), QString::number(id));
     notificationData.insert(QStringLiteral(""eventId""), eventId);",kde,https://cgit.kde.org/plasma-workspace.git/tree/dataengines/notifications/notificationsengine.cpp?id=8164beac15ea34ec0d1564f0557fe3e742bdd938,https://cgit.kde.org/plasma-workspace.git/tree/dataengines/notifications/notificationsengine.cpp?id=9db872df82c258315c6ebad800af59e81ffb9212,1,"uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,
                                 const QString &app_icon, const QString &summary, const QString &body,
                                 const QStringList &actions, const QVariantMap &hints, int timeout)
{
    uint partOf = 0;
    const QString appRealName = hints[QStringLiteral(""x-kde-appname"")].toString();
    const QString eventId = hints[QStringLiteral(""x-kde-eventId"")].toString();
    const bool skipGrouping = hints[QStringLiteral(""x-kde-skipGrouping"")].toBool();

    // group notifications that have the same title coming from the same app
    // or if they are on the ""blacklist"", honor the skipGrouping hint sent
    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {
        // cut off the ""notification "" from the source name
        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();
    }

     qDebug() << ""Currrent active notifications:"" << m_activeNotifications;
     qDebug() << ""Guessing partOf as:"" << partOf;
     qDebug() << "" New Notification: "" << summary << body << timeout << ""& Part of:"" << partOf;
//flaw_line_below:
    QString _body;
//fix_flaw_line_below:
//    QString bodyFinal = NotificationSanitizer::parse(body);
 
     if (partOf > 0) {
         const QString source = QStringLiteral(""notification %1"").arg(partOf);
         Plasma::DataContainer *container = containerForSource(source);
         if (container) {
             // append the body text
//flaw_line_below:
            _body = container->data()[QStringLiteral(""body"")].toString();
//flaw_line_below:
            if (_body != body) {
//flaw_line_below:
                _body.append(""\n"").append(body);
//flaw_line_below:
            } else {
//flaw_line_below:
                _body = body;
//fix_flaw_line_below:
//            const QString previousBody = container->data()[QStringLiteral(""body"")].toString();
//fix_flaw_line_below:
//            if (previousBody != bodyFinal) {
//fix_flaw_line_below:
//                // FIXME: This will just append the entire old XML document to another one, leading to:
//fix_flaw_line_below:
//                // <?xml><html>old</html><br><?xml><html>new</html>
//fix_flaw_line_below:
//                // It works but is not very clean.
//fix_flaw_line_below:
//                bodyFinal = previousBody + QStringLiteral(""<br/>"") + bodyFinal;
             }
 
             replaces_id = partOf;
            // remove the old notification and replace it with the new one
            // TODO: maybe just update the current notification?
            CloseNotification(partOf);
        }
    }

    uint id = replaces_id ? replaces_id : m_nextId++;

    // If the current app is in the ""blacklist""...
    if (m_alwaysReplaceAppsList.contains(app_name)) {
        // ...check if we already have a notification from that particular
        // app and if yes, use its id to replace it
        if (m_notificationsFromReplaceableApp.contains(app_name)) {
            id = m_notificationsFromReplaceableApp.value(app_name);
        } else {
            m_notificationsFromReplaceableApp.insert(app_name, id);
        }
    }

    QString appname_str = app_name;
    if (appname_str.isEmpty()) {
        appname_str = i18n(""Unknown Application"");
    }

    bool isPersistent = timeout == 0;

 
     const int AVERAGE_WORD_LENGTH = 6;
     const int WORD_PER_MINUTE = 250;
//flaw_line_below:
    int count = summary.length() + body.length();
//fix_flaw_line_below:
//    int count = summary.length() + body.length() - strlen(""<?xml version=\""1.0\""><html></html>"");
 
     // -1 is ""server default"", 0 is persistent with ""server default"" display time,
     // anything more should honor the setting
        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;

        // Add two seconds for the user to notice the notification, and ensure
        // it last at least five seconds, otherwise all the user see is a
        // flash
        timeout = 2000 + qMax(timeout, 3000);
    }
",178197,"uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,
                                 const QString &app_icon, const QString &summary, const QString &body,
                                 const QStringList &actions, const QVariantMap &hints, int timeout)
{
    uint partOf = 0;
    const QString appRealName = hints[QStringLiteral(""x-kde-appname"")].toString();
    const QString eventId = hints[QStringLiteral(""x-kde-eventId"")].toString();
    const bool skipGrouping = hints[QStringLiteral(""x-kde-skipGrouping"")].toBool();

    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {
        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();
    }

     qDebug() << ""Currrent active notifications:"" << m_activeNotifications;
     qDebug() << ""Guessing partOf as:"" << partOf;
     qDebug() << "" New Notification: "" << summary << body << timeout << ""& Part of:"" << partOf;
    QString _body;
 
     if (partOf > 0) {
         const QString source = QStringLiteral(""notification %1"").arg(partOf);
         Plasma::DataContainer *container = containerForSource(source);
         if (container) {
            _body = container->data()[QStringLiteral(""body"")].toString();
            if (_body != body) {
                _body.append(""\n"").append(body);
            } else {
                _body = body;
             }
 
             replaces_id = partOf;
            CloseNotification(partOf);
        }
    }

    uint id = replaces_id ? replaces_id : m_nextId++;

    if (m_alwaysReplaceAppsList.contains(app_name)) {
        if (m_notificationsFromReplaceableApp.contains(app_name)) {
            id = m_notificationsFromReplaceableApp.value(app_name);
        } else {
            m_notificationsFromReplaceableApp.insert(app_name, id);
        }
    }

    QString appname_str = app_name;
    if (appname_str.isEmpty()) {
        appname_str = i18n(""Unknown Application"");
    }

    bool isPersistent = timeout == 0;

 
     const int AVERAGE_WORD_LENGTH = 6;
     const int WORD_PER_MINUTE = 250;
    int count = summary.length() + body.length();
 
        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;

        timeout = 2000 + qMax(timeout, 3000);
    }
","uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,
                                 const QString &app_icon, const QString &summary, const QString &body,
                                 const QStringList &actions, const QVariantMap &hints, int timeout)
{
    uint partOf = 0;
    const QString appRealName = hints[QStringLiteral(""x-kde-appname"")].toString();
    const QString eventId = hints[QStringLiteral(""x-kde-eventId"")].toString();
    const bool skipGrouping = hints[QStringLiteral(""x-kde-skipGrouping"")].toBool();

    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {
        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();
    }

     qDebug() << ""Currrent active notifications:"" << m_activeNotifications;
     qDebug() << ""Guessing partOf as:"" << partOf;
     qDebug() << "" New Notification: "" << summary << body << timeout << ""& Part of:"" << partOf;
    QString bodyFinal = NotificationSanitizer::parse(body);
 
     if (partOf > 0) {
         const QString source = QStringLiteral(""notification %1"").arg(partOf);
         Plasma::DataContainer *container = containerForSource(source);
         if (container) {
            const QString previousBody = container->data()[QStringLiteral(""body"")].toString();
            if (previousBody != bodyFinal) {
                // FIXME: This will just append the entire old XML document to another one, leading to:
                // <?xml><html>old</html><br><?xml><html>new</html>
                // It works but is not very clean.
                bodyFinal = previousBody + QStringLiteral(""<br/>"") + bodyFinal;
             }
 
             replaces_id = partOf;
            CloseNotification(partOf);
        }
    }

    uint id = replaces_id ? replaces_id : m_nextId++;

    if (m_alwaysReplaceAppsList.contains(app_name)) {
        if (m_notificationsFromReplaceableApp.contains(app_name)) {
            id = m_notificationsFromReplaceableApp.value(app_name);
        } else {
            m_notificationsFromReplaceableApp.insert(app_name, id);
        }
    }

    QString appname_str = app_name;
    if (appname_str.isEmpty()) {
        appname_str = i18n(""Unknown Application"");
    }

    bool isPersistent = timeout == 0;

 
     const int AVERAGE_WORD_LENGTH = 6;
     const int WORD_PER_MINUTE = 250;
    int count = summary.length() + body.length() - strlen(""<?xml version=\""1.0\""><html></html>"");
 
        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;

        timeout = 2000 + qMax(timeout, 3000);
    }
","The `Notify` function in the `NotificationsEngine` class is responsible for managing and displaying notifications for applications. It takes parameters such as the application name, an optional ID for replacing existing notifications, an application icon, a summary, a body message, a list of actions, hints, and a timeout duration. The function checks if a notification should be grouped with an existing one or replaced based on specific conditions. It calculates a timeout based on the length of the summary and body, ensuring a minimum display time. Additionally, it handles persistent notifications and manages unique IDs for notifications, logging relevant information for debugging purposes.","The provided code defines a function that manages the creation and display of notifications for applications. It determines whether to group a new notification with an existing one or replace it based on specific criteria. The function calculates an appropriate display duration based on the content length of the notification, ensuring it meets a minimum time requirement. It also handles unique identifiers for notifications, allowing for consistent management of notifications from applications that frequently update their messages. Additionally, the function logs relevant information for debugging purposes, providing insights into the current state of active notifications.","The vulnerability in the original code stemmed from improper handling of notification body content, particularly when appending new messages to existing ones. This could lead to malformed XML structures, as the code would concatenate old and new content without proper formatting, resulting in potentially invalid XML output. The fix introduced a sanitization step using `NotificationSanitizer::parse(body)`, which ensures that the body content is properly formatted before being processed. Additionally, the code now checks if the previous body content differs from the new sanitized body, preventing the creation of messy concatenations and ensuring cleaner, valid XML output.","The vulnerability in the original code arose from the improper handling of notification body content, which could lead to malformed XML when appending new messages to existing ones. This issue could result in invalid structures that compromise the integrity of the notification system. The fix addressed this by introducing a sanitization process for the notification body, ensuring that the content is properly formatted before being processed. Additionally, the updated code checks for differences between the previous and new content, preventing messy concatenations and ensuring that the final output remains clean and valid, thus enhancing the overall robustness of the notification handling.","The vulnerability was fixed by introducing the `NotificationSanitizer::parse(body)` function, which sanitizes the notification body content before it is processed. This ensures that the body is properly formatted, preventing the creation of malformed XML when appending new messages. Additionally, the code now checks if the `previousBody` differs from the sanitized `bodyFinal`. If they are different, it appends the new content to the existing one with a proper line break, avoiding messy concatenations. This approach enhances the integrity of the notification output, ensuring that it remains clean and valid XML.","The vulnerability was addressed by implementing a sanitization process for the notification content, ensuring that any new messages are properly formatted before being combined with existing ones. This prevents the creation of malformed structures that could arise from improper concatenation. Additionally, the updated code includes a check to compare the previous content with the new sanitized message. If they differ, the new content is appended in a way that maintains clarity and structure, thereby enhancing the overall integrity and validity of the notification output while avoiding messy or invalid formatting.","5,4","5, 5","4, 4","4,3"
19,19,178198,178198,,Remote,Not required,,CVE-2018-6790,https://www.cvedetails.com/cve/CVE-2018-6790/,CWE-200,Low,Partial,,,2018-02-06,5.0,"An issue was discovered in KDE Plasma Workspace before 5.12.0. dataengines/notifications/notificationsengine.cpp allows remote attackers to discover client IP addresses via a URL in a notification, as demonstrated by the src attribute of an IMG element.",2019-08-06,+Info,1,https://cgit.kde.org/plasma-workspace.git/commit/?id=5bc696b5abcdb460c1017592e80b2d7f6ed3107c,5bc696b5abcdb460c1017592e80b2d7f6ed3107c,,6,,,"uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,
                                 const QString &app_icon, const QString &summary, const QString &body,
                                 const QStringList &actions, const QVariantMap &hints, int timeout)
{
    uint partOf = 0;
    const QString appRealName = hints[QStringLiteral(""x-kde-appname"")].toString();
    const QString eventId = hints[QStringLiteral(""x-kde-eventId"")].toString();
    const bool skipGrouping = hints[QStringLiteral(""x-kde-skipGrouping"")].toBool();

    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {
        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();
    }

    qDebug() << ""Currrent active notifications:"" << m_activeNotifications;
    qDebug() << ""Guessing partOf as:"" << partOf;
    qDebug() << "" New Notification: "" << summary << body << timeout << ""& Part of:"" << partOf;
    QString _body;

    if (partOf > 0) {
        const QString source = QStringLiteral(""notification %1"").arg(partOf);
        Plasma::DataContainer *container = containerForSource(source);
        if (container) {
            _body = container->data()[QStringLiteral(""body"")].toString();
            if (_body != body) {
                _body.append(""\n"").append(body);
            } else {
                _body = body;
            }

            replaces_id = partOf;

            CloseNotification(partOf);
        }
    }

    uint id = replaces_id ? replaces_id : m_nextId++;

    if (m_alwaysReplaceAppsList.contains(app_name)) {
        if (m_notificationsFromReplaceableApp.contains(app_name)) {
            id = m_notificationsFromReplaceableApp.value(app_name);
        } else {
            m_notificationsFromReplaceableApp.insert(app_name, id);
        }
    }

    QString appname_str = app_name;
    if (appname_str.isEmpty()) {
        appname_str = i18n(""Unknown Application"");
    }

    bool isPersistent = timeout == 0;

    const int AVERAGE_WORD_LENGTH = 6;
    const int WORD_PER_MINUTE = 250;
    int count = summary.length() + body.length();

    if (timeout <= 0) {
        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;

        timeout = 2000 + qMax(timeout, 3000);
    }

    const QString source = QStringLiteral(""notification %1"").arg(id);
     const QString source = QStringLiteral(""notification %1"").arg(id);
 
     QString bodyFinal = (partOf == 0 ? body : _body);
    bodyFinal = NotificationSanitizer::parse(bodyFinal);
 
     Plasma::DataEngine::Data notificationData;
     notificationData.insert(QStringLiteral(""id""), QString::number(id));
    bodyFinal = bodyFinal.simplified();
    bodyFinal.replace(QRegularExpression(QStringLiteral(""<br/>\\s*<br/>(\\s|<br/>)*"")), QLatin1String(""<br/>""));
    bodyFinal.replace(QRegularExpression(QStringLiteral(""&(?!(?:apos|quot|[gl]t|amp);|#)"")), QLatin1String(""&amp;""));
    bodyFinal.replace(QLatin1String(""&apos;""), QChar('\''));

    Plasma::DataEngine::Data notificationData;
    notificationData.insert(QStringLiteral(""id""), QString::number(id));
    notificationData.insert(QStringLiteral(""eventId""), eventId);
    notificationData.insert(QStringLiteral(""appName""), appname_str);
    notificationData.insert(QStringLiteral(""appIcon""), app_icon);
    notificationData.insert(QStringLiteral(""summary""), summary);
    notificationData.insert(QStringLiteral(""body""), bodyFinal);
    notificationData.insert(QStringLiteral(""actions""), actions);
    notificationData.insert(QStringLiteral(""isPersistent""), isPersistent);
    notificationData.insert(QStringLiteral(""expireTimeout""), timeout);

    bool configurable = false;
    if (!appRealName.isEmpty()) {

        if (m_configurableApplications.contains(appRealName)) {
            configurable = m_configurableApplications.value(appRealName);
        } else {
            QScopedPointer<KConfig> config(new KConfig(appRealName + QStringLiteral("".notifyrc""), KConfig::NoGlobals));
            config->addConfigSources(QStandardPaths::locateAll(QStandardPaths::GenericDataLocation,
                                     QStringLiteral(""knotifications5/"") + appRealName + QStringLiteral("".notifyrc"")));

            const QRegularExpression regexp(QStringLiteral(""^Event/([^/]*)$""));
            configurable = !config->groupList().filter(regexp).isEmpty();
            m_configurableApplications.insert(appRealName, configurable);
        }
    }
    notificationData.insert(QStringLiteral(""appRealName""), appRealName);
    notificationData.insert(QStringLiteral(""configurable""), configurable);

    QImage image;
    if (hints.contains(QStringLiteral(""image-data""))) {
        QDBusArgument arg = hints[QStringLiteral(""image-data"")].value<QDBusArgument>();
        image = decodeNotificationSpecImageHint(arg);
    } else if (hints.contains(QStringLiteral(""image_data""))) {
        QDBusArgument arg = hints[QStringLiteral(""image_data"")].value<QDBusArgument>();
        image = decodeNotificationSpecImageHint(arg);
    } else if (hints.contains(QStringLiteral(""image-path""))) {
        QString path = findImageForSpecImagePath(hints[QStringLiteral(""image-path"")].toString());
        if (!path.isEmpty()) {
            image.load(path);
        }
    } else if (hints.contains(QStringLiteral(""image_path""))) {
        QString path = findImageForSpecImagePath(hints[QStringLiteral(""image_path"")].toString());
        if (!path.isEmpty()) {
            image.load(path);
        }
    } else if (hints.contains(QStringLiteral(""icon_data""))) {
        QDBusArgument arg = hints[QStringLiteral(""icon_data"")].value<QDBusArgument>();
        image = decodeNotificationSpecImageHint(arg);
    }
    notificationData.insert(QStringLiteral(""image""), image.isNull() ? QVariant() : image);

    if (hints.contains(QStringLiteral(""urgency""))) {
        notificationData.insert(QStringLiteral(""urgency""), hints[QStringLiteral(""urgency"")].toInt());
    }

    setData(source, notificationData);

    m_activeNotifications.insert(source, app_name + summary);

    return id;
}
","uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,
                                 const QString &app_icon, const QString &summary, const QString &body,
                                 const QStringList &actions, const QVariantMap &hints, int timeout)
{
    uint partOf = 0;
    const QString appRealName = hints[QStringLiteral(""x-kde-appname"")].toString();
    const QString eventId = hints[QStringLiteral(""x-kde-eventId"")].toString();
    const bool skipGrouping = hints[QStringLiteral(""x-kde-skipGrouping"")].toBool();

    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {
        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();
    }

    qDebug() << ""Currrent active notifications:"" << m_activeNotifications;
    qDebug() << ""Guessing partOf as:"" << partOf;
    qDebug() << "" New Notification: "" << summary << body << timeout << ""& Part of:"" << partOf;
    QString _body;

    if (partOf > 0) {
        const QString source = QStringLiteral(""notification %1"").arg(partOf);
        Plasma::DataContainer *container = containerForSource(source);
        if (container) {
            _body = container->data()[QStringLiteral(""body"")].toString();
            if (_body != body) {
                _body.append(""\n"").append(body);
            } else {
                _body = body;
            }

            replaces_id = partOf;

            CloseNotification(partOf);
        }
    }

    uint id = replaces_id ? replaces_id : m_nextId++;

    if (m_alwaysReplaceAppsList.contains(app_name)) {
        if (m_notificationsFromReplaceableApp.contains(app_name)) {
            id = m_notificationsFromReplaceableApp.value(app_name);
        } else {
            m_notificationsFromReplaceableApp.insert(app_name, id);
        }
    }

    QString appname_str = app_name;
    if (appname_str.isEmpty()) {
        appname_str = i18n(""Unknown Application"");
    }

    bool isPersistent = timeout == 0;

    const int AVERAGE_WORD_LENGTH = 6;
    const int WORD_PER_MINUTE = 250;
    int count = summary.length() + body.length();

    if (timeout <= 0) {
        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;

        timeout = 2000 + qMax(timeout, 3000);
    }

    const QString source = QStringLiteral(""notification %1"").arg(id);
     const QString source = QStringLiteral(""notification %1"").arg(id);
 
     QString bodyFinal = (partOf == 0 ? body : _body);
    bodyFinal = bodyFinal.trimmed();
    bodyFinal = bodyFinal.replace(QLatin1String(""\n""), QLatin1String(""<br/>""));
    bodyFinal = bodyFinal.simplified();
    bodyFinal.replace(QRegularExpression(QStringLiteral(""<br/>\\s*<br/>(\\s|<br/>)*"")), QLatin1String(""<br/>""));
    bodyFinal.replace(QRegularExpression(QStringLiteral(""&(?!(?:apos|quot|[gl]t|amp);|#)"")), QLatin1String(""&amp;""));
    bodyFinal.replace(QLatin1String(""&apos;""), QChar('\''));
 
     Plasma::DataEngine::Data notificationData;
     notificationData.insert(QStringLiteral(""id""), QString::number(id));
    bodyFinal = bodyFinal.simplified();
    bodyFinal.replace(QRegularExpression(QStringLiteral(""<br/>\\s*<br/>(\\s|<br/>)*"")), QLatin1String(""<br/>""));
    bodyFinal.replace(QRegularExpression(QStringLiteral(""&(?!(?:apos|quot|[gl]t|amp);|#)"")), QLatin1String(""&amp;""));
    bodyFinal.replace(QLatin1String(""&apos;""), QChar('\''));

    Plasma::DataEngine::Data notificationData;
    notificationData.insert(QStringLiteral(""id""), QString::number(id));
    notificationData.insert(QStringLiteral(""eventId""), eventId);
    notificationData.insert(QStringLiteral(""appName""), appname_str);
    notificationData.insert(QStringLiteral(""appIcon""), app_icon);
    notificationData.insert(QStringLiteral(""summary""), summary);
    notificationData.insert(QStringLiteral(""body""), bodyFinal);
    notificationData.insert(QStringLiteral(""actions""), actions);
    notificationData.insert(QStringLiteral(""isPersistent""), isPersistent);
    notificationData.insert(QStringLiteral(""expireTimeout""), timeout);

    bool configurable = false;
    if (!appRealName.isEmpty()) {

        if (m_configurableApplications.contains(appRealName)) {
            configurable = m_configurableApplications.value(appRealName);
        } else {
            QScopedPointer<KConfig> config(new KConfig(appRealName + QStringLiteral("".notifyrc""), KConfig::NoGlobals));
            config->addConfigSources(QStandardPaths::locateAll(QStandardPaths::GenericDataLocation,
                                     QStringLiteral(""knotifications5/"") + appRealName + QStringLiteral("".notifyrc"")));

            const QRegularExpression regexp(QStringLiteral(""^Event/([^/]*)$""));
            configurable = !config->groupList().filter(regexp).isEmpty();
            m_configurableApplications.insert(appRealName, configurable);
        }
    }
    notificationData.insert(QStringLiteral(""appRealName""), appRealName);
    notificationData.insert(QStringLiteral(""configurable""), configurable);

    QImage image;
    if (hints.contains(QStringLiteral(""image-data""))) {
        QDBusArgument arg = hints[QStringLiteral(""image-data"")].value<QDBusArgument>();
        image = decodeNotificationSpecImageHint(arg);
    } else if (hints.contains(QStringLiteral(""image_data""))) {
        QDBusArgument arg = hints[QStringLiteral(""image_data"")].value<QDBusArgument>();
        image = decodeNotificationSpecImageHint(arg);
    } else if (hints.contains(QStringLiteral(""image-path""))) {
        QString path = findImageForSpecImagePath(hints[QStringLiteral(""image-path"")].toString());
        if (!path.isEmpty()) {
            image.load(path);
        }
    } else if (hints.contains(QStringLiteral(""image_path""))) {
        QString path = findImageForSpecImagePath(hints[QStringLiteral(""image_path"")].toString());
        if (!path.isEmpty()) {
            image.load(path);
        }
    } else if (hints.contains(QStringLiteral(""icon_data""))) {
        QDBusArgument arg = hints[QStringLiteral(""icon_data"")].value<QDBusArgument>();
        image = decodeNotificationSpecImageHint(arg);
    }
    notificationData.insert(QStringLiteral(""image""), image.isNull() ? QVariant() : image);

    if (hints.contains(QStringLiteral(""urgency""))) {
        notificationData.insert(QStringLiteral(""urgency""), hints[QStringLiteral(""urgency"")].toInt());
    }

    setData(source, notificationData);

    m_activeNotifications.insert(source, app_name + summary);

    return id;
}
",CPP,"    bodyFinal = NotificationSanitizer::parse(bodyFinal);
","    bodyFinal = bodyFinal.trimmed();
    bodyFinal = bodyFinal.replace(QLatin1String(""\n""), QLatin1String(""<br/>""));
    bodyFinal = bodyFinal.simplified();
    bodyFinal.replace(QRegularExpression(QStringLiteral(""<br/>\\s*<br/>(\\s|<br/>)*"")), QLatin1String(""<br/>""));
    bodyFinal.replace(QRegularExpression(QStringLiteral(""&(?!(?:apos|quot|[gl]t|amp);|#)"")), QLatin1String(""&amp;""));
    bodyFinal.replace(QLatin1String(""&apos;""), QChar('\''));
",265ab95965485f05e4c1d5ee832ea16ed5f9e96d,"@@ -20,6 +20,7 @@
 #include ""notificationsengine.h""
 #include ""notificationservice.h""
 #include ""notificationsadaptor.h""
+#include ""notificationsanitizer.h""
 
 #include <QDebug>
 #include <KConfigGroup>
@@ -261,23 +262,7 @@ uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,
     const QString source = QStringLiteral(""notification %1"").arg(id);
 
     QString bodyFinal = (partOf == 0 ? body : _body);
-    // First trim whitespace from beginning and end
-    bodyFinal = bodyFinal.trimmed();
-    // Now replace all \ns with <br/>
-    bodyFinal = bodyFinal.replace(QLatin1String(""\n""), QLatin1String(""<br/>""));
-    // Now remove all inner whitespace (\ns are already <br/>s
-    bodyFinal = bodyFinal.simplified();
-    // Finally, check if we don't have multiple <br/>s following,
-    // can happen for example when ""\n       \n"" is sent, this replaces
-    // all <br/>s in succsession with just one
-    bodyFinal.replace(QRegularExpression(QStringLiteral(""<br/>\\s*<br/>(\\s|<br/>)*"")), QLatin1String(""<br/>""));
-    // This fancy RegExp escapes every occurence of & since QtQuick Text will blatantly cut off
-    // text where it finds a stray ampersand.
-    // Only &{apos, quot, gt, lt, amp}; as well as &#123 character references will be allowed
-    bodyFinal.replace(QRegularExpression(QStringLiteral(""&(?!(?:apos|quot|[gl]t|amp);|#)"")), QLatin1String(""&amp;""));
-    // The Text.StyledText format handles only html3.2 stuff and &apos; is html4 stuff
-    // so we need to replace it here otherwise it will not render at all.
-    bodyFinal.replace(QLatin1String(""&apos;""), QChar('\''));
+    bodyFinal = NotificationSanitizer::parse(bodyFinal);
 
     Plasma::DataEngine::Data notificationData;
     notificationData.insert(QStringLiteral(""id""), QString::number(id));",kde,https://cgit.kde.org/plasma-workspace.git/tree/dataengines/notifications/notificationsengine.cpp?id=5bc696b5abcdb460c1017592e80b2d7f6ed3107c,https://cgit.kde.org/plasma-workspace.git/tree/dataengines/notifications/notificationsengine.cpp?id=265ab95965485f05e4c1d5ee832ea16ed5f9e96d,1,"uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,
                                 const QString &app_icon, const QString &summary, const QString &body,
                                 const QStringList &actions, const QVariantMap &hints, int timeout)
{
    uint partOf = 0;
    const QString appRealName = hints[QStringLiteral(""x-kde-appname"")].toString();
    const QString eventId = hints[QStringLiteral(""x-kde-eventId"")].toString();
    const bool skipGrouping = hints[QStringLiteral(""x-kde-skipGrouping"")].toBool();

    // group notifications that have the same title coming from the same app
    // or if they are on the ""blacklist"", honor the skipGrouping hint sent
    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {
        // cut off the ""notification "" from the source name
        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();
    }

    qDebug() << ""Currrent active notifications:"" << m_activeNotifications;
    qDebug() << ""Guessing partOf as:"" << partOf;
    qDebug() << "" New Notification: "" << summary << body << timeout << ""& Part of:"" << partOf;
    QString _body;

    if (partOf > 0) {
        const QString source = QStringLiteral(""notification %1"").arg(partOf);
        Plasma::DataContainer *container = containerForSource(source);
        if (container) {
            // append the body text
            _body = container->data()[QStringLiteral(""body"")].toString();
            if (_body != body) {
                _body.append(""\n"").append(body);
            } else {
                _body = body;
            }

            replaces_id = partOf;

            // remove the old notification and replace it with the new one
            // TODO: maybe just update the current notification?
            CloseNotification(partOf);
        }
    }

    uint id = replaces_id ? replaces_id : m_nextId++;

    // If the current app is in the ""blacklist""...
    if (m_alwaysReplaceAppsList.contains(app_name)) {
        // ...check if we already have a notification from that particular
        // app and if yes, use its id to replace it
        if (m_notificationsFromReplaceableApp.contains(app_name)) {
            id = m_notificationsFromReplaceableApp.value(app_name);
        } else {
            m_notificationsFromReplaceableApp.insert(app_name, id);
        }
    }

    QString appname_str = app_name;
    if (appname_str.isEmpty()) {
        appname_str = i18n(""Unknown Application"");
    }

    bool isPersistent = timeout == 0;

    const int AVERAGE_WORD_LENGTH = 6;
    const int WORD_PER_MINUTE = 250;
    int count = summary.length() + body.length();

    // -1 is ""server default"", 0 is persistent with ""server default"" display time,
    // anything more should honor the setting
    if (timeout <= 0) {
        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;

        // Add two seconds for the user to notice the notification, and ensure
        // it last at least five seconds, otherwise all the user see is a
        // flash
        timeout = 2000 + qMax(timeout, 3000);
    }

    const QString source = QStringLiteral(""notification %1"").arg(id);
     const QString source = QStringLiteral(""notification %1"").arg(id);
 
     QString bodyFinal = (partOf == 0 ? body : _body);
//flaw_line_below:
    // First trim whitespace from beginning and end
//flaw_line_below:
    bodyFinal = bodyFinal.trimmed();
//flaw_line_below:
    // Now replace all \ns with <br/>
//flaw_line_below:
    bodyFinal = bodyFinal.replace(QLatin1String(""\n""), QLatin1String(""<br/>""));
//flaw_line_below:
    // Now remove all inner whitespace (\ns are already <br/>s
//flaw_line_below:
    bodyFinal = bodyFinal.simplified();
//flaw_line_below:
    // Finally, check if we don't have multiple <br/>s following,
//flaw_line_below:
    // can happen for example when ""\n       \n"" is sent, this replaces
//flaw_line_below:
    // all <br/>s in succsession with just one
//flaw_line_below:
    bodyFinal.replace(QRegularExpression(QStringLiteral(""<br/>\\s*<br/>(\\s|<br/>)*"")), QLatin1String(""<br/>""));
//flaw_line_below:
    // This fancy RegExp escapes every occurence of & since QtQuick Text will blatantly cut off
//flaw_line_below:
    // text where it finds a stray ampersand.
//flaw_line_below:
    // Only &{apos, quot, gt, lt, amp}; as well as &#123 character references will be allowed
//flaw_line_below:
    bodyFinal.replace(QRegularExpression(QStringLiteral(""&(?!(?:apos|quot|[gl]t|amp);|#)"")), QLatin1String(""&amp;""));
//flaw_line_below:
    // The Text.StyledText format handles only html3.2 stuff and &apos; is html4 stuff
//flaw_line_below:
    // so we need to replace it here otherwise it will not render at all.
//flaw_line_below:
    bodyFinal.replace(QLatin1String(""&apos;""), QChar('\''));
//fix_flaw_line_below:
//    bodyFinal = NotificationSanitizer::parse(bodyFinal);
 
     Plasma::DataEngine::Data notificationData;
     notificationData.insert(QStringLiteral(""id""), QString::number(id));
    bodyFinal = bodyFinal.simplified();
    // Finally, check if we don't have multiple <br/>s following,
    // can happen for example when ""\n       \n"" is sent, this replaces
    // all <br/>s in succsession with just one
    bodyFinal.replace(QRegularExpression(QStringLiteral(""<br/>\\s*<br/>(\\s|<br/>)*"")), QLatin1String(""<br/>""));
    // This fancy RegExp escapes every occurence of & since QtQuick Text will blatantly cut off
    // text where it finds a stray ampersand.
    // Only &{apos, quot, gt, lt, amp}; as well as &#123 character references will be allowed
    bodyFinal.replace(QRegularExpression(QStringLiteral(""&(?!(?:apos|quot|[gl]t|amp);|#)"")), QLatin1String(""&amp;""));
    // The Text.StyledText format handles only html3.2 stuff and &apos; is html4 stuff
    // so we need to replace it here otherwise it will not render at all.
    bodyFinal.replace(QLatin1String(""&apos;""), QChar('\''));

    Plasma::DataEngine::Data notificationData;
    notificationData.insert(QStringLiteral(""id""), QString::number(id));
    notificationData.insert(QStringLiteral(""eventId""), eventId);
    notificationData.insert(QStringLiteral(""appName""), appname_str);
    notificationData.insert(QStringLiteral(""appIcon""), app_icon);
    notificationData.insert(QStringLiteral(""summary""), summary);
    notificationData.insert(QStringLiteral(""body""), bodyFinal);
    notificationData.insert(QStringLiteral(""actions""), actions);
    notificationData.insert(QStringLiteral(""isPersistent""), isPersistent);
    notificationData.insert(QStringLiteral(""expireTimeout""), timeout);

    bool configurable = false;
    if (!appRealName.isEmpty()) {

        if (m_configurableApplications.contains(appRealName)) {
            configurable = m_configurableApplications.value(appRealName);
        } else {
            // Check whether the application actually has notifications we can configure
            QScopedPointer<KConfig> config(new KConfig(appRealName + QStringLiteral("".notifyrc""), KConfig::NoGlobals));
            config->addConfigSources(QStandardPaths::locateAll(QStandardPaths::GenericDataLocation,
                                     QStringLiteral(""knotifications5/"") + appRealName + QStringLiteral("".notifyrc"")));

            const QRegularExpression regexp(QStringLiteral(""^Event/([^/]*)$""));
            configurable = !config->groupList().filter(regexp).isEmpty();
            m_configurableApplications.insert(appRealName, configurable);
        }
    }
    notificationData.insert(QStringLiteral(""appRealName""), appRealName);
    notificationData.insert(QStringLiteral(""configurable""), configurable);

    QImage image;
    // Underscored hints was in use in version 1.1 of the spec but has been
    // replaced by dashed hints in version 1.2. We need to support it for
    // users of the 1.2 version of the spec.
    if (hints.contains(QStringLiteral(""image-data""))) {
        QDBusArgument arg = hints[QStringLiteral(""image-data"")].value<QDBusArgument>();
        image = decodeNotificationSpecImageHint(arg);
    } else if (hints.contains(QStringLiteral(""image_data""))) {
        QDBusArgument arg = hints[QStringLiteral(""image_data"")].value<QDBusArgument>();
        image = decodeNotificationSpecImageHint(arg);
    } else if (hints.contains(QStringLiteral(""image-path""))) {
        QString path = findImageForSpecImagePath(hints[QStringLiteral(""image-path"")].toString());
        if (!path.isEmpty()) {
            image.load(path);
        }
    } else if (hints.contains(QStringLiteral(""image_path""))) {
        QString path = findImageForSpecImagePath(hints[QStringLiteral(""image_path"")].toString());
        if (!path.isEmpty()) {
            image.load(path);
        }
    } else if (hints.contains(QStringLiteral(""icon_data""))) {
        // This hint was in use in version 1.0 of the spec but has been
        // replaced by ""image_data"" in version 1.1. We need to support it for
        // users of the 1.0 version of the spec.
        QDBusArgument arg = hints[QStringLiteral(""icon_data"")].value<QDBusArgument>();
        image = decodeNotificationSpecImageHint(arg);
    }
    notificationData.insert(QStringLiteral(""image""), image.isNull() ? QVariant() : image);

    if (hints.contains(QStringLiteral(""urgency""))) {
        notificationData.insert(QStringLiteral(""urgency""), hints[QStringLiteral(""urgency"")].toInt());
    }

    setData(source, notificationData);

    m_activeNotifications.insert(source, app_name + summary);

    return id;
}
",178198,"uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,
                                 const QString &app_icon, const QString &summary, const QString &body,
                                 const QStringList &actions, const QVariantMap &hints, int timeout)
{
    uint partOf = 0;
    const QString appRealName = hints[QStringLiteral(""x-kde-appname"")].toString();
    const QString eventId = hints[QStringLiteral(""x-kde-eventId"")].toString();
    const bool skipGrouping = hints[QStringLiteral(""x-kde-skipGrouping"")].toBool();

    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {
        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();
    }

    qDebug() << ""Currrent active notifications:"" << m_activeNotifications;
    qDebug() << ""Guessing partOf as:"" << partOf;
    qDebug() << "" New Notification: "" << summary << body << timeout << ""& Part of:"" << partOf;
    QString _body;

    if (partOf > 0) {
        const QString source = QStringLiteral(""notification %1"").arg(partOf);
        Plasma::DataContainer *container = containerForSource(source);
        if (container) {
            _body = container->data()[QStringLiteral(""body"")].toString();
            if (_body != body) {
                _body.append(""\n"").append(body);
            } else {
                _body = body;
            }

            replaces_id = partOf;

            CloseNotification(partOf);
        }
    }

    uint id = replaces_id ? replaces_id : m_nextId++;

    if (m_alwaysReplaceAppsList.contains(app_name)) {
        if (m_notificationsFromReplaceableApp.contains(app_name)) {
            id = m_notificationsFromReplaceableApp.value(app_name);
        } else {
            m_notificationsFromReplaceableApp.insert(app_name, id);
        }
    }

    QString appname_str = app_name;
    if (appname_str.isEmpty()) {
        appname_str = i18n(""Unknown Application"");
    }

    bool isPersistent = timeout == 0;

    const int AVERAGE_WORD_LENGTH = 6;
    const int WORD_PER_MINUTE = 250;
    int count = summary.length() + body.length();

    if (timeout <= 0) {
        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;

        timeout = 2000 + qMax(timeout, 3000);
    }

    const QString source = QStringLiteral(""notification %1"").arg(id);
     const QString source = QStringLiteral(""notification %1"").arg(id);
 
     QString bodyFinal = (partOf == 0 ? body : _body);
    bodyFinal = bodyFinal.trimmed();
    bodyFinal = bodyFinal.replace(QLatin1String(""\n""), QLatin1String(""<br/>""));
    bodyFinal = bodyFinal.simplified();
    bodyFinal.replace(QRegularExpression(QStringLiteral(""<br/>\\s*<br/>(\\s|<br/>)*"")), QLatin1String(""<br/>""));
    bodyFinal.replace(QRegularExpression(QStringLiteral(""&(?!(?:apos|quot|[gl]t|amp);|#)"")), QLatin1String(""&amp;""));
    bodyFinal.replace(QLatin1String(""&apos;""), QChar('\''));
 
     Plasma::DataEngine::Data notificationData;
     notificationData.insert(QStringLiteral(""id""), QString::number(id));
    bodyFinal = bodyFinal.simplified();
    bodyFinal.replace(QRegularExpression(QStringLiteral(""<br/>\\s*<br/>(\\s|<br/>)*"")), QLatin1String(""<br/>""));
    bodyFinal.replace(QRegularExpression(QStringLiteral(""&(?!(?:apos|quot|[gl]t|amp);|#)"")), QLatin1String(""&amp;""));
    bodyFinal.replace(QLatin1String(""&apos;""), QChar('\''));

    Plasma::DataEngine::Data notificationData;
    notificationData.insert(QStringLiteral(""id""), QString::number(id));
    notificationData.insert(QStringLiteral(""eventId""), eventId);
    notificationData.insert(QStringLiteral(""appName""), appname_str);
    notificationData.insert(QStringLiteral(""appIcon""), app_icon);
    notificationData.insert(QStringLiteral(""summary""), summary);
    notificationData.insert(QStringLiteral(""body""), bodyFinal);
    notificationData.insert(QStringLiteral(""actions""), actions);
    notificationData.insert(QStringLiteral(""isPersistent""), isPersistent);
    notificationData.insert(QStringLiteral(""expireTimeout""), timeout);

    bool configurable = false;
    if (!appRealName.isEmpty()) {

        if (m_configurableApplications.contains(appRealName)) {
            configurable = m_configurableApplications.value(appRealName);
        } else {
            QScopedPointer<KConfig> config(new KConfig(appRealName + QStringLiteral("".notifyrc""), KConfig::NoGlobals));
            config->addConfigSources(QStandardPaths::locateAll(QStandardPaths::GenericDataLocation,
                                     QStringLiteral(""knotifications5/"") + appRealName + QStringLiteral("".notifyrc"")));

            const QRegularExpression regexp(QStringLiteral(""^Event/([^/]*)$""));
            configurable = !config->groupList().filter(regexp).isEmpty();
            m_configurableApplications.insert(appRealName, configurable);
        }
    }
    notificationData.insert(QStringLiteral(""appRealName""), appRealName);
    notificationData.insert(QStringLiteral(""configurable""), configurable);

    QImage image;
    if (hints.contains(QStringLiteral(""image-data""))) {
        QDBusArgument arg = hints[QStringLiteral(""image-data"")].value<QDBusArgument>();
        image = decodeNotificationSpecImageHint(arg);
    } else if (hints.contains(QStringLiteral(""image_data""))) {
        QDBusArgument arg = hints[QStringLiteral(""image_data"")].value<QDBusArgument>();
        image = decodeNotificationSpecImageHint(arg);
    } else if (hints.contains(QStringLiteral(""image-path""))) {
        QString path = findImageForSpecImagePath(hints[QStringLiteral(""image-path"")].toString());
        if (!path.isEmpty()) {
            image.load(path);
        }
    } else if (hints.contains(QStringLiteral(""image_path""))) {
        QString path = findImageForSpecImagePath(hints[QStringLiteral(""image_path"")].toString());
        if (!path.isEmpty()) {
            image.load(path);
        }
    } else if (hints.contains(QStringLiteral(""icon_data""))) {
        QDBusArgument arg = hints[QStringLiteral(""icon_data"")].value<QDBusArgument>();
        image = decodeNotificationSpecImageHint(arg);
    }
    notificationData.insert(QStringLiteral(""image""), image.isNull() ? QVariant() : image);

    if (hints.contains(QStringLiteral(""urgency""))) {
        notificationData.insert(QStringLiteral(""urgency""), hints[QStringLiteral(""urgency"")].toInt());
    }

    setData(source, notificationData);

    m_activeNotifications.insert(source, app_name + summary);

    return id;
}
","uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,
                                 const QString &app_icon, const QString &summary, const QString &body,
                                 const QStringList &actions, const QVariantMap &hints, int timeout)
{
    uint partOf = 0;
    const QString appRealName = hints[QStringLiteral(""x-kde-appname"")].toString();
    const QString eventId = hints[QStringLiteral(""x-kde-eventId"")].toString();
    const bool skipGrouping = hints[QStringLiteral(""x-kde-skipGrouping"")].toBool();

    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {
        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();
    }

    qDebug() << ""Currrent active notifications:"" << m_activeNotifications;
    qDebug() << ""Guessing partOf as:"" << partOf;
    qDebug() << "" New Notification: "" << summary << body << timeout << ""& Part of:"" << partOf;
    QString _body;

    if (partOf > 0) {
        const QString source = QStringLiteral(""notification %1"").arg(partOf);
        Plasma::DataContainer *container = containerForSource(source);
        if (container) {
            _body = container->data()[QStringLiteral(""body"")].toString();
            if (_body != body) {
                _body.append(""\n"").append(body);
            } else {
                _body = body;
            }

            replaces_id = partOf;

            CloseNotification(partOf);
        }
    }

    uint id = replaces_id ? replaces_id : m_nextId++;

    if (m_alwaysReplaceAppsList.contains(app_name)) {
        if (m_notificationsFromReplaceableApp.contains(app_name)) {
            id = m_notificationsFromReplaceableApp.value(app_name);
        } else {
            m_notificationsFromReplaceableApp.insert(app_name, id);
        }
    }

    QString appname_str = app_name;
    if (appname_str.isEmpty()) {
        appname_str = i18n(""Unknown Application"");
    }

    bool isPersistent = timeout == 0;

    const int AVERAGE_WORD_LENGTH = 6;
    const int WORD_PER_MINUTE = 250;
    int count = summary.length() + body.length();

    if (timeout <= 0) {
        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;

        timeout = 2000 + qMax(timeout, 3000);
    }

    const QString source = QStringLiteral(""notification %1"").arg(id);
     const QString source = QStringLiteral(""notification %1"").arg(id);
 
     QString bodyFinal = (partOf == 0 ? body : _body);
    bodyFinal = NotificationSanitizer::parse(bodyFinal);
 
     Plasma::DataEngine::Data notificationData;
     notificationData.insert(QStringLiteral(""id""), QString::number(id));
    bodyFinal = bodyFinal.simplified();
    bodyFinal.replace(QRegularExpression(QStringLiteral(""<br/>\\s*<br/>(\\s|<br/>)*"")), QLatin1String(""<br/>""));
    bodyFinal.replace(QRegularExpression(QStringLiteral(""&(?!(?:apos|quot|[gl]t|amp);|#)"")), QLatin1String(""&amp;""));
    bodyFinal.replace(QLatin1String(""&apos;""), QChar('\''));

    Plasma::DataEngine::Data notificationData;
    notificationData.insert(QStringLiteral(""id""), QString::number(id));
    notificationData.insert(QStringLiteral(""eventId""), eventId);
    notificationData.insert(QStringLiteral(""appName""), appname_str);
    notificationData.insert(QStringLiteral(""appIcon""), app_icon);
    notificationData.insert(QStringLiteral(""summary""), summary);
    notificationData.insert(QStringLiteral(""body""), bodyFinal);
    notificationData.insert(QStringLiteral(""actions""), actions);
    notificationData.insert(QStringLiteral(""isPersistent""), isPersistent);
    notificationData.insert(QStringLiteral(""expireTimeout""), timeout);

    bool configurable = false;
    if (!appRealName.isEmpty()) {

        if (m_configurableApplications.contains(appRealName)) {
            configurable = m_configurableApplications.value(appRealName);
        } else {
            QScopedPointer<KConfig> config(new KConfig(appRealName + QStringLiteral("".notifyrc""), KConfig::NoGlobals));
            config->addConfigSources(QStandardPaths::locateAll(QStandardPaths::GenericDataLocation,
                                     QStringLiteral(""knotifications5/"") + appRealName + QStringLiteral("".notifyrc"")));

            const QRegularExpression regexp(QStringLiteral(""^Event/([^/]*)$""));
            configurable = !config->groupList().filter(regexp).isEmpty();
            m_configurableApplications.insert(appRealName, configurable);
        }
    }
    notificationData.insert(QStringLiteral(""appRealName""), appRealName);
    notificationData.insert(QStringLiteral(""configurable""), configurable);

    QImage image;
    if (hints.contains(QStringLiteral(""image-data""))) {
        QDBusArgument arg = hints[QStringLiteral(""image-data"")].value<QDBusArgument>();
        image = decodeNotificationSpecImageHint(arg);
    } else if (hints.contains(QStringLiteral(""image_data""))) {
        QDBusArgument arg = hints[QStringLiteral(""image_data"")].value<QDBusArgument>();
        image = decodeNotificationSpecImageHint(arg);
    } else if (hints.contains(QStringLiteral(""image-path""))) {
        QString path = findImageForSpecImagePath(hints[QStringLiteral(""image-path"")].toString());
        if (!path.isEmpty()) {
            image.load(path);
        }
    } else if (hints.contains(QStringLiteral(""image_path""))) {
        QString path = findImageForSpecImagePath(hints[QStringLiteral(""image_path"")].toString());
        if (!path.isEmpty()) {
            image.load(path);
        }
    } else if (hints.contains(QStringLiteral(""icon_data""))) {
        QDBusArgument arg = hints[QStringLiteral(""icon_data"")].value<QDBusArgument>();
        image = decodeNotificationSpecImageHint(arg);
    }
    notificationData.insert(QStringLiteral(""image""), image.isNull() ? QVariant() : image);

    if (hints.contains(QStringLiteral(""urgency""))) {
        notificationData.insert(QStringLiteral(""urgency""), hints[QStringLiteral(""urgency"")].toInt());
    }

    setData(source, notificationData);

    m_activeNotifications.insert(source, app_name + summary);

    return id;
}
","The `Notify` function in the `NotificationsEngine` class is responsible for creating and managing notifications for applications. It takes parameters such as the application name, icon, summary, body, actions, hints, and timeout. The function checks if a notification should replace an existing one or be grouped with it, updates the notification body if necessary, and calculates the timeout based on the content length. It constructs a `notificationData` object containing relevant details, including the notification ID, application information, and any associated images. Finally, it stores the notification data and updates the active notifications list, returning the notification ID.","The provided code defines a function that manages the creation and updating of notifications for applications. It determines whether to replace an existing notification or group it with a new one based on specific conditions. The function constructs a detailed notification object, including the application name, icon, summary, body, actions, and timeout, while also handling potential image data. It calculates the timeout dynamically based on the content length and ensures proper formatting of the notification body. Finally, it stores the notification data and updates the list of active notifications, returning a unique identifier for the notification.","The vulnerability in the original code stemmed from insufficient sanitization of the notification body, which could allow for the injection of malicious content, potentially leading to security issues such as cross-site scripting. Specifically, the body was directly manipulated without proper validation or encoding. The fix introduced a call to `NotificationSanitizer::parse(bodyFinal)`, which ensures that the notification body is sanitized before being processed further. This change mitigates the risk of harmful content being executed or displayed, thereby enhancing the overall security of the notification handling process.","The vulnerability in the original code was due to inadequate sanitization of user-generated content, which could allow for the injection of malicious scripts or HTML, posing a risk of cross-site scripting attacks. This lack of validation meant that potentially harmful content could be displayed in notifications, compromising user security. The fix involved implementing a sanitization process that cleanses the notification content before it is processed or displayed. This change ensures that any harmful elements are removed, thereby preventing the execution of malicious code and enhancing the overall security of the notification system.","The vulnerability was fixed by introducing a call to `NotificationSanitizer::parse(bodyFinal)`, which sanitizes the notification body before further processing. This function ensures that any potentially harmful content, such as scripts or untrusted HTML, is removed or encoded, thus preventing cross-site scripting attacks. By sanitizing the `bodyFinal` variable, the code mitigates the risk of displaying malicious content in notifications. This change enhances the security of the notification system by ensuring that only safe, validated content is presented to the user, thereby protecting against exploitation.","The vulnerability was fixed by implementing a sanitization process that cleanses the notification content before it is processed or displayed. This process ensures that any potentially harmful elements, such as scripts or untrusted HTML, are removed or properly encoded, thereby preventing the risk of cross-site scripting attacks. By validating the content, the code now guarantees that only safe and trusted information is presented to the user in notifications. This enhancement significantly improves the security of the notification system, protecting users from potential exploitation through malicious content.","4,4","4, 4","4, 4","5,4"
20,20,178248,178248,,Local,Not required,,CVE-2016-4020,https://www.cvedetails.com/cve/CVE-2016-4020/,CWE-200,Low,Partial,,,2016-05-25,2.1,"The patch_instruction function in hw/i386/kvmvapic.c in QEMU does not initialize the imm32 variable, which allows local guest OS administrators to obtain sensitive information from host stack memory by accessing the Task Priority Register (TPR).",2018-12-01,+Info,1,https://git.qemu.org/?p=qemu.git;a=commit;h=691a02e2ce0c413236a78dee6f2651c937b09fb0,691a02e2ce0c413236a78dee6f2651c937b09fb0,,1,,,"static void patch_instruction(VAPICROMState *s, X86CPU *cpu, target_ulong ip)
{
    CPUState *cs = CPU(cpu);
     CPUX86State *env = &cpu->env;
     VAPICHandlers *handlers;
     uint8_t opcode[2];
    uint32_t imm32 = 0;
     target_ulong current_pc = 0;
     target_ulong current_cs_base = 0;
     uint32_t current_flags = 0;

    if (smp_cpus == 1) {
        handlers = &s->rom_state.up;
    } else {
        handlers = &s->rom_state.mp;
    }

    if (!kvm_enabled()) {
        cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,
                             &current_flags);
    }

    pause_all_vcpus();

    cpu_memory_rw_debug(cs, ip, opcode, sizeof(opcode), 0);

    switch (opcode[0]) {
    case 0x89: /* mov r32 to r/m32 */
        patch_byte(cpu, ip, 0x50 + modrm_reg(opcode[1]));  /* push reg */
        patch_call(s, cpu, ip + 1, handlers->set_tpr);
        break;
    case 0x8b: /* mov r/m32 to r32 */
        patch_byte(cpu, ip, 0x90);
        patch_call(s, cpu, ip + 1, handlers->get_tpr[modrm_reg(opcode[1])]);
        break;
    case 0xa1: /* mov abs to eax */
        patch_call(s, cpu, ip, handlers->get_tpr[0]);
        break;
    case 0xa3: /* mov eax to abs */
        patch_call(s, cpu, ip, handlers->set_tpr_eax);
        break;
    case 0xc7: /* mov imm32, r/m32 (c7/0) */
        patch_byte(cpu, ip, 0x68);  /* push imm32 */
        cpu_memory_rw_debug(cs, ip + 6, (void *)&imm32, sizeof(imm32), 0);
        cpu_memory_rw_debug(cs, ip + 1, (void *)&imm32, sizeof(imm32), 1);
        patch_call(s, cpu, ip + 5, handlers->set_tpr);
        break;
    case 0xff: /* push r/m32 */
        patch_byte(cpu, ip, 0x50); /* push eax */
        patch_call(s, cpu, ip + 1, handlers->get_tpr_stack);
        break;
    default:
        abort();
    }

    resume_all_vcpus();

    if (!kvm_enabled()) {
        tb_gen_code(cs, current_pc, current_cs_base, current_flags, 1);
        cpu_resume_from_signal(cs, NULL);
    }
}
","static void patch_instruction(VAPICROMState *s, X86CPU *cpu, target_ulong ip)
{
    CPUState *cs = CPU(cpu);
     CPUX86State *env = &cpu->env;
     VAPICHandlers *handlers;
     uint8_t opcode[2];
    uint32_t imm32;
     target_ulong current_pc = 0;
     target_ulong current_cs_base = 0;
     uint32_t current_flags = 0;

    if (smp_cpus == 1) {
        handlers = &s->rom_state.up;
    } else {
        handlers = &s->rom_state.mp;
    }

    if (!kvm_enabled()) {
        cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,
                             &current_flags);
    }

    pause_all_vcpus();

    cpu_memory_rw_debug(cs, ip, opcode, sizeof(opcode), 0);

    switch (opcode[0]) {
    case 0x89: /* mov r32 to r/m32 */
        patch_byte(cpu, ip, 0x50 + modrm_reg(opcode[1]));  /* push reg */
        patch_call(s, cpu, ip + 1, handlers->set_tpr);
        break;
    case 0x8b: /* mov r/m32 to r32 */
        patch_byte(cpu, ip, 0x90);
        patch_call(s, cpu, ip + 1, handlers->get_tpr[modrm_reg(opcode[1])]);
        break;
    case 0xa1: /* mov abs to eax */
        patch_call(s, cpu, ip, handlers->get_tpr[0]);
        break;
    case 0xa3: /* mov eax to abs */
        patch_call(s, cpu, ip, handlers->set_tpr_eax);
        break;
    case 0xc7: /* mov imm32, r/m32 (c7/0) */
        patch_byte(cpu, ip, 0x68);  /* push imm32 */
        cpu_memory_rw_debug(cs, ip + 6, (void *)&imm32, sizeof(imm32), 0);
        cpu_memory_rw_debug(cs, ip + 1, (void *)&imm32, sizeof(imm32), 1);
        patch_call(s, cpu, ip + 5, handlers->set_tpr);
        break;
    case 0xff: /* push r/m32 */
        patch_byte(cpu, ip, 0x50); /* push eax */
        patch_call(s, cpu, ip + 1, handlers->get_tpr_stack);
        break;
    default:
        abort();
    }

    resume_all_vcpus();

    if (!kvm_enabled()) {
        tb_gen_code(cs, current_pc, current_cs_base, current_flags, 1);
        cpu_resume_from_signal(cs, NULL);
    }
}
",C,"    uint32_t imm32 = 0;
","    uint32_t imm32;
",dfc007f7f7aab982a8c22cbcb783d72b0db99705,"@@ -397,7 +397,7 @@ static void patch_instruction(VAPICROMState *s, X86CPU *cpu, target_ulong ip)
     CPUX86State *env = &cpu->env;
     VAPICHandlers *handlers;
     uint8_t opcode[2];
-    uint32_t imm32;
+    uint32_t imm32 = 0;
     target_ulong current_pc = 0;
     target_ulong current_cs_base = 0;
     uint32_t current_flags = 0;",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/i386/kvmvapic.c;h=5b71b1ba46676398109283942b3bd3d557b75e27;hb=691a02e2ce0c413236a78dee6f2651c937b09fb0,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/i386/kvmvapic.c;h=8fd27ba2f40434b9ad5698b46126414b38ffa234,1,"static void patch_instruction(VAPICROMState *s, X86CPU *cpu, target_ulong ip)
{
    CPUState *cs = CPU(cpu);
     CPUX86State *env = &cpu->env;
     VAPICHandlers *handlers;
     uint8_t opcode[2];
//flaw_line_below:
    uint32_t imm32;
//fix_flaw_line_below:
//    uint32_t imm32 = 0;
     target_ulong current_pc = 0;
     target_ulong current_cs_base = 0;
     uint32_t current_flags = 0;

    if (smp_cpus == 1) {
        handlers = &s->rom_state.up;
    } else {
        handlers = &s->rom_state.mp;
    }

    if (!kvm_enabled()) {
        cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,
                             &current_flags);
    }

    pause_all_vcpus();

    cpu_memory_rw_debug(cs, ip, opcode, sizeof(opcode), 0);

    switch (opcode[0]) {
    case 0x89: /* mov r32 to r/m32 */
        patch_byte(cpu, ip, 0x50 + modrm_reg(opcode[1]));  /* push reg */
        patch_call(s, cpu, ip + 1, handlers->set_tpr);
        break;
    case 0x8b: /* mov r/m32 to r32 */
        patch_byte(cpu, ip, 0x90);
        patch_call(s, cpu, ip + 1, handlers->get_tpr[modrm_reg(opcode[1])]);
        break;
    case 0xa1: /* mov abs to eax */
        patch_call(s, cpu, ip, handlers->get_tpr[0]);
        break;
    case 0xa3: /* mov eax to abs */
        patch_call(s, cpu, ip, handlers->set_tpr_eax);
        break;
    case 0xc7: /* mov imm32, r/m32 (c7/0) */
        patch_byte(cpu, ip, 0x68);  /* push imm32 */
        cpu_memory_rw_debug(cs, ip + 6, (void *)&imm32, sizeof(imm32), 0);
        cpu_memory_rw_debug(cs, ip + 1, (void *)&imm32, sizeof(imm32), 1);
        patch_call(s, cpu, ip + 5, handlers->set_tpr);
        break;
    case 0xff: /* push r/m32 */
        patch_byte(cpu, ip, 0x50); /* push eax */
        patch_call(s, cpu, ip + 1, handlers->get_tpr_stack);
        break;
    default:
        abort();
    }

    resume_all_vcpus();

    if (!kvm_enabled()) {
        tb_gen_code(cs, current_pc, current_cs_base, current_flags, 1);
        cpu_resume_from_signal(cs, NULL);
    }
}
",178248,"static void patch_instruction(VAPICROMState *s, X86CPU *cpu, target_ulong ip)
{
    CPUState *cs = CPU(cpu);
     CPUX86State *env = &cpu->env;
     VAPICHandlers *handlers;
     uint8_t opcode[2];
    uint32_t imm32;
     target_ulong current_pc = 0;
     target_ulong current_cs_base = 0;
     uint32_t current_flags = 0;

    if (smp_cpus == 1) {
        handlers = &s->rom_state.up;
    } else {
        handlers = &s->rom_state.mp;
    }

    if (!kvm_enabled()) {
        cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,
                             &current_flags);
    }

    pause_all_vcpus();

    cpu_memory_rw_debug(cs, ip, opcode, sizeof(opcode), 0);

    switch (opcode[0]) {
    case 0x89: /* mov r32 to r/m32 */
        patch_byte(cpu, ip, 0x50 + modrm_reg(opcode[1]));  /* push reg */
        patch_call(s, cpu, ip + 1, handlers->set_tpr);
        break;
    case 0x8b: /* mov r/m32 to r32 */
        patch_byte(cpu, ip, 0x90);
        patch_call(s, cpu, ip + 1, handlers->get_tpr[modrm_reg(opcode[1])]);
        break;
    case 0xa1: /* mov abs to eax */
        patch_call(s, cpu, ip, handlers->get_tpr[0]);
        break;
    case 0xa3: /* mov eax to abs */
        patch_call(s, cpu, ip, handlers->set_tpr_eax);
        break;
    case 0xc7: /* mov imm32, r/m32 (c7/0) */
        patch_byte(cpu, ip, 0x68);  /* push imm32 */
        cpu_memory_rw_debug(cs, ip + 6, (void *)&imm32, sizeof(imm32), 0);
        cpu_memory_rw_debug(cs, ip + 1, (void *)&imm32, sizeof(imm32), 1);
        patch_call(s, cpu, ip + 5, handlers->set_tpr);
        break;
    case 0xff: /* push r/m32 */
        patch_byte(cpu, ip, 0x50); /* push eax */
        patch_call(s, cpu, ip + 1, handlers->get_tpr_stack);
        break;
    default:
        abort();
    }

    resume_all_vcpus();

    if (!kvm_enabled()) {
        tb_gen_code(cs, current_pc, current_cs_base, current_flags, 1);
        cpu_resume_from_signal(cs, NULL);
    }
}
","static void patch_instruction(VAPICROMState *s, X86CPU *cpu, target_ulong ip)
{
    CPUState *cs = CPU(cpu);
     CPUX86State *env = &cpu->env;
     VAPICHandlers *handlers;
     uint8_t opcode[2];
    uint32_t imm32 = 0;
     target_ulong current_pc = 0;
     target_ulong current_cs_base = 0;
     uint32_t current_flags = 0;

    if (smp_cpus == 1) {
        handlers = &s->rom_state.up;
    } else {
        handlers = &s->rom_state.mp;
    }

    if (!kvm_enabled()) {
        cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,
                             &current_flags);
    }

    pause_all_vcpus();

    cpu_memory_rw_debug(cs, ip, opcode, sizeof(opcode), 0);

    switch (opcode[0]) {
    case 0x89: /* mov r32 to r/m32 */
        patch_byte(cpu, ip, 0x50 + modrm_reg(opcode[1]));  /* push reg */
        patch_call(s, cpu, ip + 1, handlers->set_tpr);
        break;
    case 0x8b: /* mov r/m32 to r32 */
        patch_byte(cpu, ip, 0x90);
        patch_call(s, cpu, ip + 1, handlers->get_tpr[modrm_reg(opcode[1])]);
        break;
    case 0xa1: /* mov abs to eax */
        patch_call(s, cpu, ip, handlers->get_tpr[0]);
        break;
    case 0xa3: /* mov eax to abs */
        patch_call(s, cpu, ip, handlers->set_tpr_eax);
        break;
    case 0xc7: /* mov imm32, r/m32 (c7/0) */
        patch_byte(cpu, ip, 0x68);  /* push imm32 */
        cpu_memory_rw_debug(cs, ip + 6, (void *)&imm32, sizeof(imm32), 0);
        cpu_memory_rw_debug(cs, ip + 1, (void *)&imm32, sizeof(imm32), 1);
        patch_call(s, cpu, ip + 5, handlers->set_tpr);
        break;
    case 0xff: /* push r/m32 */
        patch_byte(cpu, ip, 0x50); /* push eax */
        patch_call(s, cpu, ip + 1, handlers->get_tpr_stack);
        break;
    default:
        abort();
    }

    resume_all_vcpus();

    if (!kvm_enabled()) {
        tb_gen_code(cs, current_pc, current_cs_base, current_flags, 1);
        cpu_resume_from_signal(cs, NULL);
    }
}
","The `patch_instruction` function modifies specific CPU instructions in a virtualized environment based on the opcode at a given instruction pointer (IP). It first determines the appropriate handler set for single or multiple CPUs and retrieves the current CPU state if KVM is not enabled. The function then pauses all virtual CPUs and reads the opcode from memory. Depending on the opcode, it patches the instruction to change its behavior, such as replacing `mov` operations with `push` instructions or calling specific handler functions. After patching, it resumes all virtual CPUs and generates new code for the translation buffer if KVM is not active.","The code modifies specific CPU instructions in a virtualized environment by reading the opcode at a designated instruction pointer. It first checks the number of CPUs to determine the appropriate handler set and retrieves the current CPU state if a certain virtualization feature is not enabled. The function then pauses all virtual CPUs, reads the opcode from memory, and alters the instruction based on its type, replacing certain operations with others or invoking specific handler functions. After making the necessary changes, it resumes all virtual CPUs and generates new code for the translation buffer if the virtualization feature is inactive.","The vulnerability in the original code stemmed from the uninitialized variable `imm32`, which could lead to undefined behavior when reading memory. Specifically, if the opcode indicated a `mov imm32, r/m32` operation, the code would attempt to read a 32-bit immediate value without ensuring that `imm32` was properly initialized, potentially exposing sensitive data or causing crashes. The fix involved initializing `imm32` to zero, ensuring that it has a defined value before any operations are performed on it. This change mitigates the risk of using uninitialized memory, enhancing the overall stability and security of the code.","The vulnerability in the original code arose from the use of an uninitialized variable, which could lead to unpredictable behavior when the program attempted to read or manipulate memory. This situation posed a risk of exposing sensitive information or causing application crashes. The fix involved initializing the variable to a known value, ensuring that it would not contain garbage data before being used in operations. This change effectively mitigated the risk associated with uninitialized memory, thereby improving the code's reliability and security by preventing potential exploitation or instability during execution.","The vulnerability was fixed by initializing the variable `imm32` to zero in the changed code. This ensures that before any operations are performed on `imm32`, it contains a defined value, preventing the use of uninitialized memory. Specifically, in the case of the `mov imm32, r/m32` operation, the code now safely reads the immediate value from memory without the risk of exposing garbage data. This initialization enhances the stability and security of the code, as it eliminates the potential for undefined behavior that could arise from using an uninitialized variable during execution.","The vulnerability was addressed by ensuring that the problematic variable was initialized to a known value before it was used in any operations. This change prevents the risk of utilizing uninitialized memory, which could lead to unpredictable behavior or exposure of sensitive information. By setting the variable to a defined state, the code now safely handles memory operations, particularly in scenarios where immediate values are read. This fix enhances the overall reliability and security of the code, mitigating potential exploitation and ensuring stable execution during runtime.","5,4","5,5","5,5","4,4"
21,21,178348,178348,,Remote,Not required,,CVE-2014-3508,https://www.cvedetails.com/cve/CVE-2014-3508/,CWE-200,Medium,Partial,,,2014-08-13,4.3,"The OBJ_obj2txt function in crypto/objects/obj_dat.c in OpenSSL 0.9.8 before 0.9.8zb, 1.0.0 before 1.0.0n, and 1.0.1 before 1.0.1i, when pretty printing is used, does not ensure the presence of '\0' characters, which allows context-dependent attackers to obtain sensitive information from process stack memory by reading output from X509_name_oneline, X509_name_print_ex, and unspecified other functions.",2017-11-14,+Info,9,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=0042fb5fd1c9d257d713b15a1f45da05cf5c1c87,0042fb5fd1c9d257d713b15a1f45da05cf5c1c87,,6,,,"int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)
{
	int i,n=0,len,nid, first, use_bn;
	BIGNUM *bl;
	unsigned long l;
        const unsigned char *p;
        char tbuf[DECIMAL_SIZE(i)+DECIMAL_SIZE(l)+2];
 
       /* Ensure that, at every state, |buf| is NUL-terminated. */
       if (buf && buf_len > 0)
               buf[0] = '\0';
 
       if ((a == NULL) || (a->data == NULL))
               return(0);
 
        if (!no_name && (nid=OBJ_obj2nid(a)) != NID_undef)
                {
		s=OBJ_nid2ln(nid);
		if (s == NULL)
			s=OBJ_nid2sn(nid);
		if (s)
			{
			if (buf)
				BUF_strlcpy(buf,s,buf_len);
			n=strlen(s);
			return n;
			}
		}


	len=a->length;
	p=a->data;

	first = 1;
	bl = NULL;

	while (len > 0)
		{
		l=0;
		use_bn = 0;
		for (;;)
			{
			unsigned char c = *p++;
			len--;
			if ((len == 0) && (c & 0x80))
				goto err;
			if (use_bn)
				{
				if (!BN_add_word(bl, c & 0x7f))
					goto err;
				}
			else
				l |= c  & 0x7f;
			if (!(c & 0x80))
				break;
			if (!use_bn && (l > (ULONG_MAX >> 7L)))
				{
				if (!bl && !(bl = BN_new()))
					goto err;
				if (!BN_set_word(bl, l))
					goto err;
				use_bn = 1;
				}
			if (use_bn)
				{
				if (!BN_lshift(bl, bl, 7))
					goto err;
				}
			else
				l<<=7L;
			}

		if (first)
			{
			first = 0;
			if (l >= 80)
				{
				i = 2;
				if (use_bn)
					{
					if (!BN_sub_word(bl, 80))
						goto err;
					}
				else
					l -= 80;
				}
			else
				{
				i=(int)(l/40);
                                i=(int)(l/40);
                                l-=(long)(i*40);
                                }
                       if (buf && (buf_len > 1))
                                {
                                *buf++ = i + '0';
                               *buf = '\0';
                                buf_len--;
                                }
                        n++;
		if (use_bn)
			{
			char *bndec;
			bndec = BN_bn2dec(bl);
			if (!bndec)
				goto err;
			i = strlen(bndec);
			if (buf)
                        i = strlen(bndec);
                        if (buf)
                                {
                               if (buf_len > 1)
                                        {
                                        *buf++ = '.';
                                       *buf = '\0';
                                        buf_len--;
                                        }
                                BUF_strlcpy(buf,bndec,buf_len);
					buf_len = 0;
					}
				else
					{
					buf+=i;
					buf_len-=i;
					}
				}
			n++;
			n += i;
			OPENSSL_free(bndec);
			}
		else
			{
			BIO_snprintf(tbuf,sizeof tbuf,"".%lu"",l);
			i=strlen(tbuf);
			if (buf && (buf_len > 0))
				{
				BUF_strlcpy(buf,tbuf,buf_len);
				if (i > buf_len)
					{
					buf += buf_len;
					buf_len = 0;
					}
				else
					{
					buf+=i;
					buf_len-=i;
					}
				}
			n+=i;
			l=0;
			}
		}

	if (bl)
		BN_free(bl);
	return n;

	err:
	if (bl)
		BN_free(bl);
	return -1;
}
","int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)
{
	int i,n=0,len,nid, first, use_bn;
	BIGNUM *bl;
	unsigned long l;
        const unsigned char *p;
        char tbuf[DECIMAL_SIZE(i)+DECIMAL_SIZE(l)+2];
 
       if ((a == NULL) || (a->data == NULL)) {
               buf[0]='\0';
               return(0);
       }
 
 
        if (!no_name && (nid=OBJ_obj2nid(a)) != NID_undef)
                {
		s=OBJ_nid2ln(nid);
		if (s == NULL)
			s=OBJ_nid2sn(nid);
		if (s)
			{
			if (buf)
				BUF_strlcpy(buf,s,buf_len);
			n=strlen(s);
			return n;
			}
		}


	len=a->length;
	p=a->data;

	first = 1;
	bl = NULL;

	while (len > 0)
		{
		l=0;
		use_bn = 0;
		for (;;)
			{
			unsigned char c = *p++;
			len--;
			if ((len == 0) && (c & 0x80))
				goto err;
			if (use_bn)
				{
				if (!BN_add_word(bl, c & 0x7f))
					goto err;
				}
			else
				l |= c  & 0x7f;
			if (!(c & 0x80))
				break;
			if (!use_bn && (l > (ULONG_MAX >> 7L)))
				{
				if (!bl && !(bl = BN_new()))
					goto err;
				if (!BN_set_word(bl, l))
					goto err;
				use_bn = 1;
				}
			if (use_bn)
				{
				if (!BN_lshift(bl, bl, 7))
					goto err;
				}
			else
				l<<=7L;
			}

		if (first)
			{
			first = 0;
			if (l >= 80)
				{
				i = 2;
				if (use_bn)
					{
					if (!BN_sub_word(bl, 80))
						goto err;
					}
				else
					l -= 80;
				}
			else
				{
				i=(int)(l/40);
                                i=(int)(l/40);
                                l-=(long)(i*40);
                                }
                       if (buf && (buf_len > 0))
                                {
                                *buf++ = i + '0';
                                buf_len--;
                                }
                        n++;
		if (use_bn)
			{
			char *bndec;
			bndec = BN_bn2dec(bl);
			if (!bndec)
				goto err;
			i = strlen(bndec);
			if (buf)
                        i = strlen(bndec);
                        if (buf)
                                {
                               if (buf_len > 0)
                                        {
                                        *buf++ = '.';
                                        buf_len--;
                                        }
                                BUF_strlcpy(buf,bndec,buf_len);
					buf_len = 0;
					}
				else
					{
					buf+=i;
					buf_len-=i;
					}
				}
			n++;
			n += i;
			OPENSSL_free(bndec);
			}
		else
			{
			BIO_snprintf(tbuf,sizeof tbuf,"".%lu"",l);
			i=strlen(tbuf);
			if (buf && (buf_len > 0))
				{
				BUF_strlcpy(buf,tbuf,buf_len);
				if (i > buf_len)
					{
					buf += buf_len;
					buf_len = 0;
					}
				else
					{
					buf+=i;
					buf_len-=i;
					}
				}
			n+=i;
			l=0;
			}
		}

	if (bl)
		BN_free(bl);
	return n;

	err:
	if (bl)
		BN_free(bl);
	return -1;
}
",C,"       /* Ensure that, at every state, |buf| is NUL-terminated. */
       if (buf && buf_len > 0)
               buf[0] = '\0';
       if ((a == NULL) || (a->data == NULL))
               return(0);
                       if (buf && (buf_len > 1))
                               *buf = '\0';
                               if (buf_len > 1)
                                       *buf = '\0';
","       if ((a == NULL) || (a->data == NULL)) {
               buf[0]='\0';
               return(0);
       }
                       if (buf && (buf_len > 0))
                               if (buf_len > 0)
",17160033765480453be0a41335fa6b833691c049,"@@ -471,11 +471,12 @@ int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)
        const unsigned char *p;
        char tbuf[DECIMAL_SIZE(i)+DECIMAL_SIZE(l)+2];
 
-       if ((a == NULL) || (a->data == NULL)) {
-               buf[0]='\0';
-               return(0);
-       }
+       /* Ensure that, at every state, |buf| is NUL-terminated. */
+       if (buf && buf_len > 0)
+               buf[0] = '\0';
 
+       if ((a == NULL) || (a->data == NULL))
+               return(0);
 
        if (!no_name && (nid=OBJ_obj2nid(a)) != NID_undef)
                {
@@ -554,9 +555,10 @@ int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)
                                i=(int)(l/40);
                                l-=(long)(i*40);
                                }
-                       if (buf && (buf_len > 0))
+                       if (buf && (buf_len > 1))
                                {
                                *buf++ = i + '0';
+                               *buf = '\0';
                                buf_len--;
                                }
                        n++;
@@ -571,9 +573,10 @@ int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)
                        i = strlen(bndec);
                        if (buf)
                                {
-                               if (buf_len > 0)
+                               if (buf_len > 1)
                                        {
                                        *buf++ = '.';
+                                       *buf = '\0';
                                        buf_len--;
                                        }
                                BUF_strlcpy(buf,bndec,buf_len);
@@ -807,4 +810,3 @@ err:
        OPENSSL_free(buf);
        return(ok);
        }
-",openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/objects/obj_dat.c;h=bf89bc7b161f5e4cef69fcb6d131d7460042e113;hb=0042fb5fd1c9d257d713b15a1f45da05cf5c1c87,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/objects/obj_dat.c;h=e515160d72e1807169c2e5f3f54b41872babbb88,1,"int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)
{
	int i,n=0,len,nid, first, use_bn;
	BIGNUM *bl;
	unsigned long l;
        const unsigned char *p;
        char tbuf[DECIMAL_SIZE(i)+DECIMAL_SIZE(l)+2];
 
//flaw_line_below:
       if ((a == NULL) || (a->data == NULL)) {
//flaw_line_below:
               buf[0]='\0';
//flaw_line_below:
               return(0);
//flaw_line_below:
       }
//fix_flaw_line_below:
//       /* Ensure that, at every state, |buf| is NUL-terminated. */
//fix_flaw_line_below:
//       if (buf && buf_len > 0)
//fix_flaw_line_below:
//               buf[0] = '\0';
 
//fix_flaw_line_below:
//       if ((a == NULL) || (a->data == NULL))
//fix_flaw_line_below:
//               return(0);
 
        if (!no_name && (nid=OBJ_obj2nid(a)) != NID_undef)
                {
		s=OBJ_nid2ln(nid);
		if (s == NULL)
			s=OBJ_nid2sn(nid);
		if (s)
			{
			if (buf)
				BUF_strlcpy(buf,s,buf_len);
			n=strlen(s);
			return n;
			}
		}


	len=a->length;
	p=a->data;

	first = 1;
	bl = NULL;

	while (len > 0)
		{
		l=0;
		use_bn = 0;
		for (;;)
			{
			unsigned char c = *p++;
			len--;
			if ((len == 0) && (c & 0x80))
				goto err;
			if (use_bn)
				{
				if (!BN_add_word(bl, c & 0x7f))
					goto err;
				}
			else
				l |= c  & 0x7f;
			if (!(c & 0x80))
				break;
			if (!use_bn && (l > (ULONG_MAX >> 7L)))
				{
				if (!bl && !(bl = BN_new()))
					goto err;
				if (!BN_set_word(bl, l))
					goto err;
				use_bn = 1;
				}
			if (use_bn)
				{
				if (!BN_lshift(bl, bl, 7))
					goto err;
				}
			else
				l<<=7L;
			}

		if (first)
			{
			first = 0;
			if (l >= 80)
				{
				i = 2;
				if (use_bn)
					{
					if (!BN_sub_word(bl, 80))
						goto err;
					}
				else
					l -= 80;
				}
			else
				{
				i=(int)(l/40);
                                i=(int)(l/40);
                                l-=(long)(i*40);
                                }
//flaw_line_below:
                       if (buf && (buf_len > 0))
//fix_flaw_line_below:
//                       if (buf && (buf_len > 1))
                                {
                                *buf++ = i + '0';
//fix_flaw_line_below:
//                               *buf = '\0';
                                buf_len--;
                                }
                        n++;
		if (use_bn)
			{
			char *bndec;
			bndec = BN_bn2dec(bl);
			if (!bndec)
				goto err;
			i = strlen(bndec);
			if (buf)
                        i = strlen(bndec);
                        if (buf)
                                {
//flaw_line_below:
                               if (buf_len > 0)
//fix_flaw_line_below:
//                               if (buf_len > 1)
                                        {
                                        *buf++ = '.';
//fix_flaw_line_below:
//                                       *buf = '\0';
                                        buf_len--;
                                        }
                                BUF_strlcpy(buf,bndec,buf_len);
					buf_len = 0;
					}
				else
					{
					buf+=i;
					buf_len-=i;
					}
				}
			n++;
			n += i;
			OPENSSL_free(bndec);
			}
		else
			{
			BIO_snprintf(tbuf,sizeof tbuf,"".%lu"",l);
			i=strlen(tbuf);
			if (buf && (buf_len > 0))
				{
				BUF_strlcpy(buf,tbuf,buf_len);
				if (i > buf_len)
					{
					buf += buf_len;
					buf_len = 0;
					}
				else
					{
					buf+=i;
					buf_len-=i;
					}
				}
			n+=i;
			l=0;
			}
		}

	if (bl)
		BN_free(bl);
	return n;

	err:
	if (bl)
		BN_free(bl);
	return -1;
}
",178348,"int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)
{
	int i,n=0,len,nid, first, use_bn;
	BIGNUM *bl;
	unsigned long l;
        const unsigned char *p;
        char tbuf[DECIMAL_SIZE(i)+DECIMAL_SIZE(l)+2];
 
       if ((a == NULL) || (a->data == NULL)) {
               buf[0]='\0';
               return(0);
       }
 
 
        if (!no_name && (nid=OBJ_obj2nid(a)) != NID_undef)
                {
		s=OBJ_nid2ln(nid);
		if (s == NULL)
			s=OBJ_nid2sn(nid);
		if (s)
			{
			if (buf)
				BUF_strlcpy(buf,s,buf_len);
			n=strlen(s);
			return n;
			}
		}


	len=a->length;
	p=a->data;

	first = 1;
	bl = NULL;

	while (len > 0)
		{
		l=0;
		use_bn = 0;
		for (;;)
			{
			unsigned char c = *p++;
			len--;
			if ((len == 0) && (c & 0x80))
				goto err;
			if (use_bn)
				{
				if (!BN_add_word(bl, c & 0x7f))
					goto err;
				}
			else
				l |= c  & 0x7f;
			if (!(c & 0x80))
				break;
			if (!use_bn && (l > (ULONG_MAX >> 7L)))
				{
				if (!bl && !(bl = BN_new()))
					goto err;
				if (!BN_set_word(bl, l))
					goto err;
				use_bn = 1;
				}
			if (use_bn)
				{
				if (!BN_lshift(bl, bl, 7))
					goto err;
				}
			else
				l<<=7L;
			}

		if (first)
			{
			first = 0;
			if (l >= 80)
				{
				i = 2;
				if (use_bn)
					{
					if (!BN_sub_word(bl, 80))
						goto err;
					}
				else
					l -= 80;
				}
			else
				{
				i=(int)(l/40);
                                i=(int)(l/40);
                                l-=(long)(i*40);
                                }
                       if (buf && (buf_len > 0))
                                {
                                *buf++ = i + '0';
                                buf_len--;
                                }
                        n++;
		if (use_bn)
			{
			char *bndec;
			bndec = BN_bn2dec(bl);
			if (!bndec)
				goto err;
			i = strlen(bndec);
			if (buf)
                        i = strlen(bndec);
                        if (buf)
                                {
                               if (buf_len > 0)
                                        {
                                        *buf++ = '.';
                                        buf_len--;
                                        }
                                BUF_strlcpy(buf,bndec,buf_len);
					buf_len = 0;
					}
				else
					{
					buf+=i;
					buf_len-=i;
					}
				}
			n++;
			n += i;
			OPENSSL_free(bndec);
			}
		else
			{
			BIO_snprintf(tbuf,sizeof tbuf,"".%lu"",l);
			i=strlen(tbuf);
			if (buf && (buf_len > 0))
				{
				BUF_strlcpy(buf,tbuf,buf_len);
				if (i > buf_len)
					{
					buf += buf_len;
					buf_len = 0;
					}
				else
					{
					buf+=i;
					buf_len-=i;
					}
				}
			n+=i;
			l=0;
			}
		}

	if (bl)
		BN_free(bl);
	return n;

	err:
	if (bl)
		BN_free(bl);
	return -1;
}
","int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)
{
	int i,n=0,len,nid, first, use_bn;
	BIGNUM *bl;
	unsigned long l;
        const unsigned char *p;
        char tbuf[DECIMAL_SIZE(i)+DECIMAL_SIZE(l)+2];
 
       /* Ensure that, at every state, |buf| is NUL-terminated. */
       if (buf && buf_len > 0)
               buf[0] = '\0';
 
       if ((a == NULL) || (a->data == NULL))
               return(0);
 
        if (!no_name && (nid=OBJ_obj2nid(a)) != NID_undef)
                {
		s=OBJ_nid2ln(nid);
		if (s == NULL)
			s=OBJ_nid2sn(nid);
		if (s)
			{
			if (buf)
				BUF_strlcpy(buf,s,buf_len);
			n=strlen(s);
			return n;
			}
		}


	len=a->length;
	p=a->data;

	first = 1;
	bl = NULL;

	while (len > 0)
		{
		l=0;
		use_bn = 0;
		for (;;)
			{
			unsigned char c = *p++;
			len--;
			if ((len == 0) && (c & 0x80))
				goto err;
			if (use_bn)
				{
				if (!BN_add_word(bl, c & 0x7f))
					goto err;
				}
			else
				l |= c  & 0x7f;
			if (!(c & 0x80))
				break;
			if (!use_bn && (l > (ULONG_MAX >> 7L)))
				{
				if (!bl && !(bl = BN_new()))
					goto err;
				if (!BN_set_word(bl, l))
					goto err;
				use_bn = 1;
				}
			if (use_bn)
				{
				if (!BN_lshift(bl, bl, 7))
					goto err;
				}
			else
				l<<=7L;
			}

		if (first)
			{
			first = 0;
			if (l >= 80)
				{
				i = 2;
				if (use_bn)
					{
					if (!BN_sub_word(bl, 80))
						goto err;
					}
				else
					l -= 80;
				}
			else
				{
				i=(int)(l/40);
                                i=(int)(l/40);
                                l-=(long)(i*40);
                                }
                       if (buf && (buf_len > 1))
                                {
                                *buf++ = i + '0';
                               *buf = '\0';
                                buf_len--;
                                }
                        n++;
		if (use_bn)
			{
			char *bndec;
			bndec = BN_bn2dec(bl);
			if (!bndec)
				goto err;
			i = strlen(bndec);
			if (buf)
                        i = strlen(bndec);
                        if (buf)
                                {
                               if (buf_len > 1)
                                        {
                                        *buf++ = '.';
                                       *buf = '\0';
                                        buf_len--;
                                        }
                                BUF_strlcpy(buf,bndec,buf_len);
					buf_len = 0;
					}
				else
					{
					buf+=i;
					buf_len-=i;
					}
				}
			n++;
			n += i;
			OPENSSL_free(bndec);
			}
		else
			{
			BIO_snprintf(tbuf,sizeof tbuf,"".%lu"",l);
			i=strlen(tbuf);
			if (buf && (buf_len > 0))
				{
				BUF_strlcpy(buf,tbuf,buf_len);
				if (i > buf_len)
					{
					buf += buf_len;
					buf_len = 0;
					}
				else
					{
					buf+=i;
					buf_len-=i;
					}
				}
			n+=i;
			l=0;
			}
		}

	if (bl)
		BN_free(bl);
	return n;

	err:
	if (bl)
		BN_free(bl);
	return -1;
}
","The `OBJ_obj2txt` function converts an ASN.1 object into a human-readable string representation, storing the result in a provided buffer. It first checks if the input object is valid and retrieves its numerical identifier (NID) if requested. If a name is available for the object, it copies it to the buffer. The function then processes the object's data, converting it from ASN.1 format to a decimal string, handling large values with a BIGNUM structure if necessary. The function returns the length of the resulting string or -1 in case of an error, ensuring proper memory management throughout.","The provided code converts an ASN.1 object into a human-readable string format, storing the output in a specified buffer. It first checks the validity of the input object and attempts to retrieve its associated name if requested. If a name is found, it is copied to the buffer. The code then processes the object's data, converting it from ASN.1 encoding to a decimal representation, using a special structure to handle large values when necessary. The function returns the length of the generated string or an error indicator if any issues arise during processing, ensuring proper memory management throughout.","The vulnerability in the original code stemmed from the lack of proper null-termination for the output buffer, which could lead to buffer overflows or undefined behavior when the buffer was accessed. Specifically, the code did not ensure that the buffer was always null-terminated after writing data to it. The fix introduced a check to ensure that the buffer is initialized with a null character at the beginning and added null-termination after writing to the buffer, particularly after copying strings and appending characters. This change enhances the safety of the buffer handling, preventing potential security issues related to string manipulation.","The vulnerability in the original code was due to the absence of proper null-termination for the output buffer, which could lead to buffer overflows or unintended memory access when the buffer was read. This oversight could allow for the reading of garbage data or even exploitation by malicious inputs. The fix addressed this issue by ensuring that the buffer is initialized with a null character at the start and explicitly adding null-termination after writing data to the buffer. This enhancement improves the safety of string handling, mitigating risks associated with improper memory management and ensuring predictable behavior.","The vulnerability was fixed by ensuring that the output buffer is properly null-terminated. The code now initializes the buffer with a null character at the beginning, using the expression `buf[0] = '\0'` if the buffer is valid and has a positive length. Additionally, after writing data to the buffer, the code explicitly sets the next position to null by using `*buf = '\0'` after appending characters or strings. This guarantees that the buffer will always be safely terminated, preventing potential buffer overflows and ensuring that any subsequent string operations behave correctly.","The vulnerability was addressed by implementing proper null-termination for the output buffer to prevent potential buffer overflows and undefined behavior. The fix involved initializing the buffer with a null character at the start to ensure it is empty before any data is written. Additionally, after appending data to the buffer, the code explicitly sets the next position to null, ensuring that the buffer remains properly terminated. This change enhances the safety of string handling, ensuring that any subsequent operations on the buffer will function correctly and securely, thereby mitigating risks associated with improper memory management.","5, 5","4,4","4,4","4, 5"
22,22,178392,178392,,Remote,Not required,,CVE-2017-0379,https://www.cvedetails.com/cve/CVE-2017-0379/,CWE-200,Low,Partial,,,2017-08-29,5.0,"Libgcrypt before 1.8.1 does not properly consider Curve25519 side-channel attacks, which makes it easier for attackers to discover a secret key, related to cipher/ecc.c and mpi/ec.c.",2019-01-16,+Info,15,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=commit;h=da780c8183cccc8f533c8ace8211ac2cb2bdee7b,da780c8183cccc8f533c8ace8211ac2cb2bdee7b,,2,,,"ecc_decrypt_raw (gcry_sexp_t *r_plain, gcry_sexp_t s_data, gcry_sexp_t keyparms)
{
  unsigned int nbits;
  gpg_err_code_t rc;
  struct pk_encoding_ctx ctx;
  gcry_sexp_t l1 = NULL;
  gcry_mpi_t data_e = NULL;
  ECC_secret_key sk;
  gcry_mpi_t mpi_g = NULL;
  char *curvename = NULL;
  mpi_ec_t ec = NULL;
  mpi_point_struct kG;
  mpi_point_struct R;
  gcry_mpi_t r = NULL;
  int flags = 0;

  memset (&sk, 0, sizeof sk);
  point_init (&kG);
  point_init (&R);

  _gcry_pk_util_init_encoding_ctx (&ctx, PUBKEY_OP_DECRYPT,
                                   (nbits = ecc_get_nbits (keyparms)));

  /* Look for flags. */
  l1 = sexp_find_token (keyparms, ""flags"", 0);
  if (l1)
    {
      rc = _gcry_pk_util_parse_flaglist (l1, &flags, NULL);
      if (rc)
        goto leave;
    }
  sexp_release (l1);
  l1 = NULL;

  /*
   * Extract the data.
   */
  rc = _gcry_pk_util_preparse_encval (s_data, ecc_names, &l1, &ctx);
  if (rc)
    goto leave;
  rc = sexp_extract_param (l1, NULL, ""e"", &data_e, NULL);
  if (rc)
    goto leave;
  if (DBG_CIPHER)
    log_printmpi (""ecc_decrypt  d_e"", data_e);
  if (mpi_is_opaque (data_e))
    {
      rc = GPG_ERR_INV_DATA;
      goto leave;
    }

  /*
   * Extract the key.
   */
  rc = sexp_extract_param (keyparms, NULL, ""-p?a?b?g?n?h?+d"",
                           &sk.E.p, &sk.E.a, &sk.E.b, &mpi_g, &sk.E.n,
                           &sk.E.h, &sk.d, NULL);
  if (rc)
    goto leave;
  if (mpi_g)
    {
      point_init (&sk.E.G);
      rc = _gcry_ecc_os2ec (&sk.E.G, mpi_g);
      if (rc)
        goto leave;
    }
  /* Add missing parameters using the optional curve parameter.  */
  sexp_release (l1);
  l1 = sexp_find_token (keyparms, ""curve"", 5);
  if (l1)
    {
      curvename = sexp_nth_string (l1, 1);
      if (curvename)
        {
          rc = _gcry_ecc_fill_in_curve (0, curvename, &sk.E, NULL);
          if (rc)
            goto leave;
        }
    }
  /* Guess required fields if a curve parameter has not been given.  */
  if (!curvename)
    {
      sk.E.model = MPI_EC_WEIERSTRASS;
      sk.E.dialect = ECC_DIALECT_STANDARD;
      if (!sk.E.h)
	sk.E.h = mpi_const (MPI_C_ONE);
    }
  if (DBG_CIPHER)
    {
      log_debug (""ecc_decrypt info: %s/%s\n"",
                 _gcry_ecc_model2str (sk.E.model),
                 _gcry_ecc_dialect2str (sk.E.dialect));
      if (sk.E.name)
        log_debug  (""ecc_decrypt name: %s\n"", sk.E.name);
      log_printmpi (""ecc_decrypt    p"", sk.E.p);
      log_printmpi (""ecc_decrypt    a"", sk.E.a);
      log_printmpi (""ecc_decrypt    b"", sk.E.b);
      log_printpnt (""ecc_decrypt  g"",   &sk.E.G, NULL);
      log_printmpi (""ecc_decrypt    n"", sk.E.n);
      log_printmpi (""ecc_decrypt    h"", sk.E.h);
      if (!fips_mode ())
        log_printmpi (""ecc_decrypt    d"", sk.d);
    }
  if (!sk.E.p || !sk.E.a || !sk.E.b || !sk.E.G.x || !sk.E.n || !sk.E.h || !sk.d)
    {
      rc = GPG_ERR_NO_OBJ;
      goto leave;
    }


  ec = _gcry_mpi_ec_p_internal_new (sk.E.model, sk.E.dialect, flags,
                                    sk.E.p, sk.E.a, sk.E.b);

  /*
   * Compute the plaintext.
   */
  if (ec->model == MPI_EC_MONTGOMERY)
    rc = _gcry_ecc_mont_decodepoint (data_e, ec, &kG);
  else
    rc = _gcry_ecc_os2ec (&kG, data_e);
  if (rc)
    goto leave;

   if (DBG_CIPHER)
     log_printpnt (""ecc_decrypt    kG"", &kG, NULL);
 
  if ((flags & PUBKEY_FLAG_DJB_TWEAK))
    {
       /* For X25519, by its definition, validation should not be done.  */
      /* (Instead, we do output check.)
       *
       * However, to mitigate secret key leak from our implementation,
       * we also do input validation here.  For constant-time
       * implementation, we can remove this input validation.
       */
      if (_gcry_mpi_ec_bad_point (&kG, ec))
        {
          rc = GPG_ERR_INV_DATA;
          goto leave;
        }
    }
  else if (!_gcry_mpi_ec_curve_point (&kG, ec))
     {
       rc = GPG_ERR_INV_DATA;
       goto leave;
      y = mpi_new (0);

    if (_gcry_mpi_ec_get_affine (x, y, &R, ec))
      {
        rc = GPG_ERR_INV_DATA;
        goto leave;
        /*
         * Note for X25519.
         *
         * By the definition of X25519, this is the case where X25519
         * returns 0, mapping infinity to zero.  However, we
         * deliberately let it return an error.
         *
         * For X25519 ECDH, comming here means that it might be
         * decrypted by anyone with the shared secret of 0 (the result
         * of this function could be always 0 by other scalar values,
         * other than the private key of SK.D).
         *
         * So, it looks like an encrypted message but it can be
         * decrypted by anyone, or at least something wrong
         * happens.  Recipient should not proceed as if it were
         * properly encrypted message.
         *
         * This handling is needed for our major usage of GnuPG,
         * where it does the One-Pass Diffie-Hellman method,
         * C(1, 1, ECC CDH), with an ephemeral key.
         */
      }

    if (y)
      r = _gcry_ecc_ec2os (x, y, sk.E.p);
    else
      {
        unsigned char *rawmpi;
        unsigned int rawmpilen;

        rawmpi = _gcry_mpi_get_buffer_extra (x, nbits/8, -1,
                                             &rawmpilen, NULL);
        if (!rawmpi)
          {
            rc = gpg_err_code_from_syserror ();
            goto leave;
          }
        else
          {
            rawmpi[0] = 0x40;
            rawmpilen++;
            r = mpi_new (0);
            mpi_set_opaque (r, rawmpi, rawmpilen*8);
          }
      }
    if (!r)
      rc = gpg_err_code_from_syserror ();
    else
      rc = 0;
    mpi_free (x);
    mpi_free (y);
  }
  if (DBG_CIPHER)
    log_printmpi (""ecc_decrypt  res"", r);

  if (!rc)
    rc = sexp_build (r_plain, NULL, ""(value %m)"", r);

 leave:
  point_free (&R);
  point_free (&kG);
  _gcry_mpi_release (r);
  _gcry_mpi_release (sk.E.p);
  _gcry_mpi_release (sk.E.a);
  _gcry_mpi_release (sk.E.b);
  _gcry_mpi_release (mpi_g);
  point_free (&sk.E.G);
  _gcry_mpi_release (sk.E.n);
  _gcry_mpi_release (sk.E.h);
  _gcry_mpi_release (sk.d);
  _gcry_mpi_release (data_e);
  xfree (curvename);
  sexp_release (l1);
  _gcry_mpi_ec_free (ec);
  _gcry_pk_util_free_encoding_ctx (&ctx);
  if (DBG_CIPHER)
    log_debug (""ecc_decrypt    => %s\n"", gpg_strerror (rc));
  return rc;
}
","ecc_decrypt_raw (gcry_sexp_t *r_plain, gcry_sexp_t s_data, gcry_sexp_t keyparms)
{
  unsigned int nbits;
  gpg_err_code_t rc;
  struct pk_encoding_ctx ctx;
  gcry_sexp_t l1 = NULL;
  gcry_mpi_t data_e = NULL;
  ECC_secret_key sk;
  gcry_mpi_t mpi_g = NULL;
  char *curvename = NULL;
  mpi_ec_t ec = NULL;
  mpi_point_struct kG;
  mpi_point_struct R;
  gcry_mpi_t r = NULL;
  int flags = 0;

  memset (&sk, 0, sizeof sk);
  point_init (&kG);
  point_init (&R);

  _gcry_pk_util_init_encoding_ctx (&ctx, PUBKEY_OP_DECRYPT,
                                   (nbits = ecc_get_nbits (keyparms)));

  /* Look for flags. */
  l1 = sexp_find_token (keyparms, ""flags"", 0);
  if (l1)
    {
      rc = _gcry_pk_util_parse_flaglist (l1, &flags, NULL);
      if (rc)
        goto leave;
    }
  sexp_release (l1);
  l1 = NULL;

  /*
   * Extract the data.
   */
  rc = _gcry_pk_util_preparse_encval (s_data, ecc_names, &l1, &ctx);
  if (rc)
    goto leave;
  rc = sexp_extract_param (l1, NULL, ""e"", &data_e, NULL);
  if (rc)
    goto leave;
  if (DBG_CIPHER)
    log_printmpi (""ecc_decrypt  d_e"", data_e);
  if (mpi_is_opaque (data_e))
    {
      rc = GPG_ERR_INV_DATA;
      goto leave;
    }

  /*
   * Extract the key.
   */
  rc = sexp_extract_param (keyparms, NULL, ""-p?a?b?g?n?h?+d"",
                           &sk.E.p, &sk.E.a, &sk.E.b, &mpi_g, &sk.E.n,
                           &sk.E.h, &sk.d, NULL);
  if (rc)
    goto leave;
  if (mpi_g)
    {
      point_init (&sk.E.G);
      rc = _gcry_ecc_os2ec (&sk.E.G, mpi_g);
      if (rc)
        goto leave;
    }
  /* Add missing parameters using the optional curve parameter.  */
  sexp_release (l1);
  l1 = sexp_find_token (keyparms, ""curve"", 5);
  if (l1)
    {
      curvename = sexp_nth_string (l1, 1);
      if (curvename)
        {
          rc = _gcry_ecc_fill_in_curve (0, curvename, &sk.E, NULL);
          if (rc)
            goto leave;
        }
    }
  /* Guess required fields if a curve parameter has not been given.  */
  if (!curvename)
    {
      sk.E.model = MPI_EC_WEIERSTRASS;
      sk.E.dialect = ECC_DIALECT_STANDARD;
      if (!sk.E.h)
	sk.E.h = mpi_const (MPI_C_ONE);
    }
  if (DBG_CIPHER)
    {
      log_debug (""ecc_decrypt info: %s/%s\n"",
                 _gcry_ecc_model2str (sk.E.model),
                 _gcry_ecc_dialect2str (sk.E.dialect));
      if (sk.E.name)
        log_debug  (""ecc_decrypt name: %s\n"", sk.E.name);
      log_printmpi (""ecc_decrypt    p"", sk.E.p);
      log_printmpi (""ecc_decrypt    a"", sk.E.a);
      log_printmpi (""ecc_decrypt    b"", sk.E.b);
      log_printpnt (""ecc_decrypt  g"",   &sk.E.G, NULL);
      log_printmpi (""ecc_decrypt    n"", sk.E.n);
      log_printmpi (""ecc_decrypt    h"", sk.E.h);
      if (!fips_mode ())
        log_printmpi (""ecc_decrypt    d"", sk.d);
    }
  if (!sk.E.p || !sk.E.a || !sk.E.b || !sk.E.G.x || !sk.E.n || !sk.E.h || !sk.d)
    {
      rc = GPG_ERR_NO_OBJ;
      goto leave;
    }


  ec = _gcry_mpi_ec_p_internal_new (sk.E.model, sk.E.dialect, flags,
                                    sk.E.p, sk.E.a, sk.E.b);

  /*
   * Compute the plaintext.
   */
  if (ec->model == MPI_EC_MONTGOMERY)
    rc = _gcry_ecc_mont_decodepoint (data_e, ec, &kG);
  else
    rc = _gcry_ecc_os2ec (&kG, data_e);
  if (rc)
    goto leave;

   if (DBG_CIPHER)
     log_printpnt (""ecc_decrypt    kG"", &kG, NULL);
 
  if (!(flags & PUBKEY_FLAG_DJB_TWEAK)
       /* For X25519, by its definition, validation should not be done.  */
      && !_gcry_mpi_ec_curve_point (&kG, ec))
     {
       rc = GPG_ERR_INV_DATA;
       goto leave;
      y = mpi_new (0);

    if (_gcry_mpi_ec_get_affine (x, y, &R, ec))
      {
        rc = GPG_ERR_INV_DATA;
        goto leave;
        /*
         * Note for X25519.
         *
         * By the definition of X25519, this is the case where X25519
         * returns 0, mapping infinity to zero.  However, we
         * deliberately let it return an error.
         *
         * For X25519 ECDH, comming here means that it might be
         * decrypted by anyone with the shared secret of 0 (the result
         * of this function could be always 0 by other scalar values,
         * other than the private key of SK.D).
         *
         * So, it looks like an encrypted message but it can be
         * decrypted by anyone, or at least something wrong
         * happens.  Recipient should not proceed as if it were
         * properly encrypted message.
         *
         * This handling is needed for our major usage of GnuPG,
         * where it does the One-Pass Diffie-Hellman method,
         * C(1, 1, ECC CDH), with an ephemeral key.
         */
      }

    if (y)
      r = _gcry_ecc_ec2os (x, y, sk.E.p);
    else
      {
        unsigned char *rawmpi;
        unsigned int rawmpilen;

        rawmpi = _gcry_mpi_get_buffer_extra (x, nbits/8, -1,
                                             &rawmpilen, NULL);
        if (!rawmpi)
          {
            rc = gpg_err_code_from_syserror ();
            goto leave;
          }
        else
          {
            rawmpi[0] = 0x40;
            rawmpilen++;
            r = mpi_new (0);
            mpi_set_opaque (r, rawmpi, rawmpilen*8);
          }
      }
    if (!r)
      rc = gpg_err_code_from_syserror ();
    else
      rc = 0;
    mpi_free (x);
    mpi_free (y);
  }
  if (DBG_CIPHER)
    log_printmpi (""ecc_decrypt  res"", r);

  if (!rc)
    rc = sexp_build (r_plain, NULL, ""(value %m)"", r);

 leave:
  point_free (&R);
  point_free (&kG);
  _gcry_mpi_release (r);
  _gcry_mpi_release (sk.E.p);
  _gcry_mpi_release (sk.E.a);
  _gcry_mpi_release (sk.E.b);
  _gcry_mpi_release (mpi_g);
  point_free (&sk.E.G);
  _gcry_mpi_release (sk.E.n);
  _gcry_mpi_release (sk.E.h);
  _gcry_mpi_release (sk.d);
  _gcry_mpi_release (data_e);
  xfree (curvename);
  sexp_release (l1);
  _gcry_mpi_ec_free (ec);
  _gcry_pk_util_free_encoding_ctx (&ctx);
  if (DBG_CIPHER)
    log_debug (""ecc_decrypt    => %s\n"", gpg_strerror (rc));
  return rc;
}
",C,"  if ((flags & PUBKEY_FLAG_DJB_TWEAK))
    {
      /* (Instead, we do output check.)
       *
       * However, to mitigate secret key leak from our implementation,
       * we also do input validation here.  For constant-time
       * implementation, we can remove this input validation.
       */
      if (_gcry_mpi_ec_bad_point (&kG, ec))
        {
          rc = GPG_ERR_INV_DATA;
          goto leave;
        }
    }
  else if (!_gcry_mpi_ec_curve_point (&kG, ec))
","  if (!(flags & PUBKEY_FLAG_DJB_TWEAK)
      && !_gcry_mpi_ec_curve_point (&kG, ec))
",cd271dce4cd8479567d1e3c8b65f04abb9445fdf,"@@ -1628,9 +1628,22 @@ ecc_decrypt_raw (gcry_sexp_t *r_plain, gcry_sexp_t s_data, gcry_sexp_t keyparms)
   if (DBG_CIPHER)
     log_printpnt (""ecc_decrypt    kG"", &kG, NULL);
 
-  if (!(flags & PUBKEY_FLAG_DJB_TWEAK)
+  if ((flags & PUBKEY_FLAG_DJB_TWEAK))
+    {
       /* For X25519, by its definition, validation should not be done.  */
-      && !_gcry_mpi_ec_curve_point (&kG, ec))
+      /* (Instead, we do output check.)
+       *
+       * However, to mitigate secret key leak from our implementation,
+       * we also do input validation here.  For constant-time
+       * implementation, we can remove this input validation.
+       */
+      if (_gcry_mpi_ec_bad_point (&kG, ec))
+        {
+          rc = GPG_ERR_INV_DATA;
+          goto leave;
+        }
+    }
+  else if (!_gcry_mpi_ec_curve_point (&kG, ec))
     {
       rc = GPG_ERR_INV_DATA;
       goto leave;",gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=blob;f=cipher/ecc.c;h=4e3e5b1ac704684c5b52f8869d52b13b5a7b5048;hb=da780c8183cccc8f533c8ace8211ac2cb2bdee7b,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=blob;f=cipher/ecc.c;h=e25bf0956089e1347d5388dbd5e326b14ee7faf8,1,"ecc_decrypt_raw (gcry_sexp_t *r_plain, gcry_sexp_t s_data, gcry_sexp_t keyparms)
{
  unsigned int nbits;
  gpg_err_code_t rc;
  struct pk_encoding_ctx ctx;
  gcry_sexp_t l1 = NULL;
  gcry_mpi_t data_e = NULL;
  ECC_secret_key sk;
  gcry_mpi_t mpi_g = NULL;
  char *curvename = NULL;
  mpi_ec_t ec = NULL;
  mpi_point_struct kG;
  mpi_point_struct R;
  gcry_mpi_t r = NULL;
  int flags = 0;

  memset (&sk, 0, sizeof sk);
  point_init (&kG);
  point_init (&R);

  _gcry_pk_util_init_encoding_ctx (&ctx, PUBKEY_OP_DECRYPT,
                                   (nbits = ecc_get_nbits (keyparms)));

  /* Look for flags. */
  l1 = sexp_find_token (keyparms, ""flags"", 0);
  if (l1)
    {
      rc = _gcry_pk_util_parse_flaglist (l1, &flags, NULL);
      if (rc)
        goto leave;
    }
  sexp_release (l1);
  l1 = NULL;

  /*
   * Extract the data.
   */
  rc = _gcry_pk_util_preparse_encval (s_data, ecc_names, &l1, &ctx);
  if (rc)
    goto leave;
  rc = sexp_extract_param (l1, NULL, ""e"", &data_e, NULL);
  if (rc)
    goto leave;
  if (DBG_CIPHER)
    log_printmpi (""ecc_decrypt  d_e"", data_e);
  if (mpi_is_opaque (data_e))
    {
      rc = GPG_ERR_INV_DATA;
      goto leave;
    }

  /*
   * Extract the key.
   */
  rc = sexp_extract_param (keyparms, NULL, ""-p?a?b?g?n?h?+d"",
                           &sk.E.p, &sk.E.a, &sk.E.b, &mpi_g, &sk.E.n,
                           &sk.E.h, &sk.d, NULL);
  if (rc)
    goto leave;
  if (mpi_g)
    {
      point_init (&sk.E.G);
      rc = _gcry_ecc_os2ec (&sk.E.G, mpi_g);
      if (rc)
        goto leave;
    }
  /* Add missing parameters using the optional curve parameter.  */
  sexp_release (l1);
  l1 = sexp_find_token (keyparms, ""curve"", 5);
  if (l1)
    {
      curvename = sexp_nth_string (l1, 1);
      if (curvename)
        {
          rc = _gcry_ecc_fill_in_curve (0, curvename, &sk.E, NULL);
          if (rc)
            goto leave;
        }
    }
  /* Guess required fields if a curve parameter has not been given.  */
  if (!curvename)
    {
      sk.E.model = MPI_EC_WEIERSTRASS;
      sk.E.dialect = ECC_DIALECT_STANDARD;
      if (!sk.E.h)
	sk.E.h = mpi_const (MPI_C_ONE);
    }
  if (DBG_CIPHER)
    {
      log_debug (""ecc_decrypt info: %s/%s\n"",
                 _gcry_ecc_model2str (sk.E.model),
                 _gcry_ecc_dialect2str (sk.E.dialect));
      if (sk.E.name)
        log_debug  (""ecc_decrypt name: %s\n"", sk.E.name);
      log_printmpi (""ecc_decrypt    p"", sk.E.p);
      log_printmpi (""ecc_decrypt    a"", sk.E.a);
      log_printmpi (""ecc_decrypt    b"", sk.E.b);
      log_printpnt (""ecc_decrypt  g"",   &sk.E.G, NULL);
      log_printmpi (""ecc_decrypt    n"", sk.E.n);
      log_printmpi (""ecc_decrypt    h"", sk.E.h);
      if (!fips_mode ())
        log_printmpi (""ecc_decrypt    d"", sk.d);
    }
  if (!sk.E.p || !sk.E.a || !sk.E.b || !sk.E.G.x || !sk.E.n || !sk.E.h || !sk.d)
    {
      rc = GPG_ERR_NO_OBJ;
      goto leave;
    }


  ec = _gcry_mpi_ec_p_internal_new (sk.E.model, sk.E.dialect, flags,
                                    sk.E.p, sk.E.a, sk.E.b);

  /*
   * Compute the plaintext.
   */
  if (ec->model == MPI_EC_MONTGOMERY)
    rc = _gcry_ecc_mont_decodepoint (data_e, ec, &kG);
  else
    rc = _gcry_ecc_os2ec (&kG, data_e);
  if (rc)
    goto leave;

   if (DBG_CIPHER)
     log_printpnt (""ecc_decrypt    kG"", &kG, NULL);
 
//flaw_line_below:
  if (!(flags & PUBKEY_FLAG_DJB_TWEAK)
//fix_flaw_line_below:
//  if ((flags & PUBKEY_FLAG_DJB_TWEAK))
//fix_flaw_line_below:
//    {
       /* For X25519, by its definition, validation should not be done.  */
//flaw_line_below:
      && !_gcry_mpi_ec_curve_point (&kG, ec))
//fix_flaw_line_below:
//      /* (Instead, we do output check.)
//fix_flaw_line_below:
//       *
//fix_flaw_line_below:
//       * However, to mitigate secret key leak from our implementation,
//fix_flaw_line_below:
//       * we also do input validation here.  For constant-time
//fix_flaw_line_below:
//       * implementation, we can remove this input validation.
//fix_flaw_line_below:
//       */
//fix_flaw_line_below:
//      if (_gcry_mpi_ec_bad_point (&kG, ec))
//fix_flaw_line_below:
//        {
//fix_flaw_line_below:
//          rc = GPG_ERR_INV_DATA;
//fix_flaw_line_below:
//          goto leave;
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//  else if (!_gcry_mpi_ec_curve_point (&kG, ec))
     {
       rc = GPG_ERR_INV_DATA;
       goto leave;
      y = mpi_new (0);

    if (_gcry_mpi_ec_get_affine (x, y, &R, ec))
      {
        rc = GPG_ERR_INV_DATA;
        goto leave;
        /*
         * Note for X25519.
         *
         * By the definition of X25519, this is the case where X25519
         * returns 0, mapping infinity to zero.  However, we
         * deliberately let it return an error.
         *
         * For X25519 ECDH, comming here means that it might be
         * decrypted by anyone with the shared secret of 0 (the result
         * of this function could be always 0 by other scalar values,
         * other than the private key of SK.D).
         *
         * So, it looks like an encrypted message but it can be
         * decrypted by anyone, or at least something wrong
         * happens.  Recipient should not proceed as if it were
         * properly encrypted message.
         *
         * This handling is needed for our major usage of GnuPG,
         * where it does the One-Pass Diffie-Hellman method,
         * C(1, 1, ECC CDH), with an ephemeral key.
         */
      }

    if (y)
      r = _gcry_ecc_ec2os (x, y, sk.E.p);
    else
      {
        unsigned char *rawmpi;
        unsigned int rawmpilen;

        rawmpi = _gcry_mpi_get_buffer_extra (x, nbits/8, -1,
                                             &rawmpilen, NULL);
        if (!rawmpi)
          {
            rc = gpg_err_code_from_syserror ();
            goto leave;
          }
        else
          {
            rawmpi[0] = 0x40;
            rawmpilen++;
            r = mpi_new (0);
            mpi_set_opaque (r, rawmpi, rawmpilen*8);
          }
      }
    if (!r)
      rc = gpg_err_code_from_syserror ();
    else
      rc = 0;
    mpi_free (x);
    mpi_free (y);
  }
  if (DBG_CIPHER)
    log_printmpi (""ecc_decrypt  res"", r);

  if (!rc)
    rc = sexp_build (r_plain, NULL, ""(value %m)"", r);

 leave:
  point_free (&R);
  point_free (&kG);
  _gcry_mpi_release (r);
  _gcry_mpi_release (sk.E.p);
  _gcry_mpi_release (sk.E.a);
  _gcry_mpi_release (sk.E.b);
  _gcry_mpi_release (mpi_g);
  point_free (&sk.E.G);
  _gcry_mpi_release (sk.E.n);
  _gcry_mpi_release (sk.E.h);
  _gcry_mpi_release (sk.d);
  _gcry_mpi_release (data_e);
  xfree (curvename);
  sexp_release (l1);
  _gcry_mpi_ec_free (ec);
  _gcry_pk_util_free_encoding_ctx (&ctx);
  if (DBG_CIPHER)
    log_debug (""ecc_decrypt    => %s\n"", gpg_strerror (rc));
  return rc;
}
",178392,"ecc_decrypt_raw (gcry_sexp_t *r_plain, gcry_sexp_t s_data, gcry_sexp_t keyparms)
{
  unsigned int nbits;
  gpg_err_code_t rc;
  struct pk_encoding_ctx ctx;
  gcry_sexp_t l1 = NULL;
  gcry_mpi_t data_e = NULL;
  ECC_secret_key sk;
  gcry_mpi_t mpi_g = NULL;
  char *curvename = NULL;
  mpi_ec_t ec = NULL;
  mpi_point_struct kG;
  mpi_point_struct R;
  gcry_mpi_t r = NULL;
  int flags = 0;

  memset (&sk, 0, sizeof sk);
  point_init (&kG);
  point_init (&R);

  _gcry_pk_util_init_encoding_ctx (&ctx, PUBKEY_OP_DECRYPT,
                                   (nbits = ecc_get_nbits (keyparms)));

  /* Look for flags. */
  l1 = sexp_find_token (keyparms, ""flags"", 0);
  if (l1)
    {
      rc = _gcry_pk_util_parse_flaglist (l1, &flags, NULL);
      if (rc)
        goto leave;
    }
  sexp_release (l1);
  l1 = NULL;

  /*
   * Extract the data.
   */
  rc = _gcry_pk_util_preparse_encval (s_data, ecc_names, &l1, &ctx);
  if (rc)
    goto leave;
  rc = sexp_extract_param (l1, NULL, ""e"", &data_e, NULL);
  if (rc)
    goto leave;
  if (DBG_CIPHER)
    log_printmpi (""ecc_decrypt  d_e"", data_e);
  if (mpi_is_opaque (data_e))
    {
      rc = GPG_ERR_INV_DATA;
      goto leave;
    }

  /*
   * Extract the key.
   */
  rc = sexp_extract_param (keyparms, NULL, ""-p?a?b?g?n?h?+d"",
                           &sk.E.p, &sk.E.a, &sk.E.b, &mpi_g, &sk.E.n,
                           &sk.E.h, &sk.d, NULL);
  if (rc)
    goto leave;
  if (mpi_g)
    {
      point_init (&sk.E.G);
      rc = _gcry_ecc_os2ec (&sk.E.G, mpi_g);
      if (rc)
        goto leave;
    }
  /* Add missing parameters using the optional curve parameter.  */
  sexp_release (l1);
  l1 = sexp_find_token (keyparms, ""curve"", 5);
  if (l1)
    {
      curvename = sexp_nth_string (l1, 1);
      if (curvename)
        {
          rc = _gcry_ecc_fill_in_curve (0, curvename, &sk.E, NULL);
          if (rc)
            goto leave;
        }
    }
  /* Guess required fields if a curve parameter has not been given.  */
  if (!curvename)
    {
      sk.E.model = MPI_EC_WEIERSTRASS;
      sk.E.dialect = ECC_DIALECT_STANDARD;
      if (!sk.E.h)
	sk.E.h = mpi_const (MPI_C_ONE);
    }
  if (DBG_CIPHER)
    {
      log_debug (""ecc_decrypt info: %s/%s\n"",
                 _gcry_ecc_model2str (sk.E.model),
                 _gcry_ecc_dialect2str (sk.E.dialect));
      if (sk.E.name)
        log_debug  (""ecc_decrypt name: %s\n"", sk.E.name);
      log_printmpi (""ecc_decrypt    p"", sk.E.p);
      log_printmpi (""ecc_decrypt    a"", sk.E.a);
      log_printmpi (""ecc_decrypt    b"", sk.E.b);
      log_printpnt (""ecc_decrypt  g"",   &sk.E.G, NULL);
      log_printmpi (""ecc_decrypt    n"", sk.E.n);
      log_printmpi (""ecc_decrypt    h"", sk.E.h);
      if (!fips_mode ())
        log_printmpi (""ecc_decrypt    d"", sk.d);
    }
  if (!sk.E.p || !sk.E.a || !sk.E.b || !sk.E.G.x || !sk.E.n || !sk.E.h || !sk.d)
    {
      rc = GPG_ERR_NO_OBJ;
      goto leave;
    }


  ec = _gcry_mpi_ec_p_internal_new (sk.E.model, sk.E.dialect, flags,
                                    sk.E.p, sk.E.a, sk.E.b);

  /*
   * Compute the plaintext.
   */
  if (ec->model == MPI_EC_MONTGOMERY)
    rc = _gcry_ecc_mont_decodepoint (data_e, ec, &kG);
  else
    rc = _gcry_ecc_os2ec (&kG, data_e);
  if (rc)
    goto leave;

   if (DBG_CIPHER)
     log_printpnt (""ecc_decrypt    kG"", &kG, NULL);
 
  if (!(flags & PUBKEY_FLAG_DJB_TWEAK)
       /* For X25519, by its definition, validation should not be done.  */
      && !_gcry_mpi_ec_curve_point (&kG, ec))
     {
       rc = GPG_ERR_INV_DATA;
       goto leave;
      y = mpi_new (0);

    if (_gcry_mpi_ec_get_affine (x, y, &R, ec))
      {
        rc = GPG_ERR_INV_DATA;
        goto leave;
        /*
         * Note for X25519.
         *
         * By the definition of X25519, this is the case where X25519
         * returns 0, mapping infinity to zero.  However, we
         * deliberately let it return an error.
         *
         * For X25519 ECDH, comming here means that it might be
         * decrypted by anyone with the shared secret of 0 (the result
         * of this function could be always 0 by other scalar values,
         * other than the private key of SK.D).
         *
         * So, it looks like an encrypted message but it can be
         * decrypted by anyone, or at least something wrong
         * happens.  Recipient should not proceed as if it were
         * properly encrypted message.
         *
         * This handling is needed for our major usage of GnuPG,
         * where it does the One-Pass Diffie-Hellman method,
         * C(1, 1, ECC CDH), with an ephemeral key.
         */
      }

    if (y)
      r = _gcry_ecc_ec2os (x, y, sk.E.p);
    else
      {
        unsigned char *rawmpi;
        unsigned int rawmpilen;

        rawmpi = _gcry_mpi_get_buffer_extra (x, nbits/8, -1,
                                             &rawmpilen, NULL);
        if (!rawmpi)
          {
            rc = gpg_err_code_from_syserror ();
            goto leave;
          }
        else
          {
            rawmpi[0] = 0x40;
            rawmpilen++;
            r = mpi_new (0);
            mpi_set_opaque (r, rawmpi, rawmpilen*8);
          }
      }
    if (!r)
      rc = gpg_err_code_from_syserror ();
    else
      rc = 0;
    mpi_free (x);
    mpi_free (y);
  }
  if (DBG_CIPHER)
    log_printmpi (""ecc_decrypt  res"", r);

  if (!rc)
    rc = sexp_build (r_plain, NULL, ""(value %m)"", r);

 leave:
  point_free (&R);
  point_free (&kG);
  _gcry_mpi_release (r);
  _gcry_mpi_release (sk.E.p);
  _gcry_mpi_release (sk.E.a);
  _gcry_mpi_release (sk.E.b);
  _gcry_mpi_release (mpi_g);
  point_free (&sk.E.G);
  _gcry_mpi_release (sk.E.n);
  _gcry_mpi_release (sk.E.h);
  _gcry_mpi_release (sk.d);
  _gcry_mpi_release (data_e);
  xfree (curvename);
  sexp_release (l1);
  _gcry_mpi_ec_free (ec);
  _gcry_pk_util_free_encoding_ctx (&ctx);
  if (DBG_CIPHER)
    log_debug (""ecc_decrypt    => %s\n"", gpg_strerror (rc));
  return rc;
}
","ecc_decrypt_raw (gcry_sexp_t *r_plain, gcry_sexp_t s_data, gcry_sexp_t keyparms)
{
  unsigned int nbits;
  gpg_err_code_t rc;
  struct pk_encoding_ctx ctx;
  gcry_sexp_t l1 = NULL;
  gcry_mpi_t data_e = NULL;
  ECC_secret_key sk;
  gcry_mpi_t mpi_g = NULL;
  char *curvename = NULL;
  mpi_ec_t ec = NULL;
  mpi_point_struct kG;
  mpi_point_struct R;
  gcry_mpi_t r = NULL;
  int flags = 0;

  memset (&sk, 0, sizeof sk);
  point_init (&kG);
  point_init (&R);

  _gcry_pk_util_init_encoding_ctx (&ctx, PUBKEY_OP_DECRYPT,
                                   (nbits = ecc_get_nbits (keyparms)));

  /* Look for flags. */
  l1 = sexp_find_token (keyparms, ""flags"", 0);
  if (l1)
    {
      rc = _gcry_pk_util_parse_flaglist (l1, &flags, NULL);
      if (rc)
        goto leave;
    }
  sexp_release (l1);
  l1 = NULL;

  /*
   * Extract the data.
   */
  rc = _gcry_pk_util_preparse_encval (s_data, ecc_names, &l1, &ctx);
  if (rc)
    goto leave;
  rc = sexp_extract_param (l1, NULL, ""e"", &data_e, NULL);
  if (rc)
    goto leave;
  if (DBG_CIPHER)
    log_printmpi (""ecc_decrypt  d_e"", data_e);
  if (mpi_is_opaque (data_e))
    {
      rc = GPG_ERR_INV_DATA;
      goto leave;
    }

  /*
   * Extract the key.
   */
  rc = sexp_extract_param (keyparms, NULL, ""-p?a?b?g?n?h?+d"",
                           &sk.E.p, &sk.E.a, &sk.E.b, &mpi_g, &sk.E.n,
                           &sk.E.h, &sk.d, NULL);
  if (rc)
    goto leave;
  if (mpi_g)
    {
      point_init (&sk.E.G);
      rc = _gcry_ecc_os2ec (&sk.E.G, mpi_g);
      if (rc)
        goto leave;
    }
  /* Add missing parameters using the optional curve parameter.  */
  sexp_release (l1);
  l1 = sexp_find_token (keyparms, ""curve"", 5);
  if (l1)
    {
      curvename = sexp_nth_string (l1, 1);
      if (curvename)
        {
          rc = _gcry_ecc_fill_in_curve (0, curvename, &sk.E, NULL);
          if (rc)
            goto leave;
        }
    }
  /* Guess required fields if a curve parameter has not been given.  */
  if (!curvename)
    {
      sk.E.model = MPI_EC_WEIERSTRASS;
      sk.E.dialect = ECC_DIALECT_STANDARD;
      if (!sk.E.h)
	sk.E.h = mpi_const (MPI_C_ONE);
    }
  if (DBG_CIPHER)
    {
      log_debug (""ecc_decrypt info: %s/%s\n"",
                 _gcry_ecc_model2str (sk.E.model),
                 _gcry_ecc_dialect2str (sk.E.dialect));
      if (sk.E.name)
        log_debug  (""ecc_decrypt name: %s\n"", sk.E.name);
      log_printmpi (""ecc_decrypt    p"", sk.E.p);
      log_printmpi (""ecc_decrypt    a"", sk.E.a);
      log_printmpi (""ecc_decrypt    b"", sk.E.b);
      log_printpnt (""ecc_decrypt  g"",   &sk.E.G, NULL);
      log_printmpi (""ecc_decrypt    n"", sk.E.n);
      log_printmpi (""ecc_decrypt    h"", sk.E.h);
      if (!fips_mode ())
        log_printmpi (""ecc_decrypt    d"", sk.d);
    }
  if (!sk.E.p || !sk.E.a || !sk.E.b || !sk.E.G.x || !sk.E.n || !sk.E.h || !sk.d)
    {
      rc = GPG_ERR_NO_OBJ;
      goto leave;
    }


  ec = _gcry_mpi_ec_p_internal_new (sk.E.model, sk.E.dialect, flags,
                                    sk.E.p, sk.E.a, sk.E.b);

  /*
   * Compute the plaintext.
   */
  if (ec->model == MPI_EC_MONTGOMERY)
    rc = _gcry_ecc_mont_decodepoint (data_e, ec, &kG);
  else
    rc = _gcry_ecc_os2ec (&kG, data_e);
  if (rc)
    goto leave;

   if (DBG_CIPHER)
     log_printpnt (""ecc_decrypt    kG"", &kG, NULL);
 
  if ((flags & PUBKEY_FLAG_DJB_TWEAK))
    {
       /* For X25519, by its definition, validation should not be done.  */
      /* (Instead, we do output check.)
       *
       * However, to mitigate secret key leak from our implementation,
       * we also do input validation here.  For constant-time
       * implementation, we can remove this input validation.
       */
      if (_gcry_mpi_ec_bad_point (&kG, ec))
        {
          rc = GPG_ERR_INV_DATA;
          goto leave;
        }
    }
  else if (!_gcry_mpi_ec_curve_point (&kG, ec))
     {
       rc = GPG_ERR_INV_DATA;
       goto leave;
      y = mpi_new (0);

    if (_gcry_mpi_ec_get_affine (x, y, &R, ec))
      {
        rc = GPG_ERR_INV_DATA;
        goto leave;
        /*
         * Note for X25519.
         *
         * By the definition of X25519, this is the case where X25519
         * returns 0, mapping infinity to zero.  However, we
         * deliberately let it return an error.
         *
         * For X25519 ECDH, comming here means that it might be
         * decrypted by anyone with the shared secret of 0 (the result
         * of this function could be always 0 by other scalar values,
         * other than the private key of SK.D).
         *
         * So, it looks like an encrypted message but it can be
         * decrypted by anyone, or at least something wrong
         * happens.  Recipient should not proceed as if it were
         * properly encrypted message.
         *
         * This handling is needed for our major usage of GnuPG,
         * where it does the One-Pass Diffie-Hellman method,
         * C(1, 1, ECC CDH), with an ephemeral key.
         */
      }

    if (y)
      r = _gcry_ecc_ec2os (x, y, sk.E.p);
    else
      {
        unsigned char *rawmpi;
        unsigned int rawmpilen;

        rawmpi = _gcry_mpi_get_buffer_extra (x, nbits/8, -1,
                                             &rawmpilen, NULL);
        if (!rawmpi)
          {
            rc = gpg_err_code_from_syserror ();
            goto leave;
          }
        else
          {
            rawmpi[0] = 0x40;
            rawmpilen++;
            r = mpi_new (0);
            mpi_set_opaque (r, rawmpi, rawmpilen*8);
          }
      }
    if (!r)
      rc = gpg_err_code_from_syserror ();
    else
      rc = 0;
    mpi_free (x);
    mpi_free (y);
  }
  if (DBG_CIPHER)
    log_printmpi (""ecc_decrypt  res"", r);

  if (!rc)
    rc = sexp_build (r_plain, NULL, ""(value %m)"", r);

 leave:
  point_free (&R);
  point_free (&kG);
  _gcry_mpi_release (r);
  _gcry_mpi_release (sk.E.p);
  _gcry_mpi_release (sk.E.a);
  _gcry_mpi_release (sk.E.b);
  _gcry_mpi_release (mpi_g);
  point_free (&sk.E.G);
  _gcry_mpi_release (sk.E.n);
  _gcry_mpi_release (sk.E.h);
  _gcry_mpi_release (sk.d);
  _gcry_mpi_release (data_e);
  xfree (curvename);
  sexp_release (l1);
  _gcry_mpi_ec_free (ec);
  _gcry_pk_util_free_encoding_ctx (&ctx);
  if (DBG_CIPHER)
    log_debug (""ecc_decrypt    => %s\n"", gpg_strerror (rc));
  return rc;
}
","The `ecc_decrypt_raw` function is designed to perform decryption of elliptic curve cryptography (ECC) encoded data using a specified private key. It initializes necessary structures and extracts parameters from the provided key and data, including curve parameters and the encrypted value. The function checks for validity of the extracted data and computes the plaintext by decoding the elliptic curve point. It handles various curve types, ensuring that the decryption adheres to ECC standards. Finally, it constructs the decrypted output and cleans up allocated resources, returning an error code or success status based on the operation's outcome.","The provided code implements a decryption process for data encoded using elliptic curve cryptography. It initializes necessary structures and extracts parameters from the input data and key, including curve specifications and the encrypted value. The code validates the extracted data, computes the corresponding plaintext by decoding the elliptic curve point, and ensures compliance with cryptographic standards. It handles different curve types and manages memory efficiently, cleaning up resources after execution. The function ultimately returns a status indicating success or failure, along with the decrypted output if successful.","The vulnerability in the original code stemmed from insufficient validation of the elliptic curve point derived from the decrypted data, which could allow an attacker to exploit invalid points, potentially leading to a secret key leak. In the fixed code, additional validation checks were introduced, specifically for the case where a certain flag is set. The function now verifies whether the derived point is valid using a dedicated validation function. This ensures that only legitimate points are processed, thereby mitigating the risk of accepting invalid data that could compromise the security of the decryption process.","The vulnerability in the original code arose from inadequate validation of the elliptic curve points derived during the decryption process, which could allow attackers to exploit invalid points and potentially leak sensitive information. In the revised code, additional checks were implemented to ensure that the derived points are valid before proceeding with further operations. This enhancement includes specific validation for certain conditions, effectively preventing the acceptance of invalid data. As a result, the security of the decryption process is strengthened, reducing the risk of unauthorized access to sensitive cryptographic keys.","The vulnerability was fixed by introducing additional validation checks for the elliptic curve point derived from the decrypted data. Specifically, the code now checks if the derived point is valid using the function that verifies whether the point is a valid curve point. If the point fails this validation, an error code is returned, preventing further processing of potentially malicious data. Additionally, for cases where a specific flag is set, a different validation function is employed to ensure that the input point does not lead to a secret key leak, thereby enhancing the overall security of the decryption process.","The vulnerability was addressed by implementing stricter validation checks for the elliptic curve points generated during the decryption process. The revised code ensures that any derived points are thoroughly verified before further processing, effectively preventing the acceptance of invalid or potentially malicious data. Additionally, specific conditions were introduced to handle cases where certain flags are set, allowing for tailored validation that mitigates the risk of secret key exposure. These enhancements collectively strengthen the security of the decryption process, reducing the likelihood of exploitation through invalid input.","4, 4","5, 5","4,4","3,4"
23,23,178426,178426,,Local,Not required,,CVE-2016-0702,https://www.cvedetails.com/cve/CVE-2016-0702/,CWE-200,Medium,Partial,,,2016-03-03,1.9,"The MOD_EXP_CTIME_COPY_FROM_PREBUF function in crypto/bn/bn_exp.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not properly consider cache-bank access times during modular exponentiation, which makes it easier for local users to discover RSA keys by running a crafted application on the same Intel Sandy Bridge CPU core as a victim and leveraging cache-bank conflicts, aka a ""CacheBleed"" attack.",2018-01-04,+Info,56,https://git.openssl.org/?p=openssl.git;a=commit;h=708dc2f1291e104fe4eef810bb8ffc1fae5b19c1,708dc2f1291e104fe4eef810bb8ffc1fae5b19c1,,18,,," static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top,
                                         unsigned char *buf, int idx,
                                        int window)
 {
    int i, j;
    int width = 1 << window;
    BN_ULONG *table = (BN_ULONG *)buf;
 
     if (top > b->top)
         top = b->top;           /* this works because 'buf' is explicitly
                                  * zeroed */
    for (i = 0, j = idx; i < top; i++, j += width) {
        table[j] = b->d[i];
     }
 
     return 1;
                                          unsigned char *buf, int idx,
 
 static int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top,
                                           unsigned char *buf, int idx,
                                          int window)
 {
    int i, j;
    int width = 1 << window;
    volatile BN_ULONG *table = (volatile BN_ULONG *)buf;
 
     if (bn_wexpand(b, top) == NULL)
         return 0;
 
    if (window <= 3) {
        for (i = 0; i < top; i++, table += width) {
            BN_ULONG acc = 0;

            for (j = 0; j < width; j++) {
                acc |= table[j] &
                       ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));
            }

            b->d[i] = acc;
        }
    } else {
        int xstride = 1 << (window - 2);
        BN_ULONG y0, y1, y2, y3;

        i = idx >> (window - 2);        /* equivalent of idx / xstride */
        idx &= xstride - 1;             /* equivalent of idx % xstride */

        y0 = (BN_ULONG)0 - (constant_time_eq_int(i,0)&1);
        y1 = (BN_ULONG)0 - (constant_time_eq_int(i,1)&1);
        y2 = (BN_ULONG)0 - (constant_time_eq_int(i,2)&1);
        y3 = (BN_ULONG)0 - (constant_time_eq_int(i,3)&1);

        for (i = 0; i < top; i++, table += width) {
            BN_ULONG acc = 0;

            for (j = 0; j < xstride; j++) {
                acc |= ( (table[j + 0 * xstride] & y0) |
                         (table[j + 1 * xstride] & y1) |
                         (table[j + 2 * xstride] & y2) |
                         (table[j + 3 * xstride] & y3) )
                       & ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));
            }

            b->d[i] = acc;
        }
     }
 
     b->top = top;
    if (!BN_is_odd(m)) {
        BNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME, BN_R_CALLED_WITH_EVEN_MODULUS);
        return (0);
    }

    top = m->top;

    bits = BN_num_bits(p);
    if (bits == 0) {
        /* x**0 mod 1 is still zero. */
        if (BN_is_one(m)) {
            ret = 1;
            BN_zero(rr);
        } else {
            ret = BN_one(rr);
        }
        return ret;
    }

    BN_CTX_start(ctx);

    /*
     * Allocate a montgomery context if it was not supplied by the caller. If
     * this is not done, things will break in the montgomery part.
     */
    if (in_mont != NULL)
        mont = in_mont;
    else {
        if ((mont = BN_MONT_CTX_new()) == NULL)
            goto err;
        if (!BN_MONT_CTX_set(mont, m, ctx))
            goto err;
    }

#ifdef RSAZ_ENABLED
    /*
     * If the size of the operands allow it, perform the optimized
     * RSAZ exponentiation. For further information see
     * crypto/bn/rsaz_exp.c and accompanying assembly modules.
     */
    if ((16 == a->top) && (16 == p->top) && (BN_num_bits(m) == 1024)
        && rsaz_avx2_eligible()) {
        if (NULL == bn_wexpand(rr, 16))
            goto err;
        RSAZ_1024_mod_exp_avx2(rr->d, a->d, p->d, m->d, mont->RR.d,
                               mont->n0[0]);
        rr->top = 16;
        rr->neg = 0;
        bn_correct_top(rr);
        ret = 1;
        goto err;
    } else if ((8 == a->top) && (8 == p->top) && (BN_num_bits(m) == 512)) {
        if (NULL == bn_wexpand(rr, 8))
            goto err;
        RSAZ_512_mod_exp(rr->d, a->d, p->d, m->d, mont->n0[0], mont->RR.d);
        rr->top = 8;
        rr->neg = 0;
        bn_correct_top(rr);
        ret = 1;
        goto err;
    }
#endif

    /* Get the window size to use with size of p. */
    window = BN_window_bits_for_ctime_exponent_size(bits);
#if defined(SPARC_T4_MONT)
    if (window >= 5 && (top & 15) == 0 && top <= 64 &&
        (OPENSSL_sparcv9cap_P[1] & (CFR_MONTMUL | CFR_MONTSQR)) ==
        (CFR_MONTMUL | CFR_MONTSQR) && (t4 = OPENSSL_sparcv9cap_P[0]))
        window = 5;
    else
#endif
#if defined(OPENSSL_BN_ASM_MONT5)
    if (window >= 5) {
        window = 5;             /* ~5% improvement for RSA2048 sign, and even
                                 * for RSA4096 */
        if ((top & 7) == 0)
            powerbufLen += 2 * top * sizeof(m->d[0]);
    }
#endif
    (void)0;

    /*
     * Allocate a buffer large enough to hold all of the pre-computed powers
     * of am, am itself and tmp.
     */
    numPowers = 1 << window;
    powerbufLen += sizeof(m->d[0]) * (top * numPowers +
                                      ((2 * top) >
                                       numPowers ? (2 * top) : numPowers));
#ifdef alloca
    if (powerbufLen < 3072)
        powerbufFree =
            alloca(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH);
    else
#endif
        if ((powerbufFree =
             (unsigned char *)OPENSSL_malloc(powerbufLen +
                                             MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH))
            == NULL)
        goto err;

    powerbuf = MOD_EXP_CTIME_ALIGN(powerbufFree);
    memset(powerbuf, 0, powerbufLen);

#ifdef alloca
    if (powerbufLen < 3072)
        powerbufFree = NULL;
#endif

    /* lay down tmp and am right after powers table */
    tmp.d = (BN_ULONG *)(powerbuf + sizeof(m->d[0]) * top * numPowers);
    am.d = tmp.d + top;
    tmp.top = am.top = 0;
    tmp.dmax = am.dmax = top;
    tmp.neg = am.neg = 0;
    tmp.flags = am.flags = BN_FLG_STATIC_DATA;

    /* prepare a^0 in Montgomery domain */
#if 1                           /* by Shay Gueron's suggestion */
    if (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {
        /* 2^(top*BN_BITS2) - m */
        tmp.d[0] = (0 - m->d[0]) & BN_MASK2;
        for (i = 1; i < top; i++)
            tmp.d[i] = (~m->d[i]) & BN_MASK2;
        tmp.top = top;
    } else
#endif
    if (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))
        goto err;

    /* prepare a^1 in Montgomery domain */
    if (a->neg || BN_ucmp(a, m) >= 0) {
        if (!BN_mod(&am, a, m, ctx))
            goto err;
        if (!BN_to_montgomery(&am, &am, mont, ctx))
            goto err;
    } else if (!BN_to_montgomery(&am, a, mont, ctx))
        goto err;

#if defined(SPARC_T4_MONT)
    if (t4) {
        typedef int (*bn_pwr5_mont_f) (BN_ULONG *tp, const BN_ULONG *np,
                                       const BN_ULONG *n0, const void *table,
                                       int power, int bits);
        int bn_pwr5_mont_t4_8(BN_ULONG *tp, const BN_ULONG *np,
                              const BN_ULONG *n0, const void *table,
                              int power, int bits);
        int bn_pwr5_mont_t4_16(BN_ULONG *tp, const BN_ULONG *np,
                               const BN_ULONG *n0, const void *table,
                               int power, int bits);
        int bn_pwr5_mont_t4_24(BN_ULONG *tp, const BN_ULONG *np,
                               const BN_ULONG *n0, const void *table,
                               int power, int bits);
        int bn_pwr5_mont_t4_32(BN_ULONG *tp, const BN_ULONG *np,
                               const BN_ULONG *n0, const void *table,
                               int power, int bits);
        static const bn_pwr5_mont_f pwr5_funcs[4] = {
            bn_pwr5_mont_t4_8, bn_pwr5_mont_t4_16,
            bn_pwr5_mont_t4_24, bn_pwr5_mont_t4_32
        };
        bn_pwr5_mont_f pwr5_worker = pwr5_funcs[top / 16 - 1];

        typedef int (*bn_mul_mont_f) (BN_ULONG *rp, const BN_ULONG *ap,
                                      const void *bp, const BN_ULONG *np,
                                      const BN_ULONG *n0);
        int bn_mul_mont_t4_8(BN_ULONG *rp, const BN_ULONG *ap, const void *bp,
                             const BN_ULONG *np, const BN_ULONG *n0);
        int bn_mul_mont_t4_16(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0);
        int bn_mul_mont_t4_24(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0);
        int bn_mul_mont_t4_32(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0);
        static const bn_mul_mont_f mul_funcs[4] = {
            bn_mul_mont_t4_8, bn_mul_mont_t4_16,
            bn_mul_mont_t4_24, bn_mul_mont_t4_32
        };
        bn_mul_mont_f mul_worker = mul_funcs[top / 16 - 1];

        void bn_mul_mont_vis3(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0, int num);
        void bn_mul_mont_t4(BN_ULONG *rp, const BN_ULONG *ap,
                            const void *bp, const BN_ULONG *np,
                            const BN_ULONG *n0, int num);
        void bn_mul_mont_gather5_t4(BN_ULONG *rp, const BN_ULONG *ap,
                                    const void *table, const BN_ULONG *np,
                                    const BN_ULONG *n0, int num, int power);
        void bn_flip_n_scatter5_t4(const BN_ULONG *inp, size_t num,
                                   void *table, size_t power);
        void bn_gather5_t4(BN_ULONG *out, size_t num,
                           void *table, size_t power);
        void bn_flip_t4(BN_ULONG *dst, BN_ULONG *src, size_t num);

        BN_ULONG *np = mont->N.d, *n0 = mont->n0;
        int stride = 5 * (6 - (top / 16 - 1)); /* multiple of 5, but less
                                                * than 32 */

        /*
         * BN_to_montgomery can contaminate words above .top [in
         * BN_DEBUG[_DEBUG] build]...
         */
        for (i = am.top; i < top; i++)
            am.d[i] = 0;
        for (i = tmp.top; i < top; i++)
            tmp.d[i] = 0;

        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 0);
        bn_flip_n_scatter5_t4(am.d, top, powerbuf, 1);
        if (!(*mul_worker) (tmp.d, am.d, am.d, np, n0) &&
            !(*mul_worker) (tmp.d, am.d, am.d, np, n0))
            bn_mul_mont_vis3(tmp.d, am.d, am.d, np, n0, top);
        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 2);

        for (i = 3; i < 32; i++) {
            /* Calculate a^i = a^(i-1) * a */
            if (!(*mul_worker) (tmp.d, tmp.d, am.d, np, n0) &&
                !(*mul_worker) (tmp.d, tmp.d, am.d, np, n0))
                bn_mul_mont_vis3(tmp.d, tmp.d, am.d, np, n0, top);
            bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, i);
        }

        /* switch to 64-bit domain */
        np = alloca(top * sizeof(BN_ULONG));
        top /= 2;
        bn_flip_t4(np, mont->N.d, top);

        bits--;
        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)
            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
        bn_gather5_t4(tmp.d, top, powerbuf, wvalue);

        /*
         * Scan the exponent one window at a time starting from the most
         * significant bits.
         */
        while (bits >= 0) {
            if (bits < stride)
                stride = bits + 1;
            bits -= stride;
            wvalue = bn_get_bits(p, bits + 1);

            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))
                continue;
            /* retry once and fall back */
            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))
                continue;

            bits += stride - 5;
            wvalue >>= stride - 5;
            wvalue &= 31;
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_gather5_t4(tmp.d, tmp.d, powerbuf, np, n0, top,
                                   wvalue);
        }

        bn_flip_t4(tmp.d, tmp.d, top);
        top *= 2;
        /* back to 32-bit domain */
        tmp.top = top;
        bn_correct_top(&tmp);
        OPENSSL_cleanse(np, top * sizeof(BN_ULONG));
    } else
#endif
#if defined(OPENSSL_BN_ASM_MONT5)
    if (window == 5 && top > 1) {
        /*
         * This optimization uses ideas from http://eprint.iacr.org/2011/239,
         * specifically optimization of cache-timing attack countermeasures
         * and pre-computation optimization.
         */

        /*
         * Dedicated window==4 case improves 512-bit RSA sign by ~15%, but as
         * 512-bit RSA is hardly relevant, we omit it to spare size...
         */
        void bn_mul_mont_gather5(BN_ULONG *rp, const BN_ULONG *ap,
                                 const void *table, const BN_ULONG *np,
                                 const BN_ULONG *n0, int num, int power);
        void bn_scatter5(const BN_ULONG *inp, size_t num,
                         void *table, size_t power);
        void bn_gather5(BN_ULONG *out, size_t num, void *table, size_t power);
        void bn_power5(BN_ULONG *rp, const BN_ULONG *ap,
                       const void *table, const BN_ULONG *np,
                       const BN_ULONG *n0, int num, int power);
        int bn_get_bits5(const BN_ULONG *ap, int off);
        int bn_from_montgomery(BN_ULONG *rp, const BN_ULONG *ap,
                               const BN_ULONG *not_used, const BN_ULONG *np,
                               const BN_ULONG *n0, int num);

        BN_ULONG *np = mont->N.d, *n0 = mont->n0, *np2;

        /*
         * BN_to_montgomery can contaminate words above .top [in
         * BN_DEBUG[_DEBUG] build]...
         */
        for (i = am.top; i < top; i++)
            am.d[i] = 0;
        for (i = tmp.top; i < top; i++)
            tmp.d[i] = 0;

        if (top & 7)
            np2 = np;
        else
            for (np2 = am.d + top, i = 0; i < top; i++)
                np2[2 * i] = np[i];

        bn_scatter5(tmp.d, top, powerbuf, 0);
        bn_scatter5(am.d, am.top, powerbuf, 1);
        bn_mul_mont(tmp.d, am.d, am.d, np, n0, top);
        bn_scatter5(tmp.d, top, powerbuf, 2);

# if 0
        for (i = 3; i < 32; i++) {
            /* Calculate a^i = a^(i-1) * a */
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
        }
# else
        /* same as above, but uses squaring for 1/2 of operations */
        for (i = 4; i < 32; i *= 2) {
            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_scatter5(tmp.d, top, powerbuf, i);
        }
        for (i = 3; i < 8; i += 2) {
            int j;
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
            for (j = 2 * i; j < 32; j *= 2) {
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_scatter5(tmp.d, top, powerbuf, j);
            }
        }
        for (; i < 16; i += 2) {
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_scatter5(tmp.d, top, powerbuf, 2 * i);
        }
        for (; i < 32; i += 2) {
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
        }
# endif
        bits--;
        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)
            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
        bn_gather5(tmp.d, top, powerbuf, wvalue);

        /*
         * Scan the exponent one window at a time starting from the most
         * significant bits.
         */
        if (top & 7)
            while (bits >= 0) {
                for (wvalue = 0, i = 0; i < 5; i++, bits--)
                    wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);

                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont_gather5(tmp.d, tmp.d, powerbuf, np, n0, top,
                                    wvalue);
        } else {
            while (bits >= 0) {
                wvalue = bn_get_bits5(p->d, bits - 4);
                bits -= 5;
                bn_power5(tmp.d, tmp.d, powerbuf, np2, n0, top, wvalue);
            }
        }

        ret = bn_from_montgomery(tmp.d, tmp.d, NULL, np2, n0, top);
        tmp.top = top;
        bn_correct_top(&tmp);
        if (ret) {
            if (!BN_copy(rr, &tmp))
                ret = 0;
            goto err;           /* non-zero ret means it's not error */
        }
    } else
#endif
    {
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers))
            goto err;
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, numPowers))
            goto err;

        /*
         * If the window size is greater than 1, then calculate
         * val[i=2..2^winsize-1]. Powers are computed as a*a^(i-1) (even
         * powers could instead be computed as (a^(i/2))^2 to use the slight
         * performance advantage of sqr over mul).
         */
        if (window > 1) {
            if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))
                goto err;
            if (!MOD_EXP_CTIME_COPY_TO_PREBUF
                (&tmp, top, powerbuf, 2, numPowers))
                goto err;
            for (i = 3; i < numPowers; i++) {
                /* Calculate a^i = a^(i-1) * a */
                if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))
                    goto err;
                if (!MOD_EXP_CTIME_COPY_TO_PREBUF
                    (&tmp, top, powerbuf, i, numPowers))
                    goto err;
            }
        }

        bits--;
        for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)
            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF
            (&tmp, top, powerbuf, wvalue, numPowers))
            goto err;

        /*
         * Scan the exponent one window at a time starting from the most
     } else
 #endif
     {
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, window))
             goto err;
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, window))
             goto err;
 
         /*
                wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
            }

            /*
             * Fetch the appropriate pre-computed value from the pre-buf
         if (window > 1) {
             if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))
                 goto err;
            if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 2,
                                              window))
                 goto err;
             for (i = 3; i < numPowers; i++) {
                 /* Calculate a^i = a^(i-1) * a */
                 if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))
                     goto err;
                if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, i,
                                                  window))
                     goto err;
             }
         }
        for (i = 1; i < top; i++)
         bits--;
         for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)
             wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&tmp, top, powerbuf, wvalue,
                                            window))
             goto err;
 
         /*
 err:
    if ((in_mont == NULL) && (mont != NULL))
        BN_MONT_CTX_free(mont);
    if (powerbuf != NULL) {
        OPENSSL_cleanse(powerbuf, powerbufLen);
        if (powerbufFree)
            OPENSSL_free(powerbufFree);
    }
    BN_CTX_end(ctx);
    return (ret);
}

int BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p,
             /*
              * Fetch the appropriate pre-computed value from the pre-buf
              */
            if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&am, top, powerbuf, wvalue,
                                                window))
                 goto err;
 
             /* Multiply the result into the intermediate result */
#define BN_MOD_MUL_WORD(r, w, m) \
                (BN_mul_word(r, (w)) && \
                (/* BN_ucmp(r, (m)) < 0 ? 1 :*/  \
                        (BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1))))
    /*
     * BN_MOD_MUL_WORD is only used with 'w' large, so the BN_ucmp test is
     * probably more overhead than always using BN_mod (which uses BN_copy if
     * a similar test returns true).
     */
    /*
     * We can use BN_mod and do not need BN_nnmod because our accumulator is
     * never negative (the result of BN_mod does not depend on the sign of
     * the modulus).
     */
#define BN_TO_MONTGOMERY_WORD(r, w, mont) \
                (BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx))

    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {
        /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */
        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return -1;
    }

    bn_check_top(p);
    bn_check_top(m);

    if (!BN_is_odd(m)) {
        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS);
        return (0);
    }
    if (m->top == 1)
        a %= m->d[0];           /* make sure that 'a' is reduced */

    bits = BN_num_bits(p);
    if (bits == 0) {
        /* x**0 mod 1 is still zero. */
        if (BN_is_one(m)) {
            ret = 1;
            BN_zero(rr);
        } else {
            ret = BN_one(rr);
        }
        return ret;
    }
    if (a == 0) {
        BN_zero(rr);
        ret = 1;
        return ret;
    }

    BN_CTX_start(ctx);
    d = BN_CTX_get(ctx);
    r = BN_CTX_get(ctx);
    t = BN_CTX_get(ctx);
    if (d == NULL || r == NULL || t == NULL)
        goto err;

    if (in_mont != NULL)
        mont = in_mont;
    else {
        if ((mont = BN_MONT_CTX_new()) == NULL)
            goto err;
        if (!BN_MONT_CTX_set(mont, m, ctx))
            goto err;
    }

    r_is_one = 1;               /* except for Montgomery factor */

    /* bits-1 >= 0 */

    /* The result is accumulated in the product r*w. */
    w = a;                      /* bit 'bits-1' of 'p' is always set */
    for (b = bits - 2; b >= 0; b--) {
        /* First, square r*w. */
        next_w = w * w;
        if ((next_w / w) != w) { /* overflow */
            if (r_is_one) {
                if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
                    goto err;
                r_is_one = 0;
            } else {
                if (!BN_MOD_MUL_WORD(r, w, m))
                    goto err;
            }
            next_w = 1;
        }
        w = next_w;
        if (!r_is_one) {
            if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))
                goto err;
        }

        /* Second, multiply r*w by 'a' if exponent bit is set. */
        if (BN_is_bit_set(p, b)) {
            next_w = w * a;
            if ((next_w / a) != w) { /* overflow */
                if (r_is_one) {
                    if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
                        goto err;
                    r_is_one = 0;
                } else {
                    if (!BN_MOD_MUL_WORD(r, w, m))
                        goto err;
                }
                next_w = a;
            }
            w = next_w;
        }
    }

    /* Finally, set r:=r*w. */
    if (w != 1) {
        if (r_is_one) {
            if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
                goto err;
            r_is_one = 0;
        } else {
            if (!BN_MOD_MUL_WORD(r, w, m))
                goto err;
        }
    }

    if (r_is_one) {             /* can happen only if a == 1 */
        if (!BN_one(rr))
            goto err;
    } else {
        if (!BN_from_montgomery(rr, r, mont, ctx))
            goto err;
    }
    ret = 1;
 err:
    if ((in_mont == NULL) && (mont != NULL))
        BN_MONT_CTX_free(mont);
    BN_CTX_end(ctx);
    bn_check_top(rr);
    return (ret);
}
"," static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top,
                                         unsigned char *buf, int idx,
                                        int width)
 {
    size_t i, j;
 
     if (top > b->top)
         top = b->top;           /* this works because 'buf' is explicitly
                                  * zeroed */
    for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {
        buf[j] = ((unsigned char *)b->d)[i];
     }
 
     return 1;
                                          unsigned char *buf, int idx,
 
 static int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top,
                                           unsigned char *buf, int idx,
                                          int width)
 {
    size_t i, j;
 
     if (bn_wexpand(b, top) == NULL)
         return 0;
 
    for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {
        ((unsigned char *)b->d)[i] = buf[j];
     }
 
     b->top = top;
    if (!BN_is_odd(m)) {
        BNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME, BN_R_CALLED_WITH_EVEN_MODULUS);
        return (0);
    }

    top = m->top;

    bits = BN_num_bits(p);
    if (bits == 0) {
        /* x**0 mod 1 is still zero. */
        if (BN_is_one(m)) {
            ret = 1;
            BN_zero(rr);
        } else {
            ret = BN_one(rr);
        }
        return ret;
    }

    BN_CTX_start(ctx);

    /*
     * Allocate a montgomery context if it was not supplied by the caller. If
     * this is not done, things will break in the montgomery part.
     */
    if (in_mont != NULL)
        mont = in_mont;
    else {
        if ((mont = BN_MONT_CTX_new()) == NULL)
            goto err;
        if (!BN_MONT_CTX_set(mont, m, ctx))
            goto err;
    }

#ifdef RSAZ_ENABLED
    /*
     * If the size of the operands allow it, perform the optimized
     * RSAZ exponentiation. For further information see
     * crypto/bn/rsaz_exp.c and accompanying assembly modules.
     */
    if ((16 == a->top) && (16 == p->top) && (BN_num_bits(m) == 1024)
        && rsaz_avx2_eligible()) {
        if (NULL == bn_wexpand(rr, 16))
            goto err;
        RSAZ_1024_mod_exp_avx2(rr->d, a->d, p->d, m->d, mont->RR.d,
                               mont->n0[0]);
        rr->top = 16;
        rr->neg = 0;
        bn_correct_top(rr);
        ret = 1;
        goto err;
    } else if ((8 == a->top) && (8 == p->top) && (BN_num_bits(m) == 512)) {
        if (NULL == bn_wexpand(rr, 8))
            goto err;
        RSAZ_512_mod_exp(rr->d, a->d, p->d, m->d, mont->n0[0], mont->RR.d);
        rr->top = 8;
        rr->neg = 0;
        bn_correct_top(rr);
        ret = 1;
        goto err;
    }
#endif

    /* Get the window size to use with size of p. */
    window = BN_window_bits_for_ctime_exponent_size(bits);
#if defined(SPARC_T4_MONT)
    if (window >= 5 && (top & 15) == 0 && top <= 64 &&
        (OPENSSL_sparcv9cap_P[1] & (CFR_MONTMUL | CFR_MONTSQR)) ==
        (CFR_MONTMUL | CFR_MONTSQR) && (t4 = OPENSSL_sparcv9cap_P[0]))
        window = 5;
    else
#endif
#if defined(OPENSSL_BN_ASM_MONT5)
    if (window >= 5) {
        window = 5;             /* ~5% improvement for RSA2048 sign, and even
                                 * for RSA4096 */
        if ((top & 7) == 0)
            powerbufLen += 2 * top * sizeof(m->d[0]);
    }
#endif
    (void)0;

    /*
     * Allocate a buffer large enough to hold all of the pre-computed powers
     * of am, am itself and tmp.
     */
    numPowers = 1 << window;
    powerbufLen += sizeof(m->d[0]) * (top * numPowers +
                                      ((2 * top) >
                                       numPowers ? (2 * top) : numPowers));
#ifdef alloca
    if (powerbufLen < 3072)
        powerbufFree =
            alloca(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH);
    else
#endif
        if ((powerbufFree =
             (unsigned char *)OPENSSL_malloc(powerbufLen +
                                             MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH))
            == NULL)
        goto err;

    powerbuf = MOD_EXP_CTIME_ALIGN(powerbufFree);
    memset(powerbuf, 0, powerbufLen);

#ifdef alloca
    if (powerbufLen < 3072)
        powerbufFree = NULL;
#endif

    /* lay down tmp and am right after powers table */
    tmp.d = (BN_ULONG *)(powerbuf + sizeof(m->d[0]) * top * numPowers);
    am.d = tmp.d + top;
    tmp.top = am.top = 0;
    tmp.dmax = am.dmax = top;
    tmp.neg = am.neg = 0;
    tmp.flags = am.flags = BN_FLG_STATIC_DATA;

    /* prepare a^0 in Montgomery domain */
#if 1                           /* by Shay Gueron's suggestion */
    if (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {
        /* 2^(top*BN_BITS2) - m */
        tmp.d[0] = (0 - m->d[0]) & BN_MASK2;
        for (i = 1; i < top; i++)
            tmp.d[i] = (~m->d[i]) & BN_MASK2;
        tmp.top = top;
    } else
#endif
    if (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))
        goto err;

    /* prepare a^1 in Montgomery domain */
    if (a->neg || BN_ucmp(a, m) >= 0) {
        if (!BN_mod(&am, a, m, ctx))
            goto err;
        if (!BN_to_montgomery(&am, &am, mont, ctx))
            goto err;
    } else if (!BN_to_montgomery(&am, a, mont, ctx))
        goto err;

#if defined(SPARC_T4_MONT)
    if (t4) {
        typedef int (*bn_pwr5_mont_f) (BN_ULONG *tp, const BN_ULONG *np,
                                       const BN_ULONG *n0, const void *table,
                                       int power, int bits);
        int bn_pwr5_mont_t4_8(BN_ULONG *tp, const BN_ULONG *np,
                              const BN_ULONG *n0, const void *table,
                              int power, int bits);
        int bn_pwr5_mont_t4_16(BN_ULONG *tp, const BN_ULONG *np,
                               const BN_ULONG *n0, const void *table,
                               int power, int bits);
        int bn_pwr5_mont_t4_24(BN_ULONG *tp, const BN_ULONG *np,
                               const BN_ULONG *n0, const void *table,
                               int power, int bits);
        int bn_pwr5_mont_t4_32(BN_ULONG *tp, const BN_ULONG *np,
                               const BN_ULONG *n0, const void *table,
                               int power, int bits);
        static const bn_pwr5_mont_f pwr5_funcs[4] = {
            bn_pwr5_mont_t4_8, bn_pwr5_mont_t4_16,
            bn_pwr5_mont_t4_24, bn_pwr5_mont_t4_32
        };
        bn_pwr5_mont_f pwr5_worker = pwr5_funcs[top / 16 - 1];

        typedef int (*bn_mul_mont_f) (BN_ULONG *rp, const BN_ULONG *ap,
                                      const void *bp, const BN_ULONG *np,
                                      const BN_ULONG *n0);
        int bn_mul_mont_t4_8(BN_ULONG *rp, const BN_ULONG *ap, const void *bp,
                             const BN_ULONG *np, const BN_ULONG *n0);
        int bn_mul_mont_t4_16(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0);
        int bn_mul_mont_t4_24(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0);
        int bn_mul_mont_t4_32(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0);
        static const bn_mul_mont_f mul_funcs[4] = {
            bn_mul_mont_t4_8, bn_mul_mont_t4_16,
            bn_mul_mont_t4_24, bn_mul_mont_t4_32
        };
        bn_mul_mont_f mul_worker = mul_funcs[top / 16 - 1];

        void bn_mul_mont_vis3(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0, int num);
        void bn_mul_mont_t4(BN_ULONG *rp, const BN_ULONG *ap,
                            const void *bp, const BN_ULONG *np,
                            const BN_ULONG *n0, int num);
        void bn_mul_mont_gather5_t4(BN_ULONG *rp, const BN_ULONG *ap,
                                    const void *table, const BN_ULONG *np,
                                    const BN_ULONG *n0, int num, int power);
        void bn_flip_n_scatter5_t4(const BN_ULONG *inp, size_t num,
                                   void *table, size_t power);
        void bn_gather5_t4(BN_ULONG *out, size_t num,
                           void *table, size_t power);
        void bn_flip_t4(BN_ULONG *dst, BN_ULONG *src, size_t num);

        BN_ULONG *np = mont->N.d, *n0 = mont->n0;
        int stride = 5 * (6 - (top / 16 - 1)); /* multiple of 5, but less
                                                * than 32 */

        /*
         * BN_to_montgomery can contaminate words above .top [in
         * BN_DEBUG[_DEBUG] build]...
         */
        for (i = am.top; i < top; i++)
            am.d[i] = 0;
        for (i = tmp.top; i < top; i++)
            tmp.d[i] = 0;

        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 0);
        bn_flip_n_scatter5_t4(am.d, top, powerbuf, 1);
        if (!(*mul_worker) (tmp.d, am.d, am.d, np, n0) &&
            !(*mul_worker) (tmp.d, am.d, am.d, np, n0))
            bn_mul_mont_vis3(tmp.d, am.d, am.d, np, n0, top);
        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 2);

        for (i = 3; i < 32; i++) {
            /* Calculate a^i = a^(i-1) * a */
            if (!(*mul_worker) (tmp.d, tmp.d, am.d, np, n0) &&
                !(*mul_worker) (tmp.d, tmp.d, am.d, np, n0))
                bn_mul_mont_vis3(tmp.d, tmp.d, am.d, np, n0, top);
            bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, i);
        }

        /* switch to 64-bit domain */
        np = alloca(top * sizeof(BN_ULONG));
        top /= 2;
        bn_flip_t4(np, mont->N.d, top);

        bits--;
        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)
            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
        bn_gather5_t4(tmp.d, top, powerbuf, wvalue);

        /*
         * Scan the exponent one window at a time starting from the most
         * significant bits.
         */
        while (bits >= 0) {
            if (bits < stride)
                stride = bits + 1;
            bits -= stride;
            wvalue = bn_get_bits(p, bits + 1);

            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))
                continue;
            /* retry once and fall back */
            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))
                continue;

            bits += stride - 5;
            wvalue >>= stride - 5;
            wvalue &= 31;
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_gather5_t4(tmp.d, tmp.d, powerbuf, np, n0, top,
                                   wvalue);
        }

        bn_flip_t4(tmp.d, tmp.d, top);
        top *= 2;
        /* back to 32-bit domain */
        tmp.top = top;
        bn_correct_top(&tmp);
        OPENSSL_cleanse(np, top * sizeof(BN_ULONG));
    } else
#endif
#if defined(OPENSSL_BN_ASM_MONT5)
    if (window == 5 && top > 1) {
        /*
         * This optimization uses ideas from http://eprint.iacr.org/2011/239,
         * specifically optimization of cache-timing attack countermeasures
         * and pre-computation optimization.
         */

        /*
         * Dedicated window==4 case improves 512-bit RSA sign by ~15%, but as
         * 512-bit RSA is hardly relevant, we omit it to spare size...
         */
        void bn_mul_mont_gather5(BN_ULONG *rp, const BN_ULONG *ap,
                                 const void *table, const BN_ULONG *np,
                                 const BN_ULONG *n0, int num, int power);
        void bn_scatter5(const BN_ULONG *inp, size_t num,
                         void *table, size_t power);
        void bn_gather5(BN_ULONG *out, size_t num, void *table, size_t power);
        void bn_power5(BN_ULONG *rp, const BN_ULONG *ap,
                       const void *table, const BN_ULONG *np,
                       const BN_ULONG *n0, int num, int power);
        int bn_get_bits5(const BN_ULONG *ap, int off);
        int bn_from_montgomery(BN_ULONG *rp, const BN_ULONG *ap,
                               const BN_ULONG *not_used, const BN_ULONG *np,
                               const BN_ULONG *n0, int num);

        BN_ULONG *np = mont->N.d, *n0 = mont->n0, *np2;

        /*
         * BN_to_montgomery can contaminate words above .top [in
         * BN_DEBUG[_DEBUG] build]...
         */
        for (i = am.top; i < top; i++)
            am.d[i] = 0;
        for (i = tmp.top; i < top; i++)
            tmp.d[i] = 0;

        if (top & 7)
            np2 = np;
        else
            for (np2 = am.d + top, i = 0; i < top; i++)
                np2[2 * i] = np[i];

        bn_scatter5(tmp.d, top, powerbuf, 0);
        bn_scatter5(am.d, am.top, powerbuf, 1);
        bn_mul_mont(tmp.d, am.d, am.d, np, n0, top);
        bn_scatter5(tmp.d, top, powerbuf, 2);

# if 0
        for (i = 3; i < 32; i++) {
            /* Calculate a^i = a^(i-1) * a */
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
        }
# else
        /* same as above, but uses squaring for 1/2 of operations */
        for (i = 4; i < 32; i *= 2) {
            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_scatter5(tmp.d, top, powerbuf, i);
        }
        for (i = 3; i < 8; i += 2) {
            int j;
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
            for (j = 2 * i; j < 32; j *= 2) {
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_scatter5(tmp.d, top, powerbuf, j);
            }
        }
        for (; i < 16; i += 2) {
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_scatter5(tmp.d, top, powerbuf, 2 * i);
        }
        for (; i < 32; i += 2) {
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
        }
# endif
        bits--;
        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)
            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
        bn_gather5(tmp.d, top, powerbuf, wvalue);

        /*
         * Scan the exponent one window at a time starting from the most
         * significant bits.
         */
        if (top & 7)
            while (bits >= 0) {
                for (wvalue = 0, i = 0; i < 5; i++, bits--)
                    wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);

                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont_gather5(tmp.d, tmp.d, powerbuf, np, n0, top,
                                    wvalue);
        } else {
            while (bits >= 0) {
                wvalue = bn_get_bits5(p->d, bits - 4);
                bits -= 5;
                bn_power5(tmp.d, tmp.d, powerbuf, np2, n0, top, wvalue);
            }
        }

        ret = bn_from_montgomery(tmp.d, tmp.d, NULL, np2, n0, top);
        tmp.top = top;
        bn_correct_top(&tmp);
        if (ret) {
            if (!BN_copy(rr, &tmp))
                ret = 0;
            goto err;           /* non-zero ret means it's not error */
        }
    } else
#endif
    {
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers))
            goto err;
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, numPowers))
            goto err;

        /*
         * If the window size is greater than 1, then calculate
         * val[i=2..2^winsize-1]. Powers are computed as a*a^(i-1) (even
         * powers could instead be computed as (a^(i/2))^2 to use the slight
         * performance advantage of sqr over mul).
         */
        if (window > 1) {
            if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))
                goto err;
            if (!MOD_EXP_CTIME_COPY_TO_PREBUF
                (&tmp, top, powerbuf, 2, numPowers))
                goto err;
            for (i = 3; i < numPowers; i++) {
                /* Calculate a^i = a^(i-1) * a */
                if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))
                    goto err;
                if (!MOD_EXP_CTIME_COPY_TO_PREBUF
                    (&tmp, top, powerbuf, i, numPowers))
                    goto err;
            }
        }

        bits--;
        for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)
            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF
            (&tmp, top, powerbuf, wvalue, numPowers))
            goto err;

        /*
         * Scan the exponent one window at a time starting from the most
     } else
 #endif
     {
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers))
             goto err;
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, numPowers))
             goto err;
 
         /*
                wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
            }

            /*
             * Fetch the appropriate pre-computed value from the pre-buf
         if (window > 1) {
             if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))
                 goto err;
            if (!MOD_EXP_CTIME_COPY_TO_PREBUF
                (&tmp, top, powerbuf, 2, numPowers))
                 goto err;
             for (i = 3; i < numPowers; i++) {
                 /* Calculate a^i = a^(i-1) * a */
                 if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))
                     goto err;
                if (!MOD_EXP_CTIME_COPY_TO_PREBUF
                    (&tmp, top, powerbuf, i, numPowers))
                     goto err;
             }
         }
        for (i = 1; i < top; i++)
         bits--;
         for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)
             wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF
            (&tmp, top, powerbuf, wvalue, numPowers))
             goto err;
 
         /*
 err:
    if ((in_mont == NULL) && (mont != NULL))
        BN_MONT_CTX_free(mont);
    if (powerbuf != NULL) {
        OPENSSL_cleanse(powerbuf, powerbufLen);
        if (powerbufFree)
            OPENSSL_free(powerbufFree);
    }
    BN_CTX_end(ctx);
    return (ret);
}

int BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p,
             /*
              * Fetch the appropriate pre-computed value from the pre-buf
              */
            if (!MOD_EXP_CTIME_COPY_FROM_PREBUF
                (&am, top, powerbuf, wvalue, numPowers))
                 goto err;
 
             /* Multiply the result into the intermediate result */
#define BN_MOD_MUL_WORD(r, w, m) \
                (BN_mul_word(r, (w)) && \
                (/* BN_ucmp(r, (m)) < 0 ? 1 :*/  \
                        (BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1))))
    /*
     * BN_MOD_MUL_WORD is only used with 'w' large, so the BN_ucmp test is
     * probably more overhead than always using BN_mod (which uses BN_copy if
     * a similar test returns true).
     */
    /*
     * We can use BN_mod and do not need BN_nnmod because our accumulator is
     * never negative (the result of BN_mod does not depend on the sign of
     * the modulus).
     */
#define BN_TO_MONTGOMERY_WORD(r, w, mont) \
                (BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx))

    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {
        /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */
        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return -1;
    }

    bn_check_top(p);
    bn_check_top(m);

    if (!BN_is_odd(m)) {
        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS);
        return (0);
    }
    if (m->top == 1)
        a %= m->d[0];           /* make sure that 'a' is reduced */

    bits = BN_num_bits(p);
    if (bits == 0) {
        /* x**0 mod 1 is still zero. */
        if (BN_is_one(m)) {
            ret = 1;
            BN_zero(rr);
        } else {
            ret = BN_one(rr);
        }
        return ret;
    }
    if (a == 0) {
        BN_zero(rr);
        ret = 1;
        return ret;
    }

    BN_CTX_start(ctx);
    d = BN_CTX_get(ctx);
    r = BN_CTX_get(ctx);
    t = BN_CTX_get(ctx);
    if (d == NULL || r == NULL || t == NULL)
        goto err;

    if (in_mont != NULL)
        mont = in_mont;
    else {
        if ((mont = BN_MONT_CTX_new()) == NULL)
            goto err;
        if (!BN_MONT_CTX_set(mont, m, ctx))
            goto err;
    }

    r_is_one = 1;               /* except for Montgomery factor */

    /* bits-1 >= 0 */

    /* The result is accumulated in the product r*w. */
    w = a;                      /* bit 'bits-1' of 'p' is always set */
    for (b = bits - 2; b >= 0; b--) {
        /* First, square r*w. */
        next_w = w * w;
        if ((next_w / w) != w) { /* overflow */
            if (r_is_one) {
                if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
                    goto err;
                r_is_one = 0;
            } else {
                if (!BN_MOD_MUL_WORD(r, w, m))
                    goto err;
            }
            next_w = 1;
        }
        w = next_w;
        if (!r_is_one) {
            if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))
                goto err;
        }

        /* Second, multiply r*w by 'a' if exponent bit is set. */
        if (BN_is_bit_set(p, b)) {
            next_w = w * a;
            if ((next_w / a) != w) { /* overflow */
                if (r_is_one) {
                    if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
                        goto err;
                    r_is_one = 0;
                } else {
                    if (!BN_MOD_MUL_WORD(r, w, m))
                        goto err;
                }
                next_w = a;
            }
            w = next_w;
        }
    }

    /* Finally, set r:=r*w. */
    if (w != 1) {
        if (r_is_one) {
            if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
                goto err;
            r_is_one = 0;
        } else {
            if (!BN_MOD_MUL_WORD(r, w, m))
                goto err;
        }
    }

    if (r_is_one) {             /* can happen only if a == 1 */
        if (!BN_one(rr))
            goto err;
    } else {
        if (!BN_from_montgomery(rr, r, mont, ctx))
            goto err;
    }
    ret = 1;
 err:
    if ((in_mont == NULL) && (mont != NULL))
        BN_MONT_CTX_free(mont);
    BN_CTX_end(ctx);
    bn_check_top(rr);
    return (ret);
}
",C,"                                        int window)
    int i, j;
    int width = 1 << window;
    BN_ULONG *table = (BN_ULONG *)buf;
    for (i = 0, j = idx; i < top; i++, j += width) {
        table[j] = b->d[i];
                                          int window)
    int i, j;
    int width = 1 << window;
    volatile BN_ULONG *table = (volatile BN_ULONG *)buf;
    if (window <= 3) {
        for (i = 0; i < top; i++, table += width) {
            BN_ULONG acc = 0;

            for (j = 0; j < width; j++) {
                acc |= table[j] &
                       ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));
            }

            b->d[i] = acc;
        }
    } else {
        int xstride = 1 << (window - 2);
        BN_ULONG y0, y1, y2, y3;

        i = idx >> (window - 2);        /* equivalent of idx / xstride */
        idx &= xstride - 1;             /* equivalent of idx % xstride */

        y0 = (BN_ULONG)0 - (constant_time_eq_int(i,0)&1);
        y1 = (BN_ULONG)0 - (constant_time_eq_int(i,1)&1);
        y2 = (BN_ULONG)0 - (constant_time_eq_int(i,2)&1);
        y3 = (BN_ULONG)0 - (constant_time_eq_int(i,3)&1);

        for (i = 0; i < top; i++, table += width) {
            BN_ULONG acc = 0;

            for (j = 0; j < xstride; j++) {
                acc |= ( (table[j + 0 * xstride] & y0) |
                         (table[j + 1 * xstride] & y1) |
                         (table[j + 2 * xstride] & y2) |
                         (table[j + 3 * xstride] & y3) )
                       & ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));
            }

            b->d[i] = acc;
        }
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, window))
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, window))
            if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 2,
                                              window))
                if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, i,
                                                  window))
        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&tmp, top, powerbuf, wvalue,
                                            window))
            if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&am, top, powerbuf, wvalue,
                                                window))
","                                        int width)
    size_t i, j;
    for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {
        buf[j] = ((unsigned char *)b->d)[i];
                                          int width)
    size_t i, j;
    for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {
        ((unsigned char *)b->d)[i] = buf[j];
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers))
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, numPowers))
            if (!MOD_EXP_CTIME_COPY_TO_PREBUF
                (&tmp, top, powerbuf, 2, numPowers))
                if (!MOD_EXP_CTIME_COPY_TO_PREBUF
                    (&tmp, top, powerbuf, i, numPowers))
        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF
            (&tmp, top, powerbuf, wvalue, numPowers))
            if (!MOD_EXP_CTIME_COPY_FROM_PREBUF
                (&am, top, powerbuf, wvalue, numPowers))
",bc38a7d2d3c6082163c50ddf99464736110f2000,"@@ -110,6 +110,7 @@
  */
 
 #include ""cryptlib.h""
+#include ""constant_time_locl.h""
 #include ""bn_lcl.h""
 
 #include <stdlib.h>
@@ -606,15 +607,17 @@ static BN_ULONG bn_get_bits(const BIGNUM *a, int bitpos)
 
 static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top,
                                         unsigned char *buf, int idx,
-                                        int width)
+                                        int window)
 {
-    size_t i, j;
+    int i, j;
+    int width = 1 << window;
+    BN_ULONG *table = (BN_ULONG *)buf;
 
     if (top > b->top)
         top = b->top;           /* this works because 'buf' is explicitly
                                  * zeroed */
-    for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {
-        buf[j] = ((unsigned char *)b->d)[i];
+    for (i = 0, j = idx; i < top; i++, j += width) {
+        table[j] = b->d[i];
     }
 
     return 1;
@@ -622,15 +625,51 @@ static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top,
 
 static int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top,
                                           unsigned char *buf, int idx,
-                                          int width)
+                                          int window)
 {
-    size_t i, j;
+    int i, j;
+    int width = 1 << window;
+    volatile BN_ULONG *table = (volatile BN_ULONG *)buf;
 
     if (bn_wexpand(b, top) == NULL)
         return 0;
 
-    for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {
-        ((unsigned char *)b->d)[i] = buf[j];
+    if (window <= 3) {
+        for (i = 0; i < top; i++, table += width) {
+            BN_ULONG acc = 0;
+
+            for (j = 0; j < width; j++) {
+                acc |= table[j] &
+                       ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));
+            }
+
+            b->d[i] = acc;
+        }
+    } else {
+        int xstride = 1 << (window - 2);
+        BN_ULONG y0, y1, y2, y3;
+
+        i = idx >> (window - 2);        /* equivalent of idx / xstride */
+        idx &= xstride - 1;             /* equivalent of idx % xstride */
+
+        y0 = (BN_ULONG)0 - (constant_time_eq_int(i,0)&1);
+        y1 = (BN_ULONG)0 - (constant_time_eq_int(i,1)&1);
+        y2 = (BN_ULONG)0 - (constant_time_eq_int(i,2)&1);
+        y3 = (BN_ULONG)0 - (constant_time_eq_int(i,3)&1);
+
+        for (i = 0; i < top; i++, table += width) {
+            BN_ULONG acc = 0;
+
+            for (j = 0; j < xstride; j++) {
+                acc |= ( (table[j + 0 * xstride] & y0) |
+                         (table[j + 1 * xstride] & y1) |
+                         (table[j + 2 * xstride] & y2) |
+                         (table[j + 3 * xstride] & y3) )
+                       & ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));
+            }
+
+            b->d[i] = acc;
+        }
     }
 
     b->top = top;
@@ -1065,9 +1104,9 @@ int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,
     } else
 #endif
     {
-        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers))
+        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, window))
             goto err;
-        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, numPowers))
+        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, window))
             goto err;
 
         /*
@@ -1079,15 +1118,15 @@ int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,
         if (window > 1) {
             if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))
                 goto err;
-            if (!MOD_EXP_CTIME_COPY_TO_PREBUF
-                (&tmp, top, powerbuf, 2, numPowers))
+            if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 2,
+                                              window))
                 goto err;
             for (i = 3; i < numPowers; i++) {
                 /* Calculate a^i = a^(i-1) * a */
                 if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))
                     goto err;
-                if (!MOD_EXP_CTIME_COPY_TO_PREBUF
-                    (&tmp, top, powerbuf, i, numPowers))
+                if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, i,
+                                                  window))
                     goto err;
             }
         }
@@ -1095,8 +1134,8 @@ int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,
         bits--;
         for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)
             wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
-        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF
-            (&tmp, top, powerbuf, wvalue, numPowers))
+        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&tmp, top, powerbuf, wvalue,
+                                            window))
             goto err;
 
         /*
@@ -1116,8 +1155,8 @@ int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,
             /*
              * Fetch the appropriate pre-computed value from the pre-buf
              */
-            if (!MOD_EXP_CTIME_COPY_FROM_PREBUF
-                (&am, top, powerbuf, wvalue, numPowers))
+            if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&am, top, powerbuf, wvalue,
+                                                window))
                 goto err;
 
             /* Multiply the result into the intermediate result */",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/bn/bn_exp.c;h=c3d575fe77a788d7d2dba44106c1222664745c90;hb=708dc2f1291e104fe4eef810bb8ffc1fae5b19c1,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/bn/bn_exp.c;h=6d30d1e0fff56e4e90238feb2ecc75328a7357db,1," static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top,
                                         unsigned char *buf, int idx,
//flaw_line_below:
                                        int width)
//fix_flaw_line_below:
//                                        int window)
 {
//flaw_line_below:
    size_t i, j;
//fix_flaw_line_below:
//    int i, j;
//fix_flaw_line_below:
//    int width = 1 << window;
//fix_flaw_line_below:
//    BN_ULONG *table = (BN_ULONG *)buf;
 
     if (top > b->top)
         top = b->top;           /* this works because 'buf' is explicitly
                                  * zeroed */
//flaw_line_below:
    for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {
//flaw_line_below:
        buf[j] = ((unsigned char *)b->d)[i];
//fix_flaw_line_below:
//    for (i = 0, j = idx; i < top; i++, j += width) {
//fix_flaw_line_below:
//        table[j] = b->d[i];
     }
 
     return 1;
                                          unsigned char *buf, int idx,
 
 static int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top,
                                           unsigned char *buf, int idx,
//flaw_line_below:
                                          int width)
//fix_flaw_line_below:
//                                          int window)
 {
//flaw_line_below:
    size_t i, j;
//fix_flaw_line_below:
//    int i, j;
//fix_flaw_line_below:
//    int width = 1 << window;
//fix_flaw_line_below:
//    volatile BN_ULONG *table = (volatile BN_ULONG *)buf;
 
     if (bn_wexpand(b, top) == NULL)
         return 0;
 
//flaw_line_below:
    for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {
//flaw_line_below:
        ((unsigned char *)b->d)[i] = buf[j];
//fix_flaw_line_below:
//    if (window <= 3) {
//fix_flaw_line_below:
//        for (i = 0; i < top; i++, table += width) {
//fix_flaw_line_below:
//            BN_ULONG acc = 0;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//            for (j = 0; j < width; j++) {
//fix_flaw_line_below:
//                acc |= table[j] &
//fix_flaw_line_below:
//                       ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//            b->d[i] = acc;
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//    } else {
//fix_flaw_line_below:
//        int xstride = 1 << (window - 2);
//fix_flaw_line_below:
//        BN_ULONG y0, y1, y2, y3;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        i = idx >> (window - 2);        /* equivalent of idx / xstride */
//fix_flaw_line_below:
//        idx &= xstride - 1;             /* equivalent of idx % xstride */
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        y0 = (BN_ULONG)0 - (constant_time_eq_int(i,0)&1);
//fix_flaw_line_below:
//        y1 = (BN_ULONG)0 - (constant_time_eq_int(i,1)&1);
//fix_flaw_line_below:
//        y2 = (BN_ULONG)0 - (constant_time_eq_int(i,2)&1);
//fix_flaw_line_below:
//        y3 = (BN_ULONG)0 - (constant_time_eq_int(i,3)&1);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        for (i = 0; i < top; i++, table += width) {
//fix_flaw_line_below:
//            BN_ULONG acc = 0;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//            for (j = 0; j < xstride; j++) {
//fix_flaw_line_below:
//                acc |= ( (table[j + 0 * xstride] & y0) |
//fix_flaw_line_below:
//                         (table[j + 1 * xstride] & y1) |
//fix_flaw_line_below:
//                         (table[j + 2 * xstride] & y2) |
//fix_flaw_line_below:
//                         (table[j + 3 * xstride] & y3) )
//fix_flaw_line_below:
//                       & ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//            b->d[i] = acc;
//fix_flaw_line_below:
//        }
     }
 
     b->top = top;
    if (!BN_is_odd(m)) {
        BNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME, BN_R_CALLED_WITH_EVEN_MODULUS);
        return (0);
    }

    top = m->top;

    bits = BN_num_bits(p);
    if (bits == 0) {
        /* x**0 mod 1 is still zero. */
        if (BN_is_one(m)) {
            ret = 1;
            BN_zero(rr);
        } else {
            ret = BN_one(rr);
        }
        return ret;
    }

    BN_CTX_start(ctx);

    /*
     * Allocate a montgomery context if it was not supplied by the caller. If
     * this is not done, things will break in the montgomery part.
     */
    if (in_mont != NULL)
        mont = in_mont;
    else {
        if ((mont = BN_MONT_CTX_new()) == NULL)
            goto err;
        if (!BN_MONT_CTX_set(mont, m, ctx))
            goto err;
    }

#ifdef RSAZ_ENABLED
    /*
     * If the size of the operands allow it, perform the optimized
     * RSAZ exponentiation. For further information see
     * crypto/bn/rsaz_exp.c and accompanying assembly modules.
     */
    if ((16 == a->top) && (16 == p->top) && (BN_num_bits(m) == 1024)
        && rsaz_avx2_eligible()) {
        if (NULL == bn_wexpand(rr, 16))
            goto err;
        RSAZ_1024_mod_exp_avx2(rr->d, a->d, p->d, m->d, mont->RR.d,
                               mont->n0[0]);
        rr->top = 16;
        rr->neg = 0;
        bn_correct_top(rr);
        ret = 1;
        goto err;
    } else if ((8 == a->top) && (8 == p->top) && (BN_num_bits(m) == 512)) {
        if (NULL == bn_wexpand(rr, 8))
            goto err;
        RSAZ_512_mod_exp(rr->d, a->d, p->d, m->d, mont->n0[0], mont->RR.d);
        rr->top = 8;
        rr->neg = 0;
        bn_correct_top(rr);
        ret = 1;
        goto err;
    }
#endif

    /* Get the window size to use with size of p. */
    window = BN_window_bits_for_ctime_exponent_size(bits);
#if defined(SPARC_T4_MONT)
    if (window >= 5 && (top & 15) == 0 && top <= 64 &&
        (OPENSSL_sparcv9cap_P[1] & (CFR_MONTMUL | CFR_MONTSQR)) ==
        (CFR_MONTMUL | CFR_MONTSQR) && (t4 = OPENSSL_sparcv9cap_P[0]))
        window = 5;
    else
#endif
#if defined(OPENSSL_BN_ASM_MONT5)
    if (window >= 5) {
        window = 5;             /* ~5% improvement for RSA2048 sign, and even
                                 * for RSA4096 */
        if ((top & 7) == 0)
            powerbufLen += 2 * top * sizeof(m->d[0]);
    }
#endif
    (void)0;

    /*
     * Allocate a buffer large enough to hold all of the pre-computed powers
     * of am, am itself and tmp.
     */
    numPowers = 1 << window;
    powerbufLen += sizeof(m->d[0]) * (top * numPowers +
                                      ((2 * top) >
                                       numPowers ? (2 * top) : numPowers));
#ifdef alloca
    if (powerbufLen < 3072)
        powerbufFree =
            alloca(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH);
    else
#endif
        if ((powerbufFree =
             (unsigned char *)OPENSSL_malloc(powerbufLen +
                                             MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH))
            == NULL)
        goto err;

    powerbuf = MOD_EXP_CTIME_ALIGN(powerbufFree);
    memset(powerbuf, 0, powerbufLen);

#ifdef alloca
    if (powerbufLen < 3072)
        powerbufFree = NULL;
#endif

    /* lay down tmp and am right after powers table */
    tmp.d = (BN_ULONG *)(powerbuf + sizeof(m->d[0]) * top * numPowers);
    am.d = tmp.d + top;
    tmp.top = am.top = 0;
    tmp.dmax = am.dmax = top;
    tmp.neg = am.neg = 0;
    tmp.flags = am.flags = BN_FLG_STATIC_DATA;

    /* prepare a^0 in Montgomery domain */
#if 1                           /* by Shay Gueron's suggestion */
    if (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {
        /* 2^(top*BN_BITS2) - m */
        tmp.d[0] = (0 - m->d[0]) & BN_MASK2;
        for (i = 1; i < top; i++)
            tmp.d[i] = (~m->d[i]) & BN_MASK2;
        tmp.top = top;
    } else
#endif
    if (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))
        goto err;

    /* prepare a^1 in Montgomery domain */
    if (a->neg || BN_ucmp(a, m) >= 0) {
        if (!BN_mod(&am, a, m, ctx))
            goto err;
        if (!BN_to_montgomery(&am, &am, mont, ctx))
            goto err;
    } else if (!BN_to_montgomery(&am, a, mont, ctx))
        goto err;

#if defined(SPARC_T4_MONT)
    if (t4) {
        typedef int (*bn_pwr5_mont_f) (BN_ULONG *tp, const BN_ULONG *np,
                                       const BN_ULONG *n0, const void *table,
                                       int power, int bits);
        int bn_pwr5_mont_t4_8(BN_ULONG *tp, const BN_ULONG *np,
                              const BN_ULONG *n0, const void *table,
                              int power, int bits);
        int bn_pwr5_mont_t4_16(BN_ULONG *tp, const BN_ULONG *np,
                               const BN_ULONG *n0, const void *table,
                               int power, int bits);
        int bn_pwr5_mont_t4_24(BN_ULONG *tp, const BN_ULONG *np,
                               const BN_ULONG *n0, const void *table,
                               int power, int bits);
        int bn_pwr5_mont_t4_32(BN_ULONG *tp, const BN_ULONG *np,
                               const BN_ULONG *n0, const void *table,
                               int power, int bits);
        static const bn_pwr5_mont_f pwr5_funcs[4] = {
            bn_pwr5_mont_t4_8, bn_pwr5_mont_t4_16,
            bn_pwr5_mont_t4_24, bn_pwr5_mont_t4_32
        };
        bn_pwr5_mont_f pwr5_worker = pwr5_funcs[top / 16 - 1];

        typedef int (*bn_mul_mont_f) (BN_ULONG *rp, const BN_ULONG *ap,
                                      const void *bp, const BN_ULONG *np,
                                      const BN_ULONG *n0);
        int bn_mul_mont_t4_8(BN_ULONG *rp, const BN_ULONG *ap, const void *bp,
                             const BN_ULONG *np, const BN_ULONG *n0);
        int bn_mul_mont_t4_16(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0);
        int bn_mul_mont_t4_24(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0);
        int bn_mul_mont_t4_32(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0);
        static const bn_mul_mont_f mul_funcs[4] = {
            bn_mul_mont_t4_8, bn_mul_mont_t4_16,
            bn_mul_mont_t4_24, bn_mul_mont_t4_32
        };
        bn_mul_mont_f mul_worker = mul_funcs[top / 16 - 1];

        void bn_mul_mont_vis3(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0, int num);
        void bn_mul_mont_t4(BN_ULONG *rp, const BN_ULONG *ap,
                            const void *bp, const BN_ULONG *np,
                            const BN_ULONG *n0, int num);
        void bn_mul_mont_gather5_t4(BN_ULONG *rp, const BN_ULONG *ap,
                                    const void *table, const BN_ULONG *np,
                                    const BN_ULONG *n0, int num, int power);
        void bn_flip_n_scatter5_t4(const BN_ULONG *inp, size_t num,
                                   void *table, size_t power);
        void bn_gather5_t4(BN_ULONG *out, size_t num,
                           void *table, size_t power);
        void bn_flip_t4(BN_ULONG *dst, BN_ULONG *src, size_t num);

        BN_ULONG *np = mont->N.d, *n0 = mont->n0;
        int stride = 5 * (6 - (top / 16 - 1)); /* multiple of 5, but less
                                                * than 32 */

        /*
         * BN_to_montgomery can contaminate words above .top [in
         * BN_DEBUG[_DEBUG] build]...
         */
        for (i = am.top; i < top; i++)
            am.d[i] = 0;
        for (i = tmp.top; i < top; i++)
            tmp.d[i] = 0;

        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 0);
        bn_flip_n_scatter5_t4(am.d, top, powerbuf, 1);
        if (!(*mul_worker) (tmp.d, am.d, am.d, np, n0) &&
            !(*mul_worker) (tmp.d, am.d, am.d, np, n0))
            bn_mul_mont_vis3(tmp.d, am.d, am.d, np, n0, top);
        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 2);

        for (i = 3; i < 32; i++) {
            /* Calculate a^i = a^(i-1) * a */
            if (!(*mul_worker) (tmp.d, tmp.d, am.d, np, n0) &&
                !(*mul_worker) (tmp.d, tmp.d, am.d, np, n0))
                bn_mul_mont_vis3(tmp.d, tmp.d, am.d, np, n0, top);
            bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, i);
        }

        /* switch to 64-bit domain */
        np = alloca(top * sizeof(BN_ULONG));
        top /= 2;
        bn_flip_t4(np, mont->N.d, top);

        bits--;
        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)
            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
        bn_gather5_t4(tmp.d, top, powerbuf, wvalue);

        /*
         * Scan the exponent one window at a time starting from the most
         * significant bits.
         */
        while (bits >= 0) {
            if (bits < stride)
                stride = bits + 1;
            bits -= stride;
            wvalue = bn_get_bits(p, bits + 1);

            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))
                continue;
            /* retry once and fall back */
            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))
                continue;

            bits += stride - 5;
            wvalue >>= stride - 5;
            wvalue &= 31;
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_gather5_t4(tmp.d, tmp.d, powerbuf, np, n0, top,
                                   wvalue);
        }

        bn_flip_t4(tmp.d, tmp.d, top);
        top *= 2;
        /* back to 32-bit domain */
        tmp.top = top;
        bn_correct_top(&tmp);
        OPENSSL_cleanse(np, top * sizeof(BN_ULONG));
    } else
#endif
#if defined(OPENSSL_BN_ASM_MONT5)
    if (window == 5 && top > 1) {
        /*
         * This optimization uses ideas from http://eprint.iacr.org/2011/239,
         * specifically optimization of cache-timing attack countermeasures
         * and pre-computation optimization.
         */

        /*
         * Dedicated window==4 case improves 512-bit RSA sign by ~15%, but as
         * 512-bit RSA is hardly relevant, we omit it to spare size...
         */
        void bn_mul_mont_gather5(BN_ULONG *rp, const BN_ULONG *ap,
                                 const void *table, const BN_ULONG *np,
                                 const BN_ULONG *n0, int num, int power);
        void bn_scatter5(const BN_ULONG *inp, size_t num,
                         void *table, size_t power);
        void bn_gather5(BN_ULONG *out, size_t num, void *table, size_t power);
        void bn_power5(BN_ULONG *rp, const BN_ULONG *ap,
                       const void *table, const BN_ULONG *np,
                       const BN_ULONG *n0, int num, int power);
        int bn_get_bits5(const BN_ULONG *ap, int off);
        int bn_from_montgomery(BN_ULONG *rp, const BN_ULONG *ap,
                               const BN_ULONG *not_used, const BN_ULONG *np,
                               const BN_ULONG *n0, int num);

        BN_ULONG *np = mont->N.d, *n0 = mont->n0, *np2;

        /*
         * BN_to_montgomery can contaminate words above .top [in
         * BN_DEBUG[_DEBUG] build]...
         */
        for (i = am.top; i < top; i++)
            am.d[i] = 0;
        for (i = tmp.top; i < top; i++)
            tmp.d[i] = 0;

        if (top & 7)
            np2 = np;
        else
            for (np2 = am.d + top, i = 0; i < top; i++)
                np2[2 * i] = np[i];

        bn_scatter5(tmp.d, top, powerbuf, 0);
        bn_scatter5(am.d, am.top, powerbuf, 1);
        bn_mul_mont(tmp.d, am.d, am.d, np, n0, top);
        bn_scatter5(tmp.d, top, powerbuf, 2);

# if 0
        for (i = 3; i < 32; i++) {
            /* Calculate a^i = a^(i-1) * a */
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
        }
# else
        /* same as above, but uses squaring for 1/2 of operations */
        for (i = 4; i < 32; i *= 2) {
            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_scatter5(tmp.d, top, powerbuf, i);
        }
        for (i = 3; i < 8; i += 2) {
            int j;
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
            for (j = 2 * i; j < 32; j *= 2) {
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_scatter5(tmp.d, top, powerbuf, j);
            }
        }
        for (; i < 16; i += 2) {
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_scatter5(tmp.d, top, powerbuf, 2 * i);
        }
        for (; i < 32; i += 2) {
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
        }
# endif
        bits--;
        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)
            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
        bn_gather5(tmp.d, top, powerbuf, wvalue);

        /*
         * Scan the exponent one window at a time starting from the most
         * significant bits.
         */
        if (top & 7)
            while (bits >= 0) {
                for (wvalue = 0, i = 0; i < 5; i++, bits--)
                    wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);

                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont_gather5(tmp.d, tmp.d, powerbuf, np, n0, top,
                                    wvalue);
        } else {
            while (bits >= 0) {
                wvalue = bn_get_bits5(p->d, bits - 4);
                bits -= 5;
                bn_power5(tmp.d, tmp.d, powerbuf, np2, n0, top, wvalue);
            }
        }

        ret = bn_from_montgomery(tmp.d, tmp.d, NULL, np2, n0, top);
        tmp.top = top;
        bn_correct_top(&tmp);
        if (ret) {
            if (!BN_copy(rr, &tmp))
                ret = 0;
            goto err;           /* non-zero ret means it's not error */
        }
    } else
#endif
    {
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers))
            goto err;
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, numPowers))
            goto err;

        /*
         * If the window size is greater than 1, then calculate
         * val[i=2..2^winsize-1]. Powers are computed as a*a^(i-1) (even
         * powers could instead be computed as (a^(i/2))^2 to use the slight
         * performance advantage of sqr over mul).
         */
        if (window > 1) {
            if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))
                goto err;
            if (!MOD_EXP_CTIME_COPY_TO_PREBUF
                (&tmp, top, powerbuf, 2, numPowers))
                goto err;
            for (i = 3; i < numPowers; i++) {
                /* Calculate a^i = a^(i-1) * a */
                if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))
                    goto err;
                if (!MOD_EXP_CTIME_COPY_TO_PREBUF
                    (&tmp, top, powerbuf, i, numPowers))
                    goto err;
            }
        }

        bits--;
        for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)
            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF
            (&tmp, top, powerbuf, wvalue, numPowers))
            goto err;

        /*
         * Scan the exponent one window at a time starting from the most
     } else
 #endif
     {
//flaw_line_below:
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers))
//fix_flaw_line_below:
//        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, window))
             goto err;
//flaw_line_below:
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, numPowers))
//fix_flaw_line_below:
//        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, window))
             goto err;
 
         /*
                wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
            }

            /*
             * Fetch the appropriate pre-computed value from the pre-buf
         if (window > 1) {
             if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))
                 goto err;
//flaw_line_below:
            if (!MOD_EXP_CTIME_COPY_TO_PREBUF
//flaw_line_below:
                (&tmp, top, powerbuf, 2, numPowers))
//fix_flaw_line_below:
//            if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 2,
//fix_flaw_line_below:
//                                              window))
                 goto err;
             for (i = 3; i < numPowers; i++) {
                 /* Calculate a^i = a^(i-1) * a */
                 if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))
                     goto err;
//flaw_line_below:
                if (!MOD_EXP_CTIME_COPY_TO_PREBUF
//flaw_line_below:
                    (&tmp, top, powerbuf, i, numPowers))
//fix_flaw_line_below:
//                if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, i,
//fix_flaw_line_below:
//                                                  window))
                     goto err;
             }
         }
        for (i = 1; i < top; i++)
         bits--;
         for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)
             wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
//flaw_line_below:
        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF
//flaw_line_below:
            (&tmp, top, powerbuf, wvalue, numPowers))
//fix_flaw_line_below:
//        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&tmp, top, powerbuf, wvalue,
//fix_flaw_line_below:
//                                            window))
             goto err;
 
         /*
 err:
    if ((in_mont == NULL) && (mont != NULL))
        BN_MONT_CTX_free(mont);
    if (powerbuf != NULL) {
        OPENSSL_cleanse(powerbuf, powerbufLen);
        if (powerbufFree)
            OPENSSL_free(powerbufFree);
    }
    BN_CTX_end(ctx);
    return (ret);
}

int BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p,
             /*
              * Fetch the appropriate pre-computed value from the pre-buf
              */
//flaw_line_below:
            if (!MOD_EXP_CTIME_COPY_FROM_PREBUF
//flaw_line_below:
                (&am, top, powerbuf, wvalue, numPowers))
//fix_flaw_line_below:
//            if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&am, top, powerbuf, wvalue,
//fix_flaw_line_below:
//                                                window))
                 goto err;
 
             /* Multiply the result into the intermediate result */
#define BN_MOD_MUL_WORD(r, w, m) \
                (BN_mul_word(r, (w)) && \
                (/* BN_ucmp(r, (m)) < 0 ? 1 :*/  \
                        (BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1))))
    /*
     * BN_MOD_MUL_WORD is only used with 'w' large, so the BN_ucmp test is
     * probably more overhead than always using BN_mod (which uses BN_copy if
     * a similar test returns true).
     */
    /*
     * We can use BN_mod and do not need BN_nnmod because our accumulator is
     * never negative (the result of BN_mod does not depend on the sign of
     * the modulus).
     */
#define BN_TO_MONTGOMERY_WORD(r, w, mont) \
                (BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx))

    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {
        /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */
        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return -1;
    }

    bn_check_top(p);
    bn_check_top(m);

    if (!BN_is_odd(m)) {
        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS);
        return (0);
    }
    if (m->top == 1)
        a %= m->d[0];           /* make sure that 'a' is reduced */

    bits = BN_num_bits(p);
    if (bits == 0) {
        /* x**0 mod 1 is still zero. */
        if (BN_is_one(m)) {
            ret = 1;
            BN_zero(rr);
        } else {
            ret = BN_one(rr);
        }
        return ret;
    }
    if (a == 0) {
        BN_zero(rr);
        ret = 1;
        return ret;
    }

    BN_CTX_start(ctx);
    d = BN_CTX_get(ctx);
    r = BN_CTX_get(ctx);
    t = BN_CTX_get(ctx);
    if (d == NULL || r == NULL || t == NULL)
        goto err;

    if (in_mont != NULL)
        mont = in_mont;
    else {
        if ((mont = BN_MONT_CTX_new()) == NULL)
            goto err;
        if (!BN_MONT_CTX_set(mont, m, ctx))
            goto err;
    }

    r_is_one = 1;               /* except for Montgomery factor */

    /* bits-1 >= 0 */

    /* The result is accumulated in the product r*w. */
    w = a;                      /* bit 'bits-1' of 'p' is always set */
    for (b = bits - 2; b >= 0; b--) {
        /* First, square r*w. */
        next_w = w * w;
        if ((next_w / w) != w) { /* overflow */
            if (r_is_one) {
                if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
                    goto err;
                r_is_one = 0;
            } else {
                if (!BN_MOD_MUL_WORD(r, w, m))
                    goto err;
            }
            next_w = 1;
        }
        w = next_w;
        if (!r_is_one) {
            if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))
                goto err;
        }

        /* Second, multiply r*w by 'a' if exponent bit is set. */
        if (BN_is_bit_set(p, b)) {
            next_w = w * a;
            if ((next_w / a) != w) { /* overflow */
                if (r_is_one) {
                    if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
                        goto err;
                    r_is_one = 0;
                } else {
                    if (!BN_MOD_MUL_WORD(r, w, m))
                        goto err;
                }
                next_w = a;
            }
            w = next_w;
        }
    }

    /* Finally, set r:=r*w. */
    if (w != 1) {
        if (r_is_one) {
            if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
                goto err;
            r_is_one = 0;
        } else {
            if (!BN_MOD_MUL_WORD(r, w, m))
                goto err;
        }
    }

    if (r_is_one) {             /* can happen only if a == 1 */
        if (!BN_one(rr))
            goto err;
    } else {
        if (!BN_from_montgomery(rr, r, mont, ctx))
            goto err;
    }
    ret = 1;
 err:
    if ((in_mont == NULL) && (mont != NULL))
        BN_MONT_CTX_free(mont);
    BN_CTX_end(ctx);
    bn_check_top(rr);
    return (ret);
}
",178426," static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top,
                                         unsigned char *buf, int idx,
                                        int width)
 {
    size_t i, j;
 
     if (top > b->top)
         top = b->top;           /* this works because 'buf' is explicitly
                                  * zeroed */
    for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {
        buf[j] = ((unsigned char *)b->d)[i];
     }
 
     return 1;
                                          unsigned char *buf, int idx,
 
 static int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top,
                                           unsigned char *buf, int idx,
                                          int width)
 {
    size_t i, j;
 
     if (bn_wexpand(b, top) == NULL)
         return 0;
 
    for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {
        ((unsigned char *)b->d)[i] = buf[j];
     }
 
     b->top = top;
    if (!BN_is_odd(m)) {
        BNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME, BN_R_CALLED_WITH_EVEN_MODULUS);
        return (0);
    }

    top = m->top;

    bits = BN_num_bits(p);
    if (bits == 0) {
        /* x**0 mod 1 is still zero. */
        if (BN_is_one(m)) {
            ret = 1;
            BN_zero(rr);
        } else {
            ret = BN_one(rr);
        }
        return ret;
    }

    BN_CTX_start(ctx);

    /*
     * Allocate a montgomery context if it was not supplied by the caller. If
     * this is not done, things will break in the montgomery part.
     */
    if (in_mont != NULL)
        mont = in_mont;
    else {
        if ((mont = BN_MONT_CTX_new()) == NULL)
            goto err;
        if (!BN_MONT_CTX_set(mont, m, ctx))
            goto err;
    }

#ifdef RSAZ_ENABLED
    /*
     * If the size of the operands allow it, perform the optimized
     * RSAZ exponentiation. For further information see
     * crypto/bn/rsaz_exp.c and accompanying assembly modules.
     */
    if ((16 == a->top) && (16 == p->top) && (BN_num_bits(m) == 1024)
        && rsaz_avx2_eligible()) {
        if (NULL == bn_wexpand(rr, 16))
            goto err;
        RSAZ_1024_mod_exp_avx2(rr->d, a->d, p->d, m->d, mont->RR.d,
                               mont->n0[0]);
        rr->top = 16;
        rr->neg = 0;
        bn_correct_top(rr);
        ret = 1;
        goto err;
    } else if ((8 == a->top) && (8 == p->top) && (BN_num_bits(m) == 512)) {
        if (NULL == bn_wexpand(rr, 8))
            goto err;
        RSAZ_512_mod_exp(rr->d, a->d, p->d, m->d, mont->n0[0], mont->RR.d);
        rr->top = 8;
        rr->neg = 0;
        bn_correct_top(rr);
        ret = 1;
        goto err;
    }
#endif

    /* Get the window size to use with size of p. */
    window = BN_window_bits_for_ctime_exponent_size(bits);
#if defined(SPARC_T4_MONT)
    if (window >= 5 && (top & 15) == 0 && top <= 64 &&
        (OPENSSL_sparcv9cap_P[1] & (CFR_MONTMUL | CFR_MONTSQR)) ==
        (CFR_MONTMUL | CFR_MONTSQR) && (t4 = OPENSSL_sparcv9cap_P[0]))
        window = 5;
    else
#endif
#if defined(OPENSSL_BN_ASM_MONT5)
    if (window >= 5) {
        window = 5;             /* ~5% improvement for RSA2048 sign, and even
                                 * for RSA4096 */
        if ((top & 7) == 0)
            powerbufLen += 2 * top * sizeof(m->d[0]);
    }
#endif
    (void)0;

    /*
     * Allocate a buffer large enough to hold all of the pre-computed powers
     * of am, am itself and tmp.
     */
    numPowers = 1 << window;
    powerbufLen += sizeof(m->d[0]) * (top * numPowers +
                                      ((2 * top) >
                                       numPowers ? (2 * top) : numPowers));
#ifdef alloca
    if (powerbufLen < 3072)
        powerbufFree =
            alloca(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH);
    else
#endif
        if ((powerbufFree =
             (unsigned char *)OPENSSL_malloc(powerbufLen +
                                             MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH))
            == NULL)
        goto err;

    powerbuf = MOD_EXP_CTIME_ALIGN(powerbufFree);
    memset(powerbuf, 0, powerbufLen);

#ifdef alloca
    if (powerbufLen < 3072)
        powerbufFree = NULL;
#endif

    /* lay down tmp and am right after powers table */
    tmp.d = (BN_ULONG *)(powerbuf + sizeof(m->d[0]) * top * numPowers);
    am.d = tmp.d + top;
    tmp.top = am.top = 0;
    tmp.dmax = am.dmax = top;
    tmp.neg = am.neg = 0;
    tmp.flags = am.flags = BN_FLG_STATIC_DATA;

    /* prepare a^0 in Montgomery domain */
#if 1                           /* by Shay Gueron's suggestion */
    if (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {
        /* 2^(top*BN_BITS2) - m */
        tmp.d[0] = (0 - m->d[0]) & BN_MASK2;
        for (i = 1; i < top; i++)
            tmp.d[i] = (~m->d[i]) & BN_MASK2;
        tmp.top = top;
    } else
#endif
    if (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))
        goto err;

    /* prepare a^1 in Montgomery domain */
    if (a->neg || BN_ucmp(a, m) >= 0) {
        if (!BN_mod(&am, a, m, ctx))
            goto err;
        if (!BN_to_montgomery(&am, &am, mont, ctx))
            goto err;
    } else if (!BN_to_montgomery(&am, a, mont, ctx))
        goto err;

#if defined(SPARC_T4_MONT)
    if (t4) {
        typedef int (*bn_pwr5_mont_f) (BN_ULONG *tp, const BN_ULONG *np,
                                       const BN_ULONG *n0, const void *table,
                                       int power, int bits);
        int bn_pwr5_mont_t4_8(BN_ULONG *tp, const BN_ULONG *np,
                              const BN_ULONG *n0, const void *table,
                              int power, int bits);
        int bn_pwr5_mont_t4_16(BN_ULONG *tp, const BN_ULONG *np,
                               const BN_ULONG *n0, const void *table,
                               int power, int bits);
        int bn_pwr5_mont_t4_24(BN_ULONG *tp, const BN_ULONG *np,
                               const BN_ULONG *n0, const void *table,
                               int power, int bits);
        int bn_pwr5_mont_t4_32(BN_ULONG *tp, const BN_ULONG *np,
                               const BN_ULONG *n0, const void *table,
                               int power, int bits);
        static const bn_pwr5_mont_f pwr5_funcs[4] = {
            bn_pwr5_mont_t4_8, bn_pwr5_mont_t4_16,
            bn_pwr5_mont_t4_24, bn_pwr5_mont_t4_32
        };
        bn_pwr5_mont_f pwr5_worker = pwr5_funcs[top / 16 - 1];

        typedef int (*bn_mul_mont_f) (BN_ULONG *rp, const BN_ULONG *ap,
                                      const void *bp, const BN_ULONG *np,
                                      const BN_ULONG *n0);
        int bn_mul_mont_t4_8(BN_ULONG *rp, const BN_ULONG *ap, const void *bp,
                             const BN_ULONG *np, const BN_ULONG *n0);
        int bn_mul_mont_t4_16(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0);
        int bn_mul_mont_t4_24(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0);
        int bn_mul_mont_t4_32(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0);
        static const bn_mul_mont_f mul_funcs[4] = {
            bn_mul_mont_t4_8, bn_mul_mont_t4_16,
            bn_mul_mont_t4_24, bn_mul_mont_t4_32
        };
        bn_mul_mont_f mul_worker = mul_funcs[top / 16 - 1];

        void bn_mul_mont_vis3(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0, int num);
        void bn_mul_mont_t4(BN_ULONG *rp, const BN_ULONG *ap,
                            const void *bp, const BN_ULONG *np,
                            const BN_ULONG *n0, int num);
        void bn_mul_mont_gather5_t4(BN_ULONG *rp, const BN_ULONG *ap,
                                    const void *table, const BN_ULONG *np,
                                    const BN_ULONG *n0, int num, int power);
        void bn_flip_n_scatter5_t4(const BN_ULONG *inp, size_t num,
                                   void *table, size_t power);
        void bn_gather5_t4(BN_ULONG *out, size_t num,
                           void *table, size_t power);
        void bn_flip_t4(BN_ULONG *dst, BN_ULONG *src, size_t num);

        BN_ULONG *np = mont->N.d, *n0 = mont->n0;
        int stride = 5 * (6 - (top / 16 - 1)); /* multiple of 5, but less
                                                * than 32 */

        /*
         * BN_to_montgomery can contaminate words above .top [in
         * BN_DEBUG[_DEBUG] build]...
         */
        for (i = am.top; i < top; i++)
            am.d[i] = 0;
        for (i = tmp.top; i < top; i++)
            tmp.d[i] = 0;

        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 0);
        bn_flip_n_scatter5_t4(am.d, top, powerbuf, 1);
        if (!(*mul_worker) (tmp.d, am.d, am.d, np, n0) &&
            !(*mul_worker) (tmp.d, am.d, am.d, np, n0))
            bn_mul_mont_vis3(tmp.d, am.d, am.d, np, n0, top);
        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 2);

        for (i = 3; i < 32; i++) {
            /* Calculate a^i = a^(i-1) * a */
            if (!(*mul_worker) (tmp.d, tmp.d, am.d, np, n0) &&
                !(*mul_worker) (tmp.d, tmp.d, am.d, np, n0))
                bn_mul_mont_vis3(tmp.d, tmp.d, am.d, np, n0, top);
            bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, i);
        }

        /* switch to 64-bit domain */
        np = alloca(top * sizeof(BN_ULONG));
        top /= 2;
        bn_flip_t4(np, mont->N.d, top);

        bits--;
        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)
            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
        bn_gather5_t4(tmp.d, top, powerbuf, wvalue);

        /*
         * Scan the exponent one window at a time starting from the most
         * significant bits.
         */
        while (bits >= 0) {
            if (bits < stride)
                stride = bits + 1;
            bits -= stride;
            wvalue = bn_get_bits(p, bits + 1);

            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))
                continue;
            /* retry once and fall back */
            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))
                continue;

            bits += stride - 5;
            wvalue >>= stride - 5;
            wvalue &= 31;
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_gather5_t4(tmp.d, tmp.d, powerbuf, np, n0, top,
                                   wvalue);
        }

        bn_flip_t4(tmp.d, tmp.d, top);
        top *= 2;
        /* back to 32-bit domain */
        tmp.top = top;
        bn_correct_top(&tmp);
        OPENSSL_cleanse(np, top * sizeof(BN_ULONG));
    } else
#endif
#if defined(OPENSSL_BN_ASM_MONT5)
    if (window == 5 && top > 1) {
        /*
         * This optimization uses ideas from http://eprint.iacr.org/2011/239,
         * specifically optimization of cache-timing attack countermeasures
         * and pre-computation optimization.
         */

        /*
         * Dedicated window==4 case improves 512-bit RSA sign by ~15%, but as
         * 512-bit RSA is hardly relevant, we omit it to spare size...
         */
        void bn_mul_mont_gather5(BN_ULONG *rp, const BN_ULONG *ap,
                                 const void *table, const BN_ULONG *np,
                                 const BN_ULONG *n0, int num, int power);
        void bn_scatter5(const BN_ULONG *inp, size_t num,
                         void *table, size_t power);
        void bn_gather5(BN_ULONG *out, size_t num, void *table, size_t power);
        void bn_power5(BN_ULONG *rp, const BN_ULONG *ap,
                       const void *table, const BN_ULONG *np,
                       const BN_ULONG *n0, int num, int power);
        int bn_get_bits5(const BN_ULONG *ap, int off);
        int bn_from_montgomery(BN_ULONG *rp, const BN_ULONG *ap,
                               const BN_ULONG *not_used, const BN_ULONG *np,
                               const BN_ULONG *n0, int num);

        BN_ULONG *np = mont->N.d, *n0 = mont->n0, *np2;

        /*
         * BN_to_montgomery can contaminate words above .top [in
         * BN_DEBUG[_DEBUG] build]...
         */
        for (i = am.top; i < top; i++)
            am.d[i] = 0;
        for (i = tmp.top; i < top; i++)
            tmp.d[i] = 0;

        if (top & 7)
            np2 = np;
        else
            for (np2 = am.d + top, i = 0; i < top; i++)
                np2[2 * i] = np[i];

        bn_scatter5(tmp.d, top, powerbuf, 0);
        bn_scatter5(am.d, am.top, powerbuf, 1);
        bn_mul_mont(tmp.d, am.d, am.d, np, n0, top);
        bn_scatter5(tmp.d, top, powerbuf, 2);

# if 0
        for (i = 3; i < 32; i++) {
            /* Calculate a^i = a^(i-1) * a */
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
        }
# else
        /* same as above, but uses squaring for 1/2 of operations */
        for (i = 4; i < 32; i *= 2) {
            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_scatter5(tmp.d, top, powerbuf, i);
        }
        for (i = 3; i < 8; i += 2) {
            int j;
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
            for (j = 2 * i; j < 32; j *= 2) {
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_scatter5(tmp.d, top, powerbuf, j);
            }
        }
        for (; i < 16; i += 2) {
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_scatter5(tmp.d, top, powerbuf, 2 * i);
        }
        for (; i < 32; i += 2) {
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
        }
# endif
        bits--;
        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)
            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
        bn_gather5(tmp.d, top, powerbuf, wvalue);

        /*
         * Scan the exponent one window at a time starting from the most
         * significant bits.
         */
        if (top & 7)
            while (bits >= 0) {
                for (wvalue = 0, i = 0; i < 5; i++, bits--)
                    wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);

                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont_gather5(tmp.d, tmp.d, powerbuf, np, n0, top,
                                    wvalue);
        } else {
            while (bits >= 0) {
                wvalue = bn_get_bits5(p->d, bits - 4);
                bits -= 5;
                bn_power5(tmp.d, tmp.d, powerbuf, np2, n0, top, wvalue);
            }
        }

        ret = bn_from_montgomery(tmp.d, tmp.d, NULL, np2, n0, top);
        tmp.top = top;
        bn_correct_top(&tmp);
        if (ret) {
            if (!BN_copy(rr, &tmp))
                ret = 0;
            goto err;           /* non-zero ret means it's not error */
        }
    } else
#endif
    {
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers))
            goto err;
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, numPowers))
            goto err;

        /*
         * If the window size is greater than 1, then calculate
         * val[i=2..2^winsize-1]. Powers are computed as a*a^(i-1) (even
         * powers could instead be computed as (a^(i/2))^2 to use the slight
         * performance advantage of sqr over mul).
         */
        if (window > 1) {
            if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))
                goto err;
            if (!MOD_EXP_CTIME_COPY_TO_PREBUF
                (&tmp, top, powerbuf, 2, numPowers))
                goto err;
            for (i = 3; i < numPowers; i++) {
                /* Calculate a^i = a^(i-1) * a */
                if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))
                    goto err;
                if (!MOD_EXP_CTIME_COPY_TO_PREBUF
                    (&tmp, top, powerbuf, i, numPowers))
                    goto err;
            }
        }

        bits--;
        for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)
            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF
            (&tmp, top, powerbuf, wvalue, numPowers))
            goto err;

        /*
         * Scan the exponent one window at a time starting from the most
     } else
 #endif
     {
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers))
             goto err;
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, numPowers))
             goto err;
 
         /*
                wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
            }

            /*
             * Fetch the appropriate pre-computed value from the pre-buf
         if (window > 1) {
             if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))
                 goto err;
            if (!MOD_EXP_CTIME_COPY_TO_PREBUF
                (&tmp, top, powerbuf, 2, numPowers))
                 goto err;
             for (i = 3; i < numPowers; i++) {
                 /* Calculate a^i = a^(i-1) * a */
                 if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))
                     goto err;
                if (!MOD_EXP_CTIME_COPY_TO_PREBUF
                    (&tmp, top, powerbuf, i, numPowers))
                     goto err;
             }
         }
        for (i = 1; i < top; i++)
         bits--;
         for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)
             wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF
            (&tmp, top, powerbuf, wvalue, numPowers))
             goto err;
 
         /*
 err:
    if ((in_mont == NULL) && (mont != NULL))
        BN_MONT_CTX_free(mont);
    if (powerbuf != NULL) {
        OPENSSL_cleanse(powerbuf, powerbufLen);
        if (powerbufFree)
            OPENSSL_free(powerbufFree);
    }
    BN_CTX_end(ctx);
    return (ret);
}

int BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p,
             /*
              * Fetch the appropriate pre-computed value from the pre-buf
              */
            if (!MOD_EXP_CTIME_COPY_FROM_PREBUF
                (&am, top, powerbuf, wvalue, numPowers))
                 goto err;
 
             /* Multiply the result into the intermediate result */
#define BN_MOD_MUL_WORD(r, w, m) \
                (BN_mul_word(r, (w)) && \
                (/* BN_ucmp(r, (m)) < 0 ? 1 :*/  \
                        (BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1))))
    /*
     * BN_MOD_MUL_WORD is only used with 'w' large, so the BN_ucmp test is
     * probably more overhead than always using BN_mod (which uses BN_copy if
     * a similar test returns true).
     */
    /*
     * We can use BN_mod and do not need BN_nnmod because our accumulator is
     * never negative (the result of BN_mod does not depend on the sign of
     * the modulus).
     */
#define BN_TO_MONTGOMERY_WORD(r, w, mont) \
                (BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx))

    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {
        /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */
        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return -1;
    }

    bn_check_top(p);
    bn_check_top(m);

    if (!BN_is_odd(m)) {
        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS);
        return (0);
    }
    if (m->top == 1)
        a %= m->d[0];           /* make sure that 'a' is reduced */

    bits = BN_num_bits(p);
    if (bits == 0) {
        /* x**0 mod 1 is still zero. */
        if (BN_is_one(m)) {
            ret = 1;
            BN_zero(rr);
        } else {
            ret = BN_one(rr);
        }
        return ret;
    }
    if (a == 0) {
        BN_zero(rr);
        ret = 1;
        return ret;
    }

    BN_CTX_start(ctx);
    d = BN_CTX_get(ctx);
    r = BN_CTX_get(ctx);
    t = BN_CTX_get(ctx);
    if (d == NULL || r == NULL || t == NULL)
        goto err;

    if (in_mont != NULL)
        mont = in_mont;
    else {
        if ((mont = BN_MONT_CTX_new()) == NULL)
            goto err;
        if (!BN_MONT_CTX_set(mont, m, ctx))
            goto err;
    }

    r_is_one = 1;               /* except for Montgomery factor */

    /* bits-1 >= 0 */

    /* The result is accumulated in the product r*w. */
    w = a;                      /* bit 'bits-1' of 'p' is always set */
    for (b = bits - 2; b >= 0; b--) {
        /* First, square r*w. */
        next_w = w * w;
        if ((next_w / w) != w) { /* overflow */
            if (r_is_one) {
                if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
                    goto err;
                r_is_one = 0;
            } else {
                if (!BN_MOD_MUL_WORD(r, w, m))
                    goto err;
            }
            next_w = 1;
        }
        w = next_w;
        if (!r_is_one) {
            if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))
                goto err;
        }

        /* Second, multiply r*w by 'a' if exponent bit is set. */
        if (BN_is_bit_set(p, b)) {
            next_w = w * a;
            if ((next_w / a) != w) { /* overflow */
                if (r_is_one) {
                    if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
                        goto err;
                    r_is_one = 0;
                } else {
                    if (!BN_MOD_MUL_WORD(r, w, m))
                        goto err;
                }
                next_w = a;
            }
            w = next_w;
        }
    }

    /* Finally, set r:=r*w. */
    if (w != 1) {
        if (r_is_one) {
            if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
                goto err;
            r_is_one = 0;
        } else {
            if (!BN_MOD_MUL_WORD(r, w, m))
                goto err;
        }
    }

    if (r_is_one) {             /* can happen only if a == 1 */
        if (!BN_one(rr))
            goto err;
    } else {
        if (!BN_from_montgomery(rr, r, mont, ctx))
            goto err;
    }
    ret = 1;
 err:
    if ((in_mont == NULL) && (mont != NULL))
        BN_MONT_CTX_free(mont);
    BN_CTX_end(ctx);
    bn_check_top(rr);
    return (ret);
}
"," static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top,
                                         unsigned char *buf, int idx,
                                        int window)
 {
    int i, j;
    int width = 1 << window;
    BN_ULONG *table = (BN_ULONG *)buf;
 
     if (top > b->top)
         top = b->top;           /* this works because 'buf' is explicitly
                                  * zeroed */
    for (i = 0, j = idx; i < top; i++, j += width) {
        table[j] = b->d[i];
     }
 
     return 1;
                                          unsigned char *buf, int idx,
 
 static int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top,
                                           unsigned char *buf, int idx,
                                          int window)
 {
    int i, j;
    int width = 1 << window;
    volatile BN_ULONG *table = (volatile BN_ULONG *)buf;
 
     if (bn_wexpand(b, top) == NULL)
         return 0;
 
    if (window <= 3) {
        for (i = 0; i < top; i++, table += width) {
            BN_ULONG acc = 0;

            for (j = 0; j < width; j++) {
                acc |= table[j] &
                       ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));
            }

            b->d[i] = acc;
        }
    } else {
        int xstride = 1 << (window - 2);
        BN_ULONG y0, y1, y2, y3;

        i = idx >> (window - 2);        /* equivalent of idx / xstride */
        idx &= xstride - 1;             /* equivalent of idx % xstride */

        y0 = (BN_ULONG)0 - (constant_time_eq_int(i,0)&1);
        y1 = (BN_ULONG)0 - (constant_time_eq_int(i,1)&1);
        y2 = (BN_ULONG)0 - (constant_time_eq_int(i,2)&1);
        y3 = (BN_ULONG)0 - (constant_time_eq_int(i,3)&1);

        for (i = 0; i < top; i++, table += width) {
            BN_ULONG acc = 0;

            for (j = 0; j < xstride; j++) {
                acc |= ( (table[j + 0 * xstride] & y0) |
                         (table[j + 1 * xstride] & y1) |
                         (table[j + 2 * xstride] & y2) |
                         (table[j + 3 * xstride] & y3) )
                       & ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));
            }

            b->d[i] = acc;
        }
     }
 
     b->top = top;
    if (!BN_is_odd(m)) {
        BNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME, BN_R_CALLED_WITH_EVEN_MODULUS);
        return (0);
    }

    top = m->top;

    bits = BN_num_bits(p);
    if (bits == 0) {
        /* x**0 mod 1 is still zero. */
        if (BN_is_one(m)) {
            ret = 1;
            BN_zero(rr);
        } else {
            ret = BN_one(rr);
        }
        return ret;
    }

    BN_CTX_start(ctx);

    /*
     * Allocate a montgomery context if it was not supplied by the caller. If
     * this is not done, things will break in the montgomery part.
     */
    if (in_mont != NULL)
        mont = in_mont;
    else {
        if ((mont = BN_MONT_CTX_new()) == NULL)
            goto err;
        if (!BN_MONT_CTX_set(mont, m, ctx))
            goto err;
    }

#ifdef RSAZ_ENABLED
    /*
     * If the size of the operands allow it, perform the optimized
     * RSAZ exponentiation. For further information see
     * crypto/bn/rsaz_exp.c and accompanying assembly modules.
     */
    if ((16 == a->top) && (16 == p->top) && (BN_num_bits(m) == 1024)
        && rsaz_avx2_eligible()) {
        if (NULL == bn_wexpand(rr, 16))
            goto err;
        RSAZ_1024_mod_exp_avx2(rr->d, a->d, p->d, m->d, mont->RR.d,
                               mont->n0[0]);
        rr->top = 16;
        rr->neg = 0;
        bn_correct_top(rr);
        ret = 1;
        goto err;
    } else if ((8 == a->top) && (8 == p->top) && (BN_num_bits(m) == 512)) {
        if (NULL == bn_wexpand(rr, 8))
            goto err;
        RSAZ_512_mod_exp(rr->d, a->d, p->d, m->d, mont->n0[0], mont->RR.d);
        rr->top = 8;
        rr->neg = 0;
        bn_correct_top(rr);
        ret = 1;
        goto err;
    }
#endif

    /* Get the window size to use with size of p. */
    window = BN_window_bits_for_ctime_exponent_size(bits);
#if defined(SPARC_T4_MONT)
    if (window >= 5 && (top & 15) == 0 && top <= 64 &&
        (OPENSSL_sparcv9cap_P[1] & (CFR_MONTMUL | CFR_MONTSQR)) ==
        (CFR_MONTMUL | CFR_MONTSQR) && (t4 = OPENSSL_sparcv9cap_P[0]))
        window = 5;
    else
#endif
#if defined(OPENSSL_BN_ASM_MONT5)
    if (window >= 5) {
        window = 5;             /* ~5% improvement for RSA2048 sign, and even
                                 * for RSA4096 */
        if ((top & 7) == 0)
            powerbufLen += 2 * top * sizeof(m->d[0]);
    }
#endif
    (void)0;

    /*
     * Allocate a buffer large enough to hold all of the pre-computed powers
     * of am, am itself and tmp.
     */
    numPowers = 1 << window;
    powerbufLen += sizeof(m->d[0]) * (top * numPowers +
                                      ((2 * top) >
                                       numPowers ? (2 * top) : numPowers));
#ifdef alloca
    if (powerbufLen < 3072)
        powerbufFree =
            alloca(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH);
    else
#endif
        if ((powerbufFree =
             (unsigned char *)OPENSSL_malloc(powerbufLen +
                                             MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH))
            == NULL)
        goto err;

    powerbuf = MOD_EXP_CTIME_ALIGN(powerbufFree);
    memset(powerbuf, 0, powerbufLen);

#ifdef alloca
    if (powerbufLen < 3072)
        powerbufFree = NULL;
#endif

    /* lay down tmp and am right after powers table */
    tmp.d = (BN_ULONG *)(powerbuf + sizeof(m->d[0]) * top * numPowers);
    am.d = tmp.d + top;
    tmp.top = am.top = 0;
    tmp.dmax = am.dmax = top;
    tmp.neg = am.neg = 0;
    tmp.flags = am.flags = BN_FLG_STATIC_DATA;

    /* prepare a^0 in Montgomery domain */
#if 1                           /* by Shay Gueron's suggestion */
    if (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {
        /* 2^(top*BN_BITS2) - m */
        tmp.d[0] = (0 - m->d[0]) & BN_MASK2;
        for (i = 1; i < top; i++)
            tmp.d[i] = (~m->d[i]) & BN_MASK2;
        tmp.top = top;
    } else
#endif
    if (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))
        goto err;

    /* prepare a^1 in Montgomery domain */
    if (a->neg || BN_ucmp(a, m) >= 0) {
        if (!BN_mod(&am, a, m, ctx))
            goto err;
        if (!BN_to_montgomery(&am, &am, mont, ctx))
            goto err;
    } else if (!BN_to_montgomery(&am, a, mont, ctx))
        goto err;

#if defined(SPARC_T4_MONT)
    if (t4) {
        typedef int (*bn_pwr5_mont_f) (BN_ULONG *tp, const BN_ULONG *np,
                                       const BN_ULONG *n0, const void *table,
                                       int power, int bits);
        int bn_pwr5_mont_t4_8(BN_ULONG *tp, const BN_ULONG *np,
                              const BN_ULONG *n0, const void *table,
                              int power, int bits);
        int bn_pwr5_mont_t4_16(BN_ULONG *tp, const BN_ULONG *np,
                               const BN_ULONG *n0, const void *table,
                               int power, int bits);
        int bn_pwr5_mont_t4_24(BN_ULONG *tp, const BN_ULONG *np,
                               const BN_ULONG *n0, const void *table,
                               int power, int bits);
        int bn_pwr5_mont_t4_32(BN_ULONG *tp, const BN_ULONG *np,
                               const BN_ULONG *n0, const void *table,
                               int power, int bits);
        static const bn_pwr5_mont_f pwr5_funcs[4] = {
            bn_pwr5_mont_t4_8, bn_pwr5_mont_t4_16,
            bn_pwr5_mont_t4_24, bn_pwr5_mont_t4_32
        };
        bn_pwr5_mont_f pwr5_worker = pwr5_funcs[top / 16 - 1];

        typedef int (*bn_mul_mont_f) (BN_ULONG *rp, const BN_ULONG *ap,
                                      const void *bp, const BN_ULONG *np,
                                      const BN_ULONG *n0);
        int bn_mul_mont_t4_8(BN_ULONG *rp, const BN_ULONG *ap, const void *bp,
                             const BN_ULONG *np, const BN_ULONG *n0);
        int bn_mul_mont_t4_16(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0);
        int bn_mul_mont_t4_24(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0);
        int bn_mul_mont_t4_32(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0);
        static const bn_mul_mont_f mul_funcs[4] = {
            bn_mul_mont_t4_8, bn_mul_mont_t4_16,
            bn_mul_mont_t4_24, bn_mul_mont_t4_32
        };
        bn_mul_mont_f mul_worker = mul_funcs[top / 16 - 1];

        void bn_mul_mont_vis3(BN_ULONG *rp, const BN_ULONG *ap,
                              const void *bp, const BN_ULONG *np,
                              const BN_ULONG *n0, int num);
        void bn_mul_mont_t4(BN_ULONG *rp, const BN_ULONG *ap,
                            const void *bp, const BN_ULONG *np,
                            const BN_ULONG *n0, int num);
        void bn_mul_mont_gather5_t4(BN_ULONG *rp, const BN_ULONG *ap,
                                    const void *table, const BN_ULONG *np,
                                    const BN_ULONG *n0, int num, int power);
        void bn_flip_n_scatter5_t4(const BN_ULONG *inp, size_t num,
                                   void *table, size_t power);
        void bn_gather5_t4(BN_ULONG *out, size_t num,
                           void *table, size_t power);
        void bn_flip_t4(BN_ULONG *dst, BN_ULONG *src, size_t num);

        BN_ULONG *np = mont->N.d, *n0 = mont->n0;
        int stride = 5 * (6 - (top / 16 - 1)); /* multiple of 5, but less
                                                * than 32 */

        /*
         * BN_to_montgomery can contaminate words above .top [in
         * BN_DEBUG[_DEBUG] build]...
         */
        for (i = am.top; i < top; i++)
            am.d[i] = 0;
        for (i = tmp.top; i < top; i++)
            tmp.d[i] = 0;

        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 0);
        bn_flip_n_scatter5_t4(am.d, top, powerbuf, 1);
        if (!(*mul_worker) (tmp.d, am.d, am.d, np, n0) &&
            !(*mul_worker) (tmp.d, am.d, am.d, np, n0))
            bn_mul_mont_vis3(tmp.d, am.d, am.d, np, n0, top);
        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 2);

        for (i = 3; i < 32; i++) {
            /* Calculate a^i = a^(i-1) * a */
            if (!(*mul_worker) (tmp.d, tmp.d, am.d, np, n0) &&
                !(*mul_worker) (tmp.d, tmp.d, am.d, np, n0))
                bn_mul_mont_vis3(tmp.d, tmp.d, am.d, np, n0, top);
            bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, i);
        }

        /* switch to 64-bit domain */
        np = alloca(top * sizeof(BN_ULONG));
        top /= 2;
        bn_flip_t4(np, mont->N.d, top);

        bits--;
        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)
            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
        bn_gather5_t4(tmp.d, top, powerbuf, wvalue);

        /*
         * Scan the exponent one window at a time starting from the most
         * significant bits.
         */
        while (bits >= 0) {
            if (bits < stride)
                stride = bits + 1;
            bits -= stride;
            wvalue = bn_get_bits(p, bits + 1);

            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))
                continue;
            /* retry once and fall back */
            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))
                continue;

            bits += stride - 5;
            wvalue >>= stride - 5;
            wvalue &= 31;
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_mul_mont_gather5_t4(tmp.d, tmp.d, powerbuf, np, n0, top,
                                   wvalue);
        }

        bn_flip_t4(tmp.d, tmp.d, top);
        top *= 2;
        /* back to 32-bit domain */
        tmp.top = top;
        bn_correct_top(&tmp);
        OPENSSL_cleanse(np, top * sizeof(BN_ULONG));
    } else
#endif
#if defined(OPENSSL_BN_ASM_MONT5)
    if (window == 5 && top > 1) {
        /*
         * This optimization uses ideas from http://eprint.iacr.org/2011/239,
         * specifically optimization of cache-timing attack countermeasures
         * and pre-computation optimization.
         */

        /*
         * Dedicated window==4 case improves 512-bit RSA sign by ~15%, but as
         * 512-bit RSA is hardly relevant, we omit it to spare size...
         */
        void bn_mul_mont_gather5(BN_ULONG *rp, const BN_ULONG *ap,
                                 const void *table, const BN_ULONG *np,
                                 const BN_ULONG *n0, int num, int power);
        void bn_scatter5(const BN_ULONG *inp, size_t num,
                         void *table, size_t power);
        void bn_gather5(BN_ULONG *out, size_t num, void *table, size_t power);
        void bn_power5(BN_ULONG *rp, const BN_ULONG *ap,
                       const void *table, const BN_ULONG *np,
                       const BN_ULONG *n0, int num, int power);
        int bn_get_bits5(const BN_ULONG *ap, int off);
        int bn_from_montgomery(BN_ULONG *rp, const BN_ULONG *ap,
                               const BN_ULONG *not_used, const BN_ULONG *np,
                               const BN_ULONG *n0, int num);

        BN_ULONG *np = mont->N.d, *n0 = mont->n0, *np2;

        /*
         * BN_to_montgomery can contaminate words above .top [in
         * BN_DEBUG[_DEBUG] build]...
         */
        for (i = am.top; i < top; i++)
            am.d[i] = 0;
        for (i = tmp.top; i < top; i++)
            tmp.d[i] = 0;

        if (top & 7)
            np2 = np;
        else
            for (np2 = am.d + top, i = 0; i < top; i++)
                np2[2 * i] = np[i];

        bn_scatter5(tmp.d, top, powerbuf, 0);
        bn_scatter5(am.d, am.top, powerbuf, 1);
        bn_mul_mont(tmp.d, am.d, am.d, np, n0, top);
        bn_scatter5(tmp.d, top, powerbuf, 2);

# if 0
        for (i = 3; i < 32; i++) {
            /* Calculate a^i = a^(i-1) * a */
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
        }
# else
        /* same as above, but uses squaring for 1/2 of operations */
        for (i = 4; i < 32; i *= 2) {
            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_scatter5(tmp.d, top, powerbuf, i);
        }
        for (i = 3; i < 8; i += 2) {
            int j;
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
            for (j = 2 * i; j < 32; j *= 2) {
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_scatter5(tmp.d, top, powerbuf, j);
            }
        }
        for (; i < 16; i += 2) {
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
            bn_scatter5(tmp.d, top, powerbuf, 2 * i);
        }
        for (; i < 32; i += 2) {
            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);
            bn_scatter5(tmp.d, top, powerbuf, i);
        }
# endif
        bits--;
        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)
            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
        bn_gather5(tmp.d, top, powerbuf, wvalue);

        /*
         * Scan the exponent one window at a time starting from the most
         * significant bits.
         */
        if (top & 7)
            while (bits >= 0) {
                for (wvalue = 0, i = 0; i < 5; i++, bits--)
                    wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);

                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
                bn_mul_mont_gather5(tmp.d, tmp.d, powerbuf, np, n0, top,
                                    wvalue);
        } else {
            while (bits >= 0) {
                wvalue = bn_get_bits5(p->d, bits - 4);
                bits -= 5;
                bn_power5(tmp.d, tmp.d, powerbuf, np2, n0, top, wvalue);
            }
        }

        ret = bn_from_montgomery(tmp.d, tmp.d, NULL, np2, n0, top);
        tmp.top = top;
        bn_correct_top(&tmp);
        if (ret) {
            if (!BN_copy(rr, &tmp))
                ret = 0;
            goto err;           /* non-zero ret means it's not error */
        }
    } else
#endif
    {
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers))
            goto err;
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, numPowers))
            goto err;

        /*
         * If the window size is greater than 1, then calculate
         * val[i=2..2^winsize-1]. Powers are computed as a*a^(i-1) (even
         * powers could instead be computed as (a^(i/2))^2 to use the slight
         * performance advantage of sqr over mul).
         */
        if (window > 1) {
            if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))
                goto err;
            if (!MOD_EXP_CTIME_COPY_TO_PREBUF
                (&tmp, top, powerbuf, 2, numPowers))
                goto err;
            for (i = 3; i < numPowers; i++) {
                /* Calculate a^i = a^(i-1) * a */
                if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))
                    goto err;
                if (!MOD_EXP_CTIME_COPY_TO_PREBUF
                    (&tmp, top, powerbuf, i, numPowers))
                    goto err;
            }
        }

        bits--;
        for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)
            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF
            (&tmp, top, powerbuf, wvalue, numPowers))
            goto err;

        /*
         * Scan the exponent one window at a time starting from the most
     } else
 #endif
     {
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, window))
             goto err;
        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, window))
             goto err;
 
         /*
                wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
            }

            /*
             * Fetch the appropriate pre-computed value from the pre-buf
         if (window > 1) {
             if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))
                 goto err;
            if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 2,
                                              window))
                 goto err;
             for (i = 3; i < numPowers; i++) {
                 /* Calculate a^i = a^(i-1) * a */
                 if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))
                     goto err;
                if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, i,
                                                  window))
                     goto err;
             }
         }
        for (i = 1; i < top; i++)
         bits--;
         for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)
             wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&tmp, top, powerbuf, wvalue,
                                            window))
             goto err;
 
         /*
 err:
    if ((in_mont == NULL) && (mont != NULL))
        BN_MONT_CTX_free(mont);
    if (powerbuf != NULL) {
        OPENSSL_cleanse(powerbuf, powerbufLen);
        if (powerbufFree)
            OPENSSL_free(powerbufFree);
    }
    BN_CTX_end(ctx);
    return (ret);
}

int BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p,
             /*
              * Fetch the appropriate pre-computed value from the pre-buf
              */
            if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&am, top, powerbuf, wvalue,
                                                window))
                 goto err;
 
             /* Multiply the result into the intermediate result */
#define BN_MOD_MUL_WORD(r, w, m) \
                (BN_mul_word(r, (w)) && \
                (/* BN_ucmp(r, (m)) < 0 ? 1 :*/  \
                        (BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1))))
    /*
     * BN_MOD_MUL_WORD is only used with 'w' large, so the BN_ucmp test is
     * probably more overhead than always using BN_mod (which uses BN_copy if
     * a similar test returns true).
     */
    /*
     * We can use BN_mod and do not need BN_nnmod because our accumulator is
     * never negative (the result of BN_mod does not depend on the sign of
     * the modulus).
     */
#define BN_TO_MONTGOMERY_WORD(r, w, mont) \
                (BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx))

    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {
        /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */
        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return -1;
    }

    bn_check_top(p);
    bn_check_top(m);

    if (!BN_is_odd(m)) {
        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS);
        return (0);
    }
    if (m->top == 1)
        a %= m->d[0];           /* make sure that 'a' is reduced */

    bits = BN_num_bits(p);
    if (bits == 0) {
        /* x**0 mod 1 is still zero. */
        if (BN_is_one(m)) {
            ret = 1;
            BN_zero(rr);
        } else {
            ret = BN_one(rr);
        }
        return ret;
    }
    if (a == 0) {
        BN_zero(rr);
        ret = 1;
        return ret;
    }

    BN_CTX_start(ctx);
    d = BN_CTX_get(ctx);
    r = BN_CTX_get(ctx);
    t = BN_CTX_get(ctx);
    if (d == NULL || r == NULL || t == NULL)
        goto err;

    if (in_mont != NULL)
        mont = in_mont;
    else {
        if ((mont = BN_MONT_CTX_new()) == NULL)
            goto err;
        if (!BN_MONT_CTX_set(mont, m, ctx))
            goto err;
    }

    r_is_one = 1;               /* except for Montgomery factor */

    /* bits-1 >= 0 */

    /* The result is accumulated in the product r*w. */
    w = a;                      /* bit 'bits-1' of 'p' is always set */
    for (b = bits - 2; b >= 0; b--) {
        /* First, square r*w. */
        next_w = w * w;
        if ((next_w / w) != w) { /* overflow */
            if (r_is_one) {
                if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
                    goto err;
                r_is_one = 0;
            } else {
                if (!BN_MOD_MUL_WORD(r, w, m))
                    goto err;
            }
            next_w = 1;
        }
        w = next_w;
        if (!r_is_one) {
            if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))
                goto err;
        }

        /* Second, multiply r*w by 'a' if exponent bit is set. */
        if (BN_is_bit_set(p, b)) {
            next_w = w * a;
            if ((next_w / a) != w) { /* overflow */
                if (r_is_one) {
                    if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
                        goto err;
                    r_is_one = 0;
                } else {
                    if (!BN_MOD_MUL_WORD(r, w, m))
                        goto err;
                }
                next_w = a;
            }
            w = next_w;
        }
    }

    /* Finally, set r:=r*w. */
    if (w != 1) {
        if (r_is_one) {
            if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
                goto err;
            r_is_one = 0;
        } else {
            if (!BN_MOD_MUL_WORD(r, w, m))
                goto err;
        }
    }

    if (r_is_one) {             /* can happen only if a == 1 */
        if (!BN_one(rr))
            goto err;
    } else {
        if (!BN_from_montgomery(rr, r, mont, ctx))
            goto err;
    }
    ret = 1;
 err:
    if ((in_mont == NULL) && (mont != NULL))
        BN_MONT_CTX_free(mont);
    BN_CTX_end(ctx);
    bn_check_top(rr);
    return (ret);
}
","The provided code implements two functions, `MOD_EXP_CTIME_COPY_TO_PREBUF` and `MOD_EXP_CTIME_COPY_FROM_PREBUF`, which facilitate the secure and efficient handling of large integer exponentiation in a constant-time manner, crucial for cryptographic applications. The first function copies data from a `BIGNUM` structure into a buffer at specified intervals, ensuring that the buffer is filled correctly based on the size of the `BIGNUM`. The second function retrieves data from the buffer back into a `BIGNUM`, expanding it as necessary. Both functions are designed to prevent timing attacks by maintaining consistent execution times regardless of the data being processed.","The code implements functions for securely copying data between a large integer structure and a buffer, facilitating constant-time operations essential for cryptographic computations. The first function transfers data from the integer structure to the buffer, ensuring proper alignment and spacing, while the second function retrieves data from the buffer back into the integer structure, expanding it as needed. Both functions are designed to mitigate timing attacks by ensuring that execution time remains consistent, regardless of the specific data being processed, thereby enhancing the security of cryptographic algorithms that rely on these operations.","The vulnerability in the original code stemmed from the potential for timing attacks due to the way data was copied from a buffer to a large integer structure. Specifically, the original implementation did not ensure that the data was processed in a constant-time manner, allowing an attacker to infer information based on the time taken for operations. The fix introduced a more secure approach by using volatile pointers and incorporating constant-time equality checks, ensuring that the data was accessed and processed uniformly regardless of the values being handled. This change mitigated the risk of timing attacks by eliminating data-dependent execution paths.","The vulnerability in the original code was related to the potential for timing attacks, where an attacker could gain information about the data being processed based on the time taken for operations. This was due to the lack of constant-time execution when copying data from a buffer to a data structure, which could lead to variations in execution time depending on the values being handled. The fix addressed this issue by implementing a method that ensured all data was processed in a uniform manner, using techniques that eliminated data-dependent execution paths, thereby enhancing security against timing attacks.","The vulnerability was fixed by modifying the data copying functions to ensure constant-time execution. In the updated code, the use of volatile pointers for the buffer ensures that the compiler does not optimize away necessary reads, while the introduction of constant-time equality checks prevents timing variations based on the data being processed. Specifically, the inner loops now utilize an accumulator that combines results based on equality checks, ensuring that all potential data paths are executed uniformly. This approach mitigates the risk of timing attacks by making the execution time independent of the values being handled.","The vulnerability was fixed by implementing a constant-time approach for data copying operations, which prevents timing attacks. The updated code introduced mechanisms to ensure that all data is processed uniformly, regardless of its values. This was achieved by using techniques that incorporate equality checks in a way that does not allow execution time to vary based on the data being handled. Additionally, the use of volatile pointers ensures that the compiler does not optimize away critical reads, further reinforcing the constant-time behavior and enhancing the overall security of the data processing operations.","4,4","5, 4","4, 4","4,4"
24,24,178430,178430,,Remote,Not required,,CVE-2016-0701,https://www.cvedetails.com/cve/CVE-2016-0701/,CWE-200,High,Partial,,,2016-02-14,2.6,"The DH_check_pub_key function in crypto/dh/dh_check.c in OpenSSL 1.0.2 before 1.0.2f does not ensure that prime numbers are appropriate for Diffie-Hellman (DH) key exchange, which makes it easier for remote attackers to discover a private DH exponent by making multiple handshakes with a peer that chose an inappropriate number, as demonstrated by a number in an X9.42 file.",2017-12-12,+Info,25,https://git.openssl.org/?p=openssl.git;a=commit;h=878e2c5b13010329c203f309ed0c8f2113f85648,878e2c5b13010329c203f309ed0c8f2113f85648,,10,,," int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *ret)
 {
     int ok = 0;
    BIGNUM *tmp = NULL;
    BN_CTX *ctx = NULL;
 
     *ret = 0;
    ctx = BN_CTX_new();
    if (ctx == NULL)
         goto err;
    BN_CTX_start(ctx);
    tmp = BN_CTX_get(ctx);
    if (tmp == NULL)
        goto err;
    BN_set_word(tmp, 1);
    if (BN_cmp(pub_key, tmp) <= 0)
         *ret |= DH_CHECK_PUBKEY_TOO_SMALL;
    BN_copy(tmp, dh->p);
    BN_sub_word(tmp, 1);
    if (BN_cmp(pub_key, tmp) >= 0)
         *ret |= DH_CHECK_PUBKEY_TOO_LARGE;
 
    if (dh->q != NULL) {
        /* Check pub_key^q == 1 mod p */
        if (!BN_mod_exp(tmp, pub_key, dh->q, dh->p, ctx))
            goto err;
        if (!BN_is_one(tmp))
            *ret |= DH_CHECK_PUBKEY_INVALID;
    }

     ok = 1;
  err:
    if (ctx != NULL) {
        BN_CTX_end(ctx);
        BN_CTX_free(ctx);
    }
     return (ok);
 }
"," int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *ret)
 {
     int ok = 0;
    BIGNUM *q = NULL;
 
     *ret = 0;
    q = BN_new();
    if (q == NULL)
         goto err;
    BN_set_word(q, 1);
    if (BN_cmp(pub_key, q) <= 0)
         *ret |= DH_CHECK_PUBKEY_TOO_SMALL;
    BN_copy(q, dh->p);
    BN_sub_word(q, 1);
    if (BN_cmp(pub_key, q) >= 0)
         *ret |= DH_CHECK_PUBKEY_TOO_LARGE;
 
     ok = 1;
  err:
    if (q != NULL)
        BN_free(q);
     return (ok);
 }
",C,"    BIGNUM *tmp = NULL;
    BN_CTX *ctx = NULL;
    ctx = BN_CTX_new();
    if (ctx == NULL)
    BN_CTX_start(ctx);
    tmp = BN_CTX_get(ctx);
    if (tmp == NULL)
        goto err;
    BN_set_word(tmp, 1);
    if (BN_cmp(pub_key, tmp) <= 0)
    BN_copy(tmp, dh->p);
    BN_sub_word(tmp, 1);
    if (BN_cmp(pub_key, tmp) >= 0)
    if (dh->q != NULL) {
        /* Check pub_key^q == 1 mod p */
        if (!BN_mod_exp(tmp, pub_key, dh->q, dh->p, ctx))
            goto err;
        if (!BN_is_one(tmp))
            *ret |= DH_CHECK_PUBKEY_INVALID;
    }

    if (ctx != NULL) {
        BN_CTX_end(ctx);
        BN_CTX_free(ctx);
    }
","    BIGNUM *q = NULL;
    q = BN_new();
    if (q == NULL)
    BN_set_word(q, 1);
    if (BN_cmp(pub_key, q) <= 0)
    BN_copy(q, dh->p);
    BN_sub_word(q, 1);
    if (BN_cmp(pub_key, q) >= 0)
    if (q != NULL)
        BN_free(q);
",d81a1600588b726c2bdccda7efad3cc7a87d6245,"@@ -151,23 +151,38 @@ int DH_check(const DH *dh, int *ret)
 int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *ret)
 {
     int ok = 0;
-    BIGNUM *q = NULL;
+    BIGNUM *tmp = NULL;
+    BN_CTX *ctx = NULL;
 
     *ret = 0;
-    q = BN_new();
-    if (q == NULL)
+    ctx = BN_CTX_new();
+    if (ctx == NULL)
         goto err;
-    BN_set_word(q, 1);
-    if (BN_cmp(pub_key, q) <= 0)
+    BN_CTX_start(ctx);
+    tmp = BN_CTX_get(ctx);
+    if (tmp == NULL)
+        goto err;
+    BN_set_word(tmp, 1);
+    if (BN_cmp(pub_key, tmp) <= 0)
         *ret |= DH_CHECK_PUBKEY_TOO_SMALL;
-    BN_copy(q, dh->p);
-    BN_sub_word(q, 1);
-    if (BN_cmp(pub_key, q) >= 0)
+    BN_copy(tmp, dh->p);
+    BN_sub_word(tmp, 1);
+    if (BN_cmp(pub_key, tmp) >= 0)
         *ret |= DH_CHECK_PUBKEY_TOO_LARGE;
 
+    if (dh->q != NULL) {
+        /* Check pub_key^q == 1 mod p */
+        if (!BN_mod_exp(tmp, pub_key, dh->q, dh->p, ctx))
+            goto err;
+        if (!BN_is_one(tmp))
+            *ret |= DH_CHECK_PUBKEY_INVALID;
+    }
+
     ok = 1;
  err:
-    if (q != NULL)
-        BN_free(q);
+    if (ctx != NULL) {
+        BN_CTX_end(ctx);
+        BN_CTX_free(ctx);
+    }
     return (ok);
 }",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/dh/dh_check.c;h=5adedc0d264e99aae5d68ef2e4c5585dcfd33de3;hb=878e2c5b13010329c203f309ed0c8f2113f85648,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/dh/dh_check.c;h=347467c6a43369dfe948f05fd33373ab0f1b0ae9,1," int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *ret)
 {
     int ok = 0;
//flaw_line_below:
    BIGNUM *q = NULL;
//fix_flaw_line_below:
//    BIGNUM *tmp = NULL;
//fix_flaw_line_below:
//    BN_CTX *ctx = NULL;
 
     *ret = 0;
//flaw_line_below:
    q = BN_new();
//flaw_line_below:
    if (q == NULL)
//fix_flaw_line_below:
//    ctx = BN_CTX_new();
//fix_flaw_line_below:
//    if (ctx == NULL)
         goto err;
//flaw_line_below:
    BN_set_word(q, 1);
//flaw_line_below:
    if (BN_cmp(pub_key, q) <= 0)
//fix_flaw_line_below:
//    BN_CTX_start(ctx);
//fix_flaw_line_below:
//    tmp = BN_CTX_get(ctx);
//fix_flaw_line_below:
//    if (tmp == NULL)
//fix_flaw_line_below:
//        goto err;
//fix_flaw_line_below:
//    BN_set_word(tmp, 1);
//fix_flaw_line_below:
//    if (BN_cmp(pub_key, tmp) <= 0)
         *ret |= DH_CHECK_PUBKEY_TOO_SMALL;
//flaw_line_below:
    BN_copy(q, dh->p);
//flaw_line_below:
    BN_sub_word(q, 1);
//flaw_line_below:
    if (BN_cmp(pub_key, q) >= 0)
//fix_flaw_line_below:
//    BN_copy(tmp, dh->p);
//fix_flaw_line_below:
//    BN_sub_word(tmp, 1);
//fix_flaw_line_below:
//    if (BN_cmp(pub_key, tmp) >= 0)
         *ret |= DH_CHECK_PUBKEY_TOO_LARGE;
 
//fix_flaw_line_below:
//    if (dh->q != NULL) {
//fix_flaw_line_below:
//        /* Check pub_key^q == 1 mod p */
//fix_flaw_line_below:
//        if (!BN_mod_exp(tmp, pub_key, dh->q, dh->p, ctx))
//fix_flaw_line_below:
//            goto err;
//fix_flaw_line_below:
//        if (!BN_is_one(tmp))
//fix_flaw_line_below:
//            *ret |= DH_CHECK_PUBKEY_INVALID;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     ok = 1;
  err:
//flaw_line_below:
    if (q != NULL)
//flaw_line_below:
        BN_free(q);
//fix_flaw_line_below:
//    if (ctx != NULL) {
//fix_flaw_line_below:
//        BN_CTX_end(ctx);
//fix_flaw_line_below:
//        BN_CTX_free(ctx);
//fix_flaw_line_below:
//    }
     return (ok);
 }
",178430," int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *ret)
 {
     int ok = 0;
    BIGNUM *q = NULL;
 
     *ret = 0;
    q = BN_new();
    if (q == NULL)
         goto err;
    BN_set_word(q, 1);
    if (BN_cmp(pub_key, q) <= 0)
         *ret |= DH_CHECK_PUBKEY_TOO_SMALL;
    BN_copy(q, dh->p);
    BN_sub_word(q, 1);
    if (BN_cmp(pub_key, q) >= 0)
         *ret |= DH_CHECK_PUBKEY_TOO_LARGE;
 
     ok = 1;
  err:
    if (q != NULL)
        BN_free(q);
     return (ok);
 }
"," int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *ret)
 {
     int ok = 0;
    BIGNUM *tmp = NULL;
    BN_CTX *ctx = NULL;
 
     *ret = 0;
    ctx = BN_CTX_new();
    if (ctx == NULL)
         goto err;
    BN_CTX_start(ctx);
    tmp = BN_CTX_get(ctx);
    if (tmp == NULL)
        goto err;
    BN_set_word(tmp, 1);
    if (BN_cmp(pub_key, tmp) <= 0)
         *ret |= DH_CHECK_PUBKEY_TOO_SMALL;
    BN_copy(tmp, dh->p);
    BN_sub_word(tmp, 1);
    if (BN_cmp(pub_key, tmp) >= 0)
         *ret |= DH_CHECK_PUBKEY_TOO_LARGE;
 
    if (dh->q != NULL) {
        /* Check pub_key^q == 1 mod p */
        if (!BN_mod_exp(tmp, pub_key, dh->q, dh->p, ctx))
            goto err;
        if (!BN_is_one(tmp))
            *ret |= DH_CHECK_PUBKEY_INVALID;
    }

     ok = 1;
  err:
    if (ctx != NULL) {
        BN_CTX_end(ctx);
        BN_CTX_free(ctx);
    }
     return (ok);
 }
","The function `DH_check_pub_key` validates a given public key against the constraints of a Diffie-Hellman (DH) key exchange. It takes a DH structure, a public key, and a pointer to an integer for return status. The function initializes a temporary BIGNUM variable `q` to check if the public key is too small (less than or equal to 1) or too large (greater than or equal to p-1, where p is a prime number in the DH structure). It sets appropriate flags in the `ret` variable based on these comparisons and ensures proper memory management by freeing the allocated BIGNUM before returning a success status.","The code defines a function that checks the validity of a public key used in a key exchange protocol. It initializes a temporary variable to facilitate comparisons and sets a return status to indicate any issues. The function verifies if the public key is too small by checking if it is less than or equal to one, and it also checks if the key is too large by comparing it to a specific upper limit derived from a prime number. Appropriate flags are set based on these conditions, and memory is managed properly before returning a success status.","The vulnerability in the original code stemmed from a lack of validation for the public key, which could allow an invalid key to be accepted, potentially compromising the security of the key exchange. The fixed code addresses this by introducing a new context variable and utilizing modular exponentiation to check if the public key raised to the power of a specific value equals one modulo a prime number. This additional validation ensures that the public key is not only within acceptable bounds but also mathematically valid, enhancing the overall security of the key exchange process.","The vulnerability in the original code was due to insufficient validation of the public key, which could allow an invalid key to be accepted, potentially leading to security risks in the key exchange process. The fixed code enhances security by introducing a context for managing temporary variables and adding a crucial mathematical check to ensure the public key meets specific criteria. This check verifies that the public key, when raised to a certain power, results in a specific value under modular arithmetic, thereby ensuring that only valid keys are accepted and improving the overall integrity of the key exchange mechanism.","The vulnerability was fixed by introducing a context variable and performing an additional validation check on the public key. The code now creates a new context using `BN_CTX_new()` and retrieves a temporary variable with `BN_CTX_get()`. It then checks if the public key raised to the power of a specific value equals one modulo a prime number using `BN_mod_exp()`. If this condition is not met, the code sets a flag indicating that the public key is invalid. This enhancement ensures that only mathematically valid public keys are accepted, thereby strengthening the security of the key exchange process.","The vulnerability was addressed by implementing a more robust validation mechanism for the public key. The updated code introduces a context for managing temporary variables and includes an additional mathematical check to ensure the public key adheres to specific criteria. This check verifies that the public key, when raised to a certain power, results in a predetermined value under modular arithmetic. By incorporating this validation step, the code ensures that only valid public keys are accepted, thereby enhancing the overall security and integrity of the key exchange process.","5,4","5,5","4,5","4,4"
25,25,178436,178436,,Remote,Not required,,CVE-2016-7977,https://www.cvedetails.com/cve/CVE-2016-7977/,CWE-200,Medium,Partial,,,2017-05-23,4.3,Ghostscript before 9.21 might allow remote attackers to bypass the SAFER mode protection mechanism and consequently read arbitrary files via the use of the .libfile operator in a crafted postscript document.,2018-01-18,Bypass +Info,3,http://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=8abd22010eb4db0fb1b10e430d5f5d83e015ef70,8abd22010eb4db0fb1b10e430d5f5d83e015ef70,,0,,,"lib_file_open(gs_file_path_ptr  lib_path, const gs_memory_t *mem, i_ctx_t *i_ctx_p,
                       const char *fname, uint flen, char *buffer, int blen, uint *pclen, ref *pfile)
{   /* i_ctx_p is NULL running arg (@) files.
     * lib_path and mem are never NULL
     */
    bool starting_arg_file = (i_ctx_p == NULL) ? true : i_ctx_p->starting_arg_file;
    bool search_with_no_combine = false;
    bool search_with_combine = false;
    char fmode[2] = { 'r', 0};
    gx_io_device *iodev = iodev_default(mem);
     gs_main_instance *minst = get_minst_from_memory(mem);
     int code;
 
    if (i_ctx_p && starting_arg_file)
        i_ctx_p->starting_arg_file = false;

     /* when starting arg files (@ files) iodev_default is not yet set */
     if (iodev == 0)
         iodev = (gx_io_device *)gx_io_device_table[0];
       search_with_combine = false;
    } else {
       search_with_no_combine = starting_arg_file;
       search_with_combine = true;
    }
","lib_file_open(gs_file_path_ptr  lib_path, const gs_memory_t *mem, i_ctx_t *i_ctx_p,
                       const char *fname, uint flen, char *buffer, int blen, uint *pclen, ref *pfile)
{   /* i_ctx_p is NULL running arg (@) files.
     * lib_path and mem are never NULL
     */
    bool starting_arg_file = (i_ctx_p == NULL) ? true : i_ctx_p->starting_arg_file;
    bool search_with_no_combine = false;
    bool search_with_combine = false;
    char fmode[2] = { 'r', 0};
    gx_io_device *iodev = iodev_default(mem);
     gs_main_instance *minst = get_minst_from_memory(mem);
     int code;
 
     /* when starting arg files (@ files) iodev_default is not yet set */
     if (iodev == 0)
         iodev = (gx_io_device *)gx_io_device_table[0];
       search_with_combine = false;
    } else {
       search_with_no_combine = starting_arg_file;
       search_with_combine = true;
    }
",C,"    if (i_ctx_p && starting_arg_file)
        i_ctx_p->starting_arg_file = false;

",,d609a3d4c1b8583d1c22db6b4d3bce4b239cf88c,"@@ -1081,6 +1081,9 @@ lib_file_open(gs_file_path_ptr  lib_path, const gs_memory_t *mem, i_ctx_t *i_ctx
     gs_main_instance *minst = get_minst_from_memory(mem);
     int code;
 
+    if (i_ctx_p && starting_arg_file)
+        i_ctx_p->starting_arg_file = false;
+
     /* when starting arg files (@ files) iodev_default is not yet set */
     if (iodev == 0)
         iodev = (gx_io_device *)gx_io_device_table[0];",ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zfile.c;h=2c6c9588b39d8c9bc86c744a1356efcae0f4d18e;hb=8abd22010eb4db0fb1b10e430d5f5d83e015ef70,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/zfile.c;h=b6caea2cf7b04ff26a440add80fe20cd7b914fad,1,"lib_file_open(gs_file_path_ptr  lib_path, const gs_memory_t *mem, i_ctx_t *i_ctx_p,
                       const char *fname, uint flen, char *buffer, int blen, uint *pclen, ref *pfile)
{   /* i_ctx_p is NULL running arg (@) files.
     * lib_path and mem are never NULL
     */
    bool starting_arg_file = (i_ctx_p == NULL) ? true : i_ctx_p->starting_arg_file;
    bool search_with_no_combine = false;
    bool search_with_combine = false;
    char fmode[2] = { 'r', 0};
    gx_io_device *iodev = iodev_default(mem);
     gs_main_instance *minst = get_minst_from_memory(mem);
     int code;
 
//fix_flaw_line_below:
//    if (i_ctx_p && starting_arg_file)
//fix_flaw_line_below:
//        i_ctx_p->starting_arg_file = false;
//fix_flaw_line_below:
//
     /* when starting arg files (@ files) iodev_default is not yet set */
     if (iodev == 0)
         iodev = (gx_io_device *)gx_io_device_table[0];
       search_with_combine = false;
    } else {
       search_with_no_combine = starting_arg_file;
       search_with_combine = true;
    }
",178436,"lib_file_open(gs_file_path_ptr  lib_path, const gs_memory_t *mem, i_ctx_t *i_ctx_p,
                       const char *fname, uint flen, char *buffer, int blen, uint *pclen, ref *pfile)
{   /* i_ctx_p is NULL running arg (@) files.
     * lib_path and mem are never NULL
     */
    bool starting_arg_file = (i_ctx_p == NULL) ? true : i_ctx_p->starting_arg_file;
    bool search_with_no_combine = false;
    bool search_with_combine = false;
    char fmode[2] = { 'r', 0};
    gx_io_device *iodev = iodev_default(mem);
     gs_main_instance *minst = get_minst_from_memory(mem);
     int code;
 
     /* when starting arg files (@ files) iodev_default is not yet set */
     if (iodev == 0)
         iodev = (gx_io_device *)gx_io_device_table[0];
       search_with_combine = false;
    } else {
       search_with_no_combine = starting_arg_file;
       search_with_combine = true;
    }
","lib_file_open(gs_file_path_ptr  lib_path, const gs_memory_t *mem, i_ctx_t *i_ctx_p,
                       const char *fname, uint flen, char *buffer, int blen, uint *pclen, ref *pfile)
{   /* i_ctx_p is NULL running arg (@) files.
     * lib_path and mem are never NULL
     */
    bool starting_arg_file = (i_ctx_p == NULL) ? true : i_ctx_p->starting_arg_file;
    bool search_with_no_combine = false;
    bool search_with_combine = false;
    char fmode[2] = { 'r', 0};
    gx_io_device *iodev = iodev_default(mem);
     gs_main_instance *minst = get_minst_from_memory(mem);
     int code;
 
    if (i_ctx_p && starting_arg_file)
        i_ctx_p->starting_arg_file = false;

     /* when starting arg files (@ files) iodev_default is not yet set */
     if (iodev == 0)
         iodev = (gx_io_device *)gx_io_device_table[0];
       search_with_combine = false;
    } else {
       search_with_no_combine = starting_arg_file;
       search_with_combine = true;
    }
","The `lib_file_open` function is designed to open a file specified by the `fname` parameter, utilizing a provided memory context (`mem`) and an execution context (`i_ctx_p`). It checks if the function is being called with a starting argument file (indicated by a NULL `i_ctx_p`), which influences the file search behavior. The function initializes an input/output device and determines the appropriate search strategy for locating the file, either with or without combining paths. Additionally, it prepares to read the file in a specified mode, setting up necessary variables for further processing, though the actual file opening logic is not included in the provided code snippet.","The provided code defines a function that facilitates the opening of a specified file while managing different execution contexts. It determines whether the function is invoked with an initial argument file, which affects how the file search is conducted. The function initializes an input/output device and sets the mode for reading the file. Depending on the context, it establishes whether to search for the file using combined paths or not. The code prepares necessary variables for subsequent operations related to file handling, although the actual implementation for opening the file is not included in the snippet.","The vulnerability in the original code arises from the potential misuse of the `starting_arg_file` variable, which could lead to incorrect behavior when handling argument files. Specifically, if `i_ctx_p` is not NULL but `starting_arg_file` is true, the code does not reset this flag, potentially causing unintended consequences in subsequent file operations. The fix addresses this by explicitly setting `i_ctx_p->starting_arg_file` to false when `i_ctx_p` is valid and `starting_arg_file` is true. This ensures that the state is correctly managed, preventing misuse of the execution context in future operations and enhancing overall stability.","The vulnerability in the original code stems from the improper handling of a flag that indicates whether the function is processing an initial argument file. If the function is called with a valid execution context, the flag could remain set to true, leading to incorrect behavior in subsequent file operations. The fix addresses this issue by ensuring that the flag is reset to false whenever the execution context is valid and the flag is true. This change prevents the potential misuse of the flag in future operations, thereby enhancing the stability and correctness of the file handling process.","The vulnerability was fixed by adding a conditional statement that checks if the execution context pointer is valid and if the `starting_arg_file` variable is true. If both conditions are met, the code explicitly sets `i_ctx_p->starting_arg_file` to false. This ensures that the flag is correctly reset, preventing it from incorrectly indicating that the function is still processing an initial argument file in subsequent operations. By managing the state of this flag appropriately, the fix enhances the reliability of the file handling process and mitigates the risk of unintended behavior.","The vulnerability was addressed by introducing a check that ensures the state of a specific flag is correctly managed when the function is invoked with a valid execution context. When the flag indicates that the function is processing an initial argument file, the fix explicitly resets this flag to false. This adjustment prevents the flag from retaining an incorrect state, which could lead to unintended behavior in subsequent operations. By ensuring that the flag is properly updated, the fix enhances the overall stability and correctness of the file handling process, reducing the risk of misuse.","4, 5","3, 4","4,4","3,4"
26,26,178460,178460,,Local,Not required,Partial,CVE-2018-1116,https://www.cvedetails.com/cve/CVE-2018-1116/,CWE-200,Low,Partial,,,2018-07-10,3.6,A flaw was found in polkit before version 0.116. The implementation of the polkit_backend_interactive_authority_check_authorization function in polkitd allows to test for authentication and trigger authentication of unrelated processes owned by other users. This may result in a local DoS and information disclosure.,2019-10-09,+Info,10,https://cgit.freedesktop.org/polkit/commit/?id=bc7ffad5364,bc7ffad53643a9c80231fc41f5582d6a8931c32c,,4,,,"polkit_backend_interactive_authority_check_authorization (PolkitBackendAuthority         *authority,
                                                          PolkitSubject                  *caller,
                                                          PolkitSubject                  *subject,
                                                          const gchar                    *action_id,
                                                          PolkitDetails                  *details,
                                                          PolkitCheckAuthorizationFlags   flags,
                                                          GCancellable                   *cancellable,
                                                          GAsyncReadyCallback             callback,
                                                          gpointer                        user_data)
{
  PolkitBackendInteractiveAuthority *interactive_authority;
  PolkitBackendInteractiveAuthorityPrivate *priv;
  gchar *caller_str;
   gchar *subject_str;
   PolkitIdentity *user_of_caller;
   PolkitIdentity *user_of_subject;
  gboolean user_of_subject_matches;
   gchar *user_of_caller_str;
   gchar *user_of_subject_str;
   PolkitAuthorizationResult *result;
  GError *error;
  GSimpleAsyncResult *simple;
  gboolean has_details;
  gchar **detail_keys;

  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);
  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);

  error = NULL;
  caller_str = NULL;
  subject_str = NULL;
  user_of_caller = NULL;
  user_of_subject = NULL;
  user_of_caller_str = NULL;
  user_of_subject_str = NULL;
  result = NULL;

  simple = g_simple_async_result_new (G_OBJECT (authority),
                                      callback,
                                      user_data,
                                      polkit_backend_interactive_authority_check_authorization);

  /* handle being called from ourselves */
  if (caller == NULL)
    {
      /* TODO: this is kind of a hack */
      GDBusConnection *system_bus;
      system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);
      caller = polkit_system_bus_name_new (g_dbus_connection_get_unique_name (system_bus));
      g_object_unref (system_bus);
    }

  caller_str = polkit_subject_to_string (caller);
  subject_str = polkit_subject_to_string (subject);

  g_debug (""%s is inquiring whether %s is authorized for %s"",
           caller_str,
           subject_str,
           action_id);
            action_id);
 
   user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,
                                                                        caller, NULL,
                                                                         &error);
   if (error != NULL)
     {
      g_simple_async_result_complete (simple);
      g_object_unref (simple);
      g_error_free (error);
      goto out;
    }

  user_of_caller_str = polkit_identity_to_string (user_of_caller);
  g_debug ("" user of caller is %s"", user_of_caller_str);
   g_debug ("" user of caller is %s"", user_of_caller_str);
 
   user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,
                                                                         subject, &user_of_subject_matches,
                                                                          &error);
   if (error != NULL)
     {
      g_simple_async_result_complete (simple);
      g_object_unref (simple);
      g_error_free (error);
      goto out;
    }

  user_of_subject_str = polkit_identity_to_string (user_of_subject);
  g_debug ("" user of subject is %s"", user_of_subject_str);

  has_details = FALSE;
  if (details != NULL)
    {
      detail_keys = polkit_details_get_keys (details);
      if (detail_keys != NULL)
        {
          if (g_strv_length (detail_keys) > 0)
            has_details = TRUE;
          g_strfreev (detail_keys);
        }
    }

  /* Not anyone is allowed to check that process XYZ is allowed to do ABC.
   * We only allow this if, and only if,
    * We only allow this if, and only if,
    *
    *  - processes may check for another process owned by the *same* user but not
   *    if details are passed (otherwise you'd be able to spoof the dialog);
   *    the caller supplies the user_of_subject value, so we additionally
   *    require it to match at least at one point in time (via
   *    user_of_subject_matches).
    *
    *  - processes running as uid 0 may check anything and pass any details
    *
  if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details)
    *    then any uid referenced by that annotation is also allowed to check
    *    to check anything and pass any details
    */
  if (!user_of_subject_matches
      || !polkit_identity_equal (user_of_caller, user_of_subject)
      || has_details)
     {
       if (!may_identity_check_authorization (interactive_authority, action_id, user_of_caller))
         {
                                               ""pass details"");
            }
          else
            {
              g_simple_async_result_set_error (simple,
                                               POLKIT_ERROR,
                                               POLKIT_ERROR_NOT_AUTHORIZED,
                                               ""Only trusted callers (e.g. uid 0 or an action owner) can use CheckAuthorization() for ""
                                               ""subjects belonging to other identities"");
            }
          g_simple_async_result_complete (simple);
          g_object_unref (simple);
          goto out;
        }
    }
","polkit_backend_interactive_authority_check_authorization (PolkitBackendAuthority         *authority,
                                                          PolkitSubject                  *caller,
                                                          PolkitSubject                  *subject,
                                                          const gchar                    *action_id,
                                                          PolkitDetails                  *details,
                                                          PolkitCheckAuthorizationFlags   flags,
                                                          GCancellable                   *cancellable,
                                                          GAsyncReadyCallback             callback,
                                                          gpointer                        user_data)
{
  PolkitBackendInteractiveAuthority *interactive_authority;
  PolkitBackendInteractiveAuthorityPrivate *priv;
  gchar *caller_str;
   gchar *subject_str;
   PolkitIdentity *user_of_caller;
   PolkitIdentity *user_of_subject;
   gchar *user_of_caller_str;
   gchar *user_of_subject_str;
   PolkitAuthorizationResult *result;
  GError *error;
  GSimpleAsyncResult *simple;
  gboolean has_details;
  gchar **detail_keys;

  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);
  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);

  error = NULL;
  caller_str = NULL;
  subject_str = NULL;
  user_of_caller = NULL;
  user_of_subject = NULL;
  user_of_caller_str = NULL;
  user_of_subject_str = NULL;
  result = NULL;

  simple = g_simple_async_result_new (G_OBJECT (authority),
                                      callback,
                                      user_data,
                                      polkit_backend_interactive_authority_check_authorization);

  /* handle being called from ourselves */
  if (caller == NULL)
    {
      /* TODO: this is kind of a hack */
      GDBusConnection *system_bus;
      system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);
      caller = polkit_system_bus_name_new (g_dbus_connection_get_unique_name (system_bus));
      g_object_unref (system_bus);
    }

  caller_str = polkit_subject_to_string (caller);
  subject_str = polkit_subject_to_string (subject);

  g_debug (""%s is inquiring whether %s is authorized for %s"",
           caller_str,
           subject_str,
           action_id);
            action_id);
 
   user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,
                                                                        caller,
                                                                         &error);
   if (error != NULL)
     {
      g_simple_async_result_complete (simple);
      g_object_unref (simple);
      g_error_free (error);
      goto out;
    }

  user_of_caller_str = polkit_identity_to_string (user_of_caller);
  g_debug ("" user of caller is %s"", user_of_caller_str);
   g_debug ("" user of caller is %s"", user_of_caller_str);
 
   user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,
                                                                         subject,
                                                                          &error);
   if (error != NULL)
     {
      g_simple_async_result_complete (simple);
      g_object_unref (simple);
      g_error_free (error);
      goto out;
    }

  user_of_subject_str = polkit_identity_to_string (user_of_subject);
  g_debug ("" user of subject is %s"", user_of_subject_str);

  has_details = FALSE;
  if (details != NULL)
    {
      detail_keys = polkit_details_get_keys (details);
      if (detail_keys != NULL)
        {
          if (g_strv_length (detail_keys) > 0)
            has_details = TRUE;
          g_strfreev (detail_keys);
        }
    }

  /* Not anyone is allowed to check that process XYZ is allowed to do ABC.
   * We only allow this if, and only if,
    * We only allow this if, and only if,
    *
    *  - processes may check for another process owned by the *same* user but not
   *    if details are passed (otherwise you'd be able to spoof the dialog)
    *
    *  - processes running as uid 0 may check anything and pass any details
    *
  if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details)
    *    then any uid referenced by that annotation is also allowed to check
    *    to check anything and pass any details
    */
  if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details)
     {
       if (!may_identity_check_authorization (interactive_authority, action_id, user_of_caller))
         {
                                               ""pass details"");
            }
          else
            {
              g_simple_async_result_set_error (simple,
                                               POLKIT_ERROR,
                                               POLKIT_ERROR_NOT_AUTHORIZED,
                                               ""Only trusted callers (e.g. uid 0 or an action owner) can use CheckAuthorization() for ""
                                               ""subjects belonging to other identities"");
            }
          g_simple_async_result_complete (simple);
          g_object_unref (simple);
          goto out;
        }
    }
",C,"  gboolean user_of_subject_matches;
                                                                        caller, NULL,
                                                                         subject, &user_of_subject_matches,
   *    if details are passed (otherwise you'd be able to spoof the dialog);
   *    the caller supplies the user_of_subject value, so we additionally
   *    require it to match at least at one point in time (via
   *    user_of_subject_matches).
  if (!user_of_subject_matches
      || !polkit_identity_equal (user_of_caller, user_of_subject)
      || has_details)
","                                                                        caller,
                                                                         subject,
   *    if details are passed (otherwise you'd be able to spoof the dialog)
  if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details)
",dda431905221a81921492b1d28b96b4bffb57700,"@@ -575,7 +575,7 @@ log_result (PolkitBackendInteractiveAuthority    *authority,
   if (polkit_authorization_result_get_is_authorized (result))
     log_result_str = ""ALLOWING"";
 
-  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, NULL);
+  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, NULL, NULL);
 
   subject_str = polkit_subject_to_string (subject);
 
@@ -847,6 +847,7 @@ polkit_backend_interactive_authority_check_authorization (PolkitBackendAuthority
   gchar *subject_str;
   PolkitIdentity *user_of_caller;
   PolkitIdentity *user_of_subject;
+  gboolean user_of_subject_matches;
   gchar *user_of_caller_str;
   gchar *user_of_subject_str;
   PolkitAuthorizationResult *result;
@@ -892,7 +893,7 @@ polkit_backend_interactive_authority_check_authorization (PolkitBackendAuthority
            action_id);
 
   user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,
-                                                                        caller,
+                                                                        caller, NULL,
                                                                         &error);
   if (error != NULL)
     {
@@ -907,7 +908,7 @@ polkit_backend_interactive_authority_check_authorization (PolkitBackendAuthority
   g_debug ("" user of caller is %s"", user_of_caller_str);
 
   user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,
-                                                                         subject,
+                                                                         subject, &user_of_subject_matches,
                                                                          &error);
   if (error != NULL)
     {
@@ -937,7 +938,10 @@ polkit_backend_interactive_authority_check_authorization (PolkitBackendAuthority
    * We only allow this if, and only if,
    *
    *  - processes may check for another process owned by the *same* user but not
-   *    if details are passed (otherwise you'd be able to spoof the dialog)
+   *    if details are passed (otherwise you'd be able to spoof the dialog);
+   *    the caller supplies the user_of_subject value, so we additionally
+   *    require it to match at least at one point in time (via
+   *    user_of_subject_matches).
    *
    *  - processes running as uid 0 may check anything and pass any details
    *
@@ -945,7 +949,9 @@ polkit_backend_interactive_authority_check_authorization (PolkitBackendAuthority
    *    then any uid referenced by that annotation is also allowed to check
    *    to check anything and pass any details
    */
-  if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details)
+  if (!user_of_subject_matches
+      || !polkit_identity_equal (user_of_caller, user_of_subject)
+      || has_details)
     {
       if (!may_identity_check_authorization (interactive_authority, action_id, user_of_caller))
         {
@@ -1110,9 +1116,10 @@ check_authorization_sync (PolkitBackendAuthority         *authority,
       goto out;
     }
 
-  /* every subject has a user */
+  /* every subject has a user; this is supplied by the client, so we rely
+   * on the caller to validate its acceptability. */
   user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,
-                                                                         subject,
+                                                                         subject, NULL,
                                                                          error);
   if (user_of_subject == NULL)
       goto out;
@@ -2480,6 +2487,7 @@ polkit_backend_interactive_authority_register_authentication_agent (PolkitBacken
   PolkitSubject *session_for_caller;
   PolkitIdentity *user_of_caller;
   PolkitIdentity *user_of_subject;
+  gboolean user_of_subject_matches;
   AuthenticationAgent *agent;
   gboolean ret;
   gchar *caller_cmdline;
@@ -2532,7 +2540,7 @@ polkit_backend_interactive_authority_register_authentication_agent (PolkitBacken
       goto out;
     }
 
-  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, caller, NULL);
+  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, caller, NULL, NULL);
   if (user_of_caller == NULL)
     {
       g_set_error (error,
@@ -2541,7 +2549,7 @@ polkit_backend_interactive_authority_register_authentication_agent (PolkitBacken
                    ""Cannot determine user of caller"");
       goto out;
     }
-  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, NULL);
+  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, &user_of_subject_matches, NULL);
   if (user_of_subject == NULL)
     {
       g_set_error (error,
@@ -2550,7 +2558,8 @@ polkit_backend_interactive_authority_register_authentication_agent (PolkitBacken
                    ""Cannot determine user of subject"");
       goto out;
     }
-  if (!polkit_identity_equal (user_of_caller, user_of_subject))
+  if (!user_of_subject_matches
+      || !polkit_identity_equal (user_of_caller, user_of_subject))
     {
       if (identity_is_root_user (user_of_caller))
         {
@@ -2643,6 +2652,7 @@ polkit_backend_interactive_authority_unregister_authentication_agent (PolkitBack
   PolkitSubject *session_for_caller;
   PolkitIdentity *user_of_caller;
   PolkitIdentity *user_of_subject;
+  gboolean user_of_subject_matches;
   AuthenticationAgent *agent;
   gboolean ret;
   gchar *scope_str;
@@ -2691,7 +2701,7 @@ polkit_backend_interactive_authority_unregister_authentication_agent (PolkitBack
       goto out;
     }
 
-  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, caller, NULL);
+  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, caller, NULL, NULL);
   if (user_of_caller == NULL)
     {
       g_set_error (error,
@@ -2700,7 +2710,7 @@ polkit_backend_interactive_authority_unregister_authentication_agent (PolkitBack
                    ""Cannot determine user of caller"");
       goto out;
     }
-  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, NULL);
+  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, &user_of_subject_matches, NULL);
   if (user_of_subject == NULL)
     {
       g_set_error (error,
@@ -2709,7 +2719,8 @@ polkit_backend_interactive_authority_unregister_authentication_agent (PolkitBack
                    ""Cannot determine user of subject"");
       goto out;
     }
-  if (!polkit_identity_equal (user_of_caller, user_of_subject))
+  if (!user_of_subject_matches
+      || !polkit_identity_equal (user_of_caller, user_of_subject))
     {
       if (identity_is_root_user (user_of_caller))
         {
@@ -2819,7 +2830,7 @@ polkit_backend_interactive_authority_authentication_agent_response (PolkitBacken
            identity_str);
 
   user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,
-                                                                        caller,
+                                                                        caller, NULL,
                                                                         error);
   if (user_of_caller == NULL)
     goto out;",polkit,https://cgit.freedesktop.org/polkit/tree/src/polkitbackend/polkitbackendinteractiveauthority.c?id=bc7ffad53643a9c80231fc41f5582d6a8931c32c,https://cgit.freedesktop.org/polkit/tree/src/polkitbackend/polkitbackendinteractiveauthority.c?id=dda431905221a81921492b1d28b96b4bffb57700,1,"polkit_backend_interactive_authority_check_authorization (PolkitBackendAuthority         *authority,
                                                          PolkitSubject                  *caller,
                                                          PolkitSubject                  *subject,
                                                          const gchar                    *action_id,
                                                          PolkitDetails                  *details,
                                                          PolkitCheckAuthorizationFlags   flags,
                                                          GCancellable                   *cancellable,
                                                          GAsyncReadyCallback             callback,
                                                          gpointer                        user_data)
{
  PolkitBackendInteractiveAuthority *interactive_authority;
  PolkitBackendInteractiveAuthorityPrivate *priv;
  gchar *caller_str;
   gchar *subject_str;
   PolkitIdentity *user_of_caller;
   PolkitIdentity *user_of_subject;
//fix_flaw_line_below:
//  gboolean user_of_subject_matches;
   gchar *user_of_caller_str;
   gchar *user_of_subject_str;
   PolkitAuthorizationResult *result;
  GError *error;
  GSimpleAsyncResult *simple;
  gboolean has_details;
  gchar **detail_keys;

  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);
  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);

  error = NULL;
  caller_str = NULL;
  subject_str = NULL;
  user_of_caller = NULL;
  user_of_subject = NULL;
  user_of_caller_str = NULL;
  user_of_subject_str = NULL;
  result = NULL;

  simple = g_simple_async_result_new (G_OBJECT (authority),
                                      callback,
                                      user_data,
                                      polkit_backend_interactive_authority_check_authorization);

  /* handle being called from ourselves */
  if (caller == NULL)
    {
      /* TODO: this is kind of a hack */
      GDBusConnection *system_bus;
      system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);
      caller = polkit_system_bus_name_new (g_dbus_connection_get_unique_name (system_bus));
      g_object_unref (system_bus);
    }

  caller_str = polkit_subject_to_string (caller);
  subject_str = polkit_subject_to_string (subject);

  g_debug (""%s is inquiring whether %s is authorized for %s"",
           caller_str,
           subject_str,
           action_id);
            action_id);
 
   user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,
//flaw_line_below:
                                                                        caller,
//fix_flaw_line_below:
//                                                                        caller, NULL,
                                                                         &error);
   if (error != NULL)
     {
      g_simple_async_result_complete (simple);
      g_object_unref (simple);
      g_error_free (error);
      goto out;
    }

  user_of_caller_str = polkit_identity_to_string (user_of_caller);
  g_debug ("" user of caller is %s"", user_of_caller_str);
   g_debug ("" user of caller is %s"", user_of_caller_str);
 
   user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,
//flaw_line_below:
                                                                         subject,
//fix_flaw_line_below:
//                                                                         subject, &user_of_subject_matches,
                                                                          &error);
   if (error != NULL)
     {
      g_simple_async_result_complete (simple);
      g_object_unref (simple);
      g_error_free (error);
      goto out;
    }

  user_of_subject_str = polkit_identity_to_string (user_of_subject);
  g_debug ("" user of subject is %s"", user_of_subject_str);

  has_details = FALSE;
  if (details != NULL)
    {
      detail_keys = polkit_details_get_keys (details);
      if (detail_keys != NULL)
        {
          if (g_strv_length (detail_keys) > 0)
            has_details = TRUE;
          g_strfreev (detail_keys);
        }
    }

  /* Not anyone is allowed to check that process XYZ is allowed to do ABC.
   * We only allow this if, and only if,
    * We only allow this if, and only if,
    *
    *  - processes may check for another process owned by the *same* user but not
//flaw_line_below:
   *    if details are passed (otherwise you'd be able to spoof the dialog)
//fix_flaw_line_below:
//   *    if details are passed (otherwise you'd be able to spoof the dialog);
//fix_flaw_line_below:
//   *    the caller supplies the user_of_subject value, so we additionally
//fix_flaw_line_below:
//   *    require it to match at least at one point in time (via
//fix_flaw_line_below:
//   *    user_of_subject_matches).
    *
    *  - processes running as uid 0 may check anything and pass any details
    *
  if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details)
    *    then any uid referenced by that annotation is also allowed to check
    *    to check anything and pass any details
    */
//flaw_line_below:
  if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details)
//fix_flaw_line_below:
//  if (!user_of_subject_matches
//fix_flaw_line_below:
//      || !polkit_identity_equal (user_of_caller, user_of_subject)
//fix_flaw_line_below:
//      || has_details)
     {
       if (!may_identity_check_authorization (interactive_authority, action_id, user_of_caller))
         {
                                               ""pass details"");
            }
          else
            {
              g_simple_async_result_set_error (simple,
                                               POLKIT_ERROR,
                                               POLKIT_ERROR_NOT_AUTHORIZED,
                                               ""Only trusted callers (e.g. uid 0 or an action owner) can use CheckAuthorization() for ""
                                               ""subjects belonging to other identities"");
            }
          g_simple_async_result_complete (simple);
          g_object_unref (simple);
          goto out;
        }
    }
",178460,"polkit_backend_interactive_authority_check_authorization (PolkitBackendAuthority         *authority,
                                                          PolkitSubject                  *caller,
                                                          PolkitSubject                  *subject,
                                                          const gchar                    *action_id,
                                                          PolkitDetails                  *details,
                                                          PolkitCheckAuthorizationFlags   flags,
                                                          GCancellable                   *cancellable,
                                                          GAsyncReadyCallback             callback,
                                                          gpointer                        user_data)
{
  PolkitBackendInteractiveAuthority *interactive_authority;
  PolkitBackendInteractiveAuthorityPrivate *priv;
  gchar *caller_str;
   gchar *subject_str;
   PolkitIdentity *user_of_caller;
   PolkitIdentity *user_of_subject;
   gchar *user_of_caller_str;
   gchar *user_of_subject_str;
   PolkitAuthorizationResult *result;
  GError *error;
  GSimpleAsyncResult *simple;
  gboolean has_details;
  gchar **detail_keys;

  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);
  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);

  error = NULL;
  caller_str = NULL;
  subject_str = NULL;
  user_of_caller = NULL;
  user_of_subject = NULL;
  user_of_caller_str = NULL;
  user_of_subject_str = NULL;
  result = NULL;

  simple = g_simple_async_result_new (G_OBJECT (authority),
                                      callback,
                                      user_data,
                                      polkit_backend_interactive_authority_check_authorization);

  /* handle being called from ourselves */
  if (caller == NULL)
    {
      /* TODO: this is kind of a hack */
      GDBusConnection *system_bus;
      system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);
      caller = polkit_system_bus_name_new (g_dbus_connection_get_unique_name (system_bus));
      g_object_unref (system_bus);
    }

  caller_str = polkit_subject_to_string (caller);
  subject_str = polkit_subject_to_string (subject);

  g_debug (""%s is inquiring whether %s is authorized for %s"",
           caller_str,
           subject_str,
           action_id);
            action_id);
 
   user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,
                                                                        caller,
                                                                         &error);
   if (error != NULL)
     {
      g_simple_async_result_complete (simple);
      g_object_unref (simple);
      g_error_free (error);
      goto out;
    }

  user_of_caller_str = polkit_identity_to_string (user_of_caller);
  g_debug ("" user of caller is %s"", user_of_caller_str);
   g_debug ("" user of caller is %s"", user_of_caller_str);
 
   user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,
                                                                         subject,
                                                                          &error);
   if (error != NULL)
     {
      g_simple_async_result_complete (simple);
      g_object_unref (simple);
      g_error_free (error);
      goto out;
    }

  user_of_subject_str = polkit_identity_to_string (user_of_subject);
  g_debug ("" user of subject is %s"", user_of_subject_str);

  has_details = FALSE;
  if (details != NULL)
    {
      detail_keys = polkit_details_get_keys (details);
      if (detail_keys != NULL)
        {
          if (g_strv_length (detail_keys) > 0)
            has_details = TRUE;
          g_strfreev (detail_keys);
        }
    }

  /* Not anyone is allowed to check that process XYZ is allowed to do ABC.
   * We only allow this if, and only if,
    * We only allow this if, and only if,
    *
    *  - processes may check for another process owned by the *same* user but not
   *    if details are passed (otherwise you'd be able to spoof the dialog)
    *
    *  - processes running as uid 0 may check anything and pass any details
    *
  if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details)
    *    then any uid referenced by that annotation is also allowed to check
    *    to check anything and pass any details
    */
  if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details)
     {
       if (!may_identity_check_authorization (interactive_authority, action_id, user_of_caller))
         {
                                               ""pass details"");
            }
          else
            {
              g_simple_async_result_set_error (simple,
                                               POLKIT_ERROR,
                                               POLKIT_ERROR_NOT_AUTHORIZED,
                                               ""Only trusted callers (e.g. uid 0 or an action owner) can use CheckAuthorization() for ""
                                               ""subjects belonging to other identities"");
            }
          g_simple_async_result_complete (simple);
          g_object_unref (simple);
          goto out;
        }
    }
","polkit_backend_interactive_authority_check_authorization (PolkitBackendAuthority         *authority,
                                                          PolkitSubject                  *caller,
                                                          PolkitSubject                  *subject,
                                                          const gchar                    *action_id,
                                                          PolkitDetails                  *details,
                                                          PolkitCheckAuthorizationFlags   flags,
                                                          GCancellable                   *cancellable,
                                                          GAsyncReadyCallback             callback,
                                                          gpointer                        user_data)
{
  PolkitBackendInteractiveAuthority *interactive_authority;
  PolkitBackendInteractiveAuthorityPrivate *priv;
  gchar *caller_str;
   gchar *subject_str;
   PolkitIdentity *user_of_caller;
   PolkitIdentity *user_of_subject;
  gboolean user_of_subject_matches;
   gchar *user_of_caller_str;
   gchar *user_of_subject_str;
   PolkitAuthorizationResult *result;
  GError *error;
  GSimpleAsyncResult *simple;
  gboolean has_details;
  gchar **detail_keys;

  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);
  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);

  error = NULL;
  caller_str = NULL;
  subject_str = NULL;
  user_of_caller = NULL;
  user_of_subject = NULL;
  user_of_caller_str = NULL;
  user_of_subject_str = NULL;
  result = NULL;

  simple = g_simple_async_result_new (G_OBJECT (authority),
                                      callback,
                                      user_data,
                                      polkit_backend_interactive_authority_check_authorization);

  /* handle being called from ourselves */
  if (caller == NULL)
    {
      /* TODO: this is kind of a hack */
      GDBusConnection *system_bus;
      system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);
      caller = polkit_system_bus_name_new (g_dbus_connection_get_unique_name (system_bus));
      g_object_unref (system_bus);
    }

  caller_str = polkit_subject_to_string (caller);
  subject_str = polkit_subject_to_string (subject);

  g_debug (""%s is inquiring whether %s is authorized for %s"",
           caller_str,
           subject_str,
           action_id);
            action_id);
 
   user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,
                                                                        caller, NULL,
                                                                         &error);
   if (error != NULL)
     {
      g_simple_async_result_complete (simple);
      g_object_unref (simple);
      g_error_free (error);
      goto out;
    }

  user_of_caller_str = polkit_identity_to_string (user_of_caller);
  g_debug ("" user of caller is %s"", user_of_caller_str);
   g_debug ("" user of caller is %s"", user_of_caller_str);
 
   user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,
                                                                         subject, &user_of_subject_matches,
                                                                          &error);
   if (error != NULL)
     {
      g_simple_async_result_complete (simple);
      g_object_unref (simple);
      g_error_free (error);
      goto out;
    }

  user_of_subject_str = polkit_identity_to_string (user_of_subject);
  g_debug ("" user of subject is %s"", user_of_subject_str);

  has_details = FALSE;
  if (details != NULL)
    {
      detail_keys = polkit_details_get_keys (details);
      if (detail_keys != NULL)
        {
          if (g_strv_length (detail_keys) > 0)
            has_details = TRUE;
          g_strfreev (detail_keys);
        }
    }

  /* Not anyone is allowed to check that process XYZ is allowed to do ABC.
   * We only allow this if, and only if,
    * We only allow this if, and only if,
    *
    *  - processes may check for another process owned by the *same* user but not
   *    if details are passed (otherwise you'd be able to spoof the dialog);
   *    the caller supplies the user_of_subject value, so we additionally
   *    require it to match at least at one point in time (via
   *    user_of_subject_matches).
    *
    *  - processes running as uid 0 may check anything and pass any details
    *
  if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details)
    *    then any uid referenced by that annotation is also allowed to check
    *    to check anything and pass any details
    */
  if (!user_of_subject_matches
      || !polkit_identity_equal (user_of_caller, user_of_subject)
      || has_details)
     {
       if (!may_identity_check_authorization (interactive_authority, action_id, user_of_caller))
         {
                                               ""pass details"");
            }
          else
            {
              g_simple_async_result_set_error (simple,
                                               POLKIT_ERROR,
                                               POLKIT_ERROR_NOT_AUTHORIZED,
                                               ""Only trusted callers (e.g. uid 0 or an action owner) can use CheckAuthorization() for ""
                                               ""subjects belonging to other identities"");
            }
          g_simple_async_result_complete (simple);
          g_object_unref (simple);
          goto out;
        }
    }
","The provided code defines a function that checks the authorization of a subject to perform a specific action within a policy kit framework. It takes various parameters, including the authority, caller, subject, action ID, and additional details. The function first retrieves user identities for both the caller and the subject, logging their information. It then evaluates whether the caller is authorized to check the subject's permissions based on specific conditions, such as user identity equality and the presence of details. If the caller lacks the necessary permissions, an error is set, and the result is completed asynchronously.","The code implements a function that verifies whether a specific subject is authorized to perform a designated action, based on the identity of the caller and the subject. It begins by determining the user identities associated with both the caller and the subject, logging relevant information for debugging purposes. The function then checks if the caller has the necessary permissions to inquire about the subject's authorization, considering factors such as user identity equality and the presence of additional details. If the caller lacks the required permissions, an error is generated, and the result is returned asynchronously.","The vulnerability in the original code stemmed from insufficient checks on the caller's permissions when verifying if a subject was authorized for a specific action. Specifically, the code allowed any caller to check the authorization of another subject, potentially leading to privilege escalation or unauthorized access. The fix introduced a new boolean variable to track whether the user of the subject matched the caller at any point in time. This additional check ensures that if the caller and subject do not match or if details are present, the caller must have explicit permission to check the authorization, thereby enhancing security.","The vulnerability in the original code allowed any caller to check the authorization of another subject without adequate restrictions, potentially leading to unauthorized access or privilege escalation. This lack of checks meant that a malicious caller could exploit the system by querying permissions for subjects they should not have access to. The fix introduced a mechanism to verify whether the caller and subject matched at any point in time, ensuring that only trusted callers could perform such checks. This added layer of validation significantly enhances security by preventing unauthorized authorization inquiries.","The vulnerability was fixed by introducing a new boolean variable, `user_of_subject_matches`, which tracks whether the user of the subject matched the caller at any point in time. In the updated code, the condition for allowing a caller to check authorization was modified to include this variable. Specifically, the check now ensures that if `user_of_subject_matches` is false, or if the caller and subject do not match, or if additional details are present, the caller must have explicit permission to perform the authorization check. This change restricts unauthorized access and enhances overall security.","The vulnerability was addressed by implementing an additional validation mechanism that checks whether the caller and the subject have a matching user identity at any point in time. The updated logic now requires that if there is no match between the caller and the subject, or if additional details are provided, the caller must possess explicit permissions to check the subject's authorization. This enhancement ensures that only trusted callers can perform such checks, thereby preventing unauthorized access and reducing the risk of privilege escalation within the system.","5,5","5, 5","5, 4","4,5"
27,27,178520,178520,,Local,Not required,,CVE-2018-0495,https://www.cvedetails.com/cve/CVE-2018-0495/,CWE-200,Medium,Partial,,,2018-06-13,1.9,"Libgcrypt before 1.7.10 and 1.8.x before 1.8.3 allows a memory-cache side-channel attack on ECDSA signatures that can be mitigated through the use of blinding during the signing process in the _gcry_ecc_ecdsa_sign function in cipher/ecc-ecdsa.c, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host.",2019-05-30,+Info,11,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=commit;h=9010d1576e278a4274ad3f4aa15776c28f6ba965,9010d1576e278a4274ad3f4aa15776c28f6ba965,,0,,,"_gcry_ecc_ecdsa_sign (gcry_mpi_t input, ECC_secret_key *skey,
                      gcry_mpi_t r, gcry_mpi_t s,
                      int flags, int hashalgo)
{
  gpg_err_code_t rc = 0;
  int extraloops = 0;
  gcry_mpi_t k, dr, sum, k_1, x;
  mpi_point_struct I;
  gcry_mpi_t hash;
   const void *abuf;
   unsigned int abits, qbits;
   mpi_ec_t ctx;
  gcry_mpi_t b;                /* Random number needed for blinding.  */
  gcry_mpi_t bi;               /* multiplicative inverse of B.        */
 
   if (DBG_CIPHER)
     log_mpidump (""ecdsa sign hash  "", input );

  /* Convert the INPUT into an MPI if needed.  */
  rc = _gcry_dsa_normalize_hash (input, &hash, qbits);
  if (rc)
    return rc;
   if (rc)
     return rc;
 
  b  = mpi_snew (qbits);
  bi = mpi_snew (qbits);
  do
    {
      _gcry_mpi_randomize (b, qbits, GCRY_WEAK_RANDOM);
      mpi_mod (b, b, skey->E.n);
    }
  while (!mpi_invm (bi, b, skey->E.n));

   k = NULL;
   dr = mpi_alloc (0);
   sum = mpi_alloc (0);
    {
      do
        {
          mpi_free (k);
          k = NULL;
          if ((flags & PUBKEY_FLAG_RFC6979) && hashalgo)
            {
              /* Use Pornin's method for deterministic DSA.  If this
                 flag is set, it is expected that HASH is an opaque
                 MPI with the to be signed hash.  That hash is also
                 used as h1 from 3.2.a.  */
              if (!mpi_is_opaque (input))
                {
                  rc = GPG_ERR_CONFLICT;
                  goto leave;
                }

              abuf = mpi_get_opaque (input, &abits);
              rc = _gcry_dsa_gen_rfc6979_k (&k, skey->E.n, skey->d,
                                            abuf, (abits+7)/8,
                                            hashalgo, extraloops);
              if (rc)
                goto leave;
              extraloops++;
            }
          else
            k = _gcry_dsa_gen_k (skey->E.n, GCRY_STRONG_RANDOM);

          _gcry_mpi_ec_mul_point (&I, k, &skey->E.G, ctx);
          if (_gcry_mpi_ec_get_affine (x, NULL, &I, ctx))
            {
              if (DBG_CIPHER)
                log_debug (""ecc sign: Failed to get affine coordinates\n"");
              rc = GPG_ERR_BAD_SIGNATURE;
              goto leave;
            }
          mpi_mod (r, x, skey->E.n);  /* r = x mod n */
        }
      while (!mpi_cmp_ui (r, 0));

      mpi_mulm (dr, skey->d, r, skey->E.n); /* dr = d*r mod n  */
      mpi_addm (sum, hash, dr, skey->E.n);  /* sum = hash + (d*r) mod n  */
      mpi_invm (k_1, k, skey->E.n);         /* k_1 = k^(-1) mod n  */
      mpi_mulm (s, k_1, sum, skey->E.n);    /* s = k^(-1)*(hash+(d*r)) mod n */
    }
  while (!mpi_cmp_ui (s, 0));

  if (DBG_CIPHER)
         }
","_gcry_ecc_ecdsa_sign (gcry_mpi_t input, ECC_secret_key *skey,
                      gcry_mpi_t r, gcry_mpi_t s,
                      int flags, int hashalgo)
{
  gpg_err_code_t rc = 0;
  int extraloops = 0;
  gcry_mpi_t k, dr, sum, k_1, x;
  mpi_point_struct I;
  gcry_mpi_t hash;
   const void *abuf;
   unsigned int abits, qbits;
   mpi_ec_t ctx;
 
   if (DBG_CIPHER)
     log_mpidump (""ecdsa sign hash  "", input );

  /* Convert the INPUT into an MPI if needed.  */
  rc = _gcry_dsa_normalize_hash (input, &hash, qbits);
  if (rc)
    return rc;
   if (rc)
     return rc;
 
   k = NULL;
   dr = mpi_alloc (0);
   sum = mpi_alloc (0);
    {
      do
        {
          mpi_free (k);
          k = NULL;
          if ((flags & PUBKEY_FLAG_RFC6979) && hashalgo)
            {
              /* Use Pornin's method for deterministic DSA.  If this
                 flag is set, it is expected that HASH is an opaque
                 MPI with the to be signed hash.  That hash is also
                 used as h1 from 3.2.a.  */
              if (!mpi_is_opaque (input))
                {
                  rc = GPG_ERR_CONFLICT;
                  goto leave;
                }

              abuf = mpi_get_opaque (input, &abits);
              rc = _gcry_dsa_gen_rfc6979_k (&k, skey->E.n, skey->d,
                                            abuf, (abits+7)/8,
                                            hashalgo, extraloops);
              if (rc)
                goto leave;
              extraloops++;
            }
          else
            k = _gcry_dsa_gen_k (skey->E.n, GCRY_STRONG_RANDOM);

          _gcry_mpi_ec_mul_point (&I, k, &skey->E.G, ctx);
          if (_gcry_mpi_ec_get_affine (x, NULL, &I, ctx))
            {
              if (DBG_CIPHER)
                log_debug (""ecc sign: Failed to get affine coordinates\n"");
              rc = GPG_ERR_BAD_SIGNATURE;
              goto leave;
            }
          mpi_mod (r, x, skey->E.n);  /* r = x mod n */
        }
      while (!mpi_cmp_ui (r, 0));

      mpi_mulm (dr, skey->d, r, skey->E.n); /* dr = d*r mod n  */
      mpi_addm (sum, hash, dr, skey->E.n);  /* sum = hash + (d*r) mod n  */
      mpi_invm (k_1, k, skey->E.n);         /* k_1 = k^(-1) mod n  */
      mpi_mulm (s, k_1, sum, skey->E.n);    /* s = k^(-1)*(hash+(d*r)) mod n */
    }
  while (!mpi_cmp_ui (s, 0));

  if (DBG_CIPHER)
         }
",C,"  gcry_mpi_t b;                /* Random number needed for blinding.  */
  gcry_mpi_t bi;               /* multiplicative inverse of B.        */
  b  = mpi_snew (qbits);
  bi = mpi_snew (qbits);
  do
    {
      _gcry_mpi_randomize (b, qbits, GCRY_WEAK_RANDOM);
      mpi_mod (b, b, skey->E.n);
    }
  while (!mpi_invm (bi, b, skey->E.n));

",,7b6c2afd699e889f5f054cc3d202a61bd0ee1dcf,"@@ -50,6 +50,8 @@ _gcry_ecc_ecdsa_sign (gcry_mpi_t input, ECC_secret_key *skey,
   const void *abuf;
   unsigned int abits, qbits;
   mpi_ec_t ctx;
+  gcry_mpi_t b;                /* Random number needed for blinding.  */
+  gcry_mpi_t bi;               /* multiplicative inverse of B.        */
 
   if (DBG_CIPHER)
     log_mpidump (""ecdsa sign hash  "", input );
@@ -61,6 +63,15 @@ _gcry_ecc_ecdsa_sign (gcry_mpi_t input, ECC_secret_key *skey,
   if (rc)
     return rc;
 
+  b  = mpi_snew (qbits);
+  bi = mpi_snew (qbits);
+  do
+    {
+      _gcry_mpi_randomize (b, qbits, GCRY_WEAK_RANDOM);
+      mpi_mod (b, b, skey->E.n);
+    }
+  while (!mpi_invm (bi, b, skey->E.n));
+
   k = NULL;
   dr = mpi_alloc (0);
   sum = mpi_alloc (0);
@@ -115,8 +126,11 @@ _gcry_ecc_ecdsa_sign (gcry_mpi_t input, ECC_secret_key *skey,
         }
       while (!mpi_cmp_ui (r, 0));
 
-      mpi_mulm (dr, skey->d, r, skey->E.n); /* dr = d*r mod n  */
-      mpi_addm (sum, hash, dr, skey->E.n);  /* sum = hash + (d*r) mod n  */
+      mpi_mulm (dr, b, skey->d, skey->E.n);
+      mpi_mulm (dr, dr, r, skey->E.n);      /* dr = d*r mod n (blinded with b) */
+      mpi_mulm (sum, b, hash, skey->E.n);
+      mpi_addm (sum, sum, dr, skey->E.n);   /* sum = hash + (d*r) mod n  (blinded with b) */
+      mpi_mulm (sum, bi, sum, skey->E.n);   /* undo blinding by b^-1 */
       mpi_invm (k_1, k, skey->E.n);         /* k_1 = k^(-1) mod n  */
       mpi_mulm (s, k_1, sum, skey->E.n);    /* s = k^(-1)*(hash+(d*r)) mod n */
     }
@@ -129,6 +143,8 @@ _gcry_ecc_ecdsa_sign (gcry_mpi_t input, ECC_secret_key *skey,
     }
 
  leave:
+  mpi_free (b);
+  mpi_free (bi);
   _gcry_mpi_ec_free (ctx);
   point_free (&I);
   mpi_free (x);",gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=blob;f=cipher/ecc-ecdsa.c;h=140e8c09655cfd4005960bf7457c8b799f163c25;hb=9010d1576e278a4274ad3f4aa15776c28f6ba965,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=blob;f=cipher/ecc-ecdsa.c;h=1484830ba64c83bc133ca7e7cc75541cdbcd5bd8,1,"_gcry_ecc_ecdsa_sign (gcry_mpi_t input, ECC_secret_key *skey,
                      gcry_mpi_t r, gcry_mpi_t s,
                      int flags, int hashalgo)
{
  gpg_err_code_t rc = 0;
  int extraloops = 0;
  gcry_mpi_t k, dr, sum, k_1, x;
  mpi_point_struct I;
  gcry_mpi_t hash;
   const void *abuf;
   unsigned int abits, qbits;
   mpi_ec_t ctx;
//fix_flaw_line_below:
//  gcry_mpi_t b;                /* Random number needed for blinding.  */
//fix_flaw_line_below:
//  gcry_mpi_t bi;               /* multiplicative inverse of B.        */
 
   if (DBG_CIPHER)
     log_mpidump (""ecdsa sign hash  "", input );

  /* Convert the INPUT into an MPI if needed.  */
  rc = _gcry_dsa_normalize_hash (input, &hash, qbits);
  if (rc)
    return rc;
   if (rc)
     return rc;
 
//fix_flaw_line_below:
//  b  = mpi_snew (qbits);
//fix_flaw_line_below:
//  bi = mpi_snew (qbits);
//fix_flaw_line_below:
//  do
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//      _gcry_mpi_randomize (b, qbits, GCRY_WEAK_RANDOM);
//fix_flaw_line_below:
//      mpi_mod (b, b, skey->E.n);
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//  while (!mpi_invm (bi, b, skey->E.n));
//fix_flaw_line_below:
//
   k = NULL;
   dr = mpi_alloc (0);
   sum = mpi_alloc (0);
    {
      do
        {
          mpi_free (k);
          k = NULL;
          if ((flags & PUBKEY_FLAG_RFC6979) && hashalgo)
            {
              /* Use Pornin's method for deterministic DSA.  If this
                 flag is set, it is expected that HASH is an opaque
                 MPI with the to be signed hash.  That hash is also
                 used as h1 from 3.2.a.  */
              if (!mpi_is_opaque (input))
                {
                  rc = GPG_ERR_CONFLICT;
                  goto leave;
                }

              abuf = mpi_get_opaque (input, &abits);
              rc = _gcry_dsa_gen_rfc6979_k (&k, skey->E.n, skey->d,
                                            abuf, (abits+7)/8,
                                            hashalgo, extraloops);
              if (rc)
                goto leave;
              extraloops++;
            }
          else
            k = _gcry_dsa_gen_k (skey->E.n, GCRY_STRONG_RANDOM);

          _gcry_mpi_ec_mul_point (&I, k, &skey->E.G, ctx);
          if (_gcry_mpi_ec_get_affine (x, NULL, &I, ctx))
            {
              if (DBG_CIPHER)
                log_debug (""ecc sign: Failed to get affine coordinates\n"");
              rc = GPG_ERR_BAD_SIGNATURE;
              goto leave;
            }
          mpi_mod (r, x, skey->E.n);  /* r = x mod n */
        }
      while (!mpi_cmp_ui (r, 0));

      mpi_mulm (dr, skey->d, r, skey->E.n); /* dr = d*r mod n  */
      mpi_addm (sum, hash, dr, skey->E.n);  /* sum = hash + (d*r) mod n  */
      mpi_invm (k_1, k, skey->E.n);         /* k_1 = k^(-1) mod n  */
      mpi_mulm (s, k_1, sum, skey->E.n);    /* s = k^(-1)*(hash+(d*r)) mod n */
    }
  while (!mpi_cmp_ui (s, 0));

  if (DBG_CIPHER)
         }
",178520,"_gcry_ecc_ecdsa_sign (gcry_mpi_t input, ECC_secret_key *skey,
                      gcry_mpi_t r, gcry_mpi_t s,
                      int flags, int hashalgo)
{
  gpg_err_code_t rc = 0;
  int extraloops = 0;
  gcry_mpi_t k, dr, sum, k_1, x;
  mpi_point_struct I;
  gcry_mpi_t hash;
   const void *abuf;
   unsigned int abits, qbits;
   mpi_ec_t ctx;
 
   if (DBG_CIPHER)
     log_mpidump (""ecdsa sign hash  "", input );

  /* Convert the INPUT into an MPI if needed.  */
  rc = _gcry_dsa_normalize_hash (input, &hash, qbits);
  if (rc)
    return rc;
   if (rc)
     return rc;
 
   k = NULL;
   dr = mpi_alloc (0);
   sum = mpi_alloc (0);
    {
      do
        {
          mpi_free (k);
          k = NULL;
          if ((flags & PUBKEY_FLAG_RFC6979) && hashalgo)
            {
              /* Use Pornin's method for deterministic DSA.  If this
                 flag is set, it is expected that HASH is an opaque
                 MPI with the to be signed hash.  That hash is also
                 used as h1 from 3.2.a.  */
              if (!mpi_is_opaque (input))
                {
                  rc = GPG_ERR_CONFLICT;
                  goto leave;
                }

              abuf = mpi_get_opaque (input, &abits);
              rc = _gcry_dsa_gen_rfc6979_k (&k, skey->E.n, skey->d,
                                            abuf, (abits+7)/8,
                                            hashalgo, extraloops);
              if (rc)
                goto leave;
              extraloops++;
            }
          else
            k = _gcry_dsa_gen_k (skey->E.n, GCRY_STRONG_RANDOM);

          _gcry_mpi_ec_mul_point (&I, k, &skey->E.G, ctx);
          if (_gcry_mpi_ec_get_affine (x, NULL, &I, ctx))
            {
              if (DBG_CIPHER)
                log_debug (""ecc sign: Failed to get affine coordinates\n"");
              rc = GPG_ERR_BAD_SIGNATURE;
              goto leave;
            }
          mpi_mod (r, x, skey->E.n);  /* r = x mod n */
        }
      while (!mpi_cmp_ui (r, 0));

      mpi_mulm (dr, skey->d, r, skey->E.n); /* dr = d*r mod n  */
      mpi_addm (sum, hash, dr, skey->E.n);  /* sum = hash + (d*r) mod n  */
      mpi_invm (k_1, k, skey->E.n);         /* k_1 = k^(-1) mod n  */
      mpi_mulm (s, k_1, sum, skey->E.n);    /* s = k^(-1)*(hash+(d*r)) mod n */
    }
  while (!mpi_cmp_ui (s, 0));

  if (DBG_CIPHER)
         }
","_gcry_ecc_ecdsa_sign (gcry_mpi_t input, ECC_secret_key *skey,
                      gcry_mpi_t r, gcry_mpi_t s,
                      int flags, int hashalgo)
{
  gpg_err_code_t rc = 0;
  int extraloops = 0;
  gcry_mpi_t k, dr, sum, k_1, x;
  mpi_point_struct I;
  gcry_mpi_t hash;
   const void *abuf;
   unsigned int abits, qbits;
   mpi_ec_t ctx;
  gcry_mpi_t b;                /* Random number needed for blinding.  */
  gcry_mpi_t bi;               /* multiplicative inverse of B.        */
 
   if (DBG_CIPHER)
     log_mpidump (""ecdsa sign hash  "", input );

  /* Convert the INPUT into an MPI if needed.  */
  rc = _gcry_dsa_normalize_hash (input, &hash, qbits);
  if (rc)
    return rc;
   if (rc)
     return rc;
 
  b  = mpi_snew (qbits);
  bi = mpi_snew (qbits);
  do
    {
      _gcry_mpi_randomize (b, qbits, GCRY_WEAK_RANDOM);
      mpi_mod (b, b, skey->E.n);
    }
  while (!mpi_invm (bi, b, skey->E.n));

   k = NULL;
   dr = mpi_alloc (0);
   sum = mpi_alloc (0);
    {
      do
        {
          mpi_free (k);
          k = NULL;
          if ((flags & PUBKEY_FLAG_RFC6979) && hashalgo)
            {
              /* Use Pornin's method for deterministic DSA.  If this
                 flag is set, it is expected that HASH is an opaque
                 MPI with the to be signed hash.  That hash is also
                 used as h1 from 3.2.a.  */
              if (!mpi_is_opaque (input))
                {
                  rc = GPG_ERR_CONFLICT;
                  goto leave;
                }

              abuf = mpi_get_opaque (input, &abits);
              rc = _gcry_dsa_gen_rfc6979_k (&k, skey->E.n, skey->d,
                                            abuf, (abits+7)/8,
                                            hashalgo, extraloops);
              if (rc)
                goto leave;
              extraloops++;
            }
          else
            k = _gcry_dsa_gen_k (skey->E.n, GCRY_STRONG_RANDOM);

          _gcry_mpi_ec_mul_point (&I, k, &skey->E.G, ctx);
          if (_gcry_mpi_ec_get_affine (x, NULL, &I, ctx))
            {
              if (DBG_CIPHER)
                log_debug (""ecc sign: Failed to get affine coordinates\n"");
              rc = GPG_ERR_BAD_SIGNATURE;
              goto leave;
            }
          mpi_mod (r, x, skey->E.n);  /* r = x mod n */
        }
      while (!mpi_cmp_ui (r, 0));

      mpi_mulm (dr, skey->d, r, skey->E.n); /* dr = d*r mod n  */
      mpi_addm (sum, hash, dr, skey->E.n);  /* sum = hash + (d*r) mod n  */
      mpi_invm (k_1, k, skey->E.n);         /* k_1 = k^(-1) mod n  */
      mpi_mulm (s, k_1, sum, skey->E.n);    /* s = k^(-1)*(hash+(d*r)) mod n */
    }
  while (!mpi_cmp_ui (s, 0));

  if (DBG_CIPHER)
         }
","The provided code implements the ECDSA (Elliptic Curve Digital Signature Algorithm) signing process. It takes an input hash, a secret key, and outputs two components of the signature, `r` and `s`. The function first normalizes the input hash and generates a random integer `k`, either deterministically (if the RFC6979 flag is set) or randomly. It then computes the elliptic curve point corresponding to `k`, extracts its x-coordinate, and calculates `r`. Subsequently, it computes `s` using the secret key and the hash, ensuring both `r` and `s` are non-zero. The function handles errors and logs debug information as needed.","The code implements the signing process of the Elliptic Curve Digital Signature Algorithm (ECDSA). It begins by normalizing the input hash and generating a random integer for the signing process, which can be done either deterministically or randomly. The algorithm computes a point on the elliptic curve based on this integer and extracts its x-coordinate to derive one part of the signature. It then calculates the second part of the signature using the secret key and the hash. Throughout the process, the code ensures that both signature components are non-zero and handles potential errors while logging relevant information.","The vulnerability in the original code stemmed from the potential reuse of the random integer `k` during the signing process, which could lead to the exposure of the secret key if the same `k` was used for multiple signatures. This risk was mitigated in the fixed code by introducing a blinding factor `b`, which is generated randomly and used to ensure that `k` is unique for each signing operation. The code now includes a loop that generates `b` and its multiplicative inverse `bi`, ensuring that `k` is derived in a way that prevents its reuse, thereby enhancing the security of the signing process.","The vulnerability in the original code was due to the potential reuse of a random integer used in the signing process, which could compromise the secret key if the same integer was employed for multiple signatures. This risk was addressed in the updated code by introducing a blinding factor that is generated randomly and ensures the uniqueness of the integer for each signing operation. The new implementation includes a mechanism to create and validate this blinding factor, thereby preventing the reuse of the integer and significantly enhancing the security of the signing process against key exposure attacks.","The vulnerability was fixed by introducing a blinding factor, represented by the variable `b`, which is generated randomly within a loop that ensures it is valid and unique for each signing operation. The code now includes a check that uses the multiplicative inverse `bi` of `b`, ensuring that it is non-zero and properly modulated by the secret key's order. This prevents the reuse of the random integer `k` during the signing process, as `k` is derived in a way that incorporates this blinding factor, thereby enhancing the overall security of the signature generation.","The vulnerability was fixed by implementing a mechanism to generate a unique blinding factor that ensures the randomness of the integer used in the signing process. This approach involves creating a random value that is validated to ensure it is non-zero and suitable for use, thereby preventing the reuse of the signing integer across multiple signatures. By incorporating this blinding factor into the signing algorithm, the updated code significantly enhances security, reducing the risk of exposing the secret key through potential integer reuse and ensuring that each signature remains distinct and secure.","5,4","5,5","4, 4","4,4"
28,28,179067,179067,,Local,Not required,,CVE-2011-1160,https://www.cvedetails.com/cve/CVE-2011-1160/,CWE-200,Low,Partial,,,2012-06-21,2.1,"The tpm_open function in drivers/char/tpm/tpm.c in the Linux kernel before 2.6.39 does not initialize a certain buffer, which allows local users to obtain potentially sensitive information from kernel memory via unspecified vectors.",2012-06-26,+Info ,1,https://github.com/torvalds/linux/commit/1309d7afbed112f0e8e90be9af975550caa0076b,1309d7afbed112f0e8e90be9af975550caa0076b,"char/tpm: Fix unitialized usage of data buffer

This patch fixes information leakage to the userspace by initializing
the data buffer to zero.

Reported-by: Peter Huewe <huewe.external@infineon.com>
Signed-off-by: Peter Huewe <huewe.external@infineon.com>
Signed-off-by: Marcel Selhorst <m.selhorst@sirrix.com>
[ Also removed the silly ""* sizeof(u8)"".  If that isn't 1, we have way
  deeper problems than a simple multiplication can fix.   - Linus ]
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",1,drivers/char/tpm/tpm.c,"{""sha"": ""7beb0e25f1e1e2ca192ae563eb43f6dc0147f8f8"", ""filename"": ""drivers/char/tpm/tpm.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/1309d7afbed112f0e8e90be9af975550caa0076b/drivers/char/tpm/tpm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/1309d7afbed112f0e8e90be9af975550caa0076b/drivers/char/tpm/tpm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/tpm/tpm.c?ref=1309d7afbed112f0e8e90be9af975550caa0076b"", ""patch"": ""@@ -980,7 +980,7 @@ int tpm_open(struct inode *inode, struct file *file)\n \t\treturn -EBUSY;\n \t}\n \n-\tchip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);\n+\tchip->data_buffer = kzalloc(TPM_BUFSIZE, GFP_KERNEL);\n \tif (chip->data_buffer == NULL) {\n \t\tclear_bit(0, &chip->is_open);\n \t\tput_device(chip->dev);""}","int tpm_open(struct inode *inode, struct file *file)
{
	int minor = iminor(inode);
	struct tpm_chip *chip = NULL, *pos;

	rcu_read_lock();
	list_for_each_entry_rcu(pos, &tpm_chip_list, list) {
		if (pos->vendor.miscdev.minor == minor) {
			chip = pos;
			get_device(chip->dev);
			break;
		}
	}
	rcu_read_unlock();

	if (!chip)
		return -ENODEV;

	if (test_and_set_bit(0, &chip->is_open)) {
		dev_dbg(chip->dev, ""Another process owns this TPM\n"");
		put_device(chip->dev);
 		return -EBUSY;
 	}
 
	chip->data_buffer = kzalloc(TPM_BUFSIZE, GFP_KERNEL);
 	if (chip->data_buffer == NULL) {
 		clear_bit(0, &chip->is_open);
 		put_device(chip->dev);
		return -ENOMEM;
	}

	atomic_set(&chip->data_pending, 0);

	file->private_data = chip;
	return 0;
}
","int tpm_open(struct inode *inode, struct file *file)
{
	int minor = iminor(inode);
	struct tpm_chip *chip = NULL, *pos;

	rcu_read_lock();
	list_for_each_entry_rcu(pos, &tpm_chip_list, list) {
		if (pos->vendor.miscdev.minor == minor) {
			chip = pos;
			get_device(chip->dev);
			break;
		}
	}
	rcu_read_unlock();

	if (!chip)
		return -ENODEV;

	if (test_and_set_bit(0, &chip->is_open)) {
		dev_dbg(chip->dev, ""Another process owns this TPM\n"");
		put_device(chip->dev);
 		return -EBUSY;
 	}
 
	chip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);
 	if (chip->data_buffer == NULL) {
 		clear_bit(0, &chip->is_open);
 		put_device(chip->dev);
		return -ENOMEM;
	}

	atomic_set(&chip->data_pending, 0);

	file->private_data = chip;
	return 0;
}
",C,"	chip->data_buffer = kzalloc(TPM_BUFSIZE, GFP_KERNEL);
","	chip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);
",,"@@ -980,7 +980,7 @@ int tpm_open(struct inode *inode, struct file *file)
 		return -EBUSY;
 	}
 
-	chip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);
+	chip->data_buffer = kzalloc(TPM_BUFSIZE, GFP_KERNEL);
 	if (chip->data_buffer == NULL) {
 		clear_bit(0, &chip->is_open);
 		put_device(chip->dev);",linux,1309d7afbed112f0e8e90be9af975550caa0076b,0444d76ae64fffc7851797fc1b6ebdbb44ac504a,1,"int tpm_open(struct inode *inode, struct file *file)
{
	int minor = iminor(inode);
	struct tpm_chip *chip = NULL, *pos;

	rcu_read_lock();
	list_for_each_entry_rcu(pos, &tpm_chip_list, list) {
		if (pos->vendor.miscdev.minor == minor) {
			chip = pos;
			get_device(chip->dev);
			break;
		}
	}
	rcu_read_unlock();

	if (!chip)
		return -ENODEV;

	if (test_and_set_bit(0, &chip->is_open)) {
		dev_dbg(chip->dev, ""Another process owns this TPM\n"");
		put_device(chip->dev);
 		return -EBUSY;
 	}
 
//flaw_line_below:
	chip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);
//fix_flaw_line_below:
//	chip->data_buffer = kzalloc(TPM_BUFSIZE, GFP_KERNEL);
 	if (chip->data_buffer == NULL) {
 		clear_bit(0, &chip->is_open);
 		put_device(chip->dev);
		return -ENOMEM;
	}

	atomic_set(&chip->data_pending, 0);

	file->private_data = chip;
	return 0;
}
",179067,"int tpm_open(struct inode *inode, struct file *file)
{
	int minor = iminor(inode);
	struct tpm_chip *chip = NULL, *pos;

	rcu_read_lock();
	list_for_each_entry_rcu(pos, &tpm_chip_list, list) {
		if (pos->vendor.miscdev.minor == minor) {
			chip = pos;
			get_device(chip->dev);
			break;
		}
	}
	rcu_read_unlock();

	if (!chip)
		return -ENODEV;

	if (test_and_set_bit(0, &chip->is_open)) {
		dev_dbg(chip->dev, ""Another process owns this TPM\n"");
		put_device(chip->dev);
 		return -EBUSY;
 	}
 
	chip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);
 	if (chip->data_buffer == NULL) {
 		clear_bit(0, &chip->is_open);
 		put_device(chip->dev);
		return -ENOMEM;
	}

	atomic_set(&chip->data_pending, 0);

	file->private_data = chip;
	return 0;
}
","int tpm_open(struct inode *inode, struct file *file)
{
	int minor = iminor(inode);
	struct tpm_chip *chip = NULL, *pos;

	rcu_read_lock();
	list_for_each_entry_rcu(pos, &tpm_chip_list, list) {
		if (pos->vendor.miscdev.minor == minor) {
			chip = pos;
			get_device(chip->dev);
			break;
		}
	}
	rcu_read_unlock();

	if (!chip)
		return -ENODEV;

	if (test_and_set_bit(0, &chip->is_open)) {
		dev_dbg(chip->dev, ""Another process owns this TPM\n"");
		put_device(chip->dev);
 		return -EBUSY;
 	}
 
	chip->data_buffer = kzalloc(TPM_BUFSIZE, GFP_KERNEL);
 	if (chip->data_buffer == NULL) {
 		clear_bit(0, &chip->is_open);
 		put_device(chip->dev);
		return -ENOMEM;
	}

	atomic_set(&chip->data_pending, 0);

	file->private_data = chip;
	return 0;
}
","The `tpm_open` function is designed to manage the opening of a Trusted Platform Module (TPM) device in a Linux kernel environment. It first retrieves the minor device number from the inode and searches for the corresponding TPM chip in a list. If found, it checks if the device is already open; if so, it logs a message and returns an error. If the device is not in use, it allocates a buffer for data storage and initializes a pending data counter. Finally, it associates the TPM chip with the file's private data, allowing further operations on the device.","The provided code manages the opening of a Trusted Platform Module device within a Linux kernel environment. It begins by identifying the specific device based on its minor number and searches for the corresponding device in a list. If the device is found, it checks if it is already in use; if so, it logs a message and returns an error. If the device is available, it allocates memory for a data buffer and initializes a counter for pending data. Finally, it associates the device with the file's private data, enabling subsequent operations on the device.","The vulnerability in the original code stemmed from the allocation of a data buffer without initializing it, which could lead to information leakage to userspace, as uninitialized memory may contain residual data from previous operations. In the fixed code, the allocation function was changed from `kmalloc` to `kzalloc`, which not only allocates memory but also initializes it to zero. This change ensures that the data buffer does not contain any sensitive or unintended information, thereby mitigating the risk of exposing residual data to userspace and enhancing the overall security of the TPM device management.","The vulnerability in the original code was due to the allocation of a data buffer without proper initialization, which could lead to information leakage by exposing residual data from previous uses of the memory. This uninitialized memory could inadvertently reveal sensitive information to userspace applications. The fix addressed this issue by changing the memory allocation method to one that initializes the allocated memory to zero. This ensures that the data buffer starts in a clean state, preventing any potential leakage of sensitive information and enhancing the security of the system.","The vulnerability was fixed by replacing the memory allocation function from `kmalloc` to `kzalloc` for the `data_buffer`. While `kmalloc` allocates memory without initializing it, potentially leaving residual data, `kzalloc` allocates the same amount of memory but also initializes it to zero. This change ensures that the `data_buffer` does not contain any sensitive or unintended information, thereby preventing information leakage to userspace. Additionally, the code also removed the unnecessary multiplication by `sizeof(u8)`, simplifying the allocation process and reinforcing the focus on security and clarity in memory management.","The vulnerability was addressed by changing the memory allocation method to one that initializes the allocated memory to zero. This modification ensures that the memory does not contain any residual data from previous uses, which could lead to unintended information leakage to userspace. By initializing the memory, the fix effectively prevents the exposure of sensitive information that might have been present in uninitialized memory. Additionally, the code was simplified by removing unnecessary calculations, enhancing both security and clarity in the memory management process. This comprehensive approach significantly improves the overall safety of the system.","5,5","5,5","5,5","5,5"
29,29,179133,179133,,Local,Not required,,CVE-2013-4516,https://www.cvedetails.com/cve/CVE-2013-4516/,CWE-200,Low,Complete,,,2013-11-12,4.9,"The mp_get_count function in drivers/staging/sb105x/sb_pci_mp.c in the Linux kernel before 3.12 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel stack memory via a TIOCGICOUNT ioctl call.",2014-01-07,+Info ,1,https://github.com/torvalds/linux/commit/a8b33654b1e3b0c74d4a1fed041c9aae50b3c427,a8b33654b1e3b0c74d4a1fed041c9aae50b3c427,"Staging: sb105x: info leak in mp_get_count()

The icount.reserved[] array isn't initialized so it leaks stack
information to userspace.

Reported-by: Nico Golde <nico@ngolde.de>
Reported-by: Fabian Yamaguchi <fabs@goesec.de>
Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
Cc: stable@kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",1,drivers/staging/sb105x/sb_pci_mp.c,"{""sha"": ""a10cdb17038bf9717bbb20f979fb104dda9ccb27"", ""filename"": ""drivers/staging/sb105x/sb_pci_mp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b33654b1e3b0c74d4a1fed041c9aae50b3c427/drivers/staging/sb105x/sb_pci_mp.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b33654b1e3b0c74d4a1fed041c9aae50b3c427/drivers/staging/sb105x/sb_pci_mp.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/staging/sb105x/sb_pci_mp.c?ref=a8b33654b1e3b0c74d4a1fed041c9aae50b3c427"", ""patch"": ""@@ -1063,7 +1063,7 @@ static int mp_wait_modem_status(struct sb_uart_state *state, unsigned long arg)\n \n static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n {\n-\tstruct serial_icounter_struct icount;\n+\tstruct serial_icounter_struct icount = {};\n \tstruct sb_uart_icount cnow;\n \tstruct sb_uart_port *port = state->port;\n ""}"," static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)
 {
	struct serial_icounter_struct icount = {};
 	struct sb_uart_icount cnow;
 	struct sb_uart_port *port = state->port;
 
	spin_lock_irq(&port->lock);
	memcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));
	spin_unlock_irq(&port->lock);

	icount.cts         = cnow.cts;
	icount.dsr         = cnow.dsr;
	icount.rng         = cnow.rng;
	icount.dcd         = cnow.dcd;
	icount.rx          = cnow.rx;
	icount.tx          = cnow.tx;
	icount.frame       = cnow.frame;
	icount.overrun     = cnow.overrun;
	icount.parity      = cnow.parity;
	icount.brk         = cnow.brk;
	icount.buf_overrun = cnow.buf_overrun;

	return copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;
}
"," static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)
 {
	struct serial_icounter_struct icount;
 	struct sb_uart_icount cnow;
 	struct sb_uart_port *port = state->port;
 
	spin_lock_irq(&port->lock);
	memcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));
	spin_unlock_irq(&port->lock);

	icount.cts         = cnow.cts;
	icount.dsr         = cnow.dsr;
	icount.rng         = cnow.rng;
	icount.dcd         = cnow.dcd;
	icount.rx          = cnow.rx;
	icount.tx          = cnow.tx;
	icount.frame       = cnow.frame;
	icount.overrun     = cnow.overrun;
	icount.parity      = cnow.parity;
	icount.brk         = cnow.brk;
	icount.buf_overrun = cnow.buf_overrun;

	return copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;
}
",C,"	struct serial_icounter_struct icount = {};
","	struct serial_icounter_struct icount;
",,"@@ -1063,7 +1063,7 @@ static int mp_wait_modem_status(struct sb_uart_state *state, unsigned long arg)
 
 static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)
 {
-	struct serial_icounter_struct icount;
+	struct serial_icounter_struct icount = {};
 	struct sb_uart_icount cnow;
 	struct sb_uart_port *port = state->port;
 ",linux,a8b33654b1e3b0c74d4a1fed041c9aae50b3c427,8d1e72250c847fa96498ec029891de4dc638a5ba,1," static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)
 {
//flaw_line_below:
	struct serial_icounter_struct icount;
//fix_flaw_line_below:
//	struct serial_icounter_struct icount = {};
 	struct sb_uart_icount cnow;
 	struct sb_uart_port *port = state->port;
 
	spin_lock_irq(&port->lock);
	memcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));
	spin_unlock_irq(&port->lock);

	icount.cts         = cnow.cts;
	icount.dsr         = cnow.dsr;
	icount.rng         = cnow.rng;
	icount.dcd         = cnow.dcd;
	icount.rx          = cnow.rx;
	icount.tx          = cnow.tx;
	icount.frame       = cnow.frame;
	icount.overrun     = cnow.overrun;
	icount.parity      = cnow.parity;
	icount.brk         = cnow.brk;
	icount.buf_overrun = cnow.buf_overrun;

	return copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;
}
",179133," static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)
 {
	struct serial_icounter_struct icount;
 	struct sb_uart_icount cnow;
 	struct sb_uart_port *port = state->port;
 
	spin_lock_irq(&port->lock);
	memcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));
	spin_unlock_irq(&port->lock);

	icount.cts         = cnow.cts;
	icount.dsr         = cnow.dsr;
	icount.rng         = cnow.rng;
	icount.dcd         = cnow.dcd;
	icount.rx          = cnow.rx;
	icount.tx          = cnow.tx;
	icount.frame       = cnow.frame;
	icount.overrun     = cnow.overrun;
	icount.parity      = cnow.parity;
	icount.brk         = cnow.brk;
	icount.buf_overrun = cnow.buf_overrun;

	return copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;
}
"," static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)
 {
	struct serial_icounter_struct icount = {};
 	struct sb_uart_icount cnow;
 	struct sb_uart_port *port = state->port;
 
	spin_lock_irq(&port->lock);
	memcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));
	spin_unlock_irq(&port->lock);

	icount.cts         = cnow.cts;
	icount.dsr         = cnow.dsr;
	icount.rng         = cnow.rng;
	icount.dcd         = cnow.dcd;
	icount.rx          = cnow.rx;
	icount.tx          = cnow.tx;
	icount.frame       = cnow.frame;
	icount.overrun     = cnow.overrun;
	icount.parity      = cnow.parity;
	icount.brk         = cnow.brk;
	icount.buf_overrun = cnow.buf_overrun;

	return copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;
}
","The `mp_get_count` function retrieves and returns the current state of various serial communication counters from a UART (Universal Asynchronous Receiver-Transmitter) port. It first locks the port to ensure thread safety, then copies the current interrupt counts (such as received/transmitted bytes and error counts) from the port's internal structure to a local structure. After unlocking the port, it attempts to copy this data to a user-provided structure, returning a success status or an error code if the copy operation fails. This function is essential for monitoring the performance and error rates of serial communication.","The provided code defines a function that retrieves the current counts of various serial communication events from a UART port. It ensures thread safety by locking the port before accessing its internal data, which includes counts for received and transmitted characters, as well as error occurrences. After copying this data to a local structure, the function unlocks the port and attempts to transfer the information to a user-specified location. It returns a success status if the transfer is successful or an error code if it fails, facilitating the monitoring of serial communication performance and reliability.","The vulnerability in the original code stemmed from the uninitialized `icount.reserved[]` array, which could inadvertently leak sensitive stack information to user space when the function returned data. This information exposure posed a security risk, as it could allow an attacker to infer details about the system's memory state. The fix involved initializing the `icount` structure to zero at the start of the function, ensuring that all fields, including the `reserved[]` array, are set to a known state before being populated with valid data. This change effectively mitigated the information leak by preventing any residual stack data from being exposed.","The vulnerability in the original code was due to an uninitialized array that could leak sensitive stack information to user space, potentially exposing internal memory details to unauthorized access. This information leak posed a security risk, as it could allow attackers to infer system state or exploit other vulnerabilities. The fix involved initializing the entire structure to zero at the beginning of the function, ensuring that all fields, including the problematic array, were set to a known state before being populated with valid data. This change effectively eliminated the risk of leaking residual stack information, enhancing the security of the code.","The vulnerability was fixed by initializing the `icount` structure to zero at the beginning of the function using the syntax `struct serial_icounter_struct icount = {};`. This initialization ensures that all fields within the structure, including the `reserved[]` array, are set to a known state before any valid data is copied into them. By doing this, the code prevents any uninitialized memory from being exposed to user space, effectively mitigating the risk of leaking sensitive stack information. This change enhances the overall security of the function by ensuring that only intended data is returned to the user.","The vulnerability was addressed by ensuring that the structure used to hold communication counts was fully initialized to zero at the start of the function. This initialization process guarantees that all fields, including those that could potentially leak sensitive information, are set to a known state before any valid data is assigned. By eliminating any residual data from memory, the fix effectively prevents the exposure of uninitialized values to user space, thereby mitigating the risk of information leaks and enhancing the overall security of the code. This proactive approach ensures that only intended and valid data is returned.","5,5","5,5","5,5","4,5"
30,30,179134,179134,,Local,Not required,,CVE-2013-4515,https://www.cvedetails.com/cve/CVE-2013-4515/,CWE-200,Low,Complete,,,2013-11-12,4.9,"The bcm_char_ioctl function in drivers/staging/bcm/Bcmchar.c in the Linux kernel before 3.12 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel memory via an IOCTL_BCM_GET_DEVICE_DRIVER_INFO ioctl call.",2014-03-05,+Info ,1,https://github.com/torvalds/linux/commit/8d1e72250c847fa96498ec029891de4dc638a5ba,8d1e72250c847fa96498ec029891de4dc638a5ba,"Staging: bcm: info leak in ioctl

The DevInfo.u32Reserved[] array isn't initialized so it leaks kernel
information to user space.

Reported-by: Nico Golde <nico@ngolde.de>
Reported-by: Fabian Yamaguchi <fabs@goesec.de>
Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
Cc: stable@kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,drivers/staging/bcm/Bcmchar.c,"{""sha"": ""639ba96adb36b58e1c21b6ae037f084be512cdfc"", ""filename"": ""drivers/staging/bcm/Bcmchar.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d1e72250c847fa96498ec029891de4dc638a5ba/drivers/staging/bcm/Bcmchar.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d1e72250c847fa96498ec029891de4dc638a5ba/drivers/staging/bcm/Bcmchar.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/staging/bcm/Bcmchar.c?ref=8d1e72250c847fa96498ec029891de4dc638a5ba"", ""patch"": ""@@ -1960,6 +1960,7 @@ static long bcm_char_ioctl(struct file *filp, UINT cmd, ULONG arg)\n \n \t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \""Called IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n\"");\n \n+\t\tmemset(&DevInfo, 0, sizeof(DevInfo));\n \t\tDevInfo.MaxRDMBufferSize = BUFFER_4K;\n \t\tDevInfo.u32DSDStartOffset = EEPROM_CALPARAM_START;\n \t\tDevInfo.u32RxAlignmentCorrection = 0;""}","static long bcm_char_ioctl(struct file *filp, UINT cmd, ULONG arg)
{
	struct bcm_tarang_data *pTarang = filp->private_data;
	void __user *argp = (void __user *)arg;
	struct bcm_mini_adapter *Adapter = pTarang->Adapter;
	INT Status = STATUS_FAILURE;
	int timeout = 0;
	struct bcm_ioctl_buffer IoBuffer;
	int bytes;

	BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Parameters Passed to control IOCTL cmd=0x%X arg=0x%lX"", cmd, arg);

	if (_IOC_TYPE(cmd) != BCM_IOCTL)
		return -EFAULT;
	if (_IOC_DIR(cmd) & _IOC_READ)
		Status = !access_ok(VERIFY_WRITE, argp, _IOC_SIZE(cmd));
	else if (_IOC_DIR(cmd) & _IOC_WRITE)
		Status = !access_ok(VERIFY_READ, argp, _IOC_SIZE(cmd));
	else if (_IOC_NONE == (_IOC_DIR(cmd) & _IOC_NONE))
		Status = STATUS_SUCCESS;

	if (Status)
		return -EFAULT;

	if (Adapter->device_removed)
		return -EFAULT;

	if (FALSE == Adapter->fw_download_done) {
		switch (cmd) {
		case IOCTL_MAC_ADDR_REQ:
		case IOCTL_LINK_REQ:
		case IOCTL_CM_REQUEST:
		case IOCTL_SS_INFO_REQ:
		case IOCTL_SEND_CONTROL_MESSAGE:
		case IOCTL_IDLE_REQ:
		case IOCTL_BCM_GPIO_SET_REQUEST:
		case IOCTL_BCM_GPIO_STATUS_REQUEST:
			return -EACCES;
		default:
			break;
		}
	}

	Status = vendorextnIoctl(Adapter, cmd, arg);
	if (Status != CONTINUE_COMMON_PATH)
		return Status;

	switch (cmd) {
	/* Rdms for Swin Idle... */
	case IOCTL_BCM_REGISTER_READ_PRIVATE: {
		struct bcm_rdm_buffer sRdmBuffer = {0};
		PCHAR temp_buff;
		UINT Bufflen;
		u16 temp_value;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sRdmBuffer))
			return -EINVAL;

		if (copy_from_user(&sRdmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if (IoBuffer.OutputLength > USHRT_MAX ||
			IoBuffer.OutputLength == 0) {
			return -EINVAL;
		}

		Bufflen = IoBuffer.OutputLength;
		temp_value = 4 - (Bufflen % 4);
		Bufflen += temp_value % 4;

		temp_buff = kmalloc(Bufflen, GFP_KERNEL);
		if (!temp_buff)
			return -ENOMEM;

		bytes = rdmalt(Adapter, (UINT)sRdmBuffer.Register,
				(PUINT)temp_buff, Bufflen);
		if (bytes > 0) {
			Status = STATUS_SUCCESS;
			if (copy_to_user(IoBuffer.OutputBuffer, temp_buff, bytes)) {
				kfree(temp_buff);
				return -EFAULT;
			}
		} else {
			Status = bytes;
		}

		kfree(temp_buff);
		break;
	}

	case IOCTL_BCM_REGISTER_WRITE_PRIVATE: {
		struct bcm_wrm_buffer sWrmBuffer = {0};
		UINT uiTempVar = 0;
		/* Copy Ioctl Buffer structure */

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sWrmBuffer))
			return -EINVAL;

		/* Get WrmBuffer structure */
		if (copy_from_user(&sWrmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		uiTempVar = sWrmBuffer.Register & EEPROM_REJECT_MASK;
		if (!((Adapter->pstargetparams->m_u32Customize) & VSG_MODE) &&
			((uiTempVar == EEPROM_REJECT_REG_1) ||
				(uiTempVar == EEPROM_REJECT_REG_2) ||
				(uiTempVar == EEPROM_REJECT_REG_3) ||
				(uiTempVar == EEPROM_REJECT_REG_4))) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""EEPROM Access Denied, not in VSG Mode\n"");
			return -EFAULT;
		}

		Status = wrmalt(Adapter, (UINT)sWrmBuffer.Register,
				(PUINT)sWrmBuffer.Data, sizeof(ULONG));

		if (Status == STATUS_SUCCESS) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""WRM Done\n"");
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""WRM Failed\n"");
			Status = -EFAULT;
		}
		break;
	}

	case IOCTL_BCM_REGISTER_READ:
	case IOCTL_BCM_EEPROM_REGISTER_READ: {
		struct bcm_rdm_buffer sRdmBuffer = {0};
		PCHAR temp_buff = NULL;
		UINT uiTempVar = 0;
		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device in Idle Mode, Blocking Rdms\n"");
			return -EACCES;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sRdmBuffer))
			return -EINVAL;

		if (copy_from_user(&sRdmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if (IoBuffer.OutputLength > USHRT_MAX ||
			IoBuffer.OutputLength == 0) {
			return -EINVAL;
		}

		temp_buff = kmalloc(IoBuffer.OutputLength, GFP_KERNEL);
		if (!temp_buff)
			return STATUS_FAILURE;

		if ((((ULONG)sRdmBuffer.Register & 0x0F000000) != 0x0F000000) ||
			((ULONG)sRdmBuffer.Register & 0x3)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""RDM Done On invalid Address : %x Access Denied.\n"",
					(int)sRdmBuffer.Register);

			kfree(temp_buff);
			return -EINVAL;
		}

		uiTempVar = sRdmBuffer.Register & EEPROM_REJECT_MASK;
		bytes = rdmaltWithLock(Adapter, (UINT)sRdmBuffer.Register, (PUINT)temp_buff, IoBuffer.OutputLength);

		if (bytes > 0) {
			Status = STATUS_SUCCESS;
			if (copy_to_user(IoBuffer.OutputBuffer, temp_buff, bytes)) {
				kfree(temp_buff);
				return -EFAULT;
			}
		} else {
			Status = bytes;
		}

		kfree(temp_buff);
		break;
	}
	case IOCTL_BCM_REGISTER_WRITE:
	case IOCTL_BCM_EEPROM_REGISTER_WRITE: {
		struct bcm_wrm_buffer sWrmBuffer = {0};
		UINT uiTempVar = 0;

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device in Idle Mode, Blocking Wrms\n"");
			return -EACCES;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sWrmBuffer))
			return -EINVAL;

		/* Get WrmBuffer structure */
		if (copy_from_user(&sWrmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if ((((ULONG)sWrmBuffer.Register & 0x0F000000) != 0x0F000000) ||
			((ULONG)sWrmBuffer.Register & 0x3)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM Done On invalid Address : %x Access Denied.\n"", (int)sWrmBuffer.Register);
			return -EINVAL;
		}

		uiTempVar = sWrmBuffer.Register & EEPROM_REJECT_MASK;
		if (!((Adapter->pstargetparams->m_u32Customize) & VSG_MODE) &&
				((uiTempVar == EEPROM_REJECT_REG_1) ||
				(uiTempVar == EEPROM_REJECT_REG_2) ||
				(uiTempVar == EEPROM_REJECT_REG_3) ||
				(uiTempVar == EEPROM_REJECT_REG_4)) &&
				(cmd == IOCTL_BCM_REGISTER_WRITE)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""EEPROM Access Denied, not in VSG Mode\n"");
				return -EFAULT;
		}

		Status = wrmaltWithLock(Adapter, (UINT)sWrmBuffer.Register,
					(PUINT)sWrmBuffer.Data, sWrmBuffer.Length);

		if (Status == STATUS_SUCCESS) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL, ""WRM Done\n"");
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""WRM Failed\n"");
			Status = -EFAULT;
		}
		break;
	}
	case IOCTL_BCM_GPIO_SET_REQUEST: {
		UCHAR ucResetValue[4];
		UINT value = 0;
		UINT uiBit = 0;
		UINT uiOperation = 0;
		struct bcm_gpio_info gpio_info = {0};

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""GPIO Can't be set/clear in Low power Mode"");
			return -EACCES;
		}

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_info))
			return -EINVAL;

		if (copy_from_user(&gpio_info, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		uiBit  = gpio_info.uiGpioNumber;
		uiOperation = gpio_info.uiGpioValue;
		value = (1<<uiBit);

		if (IsReqGpioIsLedInNVM(Adapter, value) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Sorry, Requested GPIO<0x%X> is not correspond to LED !!!"", value);
			Status = -EINVAL;
			break;
		}

		/* Set - setting 1 */
		if (uiOperation) {
			/* Set the gpio output register */
			Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_SET_REG, (PUINT)(&value), sizeof(UINT));

			if (Status == STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Set the GPIO bit\n"");
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Failed to set the %dth GPIO\n"", uiBit);
				break;
			}
		} else {
			/* Set the gpio output register */
			Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_CLR_REG, (PUINT)(&value), sizeof(UINT));

			if (Status == STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Set the GPIO bit\n"");
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Failed to clear the %dth GPIO\n"", uiBit);
				break;
			}
		}

		bytes = rdmaltWithLock(Adapter, (UINT)GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));
		if (bytes < 0) {
			Status = bytes;
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""GPIO_MODE_REGISTER read failed"");
			break;
		} else {
			Status = STATUS_SUCCESS;
		}

		/* Set the gpio mode register to output */
		*(UINT *)ucResetValue |= (1<<uiBit);
		Status = wrmaltWithLock(Adapter, GPIO_MODE_REGISTER,
					(PUINT)ucResetValue, sizeof(UINT));

		if (Status == STATUS_SUCCESS) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Set the GPIO to output Mode\n"");
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Failed to put GPIO in Output Mode\n"");
			break;
		}
	}
	break;

	case BCM_LED_THREAD_STATE_CHANGE_REQ: {
		struct bcm_user_thread_req threadReq = {0};
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""User made LED thread InActive"");

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""GPIO Can't be set/clear in Low power Mode"");
			Status = -EACCES;
			break;
		}

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(threadReq))
			return -EINVAL;

		if (copy_from_user(&threadReq, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		/* if LED thread is running(Actively or Inactively) set it state to make inactive */
		if (Adapter->LEDInfo.led_thread_running) {
			if (threadReq.ThreadState == LED_THREAD_ACTIVATION_REQ) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Activating thread req"");
				Adapter->DriverState = LED_THREAD_ACTIVE;
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""DeActivating Thread req....."");
				Adapter->DriverState = LED_THREAD_INACTIVE;
			}

			/* signal thread. */
			wake_up(&Adapter->LEDInfo.notify_led_event);
		}
	}
	break;

	case IOCTL_BCM_GPIO_STATUS_REQUEST: {
		ULONG uiBit = 0;
		UCHAR ucRead[4];
		struct bcm_gpio_info gpio_info = {0};

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE))
			return -EACCES;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_info))
			return -EINVAL;

		if (copy_from_user(&gpio_info, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		uiBit = gpio_info.uiGpioNumber;

		/* Set the gpio output register */
		bytes = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER,
					(PUINT)ucRead, sizeof(UINT));

		if (bytes < 0) {
			Status = bytes;
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""RDM Failed\n"");
			return Status;
		} else {
			Status = STATUS_SUCCESS;
		}
	}
	break;

	case IOCTL_BCM_GPIO_MULTI_REQUEST: {
		UCHAR ucResetValue[4];
		struct bcm_gpio_multi_info gpio_multi_info[MAX_IDX];
		struct bcm_gpio_multi_info *pgpio_multi_info = (struct bcm_gpio_multi_info *)gpio_multi_info;

		memset(pgpio_multi_info, 0, MAX_IDX * sizeof(struct bcm_gpio_multi_info));

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE))
			return -EINVAL;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_multi_info))
			return -EINVAL;

		if (copy_from_user(&gpio_multi_info, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if (IsReqGpioIsLedInNVM(Adapter, pgpio_multi_info[WIMAX_IDX].uiGPIOMask) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!"",
					pgpio_multi_info[WIMAX_IDX].uiGPIOMask, Adapter->gpioBitMap);
			Status = -EINVAL;
			break;
		}

		/* Set the gpio output register */
		if ((pgpio_multi_info[WIMAX_IDX].uiGPIOMask) &
			(pgpio_multi_info[WIMAX_IDX].uiGPIOCommand)) {
			/* Set 1's in GPIO OUTPUT REGISTER */
			*(UINT *)ucResetValue =  pgpio_multi_info[WIMAX_IDX].uiGPIOMask &
				pgpio_multi_info[WIMAX_IDX].uiGPIOCommand &
				pgpio_multi_info[WIMAX_IDX].uiGPIOValue;

			if (*(UINT *) ucResetValue)
				Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_SET_REG,
							(PUINT)ucResetValue, sizeof(ULONG));

			if (Status != STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM to BCM_GPIO_OUTPUT_SET_REG Failed."");
				return Status;
			}

			/* Clear to 0's in GPIO OUTPUT REGISTER */
			*(UINT *)ucResetValue = (pgpio_multi_info[WIMAX_IDX].uiGPIOMask &
						pgpio_multi_info[WIMAX_IDX].uiGPIOCommand &
						(~(pgpio_multi_info[WIMAX_IDX].uiGPIOValue)));

			if (*(UINT *) ucResetValue)
				Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_CLR_REG, (PUINT)ucResetValue, sizeof(ULONG));

			if (Status != STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM to BCM_GPIO_OUTPUT_CLR_REG Failed."");
				return Status;
			}
		}

		if (pgpio_multi_info[WIMAX_IDX].uiGPIOMask) {
			bytes = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));

			if (bytes < 0) {
				Status = bytes;
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""RDM to GPIO_PIN_STATE_REGISTER Failed."");
				return Status;
			} else {
				Status = STATUS_SUCCESS;
			}

			pgpio_multi_info[WIMAX_IDX].uiGPIOValue = (*(UINT *)ucResetValue &
								pgpio_multi_info[WIMAX_IDX].uiGPIOMask);
		}

		Status = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_info, IoBuffer.OutputLength);
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Failed while copying Content to IOBufer for user space err:%d"", Status);
			return -EFAULT;
		}
	}
	break;

	case IOCTL_BCM_GPIO_MODE_REQUEST: {
		UCHAR ucResetValue[4];
		struct bcm_gpio_multi_mode gpio_multi_mode[MAX_IDX];
		struct bcm_gpio_multi_mode *pgpio_multi_mode = (struct bcm_gpio_multi_mode *)gpio_multi_mode;

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE))
			return -EINVAL;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_multi_mode))
			return -EINVAL;

		if (copy_from_user(&gpio_multi_mode, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		bytes = rdmaltWithLock(Adapter, (UINT)GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));

		if (bytes < 0) {
			Status = bytes;
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Read of GPIO_MODE_REGISTER failed"");
			return Status;
		} else {
			Status = STATUS_SUCCESS;
		}

		/* Validating the request */
		if (IsReqGpioIsLedInNVM(Adapter, pgpio_multi_mode[WIMAX_IDX].uiGPIOMask) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!"",
					pgpio_multi_mode[WIMAX_IDX].uiGPIOMask, Adapter->gpioBitMap);
			Status = -EINVAL;
			break;
		}

		if (pgpio_multi_mode[WIMAX_IDX].uiGPIOMask) {
			/* write all OUT's (1's) */
			*(UINT *) ucResetValue |= (pgpio_multi_mode[WIMAX_IDX].uiGPIOMode &
						pgpio_multi_mode[WIMAX_IDX].uiGPIOMask);

			/* write all IN's (0's) */
			*(UINT *) ucResetValue &= ~((~pgpio_multi_mode[WIMAX_IDX].uiGPIOMode) &
						pgpio_multi_mode[WIMAX_IDX].uiGPIOMask);

			/* Currently implemented return the modes of all GPIO's
			 * else needs to bit AND with  mask
			 */
			pgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT *)ucResetValue;

			Status = wrmaltWithLock(Adapter, GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(ULONG));
			if (Status == STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
						""WRM to GPIO_MODE_REGISTER Done"");
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
						""WRM to GPIO_MODE_REGISTER Failed"");
				Status = -EFAULT;
				break;
			}
		} else {
/* if uiGPIOMask is 0 then return mode register configuration */
			pgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT *)ucResetValue;
		}

		Status = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_mode, IoBuffer.OutputLength);
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Failed while copying Content to IOBufer for user space err:%d"", Status);
			return -EFAULT;
		}
	}
	break;

	case IOCTL_MAC_ADDR_REQ:
	case IOCTL_LINK_REQ:
	case IOCTL_CM_REQUEST:
	case IOCTL_SS_INFO_REQ:
	case IOCTL_SEND_CONTROL_MESSAGE:
	case IOCTL_IDLE_REQ: {
		PVOID pvBuffer = NULL;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength < sizeof(struct bcm_link_request))
			return -EINVAL;

		if (IoBuffer.InputLength > MAX_CNTL_PKT_SIZE)
			return -EINVAL;

		pvBuffer = memdup_user(IoBuffer.InputBuffer,
				       IoBuffer.InputLength);
		if (IS_ERR(pvBuffer))
			return PTR_ERR(pvBuffer);

		down(&Adapter->LowPowerModeSync);
		Status = wait_event_interruptible_timeout(Adapter->lowpower_mode_wait_queue,
							!Adapter->bPreparingForLowPowerMode,
							(1 * HZ));
		if (Status == -ERESTARTSYS)
			goto cntrlEnd;

		if (Adapter->bPreparingForLowPowerMode) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""Preparing Idle Mode is still True - Hence Rejecting control message\n"");
			Status = STATUS_FAILURE;
			goto cntrlEnd;
		}
		Status = CopyBufferToControlPacket(Adapter, (PVOID)pvBuffer);

cntrlEnd:
		up(&Adapter->LowPowerModeSync);
		kfree(pvBuffer);
		break;
	}

	case IOCTL_BCM_BUFFER_DOWNLOAD_START: {
		if (down_trylock(&Adapter->NVMRdmWrmLock)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\n"");
			return -EACCES;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
				""Starting the firmware download PID =0x%x!!!!\n"", current->pid);

		if (down_trylock(&Adapter->fw_download_sema))
			return -EBUSY;

		Adapter->bBinDownloaded = FALSE;
		Adapter->fw_download_process_pid = current->pid;
		Adapter->bCfgDownloaded = FALSE;
		Adapter->fw_download_done = FALSE;
		netif_carrier_off(Adapter->dev);
		netif_stop_queue(Adapter->dev);
		Status = reset_card_proc(Adapter);
		if (Status) {
			pr_err(PFX ""%s: reset_card_proc Failed!\n"", Adapter->dev->name);
			up(&Adapter->fw_download_sema);
			up(&Adapter->NVMRdmWrmLock);
			return Status;
		}
		mdelay(10);

		up(&Adapter->NVMRdmWrmLock);
		return Status;
	}

	case IOCTL_BCM_BUFFER_DOWNLOAD: {
		struct bcm_firmware_info *psFwInfo = NULL;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Starting the firmware download PID =0x%x!!!!\n"", current->pid);

		if (!down_trylock(&Adapter->fw_download_sema)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Invalid way to download buffer. Use Start and then call this!!!\n"");
			up(&Adapter->fw_download_sema);
			Status = -EINVAL;
			return Status;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {
			up(&Adapter->fw_download_sema);
			return -EFAULT;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
				""Length for FW DLD is : %lx\n"", IoBuffer.InputLength);

		if (IoBuffer.InputLength > sizeof(struct bcm_firmware_info)) {
			up(&Adapter->fw_download_sema);
			return -EINVAL;
		}

		psFwInfo = kmalloc(sizeof(*psFwInfo), GFP_KERNEL);
		if (!psFwInfo) {
			up(&Adapter->fw_download_sema);
			return -ENOMEM;
		}

		if (copy_from_user(psFwInfo, IoBuffer.InputBuffer, IoBuffer.InputLength)) {
			up(&Adapter->fw_download_sema);
			kfree(psFwInfo);
			return -EFAULT;
		}

		if (!psFwInfo->pvMappedFirmwareAddress ||
			(psFwInfo->u32FirmwareLength == 0)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Something else is wrong %lu\n"",
					psFwInfo->u32FirmwareLength);
			up(&Adapter->fw_download_sema);
			kfree(psFwInfo);
			Status = -EINVAL;
			return Status;
		}

		Status = bcm_ioctl_fw_download(Adapter, psFwInfo);

		if (Status != STATUS_SUCCESS) {
			if (psFwInfo->u32StartingAddress == CONFIG_BEGIN_ADDR)
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""IOCTL: Configuration File Upload Failed\n"");
			else
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,	""IOCTL: Firmware File Upload Failed\n"");

			/* up(&Adapter->fw_download_sema); */

			if (Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY) {
				Adapter->DriverState = DRIVER_INIT;
				Adapter->LEDInfo.bLedInitDone = FALSE;
				wake_up(&Adapter->LEDInfo.notify_led_event);
			}
		}

		if (Status != STATUS_SUCCESS)
			up(&Adapter->fw_download_sema);

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL, ""IOCTL: Firmware File Uploaded\n"");
		kfree(psFwInfo);
		return Status;
	}

	case IOCTL_BCM_BUFFER_DOWNLOAD_STOP: {
		if (!down_trylock(&Adapter->fw_download_sema)) {
			up(&Adapter->fw_download_sema);
			return -EINVAL;
		}

		if (down_trylock(&Adapter->NVMRdmWrmLock)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""FW download blocked as EEPROM Read/Write is in progress\n"");
			up(&Adapter->fw_download_sema);
			return -EACCES;
		}

		Adapter->bBinDownloaded = TRUE;
		Adapter->bCfgDownloaded = TRUE;
		atomic_set(&Adapter->CurrNumFreeTxDesc, 0);
		Adapter->CurrNumRecvDescs = 0;
		Adapter->downloadDDR = 0;

		/* setting the Mips to Run */
		Status = run_card_proc(Adapter);

		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Firm Download Failed\n"");
			up(&Adapter->fw_download_sema);
			up(&Adapter->NVMRdmWrmLock);
			return Status;
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG,
					DBG_LVL_ALL, ""Firm Download Over...\n"");
		}

		mdelay(10);

		/* Wait for MailBox Interrupt */
		if (StartInterruptUrb((struct bcm_interface_adapter *)Adapter->pvInterfaceAdapter))
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Unable to send interrupt...\n"");

		timeout = 5*HZ;
		Adapter->waiting_to_fw_download_done = FALSE;
		wait_event_timeout(Adapter->ioctl_fw_dnld_wait_queue,
				Adapter->waiting_to_fw_download_done, timeout);
		Adapter->fw_download_process_pid = INVALID_PID;
		Adapter->fw_download_done = TRUE;
		atomic_set(&Adapter->CurrNumFreeTxDesc, 0);
		Adapter->CurrNumRecvDescs = 0;
		Adapter->PrevNumRecvDescs = 0;
		atomic_set(&Adapter->cntrlpktCnt, 0);
		Adapter->LinkUpStatus = 0;
		Adapter->LinkStatus = 0;

		if (Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY) {
			Adapter->DriverState = FW_DOWNLOAD_DONE;
			wake_up(&Adapter->LEDInfo.notify_led_event);
		}

		if (!timeout)
			Status = -ENODEV;

		up(&Adapter->fw_download_sema);
		up(&Adapter->NVMRdmWrmLock);
		return Status;
	}

	case IOCTL_BE_BUCKET_SIZE:
		Status = 0;
		if (get_user(Adapter->BEBucketSize, (unsigned long __user *)arg))
			Status = -EFAULT;
		break;

	case IOCTL_RTPS_BUCKET_SIZE:
		Status = 0;
		if (get_user(Adapter->rtPSBucketSize, (unsigned long __user *)arg))
			Status = -EFAULT;
		break;

	case IOCTL_CHIP_RESET: {
		INT NVMAccess = down_trylock(&Adapter->NVMRdmWrmLock);
		if (NVMAccess) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "" IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\n"");
			return -EACCES;
		}

		down(&Adapter->RxAppControlQueuelock);
		Status = reset_card_proc(Adapter);
		flushAllAppQ();
		up(&Adapter->RxAppControlQueuelock);
		up(&Adapter->NVMRdmWrmLock);
		ResetCounters(Adapter);
		break;
	}

	case IOCTL_QOS_THRESHOLD: {
		USHORT uiLoopIndex;

		Status = 0;
		for (uiLoopIndex = 0; uiLoopIndex < NO_OF_QUEUES; uiLoopIndex++) {
			if (get_user(Adapter->PackInfo[uiLoopIndex].uiThreshold,
					(unsigned long __user *)arg)) {
				Status = -EFAULT;
				break;
			}
		}
		break;
	}

	case IOCTL_DUMP_PACKET_INFO:
		DumpPackInfo(Adapter);
		DumpPhsRules(&Adapter->stBCMPhsContext);
		Status = STATUS_SUCCESS;
		break;

	case IOCTL_GET_PACK_INFO:
		if (copy_to_user(argp, &Adapter->PackInfo, sizeof(struct bcm_packet_info)*NO_OF_QUEUES))
			return -EFAULT;
		Status = STATUS_SUCCESS;
		break;

	case IOCTL_BCM_SWITCH_TRANSFER_MODE: {
		UINT uiData = 0;
		if (copy_from_user(&uiData, argp, sizeof(UINT)))
			return -EFAULT;

		if (uiData) {
			/* Allow All Packets */
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SWITCH_TRANSFER_MODE: ETH_PACKET_TUNNELING_MODE\n"");
				Adapter->TransferMode = ETH_PACKET_TUNNELING_MODE;
		} else {
			/* Allow IP only Packets */
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SWITCH_TRANSFER_MODE: IP_PACKET_ONLY_MODE\n"");
			Adapter->TransferMode = IP_PACKET_ONLY_MODE;
		}
		Status = STATUS_SUCCESS;
		break;
	}

	case IOCTL_BCM_GET_DRIVER_VERSION: {
		ulong len;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		len = min_t(ulong, IoBuffer.OutputLength, strlen(DRV_VERSION) + 1);

		if (copy_to_user(IoBuffer.OutputBuffer, DRV_VERSION, len))
			return -EFAULT;
		Status = STATUS_SUCCESS;
		break;
	}

	case IOCTL_BCM_GET_CURRENT_STATUS: {
		struct bcm_link_state link_state;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""copy_from_user failed..\n"");
			return -EFAULT;
		}

		if (IoBuffer.OutputLength != sizeof(link_state)) {
			Status = -EINVAL;
			break;
		}

		memset(&link_state, 0, sizeof(link_state));
		link_state.bIdleMode = Adapter->IdleMode;
		link_state.bShutdownMode = Adapter->bShutStatus;
		link_state.ucLinkStatus = Adapter->LinkStatus;

		if (copy_to_user(IoBuffer.OutputBuffer, &link_state, min_t(size_t, sizeof(link_state), IoBuffer.OutputLength))) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy_to_user Failed..\n"");
			return -EFAULT;
		}
		Status = STATUS_SUCCESS;
		break;
	}

	case IOCTL_BCM_SET_MAC_TRACING: {
		UINT  tracing_flag;

		/* copy ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (copy_from_user(&tracing_flag, IoBuffer.InputBuffer, sizeof(UINT)))
			return -EFAULT;

		if (tracing_flag)
			Adapter->pTarangs->MacTracingEnabled = TRUE;
		else
			Adapter->pTarangs->MacTracingEnabled = FALSE;
		break;
	}

	case IOCTL_BCM_GET_DSX_INDICATION: {
		ULONG ulSFId = 0;
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength < sizeof(struct bcm_add_indication_alt)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Mismatch req: %lx needed is =0x%zx!!!"",
					IoBuffer.OutputLength, sizeof(struct bcm_add_indication_alt));
			return -EINVAL;
		}

		if (copy_from_user(&ulSFId, IoBuffer.InputBuffer, sizeof(ulSFId)))
			return -EFAULT;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Get DSX Data SF ID is =%lx\n"", ulSFId);
		get_dsx_sf_data_to_application(Adapter, ulSFId, IoBuffer.OutputBuffer);
		Status = STATUS_SUCCESS;
	}
	break;

	case IOCTL_BCM_GET_HOST_MIBS: {
		PVOID temp_buff;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength != sizeof(struct bcm_host_stats_mibs)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Length Check failed %lu %zd\n"",
					IoBuffer.OutputLength, sizeof(struct bcm_host_stats_mibs));
			return -EINVAL;
		}

		/* FIXME: HOST_STATS are too big for kmalloc (122048)! */
		temp_buff = kzalloc(sizeof(struct bcm_host_stats_mibs), GFP_KERNEL);
		if (!temp_buff)
			return STATUS_FAILURE;

		Status = ProcessGetHostMibs(Adapter, temp_buff);
		GetDroppedAppCntrlPktMibs(temp_buff, pTarang);

		if (Status != STATUS_FAILURE)
			if (copy_to_user(IoBuffer.OutputBuffer, temp_buff, sizeof(struct bcm_host_stats_mibs))) {
				kfree(temp_buff);
				return -EFAULT;
			}

		kfree(temp_buff);
		break;
	}

	case IOCTL_BCM_WAKE_UP_DEVICE_FROM_IDLE:
		if ((FALSE == Adapter->bTriedToWakeUpFromlowPowerMode) && (TRUE == Adapter->IdleMode)) {
			Adapter->usIdleModePattern = ABORT_IDLE_MODE;
			Adapter->bWakeUpDevice = TRUE;
			wake_up(&Adapter->process_rx_cntrlpkt);
		}

		Status = STATUS_SUCCESS;
		break;

	case IOCTL_BCM_BULK_WRM: {
		struct bcm_bulk_wrm_buffer *pBulkBuffer;
		UINT uiTempVar = 0;
		PCHAR pvBuffer = NULL;

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device in Idle/Shutdown Mode, Blocking Wrms\n"");
			Status = -EACCES;
			break;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength < sizeof(ULONG) * 2)
			return -EINVAL;

		pvBuffer = memdup_user(IoBuffer.InputBuffer,
				       IoBuffer.InputLength);
		if (IS_ERR(pvBuffer))
			return PTR_ERR(pvBuffer);

		pBulkBuffer = (struct bcm_bulk_wrm_buffer *)pvBuffer;

		if (((ULONG)pBulkBuffer->Register & 0x0F000000) != 0x0F000000 ||
			((ULONG)pBulkBuffer->Register & 0x3)) {
			BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM Done On invalid Address : %x Access Denied.\n"", (int)pBulkBuffer->Register);
			kfree(pvBuffer);
			Status = -EINVAL;
			break;
		}

		uiTempVar = pBulkBuffer->Register & EEPROM_REJECT_MASK;
		if (!((Adapter->pstargetparams->m_u32Customize)&VSG_MODE) &&
			((uiTempVar == EEPROM_REJECT_REG_1) ||
				(uiTempVar == EEPROM_REJECT_REG_2) ||
				(uiTempVar == EEPROM_REJECT_REG_3) ||
				(uiTempVar == EEPROM_REJECT_REG_4)) &&
			(cmd == IOCTL_BCM_REGISTER_WRITE)) {

			kfree(pvBuffer);
			BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""EEPROM Access Denied, not in VSG Mode\n"");
			Status = -EFAULT;
			break;
		}

		if (pBulkBuffer->SwapEndian == FALSE)
			Status = wrmWithLock(Adapter, (UINT)pBulkBuffer->Register, (PCHAR)pBulkBuffer->Values, IoBuffer.InputLength - 2*sizeof(ULONG));
		else
			Status = wrmaltWithLock(Adapter, (UINT)pBulkBuffer->Register, (PUINT)pBulkBuffer->Values, IoBuffer.InputLength - 2*sizeof(ULONG));

		if (Status != STATUS_SUCCESS)
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM Failed\n"");

		kfree(pvBuffer);
		break;
	}

	case IOCTL_BCM_GET_NVM_SIZE:
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (Adapter->eNVMType == NVM_EEPROM || Adapter->eNVMType == NVM_FLASH) {
			if (copy_to_user(IoBuffer.OutputBuffer, &Adapter->uiNVMDSDSize, sizeof(UINT)))
				return -EFAULT;
		}

		Status = STATUS_SUCCESS;
		break;

	case IOCTL_BCM_CAL_INIT: {
		UINT uiSectorSize = 0 ;
		if (Adapter->eNVMType == NVM_FLASH) {
			if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
				return -EFAULT;

			if (copy_from_user(&uiSectorSize, IoBuffer.InputBuffer, sizeof(UINT)))
				return -EFAULT;

			if ((uiSectorSize < MIN_SECTOR_SIZE) || (uiSectorSize > MAX_SECTOR_SIZE)) {
				if (copy_to_user(IoBuffer.OutputBuffer, &Adapter->uiSectorSize,
							sizeof(UINT)))
					return -EFAULT;
			} else {
				if (IsFlash2x(Adapter)) {
					if (copy_to_user(IoBuffer.OutputBuffer,	&Adapter->uiSectorSize, sizeof(UINT)))
						return -EFAULT;
				} else {
					if ((TRUE == Adapter->bShutStatus) || (TRUE == Adapter->IdleMode)) {
						BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device is in Idle/Shutdown Mode\n"");
						return -EACCES;
					}

					Adapter->uiSectorSize = uiSectorSize;
					BcmUpdateSectorSize(Adapter, Adapter->uiSectorSize);
				}
			}
			Status = STATUS_SUCCESS;
		} else {
			Status = STATUS_FAILURE;
		}
	}
	break;

	case IOCTL_BCM_SET_DEBUG:
#ifdef DEBUG
	{
		struct bcm_user_debug_state sUserDebugState;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""In SET_DEBUG ioctl\n"");
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (copy_from_user(&sUserDebugState, IoBuffer.InputBuffer, sizeof(struct bcm_user_debug_state)))
			return -EFAULT;

		BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""IOCTL_BCM_SET_DEBUG: OnOff=%d Type = 0x%x "",
				sUserDebugState.OnOff, sUserDebugState.Type);
		/* sUserDebugState.Subtype <<= 1; */
		sUserDebugState.Subtype = 1 << sUserDebugState.Subtype;
		BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""actual Subtype=0x%x\n"", sUserDebugState.Subtype);

		/* Update new 'DebugState' in the Adapter */
		Adapter->stDebugState.type |= sUserDebugState.Type;
		/* Subtype: A bitmap of 32 bits for Subtype per Type.
		 * Valid indexes in 'subtype' array: 1,2,4,8
		 * corresponding to valid Type values. Hence we can use the 'Type' field
		 * as the index value, ignoring the array entries 0,3,5,6,7 !
		 */
		if (sUserDebugState.OnOff)
			Adapter->stDebugState.subtype[sUserDebugState.Type] |= sUserDebugState.Subtype;
		else
			Adapter->stDebugState.subtype[sUserDebugState.Type] &= ~sUserDebugState.Subtype;

		BCM_SHOW_DEBUG_BITMAP(Adapter);
	}
#endif
	break;

	case IOCTL_BCM_NVM_READ:
	case IOCTL_BCM_NVM_WRITE: {
		struct bcm_nvm_readwrite stNVMReadWrite;
		PUCHAR pReadData = NULL;
		ULONG ulDSDMagicNumInUsrBuff = 0;
		struct timeval tv0, tv1;
		memset(&tv0, 0, sizeof(struct timeval));
		memset(&tv1, 0, sizeof(struct timeval));
		if ((Adapter->eNVMType == NVM_FLASH) && (Adapter->uiFlashLayoutMajorVersion == 0)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""The Flash Control Section is Corrupted. Hence Rejection on NVM Read/Write\n"");
			return -EFAULT;
		}

		if (IsFlash2x(Adapter)) {
			if ((Adapter->eActiveDSD != DSD0) &&
				(Adapter->eActiveDSD != DSD1) &&
				(Adapter->eActiveDSD != DSD2)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""No DSD is active..hence NVM Command is blocked"");
				return STATUS_FAILURE;
			}
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (copy_from_user(&stNVMReadWrite,
					(IOCTL_BCM_NVM_READ == cmd) ? IoBuffer.OutputBuffer : IoBuffer.InputBuffer,
					sizeof(struct bcm_nvm_readwrite)))
			return -EFAULT;

		/*
		 * Deny the access if the offset crosses the cal area limit.
		 */
		if (stNVMReadWrite.uiNumBytes > Adapter->uiNVMDSDSize)
			return STATUS_FAILURE;

		if (stNVMReadWrite.uiOffset > Adapter->uiNVMDSDSize - stNVMReadWrite.uiNumBytes) {
			/* BCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,""Can't allow access beyond NVM Size: 0x%x 0x%x\n"", stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes); */
			return STATUS_FAILURE;
		}

		pReadData = memdup_user(stNVMReadWrite.pBuffer,
					stNVMReadWrite.uiNumBytes);
		if (IS_ERR(pReadData))
			return PTR_ERR(pReadData);

		do_gettimeofday(&tv0);
		if (IOCTL_BCM_NVM_READ == cmd) {
			down(&Adapter->NVMRdmWrmLock);

			if ((Adapter->IdleMode == TRUE) ||
				(Adapter->bShutStatus == TRUE) ||
				(Adapter->bPreparingForLowPowerMode == TRUE)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadData);
				return -EACCES;
			}

			Status = BeceemNVMRead(Adapter, (PUINT)pReadData, stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes);
			up(&Adapter->NVMRdmWrmLock);

			if (Status != STATUS_SUCCESS) {
				kfree(pReadData);
				return Status;
			}

			if (copy_to_user(stNVMReadWrite.pBuffer, pReadData, stNVMReadWrite.uiNumBytes)) {
				kfree(pReadData);
				return -EFAULT;
			}
		} else {
			down(&Adapter->NVMRdmWrmLock);

			if ((Adapter->IdleMode == TRUE) ||
				(Adapter->bShutStatus == TRUE) ||
				(Adapter->bPreparingForLowPowerMode == TRUE)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadData);
				return -EACCES;
			}

			Adapter->bHeaderChangeAllowed = TRUE;
			if (IsFlash2x(Adapter)) {
				/*
				 *			New Requirement:-
				 *			DSD section updation will be allowed in two case:-
				 *			1.  if DSD sig is present in DSD header means dongle is ok and updation is fruitfull
				 *			2.  if point 1 failes then user buff should have DSD sig. this point ensures that if dongle is
				 *			      corrupted then user space program first modify the DSD header with valid DSD sig so
				 *			      that this as well as further write may be worthwhile.
				 *
				 *			 This restriction has been put assuming that if DSD sig is corrupted, DSD
				 *			 data won't be considered valid.
				 */

				Status = BcmFlash2xCorruptSig(Adapter, Adapter->eActiveDSD);
				if (Status != STATUS_SUCCESS) {
					if (((stNVMReadWrite.uiOffset + stNVMReadWrite.uiNumBytes) != Adapter->uiNVMDSDSize) ||
						(stNVMReadWrite.uiNumBytes < SIGNATURE_SIZE)) {

						BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""DSD Sig is present neither in Flash nor User provided Input.."");
						up(&Adapter->NVMRdmWrmLock);
						kfree(pReadData);
						return Status;
					}

					ulDSDMagicNumInUsrBuff = ntohl(*(PUINT)(pReadData + stNVMReadWrite.uiNumBytes - SIGNATURE_SIZE));
					if (ulDSDMagicNumInUsrBuff != DSD_IMAGE_MAGIC_NUMBER) {
						BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""DSD Sig is present neither in Flash nor User provided Input.."");
						up(&Adapter->NVMRdmWrmLock);
						kfree(pReadData);
						return Status;
					}
				}
			}

			Status = BeceemNVMWrite(Adapter, (PUINT)pReadData, stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes, stNVMReadWrite.bVerify);
			if (IsFlash2x(Adapter))
				BcmFlash2xWriteSig(Adapter, Adapter->eActiveDSD);

			Adapter->bHeaderChangeAllowed = FALSE;

			up(&Adapter->NVMRdmWrmLock);

			if (Status != STATUS_SUCCESS) {
				kfree(pReadData);
				return Status;
			}
		}

		do_gettimeofday(&tv1);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "" timetaken by Write/read :%ld msec\n"", (tv1.tv_sec - tv0.tv_sec)*1000 + (tv1.tv_usec - tv0.tv_usec)/1000);

		kfree(pReadData);
		return STATUS_SUCCESS;
	}

	case IOCTL_BCM_FLASH2X_SECTION_READ: {
		struct bcm_flash2x_readwrite sFlash2xRead = {0};
		PUCHAR pReadBuff = NULL ;
		UINT NOB = 0;
		UINT BuffSize = 0;
		UINT ReadBytes = 0;
		UINT ReadOffset = 0;
		void __user *OutPutBuff;

		if (IsFlash2x(Adapter) != TRUE)	{
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_FLASH2X_SECTION_READ Called"");
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		/* Reading FLASH 2.x READ structure */
		if (copy_from_user(&sFlash2xRead, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_readwrite)))
			return -EFAULT;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.Section :%x"", sFlash2xRead.Section);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.offset :%x"", sFlash2xRead.offset);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.numOfBytes :%x"", sFlash2xRead.numOfBytes);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.bVerify :%x\n"", sFlash2xRead.bVerify);

		/* This was internal to driver for raw read. now it has ben exposed to user space app. */
		if (validateFlash2xReadWrite(Adapter, &sFlash2xRead) == FALSE)
			return STATUS_FAILURE;

		NOB = sFlash2xRead.numOfBytes;
		if (NOB > Adapter->uiSectorSize)
			BuffSize = Adapter->uiSectorSize;
		else
			BuffSize = NOB;

		ReadOffset = sFlash2xRead.offset ;
		OutPutBuff = IoBuffer.OutputBuffer;
		pReadBuff = (PCHAR)kzalloc(BuffSize , GFP_KERNEL);

		if (pReadBuff == NULL) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Memory allocation failed for Flash 2.x Read Structure"");
			return -ENOMEM;
		}
		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			kfree(pReadBuff);
			return -EACCES;
		}

		while (NOB) {
			if (NOB > Adapter->uiSectorSize)
				ReadBytes = Adapter->uiSectorSize;
			else
				ReadBytes = NOB;

			/* Reading the data from Flash 2.x */
			Status = BcmFlash2xBulkRead(Adapter, (PUINT)pReadBuff, sFlash2xRead.Section, ReadOffset, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Flash 2x read err with Status :%d"", Status);
				break;
			}

			BCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pReadBuff, ReadBytes);

			Status = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Copy to use failed with status :%d"", Status);
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadBuff);
				return -EFAULT;
			}
			NOB = NOB - ReadBytes;
			if (NOB) {
				ReadOffset = ReadOffset + ReadBytes;
				OutPutBuff = OutPutBuff + ReadBytes ;
			}
		}

		up(&Adapter->NVMRdmWrmLock);
		kfree(pReadBuff);
	}
	break;

	case IOCTL_BCM_FLASH2X_SECTION_WRITE: {
		struct bcm_flash2x_readwrite sFlash2xWrite = {0};
		PUCHAR pWriteBuff;
		void __user *InputAddr;
		UINT NOB = 0;
		UINT BuffSize = 0;
		UINT WriteOffset = 0;
		UINT WriteBytes = 0;

		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		/* First make this False so that we can enable the Sector Permission Check in BeceemFlashBulkWrite */
		Adapter->bAllDSDWriteAllow = FALSE;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_FLASH2X_SECTION_WRITE Called"");

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		/* Reading FLASH 2.x READ structure */
		if (copy_from_user(&sFlash2xWrite, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_readwrite)))
			return -EFAULT;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.Section :%x"", sFlash2xWrite.Section);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.offset :%d"", sFlash2xWrite.offset);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.numOfBytes :%x"", sFlash2xWrite.numOfBytes);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.bVerify :%x\n"", sFlash2xWrite.bVerify);

		if ((sFlash2xWrite.Section != VSA0) && (sFlash2xWrite.Section != VSA1) && (sFlash2xWrite.Section != VSA2)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Only VSA write is allowed"");
			return -EINVAL;
		}

		if (validateFlash2xReadWrite(Adapter, &sFlash2xWrite) == FALSE)
			return STATUS_FAILURE;

		InputAddr = sFlash2xWrite.pDataBuff;
		WriteOffset = sFlash2xWrite.offset;
		NOB = sFlash2xWrite.numOfBytes;

		if (NOB > Adapter->uiSectorSize)
			BuffSize = Adapter->uiSectorSize;
		else
			BuffSize = NOB ;

		pWriteBuff = kmalloc(BuffSize, GFP_KERNEL);

		if (pWriteBuff == NULL)
			return -ENOMEM;

		/* extracting the remainder of the given offset. */
		WriteBytes = Adapter->uiSectorSize;
		if (WriteOffset % Adapter->uiSectorSize)
			WriteBytes = Adapter->uiSectorSize - (WriteOffset % Adapter->uiSectorSize);

		if (NOB < WriteBytes)
			WriteBytes = NOB;

		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			kfree(pWriteBuff);
			return -EACCES;
		}

		BcmFlash2xCorruptSig(Adapter, sFlash2xWrite.Section);
		do {
			Status = copy_from_user(pWriteBuff, InputAddr, WriteBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy to user failed with status :%d"", Status);
				up(&Adapter->NVMRdmWrmLock);
				kfree(pWriteBuff);
				return -EFAULT;
			}
			BCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pWriteBuff, WriteBytes);

			/* Writing the data from Flash 2.x */
			Status = BcmFlash2xBulkWrite(Adapter, (PUINT)pWriteBuff, sFlash2xWrite.Section, WriteOffset, WriteBytes, sFlash2xWrite.bVerify);

			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash 2x read err with Status :%d"", Status);
				break;
			}

			NOB = NOB - WriteBytes;
			if (NOB) {
				WriteOffset = WriteOffset + WriteBytes;
				InputAddr = InputAddr + WriteBytes;
				if (NOB > Adapter->uiSectorSize)
					WriteBytes = Adapter->uiSectorSize;
				else
					WriteBytes = NOB;
			}
		} while (NOB > 0);

		BcmFlash2xWriteSig(Adapter, sFlash2xWrite.Section);
		up(&Adapter->NVMRdmWrmLock);
		kfree(pWriteBuff);
	}
	break;

	case IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP: {
		struct bcm_flash2x_bitmap *psFlash2xBitMap;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP Called"");

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength != sizeof(struct bcm_flash2x_bitmap))
			return -EINVAL;

		psFlash2xBitMap = kzalloc(sizeof(struct bcm_flash2x_bitmap), GFP_KERNEL);
		if (psFlash2xBitMap == NULL) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Memory is not available"");
			return -ENOMEM;
		}

		/* Reading the Flash Sectio Bit map */
		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			kfree(psFlash2xBitMap);
			return -EACCES;
		}

		BcmGetFlash2xSectionalBitMap(Adapter, psFlash2xBitMap);
		up(&Adapter->NVMRdmWrmLock);
		if (copy_to_user(IoBuffer.OutputBuffer, psFlash2xBitMap, sizeof(struct bcm_flash2x_bitmap))) {
			kfree(psFlash2xBitMap);
			return -EFAULT;
		}

		kfree(psFlash2xBitMap);
	}
	break;

	case IOCTL_BCM_SET_ACTIVE_SECTION: {
		enum bcm_flash2x_section_val eFlash2xSectionVal = 0;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SET_ACTIVE_SECTION Called"");

		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed"");
			return -EFAULT;
		}

		Status = copy_from_user(&eFlash2xSectionVal, IoBuffer.InputBuffer, sizeof(INT));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of flash section val failed"");
			return -EFAULT;
		}

		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			return -EACCES;
		}

		Status = BcmSetActiveSection(Adapter, eFlash2xSectionVal);
		if (Status)
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Failed to make it's priority Highest. Status %d"", Status);

		up(&Adapter->NVMRdmWrmLock);
	}
	break;

	case IOCTL_BCM_IDENTIFY_ACTIVE_SECTION: {
		/* Right Now we are taking care of only DSD */
		Adapter->bAllDSDWriteAllow = FALSE;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_IDENTIFY_ACTIVE_SECTION called"");
		Status = STATUS_SUCCESS;
	}
	break;

	case IOCTL_BCM_COPY_SECTION: {
		struct bcm_flash2x_copy_section sCopySectStrut = {0};
		Status = STATUS_SUCCESS;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_COPY_SECTION  Called"");

		Adapter->bAllDSDWriteAllow = FALSE;
		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed Status :%d"", Status);
			return -EFAULT;
		}

		Status = copy_from_user(&sCopySectStrut, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_copy_section));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of Copy_Section_Struct failed with Status :%d"", Status);
			return -EFAULT;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Source SEction :%x"", sCopySectStrut.SrcSection);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Destination SEction :%x"", sCopySectStrut.DstSection);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""offset :%x"", sCopySectStrut.offset);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""NOB :%x"", sCopySectStrut.numOfBytes);

		if (IsSectionExistInFlash(Adapter, sCopySectStrut.SrcSection) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Source Section<%x> does not exixt in Flash "", sCopySectStrut.SrcSection);
			return -EINVAL;
		}

		if (IsSectionExistInFlash(Adapter, sCopySectStrut.DstSection) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Destinatio Section<%x> does not exixt in Flash "", sCopySectStrut.DstSection);
			return -EINVAL;
		}

		if (sCopySectStrut.SrcSection == sCopySectStrut.DstSection) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Source and Destination section should be different"");
			return -EINVAL;
		}

		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			return -EACCES;
		}

		if (sCopySectStrut.SrcSection == ISO_IMAGE1 || sCopySectStrut.SrcSection == ISO_IMAGE2) {
			if (IsNonCDLessDevice(Adapter)) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device is Non-CDLess hence won't have ISO !!"");
				Status = -EINVAL;
			} else if (sCopySectStrut.numOfBytes == 0) {
				Status = BcmCopyISO(Adapter, sCopySectStrut);
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Partial Copy of ISO section is not Allowed.."");
				Status = STATUS_FAILURE;
			}
			up(&Adapter->NVMRdmWrmLock);
			return Status;
		}

		Status = BcmCopySection(Adapter, sCopySectStrut.SrcSection,
					sCopySectStrut.DstSection, sCopySectStrut.offset, sCopySectStrut.numOfBytes);
		up(&Adapter->NVMRdmWrmLock);
	}
	break;

	case IOCTL_BCM_GET_FLASH_CS_INFO: {
		Status = STATUS_SUCCESS;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "" IOCTL_BCM_GET_FLASH_CS_INFO Called"");

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed"");
			return -EFAULT;
		}

		if (Adapter->eNVMType != NVM_FLASH) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Connected device does not have flash"");
			Status = -EINVAL;
			break;
		}

		if (IsFlash2x(Adapter) == TRUE) {
			if (IoBuffer.OutputLength < sizeof(struct bcm_flash2x_cs_info))
				return -EINVAL;

			if (copy_to_user(IoBuffer.OutputBuffer, Adapter->psFlash2xCSInfo, sizeof(struct bcm_flash2x_cs_info)))
				return -EFAULT;
		} else {
			if (IoBuffer.OutputLength < sizeof(struct bcm_flash_cs_info))
				return -EINVAL;

			if (copy_to_user(IoBuffer.OutputBuffer, Adapter->psFlashCSInfo, sizeof(struct bcm_flash_cs_info)))
				return -EFAULT;
		}
	}
	break;

	case IOCTL_BCM_SELECT_DSD: {
		UINT SectOfset = 0;
		enum bcm_flash2x_section_val eFlash2xSectionVal;
		eFlash2xSectionVal = NO_SECTION_VAL;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SELECT_DSD Called"");

		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed"");
			return -EFAULT;
		}
		Status = copy_from_user(&eFlash2xSectionVal, IoBuffer.InputBuffer, sizeof(INT));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of flash section val failed"");
			return -EFAULT;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Read Section :%d"", eFlash2xSectionVal);
		if ((eFlash2xSectionVal != DSD0) &&
			(eFlash2xSectionVal != DSD1) &&
			(eFlash2xSectionVal != DSD2)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Passed section<%x> is not DSD section"", eFlash2xSectionVal);
			return STATUS_FAILURE;
		}

		SectOfset = BcmGetSectionValStartOffset(Adapter, eFlash2xSectionVal);
		if (SectOfset == INVALID_OFFSET) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Provided Section val <%d> does not exixt in Flash 2.x"", eFlash2xSectionVal);
			return -EINVAL;
		}

		Adapter->bAllDSDWriteAllow = TRUE;
		Adapter->ulFlashCalStart = SectOfset;
		Adapter->eActiveDSD = eFlash2xSectionVal;
	}
	Status = STATUS_SUCCESS;
	break;

	case IOCTL_BCM_NVM_RAW_READ: {
		struct bcm_nvm_readwrite stNVMRead;
		INT NOB ;
		INT BuffSize ;
		INT ReadOffset = 0;
		UINT ReadBytes = 0 ;
		PUCHAR pReadBuff;
		void __user *OutPutBuff;

		if (Adapter->eNVMType != NVM_FLASH) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""NVM TYPE is not Flash"");
			return -EINVAL;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""copy_from_user 1 failed\n"");
			return -EFAULT;
		}

		if (copy_from_user(&stNVMRead, IoBuffer.OutputBuffer, sizeof(struct bcm_nvm_readwrite)))
			return -EFAULT;

		NOB = stNVMRead.uiNumBytes;
		/* In Raw-Read max Buff size : 64MB */

		if (NOB > DEFAULT_BUFF_SIZE)
			BuffSize = DEFAULT_BUFF_SIZE;
		else
			BuffSize = NOB;

		ReadOffset = stNVMRead.uiOffset;
		OutPutBuff = stNVMRead.pBuffer;

		pReadBuff = kzalloc(BuffSize , GFP_KERNEL);
		if (pReadBuff == NULL) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Memory allocation failed for Flash 2.x Read Structure"");
			Status = -ENOMEM;
			break;
		}
		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			kfree(pReadBuff);
			up(&Adapter->NVMRdmWrmLock);
			return -EACCES;
		}

		Adapter->bFlashRawRead = TRUE;

		while (NOB) {
			if (NOB > DEFAULT_BUFF_SIZE)
				ReadBytes = DEFAULT_BUFF_SIZE;
			else
				ReadBytes = NOB;

			/* Reading the data from Flash 2.x */
			Status = BeceemNVMRead(Adapter, (PUINT)pReadBuff, ReadOffset, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash 2x read err with Status :%d"", Status);
				break;
			}

			BCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pReadBuff, ReadBytes);

			Status = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy to use failed with status :%d"", Status);
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadBuff);
				return -EFAULT;
			}
			NOB = NOB - ReadBytes;
			if (NOB) {
				ReadOffset = ReadOffset + ReadBytes;
				OutPutBuff = OutPutBuff + ReadBytes;
			}
		}
		Adapter->bFlashRawRead = FALSE;
		up(&Adapter->NVMRdmWrmLock);
		kfree(pReadBuff);
		break;
	}

	case IOCTL_BCM_CNTRLMSG_MASK: {
		ULONG RxCntrlMsgBitMask = 0;

		/* Copy Ioctl Buffer structure */
		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""copy of Ioctl buffer is failed from user space"");
			return -EFAULT;
		}

		if (IoBuffer.InputLength != sizeof(unsigned long)) {
			Status = -EINVAL;
			break;
		}

		Status = copy_from_user(&RxCntrlMsgBitMask, IoBuffer.InputBuffer, IoBuffer.InputLength);
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""copy of control bit mask failed from user space"");
			return -EFAULT;
		}
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\n Got user defined cntrl msg bit mask :%lx"", RxCntrlMsgBitMask);
		pTarang->RxCntrlMsgBitMask = RxCntrlMsgBitMask;
	}
	break;

	case IOCTL_BCM_GET_DEVICE_DRIVER_INFO: {
		struct bcm_driver_info DevInfo;
 
 		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Called IOCTL_BCM_GET_DEVICE_DRIVER_INFO\n"");
 
		memset(&DevInfo, 0, sizeof(DevInfo));
 		DevInfo.MaxRDMBufferSize = BUFFER_4K;
 		DevInfo.u32DSDStartOffset = EEPROM_CALPARAM_START;
 		DevInfo.u32RxAlignmentCorrection = 0;
		DevInfo.u32NVMType = Adapter->eNVMType;
		DevInfo.u32InterfaceType = BCM_USB;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength < sizeof(DevInfo))
			return -EINVAL;

		if (copy_to_user(IoBuffer.OutputBuffer, &DevInfo, sizeof(DevInfo)))
			return -EFAULT;
	}
	break;

	case IOCTL_BCM_TIME_SINCE_NET_ENTRY: {
		struct bcm_time_elapsed stTimeElapsedSinceNetEntry = {0};

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_TIME_SINCE_NET_ENTRY called"");

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength < sizeof(struct bcm_time_elapsed))
			return -EINVAL;

		stTimeElapsedSinceNetEntry.ul64TimeElapsedSinceNetEntry = get_seconds() - Adapter->liTimeSinceLastNetEntry;

		if (copy_to_user(IoBuffer.OutputBuffer, &stTimeElapsedSinceNetEntry, sizeof(struct bcm_time_elapsed)))
			return -EFAULT;
	}
	break;

	case IOCTL_CLOSE_NOTIFICATION:
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_CLOSE_NOTIFICATION"");
		break;

	default:
		pr_info(DRV_NAME "": unknown ioctl cmd=%#x\n"", cmd);
		Status = STATUS_FAILURE;
		break;
	}
	return Status;
}
","static long bcm_char_ioctl(struct file *filp, UINT cmd, ULONG arg)
{
	struct bcm_tarang_data *pTarang = filp->private_data;
	void __user *argp = (void __user *)arg;
	struct bcm_mini_adapter *Adapter = pTarang->Adapter;
	INT Status = STATUS_FAILURE;
	int timeout = 0;
	struct bcm_ioctl_buffer IoBuffer;
	int bytes;

	BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Parameters Passed to control IOCTL cmd=0x%X arg=0x%lX"", cmd, arg);

	if (_IOC_TYPE(cmd) != BCM_IOCTL)
		return -EFAULT;
	if (_IOC_DIR(cmd) & _IOC_READ)
		Status = !access_ok(VERIFY_WRITE, argp, _IOC_SIZE(cmd));
	else if (_IOC_DIR(cmd) & _IOC_WRITE)
		Status = !access_ok(VERIFY_READ, argp, _IOC_SIZE(cmd));
	else if (_IOC_NONE == (_IOC_DIR(cmd) & _IOC_NONE))
		Status = STATUS_SUCCESS;

	if (Status)
		return -EFAULT;

	if (Adapter->device_removed)
		return -EFAULT;

	if (FALSE == Adapter->fw_download_done) {
		switch (cmd) {
		case IOCTL_MAC_ADDR_REQ:
		case IOCTL_LINK_REQ:
		case IOCTL_CM_REQUEST:
		case IOCTL_SS_INFO_REQ:
		case IOCTL_SEND_CONTROL_MESSAGE:
		case IOCTL_IDLE_REQ:
		case IOCTL_BCM_GPIO_SET_REQUEST:
		case IOCTL_BCM_GPIO_STATUS_REQUEST:
			return -EACCES;
		default:
			break;
		}
	}

	Status = vendorextnIoctl(Adapter, cmd, arg);
	if (Status != CONTINUE_COMMON_PATH)
		return Status;

	switch (cmd) {
	/* Rdms for Swin Idle... */
	case IOCTL_BCM_REGISTER_READ_PRIVATE: {
		struct bcm_rdm_buffer sRdmBuffer = {0};
		PCHAR temp_buff;
		UINT Bufflen;
		u16 temp_value;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sRdmBuffer))
			return -EINVAL;

		if (copy_from_user(&sRdmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if (IoBuffer.OutputLength > USHRT_MAX ||
			IoBuffer.OutputLength == 0) {
			return -EINVAL;
		}

		Bufflen = IoBuffer.OutputLength;
		temp_value = 4 - (Bufflen % 4);
		Bufflen += temp_value % 4;

		temp_buff = kmalloc(Bufflen, GFP_KERNEL);
		if (!temp_buff)
			return -ENOMEM;

		bytes = rdmalt(Adapter, (UINT)sRdmBuffer.Register,
				(PUINT)temp_buff, Bufflen);
		if (bytes > 0) {
			Status = STATUS_SUCCESS;
			if (copy_to_user(IoBuffer.OutputBuffer, temp_buff, bytes)) {
				kfree(temp_buff);
				return -EFAULT;
			}
		} else {
			Status = bytes;
		}

		kfree(temp_buff);
		break;
	}

	case IOCTL_BCM_REGISTER_WRITE_PRIVATE: {
		struct bcm_wrm_buffer sWrmBuffer = {0};
		UINT uiTempVar = 0;
		/* Copy Ioctl Buffer structure */

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sWrmBuffer))
			return -EINVAL;

		/* Get WrmBuffer structure */
		if (copy_from_user(&sWrmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		uiTempVar = sWrmBuffer.Register & EEPROM_REJECT_MASK;
		if (!((Adapter->pstargetparams->m_u32Customize) & VSG_MODE) &&
			((uiTempVar == EEPROM_REJECT_REG_1) ||
				(uiTempVar == EEPROM_REJECT_REG_2) ||
				(uiTempVar == EEPROM_REJECT_REG_3) ||
				(uiTempVar == EEPROM_REJECT_REG_4))) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""EEPROM Access Denied, not in VSG Mode\n"");
			return -EFAULT;
		}

		Status = wrmalt(Adapter, (UINT)sWrmBuffer.Register,
				(PUINT)sWrmBuffer.Data, sizeof(ULONG));

		if (Status == STATUS_SUCCESS) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""WRM Done\n"");
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""WRM Failed\n"");
			Status = -EFAULT;
		}
		break;
	}

	case IOCTL_BCM_REGISTER_READ:
	case IOCTL_BCM_EEPROM_REGISTER_READ: {
		struct bcm_rdm_buffer sRdmBuffer = {0};
		PCHAR temp_buff = NULL;
		UINT uiTempVar = 0;
		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device in Idle Mode, Blocking Rdms\n"");
			return -EACCES;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sRdmBuffer))
			return -EINVAL;

		if (copy_from_user(&sRdmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if (IoBuffer.OutputLength > USHRT_MAX ||
			IoBuffer.OutputLength == 0) {
			return -EINVAL;
		}

		temp_buff = kmalloc(IoBuffer.OutputLength, GFP_KERNEL);
		if (!temp_buff)
			return STATUS_FAILURE;

		if ((((ULONG)sRdmBuffer.Register & 0x0F000000) != 0x0F000000) ||
			((ULONG)sRdmBuffer.Register & 0x3)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""RDM Done On invalid Address : %x Access Denied.\n"",
					(int)sRdmBuffer.Register);

			kfree(temp_buff);
			return -EINVAL;
		}

		uiTempVar = sRdmBuffer.Register & EEPROM_REJECT_MASK;
		bytes = rdmaltWithLock(Adapter, (UINT)sRdmBuffer.Register, (PUINT)temp_buff, IoBuffer.OutputLength);

		if (bytes > 0) {
			Status = STATUS_SUCCESS;
			if (copy_to_user(IoBuffer.OutputBuffer, temp_buff, bytes)) {
				kfree(temp_buff);
				return -EFAULT;
			}
		} else {
			Status = bytes;
		}

		kfree(temp_buff);
		break;
	}
	case IOCTL_BCM_REGISTER_WRITE:
	case IOCTL_BCM_EEPROM_REGISTER_WRITE: {
		struct bcm_wrm_buffer sWrmBuffer = {0};
		UINT uiTempVar = 0;

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device in Idle Mode, Blocking Wrms\n"");
			return -EACCES;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sWrmBuffer))
			return -EINVAL;

		/* Get WrmBuffer structure */
		if (copy_from_user(&sWrmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if ((((ULONG)sWrmBuffer.Register & 0x0F000000) != 0x0F000000) ||
			((ULONG)sWrmBuffer.Register & 0x3)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM Done On invalid Address : %x Access Denied.\n"", (int)sWrmBuffer.Register);
			return -EINVAL;
		}

		uiTempVar = sWrmBuffer.Register & EEPROM_REJECT_MASK;
		if (!((Adapter->pstargetparams->m_u32Customize) & VSG_MODE) &&
				((uiTempVar == EEPROM_REJECT_REG_1) ||
				(uiTempVar == EEPROM_REJECT_REG_2) ||
				(uiTempVar == EEPROM_REJECT_REG_3) ||
				(uiTempVar == EEPROM_REJECT_REG_4)) &&
				(cmd == IOCTL_BCM_REGISTER_WRITE)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""EEPROM Access Denied, not in VSG Mode\n"");
				return -EFAULT;
		}

		Status = wrmaltWithLock(Adapter, (UINT)sWrmBuffer.Register,
					(PUINT)sWrmBuffer.Data, sWrmBuffer.Length);

		if (Status == STATUS_SUCCESS) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL, ""WRM Done\n"");
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""WRM Failed\n"");
			Status = -EFAULT;
		}
		break;
	}
	case IOCTL_BCM_GPIO_SET_REQUEST: {
		UCHAR ucResetValue[4];
		UINT value = 0;
		UINT uiBit = 0;
		UINT uiOperation = 0;
		struct bcm_gpio_info gpio_info = {0};

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""GPIO Can't be set/clear in Low power Mode"");
			return -EACCES;
		}

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_info))
			return -EINVAL;

		if (copy_from_user(&gpio_info, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		uiBit  = gpio_info.uiGpioNumber;
		uiOperation = gpio_info.uiGpioValue;
		value = (1<<uiBit);

		if (IsReqGpioIsLedInNVM(Adapter, value) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Sorry, Requested GPIO<0x%X> is not correspond to LED !!!"", value);
			Status = -EINVAL;
			break;
		}

		/* Set - setting 1 */
		if (uiOperation) {
			/* Set the gpio output register */
			Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_SET_REG, (PUINT)(&value), sizeof(UINT));

			if (Status == STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Set the GPIO bit\n"");
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Failed to set the %dth GPIO\n"", uiBit);
				break;
			}
		} else {
			/* Set the gpio output register */
			Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_CLR_REG, (PUINT)(&value), sizeof(UINT));

			if (Status == STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Set the GPIO bit\n"");
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Failed to clear the %dth GPIO\n"", uiBit);
				break;
			}
		}

		bytes = rdmaltWithLock(Adapter, (UINT)GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));
		if (bytes < 0) {
			Status = bytes;
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""GPIO_MODE_REGISTER read failed"");
			break;
		} else {
			Status = STATUS_SUCCESS;
		}

		/* Set the gpio mode register to output */
		*(UINT *)ucResetValue |= (1<<uiBit);
		Status = wrmaltWithLock(Adapter, GPIO_MODE_REGISTER,
					(PUINT)ucResetValue, sizeof(UINT));

		if (Status == STATUS_SUCCESS) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Set the GPIO to output Mode\n"");
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Failed to put GPIO in Output Mode\n"");
			break;
		}
	}
	break;

	case BCM_LED_THREAD_STATE_CHANGE_REQ: {
		struct bcm_user_thread_req threadReq = {0};
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""User made LED thread InActive"");

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""GPIO Can't be set/clear in Low power Mode"");
			Status = -EACCES;
			break;
		}

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(threadReq))
			return -EINVAL;

		if (copy_from_user(&threadReq, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		/* if LED thread is running(Actively or Inactively) set it state to make inactive */
		if (Adapter->LEDInfo.led_thread_running) {
			if (threadReq.ThreadState == LED_THREAD_ACTIVATION_REQ) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Activating thread req"");
				Adapter->DriverState = LED_THREAD_ACTIVE;
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""DeActivating Thread req....."");
				Adapter->DriverState = LED_THREAD_INACTIVE;
			}

			/* signal thread. */
			wake_up(&Adapter->LEDInfo.notify_led_event);
		}
	}
	break;

	case IOCTL_BCM_GPIO_STATUS_REQUEST: {
		ULONG uiBit = 0;
		UCHAR ucRead[4];
		struct bcm_gpio_info gpio_info = {0};

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE))
			return -EACCES;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_info))
			return -EINVAL;

		if (copy_from_user(&gpio_info, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		uiBit = gpio_info.uiGpioNumber;

		/* Set the gpio output register */
		bytes = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER,
					(PUINT)ucRead, sizeof(UINT));

		if (bytes < 0) {
			Status = bytes;
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""RDM Failed\n"");
			return Status;
		} else {
			Status = STATUS_SUCCESS;
		}
	}
	break;

	case IOCTL_BCM_GPIO_MULTI_REQUEST: {
		UCHAR ucResetValue[4];
		struct bcm_gpio_multi_info gpio_multi_info[MAX_IDX];
		struct bcm_gpio_multi_info *pgpio_multi_info = (struct bcm_gpio_multi_info *)gpio_multi_info;

		memset(pgpio_multi_info, 0, MAX_IDX * sizeof(struct bcm_gpio_multi_info));

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE))
			return -EINVAL;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_multi_info))
			return -EINVAL;

		if (copy_from_user(&gpio_multi_info, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if (IsReqGpioIsLedInNVM(Adapter, pgpio_multi_info[WIMAX_IDX].uiGPIOMask) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!"",
					pgpio_multi_info[WIMAX_IDX].uiGPIOMask, Adapter->gpioBitMap);
			Status = -EINVAL;
			break;
		}

		/* Set the gpio output register */
		if ((pgpio_multi_info[WIMAX_IDX].uiGPIOMask) &
			(pgpio_multi_info[WIMAX_IDX].uiGPIOCommand)) {
			/* Set 1's in GPIO OUTPUT REGISTER */
			*(UINT *)ucResetValue =  pgpio_multi_info[WIMAX_IDX].uiGPIOMask &
				pgpio_multi_info[WIMAX_IDX].uiGPIOCommand &
				pgpio_multi_info[WIMAX_IDX].uiGPIOValue;

			if (*(UINT *) ucResetValue)
				Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_SET_REG,
							(PUINT)ucResetValue, sizeof(ULONG));

			if (Status != STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM to BCM_GPIO_OUTPUT_SET_REG Failed."");
				return Status;
			}

			/* Clear to 0's in GPIO OUTPUT REGISTER */
			*(UINT *)ucResetValue = (pgpio_multi_info[WIMAX_IDX].uiGPIOMask &
						pgpio_multi_info[WIMAX_IDX].uiGPIOCommand &
						(~(pgpio_multi_info[WIMAX_IDX].uiGPIOValue)));

			if (*(UINT *) ucResetValue)
				Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_CLR_REG, (PUINT)ucResetValue, sizeof(ULONG));

			if (Status != STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM to BCM_GPIO_OUTPUT_CLR_REG Failed."");
				return Status;
			}
		}

		if (pgpio_multi_info[WIMAX_IDX].uiGPIOMask) {
			bytes = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));

			if (bytes < 0) {
				Status = bytes;
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""RDM to GPIO_PIN_STATE_REGISTER Failed."");
				return Status;
			} else {
				Status = STATUS_SUCCESS;
			}

			pgpio_multi_info[WIMAX_IDX].uiGPIOValue = (*(UINT *)ucResetValue &
								pgpio_multi_info[WIMAX_IDX].uiGPIOMask);
		}

		Status = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_info, IoBuffer.OutputLength);
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Failed while copying Content to IOBufer for user space err:%d"", Status);
			return -EFAULT;
		}
	}
	break;

	case IOCTL_BCM_GPIO_MODE_REQUEST: {
		UCHAR ucResetValue[4];
		struct bcm_gpio_multi_mode gpio_multi_mode[MAX_IDX];
		struct bcm_gpio_multi_mode *pgpio_multi_mode = (struct bcm_gpio_multi_mode *)gpio_multi_mode;

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE))
			return -EINVAL;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_multi_mode))
			return -EINVAL;

		if (copy_from_user(&gpio_multi_mode, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		bytes = rdmaltWithLock(Adapter, (UINT)GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));

		if (bytes < 0) {
			Status = bytes;
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Read of GPIO_MODE_REGISTER failed"");
			return Status;
		} else {
			Status = STATUS_SUCCESS;
		}

		/* Validating the request */
		if (IsReqGpioIsLedInNVM(Adapter, pgpio_multi_mode[WIMAX_IDX].uiGPIOMask) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!"",
					pgpio_multi_mode[WIMAX_IDX].uiGPIOMask, Adapter->gpioBitMap);
			Status = -EINVAL;
			break;
		}

		if (pgpio_multi_mode[WIMAX_IDX].uiGPIOMask) {
			/* write all OUT's (1's) */
			*(UINT *) ucResetValue |= (pgpio_multi_mode[WIMAX_IDX].uiGPIOMode &
						pgpio_multi_mode[WIMAX_IDX].uiGPIOMask);

			/* write all IN's (0's) */
			*(UINT *) ucResetValue &= ~((~pgpio_multi_mode[WIMAX_IDX].uiGPIOMode) &
						pgpio_multi_mode[WIMAX_IDX].uiGPIOMask);

			/* Currently implemented return the modes of all GPIO's
			 * else needs to bit AND with  mask
			 */
			pgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT *)ucResetValue;

			Status = wrmaltWithLock(Adapter, GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(ULONG));
			if (Status == STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
						""WRM to GPIO_MODE_REGISTER Done"");
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
						""WRM to GPIO_MODE_REGISTER Failed"");
				Status = -EFAULT;
				break;
			}
		} else {
/* if uiGPIOMask is 0 then return mode register configuration */
			pgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT *)ucResetValue;
		}

		Status = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_mode, IoBuffer.OutputLength);
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Failed while copying Content to IOBufer for user space err:%d"", Status);
			return -EFAULT;
		}
	}
	break;

	case IOCTL_MAC_ADDR_REQ:
	case IOCTL_LINK_REQ:
	case IOCTL_CM_REQUEST:
	case IOCTL_SS_INFO_REQ:
	case IOCTL_SEND_CONTROL_MESSAGE:
	case IOCTL_IDLE_REQ: {
		PVOID pvBuffer = NULL;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength < sizeof(struct bcm_link_request))
			return -EINVAL;

		if (IoBuffer.InputLength > MAX_CNTL_PKT_SIZE)
			return -EINVAL;

		pvBuffer = memdup_user(IoBuffer.InputBuffer,
				       IoBuffer.InputLength);
		if (IS_ERR(pvBuffer))
			return PTR_ERR(pvBuffer);

		down(&Adapter->LowPowerModeSync);
		Status = wait_event_interruptible_timeout(Adapter->lowpower_mode_wait_queue,
							!Adapter->bPreparingForLowPowerMode,
							(1 * HZ));
		if (Status == -ERESTARTSYS)
			goto cntrlEnd;

		if (Adapter->bPreparingForLowPowerMode) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""Preparing Idle Mode is still True - Hence Rejecting control message\n"");
			Status = STATUS_FAILURE;
			goto cntrlEnd;
		}
		Status = CopyBufferToControlPacket(Adapter, (PVOID)pvBuffer);

cntrlEnd:
		up(&Adapter->LowPowerModeSync);
		kfree(pvBuffer);
		break;
	}

	case IOCTL_BCM_BUFFER_DOWNLOAD_START: {
		if (down_trylock(&Adapter->NVMRdmWrmLock)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\n"");
			return -EACCES;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
				""Starting the firmware download PID =0x%x!!!!\n"", current->pid);

		if (down_trylock(&Adapter->fw_download_sema))
			return -EBUSY;

		Adapter->bBinDownloaded = FALSE;
		Adapter->fw_download_process_pid = current->pid;
		Adapter->bCfgDownloaded = FALSE;
		Adapter->fw_download_done = FALSE;
		netif_carrier_off(Adapter->dev);
		netif_stop_queue(Adapter->dev);
		Status = reset_card_proc(Adapter);
		if (Status) {
			pr_err(PFX ""%s: reset_card_proc Failed!\n"", Adapter->dev->name);
			up(&Adapter->fw_download_sema);
			up(&Adapter->NVMRdmWrmLock);
			return Status;
		}
		mdelay(10);

		up(&Adapter->NVMRdmWrmLock);
		return Status;
	}

	case IOCTL_BCM_BUFFER_DOWNLOAD: {
		struct bcm_firmware_info *psFwInfo = NULL;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Starting the firmware download PID =0x%x!!!!\n"", current->pid);

		if (!down_trylock(&Adapter->fw_download_sema)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Invalid way to download buffer. Use Start and then call this!!!\n"");
			up(&Adapter->fw_download_sema);
			Status = -EINVAL;
			return Status;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {
			up(&Adapter->fw_download_sema);
			return -EFAULT;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
				""Length for FW DLD is : %lx\n"", IoBuffer.InputLength);

		if (IoBuffer.InputLength > sizeof(struct bcm_firmware_info)) {
			up(&Adapter->fw_download_sema);
			return -EINVAL;
		}

		psFwInfo = kmalloc(sizeof(*psFwInfo), GFP_KERNEL);
		if (!psFwInfo) {
			up(&Adapter->fw_download_sema);
			return -ENOMEM;
		}

		if (copy_from_user(psFwInfo, IoBuffer.InputBuffer, IoBuffer.InputLength)) {
			up(&Adapter->fw_download_sema);
			kfree(psFwInfo);
			return -EFAULT;
		}

		if (!psFwInfo->pvMappedFirmwareAddress ||
			(psFwInfo->u32FirmwareLength == 0)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Something else is wrong %lu\n"",
					psFwInfo->u32FirmwareLength);
			up(&Adapter->fw_download_sema);
			kfree(psFwInfo);
			Status = -EINVAL;
			return Status;
		}

		Status = bcm_ioctl_fw_download(Adapter, psFwInfo);

		if (Status != STATUS_SUCCESS) {
			if (psFwInfo->u32StartingAddress == CONFIG_BEGIN_ADDR)
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""IOCTL: Configuration File Upload Failed\n"");
			else
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,	""IOCTL: Firmware File Upload Failed\n"");

			/* up(&Adapter->fw_download_sema); */

			if (Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY) {
				Adapter->DriverState = DRIVER_INIT;
				Adapter->LEDInfo.bLedInitDone = FALSE;
				wake_up(&Adapter->LEDInfo.notify_led_event);
			}
		}

		if (Status != STATUS_SUCCESS)
			up(&Adapter->fw_download_sema);

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL, ""IOCTL: Firmware File Uploaded\n"");
		kfree(psFwInfo);
		return Status;
	}

	case IOCTL_BCM_BUFFER_DOWNLOAD_STOP: {
		if (!down_trylock(&Adapter->fw_download_sema)) {
			up(&Adapter->fw_download_sema);
			return -EINVAL;
		}

		if (down_trylock(&Adapter->NVMRdmWrmLock)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""FW download blocked as EEPROM Read/Write is in progress\n"");
			up(&Adapter->fw_download_sema);
			return -EACCES;
		}

		Adapter->bBinDownloaded = TRUE;
		Adapter->bCfgDownloaded = TRUE;
		atomic_set(&Adapter->CurrNumFreeTxDesc, 0);
		Adapter->CurrNumRecvDescs = 0;
		Adapter->downloadDDR = 0;

		/* setting the Mips to Run */
		Status = run_card_proc(Adapter);

		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Firm Download Failed\n"");
			up(&Adapter->fw_download_sema);
			up(&Adapter->NVMRdmWrmLock);
			return Status;
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG,
					DBG_LVL_ALL, ""Firm Download Over...\n"");
		}

		mdelay(10);

		/* Wait for MailBox Interrupt */
		if (StartInterruptUrb((struct bcm_interface_adapter *)Adapter->pvInterfaceAdapter))
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Unable to send interrupt...\n"");

		timeout = 5*HZ;
		Adapter->waiting_to_fw_download_done = FALSE;
		wait_event_timeout(Adapter->ioctl_fw_dnld_wait_queue,
				Adapter->waiting_to_fw_download_done, timeout);
		Adapter->fw_download_process_pid = INVALID_PID;
		Adapter->fw_download_done = TRUE;
		atomic_set(&Adapter->CurrNumFreeTxDesc, 0);
		Adapter->CurrNumRecvDescs = 0;
		Adapter->PrevNumRecvDescs = 0;
		atomic_set(&Adapter->cntrlpktCnt, 0);
		Adapter->LinkUpStatus = 0;
		Adapter->LinkStatus = 0;

		if (Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY) {
			Adapter->DriverState = FW_DOWNLOAD_DONE;
			wake_up(&Adapter->LEDInfo.notify_led_event);
		}

		if (!timeout)
			Status = -ENODEV;

		up(&Adapter->fw_download_sema);
		up(&Adapter->NVMRdmWrmLock);
		return Status;
	}

	case IOCTL_BE_BUCKET_SIZE:
		Status = 0;
		if (get_user(Adapter->BEBucketSize, (unsigned long __user *)arg))
			Status = -EFAULT;
		break;

	case IOCTL_RTPS_BUCKET_SIZE:
		Status = 0;
		if (get_user(Adapter->rtPSBucketSize, (unsigned long __user *)arg))
			Status = -EFAULT;
		break;

	case IOCTL_CHIP_RESET: {
		INT NVMAccess = down_trylock(&Adapter->NVMRdmWrmLock);
		if (NVMAccess) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "" IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\n"");
			return -EACCES;
		}

		down(&Adapter->RxAppControlQueuelock);
		Status = reset_card_proc(Adapter);
		flushAllAppQ();
		up(&Adapter->RxAppControlQueuelock);
		up(&Adapter->NVMRdmWrmLock);
		ResetCounters(Adapter);
		break;
	}

	case IOCTL_QOS_THRESHOLD: {
		USHORT uiLoopIndex;

		Status = 0;
		for (uiLoopIndex = 0; uiLoopIndex < NO_OF_QUEUES; uiLoopIndex++) {
			if (get_user(Adapter->PackInfo[uiLoopIndex].uiThreshold,
					(unsigned long __user *)arg)) {
				Status = -EFAULT;
				break;
			}
		}
		break;
	}

	case IOCTL_DUMP_PACKET_INFO:
		DumpPackInfo(Adapter);
		DumpPhsRules(&Adapter->stBCMPhsContext);
		Status = STATUS_SUCCESS;
		break;

	case IOCTL_GET_PACK_INFO:
		if (copy_to_user(argp, &Adapter->PackInfo, sizeof(struct bcm_packet_info)*NO_OF_QUEUES))
			return -EFAULT;
		Status = STATUS_SUCCESS;
		break;

	case IOCTL_BCM_SWITCH_TRANSFER_MODE: {
		UINT uiData = 0;
		if (copy_from_user(&uiData, argp, sizeof(UINT)))
			return -EFAULT;

		if (uiData) {
			/* Allow All Packets */
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SWITCH_TRANSFER_MODE: ETH_PACKET_TUNNELING_MODE\n"");
				Adapter->TransferMode = ETH_PACKET_TUNNELING_MODE;
		} else {
			/* Allow IP only Packets */
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SWITCH_TRANSFER_MODE: IP_PACKET_ONLY_MODE\n"");
			Adapter->TransferMode = IP_PACKET_ONLY_MODE;
		}
		Status = STATUS_SUCCESS;
		break;
	}

	case IOCTL_BCM_GET_DRIVER_VERSION: {
		ulong len;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		len = min_t(ulong, IoBuffer.OutputLength, strlen(DRV_VERSION) + 1);

		if (copy_to_user(IoBuffer.OutputBuffer, DRV_VERSION, len))
			return -EFAULT;
		Status = STATUS_SUCCESS;
		break;
	}

	case IOCTL_BCM_GET_CURRENT_STATUS: {
		struct bcm_link_state link_state;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""copy_from_user failed..\n"");
			return -EFAULT;
		}

		if (IoBuffer.OutputLength != sizeof(link_state)) {
			Status = -EINVAL;
			break;
		}

		memset(&link_state, 0, sizeof(link_state));
		link_state.bIdleMode = Adapter->IdleMode;
		link_state.bShutdownMode = Adapter->bShutStatus;
		link_state.ucLinkStatus = Adapter->LinkStatus;

		if (copy_to_user(IoBuffer.OutputBuffer, &link_state, min_t(size_t, sizeof(link_state), IoBuffer.OutputLength))) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy_to_user Failed..\n"");
			return -EFAULT;
		}
		Status = STATUS_SUCCESS;
		break;
	}

	case IOCTL_BCM_SET_MAC_TRACING: {
		UINT  tracing_flag;

		/* copy ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (copy_from_user(&tracing_flag, IoBuffer.InputBuffer, sizeof(UINT)))
			return -EFAULT;

		if (tracing_flag)
			Adapter->pTarangs->MacTracingEnabled = TRUE;
		else
			Adapter->pTarangs->MacTracingEnabled = FALSE;
		break;
	}

	case IOCTL_BCM_GET_DSX_INDICATION: {
		ULONG ulSFId = 0;
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength < sizeof(struct bcm_add_indication_alt)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Mismatch req: %lx needed is =0x%zx!!!"",
					IoBuffer.OutputLength, sizeof(struct bcm_add_indication_alt));
			return -EINVAL;
		}

		if (copy_from_user(&ulSFId, IoBuffer.InputBuffer, sizeof(ulSFId)))
			return -EFAULT;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Get DSX Data SF ID is =%lx\n"", ulSFId);
		get_dsx_sf_data_to_application(Adapter, ulSFId, IoBuffer.OutputBuffer);
		Status = STATUS_SUCCESS;
	}
	break;

	case IOCTL_BCM_GET_HOST_MIBS: {
		PVOID temp_buff;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength != sizeof(struct bcm_host_stats_mibs)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Length Check failed %lu %zd\n"",
					IoBuffer.OutputLength, sizeof(struct bcm_host_stats_mibs));
			return -EINVAL;
		}

		/* FIXME: HOST_STATS are too big for kmalloc (122048)! */
		temp_buff = kzalloc(sizeof(struct bcm_host_stats_mibs), GFP_KERNEL);
		if (!temp_buff)
			return STATUS_FAILURE;

		Status = ProcessGetHostMibs(Adapter, temp_buff);
		GetDroppedAppCntrlPktMibs(temp_buff, pTarang);

		if (Status != STATUS_FAILURE)
			if (copy_to_user(IoBuffer.OutputBuffer, temp_buff, sizeof(struct bcm_host_stats_mibs))) {
				kfree(temp_buff);
				return -EFAULT;
			}

		kfree(temp_buff);
		break;
	}

	case IOCTL_BCM_WAKE_UP_DEVICE_FROM_IDLE:
		if ((FALSE == Adapter->bTriedToWakeUpFromlowPowerMode) && (TRUE == Adapter->IdleMode)) {
			Adapter->usIdleModePattern = ABORT_IDLE_MODE;
			Adapter->bWakeUpDevice = TRUE;
			wake_up(&Adapter->process_rx_cntrlpkt);
		}

		Status = STATUS_SUCCESS;
		break;

	case IOCTL_BCM_BULK_WRM: {
		struct bcm_bulk_wrm_buffer *pBulkBuffer;
		UINT uiTempVar = 0;
		PCHAR pvBuffer = NULL;

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device in Idle/Shutdown Mode, Blocking Wrms\n"");
			Status = -EACCES;
			break;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength < sizeof(ULONG) * 2)
			return -EINVAL;

		pvBuffer = memdup_user(IoBuffer.InputBuffer,
				       IoBuffer.InputLength);
		if (IS_ERR(pvBuffer))
			return PTR_ERR(pvBuffer);

		pBulkBuffer = (struct bcm_bulk_wrm_buffer *)pvBuffer;

		if (((ULONG)pBulkBuffer->Register & 0x0F000000) != 0x0F000000 ||
			((ULONG)pBulkBuffer->Register & 0x3)) {
			BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM Done On invalid Address : %x Access Denied.\n"", (int)pBulkBuffer->Register);
			kfree(pvBuffer);
			Status = -EINVAL;
			break;
		}

		uiTempVar = pBulkBuffer->Register & EEPROM_REJECT_MASK;
		if (!((Adapter->pstargetparams->m_u32Customize)&VSG_MODE) &&
			((uiTempVar == EEPROM_REJECT_REG_1) ||
				(uiTempVar == EEPROM_REJECT_REG_2) ||
				(uiTempVar == EEPROM_REJECT_REG_3) ||
				(uiTempVar == EEPROM_REJECT_REG_4)) &&
			(cmd == IOCTL_BCM_REGISTER_WRITE)) {

			kfree(pvBuffer);
			BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""EEPROM Access Denied, not in VSG Mode\n"");
			Status = -EFAULT;
			break;
		}

		if (pBulkBuffer->SwapEndian == FALSE)
			Status = wrmWithLock(Adapter, (UINT)pBulkBuffer->Register, (PCHAR)pBulkBuffer->Values, IoBuffer.InputLength - 2*sizeof(ULONG));
		else
			Status = wrmaltWithLock(Adapter, (UINT)pBulkBuffer->Register, (PUINT)pBulkBuffer->Values, IoBuffer.InputLength - 2*sizeof(ULONG));

		if (Status != STATUS_SUCCESS)
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM Failed\n"");

		kfree(pvBuffer);
		break;
	}

	case IOCTL_BCM_GET_NVM_SIZE:
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (Adapter->eNVMType == NVM_EEPROM || Adapter->eNVMType == NVM_FLASH) {
			if (copy_to_user(IoBuffer.OutputBuffer, &Adapter->uiNVMDSDSize, sizeof(UINT)))
				return -EFAULT;
		}

		Status = STATUS_SUCCESS;
		break;

	case IOCTL_BCM_CAL_INIT: {
		UINT uiSectorSize = 0 ;
		if (Adapter->eNVMType == NVM_FLASH) {
			if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
				return -EFAULT;

			if (copy_from_user(&uiSectorSize, IoBuffer.InputBuffer, sizeof(UINT)))
				return -EFAULT;

			if ((uiSectorSize < MIN_SECTOR_SIZE) || (uiSectorSize > MAX_SECTOR_SIZE)) {
				if (copy_to_user(IoBuffer.OutputBuffer, &Adapter->uiSectorSize,
							sizeof(UINT)))
					return -EFAULT;
			} else {
				if (IsFlash2x(Adapter)) {
					if (copy_to_user(IoBuffer.OutputBuffer,	&Adapter->uiSectorSize, sizeof(UINT)))
						return -EFAULT;
				} else {
					if ((TRUE == Adapter->bShutStatus) || (TRUE == Adapter->IdleMode)) {
						BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device is in Idle/Shutdown Mode\n"");
						return -EACCES;
					}

					Adapter->uiSectorSize = uiSectorSize;
					BcmUpdateSectorSize(Adapter, Adapter->uiSectorSize);
				}
			}
			Status = STATUS_SUCCESS;
		} else {
			Status = STATUS_FAILURE;
		}
	}
	break;

	case IOCTL_BCM_SET_DEBUG:
#ifdef DEBUG
	{
		struct bcm_user_debug_state sUserDebugState;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""In SET_DEBUG ioctl\n"");
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (copy_from_user(&sUserDebugState, IoBuffer.InputBuffer, sizeof(struct bcm_user_debug_state)))
			return -EFAULT;

		BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""IOCTL_BCM_SET_DEBUG: OnOff=%d Type = 0x%x "",
				sUserDebugState.OnOff, sUserDebugState.Type);
		/* sUserDebugState.Subtype <<= 1; */
		sUserDebugState.Subtype = 1 << sUserDebugState.Subtype;
		BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""actual Subtype=0x%x\n"", sUserDebugState.Subtype);

		/* Update new 'DebugState' in the Adapter */
		Adapter->stDebugState.type |= sUserDebugState.Type;
		/* Subtype: A bitmap of 32 bits for Subtype per Type.
		 * Valid indexes in 'subtype' array: 1,2,4,8
		 * corresponding to valid Type values. Hence we can use the 'Type' field
		 * as the index value, ignoring the array entries 0,3,5,6,7 !
		 */
		if (sUserDebugState.OnOff)
			Adapter->stDebugState.subtype[sUserDebugState.Type] |= sUserDebugState.Subtype;
		else
			Adapter->stDebugState.subtype[sUserDebugState.Type] &= ~sUserDebugState.Subtype;

		BCM_SHOW_DEBUG_BITMAP(Adapter);
	}
#endif
	break;

	case IOCTL_BCM_NVM_READ:
	case IOCTL_BCM_NVM_WRITE: {
		struct bcm_nvm_readwrite stNVMReadWrite;
		PUCHAR pReadData = NULL;
		ULONG ulDSDMagicNumInUsrBuff = 0;
		struct timeval tv0, tv1;
		memset(&tv0, 0, sizeof(struct timeval));
		memset(&tv1, 0, sizeof(struct timeval));
		if ((Adapter->eNVMType == NVM_FLASH) && (Adapter->uiFlashLayoutMajorVersion == 0)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""The Flash Control Section is Corrupted. Hence Rejection on NVM Read/Write\n"");
			return -EFAULT;
		}

		if (IsFlash2x(Adapter)) {
			if ((Adapter->eActiveDSD != DSD0) &&
				(Adapter->eActiveDSD != DSD1) &&
				(Adapter->eActiveDSD != DSD2)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""No DSD is active..hence NVM Command is blocked"");
				return STATUS_FAILURE;
			}
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (copy_from_user(&stNVMReadWrite,
					(IOCTL_BCM_NVM_READ == cmd) ? IoBuffer.OutputBuffer : IoBuffer.InputBuffer,
					sizeof(struct bcm_nvm_readwrite)))
			return -EFAULT;

		/*
		 * Deny the access if the offset crosses the cal area limit.
		 */
		if (stNVMReadWrite.uiNumBytes > Adapter->uiNVMDSDSize)
			return STATUS_FAILURE;

		if (stNVMReadWrite.uiOffset > Adapter->uiNVMDSDSize - stNVMReadWrite.uiNumBytes) {
			/* BCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,""Can't allow access beyond NVM Size: 0x%x 0x%x\n"", stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes); */
			return STATUS_FAILURE;
		}

		pReadData = memdup_user(stNVMReadWrite.pBuffer,
					stNVMReadWrite.uiNumBytes);
		if (IS_ERR(pReadData))
			return PTR_ERR(pReadData);

		do_gettimeofday(&tv0);
		if (IOCTL_BCM_NVM_READ == cmd) {
			down(&Adapter->NVMRdmWrmLock);

			if ((Adapter->IdleMode == TRUE) ||
				(Adapter->bShutStatus == TRUE) ||
				(Adapter->bPreparingForLowPowerMode == TRUE)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadData);
				return -EACCES;
			}

			Status = BeceemNVMRead(Adapter, (PUINT)pReadData, stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes);
			up(&Adapter->NVMRdmWrmLock);

			if (Status != STATUS_SUCCESS) {
				kfree(pReadData);
				return Status;
			}

			if (copy_to_user(stNVMReadWrite.pBuffer, pReadData, stNVMReadWrite.uiNumBytes)) {
				kfree(pReadData);
				return -EFAULT;
			}
		} else {
			down(&Adapter->NVMRdmWrmLock);

			if ((Adapter->IdleMode == TRUE) ||
				(Adapter->bShutStatus == TRUE) ||
				(Adapter->bPreparingForLowPowerMode == TRUE)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadData);
				return -EACCES;
			}

			Adapter->bHeaderChangeAllowed = TRUE;
			if (IsFlash2x(Adapter)) {
				/*
				 *			New Requirement:-
				 *			DSD section updation will be allowed in two case:-
				 *			1.  if DSD sig is present in DSD header means dongle is ok and updation is fruitfull
				 *			2.  if point 1 failes then user buff should have DSD sig. this point ensures that if dongle is
				 *			      corrupted then user space program first modify the DSD header with valid DSD sig so
				 *			      that this as well as further write may be worthwhile.
				 *
				 *			 This restriction has been put assuming that if DSD sig is corrupted, DSD
				 *			 data won't be considered valid.
				 */

				Status = BcmFlash2xCorruptSig(Adapter, Adapter->eActiveDSD);
				if (Status != STATUS_SUCCESS) {
					if (((stNVMReadWrite.uiOffset + stNVMReadWrite.uiNumBytes) != Adapter->uiNVMDSDSize) ||
						(stNVMReadWrite.uiNumBytes < SIGNATURE_SIZE)) {

						BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""DSD Sig is present neither in Flash nor User provided Input.."");
						up(&Adapter->NVMRdmWrmLock);
						kfree(pReadData);
						return Status;
					}

					ulDSDMagicNumInUsrBuff = ntohl(*(PUINT)(pReadData + stNVMReadWrite.uiNumBytes - SIGNATURE_SIZE));
					if (ulDSDMagicNumInUsrBuff != DSD_IMAGE_MAGIC_NUMBER) {
						BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""DSD Sig is present neither in Flash nor User provided Input.."");
						up(&Adapter->NVMRdmWrmLock);
						kfree(pReadData);
						return Status;
					}
				}
			}

			Status = BeceemNVMWrite(Adapter, (PUINT)pReadData, stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes, stNVMReadWrite.bVerify);
			if (IsFlash2x(Adapter))
				BcmFlash2xWriteSig(Adapter, Adapter->eActiveDSD);

			Adapter->bHeaderChangeAllowed = FALSE;

			up(&Adapter->NVMRdmWrmLock);

			if (Status != STATUS_SUCCESS) {
				kfree(pReadData);
				return Status;
			}
		}

		do_gettimeofday(&tv1);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "" timetaken by Write/read :%ld msec\n"", (tv1.tv_sec - tv0.tv_sec)*1000 + (tv1.tv_usec - tv0.tv_usec)/1000);

		kfree(pReadData);
		return STATUS_SUCCESS;
	}

	case IOCTL_BCM_FLASH2X_SECTION_READ: {
		struct bcm_flash2x_readwrite sFlash2xRead = {0};
		PUCHAR pReadBuff = NULL ;
		UINT NOB = 0;
		UINT BuffSize = 0;
		UINT ReadBytes = 0;
		UINT ReadOffset = 0;
		void __user *OutPutBuff;

		if (IsFlash2x(Adapter) != TRUE)	{
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_FLASH2X_SECTION_READ Called"");
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		/* Reading FLASH 2.x READ structure */
		if (copy_from_user(&sFlash2xRead, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_readwrite)))
			return -EFAULT;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.Section :%x"", sFlash2xRead.Section);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.offset :%x"", sFlash2xRead.offset);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.numOfBytes :%x"", sFlash2xRead.numOfBytes);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.bVerify :%x\n"", sFlash2xRead.bVerify);

		/* This was internal to driver for raw read. now it has ben exposed to user space app. */
		if (validateFlash2xReadWrite(Adapter, &sFlash2xRead) == FALSE)
			return STATUS_FAILURE;

		NOB = sFlash2xRead.numOfBytes;
		if (NOB > Adapter->uiSectorSize)
			BuffSize = Adapter->uiSectorSize;
		else
			BuffSize = NOB;

		ReadOffset = sFlash2xRead.offset ;
		OutPutBuff = IoBuffer.OutputBuffer;
		pReadBuff = (PCHAR)kzalloc(BuffSize , GFP_KERNEL);

		if (pReadBuff == NULL) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Memory allocation failed for Flash 2.x Read Structure"");
			return -ENOMEM;
		}
		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			kfree(pReadBuff);
			return -EACCES;
		}

		while (NOB) {
			if (NOB > Adapter->uiSectorSize)
				ReadBytes = Adapter->uiSectorSize;
			else
				ReadBytes = NOB;

			/* Reading the data from Flash 2.x */
			Status = BcmFlash2xBulkRead(Adapter, (PUINT)pReadBuff, sFlash2xRead.Section, ReadOffset, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Flash 2x read err with Status :%d"", Status);
				break;
			}

			BCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pReadBuff, ReadBytes);

			Status = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Copy to use failed with status :%d"", Status);
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadBuff);
				return -EFAULT;
			}
			NOB = NOB - ReadBytes;
			if (NOB) {
				ReadOffset = ReadOffset + ReadBytes;
				OutPutBuff = OutPutBuff + ReadBytes ;
			}
		}

		up(&Adapter->NVMRdmWrmLock);
		kfree(pReadBuff);
	}
	break;

	case IOCTL_BCM_FLASH2X_SECTION_WRITE: {
		struct bcm_flash2x_readwrite sFlash2xWrite = {0};
		PUCHAR pWriteBuff;
		void __user *InputAddr;
		UINT NOB = 0;
		UINT BuffSize = 0;
		UINT WriteOffset = 0;
		UINT WriteBytes = 0;

		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		/* First make this False so that we can enable the Sector Permission Check in BeceemFlashBulkWrite */
		Adapter->bAllDSDWriteAllow = FALSE;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_FLASH2X_SECTION_WRITE Called"");

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		/* Reading FLASH 2.x READ structure */
		if (copy_from_user(&sFlash2xWrite, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_readwrite)))
			return -EFAULT;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.Section :%x"", sFlash2xWrite.Section);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.offset :%d"", sFlash2xWrite.offset);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.numOfBytes :%x"", sFlash2xWrite.numOfBytes);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.bVerify :%x\n"", sFlash2xWrite.bVerify);

		if ((sFlash2xWrite.Section != VSA0) && (sFlash2xWrite.Section != VSA1) && (sFlash2xWrite.Section != VSA2)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Only VSA write is allowed"");
			return -EINVAL;
		}

		if (validateFlash2xReadWrite(Adapter, &sFlash2xWrite) == FALSE)
			return STATUS_FAILURE;

		InputAddr = sFlash2xWrite.pDataBuff;
		WriteOffset = sFlash2xWrite.offset;
		NOB = sFlash2xWrite.numOfBytes;

		if (NOB > Adapter->uiSectorSize)
			BuffSize = Adapter->uiSectorSize;
		else
			BuffSize = NOB ;

		pWriteBuff = kmalloc(BuffSize, GFP_KERNEL);

		if (pWriteBuff == NULL)
			return -ENOMEM;

		/* extracting the remainder of the given offset. */
		WriteBytes = Adapter->uiSectorSize;
		if (WriteOffset % Adapter->uiSectorSize)
			WriteBytes = Adapter->uiSectorSize - (WriteOffset % Adapter->uiSectorSize);

		if (NOB < WriteBytes)
			WriteBytes = NOB;

		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			kfree(pWriteBuff);
			return -EACCES;
		}

		BcmFlash2xCorruptSig(Adapter, sFlash2xWrite.Section);
		do {
			Status = copy_from_user(pWriteBuff, InputAddr, WriteBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy to user failed with status :%d"", Status);
				up(&Adapter->NVMRdmWrmLock);
				kfree(pWriteBuff);
				return -EFAULT;
			}
			BCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pWriteBuff, WriteBytes);

			/* Writing the data from Flash 2.x */
			Status = BcmFlash2xBulkWrite(Adapter, (PUINT)pWriteBuff, sFlash2xWrite.Section, WriteOffset, WriteBytes, sFlash2xWrite.bVerify);

			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash 2x read err with Status :%d"", Status);
				break;
			}

			NOB = NOB - WriteBytes;
			if (NOB) {
				WriteOffset = WriteOffset + WriteBytes;
				InputAddr = InputAddr + WriteBytes;
				if (NOB > Adapter->uiSectorSize)
					WriteBytes = Adapter->uiSectorSize;
				else
					WriteBytes = NOB;
			}
		} while (NOB > 0);

		BcmFlash2xWriteSig(Adapter, sFlash2xWrite.Section);
		up(&Adapter->NVMRdmWrmLock);
		kfree(pWriteBuff);
	}
	break;

	case IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP: {
		struct bcm_flash2x_bitmap *psFlash2xBitMap;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP Called"");

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength != sizeof(struct bcm_flash2x_bitmap))
			return -EINVAL;

		psFlash2xBitMap = kzalloc(sizeof(struct bcm_flash2x_bitmap), GFP_KERNEL);
		if (psFlash2xBitMap == NULL) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Memory is not available"");
			return -ENOMEM;
		}

		/* Reading the Flash Sectio Bit map */
		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			kfree(psFlash2xBitMap);
			return -EACCES;
		}

		BcmGetFlash2xSectionalBitMap(Adapter, psFlash2xBitMap);
		up(&Adapter->NVMRdmWrmLock);
		if (copy_to_user(IoBuffer.OutputBuffer, psFlash2xBitMap, sizeof(struct bcm_flash2x_bitmap))) {
			kfree(psFlash2xBitMap);
			return -EFAULT;
		}

		kfree(psFlash2xBitMap);
	}
	break;

	case IOCTL_BCM_SET_ACTIVE_SECTION: {
		enum bcm_flash2x_section_val eFlash2xSectionVal = 0;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SET_ACTIVE_SECTION Called"");

		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed"");
			return -EFAULT;
		}

		Status = copy_from_user(&eFlash2xSectionVal, IoBuffer.InputBuffer, sizeof(INT));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of flash section val failed"");
			return -EFAULT;
		}

		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			return -EACCES;
		}

		Status = BcmSetActiveSection(Adapter, eFlash2xSectionVal);
		if (Status)
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Failed to make it's priority Highest. Status %d"", Status);

		up(&Adapter->NVMRdmWrmLock);
	}
	break;

	case IOCTL_BCM_IDENTIFY_ACTIVE_SECTION: {
		/* Right Now we are taking care of only DSD */
		Adapter->bAllDSDWriteAllow = FALSE;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_IDENTIFY_ACTIVE_SECTION called"");
		Status = STATUS_SUCCESS;
	}
	break;

	case IOCTL_BCM_COPY_SECTION: {
		struct bcm_flash2x_copy_section sCopySectStrut = {0};
		Status = STATUS_SUCCESS;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_COPY_SECTION  Called"");

		Adapter->bAllDSDWriteAllow = FALSE;
		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed Status :%d"", Status);
			return -EFAULT;
		}

		Status = copy_from_user(&sCopySectStrut, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_copy_section));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of Copy_Section_Struct failed with Status :%d"", Status);
			return -EFAULT;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Source SEction :%x"", sCopySectStrut.SrcSection);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Destination SEction :%x"", sCopySectStrut.DstSection);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""offset :%x"", sCopySectStrut.offset);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""NOB :%x"", sCopySectStrut.numOfBytes);

		if (IsSectionExistInFlash(Adapter, sCopySectStrut.SrcSection) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Source Section<%x> does not exixt in Flash "", sCopySectStrut.SrcSection);
			return -EINVAL;
		}

		if (IsSectionExistInFlash(Adapter, sCopySectStrut.DstSection) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Destinatio Section<%x> does not exixt in Flash "", sCopySectStrut.DstSection);
			return -EINVAL;
		}

		if (sCopySectStrut.SrcSection == sCopySectStrut.DstSection) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Source and Destination section should be different"");
			return -EINVAL;
		}

		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			return -EACCES;
		}

		if (sCopySectStrut.SrcSection == ISO_IMAGE1 || sCopySectStrut.SrcSection == ISO_IMAGE2) {
			if (IsNonCDLessDevice(Adapter)) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device is Non-CDLess hence won't have ISO !!"");
				Status = -EINVAL;
			} else if (sCopySectStrut.numOfBytes == 0) {
				Status = BcmCopyISO(Adapter, sCopySectStrut);
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Partial Copy of ISO section is not Allowed.."");
				Status = STATUS_FAILURE;
			}
			up(&Adapter->NVMRdmWrmLock);
			return Status;
		}

		Status = BcmCopySection(Adapter, sCopySectStrut.SrcSection,
					sCopySectStrut.DstSection, sCopySectStrut.offset, sCopySectStrut.numOfBytes);
		up(&Adapter->NVMRdmWrmLock);
	}
	break;

	case IOCTL_BCM_GET_FLASH_CS_INFO: {
		Status = STATUS_SUCCESS;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "" IOCTL_BCM_GET_FLASH_CS_INFO Called"");

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed"");
			return -EFAULT;
		}

		if (Adapter->eNVMType != NVM_FLASH) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Connected device does not have flash"");
			Status = -EINVAL;
			break;
		}

		if (IsFlash2x(Adapter) == TRUE) {
			if (IoBuffer.OutputLength < sizeof(struct bcm_flash2x_cs_info))
				return -EINVAL;

			if (copy_to_user(IoBuffer.OutputBuffer, Adapter->psFlash2xCSInfo, sizeof(struct bcm_flash2x_cs_info)))
				return -EFAULT;
		} else {
			if (IoBuffer.OutputLength < sizeof(struct bcm_flash_cs_info))
				return -EINVAL;

			if (copy_to_user(IoBuffer.OutputBuffer, Adapter->psFlashCSInfo, sizeof(struct bcm_flash_cs_info)))
				return -EFAULT;
		}
	}
	break;

	case IOCTL_BCM_SELECT_DSD: {
		UINT SectOfset = 0;
		enum bcm_flash2x_section_val eFlash2xSectionVal;
		eFlash2xSectionVal = NO_SECTION_VAL;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SELECT_DSD Called"");

		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed"");
			return -EFAULT;
		}
		Status = copy_from_user(&eFlash2xSectionVal, IoBuffer.InputBuffer, sizeof(INT));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of flash section val failed"");
			return -EFAULT;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Read Section :%d"", eFlash2xSectionVal);
		if ((eFlash2xSectionVal != DSD0) &&
			(eFlash2xSectionVal != DSD1) &&
			(eFlash2xSectionVal != DSD2)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Passed section<%x> is not DSD section"", eFlash2xSectionVal);
			return STATUS_FAILURE;
		}

		SectOfset = BcmGetSectionValStartOffset(Adapter, eFlash2xSectionVal);
		if (SectOfset == INVALID_OFFSET) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Provided Section val <%d> does not exixt in Flash 2.x"", eFlash2xSectionVal);
			return -EINVAL;
		}

		Adapter->bAllDSDWriteAllow = TRUE;
		Adapter->ulFlashCalStart = SectOfset;
		Adapter->eActiveDSD = eFlash2xSectionVal;
	}
	Status = STATUS_SUCCESS;
	break;

	case IOCTL_BCM_NVM_RAW_READ: {
		struct bcm_nvm_readwrite stNVMRead;
		INT NOB ;
		INT BuffSize ;
		INT ReadOffset = 0;
		UINT ReadBytes = 0 ;
		PUCHAR pReadBuff;
		void __user *OutPutBuff;

		if (Adapter->eNVMType != NVM_FLASH) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""NVM TYPE is not Flash"");
			return -EINVAL;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""copy_from_user 1 failed\n"");
			return -EFAULT;
		}

		if (copy_from_user(&stNVMRead, IoBuffer.OutputBuffer, sizeof(struct bcm_nvm_readwrite)))
			return -EFAULT;

		NOB = stNVMRead.uiNumBytes;
		/* In Raw-Read max Buff size : 64MB */

		if (NOB > DEFAULT_BUFF_SIZE)
			BuffSize = DEFAULT_BUFF_SIZE;
		else
			BuffSize = NOB;

		ReadOffset = stNVMRead.uiOffset;
		OutPutBuff = stNVMRead.pBuffer;

		pReadBuff = kzalloc(BuffSize , GFP_KERNEL);
		if (pReadBuff == NULL) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Memory allocation failed for Flash 2.x Read Structure"");
			Status = -ENOMEM;
			break;
		}
		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			kfree(pReadBuff);
			up(&Adapter->NVMRdmWrmLock);
			return -EACCES;
		}

		Adapter->bFlashRawRead = TRUE;

		while (NOB) {
			if (NOB > DEFAULT_BUFF_SIZE)
				ReadBytes = DEFAULT_BUFF_SIZE;
			else
				ReadBytes = NOB;

			/* Reading the data from Flash 2.x */
			Status = BeceemNVMRead(Adapter, (PUINT)pReadBuff, ReadOffset, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash 2x read err with Status :%d"", Status);
				break;
			}

			BCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pReadBuff, ReadBytes);

			Status = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy to use failed with status :%d"", Status);
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadBuff);
				return -EFAULT;
			}
			NOB = NOB - ReadBytes;
			if (NOB) {
				ReadOffset = ReadOffset + ReadBytes;
				OutPutBuff = OutPutBuff + ReadBytes;
			}
		}
		Adapter->bFlashRawRead = FALSE;
		up(&Adapter->NVMRdmWrmLock);
		kfree(pReadBuff);
		break;
	}

	case IOCTL_BCM_CNTRLMSG_MASK: {
		ULONG RxCntrlMsgBitMask = 0;

		/* Copy Ioctl Buffer structure */
		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""copy of Ioctl buffer is failed from user space"");
			return -EFAULT;
		}

		if (IoBuffer.InputLength != sizeof(unsigned long)) {
			Status = -EINVAL;
			break;
		}

		Status = copy_from_user(&RxCntrlMsgBitMask, IoBuffer.InputBuffer, IoBuffer.InputLength);
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""copy of control bit mask failed from user space"");
			return -EFAULT;
		}
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\n Got user defined cntrl msg bit mask :%lx"", RxCntrlMsgBitMask);
		pTarang->RxCntrlMsgBitMask = RxCntrlMsgBitMask;
	}
	break;

	case IOCTL_BCM_GET_DEVICE_DRIVER_INFO: {
		struct bcm_driver_info DevInfo;
 
 		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Called IOCTL_BCM_GET_DEVICE_DRIVER_INFO\n"");
 
 		DevInfo.MaxRDMBufferSize = BUFFER_4K;
 		DevInfo.u32DSDStartOffset = EEPROM_CALPARAM_START;
 		DevInfo.u32RxAlignmentCorrection = 0;
		DevInfo.u32NVMType = Adapter->eNVMType;
		DevInfo.u32InterfaceType = BCM_USB;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength < sizeof(DevInfo))
			return -EINVAL;

		if (copy_to_user(IoBuffer.OutputBuffer, &DevInfo, sizeof(DevInfo)))
			return -EFAULT;
	}
	break;

	case IOCTL_BCM_TIME_SINCE_NET_ENTRY: {
		struct bcm_time_elapsed stTimeElapsedSinceNetEntry = {0};

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_TIME_SINCE_NET_ENTRY called"");

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength < sizeof(struct bcm_time_elapsed))
			return -EINVAL;

		stTimeElapsedSinceNetEntry.ul64TimeElapsedSinceNetEntry = get_seconds() - Adapter->liTimeSinceLastNetEntry;

		if (copy_to_user(IoBuffer.OutputBuffer, &stTimeElapsedSinceNetEntry, sizeof(struct bcm_time_elapsed)))
			return -EFAULT;
	}
	break;

	case IOCTL_CLOSE_NOTIFICATION:
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_CLOSE_NOTIFICATION"");
		break;

	default:
		pr_info(DRV_NAME "": unknown ioctl cmd=%#x\n"", cmd);
		Status = STATUS_FAILURE;
		break;
	}
	return Status;
}
",C,"		memset(&DevInfo, 0, sizeof(DevInfo));
",,,"@@ -1960,6 +1960,7 @@ static long bcm_char_ioctl(struct file *filp, UINT cmd, ULONG arg)
 
 		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Called IOCTL_BCM_GET_DEVICE_DRIVER_INFO\n"");
 
+		memset(&DevInfo, 0, sizeof(DevInfo));
 		DevInfo.MaxRDMBufferSize = BUFFER_4K;
 		DevInfo.u32DSDStartOffset = EEPROM_CALPARAM_START;
 		DevInfo.u32RxAlignmentCorrection = 0;",linux,8d1e72250c847fa96498ec029891de4dc638a5ba,b5e2f339865fb443107e5b10603e53bbc92dc054,1,"static long bcm_char_ioctl(struct file *filp, UINT cmd, ULONG arg)
{
	struct bcm_tarang_data *pTarang = filp->private_data;
	void __user *argp = (void __user *)arg;
	struct bcm_mini_adapter *Adapter = pTarang->Adapter;
	INT Status = STATUS_FAILURE;
	int timeout = 0;
	struct bcm_ioctl_buffer IoBuffer;
	int bytes;

	BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Parameters Passed to control IOCTL cmd=0x%X arg=0x%lX"", cmd, arg);

	if (_IOC_TYPE(cmd) != BCM_IOCTL)
		return -EFAULT;
	if (_IOC_DIR(cmd) & _IOC_READ)
		Status = !access_ok(VERIFY_WRITE, argp, _IOC_SIZE(cmd));
	else if (_IOC_DIR(cmd) & _IOC_WRITE)
		Status = !access_ok(VERIFY_READ, argp, _IOC_SIZE(cmd));
	else if (_IOC_NONE == (_IOC_DIR(cmd) & _IOC_NONE))
		Status = STATUS_SUCCESS;

	if (Status)
		return -EFAULT;

	if (Adapter->device_removed)
		return -EFAULT;

	if (FALSE == Adapter->fw_download_done) {
		switch (cmd) {
		case IOCTL_MAC_ADDR_REQ:
		case IOCTL_LINK_REQ:
		case IOCTL_CM_REQUEST:
		case IOCTL_SS_INFO_REQ:
		case IOCTL_SEND_CONTROL_MESSAGE:
		case IOCTL_IDLE_REQ:
		case IOCTL_BCM_GPIO_SET_REQUEST:
		case IOCTL_BCM_GPIO_STATUS_REQUEST:
			return -EACCES;
		default:
			break;
		}
	}

	Status = vendorextnIoctl(Adapter, cmd, arg);
	if (Status != CONTINUE_COMMON_PATH)
		return Status;

	switch (cmd) {
	/* Rdms for Swin Idle... */
	case IOCTL_BCM_REGISTER_READ_PRIVATE: {
		struct bcm_rdm_buffer sRdmBuffer = {0};
		PCHAR temp_buff;
		UINT Bufflen;
		u16 temp_value;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sRdmBuffer))
			return -EINVAL;

		if (copy_from_user(&sRdmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if (IoBuffer.OutputLength > USHRT_MAX ||
			IoBuffer.OutputLength == 0) {
			return -EINVAL;
		}

		Bufflen = IoBuffer.OutputLength;
		temp_value = 4 - (Bufflen % 4);
		Bufflen += temp_value % 4;

		temp_buff = kmalloc(Bufflen, GFP_KERNEL);
		if (!temp_buff)
			return -ENOMEM;

		bytes = rdmalt(Adapter, (UINT)sRdmBuffer.Register,
				(PUINT)temp_buff, Bufflen);
		if (bytes > 0) {
			Status = STATUS_SUCCESS;
			if (copy_to_user(IoBuffer.OutputBuffer, temp_buff, bytes)) {
				kfree(temp_buff);
				return -EFAULT;
			}
		} else {
			Status = bytes;
		}

		kfree(temp_buff);
		break;
	}

	case IOCTL_BCM_REGISTER_WRITE_PRIVATE: {
		struct bcm_wrm_buffer sWrmBuffer = {0};
		UINT uiTempVar = 0;
		/* Copy Ioctl Buffer structure */

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sWrmBuffer))
			return -EINVAL;

		/* Get WrmBuffer structure */
		if (copy_from_user(&sWrmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		uiTempVar = sWrmBuffer.Register & EEPROM_REJECT_MASK;
		if (!((Adapter->pstargetparams->m_u32Customize) & VSG_MODE) &&
			((uiTempVar == EEPROM_REJECT_REG_1) ||
				(uiTempVar == EEPROM_REJECT_REG_2) ||
				(uiTempVar == EEPROM_REJECT_REG_3) ||
				(uiTempVar == EEPROM_REJECT_REG_4))) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""EEPROM Access Denied, not in VSG Mode\n"");
			return -EFAULT;
		}

		Status = wrmalt(Adapter, (UINT)sWrmBuffer.Register,
				(PUINT)sWrmBuffer.Data, sizeof(ULONG));

		if (Status == STATUS_SUCCESS) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""WRM Done\n"");
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""WRM Failed\n"");
			Status = -EFAULT;
		}
		break;
	}

	case IOCTL_BCM_REGISTER_READ:
	case IOCTL_BCM_EEPROM_REGISTER_READ: {
		struct bcm_rdm_buffer sRdmBuffer = {0};
		PCHAR temp_buff = NULL;
		UINT uiTempVar = 0;
		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device in Idle Mode, Blocking Rdms\n"");
			return -EACCES;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sRdmBuffer))
			return -EINVAL;

		if (copy_from_user(&sRdmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if (IoBuffer.OutputLength > USHRT_MAX ||
			IoBuffer.OutputLength == 0) {
			return -EINVAL;
		}

		temp_buff = kmalloc(IoBuffer.OutputLength, GFP_KERNEL);
		if (!temp_buff)
			return STATUS_FAILURE;

		if ((((ULONG)sRdmBuffer.Register & 0x0F000000) != 0x0F000000) ||
			((ULONG)sRdmBuffer.Register & 0x3)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""RDM Done On invalid Address : %x Access Denied.\n"",
					(int)sRdmBuffer.Register);

			kfree(temp_buff);
			return -EINVAL;
		}

		uiTempVar = sRdmBuffer.Register & EEPROM_REJECT_MASK;
		bytes = rdmaltWithLock(Adapter, (UINT)sRdmBuffer.Register, (PUINT)temp_buff, IoBuffer.OutputLength);

		if (bytes > 0) {
			Status = STATUS_SUCCESS;
			if (copy_to_user(IoBuffer.OutputBuffer, temp_buff, bytes)) {
				kfree(temp_buff);
				return -EFAULT;
			}
		} else {
			Status = bytes;
		}

		kfree(temp_buff);
		break;
	}
	case IOCTL_BCM_REGISTER_WRITE:
	case IOCTL_BCM_EEPROM_REGISTER_WRITE: {
		struct bcm_wrm_buffer sWrmBuffer = {0};
		UINT uiTempVar = 0;

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device in Idle Mode, Blocking Wrms\n"");
			return -EACCES;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sWrmBuffer))
			return -EINVAL;

		/* Get WrmBuffer structure */
		if (copy_from_user(&sWrmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if ((((ULONG)sWrmBuffer.Register & 0x0F000000) != 0x0F000000) ||
			((ULONG)sWrmBuffer.Register & 0x3)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM Done On invalid Address : %x Access Denied.\n"", (int)sWrmBuffer.Register);
			return -EINVAL;
		}

		uiTempVar = sWrmBuffer.Register & EEPROM_REJECT_MASK;
		if (!((Adapter->pstargetparams->m_u32Customize) & VSG_MODE) &&
				((uiTempVar == EEPROM_REJECT_REG_1) ||
				(uiTempVar == EEPROM_REJECT_REG_2) ||
				(uiTempVar == EEPROM_REJECT_REG_3) ||
				(uiTempVar == EEPROM_REJECT_REG_4)) &&
				(cmd == IOCTL_BCM_REGISTER_WRITE)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""EEPROM Access Denied, not in VSG Mode\n"");
				return -EFAULT;
		}

		Status = wrmaltWithLock(Adapter, (UINT)sWrmBuffer.Register,
					(PUINT)sWrmBuffer.Data, sWrmBuffer.Length);

		if (Status == STATUS_SUCCESS) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL, ""WRM Done\n"");
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""WRM Failed\n"");
			Status = -EFAULT;
		}
		break;
	}
	case IOCTL_BCM_GPIO_SET_REQUEST: {
		UCHAR ucResetValue[4];
		UINT value = 0;
		UINT uiBit = 0;
		UINT uiOperation = 0;
		struct bcm_gpio_info gpio_info = {0};

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""GPIO Can't be set/clear in Low power Mode"");
			return -EACCES;
		}

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_info))
			return -EINVAL;

		if (copy_from_user(&gpio_info, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		uiBit  = gpio_info.uiGpioNumber;
		uiOperation = gpio_info.uiGpioValue;
		value = (1<<uiBit);

		if (IsReqGpioIsLedInNVM(Adapter, value) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Sorry, Requested GPIO<0x%X> is not correspond to LED !!!"", value);
			Status = -EINVAL;
			break;
		}

		/* Set - setting 1 */
		if (uiOperation) {
			/* Set the gpio output register */
			Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_SET_REG, (PUINT)(&value), sizeof(UINT));

			if (Status == STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Set the GPIO bit\n"");
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Failed to set the %dth GPIO\n"", uiBit);
				break;
			}
		} else {
			/* Set the gpio output register */
			Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_CLR_REG, (PUINT)(&value), sizeof(UINT));

			if (Status == STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Set the GPIO bit\n"");
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Failed to clear the %dth GPIO\n"", uiBit);
				break;
			}
		}

		bytes = rdmaltWithLock(Adapter, (UINT)GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));
		if (bytes < 0) {
			Status = bytes;
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""GPIO_MODE_REGISTER read failed"");
			break;
		} else {
			Status = STATUS_SUCCESS;
		}

		/* Set the gpio mode register to output */
		*(UINT *)ucResetValue |= (1<<uiBit);
		Status = wrmaltWithLock(Adapter, GPIO_MODE_REGISTER,
					(PUINT)ucResetValue, sizeof(UINT));

		if (Status == STATUS_SUCCESS) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Set the GPIO to output Mode\n"");
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Failed to put GPIO in Output Mode\n"");
			break;
		}
	}
	break;

	case BCM_LED_THREAD_STATE_CHANGE_REQ: {
		struct bcm_user_thread_req threadReq = {0};
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""User made LED thread InActive"");

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""GPIO Can't be set/clear in Low power Mode"");
			Status = -EACCES;
			break;
		}

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(threadReq))
			return -EINVAL;

		if (copy_from_user(&threadReq, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		/* if LED thread is running(Actively or Inactively) set it state to make inactive */
		if (Adapter->LEDInfo.led_thread_running) {
			if (threadReq.ThreadState == LED_THREAD_ACTIVATION_REQ) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Activating thread req"");
				Adapter->DriverState = LED_THREAD_ACTIVE;
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""DeActivating Thread req....."");
				Adapter->DriverState = LED_THREAD_INACTIVE;
			}

			/* signal thread. */
			wake_up(&Adapter->LEDInfo.notify_led_event);
		}
	}
	break;

	case IOCTL_BCM_GPIO_STATUS_REQUEST: {
		ULONG uiBit = 0;
		UCHAR ucRead[4];
		struct bcm_gpio_info gpio_info = {0};

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE))
			return -EACCES;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_info))
			return -EINVAL;

		if (copy_from_user(&gpio_info, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		uiBit = gpio_info.uiGpioNumber;

		/* Set the gpio output register */
		bytes = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER,
					(PUINT)ucRead, sizeof(UINT));

		if (bytes < 0) {
			Status = bytes;
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""RDM Failed\n"");
			return Status;
		} else {
			Status = STATUS_SUCCESS;
		}
	}
	break;

	case IOCTL_BCM_GPIO_MULTI_REQUEST: {
		UCHAR ucResetValue[4];
		struct bcm_gpio_multi_info gpio_multi_info[MAX_IDX];
		struct bcm_gpio_multi_info *pgpio_multi_info = (struct bcm_gpio_multi_info *)gpio_multi_info;

		memset(pgpio_multi_info, 0, MAX_IDX * sizeof(struct bcm_gpio_multi_info));

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE))
			return -EINVAL;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_multi_info))
			return -EINVAL;

		if (copy_from_user(&gpio_multi_info, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if (IsReqGpioIsLedInNVM(Adapter, pgpio_multi_info[WIMAX_IDX].uiGPIOMask) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!"",
					pgpio_multi_info[WIMAX_IDX].uiGPIOMask, Adapter->gpioBitMap);
			Status = -EINVAL;
			break;
		}

		/* Set the gpio output register */
		if ((pgpio_multi_info[WIMAX_IDX].uiGPIOMask) &
			(pgpio_multi_info[WIMAX_IDX].uiGPIOCommand)) {
			/* Set 1's in GPIO OUTPUT REGISTER */
			*(UINT *)ucResetValue =  pgpio_multi_info[WIMAX_IDX].uiGPIOMask &
				pgpio_multi_info[WIMAX_IDX].uiGPIOCommand &
				pgpio_multi_info[WIMAX_IDX].uiGPIOValue;

			if (*(UINT *) ucResetValue)
				Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_SET_REG,
							(PUINT)ucResetValue, sizeof(ULONG));

			if (Status != STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM to BCM_GPIO_OUTPUT_SET_REG Failed."");
				return Status;
			}

			/* Clear to 0's in GPIO OUTPUT REGISTER */
			*(UINT *)ucResetValue = (pgpio_multi_info[WIMAX_IDX].uiGPIOMask &
						pgpio_multi_info[WIMAX_IDX].uiGPIOCommand &
						(~(pgpio_multi_info[WIMAX_IDX].uiGPIOValue)));

			if (*(UINT *) ucResetValue)
				Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_CLR_REG, (PUINT)ucResetValue, sizeof(ULONG));

			if (Status != STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM to BCM_GPIO_OUTPUT_CLR_REG Failed."");
				return Status;
			}
		}

		if (pgpio_multi_info[WIMAX_IDX].uiGPIOMask) {
			bytes = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));

			if (bytes < 0) {
				Status = bytes;
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""RDM to GPIO_PIN_STATE_REGISTER Failed."");
				return Status;
			} else {
				Status = STATUS_SUCCESS;
			}

			pgpio_multi_info[WIMAX_IDX].uiGPIOValue = (*(UINT *)ucResetValue &
								pgpio_multi_info[WIMAX_IDX].uiGPIOMask);
		}

		Status = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_info, IoBuffer.OutputLength);
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Failed while copying Content to IOBufer for user space err:%d"", Status);
			return -EFAULT;
		}
	}
	break;

	case IOCTL_BCM_GPIO_MODE_REQUEST: {
		UCHAR ucResetValue[4];
		struct bcm_gpio_multi_mode gpio_multi_mode[MAX_IDX];
		struct bcm_gpio_multi_mode *pgpio_multi_mode = (struct bcm_gpio_multi_mode *)gpio_multi_mode;

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE))
			return -EINVAL;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_multi_mode))
			return -EINVAL;

		if (copy_from_user(&gpio_multi_mode, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		bytes = rdmaltWithLock(Adapter, (UINT)GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));

		if (bytes < 0) {
			Status = bytes;
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Read of GPIO_MODE_REGISTER failed"");
			return Status;
		} else {
			Status = STATUS_SUCCESS;
		}

		/* Validating the request */
		if (IsReqGpioIsLedInNVM(Adapter, pgpio_multi_mode[WIMAX_IDX].uiGPIOMask) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!"",
					pgpio_multi_mode[WIMAX_IDX].uiGPIOMask, Adapter->gpioBitMap);
			Status = -EINVAL;
			break;
		}

		if (pgpio_multi_mode[WIMAX_IDX].uiGPIOMask) {
			/* write all OUT's (1's) */
			*(UINT *) ucResetValue |= (pgpio_multi_mode[WIMAX_IDX].uiGPIOMode &
						pgpio_multi_mode[WIMAX_IDX].uiGPIOMask);

			/* write all IN's (0's) */
			*(UINT *) ucResetValue &= ~((~pgpio_multi_mode[WIMAX_IDX].uiGPIOMode) &
						pgpio_multi_mode[WIMAX_IDX].uiGPIOMask);

			/* Currently implemented return the modes of all GPIO's
			 * else needs to bit AND with  mask
			 */
			pgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT *)ucResetValue;

			Status = wrmaltWithLock(Adapter, GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(ULONG));
			if (Status == STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
						""WRM to GPIO_MODE_REGISTER Done"");
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
						""WRM to GPIO_MODE_REGISTER Failed"");
				Status = -EFAULT;
				break;
			}
		} else {
/* if uiGPIOMask is 0 then return mode register configuration */
			pgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT *)ucResetValue;
		}

		Status = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_mode, IoBuffer.OutputLength);
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Failed while copying Content to IOBufer for user space err:%d"", Status);
			return -EFAULT;
		}
	}
	break;

	case IOCTL_MAC_ADDR_REQ:
	case IOCTL_LINK_REQ:
	case IOCTL_CM_REQUEST:
	case IOCTL_SS_INFO_REQ:
	case IOCTL_SEND_CONTROL_MESSAGE:
	case IOCTL_IDLE_REQ: {
		PVOID pvBuffer = NULL;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength < sizeof(struct bcm_link_request))
			return -EINVAL;

		if (IoBuffer.InputLength > MAX_CNTL_PKT_SIZE)
			return -EINVAL;

		pvBuffer = memdup_user(IoBuffer.InputBuffer,
				       IoBuffer.InputLength);
		if (IS_ERR(pvBuffer))
			return PTR_ERR(pvBuffer);

		down(&Adapter->LowPowerModeSync);
		Status = wait_event_interruptible_timeout(Adapter->lowpower_mode_wait_queue,
							!Adapter->bPreparingForLowPowerMode,
							(1 * HZ));
		if (Status == -ERESTARTSYS)
			goto cntrlEnd;

		if (Adapter->bPreparingForLowPowerMode) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""Preparing Idle Mode is still True - Hence Rejecting control message\n"");
			Status = STATUS_FAILURE;
			goto cntrlEnd;
		}
		Status = CopyBufferToControlPacket(Adapter, (PVOID)pvBuffer);

cntrlEnd:
		up(&Adapter->LowPowerModeSync);
		kfree(pvBuffer);
		break;
	}

	case IOCTL_BCM_BUFFER_DOWNLOAD_START: {
		if (down_trylock(&Adapter->NVMRdmWrmLock)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\n"");
			return -EACCES;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
				""Starting the firmware download PID =0x%x!!!!\n"", current->pid);

		if (down_trylock(&Adapter->fw_download_sema))
			return -EBUSY;

		Adapter->bBinDownloaded = FALSE;
		Adapter->fw_download_process_pid = current->pid;
		Adapter->bCfgDownloaded = FALSE;
		Adapter->fw_download_done = FALSE;
		netif_carrier_off(Adapter->dev);
		netif_stop_queue(Adapter->dev);
		Status = reset_card_proc(Adapter);
		if (Status) {
			pr_err(PFX ""%s: reset_card_proc Failed!\n"", Adapter->dev->name);
			up(&Adapter->fw_download_sema);
			up(&Adapter->NVMRdmWrmLock);
			return Status;
		}
		mdelay(10);

		up(&Adapter->NVMRdmWrmLock);
		return Status;
	}

	case IOCTL_BCM_BUFFER_DOWNLOAD: {
		struct bcm_firmware_info *psFwInfo = NULL;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Starting the firmware download PID =0x%x!!!!\n"", current->pid);

		if (!down_trylock(&Adapter->fw_download_sema)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Invalid way to download buffer. Use Start and then call this!!!\n"");
			up(&Adapter->fw_download_sema);
			Status = -EINVAL;
			return Status;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {
			up(&Adapter->fw_download_sema);
			return -EFAULT;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
				""Length for FW DLD is : %lx\n"", IoBuffer.InputLength);

		if (IoBuffer.InputLength > sizeof(struct bcm_firmware_info)) {
			up(&Adapter->fw_download_sema);
			return -EINVAL;
		}

		psFwInfo = kmalloc(sizeof(*psFwInfo), GFP_KERNEL);
		if (!psFwInfo) {
			up(&Adapter->fw_download_sema);
			return -ENOMEM;
		}

		if (copy_from_user(psFwInfo, IoBuffer.InputBuffer, IoBuffer.InputLength)) {
			up(&Adapter->fw_download_sema);
			kfree(psFwInfo);
			return -EFAULT;
		}

		if (!psFwInfo->pvMappedFirmwareAddress ||
			(psFwInfo->u32FirmwareLength == 0)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Something else is wrong %lu\n"",
					psFwInfo->u32FirmwareLength);
			up(&Adapter->fw_download_sema);
			kfree(psFwInfo);
			Status = -EINVAL;
			return Status;
		}

		Status = bcm_ioctl_fw_download(Adapter, psFwInfo);

		if (Status != STATUS_SUCCESS) {
			if (psFwInfo->u32StartingAddress == CONFIG_BEGIN_ADDR)
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""IOCTL: Configuration File Upload Failed\n"");
			else
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,	""IOCTL: Firmware File Upload Failed\n"");

			/* up(&Adapter->fw_download_sema); */

			if (Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY) {
				Adapter->DriverState = DRIVER_INIT;
				Adapter->LEDInfo.bLedInitDone = FALSE;
				wake_up(&Adapter->LEDInfo.notify_led_event);
			}
		}

		if (Status != STATUS_SUCCESS)
			up(&Adapter->fw_download_sema);

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL, ""IOCTL: Firmware File Uploaded\n"");
		kfree(psFwInfo);
		return Status;
	}

	case IOCTL_BCM_BUFFER_DOWNLOAD_STOP: {
		if (!down_trylock(&Adapter->fw_download_sema)) {
			up(&Adapter->fw_download_sema);
			return -EINVAL;
		}

		if (down_trylock(&Adapter->NVMRdmWrmLock)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""FW download blocked as EEPROM Read/Write is in progress\n"");
			up(&Adapter->fw_download_sema);
			return -EACCES;
		}

		Adapter->bBinDownloaded = TRUE;
		Adapter->bCfgDownloaded = TRUE;
		atomic_set(&Adapter->CurrNumFreeTxDesc, 0);
		Adapter->CurrNumRecvDescs = 0;
		Adapter->downloadDDR = 0;

		/* setting the Mips to Run */
		Status = run_card_proc(Adapter);

		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Firm Download Failed\n"");
			up(&Adapter->fw_download_sema);
			up(&Adapter->NVMRdmWrmLock);
			return Status;
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG,
					DBG_LVL_ALL, ""Firm Download Over...\n"");
		}

		mdelay(10);

		/* Wait for MailBox Interrupt */
		if (StartInterruptUrb((struct bcm_interface_adapter *)Adapter->pvInterfaceAdapter))
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Unable to send interrupt...\n"");

		timeout = 5*HZ;
		Adapter->waiting_to_fw_download_done = FALSE;
		wait_event_timeout(Adapter->ioctl_fw_dnld_wait_queue,
				Adapter->waiting_to_fw_download_done, timeout);
		Adapter->fw_download_process_pid = INVALID_PID;
		Adapter->fw_download_done = TRUE;
		atomic_set(&Adapter->CurrNumFreeTxDesc, 0);
		Adapter->CurrNumRecvDescs = 0;
		Adapter->PrevNumRecvDescs = 0;
		atomic_set(&Adapter->cntrlpktCnt, 0);
		Adapter->LinkUpStatus = 0;
		Adapter->LinkStatus = 0;

		if (Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY) {
			Adapter->DriverState = FW_DOWNLOAD_DONE;
			wake_up(&Adapter->LEDInfo.notify_led_event);
		}

		if (!timeout)
			Status = -ENODEV;

		up(&Adapter->fw_download_sema);
		up(&Adapter->NVMRdmWrmLock);
		return Status;
	}

	case IOCTL_BE_BUCKET_SIZE:
		Status = 0;
		if (get_user(Adapter->BEBucketSize, (unsigned long __user *)arg))
			Status = -EFAULT;
		break;

	case IOCTL_RTPS_BUCKET_SIZE:
		Status = 0;
		if (get_user(Adapter->rtPSBucketSize, (unsigned long __user *)arg))
			Status = -EFAULT;
		break;

	case IOCTL_CHIP_RESET: {
		INT NVMAccess = down_trylock(&Adapter->NVMRdmWrmLock);
		if (NVMAccess) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "" IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\n"");
			return -EACCES;
		}

		down(&Adapter->RxAppControlQueuelock);
		Status = reset_card_proc(Adapter);
		flushAllAppQ();
		up(&Adapter->RxAppControlQueuelock);
		up(&Adapter->NVMRdmWrmLock);
		ResetCounters(Adapter);
		break;
	}

	case IOCTL_QOS_THRESHOLD: {
		USHORT uiLoopIndex;

		Status = 0;
		for (uiLoopIndex = 0; uiLoopIndex < NO_OF_QUEUES; uiLoopIndex++) {
			if (get_user(Adapter->PackInfo[uiLoopIndex].uiThreshold,
					(unsigned long __user *)arg)) {
				Status = -EFAULT;
				break;
			}
		}
		break;
	}

	case IOCTL_DUMP_PACKET_INFO:
		DumpPackInfo(Adapter);
		DumpPhsRules(&Adapter->stBCMPhsContext);
		Status = STATUS_SUCCESS;
		break;

	case IOCTL_GET_PACK_INFO:
		if (copy_to_user(argp, &Adapter->PackInfo, sizeof(struct bcm_packet_info)*NO_OF_QUEUES))
			return -EFAULT;
		Status = STATUS_SUCCESS;
		break;

	case IOCTL_BCM_SWITCH_TRANSFER_MODE: {
		UINT uiData = 0;
		if (copy_from_user(&uiData, argp, sizeof(UINT)))
			return -EFAULT;

		if (uiData) {
			/* Allow All Packets */
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SWITCH_TRANSFER_MODE: ETH_PACKET_TUNNELING_MODE\n"");
				Adapter->TransferMode = ETH_PACKET_TUNNELING_MODE;
		} else {
			/* Allow IP only Packets */
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SWITCH_TRANSFER_MODE: IP_PACKET_ONLY_MODE\n"");
			Adapter->TransferMode = IP_PACKET_ONLY_MODE;
		}
		Status = STATUS_SUCCESS;
		break;
	}

	case IOCTL_BCM_GET_DRIVER_VERSION: {
		ulong len;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		len = min_t(ulong, IoBuffer.OutputLength, strlen(DRV_VERSION) + 1);

		if (copy_to_user(IoBuffer.OutputBuffer, DRV_VERSION, len))
			return -EFAULT;
		Status = STATUS_SUCCESS;
		break;
	}

	case IOCTL_BCM_GET_CURRENT_STATUS: {
		struct bcm_link_state link_state;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""copy_from_user failed..\n"");
			return -EFAULT;
		}

		if (IoBuffer.OutputLength != sizeof(link_state)) {
			Status = -EINVAL;
			break;
		}

		memset(&link_state, 0, sizeof(link_state));
		link_state.bIdleMode = Adapter->IdleMode;
		link_state.bShutdownMode = Adapter->bShutStatus;
		link_state.ucLinkStatus = Adapter->LinkStatus;

		if (copy_to_user(IoBuffer.OutputBuffer, &link_state, min_t(size_t, sizeof(link_state), IoBuffer.OutputLength))) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy_to_user Failed..\n"");
			return -EFAULT;
		}
		Status = STATUS_SUCCESS;
		break;
	}

	case IOCTL_BCM_SET_MAC_TRACING: {
		UINT  tracing_flag;

		/* copy ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (copy_from_user(&tracing_flag, IoBuffer.InputBuffer, sizeof(UINT)))
			return -EFAULT;

		if (tracing_flag)
			Adapter->pTarangs->MacTracingEnabled = TRUE;
		else
			Adapter->pTarangs->MacTracingEnabled = FALSE;
		break;
	}

	case IOCTL_BCM_GET_DSX_INDICATION: {
		ULONG ulSFId = 0;
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength < sizeof(struct bcm_add_indication_alt)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Mismatch req: %lx needed is =0x%zx!!!"",
					IoBuffer.OutputLength, sizeof(struct bcm_add_indication_alt));
			return -EINVAL;
		}

		if (copy_from_user(&ulSFId, IoBuffer.InputBuffer, sizeof(ulSFId)))
			return -EFAULT;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Get DSX Data SF ID is =%lx\n"", ulSFId);
		get_dsx_sf_data_to_application(Adapter, ulSFId, IoBuffer.OutputBuffer);
		Status = STATUS_SUCCESS;
	}
	break;

	case IOCTL_BCM_GET_HOST_MIBS: {
		PVOID temp_buff;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength != sizeof(struct bcm_host_stats_mibs)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Length Check failed %lu %zd\n"",
					IoBuffer.OutputLength, sizeof(struct bcm_host_stats_mibs));
			return -EINVAL;
		}

		/* FIXME: HOST_STATS are too big for kmalloc (122048)! */
		temp_buff = kzalloc(sizeof(struct bcm_host_stats_mibs), GFP_KERNEL);
		if (!temp_buff)
			return STATUS_FAILURE;

		Status = ProcessGetHostMibs(Adapter, temp_buff);
		GetDroppedAppCntrlPktMibs(temp_buff, pTarang);

		if (Status != STATUS_FAILURE)
			if (copy_to_user(IoBuffer.OutputBuffer, temp_buff, sizeof(struct bcm_host_stats_mibs))) {
				kfree(temp_buff);
				return -EFAULT;
			}

		kfree(temp_buff);
		break;
	}

	case IOCTL_BCM_WAKE_UP_DEVICE_FROM_IDLE:
		if ((FALSE == Adapter->bTriedToWakeUpFromlowPowerMode) && (TRUE == Adapter->IdleMode)) {
			Adapter->usIdleModePattern = ABORT_IDLE_MODE;
			Adapter->bWakeUpDevice = TRUE;
			wake_up(&Adapter->process_rx_cntrlpkt);
		}

		Status = STATUS_SUCCESS;
		break;

	case IOCTL_BCM_BULK_WRM: {
		struct bcm_bulk_wrm_buffer *pBulkBuffer;
		UINT uiTempVar = 0;
		PCHAR pvBuffer = NULL;

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device in Idle/Shutdown Mode, Blocking Wrms\n"");
			Status = -EACCES;
			break;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength < sizeof(ULONG) * 2)
			return -EINVAL;

		pvBuffer = memdup_user(IoBuffer.InputBuffer,
				       IoBuffer.InputLength);
		if (IS_ERR(pvBuffer))
			return PTR_ERR(pvBuffer);

		pBulkBuffer = (struct bcm_bulk_wrm_buffer *)pvBuffer;

		if (((ULONG)pBulkBuffer->Register & 0x0F000000) != 0x0F000000 ||
			((ULONG)pBulkBuffer->Register & 0x3)) {
			BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM Done On invalid Address : %x Access Denied.\n"", (int)pBulkBuffer->Register);
			kfree(pvBuffer);
			Status = -EINVAL;
			break;
		}

		uiTempVar = pBulkBuffer->Register & EEPROM_REJECT_MASK;
		if (!((Adapter->pstargetparams->m_u32Customize)&VSG_MODE) &&
			((uiTempVar == EEPROM_REJECT_REG_1) ||
				(uiTempVar == EEPROM_REJECT_REG_2) ||
				(uiTempVar == EEPROM_REJECT_REG_3) ||
				(uiTempVar == EEPROM_REJECT_REG_4)) &&
			(cmd == IOCTL_BCM_REGISTER_WRITE)) {

			kfree(pvBuffer);
			BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""EEPROM Access Denied, not in VSG Mode\n"");
			Status = -EFAULT;
			break;
		}

		if (pBulkBuffer->SwapEndian == FALSE)
			Status = wrmWithLock(Adapter, (UINT)pBulkBuffer->Register, (PCHAR)pBulkBuffer->Values, IoBuffer.InputLength - 2*sizeof(ULONG));
		else
			Status = wrmaltWithLock(Adapter, (UINT)pBulkBuffer->Register, (PUINT)pBulkBuffer->Values, IoBuffer.InputLength - 2*sizeof(ULONG));

		if (Status != STATUS_SUCCESS)
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM Failed\n"");

		kfree(pvBuffer);
		break;
	}

	case IOCTL_BCM_GET_NVM_SIZE:
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (Adapter->eNVMType == NVM_EEPROM || Adapter->eNVMType == NVM_FLASH) {
			if (copy_to_user(IoBuffer.OutputBuffer, &Adapter->uiNVMDSDSize, sizeof(UINT)))
				return -EFAULT;
		}

		Status = STATUS_SUCCESS;
		break;

	case IOCTL_BCM_CAL_INIT: {
		UINT uiSectorSize = 0 ;
		if (Adapter->eNVMType == NVM_FLASH) {
			if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
				return -EFAULT;

			if (copy_from_user(&uiSectorSize, IoBuffer.InputBuffer, sizeof(UINT)))
				return -EFAULT;

			if ((uiSectorSize < MIN_SECTOR_SIZE) || (uiSectorSize > MAX_SECTOR_SIZE)) {
				if (copy_to_user(IoBuffer.OutputBuffer, &Adapter->uiSectorSize,
							sizeof(UINT)))
					return -EFAULT;
			} else {
				if (IsFlash2x(Adapter)) {
					if (copy_to_user(IoBuffer.OutputBuffer,	&Adapter->uiSectorSize, sizeof(UINT)))
						return -EFAULT;
				} else {
					if ((TRUE == Adapter->bShutStatus) || (TRUE == Adapter->IdleMode)) {
						BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device is in Idle/Shutdown Mode\n"");
						return -EACCES;
					}

					Adapter->uiSectorSize = uiSectorSize;
					BcmUpdateSectorSize(Adapter, Adapter->uiSectorSize);
				}
			}
			Status = STATUS_SUCCESS;
		} else {
			Status = STATUS_FAILURE;
		}
	}
	break;

	case IOCTL_BCM_SET_DEBUG:
#ifdef DEBUG
	{
		struct bcm_user_debug_state sUserDebugState;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""In SET_DEBUG ioctl\n"");
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (copy_from_user(&sUserDebugState, IoBuffer.InputBuffer, sizeof(struct bcm_user_debug_state)))
			return -EFAULT;

		BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""IOCTL_BCM_SET_DEBUG: OnOff=%d Type = 0x%x "",
				sUserDebugState.OnOff, sUserDebugState.Type);
		/* sUserDebugState.Subtype <<= 1; */
		sUserDebugState.Subtype = 1 << sUserDebugState.Subtype;
		BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""actual Subtype=0x%x\n"", sUserDebugState.Subtype);

		/* Update new 'DebugState' in the Adapter */
		Adapter->stDebugState.type |= sUserDebugState.Type;
		/* Subtype: A bitmap of 32 bits for Subtype per Type.
		 * Valid indexes in 'subtype' array: 1,2,4,8
		 * corresponding to valid Type values. Hence we can use the 'Type' field
		 * as the index value, ignoring the array entries 0,3,5,6,7 !
		 */
		if (sUserDebugState.OnOff)
			Adapter->stDebugState.subtype[sUserDebugState.Type] |= sUserDebugState.Subtype;
		else
			Adapter->stDebugState.subtype[sUserDebugState.Type] &= ~sUserDebugState.Subtype;

		BCM_SHOW_DEBUG_BITMAP(Adapter);
	}
#endif
	break;

	case IOCTL_BCM_NVM_READ:
	case IOCTL_BCM_NVM_WRITE: {
		struct bcm_nvm_readwrite stNVMReadWrite;
		PUCHAR pReadData = NULL;
		ULONG ulDSDMagicNumInUsrBuff = 0;
		struct timeval tv0, tv1;
		memset(&tv0, 0, sizeof(struct timeval));
		memset(&tv1, 0, sizeof(struct timeval));
		if ((Adapter->eNVMType == NVM_FLASH) && (Adapter->uiFlashLayoutMajorVersion == 0)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""The Flash Control Section is Corrupted. Hence Rejection on NVM Read/Write\n"");
			return -EFAULT;
		}

		if (IsFlash2x(Adapter)) {
			if ((Adapter->eActiveDSD != DSD0) &&
				(Adapter->eActiveDSD != DSD1) &&
				(Adapter->eActiveDSD != DSD2)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""No DSD is active..hence NVM Command is blocked"");
				return STATUS_FAILURE;
			}
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (copy_from_user(&stNVMReadWrite,
					(IOCTL_BCM_NVM_READ == cmd) ? IoBuffer.OutputBuffer : IoBuffer.InputBuffer,
					sizeof(struct bcm_nvm_readwrite)))
			return -EFAULT;

		/*
		 * Deny the access if the offset crosses the cal area limit.
		 */
		if (stNVMReadWrite.uiNumBytes > Adapter->uiNVMDSDSize)
			return STATUS_FAILURE;

		if (stNVMReadWrite.uiOffset > Adapter->uiNVMDSDSize - stNVMReadWrite.uiNumBytes) {
			/* BCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,""Can't allow access beyond NVM Size: 0x%x 0x%x\n"", stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes); */
			return STATUS_FAILURE;
		}

		pReadData = memdup_user(stNVMReadWrite.pBuffer,
					stNVMReadWrite.uiNumBytes);
		if (IS_ERR(pReadData))
			return PTR_ERR(pReadData);

		do_gettimeofday(&tv0);
		if (IOCTL_BCM_NVM_READ == cmd) {
			down(&Adapter->NVMRdmWrmLock);

			if ((Adapter->IdleMode == TRUE) ||
				(Adapter->bShutStatus == TRUE) ||
				(Adapter->bPreparingForLowPowerMode == TRUE)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadData);
				return -EACCES;
			}

			Status = BeceemNVMRead(Adapter, (PUINT)pReadData, stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes);
			up(&Adapter->NVMRdmWrmLock);

			if (Status != STATUS_SUCCESS) {
				kfree(pReadData);
				return Status;
			}

			if (copy_to_user(stNVMReadWrite.pBuffer, pReadData, stNVMReadWrite.uiNumBytes)) {
				kfree(pReadData);
				return -EFAULT;
			}
		} else {
			down(&Adapter->NVMRdmWrmLock);

			if ((Adapter->IdleMode == TRUE) ||
				(Adapter->bShutStatus == TRUE) ||
				(Adapter->bPreparingForLowPowerMode == TRUE)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadData);
				return -EACCES;
			}

			Adapter->bHeaderChangeAllowed = TRUE;
			if (IsFlash2x(Adapter)) {
				/*
				 *			New Requirement:-
				 *			DSD section updation will be allowed in two case:-
				 *			1.  if DSD sig is present in DSD header means dongle is ok and updation is fruitfull
				 *			2.  if point 1 failes then user buff should have DSD sig. this point ensures that if dongle is
				 *			      corrupted then user space program first modify the DSD header with valid DSD sig so
				 *			      that this as well as further write may be worthwhile.
				 *
				 *			 This restriction has been put assuming that if DSD sig is corrupted, DSD
				 *			 data won't be considered valid.
				 */

				Status = BcmFlash2xCorruptSig(Adapter, Adapter->eActiveDSD);
				if (Status != STATUS_SUCCESS) {
					if (((stNVMReadWrite.uiOffset + stNVMReadWrite.uiNumBytes) != Adapter->uiNVMDSDSize) ||
						(stNVMReadWrite.uiNumBytes < SIGNATURE_SIZE)) {

						BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""DSD Sig is present neither in Flash nor User provided Input.."");
						up(&Adapter->NVMRdmWrmLock);
						kfree(pReadData);
						return Status;
					}

					ulDSDMagicNumInUsrBuff = ntohl(*(PUINT)(pReadData + stNVMReadWrite.uiNumBytes - SIGNATURE_SIZE));
					if (ulDSDMagicNumInUsrBuff != DSD_IMAGE_MAGIC_NUMBER) {
						BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""DSD Sig is present neither in Flash nor User provided Input.."");
						up(&Adapter->NVMRdmWrmLock);
						kfree(pReadData);
						return Status;
					}
				}
			}

			Status = BeceemNVMWrite(Adapter, (PUINT)pReadData, stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes, stNVMReadWrite.bVerify);
			if (IsFlash2x(Adapter))
				BcmFlash2xWriteSig(Adapter, Adapter->eActiveDSD);

			Adapter->bHeaderChangeAllowed = FALSE;

			up(&Adapter->NVMRdmWrmLock);

			if (Status != STATUS_SUCCESS) {
				kfree(pReadData);
				return Status;
			}
		}

		do_gettimeofday(&tv1);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "" timetaken by Write/read :%ld msec\n"", (tv1.tv_sec - tv0.tv_sec)*1000 + (tv1.tv_usec - tv0.tv_usec)/1000);

		kfree(pReadData);
		return STATUS_SUCCESS;
	}

	case IOCTL_BCM_FLASH2X_SECTION_READ: {
		struct bcm_flash2x_readwrite sFlash2xRead = {0};
		PUCHAR pReadBuff = NULL ;
		UINT NOB = 0;
		UINT BuffSize = 0;
		UINT ReadBytes = 0;
		UINT ReadOffset = 0;
		void __user *OutPutBuff;

		if (IsFlash2x(Adapter) != TRUE)	{
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_FLASH2X_SECTION_READ Called"");
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		/* Reading FLASH 2.x READ structure */
		if (copy_from_user(&sFlash2xRead, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_readwrite)))
			return -EFAULT;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.Section :%x"", sFlash2xRead.Section);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.offset :%x"", sFlash2xRead.offset);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.numOfBytes :%x"", sFlash2xRead.numOfBytes);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.bVerify :%x\n"", sFlash2xRead.bVerify);

		/* This was internal to driver for raw read. now it has ben exposed to user space app. */
		if (validateFlash2xReadWrite(Adapter, &sFlash2xRead) == FALSE)
			return STATUS_FAILURE;

		NOB = sFlash2xRead.numOfBytes;
		if (NOB > Adapter->uiSectorSize)
			BuffSize = Adapter->uiSectorSize;
		else
			BuffSize = NOB;

		ReadOffset = sFlash2xRead.offset ;
		OutPutBuff = IoBuffer.OutputBuffer;
		pReadBuff = (PCHAR)kzalloc(BuffSize , GFP_KERNEL);

		if (pReadBuff == NULL) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Memory allocation failed for Flash 2.x Read Structure"");
			return -ENOMEM;
		}
		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			kfree(pReadBuff);
			return -EACCES;
		}

		while (NOB) {
			if (NOB > Adapter->uiSectorSize)
				ReadBytes = Adapter->uiSectorSize;
			else
				ReadBytes = NOB;

			/* Reading the data from Flash 2.x */
			Status = BcmFlash2xBulkRead(Adapter, (PUINT)pReadBuff, sFlash2xRead.Section, ReadOffset, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Flash 2x read err with Status :%d"", Status);
				break;
			}

			BCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pReadBuff, ReadBytes);

			Status = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Copy to use failed with status :%d"", Status);
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadBuff);
				return -EFAULT;
			}
			NOB = NOB - ReadBytes;
			if (NOB) {
				ReadOffset = ReadOffset + ReadBytes;
				OutPutBuff = OutPutBuff + ReadBytes ;
			}
		}

		up(&Adapter->NVMRdmWrmLock);
		kfree(pReadBuff);
	}
	break;

	case IOCTL_BCM_FLASH2X_SECTION_WRITE: {
		struct bcm_flash2x_readwrite sFlash2xWrite = {0};
		PUCHAR pWriteBuff;
		void __user *InputAddr;
		UINT NOB = 0;
		UINT BuffSize = 0;
		UINT WriteOffset = 0;
		UINT WriteBytes = 0;

		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		/* First make this False so that we can enable the Sector Permission Check in BeceemFlashBulkWrite */
		Adapter->bAllDSDWriteAllow = FALSE;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_FLASH2X_SECTION_WRITE Called"");

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		/* Reading FLASH 2.x READ structure */
		if (copy_from_user(&sFlash2xWrite, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_readwrite)))
			return -EFAULT;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.Section :%x"", sFlash2xWrite.Section);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.offset :%d"", sFlash2xWrite.offset);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.numOfBytes :%x"", sFlash2xWrite.numOfBytes);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.bVerify :%x\n"", sFlash2xWrite.bVerify);

		if ((sFlash2xWrite.Section != VSA0) && (sFlash2xWrite.Section != VSA1) && (sFlash2xWrite.Section != VSA2)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Only VSA write is allowed"");
			return -EINVAL;
		}

		if (validateFlash2xReadWrite(Adapter, &sFlash2xWrite) == FALSE)
			return STATUS_FAILURE;

		InputAddr = sFlash2xWrite.pDataBuff;
		WriteOffset = sFlash2xWrite.offset;
		NOB = sFlash2xWrite.numOfBytes;

		if (NOB > Adapter->uiSectorSize)
			BuffSize = Adapter->uiSectorSize;
		else
			BuffSize = NOB ;

		pWriteBuff = kmalloc(BuffSize, GFP_KERNEL);

		if (pWriteBuff == NULL)
			return -ENOMEM;

		/* extracting the remainder of the given offset. */
		WriteBytes = Adapter->uiSectorSize;
		if (WriteOffset % Adapter->uiSectorSize)
			WriteBytes = Adapter->uiSectorSize - (WriteOffset % Adapter->uiSectorSize);

		if (NOB < WriteBytes)
			WriteBytes = NOB;

		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			kfree(pWriteBuff);
			return -EACCES;
		}

		BcmFlash2xCorruptSig(Adapter, sFlash2xWrite.Section);
		do {
			Status = copy_from_user(pWriteBuff, InputAddr, WriteBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy to user failed with status :%d"", Status);
				up(&Adapter->NVMRdmWrmLock);
				kfree(pWriteBuff);
				return -EFAULT;
			}
			BCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pWriteBuff, WriteBytes);

			/* Writing the data from Flash 2.x */
			Status = BcmFlash2xBulkWrite(Adapter, (PUINT)pWriteBuff, sFlash2xWrite.Section, WriteOffset, WriteBytes, sFlash2xWrite.bVerify);

			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash 2x read err with Status :%d"", Status);
				break;
			}

			NOB = NOB - WriteBytes;
			if (NOB) {
				WriteOffset = WriteOffset + WriteBytes;
				InputAddr = InputAddr + WriteBytes;
				if (NOB > Adapter->uiSectorSize)
					WriteBytes = Adapter->uiSectorSize;
				else
					WriteBytes = NOB;
			}
		} while (NOB > 0);

		BcmFlash2xWriteSig(Adapter, sFlash2xWrite.Section);
		up(&Adapter->NVMRdmWrmLock);
		kfree(pWriteBuff);
	}
	break;

	case IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP: {
		struct bcm_flash2x_bitmap *psFlash2xBitMap;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP Called"");

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength != sizeof(struct bcm_flash2x_bitmap))
			return -EINVAL;

		psFlash2xBitMap = kzalloc(sizeof(struct bcm_flash2x_bitmap), GFP_KERNEL);
		if (psFlash2xBitMap == NULL) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Memory is not available"");
			return -ENOMEM;
		}

		/* Reading the Flash Sectio Bit map */
		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			kfree(psFlash2xBitMap);
			return -EACCES;
		}

		BcmGetFlash2xSectionalBitMap(Adapter, psFlash2xBitMap);
		up(&Adapter->NVMRdmWrmLock);
		if (copy_to_user(IoBuffer.OutputBuffer, psFlash2xBitMap, sizeof(struct bcm_flash2x_bitmap))) {
			kfree(psFlash2xBitMap);
			return -EFAULT;
		}

		kfree(psFlash2xBitMap);
	}
	break;

	case IOCTL_BCM_SET_ACTIVE_SECTION: {
		enum bcm_flash2x_section_val eFlash2xSectionVal = 0;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SET_ACTIVE_SECTION Called"");

		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed"");
			return -EFAULT;
		}

		Status = copy_from_user(&eFlash2xSectionVal, IoBuffer.InputBuffer, sizeof(INT));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of flash section val failed"");
			return -EFAULT;
		}

		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			return -EACCES;
		}

		Status = BcmSetActiveSection(Adapter, eFlash2xSectionVal);
		if (Status)
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Failed to make it's priority Highest. Status %d"", Status);

		up(&Adapter->NVMRdmWrmLock);
	}
	break;

	case IOCTL_BCM_IDENTIFY_ACTIVE_SECTION: {
		/* Right Now we are taking care of only DSD */
		Adapter->bAllDSDWriteAllow = FALSE;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_IDENTIFY_ACTIVE_SECTION called"");
		Status = STATUS_SUCCESS;
	}
	break;

	case IOCTL_BCM_COPY_SECTION: {
		struct bcm_flash2x_copy_section sCopySectStrut = {0};
		Status = STATUS_SUCCESS;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_COPY_SECTION  Called"");

		Adapter->bAllDSDWriteAllow = FALSE;
		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed Status :%d"", Status);
			return -EFAULT;
		}

		Status = copy_from_user(&sCopySectStrut, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_copy_section));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of Copy_Section_Struct failed with Status :%d"", Status);
			return -EFAULT;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Source SEction :%x"", sCopySectStrut.SrcSection);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Destination SEction :%x"", sCopySectStrut.DstSection);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""offset :%x"", sCopySectStrut.offset);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""NOB :%x"", sCopySectStrut.numOfBytes);

		if (IsSectionExistInFlash(Adapter, sCopySectStrut.SrcSection) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Source Section<%x> does not exixt in Flash "", sCopySectStrut.SrcSection);
			return -EINVAL;
		}

		if (IsSectionExistInFlash(Adapter, sCopySectStrut.DstSection) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Destinatio Section<%x> does not exixt in Flash "", sCopySectStrut.DstSection);
			return -EINVAL;
		}

		if (sCopySectStrut.SrcSection == sCopySectStrut.DstSection) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Source and Destination section should be different"");
			return -EINVAL;
		}

		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			return -EACCES;
		}

		if (sCopySectStrut.SrcSection == ISO_IMAGE1 || sCopySectStrut.SrcSection == ISO_IMAGE2) {
			if (IsNonCDLessDevice(Adapter)) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device is Non-CDLess hence won't have ISO !!"");
				Status = -EINVAL;
			} else if (sCopySectStrut.numOfBytes == 0) {
				Status = BcmCopyISO(Adapter, sCopySectStrut);
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Partial Copy of ISO section is not Allowed.."");
				Status = STATUS_FAILURE;
			}
			up(&Adapter->NVMRdmWrmLock);
			return Status;
		}

		Status = BcmCopySection(Adapter, sCopySectStrut.SrcSection,
					sCopySectStrut.DstSection, sCopySectStrut.offset, sCopySectStrut.numOfBytes);
		up(&Adapter->NVMRdmWrmLock);
	}
	break;

	case IOCTL_BCM_GET_FLASH_CS_INFO: {
		Status = STATUS_SUCCESS;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "" IOCTL_BCM_GET_FLASH_CS_INFO Called"");

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed"");
			return -EFAULT;
		}

		if (Adapter->eNVMType != NVM_FLASH) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Connected device does not have flash"");
			Status = -EINVAL;
			break;
		}

		if (IsFlash2x(Adapter) == TRUE) {
			if (IoBuffer.OutputLength < sizeof(struct bcm_flash2x_cs_info))
				return -EINVAL;

			if (copy_to_user(IoBuffer.OutputBuffer, Adapter->psFlash2xCSInfo, sizeof(struct bcm_flash2x_cs_info)))
				return -EFAULT;
		} else {
			if (IoBuffer.OutputLength < sizeof(struct bcm_flash_cs_info))
				return -EINVAL;

			if (copy_to_user(IoBuffer.OutputBuffer, Adapter->psFlashCSInfo, sizeof(struct bcm_flash_cs_info)))
				return -EFAULT;
		}
	}
	break;

	case IOCTL_BCM_SELECT_DSD: {
		UINT SectOfset = 0;
		enum bcm_flash2x_section_val eFlash2xSectionVal;
		eFlash2xSectionVal = NO_SECTION_VAL;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SELECT_DSD Called"");

		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed"");
			return -EFAULT;
		}
		Status = copy_from_user(&eFlash2xSectionVal, IoBuffer.InputBuffer, sizeof(INT));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of flash section val failed"");
			return -EFAULT;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Read Section :%d"", eFlash2xSectionVal);
		if ((eFlash2xSectionVal != DSD0) &&
			(eFlash2xSectionVal != DSD1) &&
			(eFlash2xSectionVal != DSD2)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Passed section<%x> is not DSD section"", eFlash2xSectionVal);
			return STATUS_FAILURE;
		}

		SectOfset = BcmGetSectionValStartOffset(Adapter, eFlash2xSectionVal);
		if (SectOfset == INVALID_OFFSET) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Provided Section val <%d> does not exixt in Flash 2.x"", eFlash2xSectionVal);
			return -EINVAL;
		}

		Adapter->bAllDSDWriteAllow = TRUE;
		Adapter->ulFlashCalStart = SectOfset;
		Adapter->eActiveDSD = eFlash2xSectionVal;
	}
	Status = STATUS_SUCCESS;
	break;

	case IOCTL_BCM_NVM_RAW_READ: {
		struct bcm_nvm_readwrite stNVMRead;
		INT NOB ;
		INT BuffSize ;
		INT ReadOffset = 0;
		UINT ReadBytes = 0 ;
		PUCHAR pReadBuff;
		void __user *OutPutBuff;

		if (Adapter->eNVMType != NVM_FLASH) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""NVM TYPE is not Flash"");
			return -EINVAL;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""copy_from_user 1 failed\n"");
			return -EFAULT;
		}

		if (copy_from_user(&stNVMRead, IoBuffer.OutputBuffer, sizeof(struct bcm_nvm_readwrite)))
			return -EFAULT;

		NOB = stNVMRead.uiNumBytes;
		/* In Raw-Read max Buff size : 64MB */

		if (NOB > DEFAULT_BUFF_SIZE)
			BuffSize = DEFAULT_BUFF_SIZE;
		else
			BuffSize = NOB;

		ReadOffset = stNVMRead.uiOffset;
		OutPutBuff = stNVMRead.pBuffer;

		pReadBuff = kzalloc(BuffSize , GFP_KERNEL);
		if (pReadBuff == NULL) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Memory allocation failed for Flash 2.x Read Structure"");
			Status = -ENOMEM;
			break;
		}
		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			kfree(pReadBuff);
			up(&Adapter->NVMRdmWrmLock);
			return -EACCES;
		}

		Adapter->bFlashRawRead = TRUE;

		while (NOB) {
			if (NOB > DEFAULT_BUFF_SIZE)
				ReadBytes = DEFAULT_BUFF_SIZE;
			else
				ReadBytes = NOB;

			/* Reading the data from Flash 2.x */
			Status = BeceemNVMRead(Adapter, (PUINT)pReadBuff, ReadOffset, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash 2x read err with Status :%d"", Status);
				break;
			}

			BCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pReadBuff, ReadBytes);

			Status = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy to use failed with status :%d"", Status);
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadBuff);
				return -EFAULT;
			}
			NOB = NOB - ReadBytes;
			if (NOB) {
				ReadOffset = ReadOffset + ReadBytes;
				OutPutBuff = OutPutBuff + ReadBytes;
			}
		}
		Adapter->bFlashRawRead = FALSE;
		up(&Adapter->NVMRdmWrmLock);
		kfree(pReadBuff);
		break;
	}

	case IOCTL_BCM_CNTRLMSG_MASK: {
		ULONG RxCntrlMsgBitMask = 0;

		/* Copy Ioctl Buffer structure */
		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""copy of Ioctl buffer is failed from user space"");
			return -EFAULT;
		}

		if (IoBuffer.InputLength != sizeof(unsigned long)) {
			Status = -EINVAL;
			break;
		}

		Status = copy_from_user(&RxCntrlMsgBitMask, IoBuffer.InputBuffer, IoBuffer.InputLength);
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""copy of control bit mask failed from user space"");
			return -EFAULT;
		}
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\n Got user defined cntrl msg bit mask :%lx"", RxCntrlMsgBitMask);
		pTarang->RxCntrlMsgBitMask = RxCntrlMsgBitMask;
	}
	break;

	case IOCTL_BCM_GET_DEVICE_DRIVER_INFO: {
		struct bcm_driver_info DevInfo;
 
 		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Called IOCTL_BCM_GET_DEVICE_DRIVER_INFO\n"");
 
//fix_flaw_line_below:
//		memset(&DevInfo, 0, sizeof(DevInfo));
 		DevInfo.MaxRDMBufferSize = BUFFER_4K;
 		DevInfo.u32DSDStartOffset = EEPROM_CALPARAM_START;
 		DevInfo.u32RxAlignmentCorrection = 0;
		DevInfo.u32NVMType = Adapter->eNVMType;
		DevInfo.u32InterfaceType = BCM_USB;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength < sizeof(DevInfo))
			return -EINVAL;

		if (copy_to_user(IoBuffer.OutputBuffer, &DevInfo, sizeof(DevInfo)))
			return -EFAULT;
	}
	break;

	case IOCTL_BCM_TIME_SINCE_NET_ENTRY: {
		struct bcm_time_elapsed stTimeElapsedSinceNetEntry = {0};

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_TIME_SINCE_NET_ENTRY called"");

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength < sizeof(struct bcm_time_elapsed))
			return -EINVAL;

		stTimeElapsedSinceNetEntry.ul64TimeElapsedSinceNetEntry = get_seconds() - Adapter->liTimeSinceLastNetEntry;

		if (copy_to_user(IoBuffer.OutputBuffer, &stTimeElapsedSinceNetEntry, sizeof(struct bcm_time_elapsed)))
			return -EFAULT;
	}
	break;

	case IOCTL_CLOSE_NOTIFICATION:
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_CLOSE_NOTIFICATION"");
		break;

	default:
		pr_info(DRV_NAME "": unknown ioctl cmd=%#x\n"", cmd);
		Status = STATUS_FAILURE;
		break;
	}
	return Status;
}
",179134,"static long bcm_char_ioctl(struct file *filp, UINT cmd, ULONG arg)
{
	struct bcm_tarang_data *pTarang = filp->private_data;
	void __user *argp = (void __user *)arg;
	struct bcm_mini_adapter *Adapter = pTarang->Adapter;
	INT Status = STATUS_FAILURE;
	int timeout = 0;
	struct bcm_ioctl_buffer IoBuffer;
	int bytes;

	BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Parameters Passed to control IOCTL cmd=0x%X arg=0x%lX"", cmd, arg);

	if (_IOC_TYPE(cmd) != BCM_IOCTL)
		return -EFAULT;
	if (_IOC_DIR(cmd) & _IOC_READ)
		Status = !access_ok(VERIFY_WRITE, argp, _IOC_SIZE(cmd));
	else if (_IOC_DIR(cmd) & _IOC_WRITE)
		Status = !access_ok(VERIFY_READ, argp, _IOC_SIZE(cmd));
	else if (_IOC_NONE == (_IOC_DIR(cmd) & _IOC_NONE))
		Status = STATUS_SUCCESS;

	if (Status)
		return -EFAULT;

	if (Adapter->device_removed)
		return -EFAULT;

	if (FALSE == Adapter->fw_download_done) {
		switch (cmd) {
		case IOCTL_MAC_ADDR_REQ:
		case IOCTL_LINK_REQ:
		case IOCTL_CM_REQUEST:
		case IOCTL_SS_INFO_REQ:
		case IOCTL_SEND_CONTROL_MESSAGE:
		case IOCTL_IDLE_REQ:
		case IOCTL_BCM_GPIO_SET_REQUEST:
		case IOCTL_BCM_GPIO_STATUS_REQUEST:
			return -EACCES;
		default:
			break;
		}
	}

	Status = vendorextnIoctl(Adapter, cmd, arg);
	if (Status != CONTINUE_COMMON_PATH)
		return Status;

	switch (cmd) {
	/* Rdms for Swin Idle... */
	case IOCTL_BCM_REGISTER_READ_PRIVATE: {
		struct bcm_rdm_buffer sRdmBuffer = {0};
		PCHAR temp_buff;
		UINT Bufflen;
		u16 temp_value;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sRdmBuffer))
			return -EINVAL;

		if (copy_from_user(&sRdmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if (IoBuffer.OutputLength > USHRT_MAX ||
			IoBuffer.OutputLength == 0) {
			return -EINVAL;
		}

		Bufflen = IoBuffer.OutputLength;
		temp_value = 4 - (Bufflen % 4);
		Bufflen += temp_value % 4;

		temp_buff = kmalloc(Bufflen, GFP_KERNEL);
		if (!temp_buff)
			return -ENOMEM;

		bytes = rdmalt(Adapter, (UINT)sRdmBuffer.Register,
				(PUINT)temp_buff, Bufflen);
		if (bytes > 0) {
			Status = STATUS_SUCCESS;
			if (copy_to_user(IoBuffer.OutputBuffer, temp_buff, bytes)) {
				kfree(temp_buff);
				return -EFAULT;
			}
		} else {
			Status = bytes;
		}

		kfree(temp_buff);
		break;
	}

	case IOCTL_BCM_REGISTER_WRITE_PRIVATE: {
		struct bcm_wrm_buffer sWrmBuffer = {0};
		UINT uiTempVar = 0;
		/* Copy Ioctl Buffer structure */

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sWrmBuffer))
			return -EINVAL;

		/* Get WrmBuffer structure */
		if (copy_from_user(&sWrmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		uiTempVar = sWrmBuffer.Register & EEPROM_REJECT_MASK;
		if (!((Adapter->pstargetparams->m_u32Customize) & VSG_MODE) &&
			((uiTempVar == EEPROM_REJECT_REG_1) ||
				(uiTempVar == EEPROM_REJECT_REG_2) ||
				(uiTempVar == EEPROM_REJECT_REG_3) ||
				(uiTempVar == EEPROM_REJECT_REG_4))) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""EEPROM Access Denied, not in VSG Mode\n"");
			return -EFAULT;
		}

		Status = wrmalt(Adapter, (UINT)sWrmBuffer.Register,
				(PUINT)sWrmBuffer.Data, sizeof(ULONG));

		if (Status == STATUS_SUCCESS) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""WRM Done\n"");
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""WRM Failed\n"");
			Status = -EFAULT;
		}
		break;
	}

	case IOCTL_BCM_REGISTER_READ:
	case IOCTL_BCM_EEPROM_REGISTER_READ: {
		struct bcm_rdm_buffer sRdmBuffer = {0};
		PCHAR temp_buff = NULL;
		UINT uiTempVar = 0;
		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device in Idle Mode, Blocking Rdms\n"");
			return -EACCES;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sRdmBuffer))
			return -EINVAL;

		if (copy_from_user(&sRdmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if (IoBuffer.OutputLength > USHRT_MAX ||
			IoBuffer.OutputLength == 0) {
			return -EINVAL;
		}

		temp_buff = kmalloc(IoBuffer.OutputLength, GFP_KERNEL);
		if (!temp_buff)
			return STATUS_FAILURE;

		if ((((ULONG)sRdmBuffer.Register & 0x0F000000) != 0x0F000000) ||
			((ULONG)sRdmBuffer.Register & 0x3)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""RDM Done On invalid Address : %x Access Denied.\n"",
					(int)sRdmBuffer.Register);

			kfree(temp_buff);
			return -EINVAL;
		}

		uiTempVar = sRdmBuffer.Register & EEPROM_REJECT_MASK;
		bytes = rdmaltWithLock(Adapter, (UINT)sRdmBuffer.Register, (PUINT)temp_buff, IoBuffer.OutputLength);

		if (bytes > 0) {
			Status = STATUS_SUCCESS;
			if (copy_to_user(IoBuffer.OutputBuffer, temp_buff, bytes)) {
				kfree(temp_buff);
				return -EFAULT;
			}
		} else {
			Status = bytes;
		}

		kfree(temp_buff);
		break;
	}
	case IOCTL_BCM_REGISTER_WRITE:
	case IOCTL_BCM_EEPROM_REGISTER_WRITE: {
		struct bcm_wrm_buffer sWrmBuffer = {0};
		UINT uiTempVar = 0;

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device in Idle Mode, Blocking Wrms\n"");
			return -EACCES;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sWrmBuffer))
			return -EINVAL;

		/* Get WrmBuffer structure */
		if (copy_from_user(&sWrmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if ((((ULONG)sWrmBuffer.Register & 0x0F000000) != 0x0F000000) ||
			((ULONG)sWrmBuffer.Register & 0x3)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM Done On invalid Address : %x Access Denied.\n"", (int)sWrmBuffer.Register);
			return -EINVAL;
		}

		uiTempVar = sWrmBuffer.Register & EEPROM_REJECT_MASK;
		if (!((Adapter->pstargetparams->m_u32Customize) & VSG_MODE) &&
				((uiTempVar == EEPROM_REJECT_REG_1) ||
				(uiTempVar == EEPROM_REJECT_REG_2) ||
				(uiTempVar == EEPROM_REJECT_REG_3) ||
				(uiTempVar == EEPROM_REJECT_REG_4)) &&
				(cmd == IOCTL_BCM_REGISTER_WRITE)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""EEPROM Access Denied, not in VSG Mode\n"");
				return -EFAULT;
		}

		Status = wrmaltWithLock(Adapter, (UINT)sWrmBuffer.Register,
					(PUINT)sWrmBuffer.Data, sWrmBuffer.Length);

		if (Status == STATUS_SUCCESS) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL, ""WRM Done\n"");
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""WRM Failed\n"");
			Status = -EFAULT;
		}
		break;
	}
	case IOCTL_BCM_GPIO_SET_REQUEST: {
		UCHAR ucResetValue[4];
		UINT value = 0;
		UINT uiBit = 0;
		UINT uiOperation = 0;
		struct bcm_gpio_info gpio_info = {0};

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""GPIO Can't be set/clear in Low power Mode"");
			return -EACCES;
		}

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_info))
			return -EINVAL;

		if (copy_from_user(&gpio_info, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		uiBit  = gpio_info.uiGpioNumber;
		uiOperation = gpio_info.uiGpioValue;
		value = (1<<uiBit);

		if (IsReqGpioIsLedInNVM(Adapter, value) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Sorry, Requested GPIO<0x%X> is not correspond to LED !!!"", value);
			Status = -EINVAL;
			break;
		}

		/* Set - setting 1 */
		if (uiOperation) {
			/* Set the gpio output register */
			Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_SET_REG, (PUINT)(&value), sizeof(UINT));

			if (Status == STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Set the GPIO bit\n"");
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Failed to set the %dth GPIO\n"", uiBit);
				break;
			}
		} else {
			/* Set the gpio output register */
			Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_CLR_REG, (PUINT)(&value), sizeof(UINT));

			if (Status == STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Set the GPIO bit\n"");
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Failed to clear the %dth GPIO\n"", uiBit);
				break;
			}
		}

		bytes = rdmaltWithLock(Adapter, (UINT)GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));
		if (bytes < 0) {
			Status = bytes;
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""GPIO_MODE_REGISTER read failed"");
			break;
		} else {
			Status = STATUS_SUCCESS;
		}

		/* Set the gpio mode register to output */
		*(UINT *)ucResetValue |= (1<<uiBit);
		Status = wrmaltWithLock(Adapter, GPIO_MODE_REGISTER,
					(PUINT)ucResetValue, sizeof(UINT));

		if (Status == STATUS_SUCCESS) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Set the GPIO to output Mode\n"");
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Failed to put GPIO in Output Mode\n"");
			break;
		}
	}
	break;

	case BCM_LED_THREAD_STATE_CHANGE_REQ: {
		struct bcm_user_thread_req threadReq = {0};
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""User made LED thread InActive"");

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""GPIO Can't be set/clear in Low power Mode"");
			Status = -EACCES;
			break;
		}

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(threadReq))
			return -EINVAL;

		if (copy_from_user(&threadReq, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		/* if LED thread is running(Actively or Inactively) set it state to make inactive */
		if (Adapter->LEDInfo.led_thread_running) {
			if (threadReq.ThreadState == LED_THREAD_ACTIVATION_REQ) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Activating thread req"");
				Adapter->DriverState = LED_THREAD_ACTIVE;
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""DeActivating Thread req....."");
				Adapter->DriverState = LED_THREAD_INACTIVE;
			}

			/* signal thread. */
			wake_up(&Adapter->LEDInfo.notify_led_event);
		}
	}
	break;

	case IOCTL_BCM_GPIO_STATUS_REQUEST: {
		ULONG uiBit = 0;
		UCHAR ucRead[4];
		struct bcm_gpio_info gpio_info = {0};

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE))
			return -EACCES;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_info))
			return -EINVAL;

		if (copy_from_user(&gpio_info, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		uiBit = gpio_info.uiGpioNumber;

		/* Set the gpio output register */
		bytes = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER,
					(PUINT)ucRead, sizeof(UINT));

		if (bytes < 0) {
			Status = bytes;
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""RDM Failed\n"");
			return Status;
		} else {
			Status = STATUS_SUCCESS;
		}
	}
	break;

	case IOCTL_BCM_GPIO_MULTI_REQUEST: {
		UCHAR ucResetValue[4];
		struct bcm_gpio_multi_info gpio_multi_info[MAX_IDX];
		struct bcm_gpio_multi_info *pgpio_multi_info = (struct bcm_gpio_multi_info *)gpio_multi_info;

		memset(pgpio_multi_info, 0, MAX_IDX * sizeof(struct bcm_gpio_multi_info));

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE))
			return -EINVAL;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_multi_info))
			return -EINVAL;

		if (copy_from_user(&gpio_multi_info, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if (IsReqGpioIsLedInNVM(Adapter, pgpio_multi_info[WIMAX_IDX].uiGPIOMask) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!"",
					pgpio_multi_info[WIMAX_IDX].uiGPIOMask, Adapter->gpioBitMap);
			Status = -EINVAL;
			break;
		}

		/* Set the gpio output register */
		if ((pgpio_multi_info[WIMAX_IDX].uiGPIOMask) &
			(pgpio_multi_info[WIMAX_IDX].uiGPIOCommand)) {
			/* Set 1's in GPIO OUTPUT REGISTER */
			*(UINT *)ucResetValue =  pgpio_multi_info[WIMAX_IDX].uiGPIOMask &
				pgpio_multi_info[WIMAX_IDX].uiGPIOCommand &
				pgpio_multi_info[WIMAX_IDX].uiGPIOValue;

			if (*(UINT *) ucResetValue)
				Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_SET_REG,
							(PUINT)ucResetValue, sizeof(ULONG));

			if (Status != STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM to BCM_GPIO_OUTPUT_SET_REG Failed."");
				return Status;
			}

			/* Clear to 0's in GPIO OUTPUT REGISTER */
			*(UINT *)ucResetValue = (pgpio_multi_info[WIMAX_IDX].uiGPIOMask &
						pgpio_multi_info[WIMAX_IDX].uiGPIOCommand &
						(~(pgpio_multi_info[WIMAX_IDX].uiGPIOValue)));

			if (*(UINT *) ucResetValue)
				Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_CLR_REG, (PUINT)ucResetValue, sizeof(ULONG));

			if (Status != STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM to BCM_GPIO_OUTPUT_CLR_REG Failed."");
				return Status;
			}
		}

		if (pgpio_multi_info[WIMAX_IDX].uiGPIOMask) {
			bytes = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));

			if (bytes < 0) {
				Status = bytes;
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""RDM to GPIO_PIN_STATE_REGISTER Failed."");
				return Status;
			} else {
				Status = STATUS_SUCCESS;
			}

			pgpio_multi_info[WIMAX_IDX].uiGPIOValue = (*(UINT *)ucResetValue &
								pgpio_multi_info[WIMAX_IDX].uiGPIOMask);
		}

		Status = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_info, IoBuffer.OutputLength);
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Failed while copying Content to IOBufer for user space err:%d"", Status);
			return -EFAULT;
		}
	}
	break;

	case IOCTL_BCM_GPIO_MODE_REQUEST: {
		UCHAR ucResetValue[4];
		struct bcm_gpio_multi_mode gpio_multi_mode[MAX_IDX];
		struct bcm_gpio_multi_mode *pgpio_multi_mode = (struct bcm_gpio_multi_mode *)gpio_multi_mode;

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE))
			return -EINVAL;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_multi_mode))
			return -EINVAL;

		if (copy_from_user(&gpio_multi_mode, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		bytes = rdmaltWithLock(Adapter, (UINT)GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));

		if (bytes < 0) {
			Status = bytes;
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Read of GPIO_MODE_REGISTER failed"");
			return Status;
		} else {
			Status = STATUS_SUCCESS;
		}

		/* Validating the request */
		if (IsReqGpioIsLedInNVM(Adapter, pgpio_multi_mode[WIMAX_IDX].uiGPIOMask) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!"",
					pgpio_multi_mode[WIMAX_IDX].uiGPIOMask, Adapter->gpioBitMap);
			Status = -EINVAL;
			break;
		}

		if (pgpio_multi_mode[WIMAX_IDX].uiGPIOMask) {
			/* write all OUT's (1's) */
			*(UINT *) ucResetValue |= (pgpio_multi_mode[WIMAX_IDX].uiGPIOMode &
						pgpio_multi_mode[WIMAX_IDX].uiGPIOMask);

			/* write all IN's (0's) */
			*(UINT *) ucResetValue &= ~((~pgpio_multi_mode[WIMAX_IDX].uiGPIOMode) &
						pgpio_multi_mode[WIMAX_IDX].uiGPIOMask);

			/* Currently implemented return the modes of all GPIO's
			 * else needs to bit AND with  mask
			 */
			pgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT *)ucResetValue;

			Status = wrmaltWithLock(Adapter, GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(ULONG));
			if (Status == STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
						""WRM to GPIO_MODE_REGISTER Done"");
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
						""WRM to GPIO_MODE_REGISTER Failed"");
				Status = -EFAULT;
				break;
			}
		} else {
/* if uiGPIOMask is 0 then return mode register configuration */
			pgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT *)ucResetValue;
		}

		Status = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_mode, IoBuffer.OutputLength);
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Failed while copying Content to IOBufer for user space err:%d"", Status);
			return -EFAULT;
		}
	}
	break;

	case IOCTL_MAC_ADDR_REQ:
	case IOCTL_LINK_REQ:
	case IOCTL_CM_REQUEST:
	case IOCTL_SS_INFO_REQ:
	case IOCTL_SEND_CONTROL_MESSAGE:
	case IOCTL_IDLE_REQ: {
		PVOID pvBuffer = NULL;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength < sizeof(struct bcm_link_request))
			return -EINVAL;

		if (IoBuffer.InputLength > MAX_CNTL_PKT_SIZE)
			return -EINVAL;

		pvBuffer = memdup_user(IoBuffer.InputBuffer,
				       IoBuffer.InputLength);
		if (IS_ERR(pvBuffer))
			return PTR_ERR(pvBuffer);

		down(&Adapter->LowPowerModeSync);
		Status = wait_event_interruptible_timeout(Adapter->lowpower_mode_wait_queue,
							!Adapter->bPreparingForLowPowerMode,
							(1 * HZ));
		if (Status == -ERESTARTSYS)
			goto cntrlEnd;

		if (Adapter->bPreparingForLowPowerMode) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""Preparing Idle Mode is still True - Hence Rejecting control message\n"");
			Status = STATUS_FAILURE;
			goto cntrlEnd;
		}
		Status = CopyBufferToControlPacket(Adapter, (PVOID)pvBuffer);

cntrlEnd:
		up(&Adapter->LowPowerModeSync);
		kfree(pvBuffer);
		break;
	}

	case IOCTL_BCM_BUFFER_DOWNLOAD_START: {
		if (down_trylock(&Adapter->NVMRdmWrmLock)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\n"");
			return -EACCES;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
				""Starting the firmware download PID =0x%x!!!!\n"", current->pid);

		if (down_trylock(&Adapter->fw_download_sema))
			return -EBUSY;

		Adapter->bBinDownloaded = FALSE;
		Adapter->fw_download_process_pid = current->pid;
		Adapter->bCfgDownloaded = FALSE;
		Adapter->fw_download_done = FALSE;
		netif_carrier_off(Adapter->dev);
		netif_stop_queue(Adapter->dev);
		Status = reset_card_proc(Adapter);
		if (Status) {
			pr_err(PFX ""%s: reset_card_proc Failed!\n"", Adapter->dev->name);
			up(&Adapter->fw_download_sema);
			up(&Adapter->NVMRdmWrmLock);
			return Status;
		}
		mdelay(10);

		up(&Adapter->NVMRdmWrmLock);
		return Status;
	}

	case IOCTL_BCM_BUFFER_DOWNLOAD: {
		struct bcm_firmware_info *psFwInfo = NULL;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Starting the firmware download PID =0x%x!!!!\n"", current->pid);

		if (!down_trylock(&Adapter->fw_download_sema)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Invalid way to download buffer. Use Start and then call this!!!\n"");
			up(&Adapter->fw_download_sema);
			Status = -EINVAL;
			return Status;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {
			up(&Adapter->fw_download_sema);
			return -EFAULT;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
				""Length for FW DLD is : %lx\n"", IoBuffer.InputLength);

		if (IoBuffer.InputLength > sizeof(struct bcm_firmware_info)) {
			up(&Adapter->fw_download_sema);
			return -EINVAL;
		}

		psFwInfo = kmalloc(sizeof(*psFwInfo), GFP_KERNEL);
		if (!psFwInfo) {
			up(&Adapter->fw_download_sema);
			return -ENOMEM;
		}

		if (copy_from_user(psFwInfo, IoBuffer.InputBuffer, IoBuffer.InputLength)) {
			up(&Adapter->fw_download_sema);
			kfree(psFwInfo);
			return -EFAULT;
		}

		if (!psFwInfo->pvMappedFirmwareAddress ||
			(psFwInfo->u32FirmwareLength == 0)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Something else is wrong %lu\n"",
					psFwInfo->u32FirmwareLength);
			up(&Adapter->fw_download_sema);
			kfree(psFwInfo);
			Status = -EINVAL;
			return Status;
		}

		Status = bcm_ioctl_fw_download(Adapter, psFwInfo);

		if (Status != STATUS_SUCCESS) {
			if (psFwInfo->u32StartingAddress == CONFIG_BEGIN_ADDR)
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""IOCTL: Configuration File Upload Failed\n"");
			else
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,	""IOCTL: Firmware File Upload Failed\n"");

			/* up(&Adapter->fw_download_sema); */

			if (Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY) {
				Adapter->DriverState = DRIVER_INIT;
				Adapter->LEDInfo.bLedInitDone = FALSE;
				wake_up(&Adapter->LEDInfo.notify_led_event);
			}
		}

		if (Status != STATUS_SUCCESS)
			up(&Adapter->fw_download_sema);

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL, ""IOCTL: Firmware File Uploaded\n"");
		kfree(psFwInfo);
		return Status;
	}

	case IOCTL_BCM_BUFFER_DOWNLOAD_STOP: {
		if (!down_trylock(&Adapter->fw_download_sema)) {
			up(&Adapter->fw_download_sema);
			return -EINVAL;
		}

		if (down_trylock(&Adapter->NVMRdmWrmLock)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""FW download blocked as EEPROM Read/Write is in progress\n"");
			up(&Adapter->fw_download_sema);
			return -EACCES;
		}

		Adapter->bBinDownloaded = TRUE;
		Adapter->bCfgDownloaded = TRUE;
		atomic_set(&Adapter->CurrNumFreeTxDesc, 0);
		Adapter->CurrNumRecvDescs = 0;
		Adapter->downloadDDR = 0;

		/* setting the Mips to Run */
		Status = run_card_proc(Adapter);

		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Firm Download Failed\n"");
			up(&Adapter->fw_download_sema);
			up(&Adapter->NVMRdmWrmLock);
			return Status;
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG,
					DBG_LVL_ALL, ""Firm Download Over...\n"");
		}

		mdelay(10);

		/* Wait for MailBox Interrupt */
		if (StartInterruptUrb((struct bcm_interface_adapter *)Adapter->pvInterfaceAdapter))
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Unable to send interrupt...\n"");

		timeout = 5*HZ;
		Adapter->waiting_to_fw_download_done = FALSE;
		wait_event_timeout(Adapter->ioctl_fw_dnld_wait_queue,
				Adapter->waiting_to_fw_download_done, timeout);
		Adapter->fw_download_process_pid = INVALID_PID;
		Adapter->fw_download_done = TRUE;
		atomic_set(&Adapter->CurrNumFreeTxDesc, 0);
		Adapter->CurrNumRecvDescs = 0;
		Adapter->PrevNumRecvDescs = 0;
		atomic_set(&Adapter->cntrlpktCnt, 0);
		Adapter->LinkUpStatus = 0;
		Adapter->LinkStatus = 0;

		if (Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY) {
			Adapter->DriverState = FW_DOWNLOAD_DONE;
			wake_up(&Adapter->LEDInfo.notify_led_event);
		}

		if (!timeout)
			Status = -ENODEV;

		up(&Adapter->fw_download_sema);
		up(&Adapter->NVMRdmWrmLock);
		return Status;
	}

	case IOCTL_BE_BUCKET_SIZE:
		Status = 0;
		if (get_user(Adapter->BEBucketSize, (unsigned long __user *)arg))
			Status = -EFAULT;
		break;

	case IOCTL_RTPS_BUCKET_SIZE:
		Status = 0;
		if (get_user(Adapter->rtPSBucketSize, (unsigned long __user *)arg))
			Status = -EFAULT;
		break;

	case IOCTL_CHIP_RESET: {
		INT NVMAccess = down_trylock(&Adapter->NVMRdmWrmLock);
		if (NVMAccess) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "" IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\n"");
			return -EACCES;
		}

		down(&Adapter->RxAppControlQueuelock);
		Status = reset_card_proc(Adapter);
		flushAllAppQ();
		up(&Adapter->RxAppControlQueuelock);
		up(&Adapter->NVMRdmWrmLock);
		ResetCounters(Adapter);
		break;
	}

	case IOCTL_QOS_THRESHOLD: {
		USHORT uiLoopIndex;

		Status = 0;
		for (uiLoopIndex = 0; uiLoopIndex < NO_OF_QUEUES; uiLoopIndex++) {
			if (get_user(Adapter->PackInfo[uiLoopIndex].uiThreshold,
					(unsigned long __user *)arg)) {
				Status = -EFAULT;
				break;
			}
		}
		break;
	}

	case IOCTL_DUMP_PACKET_INFO:
		DumpPackInfo(Adapter);
		DumpPhsRules(&Adapter->stBCMPhsContext);
		Status = STATUS_SUCCESS;
		break;

	case IOCTL_GET_PACK_INFO:
		if (copy_to_user(argp, &Adapter->PackInfo, sizeof(struct bcm_packet_info)*NO_OF_QUEUES))
			return -EFAULT;
		Status = STATUS_SUCCESS;
		break;

	case IOCTL_BCM_SWITCH_TRANSFER_MODE: {
		UINT uiData = 0;
		if (copy_from_user(&uiData, argp, sizeof(UINT)))
			return -EFAULT;

		if (uiData) {
			/* Allow All Packets */
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SWITCH_TRANSFER_MODE: ETH_PACKET_TUNNELING_MODE\n"");
				Adapter->TransferMode = ETH_PACKET_TUNNELING_MODE;
		} else {
			/* Allow IP only Packets */
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SWITCH_TRANSFER_MODE: IP_PACKET_ONLY_MODE\n"");
			Adapter->TransferMode = IP_PACKET_ONLY_MODE;
		}
		Status = STATUS_SUCCESS;
		break;
	}

	case IOCTL_BCM_GET_DRIVER_VERSION: {
		ulong len;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		len = min_t(ulong, IoBuffer.OutputLength, strlen(DRV_VERSION) + 1);

		if (copy_to_user(IoBuffer.OutputBuffer, DRV_VERSION, len))
			return -EFAULT;
		Status = STATUS_SUCCESS;
		break;
	}

	case IOCTL_BCM_GET_CURRENT_STATUS: {
		struct bcm_link_state link_state;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""copy_from_user failed..\n"");
			return -EFAULT;
		}

		if (IoBuffer.OutputLength != sizeof(link_state)) {
			Status = -EINVAL;
			break;
		}

		memset(&link_state, 0, sizeof(link_state));
		link_state.bIdleMode = Adapter->IdleMode;
		link_state.bShutdownMode = Adapter->bShutStatus;
		link_state.ucLinkStatus = Adapter->LinkStatus;

		if (copy_to_user(IoBuffer.OutputBuffer, &link_state, min_t(size_t, sizeof(link_state), IoBuffer.OutputLength))) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy_to_user Failed..\n"");
			return -EFAULT;
		}
		Status = STATUS_SUCCESS;
		break;
	}

	case IOCTL_BCM_SET_MAC_TRACING: {
		UINT  tracing_flag;

		/* copy ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (copy_from_user(&tracing_flag, IoBuffer.InputBuffer, sizeof(UINT)))
			return -EFAULT;

		if (tracing_flag)
			Adapter->pTarangs->MacTracingEnabled = TRUE;
		else
			Adapter->pTarangs->MacTracingEnabled = FALSE;
		break;
	}

	case IOCTL_BCM_GET_DSX_INDICATION: {
		ULONG ulSFId = 0;
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength < sizeof(struct bcm_add_indication_alt)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Mismatch req: %lx needed is =0x%zx!!!"",
					IoBuffer.OutputLength, sizeof(struct bcm_add_indication_alt));
			return -EINVAL;
		}

		if (copy_from_user(&ulSFId, IoBuffer.InputBuffer, sizeof(ulSFId)))
			return -EFAULT;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Get DSX Data SF ID is =%lx\n"", ulSFId);
		get_dsx_sf_data_to_application(Adapter, ulSFId, IoBuffer.OutputBuffer);
		Status = STATUS_SUCCESS;
	}
	break;

	case IOCTL_BCM_GET_HOST_MIBS: {
		PVOID temp_buff;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength != sizeof(struct bcm_host_stats_mibs)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Length Check failed %lu %zd\n"",
					IoBuffer.OutputLength, sizeof(struct bcm_host_stats_mibs));
			return -EINVAL;
		}

		/* FIXME: HOST_STATS are too big for kmalloc (122048)! */
		temp_buff = kzalloc(sizeof(struct bcm_host_stats_mibs), GFP_KERNEL);
		if (!temp_buff)
			return STATUS_FAILURE;

		Status = ProcessGetHostMibs(Adapter, temp_buff);
		GetDroppedAppCntrlPktMibs(temp_buff, pTarang);

		if (Status != STATUS_FAILURE)
			if (copy_to_user(IoBuffer.OutputBuffer, temp_buff, sizeof(struct bcm_host_stats_mibs))) {
				kfree(temp_buff);
				return -EFAULT;
			}

		kfree(temp_buff);
		break;
	}

	case IOCTL_BCM_WAKE_UP_DEVICE_FROM_IDLE:
		if ((FALSE == Adapter->bTriedToWakeUpFromlowPowerMode) && (TRUE == Adapter->IdleMode)) {
			Adapter->usIdleModePattern = ABORT_IDLE_MODE;
			Adapter->bWakeUpDevice = TRUE;
			wake_up(&Adapter->process_rx_cntrlpkt);
		}

		Status = STATUS_SUCCESS;
		break;

	case IOCTL_BCM_BULK_WRM: {
		struct bcm_bulk_wrm_buffer *pBulkBuffer;
		UINT uiTempVar = 0;
		PCHAR pvBuffer = NULL;

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device in Idle/Shutdown Mode, Blocking Wrms\n"");
			Status = -EACCES;
			break;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength < sizeof(ULONG) * 2)
			return -EINVAL;

		pvBuffer = memdup_user(IoBuffer.InputBuffer,
				       IoBuffer.InputLength);
		if (IS_ERR(pvBuffer))
			return PTR_ERR(pvBuffer);

		pBulkBuffer = (struct bcm_bulk_wrm_buffer *)pvBuffer;

		if (((ULONG)pBulkBuffer->Register & 0x0F000000) != 0x0F000000 ||
			((ULONG)pBulkBuffer->Register & 0x3)) {
			BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM Done On invalid Address : %x Access Denied.\n"", (int)pBulkBuffer->Register);
			kfree(pvBuffer);
			Status = -EINVAL;
			break;
		}

		uiTempVar = pBulkBuffer->Register & EEPROM_REJECT_MASK;
		if (!((Adapter->pstargetparams->m_u32Customize)&VSG_MODE) &&
			((uiTempVar == EEPROM_REJECT_REG_1) ||
				(uiTempVar == EEPROM_REJECT_REG_2) ||
				(uiTempVar == EEPROM_REJECT_REG_3) ||
				(uiTempVar == EEPROM_REJECT_REG_4)) &&
			(cmd == IOCTL_BCM_REGISTER_WRITE)) {

			kfree(pvBuffer);
			BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""EEPROM Access Denied, not in VSG Mode\n"");
			Status = -EFAULT;
			break;
		}

		if (pBulkBuffer->SwapEndian == FALSE)
			Status = wrmWithLock(Adapter, (UINT)pBulkBuffer->Register, (PCHAR)pBulkBuffer->Values, IoBuffer.InputLength - 2*sizeof(ULONG));
		else
			Status = wrmaltWithLock(Adapter, (UINT)pBulkBuffer->Register, (PUINT)pBulkBuffer->Values, IoBuffer.InputLength - 2*sizeof(ULONG));

		if (Status != STATUS_SUCCESS)
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM Failed\n"");

		kfree(pvBuffer);
		break;
	}

	case IOCTL_BCM_GET_NVM_SIZE:
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (Adapter->eNVMType == NVM_EEPROM || Adapter->eNVMType == NVM_FLASH) {
			if (copy_to_user(IoBuffer.OutputBuffer, &Adapter->uiNVMDSDSize, sizeof(UINT)))
				return -EFAULT;
		}

		Status = STATUS_SUCCESS;
		break;

	case IOCTL_BCM_CAL_INIT: {
		UINT uiSectorSize = 0 ;
		if (Adapter->eNVMType == NVM_FLASH) {
			if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
				return -EFAULT;

			if (copy_from_user(&uiSectorSize, IoBuffer.InputBuffer, sizeof(UINT)))
				return -EFAULT;

			if ((uiSectorSize < MIN_SECTOR_SIZE) || (uiSectorSize > MAX_SECTOR_SIZE)) {
				if (copy_to_user(IoBuffer.OutputBuffer, &Adapter->uiSectorSize,
							sizeof(UINT)))
					return -EFAULT;
			} else {
				if (IsFlash2x(Adapter)) {
					if (copy_to_user(IoBuffer.OutputBuffer,	&Adapter->uiSectorSize, sizeof(UINT)))
						return -EFAULT;
				} else {
					if ((TRUE == Adapter->bShutStatus) || (TRUE == Adapter->IdleMode)) {
						BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device is in Idle/Shutdown Mode\n"");
						return -EACCES;
					}

					Adapter->uiSectorSize = uiSectorSize;
					BcmUpdateSectorSize(Adapter, Adapter->uiSectorSize);
				}
			}
			Status = STATUS_SUCCESS;
		} else {
			Status = STATUS_FAILURE;
		}
	}
	break;

	case IOCTL_BCM_SET_DEBUG:
#ifdef DEBUG
	{
		struct bcm_user_debug_state sUserDebugState;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""In SET_DEBUG ioctl\n"");
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (copy_from_user(&sUserDebugState, IoBuffer.InputBuffer, sizeof(struct bcm_user_debug_state)))
			return -EFAULT;

		BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""IOCTL_BCM_SET_DEBUG: OnOff=%d Type = 0x%x "",
				sUserDebugState.OnOff, sUserDebugState.Type);
		/* sUserDebugState.Subtype <<= 1; */
		sUserDebugState.Subtype = 1 << sUserDebugState.Subtype;
		BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""actual Subtype=0x%x\n"", sUserDebugState.Subtype);

		/* Update new 'DebugState' in the Adapter */
		Adapter->stDebugState.type |= sUserDebugState.Type;
		/* Subtype: A bitmap of 32 bits for Subtype per Type.
		 * Valid indexes in 'subtype' array: 1,2,4,8
		 * corresponding to valid Type values. Hence we can use the 'Type' field
		 * as the index value, ignoring the array entries 0,3,5,6,7 !
		 */
		if (sUserDebugState.OnOff)
			Adapter->stDebugState.subtype[sUserDebugState.Type] |= sUserDebugState.Subtype;
		else
			Adapter->stDebugState.subtype[sUserDebugState.Type] &= ~sUserDebugState.Subtype;

		BCM_SHOW_DEBUG_BITMAP(Adapter);
	}
#endif
	break;

	case IOCTL_BCM_NVM_READ:
	case IOCTL_BCM_NVM_WRITE: {
		struct bcm_nvm_readwrite stNVMReadWrite;
		PUCHAR pReadData = NULL;
		ULONG ulDSDMagicNumInUsrBuff = 0;
		struct timeval tv0, tv1;
		memset(&tv0, 0, sizeof(struct timeval));
		memset(&tv1, 0, sizeof(struct timeval));
		if ((Adapter->eNVMType == NVM_FLASH) && (Adapter->uiFlashLayoutMajorVersion == 0)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""The Flash Control Section is Corrupted. Hence Rejection on NVM Read/Write\n"");
			return -EFAULT;
		}

		if (IsFlash2x(Adapter)) {
			if ((Adapter->eActiveDSD != DSD0) &&
				(Adapter->eActiveDSD != DSD1) &&
				(Adapter->eActiveDSD != DSD2)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""No DSD is active..hence NVM Command is blocked"");
				return STATUS_FAILURE;
			}
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (copy_from_user(&stNVMReadWrite,
					(IOCTL_BCM_NVM_READ == cmd) ? IoBuffer.OutputBuffer : IoBuffer.InputBuffer,
					sizeof(struct bcm_nvm_readwrite)))
			return -EFAULT;

		/*
		 * Deny the access if the offset crosses the cal area limit.
		 */
		if (stNVMReadWrite.uiNumBytes > Adapter->uiNVMDSDSize)
			return STATUS_FAILURE;

		if (stNVMReadWrite.uiOffset > Adapter->uiNVMDSDSize - stNVMReadWrite.uiNumBytes) {
			/* BCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,""Can't allow access beyond NVM Size: 0x%x 0x%x\n"", stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes); */
			return STATUS_FAILURE;
		}

		pReadData = memdup_user(stNVMReadWrite.pBuffer,
					stNVMReadWrite.uiNumBytes);
		if (IS_ERR(pReadData))
			return PTR_ERR(pReadData);

		do_gettimeofday(&tv0);
		if (IOCTL_BCM_NVM_READ == cmd) {
			down(&Adapter->NVMRdmWrmLock);

			if ((Adapter->IdleMode == TRUE) ||
				(Adapter->bShutStatus == TRUE) ||
				(Adapter->bPreparingForLowPowerMode == TRUE)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadData);
				return -EACCES;
			}

			Status = BeceemNVMRead(Adapter, (PUINT)pReadData, stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes);
			up(&Adapter->NVMRdmWrmLock);

			if (Status != STATUS_SUCCESS) {
				kfree(pReadData);
				return Status;
			}

			if (copy_to_user(stNVMReadWrite.pBuffer, pReadData, stNVMReadWrite.uiNumBytes)) {
				kfree(pReadData);
				return -EFAULT;
			}
		} else {
			down(&Adapter->NVMRdmWrmLock);

			if ((Adapter->IdleMode == TRUE) ||
				(Adapter->bShutStatus == TRUE) ||
				(Adapter->bPreparingForLowPowerMode == TRUE)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadData);
				return -EACCES;
			}

			Adapter->bHeaderChangeAllowed = TRUE;
			if (IsFlash2x(Adapter)) {
				/*
				 *			New Requirement:-
				 *			DSD section updation will be allowed in two case:-
				 *			1.  if DSD sig is present in DSD header means dongle is ok and updation is fruitfull
				 *			2.  if point 1 failes then user buff should have DSD sig. this point ensures that if dongle is
				 *			      corrupted then user space program first modify the DSD header with valid DSD sig so
				 *			      that this as well as further write may be worthwhile.
				 *
				 *			 This restriction has been put assuming that if DSD sig is corrupted, DSD
				 *			 data won't be considered valid.
				 */

				Status = BcmFlash2xCorruptSig(Adapter, Adapter->eActiveDSD);
				if (Status != STATUS_SUCCESS) {
					if (((stNVMReadWrite.uiOffset + stNVMReadWrite.uiNumBytes) != Adapter->uiNVMDSDSize) ||
						(stNVMReadWrite.uiNumBytes < SIGNATURE_SIZE)) {

						BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""DSD Sig is present neither in Flash nor User provided Input.."");
						up(&Adapter->NVMRdmWrmLock);
						kfree(pReadData);
						return Status;
					}

					ulDSDMagicNumInUsrBuff = ntohl(*(PUINT)(pReadData + stNVMReadWrite.uiNumBytes - SIGNATURE_SIZE));
					if (ulDSDMagicNumInUsrBuff != DSD_IMAGE_MAGIC_NUMBER) {
						BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""DSD Sig is present neither in Flash nor User provided Input.."");
						up(&Adapter->NVMRdmWrmLock);
						kfree(pReadData);
						return Status;
					}
				}
			}

			Status = BeceemNVMWrite(Adapter, (PUINT)pReadData, stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes, stNVMReadWrite.bVerify);
			if (IsFlash2x(Adapter))
				BcmFlash2xWriteSig(Adapter, Adapter->eActiveDSD);

			Adapter->bHeaderChangeAllowed = FALSE;

			up(&Adapter->NVMRdmWrmLock);

			if (Status != STATUS_SUCCESS) {
				kfree(pReadData);
				return Status;
			}
		}

		do_gettimeofday(&tv1);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "" timetaken by Write/read :%ld msec\n"", (tv1.tv_sec - tv0.tv_sec)*1000 + (tv1.tv_usec - tv0.tv_usec)/1000);

		kfree(pReadData);
		return STATUS_SUCCESS;
	}

	case IOCTL_BCM_FLASH2X_SECTION_READ: {
		struct bcm_flash2x_readwrite sFlash2xRead = {0};
		PUCHAR pReadBuff = NULL ;
		UINT NOB = 0;
		UINT BuffSize = 0;
		UINT ReadBytes = 0;
		UINT ReadOffset = 0;
		void __user *OutPutBuff;

		if (IsFlash2x(Adapter) != TRUE)	{
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_FLASH2X_SECTION_READ Called"");
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		/* Reading FLASH 2.x READ structure */
		if (copy_from_user(&sFlash2xRead, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_readwrite)))
			return -EFAULT;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.Section :%x"", sFlash2xRead.Section);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.offset :%x"", sFlash2xRead.offset);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.numOfBytes :%x"", sFlash2xRead.numOfBytes);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.bVerify :%x\n"", sFlash2xRead.bVerify);

		/* This was internal to driver for raw read. now it has ben exposed to user space app. */
		if (validateFlash2xReadWrite(Adapter, &sFlash2xRead) == FALSE)
			return STATUS_FAILURE;

		NOB = sFlash2xRead.numOfBytes;
		if (NOB > Adapter->uiSectorSize)
			BuffSize = Adapter->uiSectorSize;
		else
			BuffSize = NOB;

		ReadOffset = sFlash2xRead.offset ;
		OutPutBuff = IoBuffer.OutputBuffer;
		pReadBuff = (PCHAR)kzalloc(BuffSize , GFP_KERNEL);

		if (pReadBuff == NULL) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Memory allocation failed for Flash 2.x Read Structure"");
			return -ENOMEM;
		}
		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			kfree(pReadBuff);
			return -EACCES;
		}

		while (NOB) {
			if (NOB > Adapter->uiSectorSize)
				ReadBytes = Adapter->uiSectorSize;
			else
				ReadBytes = NOB;

			/* Reading the data from Flash 2.x */
			Status = BcmFlash2xBulkRead(Adapter, (PUINT)pReadBuff, sFlash2xRead.Section, ReadOffset, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Flash 2x read err with Status :%d"", Status);
				break;
			}

			BCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pReadBuff, ReadBytes);

			Status = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Copy to use failed with status :%d"", Status);
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadBuff);
				return -EFAULT;
			}
			NOB = NOB - ReadBytes;
			if (NOB) {
				ReadOffset = ReadOffset + ReadBytes;
				OutPutBuff = OutPutBuff + ReadBytes ;
			}
		}

		up(&Adapter->NVMRdmWrmLock);
		kfree(pReadBuff);
	}
	break;

	case IOCTL_BCM_FLASH2X_SECTION_WRITE: {
		struct bcm_flash2x_readwrite sFlash2xWrite = {0};
		PUCHAR pWriteBuff;
		void __user *InputAddr;
		UINT NOB = 0;
		UINT BuffSize = 0;
		UINT WriteOffset = 0;
		UINT WriteBytes = 0;

		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		/* First make this False so that we can enable the Sector Permission Check in BeceemFlashBulkWrite */
		Adapter->bAllDSDWriteAllow = FALSE;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_FLASH2X_SECTION_WRITE Called"");

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		/* Reading FLASH 2.x READ structure */
		if (copy_from_user(&sFlash2xWrite, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_readwrite)))
			return -EFAULT;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.Section :%x"", sFlash2xWrite.Section);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.offset :%d"", sFlash2xWrite.offset);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.numOfBytes :%x"", sFlash2xWrite.numOfBytes);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.bVerify :%x\n"", sFlash2xWrite.bVerify);

		if ((sFlash2xWrite.Section != VSA0) && (sFlash2xWrite.Section != VSA1) && (sFlash2xWrite.Section != VSA2)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Only VSA write is allowed"");
			return -EINVAL;
		}

		if (validateFlash2xReadWrite(Adapter, &sFlash2xWrite) == FALSE)
			return STATUS_FAILURE;

		InputAddr = sFlash2xWrite.pDataBuff;
		WriteOffset = sFlash2xWrite.offset;
		NOB = sFlash2xWrite.numOfBytes;

		if (NOB > Adapter->uiSectorSize)
			BuffSize = Adapter->uiSectorSize;
		else
			BuffSize = NOB ;

		pWriteBuff = kmalloc(BuffSize, GFP_KERNEL);

		if (pWriteBuff == NULL)
			return -ENOMEM;

		/* extracting the remainder of the given offset. */
		WriteBytes = Adapter->uiSectorSize;
		if (WriteOffset % Adapter->uiSectorSize)
			WriteBytes = Adapter->uiSectorSize - (WriteOffset % Adapter->uiSectorSize);

		if (NOB < WriteBytes)
			WriteBytes = NOB;

		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			kfree(pWriteBuff);
			return -EACCES;
		}

		BcmFlash2xCorruptSig(Adapter, sFlash2xWrite.Section);
		do {
			Status = copy_from_user(pWriteBuff, InputAddr, WriteBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy to user failed with status :%d"", Status);
				up(&Adapter->NVMRdmWrmLock);
				kfree(pWriteBuff);
				return -EFAULT;
			}
			BCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pWriteBuff, WriteBytes);

			/* Writing the data from Flash 2.x */
			Status = BcmFlash2xBulkWrite(Adapter, (PUINT)pWriteBuff, sFlash2xWrite.Section, WriteOffset, WriteBytes, sFlash2xWrite.bVerify);

			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash 2x read err with Status :%d"", Status);
				break;
			}

			NOB = NOB - WriteBytes;
			if (NOB) {
				WriteOffset = WriteOffset + WriteBytes;
				InputAddr = InputAddr + WriteBytes;
				if (NOB > Adapter->uiSectorSize)
					WriteBytes = Adapter->uiSectorSize;
				else
					WriteBytes = NOB;
			}
		} while (NOB > 0);

		BcmFlash2xWriteSig(Adapter, sFlash2xWrite.Section);
		up(&Adapter->NVMRdmWrmLock);
		kfree(pWriteBuff);
	}
	break;

	case IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP: {
		struct bcm_flash2x_bitmap *psFlash2xBitMap;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP Called"");

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength != sizeof(struct bcm_flash2x_bitmap))
			return -EINVAL;

		psFlash2xBitMap = kzalloc(sizeof(struct bcm_flash2x_bitmap), GFP_KERNEL);
		if (psFlash2xBitMap == NULL) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Memory is not available"");
			return -ENOMEM;
		}

		/* Reading the Flash Sectio Bit map */
		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			kfree(psFlash2xBitMap);
			return -EACCES;
		}

		BcmGetFlash2xSectionalBitMap(Adapter, psFlash2xBitMap);
		up(&Adapter->NVMRdmWrmLock);
		if (copy_to_user(IoBuffer.OutputBuffer, psFlash2xBitMap, sizeof(struct bcm_flash2x_bitmap))) {
			kfree(psFlash2xBitMap);
			return -EFAULT;
		}

		kfree(psFlash2xBitMap);
	}
	break;

	case IOCTL_BCM_SET_ACTIVE_SECTION: {
		enum bcm_flash2x_section_val eFlash2xSectionVal = 0;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SET_ACTIVE_SECTION Called"");

		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed"");
			return -EFAULT;
		}

		Status = copy_from_user(&eFlash2xSectionVal, IoBuffer.InputBuffer, sizeof(INT));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of flash section val failed"");
			return -EFAULT;
		}

		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			return -EACCES;
		}

		Status = BcmSetActiveSection(Adapter, eFlash2xSectionVal);
		if (Status)
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Failed to make it's priority Highest. Status %d"", Status);

		up(&Adapter->NVMRdmWrmLock);
	}
	break;

	case IOCTL_BCM_IDENTIFY_ACTIVE_SECTION: {
		/* Right Now we are taking care of only DSD */
		Adapter->bAllDSDWriteAllow = FALSE;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_IDENTIFY_ACTIVE_SECTION called"");
		Status = STATUS_SUCCESS;
	}
	break;

	case IOCTL_BCM_COPY_SECTION: {
		struct bcm_flash2x_copy_section sCopySectStrut = {0};
		Status = STATUS_SUCCESS;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_COPY_SECTION  Called"");

		Adapter->bAllDSDWriteAllow = FALSE;
		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed Status :%d"", Status);
			return -EFAULT;
		}

		Status = copy_from_user(&sCopySectStrut, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_copy_section));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of Copy_Section_Struct failed with Status :%d"", Status);
			return -EFAULT;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Source SEction :%x"", sCopySectStrut.SrcSection);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Destination SEction :%x"", sCopySectStrut.DstSection);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""offset :%x"", sCopySectStrut.offset);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""NOB :%x"", sCopySectStrut.numOfBytes);

		if (IsSectionExistInFlash(Adapter, sCopySectStrut.SrcSection) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Source Section<%x> does not exixt in Flash "", sCopySectStrut.SrcSection);
			return -EINVAL;
		}

		if (IsSectionExistInFlash(Adapter, sCopySectStrut.DstSection) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Destinatio Section<%x> does not exixt in Flash "", sCopySectStrut.DstSection);
			return -EINVAL;
		}

		if (sCopySectStrut.SrcSection == sCopySectStrut.DstSection) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Source and Destination section should be different"");
			return -EINVAL;
		}

		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			return -EACCES;
		}

		if (sCopySectStrut.SrcSection == ISO_IMAGE1 || sCopySectStrut.SrcSection == ISO_IMAGE2) {
			if (IsNonCDLessDevice(Adapter)) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device is Non-CDLess hence won't have ISO !!"");
				Status = -EINVAL;
			} else if (sCopySectStrut.numOfBytes == 0) {
				Status = BcmCopyISO(Adapter, sCopySectStrut);
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Partial Copy of ISO section is not Allowed.."");
				Status = STATUS_FAILURE;
			}
			up(&Adapter->NVMRdmWrmLock);
			return Status;
		}

		Status = BcmCopySection(Adapter, sCopySectStrut.SrcSection,
					sCopySectStrut.DstSection, sCopySectStrut.offset, sCopySectStrut.numOfBytes);
		up(&Adapter->NVMRdmWrmLock);
	}
	break;

	case IOCTL_BCM_GET_FLASH_CS_INFO: {
		Status = STATUS_SUCCESS;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "" IOCTL_BCM_GET_FLASH_CS_INFO Called"");

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed"");
			return -EFAULT;
		}

		if (Adapter->eNVMType != NVM_FLASH) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Connected device does not have flash"");
			Status = -EINVAL;
			break;
		}

		if (IsFlash2x(Adapter) == TRUE) {
			if (IoBuffer.OutputLength < sizeof(struct bcm_flash2x_cs_info))
				return -EINVAL;

			if (copy_to_user(IoBuffer.OutputBuffer, Adapter->psFlash2xCSInfo, sizeof(struct bcm_flash2x_cs_info)))
				return -EFAULT;
		} else {
			if (IoBuffer.OutputLength < sizeof(struct bcm_flash_cs_info))
				return -EINVAL;

			if (copy_to_user(IoBuffer.OutputBuffer, Adapter->psFlashCSInfo, sizeof(struct bcm_flash_cs_info)))
				return -EFAULT;
		}
	}
	break;

	case IOCTL_BCM_SELECT_DSD: {
		UINT SectOfset = 0;
		enum bcm_flash2x_section_val eFlash2xSectionVal;
		eFlash2xSectionVal = NO_SECTION_VAL;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SELECT_DSD Called"");

		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed"");
			return -EFAULT;
		}
		Status = copy_from_user(&eFlash2xSectionVal, IoBuffer.InputBuffer, sizeof(INT));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of flash section val failed"");
			return -EFAULT;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Read Section :%d"", eFlash2xSectionVal);
		if ((eFlash2xSectionVal != DSD0) &&
			(eFlash2xSectionVal != DSD1) &&
			(eFlash2xSectionVal != DSD2)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Passed section<%x> is not DSD section"", eFlash2xSectionVal);
			return STATUS_FAILURE;
		}

		SectOfset = BcmGetSectionValStartOffset(Adapter, eFlash2xSectionVal);
		if (SectOfset == INVALID_OFFSET) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Provided Section val <%d> does not exixt in Flash 2.x"", eFlash2xSectionVal);
			return -EINVAL;
		}

		Adapter->bAllDSDWriteAllow = TRUE;
		Adapter->ulFlashCalStart = SectOfset;
		Adapter->eActiveDSD = eFlash2xSectionVal;
	}
	Status = STATUS_SUCCESS;
	break;

	case IOCTL_BCM_NVM_RAW_READ: {
		struct bcm_nvm_readwrite stNVMRead;
		INT NOB ;
		INT BuffSize ;
		INT ReadOffset = 0;
		UINT ReadBytes = 0 ;
		PUCHAR pReadBuff;
		void __user *OutPutBuff;

		if (Adapter->eNVMType != NVM_FLASH) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""NVM TYPE is not Flash"");
			return -EINVAL;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""copy_from_user 1 failed\n"");
			return -EFAULT;
		}

		if (copy_from_user(&stNVMRead, IoBuffer.OutputBuffer, sizeof(struct bcm_nvm_readwrite)))
			return -EFAULT;

		NOB = stNVMRead.uiNumBytes;
		/* In Raw-Read max Buff size : 64MB */

		if (NOB > DEFAULT_BUFF_SIZE)
			BuffSize = DEFAULT_BUFF_SIZE;
		else
			BuffSize = NOB;

		ReadOffset = stNVMRead.uiOffset;
		OutPutBuff = stNVMRead.pBuffer;

		pReadBuff = kzalloc(BuffSize , GFP_KERNEL);
		if (pReadBuff == NULL) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Memory allocation failed for Flash 2.x Read Structure"");
			Status = -ENOMEM;
			break;
		}
		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			kfree(pReadBuff);
			up(&Adapter->NVMRdmWrmLock);
			return -EACCES;
		}

		Adapter->bFlashRawRead = TRUE;

		while (NOB) {
			if (NOB > DEFAULT_BUFF_SIZE)
				ReadBytes = DEFAULT_BUFF_SIZE;
			else
				ReadBytes = NOB;

			/* Reading the data from Flash 2.x */
			Status = BeceemNVMRead(Adapter, (PUINT)pReadBuff, ReadOffset, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash 2x read err with Status :%d"", Status);
				break;
			}

			BCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pReadBuff, ReadBytes);

			Status = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy to use failed with status :%d"", Status);
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadBuff);
				return -EFAULT;
			}
			NOB = NOB - ReadBytes;
			if (NOB) {
				ReadOffset = ReadOffset + ReadBytes;
				OutPutBuff = OutPutBuff + ReadBytes;
			}
		}
		Adapter->bFlashRawRead = FALSE;
		up(&Adapter->NVMRdmWrmLock);
		kfree(pReadBuff);
		break;
	}

	case IOCTL_BCM_CNTRLMSG_MASK: {
		ULONG RxCntrlMsgBitMask = 0;

		/* Copy Ioctl Buffer structure */
		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""copy of Ioctl buffer is failed from user space"");
			return -EFAULT;
		}

		if (IoBuffer.InputLength != sizeof(unsigned long)) {
			Status = -EINVAL;
			break;
		}

		Status = copy_from_user(&RxCntrlMsgBitMask, IoBuffer.InputBuffer, IoBuffer.InputLength);
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""copy of control bit mask failed from user space"");
			return -EFAULT;
		}
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\n Got user defined cntrl msg bit mask :%lx"", RxCntrlMsgBitMask);
		pTarang->RxCntrlMsgBitMask = RxCntrlMsgBitMask;
	}
	break;

	case IOCTL_BCM_GET_DEVICE_DRIVER_INFO: {
		struct bcm_driver_info DevInfo;
 
 		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Called IOCTL_BCM_GET_DEVICE_DRIVER_INFO\n"");
 
 		DevInfo.MaxRDMBufferSize = BUFFER_4K;
 		DevInfo.u32DSDStartOffset = EEPROM_CALPARAM_START;
 		DevInfo.u32RxAlignmentCorrection = 0;
		DevInfo.u32NVMType = Adapter->eNVMType;
		DevInfo.u32InterfaceType = BCM_USB;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength < sizeof(DevInfo))
			return -EINVAL;

		if (copy_to_user(IoBuffer.OutputBuffer, &DevInfo, sizeof(DevInfo)))
			return -EFAULT;
	}
	break;

	case IOCTL_BCM_TIME_SINCE_NET_ENTRY: {
		struct bcm_time_elapsed stTimeElapsedSinceNetEntry = {0};

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_TIME_SINCE_NET_ENTRY called"");

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength < sizeof(struct bcm_time_elapsed))
			return -EINVAL;

		stTimeElapsedSinceNetEntry.ul64TimeElapsedSinceNetEntry = get_seconds() - Adapter->liTimeSinceLastNetEntry;

		if (copy_to_user(IoBuffer.OutputBuffer, &stTimeElapsedSinceNetEntry, sizeof(struct bcm_time_elapsed)))
			return -EFAULT;
	}
	break;

	case IOCTL_CLOSE_NOTIFICATION:
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_CLOSE_NOTIFICATION"");
		break;

	default:
		pr_info(DRV_NAME "": unknown ioctl cmd=%#x\n"", cmd);
		Status = STATUS_FAILURE;
		break;
	}
	return Status;
}
","static long bcm_char_ioctl(struct file *filp, UINT cmd, ULONG arg)
{
	struct bcm_tarang_data *pTarang = filp->private_data;
	void __user *argp = (void __user *)arg;
	struct bcm_mini_adapter *Adapter = pTarang->Adapter;
	INT Status = STATUS_FAILURE;
	int timeout = 0;
	struct bcm_ioctl_buffer IoBuffer;
	int bytes;

	BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Parameters Passed to control IOCTL cmd=0x%X arg=0x%lX"", cmd, arg);

	if (_IOC_TYPE(cmd) != BCM_IOCTL)
		return -EFAULT;
	if (_IOC_DIR(cmd) & _IOC_READ)
		Status = !access_ok(VERIFY_WRITE, argp, _IOC_SIZE(cmd));
	else if (_IOC_DIR(cmd) & _IOC_WRITE)
		Status = !access_ok(VERIFY_READ, argp, _IOC_SIZE(cmd));
	else if (_IOC_NONE == (_IOC_DIR(cmd) & _IOC_NONE))
		Status = STATUS_SUCCESS;

	if (Status)
		return -EFAULT;

	if (Adapter->device_removed)
		return -EFAULT;

	if (FALSE == Adapter->fw_download_done) {
		switch (cmd) {
		case IOCTL_MAC_ADDR_REQ:
		case IOCTL_LINK_REQ:
		case IOCTL_CM_REQUEST:
		case IOCTL_SS_INFO_REQ:
		case IOCTL_SEND_CONTROL_MESSAGE:
		case IOCTL_IDLE_REQ:
		case IOCTL_BCM_GPIO_SET_REQUEST:
		case IOCTL_BCM_GPIO_STATUS_REQUEST:
			return -EACCES;
		default:
			break;
		}
	}

	Status = vendorextnIoctl(Adapter, cmd, arg);
	if (Status != CONTINUE_COMMON_PATH)
		return Status;

	switch (cmd) {
	/* Rdms for Swin Idle... */
	case IOCTL_BCM_REGISTER_READ_PRIVATE: {
		struct bcm_rdm_buffer sRdmBuffer = {0};
		PCHAR temp_buff;
		UINT Bufflen;
		u16 temp_value;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sRdmBuffer))
			return -EINVAL;

		if (copy_from_user(&sRdmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if (IoBuffer.OutputLength > USHRT_MAX ||
			IoBuffer.OutputLength == 0) {
			return -EINVAL;
		}

		Bufflen = IoBuffer.OutputLength;
		temp_value = 4 - (Bufflen % 4);
		Bufflen += temp_value % 4;

		temp_buff = kmalloc(Bufflen, GFP_KERNEL);
		if (!temp_buff)
			return -ENOMEM;

		bytes = rdmalt(Adapter, (UINT)sRdmBuffer.Register,
				(PUINT)temp_buff, Bufflen);
		if (bytes > 0) {
			Status = STATUS_SUCCESS;
			if (copy_to_user(IoBuffer.OutputBuffer, temp_buff, bytes)) {
				kfree(temp_buff);
				return -EFAULT;
			}
		} else {
			Status = bytes;
		}

		kfree(temp_buff);
		break;
	}

	case IOCTL_BCM_REGISTER_WRITE_PRIVATE: {
		struct bcm_wrm_buffer sWrmBuffer = {0};
		UINT uiTempVar = 0;
		/* Copy Ioctl Buffer structure */

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sWrmBuffer))
			return -EINVAL;

		/* Get WrmBuffer structure */
		if (copy_from_user(&sWrmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		uiTempVar = sWrmBuffer.Register & EEPROM_REJECT_MASK;
		if (!((Adapter->pstargetparams->m_u32Customize) & VSG_MODE) &&
			((uiTempVar == EEPROM_REJECT_REG_1) ||
				(uiTempVar == EEPROM_REJECT_REG_2) ||
				(uiTempVar == EEPROM_REJECT_REG_3) ||
				(uiTempVar == EEPROM_REJECT_REG_4))) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""EEPROM Access Denied, not in VSG Mode\n"");
			return -EFAULT;
		}

		Status = wrmalt(Adapter, (UINT)sWrmBuffer.Register,
				(PUINT)sWrmBuffer.Data, sizeof(ULONG));

		if (Status == STATUS_SUCCESS) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""WRM Done\n"");
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""WRM Failed\n"");
			Status = -EFAULT;
		}
		break;
	}

	case IOCTL_BCM_REGISTER_READ:
	case IOCTL_BCM_EEPROM_REGISTER_READ: {
		struct bcm_rdm_buffer sRdmBuffer = {0};
		PCHAR temp_buff = NULL;
		UINT uiTempVar = 0;
		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device in Idle Mode, Blocking Rdms\n"");
			return -EACCES;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sRdmBuffer))
			return -EINVAL;

		if (copy_from_user(&sRdmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if (IoBuffer.OutputLength > USHRT_MAX ||
			IoBuffer.OutputLength == 0) {
			return -EINVAL;
		}

		temp_buff = kmalloc(IoBuffer.OutputLength, GFP_KERNEL);
		if (!temp_buff)
			return STATUS_FAILURE;

		if ((((ULONG)sRdmBuffer.Register & 0x0F000000) != 0x0F000000) ||
			((ULONG)sRdmBuffer.Register & 0x3)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""RDM Done On invalid Address : %x Access Denied.\n"",
					(int)sRdmBuffer.Register);

			kfree(temp_buff);
			return -EINVAL;
		}

		uiTempVar = sRdmBuffer.Register & EEPROM_REJECT_MASK;
		bytes = rdmaltWithLock(Adapter, (UINT)sRdmBuffer.Register, (PUINT)temp_buff, IoBuffer.OutputLength);

		if (bytes > 0) {
			Status = STATUS_SUCCESS;
			if (copy_to_user(IoBuffer.OutputBuffer, temp_buff, bytes)) {
				kfree(temp_buff);
				return -EFAULT;
			}
		} else {
			Status = bytes;
		}

		kfree(temp_buff);
		break;
	}
	case IOCTL_BCM_REGISTER_WRITE:
	case IOCTL_BCM_EEPROM_REGISTER_WRITE: {
		struct bcm_wrm_buffer sWrmBuffer = {0};
		UINT uiTempVar = 0;

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device in Idle Mode, Blocking Wrms\n"");
			return -EACCES;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(sWrmBuffer))
			return -EINVAL;

		/* Get WrmBuffer structure */
		if (copy_from_user(&sWrmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if ((((ULONG)sWrmBuffer.Register & 0x0F000000) != 0x0F000000) ||
			((ULONG)sWrmBuffer.Register & 0x3)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM Done On invalid Address : %x Access Denied.\n"", (int)sWrmBuffer.Register);
			return -EINVAL;
		}

		uiTempVar = sWrmBuffer.Register & EEPROM_REJECT_MASK;
		if (!((Adapter->pstargetparams->m_u32Customize) & VSG_MODE) &&
				((uiTempVar == EEPROM_REJECT_REG_1) ||
				(uiTempVar == EEPROM_REJECT_REG_2) ||
				(uiTempVar == EEPROM_REJECT_REG_3) ||
				(uiTempVar == EEPROM_REJECT_REG_4)) &&
				(cmd == IOCTL_BCM_REGISTER_WRITE)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""EEPROM Access Denied, not in VSG Mode\n"");
				return -EFAULT;
		}

		Status = wrmaltWithLock(Adapter, (UINT)sWrmBuffer.Register,
					(PUINT)sWrmBuffer.Data, sWrmBuffer.Length);

		if (Status == STATUS_SUCCESS) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL, ""WRM Done\n"");
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""WRM Failed\n"");
			Status = -EFAULT;
		}
		break;
	}
	case IOCTL_BCM_GPIO_SET_REQUEST: {
		UCHAR ucResetValue[4];
		UINT value = 0;
		UINT uiBit = 0;
		UINT uiOperation = 0;
		struct bcm_gpio_info gpio_info = {0};

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""GPIO Can't be set/clear in Low power Mode"");
			return -EACCES;
		}

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_info))
			return -EINVAL;

		if (copy_from_user(&gpio_info, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		uiBit  = gpio_info.uiGpioNumber;
		uiOperation = gpio_info.uiGpioValue;
		value = (1<<uiBit);

		if (IsReqGpioIsLedInNVM(Adapter, value) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Sorry, Requested GPIO<0x%X> is not correspond to LED !!!"", value);
			Status = -EINVAL;
			break;
		}

		/* Set - setting 1 */
		if (uiOperation) {
			/* Set the gpio output register */
			Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_SET_REG, (PUINT)(&value), sizeof(UINT));

			if (Status == STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Set the GPIO bit\n"");
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Failed to set the %dth GPIO\n"", uiBit);
				break;
			}
		} else {
			/* Set the gpio output register */
			Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_CLR_REG, (PUINT)(&value), sizeof(UINT));

			if (Status == STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Set the GPIO bit\n"");
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Failed to clear the %dth GPIO\n"", uiBit);
				break;
			}
		}

		bytes = rdmaltWithLock(Adapter, (UINT)GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));
		if (bytes < 0) {
			Status = bytes;
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""GPIO_MODE_REGISTER read failed"");
			break;
		} else {
			Status = STATUS_SUCCESS;
		}

		/* Set the gpio mode register to output */
		*(UINT *)ucResetValue |= (1<<uiBit);
		Status = wrmaltWithLock(Adapter, GPIO_MODE_REGISTER,
					(PUINT)ucResetValue, sizeof(UINT));

		if (Status == STATUS_SUCCESS) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Set the GPIO to output Mode\n"");
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Failed to put GPIO in Output Mode\n"");
			break;
		}
	}
	break;

	case BCM_LED_THREAD_STATE_CHANGE_REQ: {
		struct bcm_user_thread_req threadReq = {0};
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""User made LED thread InActive"");

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""GPIO Can't be set/clear in Low power Mode"");
			Status = -EACCES;
			break;
		}

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(threadReq))
			return -EINVAL;

		if (copy_from_user(&threadReq, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		/* if LED thread is running(Actively or Inactively) set it state to make inactive */
		if (Adapter->LEDInfo.led_thread_running) {
			if (threadReq.ThreadState == LED_THREAD_ACTIVATION_REQ) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Activating thread req"");
				Adapter->DriverState = LED_THREAD_ACTIVE;
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""DeActivating Thread req....."");
				Adapter->DriverState = LED_THREAD_INACTIVE;
			}

			/* signal thread. */
			wake_up(&Adapter->LEDInfo.notify_led_event);
		}
	}
	break;

	case IOCTL_BCM_GPIO_STATUS_REQUEST: {
		ULONG uiBit = 0;
		UCHAR ucRead[4];
		struct bcm_gpio_info gpio_info = {0};

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE))
			return -EACCES;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_info))
			return -EINVAL;

		if (copy_from_user(&gpio_info, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		uiBit = gpio_info.uiGpioNumber;

		/* Set the gpio output register */
		bytes = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER,
					(PUINT)ucRead, sizeof(UINT));

		if (bytes < 0) {
			Status = bytes;
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""RDM Failed\n"");
			return Status;
		} else {
			Status = STATUS_SUCCESS;
		}
	}
	break;

	case IOCTL_BCM_GPIO_MULTI_REQUEST: {
		UCHAR ucResetValue[4];
		struct bcm_gpio_multi_info gpio_multi_info[MAX_IDX];
		struct bcm_gpio_multi_info *pgpio_multi_info = (struct bcm_gpio_multi_info *)gpio_multi_info;

		memset(pgpio_multi_info, 0, MAX_IDX * sizeof(struct bcm_gpio_multi_info));

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE))
			return -EINVAL;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_multi_info))
			return -EINVAL;

		if (copy_from_user(&gpio_multi_info, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		if (IsReqGpioIsLedInNVM(Adapter, pgpio_multi_info[WIMAX_IDX].uiGPIOMask) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!"",
					pgpio_multi_info[WIMAX_IDX].uiGPIOMask, Adapter->gpioBitMap);
			Status = -EINVAL;
			break;
		}

		/* Set the gpio output register */
		if ((pgpio_multi_info[WIMAX_IDX].uiGPIOMask) &
			(pgpio_multi_info[WIMAX_IDX].uiGPIOCommand)) {
			/* Set 1's in GPIO OUTPUT REGISTER */
			*(UINT *)ucResetValue =  pgpio_multi_info[WIMAX_IDX].uiGPIOMask &
				pgpio_multi_info[WIMAX_IDX].uiGPIOCommand &
				pgpio_multi_info[WIMAX_IDX].uiGPIOValue;

			if (*(UINT *) ucResetValue)
				Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_SET_REG,
							(PUINT)ucResetValue, sizeof(ULONG));

			if (Status != STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM to BCM_GPIO_OUTPUT_SET_REG Failed."");
				return Status;
			}

			/* Clear to 0's in GPIO OUTPUT REGISTER */
			*(UINT *)ucResetValue = (pgpio_multi_info[WIMAX_IDX].uiGPIOMask &
						pgpio_multi_info[WIMAX_IDX].uiGPIOCommand &
						(~(pgpio_multi_info[WIMAX_IDX].uiGPIOValue)));

			if (*(UINT *) ucResetValue)
				Status = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_CLR_REG, (PUINT)ucResetValue, sizeof(ULONG));

			if (Status != STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM to BCM_GPIO_OUTPUT_CLR_REG Failed."");
				return Status;
			}
		}

		if (pgpio_multi_info[WIMAX_IDX].uiGPIOMask) {
			bytes = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));

			if (bytes < 0) {
				Status = bytes;
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""RDM to GPIO_PIN_STATE_REGISTER Failed."");
				return Status;
			} else {
				Status = STATUS_SUCCESS;
			}

			pgpio_multi_info[WIMAX_IDX].uiGPIOValue = (*(UINT *)ucResetValue &
								pgpio_multi_info[WIMAX_IDX].uiGPIOMask);
		}

		Status = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_info, IoBuffer.OutputLength);
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Failed while copying Content to IOBufer for user space err:%d"", Status);
			return -EFAULT;
		}
	}
	break;

	case IOCTL_BCM_GPIO_MODE_REQUEST: {
		UCHAR ucResetValue[4];
		struct bcm_gpio_multi_mode gpio_multi_mode[MAX_IDX];
		struct bcm_gpio_multi_mode *pgpio_multi_mode = (struct bcm_gpio_multi_mode *)gpio_multi_mode;

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE))
			return -EINVAL;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength > sizeof(gpio_multi_mode))
			return -EINVAL;

		if (copy_from_user(&gpio_multi_mode, IoBuffer.InputBuffer, IoBuffer.InputLength))
			return -EFAULT;

		bytes = rdmaltWithLock(Adapter, (UINT)GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));

		if (bytes < 0) {
			Status = bytes;
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Read of GPIO_MODE_REGISTER failed"");
			return Status;
		} else {
			Status = STATUS_SUCCESS;
		}

		/* Validating the request */
		if (IsReqGpioIsLedInNVM(Adapter, pgpio_multi_mode[WIMAX_IDX].uiGPIOMask) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!"",
					pgpio_multi_mode[WIMAX_IDX].uiGPIOMask, Adapter->gpioBitMap);
			Status = -EINVAL;
			break;
		}

		if (pgpio_multi_mode[WIMAX_IDX].uiGPIOMask) {
			/* write all OUT's (1's) */
			*(UINT *) ucResetValue |= (pgpio_multi_mode[WIMAX_IDX].uiGPIOMode &
						pgpio_multi_mode[WIMAX_IDX].uiGPIOMask);

			/* write all IN's (0's) */
			*(UINT *) ucResetValue &= ~((~pgpio_multi_mode[WIMAX_IDX].uiGPIOMode) &
						pgpio_multi_mode[WIMAX_IDX].uiGPIOMask);

			/* Currently implemented return the modes of all GPIO's
			 * else needs to bit AND with  mask
			 */
			pgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT *)ucResetValue;

			Status = wrmaltWithLock(Adapter, GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(ULONG));
			if (Status == STATUS_SUCCESS) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
						""WRM to GPIO_MODE_REGISTER Done"");
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
						""WRM to GPIO_MODE_REGISTER Failed"");
				Status = -EFAULT;
				break;
			}
		} else {
/* if uiGPIOMask is 0 then return mode register configuration */
			pgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT *)ucResetValue;
		}

		Status = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_mode, IoBuffer.OutputLength);
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Failed while copying Content to IOBufer for user space err:%d"", Status);
			return -EFAULT;
		}
	}
	break;

	case IOCTL_MAC_ADDR_REQ:
	case IOCTL_LINK_REQ:
	case IOCTL_CM_REQUEST:
	case IOCTL_SS_INFO_REQ:
	case IOCTL_SEND_CONTROL_MESSAGE:
	case IOCTL_IDLE_REQ: {
		PVOID pvBuffer = NULL;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength < sizeof(struct bcm_link_request))
			return -EINVAL;

		if (IoBuffer.InputLength > MAX_CNTL_PKT_SIZE)
			return -EINVAL;

		pvBuffer = memdup_user(IoBuffer.InputBuffer,
				       IoBuffer.InputLength);
		if (IS_ERR(pvBuffer))
			return PTR_ERR(pvBuffer);

		down(&Adapter->LowPowerModeSync);
		Status = wait_event_interruptible_timeout(Adapter->lowpower_mode_wait_queue,
							!Adapter->bPreparingForLowPowerMode,
							(1 * HZ));
		if (Status == -ERESTARTSYS)
			goto cntrlEnd;

		if (Adapter->bPreparingForLowPowerMode) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""Preparing Idle Mode is still True - Hence Rejecting control message\n"");
			Status = STATUS_FAILURE;
			goto cntrlEnd;
		}
		Status = CopyBufferToControlPacket(Adapter, (PVOID)pvBuffer);

cntrlEnd:
		up(&Adapter->LowPowerModeSync);
		kfree(pvBuffer);
		break;
	}

	case IOCTL_BCM_BUFFER_DOWNLOAD_START: {
		if (down_trylock(&Adapter->NVMRdmWrmLock)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,
					""IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\n"");
			return -EACCES;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
				""Starting the firmware download PID =0x%x!!!!\n"", current->pid);

		if (down_trylock(&Adapter->fw_download_sema))
			return -EBUSY;

		Adapter->bBinDownloaded = FALSE;
		Adapter->fw_download_process_pid = current->pid;
		Adapter->bCfgDownloaded = FALSE;
		Adapter->fw_download_done = FALSE;
		netif_carrier_off(Adapter->dev);
		netif_stop_queue(Adapter->dev);
		Status = reset_card_proc(Adapter);
		if (Status) {
			pr_err(PFX ""%s: reset_card_proc Failed!\n"", Adapter->dev->name);
			up(&Adapter->fw_download_sema);
			up(&Adapter->NVMRdmWrmLock);
			return Status;
		}
		mdelay(10);

		up(&Adapter->NVMRdmWrmLock);
		return Status;
	}

	case IOCTL_BCM_BUFFER_DOWNLOAD: {
		struct bcm_firmware_info *psFwInfo = NULL;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Starting the firmware download PID =0x%x!!!!\n"", current->pid);

		if (!down_trylock(&Adapter->fw_download_sema)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Invalid way to download buffer. Use Start and then call this!!!\n"");
			up(&Adapter->fw_download_sema);
			Status = -EINVAL;
			return Status;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {
			up(&Adapter->fw_download_sema);
			return -EFAULT;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
				""Length for FW DLD is : %lx\n"", IoBuffer.InputLength);

		if (IoBuffer.InputLength > sizeof(struct bcm_firmware_info)) {
			up(&Adapter->fw_download_sema);
			return -EINVAL;
		}

		psFwInfo = kmalloc(sizeof(*psFwInfo), GFP_KERNEL);
		if (!psFwInfo) {
			up(&Adapter->fw_download_sema);
			return -ENOMEM;
		}

		if (copy_from_user(psFwInfo, IoBuffer.InputBuffer, IoBuffer.InputLength)) {
			up(&Adapter->fw_download_sema);
			kfree(psFwInfo);
			return -EFAULT;
		}

		if (!psFwInfo->pvMappedFirmwareAddress ||
			(psFwInfo->u32FirmwareLength == 0)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Something else is wrong %lu\n"",
					psFwInfo->u32FirmwareLength);
			up(&Adapter->fw_download_sema);
			kfree(psFwInfo);
			Status = -EINVAL;
			return Status;
		}

		Status = bcm_ioctl_fw_download(Adapter, psFwInfo);

		if (Status != STATUS_SUCCESS) {
			if (psFwInfo->u32StartingAddress == CONFIG_BEGIN_ADDR)
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""IOCTL: Configuration File Upload Failed\n"");
			else
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,	""IOCTL: Firmware File Upload Failed\n"");

			/* up(&Adapter->fw_download_sema); */

			if (Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY) {
				Adapter->DriverState = DRIVER_INIT;
				Adapter->LEDInfo.bLedInitDone = FALSE;
				wake_up(&Adapter->LEDInfo.notify_led_event);
			}
		}

		if (Status != STATUS_SUCCESS)
			up(&Adapter->fw_download_sema);

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL, ""IOCTL: Firmware File Uploaded\n"");
		kfree(psFwInfo);
		return Status;
	}

	case IOCTL_BCM_BUFFER_DOWNLOAD_STOP: {
		if (!down_trylock(&Adapter->fw_download_sema)) {
			up(&Adapter->fw_download_sema);
			return -EINVAL;
		}

		if (down_trylock(&Adapter->NVMRdmWrmLock)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""FW download blocked as EEPROM Read/Write is in progress\n"");
			up(&Adapter->fw_download_sema);
			return -EACCES;
		}

		Adapter->bBinDownloaded = TRUE;
		Adapter->bCfgDownloaded = TRUE;
		atomic_set(&Adapter->CurrNumFreeTxDesc, 0);
		Adapter->CurrNumRecvDescs = 0;
		Adapter->downloadDDR = 0;

		/* setting the Mips to Run */
		Status = run_card_proc(Adapter);

		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Firm Download Failed\n"");
			up(&Adapter->fw_download_sema);
			up(&Adapter->NVMRdmWrmLock);
			return Status;
		} else {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG,
					DBG_LVL_ALL, ""Firm Download Over...\n"");
		}

		mdelay(10);

		/* Wait for MailBox Interrupt */
		if (StartInterruptUrb((struct bcm_interface_adapter *)Adapter->pvInterfaceAdapter))
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Unable to send interrupt...\n"");

		timeout = 5*HZ;
		Adapter->waiting_to_fw_download_done = FALSE;
		wait_event_timeout(Adapter->ioctl_fw_dnld_wait_queue,
				Adapter->waiting_to_fw_download_done, timeout);
		Adapter->fw_download_process_pid = INVALID_PID;
		Adapter->fw_download_done = TRUE;
		atomic_set(&Adapter->CurrNumFreeTxDesc, 0);
		Adapter->CurrNumRecvDescs = 0;
		Adapter->PrevNumRecvDescs = 0;
		atomic_set(&Adapter->cntrlpktCnt, 0);
		Adapter->LinkUpStatus = 0;
		Adapter->LinkStatus = 0;

		if (Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY) {
			Adapter->DriverState = FW_DOWNLOAD_DONE;
			wake_up(&Adapter->LEDInfo.notify_led_event);
		}

		if (!timeout)
			Status = -ENODEV;

		up(&Adapter->fw_download_sema);
		up(&Adapter->NVMRdmWrmLock);
		return Status;
	}

	case IOCTL_BE_BUCKET_SIZE:
		Status = 0;
		if (get_user(Adapter->BEBucketSize, (unsigned long __user *)arg))
			Status = -EFAULT;
		break;

	case IOCTL_RTPS_BUCKET_SIZE:
		Status = 0;
		if (get_user(Adapter->rtPSBucketSize, (unsigned long __user *)arg))
			Status = -EFAULT;
		break;

	case IOCTL_CHIP_RESET: {
		INT NVMAccess = down_trylock(&Adapter->NVMRdmWrmLock);
		if (NVMAccess) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "" IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\n"");
			return -EACCES;
		}

		down(&Adapter->RxAppControlQueuelock);
		Status = reset_card_proc(Adapter);
		flushAllAppQ();
		up(&Adapter->RxAppControlQueuelock);
		up(&Adapter->NVMRdmWrmLock);
		ResetCounters(Adapter);
		break;
	}

	case IOCTL_QOS_THRESHOLD: {
		USHORT uiLoopIndex;

		Status = 0;
		for (uiLoopIndex = 0; uiLoopIndex < NO_OF_QUEUES; uiLoopIndex++) {
			if (get_user(Adapter->PackInfo[uiLoopIndex].uiThreshold,
					(unsigned long __user *)arg)) {
				Status = -EFAULT;
				break;
			}
		}
		break;
	}

	case IOCTL_DUMP_PACKET_INFO:
		DumpPackInfo(Adapter);
		DumpPhsRules(&Adapter->stBCMPhsContext);
		Status = STATUS_SUCCESS;
		break;

	case IOCTL_GET_PACK_INFO:
		if (copy_to_user(argp, &Adapter->PackInfo, sizeof(struct bcm_packet_info)*NO_OF_QUEUES))
			return -EFAULT;
		Status = STATUS_SUCCESS;
		break;

	case IOCTL_BCM_SWITCH_TRANSFER_MODE: {
		UINT uiData = 0;
		if (copy_from_user(&uiData, argp, sizeof(UINT)))
			return -EFAULT;

		if (uiData) {
			/* Allow All Packets */
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SWITCH_TRANSFER_MODE: ETH_PACKET_TUNNELING_MODE\n"");
				Adapter->TransferMode = ETH_PACKET_TUNNELING_MODE;
		} else {
			/* Allow IP only Packets */
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SWITCH_TRANSFER_MODE: IP_PACKET_ONLY_MODE\n"");
			Adapter->TransferMode = IP_PACKET_ONLY_MODE;
		}
		Status = STATUS_SUCCESS;
		break;
	}

	case IOCTL_BCM_GET_DRIVER_VERSION: {
		ulong len;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		len = min_t(ulong, IoBuffer.OutputLength, strlen(DRV_VERSION) + 1);

		if (copy_to_user(IoBuffer.OutputBuffer, DRV_VERSION, len))
			return -EFAULT;
		Status = STATUS_SUCCESS;
		break;
	}

	case IOCTL_BCM_GET_CURRENT_STATUS: {
		struct bcm_link_state link_state;

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""copy_from_user failed..\n"");
			return -EFAULT;
		}

		if (IoBuffer.OutputLength != sizeof(link_state)) {
			Status = -EINVAL;
			break;
		}

		memset(&link_state, 0, sizeof(link_state));
		link_state.bIdleMode = Adapter->IdleMode;
		link_state.bShutdownMode = Adapter->bShutStatus;
		link_state.ucLinkStatus = Adapter->LinkStatus;

		if (copy_to_user(IoBuffer.OutputBuffer, &link_state, min_t(size_t, sizeof(link_state), IoBuffer.OutputLength))) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy_to_user Failed..\n"");
			return -EFAULT;
		}
		Status = STATUS_SUCCESS;
		break;
	}

	case IOCTL_BCM_SET_MAC_TRACING: {
		UINT  tracing_flag;

		/* copy ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (copy_from_user(&tracing_flag, IoBuffer.InputBuffer, sizeof(UINT)))
			return -EFAULT;

		if (tracing_flag)
			Adapter->pTarangs->MacTracingEnabled = TRUE;
		else
			Adapter->pTarangs->MacTracingEnabled = FALSE;
		break;
	}

	case IOCTL_BCM_GET_DSX_INDICATION: {
		ULONG ulSFId = 0;
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength < sizeof(struct bcm_add_indication_alt)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Mismatch req: %lx needed is =0x%zx!!!"",
					IoBuffer.OutputLength, sizeof(struct bcm_add_indication_alt));
			return -EINVAL;
		}

		if (copy_from_user(&ulSFId, IoBuffer.InputBuffer, sizeof(ulSFId)))
			return -EFAULT;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Get DSX Data SF ID is =%lx\n"", ulSFId);
		get_dsx_sf_data_to_application(Adapter, ulSFId, IoBuffer.OutputBuffer);
		Status = STATUS_SUCCESS;
	}
	break;

	case IOCTL_BCM_GET_HOST_MIBS: {
		PVOID temp_buff;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength != sizeof(struct bcm_host_stats_mibs)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,
					""Length Check failed %lu %zd\n"",
					IoBuffer.OutputLength, sizeof(struct bcm_host_stats_mibs));
			return -EINVAL;
		}

		/* FIXME: HOST_STATS are too big for kmalloc (122048)! */
		temp_buff = kzalloc(sizeof(struct bcm_host_stats_mibs), GFP_KERNEL);
		if (!temp_buff)
			return STATUS_FAILURE;

		Status = ProcessGetHostMibs(Adapter, temp_buff);
		GetDroppedAppCntrlPktMibs(temp_buff, pTarang);

		if (Status != STATUS_FAILURE)
			if (copy_to_user(IoBuffer.OutputBuffer, temp_buff, sizeof(struct bcm_host_stats_mibs))) {
				kfree(temp_buff);
				return -EFAULT;
			}

		kfree(temp_buff);
		break;
	}

	case IOCTL_BCM_WAKE_UP_DEVICE_FROM_IDLE:
		if ((FALSE == Adapter->bTriedToWakeUpFromlowPowerMode) && (TRUE == Adapter->IdleMode)) {
			Adapter->usIdleModePattern = ABORT_IDLE_MODE;
			Adapter->bWakeUpDevice = TRUE;
			wake_up(&Adapter->process_rx_cntrlpkt);
		}

		Status = STATUS_SUCCESS;
		break;

	case IOCTL_BCM_BULK_WRM: {
		struct bcm_bulk_wrm_buffer *pBulkBuffer;
		UINT uiTempVar = 0;
		PCHAR pvBuffer = NULL;

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device in Idle/Shutdown Mode, Blocking Wrms\n"");
			Status = -EACCES;
			break;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.InputLength < sizeof(ULONG) * 2)
			return -EINVAL;

		pvBuffer = memdup_user(IoBuffer.InputBuffer,
				       IoBuffer.InputLength);
		if (IS_ERR(pvBuffer))
			return PTR_ERR(pvBuffer);

		pBulkBuffer = (struct bcm_bulk_wrm_buffer *)pvBuffer;

		if (((ULONG)pBulkBuffer->Register & 0x0F000000) != 0x0F000000 ||
			((ULONG)pBulkBuffer->Register & 0x3)) {
			BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM Done On invalid Address : %x Access Denied.\n"", (int)pBulkBuffer->Register);
			kfree(pvBuffer);
			Status = -EINVAL;
			break;
		}

		uiTempVar = pBulkBuffer->Register & EEPROM_REJECT_MASK;
		if (!((Adapter->pstargetparams->m_u32Customize)&VSG_MODE) &&
			((uiTempVar == EEPROM_REJECT_REG_1) ||
				(uiTempVar == EEPROM_REJECT_REG_2) ||
				(uiTempVar == EEPROM_REJECT_REG_3) ||
				(uiTempVar == EEPROM_REJECT_REG_4)) &&
			(cmd == IOCTL_BCM_REGISTER_WRITE)) {

			kfree(pvBuffer);
			BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""EEPROM Access Denied, not in VSG Mode\n"");
			Status = -EFAULT;
			break;
		}

		if (pBulkBuffer->SwapEndian == FALSE)
			Status = wrmWithLock(Adapter, (UINT)pBulkBuffer->Register, (PCHAR)pBulkBuffer->Values, IoBuffer.InputLength - 2*sizeof(ULONG));
		else
			Status = wrmaltWithLock(Adapter, (UINT)pBulkBuffer->Register, (PUINT)pBulkBuffer->Values, IoBuffer.InputLength - 2*sizeof(ULONG));

		if (Status != STATUS_SUCCESS)
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""WRM Failed\n"");

		kfree(pvBuffer);
		break;
	}

	case IOCTL_BCM_GET_NVM_SIZE:
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (Adapter->eNVMType == NVM_EEPROM || Adapter->eNVMType == NVM_FLASH) {
			if (copy_to_user(IoBuffer.OutputBuffer, &Adapter->uiNVMDSDSize, sizeof(UINT)))
				return -EFAULT;
		}

		Status = STATUS_SUCCESS;
		break;

	case IOCTL_BCM_CAL_INIT: {
		UINT uiSectorSize = 0 ;
		if (Adapter->eNVMType == NVM_FLASH) {
			if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
				return -EFAULT;

			if (copy_from_user(&uiSectorSize, IoBuffer.InputBuffer, sizeof(UINT)))
				return -EFAULT;

			if ((uiSectorSize < MIN_SECTOR_SIZE) || (uiSectorSize > MAX_SECTOR_SIZE)) {
				if (copy_to_user(IoBuffer.OutputBuffer, &Adapter->uiSectorSize,
							sizeof(UINT)))
					return -EFAULT;
			} else {
				if (IsFlash2x(Adapter)) {
					if (copy_to_user(IoBuffer.OutputBuffer,	&Adapter->uiSectorSize, sizeof(UINT)))
						return -EFAULT;
				} else {
					if ((TRUE == Adapter->bShutStatus) || (TRUE == Adapter->IdleMode)) {
						BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device is in Idle/Shutdown Mode\n"");
						return -EACCES;
					}

					Adapter->uiSectorSize = uiSectorSize;
					BcmUpdateSectorSize(Adapter, Adapter->uiSectorSize);
				}
			}
			Status = STATUS_SUCCESS;
		} else {
			Status = STATUS_FAILURE;
		}
	}
	break;

	case IOCTL_BCM_SET_DEBUG:
#ifdef DEBUG
	{
		struct bcm_user_debug_state sUserDebugState;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""In SET_DEBUG ioctl\n"");
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (copy_from_user(&sUserDebugState, IoBuffer.InputBuffer, sizeof(struct bcm_user_debug_state)))
			return -EFAULT;

		BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""IOCTL_BCM_SET_DEBUG: OnOff=%d Type = 0x%x "",
				sUserDebugState.OnOff, sUserDebugState.Type);
		/* sUserDebugState.Subtype <<= 1; */
		sUserDebugState.Subtype = 1 << sUserDebugState.Subtype;
		BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, ""actual Subtype=0x%x\n"", sUserDebugState.Subtype);

		/* Update new 'DebugState' in the Adapter */
		Adapter->stDebugState.type |= sUserDebugState.Type;
		/* Subtype: A bitmap of 32 bits for Subtype per Type.
		 * Valid indexes in 'subtype' array: 1,2,4,8
		 * corresponding to valid Type values. Hence we can use the 'Type' field
		 * as the index value, ignoring the array entries 0,3,5,6,7 !
		 */
		if (sUserDebugState.OnOff)
			Adapter->stDebugState.subtype[sUserDebugState.Type] |= sUserDebugState.Subtype;
		else
			Adapter->stDebugState.subtype[sUserDebugState.Type] &= ~sUserDebugState.Subtype;

		BCM_SHOW_DEBUG_BITMAP(Adapter);
	}
#endif
	break;

	case IOCTL_BCM_NVM_READ:
	case IOCTL_BCM_NVM_WRITE: {
		struct bcm_nvm_readwrite stNVMReadWrite;
		PUCHAR pReadData = NULL;
		ULONG ulDSDMagicNumInUsrBuff = 0;
		struct timeval tv0, tv1;
		memset(&tv0, 0, sizeof(struct timeval));
		memset(&tv1, 0, sizeof(struct timeval));
		if ((Adapter->eNVMType == NVM_FLASH) && (Adapter->uiFlashLayoutMajorVersion == 0)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""The Flash Control Section is Corrupted. Hence Rejection on NVM Read/Write\n"");
			return -EFAULT;
		}

		if (IsFlash2x(Adapter)) {
			if ((Adapter->eActiveDSD != DSD0) &&
				(Adapter->eActiveDSD != DSD1) &&
				(Adapter->eActiveDSD != DSD2)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""No DSD is active..hence NVM Command is blocked"");
				return STATUS_FAILURE;
			}
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (copy_from_user(&stNVMReadWrite,
					(IOCTL_BCM_NVM_READ == cmd) ? IoBuffer.OutputBuffer : IoBuffer.InputBuffer,
					sizeof(struct bcm_nvm_readwrite)))
			return -EFAULT;

		/*
		 * Deny the access if the offset crosses the cal area limit.
		 */
		if (stNVMReadWrite.uiNumBytes > Adapter->uiNVMDSDSize)
			return STATUS_FAILURE;

		if (stNVMReadWrite.uiOffset > Adapter->uiNVMDSDSize - stNVMReadWrite.uiNumBytes) {
			/* BCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,""Can't allow access beyond NVM Size: 0x%x 0x%x\n"", stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes); */
			return STATUS_FAILURE;
		}

		pReadData = memdup_user(stNVMReadWrite.pBuffer,
					stNVMReadWrite.uiNumBytes);
		if (IS_ERR(pReadData))
			return PTR_ERR(pReadData);

		do_gettimeofday(&tv0);
		if (IOCTL_BCM_NVM_READ == cmd) {
			down(&Adapter->NVMRdmWrmLock);

			if ((Adapter->IdleMode == TRUE) ||
				(Adapter->bShutStatus == TRUE) ||
				(Adapter->bPreparingForLowPowerMode == TRUE)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadData);
				return -EACCES;
			}

			Status = BeceemNVMRead(Adapter, (PUINT)pReadData, stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes);
			up(&Adapter->NVMRdmWrmLock);

			if (Status != STATUS_SUCCESS) {
				kfree(pReadData);
				return Status;
			}

			if (copy_to_user(stNVMReadWrite.pBuffer, pReadData, stNVMReadWrite.uiNumBytes)) {
				kfree(pReadData);
				return -EFAULT;
			}
		} else {
			down(&Adapter->NVMRdmWrmLock);

			if ((Adapter->IdleMode == TRUE) ||
				(Adapter->bShutStatus == TRUE) ||
				(Adapter->bPreparingForLowPowerMode == TRUE)) {

				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadData);
				return -EACCES;
			}

			Adapter->bHeaderChangeAllowed = TRUE;
			if (IsFlash2x(Adapter)) {
				/*
				 *			New Requirement:-
				 *			DSD section updation will be allowed in two case:-
				 *			1.  if DSD sig is present in DSD header means dongle is ok and updation is fruitfull
				 *			2.  if point 1 failes then user buff should have DSD sig. this point ensures that if dongle is
				 *			      corrupted then user space program first modify the DSD header with valid DSD sig so
				 *			      that this as well as further write may be worthwhile.
				 *
				 *			 This restriction has been put assuming that if DSD sig is corrupted, DSD
				 *			 data won't be considered valid.
				 */

				Status = BcmFlash2xCorruptSig(Adapter, Adapter->eActiveDSD);
				if (Status != STATUS_SUCCESS) {
					if (((stNVMReadWrite.uiOffset + stNVMReadWrite.uiNumBytes) != Adapter->uiNVMDSDSize) ||
						(stNVMReadWrite.uiNumBytes < SIGNATURE_SIZE)) {

						BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""DSD Sig is present neither in Flash nor User provided Input.."");
						up(&Adapter->NVMRdmWrmLock);
						kfree(pReadData);
						return Status;
					}

					ulDSDMagicNumInUsrBuff = ntohl(*(PUINT)(pReadData + stNVMReadWrite.uiNumBytes - SIGNATURE_SIZE));
					if (ulDSDMagicNumInUsrBuff != DSD_IMAGE_MAGIC_NUMBER) {
						BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""DSD Sig is present neither in Flash nor User provided Input.."");
						up(&Adapter->NVMRdmWrmLock);
						kfree(pReadData);
						return Status;
					}
				}
			}

			Status = BeceemNVMWrite(Adapter, (PUINT)pReadData, stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes, stNVMReadWrite.bVerify);
			if (IsFlash2x(Adapter))
				BcmFlash2xWriteSig(Adapter, Adapter->eActiveDSD);

			Adapter->bHeaderChangeAllowed = FALSE;

			up(&Adapter->NVMRdmWrmLock);

			if (Status != STATUS_SUCCESS) {
				kfree(pReadData);
				return Status;
			}
		}

		do_gettimeofday(&tv1);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "" timetaken by Write/read :%ld msec\n"", (tv1.tv_sec - tv0.tv_sec)*1000 + (tv1.tv_usec - tv0.tv_usec)/1000);

		kfree(pReadData);
		return STATUS_SUCCESS;
	}

	case IOCTL_BCM_FLASH2X_SECTION_READ: {
		struct bcm_flash2x_readwrite sFlash2xRead = {0};
		PUCHAR pReadBuff = NULL ;
		UINT NOB = 0;
		UINT BuffSize = 0;
		UINT ReadBytes = 0;
		UINT ReadOffset = 0;
		void __user *OutPutBuff;

		if (IsFlash2x(Adapter) != TRUE)	{
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_FLASH2X_SECTION_READ Called"");
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		/* Reading FLASH 2.x READ structure */
		if (copy_from_user(&sFlash2xRead, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_readwrite)))
			return -EFAULT;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.Section :%x"", sFlash2xRead.Section);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.offset :%x"", sFlash2xRead.offset);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.numOfBytes :%x"", sFlash2xRead.numOfBytes);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.bVerify :%x\n"", sFlash2xRead.bVerify);

		/* This was internal to driver for raw read. now it has ben exposed to user space app. */
		if (validateFlash2xReadWrite(Adapter, &sFlash2xRead) == FALSE)
			return STATUS_FAILURE;

		NOB = sFlash2xRead.numOfBytes;
		if (NOB > Adapter->uiSectorSize)
			BuffSize = Adapter->uiSectorSize;
		else
			BuffSize = NOB;

		ReadOffset = sFlash2xRead.offset ;
		OutPutBuff = IoBuffer.OutputBuffer;
		pReadBuff = (PCHAR)kzalloc(BuffSize , GFP_KERNEL);

		if (pReadBuff == NULL) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Memory allocation failed for Flash 2.x Read Structure"");
			return -ENOMEM;
		}
		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			kfree(pReadBuff);
			return -EACCES;
		}

		while (NOB) {
			if (NOB > Adapter->uiSectorSize)
				ReadBytes = Adapter->uiSectorSize;
			else
				ReadBytes = NOB;

			/* Reading the data from Flash 2.x */
			Status = BcmFlash2xBulkRead(Adapter, (PUINT)pReadBuff, sFlash2xRead.Section, ReadOffset, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Flash 2x read err with Status :%d"", Status);
				break;
			}

			BCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pReadBuff, ReadBytes);

			Status = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Copy to use failed with status :%d"", Status);
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadBuff);
				return -EFAULT;
			}
			NOB = NOB - ReadBytes;
			if (NOB) {
				ReadOffset = ReadOffset + ReadBytes;
				OutPutBuff = OutPutBuff + ReadBytes ;
			}
		}

		up(&Adapter->NVMRdmWrmLock);
		kfree(pReadBuff);
	}
	break;

	case IOCTL_BCM_FLASH2X_SECTION_WRITE: {
		struct bcm_flash2x_readwrite sFlash2xWrite = {0};
		PUCHAR pWriteBuff;
		void __user *InputAddr;
		UINT NOB = 0;
		UINT BuffSize = 0;
		UINT WriteOffset = 0;
		UINT WriteBytes = 0;

		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		/* First make this False so that we can enable the Sector Permission Check in BeceemFlashBulkWrite */
		Adapter->bAllDSDWriteAllow = FALSE;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_FLASH2X_SECTION_WRITE Called"");

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		/* Reading FLASH 2.x READ structure */
		if (copy_from_user(&sFlash2xWrite, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_readwrite)))
			return -EFAULT;

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.Section :%x"", sFlash2xWrite.Section);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.offset :%d"", sFlash2xWrite.offset);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.numOfBytes :%x"", sFlash2xWrite.numOfBytes);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\nsFlash2xRead.bVerify :%x\n"", sFlash2xWrite.bVerify);

		if ((sFlash2xWrite.Section != VSA0) && (sFlash2xWrite.Section != VSA1) && (sFlash2xWrite.Section != VSA2)) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Only VSA write is allowed"");
			return -EINVAL;
		}

		if (validateFlash2xReadWrite(Adapter, &sFlash2xWrite) == FALSE)
			return STATUS_FAILURE;

		InputAddr = sFlash2xWrite.pDataBuff;
		WriteOffset = sFlash2xWrite.offset;
		NOB = sFlash2xWrite.numOfBytes;

		if (NOB > Adapter->uiSectorSize)
			BuffSize = Adapter->uiSectorSize;
		else
			BuffSize = NOB ;

		pWriteBuff = kmalloc(BuffSize, GFP_KERNEL);

		if (pWriteBuff == NULL)
			return -ENOMEM;

		/* extracting the remainder of the given offset. */
		WriteBytes = Adapter->uiSectorSize;
		if (WriteOffset % Adapter->uiSectorSize)
			WriteBytes = Adapter->uiSectorSize - (WriteOffset % Adapter->uiSectorSize);

		if (NOB < WriteBytes)
			WriteBytes = NOB;

		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			kfree(pWriteBuff);
			return -EACCES;
		}

		BcmFlash2xCorruptSig(Adapter, sFlash2xWrite.Section);
		do {
			Status = copy_from_user(pWriteBuff, InputAddr, WriteBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy to user failed with status :%d"", Status);
				up(&Adapter->NVMRdmWrmLock);
				kfree(pWriteBuff);
				return -EFAULT;
			}
			BCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pWriteBuff, WriteBytes);

			/* Writing the data from Flash 2.x */
			Status = BcmFlash2xBulkWrite(Adapter, (PUINT)pWriteBuff, sFlash2xWrite.Section, WriteOffset, WriteBytes, sFlash2xWrite.bVerify);

			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash 2x read err with Status :%d"", Status);
				break;
			}

			NOB = NOB - WriteBytes;
			if (NOB) {
				WriteOffset = WriteOffset + WriteBytes;
				InputAddr = InputAddr + WriteBytes;
				if (NOB > Adapter->uiSectorSize)
					WriteBytes = Adapter->uiSectorSize;
				else
					WriteBytes = NOB;
			}
		} while (NOB > 0);

		BcmFlash2xWriteSig(Adapter, sFlash2xWrite.Section);
		up(&Adapter->NVMRdmWrmLock);
		kfree(pWriteBuff);
	}
	break;

	case IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP: {
		struct bcm_flash2x_bitmap *psFlash2xBitMap;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP Called"");

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength != sizeof(struct bcm_flash2x_bitmap))
			return -EINVAL;

		psFlash2xBitMap = kzalloc(sizeof(struct bcm_flash2x_bitmap), GFP_KERNEL);
		if (psFlash2xBitMap == NULL) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Memory is not available"");
			return -ENOMEM;
		}

		/* Reading the Flash Sectio Bit map */
		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			kfree(psFlash2xBitMap);
			return -EACCES;
		}

		BcmGetFlash2xSectionalBitMap(Adapter, psFlash2xBitMap);
		up(&Adapter->NVMRdmWrmLock);
		if (copy_to_user(IoBuffer.OutputBuffer, psFlash2xBitMap, sizeof(struct bcm_flash2x_bitmap))) {
			kfree(psFlash2xBitMap);
			return -EFAULT;
		}

		kfree(psFlash2xBitMap);
	}
	break;

	case IOCTL_BCM_SET_ACTIVE_SECTION: {
		enum bcm_flash2x_section_val eFlash2xSectionVal = 0;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SET_ACTIVE_SECTION Called"");

		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed"");
			return -EFAULT;
		}

		Status = copy_from_user(&eFlash2xSectionVal, IoBuffer.InputBuffer, sizeof(INT));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of flash section val failed"");
			return -EFAULT;
		}

		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			return -EACCES;
		}

		Status = BcmSetActiveSection(Adapter, eFlash2xSectionVal);
		if (Status)
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Failed to make it's priority Highest. Status %d"", Status);

		up(&Adapter->NVMRdmWrmLock);
	}
	break;

	case IOCTL_BCM_IDENTIFY_ACTIVE_SECTION: {
		/* Right Now we are taking care of only DSD */
		Adapter->bAllDSDWriteAllow = FALSE;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_IDENTIFY_ACTIVE_SECTION called"");
		Status = STATUS_SUCCESS;
	}
	break;

	case IOCTL_BCM_COPY_SECTION: {
		struct bcm_flash2x_copy_section sCopySectStrut = {0};
		Status = STATUS_SUCCESS;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_COPY_SECTION  Called"");

		Adapter->bAllDSDWriteAllow = FALSE;
		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed Status :%d"", Status);
			return -EFAULT;
		}

		Status = copy_from_user(&sCopySectStrut, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_copy_section));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of Copy_Section_Struct failed with Status :%d"", Status);
			return -EFAULT;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Source SEction :%x"", sCopySectStrut.SrcSection);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Destination SEction :%x"", sCopySectStrut.DstSection);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""offset :%x"", sCopySectStrut.offset);
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""NOB :%x"", sCopySectStrut.numOfBytes);

		if (IsSectionExistInFlash(Adapter, sCopySectStrut.SrcSection) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Source Section<%x> does not exixt in Flash "", sCopySectStrut.SrcSection);
			return -EINVAL;
		}

		if (IsSectionExistInFlash(Adapter, sCopySectStrut.DstSection) == FALSE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Destinatio Section<%x> does not exixt in Flash "", sCopySectStrut.DstSection);
			return -EINVAL;
		}

		if (sCopySectStrut.SrcSection == sCopySectStrut.DstSection) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Source and Destination section should be different"");
			return -EINVAL;
		}

		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			up(&Adapter->NVMRdmWrmLock);
			return -EACCES;
		}

		if (sCopySectStrut.SrcSection == ISO_IMAGE1 || sCopySectStrut.SrcSection == ISO_IMAGE2) {
			if (IsNonCDLessDevice(Adapter)) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Device is Non-CDLess hence won't have ISO !!"");
				Status = -EINVAL;
			} else if (sCopySectStrut.numOfBytes == 0) {
				Status = BcmCopyISO(Adapter, sCopySectStrut);
			} else {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Partial Copy of ISO section is not Allowed.."");
				Status = STATUS_FAILURE;
			}
			up(&Adapter->NVMRdmWrmLock);
			return Status;
		}

		Status = BcmCopySection(Adapter, sCopySectStrut.SrcSection,
					sCopySectStrut.DstSection, sCopySectStrut.offset, sCopySectStrut.numOfBytes);
		up(&Adapter->NVMRdmWrmLock);
	}
	break;

	case IOCTL_BCM_GET_FLASH_CS_INFO: {
		Status = STATUS_SUCCESS;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, "" IOCTL_BCM_GET_FLASH_CS_INFO Called"");

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed"");
			return -EFAULT;
		}

		if (Adapter->eNVMType != NVM_FLASH) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Connected device does not have flash"");
			Status = -EINVAL;
			break;
		}

		if (IsFlash2x(Adapter) == TRUE) {
			if (IoBuffer.OutputLength < sizeof(struct bcm_flash2x_cs_info))
				return -EINVAL;

			if (copy_to_user(IoBuffer.OutputBuffer, Adapter->psFlash2xCSInfo, sizeof(struct bcm_flash2x_cs_info)))
				return -EFAULT;
		} else {
			if (IoBuffer.OutputLength < sizeof(struct bcm_flash_cs_info))
				return -EINVAL;

			if (copy_to_user(IoBuffer.OutputBuffer, Adapter->psFlashCSInfo, sizeof(struct bcm_flash_cs_info)))
				return -EFAULT;
		}
	}
	break;

	case IOCTL_BCM_SELECT_DSD: {
		UINT SectOfset = 0;
		enum bcm_flash2x_section_val eFlash2xSectionVal;
		eFlash2xSectionVal = NO_SECTION_VAL;
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_SELECT_DSD Called"");

		if (IsFlash2x(Adapter) != TRUE) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash Does not have 2.x map"");
			return -EINVAL;
		}

		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of IOCTL BUFFER failed"");
			return -EFAULT;
		}
		Status = copy_from_user(&eFlash2xSectionVal, IoBuffer.InputBuffer, sizeof(INT));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy of flash section val failed"");
			return -EFAULT;
		}

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Read Section :%d"", eFlash2xSectionVal);
		if ((eFlash2xSectionVal != DSD0) &&
			(eFlash2xSectionVal != DSD1) &&
			(eFlash2xSectionVal != DSD2)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Passed section<%x> is not DSD section"", eFlash2xSectionVal);
			return STATUS_FAILURE;
		}

		SectOfset = BcmGetSectionValStartOffset(Adapter, eFlash2xSectionVal);
		if (SectOfset == INVALID_OFFSET) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Provided Section val <%d> does not exixt in Flash 2.x"", eFlash2xSectionVal);
			return -EINVAL;
		}

		Adapter->bAllDSDWriteAllow = TRUE;
		Adapter->ulFlashCalStart = SectOfset;
		Adapter->eActiveDSD = eFlash2xSectionVal;
	}
	Status = STATUS_SUCCESS;
	break;

	case IOCTL_BCM_NVM_RAW_READ: {
		struct bcm_nvm_readwrite stNVMRead;
		INT NOB ;
		INT BuffSize ;
		INT ReadOffset = 0;
		UINT ReadBytes = 0 ;
		PUCHAR pReadBuff;
		void __user *OutPutBuff;

		if (Adapter->eNVMType != NVM_FLASH) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""NVM TYPE is not Flash"");
			return -EINVAL;
		}

		/* Copy Ioctl Buffer structure */
		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""copy_from_user 1 failed\n"");
			return -EFAULT;
		}

		if (copy_from_user(&stNVMRead, IoBuffer.OutputBuffer, sizeof(struct bcm_nvm_readwrite)))
			return -EFAULT;

		NOB = stNVMRead.uiNumBytes;
		/* In Raw-Read max Buff size : 64MB */

		if (NOB > DEFAULT_BUFF_SIZE)
			BuffSize = DEFAULT_BUFF_SIZE;
		else
			BuffSize = NOB;

		ReadOffset = stNVMRead.uiOffset;
		OutPutBuff = stNVMRead.pBuffer;

		pReadBuff = kzalloc(BuffSize , GFP_KERNEL);
		if (pReadBuff == NULL) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Memory allocation failed for Flash 2.x Read Structure"");
			Status = -ENOMEM;
			break;
		}
		down(&Adapter->NVMRdmWrmLock);

		if ((Adapter->IdleMode == TRUE) ||
			(Adapter->bShutStatus == TRUE) ||
			(Adapter->bPreparingForLowPowerMode == TRUE)) {

			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Device is in Idle/Shutdown Mode\n"");
			kfree(pReadBuff);
			up(&Adapter->NVMRdmWrmLock);
			return -EACCES;
		}

		Adapter->bFlashRawRead = TRUE;

		while (NOB) {
			if (NOB > DEFAULT_BUFF_SIZE)
				ReadBytes = DEFAULT_BUFF_SIZE;
			else
				ReadBytes = NOB;

			/* Reading the data from Flash 2.x */
			Status = BeceemNVMRead(Adapter, (PUINT)pReadBuff, ReadOffset, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Flash 2x read err with Status :%d"", Status);
				break;
			}

			BCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pReadBuff, ReadBytes);

			Status = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);
			if (Status) {
				BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, ""Copy to use failed with status :%d"", Status);
				up(&Adapter->NVMRdmWrmLock);
				kfree(pReadBuff);
				return -EFAULT;
			}
			NOB = NOB - ReadBytes;
			if (NOB) {
				ReadOffset = ReadOffset + ReadBytes;
				OutPutBuff = OutPutBuff + ReadBytes;
			}
		}
		Adapter->bFlashRawRead = FALSE;
		up(&Adapter->NVMRdmWrmLock);
		kfree(pReadBuff);
		break;
	}

	case IOCTL_BCM_CNTRLMSG_MASK: {
		ULONG RxCntrlMsgBitMask = 0;

		/* Copy Ioctl Buffer structure */
		Status = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""copy of Ioctl buffer is failed from user space"");
			return -EFAULT;
		}

		if (IoBuffer.InputLength != sizeof(unsigned long)) {
			Status = -EINVAL;
			break;
		}

		Status = copy_from_user(&RxCntrlMsgBitMask, IoBuffer.InputBuffer, IoBuffer.InputLength);
		if (Status) {
			BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""copy of control bit mask failed from user space"");
			return -EFAULT;
		}
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""\n Got user defined cntrl msg bit mask :%lx"", RxCntrlMsgBitMask);
		pTarang->RxCntrlMsgBitMask = RxCntrlMsgBitMask;
	}
	break;

	case IOCTL_BCM_GET_DEVICE_DRIVER_INFO: {
		struct bcm_driver_info DevInfo;
 
 		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Called IOCTL_BCM_GET_DEVICE_DRIVER_INFO\n"");
 
		memset(&DevInfo, 0, sizeof(DevInfo));
 		DevInfo.MaxRDMBufferSize = BUFFER_4K;
 		DevInfo.u32DSDStartOffset = EEPROM_CALPARAM_START;
 		DevInfo.u32RxAlignmentCorrection = 0;
		DevInfo.u32NVMType = Adapter->eNVMType;
		DevInfo.u32InterfaceType = BCM_USB;

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength < sizeof(DevInfo))
			return -EINVAL;

		if (copy_to_user(IoBuffer.OutputBuffer, &DevInfo, sizeof(DevInfo)))
			return -EFAULT;
	}
	break;

	case IOCTL_BCM_TIME_SINCE_NET_ENTRY: {
		struct bcm_time_elapsed stTimeElapsedSinceNetEntry = {0};

		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_BCM_TIME_SINCE_NET_ENTRY called"");

		if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))
			return -EFAULT;

		if (IoBuffer.OutputLength < sizeof(struct bcm_time_elapsed))
			return -EINVAL;

		stTimeElapsedSinceNetEntry.ul64TimeElapsedSinceNetEntry = get_seconds() - Adapter->liTimeSinceLastNetEntry;

		if (copy_to_user(IoBuffer.OutputBuffer, &stTimeElapsedSinceNetEntry, sizeof(struct bcm_time_elapsed)))
			return -EFAULT;
	}
	break;

	case IOCTL_CLOSE_NOTIFICATION:
		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""IOCTL_CLOSE_NOTIFICATION"");
		break;

	default:
		pr_info(DRV_NAME "": unknown ioctl cmd=%#x\n"", cmd);
		Status = STATUS_FAILURE;
		break;
	}
	return Status;
}
","The `bcm_char_ioctl` function is a device driver implementation that handles various IOCTL (Input/Output Control) commands for a Broadcom device. It begins by validating the command and checking user access permissions for the provided arguments. The function processes different commands, such as reading and writing to device registers, managing GPIO settings, and handling firmware downloads. It ensures that operations are only performed when the device is not in low power or shutdown modes. Additionally, it manages memory allocation for buffers, performs data copying between user and kernel space, and logs debug information throughout the process. The function returns appropriate status codes based on the success or failure of each operation.","The provided code implements a device driver function that processes various control commands for a hardware device. It validates input parameters, checks access permissions, and ensures the device is in an appropriate state for operations. The function handles tasks such as reading and writing device registers, managing GPIO settings, and facilitating firmware downloads. It includes mechanisms for memory management and data transfer between user and kernel spaces, while also logging debug information. The function returns status codes to indicate the success or failure of each operation, ensuring robust interaction with the device.","The vulnerability in the original code stemmed from the uninitialized `DevInfo.u32Reserved[]` array, which could inadvertently expose sensitive kernel information to user space, leading to potential information leaks. This issue was addressed in the fixed code by ensuring that the `DevInfo` structure is properly initialized with a call to `memset(&DevInfo, 0, sizeof(DevInfo));` before it is populated with values. This change guarantees that all fields, including the reserved array, are set to zero, thus preventing any leakage of uninitialized memory contents to user space.","The vulnerability in the original code was due to an uninitialized array within a structure, which could inadvertently expose sensitive kernel data to user space, leading to potential information leaks. This issue was resolved in the updated code by ensuring that the entire structure is initialized to zero before being populated with valid data. This initialization prevents any residual data from being leaked, as all fields, including the reserved array, are set to a known state, thereby enhancing the security and integrity of the data being shared with user space.","The vulnerability was fixed by adding a call to `memset(&DevInfo, 0, sizeof(DevInfo));` in the updated code. This line ensures that the entire `DevInfo` structure, including the `u32Reserved[]` array, is initialized to zero before any values are assigned. By doing this, the code prevents any uninitialized memory from being exposed to user space, thereby eliminating the risk of leaking sensitive kernel information. This change enhances the security of the ioctl implementation by ensuring that all fields are in a known state before being accessed or returned to user space.","The vulnerability was fixed by ensuring that the entire structure used to hold device information is initialized to zero before any data is assigned to it. This initialization process prevents any residual or uninitialized data from being inadvertently exposed to user space, which could lead to information leaks. By setting all fields to a known state, the code eliminates the risk of leaking sensitive kernel information, thereby enhancing the security and integrity of the data shared with user space applications. This change ensures that only valid and intended data is accessible to users.","5,5","5, 5","4,4","5,5"
31,31,179209,179209,,Local,Not required,,CVE-2013-3230,https://www.cvedetails.com/cve/CVE-2013-3230/,CWE-200,Low,Complete,,,2013-04-22,4.9,"The l2tp_ip6_recvmsg function in net/l2tp/l2tp_ip6.c in the Linux kernel before 3.9-rc7 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call.",2014-01-03,+Info ,1,https://github.com/torvalds/linux/commit/b860d3cc62877fad02863e2a08efff69a19382d2,b860d3cc62877fad02863e2a08efff69a19382d2,"l2tp: fix info leak in l2tp_ip6_recvmsg()

The L2TP code for IPv6 fails to initialize the l2tp_conn_id member of
struct sockaddr_l2tpip6 and therefore leaks four bytes kernel stack
in l2tp_ip6_recvmsg() in case msg_name is set.

Initialize l2tp_conn_id with 0 to avoid the info leak.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/l2tp/l2tp_ip6.c,"{""sha"": ""b8a6039314e868781d3130f06fbb78ced6c4a678"", ""filename"": ""net/l2tp/l2tp_ip6.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/b860d3cc62877fad02863e2a08efff69a19382d2/net/l2tp/l2tp_ip6.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/b860d3cc62877fad02863e2a08efff69a19382d2/net/l2tp/l2tp_ip6.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/l2tp/l2tp_ip6.c?ref=b860d3cc62877fad02863e2a08efff69a19382d2"", ""patch"": ""@@ -690,6 +690,7 @@ static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,\n \t\tlsa->l2tp_addr = ipv6_hdr(skb)->saddr;\n \t\tlsa->l2tp_flowinfo = 0;\n \t\tlsa->l2tp_scope_id = 0;\n+\t\tlsa->l2tp_conn_id = 0;\n \t\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n \t\t\tlsa->l2tp_scope_id = IP6CB(skb)->iif;\n \t}""}","static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,
			    struct msghdr *msg, size_t len, int noblock,
			    int flags, int *addr_len)
{
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)msg->msg_name;
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *skb;

	if (flags & MSG_OOB)
		goto out;

	if (addr_len)
		*addr_len = sizeof(*lsa);

	if (flags & MSG_ERRQUEUE)
		return ipv6_recv_error(sk, msg, len);

	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb)
		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_timestamp(msg, sk, skb);

	/* Copy the address. */
	if (lsa) {
		lsa->l2tp_family = AF_INET6;
		lsa->l2tp_unused = 0;
 		lsa->l2tp_addr = ipv6_hdr(skb)->saddr;
 		lsa->l2tp_flowinfo = 0;
 		lsa->l2tp_scope_id = 0;
		lsa->l2tp_conn_id = 0;
 		if (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)
 			lsa->l2tp_scope_id = IP6CB(skb)->iif;
 	}

	if (np->rxopt.all)
		ip6_datagram_recv_ctl(sk, msg, skb);

	if (flags & MSG_TRUNC)
		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	return err ? err : copied;
}
","static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,
			    struct msghdr *msg, size_t len, int noblock,
			    int flags, int *addr_len)
{
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)msg->msg_name;
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *skb;

	if (flags & MSG_OOB)
		goto out;

	if (addr_len)
		*addr_len = sizeof(*lsa);

	if (flags & MSG_ERRQUEUE)
		return ipv6_recv_error(sk, msg, len);

	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb)
		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_timestamp(msg, sk, skb);

	/* Copy the address. */
	if (lsa) {
		lsa->l2tp_family = AF_INET6;
		lsa->l2tp_unused = 0;
 		lsa->l2tp_addr = ipv6_hdr(skb)->saddr;
 		lsa->l2tp_flowinfo = 0;
 		lsa->l2tp_scope_id = 0;
 		if (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)
 			lsa->l2tp_scope_id = IP6CB(skb)->iif;
 	}

	if (np->rxopt.all)
		ip6_datagram_recv_ctl(sk, msg, skb);

	if (flags & MSG_TRUNC)
		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	return err ? err : copied;
}
",C,"		lsa->l2tp_conn_id = 0;
",,,"@@ -690,6 +690,7 @@ static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,
 		lsa->l2tp_addr = ipv6_hdr(skb)->saddr;
 		lsa->l2tp_flowinfo = 0;
 		lsa->l2tp_scope_id = 0;
+		lsa->l2tp_conn_id = 0;
 		if (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)
 			lsa->l2tp_scope_id = IP6CB(skb)->iif;
 	}",linux,b860d3cc62877fad02863e2a08efff69a19382d2,a5598bd9c087dc0efc250a5221e5d0e6f584ee88,1,"static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,
			    struct msghdr *msg, size_t len, int noblock,
			    int flags, int *addr_len)
{
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)msg->msg_name;
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *skb;

	if (flags & MSG_OOB)
		goto out;

	if (addr_len)
		*addr_len = sizeof(*lsa);

	if (flags & MSG_ERRQUEUE)
		return ipv6_recv_error(sk, msg, len);

	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb)
		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_timestamp(msg, sk, skb);

	/* Copy the address. */
	if (lsa) {
		lsa->l2tp_family = AF_INET6;
		lsa->l2tp_unused = 0;
 		lsa->l2tp_addr = ipv6_hdr(skb)->saddr;
 		lsa->l2tp_flowinfo = 0;
 		lsa->l2tp_scope_id = 0;
//fix_flaw_line_below:
//		lsa->l2tp_conn_id = 0;
 		if (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)
 			lsa->l2tp_scope_id = IP6CB(skb)->iif;
 	}

	if (np->rxopt.all)
		ip6_datagram_recv_ctl(sk, msg, skb);

	if (flags & MSG_TRUNC)
		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	return err ? err : copied;
}
",179209,"static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,
			    struct msghdr *msg, size_t len, int noblock,
			    int flags, int *addr_len)
{
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)msg->msg_name;
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *skb;

	if (flags & MSG_OOB)
		goto out;

	if (addr_len)
		*addr_len = sizeof(*lsa);

	if (flags & MSG_ERRQUEUE)
		return ipv6_recv_error(sk, msg, len);

	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb)
		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_timestamp(msg, sk, skb);

	/* Copy the address. */
	if (lsa) {
		lsa->l2tp_family = AF_INET6;
		lsa->l2tp_unused = 0;
 		lsa->l2tp_addr = ipv6_hdr(skb)->saddr;
 		lsa->l2tp_flowinfo = 0;
 		lsa->l2tp_scope_id = 0;
 		if (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)
 			lsa->l2tp_scope_id = IP6CB(skb)->iif;
 	}

	if (np->rxopt.all)
		ip6_datagram_recv_ctl(sk, msg, skb);

	if (flags & MSG_TRUNC)
		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	return err ? err : copied;
}
","static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,
			    struct msghdr *msg, size_t len, int noblock,
			    int flags, int *addr_len)
{
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)msg->msg_name;
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *skb;

	if (flags & MSG_OOB)
		goto out;

	if (addr_len)
		*addr_len = sizeof(*lsa);

	if (flags & MSG_ERRQUEUE)
		return ipv6_recv_error(sk, msg, len);

	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb)
		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_timestamp(msg, sk, skb);

	/* Copy the address. */
	if (lsa) {
		lsa->l2tp_family = AF_INET6;
		lsa->l2tp_unused = 0;
 		lsa->l2tp_addr = ipv6_hdr(skb)->saddr;
 		lsa->l2tp_flowinfo = 0;
 		lsa->l2tp_scope_id = 0;
		lsa->l2tp_conn_id = 0;
 		if (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)
 			lsa->l2tp_scope_id = IP6CB(skb)->iif;
 	}

	if (np->rxopt.all)
		ip6_datagram_recv_ctl(sk, msg, skb);

	if (flags & MSG_TRUNC)
		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	return err ? err : copied;
}
","The `l2tp_ip6_recvmsg` function processes incoming L2TP over IPv6 messages for a socket, handling various flags and conditions. It begins by checking for out-of-band data and error queue messages, returning appropriate responses if detected. The function retrieves a socket buffer containing the incoming data, copying it to the provided message structure while managing the length and potential truncation. It also populates the associated address structure with relevant IPv6 information, including the source address and scope ID for link-local addresses. Finally, it cleans up the socket buffer and returns the number of bytes copied or an error code if applicable.","The code defines a function that handles the reception of messages over L2TP using IPv6. It begins by checking for specific flags related to out-of-band data and error messages, returning appropriate responses when necessary. The function retrieves incoming data from a socket, copying it into a message structure while managing the length and potential truncation of the data. It also populates an address structure with relevant IPv6 information, including the source address and scope for link-local addresses. Finally, it cleans up resources and returns either the number of bytes copied or an error code if an issue arises.","The vulnerability in the original code stemmed from the failure to initialize the `l2tp_conn_id` member of the `struct sockaddr_l2tpip6`, which could lead to an information leak by exposing uninitialized data from the kernel stack when `msg_name` was set. This could potentially allow an attacker to read sensitive information. The fix involved explicitly initializing `l2tp_conn_id` to zero, ensuring that no residual data from the stack would be leaked. This change effectively mitigated the risk of information disclosure by guaranteeing that the memory location is cleared before being used.","The vulnerability in the original code was due to the failure to initialize a specific member of a data structure, which could lead to an information leak by exposing uninitialized memory from the kernel stack when certain conditions were met. This oversight allowed potentially sensitive data to be read by unauthorized users. The fix involved explicitly setting this member to zero, ensuring that it contained no residual data from previous operations. This change effectively eliminated the risk of leaking sensitive information by guaranteeing that the memory was properly initialized before being accessed.","The vulnerability was fixed by explicitly initializing the `l2tp_conn_id` member of the `struct sockaddr_l2tpip6` to zero within the `l2tp_ip6_recvmsg` function. This change ensures that when the `msg_name` is set, the `l2tp_conn_id` does not contain any uninitialized data from the kernel stack, thereby preventing any potential information leak. By setting this member to zero, the code guarantees that sensitive information cannot be inadvertently exposed, thus enhancing the security of the L2TP over IPv6 implementation. This initialization effectively mitigates the risk associated with reading uninitialized memory.","The vulnerability was addressed by ensuring that a specific member of a data structure was explicitly initialized to zero before being used. This change prevents the exposure of uninitialized memory, which could contain sensitive data from previous operations. By setting this member to a known value, the code eliminates the risk of leaking information when certain conditions are met. This fix enhances the overall security of the implementation by ensuring that no residual data can be accessed, thereby safeguarding against potential information disclosure vulnerabilities.","4,4","5,5","4,4","5, 5"
32,32,179210,179210,,Local,Not required,,CVE-2013-3229,https://www.cvedetails.com/cve/CVE-2013-3229/,CWE-200,Low,Complete,,,2013-04-22,4.9,"The iucv_sock_recvmsg function in net/iucv/af_iucv.c in the Linux kernel before 3.9-rc7 does not initialize a certain length variable, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call.",2017-11-28,+Info ,2,https://github.com/torvalds/linux/commit/a5598bd9c087dc0efc250a5221e5d0e6f584ee88,a5598bd9c087dc0efc250a5221e5d0e6f584ee88,"iucv: Fix missing msg_namelen update in iucv_sock_recvmsg()

The current code does not fill the msg_name member in case it is set.
It also does not set the msg_namelen member to 0 and therefore makes
net/socket.c leak the local, uninitialized sockaddr_storage variable
to userland -- 128 bytes of kernel stack memory.

Fix that by simply setting msg_namelen to 0 as obviously nobody cared
about iucv_sock_recvmsg() not filling the msg_name in case it was set.

Cc: Ursula Braun <ursula.braun@de.ibm.com>
Signed-off-by: Mathias Krause <minipli@googlemail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/iucv/af_iucv.c,"{""sha"": ""bf69358200019c28c18472cc852ccd6b3f74f7cf"", ""filename"": ""net/iucv/af_iucv.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a5598bd9c087dc0efc250a5221e5d0e6f584ee88/net/iucv/af_iucv.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a5598bd9c087dc0efc250a5221e5d0e6f584ee88/net/iucv/af_iucv.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/iucv/af_iucv.c?ref=a5598bd9c087dc0efc250a5221e5d0e6f584ee88"", ""patch"": ""@@ -1328,6 +1328,8 @@ static int iucv_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tstruct sk_buff *skb, *rskb, *cskb;\n \tint err = 0;\n \n+\tmsg->msg_namelen = 0;\n+\n \tif ((sk->sk_state == IUCV_DISCONN) &&\n \t    skb_queue_empty(&iucv->backlog_skb_q) &&\n \t    skb_queue_empty(&sk->sk_receive_queue) &&""}","static int iucv_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
			     struct msghdr *msg, size_t len, int flags)
{
	int noblock = flags & MSG_DONTWAIT;
	struct sock *sk = sock->sk;
	struct iucv_sock *iucv = iucv_sk(sk);
	unsigned int copied, rlen;
 	struct sk_buff *skb, *rskb, *cskb;
 	int err = 0;
 
	msg->msg_namelen = 0;

 	if ((sk->sk_state == IUCV_DISCONN) &&
 	    skb_queue_empty(&iucv->backlog_skb_q) &&
 	    skb_queue_empty(&sk->sk_receive_queue) &&
	    list_empty(&iucv->message_q.list))
		return 0;

	if (flags & (MSG_OOB))
		return -EOPNOTSUPP;

	/* receive/dequeue next skb:
	 * the function understands MSG_PEEK and, thus, does not dequeue skb */
	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb) {
		if (sk->sk_shutdown & RCV_SHUTDOWN)
			return 0;
		return err;
	}

	rlen   = skb->len;		/* real length of skb */
	copied = min_t(unsigned int, rlen, len);
	if (!rlen)
		sk->sk_shutdown = sk->sk_shutdown | RCV_SHUTDOWN;

	cskb = skb;
	if (skb_copy_datagram_iovec(cskb, 0, msg->msg_iov, copied)) {
		if (!(flags & MSG_PEEK))
			skb_queue_head(&sk->sk_receive_queue, skb);
		return -EFAULT;
	}

	/* SOCK_SEQPACKET: set MSG_TRUNC if recv buf size is too small */
	if (sk->sk_type == SOCK_SEQPACKET) {
		if (copied < rlen)
			msg->msg_flags |= MSG_TRUNC;
		/* each iucv message contains a complete record */
		msg->msg_flags |= MSG_EOR;
	}

	/* create control message to store iucv msg target class:
	 * get the trgcls from the control buffer of the skb due to
	 * fragmentation of original iucv message. */
	err = put_cmsg(msg, SOL_IUCV, SCM_IUCV_TRGCLS,
			CB_TRGCLS_LEN, CB_TRGCLS(skb));
	if (err) {
		if (!(flags & MSG_PEEK))
			skb_queue_head(&sk->sk_receive_queue, skb);
		return err;
	}

	/* Mark read part of skb as used */
	if (!(flags & MSG_PEEK)) {

		/* SOCK_STREAM: re-queue skb if it contains unreceived data */
		if (sk->sk_type == SOCK_STREAM) {
			skb_pull(skb, copied);
			if (skb->len) {
				skb_queue_head(&sk->sk_receive_queue, skb);
				goto done;
			}
		}

		kfree_skb(skb);
		if (iucv->transport == AF_IUCV_TRANS_HIPER) {
			atomic_inc(&iucv->msg_recv);
			if (atomic_read(&iucv->msg_recv) > iucv->msglimit) {
				WARN_ON(1);
				iucv_sock_close(sk);
				return -EFAULT;
			}
		}

		/* Queue backlog skbs */
		spin_lock_bh(&iucv->message_q.lock);
		rskb = skb_dequeue(&iucv->backlog_skb_q);
		while (rskb) {
			if (sock_queue_rcv_skb(sk, rskb)) {
				skb_queue_head(&iucv->backlog_skb_q,
						rskb);
				break;
			} else {
				rskb = skb_dequeue(&iucv->backlog_skb_q);
			}
		}
		if (skb_queue_empty(&iucv->backlog_skb_q)) {
			if (!list_empty(&iucv->message_q.list))
				iucv_process_message_q(sk);
			if (atomic_read(&iucv->msg_recv) >=
							iucv->msglimit / 2) {
				err = iucv_send_ctrl(sk, AF_IUCV_FLAG_WIN);
				if (err) {
					sk->sk_state = IUCV_DISCONN;
					sk->sk_state_change(sk);
				}
			}
		}
		spin_unlock_bh(&iucv->message_q.lock);
	}

done:
	/* SOCK_SEQPACKET: return real length if MSG_TRUNC is set */
	if (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))
		copied = rlen;

	return copied;
}
","static int iucv_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
			     struct msghdr *msg, size_t len, int flags)
{
	int noblock = flags & MSG_DONTWAIT;
	struct sock *sk = sock->sk;
	struct iucv_sock *iucv = iucv_sk(sk);
	unsigned int copied, rlen;
 	struct sk_buff *skb, *rskb, *cskb;
 	int err = 0;
 
 	if ((sk->sk_state == IUCV_DISCONN) &&
 	    skb_queue_empty(&iucv->backlog_skb_q) &&
 	    skb_queue_empty(&sk->sk_receive_queue) &&
	    list_empty(&iucv->message_q.list))
		return 0;

	if (flags & (MSG_OOB))
		return -EOPNOTSUPP;

	/* receive/dequeue next skb:
	 * the function understands MSG_PEEK and, thus, does not dequeue skb */
	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb) {
		if (sk->sk_shutdown & RCV_SHUTDOWN)
			return 0;
		return err;
	}

	rlen   = skb->len;		/* real length of skb */
	copied = min_t(unsigned int, rlen, len);
	if (!rlen)
		sk->sk_shutdown = sk->sk_shutdown | RCV_SHUTDOWN;

	cskb = skb;
	if (skb_copy_datagram_iovec(cskb, 0, msg->msg_iov, copied)) {
		if (!(flags & MSG_PEEK))
			skb_queue_head(&sk->sk_receive_queue, skb);
		return -EFAULT;
	}

	/* SOCK_SEQPACKET: set MSG_TRUNC if recv buf size is too small */
	if (sk->sk_type == SOCK_SEQPACKET) {
		if (copied < rlen)
			msg->msg_flags |= MSG_TRUNC;
		/* each iucv message contains a complete record */
		msg->msg_flags |= MSG_EOR;
	}

	/* create control message to store iucv msg target class:
	 * get the trgcls from the control buffer of the skb due to
	 * fragmentation of original iucv message. */
	err = put_cmsg(msg, SOL_IUCV, SCM_IUCV_TRGCLS,
			CB_TRGCLS_LEN, CB_TRGCLS(skb));
	if (err) {
		if (!(flags & MSG_PEEK))
			skb_queue_head(&sk->sk_receive_queue, skb);
		return err;
	}

	/* Mark read part of skb as used */
	if (!(flags & MSG_PEEK)) {

		/* SOCK_STREAM: re-queue skb if it contains unreceived data */
		if (sk->sk_type == SOCK_STREAM) {
			skb_pull(skb, copied);
			if (skb->len) {
				skb_queue_head(&sk->sk_receive_queue, skb);
				goto done;
			}
		}

		kfree_skb(skb);
		if (iucv->transport == AF_IUCV_TRANS_HIPER) {
			atomic_inc(&iucv->msg_recv);
			if (atomic_read(&iucv->msg_recv) > iucv->msglimit) {
				WARN_ON(1);
				iucv_sock_close(sk);
				return -EFAULT;
			}
		}

		/* Queue backlog skbs */
		spin_lock_bh(&iucv->message_q.lock);
		rskb = skb_dequeue(&iucv->backlog_skb_q);
		while (rskb) {
			if (sock_queue_rcv_skb(sk, rskb)) {
				skb_queue_head(&iucv->backlog_skb_q,
						rskb);
				break;
			} else {
				rskb = skb_dequeue(&iucv->backlog_skb_q);
			}
		}
		if (skb_queue_empty(&iucv->backlog_skb_q)) {
			if (!list_empty(&iucv->message_q.list))
				iucv_process_message_q(sk);
			if (atomic_read(&iucv->msg_recv) >=
							iucv->msglimit / 2) {
				err = iucv_send_ctrl(sk, AF_IUCV_FLAG_WIN);
				if (err) {
					sk->sk_state = IUCV_DISCONN;
					sk->sk_state_change(sk);
				}
			}
		}
		spin_unlock_bh(&iucv->message_q.lock);
	}

done:
	/* SOCK_SEQPACKET: return real length if MSG_TRUNC is set */
	if (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))
		copied = rlen;

	return copied;
}
",C,"	msg->msg_namelen = 0;

",,,"@@ -1328,6 +1328,8 @@ static int iucv_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
 	struct sk_buff *skb, *rskb, *cskb;
 	int err = 0;
 
+	msg->msg_namelen = 0;
+
 	if ((sk->sk_state == IUCV_DISCONN) &&
 	    skb_queue_empty(&iucv->backlog_skb_q) &&
 	    skb_queue_empty(&sk->sk_receive_queue) &&",linux,a5598bd9c087dc0efc250a5221e5d0e6f584ee88,5ae94c0d2f0bed41d6718be743985d61b7f5c47d,1,"static int iucv_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
			     struct msghdr *msg, size_t len, int flags)
{
	int noblock = flags & MSG_DONTWAIT;
	struct sock *sk = sock->sk;
	struct iucv_sock *iucv = iucv_sk(sk);
	unsigned int copied, rlen;
 	struct sk_buff *skb, *rskb, *cskb;
 	int err = 0;
 
//fix_flaw_line_below:
//	msg->msg_namelen = 0;
//fix_flaw_line_below:
//
 	if ((sk->sk_state == IUCV_DISCONN) &&
 	    skb_queue_empty(&iucv->backlog_skb_q) &&
 	    skb_queue_empty(&sk->sk_receive_queue) &&
	    list_empty(&iucv->message_q.list))
		return 0;

	if (flags & (MSG_OOB))
		return -EOPNOTSUPP;

	/* receive/dequeue next skb:
	 * the function understands MSG_PEEK and, thus, does not dequeue skb */
	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb) {
		if (sk->sk_shutdown & RCV_SHUTDOWN)
			return 0;
		return err;
	}

	rlen   = skb->len;		/* real length of skb */
	copied = min_t(unsigned int, rlen, len);
	if (!rlen)
		sk->sk_shutdown = sk->sk_shutdown | RCV_SHUTDOWN;

	cskb = skb;
	if (skb_copy_datagram_iovec(cskb, 0, msg->msg_iov, copied)) {
		if (!(flags & MSG_PEEK))
			skb_queue_head(&sk->sk_receive_queue, skb);
		return -EFAULT;
	}

	/* SOCK_SEQPACKET: set MSG_TRUNC if recv buf size is too small */
	if (sk->sk_type == SOCK_SEQPACKET) {
		if (copied < rlen)
			msg->msg_flags |= MSG_TRUNC;
		/* each iucv message contains a complete record */
		msg->msg_flags |= MSG_EOR;
	}

	/* create control message to store iucv msg target class:
	 * get the trgcls from the control buffer of the skb due to
	 * fragmentation of original iucv message. */
	err = put_cmsg(msg, SOL_IUCV, SCM_IUCV_TRGCLS,
			CB_TRGCLS_LEN, CB_TRGCLS(skb));
	if (err) {
		if (!(flags & MSG_PEEK))
			skb_queue_head(&sk->sk_receive_queue, skb);
		return err;
	}

	/* Mark read part of skb as used */
	if (!(flags & MSG_PEEK)) {

		/* SOCK_STREAM: re-queue skb if it contains unreceived data */
		if (sk->sk_type == SOCK_STREAM) {
			skb_pull(skb, copied);
			if (skb->len) {
				skb_queue_head(&sk->sk_receive_queue, skb);
				goto done;
			}
		}

		kfree_skb(skb);
		if (iucv->transport == AF_IUCV_TRANS_HIPER) {
			atomic_inc(&iucv->msg_recv);
			if (atomic_read(&iucv->msg_recv) > iucv->msglimit) {
				WARN_ON(1);
				iucv_sock_close(sk);
				return -EFAULT;
			}
		}

		/* Queue backlog skbs */
		spin_lock_bh(&iucv->message_q.lock);
		rskb = skb_dequeue(&iucv->backlog_skb_q);
		while (rskb) {
			if (sock_queue_rcv_skb(sk, rskb)) {
				skb_queue_head(&iucv->backlog_skb_q,
						rskb);
				break;
			} else {
				rskb = skb_dequeue(&iucv->backlog_skb_q);
			}
		}
		if (skb_queue_empty(&iucv->backlog_skb_q)) {
			if (!list_empty(&iucv->message_q.list))
				iucv_process_message_q(sk);
			if (atomic_read(&iucv->msg_recv) >=
							iucv->msglimit / 2) {
				err = iucv_send_ctrl(sk, AF_IUCV_FLAG_WIN);
				if (err) {
					sk->sk_state = IUCV_DISCONN;
					sk->sk_state_change(sk);
				}
			}
		}
		spin_unlock_bh(&iucv->message_q.lock);
	}

done:
	/* SOCK_SEQPACKET: return real length if MSG_TRUNC is set */
	if (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))
		copied = rlen;

	return copied;
}
",179210,"static int iucv_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
			     struct msghdr *msg, size_t len, int flags)
{
	int noblock = flags & MSG_DONTWAIT;
	struct sock *sk = sock->sk;
	struct iucv_sock *iucv = iucv_sk(sk);
	unsigned int copied, rlen;
 	struct sk_buff *skb, *rskb, *cskb;
 	int err = 0;
 
 	if ((sk->sk_state == IUCV_DISCONN) &&
 	    skb_queue_empty(&iucv->backlog_skb_q) &&
 	    skb_queue_empty(&sk->sk_receive_queue) &&
	    list_empty(&iucv->message_q.list))
		return 0;

	if (flags & (MSG_OOB))
		return -EOPNOTSUPP;

	/* receive/dequeue next skb:
	 * the function understands MSG_PEEK and, thus, does not dequeue skb */
	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb) {
		if (sk->sk_shutdown & RCV_SHUTDOWN)
			return 0;
		return err;
	}

	rlen   = skb->len;		/* real length of skb */
	copied = min_t(unsigned int, rlen, len);
	if (!rlen)
		sk->sk_shutdown = sk->sk_shutdown | RCV_SHUTDOWN;

	cskb = skb;
	if (skb_copy_datagram_iovec(cskb, 0, msg->msg_iov, copied)) {
		if (!(flags & MSG_PEEK))
			skb_queue_head(&sk->sk_receive_queue, skb);
		return -EFAULT;
	}

	/* SOCK_SEQPACKET: set MSG_TRUNC if recv buf size is too small */
	if (sk->sk_type == SOCK_SEQPACKET) {
		if (copied < rlen)
			msg->msg_flags |= MSG_TRUNC;
		/* each iucv message contains a complete record */
		msg->msg_flags |= MSG_EOR;
	}

	/* create control message to store iucv msg target class:
	 * get the trgcls from the control buffer of the skb due to
	 * fragmentation of original iucv message. */
	err = put_cmsg(msg, SOL_IUCV, SCM_IUCV_TRGCLS,
			CB_TRGCLS_LEN, CB_TRGCLS(skb));
	if (err) {
		if (!(flags & MSG_PEEK))
			skb_queue_head(&sk->sk_receive_queue, skb);
		return err;
	}

	/* Mark read part of skb as used */
	if (!(flags & MSG_PEEK)) {

		/* SOCK_STREAM: re-queue skb if it contains unreceived data */
		if (sk->sk_type == SOCK_STREAM) {
			skb_pull(skb, copied);
			if (skb->len) {
				skb_queue_head(&sk->sk_receive_queue, skb);
				goto done;
			}
		}

		kfree_skb(skb);
		if (iucv->transport == AF_IUCV_TRANS_HIPER) {
			atomic_inc(&iucv->msg_recv);
			if (atomic_read(&iucv->msg_recv) > iucv->msglimit) {
				WARN_ON(1);
				iucv_sock_close(sk);
				return -EFAULT;
			}
		}

		/* Queue backlog skbs */
		spin_lock_bh(&iucv->message_q.lock);
		rskb = skb_dequeue(&iucv->backlog_skb_q);
		while (rskb) {
			if (sock_queue_rcv_skb(sk, rskb)) {
				skb_queue_head(&iucv->backlog_skb_q,
						rskb);
				break;
			} else {
				rskb = skb_dequeue(&iucv->backlog_skb_q);
			}
		}
		if (skb_queue_empty(&iucv->backlog_skb_q)) {
			if (!list_empty(&iucv->message_q.list))
				iucv_process_message_q(sk);
			if (atomic_read(&iucv->msg_recv) >=
							iucv->msglimit / 2) {
				err = iucv_send_ctrl(sk, AF_IUCV_FLAG_WIN);
				if (err) {
					sk->sk_state = IUCV_DISCONN;
					sk->sk_state_change(sk);
				}
			}
		}
		spin_unlock_bh(&iucv->message_q.lock);
	}

done:
	/* SOCK_SEQPACKET: return real length if MSG_TRUNC is set */
	if (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))
		copied = rlen;

	return copied;
}
","static int iucv_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
			     struct msghdr *msg, size_t len, int flags)
{
	int noblock = flags & MSG_DONTWAIT;
	struct sock *sk = sock->sk;
	struct iucv_sock *iucv = iucv_sk(sk);
	unsigned int copied, rlen;
 	struct sk_buff *skb, *rskb, *cskb;
 	int err = 0;
 
	msg->msg_namelen = 0;

 	if ((sk->sk_state == IUCV_DISCONN) &&
 	    skb_queue_empty(&iucv->backlog_skb_q) &&
 	    skb_queue_empty(&sk->sk_receive_queue) &&
	    list_empty(&iucv->message_q.list))
		return 0;

	if (flags & (MSG_OOB))
		return -EOPNOTSUPP;

	/* receive/dequeue next skb:
	 * the function understands MSG_PEEK and, thus, does not dequeue skb */
	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb) {
		if (sk->sk_shutdown & RCV_SHUTDOWN)
			return 0;
		return err;
	}

	rlen   = skb->len;		/* real length of skb */
	copied = min_t(unsigned int, rlen, len);
	if (!rlen)
		sk->sk_shutdown = sk->sk_shutdown | RCV_SHUTDOWN;

	cskb = skb;
	if (skb_copy_datagram_iovec(cskb, 0, msg->msg_iov, copied)) {
		if (!(flags & MSG_PEEK))
			skb_queue_head(&sk->sk_receive_queue, skb);
		return -EFAULT;
	}

	/* SOCK_SEQPACKET: set MSG_TRUNC if recv buf size is too small */
	if (sk->sk_type == SOCK_SEQPACKET) {
		if (copied < rlen)
			msg->msg_flags |= MSG_TRUNC;
		/* each iucv message contains a complete record */
		msg->msg_flags |= MSG_EOR;
	}

	/* create control message to store iucv msg target class:
	 * get the trgcls from the control buffer of the skb due to
	 * fragmentation of original iucv message. */
	err = put_cmsg(msg, SOL_IUCV, SCM_IUCV_TRGCLS,
			CB_TRGCLS_LEN, CB_TRGCLS(skb));
	if (err) {
		if (!(flags & MSG_PEEK))
			skb_queue_head(&sk->sk_receive_queue, skb);
		return err;
	}

	/* Mark read part of skb as used */
	if (!(flags & MSG_PEEK)) {

		/* SOCK_STREAM: re-queue skb if it contains unreceived data */
		if (sk->sk_type == SOCK_STREAM) {
			skb_pull(skb, copied);
			if (skb->len) {
				skb_queue_head(&sk->sk_receive_queue, skb);
				goto done;
			}
		}

		kfree_skb(skb);
		if (iucv->transport == AF_IUCV_TRANS_HIPER) {
			atomic_inc(&iucv->msg_recv);
			if (atomic_read(&iucv->msg_recv) > iucv->msglimit) {
				WARN_ON(1);
				iucv_sock_close(sk);
				return -EFAULT;
			}
		}

		/* Queue backlog skbs */
		spin_lock_bh(&iucv->message_q.lock);
		rskb = skb_dequeue(&iucv->backlog_skb_q);
		while (rskb) {
			if (sock_queue_rcv_skb(sk, rskb)) {
				skb_queue_head(&iucv->backlog_skb_q,
						rskb);
				break;
			} else {
				rskb = skb_dequeue(&iucv->backlog_skb_q);
			}
		}
		if (skb_queue_empty(&iucv->backlog_skb_q)) {
			if (!list_empty(&iucv->message_q.list))
				iucv_process_message_q(sk);
			if (atomic_read(&iucv->msg_recv) >=
							iucv->msglimit / 2) {
				err = iucv_send_ctrl(sk, AF_IUCV_FLAG_WIN);
				if (err) {
					sk->sk_state = IUCV_DISCONN;
					sk->sk_state_change(sk);
				}
			}
		}
		spin_unlock_bh(&iucv->message_q.lock);
	}

done:
	/* SOCK_SEQPACKET: return real length if MSG_TRUNC is set */
	if (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))
		copied = rlen;

	return copied;
}
","The `iucv_sock_recvmsg` function is designed to handle receiving messages over a socket in a network communication context, specifically for IUCV (Inter-User Communication Vehicle) sockets. It checks the socket's state and manages message queues, ensuring that incoming data is processed correctly. The function supports non-blocking operations and handles out-of-band data, while also managing message fragmentation and control messages. It copies data from the socket's buffer to the provided message structure, updates the socket's state, and re-queues any remaining data if necessary. Additionally, it monitors message limits and can trigger control messages based on the current load.","The provided code implements a function that facilitates the reception of messages over a specific type of network socket. It checks the socket's state and manages incoming message queues, allowing for both blocking and non-blocking operations. The function processes received data, ensuring that it is copied to the appropriate message structure while handling potential fragmentation. It also manages control messages related to the communication protocol and monitors the number of received messages to prevent overload. Additionally, it re-queues any remaining data for future processing and updates the socket's state as necessary.","The vulnerability in the original code stemmed from the failure to initialize the `msg_namelen` member of the message structure, which could lead to leaking uninitialized memory from the kernel stack to userland. Specifically, if the `msg_name` was set but not filled, the uninitialized `sockaddr_storage` variable could expose sensitive data, resulting in a potential information leak. The fix addressed this issue by explicitly setting `msg_namelen` to 0 at the beginning of the function, ensuring that no uninitialized data is passed to userland, thereby preventing the leakage of kernel memory.","The vulnerability in the original code arose from the failure to initialize a specific member of the message structure, which could lead to the exposure of uninitialized memory from the kernel stack to userland. This oversight meant that if the message structure was set up but not properly filled, it could inadvertently leak sensitive data, potentially compromising system security. The fix involved explicitly setting the problematic member to zero at the start of the function, ensuring that no uninitialized data would be passed to userland, thus preventing any information leakage from the kernel.","The vulnerability was fixed by explicitly setting the `msg_namelen` member of the message structure to 0 at the beginning of the `iucv_sock_recvmsg` function. This change ensures that if the `msg_name` member is not filled, the length remains zero, preventing any uninitialized data from being leaked to userland. By addressing this oversight, the code now guarantees that the local `sockaddr_storage` variable does not expose its contents, thereby eliminating the risk of leaking sensitive kernel stack memory. This simple initialization effectively mitigates the potential information disclosure vulnerability.","The vulnerability was fixed by ensuring that a specific member of the message structure is explicitly initialized to zero at the start of the function. This adjustment prevents the exposure of uninitialized memory, which could inadvertently leak sensitive data to userland. By setting this member to zero, the code guarantees that if the associated data is not filled, it will not carry any residual values from the kernel stack. This simple yet effective change eliminates the risk of information disclosure, thereby enhancing the security of the communication process.","5,5","5,5","4,4","4, 4"
33,33,179213,179213,,Local,Not required,,CVE-2013-3226,https://www.cvedetails.com/cve/CVE-2013-3226/,CWE-200,Low,Complete,,,2013-04-22,4.9,"The sco_sock_recvmsg function in net/bluetooth/sco.c in the Linux kernel before 3.9-rc7 does not initialize a certain length variable, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call.",2014-01-03,+Info ,1,https://github.com/torvalds/linux/commit/c8c499175f7d295ef867335bceb9a76a2c3cdc38,c8c499175f7d295ef867335bceb9a76a2c3cdc38,"Bluetooth: SCO - Fix missing msg_namelen update in sco_sock_recvmsg()

If the socket is in state BT_CONNECT2 and BT_SK_DEFER_SETUP is set in
the flags, sco_sock_recvmsg() returns early with 0 without updating the
possibly set msg_namelen member. This, in turn, leads to a 128 byte
kernel stack leak in net/socket.c.

Fix this by updating msg_namelen in this case. For all other cases it
will be handled in bt_sock_recvmsg().

Cc: Marcel Holtmann <marcel@holtmann.org>
Cc: Gustavo Padovan <gustavo@padovan.org>
Cc: Johan Hedberg <johan.hedberg@gmail.com>
Signed-off-by: Mathias Krause <minipli@googlemail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/bluetooth/sco.c,"{""sha"": ""fb6192c9812e81bcac3d8dea31f60095aa40ffda"", ""filename"": ""net/bluetooth/sco.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/c8c499175f7d295ef867335bceb9a76a2c3cdc38/net/bluetooth/sco.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c8c499175f7d295ef867335bceb9a76a2c3cdc38/net/bluetooth/sco.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/bluetooth/sco.c?ref=c8c499175f7d295ef867335bceb9a76a2c3cdc38"", ""patch"": ""@@ -665,6 +665,7 @@ static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n \t\thci_conn_accept(pi->conn->hcon, 0);\n \t\tsk->sk_state = BT_CONFIG;\n+\t\tmsg->msg_namelen = 0;\n \n \t\trelease_sock(sk);\n \t\treturn 0;""}","static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
			    struct msghdr *msg, size_t len, int flags)
{
	struct sock *sk = sock->sk;
	struct sco_pinfo *pi = sco_pi(sk);

	lock_sock(sk);

	if (sk->sk_state == BT_CONNECT2 &&
 	    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {
 		hci_conn_accept(pi->conn->hcon, 0);
 		sk->sk_state = BT_CONFIG;
		msg->msg_namelen = 0;
 
 		release_sock(sk);
 		return 0;
	}

	release_sock(sk);

	return bt_sock_recvmsg(iocb, sock, msg, len, flags);
}
","static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
			    struct msghdr *msg, size_t len, int flags)
{
	struct sock *sk = sock->sk;
	struct sco_pinfo *pi = sco_pi(sk);

	lock_sock(sk);

	if (sk->sk_state == BT_CONNECT2 &&
 	    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {
 		hci_conn_accept(pi->conn->hcon, 0);
 		sk->sk_state = BT_CONFIG;
 
 		release_sock(sk);
 		return 0;
	}

	release_sock(sk);

	return bt_sock_recvmsg(iocb, sock, msg, len, flags);
}
",C,"		msg->msg_namelen = 0;
",,,"@@ -665,6 +665,7 @@ static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
 	    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {
 		hci_conn_accept(pi->conn->hcon, 0);
 		sk->sk_state = BT_CONFIG;
+		msg->msg_namelen = 0;
 
 		release_sock(sk);
 		return 0;",linux,c8c499175f7d295ef867335bceb9a76a2c3cdc38,e11e0455c0d7d3d62276a0c55d9dfbc16779d691,1,"static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
			    struct msghdr *msg, size_t len, int flags)
{
	struct sock *sk = sock->sk;
	struct sco_pinfo *pi = sco_pi(sk);

	lock_sock(sk);

	if (sk->sk_state == BT_CONNECT2 &&
 	    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {
 		hci_conn_accept(pi->conn->hcon, 0);
 		sk->sk_state = BT_CONFIG;
//fix_flaw_line_below:
//		msg->msg_namelen = 0;
 
 		release_sock(sk);
 		return 0;
	}

	release_sock(sk);

	return bt_sock_recvmsg(iocb, sock, msg, len, flags);
}
",179213,"static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
			    struct msghdr *msg, size_t len, int flags)
{
	struct sock *sk = sock->sk;
	struct sco_pinfo *pi = sco_pi(sk);

	lock_sock(sk);

	if (sk->sk_state == BT_CONNECT2 &&
 	    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {
 		hci_conn_accept(pi->conn->hcon, 0);
 		sk->sk_state = BT_CONFIG;
 
 		release_sock(sk);
 		return 0;
	}

	release_sock(sk);

	return bt_sock_recvmsg(iocb, sock, msg, len, flags);
}
","static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
			    struct msghdr *msg, size_t len, int flags)
{
	struct sock *sk = sock->sk;
	struct sco_pinfo *pi = sco_pi(sk);

	lock_sock(sk);

	if (sk->sk_state == BT_CONNECT2 &&
 	    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {
 		hci_conn_accept(pi->conn->hcon, 0);
 		sk->sk_state = BT_CONFIG;
		msg->msg_namelen = 0;
 
 		release_sock(sk);
 		return 0;
	}

	release_sock(sk);

	return bt_sock_recvmsg(iocb, sock, msg, len, flags);
}
","The `sco_sock_recvmsg` function is designed to handle receiving messages over a Bluetooth SCO (Synchronous Connection-Oriented) socket. It first retrieves the associated socket's state and connection information, then locks the socket to ensure thread safety. If the socket is in the `BT_CONNECT2` state and a specific flag is set, it accepts the Bluetooth connection and transitions the socket state to `BT_CONFIG`. After this, it releases the socket lock and returns 0, indicating successful handling. If the conditions are not met, it delegates the message reception to the `bt_sock_recvmsg` function, allowing for standard message processing.","The provided code defines a function that manages the reception of messages over a Bluetooth SCO socket. It begins by ensuring thread safety through locking the socket. The function checks if the socket is in a specific connection state and if a certain condition is met; if so, it accepts the Bluetooth connection and updates the socket's state accordingly. After handling this scenario, it releases the lock on the socket. If the initial conditions are not satisfied, the function proceeds to call another routine to handle the message reception in a standard manner, ensuring proper message processing.","The vulnerability in the original code arises from the early return of the `sco_sock_recvmsg` function when the socket is in the `BT_CONNECT2` state and the `BT_SK_DEFER_SETUP` flag is set. In this scenario, the function fails to update the `msg_namelen` member, which can lead to a kernel stack leak of 128 bytes, as the uninitialized value may be exposed. The fix addresses this issue by explicitly setting `msg->msg_namelen` to 0 before the function returns, ensuring that the member is properly updated and preventing the potential information leak while allowing other cases to be handled by the subsequent function call.","The vulnerability in the original code occurs when the function returns early without updating a specific member that indicates the length of the address associated with the message. This oversight can lead to a kernel stack leak, exposing potentially sensitive data from the kernel stack. The fix addresses this issue by ensuring that the member is explicitly set to zero before the function exits in the specific condition, thereby preventing the leak. For all other scenarios, the handling of the member is delegated to another function, ensuring that proper data management is maintained throughout the code.","The vulnerability was fixed by adding a line to explicitly set the `msg->msg_namelen` member to 0 in the `sco_sock_recvmsg` function when the socket is in the `BT_CONNECT2` state and the `BT_SK_DEFER_SETUP` flag is set. This update ensures that the member is properly initialized before the function returns early with 0, thus preventing the potential kernel stack leak of 128 bytes. By addressing this specific case, the fix maintains data integrity and security, while allowing all other scenarios to be handled by the existing `bt_sock_recvmsg` function.","The vulnerability was fixed by ensuring that a specific member, which indicates the length of the address associated with a message, is explicitly set to zero before the function exits in a particular condition. This change prevents the function from returning without properly initializing the member, thereby eliminating the risk of exposing sensitive data from the kernel stack. By addressing this oversight, the fix enhances data security while allowing other scenarios to be managed by the existing message handling routine, ensuring that proper data management practices are upheld throughout the code.","5,5","5,5","5,5","4, 4"
34,34,179215,179215,,Local,Not required,,CVE-2013-3224,https://www.cvedetails.com/cve/CVE-2013-3224/,CWE-200,Low,Complete,,,2013-04-22,4.9,"The bt_sock_recvmsg function in net/bluetooth/af_bluetooth.c in the Linux kernel before 3.9-rc7 does not properly initialize a certain length variable, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call.",2017-11-28,+Info ,2,https://github.com/torvalds/linux/commit/4683f42fde3977bdb4e8a09622788cc8b5313778,4683f42fde3977bdb4e8a09622788cc8b5313778,"Bluetooth: fix possible info leak in bt_sock_recvmsg()

In case the socket is already shutting down, bt_sock_recvmsg() returns
with 0 without updating msg_namelen leading to net/socket.c leaking the
local, uninitialized sockaddr_storage variable to userland -- 128 bytes
of kernel stack memory.

Fix this by moving the msg_namelen assignment in front of the shutdown
test.

Cc: Marcel Holtmann <marcel@holtmann.org>
Cc: Gustavo Padovan <gustavo@padovan.org>
Cc: Johan Hedberg <johan.hedberg@gmail.com>
Signed-off-by: Mathias Krause <minipli@googlemail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/bluetooth/af_bluetooth.c,"{""sha"": ""0d1b08cc76e1d73acba966e4c22f64c0285cce05"", ""filename"": ""net/bluetooth/af_bluetooth.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/4683f42fde3977bdb4e8a09622788cc8b5313778/net/bluetooth/af_bluetooth.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4683f42fde3977bdb4e8a09622788cc8b5313778/net/bluetooth/af_bluetooth.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/bluetooth/af_bluetooth.c?ref=4683f42fde3977bdb4e8a09622788cc8b5313778"", ""patch"": ""@@ -230,15 +230,15 @@ int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags & (MSG_OOB))\n \t\treturn -EOPNOTSUPP;\n \n+\tmsg->msg_namelen = 0;\n+\n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb) {\n \t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n \t\t\treturn 0;\n \t\treturn err;\n \t}\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;""}","int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
				struct msghdr *msg, size_t len, int flags)
{
	int noblock = flags & MSG_DONTWAIT;
	struct sock *sk = sock->sk;
	struct sk_buff *skb;
	size_t copied;
	int err;

	BT_DBG(""sock %p sk %p len %zu"", sock, sk, len);

 	if (flags & (MSG_OOB))
 		return -EOPNOTSUPP;
 
	msg->msg_namelen = 0;

 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb) {
 		if (sk->sk_shutdown & RCV_SHUTDOWN)
 			return 0;
 		return err;
 	}
 
 	copied = skb->len;
 	if (len < copied) {
 		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	skb_reset_transport_header(skb);
	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err == 0)
		sock_recv_ts_and_drops(msg, sk, skb);

	skb_free_datagram(sk, skb);

	return err ? : copied;
}
","int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
				struct msghdr *msg, size_t len, int flags)
{
	int noblock = flags & MSG_DONTWAIT;
	struct sock *sk = sock->sk;
	struct sk_buff *skb;
	size_t copied;
	int err;

	BT_DBG(""sock %p sk %p len %zu"", sock, sk, len);

 	if (flags & (MSG_OOB))
 		return -EOPNOTSUPP;
 
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb) {
 		if (sk->sk_shutdown & RCV_SHUTDOWN)
 			return 0;
 		return err;
 	}
 
	msg->msg_namelen = 0;
 	copied = skb->len;
 	if (len < copied) {
 		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	skb_reset_transport_header(skb);
	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err == 0)
		sock_recv_ts_and_drops(msg, sk, skb);

	skb_free_datagram(sk, skb);

	return err ? : copied;
}
",C,"	msg->msg_namelen = 0;

","	msg->msg_namelen = 0;
",,"@@ -230,15 +230,15 @@ int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
 	if (flags & (MSG_OOB))
 		return -EOPNOTSUPP;
 
+	msg->msg_namelen = 0;
+
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb) {
 		if (sk->sk_shutdown & RCV_SHUTDOWN)
 			return 0;
 		return err;
 	}
 
-	msg->msg_namelen = 0;
-
 	copied = skb->len;
 	if (len < copied) {
 		msg->msg_flags |= MSG_TRUNC;",linux,4683f42fde3977bdb4e8a09622788cc8b5313778,ef3313e84acbf349caecae942ab3ab731471f1a1,1,"int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
				struct msghdr *msg, size_t len, int flags)
{
	int noblock = flags & MSG_DONTWAIT;
	struct sock *sk = sock->sk;
	struct sk_buff *skb;
	size_t copied;
	int err;

	BT_DBG(""sock %p sk %p len %zu"", sock, sk, len);

 	if (flags & (MSG_OOB))
 		return -EOPNOTSUPP;
 
//fix_flaw_line_below:
//	msg->msg_namelen = 0;
//fix_flaw_line_below:
//
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb) {
 		if (sk->sk_shutdown & RCV_SHUTDOWN)
 			return 0;
 		return err;
 	}
 
//flaw_line_below:
	msg->msg_namelen = 0;
//flaw_line_below:

 	copied = skb->len;
 	if (len < copied) {
 		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	skb_reset_transport_header(skb);
	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err == 0)
		sock_recv_ts_and_drops(msg, sk, skb);

	skb_free_datagram(sk, skb);

	return err ? : copied;
}
",179215,"int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
				struct msghdr *msg, size_t len, int flags)
{
	int noblock = flags & MSG_DONTWAIT;
	struct sock *sk = sock->sk;
	struct sk_buff *skb;
	size_t copied;
	int err;

	BT_DBG(""sock %p sk %p len %zu"", sock, sk, len);

 	if (flags & (MSG_OOB))
 		return -EOPNOTSUPP;
 
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb) {
 		if (sk->sk_shutdown & RCV_SHUTDOWN)
 			return 0;
 		return err;
 	}
 
	msg->msg_namelen = 0;
 	copied = skb->len;
 	if (len < copied) {
 		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	skb_reset_transport_header(skb);
	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err == 0)
		sock_recv_ts_and_drops(msg, sk, skb);

	skb_free_datagram(sk, skb);

	return err ? : copied;
}
","int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
				struct msghdr *msg, size_t len, int flags)
{
	int noblock = flags & MSG_DONTWAIT;
	struct sock *sk = sock->sk;
	struct sk_buff *skb;
	size_t copied;
	int err;

	BT_DBG(""sock %p sk %p len %zu"", sock, sk, len);

 	if (flags & (MSG_OOB))
 		return -EOPNOTSUPP;
 
	msg->msg_namelen = 0;

 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb) {
 		if (sk->sk_shutdown & RCV_SHUTDOWN)
 			return 0;
 		return err;
 	}
 
 	copied = skb->len;
 	if (len < copied) {
 		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	skb_reset_transport_header(skb);
	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err == 0)
		sock_recv_ts_and_drops(msg, sk, skb);

	skb_free_datagram(sk, skb);

	return err ? : copied;
}
","The `bt_sock_recvmsg` function is designed to receive messages from a Bluetooth socket in a non-blocking manner. It first checks if the socket is set to non-blocking mode and retrieves the associated socket structure. The function then attempts to receive a datagram using `skb_recv_datagram`, handling any errors that may arise. If a message is successfully received, it checks if the provided buffer length is sufficient, potentially truncating the message. The function copies the data into the provided message structure and updates the message flags accordingly. Finally, it frees the received datagram and returns the number of bytes copied or an error code.","The function facilitates the reception of messages from a Bluetooth socket, allowing for both blocking and non-blocking operations. It begins by determining the socket's mode and attempts to retrieve incoming data. If successful, it checks whether the buffer can accommodate the message size, potentially truncating it if necessary. The function then copies the received data into the specified message structure while updating relevant flags to indicate any truncation. After processing, it releases the resources associated with the received message and returns either the number of bytes copied or an error code if an issue occurred during the operation.","The vulnerability in the original code arises from the potential for leaking uninitialized memory to userland when the socket is shutting down. Specifically, if the function encounters a shutdown condition, it returns 0 without setting the `msg_namelen`, which could expose 128 bytes of kernel stack memory. The fix addresses this issue by moving the assignment of `msg->msg_namelen` to occur before the shutdown check. This ensures that even if the socket is shutting down, the `msg_namelen` is properly initialized, preventing any leakage of sensitive information from the kernel to userland.","The vulnerability in the original code stems from a potential information leak when the socket is in a shutdown state. If the function returns without properly initializing a specific field, it could inadvertently expose uninitialized memory from the kernel stack to userland, allowing access to sensitive data. The fix addresses this issue by ensuring that the field is assigned a value before checking for the shutdown condition. This change guarantees that even if the socket is shutting down, the relevant field is correctly set, thereby preventing any leakage of uninitialized memory to userland.","The vulnerability was fixed by moving the assignment of `msg->msg_namelen` to occur before the shutdown check in the function. In the original code, if the socket was shutting down, the function would return 0 without updating `msg->msg_namelen`, which could lead to leaking uninitialized memory from the kernel stack to userland. By placing the assignment before the shutdown condition, the code ensures that `msg->msg_namelen` is always initialized, regardless of whether the socket is shutting down, thus preventing any exposure of sensitive data from the uninitialized `sockaddr_storage` variable.","The vulnerability was addressed by rearranging the order of operations in the code to ensure that a specific field is initialized before checking for a shutdown condition. In the original implementation, if the socket was shutting down, the function could return without setting this field, leading to the potential exposure of uninitialized memory to userland. By moving the initialization step earlier in the process, the fix guarantees that the field is always properly set, thereby preventing any leakage of sensitive data from the kernel stack, regardless of the socket's state. This change enhances the overall security of the function.","4,4","5,5","4,4","4,4"
35,35,179258,179258,,Remote,Not required,,CVE-2013-2061,https://www.cvedetails.com/cve/CVE-2013-2061/,CWE-200,High,Partial,,,2013-11-17,2.6,"The openvpn_decrypt function in crypto.c in OpenVPN 2.3.0 and earlier, when running in UDP mode, allows remote attackers to obtain sensitive information via a timing attack involving an HMAC comparison function that does not run in constant time and a padding oracle attack on the CBC mode cipher.",2018-10-30,+Info ,1,https://github.com/OpenVPN/openvpn/commit/11d21349a4e7e38a025849479b36ace7c2eec2ee,11d21349a4e7e38a025849479b36ace7c2eec2ee,"Use constant time memcmp when comparing HMACs in openvpn_decrypt.

Signed-off-by: Steffan Karger <steffan.karger@fox-it.com>
Acked-by: Gert Doering <gert@greenie.muc.de>
Signed-off-by: Gert Doering <gert@greenie.muc.de>",1,src/openvpn/crypto.c,"{""sha"": ""93efb0962b3b99891f35a595f8de5d9459f4f160"", ""filename"": ""src/openvpn/buffer.h"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/OpenVPN/openvpn/blob/11d21349a4e7e38a025849479b36ace7c2eec2ee/src/openvpn/buffer.h"", ""raw_url"": ""https://github.com/OpenVPN/openvpn/raw/11d21349a4e7e38a025849479b36ace7c2eec2ee/src/openvpn/buffer.h"", ""contents_url"": ""https://api.github.com/repos/OpenVPN/openvpn/contents/src/openvpn/buffer.h?ref=11d21349a4e7e38a025849479b36ace7c2eec2ee"", ""patch"": ""@@ -668,6 +668,10 @@ buf_read_u32 (struct buffer *buf, bool *good)\n     }\n }\n \n+/**\n+ * Compare src buffer contents with match.\n+ * *NOT* constant time. Do not use when comparing HMACs.\n+ */\n static inline bool\n buf_string_match (const struct buffer *src, const void *match, int size)\n {\n@@ -676,6 +680,10 @@ buf_string_match (const struct buffer *src, const void *match, int size)\n   return memcmp (BPTR (src), match, size) == 0;\n }\n \n+/**\n+ * Compare first size bytes of src buffer contents with match.\n+ * *NOT* constant time. Do not use when comparing HMACs.\n+ */\n static inline bool\n buf_string_match_head (const struct buffer *src, const void *match, int size)\n {""}<_**next**_>{""sha"": ""d9adf5b51304cd7611c7bfc8d69d6f6447555476"", ""filename"": ""src/openvpn/crypto.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 1, ""changes"": 20, ""blob_url"": ""https://github.com/OpenVPN/openvpn/blob/11d21349a4e7e38a025849479b36ace7c2eec2ee/src/openvpn/crypto.c"", ""raw_url"": ""https://github.com/OpenVPN/openvpn/raw/11d21349a4e7e38a025849479b36ace7c2eec2ee/src/openvpn/crypto.c"", ""contents_url"": ""https://api.github.com/repos/OpenVPN/openvpn/contents/src/openvpn/crypto.c?ref=11d21349a4e7e38a025849479b36ace7c2eec2ee"", ""patch"": ""@@ -65,6 +65,24 @@\n #define CRYPT_ERROR(format) \\\n   do { msg (D_CRYPT_ERRORS, \""%s: \"" format, error_prefix); goto error_exit; } while (false)\n \n+/**\n+ * As memcmp(), but constant-time.\n+ * Returns 0 when data is equal, non-zero otherwise.\n+ */\n+static int\n+memcmp_constant_time (const void *a, const void *b, size_t size) {\n+  const uint8_t * a1 = a;\n+  const uint8_t * b1 = b;\n+  int ret = 0;\n+  size_t i;\n+\n+  for (i = 0; i < size; i++) {\n+      ret |= *a1++ ^ *b1++;\n+  }\n+\n+  return ret;\n+}\n+\n void\n openvpn_encrypt (struct buffer *buf, struct buffer work,\n \t\t const struct crypto_options *opt,\n@@ -244,7 +262,7 @@ openvpn_decrypt (struct buffer *buf, struct buffer work,\n \t  hmac_ctx_final (ctx->hmac, local_hmac);\n \n \t  /* Compare locally computed HMAC with packet HMAC */\n-\t  if (memcmp (local_hmac, BPTR (buf), hmac_len))\n+\t  if (memcmp_constant_time (local_hmac, BPTR (buf), hmac_len))\n \t    CRYPT_ERROR (\""packet HMAC authentication failed\"");\n \n \t  ASSERT (buf_advance (buf, hmac_len));""}","openvpn_decrypt (struct buffer *buf, struct buffer work,
		 const struct crypto_options *opt,
		 const struct frame* frame)
{
  static const char error_prefix[] = ""Authenticate/Decrypt packet error"";
  struct gc_arena gc;
  gc_init (&gc);

  if (buf->len > 0 && opt->key_ctx_bi)
    {
      struct key_ctx *ctx = &opt->key_ctx_bi->decrypt;
      struct packet_id_net pin;
      bool have_pin = false;

      /* Verify the HMAC */
      if (ctx->hmac)
	{
	  int hmac_len;
	  uint8_t local_hmac[MAX_HMAC_KEY_LENGTH]; /* HMAC of ciphertext computed locally */

	  hmac_ctx_reset(ctx->hmac);

	  /* Assume the length of the input HMAC */
	  hmac_len = hmac_ctx_size (ctx->hmac);

	  /* Authentication fails if insufficient data in packet for HMAC */
	  if (buf->len < hmac_len)
	    CRYPT_ERROR (""missing authentication info"");

	  hmac_ctx_update (ctx->hmac, BPTR (buf) + hmac_len, BLEN (buf) - hmac_len);
 	  hmac_ctx_final (ctx->hmac, local_hmac);
 
 	  /* Compare locally computed HMAC with packet HMAC */
	  if (memcmp_constant_time (local_hmac, BPTR (buf), hmac_len))
 	    CRYPT_ERROR (""packet HMAC authentication failed"");
 
 	  ASSERT (buf_advance (buf, hmac_len));
	}

      /* Decrypt packet ID + payload */

      if (ctx->cipher)
	{
	  const unsigned int mode = cipher_ctx_mode (ctx->cipher);
	  const int iv_size = cipher_ctx_iv_length (ctx->cipher);
	  uint8_t iv_buf[OPENVPN_MAX_IV_LENGTH];
	  int outlen;

	  /* initialize work buffer with FRAME_HEADROOM bytes of prepend capacity */
	  ASSERT (buf_init (&work, FRAME_HEADROOM_ADJ (frame, FRAME_HEADROOM_MARKER_DECRYPT)));

	  /* use IV if user requested it */
	  CLEAR (iv_buf);
	  if (opt->flags & CO_USE_IV)
	    {
	      if (buf->len < iv_size)
		CRYPT_ERROR (""missing IV info"");
	      memcpy (iv_buf, BPTR (buf), iv_size);
	      ASSERT (buf_advance (buf, iv_size));
	    }

	  /* show the IV's initial state */
	  if (opt->flags & CO_USE_IV)
	    dmsg (D_PACKET_CONTENT, ""DECRYPT IV: %s"", format_hex (iv_buf, iv_size, 0, &gc));

	  if (buf->len < 1)
	    CRYPT_ERROR (""missing payload"");

	  /* ctx->cipher was already initialized with key & keylen */
	  if (!cipher_ctx_reset (ctx->cipher, iv_buf))
	    CRYPT_ERROR (""cipher init failed"");

	  /* Buffer overflow check (should never happen) */
	  if (!buf_safe (&work, buf->len))
	    CRYPT_ERROR (""buffer overflow"");

	  /* Decrypt packet ID, payload */
	  if (!cipher_ctx_update (ctx->cipher, BPTR (&work), &outlen, BPTR (buf), BLEN (buf)))
	    CRYPT_ERROR (""cipher update failed"");
	  work.len += outlen;

	  /* Flush the decryption buffer */
	  if (!cipher_ctx_final (ctx->cipher, BPTR (&work) + outlen, &outlen))
	    CRYPT_ERROR (""cipher final failed"");
	  work.len += outlen;

	  dmsg (D_PACKET_CONTENT, ""DECRYPT TO: %s"",
	       format_hex (BPTR (&work), BLEN (&work), 80, &gc));

	  /* Get packet ID from plaintext buffer or IV, depending on cipher mode */
	  {
	    if (mode == OPENVPN_MODE_CBC)
	      {
		if (opt->packet_id)
		  {
		    if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))
		      CRYPT_ERROR (""error reading CBC packet-id"");
		    have_pin = true;
		  }
	      }
	    else if (mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB)
	      {
		struct buffer b;

		ASSERT (opt->flags & CO_USE_IV);    /* IV and packet-ID required */
		ASSERT (opt->packet_id); /*  for this mode. */

		buf_set_read (&b, iv_buf, iv_size);
		if (!packet_id_read (&pin, &b, true))
		  CRYPT_ERROR (""error reading CFB/OFB packet-id"");
		have_pin = true;
	      }
	    else /* We only support CBC, CFB, or OFB modes right now */
	      {
		ASSERT (0);
	      }
	  }
	}
      else
	{
	  work = *buf;
	  if (opt->packet_id)
	    {
	      if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))
		CRYPT_ERROR (""error reading packet-id"");
	      have_pin = !BOOL_CAST (opt->flags & CO_IGNORE_PACKET_ID);
	    }
	}
      
      if (have_pin)
	{
	  packet_id_reap_test (&opt->packet_id->rec);
	  if (packet_id_test (&opt->packet_id->rec, &pin))
	    {
	      packet_id_add (&opt->packet_id->rec, &pin);
	      if (opt->pid_persist && (opt->flags & CO_PACKET_ID_LONG_FORM))
		packet_id_persist_save_obj (opt->pid_persist, opt->packet_id);
	    }
	  else
	    {
	      if (!(opt->flags & CO_MUTE_REPLAY_WARNINGS))
	      msg (D_REPLAY_ERRORS, ""%s: bad packet ID (may be a replay): %s -- see the man page entry for --no-replay and --replay-window for more info or silence this warning with --mute-replay-warnings"",
		   error_prefix, packet_id_net_print (&pin, true, &gc));
	      goto error_exit;
	    }
	}
      *buf = work;
    }

  gc_free (&gc);
  return true;

 error_exit:
  crypto_clear_error();
  buf->len = 0;
  gc_free (&gc);
  return false;
}
","openvpn_decrypt (struct buffer *buf, struct buffer work,
		 const struct crypto_options *opt,
		 const struct frame* frame)
{
  static const char error_prefix[] = ""Authenticate/Decrypt packet error"";
  struct gc_arena gc;
  gc_init (&gc);

  if (buf->len > 0 && opt->key_ctx_bi)
    {
      struct key_ctx *ctx = &opt->key_ctx_bi->decrypt;
      struct packet_id_net pin;
      bool have_pin = false;

      /* Verify the HMAC */
      if (ctx->hmac)
	{
	  int hmac_len;
	  uint8_t local_hmac[MAX_HMAC_KEY_LENGTH]; /* HMAC of ciphertext computed locally */

	  hmac_ctx_reset(ctx->hmac);

	  /* Assume the length of the input HMAC */
	  hmac_len = hmac_ctx_size (ctx->hmac);

	  /* Authentication fails if insufficient data in packet for HMAC */
	  if (buf->len < hmac_len)
	    CRYPT_ERROR (""missing authentication info"");

	  hmac_ctx_update (ctx->hmac, BPTR (buf) + hmac_len, BLEN (buf) - hmac_len);
 	  hmac_ctx_final (ctx->hmac, local_hmac);
 
 	  /* Compare locally computed HMAC with packet HMAC */
	  if (memcmp (local_hmac, BPTR (buf), hmac_len))
 	    CRYPT_ERROR (""packet HMAC authentication failed"");
 
 	  ASSERT (buf_advance (buf, hmac_len));
	}

      /* Decrypt packet ID + payload */

      if (ctx->cipher)
	{
	  const unsigned int mode = cipher_ctx_mode (ctx->cipher);
	  const int iv_size = cipher_ctx_iv_length (ctx->cipher);
	  uint8_t iv_buf[OPENVPN_MAX_IV_LENGTH];
	  int outlen;

	  /* initialize work buffer with FRAME_HEADROOM bytes of prepend capacity */
	  ASSERT (buf_init (&work, FRAME_HEADROOM_ADJ (frame, FRAME_HEADROOM_MARKER_DECRYPT)));

	  /* use IV if user requested it */
	  CLEAR (iv_buf);
	  if (opt->flags & CO_USE_IV)
	    {
	      if (buf->len < iv_size)
		CRYPT_ERROR (""missing IV info"");
	      memcpy (iv_buf, BPTR (buf), iv_size);
	      ASSERT (buf_advance (buf, iv_size));
	    }

	  /* show the IV's initial state */
	  if (opt->flags & CO_USE_IV)
	    dmsg (D_PACKET_CONTENT, ""DECRYPT IV: %s"", format_hex (iv_buf, iv_size, 0, &gc));

	  if (buf->len < 1)
	    CRYPT_ERROR (""missing payload"");

	  /* ctx->cipher was already initialized with key & keylen */
	  if (!cipher_ctx_reset (ctx->cipher, iv_buf))
	    CRYPT_ERROR (""cipher init failed"");

	  /* Buffer overflow check (should never happen) */
	  if (!buf_safe (&work, buf->len))
	    CRYPT_ERROR (""buffer overflow"");

	  /* Decrypt packet ID, payload */
	  if (!cipher_ctx_update (ctx->cipher, BPTR (&work), &outlen, BPTR (buf), BLEN (buf)))
	    CRYPT_ERROR (""cipher update failed"");
	  work.len += outlen;

	  /* Flush the decryption buffer */
	  if (!cipher_ctx_final (ctx->cipher, BPTR (&work) + outlen, &outlen))
	    CRYPT_ERROR (""cipher final failed"");
	  work.len += outlen;

	  dmsg (D_PACKET_CONTENT, ""DECRYPT TO: %s"",
	       format_hex (BPTR (&work), BLEN (&work), 80, &gc));

	  /* Get packet ID from plaintext buffer or IV, depending on cipher mode */
	  {
	    if (mode == OPENVPN_MODE_CBC)
	      {
		if (opt->packet_id)
		  {
		    if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))
		      CRYPT_ERROR (""error reading CBC packet-id"");
		    have_pin = true;
		  }
	      }
	    else if (mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB)
	      {
		struct buffer b;

		ASSERT (opt->flags & CO_USE_IV);    /* IV and packet-ID required */
		ASSERT (opt->packet_id); /*  for this mode. */

		buf_set_read (&b, iv_buf, iv_size);
		if (!packet_id_read (&pin, &b, true))
		  CRYPT_ERROR (""error reading CFB/OFB packet-id"");
		have_pin = true;
	      }
	    else /* We only support CBC, CFB, or OFB modes right now */
	      {
		ASSERT (0);
	      }
	  }
	}
      else
	{
	  work = *buf;
	  if (opt->packet_id)
	    {
	      if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))
		CRYPT_ERROR (""error reading packet-id"");
	      have_pin = !BOOL_CAST (opt->flags & CO_IGNORE_PACKET_ID);
	    }
	}
      
      if (have_pin)
	{
	  packet_id_reap_test (&opt->packet_id->rec);
	  if (packet_id_test (&opt->packet_id->rec, &pin))
	    {
	      packet_id_add (&opt->packet_id->rec, &pin);
	      if (opt->pid_persist && (opt->flags & CO_PACKET_ID_LONG_FORM))
		packet_id_persist_save_obj (opt->pid_persist, opt->packet_id);
	    }
	  else
	    {
	      if (!(opt->flags & CO_MUTE_REPLAY_WARNINGS))
	      msg (D_REPLAY_ERRORS, ""%s: bad packet ID (may be a replay): %s -- see the man page entry for --no-replay and --replay-window for more info or silence this warning with --mute-replay-warnings"",
		   error_prefix, packet_id_net_print (&pin, true, &gc));
	      goto error_exit;
	    }
	}
      *buf = work;
    }

  gc_free (&gc);
  return true;

 error_exit:
  crypto_clear_error();
  buf->len = 0;
  gc_free (&gc);
  return false;
}
",C,"	  if (memcmp_constant_time (local_hmac, BPTR (buf), hmac_len))
","	  if (memcmp (local_hmac, BPTR (buf), hmac_len))
",,"@@ -65,6 +65,24 @@
 #define CRYPT_ERROR(format) \
   do { msg (D_CRYPT_ERRORS, ""%s: "" format, error_prefix); goto error_exit; } while (false)
 
+/**
+ * As memcmp(), but constant-time.
+ * Returns 0 when data is equal, non-zero otherwise.
+ */
+static int
+memcmp_constant_time (const void *a, const void *b, size_t size) {
+  const uint8_t * a1 = a;
+  const uint8_t * b1 = b;
+  int ret = 0;
+  size_t i;
+
+  for (i = 0; i < size; i++) {
+      ret |= *a1++ ^ *b1++;
+  }
+
+  return ret;
+}
+
 void
 openvpn_encrypt (struct buffer *buf, struct buffer work,
 		 const struct crypto_options *opt,
@@ -244,7 +262,7 @@ openvpn_decrypt (struct buffer *buf, struct buffer work,
 	  hmac_ctx_final (ctx->hmac, local_hmac);
 
 	  /* Compare locally computed HMAC with packet HMAC */
-	  if (memcmp (local_hmac, BPTR (buf), hmac_len))
+	  if (memcmp_constant_time (local_hmac, BPTR (buf), hmac_len))
 	    CRYPT_ERROR (""packet HMAC authentication failed"");
 
 	  ASSERT (buf_advance (buf, hmac_len));",openvpn,11d21349a4e7e38a025849479b36ace7c2eec2ee,9a3f670248d6f519a399e65a7232e2196b5115db,1,"openvpn_decrypt (struct buffer *buf, struct buffer work,
		 const struct crypto_options *opt,
		 const struct frame* frame)
{
  static const char error_prefix[] = ""Authenticate/Decrypt packet error"";
  struct gc_arena gc;
  gc_init (&gc);

  if (buf->len > 0 && opt->key_ctx_bi)
    {
      struct key_ctx *ctx = &opt->key_ctx_bi->decrypt;
      struct packet_id_net pin;
      bool have_pin = false;

      /* Verify the HMAC */
      if (ctx->hmac)
	{
	  int hmac_len;
	  uint8_t local_hmac[MAX_HMAC_KEY_LENGTH]; /* HMAC of ciphertext computed locally */

	  hmac_ctx_reset(ctx->hmac);

	  /* Assume the length of the input HMAC */
	  hmac_len = hmac_ctx_size (ctx->hmac);

	  /* Authentication fails if insufficient data in packet for HMAC */
	  if (buf->len < hmac_len)
	    CRYPT_ERROR (""missing authentication info"");

	  hmac_ctx_update (ctx->hmac, BPTR (buf) + hmac_len, BLEN (buf) - hmac_len);
 	  hmac_ctx_final (ctx->hmac, local_hmac);
 
 	  /* Compare locally computed HMAC with packet HMAC */
//flaw_line_below:
	  if (memcmp (local_hmac, BPTR (buf), hmac_len))
//fix_flaw_line_below:
//	  if (memcmp_constant_time (local_hmac, BPTR (buf), hmac_len))
 	    CRYPT_ERROR (""packet HMAC authentication failed"");
 
 	  ASSERT (buf_advance (buf, hmac_len));
	}

      /* Decrypt packet ID + payload */

      if (ctx->cipher)
	{
	  const unsigned int mode = cipher_ctx_mode (ctx->cipher);
	  const int iv_size = cipher_ctx_iv_length (ctx->cipher);
	  uint8_t iv_buf[OPENVPN_MAX_IV_LENGTH];
	  int outlen;

	  /* initialize work buffer with FRAME_HEADROOM bytes of prepend capacity */
	  ASSERT (buf_init (&work, FRAME_HEADROOM_ADJ (frame, FRAME_HEADROOM_MARKER_DECRYPT)));

	  /* use IV if user requested it */
	  CLEAR (iv_buf);
	  if (opt->flags & CO_USE_IV)
	    {
	      if (buf->len < iv_size)
		CRYPT_ERROR (""missing IV info"");
	      memcpy (iv_buf, BPTR (buf), iv_size);
	      ASSERT (buf_advance (buf, iv_size));
	    }

	  /* show the IV's initial state */
	  if (opt->flags & CO_USE_IV)
	    dmsg (D_PACKET_CONTENT, ""DECRYPT IV: %s"", format_hex (iv_buf, iv_size, 0, &gc));

	  if (buf->len < 1)
	    CRYPT_ERROR (""missing payload"");

	  /* ctx->cipher was already initialized with key & keylen */
	  if (!cipher_ctx_reset (ctx->cipher, iv_buf))
	    CRYPT_ERROR (""cipher init failed"");

	  /* Buffer overflow check (should never happen) */
	  if (!buf_safe (&work, buf->len))
	    CRYPT_ERROR (""buffer overflow"");

	  /* Decrypt packet ID, payload */
	  if (!cipher_ctx_update (ctx->cipher, BPTR (&work), &outlen, BPTR (buf), BLEN (buf)))
	    CRYPT_ERROR (""cipher update failed"");
	  work.len += outlen;

	  /* Flush the decryption buffer */
	  if (!cipher_ctx_final (ctx->cipher, BPTR (&work) + outlen, &outlen))
	    CRYPT_ERROR (""cipher final failed"");
	  work.len += outlen;

	  dmsg (D_PACKET_CONTENT, ""DECRYPT TO: %s"",
	       format_hex (BPTR (&work), BLEN (&work), 80, &gc));

	  /* Get packet ID from plaintext buffer or IV, depending on cipher mode */
	  {
	    if (mode == OPENVPN_MODE_CBC)
	      {
		if (opt->packet_id)
		  {
		    if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))
		      CRYPT_ERROR (""error reading CBC packet-id"");
		    have_pin = true;
		  }
	      }
	    else if (mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB)
	      {
		struct buffer b;

		ASSERT (opt->flags & CO_USE_IV);    /* IV and packet-ID required */
		ASSERT (opt->packet_id); /*  for this mode. */

		buf_set_read (&b, iv_buf, iv_size);
		if (!packet_id_read (&pin, &b, true))
		  CRYPT_ERROR (""error reading CFB/OFB packet-id"");
		have_pin = true;
	      }
	    else /* We only support CBC, CFB, or OFB modes right now */
	      {
		ASSERT (0);
	      }
	  }
	}
      else
	{
	  work = *buf;
	  if (opt->packet_id)
	    {
	      if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))
		CRYPT_ERROR (""error reading packet-id"");
	      have_pin = !BOOL_CAST (opt->flags & CO_IGNORE_PACKET_ID);
	    }
	}
      
      if (have_pin)
	{
	  packet_id_reap_test (&opt->packet_id->rec);
	  if (packet_id_test (&opt->packet_id->rec, &pin))
	    {
	      packet_id_add (&opt->packet_id->rec, &pin);
	      if (opt->pid_persist && (opt->flags & CO_PACKET_ID_LONG_FORM))
		packet_id_persist_save_obj (opt->pid_persist, opt->packet_id);
	    }
	  else
	    {
	      if (!(opt->flags & CO_MUTE_REPLAY_WARNINGS))
	      msg (D_REPLAY_ERRORS, ""%s: bad packet ID (may be a replay): %s -- see the man page entry for --no-replay and --replay-window for more info or silence this warning with --mute-replay-warnings"",
		   error_prefix, packet_id_net_print (&pin, true, &gc));
	      goto error_exit;
	    }
	}
      *buf = work;
    }

  gc_free (&gc);
  return true;

 error_exit:
  crypto_clear_error();
  buf->len = 0;
  gc_free (&gc);
  return false;
}
",179258,"openvpn_decrypt (struct buffer *buf, struct buffer work,
		 const struct crypto_options *opt,
		 const struct frame* frame)
{
  static const char error_prefix[] = ""Authenticate/Decrypt packet error"";
  struct gc_arena gc;
  gc_init (&gc);

  if (buf->len > 0 && opt->key_ctx_bi)
    {
      struct key_ctx *ctx = &opt->key_ctx_bi->decrypt;
      struct packet_id_net pin;
      bool have_pin = false;

      /* Verify the HMAC */
      if (ctx->hmac)
	{
	  int hmac_len;
	  uint8_t local_hmac[MAX_HMAC_KEY_LENGTH]; /* HMAC of ciphertext computed locally */

	  hmac_ctx_reset(ctx->hmac);

	  /* Assume the length of the input HMAC */
	  hmac_len = hmac_ctx_size (ctx->hmac);

	  /* Authentication fails if insufficient data in packet for HMAC */
	  if (buf->len < hmac_len)
	    CRYPT_ERROR (""missing authentication info"");

	  hmac_ctx_update (ctx->hmac, BPTR (buf) + hmac_len, BLEN (buf) - hmac_len);
 	  hmac_ctx_final (ctx->hmac, local_hmac);
 
 	  /* Compare locally computed HMAC with packet HMAC */
	  if (memcmp (local_hmac, BPTR (buf), hmac_len))
 	    CRYPT_ERROR (""packet HMAC authentication failed"");
 
 	  ASSERT (buf_advance (buf, hmac_len));
	}

      /* Decrypt packet ID + payload */

      if (ctx->cipher)
	{
	  const unsigned int mode = cipher_ctx_mode (ctx->cipher);
	  const int iv_size = cipher_ctx_iv_length (ctx->cipher);
	  uint8_t iv_buf[OPENVPN_MAX_IV_LENGTH];
	  int outlen;

	  /* initialize work buffer with FRAME_HEADROOM bytes of prepend capacity */
	  ASSERT (buf_init (&work, FRAME_HEADROOM_ADJ (frame, FRAME_HEADROOM_MARKER_DECRYPT)));

	  /* use IV if user requested it */
	  CLEAR (iv_buf);
	  if (opt->flags & CO_USE_IV)
	    {
	      if (buf->len < iv_size)
		CRYPT_ERROR (""missing IV info"");
	      memcpy (iv_buf, BPTR (buf), iv_size);
	      ASSERT (buf_advance (buf, iv_size));
	    }

	  /* show the IV's initial state */
	  if (opt->flags & CO_USE_IV)
	    dmsg (D_PACKET_CONTENT, ""DECRYPT IV: %s"", format_hex (iv_buf, iv_size, 0, &gc));

	  if (buf->len < 1)
	    CRYPT_ERROR (""missing payload"");

	  /* ctx->cipher was already initialized with key & keylen */
	  if (!cipher_ctx_reset (ctx->cipher, iv_buf))
	    CRYPT_ERROR (""cipher init failed"");

	  /* Buffer overflow check (should never happen) */
	  if (!buf_safe (&work, buf->len))
	    CRYPT_ERROR (""buffer overflow"");

	  /* Decrypt packet ID, payload */
	  if (!cipher_ctx_update (ctx->cipher, BPTR (&work), &outlen, BPTR (buf), BLEN (buf)))
	    CRYPT_ERROR (""cipher update failed"");
	  work.len += outlen;

	  /* Flush the decryption buffer */
	  if (!cipher_ctx_final (ctx->cipher, BPTR (&work) + outlen, &outlen))
	    CRYPT_ERROR (""cipher final failed"");
	  work.len += outlen;

	  dmsg (D_PACKET_CONTENT, ""DECRYPT TO: %s"",
	       format_hex (BPTR (&work), BLEN (&work), 80, &gc));

	  /* Get packet ID from plaintext buffer or IV, depending on cipher mode */
	  {
	    if (mode == OPENVPN_MODE_CBC)
	      {
		if (opt->packet_id)
		  {
		    if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))
		      CRYPT_ERROR (""error reading CBC packet-id"");
		    have_pin = true;
		  }
	      }
	    else if (mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB)
	      {
		struct buffer b;

		ASSERT (opt->flags & CO_USE_IV);    /* IV and packet-ID required */
		ASSERT (opt->packet_id); /*  for this mode. */

		buf_set_read (&b, iv_buf, iv_size);
		if (!packet_id_read (&pin, &b, true))
		  CRYPT_ERROR (""error reading CFB/OFB packet-id"");
		have_pin = true;
	      }
	    else /* We only support CBC, CFB, or OFB modes right now */
	      {
		ASSERT (0);
	      }
	  }
	}
      else
	{
	  work = *buf;
	  if (opt->packet_id)
	    {
	      if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))
		CRYPT_ERROR (""error reading packet-id"");
	      have_pin = !BOOL_CAST (opt->flags & CO_IGNORE_PACKET_ID);
	    }
	}
      
      if (have_pin)
	{
	  packet_id_reap_test (&opt->packet_id->rec);
	  if (packet_id_test (&opt->packet_id->rec, &pin))
	    {
	      packet_id_add (&opt->packet_id->rec, &pin);
	      if (opt->pid_persist && (opt->flags & CO_PACKET_ID_LONG_FORM))
		packet_id_persist_save_obj (opt->pid_persist, opt->packet_id);
	    }
	  else
	    {
	      if (!(opt->flags & CO_MUTE_REPLAY_WARNINGS))
	      msg (D_REPLAY_ERRORS, ""%s: bad packet ID (may be a replay): %s -- see the man page entry for --no-replay and --replay-window for more info or silence this warning with --mute-replay-warnings"",
		   error_prefix, packet_id_net_print (&pin, true, &gc));
	      goto error_exit;
	    }
	}
      *buf = work;
    }

  gc_free (&gc);
  return true;

 error_exit:
  crypto_clear_error();
  buf->len = 0;
  gc_free (&gc);
  return false;
}
","openvpn_decrypt (struct buffer *buf, struct buffer work,
		 const struct crypto_options *opt,
		 const struct frame* frame)
{
  static const char error_prefix[] = ""Authenticate/Decrypt packet error"";
  struct gc_arena gc;
  gc_init (&gc);

  if (buf->len > 0 && opt->key_ctx_bi)
    {
      struct key_ctx *ctx = &opt->key_ctx_bi->decrypt;
      struct packet_id_net pin;
      bool have_pin = false;

      /* Verify the HMAC */
      if (ctx->hmac)
	{
	  int hmac_len;
	  uint8_t local_hmac[MAX_HMAC_KEY_LENGTH]; /* HMAC of ciphertext computed locally */

	  hmac_ctx_reset(ctx->hmac);

	  /* Assume the length of the input HMAC */
	  hmac_len = hmac_ctx_size (ctx->hmac);

	  /* Authentication fails if insufficient data in packet for HMAC */
	  if (buf->len < hmac_len)
	    CRYPT_ERROR (""missing authentication info"");

	  hmac_ctx_update (ctx->hmac, BPTR (buf) + hmac_len, BLEN (buf) - hmac_len);
 	  hmac_ctx_final (ctx->hmac, local_hmac);
 
 	  /* Compare locally computed HMAC with packet HMAC */
	  if (memcmp_constant_time (local_hmac, BPTR (buf), hmac_len))
 	    CRYPT_ERROR (""packet HMAC authentication failed"");
 
 	  ASSERT (buf_advance (buf, hmac_len));
	}

      /* Decrypt packet ID + payload */

      if (ctx->cipher)
	{
	  const unsigned int mode = cipher_ctx_mode (ctx->cipher);
	  const int iv_size = cipher_ctx_iv_length (ctx->cipher);
	  uint8_t iv_buf[OPENVPN_MAX_IV_LENGTH];
	  int outlen;

	  /* initialize work buffer with FRAME_HEADROOM bytes of prepend capacity */
	  ASSERT (buf_init (&work, FRAME_HEADROOM_ADJ (frame, FRAME_HEADROOM_MARKER_DECRYPT)));

	  /* use IV if user requested it */
	  CLEAR (iv_buf);
	  if (opt->flags & CO_USE_IV)
	    {
	      if (buf->len < iv_size)
		CRYPT_ERROR (""missing IV info"");
	      memcpy (iv_buf, BPTR (buf), iv_size);
	      ASSERT (buf_advance (buf, iv_size));
	    }

	  /* show the IV's initial state */
	  if (opt->flags & CO_USE_IV)
	    dmsg (D_PACKET_CONTENT, ""DECRYPT IV: %s"", format_hex (iv_buf, iv_size, 0, &gc));

	  if (buf->len < 1)
	    CRYPT_ERROR (""missing payload"");

	  /* ctx->cipher was already initialized with key & keylen */
	  if (!cipher_ctx_reset (ctx->cipher, iv_buf))
	    CRYPT_ERROR (""cipher init failed"");

	  /* Buffer overflow check (should never happen) */
	  if (!buf_safe (&work, buf->len))
	    CRYPT_ERROR (""buffer overflow"");

	  /* Decrypt packet ID, payload */
	  if (!cipher_ctx_update (ctx->cipher, BPTR (&work), &outlen, BPTR (buf), BLEN (buf)))
	    CRYPT_ERROR (""cipher update failed"");
	  work.len += outlen;

	  /* Flush the decryption buffer */
	  if (!cipher_ctx_final (ctx->cipher, BPTR (&work) + outlen, &outlen))
	    CRYPT_ERROR (""cipher final failed"");
	  work.len += outlen;

	  dmsg (D_PACKET_CONTENT, ""DECRYPT TO: %s"",
	       format_hex (BPTR (&work), BLEN (&work), 80, &gc));

	  /* Get packet ID from plaintext buffer or IV, depending on cipher mode */
	  {
	    if (mode == OPENVPN_MODE_CBC)
	      {
		if (opt->packet_id)
		  {
		    if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))
		      CRYPT_ERROR (""error reading CBC packet-id"");
		    have_pin = true;
		  }
	      }
	    else if (mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB)
	      {
		struct buffer b;

		ASSERT (opt->flags & CO_USE_IV);    /* IV and packet-ID required */
		ASSERT (opt->packet_id); /*  for this mode. */

		buf_set_read (&b, iv_buf, iv_size);
		if (!packet_id_read (&pin, &b, true))
		  CRYPT_ERROR (""error reading CFB/OFB packet-id"");
		have_pin = true;
	      }
	    else /* We only support CBC, CFB, or OFB modes right now */
	      {
		ASSERT (0);
	      }
	  }
	}
      else
	{
	  work = *buf;
	  if (opt->packet_id)
	    {
	      if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))
		CRYPT_ERROR (""error reading packet-id"");
	      have_pin = !BOOL_CAST (opt->flags & CO_IGNORE_PACKET_ID);
	    }
	}
      
      if (have_pin)
	{
	  packet_id_reap_test (&opt->packet_id->rec);
	  if (packet_id_test (&opt->packet_id->rec, &pin))
	    {
	      packet_id_add (&opt->packet_id->rec, &pin);
	      if (opt->pid_persist && (opt->flags & CO_PACKET_ID_LONG_FORM))
		packet_id_persist_save_obj (opt->pid_persist, opt->packet_id);
	    }
	  else
	    {
	      if (!(opt->flags & CO_MUTE_REPLAY_WARNINGS))
	      msg (D_REPLAY_ERRORS, ""%s: bad packet ID (may be a replay): %s -- see the man page entry for --no-replay and --replay-window for more info or silence this warning with --mute-replay-warnings"",
		   error_prefix, packet_id_net_print (&pin, true, &gc));
	      goto error_exit;
	    }
	}
      *buf = work;
    }

  gc_free (&gc);
  return true;

 error_exit:
  crypto_clear_error();
  buf->len = 0;
  gc_free (&gc);
  return false;
}
","The `openvpn_decrypt` function is responsible for decrypting packets in an OpenVPN context. It first verifies the HMAC (Hash-based Message Authentication Code) of the incoming data to ensure its integrity and authenticity. If the HMAC is valid, it proceeds to decrypt the packet using a specified cipher, handling initialization vectors (IVs) as needed. The function also extracts a packet ID from the decrypted data, checks it against a replay protection mechanism, and manages packet ID persistence if configured. If any step fails, it logs an error, clears the buffer, and returns a failure status, ensuring secure handling of sensitive data.","The provided code implements a decryption process for secure packet transmission, ensuring data integrity and authenticity. It begins by verifying the authenticity of the incoming data using a cryptographic checksum. Upon successful verification, the code decrypts the packet while managing initialization vectors to enhance security. It extracts a unique identifier from the decrypted data to prevent replay attacks, checking it against a stored record to ensure it hasn't been previously used. If any verification or decryption step fails, the code handles errors gracefully, clearing sensitive data and returning a failure status to maintain security.","The vulnerability in the original code stemmed from using a standard memory comparison function to verify the HMAC, which could be susceptible to timing attacks. An attacker could exploit the time variations in the comparison process to infer information about the HMAC and potentially forge valid packets. The fix implemented a constant-time comparison function, ensuring that the time taken to compare the HMACs remains consistent regardless of the input values. This change mitigates the risk of timing attacks, enhancing the overall security of the packet authentication process in the decryption function.","The vulnerability in the original code arose from using a standard comparison method to verify the integrity of cryptographic data, which could be exploited through timing attacks. An attacker could measure the time taken for the comparison to infer information about the data being compared, potentially allowing them to craft valid packets. The fix involved implementing a constant-time comparison method, ensuring that the time taken to compare the data remains consistent regardless of the input values. This adjustment effectively mitigates the risk of timing attacks, thereby enhancing the security of the authentication process.","The vulnerability was fixed by replacing the standard memory comparison function with a constant-time comparison function for verifying the HMAC. In the updated code, the `memcmp_constant_time` function is used instead of the original `memcmp` to compare the locally computed HMAC with the packet HMAC. This change ensures that the time taken for the comparison does not vary based on the input values, effectively preventing timing attacks that could exploit differences in execution time. By implementing this constant-time approach, the integrity of the authentication process is significantly enhanced, making it more resistant to potential attacks.","The vulnerability was addressed by implementing a constant-time comparison method for verifying the integrity of cryptographic data. This change replaced the standard comparison approach, which could be exploited through timing attacks, with a method that ensures the time taken for the comparison remains consistent regardless of the input values. By doing so, the code prevents attackers from inferring information based on timing variations during the comparison process. This enhancement significantly strengthens the security of the authentication mechanism, making it more resilient against potential exploitation attempts.","5,5","5, 5","5,5","4,4"
36,36,179274,179274,,Local,Not required,,CVE-2013-1928,https://www.cvedetails.com/cve/CVE-2013-1928/,CWE-200,Medium,Complete,,,2013-04-29,4.7,"The do_video_set_spu_palette function in fs/compat_ioctl.c in the Linux kernel before 3.6.5 on unspecified architectures lacks a certain error check, which might allow local users to obtain sensitive information from kernel stack memory via a crafted VIDEO_SET_SPU_PALETTE ioctl call on a /dev/dvb device.",2019-04-22,+Info ,2,https://github.com/torvalds/linux/commit/12176503366885edd542389eed3aaf94be163fdb,12176503366885edd542389eed3aaf94be163fdb,"fs/compat_ioctl.c: VIDEO_SET_SPU_PALETTE missing error check

The compat ioctl for VIDEO_SET_SPU_PALETTE was missing an error check
while converting ioctl arguments.  This could lead to leaking kernel
stack contents into userspace.

Patch extracted from existing fix in grsecurity.

Signed-off-by: Kees Cook <keescook@chromium.org>
Cc: David Miller <davem@davemloft.net>
Cc: Brad Spengler <spender@grsecurity.net>
Cc: PaX Team <pageexec@freemail.hu>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,fs/compat_ioctl.c,"{""sha"": ""4c6285fff598e1faf9bb471f8b3b5593db74b355"", ""filename"": ""fs/compat_ioctl.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/12176503366885edd542389eed3aaf94be163fdb/fs/compat_ioctl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/12176503366885edd542389eed3aaf94be163fdb/fs/compat_ioctl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/compat_ioctl.c?ref=12176503366885edd542389eed3aaf94be163fdb"", ""patch"": ""@@ -210,6 +210,8 @@ static int do_video_set_spu_palette(unsigned int fd, unsigned int cmd,\n \n \terr  = get_user(palp, &up->palette);\n \terr |= get_user(length, &up->length);\n+\tif (err)\n+\t\treturn -EFAULT;\n \n \tup_native = compat_alloc_user_space(sizeof(struct video_spu_palette));\n \terr  = put_user(compat_ptr(palp), &up_native->palette);""}","static int do_video_set_spu_palette(unsigned int fd, unsigned int cmd,
		struct compat_video_spu_palette __user *up)
{
	struct video_spu_palette __user *up_native;
	compat_uptr_t palp;
	int length, err;
 
 	err  = get_user(palp, &up->palette);
 	err |= get_user(length, &up->length);
	if (err)
		return -EFAULT;
 
 	up_native = compat_alloc_user_space(sizeof(struct video_spu_palette));
 	err  = put_user(compat_ptr(palp), &up_native->palette);
	err |= put_user(length, &up_native->length);
	if (err)
		return -EFAULT;

	err = sys_ioctl(fd, cmd, (unsigned long) up_native);

	return err;
}
","static int do_video_set_spu_palette(unsigned int fd, unsigned int cmd,
		struct compat_video_spu_palette __user *up)
{
	struct video_spu_palette __user *up_native;
	compat_uptr_t palp;
	int length, err;
 
 	err  = get_user(palp, &up->palette);
 	err |= get_user(length, &up->length);
 
 	up_native = compat_alloc_user_space(sizeof(struct video_spu_palette));
 	err  = put_user(compat_ptr(palp), &up_native->palette);
	err |= put_user(length, &up_native->length);
	if (err)
		return -EFAULT;

	err = sys_ioctl(fd, cmd, (unsigned long) up_native);

	return err;
}
",C,"	if (err)
		return -EFAULT;
",,,"@@ -210,6 +210,8 @@ static int do_video_set_spu_palette(unsigned int fd, unsigned int cmd,
 
 	err  = get_user(palp, &up->palette);
 	err |= get_user(length, &up->length);
+	if (err)
+		return -EFAULT;
 
 	up_native = compat_alloc_user_space(sizeof(struct video_spu_palette));
 	err  = put_user(compat_ptr(palp), &up_native->palette);",linux,12176503366885edd542389eed3aaf94be163fdb,20f1de659b77364d55d4e7fad2ef657e7730323f,1,"static int do_video_set_spu_palette(unsigned int fd, unsigned int cmd,
		struct compat_video_spu_palette __user *up)
{
	struct video_spu_palette __user *up_native;
	compat_uptr_t palp;
	int length, err;
 
 	err  = get_user(palp, &up->palette);
 	err |= get_user(length, &up->length);
//fix_flaw_line_below:
//	if (err)
//fix_flaw_line_below:
//		return -EFAULT;
 
 	up_native = compat_alloc_user_space(sizeof(struct video_spu_palette));
 	err  = put_user(compat_ptr(palp), &up_native->palette);
	err |= put_user(length, &up_native->length);
	if (err)
		return -EFAULT;

	err = sys_ioctl(fd, cmd, (unsigned long) up_native);

	return err;
}
",179274,"static int do_video_set_spu_palette(unsigned int fd, unsigned int cmd,
		struct compat_video_spu_palette __user *up)
{
	struct video_spu_palette __user *up_native;
	compat_uptr_t palp;
	int length, err;
 
 	err  = get_user(palp, &up->palette);
 	err |= get_user(length, &up->length);
 
 	up_native = compat_alloc_user_space(sizeof(struct video_spu_palette));
 	err  = put_user(compat_ptr(palp), &up_native->palette);
	err |= put_user(length, &up_native->length);
	if (err)
		return -EFAULT;

	err = sys_ioctl(fd, cmd, (unsigned long) up_native);

	return err;
}
","static int do_video_set_spu_palette(unsigned int fd, unsigned int cmd,
		struct compat_video_spu_palette __user *up)
{
	struct video_spu_palette __user *up_native;
	compat_uptr_t palp;
	int length, err;
 
 	err  = get_user(palp, &up->palette);
 	err |= get_user(length, &up->length);
	if (err)
		return -EFAULT;
 
 	up_native = compat_alloc_user_space(sizeof(struct video_spu_palette));
 	err  = put_user(compat_ptr(palp), &up_native->palette);
	err |= put_user(length, &up_native->length);
	if (err)
		return -EFAULT;

	err = sys_ioctl(fd, cmd, (unsigned long) up_native);

	return err;
}
","The provided code defines a function `do_video_set_spu_palette` that facilitates the setting of a video subtitle palette in a compatibility layer for user-space applications. It begins by retrieving the palette pointer and length from a user-provided structure, handling potential errors during this process. The function then allocates space for a native video subtitle palette structure and populates it with the retrieved values. If successful, it invokes the `sys_ioctl` system call to apply the changes using the file descriptor and command provided. The function ultimately returns any error encountered or the result of the `sys_ioctl` call.","The code defines a function that manages the setting of a video subtitle palette within a compatibility framework for user-space applications. It begins by extracting a pointer to the palette and its length from a user-supplied structure, while also checking for errors during this retrieval. The function then allocates memory for a native structure to hold the palette data and populates it with the extracted values. If all operations succeed, it calls a system-level function to apply the changes using the provided file descriptor and command, ultimately returning any encountered errors or the result of the system call.","The vulnerability in the original code stemmed from the lack of error checking after retrieving the palette pointer and length using `get_user`. If these operations failed, the function would proceed to allocate user space and potentially leak uninitialized kernel stack contents into user space, posing a security risk. The fix introduced an error check immediately after the `get_user` calls, ensuring that if an error occurs, the function returns an error code without proceeding further. This change effectively prevents the use of invalid or uninitialized data, thereby mitigating the risk of leaking sensitive information.","The vulnerability in the original code arose from the absence of error checks after retrieving user-supplied data, which could allow the function to proceed with invalid or uninitialized values. This oversight risked leaking sensitive kernel stack information into user space, potentially exposing confidential data. The fix implemented an error check immediately after the data retrieval process, ensuring that if any errors occurred, the function would terminate early and return an appropriate error code. This adjustment effectively prevents the use of erroneous data, thereby safeguarding against the risk of information leakage.","The vulnerability was fixed by adding an error check immediately after the `get_user` calls for retrieving the palette pointer and length. In the updated code, if either `get_user` operation fails, the function now returns an error code, preventing further execution. This change ensures that the function does not proceed to allocate user space or attempt to use potentially invalid data. By validating the success of these critical operations before moving forward, the fix effectively mitigates the risk of leaking kernel stack contents into user space, enhancing the overall security of the function.","The vulnerability was addressed by incorporating an error check immediately after retrieving user-supplied data. This modification ensures that if any issues arise during the data retrieval process, the function will terminate early and return an appropriate error code, preventing further execution. By validating the success of these critical operations before proceeding with memory allocation and data manipulation, the fix effectively eliminates the risk of using invalid or uninitialized data. This enhancement significantly improves the security of the function by safeguarding against potential information leakage from the kernel to user space.","4, 4","5,5","4,4","4,4"
37,37,179312,179312,,Local,Not required,,CVE-2013-0349,https://www.cvedetails.com/cve/CVE-2013-0349/,CWE-200,Medium,Partial,,,2013-02-28,1.9,"The hidp_setup_hid function in net/bluetooth/hidp/core.c in the Linux kernel before 3.7.6 does not properly copy a certain name field, which allows local users to obtain sensitive information from kernel memory by setting a long name and making an HIDPCONNADD ioctl call.",2013-06-04,+Info ,1,https://github.com/torvalds/linux/commit/0a9ab9bdb3e891762553f667066190c1d22ad62b,0a9ab9bdb3e891762553f667066190c1d22ad62b,"Bluetooth: Fix incorrect strncpy() in hidp_setup_hid()

The length parameter should be sizeof(req->name) - 1 because there is no
guarantee that string provided by userspace will contain the trailing
'\0'.

Can be easily reproduced by manually setting req->name to 128 non-zero
bytes prior to ioctl(HIDPCONNADD) and checking the device name setup on
input subsystem:

$ cat /sys/devices/pnp0/00\:04/tty/ttyS0/hci0/hci0\:1/input8/name
AAAAAA[...]AAAAAAAAf0:af:f0:af:f0:af

(""f0:af:f0:af:f0:af"" is the device bluetooth address, taken from ""phys""
field in struct hid_device due to overflow.)

Cc: stable@vger.kernel.org
Signed-off-by: Anderson Lizardo <anderson.lizardo@openbossa.org>
Acked-by: Marcel Holtmann <marcel@holtmann.org>
Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>",1,net/bluetooth/hidp/core.c,"{""sha"": ""a7352ff3fd1e7884c2fc43142fba9bc0033063b8"", ""filename"": ""net/bluetooth/hidp/core.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/0a9ab9bdb3e891762553f667066190c1d22ad62b/net/bluetooth/hidp/core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0a9ab9bdb3e891762553f667066190c1d22ad62b/net/bluetooth/hidp/core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/bluetooth/hidp/core.c?ref=0a9ab9bdb3e891762553f667066190c1d22ad62b"", ""patch"": ""@@ -931,7 +931,7 @@ static int hidp_setup_hid(struct hidp_session *session,\n \thid->version = req->version;\n \thid->country = req->country;\n \n-\tstrncpy(hid->name, req->name, 128);\n+\tstrncpy(hid->name, req->name, sizeof(req->name) - 1);\n \n \tsnprintf(hid->phys, sizeof(hid->phys), \""%pMR\"",\n \t\t &bt_sk(session->ctrl_sock->sk)->src);""}","static int hidp_setup_hid(struct hidp_session *session,
				struct hidp_connadd_req *req)
{
	struct hid_device *hid;
	int err;

	session->rd_data = kzalloc(req->rd_size, GFP_KERNEL);
	if (!session->rd_data)
		return -ENOMEM;

	if (copy_from_user(session->rd_data, req->rd_data, req->rd_size)) {
		err = -EFAULT;
		goto fault;
	}
	session->rd_size = req->rd_size;

	hid = hid_allocate_device();
	if (IS_ERR(hid)) {
		err = PTR_ERR(hid);
		goto fault;
	}

	session->hid = hid;

	hid->driver_data = session;

	hid->bus     = BUS_BLUETOOTH;
	hid->vendor  = req->vendor;
	hid->product = req->product;
 	hid->version = req->version;
 	hid->country = req->country;
 
	strncpy(hid->name, req->name, sizeof(req->name) - 1);
 
 	snprintf(hid->phys, sizeof(hid->phys), ""%pMR"",
 		 &bt_sk(session->ctrl_sock->sk)->src);

	snprintf(hid->uniq, sizeof(hid->uniq), ""%pMR"",
		 &bt_sk(session->ctrl_sock->sk)->dst);

	hid->dev.parent = &session->conn->dev;
	hid->ll_driver = &hidp_hid_driver;

	hid->hid_get_raw_report = hidp_get_raw_report;
	hid->hid_output_raw_report = hidp_output_raw_report;

	/* True if device is blacklisted in drivers/hid/hid-core.c */
	if (hid_ignore(hid)) {
		hid_destroy_device(session->hid);
		session->hid = NULL;
		return -ENODEV;
	}

	return 0;

fault:
	kfree(session->rd_data);
	session->rd_data = NULL;

	return err;
}
","static int hidp_setup_hid(struct hidp_session *session,
				struct hidp_connadd_req *req)
{
	struct hid_device *hid;
	int err;

	session->rd_data = kzalloc(req->rd_size, GFP_KERNEL);
	if (!session->rd_data)
		return -ENOMEM;

	if (copy_from_user(session->rd_data, req->rd_data, req->rd_size)) {
		err = -EFAULT;
		goto fault;
	}
	session->rd_size = req->rd_size;

	hid = hid_allocate_device();
	if (IS_ERR(hid)) {
		err = PTR_ERR(hid);
		goto fault;
	}

	session->hid = hid;

	hid->driver_data = session;

	hid->bus     = BUS_BLUETOOTH;
	hid->vendor  = req->vendor;
	hid->product = req->product;
 	hid->version = req->version;
 	hid->country = req->country;
 
	strncpy(hid->name, req->name, 128);
 
 	snprintf(hid->phys, sizeof(hid->phys), ""%pMR"",
 		 &bt_sk(session->ctrl_sock->sk)->src);

	snprintf(hid->uniq, sizeof(hid->uniq), ""%pMR"",
		 &bt_sk(session->ctrl_sock->sk)->dst);

	hid->dev.parent = &session->conn->dev;
	hid->ll_driver = &hidp_hid_driver;

	hid->hid_get_raw_report = hidp_get_raw_report;
	hid->hid_output_raw_report = hidp_output_raw_report;

	/* True if device is blacklisted in drivers/hid/hid-core.c */
	if (hid_ignore(hid)) {
		hid_destroy_device(session->hid);
		session->hid = NULL;
		return -ENODEV;
	}

	return 0;

fault:
	kfree(session->rd_data);
	session->rd_data = NULL;

	return err;
}
",C,"	strncpy(hid->name, req->name, sizeof(req->name) - 1);
","	strncpy(hid->name, req->name, 128);
",,"@@ -931,7 +931,7 @@ static int hidp_setup_hid(struct hidp_session *session,
 	hid->version = req->version;
 	hid->country = req->country;
 
-	strncpy(hid->name, req->name, 128);
+	strncpy(hid->name, req->name, sizeof(req->name) - 1);
 
 	snprintf(hid->phys, sizeof(hid->phys), ""%pMR"",
 		 &bt_sk(session->ctrl_sock->sk)->src);",linux,0a9ab9bdb3e891762553f667066190c1d22ad62b,2582d529c44d12502a700f1c3db062b9f44679bc,1,"static int hidp_setup_hid(struct hidp_session *session,
				struct hidp_connadd_req *req)
{
	struct hid_device *hid;
	int err;

	session->rd_data = kzalloc(req->rd_size, GFP_KERNEL);
	if (!session->rd_data)
		return -ENOMEM;

	if (copy_from_user(session->rd_data, req->rd_data, req->rd_size)) {
		err = -EFAULT;
		goto fault;
	}
	session->rd_size = req->rd_size;

	hid = hid_allocate_device();
	if (IS_ERR(hid)) {
		err = PTR_ERR(hid);
		goto fault;
	}

	session->hid = hid;

	hid->driver_data = session;

	hid->bus     = BUS_BLUETOOTH;
	hid->vendor  = req->vendor;
	hid->product = req->product;
 	hid->version = req->version;
 	hid->country = req->country;
 
//flaw_line_below:
	strncpy(hid->name, req->name, 128);
//fix_flaw_line_below:
//	strncpy(hid->name, req->name, sizeof(req->name) - 1);
 
 	snprintf(hid->phys, sizeof(hid->phys), ""%pMR"",
 		 &bt_sk(session->ctrl_sock->sk)->src);

	snprintf(hid->uniq, sizeof(hid->uniq), ""%pMR"",
		 &bt_sk(session->ctrl_sock->sk)->dst);

	hid->dev.parent = &session->conn->dev;
	hid->ll_driver = &hidp_hid_driver;

	hid->hid_get_raw_report = hidp_get_raw_report;
	hid->hid_output_raw_report = hidp_output_raw_report;

	/* True if device is blacklisted in drivers/hid/hid-core.c */
	if (hid_ignore(hid)) {
		hid_destroy_device(session->hid);
		session->hid = NULL;
		return -ENODEV;
	}

	return 0;

fault:
	kfree(session->rd_data);
	session->rd_data = NULL;

	return err;
}
",179312,"static int hidp_setup_hid(struct hidp_session *session,
				struct hidp_connadd_req *req)
{
	struct hid_device *hid;
	int err;

	session->rd_data = kzalloc(req->rd_size, GFP_KERNEL);
	if (!session->rd_data)
		return -ENOMEM;

	if (copy_from_user(session->rd_data, req->rd_data, req->rd_size)) {
		err = -EFAULT;
		goto fault;
	}
	session->rd_size = req->rd_size;

	hid = hid_allocate_device();
	if (IS_ERR(hid)) {
		err = PTR_ERR(hid);
		goto fault;
	}

	session->hid = hid;

	hid->driver_data = session;

	hid->bus     = BUS_BLUETOOTH;
	hid->vendor  = req->vendor;
	hid->product = req->product;
 	hid->version = req->version;
 	hid->country = req->country;
 
	strncpy(hid->name, req->name, 128);
 
 	snprintf(hid->phys, sizeof(hid->phys), ""%pMR"",
 		 &bt_sk(session->ctrl_sock->sk)->src);

	snprintf(hid->uniq, sizeof(hid->uniq), ""%pMR"",
		 &bt_sk(session->ctrl_sock->sk)->dst);

	hid->dev.parent = &session->conn->dev;
	hid->ll_driver = &hidp_hid_driver;

	hid->hid_get_raw_report = hidp_get_raw_report;
	hid->hid_output_raw_report = hidp_output_raw_report;

	/* True if device is blacklisted in drivers/hid/hid-core.c */
	if (hid_ignore(hid)) {
		hid_destroy_device(session->hid);
		session->hid = NULL;
		return -ENODEV;
	}

	return 0;

fault:
	kfree(session->rd_data);
	session->rd_data = NULL;

	return err;
}
","static int hidp_setup_hid(struct hidp_session *session,
				struct hidp_connadd_req *req)
{
	struct hid_device *hid;
	int err;

	session->rd_data = kzalloc(req->rd_size, GFP_KERNEL);
	if (!session->rd_data)
		return -ENOMEM;

	if (copy_from_user(session->rd_data, req->rd_data, req->rd_size)) {
		err = -EFAULT;
		goto fault;
	}
	session->rd_size = req->rd_size;

	hid = hid_allocate_device();
	if (IS_ERR(hid)) {
		err = PTR_ERR(hid);
		goto fault;
	}

	session->hid = hid;

	hid->driver_data = session;

	hid->bus     = BUS_BLUETOOTH;
	hid->vendor  = req->vendor;
	hid->product = req->product;
 	hid->version = req->version;
 	hid->country = req->country;
 
	strncpy(hid->name, req->name, sizeof(req->name) - 1);
 
 	snprintf(hid->phys, sizeof(hid->phys), ""%pMR"",
 		 &bt_sk(session->ctrl_sock->sk)->src);

	snprintf(hid->uniq, sizeof(hid->uniq), ""%pMR"",
		 &bt_sk(session->ctrl_sock->sk)->dst);

	hid->dev.parent = &session->conn->dev;
	hid->ll_driver = &hidp_hid_driver;

	hid->hid_get_raw_report = hidp_get_raw_report;
	hid->hid_output_raw_report = hidp_output_raw_report;

	/* True if device is blacklisted in drivers/hid/hid-core.c */
	if (hid_ignore(hid)) {
		hid_destroy_device(session->hid);
		session->hid = NULL;
		return -ENODEV;
	}

	return 0;

fault:
	kfree(session->rd_data);
	session->rd_data = NULL;

	return err;
}
","The `hidp_setup_hid` function initializes a Human Interface Device (HID) session by allocating memory for report data and copying it from user space. It creates a new HID device, populating its attributes such as vendor, product, and version from the provided request. The function also sets up the device's physical and unique identifiers based on Bluetooth socket information. If the device is blacklisted, it cleans up by destroying the HID device and returning an error. The function ultimately returns 0 on success or an error code if any step fails, ensuring proper resource management throughout.","The code initializes a Human Interface Device session by allocating memory for report data and transferring it from user space. It creates a new HID device and populates its attributes, such as vendor and product information, while also setting identifiers based on Bluetooth socket details. The function checks if the device is blacklisted, and if so, it cleans up by destroying the HID device and returning an error. Overall, it ensures proper resource management and returns a success indicator or an error code based on the outcome of each operation.","The vulnerability in the original code stemmed from using `strncpy` without properly accounting for the potential lack of a null terminator in the user-provided string, which could lead to buffer overflows. Specifically, the length parameter for `strncpy` was incorrectly set, allowing for the possibility of writing beyond the allocated space for the device name. This was fixed by changing the length parameter to `sizeof(req->name) - 1`, ensuring that the string is correctly truncated to fit within the buffer and always includes a null terminator, thus preventing overflow and ensuring safe memory handling.","The vulnerability in the original code arose from an improper use of a string copy function, which did not ensure that the copied string would be null-terminated. This oversight allowed for the possibility of writing beyond the allocated buffer if the user-provided string was not properly formatted, leading to potential buffer overflows. The fix involved adjusting the length parameter of the string copy function to account for this, ensuring that the buffer would always be correctly sized and null-terminated. This change effectively mitigated the risk of overflow and improved the overall safety of memory handling in the code.","The vulnerability was fixed by modifying the length parameter in the `strncpy` function call to `sizeof(req->name) - 1`. This adjustment ensures that the copied string fits within the allocated buffer while leaving space for a null terminator, thus preventing potential buffer overflows. By ensuring that the string from user space is truncated appropriately, the risk of writing beyond the allocated memory is mitigated. This change enhances the safety of the code by guaranteeing that the device name is always properly null-terminated, thereby preventing unintended memory corruption and ensuring stable operation.","The vulnerability was addressed by adjusting the length parameter used in the string copying operation to ensure that the copied data would fit within the allocated buffer while allowing space for a null terminator. This change prevents the risk of writing beyond the buffer's boundaries, which could lead to memory corruption and potential security issues. By ensuring that the copied string is always properly truncated and null-terminated, the fix enhances the overall safety and stability of the code, effectively mitigating the risk of buffer overflow vulnerabilities associated with user-provided input.","5, 4","5,5","5,4","5,5"
38,38,179349,179349,,Local,Not required,,CVE-2012-6549,https://www.cvedetails.com/cve/CVE-2012-6549/,CWE-200,Medium,Partial,,,2013-03-15,1.9,"The isofs_export_encode_fh function in fs/isofs/export.c in the Linux kernel before 3.6 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel heap memory via a crafted application.",2013-08-22,+Info ,1,https://github.com/torvalds/linux/commit/fe685aabf7c8c9f138e5ea900954d295bf229175,fe685aabf7c8c9f138e5ea900954d295bf229175,"isofs: avoid info leak on export

For type 1 the parent_offset member in struct isofs_fid gets copied
uninitialized to userland. Fix this by initializing it to 0.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Signed-off-by: Jan Kara <jack@suse.cz>",0,fs/isofs/export.c,"{""sha"": ""1d3804492aa77d7ca4440d087fd415febc2e3681"", ""filename"": ""fs/isofs/export.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/fe685aabf7c8c9f138e5ea900954d295bf229175/fs/isofs/export.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fe685aabf7c8c9f138e5ea900954d295bf229175/fs/isofs/export.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/isofs/export.c?ref=fe685aabf7c8c9f138e5ea900954d295bf229175"", ""patch"": ""@@ -134,6 +134,7 @@ isofs_export_encode_fh(struct inode *inode,\n \tlen = 3;\n \tfh32[0] = ei->i_iget5_block;\n  \tfh16[2] = (__u16)ei->i_iget5_offset;  /* fh16 [sic] */\n+\tfh16[3] = 0;  /* avoid leaking uninitialized data */\n \tfh32[2] = inode->i_generation;\n \tif (parent) {\n \t\tstruct iso_inode_info *eparent;""}","isofs_export_encode_fh(struct inode *inode,
		       __u32 *fh32,
		       int *max_len,
		       struct inode *parent)
{
	struct iso_inode_info * ei = ISOFS_I(inode);
	int len = *max_len;
	int type = 1;
	__u16 *fh16 = (__u16*)fh32;

	/*
	 * WARNING: max_len is 5 for NFSv2.  Because of this
	 * limitation, we use the lower 16 bits of fh32[1] to hold the
	 * offset of the inode and the upper 16 bits of fh32[1] to
	 * hold the offset of the parent.
	 */
	if (parent && (len < 5)) {
		*max_len = 5;
		return 255;
	} else if (len < 3) {
		*max_len = 3;
		return 255;
	}

 	len = 3;
 	fh32[0] = ei->i_iget5_block;
  	fh16[2] = (__u16)ei->i_iget5_offset;  /* fh16 [sic] */
	fh16[3] = 0;  /* avoid leaking uninitialized data */
 	fh32[2] = inode->i_generation;
 	if (parent) {
 		struct iso_inode_info *eparent;
		eparent = ISOFS_I(parent);
		fh32[3] = eparent->i_iget5_block;
		fh16[3] = (__u16)eparent->i_iget5_offset;  /* fh16 [sic] */
		fh32[4] = parent->i_generation;
		len = 5;
		type = 2;
	}
	*max_len = len;
	return type;
}
","isofs_export_encode_fh(struct inode *inode,
		       __u32 *fh32,
		       int *max_len,
		       struct inode *parent)
{
	struct iso_inode_info * ei = ISOFS_I(inode);
	int len = *max_len;
	int type = 1;
	__u16 *fh16 = (__u16*)fh32;

	/*
	 * WARNING: max_len is 5 for NFSv2.  Because of this
	 * limitation, we use the lower 16 bits of fh32[1] to hold the
	 * offset of the inode and the upper 16 bits of fh32[1] to
	 * hold the offset of the parent.
	 */
	if (parent && (len < 5)) {
		*max_len = 5;
		return 255;
	} else if (len < 3) {
		*max_len = 3;
		return 255;
	}

 	len = 3;
 	fh32[0] = ei->i_iget5_block;
  	fh16[2] = (__u16)ei->i_iget5_offset;  /* fh16 [sic] */
 	fh32[2] = inode->i_generation;
 	if (parent) {
 		struct iso_inode_info *eparent;
		eparent = ISOFS_I(parent);
		fh32[3] = eparent->i_iget5_block;
		fh16[3] = (__u16)eparent->i_iget5_offset;  /* fh16 [sic] */
		fh32[4] = parent->i_generation;
		len = 5;
		type = 2;
	}
	*max_len = len;
	return type;
}
",C,"	fh16[3] = 0;  /* avoid leaking uninitialized data */
",,,"@@ -134,6 +134,7 @@ isofs_export_encode_fh(struct inode *inode,
 	len = 3;
 	fh32[0] = ei->i_iget5_block;
  	fh16[2] = (__u16)ei->i_iget5_offset;  /* fh16 [sic] */
+	fh16[3] = 0;  /* avoid leaking uninitialized data */
 	fh32[2] = inode->i_generation;
 	if (parent) {
 		struct iso_inode_info *eparent;",linux,fe685aabf7c8c9f138e5ea900954d295bf229175,57b9655d01ef057a523e810d29c37ac09b80eead,1,"isofs_export_encode_fh(struct inode *inode,
		       __u32 *fh32,
		       int *max_len,
		       struct inode *parent)
{
	struct iso_inode_info * ei = ISOFS_I(inode);
	int len = *max_len;
	int type = 1;
	__u16 *fh16 = (__u16*)fh32;

	/*
	 * WARNING: max_len is 5 for NFSv2.  Because of this
	 * limitation, we use the lower 16 bits of fh32[1] to hold the
	 * offset of the inode and the upper 16 bits of fh32[1] to
	 * hold the offset of the parent.
	 */
	if (parent && (len < 5)) {
		*max_len = 5;
		return 255;
	} else if (len < 3) {
		*max_len = 3;
		return 255;
	}

 	len = 3;
 	fh32[0] = ei->i_iget5_block;
  	fh16[2] = (__u16)ei->i_iget5_offset;  /* fh16 [sic] */
//fix_flaw_line_below:
//	fh16[3] = 0;  /* avoid leaking uninitialized data */
 	fh32[2] = inode->i_generation;
 	if (parent) {
 		struct iso_inode_info *eparent;
		eparent = ISOFS_I(parent);
		fh32[3] = eparent->i_iget5_block;
		fh16[3] = (__u16)eparent->i_iget5_offset;  /* fh16 [sic] */
		fh32[4] = parent->i_generation;
		len = 5;
		type = 2;
	}
	*max_len = len;
	return type;
}
",179349,"isofs_export_encode_fh(struct inode *inode,
		       __u32 *fh32,
		       int *max_len,
		       struct inode *parent)
{
	struct iso_inode_info * ei = ISOFS_I(inode);
	int len = *max_len;
	int type = 1;
	__u16 *fh16 = (__u16*)fh32;

	/*
	 * WARNING: max_len is 5 for NFSv2.  Because of this
	 * limitation, we use the lower 16 bits of fh32[1] to hold the
	 * offset of the inode and the upper 16 bits of fh32[1] to
	 * hold the offset of the parent.
	 */
	if (parent && (len < 5)) {
		*max_len = 5;
		return 255;
	} else if (len < 3) {
		*max_len = 3;
		return 255;
	}

 	len = 3;
 	fh32[0] = ei->i_iget5_block;
  	fh16[2] = (__u16)ei->i_iget5_offset;  /* fh16 [sic] */
 	fh32[2] = inode->i_generation;
 	if (parent) {
 		struct iso_inode_info *eparent;
		eparent = ISOFS_I(parent);
		fh32[3] = eparent->i_iget5_block;
		fh16[3] = (__u16)eparent->i_iget5_offset;  /* fh16 [sic] */
		fh32[4] = parent->i_generation;
		len = 5;
		type = 2;
	}
	*max_len = len;
	return type;
}
","isofs_export_encode_fh(struct inode *inode,
		       __u32 *fh32,
		       int *max_len,
		       struct inode *parent)
{
	struct iso_inode_info * ei = ISOFS_I(inode);
	int len = *max_len;
	int type = 1;
	__u16 *fh16 = (__u16*)fh32;

	/*
	 * WARNING: max_len is 5 for NFSv2.  Because of this
	 * limitation, we use the lower 16 bits of fh32[1] to hold the
	 * offset of the inode and the upper 16 bits of fh32[1] to
	 * hold the offset of the parent.
	 */
	if (parent && (len < 5)) {
		*max_len = 5;
		return 255;
	} else if (len < 3) {
		*max_len = 3;
		return 255;
	}

 	len = 3;
 	fh32[0] = ei->i_iget5_block;
  	fh16[2] = (__u16)ei->i_iget5_offset;  /* fh16 [sic] */
	fh16[3] = 0;  /* avoid leaking uninitialized data */
 	fh32[2] = inode->i_generation;
 	if (parent) {
 		struct iso_inode_info *eparent;
		eparent = ISOFS_I(parent);
		fh32[3] = eparent->i_iget5_block;
		fh16[3] = (__u16)eparent->i_iget5_offset;  /* fh16 [sic] */
		fh32[4] = parent->i_generation;
		len = 5;
		type = 2;
	}
	*max_len = len;
	return type;
}
","The function `isofs_export_encode_fh` encodes a file handle for an inode in an ISO filesystem, facilitating its export for network file systems like NFS. It takes an inode, a pointer to a 32-bit file handle array, a pointer to an integer representing the maximum length of the file handle, and an optional parent inode. The function checks the length constraints and populates the file handle with specific inode information, including block and offset values, as well as generation numbers. It adjusts the maximum length accordingly and returns a type indicator, distinguishing between file handles with and without a parent inode.","The provided code encodes a file handle for an inode within an ISO filesystem, enabling its use in network file systems. It checks the maximum length constraints for the file handle and populates it with essential information from the inode, including block and offset values, as well as generation numbers. If a parent inode is specified, the function retrieves and includes its corresponding information in the file handle. The maximum length is updated based on the presence of the parent inode, and the function returns a type indicator to differentiate between file handles with and without a parent.","The vulnerability in the original code stemmed from the potential leakage of uninitialized data when exporting file handles, specifically the `parent_offset` member in the structure used for file identification. If the parent inode was not present, the code did not initialize the corresponding entry in the file handle, leading to the risk of exposing sensitive information to userland. The fix involved explicitly initializing the `fh16[3]` entry to zero, ensuring that no uninitialized data would be copied to userland, thereby preventing information leakage and enhancing the security of the file handle export process.","The vulnerability in the original code was due to the potential exposure of uninitialized data when exporting file handles, which could inadvertently leak sensitive information to userland. Specifically, when the parent inode was absent, the code failed to initialize a critical member of the file identification structure, leading to the risk of returning garbage values. The fix addressed this issue by ensuring that the relevant member was explicitly set to zero before being copied, thereby preventing any uninitialized data from being exposed and enhancing the overall security of the file handle export process.","The vulnerability was fixed by initializing the `fh16[3]` entry to zero in the modified code. This change ensures that when the parent inode is not present, the corresponding offset in the file handle is explicitly set to a known value, preventing any uninitialized data from being copied to userland. By doing this, the code mitigates the risk of leaking sensitive information through the `parent_offset` member in the file identification structure. This simple initialization step enhances the security of the file handle export process, ensuring that only valid and expected data is exposed.","The vulnerability was fixed by explicitly initializing a specific entry in the file handle to zero before it could be copied to userland. This change ensures that when the parent inode is absent, the corresponding data is set to a known value, thereby preventing any uninitialized data from being exposed. By addressing this issue, the code mitigates the risk of leaking sensitive information, ensuring that only valid and expected data is transmitted. This simple yet effective initialization step significantly enhances the security of the file handle export process, protecting against potential information leaks.","5, 5","4, 4","4,4","4,5"
39,39,179350,179350,,Local,Not required,,CVE-2012-6548,https://www.cvedetails.com/cve/CVE-2012-6548/,CWE-200,Medium,Partial,,,2013-03-15,1.9,"The udf_encode_fh function in fs/udf/namei.c in the Linux kernel before 3.6 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel heap memory via a crafted application.",2019-04-22,+Info ,1,https://github.com/torvalds/linux/commit/0143fc5e9f6f5aad4764801015bc8d4b4a278200,0143fc5e9f6f5aad4764801015bc8d4b4a278200,"udf: avoid info leak on export

For type 0x51 the udf.parent_partref member in struct fid gets copied
uninitialized to userland. Fix this by initializing it to 0.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Signed-off-by: Jan Kara <jack@suse.cz>",0,fs/udf/namei.c,"{""sha"": ""c31deb382afd006f26072d6744976b4258bcc202"", ""filename"": ""fs/udf/namei.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/0143fc5e9f6f5aad4764801015bc8d4b4a278200/fs/udf/namei.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0143fc5e9f6f5aad4764801015bc8d4b4a278200/fs/udf/namei.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/udf/namei.c?ref=0143fc5e9f6f5aad4764801015bc8d4b4a278200"", ""patch"": ""@@ -1279,6 +1279,7 @@ static int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,\n \t*lenp = 3;\n \tfid->udf.block = location.logicalBlockNum;\n \tfid->udf.partref = location.partitionReferenceNum;\n+\tfid->udf.parent_partref = 0;\n \tfid->udf.generation = inode->i_generation;\n \n \tif (parent) {""}","static int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,
			 struct inode *parent)
{
	int len = *lenp;
	struct kernel_lb_addr location = UDF_I(inode)->i_location;
	struct fid *fid = (struct fid *)fh;
	int type = FILEID_UDF_WITHOUT_PARENT;

	if (parent && (len < 5)) {
		*lenp = 5;
		return 255;
	} else if (len < 3) {
		*lenp = 3;
		return 255;
	}

 	*lenp = 3;
 	fid->udf.block = location.logicalBlockNum;
 	fid->udf.partref = location.partitionReferenceNum;
	fid->udf.parent_partref = 0;
 	fid->udf.generation = inode->i_generation;
 
 	if (parent) {
		location = UDF_I(parent)->i_location;
		fid->udf.parent_block = location.logicalBlockNum;
		fid->udf.parent_partref = location.partitionReferenceNum;
		fid->udf.parent_generation = inode->i_generation;
		*lenp = 5;
		type = FILEID_UDF_WITH_PARENT;
	}

	return type;
}
","static int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,
			 struct inode *parent)
{
	int len = *lenp;
	struct kernel_lb_addr location = UDF_I(inode)->i_location;
	struct fid *fid = (struct fid *)fh;
	int type = FILEID_UDF_WITHOUT_PARENT;

	if (parent && (len < 5)) {
		*lenp = 5;
		return 255;
	} else if (len < 3) {
		*lenp = 3;
		return 255;
	}

 	*lenp = 3;
 	fid->udf.block = location.logicalBlockNum;
 	fid->udf.partref = location.partitionReferenceNum;
 	fid->udf.generation = inode->i_generation;
 
 	if (parent) {
		location = UDF_I(parent)->i_location;
		fid->udf.parent_block = location.logicalBlockNum;
		fid->udf.parent_partref = location.partitionReferenceNum;
		fid->udf.parent_generation = inode->i_generation;
		*lenp = 5;
		type = FILEID_UDF_WITH_PARENT;
	}

	return type;
}
",C,"	fid->udf.parent_partref = 0;
",,,"@@ -1279,6 +1279,7 @@ static int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,
 	*lenp = 3;
 	fid->udf.block = location.logicalBlockNum;
 	fid->udf.partref = location.partitionReferenceNum;
+	fid->udf.parent_partref = 0;
 	fid->udf.generation = inode->i_generation;
 
 	if (parent) {",linux,0143fc5e9f6f5aad4764801015bc8d4b4a278200,fe685aabf7c8c9f138e5ea900954d295bf229175,1,"static int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,
			 struct inode *parent)
{
	int len = *lenp;
	struct kernel_lb_addr location = UDF_I(inode)->i_location;
	struct fid *fid = (struct fid *)fh;
	int type = FILEID_UDF_WITHOUT_PARENT;

	if (parent && (len < 5)) {
		*lenp = 5;
		return 255;
	} else if (len < 3) {
		*lenp = 3;
		return 255;
	}

 	*lenp = 3;
 	fid->udf.block = location.logicalBlockNum;
 	fid->udf.partref = location.partitionReferenceNum;
//fix_flaw_line_below:
//	fid->udf.parent_partref = 0;
 	fid->udf.generation = inode->i_generation;
 
 	if (parent) {
		location = UDF_I(parent)->i_location;
		fid->udf.parent_block = location.logicalBlockNum;
		fid->udf.parent_partref = location.partitionReferenceNum;
		fid->udf.parent_generation = inode->i_generation;
		*lenp = 5;
		type = FILEID_UDF_WITH_PARENT;
	}

	return type;
}
",179350,"static int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,
			 struct inode *parent)
{
	int len = *lenp;
	struct kernel_lb_addr location = UDF_I(inode)->i_location;
	struct fid *fid = (struct fid *)fh;
	int type = FILEID_UDF_WITHOUT_PARENT;

	if (parent && (len < 5)) {
		*lenp = 5;
		return 255;
	} else if (len < 3) {
		*lenp = 3;
		return 255;
	}

 	*lenp = 3;
 	fid->udf.block = location.logicalBlockNum;
 	fid->udf.partref = location.partitionReferenceNum;
 	fid->udf.generation = inode->i_generation;
 
 	if (parent) {
		location = UDF_I(parent)->i_location;
		fid->udf.parent_block = location.logicalBlockNum;
		fid->udf.parent_partref = location.partitionReferenceNum;
		fid->udf.parent_generation = inode->i_generation;
		*lenp = 5;
		type = FILEID_UDF_WITH_PARENT;
	}

	return type;
}
","static int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,
			 struct inode *parent)
{
	int len = *lenp;
	struct kernel_lb_addr location = UDF_I(inode)->i_location;
	struct fid *fid = (struct fid *)fh;
	int type = FILEID_UDF_WITHOUT_PARENT;

	if (parent && (len < 5)) {
		*lenp = 5;
		return 255;
	} else if (len < 3) {
		*lenp = 3;
		return 255;
	}

 	*lenp = 3;
 	fid->udf.block = location.logicalBlockNum;
 	fid->udf.partref = location.partitionReferenceNum;
	fid->udf.parent_partref = 0;
 	fid->udf.generation = inode->i_generation;
 
 	if (parent) {
		location = UDF_I(parent)->i_location;
		fid->udf.parent_block = location.logicalBlockNum;
		fid->udf.parent_partref = location.partitionReferenceNum;
		fid->udf.parent_generation = inode->i_generation;
		*lenp = 5;
		type = FILEID_UDF_WITH_PARENT;
	}

	return type;
}
","The `udf_encode_fh` function encodes a file handle for a given inode in a UDF (Universal Disk Format) filesystem. It takes an inode pointer, a pointer to a buffer for the file handle, a pointer to an integer representing the buffer length, and an optional parent inode pointer. The function checks the provided length and adjusts it as necessary, ensuring it meets minimum requirements. It populates the file handle with the logical block number, partition reference number, and generation of the inode. If a parent inode is provided, it also includes the parent's details, returning a type indicator based on whether the parent is included.","The code defines a function that encodes a file handle for a specific file system structure, ensuring it meets certain length requirements based on whether a parent structure is provided. It checks the length of the buffer and adjusts it if necessary, setting a minimum size. The function retrieves and stores essential information about the file's location and its generation. If a parent structure is present, it also captures the parent's details, updating the buffer accordingly. Finally, the function returns a type indicator that specifies whether the encoded handle includes information about the parent structure.","The vulnerability in the original code stemmed from the potential leakage of uninitialized data to userland, specifically through the `fid->udf.parent_partref` member when the type was 0x51. If the parent inode was not provided, this member could contain garbage values, leading to unintended information exposure. The fix involved explicitly initializing `fid->udf.parent_partref` to 0, ensuring that it does not carry any uninitialized data when the parent inode is absent. This change effectively mitigates the risk of leaking sensitive information by guaranteeing that the member is always set to a known value before being used.","The vulnerability in the original code was due to the potential exposure of uninitialized data to userland, which could occur when certain conditions were met. Specifically, if a specific type was processed without a parent structure, an uninitialized member could inadvertently be sent, leading to information leakage. The fix addressed this issue by ensuring that the problematic member was explicitly initialized to zero before being used. This change guarantees that no sensitive or unintended data is leaked, thereby enhancing the security of the code by providing a known and safe value in all scenarios.","The vulnerability was fixed by explicitly initializing the `fid->udf.parent_partref` member to zero in the code. This change ensures that when the parent inode is not provided, this member does not carry any uninitialized data that could leak to userland. By setting `fid->udf.parent_partref` to zero, the code guarantees that it will always contain a known value, thus preventing the exposure of potentially sensitive information. This initialization occurs before any conditions are checked, ensuring that the member is safely set regardless of the execution path taken in the function.","The vulnerability was fixed by ensuring that a specific member, which could potentially carry uninitialized data, is explicitly set to zero before being used. This initialization prevents any garbage values from being inadvertently exposed to userland, thereby mitigating the risk of information leakage. By establishing a known value for this member, the code guarantees that it will not contain sensitive or unintended data when certain conditions are met. This proactive approach enhances the overall security of the function by ensuring that all data sent to userland is properly initialized and safe.","5,4","5,5","4,5","4, 5"
40,40,179351,179351,,Local,Not required,,CVE-2012-6547,https://www.cvedetails.com/cve/CVE-2012-6547/,CWE-200,Medium,Partial,,,2013-03-15,1.9,"The __tun_chr_ioctl function in drivers/net/tun.c in the Linux kernel before 3.6 does not initialize a certain structure, which allows local users to obtain sensitive information from kernel stack memory via a crafted application.",2013-08-22,+Info ,3,https://github.com/torvalds/linux/commit/a117dacde0288f3ec60b6e5bcedae8fa37ee0dfc,a117dacde0288f3ec60b6e5bcedae8fa37ee0dfc,"net/tun: fix ioctl() based info leaks

The tun module leaks up to 36 bytes of memory by not fully initializing
a structure located on the stack that gets copied to user memory by the
TUNGETIFF and SIOCGIFHWADDR ioctl()s.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,drivers/net/tun.c,"{""sha"": ""f55c46222613f01f44b14f3455c38d832b2fc6fe"", ""filename"": ""drivers/net/tun.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/a117dacde0288f3ec60b6e5bcedae8fa37ee0dfc/drivers/net/tun.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a117dacde0288f3ec60b6e5bcedae8fa37ee0dfc/drivers/net/tun.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/tun.c?ref=a117dacde0288f3ec60b6e5bcedae8fa37ee0dfc"", ""patch"": ""@@ -1379,9 +1379,11 @@ static long __tun_chr_ioctl(struct file *file, unsigned int cmd,\n \tint vnet_hdr_sz;\n \tint ret;\n \n-\tif (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89)\n+\tif (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89) {\n \t\tif (copy_from_user(&ifr, argp, ifreq_len))\n \t\t\treturn -EFAULT;\n+\t} else\n+\t\tmemset(&ifr, 0, sizeof(ifr));\n \n \tif (cmd == TUNGETFEATURES) {\n \t\t/* Currently this just means: \""what IFF flags are valid?\"".""}","static long __tun_chr_ioctl(struct file *file, unsigned int cmd,
			    unsigned long arg, int ifreq_len)
{
	struct tun_file *tfile = file->private_data;
	struct tun_struct *tun;
	void __user* argp = (void __user*)arg;
	struct sock_fprog fprog;
	struct ifreq ifr;
	int sndbuf;
 	int vnet_hdr_sz;
 	int ret;
 
	if (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89) {
 		if (copy_from_user(&ifr, argp, ifreq_len))
 			return -EFAULT;
	} else
		memset(&ifr, 0, sizeof(ifr));
 
 	if (cmd == TUNGETFEATURES) {
 		/* Currently this just means: ""what IFF flags are valid?"".
		 * This is needed because we never checked for invalid flags on
		 * TUNSETIFF. */
		return put_user(IFF_TUN | IFF_TAP | IFF_NO_PI | IFF_ONE_QUEUE |
				IFF_VNET_HDR,
				(unsigned int __user*)argp);
	}

	rtnl_lock();

	tun = __tun_get(tfile);
	if (cmd == TUNSETIFF && !tun) {
		ifr.ifr_name[IFNAMSIZ-1] = '\0';

		ret = tun_set_iff(tfile->net, file, &ifr);

		if (ret)
			goto unlock;

		if (copy_to_user(argp, &ifr, ifreq_len))
			ret = -EFAULT;
		goto unlock;
	}

	ret = -EBADFD;
	if (!tun)
		goto unlock;

	tun_debug(KERN_INFO, tun, ""tun_chr_ioctl cmd %d\n"", cmd);

	ret = 0;
	switch (cmd) {
	case TUNGETIFF:
		ret = tun_get_iff(current->nsproxy->net_ns, tun, &ifr);
		if (ret)
			break;

		if (copy_to_user(argp, &ifr, ifreq_len))
			ret = -EFAULT;
		break;

	case TUNSETNOCSUM:
		/* Disable/Enable checksum */

		/* [unimplemented] */
		tun_debug(KERN_INFO, tun, ""ignored: set checksum %s\n"",
			  arg ? ""disabled"" : ""enabled"");
		break;

	case TUNSETPERSIST:
		/* Disable/Enable persist mode */
		if (arg)
			tun->flags |= TUN_PERSIST;
		else
			tun->flags &= ~TUN_PERSIST;

		tun_debug(KERN_INFO, tun, ""persist %s\n"",
			  arg ? ""enabled"" : ""disabled"");
		break;

	case TUNSETOWNER:
		/* Set owner of the device */
		tun->owner = (uid_t) arg;

		tun_debug(KERN_INFO, tun, ""owner set to %d\n"", tun->owner);
		break;

	case TUNSETGROUP:
		/* Set group of the device */
		tun->group= (gid_t) arg;

		tun_debug(KERN_INFO, tun, ""group set to %d\n"", tun->group);
		break;

	case TUNSETLINK:
		/* Only allow setting the type when the interface is down */
		if (tun->dev->flags & IFF_UP) {
			tun_debug(KERN_INFO, tun,
				  ""Linktype set failed because interface is up\n"");
			ret = -EBUSY;
		} else {
			tun->dev->type = (int) arg;
			tun_debug(KERN_INFO, tun, ""linktype set to %d\n"",
				  tun->dev->type);
			ret = 0;
		}
		break;

#ifdef TUN_DEBUG
	case TUNSETDEBUG:
		tun->debug = arg;
		break;
#endif
	case TUNSETOFFLOAD:
		ret = set_offload(tun, arg);
		break;

	case TUNSETTXFILTER:
		/* Can be set only for TAPs */
		ret = -EINVAL;
		if ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)
			break;
		ret = update_filter(&tun->txflt, (void __user *)arg);
		break;

	case SIOCGIFHWADDR:
		/* Get hw address */
		memcpy(ifr.ifr_hwaddr.sa_data, tun->dev->dev_addr, ETH_ALEN);
		ifr.ifr_hwaddr.sa_family = tun->dev->type;
		if (copy_to_user(argp, &ifr, ifreq_len))
			ret = -EFAULT;
		break;

	case SIOCSIFHWADDR:
		/* Set hw address */
		tun_debug(KERN_DEBUG, tun, ""set hw address: %pM\n"",
			  ifr.ifr_hwaddr.sa_data);

		ret = dev_set_mac_address(tun->dev, &ifr.ifr_hwaddr);
		break;

	case TUNGETSNDBUF:
		sndbuf = tun->socket.sk->sk_sndbuf;
		if (copy_to_user(argp, &sndbuf, sizeof(sndbuf)))
			ret = -EFAULT;
		break;

	case TUNSETSNDBUF:
		if (copy_from_user(&sndbuf, argp, sizeof(sndbuf))) {
			ret = -EFAULT;
			break;
		}

		tun->socket.sk->sk_sndbuf = sndbuf;
		break;

	case TUNGETVNETHDRSZ:
		vnet_hdr_sz = tun->vnet_hdr_sz;
		if (copy_to_user(argp, &vnet_hdr_sz, sizeof(vnet_hdr_sz)))
			ret = -EFAULT;
		break;

	case TUNSETVNETHDRSZ:
		if (copy_from_user(&vnet_hdr_sz, argp, sizeof(vnet_hdr_sz))) {
			ret = -EFAULT;
			break;
		}
		if (vnet_hdr_sz < (int)sizeof(struct virtio_net_hdr)) {
			ret = -EINVAL;
			break;
		}

		tun->vnet_hdr_sz = vnet_hdr_sz;
		break;

	case TUNATTACHFILTER:
		/* Can be set only for TAPs */
		ret = -EINVAL;
		if ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)
			break;
		ret = -EFAULT;
		if (copy_from_user(&fprog, argp, sizeof(fprog)))
			break;

		ret = sk_attach_filter(&fprog, tun->socket.sk);
		break;

	case TUNDETACHFILTER:
		/* Can be set only for TAPs */
		ret = -EINVAL;
		if ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)
			break;
		ret = sk_detach_filter(tun->socket.sk);
		break;

	default:
		ret = -EINVAL;
		break;
	}

unlock:
	rtnl_unlock();
	if (tun)
		tun_put(tun);
	return ret;
}
","static long __tun_chr_ioctl(struct file *file, unsigned int cmd,
			    unsigned long arg, int ifreq_len)
{
	struct tun_file *tfile = file->private_data;
	struct tun_struct *tun;
	void __user* argp = (void __user*)arg;
	struct sock_fprog fprog;
	struct ifreq ifr;
	int sndbuf;
 	int vnet_hdr_sz;
 	int ret;
 
	if (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89)
 		if (copy_from_user(&ifr, argp, ifreq_len))
 			return -EFAULT;
 
 	if (cmd == TUNGETFEATURES) {
 		/* Currently this just means: ""what IFF flags are valid?"".
		 * This is needed because we never checked for invalid flags on
		 * TUNSETIFF. */
		return put_user(IFF_TUN | IFF_TAP | IFF_NO_PI | IFF_ONE_QUEUE |
				IFF_VNET_HDR,
				(unsigned int __user*)argp);
	}

	rtnl_lock();

	tun = __tun_get(tfile);
	if (cmd == TUNSETIFF && !tun) {
		ifr.ifr_name[IFNAMSIZ-1] = '\0';

		ret = tun_set_iff(tfile->net, file, &ifr);

		if (ret)
			goto unlock;

		if (copy_to_user(argp, &ifr, ifreq_len))
			ret = -EFAULT;
		goto unlock;
	}

	ret = -EBADFD;
	if (!tun)
		goto unlock;

	tun_debug(KERN_INFO, tun, ""tun_chr_ioctl cmd %d\n"", cmd);

	ret = 0;
	switch (cmd) {
	case TUNGETIFF:
		ret = tun_get_iff(current->nsproxy->net_ns, tun, &ifr);
		if (ret)
			break;

		if (copy_to_user(argp, &ifr, ifreq_len))
			ret = -EFAULT;
		break;

	case TUNSETNOCSUM:
		/* Disable/Enable checksum */

		/* [unimplemented] */
		tun_debug(KERN_INFO, tun, ""ignored: set checksum %s\n"",
			  arg ? ""disabled"" : ""enabled"");
		break;

	case TUNSETPERSIST:
		/* Disable/Enable persist mode */
		if (arg)
			tun->flags |= TUN_PERSIST;
		else
			tun->flags &= ~TUN_PERSIST;

		tun_debug(KERN_INFO, tun, ""persist %s\n"",
			  arg ? ""enabled"" : ""disabled"");
		break;

	case TUNSETOWNER:
		/* Set owner of the device */
		tun->owner = (uid_t) arg;

		tun_debug(KERN_INFO, tun, ""owner set to %d\n"", tun->owner);
		break;

	case TUNSETGROUP:
		/* Set group of the device */
		tun->group= (gid_t) arg;

		tun_debug(KERN_INFO, tun, ""group set to %d\n"", tun->group);
		break;

	case TUNSETLINK:
		/* Only allow setting the type when the interface is down */
		if (tun->dev->flags & IFF_UP) {
			tun_debug(KERN_INFO, tun,
				  ""Linktype set failed because interface is up\n"");
			ret = -EBUSY;
		} else {
			tun->dev->type = (int) arg;
			tun_debug(KERN_INFO, tun, ""linktype set to %d\n"",
				  tun->dev->type);
			ret = 0;
		}
		break;

#ifdef TUN_DEBUG
	case TUNSETDEBUG:
		tun->debug = arg;
		break;
#endif
	case TUNSETOFFLOAD:
		ret = set_offload(tun, arg);
		break;

	case TUNSETTXFILTER:
		/* Can be set only for TAPs */
		ret = -EINVAL;
		if ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)
			break;
		ret = update_filter(&tun->txflt, (void __user *)arg);
		break;

	case SIOCGIFHWADDR:
		/* Get hw address */
		memcpy(ifr.ifr_hwaddr.sa_data, tun->dev->dev_addr, ETH_ALEN);
		ifr.ifr_hwaddr.sa_family = tun->dev->type;
		if (copy_to_user(argp, &ifr, ifreq_len))
			ret = -EFAULT;
		break;

	case SIOCSIFHWADDR:
		/* Set hw address */
		tun_debug(KERN_DEBUG, tun, ""set hw address: %pM\n"",
			  ifr.ifr_hwaddr.sa_data);

		ret = dev_set_mac_address(tun->dev, &ifr.ifr_hwaddr);
		break;

	case TUNGETSNDBUF:
		sndbuf = tun->socket.sk->sk_sndbuf;
		if (copy_to_user(argp, &sndbuf, sizeof(sndbuf)))
			ret = -EFAULT;
		break;

	case TUNSETSNDBUF:
		if (copy_from_user(&sndbuf, argp, sizeof(sndbuf))) {
			ret = -EFAULT;
			break;
		}

		tun->socket.sk->sk_sndbuf = sndbuf;
		break;

	case TUNGETVNETHDRSZ:
		vnet_hdr_sz = tun->vnet_hdr_sz;
		if (copy_to_user(argp, &vnet_hdr_sz, sizeof(vnet_hdr_sz)))
			ret = -EFAULT;
		break;

	case TUNSETVNETHDRSZ:
		if (copy_from_user(&vnet_hdr_sz, argp, sizeof(vnet_hdr_sz))) {
			ret = -EFAULT;
			break;
		}
		if (vnet_hdr_sz < (int)sizeof(struct virtio_net_hdr)) {
			ret = -EINVAL;
			break;
		}

		tun->vnet_hdr_sz = vnet_hdr_sz;
		break;

	case TUNATTACHFILTER:
		/* Can be set only for TAPs */
		ret = -EINVAL;
		if ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)
			break;
		ret = -EFAULT;
		if (copy_from_user(&fprog, argp, sizeof(fprog)))
			break;

		ret = sk_attach_filter(&fprog, tun->socket.sk);
		break;

	case TUNDETACHFILTER:
		/* Can be set only for TAPs */
		ret = -EINVAL;
		if ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)
			break;
		ret = sk_detach_filter(tun->socket.sk);
		break;

	default:
		ret = -EINVAL;
		break;
	}

unlock:
	rtnl_unlock();
	if (tun)
		tun_put(tun);
	return ret;
}
",C,"	if (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89) {
	} else
		memset(&ifr, 0, sizeof(ifr));
","	if (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89)
",,"@@ -1379,9 +1379,11 @@ static long __tun_chr_ioctl(struct file *file, unsigned int cmd,
 	int vnet_hdr_sz;
 	int ret;
 
-	if (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89)
+	if (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89) {
 		if (copy_from_user(&ifr, argp, ifreq_len))
 			return -EFAULT;
+	} else
+		memset(&ifr, 0, sizeof(ifr));
 
 	if (cmd == TUNGETFEATURES) {
 		/* Currently this just means: ""what IFF flags are valid?"".",linux,a117dacde0288f3ec60b6e5bcedae8fa37ee0dfc,cac83e53917ebc058066eb98023c11fdaa2262dc,1,"static long __tun_chr_ioctl(struct file *file, unsigned int cmd,
			    unsigned long arg, int ifreq_len)
{
	struct tun_file *tfile = file->private_data;
	struct tun_struct *tun;
	void __user* argp = (void __user*)arg;
	struct sock_fprog fprog;
	struct ifreq ifr;
	int sndbuf;
 	int vnet_hdr_sz;
 	int ret;
 
//flaw_line_below:
	if (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89)
//fix_flaw_line_below:
//	if (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89) {
 		if (copy_from_user(&ifr, argp, ifreq_len))
 			return -EFAULT;
//fix_flaw_line_below:
//	} else
//fix_flaw_line_below:
//		memset(&ifr, 0, sizeof(ifr));
 
 	if (cmd == TUNGETFEATURES) {
 		/* Currently this just means: ""what IFF flags are valid?"".
		 * This is needed because we never checked for invalid flags on
		 * TUNSETIFF. */
		return put_user(IFF_TUN | IFF_TAP | IFF_NO_PI | IFF_ONE_QUEUE |
				IFF_VNET_HDR,
				(unsigned int __user*)argp);
	}

	rtnl_lock();

	tun = __tun_get(tfile);
	if (cmd == TUNSETIFF && !tun) {
		ifr.ifr_name[IFNAMSIZ-1] = '\0';

		ret = tun_set_iff(tfile->net, file, &ifr);

		if (ret)
			goto unlock;

		if (copy_to_user(argp, &ifr, ifreq_len))
			ret = -EFAULT;
		goto unlock;
	}

	ret = -EBADFD;
	if (!tun)
		goto unlock;

	tun_debug(KERN_INFO, tun, ""tun_chr_ioctl cmd %d\n"", cmd);

	ret = 0;
	switch (cmd) {
	case TUNGETIFF:
		ret = tun_get_iff(current->nsproxy->net_ns, tun, &ifr);
		if (ret)
			break;

		if (copy_to_user(argp, &ifr, ifreq_len))
			ret = -EFAULT;
		break;

	case TUNSETNOCSUM:
		/* Disable/Enable checksum */

		/* [unimplemented] */
		tun_debug(KERN_INFO, tun, ""ignored: set checksum %s\n"",
			  arg ? ""disabled"" : ""enabled"");
		break;

	case TUNSETPERSIST:
		/* Disable/Enable persist mode */
		if (arg)
			tun->flags |= TUN_PERSIST;
		else
			tun->flags &= ~TUN_PERSIST;

		tun_debug(KERN_INFO, tun, ""persist %s\n"",
			  arg ? ""enabled"" : ""disabled"");
		break;

	case TUNSETOWNER:
		/* Set owner of the device */
		tun->owner = (uid_t) arg;

		tun_debug(KERN_INFO, tun, ""owner set to %d\n"", tun->owner);
		break;

	case TUNSETGROUP:
		/* Set group of the device */
		tun->group= (gid_t) arg;

		tun_debug(KERN_INFO, tun, ""group set to %d\n"", tun->group);
		break;

	case TUNSETLINK:
		/* Only allow setting the type when the interface is down */
		if (tun->dev->flags & IFF_UP) {
			tun_debug(KERN_INFO, tun,
				  ""Linktype set failed because interface is up\n"");
			ret = -EBUSY;
		} else {
			tun->dev->type = (int) arg;
			tun_debug(KERN_INFO, tun, ""linktype set to %d\n"",
				  tun->dev->type);
			ret = 0;
		}
		break;

#ifdef TUN_DEBUG
	case TUNSETDEBUG:
		tun->debug = arg;
		break;
#endif
	case TUNSETOFFLOAD:
		ret = set_offload(tun, arg);
		break;

	case TUNSETTXFILTER:
		/* Can be set only for TAPs */
		ret = -EINVAL;
		if ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)
			break;
		ret = update_filter(&tun->txflt, (void __user *)arg);
		break;

	case SIOCGIFHWADDR:
		/* Get hw address */
		memcpy(ifr.ifr_hwaddr.sa_data, tun->dev->dev_addr, ETH_ALEN);
		ifr.ifr_hwaddr.sa_family = tun->dev->type;
		if (copy_to_user(argp, &ifr, ifreq_len))
			ret = -EFAULT;
		break;

	case SIOCSIFHWADDR:
		/* Set hw address */
		tun_debug(KERN_DEBUG, tun, ""set hw address: %pM\n"",
			  ifr.ifr_hwaddr.sa_data);

		ret = dev_set_mac_address(tun->dev, &ifr.ifr_hwaddr);
		break;

	case TUNGETSNDBUF:
		sndbuf = tun->socket.sk->sk_sndbuf;
		if (copy_to_user(argp, &sndbuf, sizeof(sndbuf)))
			ret = -EFAULT;
		break;

	case TUNSETSNDBUF:
		if (copy_from_user(&sndbuf, argp, sizeof(sndbuf))) {
			ret = -EFAULT;
			break;
		}

		tun->socket.sk->sk_sndbuf = sndbuf;
		break;

	case TUNGETVNETHDRSZ:
		vnet_hdr_sz = tun->vnet_hdr_sz;
		if (copy_to_user(argp, &vnet_hdr_sz, sizeof(vnet_hdr_sz)))
			ret = -EFAULT;
		break;

	case TUNSETVNETHDRSZ:
		if (copy_from_user(&vnet_hdr_sz, argp, sizeof(vnet_hdr_sz))) {
			ret = -EFAULT;
			break;
		}
		if (vnet_hdr_sz < (int)sizeof(struct virtio_net_hdr)) {
			ret = -EINVAL;
			break;
		}

		tun->vnet_hdr_sz = vnet_hdr_sz;
		break;

	case TUNATTACHFILTER:
		/* Can be set only for TAPs */
		ret = -EINVAL;
		if ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)
			break;
		ret = -EFAULT;
		if (copy_from_user(&fprog, argp, sizeof(fprog)))
			break;

		ret = sk_attach_filter(&fprog, tun->socket.sk);
		break;

	case TUNDETACHFILTER:
		/* Can be set only for TAPs */
		ret = -EINVAL;
		if ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)
			break;
		ret = sk_detach_filter(tun->socket.sk);
		break;

	default:
		ret = -EINVAL;
		break;
	}

unlock:
	rtnl_unlock();
	if (tun)
		tun_put(tun);
	return ret;
}
",179351,"static long __tun_chr_ioctl(struct file *file, unsigned int cmd,
			    unsigned long arg, int ifreq_len)
{
	struct tun_file *tfile = file->private_data;
	struct tun_struct *tun;
	void __user* argp = (void __user*)arg;
	struct sock_fprog fprog;
	struct ifreq ifr;
	int sndbuf;
 	int vnet_hdr_sz;
 	int ret;
 
	if (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89)
 		if (copy_from_user(&ifr, argp, ifreq_len))
 			return -EFAULT;
 
 	if (cmd == TUNGETFEATURES) {
 		/* Currently this just means: ""what IFF flags are valid?"".
		 * This is needed because we never checked for invalid flags on
		 * TUNSETIFF. */
		return put_user(IFF_TUN | IFF_TAP | IFF_NO_PI | IFF_ONE_QUEUE |
				IFF_VNET_HDR,
				(unsigned int __user*)argp);
	}

	rtnl_lock();

	tun = __tun_get(tfile);
	if (cmd == TUNSETIFF && !tun) {
		ifr.ifr_name[IFNAMSIZ-1] = '\0';

		ret = tun_set_iff(tfile->net, file, &ifr);

		if (ret)
			goto unlock;

		if (copy_to_user(argp, &ifr, ifreq_len))
			ret = -EFAULT;
		goto unlock;
	}

	ret = -EBADFD;
	if (!tun)
		goto unlock;

	tun_debug(KERN_INFO, tun, ""tun_chr_ioctl cmd %d\n"", cmd);

	ret = 0;
	switch (cmd) {
	case TUNGETIFF:
		ret = tun_get_iff(current->nsproxy->net_ns, tun, &ifr);
		if (ret)
			break;

		if (copy_to_user(argp, &ifr, ifreq_len))
			ret = -EFAULT;
		break;

	case TUNSETNOCSUM:
		/* Disable/Enable checksum */

		/* [unimplemented] */
		tun_debug(KERN_INFO, tun, ""ignored: set checksum %s\n"",
			  arg ? ""disabled"" : ""enabled"");
		break;

	case TUNSETPERSIST:
		/* Disable/Enable persist mode */
		if (arg)
			tun->flags |= TUN_PERSIST;
		else
			tun->flags &= ~TUN_PERSIST;

		tun_debug(KERN_INFO, tun, ""persist %s\n"",
			  arg ? ""enabled"" : ""disabled"");
		break;

	case TUNSETOWNER:
		/* Set owner of the device */
		tun->owner = (uid_t) arg;

		tun_debug(KERN_INFO, tun, ""owner set to %d\n"", tun->owner);
		break;

	case TUNSETGROUP:
		/* Set group of the device */
		tun->group= (gid_t) arg;

		tun_debug(KERN_INFO, tun, ""group set to %d\n"", tun->group);
		break;

	case TUNSETLINK:
		/* Only allow setting the type when the interface is down */
		if (tun->dev->flags & IFF_UP) {
			tun_debug(KERN_INFO, tun,
				  ""Linktype set failed because interface is up\n"");
			ret = -EBUSY;
		} else {
			tun->dev->type = (int) arg;
			tun_debug(KERN_INFO, tun, ""linktype set to %d\n"",
				  tun->dev->type);
			ret = 0;
		}
		break;

#ifdef TUN_DEBUG
	case TUNSETDEBUG:
		tun->debug = arg;
		break;
#endif
	case TUNSETOFFLOAD:
		ret = set_offload(tun, arg);
		break;

	case TUNSETTXFILTER:
		/* Can be set only for TAPs */
		ret = -EINVAL;
		if ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)
			break;
		ret = update_filter(&tun->txflt, (void __user *)arg);
		break;

	case SIOCGIFHWADDR:
		/* Get hw address */
		memcpy(ifr.ifr_hwaddr.sa_data, tun->dev->dev_addr, ETH_ALEN);
		ifr.ifr_hwaddr.sa_family = tun->dev->type;
		if (copy_to_user(argp, &ifr, ifreq_len))
			ret = -EFAULT;
		break;

	case SIOCSIFHWADDR:
		/* Set hw address */
		tun_debug(KERN_DEBUG, tun, ""set hw address: %pM\n"",
			  ifr.ifr_hwaddr.sa_data);

		ret = dev_set_mac_address(tun->dev, &ifr.ifr_hwaddr);
		break;

	case TUNGETSNDBUF:
		sndbuf = tun->socket.sk->sk_sndbuf;
		if (copy_to_user(argp, &sndbuf, sizeof(sndbuf)))
			ret = -EFAULT;
		break;

	case TUNSETSNDBUF:
		if (copy_from_user(&sndbuf, argp, sizeof(sndbuf))) {
			ret = -EFAULT;
			break;
		}

		tun->socket.sk->sk_sndbuf = sndbuf;
		break;

	case TUNGETVNETHDRSZ:
		vnet_hdr_sz = tun->vnet_hdr_sz;
		if (copy_to_user(argp, &vnet_hdr_sz, sizeof(vnet_hdr_sz)))
			ret = -EFAULT;
		break;

	case TUNSETVNETHDRSZ:
		if (copy_from_user(&vnet_hdr_sz, argp, sizeof(vnet_hdr_sz))) {
			ret = -EFAULT;
			break;
		}
		if (vnet_hdr_sz < (int)sizeof(struct virtio_net_hdr)) {
			ret = -EINVAL;
			break;
		}

		tun->vnet_hdr_sz = vnet_hdr_sz;
		break;

	case TUNATTACHFILTER:
		/* Can be set only for TAPs */
		ret = -EINVAL;
		if ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)
			break;
		ret = -EFAULT;
		if (copy_from_user(&fprog, argp, sizeof(fprog)))
			break;

		ret = sk_attach_filter(&fprog, tun->socket.sk);
		break;

	case TUNDETACHFILTER:
		/* Can be set only for TAPs */
		ret = -EINVAL;
		if ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)
			break;
		ret = sk_detach_filter(tun->socket.sk);
		break;

	default:
		ret = -EINVAL;
		break;
	}

unlock:
	rtnl_unlock();
	if (tun)
		tun_put(tun);
	return ret;
}
","static long __tun_chr_ioctl(struct file *file, unsigned int cmd,
			    unsigned long arg, int ifreq_len)
{
	struct tun_file *tfile = file->private_data;
	struct tun_struct *tun;
	void __user* argp = (void __user*)arg;
	struct sock_fprog fprog;
	struct ifreq ifr;
	int sndbuf;
 	int vnet_hdr_sz;
 	int ret;
 
	if (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89) {
 		if (copy_from_user(&ifr, argp, ifreq_len))
 			return -EFAULT;
	} else
		memset(&ifr, 0, sizeof(ifr));
 
 	if (cmd == TUNGETFEATURES) {
 		/* Currently this just means: ""what IFF flags are valid?"".
		 * This is needed because we never checked for invalid flags on
		 * TUNSETIFF. */
		return put_user(IFF_TUN | IFF_TAP | IFF_NO_PI | IFF_ONE_QUEUE |
				IFF_VNET_HDR,
				(unsigned int __user*)argp);
	}

	rtnl_lock();

	tun = __tun_get(tfile);
	if (cmd == TUNSETIFF && !tun) {
		ifr.ifr_name[IFNAMSIZ-1] = '\0';

		ret = tun_set_iff(tfile->net, file, &ifr);

		if (ret)
			goto unlock;

		if (copy_to_user(argp, &ifr, ifreq_len))
			ret = -EFAULT;
		goto unlock;
	}

	ret = -EBADFD;
	if (!tun)
		goto unlock;

	tun_debug(KERN_INFO, tun, ""tun_chr_ioctl cmd %d\n"", cmd);

	ret = 0;
	switch (cmd) {
	case TUNGETIFF:
		ret = tun_get_iff(current->nsproxy->net_ns, tun, &ifr);
		if (ret)
			break;

		if (copy_to_user(argp, &ifr, ifreq_len))
			ret = -EFAULT;
		break;

	case TUNSETNOCSUM:
		/* Disable/Enable checksum */

		/* [unimplemented] */
		tun_debug(KERN_INFO, tun, ""ignored: set checksum %s\n"",
			  arg ? ""disabled"" : ""enabled"");
		break;

	case TUNSETPERSIST:
		/* Disable/Enable persist mode */
		if (arg)
			tun->flags |= TUN_PERSIST;
		else
			tun->flags &= ~TUN_PERSIST;

		tun_debug(KERN_INFO, tun, ""persist %s\n"",
			  arg ? ""enabled"" : ""disabled"");
		break;

	case TUNSETOWNER:
		/* Set owner of the device */
		tun->owner = (uid_t) arg;

		tun_debug(KERN_INFO, tun, ""owner set to %d\n"", tun->owner);
		break;

	case TUNSETGROUP:
		/* Set group of the device */
		tun->group= (gid_t) arg;

		tun_debug(KERN_INFO, tun, ""group set to %d\n"", tun->group);
		break;

	case TUNSETLINK:
		/* Only allow setting the type when the interface is down */
		if (tun->dev->flags & IFF_UP) {
			tun_debug(KERN_INFO, tun,
				  ""Linktype set failed because interface is up\n"");
			ret = -EBUSY;
		} else {
			tun->dev->type = (int) arg;
			tun_debug(KERN_INFO, tun, ""linktype set to %d\n"",
				  tun->dev->type);
			ret = 0;
		}
		break;

#ifdef TUN_DEBUG
	case TUNSETDEBUG:
		tun->debug = arg;
		break;
#endif
	case TUNSETOFFLOAD:
		ret = set_offload(tun, arg);
		break;

	case TUNSETTXFILTER:
		/* Can be set only for TAPs */
		ret = -EINVAL;
		if ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)
			break;
		ret = update_filter(&tun->txflt, (void __user *)arg);
		break;

	case SIOCGIFHWADDR:
		/* Get hw address */
		memcpy(ifr.ifr_hwaddr.sa_data, tun->dev->dev_addr, ETH_ALEN);
		ifr.ifr_hwaddr.sa_family = tun->dev->type;
		if (copy_to_user(argp, &ifr, ifreq_len))
			ret = -EFAULT;
		break;

	case SIOCSIFHWADDR:
		/* Set hw address */
		tun_debug(KERN_DEBUG, tun, ""set hw address: %pM\n"",
			  ifr.ifr_hwaddr.sa_data);

		ret = dev_set_mac_address(tun->dev, &ifr.ifr_hwaddr);
		break;

	case TUNGETSNDBUF:
		sndbuf = tun->socket.sk->sk_sndbuf;
		if (copy_to_user(argp, &sndbuf, sizeof(sndbuf)))
			ret = -EFAULT;
		break;

	case TUNSETSNDBUF:
		if (copy_from_user(&sndbuf, argp, sizeof(sndbuf))) {
			ret = -EFAULT;
			break;
		}

		tun->socket.sk->sk_sndbuf = sndbuf;
		break;

	case TUNGETVNETHDRSZ:
		vnet_hdr_sz = tun->vnet_hdr_sz;
		if (copy_to_user(argp, &vnet_hdr_sz, sizeof(vnet_hdr_sz)))
			ret = -EFAULT;
		break;

	case TUNSETVNETHDRSZ:
		if (copy_from_user(&vnet_hdr_sz, argp, sizeof(vnet_hdr_sz))) {
			ret = -EFAULT;
			break;
		}
		if (vnet_hdr_sz < (int)sizeof(struct virtio_net_hdr)) {
			ret = -EINVAL;
			break;
		}

		tun->vnet_hdr_sz = vnet_hdr_sz;
		break;

	case TUNATTACHFILTER:
		/* Can be set only for TAPs */
		ret = -EINVAL;
		if ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)
			break;
		ret = -EFAULT;
		if (copy_from_user(&fprog, argp, sizeof(fprog)))
			break;

		ret = sk_attach_filter(&fprog, tun->socket.sk);
		break;

	case TUNDETACHFILTER:
		/* Can be set only for TAPs */
		ret = -EINVAL;
		if ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)
			break;
		ret = sk_detach_filter(tun->socket.sk);
		break;

	default:
		ret = -EINVAL;
		break;
	}

unlock:
	rtnl_unlock();
	if (tun)
		tun_put(tun);
	return ret;
}
","The provided code implements the `__tun_chr_ioctl` function, which handles various IOCTL commands for a TUN/TAP virtual network device in a Linux kernel module. It processes commands such as setting interface flags, retrieving features, managing device ownership and group, configuring hardware addresses, and adjusting socket buffer sizes. The function ensures proper user-space memory access and synchronization using the `rtnl_lock()` to prevent race conditions. It also includes error handling for invalid commands and conditions, such as attempting to change settings on an active interface. The function returns appropriate status codes based on the success or failure of each operation.","The code defines a function that processes various control commands for a virtual network device within a kernel module. It handles operations such as configuring interface flags, retrieving device features, managing ownership and group settings, and adjusting network parameters. The function ensures safe access to user-space memory and employs locking mechanisms to prevent concurrent access issues. It includes error handling for invalid commands and conditions, such as modifying settings on an active interface. The function ultimately returns status codes indicating the success or failure of each requested operation, facilitating communication between user-space applications and the kernel.","The vulnerability in the original code stemmed from not fully initializing the `ifr` structure before it was copied to user memory in response to certain IOCTL commands, specifically `TUNGETIFF` and `SIOCGIFHWADDR`. This oversight could lead to information leaks, as uninitialized memory could contain sensitive data. The fix involved adding a conditional initialization of the `ifr` structure using `memset` to zero it out when the command was not `TUNSETIFF` or `_IOC_TYPE(cmd) == 0x89`. This ensures that the structure is properly initialized, preventing any leakage of potentially sensitive data to user space.","The vulnerability in the original code was due to a failure to fully initialize a stack-allocated structure before copying it to user memory in response to specific IOCTL commands. This oversight could result in leaking uninitialized memory, potentially exposing sensitive information to user space. The fix involved ensuring that the structure is properly zeroed out when it is not being set with valid data, thereby preventing any residual data from being inadvertently shared. This change effectively mitigates the risk of information leaks by guaranteeing that only initialized and safe data is sent to user space.","The vulnerability was fixed by adding a call to `memset` to initialize the `ifr` structure to zero before it is used in the `TUNGETIFF` and `SIOCGIFHWADDR` commands. Specifically, the code now checks if the command is not `TUNSETIFF` or `_IOC_TYPE(cmd) == 0x89`, and if so, it calls `memset(&ifr, 0, sizeof(ifr))`. This ensures that any residual data in the structure is cleared, preventing the leakage of up to 36 bytes of uninitialized memory to user space. As a result, only safe and initialized data is copied to user memory, addressing the information leak issue.","The vulnerability was fixed by ensuring that a specific structure used in the code is fully initialized before being copied to user memory. This was achieved by adding a condition to zero out the structure when it is not being set with valid data. By doing so, any residual or uninitialized memory that could potentially contain sensitive information is cleared, thereby preventing information leaks. This change guarantees that only safe and properly initialized data is sent to user space, effectively mitigating the risk of exposing unintended data to users.","5, 5","5,5","4,4","4,5"
41,41,179357,179357,,Local,Not required,,CVE-2012-6541,https://www.cvedetails.com/cve/CVE-2012-6541/,CWE-200,Medium,Partial,,,2013-03-15,1.9,"The ccid3_hc_tx_getsockopt function in net/dccp/ccids/ccid3.c in the Linux kernel before 3.6 does not initialize a certain structure, which allows local users to obtain sensitive information from kernel stack memory via a crafted application.",2013-03-18,+Info ,1,https://github.com/torvalds/linux/commit/7b07f8eb75aa3097cdfd4f6eac3da49db787381d,7b07f8eb75aa3097cdfd4f6eac3da49db787381d,"dccp: fix info leak via getsockopt(DCCP_SOCKOPT_CCID_TX_INFO)

The CCID3 code fails to initialize the trailing padding bytes of struct
tfrc_tx_info added for alignment on 64 bit architectures. It that for
potentially leaks four bytes kernel stack via the getsockopt() syscall.
Add an explicit memset(0) before filling the structure to avoid the
info leak.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/dccp/ccids/ccid3.c,"{""sha"": ""119c04317d48eed4abcb2bbf6071062c8d9784fd"", ""filename"": ""net/dccp/ccids/ccid3.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/7b07f8eb75aa3097cdfd4f6eac3da49db787381d/net/dccp/ccids/ccid3.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/7b07f8eb75aa3097cdfd4f6eac3da49db787381d/net/dccp/ccids/ccid3.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/dccp/ccids/ccid3.c?ref=7b07f8eb75aa3097cdfd4f6eac3da49db787381d"", ""patch"": ""@@ -535,6 +535,7 @@ static int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,\n \tcase DCCP_SOCKOPT_CCID_TX_INFO:\n \t\tif (len < sizeof(tfrc))\n \t\t\treturn -EINVAL;\n+\t\tmemset(&tfrc, 0, sizeof(tfrc));\n \t\ttfrc.tfrctx_x\t   = hc->tx_x;\n \t\ttfrc.tfrctx_x_recv = hc->tx_x_recv;\n \t\ttfrc.tfrctx_x_calc = hc->tx_x_calc;""}","static int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,
				  u32 __user *optval, int __user *optlen)
{
	const struct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);
	struct tfrc_tx_info tfrc;
	const void *val;

	switch (optname) {
 	case DCCP_SOCKOPT_CCID_TX_INFO:
 		if (len < sizeof(tfrc))
 			return -EINVAL;
		memset(&tfrc, 0, sizeof(tfrc));
 		tfrc.tfrctx_x	   = hc->tx_x;
 		tfrc.tfrctx_x_recv = hc->tx_x_recv;
 		tfrc.tfrctx_x_calc = hc->tx_x_calc;
		tfrc.tfrctx_rtt	   = hc->tx_rtt;
		tfrc.tfrctx_p	   = hc->tx_p;
		tfrc.tfrctx_rto	   = hc->tx_t_rto;
		tfrc.tfrctx_ipi	   = hc->tx_t_ipi;
		len = sizeof(tfrc);
		val = &tfrc;
		break;
	default:
		return -ENOPROTOOPT;
	}

	if (put_user(len, optlen) || copy_to_user(optval, val, len))
		return -EFAULT;

	return 0;
}
","static int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,
				  u32 __user *optval, int __user *optlen)
{
	const struct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);
	struct tfrc_tx_info tfrc;
	const void *val;

	switch (optname) {
 	case DCCP_SOCKOPT_CCID_TX_INFO:
 		if (len < sizeof(tfrc))
 			return -EINVAL;
 		tfrc.tfrctx_x	   = hc->tx_x;
 		tfrc.tfrctx_x_recv = hc->tx_x_recv;
 		tfrc.tfrctx_x_calc = hc->tx_x_calc;
		tfrc.tfrctx_rtt	   = hc->tx_rtt;
		tfrc.tfrctx_p	   = hc->tx_p;
		tfrc.tfrctx_rto	   = hc->tx_t_rto;
		tfrc.tfrctx_ipi	   = hc->tx_t_ipi;
		len = sizeof(tfrc);
		val = &tfrc;
		break;
	default:
		return -ENOPROTOOPT;
	}

	if (put_user(len, optlen) || copy_to_user(optval, val, len))
		return -EFAULT;

	return 0;
}
",C,"		memset(&tfrc, 0, sizeof(tfrc));
",,,"@@ -535,6 +535,7 @@ static int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,
 	case DCCP_SOCKOPT_CCID_TX_INFO:
 		if (len < sizeof(tfrc))
 			return -EINVAL;
+		memset(&tfrc, 0, sizeof(tfrc));
 		tfrc.tfrctx_x	   = hc->tx_x;
 		tfrc.tfrctx_x_recv = hc->tx_x_recv;
 		tfrc.tfrctx_x_calc = hc->tx_x_calc;",linux,7b07f8eb75aa3097cdfd4f6eac3da49db787381d,276bdb82dedb290511467a5a4fdbe9f0b52dce6f,1,"static int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,
				  u32 __user *optval, int __user *optlen)
{
	const struct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);
	struct tfrc_tx_info tfrc;
	const void *val;

	switch (optname) {
 	case DCCP_SOCKOPT_CCID_TX_INFO:
 		if (len < sizeof(tfrc))
 			return -EINVAL;
//fix_flaw_line_below:
//		memset(&tfrc, 0, sizeof(tfrc));
 		tfrc.tfrctx_x	   = hc->tx_x;
 		tfrc.tfrctx_x_recv = hc->tx_x_recv;
 		tfrc.tfrctx_x_calc = hc->tx_x_calc;
		tfrc.tfrctx_rtt	   = hc->tx_rtt;
		tfrc.tfrctx_p	   = hc->tx_p;
		tfrc.tfrctx_rto	   = hc->tx_t_rto;
		tfrc.tfrctx_ipi	   = hc->tx_t_ipi;
		len = sizeof(tfrc);
		val = &tfrc;
		break;
	default:
		return -ENOPROTOOPT;
	}

	if (put_user(len, optlen) || copy_to_user(optval, val, len))
		return -EFAULT;

	return 0;
}
",179357,"static int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,
				  u32 __user *optval, int __user *optlen)
{
	const struct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);
	struct tfrc_tx_info tfrc;
	const void *val;

	switch (optname) {
 	case DCCP_SOCKOPT_CCID_TX_INFO:
 		if (len < sizeof(tfrc))
 			return -EINVAL;
 		tfrc.tfrctx_x	   = hc->tx_x;
 		tfrc.tfrctx_x_recv = hc->tx_x_recv;
 		tfrc.tfrctx_x_calc = hc->tx_x_calc;
		tfrc.tfrctx_rtt	   = hc->tx_rtt;
		tfrc.tfrctx_p	   = hc->tx_p;
		tfrc.tfrctx_rto	   = hc->tx_t_rto;
		tfrc.tfrctx_ipi	   = hc->tx_t_ipi;
		len = sizeof(tfrc);
		val = &tfrc;
		break;
	default:
		return -ENOPROTOOPT;
	}

	if (put_user(len, optlen) || copy_to_user(optval, val, len))
		return -EFAULT;

	return 0;
}
","static int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,
				  u32 __user *optval, int __user *optlen)
{
	const struct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);
	struct tfrc_tx_info tfrc;
	const void *val;

	switch (optname) {
 	case DCCP_SOCKOPT_CCID_TX_INFO:
 		if (len < sizeof(tfrc))
 			return -EINVAL;
		memset(&tfrc, 0, sizeof(tfrc));
 		tfrc.tfrctx_x	   = hc->tx_x;
 		tfrc.tfrctx_x_recv = hc->tx_x_recv;
 		tfrc.tfrctx_x_calc = hc->tx_x_calc;
		tfrc.tfrctx_rtt	   = hc->tx_rtt;
		tfrc.tfrctx_p	   = hc->tx_p;
		tfrc.tfrctx_rto	   = hc->tx_t_rto;
		tfrc.tfrctx_ipi	   = hc->tx_t_ipi;
		len = sizeof(tfrc);
		val = &tfrc;
		break;
	default:
		return -ENOPROTOOPT;
	}

	if (put_user(len, optlen) || copy_to_user(optval, val, len))
		return -EFAULT;

	return 0;
}
","The provided code defines a function `ccid3_hc_tx_getsockopt`, which retrieves socket options for a specific transport protocol (DCCP) related to congestion control. It checks the requested option name, and if it matches `DCCP_SOCKOPT_CCID_TX_INFO`, it populates a `tfrc_tx_info` structure with various transmission parameters from the socket's state. The function ensures that the length of the data is valid and then copies the populated structure to user space. If the option name is unrecognized or if there are issues with memory access, it returns appropriate error codes, ensuring robust error handling.","The code defines a function that retrieves specific socket options related to congestion control for a transport protocol. It checks if the requested option is valid and, if so, populates a structure with various transmission parameters from the socket's state. The function verifies that the length of the data is appropriate before copying the populated information to user space. If the option is not recognized or if there are issues accessing memory, it returns relevant error codes, ensuring proper error handling and communication between the kernel and user space.","The vulnerability in the original code stemmed from the failure to initialize the trailing padding bytes of the `tfrc_tx_info` structure, which could lead to an information leak through the `getsockopt` syscall, potentially exposing sensitive data from the kernel stack. This issue arose because the structure was not fully cleared before being populated with values from the socket's state. The fix involved adding a `memset` call to explicitly zero out the entire structure before assigning values, ensuring that any uninitialized memory would not inadvertently leak information, thus enhancing security and preventing unauthorized data exposure.","The vulnerability in the original code was due to uninitialized trailing padding bytes in a structure, which could lead to an information leak through a system call, potentially exposing sensitive data from the kernel stack. This oversight occurred because the structure was not fully cleared before being populated with relevant values, allowing leftover data to be inadvertently returned to user space. The fix involved adding a memory initialization step to ensure that all bytes of the structure were set to zero before any values were assigned, thereby preventing any leakage of sensitive information and enhancing overall security.","The vulnerability was fixed by adding a `memset` function call to explicitly initialize the entire `tfrc_tx_info` structure to zero before populating it with values from the socket's state. This was done by inserting `memset(&tfrc, 0, sizeof(tfrc));` right after checking the length of the input. By ensuring that all bytes, including the trailing padding, were set to zero, the fix effectively eliminated the risk of leaking uninitialized data from the kernel stack through the `getsockopt` syscall, thereby enhancing the security of the code.","The vulnerability was addressed by incorporating a memory initialization step that sets all bytes of the affected structure to zero before any data is assigned to it. This change ensures that any uninitialized memory, which could contain sensitive information from the kernel stack, is cleared out, preventing potential information leaks. By explicitly zeroing out the structure, the fix guarantees that only the intended values are returned to user space, thereby enhancing the security of the code and mitigating the risk of exposing leftover data from previous operations.","5, 5","5,5","5,5","5,5"
42,42,179358,179358,,Local,Not required,,CVE-2012-6540,https://www.cvedetails.com/cve/CVE-2012-6540/,CWE-200,Medium,Partial,,,2013-03-15,1.9,"The do_ip_vs_get_ctl function in net/netfilter/ipvs/ip_vs_ctl.c in the Linux kernel before 3.6 does not initialize a certain structure for IP_VS_SO_GET_TIMEOUT commands, which allows local users to obtain sensitive information from kernel stack memory via a crafted application.",2013-05-14,+Info ,1,https://github.com/torvalds/linux/commit/2d8a041b7bfe1097af21441cb77d6af95f4f4680,2d8a041b7bfe1097af21441cb77d6af95f4f4680,"ipvs: fix info leak in getsockopt(IP_VS_SO_GET_TIMEOUT)

If at least one of CONFIG_IP_VS_PROTO_TCP or CONFIG_IP_VS_PROTO_UDP is
not set, __ip_vs_get_timeouts() does not fully initialize the structure
that gets copied to userland and that for leaks up to 12 bytes of kernel
stack. Add an explicit memset(0) before passing the structure to
__ip_vs_get_timeouts() to avoid the info leak.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Wensong Zhang <wensong@linux-vs.org>
Cc: Simon Horman <horms@verge.net.au>
Cc: Julian Anastasov <ja@ssi.bg>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/netfilter/ipvs/ip_vs_ctl.c,"{""sha"": ""72bf32a84874718927a4bcbdc2e26395be00bdd8"", ""filename"": ""net/netfilter/ipvs/ip_vs_ctl.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/2d8a041b7bfe1097af21441cb77d6af95f4f4680/net/netfilter/ipvs/ip_vs_ctl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/2d8a041b7bfe1097af21441cb77d6af95f4f4680/net/netfilter/ipvs/ip_vs_ctl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/netfilter/ipvs/ip_vs_ctl.c?ref=2d8a041b7bfe1097af21441cb77d6af95f4f4680"", ""patch"": ""@@ -2759,6 +2759,7 @@ do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n \t{\n \t\tstruct ip_vs_timeout_user t;\n \n+\t\tmemset(&t, 0, sizeof(t));\n \t\t__ip_vs_get_timeouts(net, &t);\n \t\tif (copy_to_user(user, &t, sizeof(t)) != 0)\n \t\t\tret = -EFAULT;""}","do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)
{
	unsigned char arg[128];
	int ret = 0;
	unsigned int copylen;
	struct net *net = sock_net(sk);
	struct netns_ipvs *ipvs = net_ipvs(net);

	BUG_ON(!net);
	if (!capable(CAP_NET_ADMIN))
		return -EPERM;

	if (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX)
		return -EINVAL;

	if (*len < get_arglen[GET_CMDID(cmd)]) {
		pr_err(""get_ctl: len %u < %u\n"",
		       *len, get_arglen[GET_CMDID(cmd)]);
		return -EINVAL;
	}

	copylen = get_arglen[GET_CMDID(cmd)];
	if (copylen > 128)
		return -EINVAL;

	if (copy_from_user(arg, user, copylen) != 0)
		return -EFAULT;
	/*
	 * Handle daemons first since it has its own locking
	 */
	if (cmd == IP_VS_SO_GET_DAEMON) {
		struct ip_vs_daemon_user d[2];

		memset(&d, 0, sizeof(d));
		if (mutex_lock_interruptible(&ipvs->sync_mutex))
			return -ERESTARTSYS;

		if (ipvs->sync_state & IP_VS_STATE_MASTER) {
			d[0].state = IP_VS_STATE_MASTER;
			strlcpy(d[0].mcast_ifn, ipvs->master_mcast_ifn,
				sizeof(d[0].mcast_ifn));
			d[0].syncid = ipvs->master_syncid;
		}
		if (ipvs->sync_state & IP_VS_STATE_BACKUP) {
			d[1].state = IP_VS_STATE_BACKUP;
			strlcpy(d[1].mcast_ifn, ipvs->backup_mcast_ifn,
				sizeof(d[1].mcast_ifn));
			d[1].syncid = ipvs->backup_syncid;
		}
		if (copy_to_user(user, &d, sizeof(d)) != 0)
			ret = -EFAULT;
		mutex_unlock(&ipvs->sync_mutex);
		return ret;
	}

	if (mutex_lock_interruptible(&__ip_vs_mutex))
		return -ERESTARTSYS;

	switch (cmd) {
	case IP_VS_SO_GET_VERSION:
	{
		char buf[64];

		sprintf(buf, ""IP Virtual Server version %d.%d.%d (size=%d)"",
			NVERSION(IP_VS_VERSION_CODE), ip_vs_conn_tab_size);
		if (copy_to_user(user, buf, strlen(buf)+1) != 0) {
			ret = -EFAULT;
			goto out;
		}
		*len = strlen(buf)+1;
	}
	break;

	case IP_VS_SO_GET_INFO:
	{
		struct ip_vs_getinfo info;
		info.version = IP_VS_VERSION_CODE;
		info.size = ip_vs_conn_tab_size;
		info.num_services = ipvs->num_services;
		if (copy_to_user(user, &info, sizeof(info)) != 0)
			ret = -EFAULT;
	}
	break;

	case IP_VS_SO_GET_SERVICES:
	{
		struct ip_vs_get_services *get;
		int size;

		get = (struct ip_vs_get_services *)arg;
		size = sizeof(*get) +
			sizeof(struct ip_vs_service_entry) * get->num_services;
		if (*len != size) {
			pr_err(""length: %u != %u\n"", *len, size);
			ret = -EINVAL;
			goto out;
		}
		ret = __ip_vs_get_service_entries(net, get, user);
	}
	break;

	case IP_VS_SO_GET_SERVICE:
	{
		struct ip_vs_service_entry *entry;
		struct ip_vs_service *svc;
		union nf_inet_addr addr;

		entry = (struct ip_vs_service_entry *)arg;
		addr.ip = entry->addr;
		if (entry->fwmark)
			svc = __ip_vs_svc_fwm_find(net, AF_INET, entry->fwmark);
		else
			svc = __ip_vs_service_find(net, AF_INET,
						   entry->protocol, &addr,
						   entry->port);
		if (svc) {
			ip_vs_copy_service(entry, svc);
			if (copy_to_user(user, entry, sizeof(*entry)) != 0)
				ret = -EFAULT;
		} else
			ret = -ESRCH;
	}
	break;

	case IP_VS_SO_GET_DESTS:
	{
		struct ip_vs_get_dests *get;
		int size;

		get = (struct ip_vs_get_dests *)arg;
		size = sizeof(*get) +
			sizeof(struct ip_vs_dest_entry) * get->num_dests;
		if (*len != size) {
			pr_err(""length: %u != %u\n"", *len, size);
			ret = -EINVAL;
			goto out;
		}
		ret = __ip_vs_get_dest_entries(net, get, user);
	}
	break;

	case IP_VS_SO_GET_TIMEOUT:
 	{
 		struct ip_vs_timeout_user t;
 
		memset(&t, 0, sizeof(t));
 		__ip_vs_get_timeouts(net, &t);
 		if (copy_to_user(user, &t, sizeof(t)) != 0)
 			ret = -EFAULT;
	}
	break;

	default:
		ret = -EINVAL;
	}

out:
	mutex_unlock(&__ip_vs_mutex);
	return ret;
}
","do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)
{
	unsigned char arg[128];
	int ret = 0;
	unsigned int copylen;
	struct net *net = sock_net(sk);
	struct netns_ipvs *ipvs = net_ipvs(net);

	BUG_ON(!net);
	if (!capable(CAP_NET_ADMIN))
		return -EPERM;

	if (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX)
		return -EINVAL;

	if (*len < get_arglen[GET_CMDID(cmd)]) {
		pr_err(""get_ctl: len %u < %u\n"",
		       *len, get_arglen[GET_CMDID(cmd)]);
		return -EINVAL;
	}

	copylen = get_arglen[GET_CMDID(cmd)];
	if (copylen > 128)
		return -EINVAL;

	if (copy_from_user(arg, user, copylen) != 0)
		return -EFAULT;
	/*
	 * Handle daemons first since it has its own locking
	 */
	if (cmd == IP_VS_SO_GET_DAEMON) {
		struct ip_vs_daemon_user d[2];

		memset(&d, 0, sizeof(d));
		if (mutex_lock_interruptible(&ipvs->sync_mutex))
			return -ERESTARTSYS;

		if (ipvs->sync_state & IP_VS_STATE_MASTER) {
			d[0].state = IP_VS_STATE_MASTER;
			strlcpy(d[0].mcast_ifn, ipvs->master_mcast_ifn,
				sizeof(d[0].mcast_ifn));
			d[0].syncid = ipvs->master_syncid;
		}
		if (ipvs->sync_state & IP_VS_STATE_BACKUP) {
			d[1].state = IP_VS_STATE_BACKUP;
			strlcpy(d[1].mcast_ifn, ipvs->backup_mcast_ifn,
				sizeof(d[1].mcast_ifn));
			d[1].syncid = ipvs->backup_syncid;
		}
		if (copy_to_user(user, &d, sizeof(d)) != 0)
			ret = -EFAULT;
		mutex_unlock(&ipvs->sync_mutex);
		return ret;
	}

	if (mutex_lock_interruptible(&__ip_vs_mutex))
		return -ERESTARTSYS;

	switch (cmd) {
	case IP_VS_SO_GET_VERSION:
	{
		char buf[64];

		sprintf(buf, ""IP Virtual Server version %d.%d.%d (size=%d)"",
			NVERSION(IP_VS_VERSION_CODE), ip_vs_conn_tab_size);
		if (copy_to_user(user, buf, strlen(buf)+1) != 0) {
			ret = -EFAULT;
			goto out;
		}
		*len = strlen(buf)+1;
	}
	break;

	case IP_VS_SO_GET_INFO:
	{
		struct ip_vs_getinfo info;
		info.version = IP_VS_VERSION_CODE;
		info.size = ip_vs_conn_tab_size;
		info.num_services = ipvs->num_services;
		if (copy_to_user(user, &info, sizeof(info)) != 0)
			ret = -EFAULT;
	}
	break;

	case IP_VS_SO_GET_SERVICES:
	{
		struct ip_vs_get_services *get;
		int size;

		get = (struct ip_vs_get_services *)arg;
		size = sizeof(*get) +
			sizeof(struct ip_vs_service_entry) * get->num_services;
		if (*len != size) {
			pr_err(""length: %u != %u\n"", *len, size);
			ret = -EINVAL;
			goto out;
		}
		ret = __ip_vs_get_service_entries(net, get, user);
	}
	break;

	case IP_VS_SO_GET_SERVICE:
	{
		struct ip_vs_service_entry *entry;
		struct ip_vs_service *svc;
		union nf_inet_addr addr;

		entry = (struct ip_vs_service_entry *)arg;
		addr.ip = entry->addr;
		if (entry->fwmark)
			svc = __ip_vs_svc_fwm_find(net, AF_INET, entry->fwmark);
		else
			svc = __ip_vs_service_find(net, AF_INET,
						   entry->protocol, &addr,
						   entry->port);
		if (svc) {
			ip_vs_copy_service(entry, svc);
			if (copy_to_user(user, entry, sizeof(*entry)) != 0)
				ret = -EFAULT;
		} else
			ret = -ESRCH;
	}
	break;

	case IP_VS_SO_GET_DESTS:
	{
		struct ip_vs_get_dests *get;
		int size;

		get = (struct ip_vs_get_dests *)arg;
		size = sizeof(*get) +
			sizeof(struct ip_vs_dest_entry) * get->num_dests;
		if (*len != size) {
			pr_err(""length: %u != %u\n"", *len, size);
			ret = -EINVAL;
			goto out;
		}
		ret = __ip_vs_get_dest_entries(net, get, user);
	}
	break;

	case IP_VS_SO_GET_TIMEOUT:
 	{
 		struct ip_vs_timeout_user t;
 
 		__ip_vs_get_timeouts(net, &t);
 		if (copy_to_user(user, &t, sizeof(t)) != 0)
 			ret = -EFAULT;
	}
	break;

	default:
		ret = -EINVAL;
	}

out:
	mutex_unlock(&__ip_vs_mutex);
	return ret;
}
",C,"		memset(&t, 0, sizeof(t));
",,,"@@ -2759,6 +2759,7 @@ do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)
 	{
 		struct ip_vs_timeout_user t;
 
+		memset(&t, 0, sizeof(t));
 		__ip_vs_get_timeouts(net, &t);
 		if (copy_to_user(user, &t, sizeof(t)) != 0)
 			ret = -EFAULT;",linux,2d8a041b7bfe1097af21441cb77d6af95f4f4680,7b07f8eb75aa3097cdfd4f6eac3da49db787381d,1,"do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)
{
	unsigned char arg[128];
	int ret = 0;
	unsigned int copylen;
	struct net *net = sock_net(sk);
	struct netns_ipvs *ipvs = net_ipvs(net);

	BUG_ON(!net);
	if (!capable(CAP_NET_ADMIN))
		return -EPERM;

	if (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX)
		return -EINVAL;

	if (*len < get_arglen[GET_CMDID(cmd)]) {
		pr_err(""get_ctl: len %u < %u\n"",
		       *len, get_arglen[GET_CMDID(cmd)]);
		return -EINVAL;
	}

	copylen = get_arglen[GET_CMDID(cmd)];
	if (copylen > 128)
		return -EINVAL;

	if (copy_from_user(arg, user, copylen) != 0)
		return -EFAULT;
	/*
	 * Handle daemons first since it has its own locking
	 */
	if (cmd == IP_VS_SO_GET_DAEMON) {
		struct ip_vs_daemon_user d[2];

		memset(&d, 0, sizeof(d));
		if (mutex_lock_interruptible(&ipvs->sync_mutex))
			return -ERESTARTSYS;

		if (ipvs->sync_state & IP_VS_STATE_MASTER) {
			d[0].state = IP_VS_STATE_MASTER;
			strlcpy(d[0].mcast_ifn, ipvs->master_mcast_ifn,
				sizeof(d[0].mcast_ifn));
			d[0].syncid = ipvs->master_syncid;
		}
		if (ipvs->sync_state & IP_VS_STATE_BACKUP) {
			d[1].state = IP_VS_STATE_BACKUP;
			strlcpy(d[1].mcast_ifn, ipvs->backup_mcast_ifn,
				sizeof(d[1].mcast_ifn));
			d[1].syncid = ipvs->backup_syncid;
		}
		if (copy_to_user(user, &d, sizeof(d)) != 0)
			ret = -EFAULT;
		mutex_unlock(&ipvs->sync_mutex);
		return ret;
	}

	if (mutex_lock_interruptible(&__ip_vs_mutex))
		return -ERESTARTSYS;

	switch (cmd) {
	case IP_VS_SO_GET_VERSION:
	{
		char buf[64];

		sprintf(buf, ""IP Virtual Server version %d.%d.%d (size=%d)"",
			NVERSION(IP_VS_VERSION_CODE), ip_vs_conn_tab_size);
		if (copy_to_user(user, buf, strlen(buf)+1) != 0) {
			ret = -EFAULT;
			goto out;
		}
		*len = strlen(buf)+1;
	}
	break;

	case IP_VS_SO_GET_INFO:
	{
		struct ip_vs_getinfo info;
		info.version = IP_VS_VERSION_CODE;
		info.size = ip_vs_conn_tab_size;
		info.num_services = ipvs->num_services;
		if (copy_to_user(user, &info, sizeof(info)) != 0)
			ret = -EFAULT;
	}
	break;

	case IP_VS_SO_GET_SERVICES:
	{
		struct ip_vs_get_services *get;
		int size;

		get = (struct ip_vs_get_services *)arg;
		size = sizeof(*get) +
			sizeof(struct ip_vs_service_entry) * get->num_services;
		if (*len != size) {
			pr_err(""length: %u != %u\n"", *len, size);
			ret = -EINVAL;
			goto out;
		}
		ret = __ip_vs_get_service_entries(net, get, user);
	}
	break;

	case IP_VS_SO_GET_SERVICE:
	{
		struct ip_vs_service_entry *entry;
		struct ip_vs_service *svc;
		union nf_inet_addr addr;

		entry = (struct ip_vs_service_entry *)arg;
		addr.ip = entry->addr;
		if (entry->fwmark)
			svc = __ip_vs_svc_fwm_find(net, AF_INET, entry->fwmark);
		else
			svc = __ip_vs_service_find(net, AF_INET,
						   entry->protocol, &addr,
						   entry->port);
		if (svc) {
			ip_vs_copy_service(entry, svc);
			if (copy_to_user(user, entry, sizeof(*entry)) != 0)
				ret = -EFAULT;
		} else
			ret = -ESRCH;
	}
	break;

	case IP_VS_SO_GET_DESTS:
	{
		struct ip_vs_get_dests *get;
		int size;

		get = (struct ip_vs_get_dests *)arg;
		size = sizeof(*get) +
			sizeof(struct ip_vs_dest_entry) * get->num_dests;
		if (*len != size) {
			pr_err(""length: %u != %u\n"", *len, size);
			ret = -EINVAL;
			goto out;
		}
		ret = __ip_vs_get_dest_entries(net, get, user);
	}
	break;

	case IP_VS_SO_GET_TIMEOUT:
 	{
 		struct ip_vs_timeout_user t;
 
//fix_flaw_line_below:
//		memset(&t, 0, sizeof(t));
 		__ip_vs_get_timeouts(net, &t);
 		if (copy_to_user(user, &t, sizeof(t)) != 0)
 			ret = -EFAULT;
	}
	break;

	default:
		ret = -EINVAL;
	}

out:
	mutex_unlock(&__ip_vs_mutex);
	return ret;
}
",179358,"do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)
{
	unsigned char arg[128];
	int ret = 0;
	unsigned int copylen;
	struct net *net = sock_net(sk);
	struct netns_ipvs *ipvs = net_ipvs(net);

	BUG_ON(!net);
	if (!capable(CAP_NET_ADMIN))
		return -EPERM;

	if (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX)
		return -EINVAL;

	if (*len < get_arglen[GET_CMDID(cmd)]) {
		pr_err(""get_ctl: len %u < %u\n"",
		       *len, get_arglen[GET_CMDID(cmd)]);
		return -EINVAL;
	}

	copylen = get_arglen[GET_CMDID(cmd)];
	if (copylen > 128)
		return -EINVAL;

	if (copy_from_user(arg, user, copylen) != 0)
		return -EFAULT;
	/*
	 * Handle daemons first since it has its own locking
	 */
	if (cmd == IP_VS_SO_GET_DAEMON) {
		struct ip_vs_daemon_user d[2];

		memset(&d, 0, sizeof(d));
		if (mutex_lock_interruptible(&ipvs->sync_mutex))
			return -ERESTARTSYS;

		if (ipvs->sync_state & IP_VS_STATE_MASTER) {
			d[0].state = IP_VS_STATE_MASTER;
			strlcpy(d[0].mcast_ifn, ipvs->master_mcast_ifn,
				sizeof(d[0].mcast_ifn));
			d[0].syncid = ipvs->master_syncid;
		}
		if (ipvs->sync_state & IP_VS_STATE_BACKUP) {
			d[1].state = IP_VS_STATE_BACKUP;
			strlcpy(d[1].mcast_ifn, ipvs->backup_mcast_ifn,
				sizeof(d[1].mcast_ifn));
			d[1].syncid = ipvs->backup_syncid;
		}
		if (copy_to_user(user, &d, sizeof(d)) != 0)
			ret = -EFAULT;
		mutex_unlock(&ipvs->sync_mutex);
		return ret;
	}

	if (mutex_lock_interruptible(&__ip_vs_mutex))
		return -ERESTARTSYS;

	switch (cmd) {
	case IP_VS_SO_GET_VERSION:
	{
		char buf[64];

		sprintf(buf, ""IP Virtual Server version %d.%d.%d (size=%d)"",
			NVERSION(IP_VS_VERSION_CODE), ip_vs_conn_tab_size);
		if (copy_to_user(user, buf, strlen(buf)+1) != 0) {
			ret = -EFAULT;
			goto out;
		}
		*len = strlen(buf)+1;
	}
	break;

	case IP_VS_SO_GET_INFO:
	{
		struct ip_vs_getinfo info;
		info.version = IP_VS_VERSION_CODE;
		info.size = ip_vs_conn_tab_size;
		info.num_services = ipvs->num_services;
		if (copy_to_user(user, &info, sizeof(info)) != 0)
			ret = -EFAULT;
	}
	break;

	case IP_VS_SO_GET_SERVICES:
	{
		struct ip_vs_get_services *get;
		int size;

		get = (struct ip_vs_get_services *)arg;
		size = sizeof(*get) +
			sizeof(struct ip_vs_service_entry) * get->num_services;
		if (*len != size) {
			pr_err(""length: %u != %u\n"", *len, size);
			ret = -EINVAL;
			goto out;
		}
		ret = __ip_vs_get_service_entries(net, get, user);
	}
	break;

	case IP_VS_SO_GET_SERVICE:
	{
		struct ip_vs_service_entry *entry;
		struct ip_vs_service *svc;
		union nf_inet_addr addr;

		entry = (struct ip_vs_service_entry *)arg;
		addr.ip = entry->addr;
		if (entry->fwmark)
			svc = __ip_vs_svc_fwm_find(net, AF_INET, entry->fwmark);
		else
			svc = __ip_vs_service_find(net, AF_INET,
						   entry->protocol, &addr,
						   entry->port);
		if (svc) {
			ip_vs_copy_service(entry, svc);
			if (copy_to_user(user, entry, sizeof(*entry)) != 0)
				ret = -EFAULT;
		} else
			ret = -ESRCH;
	}
	break;

	case IP_VS_SO_GET_DESTS:
	{
		struct ip_vs_get_dests *get;
		int size;

		get = (struct ip_vs_get_dests *)arg;
		size = sizeof(*get) +
			sizeof(struct ip_vs_dest_entry) * get->num_dests;
		if (*len != size) {
			pr_err(""length: %u != %u\n"", *len, size);
			ret = -EINVAL;
			goto out;
		}
		ret = __ip_vs_get_dest_entries(net, get, user);
	}
	break;

	case IP_VS_SO_GET_TIMEOUT:
 	{
 		struct ip_vs_timeout_user t;
 
 		__ip_vs_get_timeouts(net, &t);
 		if (copy_to_user(user, &t, sizeof(t)) != 0)
 			ret = -EFAULT;
	}
	break;

	default:
		ret = -EINVAL;
	}

out:
	mutex_unlock(&__ip_vs_mutex);
	return ret;
}
","do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)
{
	unsigned char arg[128];
	int ret = 0;
	unsigned int copylen;
	struct net *net = sock_net(sk);
	struct netns_ipvs *ipvs = net_ipvs(net);

	BUG_ON(!net);
	if (!capable(CAP_NET_ADMIN))
		return -EPERM;

	if (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX)
		return -EINVAL;

	if (*len < get_arglen[GET_CMDID(cmd)]) {
		pr_err(""get_ctl: len %u < %u\n"",
		       *len, get_arglen[GET_CMDID(cmd)]);
		return -EINVAL;
	}

	copylen = get_arglen[GET_CMDID(cmd)];
	if (copylen > 128)
		return -EINVAL;

	if (copy_from_user(arg, user, copylen) != 0)
		return -EFAULT;
	/*
	 * Handle daemons first since it has its own locking
	 */
	if (cmd == IP_VS_SO_GET_DAEMON) {
		struct ip_vs_daemon_user d[2];

		memset(&d, 0, sizeof(d));
		if (mutex_lock_interruptible(&ipvs->sync_mutex))
			return -ERESTARTSYS;

		if (ipvs->sync_state & IP_VS_STATE_MASTER) {
			d[0].state = IP_VS_STATE_MASTER;
			strlcpy(d[0].mcast_ifn, ipvs->master_mcast_ifn,
				sizeof(d[0].mcast_ifn));
			d[0].syncid = ipvs->master_syncid;
		}
		if (ipvs->sync_state & IP_VS_STATE_BACKUP) {
			d[1].state = IP_VS_STATE_BACKUP;
			strlcpy(d[1].mcast_ifn, ipvs->backup_mcast_ifn,
				sizeof(d[1].mcast_ifn));
			d[1].syncid = ipvs->backup_syncid;
		}
		if (copy_to_user(user, &d, sizeof(d)) != 0)
			ret = -EFAULT;
		mutex_unlock(&ipvs->sync_mutex);
		return ret;
	}

	if (mutex_lock_interruptible(&__ip_vs_mutex))
		return -ERESTARTSYS;

	switch (cmd) {
	case IP_VS_SO_GET_VERSION:
	{
		char buf[64];

		sprintf(buf, ""IP Virtual Server version %d.%d.%d (size=%d)"",
			NVERSION(IP_VS_VERSION_CODE), ip_vs_conn_tab_size);
		if (copy_to_user(user, buf, strlen(buf)+1) != 0) {
			ret = -EFAULT;
			goto out;
		}
		*len = strlen(buf)+1;
	}
	break;

	case IP_VS_SO_GET_INFO:
	{
		struct ip_vs_getinfo info;
		info.version = IP_VS_VERSION_CODE;
		info.size = ip_vs_conn_tab_size;
		info.num_services = ipvs->num_services;
		if (copy_to_user(user, &info, sizeof(info)) != 0)
			ret = -EFAULT;
	}
	break;

	case IP_VS_SO_GET_SERVICES:
	{
		struct ip_vs_get_services *get;
		int size;

		get = (struct ip_vs_get_services *)arg;
		size = sizeof(*get) +
			sizeof(struct ip_vs_service_entry) * get->num_services;
		if (*len != size) {
			pr_err(""length: %u != %u\n"", *len, size);
			ret = -EINVAL;
			goto out;
		}
		ret = __ip_vs_get_service_entries(net, get, user);
	}
	break;

	case IP_VS_SO_GET_SERVICE:
	{
		struct ip_vs_service_entry *entry;
		struct ip_vs_service *svc;
		union nf_inet_addr addr;

		entry = (struct ip_vs_service_entry *)arg;
		addr.ip = entry->addr;
		if (entry->fwmark)
			svc = __ip_vs_svc_fwm_find(net, AF_INET, entry->fwmark);
		else
			svc = __ip_vs_service_find(net, AF_INET,
						   entry->protocol, &addr,
						   entry->port);
		if (svc) {
			ip_vs_copy_service(entry, svc);
			if (copy_to_user(user, entry, sizeof(*entry)) != 0)
				ret = -EFAULT;
		} else
			ret = -ESRCH;
	}
	break;

	case IP_VS_SO_GET_DESTS:
	{
		struct ip_vs_get_dests *get;
		int size;

		get = (struct ip_vs_get_dests *)arg;
		size = sizeof(*get) +
			sizeof(struct ip_vs_dest_entry) * get->num_dests;
		if (*len != size) {
			pr_err(""length: %u != %u\n"", *len, size);
			ret = -EINVAL;
			goto out;
		}
		ret = __ip_vs_get_dest_entries(net, get, user);
	}
	break;

	case IP_VS_SO_GET_TIMEOUT:
 	{
 		struct ip_vs_timeout_user t;
 
		memset(&t, 0, sizeof(t));
 		__ip_vs_get_timeouts(net, &t);
 		if (copy_to_user(user, &t, sizeof(t)) != 0)
 			ret = -EFAULT;
	}
	break;

	default:
		ret = -EINVAL;
	}

out:
	mutex_unlock(&__ip_vs_mutex);
	return ret;
}
","The `do_ip_vs_get_ctl` function is designed to handle control commands related to IP Virtual Server (IPVS) functionality in a network socket context. It first checks for administrative permissions and validates the command and length of the user-provided data. Depending on the command, it retrieves various information such as daemon states, version details, service entries, destination entries, and timeout settings, copying the results back to the user space. The function employs mutexes for thread safety during data access and returns appropriate error codes for permission issues, invalid commands, or data transfer failures.","The provided code implements a function that processes control commands for managing an IP Virtual Server within a network socket. It verifies administrative permissions and checks the validity of the command and data length before proceeding. Depending on the command, it retrieves and returns various types of information, such as daemon states, version details, service and destination entries, and timeout settings, ensuring safe data transfer between kernel and user space. The function also incorporates mechanisms to handle concurrent access, returning appropriate error codes for issues like permission denial, invalid commands, or data transfer failures.","The vulnerability in the original code arises from the potential information leak when the `__ip_vs_get_timeouts()` function is called without fully initializing the timeout structure. If neither TCP nor UDP protocols are configured, this function may leave parts of the structure uninitialized, allowing up to 12 bytes of sensitive kernel stack data to be copied to user space. The fix involves adding an explicit memory zeroing operation using `memset()` before invoking `__ip_vs_get_timeouts()`, ensuring that the entire structure is initialized to zero, thus preventing any leakage of uninitialized data to userland.","The vulnerability in the original code stems from an information leak that occurs when a specific structure is not fully initialized before being copied to user space. If certain protocol configurations are not enabled, the structure may contain uninitialized data, potentially exposing sensitive information from the kernel stack. The fix addresses this issue by introducing a memory-clearing operation prior to populating the structure, ensuring that all fields are set to zero. This prevents any leakage of residual data, thereby enhancing the security of the data being transferred to userland.","The vulnerability was fixed by adding an explicit `memset()` operation to zero out the timeout structure before it is passed to the `__ip_vs_get_timeouts()` function. This ensures that all fields in the structure are initialized to zero, preventing any uninitialized data from being copied to user space. By doing this, the code eliminates the risk of leaking up to 12 bytes of sensitive kernel stack information when the configurations for TCP or UDP protocols are not set. This change effectively safeguards against information leaks and enhances the overall security of the data transfer process.","The vulnerability was addressed by incorporating a memory-clearing operation to ensure that the structure intended for user space transfer is fully initialized to zero. This step prevents any uninitialized data from being included in the structure, which could potentially expose sensitive information from the kernel stack. By ensuring that all fields are set to a known state before the data is copied, the fix effectively eliminates the risk of leaking residual data, thereby enhancing the security of the information being shared with user space and preventing unauthorized access to kernel memory.","5,5","5,5","4, 4","5, 5"
43,43,179361,179361,,Local,Not required,,CVE-2012-6537,https://www.cvedetails.com/cve/CVE-2012-6537/,CWE-200,Medium,Partial,,,2013-03-15,1.9,"net/xfrm/xfrm_user.c in the Linux kernel before 3.6 does not initialize certain structures, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability.",2019-04-22,+Info ,1,https://github.com/torvalds/linux/commit/f778a636713a435d3a922c60b1622a91136560c1,f778a636713a435d3a922c60b1622a91136560c1,"xfrm_user: fix info leak in copy_to_user_state()

The memory reserved to dump the xfrm state includes the padding bytes of
struct xfrm_usersa_info added by the compiler for alignment (7 for
amd64, 3 for i386). Add an explicit memset(0) before filling the buffer
to avoid the info leak.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Acked-by: Steffen Klassert <steffen.klassert@secunet.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/xfrm/xfrm_user.c,"{""sha"": ""d585459dc8bb541f6c6e115dd585fbd04bf6ded6"", ""filename"": ""net/xfrm/xfrm_user.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/f778a636713a435d3a922c60b1622a91136560c1/net/xfrm/xfrm_user.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f778a636713a435d3a922c60b1622a91136560c1/net/xfrm/xfrm_user.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/xfrm/xfrm_user.c?ref=f778a636713a435d3a922c60b1622a91136560c1"", ""patch"": ""@@ -689,6 +689,7 @@ static int xfrm_del_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\n \n static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n {\n+\tmemset(p, 0, sizeof(*p));\n \tmemcpy(&p->id, &x->id, sizeof(p->id));\n \tmemcpy(&p->sel, &x->sel, sizeof(p->sel));\n \tmemcpy(&p->lft, &x->lft, sizeof(p->lft));""}"," static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)
 {
	memset(p, 0, sizeof(*p));
 	memcpy(&p->id, &x->id, sizeof(p->id));
 	memcpy(&p->sel, &x->sel, sizeof(p->sel));
 	memcpy(&p->lft, &x->lft, sizeof(p->lft));
	memcpy(&p->curlft, &x->curlft, sizeof(p->curlft));
	memcpy(&p->stats, &x->stats, sizeof(p->stats));
	memcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));
	p->mode = x->props.mode;
	p->replay_window = x->props.replay_window;
	p->reqid = x->props.reqid;
	p->family = x->props.family;
	p->flags = x->props.flags;
	p->seq = x->km.seq;
}
"," static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)
 {
 	memcpy(&p->id, &x->id, sizeof(p->id));
 	memcpy(&p->sel, &x->sel, sizeof(p->sel));
 	memcpy(&p->lft, &x->lft, sizeof(p->lft));
	memcpy(&p->curlft, &x->curlft, sizeof(p->curlft));
	memcpy(&p->stats, &x->stats, sizeof(p->stats));
	memcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));
	p->mode = x->props.mode;
	p->replay_window = x->props.replay_window;
	p->reqid = x->props.reqid;
	p->family = x->props.family;
	p->flags = x->props.flags;
	p->seq = x->km.seq;
}
",C,"	memset(p, 0, sizeof(*p));
",,,"@@ -689,6 +689,7 @@ static int xfrm_del_sa(struct sk_buff *skb, struct nlmsghdr *nlh,
 
 static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)
 {
+	memset(p, 0, sizeof(*p));
 	memcpy(&p->id, &x->id, sizeof(p->id));
 	memcpy(&p->sel, &x->sel, sizeof(p->sel));
 	memcpy(&p->lft, &x->lft, sizeof(p->lft));",linux,f778a636713a435d3a922c60b1622a91136560c1,4c87308bdea31a7b4828a51f6156e6f721a1fcc9,1," static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)
 {
//fix_flaw_line_below:
//	memset(p, 0, sizeof(*p));
 	memcpy(&p->id, &x->id, sizeof(p->id));
 	memcpy(&p->sel, &x->sel, sizeof(p->sel));
 	memcpy(&p->lft, &x->lft, sizeof(p->lft));
	memcpy(&p->curlft, &x->curlft, sizeof(p->curlft));
	memcpy(&p->stats, &x->stats, sizeof(p->stats));
	memcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));
	p->mode = x->props.mode;
	p->replay_window = x->props.replay_window;
	p->reqid = x->props.reqid;
	p->family = x->props.family;
	p->flags = x->props.flags;
	p->seq = x->km.seq;
}
",179361," static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)
 {
 	memcpy(&p->id, &x->id, sizeof(p->id));
 	memcpy(&p->sel, &x->sel, sizeof(p->sel));
 	memcpy(&p->lft, &x->lft, sizeof(p->lft));
	memcpy(&p->curlft, &x->curlft, sizeof(p->curlft));
	memcpy(&p->stats, &x->stats, sizeof(p->stats));
	memcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));
	p->mode = x->props.mode;
	p->replay_window = x->props.replay_window;
	p->reqid = x->props.reqid;
	p->family = x->props.family;
	p->flags = x->props.flags;
	p->seq = x->km.seq;
}
"," static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)
 {
	memset(p, 0, sizeof(*p));
 	memcpy(&p->id, &x->id, sizeof(p->id));
 	memcpy(&p->sel, &x->sel, sizeof(p->sel));
 	memcpy(&p->lft, &x->lft, sizeof(p->lft));
	memcpy(&p->curlft, &x->curlft, sizeof(p->curlft));
	memcpy(&p->stats, &x->stats, sizeof(p->stats));
	memcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));
	p->mode = x->props.mode;
	p->replay_window = x->props.replay_window;
	p->reqid = x->props.reqid;
	p->family = x->props.family;
	p->flags = x->props.flags;
	p->seq = x->km.seq;
}
","The `copy_to_user_state` function is designed to transfer data from a kernel-level `xfrm_state` structure to a user-level `xfrm_usersa_info` structure. It achieves this by using the `memcpy` function to copy various fields, including identifiers, selectors, lifetimes, statistics, and source addresses, ensuring that the user-space structure accurately reflects the state of the corresponding kernel structure. Additionally, it directly assigns several properties such as mode, replay window, request ID, address family, flags, and sequence number from the `xfrm_state` to the `xfrm_usersa_info`, facilitating communication between kernel and user space in a secure manner.","The provided code defines a function that facilitates the transfer of data from a kernel-level structure to a user-level structure, ensuring that essential information is accurately copied. It utilizes memory copying to replicate various attributes, including identifiers, selectors, lifetimes, statistics, and source addresses, thereby maintaining consistency between the two structures. Additionally, specific properties such as operational mode, replay window, request identification, address family, flags, and sequence number are directly assigned, enabling effective communication and data sharing between the kernel and user space while adhering to security protocols.","The vulnerability in the original code stemmed from the potential leakage of uninitialized memory, specifically the padding bytes in the user-level structure, which could contain sensitive information. This risk arose because the function directly copied data from the kernel structure without first clearing the user structure. The fix involved adding a `memset(p, 0, sizeof(*p));` line at the beginning of the function, which initializes the entire user structure to zero, effectively eliminating any residual data from previous uses and preventing any unintended information disclosure when the user structure is accessed.","The vulnerability in the original code was due to the potential exposure of uninitialized memory, specifically the padding bytes added by the compiler for alignment purposes. This could lead to sensitive information being unintentionally revealed when the user-level structure was accessed, as it might contain remnants of previous data. The fix involved initializing the entire user structure to zero before populating it with new data. This explicit clearing of memory ensured that any leftover data was removed, thereby preventing any information leakage and enhancing the security of the data transfer process.","The vulnerability was fixed by adding a `memset(p, 0, sizeof(*p));` line at the beginning of the `copy_to_user_state` function. This line initializes the entire user structure to zero, effectively clearing any uninitialized memory, including the padding bytes that could contain sensitive information. By ensuring that the user structure is fully reset before copying data from the kernel structure, the fix prevents any potential information leakage that could occur when accessing the user structure. This change enhances the security of the data transfer process by eliminating the risk of exposing residual data.","The vulnerability was addressed by incorporating a memory initialization step at the start of the function, which sets the entire user structure to zero. This action effectively clears any uninitialized memory, including any padding that may have been added by the compiler, which could inadvertently contain sensitive information from previous operations. By ensuring that the user structure is fully reset before populating it with new data, the fix prevents any potential leakage of residual data, thereby enhancing the security of the data transfer process and safeguarding against unintended information exposure.","5,5","5,5","4,4","5,5"
44,44,179370,179370,,Local,Not required,,CVE-2012-4530,https://www.cvedetails.com/cve/CVE-2012-4530/,CWE-200,Low,Partial,,,2013-02-17,2.1,"The load_script function in fs/binfmt_script.c in the Linux kernel before 3.7.2 does not properly handle recursion, which allows local users to obtain sensitive information from kernel stack memory via a crafted application.",2013-06-04,+Info ,3,https://github.com/torvalds/linux/commit/b66c5984017533316fd1951770302649baf1aa33,b66c5984017533316fd1951770302649baf1aa33,"exec: do not leave bprm->interp on stack

If a series of scripts are executed, each triggering module loading via
unprintable bytes in the script header, kernel stack contents can leak
into the command line.

Normally execution of binfmt_script and binfmt_misc happens recursively.
However, when modules are enabled, and unprintable bytes exist in the
bprm->buf, execution will restart after attempting to load matching
binfmt modules.  Unfortunately, the logic in binfmt_script and
binfmt_misc does not expect to get restarted.  They leave bprm->interp
pointing to their local stack.  This means on restart bprm->interp is
left pointing into unused stack memory which can then be copied into the
userspace argv areas.

After additional study, it seems that both recursion and restart remains
the desirable way to handle exec with scripts, misc, and modules.  As
such, we need to protect the changes to interp.

This changes the logic to require allocation for any changes to the
bprm->interp.  To avoid adding a new kmalloc to every exec, the default
value is left as-is.  Only when passing through binfmt_script or
binfmt_misc does an allocation take place.

For a proof of concept, see DoTest.sh from:

   http://www.halfdog.net/Security/2012/LinuxKernelBinfmtScriptStackDataDisclosure/

Signed-off-by: Kees Cook <keescook@chromium.org>
Cc: halfdog <me@halfdog.net>
Cc: P J P <ppandit@redhat.com>
Cc: Alexander Viro <viro@zeniv.linux.org.uk>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",1,fs/binfmt_script.c,"{""sha"": ""0c8869fdd14ebf9291eb700ccd099c910584910d"", ""filename"": ""fs/binfmt_misc.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/b66c5984017533316fd1951770302649baf1aa33/fs/binfmt_misc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/b66c5984017533316fd1951770302649baf1aa33/fs/binfmt_misc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/binfmt_misc.c?ref=b66c5984017533316fd1951770302649baf1aa33"", ""patch"": ""@@ -172,7 +172,10 @@ static int load_misc_binary(struct linux_binprm *bprm)\n \t\tgoto _error;\n \tbprm->argc ++;\n \n-\tbprm->interp = iname;\t/* for binfmt_script */\n+\t/* Update interp in case binfmt_script needs it. */\n+\tretval = bprm_change_interp(iname, bprm);\n+\tif (retval < 0)\n+\t\tgoto _error;\n \n \tinterp_file = open_exec (iname);\n \tretval = PTR_ERR (interp_file);""}<_**next**_>{""sha"": ""5027a3e149222bd5945c87d9521e6e7a6108dc77"", ""filename"": ""fs/binfmt_script.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/b66c5984017533316fd1951770302649baf1aa33/fs/binfmt_script.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/b66c5984017533316fd1951770302649baf1aa33/fs/binfmt_script.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/binfmt_script.c?ref=b66c5984017533316fd1951770302649baf1aa33"", ""patch"": ""@@ -80,7 +80,9 @@ static int load_script(struct linux_binprm *bprm)\n \tretval = copy_strings_kernel(1, &i_name, bprm);\n \tif (retval) return retval; \n \tbprm->argc++;\n-\tbprm->interp = interp;\n+\tretval = bprm_change_interp(interp, bprm);\n+\tif (retval < 0)\n+\t\treturn retval;\n \n \t/*\n \t * OK, now restart the process with the interpreter's dentry.""}<_**next**_>{""sha"": ""237d5342786c43499bf32cfb831607ff8c86a728"", ""filename"": ""fs/exec.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 0, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/b66c5984017533316fd1951770302649baf1aa33/fs/exec.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/b66c5984017533316fd1951770302649baf1aa33/fs/exec.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/exec.c?ref=b66c5984017533316fd1951770302649baf1aa33"", ""patch"": ""@@ -1175,9 +1175,24 @@ void free_bprm(struct linux_binprm *bprm)\n \t\tmutex_unlock(&current->signal->cred_guard_mutex);\n \t\tabort_creds(bprm->cred);\n \t}\n+\t/* If a binfmt changed the interp, free it. */\n+\tif (bprm->interp != bprm->filename)\n+\t\tkfree(bprm->interp);\n \tkfree(bprm);\n }\n \n+int bprm_change_interp(char *interp, struct linux_binprm *bprm)\n+{\n+\t/* If a binfmt changed the interp, free it first. */\n+\tif (bprm->interp != bprm->filename)\n+\t\tkfree(bprm->interp);\n+\tbprm->interp = kstrdup(interp, GFP_KERNEL);\n+\tif (!bprm->interp)\n+\t\treturn -ENOMEM;\n+\treturn 0;\n+}\n+EXPORT_SYMBOL(bprm_change_interp);\n+\n /*\n  * install the new credentials for this executable\n  */""}<_**next**_>{""sha"": ""bdf3965f0a29a9d6b3cf9568ce58dc457de32526"", ""filename"": ""include/linux/binfmts.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/b66c5984017533316fd1951770302649baf1aa33/include/linux/binfmts.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/b66c5984017533316fd1951770302649baf1aa33/include/linux/binfmts.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/binfmts.h?ref=b66c5984017533316fd1951770302649baf1aa33"", ""patch"": ""@@ -112,6 +112,7 @@ extern int setup_arg_pages(struct linux_binprm * bprm,\n \t\t\t   unsigned long stack_top,\n \t\t\t   int executable_stack);\n extern int bprm_mm_init(struct linux_binprm *bprm);\n+extern int bprm_change_interp(char *interp, struct linux_binprm *bprm);\n extern int copy_strings_kernel(int argc, const char *const *argv,\n \t\t\t       struct linux_binprm *bprm);\n extern int prepare_bprm_creds(struct linux_binprm *bprm);""}","static int load_script(struct linux_binprm *bprm)
{
	const char *i_arg, *i_name;
	char *cp;
	struct file *file;
	char interp[BINPRM_BUF_SIZE];
	int retval;

	if ((bprm->buf[0] != '#') || (bprm->buf[1] != '!'))
		return -ENOEXEC;
	/*
	 * This section does the #! interpretation.
	 * Sorta complicated, but hopefully it will work.  -TYT
	 */

	allow_write_access(bprm->file);
	fput(bprm->file);
	bprm->file = NULL;

	bprm->buf[BINPRM_BUF_SIZE - 1] = '\0';
	if ((cp = strchr(bprm->buf, '\n')) == NULL)
		cp = bprm->buf+BINPRM_BUF_SIZE-1;
	*cp = '\0';
	while (cp > bprm->buf) {
		cp--;
		if ((*cp == ' ') || (*cp == '\t'))
			*cp = '\0';
		else
			break;
	}
	for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++);
	if (*cp == '\0') 
		return -ENOEXEC; /* No interpreter name found */
	i_name = cp;
	i_arg = NULL;
	for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++)
		/* nothing */ ;
	while ((*cp == ' ') || (*cp == '\t'))
		*cp++ = '\0';
	if (*cp)
		i_arg = cp;
	strcpy (interp, i_name);
	/*
	 * OK, we've parsed out the interpreter name and
	 * (optional) argument.
	 * Splice in (1) the interpreter's name for argv[0]
	 *           (2) (optional) argument to interpreter
	 *           (3) filename of shell script (replace argv[0])
	 *
	 * This is done in reverse order, because of how the
	 * user environment and arguments are stored.
	 */
	retval = remove_arg_zero(bprm);
	if (retval)
		return retval;
	retval = copy_strings_kernel(1, &bprm->interp, bprm);
	if (retval < 0) return retval; 
	bprm->argc++;
	if (i_arg) {
		retval = copy_strings_kernel(1, &i_arg, bprm);
		if (retval < 0) return retval; 
		bprm->argc++;
	}
 	retval = copy_strings_kernel(1, &i_name, bprm);
 	if (retval) return retval; 
 	bprm->argc++;
	retval = bprm_change_interp(interp, bprm);
	if (retval < 0)
		return retval;
 
 	/*
 	 * OK, now restart the process with the interpreter's dentry.
	 */
	file = open_exec(interp);
	if (IS_ERR(file))
		return PTR_ERR(file);

	bprm->file = file;
	retval = prepare_binprm(bprm);
	if (retval < 0)
		return retval;
	return search_binary_handler(bprm);
}
","static int load_script(struct linux_binprm *bprm)
{
	const char *i_arg, *i_name;
	char *cp;
	struct file *file;
	char interp[BINPRM_BUF_SIZE];
	int retval;

	if ((bprm->buf[0] != '#') || (bprm->buf[1] != '!'))
		return -ENOEXEC;
	/*
	 * This section does the #! interpretation.
	 * Sorta complicated, but hopefully it will work.  -TYT
	 */

	allow_write_access(bprm->file);
	fput(bprm->file);
	bprm->file = NULL;

	bprm->buf[BINPRM_BUF_SIZE - 1] = '\0';
	if ((cp = strchr(bprm->buf, '\n')) == NULL)
		cp = bprm->buf+BINPRM_BUF_SIZE-1;
	*cp = '\0';
	while (cp > bprm->buf) {
		cp--;
		if ((*cp == ' ') || (*cp == '\t'))
			*cp = '\0';
		else
			break;
	}
	for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++);
	if (*cp == '\0') 
		return -ENOEXEC; /* No interpreter name found */
	i_name = cp;
	i_arg = NULL;
	for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++)
		/* nothing */ ;
	while ((*cp == ' ') || (*cp == '\t'))
		*cp++ = '\0';
	if (*cp)
		i_arg = cp;
	strcpy (interp, i_name);
	/*
	 * OK, we've parsed out the interpreter name and
	 * (optional) argument.
	 * Splice in (1) the interpreter's name for argv[0]
	 *           (2) (optional) argument to interpreter
	 *           (3) filename of shell script (replace argv[0])
	 *
	 * This is done in reverse order, because of how the
	 * user environment and arguments are stored.
	 */
	retval = remove_arg_zero(bprm);
	if (retval)
		return retval;
	retval = copy_strings_kernel(1, &bprm->interp, bprm);
	if (retval < 0) return retval; 
	bprm->argc++;
	if (i_arg) {
		retval = copy_strings_kernel(1, &i_arg, bprm);
		if (retval < 0) return retval; 
		bprm->argc++;
	}
 	retval = copy_strings_kernel(1, &i_name, bprm);
 	if (retval) return retval; 
 	bprm->argc++;
	bprm->interp = interp;
 
 	/*
 	 * OK, now restart the process with the interpreter's dentry.
	 */
	file = open_exec(interp);
	if (IS_ERR(file))
		return PTR_ERR(file);

	bprm->file = file;
	retval = prepare_binprm(bprm);
	if (retval < 0)
		return retval;
	return search_binary_handler(bprm);
}
",C,"	retval = bprm_change_interp(interp, bprm);
	if (retval < 0)
		return retval;
","	bprm->interp = interp;
",,"@@ -80,7 +80,9 @@ static int load_script(struct linux_binprm *bprm)
 	retval = copy_strings_kernel(1, &i_name, bprm);
 	if (retval) return retval; 
 	bprm->argc++;
-	bprm->interp = interp;
+	retval = bprm_change_interp(interp, bprm);
+	if (retval < 0)
+		return retval;
 
 	/*
 	 * OK, now restart the process with the interpreter's dentry.",linux,b66c5984017533316fd1951770302649baf1aa33,9f9c9cbb60576a1518d0bf93fb8e499cffccf377,1,"static int load_script(struct linux_binprm *bprm)
{
	const char *i_arg, *i_name;
	char *cp;
	struct file *file;
	char interp[BINPRM_BUF_SIZE];
	int retval;

	if ((bprm->buf[0] != '#') || (bprm->buf[1] != '!'))
		return -ENOEXEC;
	/*
	 * This section does the #! interpretation.
	 * Sorta complicated, but hopefully it will work.  -TYT
	 */

	allow_write_access(bprm->file);
	fput(bprm->file);
	bprm->file = NULL;

	bprm->buf[BINPRM_BUF_SIZE - 1] = '\0';
	if ((cp = strchr(bprm->buf, '\n')) == NULL)
		cp = bprm->buf+BINPRM_BUF_SIZE-1;
	*cp = '\0';
	while (cp > bprm->buf) {
		cp--;
		if ((*cp == ' ') || (*cp == '\t'))
			*cp = '\0';
		else
			break;
	}
	for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++);
	if (*cp == '\0') 
		return -ENOEXEC; /* No interpreter name found */
	i_name = cp;
	i_arg = NULL;
	for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++)
		/* nothing */ ;
	while ((*cp == ' ') || (*cp == '\t'))
		*cp++ = '\0';
	if (*cp)
		i_arg = cp;
	strcpy (interp, i_name);
	/*
	 * OK, we've parsed out the interpreter name and
	 * (optional) argument.
	 * Splice in (1) the interpreter's name for argv[0]
	 *           (2) (optional) argument to interpreter
	 *           (3) filename of shell script (replace argv[0])
	 *
	 * This is done in reverse order, because of how the
	 * user environment and arguments are stored.
	 */
	retval = remove_arg_zero(bprm);
	if (retval)
		return retval;
	retval = copy_strings_kernel(1, &bprm->interp, bprm);
	if (retval < 0) return retval; 
	bprm->argc++;
	if (i_arg) {
		retval = copy_strings_kernel(1, &i_arg, bprm);
		if (retval < 0) return retval; 
		bprm->argc++;
	}
 	retval = copy_strings_kernel(1, &i_name, bprm);
 	if (retval) return retval; 
 	bprm->argc++;
//flaw_line_below:
	bprm->interp = interp;
//fix_flaw_line_below:
//	retval = bprm_change_interp(interp, bprm);
//fix_flaw_line_below:
//	if (retval < 0)
//fix_flaw_line_below:
//		return retval;
 
 	/*
 	 * OK, now restart the process with the interpreter's dentry.
	 */
	file = open_exec(interp);
	if (IS_ERR(file))
		return PTR_ERR(file);

	bprm->file = file;
	retval = prepare_binprm(bprm);
	if (retval < 0)
		return retval;
	return search_binary_handler(bprm);
}
",179370,"static int load_script(struct linux_binprm *bprm)
{
	const char *i_arg, *i_name;
	char *cp;
	struct file *file;
	char interp[BINPRM_BUF_SIZE];
	int retval;

	if ((bprm->buf[0] != '#') || (bprm->buf[1] != '!'))
		return -ENOEXEC;
	/*
	 * This section does the #! interpretation.
	 * Sorta complicated, but hopefully it will work.  -TYT
	 */

	allow_write_access(bprm->file);
	fput(bprm->file);
	bprm->file = NULL;

	bprm->buf[BINPRM_BUF_SIZE - 1] = '\0';
	if ((cp = strchr(bprm->buf, '\n')) == NULL)
		cp = bprm->buf+BINPRM_BUF_SIZE-1;
	*cp = '\0';
	while (cp > bprm->buf) {
		cp--;
		if ((*cp == ' ') || (*cp == '\t'))
			*cp = '\0';
		else
			break;
	}
	for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++);
	if (*cp == '\0') 
		return -ENOEXEC; /* No interpreter name found */
	i_name = cp;
	i_arg = NULL;
	for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++)
		/* nothing */ ;
	while ((*cp == ' ') || (*cp == '\t'))
		*cp++ = '\0';
	if (*cp)
		i_arg = cp;
	strcpy (interp, i_name);
	/*
	 * OK, we've parsed out the interpreter name and
	 * (optional) argument.
	 * Splice in (1) the interpreter's name for argv[0]
	 *           (2) (optional) argument to interpreter
	 *           (3) filename of shell script (replace argv[0])
	 *
	 * This is done in reverse order, because of how the
	 * user environment and arguments are stored.
	 */
	retval = remove_arg_zero(bprm);
	if (retval)
		return retval;
	retval = copy_strings_kernel(1, &bprm->interp, bprm);
	if (retval < 0) return retval; 
	bprm->argc++;
	if (i_arg) {
		retval = copy_strings_kernel(1, &i_arg, bprm);
		if (retval < 0) return retval; 
		bprm->argc++;
	}
 	retval = copy_strings_kernel(1, &i_name, bprm);
 	if (retval) return retval; 
 	bprm->argc++;
	bprm->interp = interp;
 
 	/*
 	 * OK, now restart the process with the interpreter's dentry.
	 */
	file = open_exec(interp);
	if (IS_ERR(file))
		return PTR_ERR(file);

	bprm->file = file;
	retval = prepare_binprm(bprm);
	if (retval < 0)
		return retval;
	return search_binary_handler(bprm);
}
","static int load_script(struct linux_binprm *bprm)
{
	const char *i_arg, *i_name;
	char *cp;
	struct file *file;
	char interp[BINPRM_BUF_SIZE];
	int retval;

	if ((bprm->buf[0] != '#') || (bprm->buf[1] != '!'))
		return -ENOEXEC;
	/*
	 * This section does the #! interpretation.
	 * Sorta complicated, but hopefully it will work.  -TYT
	 */

	allow_write_access(bprm->file);
	fput(bprm->file);
	bprm->file = NULL;

	bprm->buf[BINPRM_BUF_SIZE - 1] = '\0';
	if ((cp = strchr(bprm->buf, '\n')) == NULL)
		cp = bprm->buf+BINPRM_BUF_SIZE-1;
	*cp = '\0';
	while (cp > bprm->buf) {
		cp--;
		if ((*cp == ' ') || (*cp == '\t'))
			*cp = '\0';
		else
			break;
	}
	for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++);
	if (*cp == '\0') 
		return -ENOEXEC; /* No interpreter name found */
	i_name = cp;
	i_arg = NULL;
	for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++)
		/* nothing */ ;
	while ((*cp == ' ') || (*cp == '\t'))
		*cp++ = '\0';
	if (*cp)
		i_arg = cp;
	strcpy (interp, i_name);
	/*
	 * OK, we've parsed out the interpreter name and
	 * (optional) argument.
	 * Splice in (1) the interpreter's name for argv[0]
	 *           (2) (optional) argument to interpreter
	 *           (3) filename of shell script (replace argv[0])
	 *
	 * This is done in reverse order, because of how the
	 * user environment and arguments are stored.
	 */
	retval = remove_arg_zero(bprm);
	if (retval)
		return retval;
	retval = copy_strings_kernel(1, &bprm->interp, bprm);
	if (retval < 0) return retval; 
	bprm->argc++;
	if (i_arg) {
		retval = copy_strings_kernel(1, &i_arg, bprm);
		if (retval < 0) return retval; 
		bprm->argc++;
	}
 	retval = copy_strings_kernel(1, &i_name, bprm);
 	if (retval) return retval; 
 	bprm->argc++;
	retval = bprm_change_interp(interp, bprm);
	if (retval < 0)
		return retval;
 
 	/*
 	 * OK, now restart the process with the interpreter's dentry.
	 */
	file = open_exec(interp);
	if (IS_ERR(file))
		return PTR_ERR(file);

	bprm->file = file;
	retval = prepare_binprm(bprm);
	if (retval < 0)
		return retval;
	return search_binary_handler(bprm);
}
","The `load_script` function processes a script file in a Linux environment, specifically handling the shebang (`#!`) mechanism to determine the appropriate interpreter for executing the script. It first checks if the script starts with `#!`, then extracts the interpreter's name and any optional arguments from the script's initial line. After cleaning up the input, it prepares the argument list for the interpreter, updating the binary parameters structure (`bprm`). The function then attempts to open the specified interpreter executable, prepares the binary parameters for execution, and finally invokes the appropriate binary handler to execute the script with the specified interpreter.","The code defines a function that processes a script file to identify and execute the appropriate interpreter specified in the script's shebang line. It first verifies the presence of the shebang, then extracts the interpreter's name and any optional arguments from the first line of the script. After cleaning up the input, it prepares the argument list for the interpreter and updates the execution parameters. The function attempts to open the interpreter executable, prepares the necessary parameters for execution, and ultimately invokes the appropriate handler to run the script with the specified interpreter.","The vulnerability in the original code arises from the handling of the interpreter string, which could point to local stack memory after a recursive execution of script binaries. If unprintable bytes were present in the script header, this could lead to the leakage of kernel stack contents into user space, compromising security. The fix involves modifying the logic to ensure that any changes to the interpreter string require dynamic memory allocation, preventing it from pointing to stack memory. This change ensures that the interpreter string is safely managed, eliminating the risk of exposing sensitive data during recursive executions.","The vulnerability in the original code stems from the handling of the interpreter string during recursive executions of script binaries, which could inadvertently point to local stack memory. This situation arises when unprintable bytes are present in the script header, leading to potential leakage of kernel stack contents into user space. The fix addresses this issue by ensuring that any modifications to the interpreter string require dynamic memory allocation, thereby preventing it from referencing stack memory. This change safeguards against exposing sensitive data during recursive executions while maintaining the desired functionality of script handling.","The vulnerability was fixed by modifying the logic surrounding the handling of the interpreter string, specifically by requiring dynamic memory allocation for any changes to `bprm->interp`. This ensures that the interpreter string does not point to local stack memory, which could lead to data leakage. The code retains the default value of `bprm->interp` to avoid unnecessary allocations during every execution. However, when passing through the script handling functions, such as `binfmt_script` or `binfmt_misc`, an allocation is performed to securely manage the interpreter string, thus preventing exposure of sensitive stack data.","The vulnerability was addressed by implementing a requirement for dynamic memory allocation whenever the interpreter string is modified. This change ensures that the interpreter string does not reference local stack memory, which could lead to the unintended exposure of sensitive data during recursive executions. By maintaining the default value to avoid unnecessary allocations in typical scenarios, the code only allocates memory when necessary, specifically during script handling. This approach effectively mitigates the risk of data leakage while preserving the intended functionality of executing scripts securely.","4, 4","5,5","4,4","4,4"
45,45,179409,179409,,Local,Not required,,CVE-2014-9419,https://www.cvedetails.com/cve/CVE-2014-9419/,CWE-200,Low,Partial,,,2014-12-25,2.1,"The __switch_to function in arch/x86/kernel/process_64.c in the Linux kernel through 3.18.1 does not ensure that Thread Local Storage (TLS) descriptors are loaded before proceeding with other steps, which makes it easier for local users to bypass the ASLR protection mechanism via a crafted application that reads a TLS base address.",2018-01-04,Bypass +Info ,73,https://github.com/torvalds/linux/commit/f647d7c155f069c1a068030255c300663516420e,f647d7c155f069c1a068030255c300663516420e,"x86_64, switch_to(): Load TLS descriptors before switching DS and ES

Otherwise, if buggy user code points DS or ES into the TLS
array, they would be corrupted after a context switch.

This also significantly improves the comments and documents some
gotchas in the code.

Before this patch, the both tests below failed.  With this
patch, the es test passes, although the gsbase test still fails.

 ----- begin es test -----

/*
 * Copyright (c) 2014 Andy Lutomirski
 * GPL v2
 */

static unsigned short GDT3(int idx)
{
	return (idx << 3) | 3;
}

static int create_tls(int idx, unsigned int base)
{
	struct user_desc desc = {
		.entry_number    = idx,
		.base_addr       = base,
		.limit           = 0xfffff,
		.seg_32bit       = 1,
		.contents        = 0, /* Data, grow-up */
		.read_exec_only  = 0,
		.limit_in_pages  = 1,
		.seg_not_present = 0,
		.useable         = 0,
	};

	if (syscall(SYS_set_thread_area, &desc) != 0)
		err(1, ""set_thread_area"");

	return desc.entry_number;
}

int main()
{
	int idx = create_tls(-1, 0);
	printf(""Allocated GDT index %d\n"", idx);

	unsigned short orig_es;
	asm volatile (""mov %%es,%0"" : ""=rm"" (orig_es));

	int errors = 0;
	int total = 1000;
	for (int i = 0; i < total; i++) {
		asm volatile (""mov %0,%%es"" : : ""rm"" (GDT3(idx)));
		usleep(100);

		unsigned short es;
		asm volatile (""mov %%es,%0"" : ""=rm"" (es));
		asm volatile (""mov %0,%%es"" : : ""rm"" (orig_es));
		if (es != GDT3(idx)) {
			if (errors == 0)
				printf(""[FAIL]\tES changed from 0x%hx to 0x%hx\n"",
				       GDT3(idx), es);
			errors++;
		}
	}

	if (errors) {
		printf(""[FAIL]\tES was corrupted %d/%d times\n"", errors, total);
		return 1;
	} else {
		printf(""[OK]\tES was preserved\n"");
		return 0;
	}
}

 ----- end es test -----

 ----- begin gsbase test -----

/*
 * gsbase.c, a gsbase test
 * Copyright (c) 2014 Andy Lutomirski
 * GPL v2
 */

static unsigned char *testptr, *testptr2;

static unsigned char read_gs_testvals(void)
{
	unsigned char ret;
	asm volatile (""movb %%gs:%1, %0"" : ""=r"" (ret) : ""m"" (*testptr));
	return ret;
}

int main()
{
	int errors = 0;

	testptr = mmap((void *)0x200000000UL, 1, PROT_READ | PROT_WRITE,
		       MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0);
	if (testptr == MAP_FAILED)
		err(1, ""mmap"");

	testptr2 = mmap((void *)0x300000000UL, 1, PROT_READ | PROT_WRITE,
		       MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0);
	if (testptr2 == MAP_FAILED)
		err(1, ""mmap"");

	*testptr = 0;
	*testptr2 = 1;

	if (syscall(SYS_arch_prctl, ARCH_SET_GS,
		    (unsigned long)testptr2 - (unsigned long)testptr) != 0)
		err(1, ""ARCH_SET_GS"");

	usleep(100);

	if (read_gs_testvals() == 1) {
		printf(""[OK]\tARCH_SET_GS worked\n"");
	} else {
		printf(""[FAIL]\tARCH_SET_GS failed\n"");
		errors++;
	}

	asm volatile (""mov %0,%%gs"" : : ""r"" (0));

	if (read_gs_testvals() == 0) {
		printf(""[OK]\tWriting 0 to gs worked\n"");
	} else {
		printf(""[FAIL]\tWriting 0 to gs failed\n"");
		errors++;
	}

	usleep(100);

	if (read_gs_testvals() == 0) {
		printf(""[OK]\tgsbase is still zero\n"");
	} else {
		printf(""[FAIL]\tgsbase was corrupted\n"");
		errors++;
	}

	return errors == 0 ? 0 : 1;
}

 ----- end gsbase test -----

Signed-off-by: Andy Lutomirski <luto@amacapital.net>
Cc: <stable@vger.kernel.org>
Cc: Andi Kleen <andi@firstfloor.org>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Link: http://lkml.kernel.org/r/509d27c9fec78217691c3dad91cec87e1006b34a.1418075657.git.luto@amacapital.net
Signed-off-by: Ingo Molnar <mingo@kernel.org>",25,arch/x86/kernel/process_64.c,"{""sha"": ""5a2c02913af3bd43dfc1be40947f176e0542422f"", ""filename"": ""arch/x86/kernel/process_64.c"", ""status"": ""modified"", ""additions"": 73, ""deletions"": 28, ""changes"": 101, ""blob_url"": ""https://github.com/torvalds/linux/blob/f647d7c155f069c1a068030255c300663516420e/arch/x86/kernel/process_64.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f647d7c155f069c1a068030255c300663516420e/arch/x86/kernel/process_64.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kernel/process_64.c?ref=f647d7c155f069c1a068030255c300663516420e"", ""patch"": ""@@ -283,24 +283,9 @@ __switch_to(struct task_struct *prev_p, struct task_struct *next_p)\n \n \tfpu = switch_fpu_prepare(prev_p, next_p, cpu);\n \n-\t/*\n-\t * Reload esp0, LDT and the page table pointer:\n-\t */\n+\t/* Reload esp0 and ss1. */\n \tload_sp0(tss, next);\n \n-\t/*\n-\t * Switch DS and ES.\n-\t * This won't pick up thread selector changes, but I guess that is ok.\n-\t */\n-\tsavesegment(es, prev->es);\n-\tif (unlikely(next->es | prev->es))\n-\t\tloadsegment(es, next->es);\n-\n-\tsavesegment(ds, prev->ds);\n-\tif (unlikely(next->ds | prev->ds))\n-\t\tloadsegment(ds, next->ds);\n-\n-\n \t/* We must save %fs and %gs before load_TLS() because\n \t * %fs and %gs may be cleared by load_TLS().\n \t *\n@@ -309,41 +294,101 @@ __switch_to(struct task_struct *prev_p, struct task_struct *next_p)\n \tsavesegment(fs, fsindex);\n \tsavesegment(gs, gsindex);\n \n+\t/*\n+\t * Load TLS before restoring any segments so that segment loads\n+\t * reference the correct GDT entries.\n+\t */\n \tload_TLS(next, cpu);\n \n \t/*\n-\t * Leave lazy mode, flushing any hypercalls made here.\n-\t * This must be done before restoring TLS segments so\n-\t * the GDT and LDT are properly updated, and must be\n-\t * done before math_state_restore, so the TS bit is up\n-\t * to date.\n+\t * Leave lazy mode, flushing any hypercalls made here.  This\n+\t * must be done after loading TLS entries in the GDT but before\n+\t * loading segments that might reference them, and and it must\n+\t * be done before math_state_restore, so the TS bit is up to\n+\t * date.\n \t */\n \tarch_end_context_switch(next_p);\n \n+\t/* Switch DS and ES.\n+\t *\n+\t * Reading them only returns the selectors, but writing them (if\n+\t * nonzero) loads the full descriptor from the GDT or LDT.  The\n+\t * LDT for next is loaded in switch_mm, and the GDT is loaded\n+\t * above.\n+\t *\n+\t * We therefore need to write new values to the segment\n+\t * registers on every context switch unless both the new and old\n+\t * values are zero.\n+\t *\n+\t * Note that we don't need to do anything for CS and SS, as\n+\t * those are saved and restored as part of pt_regs.\n+\t */\n+\tsavesegment(es, prev->es);\n+\tif (unlikely(next->es | prev->es))\n+\t\tloadsegment(es, next->es);\n+\n+\tsavesegment(ds, prev->ds);\n+\tif (unlikely(next->ds | prev->ds))\n+\t\tloadsegment(ds, next->ds);\n+\n \t/*\n \t * Switch FS and GS.\n \t *\n-\t * Segment register != 0 always requires a reload.  Also\n-\t * reload when it has changed.  When prev process used 64bit\n-\t * base always reload to avoid an information leak.\n+\t * These are even more complicated than FS and GS: they have\n+\t * 64-bit bases are that controlled by arch_prctl.  Those bases\n+\t * only differ from the values in the GDT or LDT if the selector\n+\t * is 0.\n+\t *\n+\t * Loading the segment register resets the hidden base part of\n+\t * the register to 0 or the value from the GDT / LDT.  If the\n+\t * next base address zero, writing 0 to the segment register is\n+\t * much faster than using wrmsr to explicitly zero the base.\n+\t *\n+\t * The thread_struct.fs and thread_struct.gs values are 0\n+\t * if the fs and gs bases respectively are not overridden\n+\t * from the values implied by fsindex and gsindex.  They\n+\t * are nonzero, and store the nonzero base addresses, if\n+\t * the bases are overridden.\n+\t *\n+\t * (fs != 0 && fsindex != 0) || (gs != 0 && gsindex != 0) should\n+\t * be impossible.\n+\t *\n+\t * Therefore we need to reload the segment registers if either\n+\t * the old or new selector is nonzero, and we need to override\n+\t * the base address if next thread expects it to be overridden.\n+\t *\n+\t * This code is unnecessarily slow in the case where the old and\n+\t * new indexes are zero and the new base is nonzero -- it will\n+\t * unnecessarily write 0 to the selector before writing the new\n+\t * base address.\n+\t *\n+\t * Note: This all depends on arch_prctl being the only way that\n+\t * user code can override the segment base.  Once wrfsbase and\n+\t * wrgsbase are enabled, most of this code will need to change.\n \t */\n \tif (unlikely(fsindex | next->fsindex | prev->fs)) {\n \t\tloadsegment(fs, next->fsindex);\n+\n \t\t/*\n-\t\t * Check if the user used a selector != 0; if yes\n-\t\t *  clear 64bit base, since overloaded base is always\n-\t\t *  mapped to the Null selector\n+\t\t * If user code wrote a nonzero value to FS, then it also\n+\t\t * cleared the overridden base address.\n+\t\t *\n+\t\t * XXX: if user code wrote 0 to FS and cleared the base\n+\t\t * address itself, we won't notice and we'll incorrectly\n+\t\t * restore the prior base address next time we reschdule\n+\t\t * the process.\n \t\t */\n \t\tif (fsindex)\n \t\t\tprev->fs = 0;\n \t}\n-\t/* when next process has a 64bit base use it */\n \tif (next->fs)\n \t\twrmsrl(MSR_FS_BASE, next->fs);\n \tprev->fsindex = fsindex;\n \n \tif (unlikely(gsindex | next->gsindex | prev->gs)) {\n \t\tload_gs_index(next->gsindex);\n+\n+\t\t/* This works (and fails) the same way as fsindex above. */\n \t\tif (gsindex)\n \t\t\tprev->gs = 0;\n \t}""}","__switch_to(struct task_struct *prev_p, struct task_struct *next_p)
{
	struct thread_struct *prev = &prev_p->thread;
	struct thread_struct *next = &next_p->thread;
	int cpu = smp_processor_id();
	struct tss_struct *tss = &per_cpu(init_tss, cpu);
	unsigned fsindex, gsindex;
	fpu_switch_t fpu;
 
 	fpu = switch_fpu_prepare(prev_p, next_p, cpu);
 
	/* Reload esp0 and ss1. */
 	load_sp0(tss, next);
 
 	/* We must save %fs and %gs before load_TLS() because
 	 * %fs and %gs may be cleared by load_TLS().
 	 *
	 * (e.g. xen_load_tls())
	 */
 	savesegment(fs, fsindex);
 	savesegment(gs, gsindex);
 
	/*
	 * Load TLS before restoring any segments so that segment loads
	 * reference the correct GDT entries.
	 */
 	load_TLS(next, cpu);
 
 	/*
	 * Leave lazy mode, flushing any hypercalls made here.  This
	 * must be done after loading TLS entries in the GDT but before
	 * loading segments that might reference them, and and it must
	 * be done before math_state_restore, so the TS bit is up to
	 * date.
 	 */
 	arch_end_context_switch(next_p);
 
	/* Switch DS and ES.
	 *
	 * Reading them only returns the selectors, but writing them (if
	 * nonzero) loads the full descriptor from the GDT or LDT.  The
	 * LDT for next is loaded in switch_mm, and the GDT is loaded
	 * above.
	 *
	 * We therefore need to write new values to the segment
	 * registers on every context switch unless both the new and old
	 * values are zero.
	 *
	 * Note that we don't need to do anything for CS and SS, as
	 * those are saved and restored as part of pt_regs.
	 */
	savesegment(es, prev->es);
	if (unlikely(next->es | prev->es))
		loadsegment(es, next->es);

	savesegment(ds, prev->ds);
	if (unlikely(next->ds | prev->ds))
		loadsegment(ds, next->ds);

 	/*
 	 * Switch FS and GS.
 	 *
	 * These are even more complicated than FS and GS: they have
	 * 64-bit bases are that controlled by arch_prctl.  Those bases
	 * only differ from the values in the GDT or LDT if the selector
	 * is 0.
	 *
	 * Loading the segment register resets the hidden base part of
	 * the register to 0 or the value from the GDT / LDT.  If the
	 * next base address zero, writing 0 to the segment register is
	 * much faster than using wrmsr to explicitly zero the base.
	 *
	 * The thread_struct.fs and thread_struct.gs values are 0
	 * if the fs and gs bases respectively are not overridden
	 * from the values implied by fsindex and gsindex.  They
	 * are nonzero, and store the nonzero base addresses, if
	 * the bases are overridden.
	 *
	 * (fs != 0 && fsindex != 0) || (gs != 0 && gsindex != 0) should
	 * be impossible.
	 *
	 * Therefore we need to reload the segment registers if either
	 * the old or new selector is nonzero, and we need to override
	 * the base address if next thread expects it to be overridden.
	 *
	 * This code is unnecessarily slow in the case where the old and
	 * new indexes are zero and the new base is nonzero -- it will
	 * unnecessarily write 0 to the selector before writing the new
	 * base address.
	 *
	 * Note: This all depends on arch_prctl being the only way that
	 * user code can override the segment base.  Once wrfsbase and
	 * wrgsbase are enabled, most of this code will need to change.
 	 */
 	if (unlikely(fsindex | next->fsindex | prev->fs)) {
 		loadsegment(fs, next->fsindex);

 		/*
		 * If user code wrote a nonzero value to FS, then it also
		 * cleared the overridden base address.
		 *
		 * XXX: if user code wrote 0 to FS and cleared the base
		 * address itself, we won't notice and we'll incorrectly
		 * restore the prior base address next time we reschdule
		 * the process.
 		 */
 		if (fsindex)
 			prev->fs = 0;
 	}
 	if (next->fs)
 		wrmsrl(MSR_FS_BASE, next->fs);
 	prev->fsindex = fsindex;
 
 	if (unlikely(gsindex | next->gsindex | prev->gs)) {
 		load_gs_index(next->gsindex);

		/* This works (and fails) the same way as fsindex above. */
 		if (gsindex)
 			prev->gs = 0;
 	}
	if (next->gs)
		wrmsrl(MSR_KERNEL_GS_BASE, next->gs);
	prev->gsindex = gsindex;

	switch_fpu_finish(next_p, fpu);

	/*
	 * Switch the PDA and FPU contexts.
	 */
	prev->usersp = this_cpu_read(old_rsp);
	this_cpu_write(old_rsp, next->usersp);
	this_cpu_write(current_task, next_p);

	/*
	 * If it were not for PREEMPT_ACTIVE we could guarantee that the
	 * preempt_count of all tasks was equal here and this would not be
	 * needed.
	 */
	task_thread_info(prev_p)->saved_preempt_count = this_cpu_read(__preempt_count);
	this_cpu_write(__preempt_count, task_thread_info(next_p)->saved_preempt_count);

	this_cpu_write(kernel_stack,
		  (unsigned long)task_stack_page(next_p) +
		  THREAD_SIZE - KERNEL_STACK_OFFSET);

	/*
	 * Now maybe reload the debug registers and handle I/O bitmaps
	 */
	if (unlikely(task_thread_info(next_p)->flags & _TIF_WORK_CTXSW_NEXT ||
		     task_thread_info(prev_p)->flags & _TIF_WORK_CTXSW_PREV))
		__switch_to_xtra(prev_p, next_p, tss);

	return prev_p;
}
","__switch_to(struct task_struct *prev_p, struct task_struct *next_p)
{
	struct thread_struct *prev = &prev_p->thread;
	struct thread_struct *next = &next_p->thread;
	int cpu = smp_processor_id();
	struct tss_struct *tss = &per_cpu(init_tss, cpu);
	unsigned fsindex, gsindex;
	fpu_switch_t fpu;
 
 	fpu = switch_fpu_prepare(prev_p, next_p, cpu);
 
	/*
	 * Reload esp0, LDT and the page table pointer:
	 */
 	load_sp0(tss, next);
 
	/*
	 * Switch DS and ES.
	 * This won't pick up thread selector changes, but I guess that is ok.
	 */
	savesegment(es, prev->es);
	if (unlikely(next->es | prev->es))
		loadsegment(es, next->es);
	savesegment(ds, prev->ds);
	if (unlikely(next->ds | prev->ds))
		loadsegment(ds, next->ds);
 	/* We must save %fs and %gs before load_TLS() because
 	 * %fs and %gs may be cleared by load_TLS().
 	 *
	 * (e.g. xen_load_tls())
	 */
 	savesegment(fs, fsindex);
 	savesegment(gs, gsindex);
 
 	load_TLS(next, cpu);
 
 	/*
	 * Leave lazy mode, flushing any hypercalls made here.
	 * This must be done before restoring TLS segments so
	 * the GDT and LDT are properly updated, and must be
	 * done before math_state_restore, so the TS bit is up
	 * to date.
 	 */
 	arch_end_context_switch(next_p);
 
 	/*
 	 * Switch FS and GS.
 	 *
	 * Segment register != 0 always requires a reload.  Also
	 * reload when it has changed.  When prev process used 64bit
	 * base always reload to avoid an information leak.
 	 */
 	if (unlikely(fsindex | next->fsindex | prev->fs)) {
 		loadsegment(fs, next->fsindex);
 		/*
		 * Check if the user used a selector != 0; if yes
		 *  clear 64bit base, since overloaded base is always
		 *  mapped to the Null selector
 		 */
 		if (fsindex)
 			prev->fs = 0;
 	}
	/* when next process has a 64bit base use it */
 	if (next->fs)
 		wrmsrl(MSR_FS_BASE, next->fs);
 	prev->fsindex = fsindex;
 
 	if (unlikely(gsindex | next->gsindex | prev->gs)) {
 		load_gs_index(next->gsindex);
 		if (gsindex)
 			prev->gs = 0;
 	}
	if (next->gs)
		wrmsrl(MSR_KERNEL_GS_BASE, next->gs);
	prev->gsindex = gsindex;

	switch_fpu_finish(next_p, fpu);

	/*
	 * Switch the PDA and FPU contexts.
	 */
	prev->usersp = this_cpu_read(old_rsp);
	this_cpu_write(old_rsp, next->usersp);
	this_cpu_write(current_task, next_p);

	/*
	 * If it were not for PREEMPT_ACTIVE we could guarantee that the
	 * preempt_count of all tasks was equal here and this would not be
	 * needed.
	 */
	task_thread_info(prev_p)->saved_preempt_count = this_cpu_read(__preempt_count);
	this_cpu_write(__preempt_count, task_thread_info(next_p)->saved_preempt_count);

	this_cpu_write(kernel_stack,
		  (unsigned long)task_stack_page(next_p) +
		  THREAD_SIZE - KERNEL_STACK_OFFSET);

	/*
	 * Now maybe reload the debug registers and handle I/O bitmaps
	 */
	if (unlikely(task_thread_info(next_p)->flags & _TIF_WORK_CTXSW_NEXT ||
		     task_thread_info(prev_p)->flags & _TIF_WORK_CTXSW_PREV))
		__switch_to_xtra(prev_p, next_p, tss);

	return prev_p;
}
",C,"	/* Reload esp0 and ss1. */
	/*
	 * Load TLS before restoring any segments so that segment loads
	 * reference the correct GDT entries.
	 */
	 * Leave lazy mode, flushing any hypercalls made here.  This
	 * must be done after loading TLS entries in the GDT but before
	 * loading segments that might reference them, and and it must
	 * be done before math_state_restore, so the TS bit is up to
	 * date.
	/* Switch DS and ES.
	 *
	 * Reading them only returns the selectors, but writing them (if
	 * nonzero) loads the full descriptor from the GDT or LDT.  The
	 * LDT for next is loaded in switch_mm, and the GDT is loaded
	 * above.
	 *
	 * We therefore need to write new values to the segment
	 * registers on every context switch unless both the new and old
	 * values are zero.
	 *
	 * Note that we don't need to do anything for CS and SS, as
	 * those are saved and restored as part of pt_regs.
	 */
	savesegment(es, prev->es);
	if (unlikely(next->es | prev->es))
		loadsegment(es, next->es);

	savesegment(ds, prev->ds);
	if (unlikely(next->ds | prev->ds))
		loadsegment(ds, next->ds);

	 * These are even more complicated than FS and GS: they have
	 * 64-bit bases are that controlled by arch_prctl.  Those bases
	 * only differ from the values in the GDT or LDT if the selector
	 * is 0.
	 *
	 * Loading the segment register resets the hidden base part of
	 * the register to 0 or the value from the GDT / LDT.  If the
	 * next base address zero, writing 0 to the segment register is
	 * much faster than using wrmsr to explicitly zero the base.
	 *
	 * The thread_struct.fs and thread_struct.gs values are 0
	 * if the fs and gs bases respectively are not overridden
	 * from the values implied by fsindex and gsindex.  They
	 * are nonzero, and store the nonzero base addresses, if
	 * the bases are overridden.
	 *
	 * (fs != 0 && fsindex != 0) || (gs != 0 && gsindex != 0) should
	 * be impossible.
	 *
	 * Therefore we need to reload the segment registers if either
	 * the old or new selector is nonzero, and we need to override
	 * the base address if next thread expects it to be overridden.
	 *
	 * This code is unnecessarily slow in the case where the old and
	 * new indexes are zero and the new base is nonzero -- it will
	 * unnecessarily write 0 to the selector before writing the new
	 * base address.
	 *
	 * Note: This all depends on arch_prctl being the only way that
	 * user code can override the segment base.  Once wrfsbase and
	 * wrgsbase are enabled, most of this code will need to change.

		 * If user code wrote a nonzero value to FS, then it also
		 * cleared the overridden base address.
		 *
		 * XXX: if user code wrote 0 to FS and cleared the base
		 * address itself, we won't notice and we'll incorrectly
		 * restore the prior base address next time we reschdule
		 * the process.

		/* This works (and fails) the same way as fsindex above. */
","	/*
	 * Reload esp0, LDT and the page table pointer:
	 */
	/*
	 * Switch DS and ES.
	 * This won't pick up thread selector changes, but I guess that is ok.
	 */
	savesegment(es, prev->es);
	if (unlikely(next->es | prev->es))
		loadsegment(es, next->es);
	savesegment(ds, prev->ds);
	if (unlikely(next->ds | prev->ds))
		loadsegment(ds, next->ds);
	 * Leave lazy mode, flushing any hypercalls made here.
	 * This must be done before restoring TLS segments so
	 * the GDT and LDT are properly updated, and must be
	 * done before math_state_restore, so the TS bit is up
	 * to date.
	 * Segment register != 0 always requires a reload.  Also
	 * reload when it has changed.  When prev process used 64bit
	 * base always reload to avoid an information leak.
		 * Check if the user used a selector != 0; if yes
		 *  clear 64bit base, since overloaded base is always
		 *  mapped to the Null selector
	/* when next process has a 64bit base use it */
",,"@@ -283,24 +283,9 @@ __switch_to(struct task_struct *prev_p, struct task_struct *next_p)
 
 	fpu = switch_fpu_prepare(prev_p, next_p, cpu);
 
-	/*
-	 * Reload esp0, LDT and the page table pointer:
-	 */
+	/* Reload esp0 and ss1. */
 	load_sp0(tss, next);
 
-	/*
-	 * Switch DS and ES.
-	 * This won't pick up thread selector changes, but I guess that is ok.
-	 */
-	savesegment(es, prev->es);
-	if (unlikely(next->es | prev->es))
-		loadsegment(es, next->es);
-
-	savesegment(ds, prev->ds);
-	if (unlikely(next->ds | prev->ds))
-		loadsegment(ds, next->ds);
-
-
 	/* We must save %fs and %gs before load_TLS() because
 	 * %fs and %gs may be cleared by load_TLS().
 	 *
@@ -309,41 +294,101 @@ __switch_to(struct task_struct *prev_p, struct task_struct *next_p)
 	savesegment(fs, fsindex);
 	savesegment(gs, gsindex);
 
+	/*
+	 * Load TLS before restoring any segments so that segment loads
+	 * reference the correct GDT entries.
+	 */
 	load_TLS(next, cpu);
 
 	/*
-	 * Leave lazy mode, flushing any hypercalls made here.
-	 * This must be done before restoring TLS segments so
-	 * the GDT and LDT are properly updated, and must be
-	 * done before math_state_restore, so the TS bit is up
-	 * to date.
+	 * Leave lazy mode, flushing any hypercalls made here.  This
+	 * must be done after loading TLS entries in the GDT but before
+	 * loading segments that might reference them, and and it must
+	 * be done before math_state_restore, so the TS bit is up to
+	 * date.
 	 */
 	arch_end_context_switch(next_p);
 
+	/* Switch DS and ES.
+	 *
+	 * Reading them only returns the selectors, but writing them (if
+	 * nonzero) loads the full descriptor from the GDT or LDT.  The
+	 * LDT for next is loaded in switch_mm, and the GDT is loaded
+	 * above.
+	 *
+	 * We therefore need to write new values to the segment
+	 * registers on every context switch unless both the new and old
+	 * values are zero.
+	 *
+	 * Note that we don't need to do anything for CS and SS, as
+	 * those are saved and restored as part of pt_regs.
+	 */
+	savesegment(es, prev->es);
+	if (unlikely(next->es | prev->es))
+		loadsegment(es, next->es);
+
+	savesegment(ds, prev->ds);
+	if (unlikely(next->ds | prev->ds))
+		loadsegment(ds, next->ds);
+
 	/*
 	 * Switch FS and GS.
 	 *
-	 * Segment register != 0 always requires a reload.  Also
-	 * reload when it has changed.  When prev process used 64bit
-	 * base always reload to avoid an information leak.
+	 * These are even more complicated than FS and GS: they have
+	 * 64-bit bases are that controlled by arch_prctl.  Those bases
+	 * only differ from the values in the GDT or LDT if the selector
+	 * is 0.
+	 *
+	 * Loading the segment register resets the hidden base part of
+	 * the register to 0 or the value from the GDT / LDT.  If the
+	 * next base address zero, writing 0 to the segment register is
+	 * much faster than using wrmsr to explicitly zero the base.
+	 *
+	 * The thread_struct.fs and thread_struct.gs values are 0
+	 * if the fs and gs bases respectively are not overridden
+	 * from the values implied by fsindex and gsindex.  They
+	 * are nonzero, and store the nonzero base addresses, if
+	 * the bases are overridden.
+	 *
+	 * (fs != 0 && fsindex != 0) || (gs != 0 && gsindex != 0) should
+	 * be impossible.
+	 *
+	 * Therefore we need to reload the segment registers if either
+	 * the old or new selector is nonzero, and we need to override
+	 * the base address if next thread expects it to be overridden.
+	 *
+	 * This code is unnecessarily slow in the case where the old and
+	 * new indexes are zero and the new base is nonzero -- it will
+	 * unnecessarily write 0 to the selector before writing the new
+	 * base address.
+	 *
+	 * Note: This all depends on arch_prctl being the only way that
+	 * user code can override the segment base.  Once wrfsbase and
+	 * wrgsbase are enabled, most of this code will need to change.
 	 */
 	if (unlikely(fsindex | next->fsindex | prev->fs)) {
 		loadsegment(fs, next->fsindex);
+
 		/*
-		 * Check if the user used a selector != 0; if yes
-		 *  clear 64bit base, since overloaded base is always
-		 *  mapped to the Null selector
+		 * If user code wrote a nonzero value to FS, then it also
+		 * cleared the overridden base address.
+		 *
+		 * XXX: if user code wrote 0 to FS and cleared the base
+		 * address itself, we won't notice and we'll incorrectly
+		 * restore the prior base address next time we reschdule
+		 * the process.
 		 */
 		if (fsindex)
 			prev->fs = 0;
 	}
-	/* when next process has a 64bit base use it */
 	if (next->fs)
 		wrmsrl(MSR_FS_BASE, next->fs);
 	prev->fsindex = fsindex;
 
 	if (unlikely(gsindex | next->gsindex | prev->gs)) {
 		load_gs_index(next->gsindex);
+
+		/* This works (and fails) the same way as fsindex above. */
 		if (gsindex)
 			prev->gs = 0;
 	}",linux,f647d7c155f069c1a068030255c300663516420e,29258cf49eb794f00989fc47da8700759a42778b,1,"__switch_to(struct task_struct *prev_p, struct task_struct *next_p)
{
	struct thread_struct *prev = &prev_p->thread;
	struct thread_struct *next = &next_p->thread;
	int cpu = smp_processor_id();
	struct tss_struct *tss = &per_cpu(init_tss, cpu);
	unsigned fsindex, gsindex;
	fpu_switch_t fpu;
 
 	fpu = switch_fpu_prepare(prev_p, next_p, cpu);
 
//flaw_line_below:
	/*
//flaw_line_below:
	 * Reload esp0, LDT and the page table pointer:
//flaw_line_below:
	 */
//fix_flaw_line_below:
//	/* Reload esp0 and ss1. */
 	load_sp0(tss, next);
 
//flaw_line_below:
	/*
//flaw_line_below:
	 * Switch DS and ES.
//flaw_line_below:
	 * This won't pick up thread selector changes, but I guess that is ok.
//flaw_line_below:
	 */
//flaw_line_below:
	savesegment(es, prev->es);
//flaw_line_below:
	if (unlikely(next->es | prev->es))
//flaw_line_below:
		loadsegment(es, next->es);
//flaw_line_below:

//flaw_line_below:
	savesegment(ds, prev->ds);
//flaw_line_below:
	if (unlikely(next->ds | prev->ds))
//flaw_line_below:
		loadsegment(ds, next->ds);
//flaw_line_below:

//flaw_line_below:

 	/* We must save %fs and %gs before load_TLS() because
 	 * %fs and %gs may be cleared by load_TLS().
 	 *
	 * (e.g. xen_load_tls())
	 */
 	savesegment(fs, fsindex);
 	savesegment(gs, gsindex);
 
//fix_flaw_line_below:
//	/*
//fix_flaw_line_below:
//	 * Load TLS before restoring any segments so that segment loads
//fix_flaw_line_below:
//	 * reference the correct GDT entries.
//fix_flaw_line_below:
//	 */
 	load_TLS(next, cpu);
 
 	/*
//flaw_line_below:
	 * Leave lazy mode, flushing any hypercalls made here.
//flaw_line_below:
	 * This must be done before restoring TLS segments so
//flaw_line_below:
	 * the GDT and LDT are properly updated, and must be
//flaw_line_below:
	 * done before math_state_restore, so the TS bit is up
//flaw_line_below:
	 * to date.
//fix_flaw_line_below:
//	 * Leave lazy mode, flushing any hypercalls made here.  This
//fix_flaw_line_below:
//	 * must be done after loading TLS entries in the GDT but before
//fix_flaw_line_below:
//	 * loading segments that might reference them, and and it must
//fix_flaw_line_below:
//	 * be done before math_state_restore, so the TS bit is up to
//fix_flaw_line_below:
//	 * date.
 	 */
 	arch_end_context_switch(next_p);
 
//fix_flaw_line_below:
//	/* Switch DS and ES.
//fix_flaw_line_below:
//	 *
//fix_flaw_line_below:
//	 * Reading them only returns the selectors, but writing them (if
//fix_flaw_line_below:
//	 * nonzero) loads the full descriptor from the GDT or LDT.  The
//fix_flaw_line_below:
//	 * LDT for next is loaded in switch_mm, and the GDT is loaded
//fix_flaw_line_below:
//	 * above.
//fix_flaw_line_below:
//	 *
//fix_flaw_line_below:
//	 * We therefore need to write new values to the segment
//fix_flaw_line_below:
//	 * registers on every context switch unless both the new and old
//fix_flaw_line_below:
//	 * values are zero.
//fix_flaw_line_below:
//	 *
//fix_flaw_line_below:
//	 * Note that we don't need to do anything for CS and SS, as
//fix_flaw_line_below:
//	 * those are saved and restored as part of pt_regs.
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//	savesegment(es, prev->es);
//fix_flaw_line_below:
//	if (unlikely(next->es | prev->es))
//fix_flaw_line_below:
//		loadsegment(es, next->es);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	savesegment(ds, prev->ds);
//fix_flaw_line_below:
//	if (unlikely(next->ds | prev->ds))
//fix_flaw_line_below:
//		loadsegment(ds, next->ds);
//fix_flaw_line_below:
//
 	/*
 	 * Switch FS and GS.
 	 *
//flaw_line_below:
	 * Segment register != 0 always requires a reload.  Also
//flaw_line_below:
	 * reload when it has changed.  When prev process used 64bit
//flaw_line_below:
	 * base always reload to avoid an information leak.
//fix_flaw_line_below:
//	 * These are even more complicated than FS and GS: they have
//fix_flaw_line_below:
//	 * 64-bit bases are that controlled by arch_prctl.  Those bases
//fix_flaw_line_below:
//	 * only differ from the values in the GDT or LDT if the selector
//fix_flaw_line_below:
//	 * is 0.
//fix_flaw_line_below:
//	 *
//fix_flaw_line_below:
//	 * Loading the segment register resets the hidden base part of
//fix_flaw_line_below:
//	 * the register to 0 or the value from the GDT / LDT.  If the
//fix_flaw_line_below:
//	 * next base address zero, writing 0 to the segment register is
//fix_flaw_line_below:
//	 * much faster than using wrmsr to explicitly zero the base.
//fix_flaw_line_below:
//	 *
//fix_flaw_line_below:
//	 * The thread_struct.fs and thread_struct.gs values are 0
//fix_flaw_line_below:
//	 * if the fs and gs bases respectively are not overridden
//fix_flaw_line_below:
//	 * from the values implied by fsindex and gsindex.  They
//fix_flaw_line_below:
//	 * are nonzero, and store the nonzero base addresses, if
//fix_flaw_line_below:
//	 * the bases are overridden.
//fix_flaw_line_below:
//	 *
//fix_flaw_line_below:
//	 * (fs != 0 && fsindex != 0) || (gs != 0 && gsindex != 0) should
//fix_flaw_line_below:
//	 * be impossible.
//fix_flaw_line_below:
//	 *
//fix_flaw_line_below:
//	 * Therefore we need to reload the segment registers if either
//fix_flaw_line_below:
//	 * the old or new selector is nonzero, and we need to override
//fix_flaw_line_below:
//	 * the base address if next thread expects it to be overridden.
//fix_flaw_line_below:
//	 *
//fix_flaw_line_below:
//	 * This code is unnecessarily slow in the case where the old and
//fix_flaw_line_below:
//	 * new indexes are zero and the new base is nonzero -- it will
//fix_flaw_line_below:
//	 * unnecessarily write 0 to the selector before writing the new
//fix_flaw_line_below:
//	 * base address.
//fix_flaw_line_below:
//	 *
//fix_flaw_line_below:
//	 * Note: This all depends on arch_prctl being the only way that
//fix_flaw_line_below:
//	 * user code can override the segment base.  Once wrfsbase and
//fix_flaw_line_below:
//	 * wrgsbase are enabled, most of this code will need to change.
 	 */
 	if (unlikely(fsindex | next->fsindex | prev->fs)) {
 		loadsegment(fs, next->fsindex);
//fix_flaw_line_below:
//
 		/*
//flaw_line_below:
		 * Check if the user used a selector != 0; if yes
//flaw_line_below:
		 *  clear 64bit base, since overloaded base is always
//flaw_line_below:
		 *  mapped to the Null selector
//fix_flaw_line_below:
//		 * If user code wrote a nonzero value to FS, then it also
//fix_flaw_line_below:
//		 * cleared the overridden base address.
//fix_flaw_line_below:
//		 *
//fix_flaw_line_below:
//		 * XXX: if user code wrote 0 to FS and cleared the base
//fix_flaw_line_below:
//		 * address itself, we won't notice and we'll incorrectly
//fix_flaw_line_below:
//		 * restore the prior base address next time we reschdule
//fix_flaw_line_below:
//		 * the process.
 		 */
 		if (fsindex)
 			prev->fs = 0;
 	}
//flaw_line_below:
	/* when next process has a 64bit base use it */
 	if (next->fs)
 		wrmsrl(MSR_FS_BASE, next->fs);
 	prev->fsindex = fsindex;
 
 	if (unlikely(gsindex | next->gsindex | prev->gs)) {
 		load_gs_index(next->gsindex);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//		/* This works (and fails) the same way as fsindex above. */
 		if (gsindex)
 			prev->gs = 0;
 	}
	if (next->gs)
		wrmsrl(MSR_KERNEL_GS_BASE, next->gs);
	prev->gsindex = gsindex;

	switch_fpu_finish(next_p, fpu);

	/*
	 * Switch the PDA and FPU contexts.
	 */
	prev->usersp = this_cpu_read(old_rsp);
	this_cpu_write(old_rsp, next->usersp);
	this_cpu_write(current_task, next_p);

	/*
	 * If it were not for PREEMPT_ACTIVE we could guarantee that the
	 * preempt_count of all tasks was equal here and this would not be
	 * needed.
	 */
	task_thread_info(prev_p)->saved_preempt_count = this_cpu_read(__preempt_count);
	this_cpu_write(__preempt_count, task_thread_info(next_p)->saved_preempt_count);

	this_cpu_write(kernel_stack,
		  (unsigned long)task_stack_page(next_p) +
		  THREAD_SIZE - KERNEL_STACK_OFFSET);

	/*
	 * Now maybe reload the debug registers and handle I/O bitmaps
	 */
	if (unlikely(task_thread_info(next_p)->flags & _TIF_WORK_CTXSW_NEXT ||
		     task_thread_info(prev_p)->flags & _TIF_WORK_CTXSW_PREV))
		__switch_to_xtra(prev_p, next_p, tss);

	return prev_p;
}
",179409,"__switch_to(struct task_struct *prev_p, struct task_struct *next_p)
{
	struct thread_struct *prev = &prev_p->thread;
	struct thread_struct *next = &next_p->thread;
	int cpu = smp_processor_id();
	struct tss_struct *tss = &per_cpu(init_tss, cpu);
	unsigned fsindex, gsindex;
	fpu_switch_t fpu;
 
 	fpu = switch_fpu_prepare(prev_p, next_p, cpu);
 
	/*
	 * Reload esp0, LDT and the page table pointer:
	 */
 	load_sp0(tss, next);
 
	/*
	 * Switch DS and ES.
	 * This won't pick up thread selector changes, but I guess that is ok.
	 */
	savesegment(es, prev->es);
	if (unlikely(next->es | prev->es))
		loadsegment(es, next->es);
	savesegment(ds, prev->ds);
	if (unlikely(next->ds | prev->ds))
		loadsegment(ds, next->ds);
 	/* We must save %fs and %gs before load_TLS() because
 	 * %fs and %gs may be cleared by load_TLS().
 	 *
	 * (e.g. xen_load_tls())
	 */
 	savesegment(fs, fsindex);
 	savesegment(gs, gsindex);
 
 	load_TLS(next, cpu);
 
 	/*
	 * Leave lazy mode, flushing any hypercalls made here.
	 * This must be done before restoring TLS segments so
	 * the GDT and LDT are properly updated, and must be
	 * done before math_state_restore, so the TS bit is up
	 * to date.
 	 */
 	arch_end_context_switch(next_p);
 
 	/*
 	 * Switch FS and GS.
 	 *
	 * Segment register != 0 always requires a reload.  Also
	 * reload when it has changed.  When prev process used 64bit
	 * base always reload to avoid an information leak.
 	 */
 	if (unlikely(fsindex | next->fsindex | prev->fs)) {
 		loadsegment(fs, next->fsindex);
 		/*
		 * Check if the user used a selector != 0; if yes
		 *  clear 64bit base, since overloaded base is always
		 *  mapped to the Null selector
 		 */
 		if (fsindex)
 			prev->fs = 0;
 	}
	/* when next process has a 64bit base use it */
 	if (next->fs)
 		wrmsrl(MSR_FS_BASE, next->fs);
 	prev->fsindex = fsindex;
 
 	if (unlikely(gsindex | next->gsindex | prev->gs)) {
 		load_gs_index(next->gsindex);
 		if (gsindex)
 			prev->gs = 0;
 	}
	if (next->gs)
		wrmsrl(MSR_KERNEL_GS_BASE, next->gs);
	prev->gsindex = gsindex;

	switch_fpu_finish(next_p, fpu);

	/*
	 * Switch the PDA and FPU contexts.
	 */
	prev->usersp = this_cpu_read(old_rsp);
	this_cpu_write(old_rsp, next->usersp);
	this_cpu_write(current_task, next_p);

	/*
	 * If it were not for PREEMPT_ACTIVE we could guarantee that the
	 * preempt_count of all tasks was equal here and this would not be
	 * needed.
	 */
	task_thread_info(prev_p)->saved_preempt_count = this_cpu_read(__preempt_count);
	this_cpu_write(__preempt_count, task_thread_info(next_p)->saved_preempt_count);

	this_cpu_write(kernel_stack,
		  (unsigned long)task_stack_page(next_p) +
		  THREAD_SIZE - KERNEL_STACK_OFFSET);

	/*
	 * Now maybe reload the debug registers and handle I/O bitmaps
	 */
	if (unlikely(task_thread_info(next_p)->flags & _TIF_WORK_CTXSW_NEXT ||
		     task_thread_info(prev_p)->flags & _TIF_WORK_CTXSW_PREV))
		__switch_to_xtra(prev_p, next_p, tss);

	return prev_p;
}
","__switch_to(struct task_struct *prev_p, struct task_struct *next_p)
{
	struct thread_struct *prev = &prev_p->thread;
	struct thread_struct *next = &next_p->thread;
	int cpu = smp_processor_id();
	struct tss_struct *tss = &per_cpu(init_tss, cpu);
	unsigned fsindex, gsindex;
	fpu_switch_t fpu;
 
 	fpu = switch_fpu_prepare(prev_p, next_p, cpu);
 
	/* Reload esp0 and ss1. */
 	load_sp0(tss, next);
 
 	/* We must save %fs and %gs before load_TLS() because
 	 * %fs and %gs may be cleared by load_TLS().
 	 *
	 * (e.g. xen_load_tls())
	 */
 	savesegment(fs, fsindex);
 	savesegment(gs, gsindex);
 
	/*
	 * Load TLS before restoring any segments so that segment loads
	 * reference the correct GDT entries.
	 */
 	load_TLS(next, cpu);
 
 	/*
	 * Leave lazy mode, flushing any hypercalls made here.  This
	 * must be done after loading TLS entries in the GDT but before
	 * loading segments that might reference them, and and it must
	 * be done before math_state_restore, so the TS bit is up to
	 * date.
 	 */
 	arch_end_context_switch(next_p);
 
	/* Switch DS and ES.
	 *
	 * Reading them only returns the selectors, but writing them (if
	 * nonzero) loads the full descriptor from the GDT or LDT.  The
	 * LDT for next is loaded in switch_mm, and the GDT is loaded
	 * above.
	 *
	 * We therefore need to write new values to the segment
	 * registers on every context switch unless both the new and old
	 * values are zero.
	 *
	 * Note that we don't need to do anything for CS and SS, as
	 * those are saved and restored as part of pt_regs.
	 */
	savesegment(es, prev->es);
	if (unlikely(next->es | prev->es))
		loadsegment(es, next->es);

	savesegment(ds, prev->ds);
	if (unlikely(next->ds | prev->ds))
		loadsegment(ds, next->ds);

 	/*
 	 * Switch FS and GS.
 	 *
	 * These are even more complicated than FS and GS: they have
	 * 64-bit bases are that controlled by arch_prctl.  Those bases
	 * only differ from the values in the GDT or LDT if the selector
	 * is 0.
	 *
	 * Loading the segment register resets the hidden base part of
	 * the register to 0 or the value from the GDT / LDT.  If the
	 * next base address zero, writing 0 to the segment register is
	 * much faster than using wrmsr to explicitly zero the base.
	 *
	 * The thread_struct.fs and thread_struct.gs values are 0
	 * if the fs and gs bases respectively are not overridden
	 * from the values implied by fsindex and gsindex.  They
	 * are nonzero, and store the nonzero base addresses, if
	 * the bases are overridden.
	 *
	 * (fs != 0 && fsindex != 0) || (gs != 0 && gsindex != 0) should
	 * be impossible.
	 *
	 * Therefore we need to reload the segment registers if either
	 * the old or new selector is nonzero, and we need to override
	 * the base address if next thread expects it to be overridden.
	 *
	 * This code is unnecessarily slow in the case where the old and
	 * new indexes are zero and the new base is nonzero -- it will
	 * unnecessarily write 0 to the selector before writing the new
	 * base address.
	 *
	 * Note: This all depends on arch_prctl being the only way that
	 * user code can override the segment base.  Once wrfsbase and
	 * wrgsbase are enabled, most of this code will need to change.
 	 */
 	if (unlikely(fsindex | next->fsindex | prev->fs)) {
 		loadsegment(fs, next->fsindex);

 		/*
		 * If user code wrote a nonzero value to FS, then it also
		 * cleared the overridden base address.
		 *
		 * XXX: if user code wrote 0 to FS and cleared the base
		 * address itself, we won't notice and we'll incorrectly
		 * restore the prior base address next time we reschdule
		 * the process.
 		 */
 		if (fsindex)
 			prev->fs = 0;
 	}
 	if (next->fs)
 		wrmsrl(MSR_FS_BASE, next->fs);
 	prev->fsindex = fsindex;
 
 	if (unlikely(gsindex | next->gsindex | prev->gs)) {
 		load_gs_index(next->gsindex);

		/* This works (and fails) the same way as fsindex above. */
 		if (gsindex)
 			prev->gs = 0;
 	}
	if (next->gs)
		wrmsrl(MSR_KERNEL_GS_BASE, next->gs);
	prev->gsindex = gsindex;

	switch_fpu_finish(next_p, fpu);

	/*
	 * Switch the PDA and FPU contexts.
	 */
	prev->usersp = this_cpu_read(old_rsp);
	this_cpu_write(old_rsp, next->usersp);
	this_cpu_write(current_task, next_p);

	/*
	 * If it were not for PREEMPT_ACTIVE we could guarantee that the
	 * preempt_count of all tasks was equal here and this would not be
	 * needed.
	 */
	task_thread_info(prev_p)->saved_preempt_count = this_cpu_read(__preempt_count);
	this_cpu_write(__preempt_count, task_thread_info(next_p)->saved_preempt_count);

	this_cpu_write(kernel_stack,
		  (unsigned long)task_stack_page(next_p) +
		  THREAD_SIZE - KERNEL_STACK_OFFSET);

	/*
	 * Now maybe reload the debug registers and handle I/O bitmaps
	 */
	if (unlikely(task_thread_info(next_p)->flags & _TIF_WORK_CTXSW_NEXT ||
		     task_thread_info(prev_p)->flags & _TIF_WORK_CTXSW_PREV))
		__switch_to_xtra(prev_p, next_p, tss);

	return prev_p;
}
","The `__switch_to` function facilitates context switching between two tasks in a multi-threaded environment, specifically within the Linux kernel. It saves the state of the currently running task (`prev_p`) and prepares to switch to the next task (`next_p`). The function updates various processor registers, including segment registers and thread-local storage, ensuring that the new task's execution context is correctly established. It also manages the floating-point unit (FPU) state and updates the processor's stack pointer. Additionally, it handles preemption counts and may invoke extra context-switching operations if necessary, ultimately returning the previous task's structure.","The provided code implements a context-switching mechanism for a multi-threaded operating system, allowing the system to switch execution from one task to another. It saves the state of the currently running task and prepares the next task for execution by updating various processor registers and memory pointers. The code ensures that the new task's execution environment is correctly set up, including managing floating-point state and thread-local storage. Additionally, it handles preemption counts to maintain task scheduling integrity and may perform additional operations if specific conditions are met, ultimately returning the previous task's state.","The vulnerability in the original code stemmed from the improper ordering of operations during context switching, which could lead to corruption of thread-local storage (TLS) descriptors if user code incorrectly pointed segment registers to the TLS array. Specifically, the code did not load the TLS descriptors before switching the data and extra segment registers, risking the integrity of the TLS data. The fix involved reordering the operations to ensure that the TLS descriptors were loaded prior to switching the segment registers, thereby preventing potential corruption and ensuring that the correct GDT entries were referenced during context switches.","The vulnerability in the original code arose from the incorrect sequence of operations during context switching, which could lead to corruption of thread-local storage if user code improperly manipulated certain segment registers. Specifically, the code did not load the necessary descriptors for thread-local storage before switching other segment registers, risking data integrity. The fix involved reordering the operations to ensure that the thread-local storage descriptors were loaded prior to switching the relevant segment registers, thereby preventing potential corruption and ensuring that the correct entries were referenced during context switches.","The vulnerability was fixed by reordering the operations in the context-switching code to ensure that the thread-local storage descriptors were loaded before switching the data segment and extra segment registers. Specifically, the code now saves the segment registers for FS and GS before calling `load_TLS`, which loads the necessary thread-local storage entries. This change prevents corruption of the TLS data when user code manipulates the segment registers, as the correct global descriptor table entries are referenced during the context switch. Additionally, improved comments were added to clarify the logic and potential pitfalls in the code.","The vulnerability was addressed by rearranging the sequence of operations during the context-switching process to ensure that the necessary thread-local storage descriptors were loaded before switching the relevant segment registers. This adjustment prevents potential corruption of data when user code manipulates segment registers, as it guarantees that the correct entries are referenced during the switch. The fix not only enhances data integrity but also includes improved documentation within the code to clarify the logic and highlight potential issues, thereby aiding future maintenance and understanding of the context-switching mechanism.","4,5","5, 5","4,4","4,5"
46,46,179605,179605,,Local,Single system,,CVE-2014-1739,https://www.cvedetails.com/cve/CVE-2014-1739/,CWE-200,Low,Partial,,,2014-06-23,1.7,"The media_device_enum_entities function in drivers/media/media-device.c in the Linux kernel before 3.14.6 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel memory by leveraging /dev/media0 read access for a MEDIA_IOC_ENUM_ENTITIES ioctl call.",2017-12-20,+Info ,1,https://github.com/torvalds/linux/commit/e6a623460e5fc960ac3ee9f946d3106233fd28d8,e6a623460e5fc960ac3ee9f946d3106233fd28d8,"[media] media-device: fix infoleak in ioctl media_enum_entities()

This fixes CVE-2014-1739.

Signed-off-by: Salva Peiró <speiro@ai2.upv.es>
Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Cc: stable@vger.kernel.org
Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>",0,drivers/media/media-device.c,"{""sha"": ""703560fa5e73b456cbc0951ccb61957bdfecebac"", ""filename"": ""drivers/media/media-device.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/e6a623460e5fc960ac3ee9f946d3106233fd28d8/drivers/media/media-device.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e6a623460e5fc960ac3ee9f946d3106233fd28d8/drivers/media/media-device.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/media/media-device.c?ref=e6a623460e5fc960ac3ee9f946d3106233fd28d8"", ""patch"": ""@@ -93,6 +93,7 @@ static long media_device_enum_entities(struct media_device *mdev,\n \tstruct media_entity *ent;\n \tstruct media_entity_desc u_ent;\n \n+\tmemset(&u_ent, 0, sizeof(u_ent));\n \tif (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))\n \t\treturn -EFAULT;\n ""}","static long media_device_enum_entities(struct media_device *mdev,
				       struct media_entity_desc __user *uent)
{
 	struct media_entity *ent;
 	struct media_entity_desc u_ent;
 
	memset(&u_ent, 0, sizeof(u_ent));
 	if (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))
 		return -EFAULT;
 
	ent = find_entity(mdev, u_ent.id);

	if (ent == NULL)
		return -EINVAL;

	u_ent.id = ent->id;
	if (ent->name) {
		strncpy(u_ent.name, ent->name, sizeof(u_ent.name));
		u_ent.name[sizeof(u_ent.name) - 1] = '\0';
	} else {
		memset(u_ent.name, 0, sizeof(u_ent.name));
	}
	u_ent.type = ent->type;
	u_ent.revision = ent->revision;
	u_ent.flags = ent->flags;
	u_ent.group_id = ent->group_id;
	u_ent.pads = ent->num_pads;
	u_ent.links = ent->num_links - ent->num_backlinks;
	memcpy(&u_ent.raw, &ent->info, sizeof(ent->info));
	if (copy_to_user(uent, &u_ent, sizeof(u_ent)))
		return -EFAULT;
	return 0;
}
","static long media_device_enum_entities(struct media_device *mdev,
				       struct media_entity_desc __user *uent)
{
 	struct media_entity *ent;
 	struct media_entity_desc u_ent;
 
 	if (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))
 		return -EFAULT;
 
	ent = find_entity(mdev, u_ent.id);

	if (ent == NULL)
		return -EINVAL;

	u_ent.id = ent->id;
	if (ent->name) {
		strncpy(u_ent.name, ent->name, sizeof(u_ent.name));
		u_ent.name[sizeof(u_ent.name) - 1] = '\0';
	} else {
		memset(u_ent.name, 0, sizeof(u_ent.name));
	}
	u_ent.type = ent->type;
	u_ent.revision = ent->revision;
	u_ent.flags = ent->flags;
	u_ent.group_id = ent->group_id;
	u_ent.pads = ent->num_pads;
	u_ent.links = ent->num_links - ent->num_backlinks;
	memcpy(&u_ent.raw, &ent->info, sizeof(ent->info));
	if (copy_to_user(uent, &u_ent, sizeof(u_ent)))
		return -EFAULT;
	return 0;
}
",C,"	memset(&u_ent, 0, sizeof(u_ent));
",,,"@@ -93,6 +93,7 @@ static long media_device_enum_entities(struct media_device *mdev,
 	struct media_entity *ent;
 	struct media_entity_desc u_ent;
 
+	memset(&u_ent, 0, sizeof(u_ent));
 	if (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))
 		return -EFAULT;
 ",linux,e6a623460e5fc960ac3ee9f946d3106233fd28d8,8845cc6415ec28ef8d57b3fb81c75ef9bce69c5f,1,"static long media_device_enum_entities(struct media_device *mdev,
				       struct media_entity_desc __user *uent)
{
 	struct media_entity *ent;
 	struct media_entity_desc u_ent;
 
//fix_flaw_line_below:
//	memset(&u_ent, 0, sizeof(u_ent));
 	if (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))
 		return -EFAULT;
 
	ent = find_entity(mdev, u_ent.id);

	if (ent == NULL)
		return -EINVAL;

	u_ent.id = ent->id;
	if (ent->name) {
		strncpy(u_ent.name, ent->name, sizeof(u_ent.name));
		u_ent.name[sizeof(u_ent.name) - 1] = '\0';
	} else {
		memset(u_ent.name, 0, sizeof(u_ent.name));
	}
	u_ent.type = ent->type;
	u_ent.revision = ent->revision;
	u_ent.flags = ent->flags;
	u_ent.group_id = ent->group_id;
	u_ent.pads = ent->num_pads;
	u_ent.links = ent->num_links - ent->num_backlinks;
	memcpy(&u_ent.raw, &ent->info, sizeof(ent->info));
	if (copy_to_user(uent, &u_ent, sizeof(u_ent)))
		return -EFAULT;
	return 0;
}
",179605,"static long media_device_enum_entities(struct media_device *mdev,
				       struct media_entity_desc __user *uent)
{
 	struct media_entity *ent;
 	struct media_entity_desc u_ent;
 
 	if (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))
 		return -EFAULT;
 
	ent = find_entity(mdev, u_ent.id);

	if (ent == NULL)
		return -EINVAL;

	u_ent.id = ent->id;
	if (ent->name) {
		strncpy(u_ent.name, ent->name, sizeof(u_ent.name));
		u_ent.name[sizeof(u_ent.name) - 1] = '\0';
	} else {
		memset(u_ent.name, 0, sizeof(u_ent.name));
	}
	u_ent.type = ent->type;
	u_ent.revision = ent->revision;
	u_ent.flags = ent->flags;
	u_ent.group_id = ent->group_id;
	u_ent.pads = ent->num_pads;
	u_ent.links = ent->num_links - ent->num_backlinks;
	memcpy(&u_ent.raw, &ent->info, sizeof(ent->info));
	if (copy_to_user(uent, &u_ent, sizeof(u_ent)))
		return -EFAULT;
	return 0;
}
","static long media_device_enum_entities(struct media_device *mdev,
				       struct media_entity_desc __user *uent)
{
 	struct media_entity *ent;
 	struct media_entity_desc u_ent;
 
	memset(&u_ent, 0, sizeof(u_ent));
 	if (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))
 		return -EFAULT;
 
	ent = find_entity(mdev, u_ent.id);

	if (ent == NULL)
		return -EINVAL;

	u_ent.id = ent->id;
	if (ent->name) {
		strncpy(u_ent.name, ent->name, sizeof(u_ent.name));
		u_ent.name[sizeof(u_ent.name) - 1] = '\0';
	} else {
		memset(u_ent.name, 0, sizeof(u_ent.name));
	}
	u_ent.type = ent->type;
	u_ent.revision = ent->revision;
	u_ent.flags = ent->flags;
	u_ent.group_id = ent->group_id;
	u_ent.pads = ent->num_pads;
	u_ent.links = ent->num_links - ent->num_backlinks;
	memcpy(&u_ent.raw, &ent->info, sizeof(ent->info));
	if (copy_to_user(uent, &u_ent, sizeof(u_ent)))
		return -EFAULT;
	return 0;
}
","The function `media_device_enum_entities` is designed to enumerate media entities within a media device structure. It begins by copying the entity ID from user space to a local structure. It then attempts to locate the corresponding media entity using this ID. If found, it populates a user-defined structure with various attributes of the entity, such as its name, type, revision, flags, group ID, number of pads, and links. Finally, it copies this populated structure back to user space. The function handles errors related to memory access and invalid entity IDs, returning appropriate error codes when necessary.","The code defines a function that retrieves and populates information about a specific media entity from a media device structure. It starts by obtaining an identifier from user space and attempts to locate the corresponding entity. If the entity is found, various attributes, including its name, type, revision, flags, group ID, and counts of pads and links, are extracted and stored in a user-defined structure. The function ensures safe memory access by copying data between user and kernel space, returning appropriate error codes for any issues encountered, such as invalid identifiers or memory access failures.","The vulnerability in the original code stemmed from the lack of initialization for the user-defined structure, which could lead to uninitialized memory being copied back to user space, potentially exposing sensitive information. Specifically, if the entity was not found, the function would still attempt to copy the uninitialized structure, resulting in an information leak. The fix involved adding a call to `memset(&u_ent, 0, sizeof(u_ent));` at the beginning of the function, ensuring that the structure is zeroed out before any data is copied into it. This prevents any residual data from being sent back to the user, thus mitigating the information leak.","The vulnerability in the original code was due to the failure to initialize a user-defined structure, which could lead to uninitialized memory being returned to user space. This oversight allowed potentially sensitive data from previous operations to be exposed, creating an information leak. The fix addressed this issue by ensuring that the structure is explicitly zeroed out before any data is copied into it. This initialization step guarantees that no residual data remains, thereby preventing any unintended information from being sent back to the user and effectively mitigating the risk of information leakage.","The vulnerability was fixed by adding a call to `memset(&u_ent, 0, sizeof(u_ent));` at the beginning of the function. This initialization step ensures that the user-defined structure is filled with zeros before any data is copied into it. By doing this, the code prevents any uninitialized memory from being inadvertently returned to user space, which could contain sensitive information from previous operations. Consequently, this change mitigates the risk of information leakage, ensuring that only valid and intended data is sent back to the user after the entity information is processed.","The vulnerability was fixed by introducing an initialization step that clears the memory of the user-defined structure before any data is copied into it. This ensures that the structure starts with a clean state, preventing any uninitialized data from being inadvertently returned to user space. By zeroing out the memory, the code eliminates the risk of exposing sensitive information that may have lingered from previous operations. This change effectively safeguards against information leakage, ensuring that only valid and intended data is provided to the user, thereby enhancing the overall security of the function.","5,4","5,5","5,4","5, 5"
47,47,179648,179648,,Local,Not required,,CVE-2013-7281,https://www.cvedetails.com/cve/CVE-2013-7281/,CWE-200,Low,Complete,,,2014-01-08,4.9,"The dgram_recvmsg function in net/ieee802154/dgram.c in the Linux kernel before 3.12.4 updates a certain length value without ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel stack memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call.",2017-08-28,+Info ,1,https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69,bceaa90240b6019ed73b49965eac7d167610be69,"inet: prevent leakage of uninitialized memory to user in recv syscalls

Only update *addr_len when we actually fill in sockaddr, otherwise we
can return uninitialized memory from the stack to the caller in the
recvfrom, recvmmsg and recvmsg syscalls. Drop the the (addr_len == NULL)
checks because we only get called with a valid addr_len pointer either
from sock_common_recvmsg or inet_recvmsg.

If a blocking read waits on a socket which is concurrently shut down we
now return zero and set msg_msgnamelen to 0.

Reported-by: mpb <mpb.mail@gmail.com>
Suggested-by: Eric Dumazet <eric.dumazet@gmail.com>
Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",2,net/ieee802154/dgram.c,"{""sha"": ""1865fdf5a5a5116be8bf28b25f9c340f8b8fd50b"", ""filename"": ""net/ieee802154/dgram.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/ieee802154/dgram.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/ieee802154/dgram.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ieee802154/dgram.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -315,9 +315,8 @@ static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,\n \tif (saddr) {\n \t\tsaddr->family = AF_IEEE802154;\n \t\tsaddr->addr = mac_cb(skb)->sa;\n-\t}\n-\tif (addr_len)\n \t\t*addr_len = sizeof(*saddr);\n+\t}\n \n \tif (flags & MSG_TRUNC)\n \t\tcopied = skb->len;""}<_**next**_>{""sha"": ""aacefa0caa36af726e848e9f590625ae310e6732"", ""filename"": ""net/ipv4/ping.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 12, ""changes"": 19, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv4/ping.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv4/ping.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/ping.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -830,8 +830,6 @@ int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n {\n \tstruct inet_sock *isk = inet_sk(sk);\n \tint family = sk->sk_family;\n-\tstruct sockaddr_in *sin;\n-\tstruct sockaddr_in6 *sin6;\n \tstruct sk_buff *skb;\n \tint copied, err;\n \n@@ -841,13 +839,6 @@ int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \tif (flags & MSG_OOB)\n \t\tgoto out;\n \n-\tif (addr_len) {\n-\t\tif (family == AF_INET)\n-\t\t\t*addr_len = sizeof(*sin);\n-\t\telse if (family == AF_INET6 && addr_len)\n-\t\t\t*addr_len = sizeof(*sin6);\n-\t}\n-\n \tif (flags & MSG_ERRQUEUE) {\n \t\tif (family == AF_INET) {\n \t\t\treturn ip_recv_error(sk, msg, len);\n@@ -877,11 +868,13 @@ int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \n \t/* Copy the address and add cmsg data. */\n \tif (family == AF_INET) {\n-\t\tsin = (struct sockaddr_in *) msg->msg_name;\n+\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n+\n \t\tsin->sin_family = AF_INET;\n \t\tsin->sin_port = 0 /* skb->h.uh->source */;\n \t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n \t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n+\t\t*addr_len = sizeof(*sin);\n \n \t\tif (isk->cmsg_flags)\n \t\t\tip_cmsg_recv(msg, skb);\n@@ -890,17 +883,19 @@ int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \t} else if (family == AF_INET6) {\n \t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n \t\tstruct ipv6hdr *ip6 = ipv6_hdr(skb);\n-\t\tsin6 = (struct sockaddr_in6 *) msg->msg_name;\n+\t\tstruct sockaddr_in6 *sin6 =\n+\t\t\t(struct sockaddr_in6 *)msg->msg_name;\n+\n \t\tsin6->sin6_family = AF_INET6;\n \t\tsin6->sin6_port = 0;\n \t\tsin6->sin6_addr = ip6->saddr;\n-\n \t\tsin6->sin6_flowinfo = 0;\n \t\tif (np->sndflow)\n \t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);\n \n \t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n \t\t\t\t\t\t\t  IP6CB(skb)->iif);\n+\t\t*addr_len = sizeof(*sin6);\n \n \t\tif (inet6_sk(sk)->rxopt.all)\n \t\t\tpingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);""}<_**next**_>{""sha"": ""5cb8ddb505ee8911461ec92a5c74feef0b441e00"", ""filename"": ""net/ipv4/raw.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv4/raw.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv4/raw.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/raw.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -696,9 +696,6 @@ static int raw_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \tif (flags & MSG_OOB)\n \t\tgoto out;\n \n-\tif (addr_len)\n-\t\t*addr_len = sizeof(*sin);\n-\n \tif (flags & MSG_ERRQUEUE) {\n \t\terr = ip_recv_error(sk, msg, len);\n \t\tgoto out;\n@@ -726,6 +723,7 @@ static int raw_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n \t\tsin->sin_port = 0;\n \t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n+\t\t*addr_len = sizeof(*sin);\n \t}\n \tif (inet->cmsg_flags)\n \t\tip_cmsg_recv(msg, skb);""}<_**next**_>{""sha"": ""998431cd471a217668f19872e99ee989cd35ba2a"", ""filename"": ""net/ipv4/udp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 6, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv4/udp.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv4/udp.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/udp.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -1235,12 +1235,6 @@ int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \tint is_udplite = IS_UDPLITE(sk);\n \tbool slow;\n \n-\t/*\n-\t *\tCheck any passed addresses\n-\t */\n-\tif (addr_len)\n-\t\t*addr_len = sizeof(*sin);\n-\n \tif (flags & MSG_ERRQUEUE)\n \t\treturn ip_recv_error(sk, msg, len);\n \n@@ -1302,6 +1296,7 @@ int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \t\tsin->sin_port = udp_hdr(skb)->source;\n \t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n \t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n+\t\t*addr_len = sizeof(*sin);\n \t}\n \tif (inet->cmsg_flags)\n \t\tip_cmsg_recv(msg, skb);""}<_**next**_>{""sha"": ""e24ff1df0401288e4e810cf79ec3ea20d86a06c0"", ""filename"": ""net/ipv6/raw.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv6/raw.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv6/raw.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/raw.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -465,9 +465,6 @@ static int rawv6_recvmsg(struct kiocb *iocb, struct sock *sk,\n \tif (flags & MSG_OOB)\n \t\treturn -EOPNOTSUPP;\n \n-\tif (addr_len)\n-\t\t*addr_len=sizeof(*sin6);\n-\n \tif (flags & MSG_ERRQUEUE)\n \t\treturn ipv6_recv_error(sk, msg, len);\n \n@@ -506,6 +503,7 @@ static int rawv6_recvmsg(struct kiocb *iocb, struct sock *sk,\n \t\tsin6->sin6_flowinfo = 0;\n \t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n \t\t\t\t\t\t\t  IP6CB(skb)->iif);\n+\t\t*addr_len = sizeof(*sin6);\n \t}\n \n \tsock_recv_ts_and_drops(msg, sk, skb);""}<_**next**_>{""sha"": ""81eb8cf8389b6a5af55f7b2994d7dbefe3d732bf"", ""filename"": ""net/ipv6/udp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 4, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv6/udp.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv6/udp.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/udp.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -392,9 +392,6 @@ int udpv6_recvmsg(struct kiocb *iocb, struct sock *sk,\n \tint is_udp4;\n \tbool slow;\n \n-\tif (addr_len)\n-\t\t*addr_len = sizeof(struct sockaddr_in6);\n-\n \tif (flags & MSG_ERRQUEUE)\n \t\treturn ipv6_recv_error(sk, msg, len);\n \n@@ -480,7 +477,7 @@ int udpv6_recvmsg(struct kiocb *iocb, struct sock *sk,\n \t\t\t\tipv6_iface_scope_id(&sin6->sin6_addr,\n \t\t\t\t\t\t    IP6CB(skb)->iif);\n \t\t}\n-\n+\t\t*addr_len = sizeof(*sin6);\n \t}\n \tif (is_udp4) {\n \t\tif (inet->cmsg_flags)""}<_**next**_>{""sha"": ""da1a1cee1a088e39816d565e99975bbc69a392d3"", ""filename"": ""net/l2tp/l2tp_ip.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/l2tp/l2tp_ip.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/l2tp/l2tp_ip.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/l2tp/l2tp_ip.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -518,9 +518,6 @@ static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *m\n \tif (flags & MSG_OOB)\n \t\tgoto out;\n \n-\tif (addr_len)\n-\t\t*addr_len = sizeof(*sin);\n-\n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb)\n \t\tgoto out;\n@@ -543,6 +540,7 @@ static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *m\n \t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n \t\tsin->sin_port = 0;\n \t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n+\t\t*addr_len = sizeof(*sin);\n \t}\n \tif (inet->cmsg_flags)\n \t\tip_cmsg_recv(msg, skb);""}<_**next**_>{""sha"": ""38946b26e471c9754c922d3451e8ec2682f5ae3d"", ""filename"": ""net/phonet/datagram.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/phonet/datagram.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/phonet/datagram.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/phonet/datagram.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -139,9 +139,6 @@ static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,\n \t\t\tMSG_CMSG_COMPAT))\n \t\tgoto out_nofree;\n \n-\tif (addr_len)\n-\t\t*addr_len = sizeof(sa);\n-\n \tskb = skb_recv_datagram(sk, flags, noblock, &rval);\n \tif (skb == NULL)\n \t\tgoto out_nofree;\n@@ -162,8 +159,10 @@ static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,\n \n \trval = (flags & MSG_TRUNC) ? skb->len : copylen;\n \n-\tif (msg->msg_name != NULL)\n-\t\tmemcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));\n+\tif (msg->msg_name != NULL) {\n+\t\tmemcpy(msg->msg_name, &sa, sizeof(sa));\n+\t\t*addr_len = sizeof(sa);\n+\t}\n \n out:\n \tskb_free_datagram(sk, skb);""}","static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,
		struct msghdr *msg, size_t len, int noblock, int flags,
		int *addr_len)
{
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *skb;
	struct sockaddr_ieee802154 *saddr;

	saddr = (struct sockaddr_ieee802154 *)msg->msg_name;

	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb)
		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	/* FIXME: skip headers if necessary ?! */
	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_ts_and_drops(msg, sk, skb);

 	if (saddr) {
 		saddr->family = AF_IEEE802154;
 		saddr->addr = mac_cb(skb)->sa;
 		*addr_len = sizeof(*saddr);
	}
 
 	if (flags & MSG_TRUNC)
 		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	if (err)
		return err;
	return copied;
}
","static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,
		struct msghdr *msg, size_t len, int noblock, int flags,
		int *addr_len)
{
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *skb;
	struct sockaddr_ieee802154 *saddr;

	saddr = (struct sockaddr_ieee802154 *)msg->msg_name;

	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb)
		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	/* FIXME: skip headers if necessary ?! */
	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_ts_and_drops(msg, sk, skb);

 	if (saddr) {
 		saddr->family = AF_IEEE802154;
 		saddr->addr = mac_cb(skb)->sa;
	}
	if (addr_len)
 		*addr_len = sizeof(*saddr);
 
 	if (flags & MSG_TRUNC)
 		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	if (err)
		return err;
	return copied;
}
",C,"	}
","	}
	if (addr_len)
",,"@@ -315,9 +315,8 @@ static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,
 	if (saddr) {
 		saddr->family = AF_IEEE802154;
 		saddr->addr = mac_cb(skb)->sa;
-	}
-	if (addr_len)
 		*addr_len = sizeof(*saddr);
+	}
 
 	if (flags & MSG_TRUNC)
 		copied = skb->len;",linux,bceaa90240b6019ed73b49965eac7d167610be69,bcd081a3aef1f7f3786067ae8dd26aaa1cf85153,1,"static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,
		struct msghdr *msg, size_t len, int noblock, int flags,
		int *addr_len)
{
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *skb;
	struct sockaddr_ieee802154 *saddr;

	saddr = (struct sockaddr_ieee802154 *)msg->msg_name;

	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb)
		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	/* FIXME: skip headers if necessary ?! */
	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_ts_and_drops(msg, sk, skb);

 	if (saddr) {
 		saddr->family = AF_IEEE802154;
 		saddr->addr = mac_cb(skb)->sa;
//flaw_line_below:
	}
//flaw_line_below:
	if (addr_len)
 		*addr_len = sizeof(*saddr);
//fix_flaw_line_below:
//	}
 
 	if (flags & MSG_TRUNC)
 		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	if (err)
		return err;
	return copied;
}
",179648,"static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,
		struct msghdr *msg, size_t len, int noblock, int flags,
		int *addr_len)
{
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *skb;
	struct sockaddr_ieee802154 *saddr;

	saddr = (struct sockaddr_ieee802154 *)msg->msg_name;

	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb)
		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	/* FIXME: skip headers if necessary ?! */
	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_ts_and_drops(msg, sk, skb);

 	if (saddr) {
 		saddr->family = AF_IEEE802154;
 		saddr->addr = mac_cb(skb)->sa;
	}
	if (addr_len)
 		*addr_len = sizeof(*saddr);
 
 	if (flags & MSG_TRUNC)
 		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	if (err)
		return err;
	return copied;
}
","static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,
		struct msghdr *msg, size_t len, int noblock, int flags,
		int *addr_len)
{
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *skb;
	struct sockaddr_ieee802154 *saddr;

	saddr = (struct sockaddr_ieee802154 *)msg->msg_name;

	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb)
		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	/* FIXME: skip headers if necessary ?! */
	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_ts_and_drops(msg, sk, skb);

 	if (saddr) {
 		saddr->family = AF_IEEE802154;
 		saddr->addr = mac_cb(skb)->sa;
 		*addr_len = sizeof(*saddr);
	}
 
 	if (flags & MSG_TRUNC)
 		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	if (err)
		return err;
	return copied;
}
","The `dgram_recvmsg` function is designed to receive a datagram message from a socket in a non-blocking manner. It first attempts to retrieve a socket buffer (`skb`) containing the incoming data. If successful, it checks if the provided buffer length is sufficient, potentially truncating the message and setting a flag if necessary. The function then copies the data from the socket buffer to the user-provided message structure, while also capturing the sender's address in a specific format. Finally, it handles any errors, cleans up the socket buffer, and returns the number of bytes copied or an error code if applicable.","The provided code defines a function that facilitates the reception of datagram messages from a socket in a non-blocking manner. It begins by attempting to retrieve incoming data, and if successful, it checks whether the buffer can accommodate the message length, potentially truncating it and setting a flag if needed. The function then copies the data into a user-defined structure while also capturing the sender's address in a specific format. After handling any errors and performing necessary cleanup, it returns either the number of bytes successfully copied or an error code if an issue occurred.","The vulnerability in the original code stemmed from the potential leakage of uninitialized memory to the user when returning the address length through the `addr_len` pointer. Specifically, the code updated `*addr_len` regardless of whether the address structure was filled, which could lead to returning garbage values if the address was not set. The fix involved updating `*addr_len` only after successfully populating the address structure, ensuring that only valid, initialized data is returned to the caller. Additionally, unnecessary checks for a null pointer were removed, as the function is guaranteed to receive a valid pointer.","The vulnerability in the original code allowed for the potential leakage of uninitialized memory to the user, as the address length was updated even when the address structure was not properly filled. This could result in returning invalid data to the caller, leading to security risks. The fix addressed this issue by ensuring that the address length is only updated after the address structure has been populated with valid data. Additionally, unnecessary checks for null pointers were removed, as the function is guaranteed to receive valid pointers, thus streamlining the code and enhancing its security.","The vulnerability was fixed by modifying the code to update the `*addr_len` only after the address structure was successfully populated. Specifically, the assignment of `*addr_len` to the size of the address structure now occurs only after the address is filled with valid data from the socket buffer. This change prevents the return of uninitialized memory to the caller. Additionally, the checks for `addr_len` being null were removed, as the function is assured to receive a valid pointer, thereby simplifying the logic and enhancing the overall security of the data being returned.","The vulnerability was addressed by ensuring that the length of the address is only updated after the address structure has been properly populated with valid data. This change prevents the function from returning uninitialized memory to the caller, which could lead to security issues. Additionally, unnecessary checks for null pointers were removed, as the function is guaranteed to receive valid pointers, streamlining the code. Overall, these modifications enhance the security and reliability of the data being returned, ensuring that only initialized and valid information is provided to the user.","4, 4","5,5","4,4","4,4"
48,48,179654,179654,,Local,Not required,,CVE-2013-7281,https://www.cvedetails.com/cve/CVE-2013-7281/,CWE-200,Low,Complete,,,2014-01-08,4.9,"The dgram_recvmsg function in net/ieee802154/dgram.c in the Linux kernel before 3.12.4 updates a certain length value without ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel stack memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call.",2017-08-28,+Info ,1,https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69,bceaa90240b6019ed73b49965eac7d167610be69,"inet: prevent leakage of uninitialized memory to user in recv syscalls

Only update *addr_len when we actually fill in sockaddr, otherwise we
can return uninitialized memory from the stack to the caller in the
recvfrom, recvmmsg and recvmsg syscalls. Drop the the (addr_len == NULL)
checks because we only get called with a valid addr_len pointer either
from sock_common_recvmsg or inet_recvmsg.

If a blocking read waits on a socket which is concurrently shut down we
now return zero and set msg_msgnamelen to 0.

Reported-by: mpb <mpb.mail@gmail.com>
Suggested-by: Eric Dumazet <eric.dumazet@gmail.com>
Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",2,net/l2tp/l2tp_ip.c,"{""sha"": ""1865fdf5a5a5116be8bf28b25f9c340f8b8fd50b"", ""filename"": ""net/ieee802154/dgram.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/ieee802154/dgram.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/ieee802154/dgram.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ieee802154/dgram.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -315,9 +315,8 @@ static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,\n \tif (saddr) {\n \t\tsaddr->family = AF_IEEE802154;\n \t\tsaddr->addr = mac_cb(skb)->sa;\n-\t}\n-\tif (addr_len)\n \t\t*addr_len = sizeof(*saddr);\n+\t}\n \n \tif (flags & MSG_TRUNC)\n \t\tcopied = skb->len;""}<_**next**_>{""sha"": ""aacefa0caa36af726e848e9f590625ae310e6732"", ""filename"": ""net/ipv4/ping.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 12, ""changes"": 19, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv4/ping.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv4/ping.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/ping.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -830,8 +830,6 @@ int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n {\n \tstruct inet_sock *isk = inet_sk(sk);\n \tint family = sk->sk_family;\n-\tstruct sockaddr_in *sin;\n-\tstruct sockaddr_in6 *sin6;\n \tstruct sk_buff *skb;\n \tint copied, err;\n \n@@ -841,13 +839,6 @@ int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \tif (flags & MSG_OOB)\n \t\tgoto out;\n \n-\tif (addr_len) {\n-\t\tif (family == AF_INET)\n-\t\t\t*addr_len = sizeof(*sin);\n-\t\telse if (family == AF_INET6 && addr_len)\n-\t\t\t*addr_len = sizeof(*sin6);\n-\t}\n-\n \tif (flags & MSG_ERRQUEUE) {\n \t\tif (family == AF_INET) {\n \t\t\treturn ip_recv_error(sk, msg, len);\n@@ -877,11 +868,13 @@ int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \n \t/* Copy the address and add cmsg data. */\n \tif (family == AF_INET) {\n-\t\tsin = (struct sockaddr_in *) msg->msg_name;\n+\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n+\n \t\tsin->sin_family = AF_INET;\n \t\tsin->sin_port = 0 /* skb->h.uh->source */;\n \t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n \t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n+\t\t*addr_len = sizeof(*sin);\n \n \t\tif (isk->cmsg_flags)\n \t\t\tip_cmsg_recv(msg, skb);\n@@ -890,17 +883,19 @@ int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \t} else if (family == AF_INET6) {\n \t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n \t\tstruct ipv6hdr *ip6 = ipv6_hdr(skb);\n-\t\tsin6 = (struct sockaddr_in6 *) msg->msg_name;\n+\t\tstruct sockaddr_in6 *sin6 =\n+\t\t\t(struct sockaddr_in6 *)msg->msg_name;\n+\n \t\tsin6->sin6_family = AF_INET6;\n \t\tsin6->sin6_port = 0;\n \t\tsin6->sin6_addr = ip6->saddr;\n-\n \t\tsin6->sin6_flowinfo = 0;\n \t\tif (np->sndflow)\n \t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);\n \n \t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n \t\t\t\t\t\t\t  IP6CB(skb)->iif);\n+\t\t*addr_len = sizeof(*sin6);\n \n \t\tif (inet6_sk(sk)->rxopt.all)\n \t\t\tpingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);""}<_**next**_>{""sha"": ""5cb8ddb505ee8911461ec92a5c74feef0b441e00"", ""filename"": ""net/ipv4/raw.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv4/raw.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv4/raw.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/raw.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -696,9 +696,6 @@ static int raw_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \tif (flags & MSG_OOB)\n \t\tgoto out;\n \n-\tif (addr_len)\n-\t\t*addr_len = sizeof(*sin);\n-\n \tif (flags & MSG_ERRQUEUE) {\n \t\terr = ip_recv_error(sk, msg, len);\n \t\tgoto out;\n@@ -726,6 +723,7 @@ static int raw_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n \t\tsin->sin_port = 0;\n \t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n+\t\t*addr_len = sizeof(*sin);\n \t}\n \tif (inet->cmsg_flags)\n \t\tip_cmsg_recv(msg, skb);""}<_**next**_>{""sha"": ""998431cd471a217668f19872e99ee989cd35ba2a"", ""filename"": ""net/ipv4/udp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 6, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv4/udp.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv4/udp.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/udp.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -1235,12 +1235,6 @@ int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \tint is_udplite = IS_UDPLITE(sk);\n \tbool slow;\n \n-\t/*\n-\t *\tCheck any passed addresses\n-\t */\n-\tif (addr_len)\n-\t\t*addr_len = sizeof(*sin);\n-\n \tif (flags & MSG_ERRQUEUE)\n \t\treturn ip_recv_error(sk, msg, len);\n \n@@ -1302,6 +1296,7 @@ int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \t\tsin->sin_port = udp_hdr(skb)->source;\n \t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n \t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n+\t\t*addr_len = sizeof(*sin);\n \t}\n \tif (inet->cmsg_flags)\n \t\tip_cmsg_recv(msg, skb);""}<_**next**_>{""sha"": ""e24ff1df0401288e4e810cf79ec3ea20d86a06c0"", ""filename"": ""net/ipv6/raw.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv6/raw.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv6/raw.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/raw.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -465,9 +465,6 @@ static int rawv6_recvmsg(struct kiocb *iocb, struct sock *sk,\n \tif (flags & MSG_OOB)\n \t\treturn -EOPNOTSUPP;\n \n-\tif (addr_len)\n-\t\t*addr_len=sizeof(*sin6);\n-\n \tif (flags & MSG_ERRQUEUE)\n \t\treturn ipv6_recv_error(sk, msg, len);\n \n@@ -506,6 +503,7 @@ static int rawv6_recvmsg(struct kiocb *iocb, struct sock *sk,\n \t\tsin6->sin6_flowinfo = 0;\n \t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n \t\t\t\t\t\t\t  IP6CB(skb)->iif);\n+\t\t*addr_len = sizeof(*sin6);\n \t}\n \n \tsock_recv_ts_and_drops(msg, sk, skb);""}<_**next**_>{""sha"": ""81eb8cf8389b6a5af55f7b2994d7dbefe3d732bf"", ""filename"": ""net/ipv6/udp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 4, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv6/udp.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv6/udp.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/udp.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -392,9 +392,6 @@ int udpv6_recvmsg(struct kiocb *iocb, struct sock *sk,\n \tint is_udp4;\n \tbool slow;\n \n-\tif (addr_len)\n-\t\t*addr_len = sizeof(struct sockaddr_in6);\n-\n \tif (flags & MSG_ERRQUEUE)\n \t\treturn ipv6_recv_error(sk, msg, len);\n \n@@ -480,7 +477,7 @@ int udpv6_recvmsg(struct kiocb *iocb, struct sock *sk,\n \t\t\t\tipv6_iface_scope_id(&sin6->sin6_addr,\n \t\t\t\t\t\t    IP6CB(skb)->iif);\n \t\t}\n-\n+\t\t*addr_len = sizeof(*sin6);\n \t}\n \tif (is_udp4) {\n \t\tif (inet->cmsg_flags)""}<_**next**_>{""sha"": ""da1a1cee1a088e39816d565e99975bbc69a392d3"", ""filename"": ""net/l2tp/l2tp_ip.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/l2tp/l2tp_ip.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/l2tp/l2tp_ip.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/l2tp/l2tp_ip.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -518,9 +518,6 @@ static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *m\n \tif (flags & MSG_OOB)\n \t\tgoto out;\n \n-\tif (addr_len)\n-\t\t*addr_len = sizeof(*sin);\n-\n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb)\n \t\tgoto out;\n@@ -543,6 +540,7 @@ static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *m\n \t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n \t\tsin->sin_port = 0;\n \t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n+\t\t*addr_len = sizeof(*sin);\n \t}\n \tif (inet->cmsg_flags)\n \t\tip_cmsg_recv(msg, skb);""}<_**next**_>{""sha"": ""38946b26e471c9754c922d3451e8ec2682f5ae3d"", ""filename"": ""net/phonet/datagram.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/phonet/datagram.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/phonet/datagram.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/phonet/datagram.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -139,9 +139,6 @@ static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,\n \t\t\tMSG_CMSG_COMPAT))\n \t\tgoto out_nofree;\n \n-\tif (addr_len)\n-\t\t*addr_len = sizeof(sa);\n-\n \tskb = skb_recv_datagram(sk, flags, noblock, &rval);\n \tif (skb == NULL)\n \t\tgoto out_nofree;\n@@ -162,8 +159,10 @@ static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,\n \n \trval = (flags & MSG_TRUNC) ? skb->len : copylen;\n \n-\tif (msg->msg_name != NULL)\n-\t\tmemcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));\n+\tif (msg->msg_name != NULL) {\n+\t\tmemcpy(msg->msg_name, &sa, sizeof(sa));\n+\t\t*addr_len = sizeof(sa);\n+\t}\n \n out:\n \tskb_free_datagram(sk, skb);""}","static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
			   size_t len, int noblock, int flags, int *addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
	struct sk_buff *skb;

 	if (flags & MSG_OOB)
 		goto out;
 
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb)
 		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_timestamp(msg, sk, skb);

	/* Copy the address. */
	if (sin) {
		sin->sin_family = AF_INET;
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
 		sin->sin_port = 0;
 		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
		*addr_len = sizeof(*sin);
 	}
 	if (inet->cmsg_flags)
 		ip_cmsg_recv(msg, skb);
	if (flags & MSG_TRUNC)
		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	return err ? err : copied;
}
","static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
			   size_t len, int noblock, int flags, int *addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
	struct sk_buff *skb;

 	if (flags & MSG_OOB)
 		goto out;
 
	if (addr_len)
		*addr_len = sizeof(*sin);
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb)
 		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_timestamp(msg, sk, skb);

	/* Copy the address. */
	if (sin) {
		sin->sin_family = AF_INET;
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
 		sin->sin_port = 0;
 		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
 	}
 	if (inet->cmsg_flags)
 		ip_cmsg_recv(msg, skb);
	if (flags & MSG_TRUNC)
		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	return err ? err : copied;
}
",C,"		*addr_len = sizeof(*sin);
","	if (addr_len)
		*addr_len = sizeof(*sin);
",,"@@ -518,9 +518,6 @@ static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *m
 	if (flags & MSG_OOB)
 		goto out;
 
-	if (addr_len)
-		*addr_len = sizeof(*sin);
-
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb)
 		goto out;
@@ -543,6 +540,7 @@ static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *m
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
 		sin->sin_port = 0;
 		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
+		*addr_len = sizeof(*sin);
 	}
 	if (inet->cmsg_flags)
 		ip_cmsg_recv(msg, skb);",linux,bceaa90240b6019ed73b49965eac7d167610be69,bcd081a3aef1f7f3786067ae8dd26aaa1cf85153,1,"static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
			   size_t len, int noblock, int flags, int *addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
	struct sk_buff *skb;

 	if (flags & MSG_OOB)
 		goto out;
 
//flaw_line_below:
	if (addr_len)
//flaw_line_below:
		*addr_len = sizeof(*sin);
//flaw_line_below:

 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb)
 		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_timestamp(msg, sk, skb);

	/* Copy the address. */
	if (sin) {
		sin->sin_family = AF_INET;
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
 		sin->sin_port = 0;
 		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
//fix_flaw_line_below:
//		*addr_len = sizeof(*sin);
 	}
 	if (inet->cmsg_flags)
 		ip_cmsg_recv(msg, skb);
	if (flags & MSG_TRUNC)
		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	return err ? err : copied;
}
",179654,"static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
			   size_t len, int noblock, int flags, int *addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
	struct sk_buff *skb;

 	if (flags & MSG_OOB)
 		goto out;
 
	if (addr_len)
		*addr_len = sizeof(*sin);
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb)
 		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_timestamp(msg, sk, skb);

	/* Copy the address. */
	if (sin) {
		sin->sin_family = AF_INET;
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
 		sin->sin_port = 0;
 		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
 	}
 	if (inet->cmsg_flags)
 		ip_cmsg_recv(msg, skb);
	if (flags & MSG_TRUNC)
		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	return err ? err : copied;
}
","static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
			   size_t len, int noblock, int flags, int *addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
	struct sk_buff *skb;

 	if (flags & MSG_OOB)
 		goto out;
 
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb)
 		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_timestamp(msg, sk, skb);

	/* Copy the address. */
	if (sin) {
		sin->sin_family = AF_INET;
 		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
 		sin->sin_port = 0;
 		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
		*addr_len = sizeof(*sin);
 	}
 	if (inet->cmsg_flags)
 		ip_cmsg_recv(msg, skb);
	if (flags & MSG_TRUNC)
		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	return err ? err : copied;
}
","The `l2tp_ip_recvmsg` function processes incoming L2TP (Layer 2 Tunneling Protocol) IP messages for a socket. It begins by checking for out-of-band data and initializes the address length if provided. The function attempts to receive a datagram from the socket, handling potential errors. If successful, it copies the data into the provided message buffer, truncating if necessary. It also retrieves and populates the source address from the IP header of the received packet. Finally, it handles any control message flags and cleans up by freeing the socket buffer before returning the number of bytes copied or an error code.","The provided code defines a function that handles the reception of incoming messages for a specific protocol over a socket. It checks for special data types and initializes the address length if applicable. The function attempts to retrieve a message from the socket, managing any errors that may arise. Upon successful retrieval, it copies the message data into a designated buffer, potentially truncating it if the buffer is smaller than the message. Additionally, it extracts and sets the source address from the message header, processes any control message flags, and ensures proper cleanup before returning the number of bytes copied or an error code.","The vulnerability in the original code stemmed from the potential leakage of uninitialized memory to the user when the `*addr_len` variable was updated without ensuring that the corresponding address structure was filled. This could allow an attacker to read sensitive data from the stack if the address length was returned without proper initialization. The fix involved updating `*addr_len` only after the address structure was populated, ensuring that it contained valid data. Additionally, the checks for `addr_len` being NULL were removed, as the function is guaranteed to receive a valid pointer, thus preventing any unintended memory exposure.","The vulnerability in the original code allowed for the potential exposure of uninitialized memory to users when returning the length of an address structure. This could lead to sensitive data being unintentionally revealed if the address length was updated without ensuring that the address itself was properly initialized. The fix addressed this issue by ensuring that the length was only updated after the address structure was filled with valid data. Additionally, unnecessary checks for the validity of the address length pointer were removed, as the function is guaranteed to receive a valid pointer, thereby enhancing security and reliability.","The vulnerability was fixed by modifying the code to update the `*addr_len` variable only after the address structure was populated with valid data. Specifically, the assignment of `*addr_len` was moved to occur after the address fields were filled, ensuring that it would not return uninitialized memory. Additionally, the checks for `addr_len` being NULL were removed, as the function is called with a valid pointer from higher-level functions. This change prevents the leakage of sensitive data from the stack and ensures that the address length reflects only valid, initialized data.","The vulnerability was addressed by ensuring that the length of the address was only updated after the address structure had been properly initialized with valid data. This change prevents the function from returning any uninitialized memory to the caller, which could potentially expose sensitive information. Additionally, unnecessary checks for the validity of the address length pointer were removed, as the function is guaranteed to receive a valid pointer from its callers. These modifications enhance the security of the code by ensuring that only correctly initialized data is returned, thereby mitigating the risk of memory leakage.","4, 4","5,5","4,4","4,4"
49,49,179655,179655,,Local,Not required,,CVE-2013-7281,https://www.cvedetails.com/cve/CVE-2013-7281/,CWE-200,Low,Complete,,,2014-01-08,4.9,"The dgram_recvmsg function in net/ieee802154/dgram.c in the Linux kernel before 3.12.4 updates a certain length value without ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel stack memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call.",2017-08-28,+Info ,4,https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69,bceaa90240b6019ed73b49965eac7d167610be69,"inet: prevent leakage of uninitialized memory to user in recv syscalls

Only update *addr_len when we actually fill in sockaddr, otherwise we
can return uninitialized memory from the stack to the caller in the
recvfrom, recvmmsg and recvmsg syscalls. Drop the the (addr_len == NULL)
checks because we only get called with a valid addr_len pointer either
from sock_common_recvmsg or inet_recvmsg.

If a blocking read waits on a socket which is concurrently shut down we
now return zero and set msg_msgnamelen to 0.

Reported-by: mpb <mpb.mail@gmail.com>
Suggested-by: Eric Dumazet <eric.dumazet@gmail.com>
Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",4,net/phonet/datagram.c,"{""sha"": ""1865fdf5a5a5116be8bf28b25f9c340f8b8fd50b"", ""filename"": ""net/ieee802154/dgram.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/ieee802154/dgram.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/ieee802154/dgram.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ieee802154/dgram.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -315,9 +315,8 @@ static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,\n \tif (saddr) {\n \t\tsaddr->family = AF_IEEE802154;\n \t\tsaddr->addr = mac_cb(skb)->sa;\n-\t}\n-\tif (addr_len)\n \t\t*addr_len = sizeof(*saddr);\n+\t}\n \n \tif (flags & MSG_TRUNC)\n \t\tcopied = skb->len;""}<_**next**_>{""sha"": ""aacefa0caa36af726e848e9f590625ae310e6732"", ""filename"": ""net/ipv4/ping.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 12, ""changes"": 19, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv4/ping.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv4/ping.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/ping.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -830,8 +830,6 @@ int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n {\n \tstruct inet_sock *isk = inet_sk(sk);\n \tint family = sk->sk_family;\n-\tstruct sockaddr_in *sin;\n-\tstruct sockaddr_in6 *sin6;\n \tstruct sk_buff *skb;\n \tint copied, err;\n \n@@ -841,13 +839,6 @@ int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \tif (flags & MSG_OOB)\n \t\tgoto out;\n \n-\tif (addr_len) {\n-\t\tif (family == AF_INET)\n-\t\t\t*addr_len = sizeof(*sin);\n-\t\telse if (family == AF_INET6 && addr_len)\n-\t\t\t*addr_len = sizeof(*sin6);\n-\t}\n-\n \tif (flags & MSG_ERRQUEUE) {\n \t\tif (family == AF_INET) {\n \t\t\treturn ip_recv_error(sk, msg, len);\n@@ -877,11 +868,13 @@ int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \n \t/* Copy the address and add cmsg data. */\n \tif (family == AF_INET) {\n-\t\tsin = (struct sockaddr_in *) msg->msg_name;\n+\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n+\n \t\tsin->sin_family = AF_INET;\n \t\tsin->sin_port = 0 /* skb->h.uh->source */;\n \t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n \t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n+\t\t*addr_len = sizeof(*sin);\n \n \t\tif (isk->cmsg_flags)\n \t\t\tip_cmsg_recv(msg, skb);\n@@ -890,17 +883,19 @@ int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \t} else if (family == AF_INET6) {\n \t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n \t\tstruct ipv6hdr *ip6 = ipv6_hdr(skb);\n-\t\tsin6 = (struct sockaddr_in6 *) msg->msg_name;\n+\t\tstruct sockaddr_in6 *sin6 =\n+\t\t\t(struct sockaddr_in6 *)msg->msg_name;\n+\n \t\tsin6->sin6_family = AF_INET6;\n \t\tsin6->sin6_port = 0;\n \t\tsin6->sin6_addr = ip6->saddr;\n-\n \t\tsin6->sin6_flowinfo = 0;\n \t\tif (np->sndflow)\n \t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);\n \n \t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n \t\t\t\t\t\t\t  IP6CB(skb)->iif);\n+\t\t*addr_len = sizeof(*sin6);\n \n \t\tif (inet6_sk(sk)->rxopt.all)\n \t\t\tpingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);""}<_**next**_>{""sha"": ""5cb8ddb505ee8911461ec92a5c74feef0b441e00"", ""filename"": ""net/ipv4/raw.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv4/raw.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv4/raw.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/raw.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -696,9 +696,6 @@ static int raw_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \tif (flags & MSG_OOB)\n \t\tgoto out;\n \n-\tif (addr_len)\n-\t\t*addr_len = sizeof(*sin);\n-\n \tif (flags & MSG_ERRQUEUE) {\n \t\terr = ip_recv_error(sk, msg, len);\n \t\tgoto out;\n@@ -726,6 +723,7 @@ static int raw_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n \t\tsin->sin_port = 0;\n \t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n+\t\t*addr_len = sizeof(*sin);\n \t}\n \tif (inet->cmsg_flags)\n \t\tip_cmsg_recv(msg, skb);""}<_**next**_>{""sha"": ""998431cd471a217668f19872e99ee989cd35ba2a"", ""filename"": ""net/ipv4/udp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 6, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv4/udp.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv4/udp.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/udp.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -1235,12 +1235,6 @@ int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \tint is_udplite = IS_UDPLITE(sk);\n \tbool slow;\n \n-\t/*\n-\t *\tCheck any passed addresses\n-\t */\n-\tif (addr_len)\n-\t\t*addr_len = sizeof(*sin);\n-\n \tif (flags & MSG_ERRQUEUE)\n \t\treturn ip_recv_error(sk, msg, len);\n \n@@ -1302,6 +1296,7 @@ int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \t\tsin->sin_port = udp_hdr(skb)->source;\n \t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n \t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n+\t\t*addr_len = sizeof(*sin);\n \t}\n \tif (inet->cmsg_flags)\n \t\tip_cmsg_recv(msg, skb);""}<_**next**_>{""sha"": ""e24ff1df0401288e4e810cf79ec3ea20d86a06c0"", ""filename"": ""net/ipv6/raw.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv6/raw.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv6/raw.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/raw.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -465,9 +465,6 @@ static int rawv6_recvmsg(struct kiocb *iocb, struct sock *sk,\n \tif (flags & MSG_OOB)\n \t\treturn -EOPNOTSUPP;\n \n-\tif (addr_len)\n-\t\t*addr_len=sizeof(*sin6);\n-\n \tif (flags & MSG_ERRQUEUE)\n \t\treturn ipv6_recv_error(sk, msg, len);\n \n@@ -506,6 +503,7 @@ static int rawv6_recvmsg(struct kiocb *iocb, struct sock *sk,\n \t\tsin6->sin6_flowinfo = 0;\n \t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n \t\t\t\t\t\t\t  IP6CB(skb)->iif);\n+\t\t*addr_len = sizeof(*sin6);\n \t}\n \n \tsock_recv_ts_and_drops(msg, sk, skb);""}<_**next**_>{""sha"": ""81eb8cf8389b6a5af55f7b2994d7dbefe3d732bf"", ""filename"": ""net/ipv6/udp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 4, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv6/udp.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/ipv6/udp.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/udp.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -392,9 +392,6 @@ int udpv6_recvmsg(struct kiocb *iocb, struct sock *sk,\n \tint is_udp4;\n \tbool slow;\n \n-\tif (addr_len)\n-\t\t*addr_len = sizeof(struct sockaddr_in6);\n-\n \tif (flags & MSG_ERRQUEUE)\n \t\treturn ipv6_recv_error(sk, msg, len);\n \n@@ -480,7 +477,7 @@ int udpv6_recvmsg(struct kiocb *iocb, struct sock *sk,\n \t\t\t\tipv6_iface_scope_id(&sin6->sin6_addr,\n \t\t\t\t\t\t    IP6CB(skb)->iif);\n \t\t}\n-\n+\t\t*addr_len = sizeof(*sin6);\n \t}\n \tif (is_udp4) {\n \t\tif (inet->cmsg_flags)""}<_**next**_>{""sha"": ""da1a1cee1a088e39816d565e99975bbc69a392d3"", ""filename"": ""net/l2tp/l2tp_ip.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/l2tp/l2tp_ip.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/l2tp/l2tp_ip.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/l2tp/l2tp_ip.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -518,9 +518,6 @@ static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *m\n \tif (flags & MSG_OOB)\n \t\tgoto out;\n \n-\tif (addr_len)\n-\t\t*addr_len = sizeof(*sin);\n-\n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb)\n \t\tgoto out;\n@@ -543,6 +540,7 @@ static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *m\n \t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n \t\tsin->sin_port = 0;\n \t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n+\t\t*addr_len = sizeof(*sin);\n \t}\n \tif (inet->cmsg_flags)\n \t\tip_cmsg_recv(msg, skb);""}<_**next**_>{""sha"": ""38946b26e471c9754c922d3451e8ec2682f5ae3d"", ""filename"": ""net/phonet/datagram.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/bceaa90240b6019ed73b49965eac7d167610be69/net/phonet/datagram.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bceaa90240b6019ed73b49965eac7d167610be69/net/phonet/datagram.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/phonet/datagram.c?ref=bceaa90240b6019ed73b49965eac7d167610be69"", ""patch"": ""@@ -139,9 +139,6 @@ static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,\n \t\t\tMSG_CMSG_COMPAT))\n \t\tgoto out_nofree;\n \n-\tif (addr_len)\n-\t\t*addr_len = sizeof(sa);\n-\n \tskb = skb_recv_datagram(sk, flags, noblock, &rval);\n \tif (skb == NULL)\n \t\tgoto out_nofree;\n@@ -162,8 +159,10 @@ static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,\n \n \trval = (flags & MSG_TRUNC) ? skb->len : copylen;\n \n-\tif (msg->msg_name != NULL)\n-\t\tmemcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));\n+\tif (msg->msg_name != NULL) {\n+\t\tmemcpy(msg->msg_name, &sa, sizeof(sa));\n+\t\t*addr_len = sizeof(sa);\n+\t}\n \n out:\n \tskb_free_datagram(sk, skb);""}","static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,
			struct msghdr *msg, size_t len, int noblock,
			int flags, int *addr_len)
{
	struct sk_buff *skb = NULL;
	struct sockaddr_pn sa;
	int rval = -EOPNOTSUPP;
	int copylen;

	if (flags & ~(MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_NOSIGNAL|
 			MSG_CMSG_COMPAT))
 		goto out_nofree;
 
 	skb = skb_recv_datagram(sk, flags, noblock, &rval);
 	if (skb == NULL)
 		goto out_nofree;

	pn_skb_get_src_sockaddr(skb, &sa);

	copylen = skb->len;
	if (len < copylen) {
		msg->msg_flags |= MSG_TRUNC;
		copylen = len;
	}

	rval = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copylen);
	if (rval) {
		rval = -EFAULT;
		goto out;
	}
 
 	rval = (flags & MSG_TRUNC) ? skb->len : copylen;
 
	if (msg->msg_name != NULL) {
		memcpy(msg->msg_name, &sa, sizeof(sa));
		*addr_len = sizeof(sa);
	}
 
 out:
 	skb_free_datagram(sk, skb);

out_nofree:
	return rval;
}
","static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,
			struct msghdr *msg, size_t len, int noblock,
			int flags, int *addr_len)
{
	struct sk_buff *skb = NULL;
	struct sockaddr_pn sa;
	int rval = -EOPNOTSUPP;
	int copylen;

	if (flags & ~(MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_NOSIGNAL|
 			MSG_CMSG_COMPAT))
 		goto out_nofree;
 
	if (addr_len)
		*addr_len = sizeof(sa);
 	skb = skb_recv_datagram(sk, flags, noblock, &rval);
 	if (skb == NULL)
 		goto out_nofree;

	pn_skb_get_src_sockaddr(skb, &sa);

	copylen = skb->len;
	if (len < copylen) {
		msg->msg_flags |= MSG_TRUNC;
		copylen = len;
	}

	rval = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copylen);
	if (rval) {
		rval = -EFAULT;
		goto out;
	}
 
 	rval = (flags & MSG_TRUNC) ? skb->len : copylen;
 
	if (msg->msg_name != NULL)
		memcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));
 
 out:
 	skb_free_datagram(sk, skb);

out_nofree:
	return rval;
}
",C,"	if (msg->msg_name != NULL) {
		memcpy(msg->msg_name, &sa, sizeof(sa));
		*addr_len = sizeof(sa);
	}
","	if (addr_len)
		*addr_len = sizeof(sa);
	if (msg->msg_name != NULL)
		memcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));
",,"@@ -139,9 +139,6 @@ static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,
 			MSG_CMSG_COMPAT))
 		goto out_nofree;
 
-	if (addr_len)
-		*addr_len = sizeof(sa);
-
 	skb = skb_recv_datagram(sk, flags, noblock, &rval);
 	if (skb == NULL)
 		goto out_nofree;
@@ -162,8 +159,10 @@ static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,
 
 	rval = (flags & MSG_TRUNC) ? skb->len : copylen;
 
-	if (msg->msg_name != NULL)
-		memcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));
+	if (msg->msg_name != NULL) {
+		memcpy(msg->msg_name, &sa, sizeof(sa));
+		*addr_len = sizeof(sa);
+	}
 
 out:
 	skb_free_datagram(sk, skb);",linux,bceaa90240b6019ed73b49965eac7d167610be69,bcd081a3aef1f7f3786067ae8dd26aaa1cf85153,1,"static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,
			struct msghdr *msg, size_t len, int noblock,
			int flags, int *addr_len)
{
	struct sk_buff *skb = NULL;
	struct sockaddr_pn sa;
	int rval = -EOPNOTSUPP;
	int copylen;

	if (flags & ~(MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_NOSIGNAL|
 			MSG_CMSG_COMPAT))
 		goto out_nofree;
 
//flaw_line_below:
	if (addr_len)
//flaw_line_below:
		*addr_len = sizeof(sa);
//flaw_line_below:

 	skb = skb_recv_datagram(sk, flags, noblock, &rval);
 	if (skb == NULL)
 		goto out_nofree;

	pn_skb_get_src_sockaddr(skb, &sa);

	copylen = skb->len;
	if (len < copylen) {
		msg->msg_flags |= MSG_TRUNC;
		copylen = len;
	}

	rval = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copylen);
	if (rval) {
		rval = -EFAULT;
		goto out;
	}
 
 	rval = (flags & MSG_TRUNC) ? skb->len : copylen;
 
//flaw_line_below:
	if (msg->msg_name != NULL)
//flaw_line_below:
		memcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));
//fix_flaw_line_below:
//	if (msg->msg_name != NULL) {
//fix_flaw_line_below:
//		memcpy(msg->msg_name, &sa, sizeof(sa));
//fix_flaw_line_below:
//		*addr_len = sizeof(sa);
//fix_flaw_line_below:
//	}
 
 out:
 	skb_free_datagram(sk, skb);

out_nofree:
	return rval;
}
",179655,"static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,
			struct msghdr *msg, size_t len, int noblock,
			int flags, int *addr_len)
{
	struct sk_buff *skb = NULL;
	struct sockaddr_pn sa;
	int rval = -EOPNOTSUPP;
	int copylen;

	if (flags & ~(MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_NOSIGNAL|
 			MSG_CMSG_COMPAT))
 		goto out_nofree;
 
	if (addr_len)
		*addr_len = sizeof(sa);
 	skb = skb_recv_datagram(sk, flags, noblock, &rval);
 	if (skb == NULL)
 		goto out_nofree;

	pn_skb_get_src_sockaddr(skb, &sa);

	copylen = skb->len;
	if (len < copylen) {
		msg->msg_flags |= MSG_TRUNC;
		copylen = len;
	}

	rval = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copylen);
	if (rval) {
		rval = -EFAULT;
		goto out;
	}
 
 	rval = (flags & MSG_TRUNC) ? skb->len : copylen;
 
	if (msg->msg_name != NULL)
		memcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));
 
 out:
 	skb_free_datagram(sk, skb);

out_nofree:
	return rval;
}
","static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,
			struct msghdr *msg, size_t len, int noblock,
			int flags, int *addr_len)
{
	struct sk_buff *skb = NULL;
	struct sockaddr_pn sa;
	int rval = -EOPNOTSUPP;
	int copylen;

	if (flags & ~(MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_NOSIGNAL|
 			MSG_CMSG_COMPAT))
 		goto out_nofree;
 
 	skb = skb_recv_datagram(sk, flags, noblock, &rval);
 	if (skb == NULL)
 		goto out_nofree;

	pn_skb_get_src_sockaddr(skb, &sa);

	copylen = skb->len;
	if (len < copylen) {
		msg->msg_flags |= MSG_TRUNC;
		copylen = len;
	}

	rval = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copylen);
	if (rval) {
		rval = -EFAULT;
		goto out;
	}
 
 	rval = (flags & MSG_TRUNC) ? skb->len : copylen;
 
	if (msg->msg_name != NULL) {
		memcpy(msg->msg_name, &sa, sizeof(sa));
		*addr_len = sizeof(sa);
	}
 
 out:
 	skb_free_datagram(sk, skb);

out_nofree:
	return rval;
}
","The `pn_recvmsg` function is designed to receive messages from a socket in a non-blocking manner, handling various flags that dictate its behavior. It first checks for unsupported flags and initializes the address length if provided. The function attempts to retrieve a socket buffer (skb) containing the incoming message; if successful, it extracts the source socket address and determines the amount of data to copy based on the provided length. It then copies the data into the message header's I/O vector, updates the message flags if truncation occurs, and optionally copies the source address to the message structure before freeing the socket buffer and returning the result.","The code implements a function that facilitates the reception of messages from a socket in a non-blocking manner, while accommodating specific operational flags. It begins by validating the provided flags and initializing the address length if applicable. The function attempts to retrieve a data packet from the socket; upon success, it extracts the source address and determines the amount of data to be copied based on the specified length. It then copies the data into the designated message structure, updates flags if the message is truncated, and optionally stores the source address before releasing the resources associated with the data packet and returning the result.","The vulnerability in the original code stemmed from the potential leakage of uninitialized memory to the user when the `addr_len` variable was updated without ensuring that the corresponding address structure was filled. Specifically, if the `msg->msg_name` was not set, the function could return an uninitialized value in `addr_len`, leading to information disclosure. The fix addressed this by ensuring that `*addr_len` is only updated after the source address is successfully populated, thus preventing the return of uninitialized memory. Additionally, the checks for `addr_len` being NULL were removed, as the function is guaranteed to receive a valid pointer.","The vulnerability in the original code allowed for the potential leakage of uninitialized memory to the user, as the length of the address was updated even when the address structure was not properly filled. This could result in the caller receiving garbage values, leading to security risks. The fix implemented a safeguard by ensuring that the length is only updated after the address structure is populated, thus preventing the return of uninitialized data. Additionally, unnecessary checks for the validity of the address length pointer were removed, as the function is assured to receive a valid pointer in its context.","The vulnerability was fixed by modifying the code to update the `*addr_len` variable only after the source address structure was successfully populated. This change ensures that uninitialized memory is not returned to the caller, as `*addr_len` is now set only when the `msg->msg_name` is filled with valid data. Additionally, the checks for `addr_len` being NULL were removed, as the function is guaranteed to receive a valid pointer from its callers. This approach effectively prevents the leakage of uninitialized memory in the `recvfrom`, `recvmmsg`, and `recvmsg` system calls.","The vulnerability was addressed by ensuring that the length of the address is only updated after the address structure has been properly populated with valid data. This change prevents the function from returning uninitialized memory to the caller, thereby mitigating the risk of information leakage. Additionally, unnecessary checks for the validity of the address length pointer were removed, as the function is designed to always receive a valid pointer in its context. This approach enhances the overall security of the code by ensuring that only initialized and meaningful data is returned to the user.","4,4","5,5","4,4","4,4"
50,50,179729,179729,,Local,Not required,,CVE-2011-2909,https://www.cvedetails.com/cve/CVE-2011-2909/,CWE-200,Low,Complete,,,2014-02-15,4.9,The do_devinfo_ioctl function in drivers/staging/comedi/comedi_fops.c in the Linux kernel before 3.1 allows local users to obtain sensitive information from kernel memory via a copy of a short string.,2014-02-18,+Info ,2,https://github.com/torvalds/linux/commit/819cbb120eaec7e014e5abd029260db1ca8c5735,819cbb120eaec7e014e5abd029260db1ca8c5735,"staging: comedi: fix infoleak to userspace

driver_name and board_name are pointers to strings, not buffers of size
COMEDI_NAMELEN.  Copying COMEDI_NAMELEN bytes of a string containing
less than COMEDI_NAMELEN-1 bytes would leak some unrelated bytes.

Signed-off-by: Vasiliy Kulikov <segoon@openwall.com>
Cc: stable <stable@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>",2,drivers/staging/comedi/comedi_fops.c,"{""sha"": ""419976b40bf47d0f46ed997d34650a72f7d5b0a4"", ""filename"": ""drivers/staging/comedi/comedi_fops.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/819cbb120eaec7e014e5abd029260db1ca8c5735/drivers/staging/comedi/comedi_fops.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/819cbb120eaec7e014e5abd029260db1ca8c5735/drivers/staging/comedi/comedi_fops.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/staging/comedi/comedi_fops.c?ref=819cbb120eaec7e014e5abd029260db1ca8c5735"", ""patch"": ""@@ -383,8 +383,8 @@ static int do_devinfo_ioctl(struct comedi_device *dev,\n \t/* fill devinfo structure */\n \tdevinfo.version_code = COMEDI_VERSION_CODE;\n \tdevinfo.n_subdevs = dev->n_subdevices;\n-\tmemcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);\n-\tmemcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);\n+\tstrlcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);\n+\tstrlcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);\n \n \tif (read_subdev)\n \t\tdevinfo.read_subdevice = read_subdev - dev->subdevices;""}","static int do_devinfo_ioctl(struct comedi_device *dev,
			    struct comedi_devinfo __user *arg,
			    struct file *file)
{
	struct comedi_devinfo devinfo;
	const unsigned minor = iminor(file->f_dentry->d_inode);
	struct comedi_device_file_info *dev_file_info =
	    comedi_get_device_file_info(minor);
	struct comedi_subdevice *read_subdev =
	    comedi_get_read_subdevice(dev_file_info);
	struct comedi_subdevice *write_subdev =
	    comedi_get_write_subdevice(dev_file_info);

	memset(&devinfo, 0, sizeof(devinfo));

 	/* fill devinfo structure */
 	devinfo.version_code = COMEDI_VERSION_CODE;
 	devinfo.n_subdevs = dev->n_subdevices;
	strlcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);
	strlcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);
 
 	if (read_subdev)
 		devinfo.read_subdevice = read_subdev - dev->subdevices;
	else
		devinfo.read_subdevice = -1;

	if (write_subdev)
		devinfo.write_subdevice = write_subdev - dev->subdevices;
	else
		devinfo.write_subdevice = -1;

	if (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))
		return -EFAULT;

	return 0;
}
","static int do_devinfo_ioctl(struct comedi_device *dev,
			    struct comedi_devinfo __user *arg,
			    struct file *file)
{
	struct comedi_devinfo devinfo;
	const unsigned minor = iminor(file->f_dentry->d_inode);
	struct comedi_device_file_info *dev_file_info =
	    comedi_get_device_file_info(minor);
	struct comedi_subdevice *read_subdev =
	    comedi_get_read_subdevice(dev_file_info);
	struct comedi_subdevice *write_subdev =
	    comedi_get_write_subdevice(dev_file_info);

	memset(&devinfo, 0, sizeof(devinfo));

 	/* fill devinfo structure */
 	devinfo.version_code = COMEDI_VERSION_CODE;
 	devinfo.n_subdevs = dev->n_subdevices;
	memcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);
	memcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);
 
 	if (read_subdev)
 		devinfo.read_subdevice = read_subdev - dev->subdevices;
	else
		devinfo.read_subdevice = -1;

	if (write_subdev)
		devinfo.write_subdevice = write_subdev - dev->subdevices;
	else
		devinfo.write_subdevice = -1;

	if (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))
		return -EFAULT;

	return 0;
}
",C,"	strlcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);
	strlcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);
","	memcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);
	memcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);
",,"@@ -383,8 +383,8 @@ static int do_devinfo_ioctl(struct comedi_device *dev,
 	/* fill devinfo structure */
 	devinfo.version_code = COMEDI_VERSION_CODE;
 	devinfo.n_subdevs = dev->n_subdevices;
-	memcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);
-	memcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);
+	strlcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);
+	strlcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);
 
 	if (read_subdev)
 		devinfo.read_subdevice = read_subdev - dev->subdevices;",linux,819cbb120eaec7e014e5abd029260db1ca8c5735,85678d5d27cb0ea1005316f51b1b062bf4609b66,1,"static int do_devinfo_ioctl(struct comedi_device *dev,
			    struct comedi_devinfo __user *arg,
			    struct file *file)
{
	struct comedi_devinfo devinfo;
	const unsigned minor = iminor(file->f_dentry->d_inode);
	struct comedi_device_file_info *dev_file_info =
	    comedi_get_device_file_info(minor);
	struct comedi_subdevice *read_subdev =
	    comedi_get_read_subdevice(dev_file_info);
	struct comedi_subdevice *write_subdev =
	    comedi_get_write_subdevice(dev_file_info);

	memset(&devinfo, 0, sizeof(devinfo));

 	/* fill devinfo structure */
 	devinfo.version_code = COMEDI_VERSION_CODE;
 	devinfo.n_subdevs = dev->n_subdevices;
//flaw_line_below:
	memcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);
//flaw_line_below:
	memcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);
//fix_flaw_line_below:
//	strlcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);
//fix_flaw_line_below:
//	strlcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);
 
 	if (read_subdev)
 		devinfo.read_subdevice = read_subdev - dev->subdevices;
	else
		devinfo.read_subdevice = -1;

	if (write_subdev)
		devinfo.write_subdevice = write_subdev - dev->subdevices;
	else
		devinfo.write_subdevice = -1;

	if (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))
		return -EFAULT;

	return 0;
}
",179729,"static int do_devinfo_ioctl(struct comedi_device *dev,
			    struct comedi_devinfo __user *arg,
			    struct file *file)
{
	struct comedi_devinfo devinfo;
	const unsigned minor = iminor(file->f_dentry->d_inode);
	struct comedi_device_file_info *dev_file_info =
	    comedi_get_device_file_info(minor);
	struct comedi_subdevice *read_subdev =
	    comedi_get_read_subdevice(dev_file_info);
	struct comedi_subdevice *write_subdev =
	    comedi_get_write_subdevice(dev_file_info);

	memset(&devinfo, 0, sizeof(devinfo));

 	/* fill devinfo structure */
 	devinfo.version_code = COMEDI_VERSION_CODE;
 	devinfo.n_subdevs = dev->n_subdevices;
	memcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);
	memcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);
 
 	if (read_subdev)
 		devinfo.read_subdevice = read_subdev - dev->subdevices;
	else
		devinfo.read_subdevice = -1;

	if (write_subdev)
		devinfo.write_subdevice = write_subdev - dev->subdevices;
	else
		devinfo.write_subdevice = -1;

	if (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))
		return -EFAULT;

	return 0;
}
","static int do_devinfo_ioctl(struct comedi_device *dev,
			    struct comedi_devinfo __user *arg,
			    struct file *file)
{
	struct comedi_devinfo devinfo;
	const unsigned minor = iminor(file->f_dentry->d_inode);
	struct comedi_device_file_info *dev_file_info =
	    comedi_get_device_file_info(minor);
	struct comedi_subdevice *read_subdev =
	    comedi_get_read_subdevice(dev_file_info);
	struct comedi_subdevice *write_subdev =
	    comedi_get_write_subdevice(dev_file_info);

	memset(&devinfo, 0, sizeof(devinfo));

 	/* fill devinfo structure */
 	devinfo.version_code = COMEDI_VERSION_CODE;
 	devinfo.n_subdevs = dev->n_subdevices;
	strlcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);
	strlcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);
 
 	if (read_subdev)
 		devinfo.read_subdevice = read_subdev - dev->subdevices;
	else
		devinfo.read_subdevice = -1;

	if (write_subdev)
		devinfo.write_subdevice = write_subdev - dev->subdevices;
	else
		devinfo.write_subdevice = -1;

	if (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))
		return -EFAULT;

	return 0;
}
","The `do_devinfo_ioctl` function retrieves and populates device information for a Comedi device, which is used in data acquisition systems. It begins by initializing a `comedi_devinfo` structure and determining the minor device number from the file descriptor. The function then retrieves the associated read and write subdevices for the specified device file. It fills the `devinfo` structure with the device's version code, number of subdevices, driver name, and board name. Finally, it attempts to copy this information to user space; if successful, it returns zero, otherwise, it returns an error code indicating a fault.","The function is designed to gather and return information about a data acquisition device. It initializes a structure to hold device details and retrieves the minor device number from the file descriptor. The function identifies the associated read and write subdevices for the device file and populates the structure with essential information, including the device's version, the number of subdevices, and names of the driver and board. Finally, it attempts to transfer this populated information to user space, returning a success status if the operation is successful or an error code if it fails.","The vulnerability in the original code stemmed from using `memcpy` to copy the driver and board names into the `devinfo` structure, which could lead to an information leak. Since these names are pointers to strings and not fixed-size buffers, copying a fixed number of bytes (COMEDI_NAMELEN) could inadvertently include unrelated memory content if the actual strings were shorter, potentially exposing sensitive data. The fix involved replacing `memcpy` with `strlcpy`, which safely copies the string while ensuring it does not exceed the specified length, thus preventing any leakage of unintended memory content.","The vulnerability in the original code arose from copying a fixed number of bytes from string pointers into a structure, which could lead to unintended memory exposure. Since the strings could be shorter than the specified length, this operation risked leaking adjacent memory content, potentially revealing sensitive information to user space. The fix involved replacing the copying method with a safer alternative that ensures only the actual string content is copied, while also preventing overflow. This change effectively mitigated the risk of information leakage by ensuring that only relevant data is transferred without exposing unrelated memory.","The vulnerability was fixed by replacing the `memcpy` function used to copy the driver and board names with `strlcpy`. This change ensures that only the actual string content is copied into the `devinfo` structure, preventing the risk of leaking unrelated memory. The use of `strlcpy` guarantees that the copied string will not exceed the specified length, thus avoiding the potential exposure of sensitive data that could occur if the original strings were shorter than the buffer size. This adjustment effectively secures the data transfer to user space by eliminating the risk of information leakage.","The vulnerability was addressed by changing the method used to copy string data into the structure, replacing a potentially unsafe copying technique with a safer alternative. This new method ensures that only the actual content of the strings is transferred, while also preventing any overflow that could lead to the exposure of adjacent memory. By implementing this safer copying approach, the fix effectively mitigates the risk of leaking unrelated memory content, thereby protecting sensitive information from being inadvertently revealed to user space during the data transfer process.","4,4","5,5","4,4","4, 3"
51,51,179739,179739,,Local,Not required,,CVE-2015-8374,https://www.cvedetails.com/cve/CVE-2015-8374/,CWE-200,Low,Partial,,,2015-12-28,2.1,"fs/btrfs/inode.c in the Linux kernel before 4.3.3 mishandles compressed inline extents, which allows local users to obtain sensitive pre-truncation information from a file via a clone action.",2018-01-04,+Info ,27,https://github.com/torvalds/linux/commit/0305cd5f7fca85dae392b9ba85b116896eb7c1c7,0305cd5f7fca85dae392b9ba85b116896eb7c1c7,"Btrfs: fix truncation of compressed and inlined extents

When truncating a file to a smaller size which consists of an inline
extent that is compressed, we did not discard (or made unusable) the
data between the new file size and the old file size, wasting metadata
space and allowing for the truncated data to be leaked and the data
corruption/loss mentioned below.
We were also not correctly decrementing the number of bytes used by the
inode, we were setting it to zero, giving a wrong report for callers of
the stat(2) syscall. The fsck tool also reported an error about a mismatch
between the nbytes of the file versus the real space used by the file.

Now because we weren't discarding the truncated region of the file, it
was possible for a caller of the clone ioctl to actually read the data
that was truncated, allowing for a security breach without requiring root
access to the system, using only standard filesystem operations. The
scenario is the following:

   1) User A creates a file which consists of an inline and compressed
      extent with a size of 2000 bytes - the file is not accessible to
      any other users (no read, write or execution permission for anyone
      else);

   2) The user truncates the file to a size of 1000 bytes;

   3) User A makes the file world readable;

   4) User B creates a file consisting of an inline extent of 2000 bytes;

   5) User B issues a clone operation from user A's file into its own
      file (using a length argument of 0, clone the whole range);

   6) User B now gets to see the 1000 bytes that user A truncated from
      its file before it made its file world readbale. User B also lost
      the bytes in the range [1000, 2000[ bytes from its own file, but
      that might be ok if his/her intention was reading stale data from
      user A that was never supposed to be public.

Note that this contrasts with the case where we truncate a file from 2000
bytes to 1000 bytes and then truncate it back from 1000 to 2000 bytes. In
this case reading any byte from the range [1000, 2000[ will return a value
of 0x00, instead of the original data.

This problem exists since the clone ioctl was added and happens both with
and without my recent data loss and file corruption fixes for the clone
ioctl (patch ""Btrfs: fix file corruption and data loss after cloning
inline extents"").

So fix this by truncating the compressed inline extents as we do for the
non-compressed case, which involves decompressing, if the data isn't already
in the page cache, compressing the truncated version of the extent, writing
the compressed content into the inline extent and then truncate it.

The following test case for fstests reproduces the problem. In order for
the test to pass both this fix and my previous fix for the clone ioctl
that forbids cloning a smaller inline extent into a larger one,
which is titled ""Btrfs: fix file corruption and data loss after cloning
inline extents"", are needed. Without that other fix the test fails in a
different way that does not leak the truncated data, instead part of
destination file gets replaced with zeroes (because the destination file
has a larger inline extent than the source).

  seq=`basename $0`
  seqres=$RESULT_DIR/$seq
  echo ""QA output created by $seq""
  tmp=/tmp/$$
  status=1	# failure is the default!
  trap ""_cleanup; exit \$status"" 0 1 2 3 15

  _cleanup()
  {
      rm -f $tmp.*
  }

  # get standard environment, filters and checks
  . ./common/rc
  . ./common/filter

  # real QA test starts here
  _need_to_be_root
  _supported_fs btrfs
  _supported_os Linux
  _require_scratch
  _require_cloner

  rm -f $seqres.full

  _scratch_mkfs >>$seqres.full 2>&1
  _scratch_mount ""-o compress""

  # Create our test files. File foo is going to be the source of a clone operation
  # and consists of a single inline extent with an uncompressed size of 512 bytes,
  # while file bar consists of a single inline extent with an uncompressed size of
  # 256 bytes. For our test's purpose, it's important that file bar has an inline
  # extent with a size smaller than foo's inline extent.
  $XFS_IO_PROG -f -c ""pwrite -S 0xa1 0 128""   \
          -c ""pwrite -S 0x2a 128 384"" \
          $SCRATCH_MNT/foo | _filter_xfs_io
  $XFS_IO_PROG -f -c ""pwrite -S 0xbb 0 256"" $SCRATCH_MNT/bar | _filter_xfs_io

  # Now durably persist all metadata and data. We do this to make sure that we get
  # on disk an inline extent with a size of 512 bytes for file foo.
  sync

  # Now truncate our file foo to a smaller size. Because it consists of a
  # compressed and inline extent, btrfs did not shrink the inline extent to the
  # new size (if the extent was not compressed, btrfs would shrink it to 128
  # bytes), it only updates the inode's i_size to 128 bytes.
  $XFS_IO_PROG -c ""truncate 128"" $SCRATCH_MNT/foo

  # Now clone foo's inline extent into bar.
  # This clone operation should fail with errno EOPNOTSUPP because the source
  # file consists only of an inline extent and the file's size is smaller than
  # the inline extent of the destination (128 bytes < 256 bytes). However the
  # clone ioctl was not prepared to deal with a file that has a size smaller
  # than the size of its inline extent (something that happens only for compressed
  # inline extents), resulting in copying the full inline extent from the source
  # file into the destination file.
  #
  # Note that btrfs' clone operation for inline extents consists of removing the
  # inline extent from the destination inode and copy the inline extent from the
  # source inode into the destination inode, meaning that if the destination
  # inode's inline extent is larger (N bytes) than the source inode's inline
  # extent (M bytes), some bytes (N - M bytes) will be lost from the destination
  # file. Btrfs could copy the source inline extent's data into the destination's
  # inline extent so that we would not lose any data, but that's currently not
  # done due to the complexity that would be needed to deal with such cases
  # (specially when one or both extents are compressed), returning EOPNOTSUPP, as
  # it's normally not a very common case to clone very small files (only case
  # where we get inline extents) and copying inline extents does not save any
  # space (unlike for normal, non-inlined extents).
  $CLONER_PROG -s 0 -d 0 -l 0 $SCRATCH_MNT/foo $SCRATCH_MNT/bar

  # Now because the above clone operation used to succeed, and due to foo's inline
  # extent not being shinked by the truncate operation, our file bar got the whole
  # inline extent copied from foo, making us lose the last 128 bytes from bar
  # which got replaced by the bytes in range [128, 256[ from foo before foo was
  # truncated - in other words, data loss from bar and being able to read old and
  # stale data from foo that should not be possible to read anymore through normal
  # filesystem operations. Contrast with the case where we truncate a file from a
  # size N to a smaller size M, truncate it back to size N and then read the range
  # [M, N[, we should always get the value 0x00 for all the bytes in that range.

  # We expected the clone operation to fail with errno EOPNOTSUPP and therefore
  # not modify our file's bar data/metadata. So its content should be 256 bytes
  # long with all bytes having the value 0xbb.
  #
  # Without the btrfs bug fix, the clone operation succeeded and resulted in
  # leaking truncated data from foo, the bytes that belonged to its range
  # [128, 256[, and losing data from bar in that same range. So reading the
  # file gave us the following content:
  #
  # 0000000 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1
  # *
  # 0000200 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
  # *
  # 0000400
  echo ""File bar's content after the clone operation:""
  od -t x1 $SCRATCH_MNT/bar

  # Also because the foo's inline extent was not shrunk by the truncate
  # operation, btrfs' fsck, which is run by the fstests framework everytime a
  # test completes, failed reporting the following error:
  #
  #  root 5 inode 257 errors 400, nbytes wrong

  status=0
  exit

Cc: stable@vger.kernel.org
Signed-off-by: Filipe Manana <fdmanana@suse.com>",13,fs/btrfs/inode.c,"{""sha"": ""cbb4286490a1283b0d71bb4e26aad0987ec3b82e"", ""filename"": ""fs/btrfs/inode.c"", ""status"": ""modified"", ""additions"": 68, ""deletions"": 14, ""changes"": 82, ""blob_url"": ""https://github.com/torvalds/linux/blob/0305cd5f7fca85dae392b9ba85b116896eb7c1c7/fs/btrfs/inode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0305cd5f7fca85dae392b9ba85b116896eb7c1c7/fs/btrfs/inode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/inode.c?ref=0305cd5f7fca85dae392b9ba85b116896eb7c1c7"", ""patch"": ""@@ -4217,6 +4217,47 @@ static int truncate_space_check(struct btrfs_trans_handle *trans,\n \n }\n \n+static int truncate_inline_extent(struct inode *inode,\n+\t\t\t\t  struct btrfs_path *path,\n+\t\t\t\t  struct btrfs_key *found_key,\n+\t\t\t\t  const u64 item_end,\n+\t\t\t\t  const u64 new_size)\n+{\n+\tstruct extent_buffer *leaf = path->nodes[0];\n+\tint slot = path->slots[0];\n+\tstruct btrfs_file_extent_item *fi;\n+\tu32 size = (u32)(new_size - found_key->offset);\n+\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n+\n+\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n+\n+\tif (btrfs_file_extent_compression(leaf, fi) != BTRFS_COMPRESS_NONE) {\n+\t\tloff_t offset = new_size;\n+\t\tloff_t page_end = ALIGN(offset, PAGE_CACHE_SIZE);\n+\n+\t\t/*\n+\t\t * Zero out the remaining of the last page of our inline extent,\n+\t\t * instead of directly truncating our inline extent here - that\n+\t\t * would be much more complex (decompressing all the data, then\n+\t\t * compressing the truncated data, which might be bigger than\n+\t\t * the size of the inline extent, resize the extent, etc).\n+\t\t * We release the path because to get the page we might need to\n+\t\t * read the extent item from disk (data not in the page cache).\n+\t\t */\n+\t\tbtrfs_release_path(path);\n+\t\treturn btrfs_truncate_page(inode, offset, page_end - offset, 0);\n+\t}\n+\n+\tbtrfs_set_file_extent_ram_bytes(leaf, fi, size);\n+\tsize = btrfs_file_extent_calc_inline_size(size);\n+\tbtrfs_truncate_item(root, path, size, 1);\n+\n+\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n+\t\tinode_sub_bytes(inode, item_end + 1 - new_size);\n+\n+\treturn 0;\n+}\n+\n /*\n  * this can truncate away extent items, csum items and directory items.\n  * It starts at a high offset and removes keys until it can't find\n@@ -4411,27 +4452,40 @@ int btrfs_truncate_inode_items(struct btrfs_trans_handle *trans,\n \t\t\t * special encodings\n \t\t\t */\n \t\t\tif (!del_item &&\n-\t\t\t    btrfs_file_extent_compression(leaf, fi) == 0 &&\n \t\t\t    btrfs_file_extent_encryption(leaf, fi) == 0 &&\n \t\t\t    btrfs_file_extent_other_encoding(leaf, fi) == 0) {\n-\t\t\t\tu32 size = new_size - found_key.offset;\n-\n-\t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n-\t\t\t\t\tinode_sub_bytes(inode, item_end + 1 -\n-\t\t\t\t\t\t\tnew_size);\n \n \t\t\t\t/*\n-\t\t\t\t * update the ram bytes to properly reflect\n-\t\t\t\t * the new size of our item\n+\t\t\t\t * Need to release path in order to truncate a\n+\t\t\t\t * compressed extent. So delete any accumulated\n+\t\t\t\t * extent items so far.\n \t\t\t\t */\n-\t\t\t\tbtrfs_set_file_extent_ram_bytes(leaf, fi, size);\n-\t\t\t\tsize =\n-\t\t\t\t    btrfs_file_extent_calc_inline_size(size);\n-\t\t\t\tbtrfs_truncate_item(root, path, size, 1);\n+\t\t\t\tif (btrfs_file_extent_compression(leaf, fi) !=\n+\t\t\t\t    BTRFS_COMPRESS_NONE && pending_del_nr) {\n+\t\t\t\t\terr = btrfs_del_items(trans, root, path,\n+\t\t\t\t\t\t\t      pending_del_slot,\n+\t\t\t\t\t\t\t      pending_del_nr);\n+\t\t\t\t\tif (err) {\n+\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n+\t\t\t\t\t\t\t\t\troot,\n+\t\t\t\t\t\t\t\t\terr);\n+\t\t\t\t\t\tgoto error;\n+\t\t\t\t\t}\n+\t\t\t\t\tpending_del_nr = 0;\n+\t\t\t\t}\n+\n+\t\t\t\terr = truncate_inline_extent(inode, path,\n+\t\t\t\t\t\t\t     &found_key,\n+\t\t\t\t\t\t\t     item_end,\n+\t\t\t\t\t\t\t     new_size);\n+\t\t\t\tif (err) {\n+\t\t\t\t\tbtrfs_abort_transaction(trans,\n+\t\t\t\t\t\t\t\troot, err);\n+\t\t\t\t\tgoto error;\n+\t\t\t\t}\n \t\t\t} else if (test_bit(BTRFS_ROOT_REF_COWS,\n \t\t\t\t\t    &root->state)) {\n-\t\t\t\tinode_sub_bytes(inode, item_end + 1 -\n-\t\t\t\t\t\tfound_key.offset);\n+\t\t\t\tinode_sub_bytes(inode, item_end + 1 - new_size);\n \t\t\t}\n \t\t}\n delete:""}","int btrfs_truncate_inode_items(struct btrfs_trans_handle *trans,
			       struct btrfs_root *root,
			       struct inode *inode,
			       u64 new_size, u32 min_type)
{
	struct btrfs_path *path;
	struct extent_buffer *leaf;
	struct btrfs_file_extent_item *fi;
	struct btrfs_key key;
	struct btrfs_key found_key;
	u64 extent_start = 0;
	u64 extent_num_bytes = 0;
	u64 extent_offset = 0;
	u64 item_end = 0;
	u64 last_size = new_size;
	u32 found_type = (u8)-1;
	int found_extent;
	int del_item;
	int pending_del_nr = 0;
	int pending_del_slot = 0;
	int extent_type = -1;
	int ret;
	int err = 0;
	u64 ino = btrfs_ino(inode);
	u64 bytes_deleted = 0;
	bool be_nice = 0;
	bool should_throttle = 0;
	bool should_end = 0;

	BUG_ON(new_size > 0 && min_type != BTRFS_EXTENT_DATA_KEY);

	/*
	 * for non-free space inodes and ref cows, we want to back off from
	 * time to time
	 */
	if (!btrfs_is_free_space_inode(inode) &&
	    test_bit(BTRFS_ROOT_REF_COWS, &root->state))
		be_nice = 1;

	path = btrfs_alloc_path();
	if (!path)
		return -ENOMEM;
	path->reada = -1;

	/*
	 * We want to drop from the next block forward in case this new size is
	 * not block aligned since we will be keeping the last block of the
	 * extent just the way it is.
	 */
	if (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||
	    root == root->fs_info->tree_root)
		btrfs_drop_extent_cache(inode, ALIGN(new_size,
					root->sectorsize), (u64)-1, 0);

	/*
	 * This function is also used to drop the items in the log tree before
	 * we relog the inode, so if root != BTRFS_I(inode)->root, it means
	 * it is used to drop the loged items. So we shouldn't kill the delayed
	 * items.
	 */
	if (min_type == 0 && root == BTRFS_I(inode)->root)
		btrfs_kill_delayed_inode_items(inode);

	key.objectid = ino;
	key.offset = (u64)-1;
	key.type = (u8)-1;

search_again:
	/*
	 * with a 16K leaf size and 128MB extents, you can actually queue
	 * up a huge file in a single leaf.  Most of the time that
	 * bytes_deleted is > 0, it will be huge by the time we get here
	 */
	if (be_nice && bytes_deleted > 32 * 1024 * 1024) {
		if (btrfs_should_end_transaction(trans, root)) {
			err = -EAGAIN;
			goto error;
		}
	}


	path->leave_spinning = 1;
	ret = btrfs_search_slot(trans, root, &key, path, -1, 1);
	if (ret < 0) {
		err = ret;
		goto out;
	}

	if (ret > 0) {
		/* there are no items in the tree for us to truncate, we're
		 * done
		 */
		if (path->slots[0] == 0)
			goto out;
		path->slots[0]--;
	}

	while (1) {
		fi = NULL;
		leaf = path->nodes[0];
		btrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);
		found_type = found_key.type;

		if (found_key.objectid != ino)
			break;

		if (found_type < min_type)
			break;

		item_end = found_key.offset;
		if (found_type == BTRFS_EXTENT_DATA_KEY) {
			fi = btrfs_item_ptr(leaf, path->slots[0],
					    struct btrfs_file_extent_item);
			extent_type = btrfs_file_extent_type(leaf, fi);
			if (extent_type != BTRFS_FILE_EXTENT_INLINE) {
				item_end +=
				    btrfs_file_extent_num_bytes(leaf, fi);
			} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {
				item_end += btrfs_file_extent_inline_len(leaf,
							 path->slots[0], fi);
			}
			item_end--;
		}
		if (found_type > min_type) {
			del_item = 1;
		} else {
			if (item_end < new_size)
				break;
			if (found_key.offset >= new_size)
				del_item = 1;
			else
				del_item = 0;
		}
		found_extent = 0;
		/* FIXME, shrink the extent if the ref count is only 1 */
		if (found_type != BTRFS_EXTENT_DATA_KEY)
			goto delete;

		if (del_item)
			last_size = found_key.offset;
		else
			last_size = new_size;

		if (extent_type != BTRFS_FILE_EXTENT_INLINE) {
			u64 num_dec;
			extent_start = btrfs_file_extent_disk_bytenr(leaf, fi);
			if (!del_item) {
				u64 orig_num_bytes =
					btrfs_file_extent_num_bytes(leaf, fi);
				extent_num_bytes = ALIGN(new_size -
						found_key.offset,
						root->sectorsize);
				btrfs_set_file_extent_num_bytes(leaf, fi,
							 extent_num_bytes);
				num_dec = (orig_num_bytes -
					   extent_num_bytes);
				if (test_bit(BTRFS_ROOT_REF_COWS,
					     &root->state) &&
				    extent_start != 0)
					inode_sub_bytes(inode, num_dec);
				btrfs_mark_buffer_dirty(leaf);
			} else {
				extent_num_bytes =
					btrfs_file_extent_disk_num_bytes(leaf,
									 fi);
				extent_offset = found_key.offset -
					btrfs_file_extent_offset(leaf, fi);

				/* FIXME blocksize != 4096 */
				num_dec = btrfs_file_extent_num_bytes(leaf, fi);
				if (extent_start != 0) {
					found_extent = 1;
					if (test_bit(BTRFS_ROOT_REF_COWS,
						     &root->state))
						inode_sub_bytes(inode, num_dec);
				}
			}
		} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {
			/*
			 * we can't truncate inline items that have had
 			 * special encodings
 			 */
 			if (!del_item &&
 			    btrfs_file_extent_encryption(leaf, fi) == 0 &&
 			    btrfs_file_extent_other_encoding(leaf, fi) == 0) {
 
 				/*
				 * Need to release path in order to truncate a
				 * compressed extent. So delete any accumulated
				 * extent items so far.
 				 */
				if (btrfs_file_extent_compression(leaf, fi) !=
				    BTRFS_COMPRESS_NONE && pending_del_nr) {
					err = btrfs_del_items(trans, root, path,
							      pending_del_slot,
							      pending_del_nr);
					if (err) {
						btrfs_abort_transaction(trans,
									root,
									err);
						goto error;
					}
					pending_del_nr = 0;
				}

				err = truncate_inline_extent(inode, path,
							     &found_key,
							     item_end,
							     new_size);
				if (err) {
					btrfs_abort_transaction(trans,
								root, err);
					goto error;
				}
 			} else if (test_bit(BTRFS_ROOT_REF_COWS,
 					    &root->state)) {
				inode_sub_bytes(inode, item_end + 1 - new_size);
 			}
 		}
 delete:
		if (del_item) {
			if (!pending_del_nr) {
				/* no pending yet, add ourselves */
				pending_del_slot = path->slots[0];
				pending_del_nr = 1;
			} else if (pending_del_nr &&
				   path->slots[0] + 1 == pending_del_slot) {
				/* hop on the pending chunk */
				pending_del_nr++;
				pending_del_slot = path->slots[0];
			} else {
				BUG();
			}
		} else {
			break;
		}
		should_throttle = 0;

		if (found_extent &&
		    (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||
		     root == root->fs_info->tree_root)) {
			btrfs_set_path_blocking(path);
			bytes_deleted += extent_num_bytes;
			ret = btrfs_free_extent(trans, root, extent_start,
						extent_num_bytes, 0,
						btrfs_header_owner(leaf),
						ino, extent_offset, 0);
			BUG_ON(ret);
			if (btrfs_should_throttle_delayed_refs(trans, root))
				btrfs_async_run_delayed_refs(root,
					trans->delayed_ref_updates * 2, 0);
			if (be_nice) {
				if (truncate_space_check(trans, root,
							 extent_num_bytes)) {
					should_end = 1;
				}
				if (btrfs_should_throttle_delayed_refs(trans,
								       root)) {
					should_throttle = 1;
				}
			}
		}

		if (found_type == BTRFS_INODE_ITEM_KEY)
			break;

		if (path->slots[0] == 0 ||
		    path->slots[0] != pending_del_slot ||
		    should_throttle || should_end) {
			if (pending_del_nr) {
				ret = btrfs_del_items(trans, root, path,
						pending_del_slot,
						pending_del_nr);
				if (ret) {
					btrfs_abort_transaction(trans,
								root, ret);
					goto error;
				}
				pending_del_nr = 0;
			}
			btrfs_release_path(path);
			if (should_throttle) {
				unsigned long updates = trans->delayed_ref_updates;
				if (updates) {
					trans->delayed_ref_updates = 0;
					ret = btrfs_run_delayed_refs(trans, root, updates * 2);
					if (ret && !err)
						err = ret;
				}
			}
			/*
			 * if we failed to refill our space rsv, bail out
			 * and let the transaction restart
			 */
			if (should_end) {
				err = -EAGAIN;
				goto error;
			}
			goto search_again;
		} else {
			path->slots[0]--;
		}
	}
out:
	if (pending_del_nr) {
		ret = btrfs_del_items(trans, root, path, pending_del_slot,
				      pending_del_nr);
		if (ret)
			btrfs_abort_transaction(trans, root, ret);
	}
error:
	if (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)
		btrfs_ordered_update_i_size(inode, last_size, NULL);

	btrfs_free_path(path);

	if (be_nice && bytes_deleted > 32 * 1024 * 1024) {
		unsigned long updates = trans->delayed_ref_updates;
		if (updates) {
			trans->delayed_ref_updates = 0;
			ret = btrfs_run_delayed_refs(trans, root, updates * 2);
			if (ret && !err)
				err = ret;
		}
	}
	return err;
}
","int btrfs_truncate_inode_items(struct btrfs_trans_handle *trans,
			       struct btrfs_root *root,
			       struct inode *inode,
			       u64 new_size, u32 min_type)
{
	struct btrfs_path *path;
	struct extent_buffer *leaf;
	struct btrfs_file_extent_item *fi;
	struct btrfs_key key;
	struct btrfs_key found_key;
	u64 extent_start = 0;
	u64 extent_num_bytes = 0;
	u64 extent_offset = 0;
	u64 item_end = 0;
	u64 last_size = new_size;
	u32 found_type = (u8)-1;
	int found_extent;
	int del_item;
	int pending_del_nr = 0;
	int pending_del_slot = 0;
	int extent_type = -1;
	int ret;
	int err = 0;
	u64 ino = btrfs_ino(inode);
	u64 bytes_deleted = 0;
	bool be_nice = 0;
	bool should_throttle = 0;
	bool should_end = 0;

	BUG_ON(new_size > 0 && min_type != BTRFS_EXTENT_DATA_KEY);

	/*
	 * for non-free space inodes and ref cows, we want to back off from
	 * time to time
	 */
	if (!btrfs_is_free_space_inode(inode) &&
	    test_bit(BTRFS_ROOT_REF_COWS, &root->state))
		be_nice = 1;

	path = btrfs_alloc_path();
	if (!path)
		return -ENOMEM;
	path->reada = -1;

	/*
	 * We want to drop from the next block forward in case this new size is
	 * not block aligned since we will be keeping the last block of the
	 * extent just the way it is.
	 */
	if (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||
	    root == root->fs_info->tree_root)
		btrfs_drop_extent_cache(inode, ALIGN(new_size,
					root->sectorsize), (u64)-1, 0);

	/*
	 * This function is also used to drop the items in the log tree before
	 * we relog the inode, so if root != BTRFS_I(inode)->root, it means
	 * it is used to drop the loged items. So we shouldn't kill the delayed
	 * items.
	 */
	if (min_type == 0 && root == BTRFS_I(inode)->root)
		btrfs_kill_delayed_inode_items(inode);

	key.objectid = ino;
	key.offset = (u64)-1;
	key.type = (u8)-1;

search_again:
	/*
	 * with a 16K leaf size and 128MB extents, you can actually queue
	 * up a huge file in a single leaf.  Most of the time that
	 * bytes_deleted is > 0, it will be huge by the time we get here
	 */
	if (be_nice && bytes_deleted > 32 * 1024 * 1024) {
		if (btrfs_should_end_transaction(trans, root)) {
			err = -EAGAIN;
			goto error;
		}
	}


	path->leave_spinning = 1;
	ret = btrfs_search_slot(trans, root, &key, path, -1, 1);
	if (ret < 0) {
		err = ret;
		goto out;
	}

	if (ret > 0) {
		/* there are no items in the tree for us to truncate, we're
		 * done
		 */
		if (path->slots[0] == 0)
			goto out;
		path->slots[0]--;
	}

	while (1) {
		fi = NULL;
		leaf = path->nodes[0];
		btrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);
		found_type = found_key.type;

		if (found_key.objectid != ino)
			break;

		if (found_type < min_type)
			break;

		item_end = found_key.offset;
		if (found_type == BTRFS_EXTENT_DATA_KEY) {
			fi = btrfs_item_ptr(leaf, path->slots[0],
					    struct btrfs_file_extent_item);
			extent_type = btrfs_file_extent_type(leaf, fi);
			if (extent_type != BTRFS_FILE_EXTENT_INLINE) {
				item_end +=
				    btrfs_file_extent_num_bytes(leaf, fi);
			} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {
				item_end += btrfs_file_extent_inline_len(leaf,
							 path->slots[0], fi);
			}
			item_end--;
		}
		if (found_type > min_type) {
			del_item = 1;
		} else {
			if (item_end < new_size)
				break;
			if (found_key.offset >= new_size)
				del_item = 1;
			else
				del_item = 0;
		}
		found_extent = 0;
		/* FIXME, shrink the extent if the ref count is only 1 */
		if (found_type != BTRFS_EXTENT_DATA_KEY)
			goto delete;

		if (del_item)
			last_size = found_key.offset;
		else
			last_size = new_size;

		if (extent_type != BTRFS_FILE_EXTENT_INLINE) {
			u64 num_dec;
			extent_start = btrfs_file_extent_disk_bytenr(leaf, fi);
			if (!del_item) {
				u64 orig_num_bytes =
					btrfs_file_extent_num_bytes(leaf, fi);
				extent_num_bytes = ALIGN(new_size -
						found_key.offset,
						root->sectorsize);
				btrfs_set_file_extent_num_bytes(leaf, fi,
							 extent_num_bytes);
				num_dec = (orig_num_bytes -
					   extent_num_bytes);
				if (test_bit(BTRFS_ROOT_REF_COWS,
					     &root->state) &&
				    extent_start != 0)
					inode_sub_bytes(inode, num_dec);
				btrfs_mark_buffer_dirty(leaf);
			} else {
				extent_num_bytes =
					btrfs_file_extent_disk_num_bytes(leaf,
									 fi);
				extent_offset = found_key.offset -
					btrfs_file_extent_offset(leaf, fi);

				/* FIXME blocksize != 4096 */
				num_dec = btrfs_file_extent_num_bytes(leaf, fi);
				if (extent_start != 0) {
					found_extent = 1;
					if (test_bit(BTRFS_ROOT_REF_COWS,
						     &root->state))
						inode_sub_bytes(inode, num_dec);
				}
			}
		} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {
			/*
			 * we can't truncate inline items that have had
 			 * special encodings
 			 */
 			if (!del_item &&
			    btrfs_file_extent_compression(leaf, fi) == 0 &&
 			    btrfs_file_extent_encryption(leaf, fi) == 0 &&
 			    btrfs_file_extent_other_encoding(leaf, fi) == 0) {
				u32 size = new_size - found_key.offset;
				if (test_bit(BTRFS_ROOT_REF_COWS, &root->state))
					inode_sub_bytes(inode, item_end + 1 -
							new_size);
 
 				/*
				 * update the ram bytes to properly reflect
				 * the new size of our item
 				 */
				btrfs_set_file_extent_ram_bytes(leaf, fi, size);
				size =
				    btrfs_file_extent_calc_inline_size(size);
				btrfs_truncate_item(root, path, size, 1);
 			} else if (test_bit(BTRFS_ROOT_REF_COWS,
 					    &root->state)) {
				inode_sub_bytes(inode, item_end + 1 -
						found_key.offset);
 			}
 		}
 delete:
		if (del_item) {
			if (!pending_del_nr) {
				/* no pending yet, add ourselves */
				pending_del_slot = path->slots[0];
				pending_del_nr = 1;
			} else if (pending_del_nr &&
				   path->slots[0] + 1 == pending_del_slot) {
				/* hop on the pending chunk */
				pending_del_nr++;
				pending_del_slot = path->slots[0];
			} else {
				BUG();
			}
		} else {
			break;
		}
		should_throttle = 0;

		if (found_extent &&
		    (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||
		     root == root->fs_info->tree_root)) {
			btrfs_set_path_blocking(path);
			bytes_deleted += extent_num_bytes;
			ret = btrfs_free_extent(trans, root, extent_start,
						extent_num_bytes, 0,
						btrfs_header_owner(leaf),
						ino, extent_offset, 0);
			BUG_ON(ret);
			if (btrfs_should_throttle_delayed_refs(trans, root))
				btrfs_async_run_delayed_refs(root,
					trans->delayed_ref_updates * 2, 0);
			if (be_nice) {
				if (truncate_space_check(trans, root,
							 extent_num_bytes)) {
					should_end = 1;
				}
				if (btrfs_should_throttle_delayed_refs(trans,
								       root)) {
					should_throttle = 1;
				}
			}
		}

		if (found_type == BTRFS_INODE_ITEM_KEY)
			break;

		if (path->slots[0] == 0 ||
		    path->slots[0] != pending_del_slot ||
		    should_throttle || should_end) {
			if (pending_del_nr) {
				ret = btrfs_del_items(trans, root, path,
						pending_del_slot,
						pending_del_nr);
				if (ret) {
					btrfs_abort_transaction(trans,
								root, ret);
					goto error;
				}
				pending_del_nr = 0;
			}
			btrfs_release_path(path);
			if (should_throttle) {
				unsigned long updates = trans->delayed_ref_updates;
				if (updates) {
					trans->delayed_ref_updates = 0;
					ret = btrfs_run_delayed_refs(trans, root, updates * 2);
					if (ret && !err)
						err = ret;
				}
			}
			/*
			 * if we failed to refill our space rsv, bail out
			 * and let the transaction restart
			 */
			if (should_end) {
				err = -EAGAIN;
				goto error;
			}
			goto search_again;
		} else {
			path->slots[0]--;
		}
	}
out:
	if (pending_del_nr) {
		ret = btrfs_del_items(trans, root, path, pending_del_slot,
				      pending_del_nr);
		if (ret)
			btrfs_abort_transaction(trans, root, ret);
	}
error:
	if (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)
		btrfs_ordered_update_i_size(inode, last_size, NULL);

	btrfs_free_path(path);

	if (be_nice && bytes_deleted > 32 * 1024 * 1024) {
		unsigned long updates = trans->delayed_ref_updates;
		if (updates) {
			trans->delayed_ref_updates = 0;
			ret = btrfs_run_delayed_refs(trans, root, updates * 2);
			if (ret && !err)
				err = ret;
		}
	}
	return err;
}
",C,"				 * Need to release path in order to truncate a
				 * compressed extent. So delete any accumulated
				 * extent items so far.
				if (btrfs_file_extent_compression(leaf, fi) !=
				    BTRFS_COMPRESS_NONE && pending_del_nr) {
					err = btrfs_del_items(trans, root, path,
							      pending_del_slot,
							      pending_del_nr);
					if (err) {
						btrfs_abort_transaction(trans,
									root,
									err);
						goto error;
					}
					pending_del_nr = 0;
				}

				err = truncate_inline_extent(inode, path,
							     &found_key,
							     item_end,
							     new_size);
				if (err) {
					btrfs_abort_transaction(trans,
								root, err);
					goto error;
				}
				inode_sub_bytes(inode, item_end + 1 - new_size);
","			    btrfs_file_extent_compression(leaf, fi) == 0 &&
				u32 size = new_size - found_key.offset;
				if (test_bit(BTRFS_ROOT_REF_COWS, &root->state))
					inode_sub_bytes(inode, item_end + 1 -
							new_size);
				 * update the ram bytes to properly reflect
				 * the new size of our item
				btrfs_set_file_extent_ram_bytes(leaf, fi, size);
				size =
				    btrfs_file_extent_calc_inline_size(size);
				btrfs_truncate_item(root, path, size, 1);
				inode_sub_bytes(inode, item_end + 1 -
						found_key.offset);
",,"@@ -4217,6 +4217,47 @@ static int truncate_space_check(struct btrfs_trans_handle *trans,
 
 }
 
+static int truncate_inline_extent(struct inode *inode,
+				  struct btrfs_path *path,
+				  struct btrfs_key *found_key,
+				  const u64 item_end,
+				  const u64 new_size)
+{
+	struct extent_buffer *leaf = path->nodes[0];
+	int slot = path->slots[0];
+	struct btrfs_file_extent_item *fi;
+	u32 size = (u32)(new_size - found_key->offset);
+	struct btrfs_root *root = BTRFS_I(inode)->root;
+
+	fi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);
+
+	if (btrfs_file_extent_compression(leaf, fi) != BTRFS_COMPRESS_NONE) {
+		loff_t offset = new_size;
+		loff_t page_end = ALIGN(offset, PAGE_CACHE_SIZE);
+
+		/*
+		 * Zero out the remaining of the last page of our inline extent,
+		 * instead of directly truncating our inline extent here - that
+		 * would be much more complex (decompressing all the data, then
+		 * compressing the truncated data, which might be bigger than
+		 * the size of the inline extent, resize the extent, etc).
+		 * We release the path because to get the page we might need to
+		 * read the extent item from disk (data not in the page cache).
+		 */
+		btrfs_release_path(path);
+		return btrfs_truncate_page(inode, offset, page_end - offset, 0);
+	}
+
+	btrfs_set_file_extent_ram_bytes(leaf, fi, size);
+	size = btrfs_file_extent_calc_inline_size(size);
+	btrfs_truncate_item(root, path, size, 1);
+
+	if (test_bit(BTRFS_ROOT_REF_COWS, &root->state))
+		inode_sub_bytes(inode, item_end + 1 - new_size);
+
+	return 0;
+}
+
 /*
  * this can truncate away extent items, csum items and directory items.
  * It starts at a high offset and removes keys until it can't find
@@ -4411,27 +4452,40 @@ int btrfs_truncate_inode_items(struct btrfs_trans_handle *trans,
 			 * special encodings
 			 */
 			if (!del_item &&
-			    btrfs_file_extent_compression(leaf, fi) == 0 &&
 			    btrfs_file_extent_encryption(leaf, fi) == 0 &&
 			    btrfs_file_extent_other_encoding(leaf, fi) == 0) {
-				u32 size = new_size - found_key.offset;
-
-				if (test_bit(BTRFS_ROOT_REF_COWS, &root->state))
-					inode_sub_bytes(inode, item_end + 1 -
-							new_size);
 
 				/*
-				 * update the ram bytes to properly reflect
-				 * the new size of our item
+				 * Need to release path in order to truncate a
+				 * compressed extent. So delete any accumulated
+				 * extent items so far.
 				 */
-				btrfs_set_file_extent_ram_bytes(leaf, fi, size);
-				size =
-				    btrfs_file_extent_calc_inline_size(size);
-				btrfs_truncate_item(root, path, size, 1);
+				if (btrfs_file_extent_compression(leaf, fi) !=
+				    BTRFS_COMPRESS_NONE && pending_del_nr) {
+					err = btrfs_del_items(trans, root, path,
+							      pending_del_slot,
+							      pending_del_nr);
+					if (err) {
+						btrfs_abort_transaction(trans,
+									root,
+									err);
+						goto error;
+					}
+					pending_del_nr = 0;
+				}
+
+				err = truncate_inline_extent(inode, path,
+							     &found_key,
+							     item_end,
+							     new_size);
+				if (err) {
+					btrfs_abort_transaction(trans,
+								root, err);
+					goto error;
+				}
 			} else if (test_bit(BTRFS_ROOT_REF_COWS,
 					    &root->state)) {
-				inode_sub_bytes(inode, item_end + 1 -
-						found_key.offset);
+				inode_sub_bytes(inode, item_end + 1 - new_size);
 			}
 		}
 delete:",linux,0305cd5f7fca85dae392b9ba85b116896eb7c1c7,5e6ecb362bd5950a3d8ce19c32829e4f8c7917d9,1,"int btrfs_truncate_inode_items(struct btrfs_trans_handle *trans,
			       struct btrfs_root *root,
			       struct inode *inode,
			       u64 new_size, u32 min_type)
{
	struct btrfs_path *path;
	struct extent_buffer *leaf;
	struct btrfs_file_extent_item *fi;
	struct btrfs_key key;
	struct btrfs_key found_key;
	u64 extent_start = 0;
	u64 extent_num_bytes = 0;
	u64 extent_offset = 0;
	u64 item_end = 0;
	u64 last_size = new_size;
	u32 found_type = (u8)-1;
	int found_extent;
	int del_item;
	int pending_del_nr = 0;
	int pending_del_slot = 0;
	int extent_type = -1;
	int ret;
	int err = 0;
	u64 ino = btrfs_ino(inode);
	u64 bytes_deleted = 0;
	bool be_nice = 0;
	bool should_throttle = 0;
	bool should_end = 0;

	BUG_ON(new_size > 0 && min_type != BTRFS_EXTENT_DATA_KEY);

	/*
	 * for non-free space inodes and ref cows, we want to back off from
	 * time to time
	 */
	if (!btrfs_is_free_space_inode(inode) &&
	    test_bit(BTRFS_ROOT_REF_COWS, &root->state))
		be_nice = 1;

	path = btrfs_alloc_path();
	if (!path)
		return -ENOMEM;
	path->reada = -1;

	/*
	 * We want to drop from the next block forward in case this new size is
	 * not block aligned since we will be keeping the last block of the
	 * extent just the way it is.
	 */
	if (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||
	    root == root->fs_info->tree_root)
		btrfs_drop_extent_cache(inode, ALIGN(new_size,
					root->sectorsize), (u64)-1, 0);

	/*
	 * This function is also used to drop the items in the log tree before
	 * we relog the inode, so if root != BTRFS_I(inode)->root, it means
	 * it is used to drop the loged items. So we shouldn't kill the delayed
	 * items.
	 */
	if (min_type == 0 && root == BTRFS_I(inode)->root)
		btrfs_kill_delayed_inode_items(inode);

	key.objectid = ino;
	key.offset = (u64)-1;
	key.type = (u8)-1;

search_again:
	/*
	 * with a 16K leaf size and 128MB extents, you can actually queue
	 * up a huge file in a single leaf.  Most of the time that
	 * bytes_deleted is > 0, it will be huge by the time we get here
	 */
	if (be_nice && bytes_deleted > 32 * 1024 * 1024) {
		if (btrfs_should_end_transaction(trans, root)) {
			err = -EAGAIN;
			goto error;
		}
	}


	path->leave_spinning = 1;
	ret = btrfs_search_slot(trans, root, &key, path, -1, 1);
	if (ret < 0) {
		err = ret;
		goto out;
	}

	if (ret > 0) {
		/* there are no items in the tree for us to truncate, we're
		 * done
		 */
		if (path->slots[0] == 0)
			goto out;
		path->slots[0]--;
	}

	while (1) {
		fi = NULL;
		leaf = path->nodes[0];
		btrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);
		found_type = found_key.type;

		if (found_key.objectid != ino)
			break;

		if (found_type < min_type)
			break;

		item_end = found_key.offset;
		if (found_type == BTRFS_EXTENT_DATA_KEY) {
			fi = btrfs_item_ptr(leaf, path->slots[0],
					    struct btrfs_file_extent_item);
			extent_type = btrfs_file_extent_type(leaf, fi);
			if (extent_type != BTRFS_FILE_EXTENT_INLINE) {
				item_end +=
				    btrfs_file_extent_num_bytes(leaf, fi);
			} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {
				item_end += btrfs_file_extent_inline_len(leaf,
							 path->slots[0], fi);
			}
			item_end--;
		}
		if (found_type > min_type) {
			del_item = 1;
		} else {
			if (item_end < new_size)
				break;
			if (found_key.offset >= new_size)
				del_item = 1;
			else
				del_item = 0;
		}
		found_extent = 0;
		/* FIXME, shrink the extent if the ref count is only 1 */
		if (found_type != BTRFS_EXTENT_DATA_KEY)
			goto delete;

		if (del_item)
			last_size = found_key.offset;
		else
			last_size = new_size;

		if (extent_type != BTRFS_FILE_EXTENT_INLINE) {
			u64 num_dec;
			extent_start = btrfs_file_extent_disk_bytenr(leaf, fi);
			if (!del_item) {
				u64 orig_num_bytes =
					btrfs_file_extent_num_bytes(leaf, fi);
				extent_num_bytes = ALIGN(new_size -
						found_key.offset,
						root->sectorsize);
				btrfs_set_file_extent_num_bytes(leaf, fi,
							 extent_num_bytes);
				num_dec = (orig_num_bytes -
					   extent_num_bytes);
				if (test_bit(BTRFS_ROOT_REF_COWS,
					     &root->state) &&
				    extent_start != 0)
					inode_sub_bytes(inode, num_dec);
				btrfs_mark_buffer_dirty(leaf);
			} else {
				extent_num_bytes =
					btrfs_file_extent_disk_num_bytes(leaf,
									 fi);
				extent_offset = found_key.offset -
					btrfs_file_extent_offset(leaf, fi);

				/* FIXME blocksize != 4096 */
				num_dec = btrfs_file_extent_num_bytes(leaf, fi);
				if (extent_start != 0) {
					found_extent = 1;
					if (test_bit(BTRFS_ROOT_REF_COWS,
						     &root->state))
						inode_sub_bytes(inode, num_dec);
				}
			}
		} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {
			/*
			 * we can't truncate inline items that have had
 			 * special encodings
 			 */
 			if (!del_item &&
//flaw_line_below:
			    btrfs_file_extent_compression(leaf, fi) == 0 &&
 			    btrfs_file_extent_encryption(leaf, fi) == 0 &&
 			    btrfs_file_extent_other_encoding(leaf, fi) == 0) {
//flaw_line_below:
				u32 size = new_size - found_key.offset;
//flaw_line_below:

//flaw_line_below:
				if (test_bit(BTRFS_ROOT_REF_COWS, &root->state))
//flaw_line_below:
					inode_sub_bytes(inode, item_end + 1 -
//flaw_line_below:
							new_size);
 
 				/*
//flaw_line_below:
				 * update the ram bytes to properly reflect
//flaw_line_below:
				 * the new size of our item
//fix_flaw_line_below:
//				 * Need to release path in order to truncate a
//fix_flaw_line_below:
//				 * compressed extent. So delete any accumulated
//fix_flaw_line_below:
//				 * extent items so far.
 				 */
//flaw_line_below:
				btrfs_set_file_extent_ram_bytes(leaf, fi, size);
//flaw_line_below:
				size =
//flaw_line_below:
				    btrfs_file_extent_calc_inline_size(size);
//flaw_line_below:
				btrfs_truncate_item(root, path, size, 1);
//fix_flaw_line_below:
//				if (btrfs_file_extent_compression(leaf, fi) !=
//fix_flaw_line_below:
//				    BTRFS_COMPRESS_NONE && pending_del_nr) {
//fix_flaw_line_below:
//					err = btrfs_del_items(trans, root, path,
//fix_flaw_line_below:
//							      pending_del_slot,
//fix_flaw_line_below:
//							      pending_del_nr);
//fix_flaw_line_below:
//					if (err) {
//fix_flaw_line_below:
//						btrfs_abort_transaction(trans,
//fix_flaw_line_below:
//									root,
//fix_flaw_line_below:
//									err);
//fix_flaw_line_below:
//						goto error;
//fix_flaw_line_below:
//					}
//fix_flaw_line_below:
//					pending_del_nr = 0;
//fix_flaw_line_below:
//				}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//				err = truncate_inline_extent(inode, path,
//fix_flaw_line_below:
//							     &found_key,
//fix_flaw_line_below:
//							     item_end,
//fix_flaw_line_below:
//							     new_size);
//fix_flaw_line_below:
//				if (err) {
//fix_flaw_line_below:
//					btrfs_abort_transaction(trans,
//fix_flaw_line_below:
//								root, err);
//fix_flaw_line_below:
//					goto error;
//fix_flaw_line_below:
//				}
 			} else if (test_bit(BTRFS_ROOT_REF_COWS,
 					    &root->state)) {
//flaw_line_below:
				inode_sub_bytes(inode, item_end + 1 -
//flaw_line_below:
						found_key.offset);
//fix_flaw_line_below:
//				inode_sub_bytes(inode, item_end + 1 - new_size);
 			}
 		}
 delete:
		if (del_item) {
			if (!pending_del_nr) {
				/* no pending yet, add ourselves */
				pending_del_slot = path->slots[0];
				pending_del_nr = 1;
			} else if (pending_del_nr &&
				   path->slots[0] + 1 == pending_del_slot) {
				/* hop on the pending chunk */
				pending_del_nr++;
				pending_del_slot = path->slots[0];
			} else {
				BUG();
			}
		} else {
			break;
		}
		should_throttle = 0;

		if (found_extent &&
		    (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||
		     root == root->fs_info->tree_root)) {
			btrfs_set_path_blocking(path);
			bytes_deleted += extent_num_bytes;
			ret = btrfs_free_extent(trans, root, extent_start,
						extent_num_bytes, 0,
						btrfs_header_owner(leaf),
						ino, extent_offset, 0);
			BUG_ON(ret);
			if (btrfs_should_throttle_delayed_refs(trans, root))
				btrfs_async_run_delayed_refs(root,
					trans->delayed_ref_updates * 2, 0);
			if (be_nice) {
				if (truncate_space_check(trans, root,
							 extent_num_bytes)) {
					should_end = 1;
				}
				if (btrfs_should_throttle_delayed_refs(trans,
								       root)) {
					should_throttle = 1;
				}
			}
		}

		if (found_type == BTRFS_INODE_ITEM_KEY)
			break;

		if (path->slots[0] == 0 ||
		    path->slots[0] != pending_del_slot ||
		    should_throttle || should_end) {
			if (pending_del_nr) {
				ret = btrfs_del_items(trans, root, path,
						pending_del_slot,
						pending_del_nr);
				if (ret) {
					btrfs_abort_transaction(trans,
								root, ret);
					goto error;
				}
				pending_del_nr = 0;
			}
			btrfs_release_path(path);
			if (should_throttle) {
				unsigned long updates = trans->delayed_ref_updates;
				if (updates) {
					trans->delayed_ref_updates = 0;
					ret = btrfs_run_delayed_refs(trans, root, updates * 2);
					if (ret && !err)
						err = ret;
				}
			}
			/*
			 * if we failed to refill our space rsv, bail out
			 * and let the transaction restart
			 */
			if (should_end) {
				err = -EAGAIN;
				goto error;
			}
			goto search_again;
		} else {
			path->slots[0]--;
		}
	}
out:
	if (pending_del_nr) {
		ret = btrfs_del_items(trans, root, path, pending_del_slot,
				      pending_del_nr);
		if (ret)
			btrfs_abort_transaction(trans, root, ret);
	}
error:
	if (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)
		btrfs_ordered_update_i_size(inode, last_size, NULL);

	btrfs_free_path(path);

	if (be_nice && bytes_deleted > 32 * 1024 * 1024) {
		unsigned long updates = trans->delayed_ref_updates;
		if (updates) {
			trans->delayed_ref_updates = 0;
			ret = btrfs_run_delayed_refs(trans, root, updates * 2);
			if (ret && !err)
				err = ret;
		}
	}
	return err;
}
",179739,"int btrfs_truncate_inode_items(struct btrfs_trans_handle *trans,
			       struct btrfs_root *root,
			       struct inode *inode,
			       u64 new_size, u32 min_type)
{
	struct btrfs_path *path;
	struct extent_buffer *leaf;
	struct btrfs_file_extent_item *fi;
	struct btrfs_key key;
	struct btrfs_key found_key;
	u64 extent_start = 0;
	u64 extent_num_bytes = 0;
	u64 extent_offset = 0;
	u64 item_end = 0;
	u64 last_size = new_size;
	u32 found_type = (u8)-1;
	int found_extent;
	int del_item;
	int pending_del_nr = 0;
	int pending_del_slot = 0;
	int extent_type = -1;
	int ret;
	int err = 0;
	u64 ino = btrfs_ino(inode);
	u64 bytes_deleted = 0;
	bool be_nice = 0;
	bool should_throttle = 0;
	bool should_end = 0;

	BUG_ON(new_size > 0 && min_type != BTRFS_EXTENT_DATA_KEY);

	/*
	 * for non-free space inodes and ref cows, we want to back off from
	 * time to time
	 */
	if (!btrfs_is_free_space_inode(inode) &&
	    test_bit(BTRFS_ROOT_REF_COWS, &root->state))
		be_nice = 1;

	path = btrfs_alloc_path();
	if (!path)
		return -ENOMEM;
	path->reada = -1;

	/*
	 * We want to drop from the next block forward in case this new size is
	 * not block aligned since we will be keeping the last block of the
	 * extent just the way it is.
	 */
	if (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||
	    root == root->fs_info->tree_root)
		btrfs_drop_extent_cache(inode, ALIGN(new_size,
					root->sectorsize), (u64)-1, 0);

	/*
	 * This function is also used to drop the items in the log tree before
	 * we relog the inode, so if root != BTRFS_I(inode)->root, it means
	 * it is used to drop the loged items. So we shouldn't kill the delayed
	 * items.
	 */
	if (min_type == 0 && root == BTRFS_I(inode)->root)
		btrfs_kill_delayed_inode_items(inode);

	key.objectid = ino;
	key.offset = (u64)-1;
	key.type = (u8)-1;

search_again:
	/*
	 * with a 16K leaf size and 128MB extents, you can actually queue
	 * up a huge file in a single leaf.  Most of the time that
	 * bytes_deleted is > 0, it will be huge by the time we get here
	 */
	if (be_nice && bytes_deleted > 32 * 1024 * 1024) {
		if (btrfs_should_end_transaction(trans, root)) {
			err = -EAGAIN;
			goto error;
		}
	}


	path->leave_spinning = 1;
	ret = btrfs_search_slot(trans, root, &key, path, -1, 1);
	if (ret < 0) {
		err = ret;
		goto out;
	}

	if (ret > 0) {
		/* there are no items in the tree for us to truncate, we're
		 * done
		 */
		if (path->slots[0] == 0)
			goto out;
		path->slots[0]--;
	}

	while (1) {
		fi = NULL;
		leaf = path->nodes[0];
		btrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);
		found_type = found_key.type;

		if (found_key.objectid != ino)
			break;

		if (found_type < min_type)
			break;

		item_end = found_key.offset;
		if (found_type == BTRFS_EXTENT_DATA_KEY) {
			fi = btrfs_item_ptr(leaf, path->slots[0],
					    struct btrfs_file_extent_item);
			extent_type = btrfs_file_extent_type(leaf, fi);
			if (extent_type != BTRFS_FILE_EXTENT_INLINE) {
				item_end +=
				    btrfs_file_extent_num_bytes(leaf, fi);
			} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {
				item_end += btrfs_file_extent_inline_len(leaf,
							 path->slots[0], fi);
			}
			item_end--;
		}
		if (found_type > min_type) {
			del_item = 1;
		} else {
			if (item_end < new_size)
				break;
			if (found_key.offset >= new_size)
				del_item = 1;
			else
				del_item = 0;
		}
		found_extent = 0;
		/* FIXME, shrink the extent if the ref count is only 1 */
		if (found_type != BTRFS_EXTENT_DATA_KEY)
			goto delete;

		if (del_item)
			last_size = found_key.offset;
		else
			last_size = new_size;

		if (extent_type != BTRFS_FILE_EXTENT_INLINE) {
			u64 num_dec;
			extent_start = btrfs_file_extent_disk_bytenr(leaf, fi);
			if (!del_item) {
				u64 orig_num_bytes =
					btrfs_file_extent_num_bytes(leaf, fi);
				extent_num_bytes = ALIGN(new_size -
						found_key.offset,
						root->sectorsize);
				btrfs_set_file_extent_num_bytes(leaf, fi,
							 extent_num_bytes);
				num_dec = (orig_num_bytes -
					   extent_num_bytes);
				if (test_bit(BTRFS_ROOT_REF_COWS,
					     &root->state) &&
				    extent_start != 0)
					inode_sub_bytes(inode, num_dec);
				btrfs_mark_buffer_dirty(leaf);
			} else {
				extent_num_bytes =
					btrfs_file_extent_disk_num_bytes(leaf,
									 fi);
				extent_offset = found_key.offset -
					btrfs_file_extent_offset(leaf, fi);

				/* FIXME blocksize != 4096 */
				num_dec = btrfs_file_extent_num_bytes(leaf, fi);
				if (extent_start != 0) {
					found_extent = 1;
					if (test_bit(BTRFS_ROOT_REF_COWS,
						     &root->state))
						inode_sub_bytes(inode, num_dec);
				}
			}
		} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {
			/*
			 * we can't truncate inline items that have had
 			 * special encodings
 			 */
 			if (!del_item &&
			    btrfs_file_extent_compression(leaf, fi) == 0 &&
 			    btrfs_file_extent_encryption(leaf, fi) == 0 &&
 			    btrfs_file_extent_other_encoding(leaf, fi) == 0) {
				u32 size = new_size - found_key.offset;
				if (test_bit(BTRFS_ROOT_REF_COWS, &root->state))
					inode_sub_bytes(inode, item_end + 1 -
							new_size);
 
 				/*
				 * update the ram bytes to properly reflect
				 * the new size of our item
 				 */
				btrfs_set_file_extent_ram_bytes(leaf, fi, size);
				size =
				    btrfs_file_extent_calc_inline_size(size);
				btrfs_truncate_item(root, path, size, 1);
 			} else if (test_bit(BTRFS_ROOT_REF_COWS,
 					    &root->state)) {
				inode_sub_bytes(inode, item_end + 1 -
						found_key.offset);
 			}
 		}
 delete:
		if (del_item) {
			if (!pending_del_nr) {
				/* no pending yet, add ourselves */
				pending_del_slot = path->slots[0];
				pending_del_nr = 1;
			} else if (pending_del_nr &&
				   path->slots[0] + 1 == pending_del_slot) {
				/* hop on the pending chunk */
				pending_del_nr++;
				pending_del_slot = path->slots[0];
			} else {
				BUG();
			}
		} else {
			break;
		}
		should_throttle = 0;

		if (found_extent &&
		    (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||
		     root == root->fs_info->tree_root)) {
			btrfs_set_path_blocking(path);
			bytes_deleted += extent_num_bytes;
			ret = btrfs_free_extent(trans, root, extent_start,
						extent_num_bytes, 0,
						btrfs_header_owner(leaf),
						ino, extent_offset, 0);
			BUG_ON(ret);
			if (btrfs_should_throttle_delayed_refs(trans, root))
				btrfs_async_run_delayed_refs(root,
					trans->delayed_ref_updates * 2, 0);
			if (be_nice) {
				if (truncate_space_check(trans, root,
							 extent_num_bytes)) {
					should_end = 1;
				}
				if (btrfs_should_throttle_delayed_refs(trans,
								       root)) {
					should_throttle = 1;
				}
			}
		}

		if (found_type == BTRFS_INODE_ITEM_KEY)
			break;

		if (path->slots[0] == 0 ||
		    path->slots[0] != pending_del_slot ||
		    should_throttle || should_end) {
			if (pending_del_nr) {
				ret = btrfs_del_items(trans, root, path,
						pending_del_slot,
						pending_del_nr);
				if (ret) {
					btrfs_abort_transaction(trans,
								root, ret);
					goto error;
				}
				pending_del_nr = 0;
			}
			btrfs_release_path(path);
			if (should_throttle) {
				unsigned long updates = trans->delayed_ref_updates;
				if (updates) {
					trans->delayed_ref_updates = 0;
					ret = btrfs_run_delayed_refs(trans, root, updates * 2);
					if (ret && !err)
						err = ret;
				}
			}
			/*
			 * if we failed to refill our space rsv, bail out
			 * and let the transaction restart
			 */
			if (should_end) {
				err = -EAGAIN;
				goto error;
			}
			goto search_again;
		} else {
			path->slots[0]--;
		}
	}
out:
	if (pending_del_nr) {
		ret = btrfs_del_items(trans, root, path, pending_del_slot,
				      pending_del_nr);
		if (ret)
			btrfs_abort_transaction(trans, root, ret);
	}
error:
	if (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)
		btrfs_ordered_update_i_size(inode, last_size, NULL);

	btrfs_free_path(path);

	if (be_nice && bytes_deleted > 32 * 1024 * 1024) {
		unsigned long updates = trans->delayed_ref_updates;
		if (updates) {
			trans->delayed_ref_updates = 0;
			ret = btrfs_run_delayed_refs(trans, root, updates * 2);
			if (ret && !err)
				err = ret;
		}
	}
	return err;
}
","int btrfs_truncate_inode_items(struct btrfs_trans_handle *trans,
			       struct btrfs_root *root,
			       struct inode *inode,
			       u64 new_size, u32 min_type)
{
	struct btrfs_path *path;
	struct extent_buffer *leaf;
	struct btrfs_file_extent_item *fi;
	struct btrfs_key key;
	struct btrfs_key found_key;
	u64 extent_start = 0;
	u64 extent_num_bytes = 0;
	u64 extent_offset = 0;
	u64 item_end = 0;
	u64 last_size = new_size;
	u32 found_type = (u8)-1;
	int found_extent;
	int del_item;
	int pending_del_nr = 0;
	int pending_del_slot = 0;
	int extent_type = -1;
	int ret;
	int err = 0;
	u64 ino = btrfs_ino(inode);
	u64 bytes_deleted = 0;
	bool be_nice = 0;
	bool should_throttle = 0;
	bool should_end = 0;

	BUG_ON(new_size > 0 && min_type != BTRFS_EXTENT_DATA_KEY);

	/*
	 * for non-free space inodes and ref cows, we want to back off from
	 * time to time
	 */
	if (!btrfs_is_free_space_inode(inode) &&
	    test_bit(BTRFS_ROOT_REF_COWS, &root->state))
		be_nice = 1;

	path = btrfs_alloc_path();
	if (!path)
		return -ENOMEM;
	path->reada = -1;

	/*
	 * We want to drop from the next block forward in case this new size is
	 * not block aligned since we will be keeping the last block of the
	 * extent just the way it is.
	 */
	if (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||
	    root == root->fs_info->tree_root)
		btrfs_drop_extent_cache(inode, ALIGN(new_size,
					root->sectorsize), (u64)-1, 0);

	/*
	 * This function is also used to drop the items in the log tree before
	 * we relog the inode, so if root != BTRFS_I(inode)->root, it means
	 * it is used to drop the loged items. So we shouldn't kill the delayed
	 * items.
	 */
	if (min_type == 0 && root == BTRFS_I(inode)->root)
		btrfs_kill_delayed_inode_items(inode);

	key.objectid = ino;
	key.offset = (u64)-1;
	key.type = (u8)-1;

search_again:
	/*
	 * with a 16K leaf size and 128MB extents, you can actually queue
	 * up a huge file in a single leaf.  Most of the time that
	 * bytes_deleted is > 0, it will be huge by the time we get here
	 */
	if (be_nice && bytes_deleted > 32 * 1024 * 1024) {
		if (btrfs_should_end_transaction(trans, root)) {
			err = -EAGAIN;
			goto error;
		}
	}


	path->leave_spinning = 1;
	ret = btrfs_search_slot(trans, root, &key, path, -1, 1);
	if (ret < 0) {
		err = ret;
		goto out;
	}

	if (ret > 0) {
		/* there are no items in the tree for us to truncate, we're
		 * done
		 */
		if (path->slots[0] == 0)
			goto out;
		path->slots[0]--;
	}

	while (1) {
		fi = NULL;
		leaf = path->nodes[0];
		btrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);
		found_type = found_key.type;

		if (found_key.objectid != ino)
			break;

		if (found_type < min_type)
			break;

		item_end = found_key.offset;
		if (found_type == BTRFS_EXTENT_DATA_KEY) {
			fi = btrfs_item_ptr(leaf, path->slots[0],
					    struct btrfs_file_extent_item);
			extent_type = btrfs_file_extent_type(leaf, fi);
			if (extent_type != BTRFS_FILE_EXTENT_INLINE) {
				item_end +=
				    btrfs_file_extent_num_bytes(leaf, fi);
			} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {
				item_end += btrfs_file_extent_inline_len(leaf,
							 path->slots[0], fi);
			}
			item_end--;
		}
		if (found_type > min_type) {
			del_item = 1;
		} else {
			if (item_end < new_size)
				break;
			if (found_key.offset >= new_size)
				del_item = 1;
			else
				del_item = 0;
		}
		found_extent = 0;
		/* FIXME, shrink the extent if the ref count is only 1 */
		if (found_type != BTRFS_EXTENT_DATA_KEY)
			goto delete;

		if (del_item)
			last_size = found_key.offset;
		else
			last_size = new_size;

		if (extent_type != BTRFS_FILE_EXTENT_INLINE) {
			u64 num_dec;
			extent_start = btrfs_file_extent_disk_bytenr(leaf, fi);
			if (!del_item) {
				u64 orig_num_bytes =
					btrfs_file_extent_num_bytes(leaf, fi);
				extent_num_bytes = ALIGN(new_size -
						found_key.offset,
						root->sectorsize);
				btrfs_set_file_extent_num_bytes(leaf, fi,
							 extent_num_bytes);
				num_dec = (orig_num_bytes -
					   extent_num_bytes);
				if (test_bit(BTRFS_ROOT_REF_COWS,
					     &root->state) &&
				    extent_start != 0)
					inode_sub_bytes(inode, num_dec);
				btrfs_mark_buffer_dirty(leaf);
			} else {
				extent_num_bytes =
					btrfs_file_extent_disk_num_bytes(leaf,
									 fi);
				extent_offset = found_key.offset -
					btrfs_file_extent_offset(leaf, fi);

				/* FIXME blocksize != 4096 */
				num_dec = btrfs_file_extent_num_bytes(leaf, fi);
				if (extent_start != 0) {
					found_extent = 1;
					if (test_bit(BTRFS_ROOT_REF_COWS,
						     &root->state))
						inode_sub_bytes(inode, num_dec);
				}
			}
		} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {
			/*
			 * we can't truncate inline items that have had
 			 * special encodings
 			 */
 			if (!del_item &&
 			    btrfs_file_extent_encryption(leaf, fi) == 0 &&
 			    btrfs_file_extent_other_encoding(leaf, fi) == 0) {
 
 				/*
				 * Need to release path in order to truncate a
				 * compressed extent. So delete any accumulated
				 * extent items so far.
 				 */
				if (btrfs_file_extent_compression(leaf, fi) !=
				    BTRFS_COMPRESS_NONE && pending_del_nr) {
					err = btrfs_del_items(trans, root, path,
							      pending_del_slot,
							      pending_del_nr);
					if (err) {
						btrfs_abort_transaction(trans,
									root,
									err);
						goto error;
					}
					pending_del_nr = 0;
				}

				err = truncate_inline_extent(inode, path,
							     &found_key,
							     item_end,
							     new_size);
				if (err) {
					btrfs_abort_transaction(trans,
								root, err);
					goto error;
				}
 			} else if (test_bit(BTRFS_ROOT_REF_COWS,
 					    &root->state)) {
				inode_sub_bytes(inode, item_end + 1 - new_size);
 			}
 		}
 delete:
		if (del_item) {
			if (!pending_del_nr) {
				/* no pending yet, add ourselves */
				pending_del_slot = path->slots[0];
				pending_del_nr = 1;
			} else if (pending_del_nr &&
				   path->slots[0] + 1 == pending_del_slot) {
				/* hop on the pending chunk */
				pending_del_nr++;
				pending_del_slot = path->slots[0];
			} else {
				BUG();
			}
		} else {
			break;
		}
		should_throttle = 0;

		if (found_extent &&
		    (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||
		     root == root->fs_info->tree_root)) {
			btrfs_set_path_blocking(path);
			bytes_deleted += extent_num_bytes;
			ret = btrfs_free_extent(trans, root, extent_start,
						extent_num_bytes, 0,
						btrfs_header_owner(leaf),
						ino, extent_offset, 0);
			BUG_ON(ret);
			if (btrfs_should_throttle_delayed_refs(trans, root))
				btrfs_async_run_delayed_refs(root,
					trans->delayed_ref_updates * 2, 0);
			if (be_nice) {
				if (truncate_space_check(trans, root,
							 extent_num_bytes)) {
					should_end = 1;
				}
				if (btrfs_should_throttle_delayed_refs(trans,
								       root)) {
					should_throttle = 1;
				}
			}
		}

		if (found_type == BTRFS_INODE_ITEM_KEY)
			break;

		if (path->slots[0] == 0 ||
		    path->slots[0] != pending_del_slot ||
		    should_throttle || should_end) {
			if (pending_del_nr) {
				ret = btrfs_del_items(trans, root, path,
						pending_del_slot,
						pending_del_nr);
				if (ret) {
					btrfs_abort_transaction(trans,
								root, ret);
					goto error;
				}
				pending_del_nr = 0;
			}
			btrfs_release_path(path);
			if (should_throttle) {
				unsigned long updates = trans->delayed_ref_updates;
				if (updates) {
					trans->delayed_ref_updates = 0;
					ret = btrfs_run_delayed_refs(trans, root, updates * 2);
					if (ret && !err)
						err = ret;
				}
			}
			/*
			 * if we failed to refill our space rsv, bail out
			 * and let the transaction restart
			 */
			if (should_end) {
				err = -EAGAIN;
				goto error;
			}
			goto search_again;
		} else {
			path->slots[0]--;
		}
	}
out:
	if (pending_del_nr) {
		ret = btrfs_del_items(trans, root, path, pending_del_slot,
				      pending_del_nr);
		if (ret)
			btrfs_abort_transaction(trans, root, ret);
	}
error:
	if (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)
		btrfs_ordered_update_i_size(inode, last_size, NULL);

	btrfs_free_path(path);

	if (be_nice && bytes_deleted > 32 * 1024 * 1024) {
		unsigned long updates = trans->delayed_ref_updates;
		if (updates) {
			trans->delayed_ref_updates = 0;
			ret = btrfs_run_delayed_refs(trans, root, updates * 2);
			if (ret && !err)
				err = ret;
		}
	}
	return err;
}
","The `btrfs_truncate_inode_items` function is responsible for truncating the items associated with a specific inode in a Btrfs filesystem. It takes parameters such as a transaction handle, root, inode, new size, and minimum type to determine which items to delete or modify. The function searches for file extent items in the Btrfs tree, adjusting their sizes or deleting them based on the new size specified. It handles inline and non-inline extents differently, ensuring proper memory management and updating the inode's size accordingly. Additionally, it incorporates mechanisms to manage transaction throttling and error handling throughout the process.","The provided code implements a function that manages the truncation of file items associated with a specific inode in a Btrfs filesystem. It adjusts the size of file extents based on a specified new size, determining whether to delete or modify existing items. The function efficiently searches through the filesystem's data structure, handling both inline and non-inline extents while ensuring proper memory management. It also incorporates mechanisms for transaction management, including throttling and error handling, to maintain filesystem integrity during the truncation process, ultimately updating the inode's size as necessary.","The vulnerability in the original code stemmed from the failure to properly discard data between the new and old file sizes when truncating a file with compressed inline extents. This oversight allowed truncated data to remain accessible, potentially leading to unauthorized data exposure through operations like cloning, where another user could read the previously truncated data. The fix involved implementing a process to correctly truncate compressed inline extents by decompressing the data, adjusting the size, and then recompressing it before writing back to the inline extent. This ensured that the truncated region was effectively discarded, preventing data leakage and maintaining accurate inode byte counts.","The vulnerability in the original code arose from the failure to properly discard data when truncating a file with compressed inline extents, which allowed truncated data to remain accessible. This oversight could lead to unauthorized access to sensitive information, as users could potentially read data that should have been removed. The fix involved implementing a process to ensure that the truncated region was effectively discarded by decompressing the data, adjusting the size, and then recompressing it before writing back. This approach not only prevented data leakage but also ensured accurate reporting of the inode's byte count, maintaining filesystem integrity.","The vulnerability was fixed by modifying the truncation process for compressed inline extents. The code now checks if the data is already in the page cache; if not, it decompresses the data before truncation. After determining the new size, it compresses the truncated version of the extent and writes it back into the inline extent. This is achieved through the `truncate_inline_extent` function, which ensures that the data between the new and old sizes is discarded, preventing any leakage of truncated data. Additionally, the code correctly updates the inode's byte count, ensuring accurate reporting for system calls.","The vulnerability was addressed by enhancing the truncation process for compressed inline extents to ensure that any data between the new and old file sizes is properly discarded. The fix involves decompressing the data if it is not already cached, adjusting the size accordingly, and then recompressing the truncated data before writing it back. This approach effectively prevents any leakage of previously truncated data, ensuring that sensitive information cannot be accessed after a file has been truncated. Additionally, the fix ensures that the byte count used by the inode is accurately updated, maintaining filesystem integrity.","5, 4","5, 5","4, 4","4,4"
52,52,179746,179746,,Local,Not required,,CVE-2015-7885,https://www.cvedetails.com/cve/CVE-2015-7885/,CWE-200,Low,Partial,,,2015-12-28,2.1,"The dgnc_mgmt_ioctl function in drivers/staging/dgnc/dgnc_mgmt.c in the Linux kernel through 4.3.3 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel memory via a crafted application.",2016-12-07,+Info ,1,https://github.com/torvalds/linux/commit/4b6184336ebb5c8dc1eae7f7ab46ee608a748b05,4b6184336ebb5c8dc1eae7f7ab46ee608a748b05,"staging/dgnc: fix info leak in ioctl

The dgnc_mgmt_ioctl() code fails to initialize the 16 _reserved bytes of
struct digi_dinfo after the ->dinfo_nboards member. Add an explicit
memset(0) before filling the structure to avoid the info leak.

Signed-off-by: Salva Peiró <speirofr@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",0,drivers/staging/dgnc/dgnc_mgmt.c,"{""sha"": ""518fbd5e2d0e20159ba4b548b92e418b67c36858"", ""filename"": ""drivers/staging/dgnc/dgnc_mgmt.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4b6184336ebb5c8dc1eae7f7ab46ee608a748b05/drivers/staging/dgnc/dgnc_mgmt.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4b6184336ebb5c8dc1eae7f7ab46ee608a748b05/drivers/staging/dgnc/dgnc_mgmt.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/staging/dgnc/dgnc_mgmt.c?ref=4b6184336ebb5c8dc1eae7f7ab46ee608a748b05"", ""patch"": ""@@ -110,6 +110,7 @@ long dgnc_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n \n \t\tspin_lock_irqsave(&dgnc_global_lock, flags);\n \n+\t\tmemset(&ddi, 0, sizeof(ddi));\n \t\tddi.dinfo_nboards = dgnc_NumBoards;\n \t\tsprintf(ddi.dinfo_version, \""%s\"", DG_PART);\n ""}","long dgnc_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	unsigned long flags;
	void __user *uarg = (void __user *)arg;

	switch (cmd) {
	case DIGI_GETDD:
	{
		/*
		 * This returns the total number of boards
		 * in the system, as well as driver version
		 * and has space for a reserved entry
		 */
		struct digi_dinfo ddi;
 
 		spin_lock_irqsave(&dgnc_global_lock, flags);
 
		memset(&ddi, 0, sizeof(ddi));
 		ddi.dinfo_nboards = dgnc_NumBoards;
 		sprintf(ddi.dinfo_version, ""%s"", DG_PART);
 
		spin_unlock_irqrestore(&dgnc_global_lock, flags);

		if (copy_to_user(uarg, &ddi, sizeof(ddi)))
			return -EFAULT;

		break;
	}

	case DIGI_GETBD:
	{
		int brd;

		struct digi_info di;

		if (copy_from_user(&brd, uarg, sizeof(int)))
			return -EFAULT;

		if (brd < 0 || brd >= dgnc_NumBoards)
			return -ENODEV;

		memset(&di, 0, sizeof(di));

		di.info_bdnum = brd;

		spin_lock_irqsave(&dgnc_Board[brd]->bd_lock, flags);

		di.info_bdtype = dgnc_Board[brd]->dpatype;
		di.info_bdstate = dgnc_Board[brd]->dpastatus;
		di.info_ioport = 0;
		di.info_physaddr = (ulong)dgnc_Board[brd]->membase;
		di.info_physsize = (ulong)dgnc_Board[brd]->membase
			- dgnc_Board[brd]->membase_end;
		if (dgnc_Board[brd]->state != BOARD_FAILED)
			di.info_nports = dgnc_Board[brd]->nasync;
		else
			di.info_nports = 0;

		spin_unlock_irqrestore(&dgnc_Board[brd]->bd_lock, flags);

		if (copy_to_user(uarg, &di, sizeof(di)))
			return -EFAULT;

		break;
	}

	case DIGI_GET_NI_INFO:
	{
		struct channel_t *ch;
		struct ni_info ni;
		unsigned char mstat = 0;
		uint board = 0;
		uint channel = 0;

		if (copy_from_user(&ni, uarg, sizeof(ni)))
			return -EFAULT;

		board = ni.board;
		channel = ni.channel;

		/* Verify boundaries on board */
		if (board >= dgnc_NumBoards)
			return -ENODEV;

		/* Verify boundaries on channel */
		if (channel >= dgnc_Board[board]->nasync)
			return -ENODEV;

		ch = dgnc_Board[board]->channels[channel];

		if (!ch || ch->magic != DGNC_CHANNEL_MAGIC)
			return -ENODEV;

		memset(&ni, 0, sizeof(ni));
		ni.board = board;
		ni.channel = channel;

		spin_lock_irqsave(&ch->ch_lock, flags);

		mstat = (ch->ch_mostat | ch->ch_mistat);

		if (mstat & UART_MCR_DTR) {
			ni.mstat |= TIOCM_DTR;
			ni.dtr = TIOCM_DTR;
		}
		if (mstat & UART_MCR_RTS) {
			ni.mstat |= TIOCM_RTS;
			ni.rts = TIOCM_RTS;
		}
		if (mstat & UART_MSR_CTS) {
			ni.mstat |= TIOCM_CTS;
			ni.cts = TIOCM_CTS;
		}
		if (mstat & UART_MSR_RI) {
			ni.mstat |= TIOCM_RI;
			ni.ri = TIOCM_RI;
		}
		if (mstat & UART_MSR_DCD) {
			ni.mstat |= TIOCM_CD;
			ni.dcd = TIOCM_CD;
		}
		if (mstat & UART_MSR_DSR)
			ni.mstat |= TIOCM_DSR;

		ni.iflag = ch->ch_c_iflag;
		ni.oflag = ch->ch_c_oflag;
		ni.cflag = ch->ch_c_cflag;
		ni.lflag = ch->ch_c_lflag;

		if (ch->ch_digi.digi_flags & CTSPACE ||
		    ch->ch_c_cflag & CRTSCTS)
			ni.hflow = 1;
		else
			ni.hflow = 0;

		if ((ch->ch_flags & CH_STOPI) ||
		    (ch->ch_flags & CH_FORCED_STOPI))
			ni.recv_stopped = 1;
		else
			ni.recv_stopped = 0;

		if ((ch->ch_flags & CH_STOP) || (ch->ch_flags & CH_FORCED_STOP))
			ni.xmit_stopped = 1;
		else
			ni.xmit_stopped = 0;

		ni.curtx = ch->ch_txcount;
		ni.currx = ch->ch_rxcount;

		ni.baud = ch->ch_old_baud;

		spin_unlock_irqrestore(&ch->ch_lock, flags);

		if (copy_to_user(uarg, &ni, sizeof(ni)))
			return -EFAULT;

		break;
	}
	}

	return 0;
}
","long dgnc_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	unsigned long flags;
	void __user *uarg = (void __user *)arg;

	switch (cmd) {
	case DIGI_GETDD:
	{
		/*
		 * This returns the total number of boards
		 * in the system, as well as driver version
		 * and has space for a reserved entry
		 */
		struct digi_dinfo ddi;
 
 		spin_lock_irqsave(&dgnc_global_lock, flags);
 
 		ddi.dinfo_nboards = dgnc_NumBoards;
 		sprintf(ddi.dinfo_version, ""%s"", DG_PART);
 
		spin_unlock_irqrestore(&dgnc_global_lock, flags);

		if (copy_to_user(uarg, &ddi, sizeof(ddi)))
			return -EFAULT;

		break;
	}

	case DIGI_GETBD:
	{
		int brd;

		struct digi_info di;

		if (copy_from_user(&brd, uarg, sizeof(int)))
			return -EFAULT;

		if (brd < 0 || brd >= dgnc_NumBoards)
			return -ENODEV;

		memset(&di, 0, sizeof(di));

		di.info_bdnum = brd;

		spin_lock_irqsave(&dgnc_Board[brd]->bd_lock, flags);

		di.info_bdtype = dgnc_Board[brd]->dpatype;
		di.info_bdstate = dgnc_Board[brd]->dpastatus;
		di.info_ioport = 0;
		di.info_physaddr = (ulong)dgnc_Board[brd]->membase;
		di.info_physsize = (ulong)dgnc_Board[brd]->membase
			- dgnc_Board[brd]->membase_end;
		if (dgnc_Board[brd]->state != BOARD_FAILED)
			di.info_nports = dgnc_Board[brd]->nasync;
		else
			di.info_nports = 0;

		spin_unlock_irqrestore(&dgnc_Board[brd]->bd_lock, flags);

		if (copy_to_user(uarg, &di, sizeof(di)))
			return -EFAULT;

		break;
	}

	case DIGI_GET_NI_INFO:
	{
		struct channel_t *ch;
		struct ni_info ni;
		unsigned char mstat = 0;
		uint board = 0;
		uint channel = 0;

		if (copy_from_user(&ni, uarg, sizeof(ni)))
			return -EFAULT;

		board = ni.board;
		channel = ni.channel;

		/* Verify boundaries on board */
		if (board >= dgnc_NumBoards)
			return -ENODEV;

		/* Verify boundaries on channel */
		if (channel >= dgnc_Board[board]->nasync)
			return -ENODEV;

		ch = dgnc_Board[board]->channels[channel];

		if (!ch || ch->magic != DGNC_CHANNEL_MAGIC)
			return -ENODEV;

		memset(&ni, 0, sizeof(ni));
		ni.board = board;
		ni.channel = channel;

		spin_lock_irqsave(&ch->ch_lock, flags);

		mstat = (ch->ch_mostat | ch->ch_mistat);

		if (mstat & UART_MCR_DTR) {
			ni.mstat |= TIOCM_DTR;
			ni.dtr = TIOCM_DTR;
		}
		if (mstat & UART_MCR_RTS) {
			ni.mstat |= TIOCM_RTS;
			ni.rts = TIOCM_RTS;
		}
		if (mstat & UART_MSR_CTS) {
			ni.mstat |= TIOCM_CTS;
			ni.cts = TIOCM_CTS;
		}
		if (mstat & UART_MSR_RI) {
			ni.mstat |= TIOCM_RI;
			ni.ri = TIOCM_RI;
		}
		if (mstat & UART_MSR_DCD) {
			ni.mstat |= TIOCM_CD;
			ni.dcd = TIOCM_CD;
		}
		if (mstat & UART_MSR_DSR)
			ni.mstat |= TIOCM_DSR;

		ni.iflag = ch->ch_c_iflag;
		ni.oflag = ch->ch_c_oflag;
		ni.cflag = ch->ch_c_cflag;
		ni.lflag = ch->ch_c_lflag;

		if (ch->ch_digi.digi_flags & CTSPACE ||
		    ch->ch_c_cflag & CRTSCTS)
			ni.hflow = 1;
		else
			ni.hflow = 0;

		if ((ch->ch_flags & CH_STOPI) ||
		    (ch->ch_flags & CH_FORCED_STOPI))
			ni.recv_stopped = 1;
		else
			ni.recv_stopped = 0;

		if ((ch->ch_flags & CH_STOP) || (ch->ch_flags & CH_FORCED_STOP))
			ni.xmit_stopped = 1;
		else
			ni.xmit_stopped = 0;

		ni.curtx = ch->ch_txcount;
		ni.currx = ch->ch_rxcount;

		ni.baud = ch->ch_old_baud;

		spin_unlock_irqrestore(&ch->ch_lock, flags);

		if (copy_to_user(uarg, &ni, sizeof(ni)))
			return -EFAULT;

		break;
	}
	}

	return 0;
}
",C,"		memset(&ddi, 0, sizeof(ddi));
",,,"@@ -110,6 +110,7 @@ long dgnc_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 
 		spin_lock_irqsave(&dgnc_global_lock, flags);
 
+		memset(&ddi, 0, sizeof(ddi));
 		ddi.dinfo_nboards = dgnc_NumBoards;
 		sprintf(ddi.dinfo_version, ""%s"", DG_PART);
 ",linux,4b6184336ebb5c8dc1eae7f7ab46ee608a748b05,561e2967346af25aca786df77a339888574caec2,1,"long dgnc_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	unsigned long flags;
	void __user *uarg = (void __user *)arg;

	switch (cmd) {
	case DIGI_GETDD:
	{
		/*
		 * This returns the total number of boards
		 * in the system, as well as driver version
		 * and has space for a reserved entry
		 */
		struct digi_dinfo ddi;
 
 		spin_lock_irqsave(&dgnc_global_lock, flags);
 
//fix_flaw_line_below:
//		memset(&ddi, 0, sizeof(ddi));
 		ddi.dinfo_nboards = dgnc_NumBoards;
 		sprintf(ddi.dinfo_version, ""%s"", DG_PART);
 
		spin_unlock_irqrestore(&dgnc_global_lock, flags);

		if (copy_to_user(uarg, &ddi, sizeof(ddi)))
			return -EFAULT;

		break;
	}

	case DIGI_GETBD:
	{
		int brd;

		struct digi_info di;

		if (copy_from_user(&brd, uarg, sizeof(int)))
			return -EFAULT;

		if (brd < 0 || brd >= dgnc_NumBoards)
			return -ENODEV;

		memset(&di, 0, sizeof(di));

		di.info_bdnum = brd;

		spin_lock_irqsave(&dgnc_Board[brd]->bd_lock, flags);

		di.info_bdtype = dgnc_Board[brd]->dpatype;
		di.info_bdstate = dgnc_Board[brd]->dpastatus;
		di.info_ioport = 0;
		di.info_physaddr = (ulong)dgnc_Board[brd]->membase;
		di.info_physsize = (ulong)dgnc_Board[brd]->membase
			- dgnc_Board[brd]->membase_end;
		if (dgnc_Board[brd]->state != BOARD_FAILED)
			di.info_nports = dgnc_Board[brd]->nasync;
		else
			di.info_nports = 0;

		spin_unlock_irqrestore(&dgnc_Board[brd]->bd_lock, flags);

		if (copy_to_user(uarg, &di, sizeof(di)))
			return -EFAULT;

		break;
	}

	case DIGI_GET_NI_INFO:
	{
		struct channel_t *ch;
		struct ni_info ni;
		unsigned char mstat = 0;
		uint board = 0;
		uint channel = 0;

		if (copy_from_user(&ni, uarg, sizeof(ni)))
			return -EFAULT;

		board = ni.board;
		channel = ni.channel;

		/* Verify boundaries on board */
		if (board >= dgnc_NumBoards)
			return -ENODEV;

		/* Verify boundaries on channel */
		if (channel >= dgnc_Board[board]->nasync)
			return -ENODEV;

		ch = dgnc_Board[board]->channels[channel];

		if (!ch || ch->magic != DGNC_CHANNEL_MAGIC)
			return -ENODEV;

		memset(&ni, 0, sizeof(ni));
		ni.board = board;
		ni.channel = channel;

		spin_lock_irqsave(&ch->ch_lock, flags);

		mstat = (ch->ch_mostat | ch->ch_mistat);

		if (mstat & UART_MCR_DTR) {
			ni.mstat |= TIOCM_DTR;
			ni.dtr = TIOCM_DTR;
		}
		if (mstat & UART_MCR_RTS) {
			ni.mstat |= TIOCM_RTS;
			ni.rts = TIOCM_RTS;
		}
		if (mstat & UART_MSR_CTS) {
			ni.mstat |= TIOCM_CTS;
			ni.cts = TIOCM_CTS;
		}
		if (mstat & UART_MSR_RI) {
			ni.mstat |= TIOCM_RI;
			ni.ri = TIOCM_RI;
		}
		if (mstat & UART_MSR_DCD) {
			ni.mstat |= TIOCM_CD;
			ni.dcd = TIOCM_CD;
		}
		if (mstat & UART_MSR_DSR)
			ni.mstat |= TIOCM_DSR;

		ni.iflag = ch->ch_c_iflag;
		ni.oflag = ch->ch_c_oflag;
		ni.cflag = ch->ch_c_cflag;
		ni.lflag = ch->ch_c_lflag;

		if (ch->ch_digi.digi_flags & CTSPACE ||
		    ch->ch_c_cflag & CRTSCTS)
			ni.hflow = 1;
		else
			ni.hflow = 0;

		if ((ch->ch_flags & CH_STOPI) ||
		    (ch->ch_flags & CH_FORCED_STOPI))
			ni.recv_stopped = 1;
		else
			ni.recv_stopped = 0;

		if ((ch->ch_flags & CH_STOP) || (ch->ch_flags & CH_FORCED_STOP))
			ni.xmit_stopped = 1;
		else
			ni.xmit_stopped = 0;

		ni.curtx = ch->ch_txcount;
		ni.currx = ch->ch_rxcount;

		ni.baud = ch->ch_old_baud;

		spin_unlock_irqrestore(&ch->ch_lock, flags);

		if (copy_to_user(uarg, &ni, sizeof(ni)))
			return -EFAULT;

		break;
	}
	}

	return 0;
}
",179746,"long dgnc_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	unsigned long flags;
	void __user *uarg = (void __user *)arg;

	switch (cmd) {
	case DIGI_GETDD:
	{
		/*
		 * This returns the total number of boards
		 * in the system, as well as driver version
		 * and has space for a reserved entry
		 */
		struct digi_dinfo ddi;
 
 		spin_lock_irqsave(&dgnc_global_lock, flags);
 
 		ddi.dinfo_nboards = dgnc_NumBoards;
 		sprintf(ddi.dinfo_version, ""%s"", DG_PART);
 
		spin_unlock_irqrestore(&dgnc_global_lock, flags);

		if (copy_to_user(uarg, &ddi, sizeof(ddi)))
			return -EFAULT;

		break;
	}

	case DIGI_GETBD:
	{
		int brd;

		struct digi_info di;

		if (copy_from_user(&brd, uarg, sizeof(int)))
			return -EFAULT;

		if (brd < 0 || brd >= dgnc_NumBoards)
			return -ENODEV;

		memset(&di, 0, sizeof(di));

		di.info_bdnum = brd;

		spin_lock_irqsave(&dgnc_Board[brd]->bd_lock, flags);

		di.info_bdtype = dgnc_Board[brd]->dpatype;
		di.info_bdstate = dgnc_Board[brd]->dpastatus;
		di.info_ioport = 0;
		di.info_physaddr = (ulong)dgnc_Board[brd]->membase;
		di.info_physsize = (ulong)dgnc_Board[brd]->membase
			- dgnc_Board[brd]->membase_end;
		if (dgnc_Board[brd]->state != BOARD_FAILED)
			di.info_nports = dgnc_Board[brd]->nasync;
		else
			di.info_nports = 0;

		spin_unlock_irqrestore(&dgnc_Board[brd]->bd_lock, flags);

		if (copy_to_user(uarg, &di, sizeof(di)))
			return -EFAULT;

		break;
	}

	case DIGI_GET_NI_INFO:
	{
		struct channel_t *ch;
		struct ni_info ni;
		unsigned char mstat = 0;
		uint board = 0;
		uint channel = 0;

		if (copy_from_user(&ni, uarg, sizeof(ni)))
			return -EFAULT;

		board = ni.board;
		channel = ni.channel;

		/* Verify boundaries on board */
		if (board >= dgnc_NumBoards)
			return -ENODEV;

		/* Verify boundaries on channel */
		if (channel >= dgnc_Board[board]->nasync)
			return -ENODEV;

		ch = dgnc_Board[board]->channels[channel];

		if (!ch || ch->magic != DGNC_CHANNEL_MAGIC)
			return -ENODEV;

		memset(&ni, 0, sizeof(ni));
		ni.board = board;
		ni.channel = channel;

		spin_lock_irqsave(&ch->ch_lock, flags);

		mstat = (ch->ch_mostat | ch->ch_mistat);

		if (mstat & UART_MCR_DTR) {
			ni.mstat |= TIOCM_DTR;
			ni.dtr = TIOCM_DTR;
		}
		if (mstat & UART_MCR_RTS) {
			ni.mstat |= TIOCM_RTS;
			ni.rts = TIOCM_RTS;
		}
		if (mstat & UART_MSR_CTS) {
			ni.mstat |= TIOCM_CTS;
			ni.cts = TIOCM_CTS;
		}
		if (mstat & UART_MSR_RI) {
			ni.mstat |= TIOCM_RI;
			ni.ri = TIOCM_RI;
		}
		if (mstat & UART_MSR_DCD) {
			ni.mstat |= TIOCM_CD;
			ni.dcd = TIOCM_CD;
		}
		if (mstat & UART_MSR_DSR)
			ni.mstat |= TIOCM_DSR;

		ni.iflag = ch->ch_c_iflag;
		ni.oflag = ch->ch_c_oflag;
		ni.cflag = ch->ch_c_cflag;
		ni.lflag = ch->ch_c_lflag;

		if (ch->ch_digi.digi_flags & CTSPACE ||
		    ch->ch_c_cflag & CRTSCTS)
			ni.hflow = 1;
		else
			ni.hflow = 0;

		if ((ch->ch_flags & CH_STOPI) ||
		    (ch->ch_flags & CH_FORCED_STOPI))
			ni.recv_stopped = 1;
		else
			ni.recv_stopped = 0;

		if ((ch->ch_flags & CH_STOP) || (ch->ch_flags & CH_FORCED_STOP))
			ni.xmit_stopped = 1;
		else
			ni.xmit_stopped = 0;

		ni.curtx = ch->ch_txcount;
		ni.currx = ch->ch_rxcount;

		ni.baud = ch->ch_old_baud;

		spin_unlock_irqrestore(&ch->ch_lock, flags);

		if (copy_to_user(uarg, &ni, sizeof(ni)))
			return -EFAULT;

		break;
	}
	}

	return 0;
}
","long dgnc_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	unsigned long flags;
	void __user *uarg = (void __user *)arg;

	switch (cmd) {
	case DIGI_GETDD:
	{
		/*
		 * This returns the total number of boards
		 * in the system, as well as driver version
		 * and has space for a reserved entry
		 */
		struct digi_dinfo ddi;
 
 		spin_lock_irqsave(&dgnc_global_lock, flags);
 
		memset(&ddi, 0, sizeof(ddi));
 		ddi.dinfo_nboards = dgnc_NumBoards;
 		sprintf(ddi.dinfo_version, ""%s"", DG_PART);
 
		spin_unlock_irqrestore(&dgnc_global_lock, flags);

		if (copy_to_user(uarg, &ddi, sizeof(ddi)))
			return -EFAULT;

		break;
	}

	case DIGI_GETBD:
	{
		int brd;

		struct digi_info di;

		if (copy_from_user(&brd, uarg, sizeof(int)))
			return -EFAULT;

		if (brd < 0 || brd >= dgnc_NumBoards)
			return -ENODEV;

		memset(&di, 0, sizeof(di));

		di.info_bdnum = brd;

		spin_lock_irqsave(&dgnc_Board[brd]->bd_lock, flags);

		di.info_bdtype = dgnc_Board[brd]->dpatype;
		di.info_bdstate = dgnc_Board[brd]->dpastatus;
		di.info_ioport = 0;
		di.info_physaddr = (ulong)dgnc_Board[brd]->membase;
		di.info_physsize = (ulong)dgnc_Board[brd]->membase
			- dgnc_Board[brd]->membase_end;
		if (dgnc_Board[brd]->state != BOARD_FAILED)
			di.info_nports = dgnc_Board[brd]->nasync;
		else
			di.info_nports = 0;

		spin_unlock_irqrestore(&dgnc_Board[brd]->bd_lock, flags);

		if (copy_to_user(uarg, &di, sizeof(di)))
			return -EFAULT;

		break;
	}

	case DIGI_GET_NI_INFO:
	{
		struct channel_t *ch;
		struct ni_info ni;
		unsigned char mstat = 0;
		uint board = 0;
		uint channel = 0;

		if (copy_from_user(&ni, uarg, sizeof(ni)))
			return -EFAULT;

		board = ni.board;
		channel = ni.channel;

		/* Verify boundaries on board */
		if (board >= dgnc_NumBoards)
			return -ENODEV;

		/* Verify boundaries on channel */
		if (channel >= dgnc_Board[board]->nasync)
			return -ENODEV;

		ch = dgnc_Board[board]->channels[channel];

		if (!ch || ch->magic != DGNC_CHANNEL_MAGIC)
			return -ENODEV;

		memset(&ni, 0, sizeof(ni));
		ni.board = board;
		ni.channel = channel;

		spin_lock_irqsave(&ch->ch_lock, flags);

		mstat = (ch->ch_mostat | ch->ch_mistat);

		if (mstat & UART_MCR_DTR) {
			ni.mstat |= TIOCM_DTR;
			ni.dtr = TIOCM_DTR;
		}
		if (mstat & UART_MCR_RTS) {
			ni.mstat |= TIOCM_RTS;
			ni.rts = TIOCM_RTS;
		}
		if (mstat & UART_MSR_CTS) {
			ni.mstat |= TIOCM_CTS;
			ni.cts = TIOCM_CTS;
		}
		if (mstat & UART_MSR_RI) {
			ni.mstat |= TIOCM_RI;
			ni.ri = TIOCM_RI;
		}
		if (mstat & UART_MSR_DCD) {
			ni.mstat |= TIOCM_CD;
			ni.dcd = TIOCM_CD;
		}
		if (mstat & UART_MSR_DSR)
			ni.mstat |= TIOCM_DSR;

		ni.iflag = ch->ch_c_iflag;
		ni.oflag = ch->ch_c_oflag;
		ni.cflag = ch->ch_c_cflag;
		ni.lflag = ch->ch_c_lflag;

		if (ch->ch_digi.digi_flags & CTSPACE ||
		    ch->ch_c_cflag & CRTSCTS)
			ni.hflow = 1;
		else
			ni.hflow = 0;

		if ((ch->ch_flags & CH_STOPI) ||
		    (ch->ch_flags & CH_FORCED_STOPI))
			ni.recv_stopped = 1;
		else
			ni.recv_stopped = 0;

		if ((ch->ch_flags & CH_STOP) || (ch->ch_flags & CH_FORCED_STOP))
			ni.xmit_stopped = 1;
		else
			ni.xmit_stopped = 0;

		ni.curtx = ch->ch_txcount;
		ni.currx = ch->ch_rxcount;

		ni.baud = ch->ch_old_baud;

		spin_unlock_irqrestore(&ch->ch_lock, flags);

		if (copy_to_user(uarg, &ni, sizeof(ni)))
			return -EFAULT;

		break;
	}
	}

	return 0;
}
","The `dgnc_mgmt_ioctl` function handles various IOCTL commands for managing and retrieving information about digital communication boards in a system. It processes commands such as `DIGI_GETDD`, which retrieves the total number of boards and driver version, and `DIGI_GETBD`, which fetches specific board details based on an index provided by the user. Additionally, it supports `DIGI_GET_NI_INFO`, which gathers information about a specific channel on a board, including its status and configuration. The function ensures thread safety using spin locks and performs user-space memory operations to transfer data, returning appropriate error codes for invalid inputs or memory access issues.","The provided code implements a function that manages input/output control commands for digital communication boards within a system. It processes commands to retrieve the total number of boards and driver version, as well as specific details about individual boards and their channels. The function ensures safe access to shared resources by using locking mechanisms and performs memory operations to transfer data between user space and kernel space. It also includes error handling for invalid inputs and memory access issues, returning appropriate error codes when necessary, thereby facilitating effective communication with the hardware.","The vulnerability in the original code stemmed from not initializing the reserved bytes in the `digi_dinfo` structure, which could lead to unintentional information leakage when the structure was copied to user space. This oversight allowed potentially sensitive data from memory to be exposed. The fix involved adding a `memset` call to explicitly set the entire structure to zero before populating it with valid data, ensuring that all reserved bytes were cleared. This change effectively mitigated the risk of leaking uninitialized memory contents, thereby enhancing the security of the ioctl implementation.","The vulnerability in the original code was due to the failure to initialize reserved bytes in a data structure, which could inadvertently expose sensitive information from memory when the structure was sent to user space. This oversight created a potential information leak, allowing uninitialized data to be accessed. The fix involved adding a memory-clearing operation before populating the structure with valid data, ensuring that all bytes, including the reserved ones, were set to zero. This change effectively eliminated the risk of leaking uninitialized memory contents, thereby improving the security of the code.","The vulnerability was fixed by adding a `memset` call to initialize the `digi_dinfo` structure to zero before populating it with valid data. Specifically, the line `memset(&ddi, 0, sizeof(ddi));` was introduced right after acquiring the lock and before setting the `dinfo_nboards` and `dinfo_version` fields. This ensures that all 16 reserved bytes in the structure are cleared, preventing any uninitialized memory from being copied to user space during the `copy_to_user` operation. This change effectively mitigates the risk of information leakage by ensuring that no sensitive data is inadvertently exposed.","The vulnerability was addressed by incorporating a memory-clearing operation to initialize the entire data structure before it was populated with valid information. This step ensured that all bytes, including reserved ones, were set to zero, effectively preventing any uninitialized memory from being exposed when the structure was transferred to user space. By ensuring that no residual data from previous operations could leak, the fix eliminated the risk of sensitive information being inadvertently revealed, thereby enhancing the overall security of the code and safeguarding against potential information leaks.","4,5","5,5","5,5","4,5"
53,53,179747,179747,,Local,Not required,,CVE-2015-7884,https://www.cvedetails.com/cve/CVE-2015-7884/,CWE-200,Medium,Partial,,,2015-12-28,1.9,"The vivid_fb_ioctl function in drivers/media/platform/vivid/vivid-osd.c in the Linux kernel through 4.3.3 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel memory via a crafted application.",2016-12-07,+Info ,1,https://github.com/torvalds/linux/commit/eda98796aff0d9bf41094b06811f5def3b4c333c,eda98796aff0d9bf41094b06811f5def3b4c333c,"[media] media/vivid-osd: fix info leak in ioctl

The vivid_fb_ioctl() code fails to initialize the 16 _reserved bytes of
struct fb_vblank after the ->hcount member. Add an explicit
memset(0) before filling the structure to avoid the info leak.

Signed-off-by: Salva Peiró <speirofr@gmail.com>
Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>",0,drivers/media/platform/vivid/vivid-osd.c,"{""sha"": ""e15eef6a94e5585ad93a0dc81dcde54563f1aff6"", ""filename"": ""drivers/media/platform/vivid/vivid-osd.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/eda98796aff0d9bf41094b06811f5def3b4c333c/drivers/media/platform/vivid/vivid-osd.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/eda98796aff0d9bf41094b06811f5def3b4c333c/drivers/media/platform/vivid/vivid-osd.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/media/platform/vivid/vivid-osd.c?ref=eda98796aff0d9bf41094b06811f5def3b4c333c"", ""patch"": ""@@ -85,6 +85,7 @@ static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)\n \tcase FBIOGET_VBLANK: {\n \t\tstruct fb_vblank vblank;\n \n+\t\tmemset(&vblank, 0, sizeof(vblank));\n \t\tvblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |\n \t\t\tFB_VBLANK_HAVE_VSYNC;\n \t\tvblank.count = 0;""}","static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)
{
	struct vivid_dev *dev = (struct vivid_dev *)info->par;

	switch (cmd) {
 	case FBIOGET_VBLANK: {
 		struct fb_vblank vblank;
 
		memset(&vblank, 0, sizeof(vblank));
 		vblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |
 			FB_VBLANK_HAVE_VSYNC;
 		vblank.count = 0;
		vblank.vcount = 0;
		vblank.hcount = 0;
		if (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))
			return -EFAULT;
		return 0;
	}

	default:
		dprintk(dev, 1, ""Unknown ioctl %08x\n"", cmd);
		return -EINVAL;
	}
	return 0;
}
","static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)
{
	struct vivid_dev *dev = (struct vivid_dev *)info->par;

	switch (cmd) {
 	case FBIOGET_VBLANK: {
 		struct fb_vblank vblank;
 
 		vblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |
 			FB_VBLANK_HAVE_VSYNC;
 		vblank.count = 0;
		vblank.vcount = 0;
		vblank.hcount = 0;
		if (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))
			return -EFAULT;
		return 0;
	}

	default:
		dprintk(dev, 1, ""Unknown ioctl %08x\n"", cmd);
		return -EINVAL;
	}
	return 0;
}
",C,"		memset(&vblank, 0, sizeof(vblank));
",,,"@@ -85,6 +85,7 @@ static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)
 	case FBIOGET_VBLANK: {
 		struct fb_vblank vblank;
 
+		memset(&vblank, 0, sizeof(vblank));
 		vblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |
 			FB_VBLANK_HAVE_VSYNC;
 		vblank.count = 0;",linux,eda98796aff0d9bf41094b06811f5def3b4c333c,3c5be988e0b6a2f368e1659083b39e1f7ac909aa,1,"static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)
{
	struct vivid_dev *dev = (struct vivid_dev *)info->par;

	switch (cmd) {
 	case FBIOGET_VBLANK: {
 		struct fb_vblank vblank;
 
//fix_flaw_line_below:
//		memset(&vblank, 0, sizeof(vblank));
 		vblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |
 			FB_VBLANK_HAVE_VSYNC;
 		vblank.count = 0;
		vblank.vcount = 0;
		vblank.hcount = 0;
		if (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))
			return -EFAULT;
		return 0;
	}

	default:
		dprintk(dev, 1, ""Unknown ioctl %08x\n"", cmd);
		return -EINVAL;
	}
	return 0;
}
",179747,"static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)
{
	struct vivid_dev *dev = (struct vivid_dev *)info->par;

	switch (cmd) {
 	case FBIOGET_VBLANK: {
 		struct fb_vblank vblank;
 
 		vblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |
 			FB_VBLANK_HAVE_VSYNC;
 		vblank.count = 0;
		vblank.vcount = 0;
		vblank.hcount = 0;
		if (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))
			return -EFAULT;
		return 0;
	}

	default:
		dprintk(dev, 1, ""Unknown ioctl %08x\n"", cmd);
		return -EINVAL;
	}
	return 0;
}
","static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)
{
	struct vivid_dev *dev = (struct vivid_dev *)info->par;

	switch (cmd) {
 	case FBIOGET_VBLANK: {
 		struct fb_vblank vblank;
 
		memset(&vblank, 0, sizeof(vblank));
 		vblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |
 			FB_VBLANK_HAVE_VSYNC;
 		vblank.count = 0;
		vblank.vcount = 0;
		vblank.hcount = 0;
		if (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))
			return -EFAULT;
		return 0;
	}

	default:
		dprintk(dev, 1, ""Unknown ioctl %08x\n"", cmd);
		return -EINVAL;
	}
	return 0;
}
","The `vivid_fb_ioctl` function is an implementation of an ioctl handler for framebuffer devices in a Linux environment. It takes a pointer to a framebuffer info structure, a command identifier, and an argument for user data. When the command is `FBIOGET_VBLANK`, it populates a `fb_vblank` structure with flags indicating the availability of vertical blanking information and initializes the count and vertical count to zero. It then attempts to copy this structure to user space; if successful, it returns zero, otherwise, it returns an error. For any unrecognized command, it logs an error and returns an invalid argument error code.","The provided code defines a function that handles specific control commands for a framebuffer device in a Linux system. It processes a command to retrieve vertical blanking information, populating a structure with flags that indicate the availability of certain metrics, while initializing the count values to zero. The function then attempts to transfer this information to user space, returning a success status if the operation is successful, or an error if it fails. For any unrecognized command, it logs an error message and returns an indication of an invalid argument, ensuring proper handling of command requests.","The vulnerability in the original code stemmed from not initializing the reserved bytes in the `fb_vblank` structure, which could lead to an information leak, exposing potentially sensitive data to user space. The fix involved adding a `memset` function call to explicitly set all bytes of the `vblank` structure to zero before populating it with valid data. This ensures that any uninitialized memory is cleared, preventing the leakage of residual data from previous operations. By addressing this oversight, the updated code enhances security and maintains the integrity of the information being shared with user space.","The vulnerability in the original code arose from the failure to initialize reserved bytes in a data structure, which could inadvertently expose sensitive information to user space, leading to potential information leaks. This oversight allowed uninitialized memory to be returned, which might contain remnants of previous data. The fix involved adding a memory-clearing operation before populating the structure with valid data, ensuring that all bytes, including the reserved ones, are set to zero. This change effectively mitigates the risk of leaking unintended information, thereby enhancing the security of the code.","The vulnerability was fixed by adding a `memset` function call to initialize the `vblank` structure to zero before populating it with valid data. This explicit initialization ensures that all bytes, including the 16 reserved bytes following the `hcount` member, are cleared, preventing any residual data from being exposed to user space. By setting the entire structure to zero, the code eliminates the risk of leaking sensitive information that could have been present in uninitialized memory. This change enhances the security of the `vivid_fb_ioctl` function by ensuring that only intended data is shared with user space.","The vulnerability was addressed by incorporating a memory-clearing operation to ensure that all bytes in the data structure are initialized to zero before any valid data is assigned. This step effectively eliminates any residual data that could have been present in uninitialized memory, thereby preventing the potential exposure of sensitive information to user space. By ensuring that all parts of the structure are explicitly set to a known state, the fix enhances the security of the code and mitigates the risk of information leaks, ensuring that only intended and valid data is shared.","5,5","5,5","4,4","5,5"
54,54,179767,179767,,Local,Not required,,CVE-2015-5697,https://www.cvedetails.com/cve/CVE-2015-5697/,CWE-200,Low,Partial,,,2015-08-31,2.1,"The get_bitmap_file function in drivers/md/md.c in the Linux kernel before 4.1.6 does not initialize a certain bitmap data structure, which allows local users to obtain sensitive information from kernel memory via a GET_BITMAP_FILE ioctl call.",2017-09-20,+Info ,1,https://github.com/torvalds/linux/commit/b6878d9e03043695dbf3fa1caa6dfc09db225b16,b6878d9e03043695dbf3fa1caa6dfc09db225b16,"md: use kzalloc() when bitmap is disabled

In drivers/md/md.c get_bitmap_file() uses kmalloc() for creating a
mdu_bitmap_file_t called ""file"".

5769         file = kmalloc(sizeof(*file), GFP_NOIO);
5770         if (!file)
5771                 return -ENOMEM;

This structure is copied to user space at the end of the function.

5786         if (err == 0 &&
5787             copy_to_user(arg, file, sizeof(*file)))
5788                 err = -EFAULT

But if bitmap is disabled only the first byte of ""file"" is initialized
with zero, so it's possible to read some bytes (up to 4095) of kernel
space memory from user space. This is an information leak.

5775         /* bitmap disabled, zero the first byte and copy out */
5776         if (!mddev->bitmap_info.file)
5777                 file->pathname[0] = '\0';

Signed-off-by: Benjamin Randazzo <benjamin@randazzo.fr>
Signed-off-by: NeilBrown <neilb@suse.com>",1,drivers/md/md.c,"{""sha"": ""e25f00f0138a7b4d82a5ae4f6fc7e1b6f0bb1b30"", ""filename"": ""drivers/md/md.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/b6878d9e03043695dbf3fa1caa6dfc09db225b16/drivers/md/md.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/b6878d9e03043695dbf3fa1caa6dfc09db225b16/drivers/md/md.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/md/md.c?ref=b6878d9e03043695dbf3fa1caa6dfc09db225b16"", ""patch"": ""@@ -5759,7 +5759,7 @@ static int get_bitmap_file(struct mddev *mddev, void __user * arg)\n \tchar *ptr;\n \tint err;\n \n-\tfile = kmalloc(sizeof(*file), GFP_NOIO);\n+\tfile = kzalloc(sizeof(*file), GFP_NOIO);\n \tif (!file)\n \t\treturn -ENOMEM;\n ""}","static int get_bitmap_file(struct mddev *mddev, void __user * arg)
{
	mdu_bitmap_file_t *file = NULL; /* too big for stack allocation */
 	char *ptr;
 	int err;
 
	file = kzalloc(sizeof(*file), GFP_NOIO);
 	if (!file)
 		return -ENOMEM;
 
	err = 0;
	spin_lock(&mddev->lock);
	/* bitmap disabled, zero the first byte and copy out */
	if (!mddev->bitmap_info.file)
		file->pathname[0] = '\0';
	else if ((ptr = file_path(mddev->bitmap_info.file,
			       file->pathname, sizeof(file->pathname))),
		 IS_ERR(ptr))
		err = PTR_ERR(ptr);
	else
		memmove(file->pathname, ptr,
			sizeof(file->pathname)-(ptr-file->pathname));
	spin_unlock(&mddev->lock);

	if (err == 0 &&
	    copy_to_user(arg, file, sizeof(*file)))
		err = -EFAULT;

	kfree(file);
	return err;
}
","static int get_bitmap_file(struct mddev *mddev, void __user * arg)
{
	mdu_bitmap_file_t *file = NULL; /* too big for stack allocation */
 	char *ptr;
 	int err;
 
	file = kmalloc(sizeof(*file), GFP_NOIO);
 	if (!file)
 		return -ENOMEM;
 
	err = 0;
	spin_lock(&mddev->lock);
	/* bitmap disabled, zero the first byte and copy out */
	if (!mddev->bitmap_info.file)
		file->pathname[0] = '\0';
	else if ((ptr = file_path(mddev->bitmap_info.file,
			       file->pathname, sizeof(file->pathname))),
		 IS_ERR(ptr))
		err = PTR_ERR(ptr);
	else
		memmove(file->pathname, ptr,
			sizeof(file->pathname)-(ptr-file->pathname));
	spin_unlock(&mddev->lock);

	if (err == 0 &&
	    copy_to_user(arg, file, sizeof(*file)))
		err = -EFAULT;

	kfree(file);
	return err;
}
",C,"	file = kzalloc(sizeof(*file), GFP_NOIO);
","	file = kmalloc(sizeof(*file), GFP_NOIO);
",,"@@ -5759,7 +5759,7 @@ static int get_bitmap_file(struct mddev *mddev, void __user * arg)
 	char *ptr;
 	int err;
 
-	file = kmalloc(sizeof(*file), GFP_NOIO);
+	file = kzalloc(sizeof(*file), GFP_NOIO);
 	if (!file)
 		return -ENOMEM;
 ",linux,b6878d9e03043695dbf3fa1caa6dfc09db225b16,423f04d63cf421ea436bcc5be02543d549ce4b28,1,"static int get_bitmap_file(struct mddev *mddev, void __user * arg)
{
	mdu_bitmap_file_t *file = NULL; /* too big for stack allocation */
 	char *ptr;
 	int err;
 
//flaw_line_below:
	file = kmalloc(sizeof(*file), GFP_NOIO);
//fix_flaw_line_below:
//	file = kzalloc(sizeof(*file), GFP_NOIO);
 	if (!file)
 		return -ENOMEM;
 
	err = 0;
	spin_lock(&mddev->lock);
	/* bitmap disabled, zero the first byte and copy out */
	if (!mddev->bitmap_info.file)
		file->pathname[0] = '\0';
	else if ((ptr = file_path(mddev->bitmap_info.file,
			       file->pathname, sizeof(file->pathname))),
		 IS_ERR(ptr))
		err = PTR_ERR(ptr);
	else
		memmove(file->pathname, ptr,
			sizeof(file->pathname)-(ptr-file->pathname));
	spin_unlock(&mddev->lock);

	if (err == 0 &&
	    copy_to_user(arg, file, sizeof(*file)))
		err = -EFAULT;

	kfree(file);
	return err;
}
",179767,"static int get_bitmap_file(struct mddev *mddev, void __user * arg)
{
	mdu_bitmap_file_t *file = NULL; /* too big for stack allocation */
 	char *ptr;
 	int err;
 
	file = kmalloc(sizeof(*file), GFP_NOIO);
 	if (!file)
 		return -ENOMEM;
 
	err = 0;
	spin_lock(&mddev->lock);
	/* bitmap disabled, zero the first byte and copy out */
	if (!mddev->bitmap_info.file)
		file->pathname[0] = '\0';
	else if ((ptr = file_path(mddev->bitmap_info.file,
			       file->pathname, sizeof(file->pathname))),
		 IS_ERR(ptr))
		err = PTR_ERR(ptr);
	else
		memmove(file->pathname, ptr,
			sizeof(file->pathname)-(ptr-file->pathname));
	spin_unlock(&mddev->lock);

	if (err == 0 &&
	    copy_to_user(arg, file, sizeof(*file)))
		err = -EFAULT;

	kfree(file);
	return err;
}
","static int get_bitmap_file(struct mddev *mddev, void __user * arg)
{
	mdu_bitmap_file_t *file = NULL; /* too big for stack allocation */
 	char *ptr;
 	int err;
 
	file = kzalloc(sizeof(*file), GFP_NOIO);
 	if (!file)
 		return -ENOMEM;
 
	err = 0;
	spin_lock(&mddev->lock);
	/* bitmap disabled, zero the first byte and copy out */
	if (!mddev->bitmap_info.file)
		file->pathname[0] = '\0';
	else if ((ptr = file_path(mddev->bitmap_info.file,
			       file->pathname, sizeof(file->pathname))),
		 IS_ERR(ptr))
		err = PTR_ERR(ptr);
	else
		memmove(file->pathname, ptr,
			sizeof(file->pathname)-(ptr-file->pathname));
	spin_unlock(&mddev->lock);

	if (err == 0 &&
	    copy_to_user(arg, file, sizeof(*file)))
		err = -EFAULT;

	kfree(file);
	return err;
}
","The `get_bitmap_file` function retrieves the file path of a bitmap associated with a given `mddev` structure, which represents a multi-device (MD) array in Linux. It allocates memory for a `mdu_bitmap_file_t` structure to store the file path. The function first checks if the bitmap is enabled; if not, it sets the first byte of the path to zero. If the bitmap is enabled, it retrieves the file path using `file_path` and copies it into the allocated structure. After unlocking the `mddev` structure, it attempts to copy the populated structure to user space. Finally, it frees the allocated memory and returns any error encountered during the process.","The function is designed to retrieve the file path of a bitmap associated with a multi-device array. It begins by allocating memory for a structure that will hold the file path. The function checks if the bitmap is enabled; if it is not, it initializes the path to an empty string. If the bitmap is enabled, it retrieves the file path and copies it into the allocated structure. After ensuring thread safety, it attempts to transfer the populated structure to user space. Finally, it releases the allocated memory and returns any errors encountered during the process.","The vulnerability in the original code arises from using `kmalloc()` to allocate memory for the structure without fully initializing it when the bitmap is disabled. This results in only the first byte being set to zero, allowing potentially sensitive data from kernel memory to be leaked when the structure is copied to user space. The fix implemented in the updated code replaces `kmalloc()` with `kzalloc()`, which initializes the entire allocated memory to zero. This ensures that all bytes of the structure are cleared, preventing any uninitialized memory from being exposed to user space, thus eliminating the information leak.","The vulnerability in the original code stems from the use of a memory allocation function that does not initialize the entire allocated structure when the bitmap is disabled. This results in only the first byte being set to zero, leaving the rest of the memory potentially containing sensitive data from kernel space. Consequently, when this structure is copied to user space, it could inadvertently expose uninitialized memory, leading to an information leak. The fix implemented in the updated code replaces the original allocation method with one that initializes all allocated memory to zero, thereby preventing any leakage of sensitive information.","The vulnerability was fixed by replacing the use of `kmalloc()` with `kzalloc()` for allocating memory for the structure. While `kmalloc()` only allocates memory without initializing it, `kzalloc()` allocates and zeroes out the entire memory block. This change ensures that when the bitmap is disabled, the entire structure is initialized to zero, preventing any uninitialized memory from being copied to user space. As a result, the risk of leaking sensitive kernel memory is eliminated, as all bytes of the structure are now safely set to zero before being transferred to user space.","The vulnerability was addressed by changing the memory allocation method to one that initializes the entire allocated memory block to zero. This modification ensures that when the bitmap is disabled, all bytes of the allocated structure are set to a safe value, preventing any uninitialized memory from being exposed. As a result, the risk of leaking sensitive information from kernel space to user space is eliminated, as the entire structure is now properly initialized before being copied out. This fix effectively safeguards against potential information leaks that could arise from uninitialized memory.","5,5","5,5","5,5","5, 5"
55,55,179960,179960,,Remote,Not required,,CVE-2014-9423,https://www.cvedetails.com/cve/CVE-2014-9423/,CWE-200,Low,Partial,,,2015-02-19,5.0,"The svcauth_gss_accept_sec_context function in lib/rpc/svc_auth_gss.c in MIT Kerberos 5 (aka krb5) 1.11.x through 1.11.5, 1.12.x through 1.12.2, and 1.13.x before 1.13.1 transmits uninitialized interposer data to clients, which allows remote attackers to obtain sensitive information from process heap memory by sniffing the network for data in a handle field.",2016-11-28,+Info ,2,https://github.com/krb5/krb5/commit/5bb8a6b9c9eb8dd22bc9526751610aaa255ead9c,5bb8a6b9c9eb8dd22bc9526751610aaa255ead9c,"Fix gssrpc data leakage [CVE-2014-9423]

[MITKRB5-SA-2015-001] In svcauth_gss_accept_sec_context(), do not copy
bytes from the union context into the handle field we send to the
client.  We do not use this handle field, so just supply a fixed
string of ""xxxx"".

In gss_union_ctx_id_struct, remove the unused ""interposer"" field which
was causing part of the union context to remain uninitialized.

ticket: 8058 (new)
target_version: 1.13.1
tags: pullup",10,src/lib/rpc/svc_auth_gss.c,"{""sha"": ""2b5145e079fe27517cbfe1a7c94113bfb184ac50"", ""filename"": ""src/lib/gssapi/mechglue/mglueP.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/krb5/krb5/blob/5bb8a6b9c9eb8dd22bc9526751610aaa255ead9c/src/lib/gssapi/mechglue/mglueP.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/5bb8a6b9c9eb8dd22bc9526751610aaa255ead9c/src/lib/gssapi/mechglue/mglueP.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/mechglue/mglueP.h?ref=5bb8a6b9c9eb8dd22bc9526751610aaa255ead9c"", ""patch"": ""@@ -25,7 +25,6 @@ do {\t\t\t\t\t\t\t\t\\\n  */\n typedef struct gss_union_ctx_id_struct {\n \tstruct gss_union_ctx_id_struct *loopback;\n-\tstruct gss_union_ctx_id_struct *interposer;\n \tgss_OID\t\t\tmech_type;\n \tgss_ctx_id_t\t\tinternal_ctx_id;\n } gss_union_ctx_id_desc, *gss_union_ctx_id_t;""}<_**next**_>{""sha"": ""b81c4a349632358f1b6f513600d2331b802305ca"", ""filename"": ""src/lib/rpc/svc_auth_gss.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 23, ""changes"": 25, ""blob_url"": ""https://github.com/krb5/krb5/blob/5bb8a6b9c9eb8dd22bc9526751610aaa255ead9c/src/lib/rpc/svc_auth_gss.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/5bb8a6b9c9eb8dd22bc9526751610aaa255ead9c/src/lib/rpc/svc_auth_gss.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/rpc/svc_auth_gss.c?ref=5bb8a6b9c9eb8dd22bc9526751610aaa255ead9c"", ""patch"": ""@@ -65,16 +65,6 @@ extern const gss_OID_desc * const gss_mech_spkm3;\n \n extern SVCAUTH svc_auth_none;\n \n-/*\n- * from mit-krb5-1.2.1 mechglue/mglueP.h:\n- * Array of context IDs typed by mechanism OID\n- */\n-typedef struct gss_union_ctx_id_t {\n-  gss_OID     mech_type;\n-  gss_ctx_id_t    internal_ctx_id;\n-} gss_union_ctx_id_desc, *gss_union_ctx_id_t;\n-\n-\n static auth_gssapi_log_badauth_func log_badauth = NULL;\n static caddr_t log_badauth_data = NULL;\n static auth_gssapi_log_badauth2_func log_badauth2 = NULL;\n@@ -239,16 +229,8 @@ svcauth_gss_accept_sec_context(struct svc_req *rqst,\n \t\tgd->ctx = GSS_C_NO_CONTEXT;\n \t\tgoto errout;\n \t}\n-\t/*\n-\t * ANDROS: krb5 mechglue returns ctx of size 8 - two pointers,\n-\t * one to the mechanism oid, one to the internal_ctx_id\n-\t */\n-\tif ((gr->gr_ctx.value = mem_alloc(sizeof(gss_union_ctx_id_desc))) == NULL) {\n-\t\tfprintf(stderr, \""svcauth_gss_accept_context: out of memory\\n\"");\n-\t\tgoto errout;\n-\t}\n-\tmemcpy(gr->gr_ctx.value, gd->ctx, sizeof(gss_union_ctx_id_desc));\n-\tgr->gr_ctx.length = sizeof(gss_union_ctx_id_desc);\n+\tgr->gr_ctx.value = \""xxxx\"";\n+\tgr->gr_ctx.length = 4;\n \n \t/* gr->gr_win = 0x00000005; ANDROS: for debugging linux kernel version...  */\n \tgr->gr_win = sizeof(gd->seqmask) * 8;\n@@ -520,8 +502,6 @@ gssrpc__svcauth_gss(struct svc_req *rqst, struct rpc_msg *msg,\n \n \t\tif (!svcauth_gss_nextverf(rqst, htonl(gr.gr_win))) {\n \t\t\tgss_release_buffer(&min_stat, &gr.gr_token);\n-\t\t\tmem_free(gr.gr_ctx.value,\n-\t\t\t\t sizeof(gss_union_ctx_id_desc));\n \t\t\tret_freegc (AUTH_FAILED);\n \t\t}\n \t\t*no_dispatch = TRUE;\n@@ -531,7 +511,6 @@ gssrpc__svcauth_gss(struct svc_req *rqst, struct rpc_msg *msg,\n \n \t\tgss_release_buffer(&min_stat, &gr.gr_token);\n \t\tgss_release_buffer(&min_stat, &gd->checksum);\n-\t\tmem_free(gr.gr_ctx.value, sizeof(gss_union_ctx_id_desc));\n \t\tif (!call_stat)\n \t\t\tret_freegc (AUTH_FAILED);\n ""}","svcauth_gss_accept_sec_context(struct svc_req *rqst,
			       struct rpc_gss_init_res *gr)
{
	struct svc_rpc_gss_data	*gd;
	struct rpc_gss_cred	*gc;
	gss_buffer_desc		 recv_tok, seqbuf;
	gss_OID			 mech;
	OM_uint32		 maj_stat = 0, min_stat = 0, ret_flags, seq;

	log_debug(""in svcauth_gss_accept_context()"");

	gd = SVCAUTH_PRIVATE(rqst->rq_xprt->xp_auth);
	gc = (struct rpc_gss_cred *)rqst->rq_clntcred;
	memset(gr, 0, sizeof(*gr));

	/* Deserialize arguments. */
	memset(&recv_tok, 0, sizeof(recv_tok));

	if (!svc_getargs(rqst->rq_xprt, xdr_rpc_gss_init_args,
			 (caddr_t)&recv_tok))
		return (FALSE);

	gr->gr_major = gss_accept_sec_context(&gr->gr_minor,
					      &gd->ctx,
					      svcauth_gss_creds,
					      &recv_tok,
					      GSS_C_NO_CHANNEL_BINDINGS,
					      &gd->client_name,
					      &mech,
					      &gr->gr_token,
					      &ret_flags,
					      NULL,
					      NULL);

	svc_freeargs(rqst->rq_xprt, xdr_rpc_gss_init_args, (caddr_t)&recv_tok);

	log_status(""accept_sec_context"", gr->gr_major, gr->gr_minor);
	if (gr->gr_major != GSS_S_COMPLETE &&
	    gr->gr_major != GSS_S_CONTINUE_NEEDED) {
		badauth(gr->gr_major, gr->gr_minor, rqst->rq_xprt);
 		gd->ctx = GSS_C_NO_CONTEXT;
 		goto errout;
 	}
	gr->gr_ctx.value = ""xxxx"";
	gr->gr_ctx.length = 4;
 
 	/* gr->gr_win = 0x00000005; ANDROS: for debugging linux kernel version...  */
 	gr->gr_win = sizeof(gd->seqmask) * 8;

	/* Save client info. */
	gd->sec.mech = mech;
	gd->sec.qop = GSS_C_QOP_DEFAULT;
	gd->sec.svc = gc->gc_svc;
	gd->seq = gc->gc_seq;
	gd->win = gr->gr_win;

	if (gr->gr_major == GSS_S_COMPLETE) {
#ifdef SPKM
		/* spkm3: no src_name (anonymous) */
		if(!g_OID_equal(gss_mech_spkm3, mech)) {
#endif
		    maj_stat = gss_display_name(&min_stat, gd->client_name,
					    &gd->cname, &gd->sec.mech);
#ifdef SPKM
		}
#endif
		if (maj_stat != GSS_S_COMPLETE) {
			log_status(""display_name"", maj_stat, min_stat);
			goto errout;
		}
#ifdef DEBUG
#ifdef HAVE_HEIMDAL
		log_debug(""accepted context for %.*s with ""
			  ""<mech {}, qop %d, svc %d>"",
			  gd->cname.length, (char *)gd->cname.value,
			  gd->sec.qop, gd->sec.svc);
#else
		{
			gss_buffer_desc mechname;

			gss_oid_to_str(&min_stat, mech, &mechname);

			log_debug(""accepted context for %.*s with ""
				  ""<mech %.*s, qop %d, svc %d>"",
				  gd->cname.length, (char *)gd->cname.value,
				  mechname.length, (char *)mechname.value,
				  gd->sec.qop, gd->sec.svc);

			gss_release_buffer(&min_stat, &mechname);
		}
#endif
#endif /* DEBUG */
		seq = htonl(gr->gr_win);
		seqbuf.value = &seq;
		seqbuf.length = sizeof(seq);

		gss_release_buffer(&min_stat, &gd->checksum);
		maj_stat = gss_sign(&min_stat, gd->ctx, GSS_C_QOP_DEFAULT,
				    &seqbuf, &gd->checksum);

		if (maj_stat != GSS_S_COMPLETE) {
			goto errout;
		}


		rqst->rq_xprt->xp_verf.oa_flavor = RPCSEC_GSS;
		rqst->rq_xprt->xp_verf.oa_base = gd->checksum.value;
		rqst->rq_xprt->xp_verf.oa_length = gd->checksum.length;
	}
	return (TRUE);
errout:
	gss_release_buffer(&min_stat, &gr->gr_token);
	return (FALSE);
}
","svcauth_gss_accept_sec_context(struct svc_req *rqst,
			       struct rpc_gss_init_res *gr)
{
	struct svc_rpc_gss_data	*gd;
	struct rpc_gss_cred	*gc;
	gss_buffer_desc		 recv_tok, seqbuf;
	gss_OID			 mech;
	OM_uint32		 maj_stat = 0, min_stat = 0, ret_flags, seq;

	log_debug(""in svcauth_gss_accept_context()"");

	gd = SVCAUTH_PRIVATE(rqst->rq_xprt->xp_auth);
	gc = (struct rpc_gss_cred *)rqst->rq_clntcred;
	memset(gr, 0, sizeof(*gr));

	/* Deserialize arguments. */
	memset(&recv_tok, 0, sizeof(recv_tok));

	if (!svc_getargs(rqst->rq_xprt, xdr_rpc_gss_init_args,
			 (caddr_t)&recv_tok))
		return (FALSE);

	gr->gr_major = gss_accept_sec_context(&gr->gr_minor,
					      &gd->ctx,
					      svcauth_gss_creds,
					      &recv_tok,
					      GSS_C_NO_CHANNEL_BINDINGS,
					      &gd->client_name,
					      &mech,
					      &gr->gr_token,
					      &ret_flags,
					      NULL,
					      NULL);

	svc_freeargs(rqst->rq_xprt, xdr_rpc_gss_init_args, (caddr_t)&recv_tok);

	log_status(""accept_sec_context"", gr->gr_major, gr->gr_minor);
	if (gr->gr_major != GSS_S_COMPLETE &&
	    gr->gr_major != GSS_S_CONTINUE_NEEDED) {
		badauth(gr->gr_major, gr->gr_minor, rqst->rq_xprt);
 		gd->ctx = GSS_C_NO_CONTEXT;
 		goto errout;
 	}
	/*
	 * ANDROS: krb5 mechglue returns ctx of size 8 - two pointers,
	 * one to the mechanism oid, one to the internal_ctx_id
	 */
	if ((gr->gr_ctx.value = mem_alloc(sizeof(gss_union_ctx_id_desc))) == NULL) {
		fprintf(stderr, ""svcauth_gss_accept_context: out of memory\n"");
		goto errout;
	}
	memcpy(gr->gr_ctx.value, gd->ctx, sizeof(gss_union_ctx_id_desc));
	gr->gr_ctx.length = sizeof(gss_union_ctx_id_desc);
 
 	/* gr->gr_win = 0x00000005; ANDROS: for debugging linux kernel version...  */
 	gr->gr_win = sizeof(gd->seqmask) * 8;

	/* Save client info. */
	gd->sec.mech = mech;
	gd->sec.qop = GSS_C_QOP_DEFAULT;
	gd->sec.svc = gc->gc_svc;
	gd->seq = gc->gc_seq;
	gd->win = gr->gr_win;

	if (gr->gr_major == GSS_S_COMPLETE) {
#ifdef SPKM
		/* spkm3: no src_name (anonymous) */
		if(!g_OID_equal(gss_mech_spkm3, mech)) {
#endif
		    maj_stat = gss_display_name(&min_stat, gd->client_name,
					    &gd->cname, &gd->sec.mech);
#ifdef SPKM
		}
#endif
		if (maj_stat != GSS_S_COMPLETE) {
			log_status(""display_name"", maj_stat, min_stat);
			goto errout;
		}
#ifdef DEBUG
#ifdef HAVE_HEIMDAL
		log_debug(""accepted context for %.*s with ""
			  ""<mech {}, qop %d, svc %d>"",
			  gd->cname.length, (char *)gd->cname.value,
			  gd->sec.qop, gd->sec.svc);
#else
		{
			gss_buffer_desc mechname;

			gss_oid_to_str(&min_stat, mech, &mechname);

			log_debug(""accepted context for %.*s with ""
				  ""<mech %.*s, qop %d, svc %d>"",
				  gd->cname.length, (char *)gd->cname.value,
				  mechname.length, (char *)mechname.value,
				  gd->sec.qop, gd->sec.svc);

			gss_release_buffer(&min_stat, &mechname);
		}
#endif
#endif /* DEBUG */
		seq = htonl(gr->gr_win);
		seqbuf.value = &seq;
		seqbuf.length = sizeof(seq);

		gss_release_buffer(&min_stat, &gd->checksum);
		maj_stat = gss_sign(&min_stat, gd->ctx, GSS_C_QOP_DEFAULT,
				    &seqbuf, &gd->checksum);

		if (maj_stat != GSS_S_COMPLETE) {
			goto errout;
		}


		rqst->rq_xprt->xp_verf.oa_flavor = RPCSEC_GSS;
		rqst->rq_xprt->xp_verf.oa_base = gd->checksum.value;
		rqst->rq_xprt->xp_verf.oa_length = gd->checksum.length;
	}
	return (TRUE);
errout:
	gss_release_buffer(&min_stat, &gr->gr_token);
	return (FALSE);
}
",C,"	gr->gr_ctx.value = ""xxxx"";
	gr->gr_ctx.length = 4;
","	/*
	 * ANDROS: krb5 mechglue returns ctx of size 8 - two pointers,
	 * one to the mechanism oid, one to the internal_ctx_id
	 */
	if ((gr->gr_ctx.value = mem_alloc(sizeof(gss_union_ctx_id_desc))) == NULL) {
		fprintf(stderr, ""svcauth_gss_accept_context: out of memory\n"");
		goto errout;
	}
	memcpy(gr->gr_ctx.value, gd->ctx, sizeof(gss_union_ctx_id_desc));
	gr->gr_ctx.length = sizeof(gss_union_ctx_id_desc);
",,"@@ -65,16 +65,6 @@ extern const gss_OID_desc * const gss_mech_spkm3;
 
 extern SVCAUTH svc_auth_none;
 
-/*
- * from mit-krb5-1.2.1 mechglue/mglueP.h:
- * Array of context IDs typed by mechanism OID
- */
-typedef struct gss_union_ctx_id_t {
-  gss_OID     mech_type;
-  gss_ctx_id_t    internal_ctx_id;
-} gss_union_ctx_id_desc, *gss_union_ctx_id_t;
-
-
 static auth_gssapi_log_badauth_func log_badauth = NULL;
 static caddr_t log_badauth_data = NULL;
 static auth_gssapi_log_badauth2_func log_badauth2 = NULL;
@@ -239,16 +229,8 @@ svcauth_gss_accept_sec_context(struct svc_req *rqst,
 		gd->ctx = GSS_C_NO_CONTEXT;
 		goto errout;
 	}
-	/*
-	 * ANDROS: krb5 mechglue returns ctx of size 8 - two pointers,
-	 * one to the mechanism oid, one to the internal_ctx_id
-	 */
-	if ((gr->gr_ctx.value = mem_alloc(sizeof(gss_union_ctx_id_desc))) == NULL) {
-		fprintf(stderr, ""svcauth_gss_accept_context: out of memory\n"");
-		goto errout;
-	}
-	memcpy(gr->gr_ctx.value, gd->ctx, sizeof(gss_union_ctx_id_desc));
-	gr->gr_ctx.length = sizeof(gss_union_ctx_id_desc);
+	gr->gr_ctx.value = ""xxxx"";
+	gr->gr_ctx.length = 4;
 
 	/* gr->gr_win = 0x00000005; ANDROS: for debugging linux kernel version...  */
 	gr->gr_win = sizeof(gd->seqmask) * 8;
@@ -520,8 +502,6 @@ gssrpc__svcauth_gss(struct svc_req *rqst, struct rpc_msg *msg,
 
 		if (!svcauth_gss_nextverf(rqst, htonl(gr.gr_win))) {
 			gss_release_buffer(&min_stat, &gr.gr_token);
-			mem_free(gr.gr_ctx.value,
-				 sizeof(gss_union_ctx_id_desc));
 			ret_freegc (AUTH_FAILED);
 		}
 		*no_dispatch = TRUE;
@@ -531,7 +511,6 @@ gssrpc__svcauth_gss(struct svc_req *rqst, struct rpc_msg *msg,
 
 		gss_release_buffer(&min_stat, &gr.gr_token);
 		gss_release_buffer(&min_stat, &gd->checksum);
-		mem_free(gr.gr_ctx.value, sizeof(gss_union_ctx_id_desc));
 		if (!call_stat)
 			ret_freegc (AUTH_FAILED);
 ",krb5,5bb8a6b9c9eb8dd22bc9526751610aaa255ead9c,6609658db0799053fbef0d7d0aa2f1fd68ef32d8,1,"svcauth_gss_accept_sec_context(struct svc_req *rqst,
			       struct rpc_gss_init_res *gr)
{
	struct svc_rpc_gss_data	*gd;
	struct rpc_gss_cred	*gc;
	gss_buffer_desc		 recv_tok, seqbuf;
	gss_OID			 mech;
	OM_uint32		 maj_stat = 0, min_stat = 0, ret_flags, seq;

	log_debug(""in svcauth_gss_accept_context()"");

	gd = SVCAUTH_PRIVATE(rqst->rq_xprt->xp_auth);
	gc = (struct rpc_gss_cred *)rqst->rq_clntcred;
	memset(gr, 0, sizeof(*gr));

	/* Deserialize arguments. */
	memset(&recv_tok, 0, sizeof(recv_tok));

	if (!svc_getargs(rqst->rq_xprt, xdr_rpc_gss_init_args,
			 (caddr_t)&recv_tok))
		return (FALSE);

	gr->gr_major = gss_accept_sec_context(&gr->gr_minor,
					      &gd->ctx,
					      svcauth_gss_creds,
					      &recv_tok,
					      GSS_C_NO_CHANNEL_BINDINGS,
					      &gd->client_name,
					      &mech,
					      &gr->gr_token,
					      &ret_flags,
					      NULL,
					      NULL);

	svc_freeargs(rqst->rq_xprt, xdr_rpc_gss_init_args, (caddr_t)&recv_tok);

	log_status(""accept_sec_context"", gr->gr_major, gr->gr_minor);
	if (gr->gr_major != GSS_S_COMPLETE &&
	    gr->gr_major != GSS_S_CONTINUE_NEEDED) {
		badauth(gr->gr_major, gr->gr_minor, rqst->rq_xprt);
 		gd->ctx = GSS_C_NO_CONTEXT;
 		goto errout;
 	}
//flaw_line_below:
	/*
//flaw_line_below:
	 * ANDROS: krb5 mechglue returns ctx of size 8 - two pointers,
//flaw_line_below:
	 * one to the mechanism oid, one to the internal_ctx_id
//flaw_line_below:
	 */
//flaw_line_below:
	if ((gr->gr_ctx.value = mem_alloc(sizeof(gss_union_ctx_id_desc))) == NULL) {
//flaw_line_below:
		fprintf(stderr, ""svcauth_gss_accept_context: out of memory\n"");
//flaw_line_below:
		goto errout;
//flaw_line_below:
	}
//flaw_line_below:
	memcpy(gr->gr_ctx.value, gd->ctx, sizeof(gss_union_ctx_id_desc));
//flaw_line_below:
	gr->gr_ctx.length = sizeof(gss_union_ctx_id_desc);
//fix_flaw_line_below:
//	gr->gr_ctx.value = ""xxxx"";
//fix_flaw_line_below:
//	gr->gr_ctx.length = 4;
 
 	/* gr->gr_win = 0x00000005; ANDROS: for debugging linux kernel version...  */
 	gr->gr_win = sizeof(gd->seqmask) * 8;

	/* Save client info. */
	gd->sec.mech = mech;
	gd->sec.qop = GSS_C_QOP_DEFAULT;
	gd->sec.svc = gc->gc_svc;
	gd->seq = gc->gc_seq;
	gd->win = gr->gr_win;

	if (gr->gr_major == GSS_S_COMPLETE) {
#ifdef SPKM
		/* spkm3: no src_name (anonymous) */
		if(!g_OID_equal(gss_mech_spkm3, mech)) {
#endif
		    maj_stat = gss_display_name(&min_stat, gd->client_name,
					    &gd->cname, &gd->sec.mech);
#ifdef SPKM
		}
#endif
		if (maj_stat != GSS_S_COMPLETE) {
			log_status(""display_name"", maj_stat, min_stat);
			goto errout;
		}
#ifdef DEBUG
#ifdef HAVE_HEIMDAL
		log_debug(""accepted context for %.*s with ""
			  ""<mech {}, qop %d, svc %d>"",
			  gd->cname.length, (char *)gd->cname.value,
			  gd->sec.qop, gd->sec.svc);
#else
		{
			gss_buffer_desc mechname;

			gss_oid_to_str(&min_stat, mech, &mechname);

			log_debug(""accepted context for %.*s with ""
				  ""<mech %.*s, qop %d, svc %d>"",
				  gd->cname.length, (char *)gd->cname.value,
				  mechname.length, (char *)mechname.value,
				  gd->sec.qop, gd->sec.svc);

			gss_release_buffer(&min_stat, &mechname);
		}
#endif
#endif /* DEBUG */
		seq = htonl(gr->gr_win);
		seqbuf.value = &seq;
		seqbuf.length = sizeof(seq);

		gss_release_buffer(&min_stat, &gd->checksum);
		maj_stat = gss_sign(&min_stat, gd->ctx, GSS_C_QOP_DEFAULT,
				    &seqbuf, &gd->checksum);

		if (maj_stat != GSS_S_COMPLETE) {
			goto errout;
		}


		rqst->rq_xprt->xp_verf.oa_flavor = RPCSEC_GSS;
		rqst->rq_xprt->xp_verf.oa_base = gd->checksum.value;
		rqst->rq_xprt->xp_verf.oa_length = gd->checksum.length;
	}
	return (TRUE);
errout:
	gss_release_buffer(&min_stat, &gr->gr_token);
	return (FALSE);
}
",179960,"svcauth_gss_accept_sec_context(struct svc_req *rqst,
			       struct rpc_gss_init_res *gr)
{
	struct svc_rpc_gss_data	*gd;
	struct rpc_gss_cred	*gc;
	gss_buffer_desc		 recv_tok, seqbuf;
	gss_OID			 mech;
	OM_uint32		 maj_stat = 0, min_stat = 0, ret_flags, seq;

	log_debug(""in svcauth_gss_accept_context()"");

	gd = SVCAUTH_PRIVATE(rqst->rq_xprt->xp_auth);
	gc = (struct rpc_gss_cred *)rqst->rq_clntcred;
	memset(gr, 0, sizeof(*gr));

	/* Deserialize arguments. */
	memset(&recv_tok, 0, sizeof(recv_tok));

	if (!svc_getargs(rqst->rq_xprt, xdr_rpc_gss_init_args,
			 (caddr_t)&recv_tok))
		return (FALSE);

	gr->gr_major = gss_accept_sec_context(&gr->gr_minor,
					      &gd->ctx,
					      svcauth_gss_creds,
					      &recv_tok,
					      GSS_C_NO_CHANNEL_BINDINGS,
					      &gd->client_name,
					      &mech,
					      &gr->gr_token,
					      &ret_flags,
					      NULL,
					      NULL);

	svc_freeargs(rqst->rq_xprt, xdr_rpc_gss_init_args, (caddr_t)&recv_tok);

	log_status(""accept_sec_context"", gr->gr_major, gr->gr_minor);
	if (gr->gr_major != GSS_S_COMPLETE &&
	    gr->gr_major != GSS_S_CONTINUE_NEEDED) {
		badauth(gr->gr_major, gr->gr_minor, rqst->rq_xprt);
 		gd->ctx = GSS_C_NO_CONTEXT;
 		goto errout;
 	}
	/*
	 * ANDROS: krb5 mechglue returns ctx of size 8 - two pointers,
	 * one to the mechanism oid, one to the internal_ctx_id
	 */
	if ((gr->gr_ctx.value = mem_alloc(sizeof(gss_union_ctx_id_desc))) == NULL) {
		fprintf(stderr, ""svcauth_gss_accept_context: out of memory\n"");
		goto errout;
	}
	memcpy(gr->gr_ctx.value, gd->ctx, sizeof(gss_union_ctx_id_desc));
	gr->gr_ctx.length = sizeof(gss_union_ctx_id_desc);
 
 	/* gr->gr_win = 0x00000005; ANDROS: for debugging linux kernel version...  */
 	gr->gr_win = sizeof(gd->seqmask) * 8;

	/* Save client info. */
	gd->sec.mech = mech;
	gd->sec.qop = GSS_C_QOP_DEFAULT;
	gd->sec.svc = gc->gc_svc;
	gd->seq = gc->gc_seq;
	gd->win = gr->gr_win;

	if (gr->gr_major == GSS_S_COMPLETE) {
#ifdef SPKM
		/* spkm3: no src_name (anonymous) */
		if(!g_OID_equal(gss_mech_spkm3, mech)) {
#endif
		    maj_stat = gss_display_name(&min_stat, gd->client_name,
					    &gd->cname, &gd->sec.mech);
#ifdef SPKM
		}
#endif
		if (maj_stat != GSS_S_COMPLETE) {
			log_status(""display_name"", maj_stat, min_stat);
			goto errout;
		}
#ifdef DEBUG
#ifdef HAVE_HEIMDAL
		log_debug(""accepted context for %.*s with ""
			  ""<mech {}, qop %d, svc %d>"",
			  gd->cname.length, (char *)gd->cname.value,
			  gd->sec.qop, gd->sec.svc);
#else
		{
			gss_buffer_desc mechname;

			gss_oid_to_str(&min_stat, mech, &mechname);

			log_debug(""accepted context for %.*s with ""
				  ""<mech %.*s, qop %d, svc %d>"",
				  gd->cname.length, (char *)gd->cname.value,
				  mechname.length, (char *)mechname.value,
				  gd->sec.qop, gd->sec.svc);

			gss_release_buffer(&min_stat, &mechname);
		}
#endif
#endif /* DEBUG */
		seq = htonl(gr->gr_win);
		seqbuf.value = &seq;
		seqbuf.length = sizeof(seq);

		gss_release_buffer(&min_stat, &gd->checksum);
		maj_stat = gss_sign(&min_stat, gd->ctx, GSS_C_QOP_DEFAULT,
				    &seqbuf, &gd->checksum);

		if (maj_stat != GSS_S_COMPLETE) {
			goto errout;
		}


		rqst->rq_xprt->xp_verf.oa_flavor = RPCSEC_GSS;
		rqst->rq_xprt->xp_verf.oa_base = gd->checksum.value;
		rqst->rq_xprt->xp_verf.oa_length = gd->checksum.length;
	}
	return (TRUE);
errout:
	gss_release_buffer(&min_stat, &gr->gr_token);
	return (FALSE);
}
","svcauth_gss_accept_sec_context(struct svc_req *rqst,
			       struct rpc_gss_init_res *gr)
{
	struct svc_rpc_gss_data	*gd;
	struct rpc_gss_cred	*gc;
	gss_buffer_desc		 recv_tok, seqbuf;
	gss_OID			 mech;
	OM_uint32		 maj_stat = 0, min_stat = 0, ret_flags, seq;

	log_debug(""in svcauth_gss_accept_context()"");

	gd = SVCAUTH_PRIVATE(rqst->rq_xprt->xp_auth);
	gc = (struct rpc_gss_cred *)rqst->rq_clntcred;
	memset(gr, 0, sizeof(*gr));

	/* Deserialize arguments. */
	memset(&recv_tok, 0, sizeof(recv_tok));

	if (!svc_getargs(rqst->rq_xprt, xdr_rpc_gss_init_args,
			 (caddr_t)&recv_tok))
		return (FALSE);

	gr->gr_major = gss_accept_sec_context(&gr->gr_minor,
					      &gd->ctx,
					      svcauth_gss_creds,
					      &recv_tok,
					      GSS_C_NO_CHANNEL_BINDINGS,
					      &gd->client_name,
					      &mech,
					      &gr->gr_token,
					      &ret_flags,
					      NULL,
					      NULL);

	svc_freeargs(rqst->rq_xprt, xdr_rpc_gss_init_args, (caddr_t)&recv_tok);

	log_status(""accept_sec_context"", gr->gr_major, gr->gr_minor);
	if (gr->gr_major != GSS_S_COMPLETE &&
	    gr->gr_major != GSS_S_CONTINUE_NEEDED) {
		badauth(gr->gr_major, gr->gr_minor, rqst->rq_xprt);
 		gd->ctx = GSS_C_NO_CONTEXT;
 		goto errout;
 	}
	gr->gr_ctx.value = ""xxxx"";
	gr->gr_ctx.length = 4;
 
 	/* gr->gr_win = 0x00000005; ANDROS: for debugging linux kernel version...  */
 	gr->gr_win = sizeof(gd->seqmask) * 8;

	/* Save client info. */
	gd->sec.mech = mech;
	gd->sec.qop = GSS_C_QOP_DEFAULT;
	gd->sec.svc = gc->gc_svc;
	gd->seq = gc->gc_seq;
	gd->win = gr->gr_win;

	if (gr->gr_major == GSS_S_COMPLETE) {
#ifdef SPKM
		/* spkm3: no src_name (anonymous) */
		if(!g_OID_equal(gss_mech_spkm3, mech)) {
#endif
		    maj_stat = gss_display_name(&min_stat, gd->client_name,
					    &gd->cname, &gd->sec.mech);
#ifdef SPKM
		}
#endif
		if (maj_stat != GSS_S_COMPLETE) {
			log_status(""display_name"", maj_stat, min_stat);
			goto errout;
		}
#ifdef DEBUG
#ifdef HAVE_HEIMDAL
		log_debug(""accepted context for %.*s with ""
			  ""<mech {}, qop %d, svc %d>"",
			  gd->cname.length, (char *)gd->cname.value,
			  gd->sec.qop, gd->sec.svc);
#else
		{
			gss_buffer_desc mechname;

			gss_oid_to_str(&min_stat, mech, &mechname);

			log_debug(""accepted context for %.*s with ""
				  ""<mech %.*s, qop %d, svc %d>"",
				  gd->cname.length, (char *)gd->cname.value,
				  mechname.length, (char *)mechname.value,
				  gd->sec.qop, gd->sec.svc);

			gss_release_buffer(&min_stat, &mechname);
		}
#endif
#endif /* DEBUG */
		seq = htonl(gr->gr_win);
		seqbuf.value = &seq;
		seqbuf.length = sizeof(seq);

		gss_release_buffer(&min_stat, &gd->checksum);
		maj_stat = gss_sign(&min_stat, gd->ctx, GSS_C_QOP_DEFAULT,
				    &seqbuf, &gd->checksum);

		if (maj_stat != GSS_S_COMPLETE) {
			goto errout;
		}


		rqst->rq_xprt->xp_verf.oa_flavor = RPCSEC_GSS;
		rqst->rq_xprt->xp_verf.oa_base = gd->checksum.value;
		rqst->rq_xprt->xp_verf.oa_length = gd->checksum.length;
	}
	return (TRUE);
errout:
	gss_release_buffer(&min_stat, &gr->gr_token);
	return (FALSE);
}
","The `svcauth_gss_accept_sec_context` function is responsible for accepting a security context in a GSSAPI (Generic Security Services Application Program Interface) environment during an RPC (Remote Procedure Call) request. It initializes necessary structures, deserializes the received token, and calls `gss_accept_sec_context` to process the token and establish a security context. If successful, it allocates memory for the context, saves client information, and logs the accepted context details. Additionally, it generates a checksum for message integrity and sets the verification information for the RPC transport. If any step fails, it cleans up and returns an error.","The provided code implements a function that manages the acceptance of a security context in a remote procedure call environment using a security protocol. It begins by initializing necessary data structures and deserializing an incoming token. The function then processes this token to establish a security context, handling both successful and error scenarios. If the context is successfully established, it allocates memory for the context, logs relevant client information, and generates a checksum for message integrity. The function concludes by updating the transport's verification information or performing cleanup in case of failure.","The vulnerability in the original code stemmed from copying potentially sensitive data from an uninitialized union context into a handle field sent to the client, which could lead to data leakage. Specifically, the code copied the context value directly, risking exposure of internal state information. The fix involved replacing this operation with a fixed string of ""xxxx"" for the handle field, ensuring that no sensitive data was transmitted. Additionally, the unused ""interposer"" field was removed from the union context structure to prevent any uninitialized data from being inadvertently included in future operations, enhancing overall security.","The vulnerability in the original code was due to the copying of potentially sensitive data from an uninitialized context into a field sent to the client, which could lead to unintended data exposure. This could allow an attacker to gain access to internal state information. The fix involved eliminating the copying of this data and instead using a fixed placeholder string, ensuring that no sensitive information was transmitted. Additionally, an unused field in the context structure was removed to prevent any uninitialized data from being included in future operations, thereby enhancing the security of the implementation.","The vulnerability was fixed by modifying the handling of the context in the `svcauth_gss_accept_sec_context` function. Instead of copying the potentially sensitive data from the union context into the `gr->gr_ctx.value`, a fixed string of ""xxxx"" was assigned to this field, ensuring that no internal state information was exposed to the client. Additionally, the unused ""interposer"" field was removed from the `gss_union_ctx_id_struct`, which helped prevent any part of the union context from remaining uninitialized, further mitigating the risk of data leakage in future operations.","The vulnerability was addressed by eliminating the copying of sensitive data from an uninitialized context into a field that was sent to the client, which could lead to data exposure. Instead, a fixed placeholder string was used to ensure that no internal information was transmitted. Additionally, an unused field in the context structure was removed to prevent any uninitialized data from being included in future operations. This combination of changes effectively mitigated the risk of data leakage and enhanced the overall security of the implementation.","4,4","5, 5","4,4","5,5"
56,56,180396,180396,,Local,Not required,Complete,CVE-2016-4913,https://www.cvedetails.com/cve/CVE-2016-4913/,CWE-200,Low,Complete,Complete,,2016-05-23,7.2,"The get_rock_ridge_filename function in fs/isofs/rock.c in the Linux kernel before 4.5.5 mishandles NM (aka alternate name) entries containing 0 characters, which allows local users to obtain sensitive information from kernel memory or possibly have unspecified other impact via a crafted isofs filesystem.",2018-10-31,+Info ,10,https://github.com/torvalds/linux/commit/99d825822eade8d827a1817357cbf3f889a552d6,99d825822eade8d827a1817357cbf3f889a552d6,"get_rock_ridge_filename(): handle malformed NM entries

Payloads of NM entries are not supposed to contain NUL.  When we run
into such, only the part prior to the first NUL goes into the
concatenation (i.e. the directory entry name being encoded by a bunch
of NM entries).  We do stop when the amount collected so far + the
claimed amount in the current NM entry exceed 254.  So far, so good,
but what we return as the total length is the sum of *claimed*
sizes, not the actual amount collected.  And that can grow pretty
large - not unlimited, since you'd need to put CE entries in
between to be able to get more than the maximum that could be
contained in one isofs directory entry / continuation chunk and
we are stop once we'd encountered 32 CEs, but you can get about 8Kb
easily.  And that's what will be passed to readdir callback as the
name length.  8Kb __copy_to_user() from a buffer allocated by
__get_free_page()

Cc: stable@vger.kernel.org # 0.98pl6+ (yes, really)
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",3,fs/isofs/rock.c,"{""sha"": ""98b3eb7d8eaf64d5eb006801aeb130ff8503f593"", ""filename"": ""fs/isofs/rock.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 3, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/99d825822eade8d827a1817357cbf3f889a552d6/fs/isofs/rock.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/99d825822eade8d827a1817357cbf3f889a552d6/fs/isofs/rock.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/isofs/rock.c?ref=99d825822eade8d827a1817357cbf3f889a552d6"", ""patch"": ""@@ -203,6 +203,8 @@ int get_rock_ridge_filename(struct iso_directory_record *de,\n \tint retnamlen = 0;\n \tint truncate = 0;\n \tint ret = 0;\n+\tchar *p;\n+\tint len;\n \n \tif (!ISOFS_SB(inode->i_sb)->s_rock)\n \t\treturn 0;\n@@ -267,12 +269,17 @@ int get_rock_ridge_filename(struct iso_directory_record *de,\n \t\t\t\t\trr->u.NM.flags);\n \t\t\t\tbreak;\n \t\t\t}\n-\t\t\tif ((strlen(retname) + rr->len - 5) >= 254) {\n+\t\t\tlen = rr->len - 5;\n+\t\t\tif (retnamlen + len >= 254) {\n \t\t\t\ttruncate = 1;\n \t\t\t\tbreak;\n \t\t\t}\n-\t\t\tstrncat(retname, rr->u.NM.name, rr->len - 5);\n-\t\t\tretnamlen += rr->len - 5;\n+\t\t\tp = memchr(rr->u.NM.name, '\\0', len);\n+\t\t\tif (unlikely(p))\n+\t\t\t\tlen = p - rr->u.NM.name;\n+\t\t\tmemcpy(retname + retnamlen, rr->u.NM.name, len);\n+\t\t\tretnamlen += len;\n+\t\t\tretname[retnamlen] = '\\0';\n \t\t\tbreak;\n \t\tcase SIG('R', 'E'):\n \t\t\tkfree(rs.buffer);""}","int get_rock_ridge_filename(struct iso_directory_record *de,
			    char *retname, struct inode *inode)
{
	struct rock_state rs;
	struct rock_ridge *rr;
	int sig;
 	int retnamlen = 0;
 	int truncate = 0;
 	int ret = 0;
	char *p;
	int len;
 
 	if (!ISOFS_SB(inode->i_sb)->s_rock)
 		return 0;
	*retname = 0;

	init_rock_state(&rs, inode);
	setup_rock_ridge(de, inode, &rs);
repeat:

	while (rs.len > 2) { /* There may be one byte for padding somewhere */
		rr = (struct rock_ridge *)rs.chr;
		/*
		 * Ignore rock ridge info if rr->len is out of range, but
		 * don't return -EIO because that would make the file
		 * invisible.
		 */
		if (rr->len < 3)
			goto out;	/* Something got screwed up here */
		sig = isonum_721(rs.chr);
		if (rock_check_overflow(&rs, sig))
			goto eio;
		rs.chr += rr->len;
		rs.len -= rr->len;
		/*
		 * As above, just ignore the rock ridge info if rr->len
		 * is bogus.
		 */
		if (rs.len < 0)
			goto out;	/* Something got screwed up here */

		switch (sig) {
		case SIG('R', 'R'):
			if ((rr->u.RR.flags[0] & RR_NM) == 0)
				goto out;
			break;
		case SIG('S', 'P'):
			if (check_sp(rr, inode))
				goto out;
			break;
		case SIG('C', 'E'):
			rs.cont_extent = isonum_733(rr->u.CE.extent);
			rs.cont_offset = isonum_733(rr->u.CE.offset);
			rs.cont_size = isonum_733(rr->u.CE.size);
			break;
		case SIG('N', 'M'):
			if (truncate)
				break;
			if (rr->len < 5)
				break;
			/*
			 * If the flags are 2 or 4, this indicates '.' or '..'.
			 * We don't want to do anything with this, because it
			 * screws up the code that calls us.  We don't really
			 * care anyways, since we can just use the non-RR
			 * name.
			 */
			if (rr->u.NM.flags & 6)
				break;

			if (rr->u.NM.flags & ~1) {
				printk(""Unsupported NM flag settings (%d)\n"",
 					rr->u.NM.flags);
 				break;
 			}
			len = rr->len - 5;
			if (retnamlen + len >= 254) {
 				truncate = 1;
 				break;
 			}
			p = memchr(rr->u.NM.name, '\0', len);
			if (unlikely(p))
				len = p - rr->u.NM.name;
			memcpy(retname + retnamlen, rr->u.NM.name, len);
			retnamlen += len;
			retname[retnamlen] = '\0';
 			break;
 		case SIG('R', 'E'):
 			kfree(rs.buffer);
			return -1;
		default:
			break;
		}
	}
	ret = rock_continue(&rs);
	if (ret == 0)
		goto repeat;
	if (ret == 1)
		return retnamlen; /* If 0, this file did not have a NM field */
out:
	kfree(rs.buffer);
	return ret;
eio:
	ret = -EIO;
	goto out;
}
","int get_rock_ridge_filename(struct iso_directory_record *de,
			    char *retname, struct inode *inode)
{
	struct rock_state rs;
	struct rock_ridge *rr;
	int sig;
 	int retnamlen = 0;
 	int truncate = 0;
 	int ret = 0;
 
 	if (!ISOFS_SB(inode->i_sb)->s_rock)
 		return 0;
	*retname = 0;

	init_rock_state(&rs, inode);
	setup_rock_ridge(de, inode, &rs);
repeat:

	while (rs.len > 2) { /* There may be one byte for padding somewhere */
		rr = (struct rock_ridge *)rs.chr;
		/*
		 * Ignore rock ridge info if rr->len is out of range, but
		 * don't return -EIO because that would make the file
		 * invisible.
		 */
		if (rr->len < 3)
			goto out;	/* Something got screwed up here */
		sig = isonum_721(rs.chr);
		if (rock_check_overflow(&rs, sig))
			goto eio;
		rs.chr += rr->len;
		rs.len -= rr->len;
		/*
		 * As above, just ignore the rock ridge info if rr->len
		 * is bogus.
		 */
		if (rs.len < 0)
			goto out;	/* Something got screwed up here */

		switch (sig) {
		case SIG('R', 'R'):
			if ((rr->u.RR.flags[0] & RR_NM) == 0)
				goto out;
			break;
		case SIG('S', 'P'):
			if (check_sp(rr, inode))
				goto out;
			break;
		case SIG('C', 'E'):
			rs.cont_extent = isonum_733(rr->u.CE.extent);
			rs.cont_offset = isonum_733(rr->u.CE.offset);
			rs.cont_size = isonum_733(rr->u.CE.size);
			break;
		case SIG('N', 'M'):
			if (truncate)
				break;
			if (rr->len < 5)
				break;
			/*
			 * If the flags are 2 or 4, this indicates '.' or '..'.
			 * We don't want to do anything with this, because it
			 * screws up the code that calls us.  We don't really
			 * care anyways, since we can just use the non-RR
			 * name.
			 */
			if (rr->u.NM.flags & 6)
				break;

			if (rr->u.NM.flags & ~1) {
				printk(""Unsupported NM flag settings (%d)\n"",
 					rr->u.NM.flags);
 				break;
 			}
			if ((strlen(retname) + rr->len - 5) >= 254) {
 				truncate = 1;
 				break;
 			}
			strncat(retname, rr->u.NM.name, rr->len - 5);
			retnamlen += rr->len - 5;
 			break;
 		case SIG('R', 'E'):
 			kfree(rs.buffer);
			return -1;
		default:
			break;
		}
	}
	ret = rock_continue(&rs);
	if (ret == 0)
		goto repeat;
	if (ret == 1)
		return retnamlen; /* If 0, this file did not have a NM field */
out:
	kfree(rs.buffer);
	return ret;
eio:
	ret = -EIO;
	goto out;
}
",C,"	char *p;
	int len;
			len = rr->len - 5;
			if (retnamlen + len >= 254) {
			p = memchr(rr->u.NM.name, '\0', len);
			if (unlikely(p))
				len = p - rr->u.NM.name;
			memcpy(retname + retnamlen, rr->u.NM.name, len);
			retnamlen += len;
			retname[retnamlen] = '\0';
","			if ((strlen(retname) + rr->len - 5) >= 254) {
			strncat(retname, rr->u.NM.name, rr->len - 5);
			retnamlen += rr->len - 5;
",,"@@ -203,6 +203,8 @@ int get_rock_ridge_filename(struct iso_directory_record *de,
 	int retnamlen = 0;
 	int truncate = 0;
 	int ret = 0;
+	char *p;
+	int len;
 
 	if (!ISOFS_SB(inode->i_sb)->s_rock)
 		return 0;
@@ -267,12 +269,17 @@ int get_rock_ridge_filename(struct iso_directory_record *de,
 					rr->u.NM.flags);
 				break;
 			}
-			if ((strlen(retname) + rr->len - 5) >= 254) {
+			len = rr->len - 5;
+			if (retnamlen + len >= 254) {
 				truncate = 1;
 				break;
 			}
-			strncat(retname, rr->u.NM.name, rr->len - 5);
-			retnamlen += rr->len - 5;
+			p = memchr(rr->u.NM.name, '\0', len);
+			if (unlikely(p))
+				len = p - rr->u.NM.name;
+			memcpy(retname + retnamlen, rr->u.NM.name, len);
+			retnamlen += len;
+			retname[retnamlen] = '\0';
 			break;
 		case SIG('R', 'E'):
 			kfree(rs.buffer);",linux,99d825822eade8d827a1817357cbf3f889a552d6,6a480a7842545ec520a91730209ec0bae41694c1,1,"int get_rock_ridge_filename(struct iso_directory_record *de,
			    char *retname, struct inode *inode)
{
	struct rock_state rs;
	struct rock_ridge *rr;
	int sig;
 	int retnamlen = 0;
 	int truncate = 0;
 	int ret = 0;
//fix_flaw_line_below:
//	char *p;
//fix_flaw_line_below:
//	int len;
 
 	if (!ISOFS_SB(inode->i_sb)->s_rock)
 		return 0;
	*retname = 0;

	init_rock_state(&rs, inode);
	setup_rock_ridge(de, inode, &rs);
repeat:

	while (rs.len > 2) { /* There may be one byte for padding somewhere */
		rr = (struct rock_ridge *)rs.chr;
		/*
		 * Ignore rock ridge info if rr->len is out of range, but
		 * don't return -EIO because that would make the file
		 * invisible.
		 */
		if (rr->len < 3)
			goto out;	/* Something got screwed up here */
		sig = isonum_721(rs.chr);
		if (rock_check_overflow(&rs, sig))
			goto eio;
		rs.chr += rr->len;
		rs.len -= rr->len;
		/*
		 * As above, just ignore the rock ridge info if rr->len
		 * is bogus.
		 */
		if (rs.len < 0)
			goto out;	/* Something got screwed up here */

		switch (sig) {
		case SIG('R', 'R'):
			if ((rr->u.RR.flags[0] & RR_NM) == 0)
				goto out;
			break;
		case SIG('S', 'P'):
			if (check_sp(rr, inode))
				goto out;
			break;
		case SIG('C', 'E'):
			rs.cont_extent = isonum_733(rr->u.CE.extent);
			rs.cont_offset = isonum_733(rr->u.CE.offset);
			rs.cont_size = isonum_733(rr->u.CE.size);
			break;
		case SIG('N', 'M'):
			if (truncate)
				break;
			if (rr->len < 5)
				break;
			/*
			 * If the flags are 2 or 4, this indicates '.' or '..'.
			 * We don't want to do anything with this, because it
			 * screws up the code that calls us.  We don't really
			 * care anyways, since we can just use the non-RR
			 * name.
			 */
			if (rr->u.NM.flags & 6)
				break;

			if (rr->u.NM.flags & ~1) {
				printk(""Unsupported NM flag settings (%d)\n"",
 					rr->u.NM.flags);
 				break;
 			}
//flaw_line_below:
			if ((strlen(retname) + rr->len - 5) >= 254) {
//fix_flaw_line_below:
//			len = rr->len - 5;
//fix_flaw_line_below:
//			if (retnamlen + len >= 254) {
 				truncate = 1;
 				break;
 			}
//flaw_line_below:
			strncat(retname, rr->u.NM.name, rr->len - 5);
//flaw_line_below:
			retnamlen += rr->len - 5;
//fix_flaw_line_below:
//			p = memchr(rr->u.NM.name, '\0', len);
//fix_flaw_line_below:
//			if (unlikely(p))
//fix_flaw_line_below:
//				len = p - rr->u.NM.name;
//fix_flaw_line_below:
//			memcpy(retname + retnamlen, rr->u.NM.name, len);
//fix_flaw_line_below:
//			retnamlen += len;
//fix_flaw_line_below:
//			retname[retnamlen] = '\0';
 			break;
 		case SIG('R', 'E'):
 			kfree(rs.buffer);
			return -1;
		default:
			break;
		}
	}
	ret = rock_continue(&rs);
	if (ret == 0)
		goto repeat;
	if (ret == 1)
		return retnamlen; /* If 0, this file did not have a NM field */
out:
	kfree(rs.buffer);
	return ret;
eio:
	ret = -EIO;
	goto out;
}
",180396,"int get_rock_ridge_filename(struct iso_directory_record *de,
			    char *retname, struct inode *inode)
{
	struct rock_state rs;
	struct rock_ridge *rr;
	int sig;
 	int retnamlen = 0;
 	int truncate = 0;
 	int ret = 0;
 
 	if (!ISOFS_SB(inode->i_sb)->s_rock)
 		return 0;
	*retname = 0;

	init_rock_state(&rs, inode);
	setup_rock_ridge(de, inode, &rs);
repeat:

	while (rs.len > 2) { /* There may be one byte for padding somewhere */
		rr = (struct rock_ridge *)rs.chr;
		/*
		 * Ignore rock ridge info if rr->len is out of range, but
		 * don't return -EIO because that would make the file
		 * invisible.
		 */
		if (rr->len < 3)
			goto out;	/* Something got screwed up here */
		sig = isonum_721(rs.chr);
		if (rock_check_overflow(&rs, sig))
			goto eio;
		rs.chr += rr->len;
		rs.len -= rr->len;
		/*
		 * As above, just ignore the rock ridge info if rr->len
		 * is bogus.
		 */
		if (rs.len < 0)
			goto out;	/* Something got screwed up here */

		switch (sig) {
		case SIG('R', 'R'):
			if ((rr->u.RR.flags[0] & RR_NM) == 0)
				goto out;
			break;
		case SIG('S', 'P'):
			if (check_sp(rr, inode))
				goto out;
			break;
		case SIG('C', 'E'):
			rs.cont_extent = isonum_733(rr->u.CE.extent);
			rs.cont_offset = isonum_733(rr->u.CE.offset);
			rs.cont_size = isonum_733(rr->u.CE.size);
			break;
		case SIG('N', 'M'):
			if (truncate)
				break;
			if (rr->len < 5)
				break;
			/*
			 * If the flags are 2 or 4, this indicates '.' or '..'.
			 * We don't want to do anything with this, because it
			 * screws up the code that calls us.  We don't really
			 * care anyways, since we can just use the non-RR
			 * name.
			 */
			if (rr->u.NM.flags & 6)
				break;

			if (rr->u.NM.flags & ~1) {
				printk(""Unsupported NM flag settings (%d)\n"",
 					rr->u.NM.flags);
 				break;
 			}
			if ((strlen(retname) + rr->len - 5) >= 254) {
 				truncate = 1;
 				break;
 			}
			strncat(retname, rr->u.NM.name, rr->len - 5);
			retnamlen += rr->len - 5;
 			break;
 		case SIG('R', 'E'):
 			kfree(rs.buffer);
			return -1;
		default:
			break;
		}
	}
	ret = rock_continue(&rs);
	if (ret == 0)
		goto repeat;
	if (ret == 1)
		return retnamlen; /* If 0, this file did not have a NM field */
out:
	kfree(rs.buffer);
	return ret;
eio:
	ret = -EIO;
	goto out;
}
","int get_rock_ridge_filename(struct iso_directory_record *de,
			    char *retname, struct inode *inode)
{
	struct rock_state rs;
	struct rock_ridge *rr;
	int sig;
 	int retnamlen = 0;
 	int truncate = 0;
 	int ret = 0;
	char *p;
	int len;
 
 	if (!ISOFS_SB(inode->i_sb)->s_rock)
 		return 0;
	*retname = 0;

	init_rock_state(&rs, inode);
	setup_rock_ridge(de, inode, &rs);
repeat:

	while (rs.len > 2) { /* There may be one byte for padding somewhere */
		rr = (struct rock_ridge *)rs.chr;
		/*
		 * Ignore rock ridge info if rr->len is out of range, but
		 * don't return -EIO because that would make the file
		 * invisible.
		 */
		if (rr->len < 3)
			goto out;	/* Something got screwed up here */
		sig = isonum_721(rs.chr);
		if (rock_check_overflow(&rs, sig))
			goto eio;
		rs.chr += rr->len;
		rs.len -= rr->len;
		/*
		 * As above, just ignore the rock ridge info if rr->len
		 * is bogus.
		 */
		if (rs.len < 0)
			goto out;	/* Something got screwed up here */

		switch (sig) {
		case SIG('R', 'R'):
			if ((rr->u.RR.flags[0] & RR_NM) == 0)
				goto out;
			break;
		case SIG('S', 'P'):
			if (check_sp(rr, inode))
				goto out;
			break;
		case SIG('C', 'E'):
			rs.cont_extent = isonum_733(rr->u.CE.extent);
			rs.cont_offset = isonum_733(rr->u.CE.offset);
			rs.cont_size = isonum_733(rr->u.CE.size);
			break;
		case SIG('N', 'M'):
			if (truncate)
				break;
			if (rr->len < 5)
				break;
			/*
			 * If the flags are 2 or 4, this indicates '.' or '..'.
			 * We don't want to do anything with this, because it
			 * screws up the code that calls us.  We don't really
			 * care anyways, since we can just use the non-RR
			 * name.
			 */
			if (rr->u.NM.flags & 6)
				break;

			if (rr->u.NM.flags & ~1) {
				printk(""Unsupported NM flag settings (%d)\n"",
 					rr->u.NM.flags);
 				break;
 			}
			len = rr->len - 5;
			if (retnamlen + len >= 254) {
 				truncate = 1;
 				break;
 			}
			p = memchr(rr->u.NM.name, '\0', len);
			if (unlikely(p))
				len = p - rr->u.NM.name;
			memcpy(retname + retnamlen, rr->u.NM.name, len);
			retnamlen += len;
			retname[retnamlen] = '\0';
 			break;
 		case SIG('R', 'E'):
 			kfree(rs.buffer);
			return -1;
		default:
			break;
		}
	}
	ret = rock_continue(&rs);
	if (ret == 0)
		goto repeat;
	if (ret == 1)
		return retnamlen; /* If 0, this file did not have a NM field */
out:
	kfree(rs.buffer);
	return ret;
eio:
	ret = -EIO;
	goto out;
}
","The `get_rock_ridge_filename` function processes Rock Ridge extensions in an ISO filesystem to extract a file's name from its directory record. It initializes a state structure, checks for the presence of Rock Ridge support, and iterates through the Rock Ridge entries, handling various signatures such as 'RR', 'SP', 'CE', and 'NM'. The function concatenates valid name segments into a return buffer while managing potential overflow and truncation. If any errors occur during processing, it ensures proper cleanup and returns appropriate error codes, ultimately returning the length of the constructed filename or an error indicator.","The code processes directory entries in an ISO filesystem to extract and construct a file name using Rock Ridge extensions. It initializes a state structure to manage the extraction process and checks for the presence of necessary support. The code iterates through various extension entries, handling specific types of information while ensuring that the constructed name does not exceed a predefined length. It manages potential errors and memory cleanup throughout the process. Ultimately, the function returns the length of the constructed name or an error code if issues arise during extraction.","The vulnerability in the original code arises from the handling of malformed NM entries, specifically when these entries contain NUL characters. The code incorrectly calculates the total length of the concatenated name based on claimed sizes rather than the actual length of the collected name, potentially allowing an attacker to exploit this by crafting entries that lead to excessive memory being accessed during a readdir callback. The fix addresses this by using `memchr` to find the first NUL character in the name, ensuring that only the valid portion is copied into the return buffer, thus preventing excessive memory access and potential buffer overflow vulnerabilities.","The vulnerability in the original code stems from the improper handling of malformed entries that contain NUL characters, which are not expected in the payloads. This oversight allows the total length of the concatenated name to be calculated based on claimed sizes rather than the actual length of the valid data collected. Consequently, this could lead to excessive memory access during operations, potentially allowing an attacker to exploit the system by passing an inflated length to a callback function. The fix ensures that only the valid portion of the name is considered, preventing excessive memory access and mitigating the risk of buffer overflow.","The vulnerability was fixed by introducing a check for NUL characters within the name payloads of NM entries. The code now uses `memchr` to locate the first NUL character, ensuring that only the portion of the name prior to this character is copied into the return buffer. This adjustment prevents the accumulation of claimed sizes that could exceed the actual length of the collected name. Additionally, the total length returned is now based on the actual data copied rather than the claimed sizes, effectively mitigating the risk of excessive memory access and potential buffer overflow during the readdir callback.","The vulnerability was addressed by implementing a check for unexpected NUL characters in the name payloads of directory entries. The updated code ensures that only the valid portion of the name, up to the first NUL character, is included in the concatenation process. This change prevents the accumulation of claimed sizes that could exceed the actual length of the collected name, thereby eliminating the risk of excessive memory access. As a result, the total length returned is now based on the actual data collected, significantly reducing the potential for buffer overflow and enhancing overall system security.","5, 4","5,5","4,4","4,4"
57,57,180407,180407,,Remote,Not required,,CVE-2016-4580,https://www.cvedetails.com/cve/CVE-2016-4580/,CWE-200,Low,Partial,,,2016-05-23,5.0,"The x25_negotiate_facilities function in net/x25/x25_facilities.c in the Linux kernel before 4.5.5 does not properly initialize a certain data structure, which allows attackers to obtain sensitive information from kernel stack memory via an X.25 Call Request.",2016-11-28,+Info ,1,https://github.com/torvalds/linux/commit/79e48650320e6fba48369fccf13fd045315b19b8,79e48650320e6fba48369fccf13fd045315b19b8,"net: fix a kernel infoleak in x25 module

Stack object ""dte_facilities"" is allocated in x25_rx_call_request(),
which is supposed to be initialized in x25_negotiate_facilities.
However, 5 fields (8 bytes in total) are not initialized. This
object is then copied to userland via copy_to_user, thus infoleak
occurs.

Signed-off-by: Kangjie Lu <kjlu@gatech.edu>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/x25/x25_facilities.c,"{""sha"": ""997ff7b2509b49a3da6d3183fe65512f8f4caa38"", ""filename"": ""net/x25/x25_facilities.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/79e48650320e6fba48369fccf13fd045315b19b8/net/x25/x25_facilities.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/79e48650320e6fba48369fccf13fd045315b19b8/net/x25/x25_facilities.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/x25/x25_facilities.c?ref=79e48650320e6fba48369fccf13fd045315b19b8"", ""patch"": ""@@ -277,6 +277,7 @@ int x25_negotiate_facilities(struct sk_buff *skb, struct sock *sk,\n \n \tmemset(&theirs, 0, sizeof(theirs));\n \tmemcpy(new, ours, sizeof(*new));\n+\tmemset(dte, 0, sizeof(*dte));\n \n \tlen = x25_parse_facilities(skb, &theirs, dte, &x25->vc_facil_mask);\n \tif (len < 0)""}","int x25_negotiate_facilities(struct sk_buff *skb, struct sock *sk,
		struct x25_facilities *new, struct x25_dte_facilities *dte)
{
	struct x25_sock *x25 = x25_sk(sk);
	struct x25_facilities *ours = &x25->facilities;
	struct x25_facilities theirs;
	int len;
 
 	memset(&theirs, 0, sizeof(theirs));
 	memcpy(new, ours, sizeof(*new));
	memset(dte, 0, sizeof(*dte));
 
 	len = x25_parse_facilities(skb, &theirs, dte, &x25->vc_facil_mask);
 	if (len < 0)
		return len;

	/*
	 *	They want reverse charging, we won't accept it.
	 */
	if ((theirs.reverse & 0x01 ) && (ours->reverse & 0x01)) {
		SOCK_DEBUG(sk, ""X.25: rejecting reverse charging request\n"");
		return -1;
	}

	new->reverse = theirs.reverse;

	if (theirs.throughput) {
		int theirs_in =  theirs.throughput & 0x0f;
		int theirs_out = theirs.throughput & 0xf0;
		int ours_in  = ours->throughput & 0x0f;
		int ours_out = ours->throughput & 0xf0;
		if (!ours_in || theirs_in < ours_in) {
			SOCK_DEBUG(sk, ""X.25: inbound throughput negotiated\n"");
			new->throughput = (new->throughput & 0xf0) | theirs_in;
		}
		if (!ours_out || theirs_out < ours_out) {
			SOCK_DEBUG(sk,
				""X.25: outbound throughput negotiated\n"");
			new->throughput = (new->throughput & 0x0f) | theirs_out;
		}
	}

	if (theirs.pacsize_in && theirs.pacsize_out) {
		if (theirs.pacsize_in < ours->pacsize_in) {
			SOCK_DEBUG(sk, ""X.25: packet size inwards negotiated down\n"");
			new->pacsize_in = theirs.pacsize_in;
		}
		if (theirs.pacsize_out < ours->pacsize_out) {
			SOCK_DEBUG(sk, ""X.25: packet size outwards negotiated down\n"");
			new->pacsize_out = theirs.pacsize_out;
		}
	}

	if (theirs.winsize_in && theirs.winsize_out) {
		if (theirs.winsize_in < ours->winsize_in) {
			SOCK_DEBUG(sk, ""X.25: window size inwards negotiated down\n"");
			new->winsize_in = theirs.winsize_in;
		}
		if (theirs.winsize_out < ours->winsize_out) {
			SOCK_DEBUG(sk, ""X.25: window size outwards negotiated down\n"");
			new->winsize_out = theirs.winsize_out;
		}
	}

	return len;
}
","int x25_negotiate_facilities(struct sk_buff *skb, struct sock *sk,
		struct x25_facilities *new, struct x25_dte_facilities *dte)
{
	struct x25_sock *x25 = x25_sk(sk);
	struct x25_facilities *ours = &x25->facilities;
	struct x25_facilities theirs;
	int len;
 
 	memset(&theirs, 0, sizeof(theirs));
 	memcpy(new, ours, sizeof(*new));
 
 	len = x25_parse_facilities(skb, &theirs, dte, &x25->vc_facil_mask);
 	if (len < 0)
		return len;

	/*
	 *	They want reverse charging, we won't accept it.
	 */
	if ((theirs.reverse & 0x01 ) && (ours->reverse & 0x01)) {
		SOCK_DEBUG(sk, ""X.25: rejecting reverse charging request\n"");
		return -1;
	}

	new->reverse = theirs.reverse;

	if (theirs.throughput) {
		int theirs_in =  theirs.throughput & 0x0f;
		int theirs_out = theirs.throughput & 0xf0;
		int ours_in  = ours->throughput & 0x0f;
		int ours_out = ours->throughput & 0xf0;
		if (!ours_in || theirs_in < ours_in) {
			SOCK_DEBUG(sk, ""X.25: inbound throughput negotiated\n"");
			new->throughput = (new->throughput & 0xf0) | theirs_in;
		}
		if (!ours_out || theirs_out < ours_out) {
			SOCK_DEBUG(sk,
				""X.25: outbound throughput negotiated\n"");
			new->throughput = (new->throughput & 0x0f) | theirs_out;
		}
	}

	if (theirs.pacsize_in && theirs.pacsize_out) {
		if (theirs.pacsize_in < ours->pacsize_in) {
			SOCK_DEBUG(sk, ""X.25: packet size inwards negotiated down\n"");
			new->pacsize_in = theirs.pacsize_in;
		}
		if (theirs.pacsize_out < ours->pacsize_out) {
			SOCK_DEBUG(sk, ""X.25: packet size outwards negotiated down\n"");
			new->pacsize_out = theirs.pacsize_out;
		}
	}

	if (theirs.winsize_in && theirs.winsize_out) {
		if (theirs.winsize_in < ours->winsize_in) {
			SOCK_DEBUG(sk, ""X.25: window size inwards negotiated down\n"");
			new->winsize_in = theirs.winsize_in;
		}
		if (theirs.winsize_out < ours->winsize_out) {
			SOCK_DEBUG(sk, ""X.25: window size outwards negotiated down\n"");
			new->winsize_out = theirs.winsize_out;
		}
	}

	return len;
}
",C,"	memset(dte, 0, sizeof(*dte));
",,,"@@ -277,6 +277,7 @@ int x25_negotiate_facilities(struct sk_buff *skb, struct sock *sk,
 
 	memset(&theirs, 0, sizeof(theirs));
 	memcpy(new, ours, sizeof(*new));
+	memset(dte, 0, sizeof(*dte));
 
 	len = x25_parse_facilities(skb, &theirs, dte, &x25->vc_facil_mask);
 	if (len < 0)",linux,79e48650320e6fba48369fccf13fd045315b19b8,7fa816b92c52e2c304f2ff6401e0d51e1d229ca5,1,"int x25_negotiate_facilities(struct sk_buff *skb, struct sock *sk,
		struct x25_facilities *new, struct x25_dte_facilities *dte)
{
	struct x25_sock *x25 = x25_sk(sk);
	struct x25_facilities *ours = &x25->facilities;
	struct x25_facilities theirs;
	int len;
 
 	memset(&theirs, 0, sizeof(theirs));
 	memcpy(new, ours, sizeof(*new));
//fix_flaw_line_below:
//	memset(dte, 0, sizeof(*dte));
 
 	len = x25_parse_facilities(skb, &theirs, dte, &x25->vc_facil_mask);
 	if (len < 0)
		return len;

	/*
	 *	They want reverse charging, we won't accept it.
	 */
	if ((theirs.reverse & 0x01 ) && (ours->reverse & 0x01)) {
		SOCK_DEBUG(sk, ""X.25: rejecting reverse charging request\n"");
		return -1;
	}

	new->reverse = theirs.reverse;

	if (theirs.throughput) {
		int theirs_in =  theirs.throughput & 0x0f;
		int theirs_out = theirs.throughput & 0xf0;
		int ours_in  = ours->throughput & 0x0f;
		int ours_out = ours->throughput & 0xf0;
		if (!ours_in || theirs_in < ours_in) {
			SOCK_DEBUG(sk, ""X.25: inbound throughput negotiated\n"");
			new->throughput = (new->throughput & 0xf0) | theirs_in;
		}
		if (!ours_out || theirs_out < ours_out) {
			SOCK_DEBUG(sk,
				""X.25: outbound throughput negotiated\n"");
			new->throughput = (new->throughput & 0x0f) | theirs_out;
		}
	}

	if (theirs.pacsize_in && theirs.pacsize_out) {
		if (theirs.pacsize_in < ours->pacsize_in) {
			SOCK_DEBUG(sk, ""X.25: packet size inwards negotiated down\n"");
			new->pacsize_in = theirs.pacsize_in;
		}
		if (theirs.pacsize_out < ours->pacsize_out) {
			SOCK_DEBUG(sk, ""X.25: packet size outwards negotiated down\n"");
			new->pacsize_out = theirs.pacsize_out;
		}
	}

	if (theirs.winsize_in && theirs.winsize_out) {
		if (theirs.winsize_in < ours->winsize_in) {
			SOCK_DEBUG(sk, ""X.25: window size inwards negotiated down\n"");
			new->winsize_in = theirs.winsize_in;
		}
		if (theirs.winsize_out < ours->winsize_out) {
			SOCK_DEBUG(sk, ""X.25: window size outwards negotiated down\n"");
			new->winsize_out = theirs.winsize_out;
		}
	}

	return len;
}
",180407,"int x25_negotiate_facilities(struct sk_buff *skb, struct sock *sk,
		struct x25_facilities *new, struct x25_dte_facilities *dte)
{
	struct x25_sock *x25 = x25_sk(sk);
	struct x25_facilities *ours = &x25->facilities;
	struct x25_facilities theirs;
	int len;
 
 	memset(&theirs, 0, sizeof(theirs));
 	memcpy(new, ours, sizeof(*new));
 
 	len = x25_parse_facilities(skb, &theirs, dte, &x25->vc_facil_mask);
 	if (len < 0)
		return len;

	/*
	 *	They want reverse charging, we won't accept it.
	 */
	if ((theirs.reverse & 0x01 ) && (ours->reverse & 0x01)) {
		SOCK_DEBUG(sk, ""X.25: rejecting reverse charging request\n"");
		return -1;
	}

	new->reverse = theirs.reverse;

	if (theirs.throughput) {
		int theirs_in =  theirs.throughput & 0x0f;
		int theirs_out = theirs.throughput & 0xf0;
		int ours_in  = ours->throughput & 0x0f;
		int ours_out = ours->throughput & 0xf0;
		if (!ours_in || theirs_in < ours_in) {
			SOCK_DEBUG(sk, ""X.25: inbound throughput negotiated\n"");
			new->throughput = (new->throughput & 0xf0) | theirs_in;
		}
		if (!ours_out || theirs_out < ours_out) {
			SOCK_DEBUG(sk,
				""X.25: outbound throughput negotiated\n"");
			new->throughput = (new->throughput & 0x0f) | theirs_out;
		}
	}

	if (theirs.pacsize_in && theirs.pacsize_out) {
		if (theirs.pacsize_in < ours->pacsize_in) {
			SOCK_DEBUG(sk, ""X.25: packet size inwards negotiated down\n"");
			new->pacsize_in = theirs.pacsize_in;
		}
		if (theirs.pacsize_out < ours->pacsize_out) {
			SOCK_DEBUG(sk, ""X.25: packet size outwards negotiated down\n"");
			new->pacsize_out = theirs.pacsize_out;
		}
	}

	if (theirs.winsize_in && theirs.winsize_out) {
		if (theirs.winsize_in < ours->winsize_in) {
			SOCK_DEBUG(sk, ""X.25: window size inwards negotiated down\n"");
			new->winsize_in = theirs.winsize_in;
		}
		if (theirs.winsize_out < ours->winsize_out) {
			SOCK_DEBUG(sk, ""X.25: window size outwards negotiated down\n"");
			new->winsize_out = theirs.winsize_out;
		}
	}

	return len;
}
","int x25_negotiate_facilities(struct sk_buff *skb, struct sock *sk,
		struct x25_facilities *new, struct x25_dte_facilities *dte)
{
	struct x25_sock *x25 = x25_sk(sk);
	struct x25_facilities *ours = &x25->facilities;
	struct x25_facilities theirs;
	int len;
 
 	memset(&theirs, 0, sizeof(theirs));
 	memcpy(new, ours, sizeof(*new));
	memset(dte, 0, sizeof(*dte));
 
 	len = x25_parse_facilities(skb, &theirs, dte, &x25->vc_facil_mask);
 	if (len < 0)
		return len;

	/*
	 *	They want reverse charging, we won't accept it.
	 */
	if ((theirs.reverse & 0x01 ) && (ours->reverse & 0x01)) {
		SOCK_DEBUG(sk, ""X.25: rejecting reverse charging request\n"");
		return -1;
	}

	new->reverse = theirs.reverse;

	if (theirs.throughput) {
		int theirs_in =  theirs.throughput & 0x0f;
		int theirs_out = theirs.throughput & 0xf0;
		int ours_in  = ours->throughput & 0x0f;
		int ours_out = ours->throughput & 0xf0;
		if (!ours_in || theirs_in < ours_in) {
			SOCK_DEBUG(sk, ""X.25: inbound throughput negotiated\n"");
			new->throughput = (new->throughput & 0xf0) | theirs_in;
		}
		if (!ours_out || theirs_out < ours_out) {
			SOCK_DEBUG(sk,
				""X.25: outbound throughput negotiated\n"");
			new->throughput = (new->throughput & 0x0f) | theirs_out;
		}
	}

	if (theirs.pacsize_in && theirs.pacsize_out) {
		if (theirs.pacsize_in < ours->pacsize_in) {
			SOCK_DEBUG(sk, ""X.25: packet size inwards negotiated down\n"");
			new->pacsize_in = theirs.pacsize_in;
		}
		if (theirs.pacsize_out < ours->pacsize_out) {
			SOCK_DEBUG(sk, ""X.25: packet size outwards negotiated down\n"");
			new->pacsize_out = theirs.pacsize_out;
		}
	}

	if (theirs.winsize_in && theirs.winsize_out) {
		if (theirs.winsize_in < ours->winsize_in) {
			SOCK_DEBUG(sk, ""X.25: window size inwards negotiated down\n"");
			new->winsize_in = theirs.winsize_in;
		}
		if (theirs.winsize_out < ours->winsize_out) {
			SOCK_DEBUG(sk, ""X.25: window size outwards negotiated down\n"");
			new->winsize_out = theirs.winsize_out;
		}
	}

	return len;
}
","The function `x25_negotiate_facilities` is responsible for negotiating communication facilities between two X.25 network endpoints. It begins by initializing and copying the local facilities into a new structure, then parses incoming facilities from a socket buffer. The function checks for reverse charging requests, rejecting them if both parties agree. It negotiates inbound and outbound throughput, packet sizes, and window sizes based on the received facilities, updating the new facilities accordingly. Debugging messages are logged throughout the process to provide insights into the negotiation decisions made, and it returns the length of the parsed facilities or an error code.","The code implements a negotiation process for communication facilities between two network endpoints using a specific protocol. It initializes local facility settings and parses incoming facility requests from a data buffer. The function checks for and rejects any requests for reverse charging if both parties agree to it. It then negotiates various parameters, including throughput, packet sizes, and window sizes, adjusting them based on the received values while ensuring they do not exceed local capabilities. Throughout the process, debugging information is logged to track the negotiation decisions, and the function returns the result of the parsing operation.","The vulnerability in the original code arises from the lack of initialization for certain fields in the `dte_facilities` structure, which could lead to an information leak when this uninitialized data is copied to userland. Specifically, the fields were not set to zero, allowing potentially sensitive data to be exposed. The fix involved adding a line to explicitly initialize the `dte` structure with zeros using `memset(dte, 0, sizeof(*dte));`. This ensures that all fields in the `dte_facilities` structure are properly initialized before being used, thereby preventing any unintended data leakage to userland.","The vulnerability in the original code stems from the failure to initialize certain fields in a stack-allocated structure, which could lead to an information leak when this uninitialized data is subsequently copied to userland. This oversight allows potentially sensitive or unintended data to be exposed, compromising security. The fix involved explicitly initializing the structure to zero before it is used, ensuring that all fields are set to a known state. This change effectively prevents any leakage of uninitialized data, thereby enhancing the security of the code by safeguarding against the exposure of sensitive information.","The vulnerability was fixed by adding a line of code that initializes the `dte` structure to zero using `memset(dte, 0, sizeof(*dte));`. This ensures that all fields within the `dte_facilities` structure are properly set before being utilized in the negotiation process. By doing this, the code prevents any uninitialized fields from being copied to userland via the `copy_to_user` function, thereby eliminating the risk of leaking sensitive or unintended data. This change enhances the overall security of the module by ensuring that only initialized and safe data is exposed.","The vulnerability was fixed by implementing an explicit initialization of a critical structure to ensure that all its fields are set to a known state before use. This initialization process prevents any uninitialized data from being inadvertently exposed when the structure is copied to userland. By ensuring that all fields are zeroed out, the fix effectively eliminates the risk of leaking sensitive or unintended information, thereby enhancing the security of the code. This change ensures that only safe and properly initialized data is made available, addressing the potential information leak issue.","5, 5","5,5","4,4","5,5"
58,58,180431,180431,,Local,Not required,,CVE-2016-4482,https://www.cvedetails.com/cve/CVE-2016-4482/,CWE-200,Low,Partial,,,2016-05-23,2.1,"The proc_connectinfo function in drivers/usb/core/devio.c in the Linux kernel through 4.6 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel stack memory via a crafted USBDEVFS_CONNECTINFO ioctl call.",2016-11-28,+Info ,5,https://github.com/torvalds/linux/commit/681fef8380eb818c0b845fca5d2ab1dcbab114ee,681fef8380eb818c0b845fca5d2ab1dcbab114ee,"USB: usbfs: fix potential infoleak in devio

The stack object “ci” has a total size of 8 bytes. Its last 3 bytes
are padding bytes which are not initialized and leaked to userland
via “copy_to_user”.

Signed-off-by: Kangjie Lu <kjlu@gatech.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",4,drivers/usb/core/devio.c,"{""sha"": ""e9f5043a2167c2be13fb3cd5b5aab93efa7d9c23"", ""filename"": ""drivers/usb/core/devio.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/681fef8380eb818c0b845fca5d2ab1dcbab114ee/drivers/usb/core/devio.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/681fef8380eb818c0b845fca5d2ab1dcbab114ee/drivers/usb/core/devio.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/core/devio.c?ref=681fef8380eb818c0b845fca5d2ab1dcbab114ee"", ""patch"": ""@@ -1316,10 +1316,11 @@ static int proc_getdriver(struct usb_dev_state *ps, void __user *arg)\n \n static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)\n {\n-\tstruct usbdevfs_connectinfo ci = {\n-\t\t.devnum = ps->dev->devnum,\n-\t\t.slow = ps->dev->speed == USB_SPEED_LOW\n-\t};\n+\tstruct usbdevfs_connectinfo ci;\n+\n+\tmemset(&ci, 0, sizeof(ci));\n+\tci.devnum = ps->dev->devnum;\n+\tci.slow = ps->dev->speed == USB_SPEED_LOW;\n \n \tif (copy_to_user(arg, &ci, sizeof(ci)))\n \t\treturn -EFAULT;""}"," static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)
 {
	struct usbdevfs_connectinfo ci;

	memset(&ci, 0, sizeof(ci));
	ci.devnum = ps->dev->devnum;
	ci.slow = ps->dev->speed == USB_SPEED_LOW;
 
 	if (copy_to_user(arg, &ci, sizeof(ci)))
 		return -EFAULT;
	return 0;
}
"," static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)
 {
	struct usbdevfs_connectinfo ci = {
		.devnum = ps->dev->devnum,
		.slow = ps->dev->speed == USB_SPEED_LOW
	};
 
 	if (copy_to_user(arg, &ci, sizeof(ci)))
 		return -EFAULT;
	return 0;
}
",C,"	struct usbdevfs_connectinfo ci;

	memset(&ci, 0, sizeof(ci));
	ci.devnum = ps->dev->devnum;
	ci.slow = ps->dev->speed == USB_SPEED_LOW;
","	struct usbdevfs_connectinfo ci = {
		.devnum = ps->dev->devnum,
		.slow = ps->dev->speed == USB_SPEED_LOW
	};
",,"@@ -1316,10 +1316,11 @@ static int proc_getdriver(struct usb_dev_state *ps, void __user *arg)
 
 static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)
 {
-	struct usbdevfs_connectinfo ci = {
-		.devnum = ps->dev->devnum,
-		.slow = ps->dev->speed == USB_SPEED_LOW
-	};
+	struct usbdevfs_connectinfo ci;
+
+	memset(&ci, 0, sizeof(ci));
+	ci.devnum = ps->dev->devnum;
+	ci.slow = ps->dev->speed == USB_SPEED_LOW;
 
 	if (copy_to_user(arg, &ci, sizeof(ci)))
 		return -EFAULT;",linux,681fef8380eb818c0b845fca5d2ab1dcbab114ee,973986126a4152ab83d09263a02bf7d2d1bf3b6e,1," static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)
 {
//flaw_line_below:
	struct usbdevfs_connectinfo ci = {
//flaw_line_below:
		.devnum = ps->dev->devnum,
//flaw_line_below:
		.slow = ps->dev->speed == USB_SPEED_LOW
//flaw_line_below:
	};
//fix_flaw_line_below:
//	struct usbdevfs_connectinfo ci;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	memset(&ci, 0, sizeof(ci));
//fix_flaw_line_below:
//	ci.devnum = ps->dev->devnum;
//fix_flaw_line_below:
//	ci.slow = ps->dev->speed == USB_SPEED_LOW;
 
 	if (copy_to_user(arg, &ci, sizeof(ci)))
 		return -EFAULT;
	return 0;
}
",180431," static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)
 {
	struct usbdevfs_connectinfo ci = {
		.devnum = ps->dev->devnum,
		.slow = ps->dev->speed == USB_SPEED_LOW
	};
 
 	if (copy_to_user(arg, &ci, sizeof(ci)))
 		return -EFAULT;
	return 0;
}
"," static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)
 {
	struct usbdevfs_connectinfo ci;

	memset(&ci, 0, sizeof(ci));
	ci.devnum = ps->dev->devnum;
	ci.slow = ps->dev->speed == USB_SPEED_LOW;
 
 	if (copy_to_user(arg, &ci, sizeof(ci)))
 		return -EFAULT;
	return 0;
}
","The `proc_connectinfo` function retrieves connection information for a USB device represented by the `usb_dev_state` structure. It initializes a `usbdevfs_connectinfo` structure with the device number and speed of the USB device, specifically checking if the speed is low. The function then attempts to copy this information to a user-space pointer provided as an argument. If the copy operation fails, it returns an error code `-EFAULT`, indicating a fault in accessing user memory. If successful, it returns 0, signaling that the connection information has been successfully transferred.","The code defines a function that retrieves and prepares connection information for a USB device. It initializes a structure with the device's unique identifier and checks its operational speed, specifically noting if it operates at a low speed. The function then attempts to transfer this information to a specified location in user space. If the transfer fails due to an issue accessing memory, it returns an error code indicating a fault. Conversely, if the transfer is successful, it returns a success code, confirming that the connection details have been successfully provided to the user.","The vulnerability in the original code stemmed from the uninitialized padding bytes in the `usbdevfs_connectinfo` structure, which could lead to an information leak when the structure was copied to user space using `copy_to_user`. This leak could expose sensitive data from the stack to userland, potentially compromising security. The fixed code addresses this issue by explicitly initializing the entire structure with `memset`, ensuring that all bytes, including the padding, are set to zero before the copy operation. This prevents any uninitialized data from being inadvertently exposed, thereby mitigating the risk of information leakage.","The vulnerability in the original code was due to uninitialized padding bytes in a stack-allocated structure, which could inadvertently expose sensitive data when the structure was copied to user space. This information leak posed a security risk, as it allowed potentially sensitive information from the stack to be accessed by userland applications. The fix involved initializing the entire structure to zero before performing the copy operation, ensuring that all bytes, including the padding, were set to a known state. This change effectively eliminated the risk of leaking uninitialized data, thereby enhancing the security of the code.","The vulnerability was fixed by adding a call to `memset` to initialize the entire `usbdevfs_connectinfo` structure before it was used. In the updated code, `memset(&ci, 0, sizeof(ci))` ensures that all bytes of the structure, including the uninitialized padding bytes, are set to zero. This prevents any potentially sensitive data from being leaked to user space when `copy_to_user` is called to transfer the structure's contents. By ensuring that the structure is fully initialized, the risk of exposing uninitialized memory is effectively mitigated, enhancing the overall security of the code.","The vulnerability was addressed by implementing a mechanism to initialize the entire data structure before it was used in the code. This initialization process ensured that all bytes, including any padding that could contain uninitialized data, were set to a known value, specifically zero. By doing so, the risk of inadvertently exposing sensitive information through a memory leak was eliminated. This change effectively safeguarded against the potential for sensitive data to be accessed by userland applications, thereby enhancing the security and integrity of the code.","5,4","5,5","4,4","5,5"
59,59,180608,180608,,Remote,Not required,,CVE-2016-2117,https://www.cvedetails.com/cve/CVE-2016-2117/,CWE-200,Low,Partial,,,2016-05-02,5.0,"The atl2_probe function in drivers/net/ethernet/atheros/atlx/atl2.c in the Linux kernel through 4.5.2 incorrectly enables scatter/gather I/O, which allows remote attackers to obtain sensitive information from kernel memory by reading packet data.",2018-01-04,+Info ,1,https://github.com/torvalds/linux/commit/f43bfaeddc79effbf3d0fcb53ca477cca66f3db8,f43bfaeddc79effbf3d0fcb53ca477cca66f3db8,"atl2: Disable unimplemented scatter/gather feature

atl2 includes NETIF_F_SG in hw_features even though it has no support
for non-linear skbs.  This bug was originally harmless since the
driver does not claim to implement checksum offload and that used to
be a requirement for SG.

Now that SG and checksum offload are independent features, if you
explicitly enable SG *and* use one of the rare protocols that can use
SG without checkusm offload, this potentially leaks sensitive
information (before you notice that it just isn't working).  Therefore
this obscure bug has been designated CVE-2016-2117.

Reported-by: Justin Yackoski <jyackoski@crypto-nite.com>
Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
Fixes: ec5f06156423 (""net: Kill link between CSUM and SG features."")
Signed-off-by: David S. Miller <davem@davemloft.net>",1,drivers/net/ethernet/atheros/atlx/atl2.c,"{""sha"": ""2ff465848b6553ecc0a646421e30cded0e8fb053"", ""filename"": ""drivers/net/ethernet/atheros/atlx/atl2.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/f43bfaeddc79effbf3d0fcb53ca477cca66f3db8/drivers/net/ethernet/atheros/atlx/atl2.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f43bfaeddc79effbf3d0fcb53ca477cca66f3db8/drivers/net/ethernet/atheros/atlx/atl2.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/atheros/atlx/atl2.c?ref=f43bfaeddc79effbf3d0fcb53ca477cca66f3db8"", ""patch"": ""@@ -1412,7 +1412,7 @@ static int atl2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n \n \terr = -EIO;\n \n-\tnetdev->hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX;\n+\tnetdev->hw_features = NETIF_F_HW_VLAN_CTAG_RX;\n \tnetdev->features |= (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX);\n \n \t/* Init PHY as early as possible due to power saving issue  */""}","static int atl2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
{
	struct net_device *netdev;
	struct atl2_adapter *adapter;
	static int cards_found;
	unsigned long mmio_start;
	int mmio_len;
	int err;

	cards_found = 0;

	err = pci_enable_device(pdev);
	if (err)
		return err;

	/*
	 * atl2 is a shared-high-32-bit device, so we're stuck with 32-bit DMA
	 * until the kernel has the proper infrastructure to support 64-bit DMA
	 * on these devices.
	 */
	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) &&
		pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {
		printk(KERN_ERR ""atl2: No usable DMA configuration, aborting\n"");
		goto err_dma;
	}

	/* Mark all PCI regions associated with PCI device
	 * pdev as being reserved by owner atl2_driver_name */
	err = pci_request_regions(pdev, atl2_driver_name);
	if (err)
		goto err_pci_reg;

	/* Enables bus-mastering on the device and calls
	 * pcibios_set_master to do the needed arch specific settings */
	pci_set_master(pdev);

	err = -ENOMEM;
	netdev = alloc_etherdev(sizeof(struct atl2_adapter));
	if (!netdev)
		goto err_alloc_etherdev;

	SET_NETDEV_DEV(netdev, &pdev->dev);

	pci_set_drvdata(pdev, netdev);
	adapter = netdev_priv(netdev);
	adapter->netdev = netdev;
	adapter->pdev = pdev;
	adapter->hw.back = adapter;

	mmio_start = pci_resource_start(pdev, 0x0);
	mmio_len = pci_resource_len(pdev, 0x0);

	adapter->hw.mem_rang = (u32)mmio_len;
	adapter->hw.hw_addr = ioremap(mmio_start, mmio_len);
	if (!adapter->hw.hw_addr) {
		err = -EIO;
		goto err_ioremap;
	}

	atl2_setup_pcicmd(pdev);

	netdev->netdev_ops = &atl2_netdev_ops;
	netdev->ethtool_ops = &atl2_ethtool_ops;
	netdev->watchdog_timeo = 5 * HZ;
	strncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);

	netdev->mem_start = mmio_start;
	netdev->mem_end = mmio_start + mmio_len;
	adapter->bd_number = cards_found;
	adapter->pci_using_64 = false;

	/* setup the private structure */
	err = atl2_sw_init(adapter);
	if (err)
		goto err_sw_init;
 
 	err = -EIO;
 
	netdev->hw_features = NETIF_F_HW_VLAN_CTAG_RX;
 	netdev->features |= (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX);
 
 	/* Init PHY as early as possible due to power saving issue  */
	atl2_phy_init(&adapter->hw);

	/* reset the controller to
	 * put the device in a known good starting state */

	if (atl2_reset_hw(&adapter->hw)) {
		err = -EIO;
		goto err_reset;
	}

	/* copy the MAC address out of the EEPROM */
	atl2_read_mac_addr(&adapter->hw);
	memcpy(netdev->dev_addr, adapter->hw.mac_addr, netdev->addr_len);
	if (!is_valid_ether_addr(netdev->dev_addr)) {
		err = -EIO;
		goto err_eeprom;
	}

	atl2_check_options(adapter);

	setup_timer(&adapter->watchdog_timer, atl2_watchdog,
		    (unsigned long)adapter);

	setup_timer(&adapter->phy_config_timer, atl2_phy_config,
		    (unsigned long)adapter);

	INIT_WORK(&adapter->reset_task, atl2_reset_task);
	INIT_WORK(&adapter->link_chg_task, atl2_link_chg_task);

	strcpy(netdev->name, ""eth%d""); /* ?? */
	err = register_netdev(netdev);
	if (err)
		goto err_register;

	/* assume we have no link for now */
	netif_carrier_off(netdev);
	netif_stop_queue(netdev);

	cards_found++;

	return 0;

err_reset:
err_register:
err_sw_init:
err_eeprom:
	iounmap(adapter->hw.hw_addr);
err_ioremap:
	free_netdev(netdev);
err_alloc_etherdev:
	pci_release_regions(pdev);
err_pci_reg:
err_dma:
	pci_disable_device(pdev);
	return err;
}
","static int atl2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
{
	struct net_device *netdev;
	struct atl2_adapter *adapter;
	static int cards_found;
	unsigned long mmio_start;
	int mmio_len;
	int err;

	cards_found = 0;

	err = pci_enable_device(pdev);
	if (err)
		return err;

	/*
	 * atl2 is a shared-high-32-bit device, so we're stuck with 32-bit DMA
	 * until the kernel has the proper infrastructure to support 64-bit DMA
	 * on these devices.
	 */
	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) &&
		pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {
		printk(KERN_ERR ""atl2: No usable DMA configuration, aborting\n"");
		goto err_dma;
	}

	/* Mark all PCI regions associated with PCI device
	 * pdev as being reserved by owner atl2_driver_name */
	err = pci_request_regions(pdev, atl2_driver_name);
	if (err)
		goto err_pci_reg;

	/* Enables bus-mastering on the device and calls
	 * pcibios_set_master to do the needed arch specific settings */
	pci_set_master(pdev);

	err = -ENOMEM;
	netdev = alloc_etherdev(sizeof(struct atl2_adapter));
	if (!netdev)
		goto err_alloc_etherdev;

	SET_NETDEV_DEV(netdev, &pdev->dev);

	pci_set_drvdata(pdev, netdev);
	adapter = netdev_priv(netdev);
	adapter->netdev = netdev;
	adapter->pdev = pdev;
	adapter->hw.back = adapter;

	mmio_start = pci_resource_start(pdev, 0x0);
	mmio_len = pci_resource_len(pdev, 0x0);

	adapter->hw.mem_rang = (u32)mmio_len;
	adapter->hw.hw_addr = ioremap(mmio_start, mmio_len);
	if (!adapter->hw.hw_addr) {
		err = -EIO;
		goto err_ioremap;
	}

	atl2_setup_pcicmd(pdev);

	netdev->netdev_ops = &atl2_netdev_ops;
	netdev->ethtool_ops = &atl2_ethtool_ops;
	netdev->watchdog_timeo = 5 * HZ;
	strncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);

	netdev->mem_start = mmio_start;
	netdev->mem_end = mmio_start + mmio_len;
	adapter->bd_number = cards_found;
	adapter->pci_using_64 = false;

	/* setup the private structure */
	err = atl2_sw_init(adapter);
	if (err)
		goto err_sw_init;
 
 	err = -EIO;
 
	netdev->hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX;
 	netdev->features |= (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX);
 
 	/* Init PHY as early as possible due to power saving issue  */
	atl2_phy_init(&adapter->hw);

	/* reset the controller to
	 * put the device in a known good starting state */

	if (atl2_reset_hw(&adapter->hw)) {
		err = -EIO;
		goto err_reset;
	}

	/* copy the MAC address out of the EEPROM */
	atl2_read_mac_addr(&adapter->hw);
	memcpy(netdev->dev_addr, adapter->hw.mac_addr, netdev->addr_len);
	if (!is_valid_ether_addr(netdev->dev_addr)) {
		err = -EIO;
		goto err_eeprom;
	}

	atl2_check_options(adapter);

	setup_timer(&adapter->watchdog_timer, atl2_watchdog,
		    (unsigned long)adapter);

	setup_timer(&adapter->phy_config_timer, atl2_phy_config,
		    (unsigned long)adapter);

	INIT_WORK(&adapter->reset_task, atl2_reset_task);
	INIT_WORK(&adapter->link_chg_task, atl2_link_chg_task);

	strcpy(netdev->name, ""eth%d""); /* ?? */
	err = register_netdev(netdev);
	if (err)
		goto err_register;

	/* assume we have no link for now */
	netif_carrier_off(netdev);
	netif_stop_queue(netdev);

	cards_found++;

	return 0;

err_reset:
err_register:
err_sw_init:
err_eeprom:
	iounmap(adapter->hw.hw_addr);
err_ioremap:
	free_netdev(netdev);
err_alloc_etherdev:
	pci_release_regions(pdev);
err_pci_reg:
err_dma:
	pci_disable_device(pdev);
	return err;
}
",C,"	netdev->hw_features = NETIF_F_HW_VLAN_CTAG_RX;
","	netdev->hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX;
",,"@@ -1412,7 +1412,7 @@ static int atl2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	err = -EIO;
 
-	netdev->hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX;
+	netdev->hw_features = NETIF_F_HW_VLAN_CTAG_RX;
 	netdev->features |= (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX);
 
 	/* Init PHY as early as possible due to power saving issue  */",linux,f43bfaeddc79effbf3d0fcb53ca477cca66f3db8,669c00c009ba0db81e840fd7e11faff7be8c8123,1,"static int atl2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
{
	struct net_device *netdev;
	struct atl2_adapter *adapter;
	static int cards_found;
	unsigned long mmio_start;
	int mmio_len;
	int err;

	cards_found = 0;

	err = pci_enable_device(pdev);
	if (err)
		return err;

	/*
	 * atl2 is a shared-high-32-bit device, so we're stuck with 32-bit DMA
	 * until the kernel has the proper infrastructure to support 64-bit DMA
	 * on these devices.
	 */
	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) &&
		pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {
		printk(KERN_ERR ""atl2: No usable DMA configuration, aborting\n"");
		goto err_dma;
	}

	/* Mark all PCI regions associated with PCI device
	 * pdev as being reserved by owner atl2_driver_name */
	err = pci_request_regions(pdev, atl2_driver_name);
	if (err)
		goto err_pci_reg;

	/* Enables bus-mastering on the device and calls
	 * pcibios_set_master to do the needed arch specific settings */
	pci_set_master(pdev);

	err = -ENOMEM;
	netdev = alloc_etherdev(sizeof(struct atl2_adapter));
	if (!netdev)
		goto err_alloc_etherdev;

	SET_NETDEV_DEV(netdev, &pdev->dev);

	pci_set_drvdata(pdev, netdev);
	adapter = netdev_priv(netdev);
	adapter->netdev = netdev;
	adapter->pdev = pdev;
	adapter->hw.back = adapter;

	mmio_start = pci_resource_start(pdev, 0x0);
	mmio_len = pci_resource_len(pdev, 0x0);

	adapter->hw.mem_rang = (u32)mmio_len;
	adapter->hw.hw_addr = ioremap(mmio_start, mmio_len);
	if (!adapter->hw.hw_addr) {
		err = -EIO;
		goto err_ioremap;
	}

	atl2_setup_pcicmd(pdev);

	netdev->netdev_ops = &atl2_netdev_ops;
	netdev->ethtool_ops = &atl2_ethtool_ops;
	netdev->watchdog_timeo = 5 * HZ;
	strncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);

	netdev->mem_start = mmio_start;
	netdev->mem_end = mmio_start + mmio_len;
	adapter->bd_number = cards_found;
	adapter->pci_using_64 = false;

	/* setup the private structure */
	err = atl2_sw_init(adapter);
	if (err)
		goto err_sw_init;
 
 	err = -EIO;
 
//flaw_line_below:
	netdev->hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX;
//fix_flaw_line_below:
//	netdev->hw_features = NETIF_F_HW_VLAN_CTAG_RX;
 	netdev->features |= (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX);
 
 	/* Init PHY as early as possible due to power saving issue  */
	atl2_phy_init(&adapter->hw);

	/* reset the controller to
	 * put the device in a known good starting state */

	if (atl2_reset_hw(&adapter->hw)) {
		err = -EIO;
		goto err_reset;
	}

	/* copy the MAC address out of the EEPROM */
	atl2_read_mac_addr(&adapter->hw);
	memcpy(netdev->dev_addr, adapter->hw.mac_addr, netdev->addr_len);
	if (!is_valid_ether_addr(netdev->dev_addr)) {
		err = -EIO;
		goto err_eeprom;
	}

	atl2_check_options(adapter);

	setup_timer(&adapter->watchdog_timer, atl2_watchdog,
		    (unsigned long)adapter);

	setup_timer(&adapter->phy_config_timer, atl2_phy_config,
		    (unsigned long)adapter);

	INIT_WORK(&adapter->reset_task, atl2_reset_task);
	INIT_WORK(&adapter->link_chg_task, atl2_link_chg_task);

	strcpy(netdev->name, ""eth%d""); /* ?? */
	err = register_netdev(netdev);
	if (err)
		goto err_register;

	/* assume we have no link for now */
	netif_carrier_off(netdev);
	netif_stop_queue(netdev);

	cards_found++;

	return 0;

err_reset:
err_register:
err_sw_init:
err_eeprom:
	iounmap(adapter->hw.hw_addr);
err_ioremap:
	free_netdev(netdev);
err_alloc_etherdev:
	pci_release_regions(pdev);
err_pci_reg:
err_dma:
	pci_disable_device(pdev);
	return err;
}
",180608,"static int atl2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
{
	struct net_device *netdev;
	struct atl2_adapter *adapter;
	static int cards_found;
	unsigned long mmio_start;
	int mmio_len;
	int err;

	cards_found = 0;

	err = pci_enable_device(pdev);
	if (err)
		return err;

	/*
	 * atl2 is a shared-high-32-bit device, so we're stuck with 32-bit DMA
	 * until the kernel has the proper infrastructure to support 64-bit DMA
	 * on these devices.
	 */
	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) &&
		pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {
		printk(KERN_ERR ""atl2: No usable DMA configuration, aborting\n"");
		goto err_dma;
	}

	/* Mark all PCI regions associated with PCI device
	 * pdev as being reserved by owner atl2_driver_name */
	err = pci_request_regions(pdev, atl2_driver_name);
	if (err)
		goto err_pci_reg;

	/* Enables bus-mastering on the device and calls
	 * pcibios_set_master to do the needed arch specific settings */
	pci_set_master(pdev);

	err = -ENOMEM;
	netdev = alloc_etherdev(sizeof(struct atl2_adapter));
	if (!netdev)
		goto err_alloc_etherdev;

	SET_NETDEV_DEV(netdev, &pdev->dev);

	pci_set_drvdata(pdev, netdev);
	adapter = netdev_priv(netdev);
	adapter->netdev = netdev;
	adapter->pdev = pdev;
	adapter->hw.back = adapter;

	mmio_start = pci_resource_start(pdev, 0x0);
	mmio_len = pci_resource_len(pdev, 0x0);

	adapter->hw.mem_rang = (u32)mmio_len;
	adapter->hw.hw_addr = ioremap(mmio_start, mmio_len);
	if (!adapter->hw.hw_addr) {
		err = -EIO;
		goto err_ioremap;
	}

	atl2_setup_pcicmd(pdev);

	netdev->netdev_ops = &atl2_netdev_ops;
	netdev->ethtool_ops = &atl2_ethtool_ops;
	netdev->watchdog_timeo = 5 * HZ;
	strncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);

	netdev->mem_start = mmio_start;
	netdev->mem_end = mmio_start + mmio_len;
	adapter->bd_number = cards_found;
	adapter->pci_using_64 = false;

	/* setup the private structure */
	err = atl2_sw_init(adapter);
	if (err)
		goto err_sw_init;
 
 	err = -EIO;
 
	netdev->hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX;
 	netdev->features |= (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX);
 
 	/* Init PHY as early as possible due to power saving issue  */
	atl2_phy_init(&adapter->hw);

	/* reset the controller to
	 * put the device in a known good starting state */

	if (atl2_reset_hw(&adapter->hw)) {
		err = -EIO;
		goto err_reset;
	}

	/* copy the MAC address out of the EEPROM */
	atl2_read_mac_addr(&adapter->hw);
	memcpy(netdev->dev_addr, adapter->hw.mac_addr, netdev->addr_len);
	if (!is_valid_ether_addr(netdev->dev_addr)) {
		err = -EIO;
		goto err_eeprom;
	}

	atl2_check_options(adapter);

	setup_timer(&adapter->watchdog_timer, atl2_watchdog,
		    (unsigned long)adapter);

	setup_timer(&adapter->phy_config_timer, atl2_phy_config,
		    (unsigned long)adapter);

	INIT_WORK(&adapter->reset_task, atl2_reset_task);
	INIT_WORK(&adapter->link_chg_task, atl2_link_chg_task);

	strcpy(netdev->name, ""eth%d""); /* ?? */
	err = register_netdev(netdev);
	if (err)
		goto err_register;

	/* assume we have no link for now */
	netif_carrier_off(netdev);
	netif_stop_queue(netdev);

	cards_found++;

	return 0;

err_reset:
err_register:
err_sw_init:
err_eeprom:
	iounmap(adapter->hw.hw_addr);
err_ioremap:
	free_netdev(netdev);
err_alloc_etherdev:
	pci_release_regions(pdev);
err_pci_reg:
err_dma:
	pci_disable_device(pdev);
	return err;
}
","static int atl2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
{
	struct net_device *netdev;
	struct atl2_adapter *adapter;
	static int cards_found;
	unsigned long mmio_start;
	int mmio_len;
	int err;

	cards_found = 0;

	err = pci_enable_device(pdev);
	if (err)
		return err;

	/*
	 * atl2 is a shared-high-32-bit device, so we're stuck with 32-bit DMA
	 * until the kernel has the proper infrastructure to support 64-bit DMA
	 * on these devices.
	 */
	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) &&
		pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {
		printk(KERN_ERR ""atl2: No usable DMA configuration, aborting\n"");
		goto err_dma;
	}

	/* Mark all PCI regions associated with PCI device
	 * pdev as being reserved by owner atl2_driver_name */
	err = pci_request_regions(pdev, atl2_driver_name);
	if (err)
		goto err_pci_reg;

	/* Enables bus-mastering on the device and calls
	 * pcibios_set_master to do the needed arch specific settings */
	pci_set_master(pdev);

	err = -ENOMEM;
	netdev = alloc_etherdev(sizeof(struct atl2_adapter));
	if (!netdev)
		goto err_alloc_etherdev;

	SET_NETDEV_DEV(netdev, &pdev->dev);

	pci_set_drvdata(pdev, netdev);
	adapter = netdev_priv(netdev);
	adapter->netdev = netdev;
	adapter->pdev = pdev;
	adapter->hw.back = adapter;

	mmio_start = pci_resource_start(pdev, 0x0);
	mmio_len = pci_resource_len(pdev, 0x0);

	adapter->hw.mem_rang = (u32)mmio_len;
	adapter->hw.hw_addr = ioremap(mmio_start, mmio_len);
	if (!adapter->hw.hw_addr) {
		err = -EIO;
		goto err_ioremap;
	}

	atl2_setup_pcicmd(pdev);

	netdev->netdev_ops = &atl2_netdev_ops;
	netdev->ethtool_ops = &atl2_ethtool_ops;
	netdev->watchdog_timeo = 5 * HZ;
	strncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);

	netdev->mem_start = mmio_start;
	netdev->mem_end = mmio_start + mmio_len;
	adapter->bd_number = cards_found;
	adapter->pci_using_64 = false;

	/* setup the private structure */
	err = atl2_sw_init(adapter);
	if (err)
		goto err_sw_init;
 
 	err = -EIO;
 
	netdev->hw_features = NETIF_F_HW_VLAN_CTAG_RX;
 	netdev->features |= (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX);
 
 	/* Init PHY as early as possible due to power saving issue  */
	atl2_phy_init(&adapter->hw);

	/* reset the controller to
	 * put the device in a known good starting state */

	if (atl2_reset_hw(&adapter->hw)) {
		err = -EIO;
		goto err_reset;
	}

	/* copy the MAC address out of the EEPROM */
	atl2_read_mac_addr(&adapter->hw);
	memcpy(netdev->dev_addr, adapter->hw.mac_addr, netdev->addr_len);
	if (!is_valid_ether_addr(netdev->dev_addr)) {
		err = -EIO;
		goto err_eeprom;
	}

	atl2_check_options(adapter);

	setup_timer(&adapter->watchdog_timer, atl2_watchdog,
		    (unsigned long)adapter);

	setup_timer(&adapter->phy_config_timer, atl2_phy_config,
		    (unsigned long)adapter);

	INIT_WORK(&adapter->reset_task, atl2_reset_task);
	INIT_WORK(&adapter->link_chg_task, atl2_link_chg_task);

	strcpy(netdev->name, ""eth%d""); /* ?? */
	err = register_netdev(netdev);
	if (err)
		goto err_register;

	/* assume we have no link for now */
	netif_carrier_off(netdev);
	netif_stop_queue(netdev);

	cards_found++;

	return 0;

err_reset:
err_register:
err_sw_init:
err_eeprom:
	iounmap(adapter->hw.hw_addr);
err_ioremap:
	free_netdev(netdev);
err_alloc_etherdev:
	pci_release_regions(pdev);
err_pci_reg:
err_dma:
	pci_disable_device(pdev);
	return err;
}
","The `atl2_probe` function initializes a network device driver for a PCI device, handling various setup tasks essential for proper operation. It begins by enabling the PCI device and configuring DMA masks, followed by reserving PCI regions and enabling bus mastering. The function allocates memory for the network device structure and maps the device's memory region. It sets up hardware features, initializes the PHY, and resets the hardware to a known state. The MAC address is read from EEPROM, and timers for watchdog and link change tasks are initialized. Finally, the network device is registered, and error handling is implemented throughout to ensure proper cleanup in case of failures.","The code initializes a network device driver for a PCI device, performing essential setup tasks for its operation. It begins by enabling the device and configuring memory access settings, followed by reserving necessary resources. Memory is allocated for the network device structure, and the device's memory region is mapped. The code sets hardware features, initializes the physical layer, and resets the hardware to ensure it starts in a known state. It retrieves the MAC address from the device's memory, sets up timers for monitoring tasks, and registers the network device, incorporating error handling to manage potential failures throughout the process.","The vulnerability in the original code stemmed from the inclusion of a feature flag for scatter/gather (SG) in the hardware features, despite the driver lacking support for non-linear socket buffers. This could lead to potential information leaks when SG was enabled alongside certain protocols that do not require checksum offload, as the driver would not function correctly without proper implementation. The fix involved removing the SG feature from the hardware features, ensuring that the driver does not falsely advertise support for a feature it cannot handle, thus mitigating the risk of sensitive data exposure and aligning with the updated requirements for feature independence.","The vulnerability in the original code arose from the inclusion of a feature flag for scatter/gather in the hardware capabilities, despite the driver lacking the necessary support for handling non-linear socket buffers. This could lead to situations where the feature was enabled, potentially allowing sensitive information to be leaked when used with certain protocols that do not require checksum offload. The fix involved removing the scatter/gather feature from the hardware capabilities, ensuring that the driver accurately reflects its supported features and preventing the risk of data exposure due to unsupported functionality.","The vulnerability was fixed by removing the scatter/gather feature from the hardware features of the network device. Specifically, the line that included the scatter/gather flag in the `netdev->hw_features` was eliminated, ensuring that the driver no longer falsely advertised support for this feature. This change prevents the driver from enabling the scatter/gather functionality, which it cannot handle, thus mitigating the risk of sensitive information leaks when using certain protocols. By accurately reflecting the supported features, the driver aligns with the updated requirements for feature independence, enhancing overall security.","The vulnerability was fixed by removing the erroneous inclusion of the scatter/gather feature from the driver's advertised capabilities. This adjustment ensured that the driver no longer claimed support for a feature it could not implement, thereby preventing potential misuse that could lead to sensitive information leaks. By accurately representing the supported features, the driver mitigated the risk associated with enabling scatter/gather in scenarios where it was not properly handled. This change aligns the driver's functionality with its actual capabilities, enhancing security and preventing unintended behavior in network operations.","4,5","5,5","5,4","4, 4"
60,60,180622,180622,,Local,Not required,,CVE-2016-0823,https://www.cvedetails.com/cve/CVE-2016-0823/,CWE-200,Low,Partial,,,2016-03-12,2.1,"The pagemap_open function in fs/proc/task_mmu.c in the Linux kernel before 3.19.3, as used in Android 6.0.1 before 2016-03-01, allows local users to obtain sensitive physical-address information by reading a pagemap file, aka Android internal bug 25739721.",2016-11-28,+Info ,3,https://github.com/torvalds/linux/commit/ab676b7d6fbf4b294bf198fb27ade5b0e865c7ce,ab676b7d6fbf4b294bf198fb27ade5b0e865c7ce,"pagemap: do not leak physical addresses to non-privileged userspace

As pointed by recent post[1] on exploiting DRAM physical imperfection,
/proc/PID/pagemap exposes sensitive information which can be used to do
attacks.

This disallows anybody without CAP_SYS_ADMIN to read the pagemap.

[1] http://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html

[ Eventually we might want to do anything more finegrained, but for now
  this is the simple model.   - Linus ]

Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Acked-by: Konstantin Khlebnikov <khlebnikov@openvz.org>
Acked-by: Andy Lutomirski <luto@amacapital.net>
Cc: Pavel Emelyanov <xemul@parallels.com>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Mark Seaborn <mseaborn@chromium.org>
Cc: stable@vger.kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,fs/proc/task_mmu.c,"{""sha"": ""6dee68d013ffa69f1f6c9d49873f17f19eb3874d"", ""filename"": ""fs/proc/task_mmu.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/ab676b7d6fbf4b294bf198fb27ade5b0e865c7ce/fs/proc/task_mmu.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ab676b7d6fbf4b294bf198fb27ade5b0e865c7ce/fs/proc/task_mmu.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/proc/task_mmu.c?ref=ab676b7d6fbf4b294bf198fb27ade5b0e865c7ce"", ""patch"": ""@@ -1325,6 +1325,9 @@ static ssize_t pagemap_read(struct file *file, char __user *buf,\n \n static int pagemap_open(struct inode *inode, struct file *file)\n {\n+\t/* do not disclose physical addresses: attack vector */\n+\tif (!capable(CAP_SYS_ADMIN))\n+\t\treturn -EPERM;\n \tpr_warn_once(\""Bits 55-60 of /proc/PID/pagemap entries are about \""\n \t\t\t\""to stop being page-shift some time soon. See the \""\n \t\t\t\""linux/Documentation/vm/pagemap.txt for details.\\n\"");""}"," static int pagemap_open(struct inode *inode, struct file *file)
 {
	/* do not disclose physical addresses: attack vector */
	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;
 	pr_warn_once(""Bits 55-60 of /proc/PID/pagemap entries are about ""
 			""to stop being page-shift some time soon. See the ""
 			""linux/Documentation/vm/pagemap.txt for details.\n"");
	return 0;
}
"," static int pagemap_open(struct inode *inode, struct file *file)
 {
 	pr_warn_once(""Bits 55-60 of /proc/PID/pagemap entries are about ""
 			""to stop being page-shift some time soon. See the ""
 			""linux/Documentation/vm/pagemap.txt for details.\n"");
	return 0;
}
",C,"	/* do not disclose physical addresses: attack vector */
	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;
",,,"@@ -1325,6 +1325,9 @@ static ssize_t pagemap_read(struct file *file, char __user *buf,
 
 static int pagemap_open(struct inode *inode, struct file *file)
 {
+	/* do not disclose physical addresses: attack vector */
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
 	pr_warn_once(""Bits 55-60 of /proc/PID/pagemap entries are about ""
 			""to stop being page-shift some time soon. See the ""
 			""linux/Documentation/vm/pagemap.txt for details.\n"");",linux,ab676b7d6fbf4b294bf198fb27ade5b0e865c7ce,06e5801b8cb3fc057d88cb4dc03c0b64b2744cda,1," static int pagemap_open(struct inode *inode, struct file *file)
 {
//fix_flaw_line_below:
//	/* do not disclose physical addresses: attack vector */
//fix_flaw_line_below:
//	if (!capable(CAP_SYS_ADMIN))
//fix_flaw_line_below:
//		return -EPERM;
 	pr_warn_once(""Bits 55-60 of /proc/PID/pagemap entries are about ""
 			""to stop being page-shift some time soon. See the ""
 			""linux/Documentation/vm/pagemap.txt for details.\n"");
	return 0;
}
",180622," static int pagemap_open(struct inode *inode, struct file *file)
 {
 	pr_warn_once(""Bits 55-60 of /proc/PID/pagemap entries are about ""
 			""to stop being page-shift some time soon. See the ""
 			""linux/Documentation/vm/pagemap.txt for details.\n"");
	return 0;
}
"," static int pagemap_open(struct inode *inode, struct file *file)
 {
	/* do not disclose physical addresses: attack vector */
	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;
 	pr_warn_once(""Bits 55-60 of /proc/PID/pagemap entries are about ""
 			""to stop being page-shift some time soon. See the ""
 			""linux/Documentation/vm/pagemap.txt for details.\n"");
	return 0;
}
","The provided code defines a function `pagemap_open`, which is a part of a Linux kernel module that handles the opening of a pagemap file associated with a specific process. When this function is called, it issues a warning message to the kernel log, notifying users that the bits 55-60 of the `/proc/PID/pagemap` entries will soon change from being page-shifted. This warning serves as a heads-up for developers and users to refer to the documentation in `linux/Documentation/vm/pagemap.txt` for further details on the impending changes, while the function itself returns 0, indicating successful execution.","The code snippet defines a function that is triggered when a specific file related to memory management is opened within the Linux kernel. Upon execution, it generates a warning message that informs users about an upcoming change regarding certain bits in memory mapping entries, which will no longer be shifted in a particular manner. This warning aims to alert developers and users to consult the relevant documentation for more information on the changes. The function concludes by returning a success status, indicating that the operation was completed without errors.","The vulnerability in the original code arises from the lack of access control, allowing any user to read the pagemap file, which could potentially expose sensitive physical memory addresses. This could be exploited to perform attacks, such as the Rowhammer attack, by revealing information that should be restricted to privileged users. The fixed code addresses this issue by introducing a check using the `capable(CAP_SYS_ADMIN)` function, which ensures that only users with administrative privileges can access the pagemap. If the user lacks the necessary capability, the function returns `-EPERM`, effectively preventing unauthorized access to sensitive information.","The vulnerability in the original code stems from the unrestricted access to a file that reveals sensitive physical memory addresses, potentially allowing unauthorized users to exploit this information for malicious purposes, such as memory attacks. The fix implemented in the updated code introduces a security check that restricts access to this file, ensuring that only users with administrative privileges can read it. By enforcing this access control, the code effectively mitigates the risk of leaking sensitive information to non-privileged users, thereby enhancing the overall security of the system against potential attacks.","The vulnerability was fixed by adding an access control check using the `capable(CAP_SYS_ADMIN)` function in the updated code. This function verifies whether the user attempting to access the pagemap file has administrative privileges. If the user lacks the necessary capability, the code returns `-EPERM`, which indicates that permission is denied. This change effectively restricts access to the pagemap file, preventing non-privileged users from reading sensitive physical memory addresses, thereby mitigating the risk of potential exploitation and enhancing the security of the system against attacks that could leverage this information.","The vulnerability was addressed by implementing an access control mechanism that restricts file access to only those users with administrative privileges. This was achieved by introducing a check that verifies the user's permissions before allowing them to read the file containing sensitive information. If a user does not possess the required privileges, the system denies access, effectively preventing unauthorized users from obtaining potentially exploitable data. This enhancement significantly improves the security of the system by ensuring that only trusted users can access critical memory information, thereby reducing the risk of malicious exploitation.","4,4","5,5","4,4","5,5"
61,61,180747,180747,,Local,Not required,,CVE-2014-9903,https://www.cvedetails.com/cve/CVE-2014-9903/,CWE-200,Low,Partial,,,2016-06-27,2.1,"The sched_read_attr function in kernel/sched/core.c in the Linux kernel 3.14-rc before 3.14-rc4 uses an incorrect size, which allows local users to obtain sensitive information from kernel stack memory via a crafted sched_getattr system call.",2016-11-28,+Info ,1,https://github.com/torvalds/linux/commit/4efbc454ba68def5ef285b26ebfcfdb605b52755,4efbc454ba68def5ef285b26ebfcfdb605b52755,"sched: Fix information leak in sys_sched_getattr()

We're copying the on-stack structure to userspace, but forgot to give
the right number of bytes to copy. This allows the calling process to
obtain up to PAGE_SIZE bytes from the stack (and possibly adjacent
kernel memory).

This fix copies only as much as we actually have on the stack
(attr->size defaults to the size of the struct) and leaves the rest of
the userspace-provided buffer untouched.

Found using kmemcheck + trinity.

Fixes: d50dde5a10f30 (""sched: Add new scheduler syscalls to support an extended scheduling parameters ABI"")
Cc: Dario Faggioli <raistlin@linux.it>
Cc: Juri Lelli <juri.lelli@gmail.com>
Cc: Ingo Molnar <mingo@kernel.org>
Signed-off-by: Vegard Nossum <vegard.nossum@oracle.com>
Signed-off-by: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/1392585857-10725-1-git-send-email-vegard.nossum@oracle.com
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>",1,kernel/sched/core.c,"{""sha"": ""a6e7470166c7e6ad19fdef5ba7e359fa98a00c8a"", ""filename"": ""kernel/sched/core.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/4efbc454ba68def5ef285b26ebfcfdb605b52755/kernel/sched/core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4efbc454ba68def5ef285b26ebfcfdb605b52755/kernel/sched/core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/sched/core.c?ref=4efbc454ba68def5ef285b26ebfcfdb605b52755"", ""patch"": ""@@ -3786,7 +3786,7 @@ static int sched_read_attr(struct sched_attr __user *uattr,\n \t\tattr->size = usize;\n \t}\n \n-\tret = copy_to_user(uattr, attr, usize);\n+\tret = copy_to_user(uattr, attr, attr->size);\n \tif (ret)\n \t\treturn -EFAULT;\n ""}","static int sched_read_attr(struct sched_attr __user *uattr,
			   struct sched_attr *attr,
			   unsigned int usize)
{
	int ret;

	if (!access_ok(VERIFY_WRITE, uattr, usize))
		return -EFAULT;

	/*
	 * If we're handed a smaller struct than we know of,
	 * ensure all the unknown bits are 0 - i.e. old
	 * user-space does not get uncomplete information.
	 */
	if (usize < sizeof(*attr)) {
		unsigned char *addr;
		unsigned char *end;

		addr = (void *)attr + usize;
		end  = (void *)attr + sizeof(*attr);

		for (; addr < end; addr++) {
			if (*addr)
				goto err_size;
		}

 		attr->size = usize;
 	}
 
	ret = copy_to_user(uattr, attr, attr->size);
 	if (ret)
 		return -EFAULT;
 
out:
	return ret;

err_size:
	ret = -E2BIG;
	goto out;
}
","static int sched_read_attr(struct sched_attr __user *uattr,
			   struct sched_attr *attr,
			   unsigned int usize)
{
	int ret;

	if (!access_ok(VERIFY_WRITE, uattr, usize))
		return -EFAULT;

	/*
	 * If we're handed a smaller struct than we know of,
	 * ensure all the unknown bits are 0 - i.e. old
	 * user-space does not get uncomplete information.
	 */
	if (usize < sizeof(*attr)) {
		unsigned char *addr;
		unsigned char *end;

		addr = (void *)attr + usize;
		end  = (void *)attr + sizeof(*attr);

		for (; addr < end; addr++) {
			if (*addr)
				goto err_size;
		}

 		attr->size = usize;
 	}
 
	ret = copy_to_user(uattr, attr, usize);
 	if (ret)
 		return -EFAULT;
 
out:
	return ret;

err_size:
	ret = -E2BIG;
	goto out;
}
",C,"	ret = copy_to_user(uattr, attr, attr->size);
","	ret = copy_to_user(uattr, attr, usize);
",,"@@ -3786,7 +3786,7 @@ static int sched_read_attr(struct sched_attr __user *uattr,
 		attr->size = usize;
 	}
 
-	ret = copy_to_user(uattr, attr, usize);
+	ret = copy_to_user(uattr, attr, attr->size);
 	if (ret)
 		return -EFAULT;
 ",linux,4efbc454ba68def5ef285b26ebfcfdb605b52755,3cf1962cdbf6b3a9e3ef21116d215bbab350ea37,1,"static int sched_read_attr(struct sched_attr __user *uattr,
			   struct sched_attr *attr,
			   unsigned int usize)
{
	int ret;

	if (!access_ok(VERIFY_WRITE, uattr, usize))
		return -EFAULT;

	/*
	 * If we're handed a smaller struct than we know of,
	 * ensure all the unknown bits are 0 - i.e. old
	 * user-space does not get uncomplete information.
	 */
	if (usize < sizeof(*attr)) {
		unsigned char *addr;
		unsigned char *end;

		addr = (void *)attr + usize;
		end  = (void *)attr + sizeof(*attr);

		for (; addr < end; addr++) {
			if (*addr)
				goto err_size;
		}

 		attr->size = usize;
 	}
 
//flaw_line_below:
	ret = copy_to_user(uattr, attr, usize);
//fix_flaw_line_below:
//	ret = copy_to_user(uattr, attr, attr->size);
 	if (ret)
 		return -EFAULT;
 
out:
	return ret;

err_size:
	ret = -E2BIG;
	goto out;
}
",180747,"static int sched_read_attr(struct sched_attr __user *uattr,
			   struct sched_attr *attr,
			   unsigned int usize)
{
	int ret;

	if (!access_ok(VERIFY_WRITE, uattr, usize))
		return -EFAULT;

	/*
	 * If we're handed a smaller struct than we know of,
	 * ensure all the unknown bits are 0 - i.e. old
	 * user-space does not get uncomplete information.
	 */
	if (usize < sizeof(*attr)) {
		unsigned char *addr;
		unsigned char *end;

		addr = (void *)attr + usize;
		end  = (void *)attr + sizeof(*attr);

		for (; addr < end; addr++) {
			if (*addr)
				goto err_size;
		}

 		attr->size = usize;
 	}
 
	ret = copy_to_user(uattr, attr, usize);
 	if (ret)
 		return -EFAULT;
 
out:
	return ret;

err_size:
	ret = -E2BIG;
	goto out;
}
","static int sched_read_attr(struct sched_attr __user *uattr,
			   struct sched_attr *attr,
			   unsigned int usize)
{
	int ret;

	if (!access_ok(VERIFY_WRITE, uattr, usize))
		return -EFAULT;

	/*
	 * If we're handed a smaller struct than we know of,
	 * ensure all the unknown bits are 0 - i.e. old
	 * user-space does not get uncomplete information.
	 */
	if (usize < sizeof(*attr)) {
		unsigned char *addr;
		unsigned char *end;

		addr = (void *)attr + usize;
		end  = (void *)attr + sizeof(*attr);

		for (; addr < end; addr++) {
			if (*addr)
				goto err_size;
		}

 		attr->size = usize;
 	}
 
	ret = copy_to_user(uattr, attr, attr->size);
 	if (ret)
 		return -EFAULT;
 
out:
	return ret;

err_size:
	ret = -E2BIG;
	goto out;
}
","The `sched_read_attr` function is designed to safely read scheduling attributes from user space into a kernel space structure. It first checks if the user-provided pointer is valid and writable. If the size of the user-provided structure is smaller than the expected size, it ensures that any additional bytes are zeroed out to prevent leaking uninitialized data. The function then copies the specified number of bytes from the kernel structure to the user space. If any errors occur during these operations, such as invalid memory access or size issues, appropriate error codes are returned, ensuring robust error handling.","The provided code defines a function that facilitates the safe transfer of scheduling attributes from user space to kernel space. It begins by verifying the validity and accessibility of the user-provided memory address. If the size of the incoming structure is smaller than expected, the function ensures that any extra bytes are set to zero to prevent exposure of uninitialized data. Subsequently, it copies the specified amount of data from the kernel structure to the user space. The function includes error handling to return appropriate codes for issues like invalid memory access or size discrepancies, ensuring reliable operation.","The vulnerability in the original code stemmed from copying an entire structure from the stack to user space without properly validating the size, which could inadvertently expose up to PAGE_SIZE bytes of sensitive kernel memory. This oversight allowed a malicious user to read uninitialized or adjacent kernel data. The fix addressed this issue by ensuring that only the amount of data specified by `attr->size` is copied to user space, thereby preventing any leakage of extraneous information. This change effectively safeguards against information leaks by leaving any unused portions of the user-provided buffer untouched.","The vulnerability in the original code arose from copying an entire structure from the stack to user space without correctly specifying the number of bytes to copy, which could inadvertently expose sensitive kernel memory, potentially allowing a malicious user to read up to PAGE_SIZE of data. This oversight created a significant security risk by leaking uninitialized or adjacent memory. The fix rectified this issue by ensuring that only the actual size of the structure is copied, thereby preventing any leakage of extraneous data and leaving any unused portions of the user-provided buffer untouched, thus enhancing security.","The vulnerability was fixed by modifying the code to use the `attr->size` variable when performing the copy operation to user space. Instead of copying a potentially larger amount of data, the updated code ensures that only the size specified by `attr->size` is copied using the `copy_to_user` function. This change prevents the exposure of up to PAGE_SIZE bytes of stack memory, as it limits the data transferred to what is actually valid and intended. Additionally, the fix leaves any remaining portions of the user-provided buffer untouched, further mitigating the risk of information leakage.","The vulnerability was addressed by ensuring that only the correct amount of data, as specified by the size attribute, is copied from the stack to user space. This change prevents the transfer of excess data that could potentially expose sensitive information from adjacent memory. By limiting the copy operation to the intended size, the fix effectively mitigates the risk of leaking uninitialized or extraneous data. Additionally, the update ensures that any unused portions of the user-provided buffer remain untouched, further enhancing the security of the data transfer process.","5,5","5,5","4,4","4, 4"
62,62,180791,180791,,Local,Not required,,CVE-2017-1000380,https://www.cvedetails.com/cve/CVE-2017-1000380/,CWE-200,Low,Partial,,,2017-06-17,2.1,"sound/core/timer.c in the Linux kernel before 4.11.5 is vulnerable to a data race in the ALSA /dev/snd/timer driver resulting in local users being able to read information belonging to other users, i.e., uninitialized memory contents may be disclosed when a read and an ioctl happen at the same time.",2017-12-05,+Info ,1,https://github.com/torvalds/linux/commit/ba3021b2c79b2fa9114f92790a99deb27a65b728,ba3021b2c79b2fa9114f92790a99deb27a65b728,"ALSA: timer: Fix missing queue indices reset at SNDRV_TIMER_IOCTL_SELECT

snd_timer_user_tselect() reallocates the queue buffer dynamically, but
it forgot to reset its indices.  Since the read may happen
concurrently with ioctl and snd_timer_user_tselect() allocates the
buffer via kmalloc(), this may lead to the leak of uninitialized
kernel-space data, as spotted via KMSAN:

  BUG: KMSAN: use of unitialized memory in snd_timer_user_read+0x6c4/0xa10
  CPU: 0 PID: 1037 Comm: probe Not tainted 4.11.0-rc5+ #2739
  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
  Call Trace:
   __dump_stack lib/dump_stack.c:16
   dump_stack+0x143/0x1b0 lib/dump_stack.c:52
   kmsan_report+0x12a/0x180 mm/kmsan/kmsan.c:1007
   kmsan_check_memory+0xc2/0x140 mm/kmsan/kmsan.c:1086
   copy_to_user ./arch/x86/include/asm/uaccess.h:725
   snd_timer_user_read+0x6c4/0xa10 sound/core/timer.c:2004
   do_loop_readv_writev fs/read_write.c:716
   __do_readv_writev+0x94c/0x1380 fs/read_write.c:864
   do_readv_writev fs/read_write.c:894
   vfs_readv fs/read_write.c:908
   do_readv+0x52a/0x5d0 fs/read_write.c:934
   SYSC_readv+0xb6/0xd0 fs/read_write.c:1021
   SyS_readv+0x87/0xb0 fs/read_write.c:1018

This patch adds the missing reset of queue indices.  Together with the
previous fix for the ioctl/read race, we cover the whole problem.

Reported-by: Alexander Potapenko <glider@google.com>
Tested-by: Alexander Potapenko <glider@google.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>",0,sound/core/timer.c,"{""sha"": ""cd67d1c12cf1ca9a32daa4de797dc0a5ec7bbb86"", ""filename"": ""sound/core/timer.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/ba3021b2c79b2fa9114f92790a99deb27a65b728/sound/core/timer.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ba3021b2c79b2fa9114f92790a99deb27a65b728/sound/core/timer.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/sound/core/timer.c?ref=ba3021b2c79b2fa9114f92790a99deb27a65b728"", ""patch"": ""@@ -1618,6 +1618,7 @@ static int snd_timer_user_tselect(struct file *file,\n \tif (err < 0)\n \t\tgoto __err;\n \n+\ttu->qhead = tu->qtail = tu->qused = 0;\n \tkfree(tu->queue);\n \ttu->queue = NULL;\n \tkfree(tu->tqueue);""}","static int snd_timer_user_tselect(struct file *file,
				  struct snd_timer_select __user *_tselect)
{
	struct snd_timer_user *tu;
	struct snd_timer_select tselect;
	char str[32];
	int err = 0;

	tu = file->private_data;
	if (tu->timeri) {
		snd_timer_close(tu->timeri);
		tu->timeri = NULL;
	}
	if (copy_from_user(&tselect, _tselect, sizeof(tselect))) {
		err = -EFAULT;
		goto __err;
	}
	sprintf(str, ""application %i"", current->pid);
	if (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)
		tselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;
	err = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);
 	if (err < 0)
 		goto __err;
 
	tu->qhead = tu->qtail = tu->qused = 0;
 	kfree(tu->queue);
 	tu->queue = NULL;
 	kfree(tu->tqueue);
	tu->tqueue = NULL;
	if (tu->tread) {
		tu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),
				     GFP_KERNEL);
		if (tu->tqueue == NULL)
			err = -ENOMEM;
	} else {
		tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
				    GFP_KERNEL);
		if (tu->queue == NULL)
			err = -ENOMEM;
	}

      	if (err < 0) {
		snd_timer_close(tu->timeri);
      		tu->timeri = NULL;
      	} else {
		tu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;
		tu->timeri->callback = tu->tread
			? snd_timer_user_tinterrupt : snd_timer_user_interrupt;
		tu->timeri->ccallback = snd_timer_user_ccallback;
		tu->timeri->callback_data = (void *)tu;
		tu->timeri->disconnect = snd_timer_user_disconnect;
	}

      __err:
	return err;
}
","static int snd_timer_user_tselect(struct file *file,
				  struct snd_timer_select __user *_tselect)
{
	struct snd_timer_user *tu;
	struct snd_timer_select tselect;
	char str[32];
	int err = 0;

	tu = file->private_data;
	if (tu->timeri) {
		snd_timer_close(tu->timeri);
		tu->timeri = NULL;
	}
	if (copy_from_user(&tselect, _tselect, sizeof(tselect))) {
		err = -EFAULT;
		goto __err;
	}
	sprintf(str, ""application %i"", current->pid);
	if (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)
		tselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;
	err = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);
 	if (err < 0)
 		goto __err;
 
 	kfree(tu->queue);
 	tu->queue = NULL;
 	kfree(tu->tqueue);
	tu->tqueue = NULL;
	if (tu->tread) {
		tu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),
				     GFP_KERNEL);
		if (tu->tqueue == NULL)
			err = -ENOMEM;
	} else {
		tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
				    GFP_KERNEL);
		if (tu->queue == NULL)
			err = -ENOMEM;
	}

      	if (err < 0) {
		snd_timer_close(tu->timeri);
      		tu->timeri = NULL;
      	} else {
		tu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;
		tu->timeri->callback = tu->tread
			? snd_timer_user_tinterrupt : snd_timer_user_interrupt;
		tu->timeri->ccallback = snd_timer_user_ccallback;
		tu->timeri->callback_data = (void *)tu;
		tu->timeri->disconnect = snd_timer_user_disconnect;
	}

      __err:
	return err;
}
",C,"	tu->qhead = tu->qtail = tu->qused = 0;
",,,"@@ -1618,6 +1618,7 @@ static int snd_timer_user_tselect(struct file *file,
 	if (err < 0)
 		goto __err;
 
+	tu->qhead = tu->qtail = tu->qused = 0;
 	kfree(tu->queue);
 	tu->queue = NULL;
 	kfree(tu->tqueue);",linux,ba3021b2c79b2fa9114f92790a99deb27a65b728,d11662f4f798b50d8c8743f433842c3e40fe3378,1,"static int snd_timer_user_tselect(struct file *file,
				  struct snd_timer_select __user *_tselect)
{
	struct snd_timer_user *tu;
	struct snd_timer_select tselect;
	char str[32];
	int err = 0;

	tu = file->private_data;
	if (tu->timeri) {
		snd_timer_close(tu->timeri);
		tu->timeri = NULL;
	}
	if (copy_from_user(&tselect, _tselect, sizeof(tselect))) {
		err = -EFAULT;
		goto __err;
	}
	sprintf(str, ""application %i"", current->pid);
	if (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)
		tselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;
	err = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);
 	if (err < 0)
 		goto __err;
 
//fix_flaw_line_below:
//	tu->qhead = tu->qtail = tu->qused = 0;
 	kfree(tu->queue);
 	tu->queue = NULL;
 	kfree(tu->tqueue);
	tu->tqueue = NULL;
	if (tu->tread) {
		tu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),
				     GFP_KERNEL);
		if (tu->tqueue == NULL)
			err = -ENOMEM;
	} else {
		tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
				    GFP_KERNEL);
		if (tu->queue == NULL)
			err = -ENOMEM;
	}

      	if (err < 0) {
		snd_timer_close(tu->timeri);
      		tu->timeri = NULL;
      	} else {
		tu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;
		tu->timeri->callback = tu->tread
			? snd_timer_user_tinterrupt : snd_timer_user_interrupt;
		tu->timeri->ccallback = snd_timer_user_ccallback;
		tu->timeri->callback_data = (void *)tu;
		tu->timeri->disconnect = snd_timer_user_disconnect;
	}

      __err:
	return err;
}
",180791,"static int snd_timer_user_tselect(struct file *file,
				  struct snd_timer_select __user *_tselect)
{
	struct snd_timer_user *tu;
	struct snd_timer_select tselect;
	char str[32];
	int err = 0;

	tu = file->private_data;
	if (tu->timeri) {
		snd_timer_close(tu->timeri);
		tu->timeri = NULL;
	}
	if (copy_from_user(&tselect, _tselect, sizeof(tselect))) {
		err = -EFAULT;
		goto __err;
	}
	sprintf(str, ""application %i"", current->pid);
	if (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)
		tselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;
	err = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);
 	if (err < 0)
 		goto __err;
 
 	kfree(tu->queue);
 	tu->queue = NULL;
 	kfree(tu->tqueue);
	tu->tqueue = NULL;
	if (tu->tread) {
		tu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),
				     GFP_KERNEL);
		if (tu->tqueue == NULL)
			err = -ENOMEM;
	} else {
		tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
				    GFP_KERNEL);
		if (tu->queue == NULL)
			err = -ENOMEM;
	}

      	if (err < 0) {
		snd_timer_close(tu->timeri);
      		tu->timeri = NULL;
      	} else {
		tu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;
		tu->timeri->callback = tu->tread
			? snd_timer_user_tinterrupt : snd_timer_user_interrupt;
		tu->timeri->ccallback = snd_timer_user_ccallback;
		tu->timeri->callback_data = (void *)tu;
		tu->timeri->disconnect = snd_timer_user_disconnect;
	}

      __err:
	return err;
}
","static int snd_timer_user_tselect(struct file *file,
				  struct snd_timer_select __user *_tselect)
{
	struct snd_timer_user *tu;
	struct snd_timer_select tselect;
	char str[32];
	int err = 0;

	tu = file->private_data;
	if (tu->timeri) {
		snd_timer_close(tu->timeri);
		tu->timeri = NULL;
	}
	if (copy_from_user(&tselect, _tselect, sizeof(tselect))) {
		err = -EFAULT;
		goto __err;
	}
	sprintf(str, ""application %i"", current->pid);
	if (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)
		tselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;
	err = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);
 	if (err < 0)
 		goto __err;
 
	tu->qhead = tu->qtail = tu->qused = 0;
 	kfree(tu->queue);
 	tu->queue = NULL;
 	kfree(tu->tqueue);
	tu->tqueue = NULL;
	if (tu->tread) {
		tu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),
				     GFP_KERNEL);
		if (tu->tqueue == NULL)
			err = -ENOMEM;
	} else {
		tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
				    GFP_KERNEL);
		if (tu->queue == NULL)
			err = -ENOMEM;
	}

      	if (err < 0) {
		snd_timer_close(tu->timeri);
      		tu->timeri = NULL;
      	} else {
		tu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;
		tu->timeri->callback = tu->tread
			? snd_timer_user_tinterrupt : snd_timer_user_interrupt;
		tu->timeri->ccallback = snd_timer_user_ccallback;
		tu->timeri->callback_data = (void *)tu;
		tu->timeri->disconnect = snd_timer_user_disconnect;
	}

      __err:
	return err;
}
","The `snd_timer_user_tselect` function manages the selection and initialization of a sound timer for a user-space application. It first retrieves the user-specific timer data and closes any existing timer. The function then copies timer selection parameters from user space and opens a new timer based on these parameters. It allocates memory for the timer's read and interrupt queues, handling potential memory allocation failures. If successful, it sets various callback functions for timer events and flags for the timer. In case of errors during any step, it ensures proper cleanup by closing the timer and returning an error code.","The function facilitates the management of a sound timer for a user-space application by first checking and closing any existing timer associated with the user. It then retrieves timer selection parameters from user space and attempts to open a new timer based on these parameters. Memory is allocated for the timer's read and interrupt queues, with error handling for potential allocation failures. If successful, it configures various callback functions for handling timer events and sets specific flags. In the event of any errors during the process, it ensures proper cleanup by closing the timer and returning an appropriate error code.","The vulnerability in the original code stemmed from the failure to reset the queue indices after reallocating the queue buffer, which could lead to the use of uninitialized memory during concurrent read operations. Specifically, the indices `qhead`, `qtail`, and `qused` were not set to zero after the buffer was allocated, risking exposure of stale data. The fix introduced in the updated code addresses this issue by explicitly resetting these indices to zero immediately after closing any existing timer and before allocating new memory for the queues, thereby ensuring that any subsequent reads operate on properly initialized data and preventing potential data leaks.","The vulnerability in the original code arose from the failure to reset the indices of the queue after dynamically reallocating its buffer. This oversight could lead to concurrent read operations accessing uninitialized memory, potentially exposing stale data and causing undefined behavior. The fix implemented in the updated code addresses this issue by explicitly resetting the queue indices to zero immediately after reallocating the buffer. This ensures that any subsequent read operations work with properly initialized data, thereby preventing the leakage of uninitialized kernel-space data and enhancing the overall stability and security of the system.","The vulnerability was fixed by adding a reset for the queue indices—specifically `tu->qhead`, `tu->qtail`, and `tu->qused`—to zero immediately after closing any existing timer and before allocating new memory for the queues. This change ensures that when the queue buffer is reallocated via `kmalloc()`, the indices are properly initialized, preventing any concurrent read operations from accessing uninitialized memory. By implementing this reset, the code mitigates the risk of leaking stale data, thereby enhancing the reliability and security of the timer management functionality.","The vulnerability was addressed by explicitly resetting the queue indices to zero immediately after closing any existing timer and before reallocating the queue buffer. This ensures that the indices are properly initialized following memory allocation, preventing any potential access to uninitialized memory during concurrent read operations. By implementing this reset, the code eliminates the risk of leaking stale data, thereby enhancing the overall stability and security of the system. This fix ensures that subsequent operations work with a clean state, mitigating the issues associated with uninitialized memory access.","5, 5","5,5","4,4","4, 5"
63,63,180833,180833,,Local,Not required,,CVE-2017-16994,https://www.cvedetails.com/cve/CVE-2017-16994/,CWE-200,Low,Partial,,,2017-11-27,2.1,"The walk_hugetlb_range function in mm/pagewalk.c in the Linux kernel before 4.14.2 mishandles holes in hugetlb ranges, which allows local users to obtain sensitive information from uninitialized kernel memory via crafted use of the mincore() system call.",2018-04-24,+Info ,5,https://github.com/torvalds/linux/commit/373c4557d2aa362702c4c2d41288fb1e54990b7c,373c4557d2aa362702c4c2d41288fb1e54990b7c,"mm/pagewalk.c: report holes in hugetlb ranges

This matters at least for the mincore syscall, which will otherwise copy
uninitialized memory from the page allocator to userspace.  It is
probably also a correctness error for /proc/$pid/pagemap, but I haven't
tested that.

Removing the `walk->hugetlb_entry` condition in walk_hugetlb_range() has
no effect because the caller already checks for that.

This only reports holes in hugetlb ranges to callers who have specified
a hugetlb_entry callback.

This issue was found using an AFL-based fuzzer.

v2:
 - don't crash on ->pte_hole==NULL (Andrew Morton)
 - add Cc stable (Andrew Morton)

Fixes: 1e25a271c8ac (""mincore: apply page table walker on do_mincore()"")
Signed-off-by: Jann Horn <jannh@google.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",1,mm/pagewalk.c,"{""sha"": ""23a3e415ac2ce592bc0e7e21f3deb957e89dff7f"", ""filename"": ""mm/pagewalk.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/373c4557d2aa362702c4c2d41288fb1e54990b7c/mm/pagewalk.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/373c4557d2aa362702c4c2d41288fb1e54990b7c/mm/pagewalk.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/pagewalk.c?ref=373c4557d2aa362702c4c2d41288fb1e54990b7c"", ""patch"": ""@@ -188,8 +188,12 @@ static int walk_hugetlb_range(unsigned long addr, unsigned long end,\n \tdo {\n \t\tnext = hugetlb_entry_end(h, addr, end);\n \t\tpte = huge_pte_offset(walk->mm, addr & hmask, sz);\n-\t\tif (pte && walk->hugetlb_entry)\n+\n+\t\tif (pte)\n \t\t\terr = walk->hugetlb_entry(pte, hmask, addr, next, walk);\n+\t\telse if (walk->pte_hole)\n+\t\t\terr = walk->pte_hole(addr, next, walk);\n+\n \t\tif (err)\n \t\t\tbreak;\n \t} while (addr = next, addr != end);""}","static int walk_hugetlb_range(unsigned long addr, unsigned long end,
			      struct mm_walk *walk)
{
	struct vm_area_struct *vma = walk->vma;
	struct hstate *h = hstate_vma(vma);
	unsigned long next;
	unsigned long hmask = huge_page_mask(h);
	unsigned long sz = huge_page_size(h);
	pte_t *pte;
	int err = 0;

 	do {
 		next = hugetlb_entry_end(h, addr, end);
 		pte = huge_pte_offset(walk->mm, addr & hmask, sz);

		if (pte)
 			err = walk->hugetlb_entry(pte, hmask, addr, next, walk);
		else if (walk->pte_hole)
			err = walk->pte_hole(addr, next, walk);

 		if (err)
 			break;
 	} while (addr = next, addr != end);

	return err;
}
","static int walk_hugetlb_range(unsigned long addr, unsigned long end,
			      struct mm_walk *walk)
{
	struct vm_area_struct *vma = walk->vma;
	struct hstate *h = hstate_vma(vma);
	unsigned long next;
	unsigned long hmask = huge_page_mask(h);
	unsigned long sz = huge_page_size(h);
	pte_t *pte;
	int err = 0;

 	do {
 		next = hugetlb_entry_end(h, addr, end);
 		pte = huge_pte_offset(walk->mm, addr & hmask, sz);
		if (pte && walk->hugetlb_entry)
 			err = walk->hugetlb_entry(pte, hmask, addr, next, walk);
 		if (err)
 			break;
 	} while (addr = next, addr != end);

	return err;
}
",C,"
		if (pte)
		else if (walk->pte_hole)
			err = walk->pte_hole(addr, next, walk);

","		if (pte && walk->hugetlb_entry)
",,"@@ -188,8 +188,12 @@ static int walk_hugetlb_range(unsigned long addr, unsigned long end,
 	do {
 		next = hugetlb_entry_end(h, addr, end);
 		pte = huge_pte_offset(walk->mm, addr & hmask, sz);
-		if (pte && walk->hugetlb_entry)
+
+		if (pte)
 			err = walk->hugetlb_entry(pte, hmask, addr, next, walk);
+		else if (walk->pte_hole)
+			err = walk->pte_hole(addr, next, walk);
+
 		if (err)
 			break;
 	} while (addr = next, addr != end);",linux,373c4557d2aa362702c4c2d41288fb1e54990b7c,5bbcc0f595fadb4cac0eddc4401035ec0bd95b09,1,"static int walk_hugetlb_range(unsigned long addr, unsigned long end,
			      struct mm_walk *walk)
{
	struct vm_area_struct *vma = walk->vma;
	struct hstate *h = hstate_vma(vma);
	unsigned long next;
	unsigned long hmask = huge_page_mask(h);
	unsigned long sz = huge_page_size(h);
	pte_t *pte;
	int err = 0;

 	do {
 		next = hugetlb_entry_end(h, addr, end);
 		pte = huge_pte_offset(walk->mm, addr & hmask, sz);
//flaw_line_below:
		if (pte && walk->hugetlb_entry)
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//		if (pte)
 			err = walk->hugetlb_entry(pte, hmask, addr, next, walk);
//fix_flaw_line_below:
//		else if (walk->pte_hole)
//fix_flaw_line_below:
//			err = walk->pte_hole(addr, next, walk);
//fix_flaw_line_below:
//
 		if (err)
 			break;
 	} while (addr = next, addr != end);

	return err;
}
",180833,"static int walk_hugetlb_range(unsigned long addr, unsigned long end,
			      struct mm_walk *walk)
{
	struct vm_area_struct *vma = walk->vma;
	struct hstate *h = hstate_vma(vma);
	unsigned long next;
	unsigned long hmask = huge_page_mask(h);
	unsigned long sz = huge_page_size(h);
	pte_t *pte;
	int err = 0;

 	do {
 		next = hugetlb_entry_end(h, addr, end);
 		pte = huge_pte_offset(walk->mm, addr & hmask, sz);
		if (pte && walk->hugetlb_entry)
 			err = walk->hugetlb_entry(pte, hmask, addr, next, walk);
 		if (err)
 			break;
 	} while (addr = next, addr != end);

	return err;
}
","static int walk_hugetlb_range(unsigned long addr, unsigned long end,
			      struct mm_walk *walk)
{
	struct vm_area_struct *vma = walk->vma;
	struct hstate *h = hstate_vma(vma);
	unsigned long next;
	unsigned long hmask = huge_page_mask(h);
	unsigned long sz = huge_page_size(h);
	pte_t *pte;
	int err = 0;

 	do {
 		next = hugetlb_entry_end(h, addr, end);
 		pte = huge_pte_offset(walk->mm, addr & hmask, sz);

		if (pte)
 			err = walk->hugetlb_entry(pte, hmask, addr, next, walk);
		else if (walk->pte_hole)
			err = walk->pte_hole(addr, next, walk);

 		if (err)
 			break;
 	} while (addr = next, addr != end);

	return err;
}
","The `walk_hugetlb_range` function iterates over a range of memory addresses, specifically targeting huge pages within a virtual memory area (VMA). It calculates the end of the current huge page entry and retrieves the corresponding page table entry (PTE) for the address. If a callback function (`hugetlb_entry`) is provided, it is invoked with the PTE and relevant parameters. The loop continues until the end address is reached or an error occurs during the callback execution. The function ultimately returns an error code, indicating success or failure of the operation, facilitating efficient management of huge pages in memory.","The provided code defines a function that traverses a specified range of memory addresses, focusing on large memory pages. It determines the end of the current large page segment and retrieves the associated page table entry for the current address. If a specific callback function is available, it is called with the relevant parameters to process the page entry. The traversal continues until the end of the specified range is reached or an error occurs during the callback execution. The function ultimately returns an error code to indicate whether the operation was successful or if an issue was encountered.","The vulnerability in the original code arises from the lack of handling for cases where a page table entry is absent, which could lead to uninitialized memory being copied to user space during operations like the `mincore` syscall. Specifically, if the `huge_pte_offset` function returns a null pointer, the absence of a corresponding check could result in dereferencing a null pointer, causing potential crashes or security issues. The fixed code addresses this by introducing an additional condition to check for a null pointer and invoke a separate callback for handling holes in the huge page range, ensuring that such scenarios are managed correctly and safely.","The vulnerability in the original code stems from the failure to handle scenarios where a page table entry is missing, which could lead to the exposure of uninitialized memory to user space during operations like the `mincore` syscall. This oversight could result in security risks and incorrect behavior, particularly when accessing memory mappings. The fix implemented in the updated code introduces a mechanism to check for missing entries and appropriately report these gaps, ensuring that any uninitialized memory is not inadvertently exposed. This change enhances the robustness of memory management by addressing potential crashes and correctness issues.","The vulnerability was fixed by adding a condition to check for null pointers returned by the `huge_pte_offset` function. In the updated code, if the page table entry is null, the function now calls the `walk->pte_hole` callback to handle the absence of a valid entry, ensuring that gaps in the huge page range are reported. This change prevents the dereferencing of a null pointer, which could lead to crashes or the exposure of uninitialized memory. Additionally, the removal of the condition checking for `walk->hugetlb_entry` ensures that the function can still report holes effectively to callers that specify a callback.","The vulnerability was addressed by implementing a check for missing page table entries, which ensures that the code can handle scenarios where a valid entry is not present. This fix introduces a mechanism to report gaps in the memory mapping, preventing the exposure of uninitialized memory to user space. By adding a callback for handling these gaps, the updated code avoids potential crashes and enhances the overall robustness of memory management. This change ensures that the system can safely navigate through memory ranges, maintaining correctness and security during operations that involve memory access.","4, 5","5,5","5,5","4,4"
64,64,180890,180890,,Local,Not required,,CVE-2017-15537,https://www.cvedetails.com/cve/CVE-2017-15537/,CWE-200,Low,Partial,,,2017-10-17,2.1,"The x86/fpu (Floating Point Unit) subsystem in the Linux kernel before 4.13.5, when a processor supports the xsave feature but not the xsaves feature, does not correctly handle attempts to set reserved bits in the xstate header via the ptrace() or rt_sigreturn() system call, allowing local users to read the FPU registers of other processes on the system, related to arch/x86/kernel/fpu/regset.c and arch/x86/kernel/fpu/signal.c.",2018-01-12,+Info ,4,https://github.com/torvalds/linux/commit/814fb7bb7db5433757d76f4c4502c96fc53b0b5e,814fb7bb7db5433757d76f4c4502c96fc53b0b5e,"x86/fpu: Don't let userspace set bogus xcomp_bv

On x86, userspace can use the ptrace() or rt_sigreturn() system calls to
set a task's extended state (xstate) or ""FPU"" registers.  ptrace() can
set them for another task using the PTRACE_SETREGSET request with
NT_X86_XSTATE, while rt_sigreturn() can set them for the current task.
In either case, registers can be set to any value, but the kernel
assumes that the XSAVE area itself remains valid in the sense that the
CPU can restore it.

However, in the case where the kernel is using the uncompacted xstate
format (which it does whenever the XSAVES instruction is unavailable),
it was possible for userspace to set the xcomp_bv field in the
xstate_header to an arbitrary value.  However, all bits in that field
are reserved in the uncompacted case, so when switching to a task with
nonzero xcomp_bv, the XRSTOR instruction failed with a #GP fault.  This
caused the WARN_ON_FPU(err) in copy_kernel_to_xregs() to be hit.  In
addition, since the error is otherwise ignored, the FPU registers from
the task previously executing on the CPU were leaked.

Fix the bug by checking that the user-supplied value of xcomp_bv is 0 in
the uncompacted case, and returning an error otherwise.

The reason for validating xcomp_bv rather than simply overwriting it
with 0 is that we want userspace to see an error if it (incorrectly)
provides an XSAVE area in compacted format rather than in uncompacted
format.

Note that as before, in case of error we clear the task's FPU state.
This is perhaps non-ideal, especially for PTRACE_SETREGSET; it might be
better to return an error before changing anything.  But it seems the
""clear on error"" behavior is fine for now, and it's a little tricky to
do otherwise because it would mean we couldn't simply copy the full
userspace state into kernel memory in one __copy_from_user().

This bug was found by syzkaller, which hit the above-mentioned
WARN_ON_FPU():

    WARNING: CPU: 1 PID: 0 at ./arch/x86/include/asm/fpu/internal.h:373 __switch_to+0x5b5/0x5d0
    CPU: 1 PID: 0 Comm: swapper/1 Not tainted 4.13.0 #453
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
    task: ffff9ba2bc8e42c0 task.stack: ffffa78cc036c000
    RIP: 0010:__switch_to+0x5b5/0x5d0
    RSP: 0000:ffffa78cc08bbb88 EFLAGS: 00010082
    RAX: 00000000fffffffe RBX: ffff9ba2b8bf2180 RCX: 00000000c0000100
    RDX: 00000000ffffffff RSI: 000000005cb10700 RDI: ffff9ba2b8bf36c0
    RBP: ffffa78cc08bbbd0 R08: 00000000929fdf46 R09: 0000000000000001
    R10: 0000000000000000 R11: 0000000000000000 R12: ffff9ba2bc8e42c0
    R13: 0000000000000000 R14: ffff9ba2b8bf3680 R15: ffff9ba2bf5d7b40
    FS:  00007f7e5cb10700(0000) GS:ffff9ba2bf400000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00000000004005cc CR3: 0000000079fd5000 CR4: 00000000001406e0
    Call Trace:
    Code: 84 00 00 00 00 00 e9 11 fd ff ff 0f ff 66 0f 1f 84 00 00 00 00 00 e9 e7 fa ff ff 0f ff 66 0f 1f 84 00 00 00 00 00 e9 c2 fa ff ff <0f> ff 66 0f 1f 84 00 00 00 00 00 e9 d4 fc ff ff 66 66 2e 0f 1f

Here is a C reproducer.  The expected behavior is that the program spin
forever with no output.  However, on a buggy kernel running on a
processor with the ""xsave"" feature but without the ""xsaves"" feature
(e.g. Sandy Bridge through Broadwell for Intel), within a second or two
the program reports that the xmm registers were corrupted, i.e. were not
restored correctly.  With CONFIG_X86_DEBUG_FPU=y it also hits the above
kernel warning.

    #define _GNU_SOURCE
    #include <stdbool.h>
    #include <inttypes.h>
    #include <linux/elf.h>
    #include <stdio.h>
    #include <sys/ptrace.h>
    #include <sys/uio.h>
    #include <sys/wait.h>
    #include <unistd.h>

    int main(void)
    {
        int pid = fork();
        uint64_t xstate[512];
        struct iovec iov = { .iov_base = xstate, .iov_len = sizeof(xstate) };

        if (pid == 0) {
            bool tracee = true;
            for (int i = 0; i < sysconf(_SC_NPROCESSORS_ONLN) && tracee; i++)
                tracee = (fork() != 0);
            uint32_t xmm0[4] = { [0 ... 3] = tracee ? 0x00000000 : 0xDEADBEEF };
            asm volatile(""   movdqu %0, %%xmm0\n""
                         ""   mov %0, %%rbx\n""
                         ""1: movdqu %%xmm0, %0\n""
                         ""   mov %0, %%rax\n""
                         ""   cmp %%rax, %%rbx\n""
                         ""   je 1b\n""
                         : ""+m"" (xmm0) : : ""rax"", ""rbx"", ""xmm0"");
            printf(""BUG: xmm registers corrupted!  tracee=%d, xmm0=%08X%08X%08X%08X\n"",
                   tracee, xmm0[0], xmm0[1], xmm0[2], xmm0[3]);
        } else {
            usleep(100000);
            ptrace(PTRACE_ATTACH, pid, 0, 0);
            wait(NULL);
            ptrace(PTRACE_GETREGSET, pid, NT_X86_XSTATE, &iov);
            xstate[65] = -1;
            ptrace(PTRACE_SETREGSET, pid, NT_X86_XSTATE, &iov);
            ptrace(PTRACE_CONT, pid, 0, 0);
            wait(NULL);
        }
        return 1;
    }

Note: the program only tests for the bug using the ptrace() system call.
The bug can also be reproduced using the rt_sigreturn() system call, but
only when called from a 32-bit program, since for 64-bit programs the
kernel restores the FPU state from the signal frame by doing XRSTOR
directly from userspace memory (with proper error checking).

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: Eric Biggers <ebiggers@google.com>
Reviewed-by: Kees Cook <keescook@chromium.org>
Reviewed-by: Rik van Riel <riel@redhat.com>
Acked-by: Dave Hansen <dave.hansen@linux.intel.com>
Cc: <stable@vger.kernel.org> [v3.17+]
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Andy Lutomirski <luto@amacapital.net>
Cc: Andy Lutomirski <luto@kernel.org>
Cc: Borislav Petkov <bp@alien8.de>
Cc: Eric Biggers <ebiggers3@gmail.com>
Cc: Fenghua Yu <fenghua.yu@intel.com>
Cc: Kevin Hao <haokexin@gmail.com>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Michael Halcrow <mhalcrow@google.com>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Thomas Gleixner <tglx@linutronix.de>
Cc: Wanpeng Li <wanpeng.li@hotmail.com>
Cc: Yu-cheng Yu <yu-cheng.yu@intel.com>
Cc: kernel-hardening@lists.openwall.com
Fixes: 0b29643a5843 (""x86/xsaves: Change compacted format xsave area header"")
Link: http://lkml.kernel.org/r/20170922174156.16780-2-ebiggers3@gmail.com
Link: http://lkml.kernel.org/r/20170923130016.21448-25-mingo@kernel.org
Signed-off-by: Ingo Molnar <mingo@kernel.org>",0,arch/x86/kernel/fpu/regset.c,"{""sha"": ""c764f74053223def07d73504dae4bd5426ec13ee"", ""filename"": ""arch/x86/kernel/fpu/regset.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/814fb7bb7db5433757d76f4c4502c96fc53b0b5e/arch/x86/kernel/fpu/regset.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/814fb7bb7db5433757d76f4c4502c96fc53b0b5e/arch/x86/kernel/fpu/regset.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kernel/fpu/regset.c?ref=814fb7bb7db5433757d76f4c4502c96fc53b0b5e"", ""patch"": ""@@ -141,6 +141,10 @@ int xstateregs_set(struct task_struct *target, const struct user_regset *regset,\n \t\t\tret = copy_user_to_xstate(xsave, ubuf);\n \t} else {\n \t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);\n+\n+\t\t/* xcomp_bv must be 0 when using uncompacted format */\n+\t\tif (!ret && xsave->header.xcomp_bv)\n+\t\t\tret = -EINVAL;\n \t}\n \n \t/*""}<_**next**_>{""sha"": ""da68ea1c3a44204d452b4b41a9477de93b894aab"", ""filename"": ""arch/x86/kernel/fpu/signal.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 2, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/814fb7bb7db5433757d76f4c4502c96fc53b0b5e/arch/x86/kernel/fpu/signal.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/814fb7bb7db5433757d76f4c4502c96fc53b0b5e/arch/x86/kernel/fpu/signal.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kernel/fpu/signal.c?ref=814fb7bb7db5433757d76f4c4502c96fc53b0b5e"", ""patch"": ""@@ -324,11 +324,16 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)\n \t\t */\n \t\tfpu__drop(fpu);\n \n-\t\tif (using_compacted_format())\n+\t\tif (using_compacted_format()) {\n \t\t\terr = copy_user_to_xstate(&fpu->state.xsave, buf_fx);\n-\t\telse\n+\t\t} else {\n \t\t\terr = __copy_from_user(&fpu->state.xsave, buf_fx, state_size);\n \n+\t\t\t/* xcomp_bv must be 0 when using uncompacted format */\n+\t\t\tif (!err && state_size > offsetof(struct xregs_state, header) && fpu->state.xsave.header.xcomp_bv)\n+\t\t\t\terr = -EINVAL;\n+\t\t}\n+\n \t\tif (err || __copy_from_user(&env, buf, sizeof(env))) {\n \t\t\tfpstate_init(&fpu->state);\n \t\t\ttrace_x86_fpu_init_state(fpu);""}","int xstateregs_set(struct task_struct *target, const struct user_regset *regset,
		  unsigned int pos, unsigned int count,
		  const void *kbuf, const void __user *ubuf)
{
	struct fpu *fpu = &target->thread.fpu;
	struct xregs_state *xsave;
	int ret;

	if (!boot_cpu_has(X86_FEATURE_XSAVE))
		return -ENODEV;

	/*
	 * A whole standard-format XSAVE buffer is needed:
	 */
	if ((pos != 0) || (count < fpu_user_xstate_size))
		return -EFAULT;

	xsave = &fpu->state.xsave;

	fpu__activate_fpstate_write(fpu);

	if (boot_cpu_has(X86_FEATURE_XSAVES)) {
		if (kbuf)
			ret = copy_kernel_to_xstate(xsave, kbuf);
		else
 			ret = copy_user_to_xstate(xsave, ubuf);
 	} else {
 		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);

		/* xcomp_bv must be 0 when using uncompacted format */
		if (!ret && xsave->header.xcomp_bv)
			ret = -EINVAL;
 	}
 
 	/*
	 * In case of failure, mark all states as init:
	 */
	if (ret)
		fpstate_init(&fpu->state);

	/*
	 * mxcsr reserved bits must be masked to zero for security reasons.
	 */
	xsave->i387.mxcsr &= mxcsr_feature_mask;
	xsave->header.xfeatures &= xfeatures_mask;
	/*
	 * These bits must be zero.
	 */
	memset(&xsave->header.reserved, 0, 48);

	return ret;
}
","int xstateregs_set(struct task_struct *target, const struct user_regset *regset,
		  unsigned int pos, unsigned int count,
		  const void *kbuf, const void __user *ubuf)
{
	struct fpu *fpu = &target->thread.fpu;
	struct xregs_state *xsave;
	int ret;

	if (!boot_cpu_has(X86_FEATURE_XSAVE))
		return -ENODEV;

	/*
	 * A whole standard-format XSAVE buffer is needed:
	 */
	if ((pos != 0) || (count < fpu_user_xstate_size))
		return -EFAULT;

	xsave = &fpu->state.xsave;

	fpu__activate_fpstate_write(fpu);

	if (boot_cpu_has(X86_FEATURE_XSAVES)) {
		if (kbuf)
			ret = copy_kernel_to_xstate(xsave, kbuf);
		else
 			ret = copy_user_to_xstate(xsave, ubuf);
 	} else {
 		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);
 	}
 
 	/*
	 * In case of failure, mark all states as init:
	 */
	if (ret)
		fpstate_init(&fpu->state);

	/*
	 * mxcsr reserved bits must be masked to zero for security reasons.
	 */
	xsave->i387.mxcsr &= mxcsr_feature_mask;
	xsave->header.xfeatures &= xfeatures_mask;
	/*
	 * These bits must be zero.
	 */
	memset(&xsave->header.reserved, 0, 48);

	return ret;
}
",C,"
		/* xcomp_bv must be 0 when using uncompacted format */
		if (!ret && xsave->header.xcomp_bv)
			ret = -EINVAL;
",,,"@@ -141,6 +141,10 @@ int xstateregs_set(struct task_struct *target, const struct user_regset *regset,
 			ret = copy_user_to_xstate(xsave, ubuf);
 	} else {
 		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);
+
+		/* xcomp_bv must be 0 when using uncompacted format */
+		if (!ret && xsave->header.xcomp_bv)
+			ret = -EINVAL;
 	}
 
 	/*",linux,814fb7bb7db5433757d76f4c4502c96fc53b0b5e,03eaec81ac09814817e9f0307d572ffe8365f980,1,"int xstateregs_set(struct task_struct *target, const struct user_regset *regset,
		  unsigned int pos, unsigned int count,
		  const void *kbuf, const void __user *ubuf)
{
	struct fpu *fpu = &target->thread.fpu;
	struct xregs_state *xsave;
	int ret;

	if (!boot_cpu_has(X86_FEATURE_XSAVE))
		return -ENODEV;

	/*
	 * A whole standard-format XSAVE buffer is needed:
	 */
	if ((pos != 0) || (count < fpu_user_xstate_size))
		return -EFAULT;

	xsave = &fpu->state.xsave;

	fpu__activate_fpstate_write(fpu);

	if (boot_cpu_has(X86_FEATURE_XSAVES)) {
		if (kbuf)
			ret = copy_kernel_to_xstate(xsave, kbuf);
		else
 			ret = copy_user_to_xstate(xsave, ubuf);
 	} else {
 		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//		/* xcomp_bv must be 0 when using uncompacted format */
//fix_flaw_line_below:
//		if (!ret && xsave->header.xcomp_bv)
//fix_flaw_line_below:
//			ret = -EINVAL;
 	}
 
 	/*
	 * In case of failure, mark all states as init:
	 */
	if (ret)
		fpstate_init(&fpu->state);

	/*
	 * mxcsr reserved bits must be masked to zero for security reasons.
	 */
	xsave->i387.mxcsr &= mxcsr_feature_mask;
	xsave->header.xfeatures &= xfeatures_mask;
	/*
	 * These bits must be zero.
	 */
	memset(&xsave->header.reserved, 0, 48);

	return ret;
}
",180890,"int xstateregs_set(struct task_struct *target, const struct user_regset *regset,
		  unsigned int pos, unsigned int count,
		  const void *kbuf, const void __user *ubuf)
{
	struct fpu *fpu = &target->thread.fpu;
	struct xregs_state *xsave;
	int ret;

	if (!boot_cpu_has(X86_FEATURE_XSAVE))
		return -ENODEV;

	/*
	 * A whole standard-format XSAVE buffer is needed:
	 */
	if ((pos != 0) || (count < fpu_user_xstate_size))
		return -EFAULT;

	xsave = &fpu->state.xsave;

	fpu__activate_fpstate_write(fpu);

	if (boot_cpu_has(X86_FEATURE_XSAVES)) {
		if (kbuf)
			ret = copy_kernel_to_xstate(xsave, kbuf);
		else
 			ret = copy_user_to_xstate(xsave, ubuf);
 	} else {
 		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);
 	}
 
 	/*
	 * In case of failure, mark all states as init:
	 */
	if (ret)
		fpstate_init(&fpu->state);

	/*
	 * mxcsr reserved bits must be masked to zero for security reasons.
	 */
	xsave->i387.mxcsr &= mxcsr_feature_mask;
	xsave->header.xfeatures &= xfeatures_mask;
	/*
	 * These bits must be zero.
	 */
	memset(&xsave->header.reserved, 0, 48);

	return ret;
}
","int xstateregs_set(struct task_struct *target, const struct user_regset *regset,
		  unsigned int pos, unsigned int count,
		  const void *kbuf, const void __user *ubuf)
{
	struct fpu *fpu = &target->thread.fpu;
	struct xregs_state *xsave;
	int ret;

	if (!boot_cpu_has(X86_FEATURE_XSAVE))
		return -ENODEV;

	/*
	 * A whole standard-format XSAVE buffer is needed:
	 */
	if ((pos != 0) || (count < fpu_user_xstate_size))
		return -EFAULT;

	xsave = &fpu->state.xsave;

	fpu__activate_fpstate_write(fpu);

	if (boot_cpu_has(X86_FEATURE_XSAVES)) {
		if (kbuf)
			ret = copy_kernel_to_xstate(xsave, kbuf);
		else
 			ret = copy_user_to_xstate(xsave, ubuf);
 	} else {
 		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);

		/* xcomp_bv must be 0 when using uncompacted format */
		if (!ret && xsave->header.xcomp_bv)
			ret = -EINVAL;
 	}
 
 	/*
	 * In case of failure, mark all states as init:
	 */
	if (ret)
		fpstate_init(&fpu->state);

	/*
	 * mxcsr reserved bits must be masked to zero for security reasons.
	 */
	xsave->i387.mxcsr &= mxcsr_feature_mask;
	xsave->header.xfeatures &= xfeatures_mask;
	/*
	 * These bits must be zero.
	 */
	memset(&xsave->header.reserved, 0, 48);

	return ret;
}
","The `xstateregs_set` function is designed to set the extended state registers of a specified task in a Linux kernel environment, specifically for tasks utilizing the x86 architecture with XSAVE support. It first checks if the CPU supports the XSAVE feature; if not, it returns an error. The function requires a complete XSAVE buffer and validates the input parameters. Depending on the CPU's capabilities, it either copies data from a kernel buffer or a user buffer into the task's xstate structure. In case of an error during the copy operation, it initializes the floating-point state. Finally, it ensures that certain reserved bits are cleared for security.","The provided code defines a function that updates the extended state registers of a specified task in a Linux kernel environment, specifically for x86 architecture with support for advanced state management features. It first verifies the availability of necessary CPU features and checks that the input parameters meet specific criteria. The function then copies data from either a kernel or user buffer into the task's state structure, depending on the CPU's capabilities. If any errors occur during this process, it resets the floating-point state. Additionally, it ensures that certain reserved bits are cleared for security purposes.","The vulnerability in the original code allowed userspace to set the `xcomp_bv` field in the xstate header to arbitrary values when using the uncompacted xstate format, which could lead to a general protection fault during the execution of the XRSTOR instruction. This occurred because the kernel assumed that the xstate area was valid, but nonzero values in `xcomp_bv` were reserved and caused the system to crash, potentially leaking FPU register states. The fix introduced a validation check to ensure that `xcomp_bv` is zero in the uncompacted case, returning an error if it is not, thus preventing the execution of invalid states and enhancing system stability.","The vulnerability in the original code allowed userspace to set a specific field in the extended state header to arbitrary values when using an uncompacted format, which could lead to a system crash during the restoration of the floating-point state. This occurred because the kernel did not validate the value of this field, resulting in a general protection fault when the system attempted to switch to a task with an invalid state. The fix introduced a validation check to ensure that this field is zero in the uncompacted case, returning an error if it is not, thereby preventing the execution of invalid states and enhancing system stability.","The vulnerability was fixed by adding a validation check for the `xcomp_bv` field in the xstate header within the `user_regset_copyin` function. Specifically, after copying the user-supplied state, the code now checks if `xsave->header.xcomp_bv` is non-zero when using the uncompacted format. If it is non-zero, the function sets the return value to an error code, preventing the execution of invalid states. This ensures that userspace cannot set the `xcomp_bv` field to an arbitrary value, thus avoiding potential crashes and maintaining the integrity of the floating-point state during task switching.","The vulnerability was addressed by implementing a validation check to ensure that a specific field in the extended state header is set to zero when using the uncompacted format. This check occurs after the user-supplied state is copied, and if the field is found to be non-zero, an error code is returned. This prevents userspace from providing invalid values that could lead to system crashes during the restoration of the floating-point state. By enforcing this validation, the fix enhances system stability and protects against potential exploitation through improper state manipulation.","4,4","5,5","4,4","5,5"
65,65,180891,180891,,Local,Not required,,CVE-2017-15537,https://www.cvedetails.com/cve/CVE-2017-15537/,CWE-200,Low,Partial,,,2017-10-17,2.1,"The x86/fpu (Floating Point Unit) subsystem in the Linux kernel before 4.13.5, when a processor supports the xsave feature but not the xsaves feature, does not correctly handle attempts to set reserved bits in the xstate header via the ptrace() or rt_sigreturn() system call, allowing local users to read the FPU registers of other processes on the system, related to arch/x86/kernel/fpu/regset.c and arch/x86/kernel/fpu/signal.c.",2018-01-12,+Info ,7,https://github.com/torvalds/linux/commit/814fb7bb7db5433757d76f4c4502c96fc53b0b5e,814fb7bb7db5433757d76f4c4502c96fc53b0b5e,"x86/fpu: Don't let userspace set bogus xcomp_bv

On x86, userspace can use the ptrace() or rt_sigreturn() system calls to
set a task's extended state (xstate) or ""FPU"" registers.  ptrace() can
set them for another task using the PTRACE_SETREGSET request with
NT_X86_XSTATE, while rt_sigreturn() can set them for the current task.
In either case, registers can be set to any value, but the kernel
assumes that the XSAVE area itself remains valid in the sense that the
CPU can restore it.

However, in the case where the kernel is using the uncompacted xstate
format (which it does whenever the XSAVES instruction is unavailable),
it was possible for userspace to set the xcomp_bv field in the
xstate_header to an arbitrary value.  However, all bits in that field
are reserved in the uncompacted case, so when switching to a task with
nonzero xcomp_bv, the XRSTOR instruction failed with a #GP fault.  This
caused the WARN_ON_FPU(err) in copy_kernel_to_xregs() to be hit.  In
addition, since the error is otherwise ignored, the FPU registers from
the task previously executing on the CPU were leaked.

Fix the bug by checking that the user-supplied value of xcomp_bv is 0 in
the uncompacted case, and returning an error otherwise.

The reason for validating xcomp_bv rather than simply overwriting it
with 0 is that we want userspace to see an error if it (incorrectly)
provides an XSAVE area in compacted format rather than in uncompacted
format.

Note that as before, in case of error we clear the task's FPU state.
This is perhaps non-ideal, especially for PTRACE_SETREGSET; it might be
better to return an error before changing anything.  But it seems the
""clear on error"" behavior is fine for now, and it's a little tricky to
do otherwise because it would mean we couldn't simply copy the full
userspace state into kernel memory in one __copy_from_user().

This bug was found by syzkaller, which hit the above-mentioned
WARN_ON_FPU():

    WARNING: CPU: 1 PID: 0 at ./arch/x86/include/asm/fpu/internal.h:373 __switch_to+0x5b5/0x5d0
    CPU: 1 PID: 0 Comm: swapper/1 Not tainted 4.13.0 #453
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
    task: ffff9ba2bc8e42c0 task.stack: ffffa78cc036c000
    RIP: 0010:__switch_to+0x5b5/0x5d0
    RSP: 0000:ffffa78cc08bbb88 EFLAGS: 00010082
    RAX: 00000000fffffffe RBX: ffff9ba2b8bf2180 RCX: 00000000c0000100
    RDX: 00000000ffffffff RSI: 000000005cb10700 RDI: ffff9ba2b8bf36c0
    RBP: ffffa78cc08bbbd0 R08: 00000000929fdf46 R09: 0000000000000001
    R10: 0000000000000000 R11: 0000000000000000 R12: ffff9ba2bc8e42c0
    R13: 0000000000000000 R14: ffff9ba2b8bf3680 R15: ffff9ba2bf5d7b40
    FS:  00007f7e5cb10700(0000) GS:ffff9ba2bf400000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00000000004005cc CR3: 0000000079fd5000 CR4: 00000000001406e0
    Call Trace:
    Code: 84 00 00 00 00 00 e9 11 fd ff ff 0f ff 66 0f 1f 84 00 00 00 00 00 e9 e7 fa ff ff 0f ff 66 0f 1f 84 00 00 00 00 00 e9 c2 fa ff ff <0f> ff 66 0f 1f 84 00 00 00 00 00 e9 d4 fc ff ff 66 66 2e 0f 1f

Here is a C reproducer.  The expected behavior is that the program spin
forever with no output.  However, on a buggy kernel running on a
processor with the ""xsave"" feature but without the ""xsaves"" feature
(e.g. Sandy Bridge through Broadwell for Intel), within a second or two
the program reports that the xmm registers were corrupted, i.e. were not
restored correctly.  With CONFIG_X86_DEBUG_FPU=y it also hits the above
kernel warning.

    #define _GNU_SOURCE
    #include <stdbool.h>
    #include <inttypes.h>
    #include <linux/elf.h>
    #include <stdio.h>
    #include <sys/ptrace.h>
    #include <sys/uio.h>
    #include <sys/wait.h>
    #include <unistd.h>

    int main(void)
    {
        int pid = fork();
        uint64_t xstate[512];
        struct iovec iov = { .iov_base = xstate, .iov_len = sizeof(xstate) };

        if (pid == 0) {
            bool tracee = true;
            for (int i = 0; i < sysconf(_SC_NPROCESSORS_ONLN) && tracee; i++)
                tracee = (fork() != 0);
            uint32_t xmm0[4] = { [0 ... 3] = tracee ? 0x00000000 : 0xDEADBEEF };
            asm volatile(""   movdqu %0, %%xmm0\n""
                         ""   mov %0, %%rbx\n""
                         ""1: movdqu %%xmm0, %0\n""
                         ""   mov %0, %%rax\n""
                         ""   cmp %%rax, %%rbx\n""
                         ""   je 1b\n""
                         : ""+m"" (xmm0) : : ""rax"", ""rbx"", ""xmm0"");
            printf(""BUG: xmm registers corrupted!  tracee=%d, xmm0=%08X%08X%08X%08X\n"",
                   tracee, xmm0[0], xmm0[1], xmm0[2], xmm0[3]);
        } else {
            usleep(100000);
            ptrace(PTRACE_ATTACH, pid, 0, 0);
            wait(NULL);
            ptrace(PTRACE_GETREGSET, pid, NT_X86_XSTATE, &iov);
            xstate[65] = -1;
            ptrace(PTRACE_SETREGSET, pid, NT_X86_XSTATE, &iov);
            ptrace(PTRACE_CONT, pid, 0, 0);
            wait(NULL);
        }
        return 1;
    }

Note: the program only tests for the bug using the ptrace() system call.
The bug can also be reproduced using the rt_sigreturn() system call, but
only when called from a 32-bit program, since for 64-bit programs the
kernel restores the FPU state from the signal frame by doing XRSTOR
directly from userspace memory (with proper error checking).

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: Eric Biggers <ebiggers@google.com>
Reviewed-by: Kees Cook <keescook@chromium.org>
Reviewed-by: Rik van Riel <riel@redhat.com>
Acked-by: Dave Hansen <dave.hansen@linux.intel.com>
Cc: <stable@vger.kernel.org> [v3.17+]
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Andy Lutomirski <luto@amacapital.net>
Cc: Andy Lutomirski <luto@kernel.org>
Cc: Borislav Petkov <bp@alien8.de>
Cc: Eric Biggers <ebiggers3@gmail.com>
Cc: Fenghua Yu <fenghua.yu@intel.com>
Cc: Kevin Hao <haokexin@gmail.com>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Michael Halcrow <mhalcrow@google.com>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Thomas Gleixner <tglx@linutronix.de>
Cc: Wanpeng Li <wanpeng.li@hotmail.com>
Cc: Yu-cheng Yu <yu-cheng.yu@intel.com>
Cc: kernel-hardening@lists.openwall.com
Fixes: 0b29643a5843 (""x86/xsaves: Change compacted format xsave area header"")
Link: http://lkml.kernel.org/r/20170922174156.16780-2-ebiggers3@gmail.com
Link: http://lkml.kernel.org/r/20170923130016.21448-25-mingo@kernel.org
Signed-off-by: Ingo Molnar <mingo@kernel.org>",2,arch/x86/kernel/fpu/signal.c,"{""sha"": ""c764f74053223def07d73504dae4bd5426ec13ee"", ""filename"": ""arch/x86/kernel/fpu/regset.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/814fb7bb7db5433757d76f4c4502c96fc53b0b5e/arch/x86/kernel/fpu/regset.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/814fb7bb7db5433757d76f4c4502c96fc53b0b5e/arch/x86/kernel/fpu/regset.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kernel/fpu/regset.c?ref=814fb7bb7db5433757d76f4c4502c96fc53b0b5e"", ""patch"": ""@@ -141,6 +141,10 @@ int xstateregs_set(struct task_struct *target, const struct user_regset *regset,\n \t\t\tret = copy_user_to_xstate(xsave, ubuf);\n \t} else {\n \t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);\n+\n+\t\t/* xcomp_bv must be 0 when using uncompacted format */\n+\t\tif (!ret && xsave->header.xcomp_bv)\n+\t\t\tret = -EINVAL;\n \t}\n \n \t/*""}<_**next**_>{""sha"": ""da68ea1c3a44204d452b4b41a9477de93b894aab"", ""filename"": ""arch/x86/kernel/fpu/signal.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 2, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/814fb7bb7db5433757d76f4c4502c96fc53b0b5e/arch/x86/kernel/fpu/signal.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/814fb7bb7db5433757d76f4c4502c96fc53b0b5e/arch/x86/kernel/fpu/signal.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kernel/fpu/signal.c?ref=814fb7bb7db5433757d76f4c4502c96fc53b0b5e"", ""patch"": ""@@ -324,11 +324,16 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)\n \t\t */\n \t\tfpu__drop(fpu);\n \n-\t\tif (using_compacted_format())\n+\t\tif (using_compacted_format()) {\n \t\t\terr = copy_user_to_xstate(&fpu->state.xsave, buf_fx);\n-\t\telse\n+\t\t} else {\n \t\t\terr = __copy_from_user(&fpu->state.xsave, buf_fx, state_size);\n \n+\t\t\t/* xcomp_bv must be 0 when using uncompacted format */\n+\t\t\tif (!err && state_size > offsetof(struct xregs_state, header) && fpu->state.xsave.header.xcomp_bv)\n+\t\t\t\terr = -EINVAL;\n+\t\t}\n+\n \t\tif (err || __copy_from_user(&env, buf, sizeof(env))) {\n \t\t\tfpstate_init(&fpu->state);\n \t\t\ttrace_x86_fpu_init_state(fpu);""}","static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
{
	int ia32_fxstate = (buf != buf_fx);
	struct task_struct *tsk = current;
	struct fpu *fpu = &tsk->thread.fpu;
	int state_size = fpu_kernel_xstate_size;
	u64 xfeatures = 0;
	int fx_only = 0;

	ia32_fxstate &= (IS_ENABLED(CONFIG_X86_32) ||
			 IS_ENABLED(CONFIG_IA32_EMULATION));

	if (!buf) {
		fpu__clear(fpu);
		return 0;
	}

	if (!access_ok(VERIFY_READ, buf, size))
		return -EACCES;

	fpu__activate_curr(fpu);

	if (!static_cpu_has(X86_FEATURE_FPU))
		return fpregs_soft_set(current, NULL,
				       0, sizeof(struct user_i387_ia32_struct),
				       NULL, buf) != 0;

	if (use_xsave()) {
		struct _fpx_sw_bytes fx_sw_user;
		if (unlikely(check_for_xstate(buf_fx, buf_fx, &fx_sw_user))) {
			/*
			 * Couldn't find the extended state information in the
			 * memory layout. Restore just the FP/SSE and init all
			 * the other extended state.
			 */
			state_size = sizeof(struct fxregs_state);
			fx_only = 1;
			trace_x86_fpu_xstate_check_failed(fpu);
		} else {
			state_size = fx_sw_user.xstate_size;
			xfeatures = fx_sw_user.xfeatures;
		}
	}

	if (ia32_fxstate) {
		/*
		 * For 32-bit frames with fxstate, copy the user state to the
		 * thread's fpu state, reconstruct fxstate from the fsave
		 * header. Sanitize the copied state etc.
		 */
		struct fpu *fpu = &tsk->thread.fpu;
		struct user_i387_ia32_struct env;
		int err = 0;

		/*
		 * Drop the current fpu which clears fpu->fpstate_active. This ensures
		 * that any context-switch during the copy of the new state,
		 * avoids the intermediate state from getting restored/saved.
		 * Thus avoiding the new restored state from getting corrupted.
		 * We will be ready to restore/save the state only after
		 * fpu->fpstate_active is again set.
 		 */
 		fpu__drop(fpu);
 
		if (using_compacted_format()) {
 			err = copy_user_to_xstate(&fpu->state.xsave, buf_fx);
		} else {
 			err = __copy_from_user(&fpu->state.xsave, buf_fx, state_size);
 
			/* xcomp_bv must be 0 when using uncompacted format */
			if (!err && state_size > offsetof(struct xregs_state, header) && fpu->state.xsave.header.xcomp_bv)
				err = -EINVAL;
		}

 		if (err || __copy_from_user(&env, buf, sizeof(env))) {
 			fpstate_init(&fpu->state);
 			trace_x86_fpu_init_state(fpu);
			err = -1;
		} else {
			sanitize_restored_xstate(tsk, &env, xfeatures, fx_only);
		}

		fpu->fpstate_active = 1;
		preempt_disable();
		fpu__restore(fpu);
		preempt_enable();

		return err;
	} else {
		/*
		 * For 64-bit frames and 32-bit fsave frames, restore the user
		 * state to the registers directly (with exceptions handled).
		 */
		user_fpu_begin();
		if (copy_user_to_fpregs_zeroing(buf_fx, xfeatures, fx_only)) {
			fpu__clear(fpu);
			return -1;
		}
	}

	return 0;
}
","static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
{
	int ia32_fxstate = (buf != buf_fx);
	struct task_struct *tsk = current;
	struct fpu *fpu = &tsk->thread.fpu;
	int state_size = fpu_kernel_xstate_size;
	u64 xfeatures = 0;
	int fx_only = 0;

	ia32_fxstate &= (IS_ENABLED(CONFIG_X86_32) ||
			 IS_ENABLED(CONFIG_IA32_EMULATION));

	if (!buf) {
		fpu__clear(fpu);
		return 0;
	}

	if (!access_ok(VERIFY_READ, buf, size))
		return -EACCES;

	fpu__activate_curr(fpu);

	if (!static_cpu_has(X86_FEATURE_FPU))
		return fpregs_soft_set(current, NULL,
				       0, sizeof(struct user_i387_ia32_struct),
				       NULL, buf) != 0;

	if (use_xsave()) {
		struct _fpx_sw_bytes fx_sw_user;
		if (unlikely(check_for_xstate(buf_fx, buf_fx, &fx_sw_user))) {
			/*
			 * Couldn't find the extended state information in the
			 * memory layout. Restore just the FP/SSE and init all
			 * the other extended state.
			 */
			state_size = sizeof(struct fxregs_state);
			fx_only = 1;
			trace_x86_fpu_xstate_check_failed(fpu);
		} else {
			state_size = fx_sw_user.xstate_size;
			xfeatures = fx_sw_user.xfeatures;
		}
	}

	if (ia32_fxstate) {
		/*
		 * For 32-bit frames with fxstate, copy the user state to the
		 * thread's fpu state, reconstruct fxstate from the fsave
		 * header. Sanitize the copied state etc.
		 */
		struct fpu *fpu = &tsk->thread.fpu;
		struct user_i387_ia32_struct env;
		int err = 0;

		/*
		 * Drop the current fpu which clears fpu->fpstate_active. This ensures
		 * that any context-switch during the copy of the new state,
		 * avoids the intermediate state from getting restored/saved.
		 * Thus avoiding the new restored state from getting corrupted.
		 * We will be ready to restore/save the state only after
		 * fpu->fpstate_active is again set.
 		 */
 		fpu__drop(fpu);
 
		if (using_compacted_format())
 			err = copy_user_to_xstate(&fpu->state.xsave, buf_fx);
		else
 			err = __copy_from_user(&fpu->state.xsave, buf_fx, state_size);
 
 		if (err || __copy_from_user(&env, buf, sizeof(env))) {
 			fpstate_init(&fpu->state);
 			trace_x86_fpu_init_state(fpu);
			err = -1;
		} else {
			sanitize_restored_xstate(tsk, &env, xfeatures, fx_only);
		}

		fpu->fpstate_active = 1;
		preempt_disable();
		fpu__restore(fpu);
		preempt_enable();

		return err;
	} else {
		/*
		 * For 64-bit frames and 32-bit fsave frames, restore the user
		 * state to the registers directly (with exceptions handled).
		 */
		user_fpu_begin();
		if (copy_user_to_fpregs_zeroing(buf_fx, xfeatures, fx_only)) {
			fpu__clear(fpu);
			return -1;
		}
	}

	return 0;
}
",C,"		if (using_compacted_format()) {
		} else {
			/* xcomp_bv must be 0 when using uncompacted format */
			if (!err && state_size > offsetof(struct xregs_state, header) && fpu->state.xsave.header.xcomp_bv)
				err = -EINVAL;
		}

","		if (using_compacted_format())
		else
",,"@@ -324,11 +324,16 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
 		 */
 		fpu__drop(fpu);
 
-		if (using_compacted_format())
+		if (using_compacted_format()) {
 			err = copy_user_to_xstate(&fpu->state.xsave, buf_fx);
-		else
+		} else {
 			err = __copy_from_user(&fpu->state.xsave, buf_fx, state_size);
 
+			/* xcomp_bv must be 0 when using uncompacted format */
+			if (!err && state_size > offsetof(struct xregs_state, header) && fpu->state.xsave.header.xcomp_bv)
+				err = -EINVAL;
+		}
+
 		if (err || __copy_from_user(&env, buf, sizeof(env))) {
 			fpstate_init(&fpu->state);
 			trace_x86_fpu_init_state(fpu);",linux,814fb7bb7db5433757d76f4c4502c96fc53b0b5e,03eaec81ac09814817e9f0307d572ffe8365f980,1,"static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
{
	int ia32_fxstate = (buf != buf_fx);
	struct task_struct *tsk = current;
	struct fpu *fpu = &tsk->thread.fpu;
	int state_size = fpu_kernel_xstate_size;
	u64 xfeatures = 0;
	int fx_only = 0;

	ia32_fxstate &= (IS_ENABLED(CONFIG_X86_32) ||
			 IS_ENABLED(CONFIG_IA32_EMULATION));

	if (!buf) {
		fpu__clear(fpu);
		return 0;
	}

	if (!access_ok(VERIFY_READ, buf, size))
		return -EACCES;

	fpu__activate_curr(fpu);

	if (!static_cpu_has(X86_FEATURE_FPU))
		return fpregs_soft_set(current, NULL,
				       0, sizeof(struct user_i387_ia32_struct),
				       NULL, buf) != 0;

	if (use_xsave()) {
		struct _fpx_sw_bytes fx_sw_user;
		if (unlikely(check_for_xstate(buf_fx, buf_fx, &fx_sw_user))) {
			/*
			 * Couldn't find the extended state information in the
			 * memory layout. Restore just the FP/SSE and init all
			 * the other extended state.
			 */
			state_size = sizeof(struct fxregs_state);
			fx_only = 1;
			trace_x86_fpu_xstate_check_failed(fpu);
		} else {
			state_size = fx_sw_user.xstate_size;
			xfeatures = fx_sw_user.xfeatures;
		}
	}

	if (ia32_fxstate) {
		/*
		 * For 32-bit frames with fxstate, copy the user state to the
		 * thread's fpu state, reconstruct fxstate from the fsave
		 * header. Sanitize the copied state etc.
		 */
		struct fpu *fpu = &tsk->thread.fpu;
		struct user_i387_ia32_struct env;
		int err = 0;

		/*
		 * Drop the current fpu which clears fpu->fpstate_active. This ensures
		 * that any context-switch during the copy of the new state,
		 * avoids the intermediate state from getting restored/saved.
		 * Thus avoiding the new restored state from getting corrupted.
		 * We will be ready to restore/save the state only after
		 * fpu->fpstate_active is again set.
 		 */
 		fpu__drop(fpu);
 
//flaw_line_below:
		if (using_compacted_format())
//fix_flaw_line_below:
//		if (using_compacted_format()) {
 			err = copy_user_to_xstate(&fpu->state.xsave, buf_fx);
//flaw_line_below:
		else
//fix_flaw_line_below:
//		} else {
 			err = __copy_from_user(&fpu->state.xsave, buf_fx, state_size);
 
//fix_flaw_line_below:
//			/* xcomp_bv must be 0 when using uncompacted format */
//fix_flaw_line_below:
//			if (!err && state_size > offsetof(struct xregs_state, header) && fpu->state.xsave.header.xcomp_bv)
//fix_flaw_line_below:
//				err = -EINVAL;
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//
 		if (err || __copy_from_user(&env, buf, sizeof(env))) {
 			fpstate_init(&fpu->state);
 			trace_x86_fpu_init_state(fpu);
			err = -1;
		} else {
			sanitize_restored_xstate(tsk, &env, xfeatures, fx_only);
		}

		fpu->fpstate_active = 1;
		preempt_disable();
		fpu__restore(fpu);
		preempt_enable();

		return err;
	} else {
		/*
		 * For 64-bit frames and 32-bit fsave frames, restore the user
		 * state to the registers directly (with exceptions handled).
		 */
		user_fpu_begin();
		if (copy_user_to_fpregs_zeroing(buf_fx, xfeatures, fx_only)) {
			fpu__clear(fpu);
			return -1;
		}
	}

	return 0;
}
",180891,"static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
{
	int ia32_fxstate = (buf != buf_fx);
	struct task_struct *tsk = current;
	struct fpu *fpu = &tsk->thread.fpu;
	int state_size = fpu_kernel_xstate_size;
	u64 xfeatures = 0;
	int fx_only = 0;

	ia32_fxstate &= (IS_ENABLED(CONFIG_X86_32) ||
			 IS_ENABLED(CONFIG_IA32_EMULATION));

	if (!buf) {
		fpu__clear(fpu);
		return 0;
	}

	if (!access_ok(VERIFY_READ, buf, size))
		return -EACCES;

	fpu__activate_curr(fpu);

	if (!static_cpu_has(X86_FEATURE_FPU))
		return fpregs_soft_set(current, NULL,
				       0, sizeof(struct user_i387_ia32_struct),
				       NULL, buf) != 0;

	if (use_xsave()) {
		struct _fpx_sw_bytes fx_sw_user;
		if (unlikely(check_for_xstate(buf_fx, buf_fx, &fx_sw_user))) {
			/*
			 * Couldn't find the extended state information in the
			 * memory layout. Restore just the FP/SSE and init all
			 * the other extended state.
			 */
			state_size = sizeof(struct fxregs_state);
			fx_only = 1;
			trace_x86_fpu_xstate_check_failed(fpu);
		} else {
			state_size = fx_sw_user.xstate_size;
			xfeatures = fx_sw_user.xfeatures;
		}
	}

	if (ia32_fxstate) {
		/*
		 * For 32-bit frames with fxstate, copy the user state to the
		 * thread's fpu state, reconstruct fxstate from the fsave
		 * header. Sanitize the copied state etc.
		 */
		struct fpu *fpu = &tsk->thread.fpu;
		struct user_i387_ia32_struct env;
		int err = 0;

		/*
		 * Drop the current fpu which clears fpu->fpstate_active. This ensures
		 * that any context-switch during the copy of the new state,
		 * avoids the intermediate state from getting restored/saved.
		 * Thus avoiding the new restored state from getting corrupted.
		 * We will be ready to restore/save the state only after
		 * fpu->fpstate_active is again set.
 		 */
 		fpu__drop(fpu);
 
		if (using_compacted_format())
 			err = copy_user_to_xstate(&fpu->state.xsave, buf_fx);
		else
 			err = __copy_from_user(&fpu->state.xsave, buf_fx, state_size);
 
 		if (err || __copy_from_user(&env, buf, sizeof(env))) {
 			fpstate_init(&fpu->state);
 			trace_x86_fpu_init_state(fpu);
			err = -1;
		} else {
			sanitize_restored_xstate(tsk, &env, xfeatures, fx_only);
		}

		fpu->fpstate_active = 1;
		preempt_disable();
		fpu__restore(fpu);
		preempt_enable();

		return err;
	} else {
		/*
		 * For 64-bit frames and 32-bit fsave frames, restore the user
		 * state to the registers directly (with exceptions handled).
		 */
		user_fpu_begin();
		if (copy_user_to_fpregs_zeroing(buf_fx, xfeatures, fx_only)) {
			fpu__clear(fpu);
			return -1;
		}
	}

	return 0;
}
","static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
{
	int ia32_fxstate = (buf != buf_fx);
	struct task_struct *tsk = current;
	struct fpu *fpu = &tsk->thread.fpu;
	int state_size = fpu_kernel_xstate_size;
	u64 xfeatures = 0;
	int fx_only = 0;

	ia32_fxstate &= (IS_ENABLED(CONFIG_X86_32) ||
			 IS_ENABLED(CONFIG_IA32_EMULATION));

	if (!buf) {
		fpu__clear(fpu);
		return 0;
	}

	if (!access_ok(VERIFY_READ, buf, size))
		return -EACCES;

	fpu__activate_curr(fpu);

	if (!static_cpu_has(X86_FEATURE_FPU))
		return fpregs_soft_set(current, NULL,
				       0, sizeof(struct user_i387_ia32_struct),
				       NULL, buf) != 0;

	if (use_xsave()) {
		struct _fpx_sw_bytes fx_sw_user;
		if (unlikely(check_for_xstate(buf_fx, buf_fx, &fx_sw_user))) {
			/*
			 * Couldn't find the extended state information in the
			 * memory layout. Restore just the FP/SSE and init all
			 * the other extended state.
			 */
			state_size = sizeof(struct fxregs_state);
			fx_only = 1;
			trace_x86_fpu_xstate_check_failed(fpu);
		} else {
			state_size = fx_sw_user.xstate_size;
			xfeatures = fx_sw_user.xfeatures;
		}
	}

	if (ia32_fxstate) {
		/*
		 * For 32-bit frames with fxstate, copy the user state to the
		 * thread's fpu state, reconstruct fxstate from the fsave
		 * header. Sanitize the copied state etc.
		 */
		struct fpu *fpu = &tsk->thread.fpu;
		struct user_i387_ia32_struct env;
		int err = 0;

		/*
		 * Drop the current fpu which clears fpu->fpstate_active. This ensures
		 * that any context-switch during the copy of the new state,
		 * avoids the intermediate state from getting restored/saved.
		 * Thus avoiding the new restored state from getting corrupted.
		 * We will be ready to restore/save the state only after
		 * fpu->fpstate_active is again set.
 		 */
 		fpu__drop(fpu);
 
		if (using_compacted_format()) {
 			err = copy_user_to_xstate(&fpu->state.xsave, buf_fx);
		} else {
 			err = __copy_from_user(&fpu->state.xsave, buf_fx, state_size);
 
			/* xcomp_bv must be 0 when using uncompacted format */
			if (!err && state_size > offsetof(struct xregs_state, header) && fpu->state.xsave.header.xcomp_bv)
				err = -EINVAL;
		}

 		if (err || __copy_from_user(&env, buf, sizeof(env))) {
 			fpstate_init(&fpu->state);
 			trace_x86_fpu_init_state(fpu);
			err = -1;
		} else {
			sanitize_restored_xstate(tsk, &env, xfeatures, fx_only);
		}

		fpu->fpstate_active = 1;
		preempt_disable();
		fpu__restore(fpu);
		preempt_enable();

		return err;
	} else {
		/*
		 * For 64-bit frames and 32-bit fsave frames, restore the user
		 * state to the registers directly (with exceptions handled).
		 */
		user_fpu_begin();
		if (copy_user_to_fpregs_zeroing(buf_fx, xfeatures, fx_only)) {
			fpu__clear(fpu);
			return -1;
		}
	}

	return 0;
}
","The `__fpu__restore_sig` function is responsible for restoring the floating-point unit (FPU) state for a given user process in a Linux kernel environment. It first checks if the provided buffers for the FPU state are valid and accessible. Depending on the architecture (32-bit or 64-bit), it either copies the FPU state from user space to the kernel's FPU structure or directly restores the state to the registers. The function also handles scenarios where extended state information is missing, ensuring that the FPU state is sanitized and correctly initialized before activation. Error handling is incorporated to manage access violations and state restoration failures.","The provided code implements a function that restores the floating-point unit state for a user process in a kernel environment. It begins by validating the input buffers and determining the architecture type. Depending on whether the state is 32-bit or 64-bit, it either copies the state from user space to the kernel or directly restores it to the registers. The function also checks for the presence of extended state information and ensures that the restored state is sanitized and properly initialized. Error handling is included to manage access violations and potential failures during the restoration process.","The vulnerability in the original code allowed userspace to set the `xcomp_bv` field in the xstate header to arbitrary values when using the uncompacted xstate format. This could lead to a situation where the kernel attempted to restore an invalid FPU state, resulting in a general protection fault and potential leakage of FPU registers from the previously executing task. The fix implemented in the updated code checks that the user-supplied `xcomp_bv` is zero when the uncompacted format is in use. If it is not zero, the function returns an error, preventing the restoration of an invalid state and enhancing overall system stability and security.","The vulnerability in the original code allowed userspace to set an arbitrary value in a specific field of the extended state header when using an uncompacted format. This could lead to a situation where the kernel attempted to restore an invalid floating-point unit state, resulting in a general protection fault and potential leakage of sensitive data from the previously executing task. The fix implemented in the updated code checks that this field is zero when the uncompacted format is in use; if it is not, the function returns an error, thereby preventing the restoration of an invalid state and enhancing system security.","The vulnerability was fixed by adding a validation check for the `xcomp_bv` field in the xstate header within the updated code. Specifically, the code now verifies that `fpu->state.xsave.header.xcomp_bv` is zero when using the uncompacted format. If this condition is not met, the function returns an error, preventing the restoration of an invalid floating-point unit state. This change ensures that userspace cannot set a bogus value in the `xcomp_bv` field, thereby avoiding potential general protection faults and ensuring the integrity of the FPU state during context switches.","The vulnerability was addressed by implementing a validation check to ensure that a specific field in the extended state header is set to zero when using the uncompacted format. This prevents userspace from supplying arbitrary values that could lead to an invalid floating-point unit state restoration. If the validation fails, the function now returns an error, effectively blocking the restoration process. This fix enhances system security by ensuring that only valid and expected values are processed, thereby mitigating the risk of faults and potential data leakage during context switches.","5,4","5,5","4,4","4, 4"
66,66,180897,180897,,Remote,Not required,,CVE-2017-15277,https://www.cvedetails.com/cve/CVE-2017-15277/,CWE-200,Medium,Partial,,,2017-10-12,4.3,"ReadGIFImage in coders/gif.c in ImageMagick 7.0.6-1 and GraphicsMagick 1.3.26 leaves the palette uninitialized when processing a GIF file that has neither a global nor local palette. If the affected product is used as a library loaded into a process that operates on interesting data, this data sometimes can be leaked via the uninitialized palette.",2018-10-18,+Info ,2,https://github.com/ImageMagick/ImageMagick/commit/9fd10cf630832b36a588c1545d8736539b2f1fb5,9fd10cf630832b36a588c1545d8736539b2f1fb5,https://github.com/ImageMagick/ImageMagick/issues/592,0,coders/gif.c,"{""sha"": ""bbfd5b2067a95019c62b4521d296de4be5f7aee3"", ""filename"": ""coders/gif.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/9fd10cf630832b36a588c1545d8736539b2f1fb5/coders/gif.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/9fd10cf630832b36a588c1545d8736539b2f1fb5/coders/gif.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/gif.c?ref=9fd10cf630832b36a588c1545d8736539b2f1fb5"", ""patch"": ""@@ -1018,6 +1018,8 @@ static Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     MagickMax(global_colors,256),3UL*sizeof(*global_colormap));\n   if (global_colormap == (unsigned char *) NULL)\n     ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n+  (void) ResetMagickMemory(global_colormap,0,3*MagickMax(global_colors,256)*\n+    sizeof(*global_colormap));\n   if (BitSet((int) flag,0x80) != 0)\n     {\n       count=ReadBlob(image,(size_t) (3*global_colors),global_colormap);""}","static Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define BitSet(byte,bit)  (((byte) & (bit)) == (bit))
#define LSBFirstOrder(x,y)  (((y) << 8) | (x))

  Image
    *image,
    *meta_image;

  int
    number_extensionss=0;

  MagickBooleanType
    status;

  RectangleInfo
    page;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    delay,
    dispose,
    duration,
    global_colors,
    image_count,
    iterations,
    one;

  ssize_t
    count,
    opacity;

  unsigned char
    background,
    c,
    flag,
    *global_colormap,
    buffer[257];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Determine if this a GIF file.
  */
  count=ReadBlob(image,6,buffer);
  if ((count != 6) || ((LocaleNCompare((char *) buffer,""GIF87"",5) != 0) &&
      (LocaleNCompare((char *) buffer,""GIF89"",5) != 0)))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  page.width=ReadBlobLSBShort(image);
  page.height=ReadBlobLSBShort(image);
  flag=(unsigned char) ReadBlobByte(image);
  background=(unsigned char) ReadBlobByte(image);
  c=(unsigned char) ReadBlobByte(image);  /* reserved */
  one=1;
  global_colors=one << (((size_t) flag & 0x07)+1);
  global_colormap=(unsigned char *) AcquireQuantumMemory((size_t)
     MagickMax(global_colors,256),3UL*sizeof(*global_colormap));
   if (global_colormap == (unsigned char *) NULL)
     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  (void) ResetMagickMemory(global_colormap,0,3*MagickMax(global_colors,256)*
    sizeof(*global_colormap));
   if (BitSet((int) flag,0x80) != 0)
     {
       count=ReadBlob(image,(size_t) (3*global_colors),global_colormap);
      if (count != (ssize_t) (3*global_colors))
        {
          global_colormap=(unsigned char *) RelinquishMagickMemory(
            global_colormap);
          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
        }
    }
  delay=0;
  dispose=0;
  duration=0;
  iterations=1;
  opacity=(-1);
  image_count=0;
  meta_image=AcquireImage(image_info,exception);  /* metadata container */
  for ( ; ; )
  {
    count=ReadBlob(image,1,&c);
    if (count != 1)
      break;
    if (c == (unsigned char) ';')
      break;  /* terminator */
    if (c == (unsigned char) '!')
      {
        /*
          GIF Extension block.
        */
        count=ReadBlob(image,1,&c);
        if (count != 1)
          {
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            meta_image=DestroyImage(meta_image);
            ThrowReaderException(CorruptImageError,
              ""UnableToReadExtensionBlock"");
          }
        switch (c)
        {
          case 0xf9:
          {
            /*
              Read graphics control extension.
            */
            while (ReadBlobBlock(image,buffer) != 0) ;
            dispose=(size_t) (buffer[0] >> 2);
            delay=(size_t) ((buffer[2] << 8) | buffer[1]);
            if ((ssize_t) (buffer[0] & 0x01) == 0x01)
              opacity=(ssize_t) buffer[3];
            break;
          }
          case 0xfe:
          {
            char
              *comments;

            size_t
              length;

            /*
              Read comment extension.
            */
            comments=AcquireString((char *) NULL);
            for (length=0; ; length+=count)
            {
              count=(ssize_t) ReadBlobBlock(image,buffer);
              if (count == 0)
                break;
              buffer[count]='\0';
              (void) ConcatenateString(&comments,(const char *) buffer);
            }
            (void) SetImageProperty(meta_image,""comment"",comments,exception);
            comments=DestroyString(comments);
            break;
          }
          case 0xff:
          {
            MagickBooleanType
              loop;

            /*
              Read Netscape Loop extension.
            */
            loop=MagickFalse;
            if (ReadBlobBlock(image,buffer) != 0)
              loop=LocaleNCompare((char *) buffer,""NETSCAPE2.0"",11) == 0 ?
                MagickTrue : MagickFalse;
            if (loop != MagickFalse)
              {
                while (ReadBlobBlock(image,buffer) != 0)
                  iterations=(size_t) ((buffer[2] << 8) | buffer[1]);
                break;
              }
            else
              {
                char
                  name[MagickPathExtent];

                int
                  block_length,
                  info_length,
                  reserved_length;

                MagickBooleanType
                  i8bim,
                  icc,
                  iptc,
                  magick;

                StringInfo
                  *profile;

                unsigned char
                  *info;

                /*
                  Store GIF application extension as a generic profile.
                */
                icc=LocaleNCompare((char *) buffer,""ICCRGBG1012"",11) == 0 ?
                  MagickTrue : MagickFalse;
                magick=LocaleNCompare((char *) buffer,""ImageMagick"",11) == 0 ?
                  MagickTrue : MagickFalse;
                i8bim=LocaleNCompare((char *) buffer,""MGK8BIM0000"",11) == 0 ?
                  MagickTrue : MagickFalse;
                iptc=LocaleNCompare((char *) buffer,""MGKIPTC0000"",11) == 0 ?
                  MagickTrue : MagickFalse;
                number_extensionss++;
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""    Reading GIF application extension"");
                info=(unsigned char *) AcquireQuantumMemory(255UL,
                  sizeof(*info));
                if (info == (unsigned char *) NULL)
                  {
                    meta_image=DestroyImage(meta_image);
                    ThrowReaderException(ResourceLimitError,
                      ""MemoryAllocationFailed"");
                  }
                reserved_length=255;
                for (info_length=0; ; )
                {
                  block_length=(int) ReadBlobBlock(image,&info[info_length]);
                  if (block_length == 0)
                    break;
                  info_length+=block_length;
                  if (info_length > (reserved_length-255))
                    {
                      reserved_length+=4096;
                      info=(unsigned char *) ResizeQuantumMemory(info,(size_t)
                        reserved_length,sizeof(*info));
                      if (info == (unsigned char *) NULL)
                        {
                          meta_image=DestroyImage(meta_image);
                          ThrowReaderException(ResourceLimitError,
                            ""MemoryAllocationFailed"");
                        }
                    }
                }
                profile=BlobToStringInfo(info,(size_t) info_length);
                if (profile == (StringInfo *) NULL)
                  {
                    meta_image=DestroyImage(meta_image);
                    ThrowReaderException(ResourceLimitError,
                      ""MemoryAllocationFailed"");
                  }
                if (i8bim != MagickFalse)
                  (void) CopyMagickString(name,""8bim"",sizeof(name));
                else if (icc != MagickFalse)
                  (void) CopyMagickString(name,""icc"",sizeof(name));
                else if (iptc != MagickFalse)
                  (void) CopyMagickString(name,""iptc"",sizeof(name));
                else if (magick != MagickFalse)
                  {
                    (void) CopyMagickString(name,""magick"",sizeof(name));
                    meta_image->gamma=StringToDouble((char *) info+6,
                      (char **) NULL);
                  }
                else
                  (void) FormatLocaleString(name,sizeof(name),""gif:%.11s"",
                    buffer);
                info=(unsigned char *) RelinquishMagickMemory(info);
                if (magick == MagickFalse)
                  (void) SetImageProfile(meta_image,name,profile,exception);
                profile=DestroyStringInfo(profile);
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      profile name=%s"",name);
              }
            break;
          }
          default:
          {
            while (ReadBlobBlock(image,buffer) != 0) ;
            break;
          }
        }
      }
    if (c != (unsigned char) ',')
      continue;
    if (image_count != 0)
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
      }
    image_count++;
    /*
      Read image attributes.
    */
    meta_image->scene=image->scene;
    (void) CloneImageProperties(image,meta_image);
    DestroyImageProperties(meta_image);
    (void) CloneImageProfiles(image,meta_image);
    DestroyImageProfiles(meta_image);
    image->storage_class=PseudoClass;
    image->compression=LZWCompression;
    page.x=(ssize_t) ReadBlobLSBShort(image);
    page.y=(ssize_t) ReadBlobLSBShort(image);
    image->columns=ReadBlobLSBShort(image);
    image->rows=ReadBlobLSBShort(image);
    image->depth=8;
    flag=(unsigned char) ReadBlobByte(image);
    image->interlace=BitSet((int) flag,0x40) != 0 ? GIFInterlace : NoInterlace;
    image->colors=BitSet((int) flag,0x80) == 0 ? global_colors : one <<
      ((size_t) (flag & 0x07)+1);
    if (opacity >= (ssize_t) image->colors)
      opacity=(-1);
    image->page.width=page.width;
    image->page.height=page.height;
    image->page.y=page.y;
    image->page.x=page.x;
    image->delay=delay;
    image->ticks_per_second=100;
    image->dispose=(DisposeType) dispose;
    image->iterations=iterations;
    image->alpha_trait=opacity >= 0 ? BlendPixelTrait : UndefinedPixelTrait;
    delay=0;
    dispose=0;
    if ((image->columns == 0) || (image->rows == 0))
      {
        global_colormap=(unsigned char *) RelinquishMagickMemory(
          global_colormap);
        meta_image=DestroyImage(meta_image);
        ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
      }
    /*
      Inititialize colormap.
    */
    if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
      {
        global_colormap=(unsigned char *) RelinquishMagickMemory(
          global_colormap);
        meta_image=DestroyImage(meta_image);
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    if (BitSet((int) flag,0x80) == 0)
      {
        /*
          Use global colormap.
        */
        p=global_colormap;
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);
          if (i == opacity)
            {
              image->colormap[i].alpha=(double) TransparentAlpha;
              image->transparent_color=image->colormap[opacity];
            }
        }
        image->background_color=image->colormap[MagickMin((ssize_t) background,
          (ssize_t) image->colors-1)];
      }
    else
      {
        unsigned char
          *colormap;

        /*
          Read local colormap.
        */
        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,3*
          sizeof(*colormap));
        if (colormap == (unsigned char *) NULL)
          {
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            meta_image=DestroyImage(meta_image);
            ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
          }
        count=ReadBlob(image,(3*image->colors)*sizeof(*colormap),colormap);
        if (count != (ssize_t) (3*image->colors))
          {
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            colormap=(unsigned char *) RelinquishMagickMemory(colormap);
            meta_image=DestroyImage(meta_image);
            ThrowReaderException(CorruptImageError,
              ""InsufficientImageDataInFile"");
          }
        p=colormap;
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);
          if (i == opacity)
            image->colormap[i].alpha=(double) TransparentAlpha;
        }
        colormap=(unsigned char *) RelinquishMagickMemory(colormap);
      }
    if (image->gamma == 1.0)
      {
        for (i=0; i < (ssize_t) image->colors; i++)
          if (IsPixelInfoGray(image->colormap+i) == MagickFalse)
            break;
        (void) SetImageColorspace(image,i == (ssize_t) image->colors ? 
          GRAYColorspace : RGBColorspace,exception);
      }
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    /*
      Decode image.
    */
    if (image_info->ping != MagickFalse)
      status=PingGIFImage(image,exception);
    else
      status=DecodeImage(image,opacity,exception);
    if ((image_info->ping == MagickFalse) && (status == MagickFalse))
      {
        global_colormap=(unsigned char *) RelinquishMagickMemory(
          global_colormap);
        meta_image=DestroyImage(meta_image);
        ThrowReaderException(CorruptImageError,""CorruptImage"");
      }
    duration+=image->delay*image->iterations;
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    opacity=(-1);
    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) image->scene-
      1,image->scene);
    if (status == MagickFalse)
      break;
  }
  image->duration=duration;
  meta_image=DestroyImage(meta_image);
  global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);
  if ((image->columns == 0) || (image->rows == 0))
    ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","static Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define BitSet(byte,bit)  (((byte) & (bit)) == (bit))
#define LSBFirstOrder(x,y)  (((y) << 8) | (x))

  Image
    *image,
    *meta_image;

  int
    number_extensionss=0;

  MagickBooleanType
    status;

  RectangleInfo
    page;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    delay,
    dispose,
    duration,
    global_colors,
    image_count,
    iterations,
    one;

  ssize_t
    count,
    opacity;

  unsigned char
    background,
    c,
    flag,
    *global_colormap,
    buffer[257];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Determine if this a GIF file.
  */
  count=ReadBlob(image,6,buffer);
  if ((count != 6) || ((LocaleNCompare((char *) buffer,""GIF87"",5) != 0) &&
      (LocaleNCompare((char *) buffer,""GIF89"",5) != 0)))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  page.width=ReadBlobLSBShort(image);
  page.height=ReadBlobLSBShort(image);
  flag=(unsigned char) ReadBlobByte(image);
  background=(unsigned char) ReadBlobByte(image);
  c=(unsigned char) ReadBlobByte(image);  /* reserved */
  one=1;
  global_colors=one << (((size_t) flag & 0x07)+1);
  global_colormap=(unsigned char *) AcquireQuantumMemory((size_t)
     MagickMax(global_colors,256),3UL*sizeof(*global_colormap));
   if (global_colormap == (unsigned char *) NULL)
     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
   if (BitSet((int) flag,0x80) != 0)
     {
       count=ReadBlob(image,(size_t) (3*global_colors),global_colormap);
      if (count != (ssize_t) (3*global_colors))
        {
          global_colormap=(unsigned char *) RelinquishMagickMemory(
            global_colormap);
          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
        }
    }
  delay=0;
  dispose=0;
  duration=0;
  iterations=1;
  opacity=(-1);
  image_count=0;
  meta_image=AcquireImage(image_info,exception);  /* metadata container */
  for ( ; ; )
  {
    count=ReadBlob(image,1,&c);
    if (count != 1)
      break;
    if (c == (unsigned char) ';')
      break;  /* terminator */
    if (c == (unsigned char) '!')
      {
        /*
          GIF Extension block.
        */
        count=ReadBlob(image,1,&c);
        if (count != 1)
          {
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            meta_image=DestroyImage(meta_image);
            ThrowReaderException(CorruptImageError,
              ""UnableToReadExtensionBlock"");
          }
        switch (c)
        {
          case 0xf9:
          {
            /*
              Read graphics control extension.
            */
            while (ReadBlobBlock(image,buffer) != 0) ;
            dispose=(size_t) (buffer[0] >> 2);
            delay=(size_t) ((buffer[2] << 8) | buffer[1]);
            if ((ssize_t) (buffer[0] & 0x01) == 0x01)
              opacity=(ssize_t) buffer[3];
            break;
          }
          case 0xfe:
          {
            char
              *comments;

            size_t
              length;

            /*
              Read comment extension.
            */
            comments=AcquireString((char *) NULL);
            for (length=0; ; length+=count)
            {
              count=(ssize_t) ReadBlobBlock(image,buffer);
              if (count == 0)
                break;
              buffer[count]='\0';
              (void) ConcatenateString(&comments,(const char *) buffer);
            }
            (void) SetImageProperty(meta_image,""comment"",comments,exception);
            comments=DestroyString(comments);
            break;
          }
          case 0xff:
          {
            MagickBooleanType
              loop;

            /*
              Read Netscape Loop extension.
            */
            loop=MagickFalse;
            if (ReadBlobBlock(image,buffer) != 0)
              loop=LocaleNCompare((char *) buffer,""NETSCAPE2.0"",11) == 0 ?
                MagickTrue : MagickFalse;
            if (loop != MagickFalse)
              {
                while (ReadBlobBlock(image,buffer) != 0)
                  iterations=(size_t) ((buffer[2] << 8) | buffer[1]);
                break;
              }
            else
              {
                char
                  name[MagickPathExtent];

                int
                  block_length,
                  info_length,
                  reserved_length;

                MagickBooleanType
                  i8bim,
                  icc,
                  iptc,
                  magick;

                StringInfo
                  *profile;

                unsigned char
                  *info;

                /*
                  Store GIF application extension as a generic profile.
                */
                icc=LocaleNCompare((char *) buffer,""ICCRGBG1012"",11) == 0 ?
                  MagickTrue : MagickFalse;
                magick=LocaleNCompare((char *) buffer,""ImageMagick"",11) == 0 ?
                  MagickTrue : MagickFalse;
                i8bim=LocaleNCompare((char *) buffer,""MGK8BIM0000"",11) == 0 ?
                  MagickTrue : MagickFalse;
                iptc=LocaleNCompare((char *) buffer,""MGKIPTC0000"",11) == 0 ?
                  MagickTrue : MagickFalse;
                number_extensionss++;
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""    Reading GIF application extension"");
                info=(unsigned char *) AcquireQuantumMemory(255UL,
                  sizeof(*info));
                if (info == (unsigned char *) NULL)
                  {
                    meta_image=DestroyImage(meta_image);
                    ThrowReaderException(ResourceLimitError,
                      ""MemoryAllocationFailed"");
                  }
                reserved_length=255;
                for (info_length=0; ; )
                {
                  block_length=(int) ReadBlobBlock(image,&info[info_length]);
                  if (block_length == 0)
                    break;
                  info_length+=block_length;
                  if (info_length > (reserved_length-255))
                    {
                      reserved_length+=4096;
                      info=(unsigned char *) ResizeQuantumMemory(info,(size_t)
                        reserved_length,sizeof(*info));
                      if (info == (unsigned char *) NULL)
                        {
                          meta_image=DestroyImage(meta_image);
                          ThrowReaderException(ResourceLimitError,
                            ""MemoryAllocationFailed"");
                        }
                    }
                }
                profile=BlobToStringInfo(info,(size_t) info_length);
                if (profile == (StringInfo *) NULL)
                  {
                    meta_image=DestroyImage(meta_image);
                    ThrowReaderException(ResourceLimitError,
                      ""MemoryAllocationFailed"");
                  }
                if (i8bim != MagickFalse)
                  (void) CopyMagickString(name,""8bim"",sizeof(name));
                else if (icc != MagickFalse)
                  (void) CopyMagickString(name,""icc"",sizeof(name));
                else if (iptc != MagickFalse)
                  (void) CopyMagickString(name,""iptc"",sizeof(name));
                else if (magick != MagickFalse)
                  {
                    (void) CopyMagickString(name,""magick"",sizeof(name));
                    meta_image->gamma=StringToDouble((char *) info+6,
                      (char **) NULL);
                  }
                else
                  (void) FormatLocaleString(name,sizeof(name),""gif:%.11s"",
                    buffer);
                info=(unsigned char *) RelinquishMagickMemory(info);
                if (magick == MagickFalse)
                  (void) SetImageProfile(meta_image,name,profile,exception);
                profile=DestroyStringInfo(profile);
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      profile name=%s"",name);
              }
            break;
          }
          default:
          {
            while (ReadBlobBlock(image,buffer) != 0) ;
            break;
          }
        }
      }
    if (c != (unsigned char) ',')
      continue;
    if (image_count != 0)
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
      }
    image_count++;
    /*
      Read image attributes.
    */
    meta_image->scene=image->scene;
    (void) CloneImageProperties(image,meta_image);
    DestroyImageProperties(meta_image);
    (void) CloneImageProfiles(image,meta_image);
    DestroyImageProfiles(meta_image);
    image->storage_class=PseudoClass;
    image->compression=LZWCompression;
    page.x=(ssize_t) ReadBlobLSBShort(image);
    page.y=(ssize_t) ReadBlobLSBShort(image);
    image->columns=ReadBlobLSBShort(image);
    image->rows=ReadBlobLSBShort(image);
    image->depth=8;
    flag=(unsigned char) ReadBlobByte(image);
    image->interlace=BitSet((int) flag,0x40) != 0 ? GIFInterlace : NoInterlace;
    image->colors=BitSet((int) flag,0x80) == 0 ? global_colors : one <<
      ((size_t) (flag & 0x07)+1);
    if (opacity >= (ssize_t) image->colors)
      opacity=(-1);
    image->page.width=page.width;
    image->page.height=page.height;
    image->page.y=page.y;
    image->page.x=page.x;
    image->delay=delay;
    image->ticks_per_second=100;
    image->dispose=(DisposeType) dispose;
    image->iterations=iterations;
    image->alpha_trait=opacity >= 0 ? BlendPixelTrait : UndefinedPixelTrait;
    delay=0;
    dispose=0;
    if ((image->columns == 0) || (image->rows == 0))
      {
        global_colormap=(unsigned char *) RelinquishMagickMemory(
          global_colormap);
        meta_image=DestroyImage(meta_image);
        ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
      }
    /*
      Inititialize colormap.
    */
    if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
      {
        global_colormap=(unsigned char *) RelinquishMagickMemory(
          global_colormap);
        meta_image=DestroyImage(meta_image);
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    if (BitSet((int) flag,0x80) == 0)
      {
        /*
          Use global colormap.
        */
        p=global_colormap;
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);
          if (i == opacity)
            {
              image->colormap[i].alpha=(double) TransparentAlpha;
              image->transparent_color=image->colormap[opacity];
            }
        }
        image->background_color=image->colormap[MagickMin((ssize_t) background,
          (ssize_t) image->colors-1)];
      }
    else
      {
        unsigned char
          *colormap;

        /*
          Read local colormap.
        */
        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,3*
          sizeof(*colormap));
        if (colormap == (unsigned char *) NULL)
          {
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            meta_image=DestroyImage(meta_image);
            ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
          }
        count=ReadBlob(image,(3*image->colors)*sizeof(*colormap),colormap);
        if (count != (ssize_t) (3*image->colors))
          {
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            colormap=(unsigned char *) RelinquishMagickMemory(colormap);
            meta_image=DestroyImage(meta_image);
            ThrowReaderException(CorruptImageError,
              ""InsufficientImageDataInFile"");
          }
        p=colormap;
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);
          if (i == opacity)
            image->colormap[i].alpha=(double) TransparentAlpha;
        }
        colormap=(unsigned char *) RelinquishMagickMemory(colormap);
      }
    if (image->gamma == 1.0)
      {
        for (i=0; i < (ssize_t) image->colors; i++)
          if (IsPixelInfoGray(image->colormap+i) == MagickFalse)
            break;
        (void) SetImageColorspace(image,i == (ssize_t) image->colors ? 
          GRAYColorspace : RGBColorspace,exception);
      }
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    /*
      Decode image.
    */
    if (image_info->ping != MagickFalse)
      status=PingGIFImage(image,exception);
    else
      status=DecodeImage(image,opacity,exception);
    if ((image_info->ping == MagickFalse) && (status == MagickFalse))
      {
        global_colormap=(unsigned char *) RelinquishMagickMemory(
          global_colormap);
        meta_image=DestroyImage(meta_image);
        ThrowReaderException(CorruptImageError,""CorruptImage"");
      }
    duration+=image->delay*image->iterations;
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    opacity=(-1);
    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) image->scene-
      1,image->scene);
    if (status == MagickFalse)
      break;
  }
  image->duration=duration;
  meta_image=DestroyImage(meta_image);
  global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);
  if ((image->columns == 0) || (image->rows == 0))
    ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",C,"  (void) ResetMagickMemory(global_colormap,0,3*MagickMax(global_colors,256)*
    sizeof(*global_colormap));
",,,"@@ -1018,6 +1018,8 @@ static Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)
     MagickMax(global_colors,256),3UL*sizeof(*global_colormap));
   if (global_colormap == (unsigned char *) NULL)
     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
+  (void) ResetMagickMemory(global_colormap,0,3*MagickMax(global_colors,256)*
+    sizeof(*global_colormap));
   if (BitSet((int) flag,0x80) != 0)
     {
       count=ReadBlob(image,(size_t) (3*global_colors),global_colormap);",ImageMagick,9fd10cf630832b36a588c1545d8736539b2f1fb5,387eb53ff6c991d5c17e6769f30a0961af77e73b,1,"static Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define BitSet(byte,bit)  (((byte) & (bit)) == (bit))
#define LSBFirstOrder(x,y)  (((y) << 8) | (x))

  Image
    *image,
    *meta_image;

  int
    number_extensionss=0;

  MagickBooleanType
    status;

  RectangleInfo
    page;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    delay,
    dispose,
    duration,
    global_colors,
    image_count,
    iterations,
    one;

  ssize_t
    count,
    opacity;

  unsigned char
    background,
    c,
    flag,
    *global_colormap,
    buffer[257];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Determine if this a GIF file.
  */
  count=ReadBlob(image,6,buffer);
  if ((count != 6) || ((LocaleNCompare((char *) buffer,""GIF87"",5) != 0) &&
      (LocaleNCompare((char *) buffer,""GIF89"",5) != 0)))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  page.width=ReadBlobLSBShort(image);
  page.height=ReadBlobLSBShort(image);
  flag=(unsigned char) ReadBlobByte(image);
  background=(unsigned char) ReadBlobByte(image);
  c=(unsigned char) ReadBlobByte(image);  /* reserved */
  one=1;
  global_colors=one << (((size_t) flag & 0x07)+1);
  global_colormap=(unsigned char *) AcquireQuantumMemory((size_t)
     MagickMax(global_colors,256),3UL*sizeof(*global_colormap));
   if (global_colormap == (unsigned char *) NULL)
     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
//fix_flaw_line_below:
//  (void) ResetMagickMemory(global_colormap,0,3*MagickMax(global_colors,256)*
//fix_flaw_line_below:
//    sizeof(*global_colormap));
   if (BitSet((int) flag,0x80) != 0)
     {
       count=ReadBlob(image,(size_t) (3*global_colors),global_colormap);
      if (count != (ssize_t) (3*global_colors))
        {
          global_colormap=(unsigned char *) RelinquishMagickMemory(
            global_colormap);
          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
        }
    }
  delay=0;
  dispose=0;
  duration=0;
  iterations=1;
  opacity=(-1);
  image_count=0;
  meta_image=AcquireImage(image_info,exception);  /* metadata container */
  for ( ; ; )
  {
    count=ReadBlob(image,1,&c);
    if (count != 1)
      break;
    if (c == (unsigned char) ';')
      break;  /* terminator */
    if (c == (unsigned char) '!')
      {
        /*
          GIF Extension block.
        */
        count=ReadBlob(image,1,&c);
        if (count != 1)
          {
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            meta_image=DestroyImage(meta_image);
            ThrowReaderException(CorruptImageError,
              ""UnableToReadExtensionBlock"");
          }
        switch (c)
        {
          case 0xf9:
          {
            /*
              Read graphics control extension.
            */
            while (ReadBlobBlock(image,buffer) != 0) ;
            dispose=(size_t) (buffer[0] >> 2);
            delay=(size_t) ((buffer[2] << 8) | buffer[1]);
            if ((ssize_t) (buffer[0] & 0x01) == 0x01)
              opacity=(ssize_t) buffer[3];
            break;
          }
          case 0xfe:
          {
            char
              *comments;

            size_t
              length;

            /*
              Read comment extension.
            */
            comments=AcquireString((char *) NULL);
            for (length=0; ; length+=count)
            {
              count=(ssize_t) ReadBlobBlock(image,buffer);
              if (count == 0)
                break;
              buffer[count]='\0';
              (void) ConcatenateString(&comments,(const char *) buffer);
            }
            (void) SetImageProperty(meta_image,""comment"",comments,exception);
            comments=DestroyString(comments);
            break;
          }
          case 0xff:
          {
            MagickBooleanType
              loop;

            /*
              Read Netscape Loop extension.
            */
            loop=MagickFalse;
            if (ReadBlobBlock(image,buffer) != 0)
              loop=LocaleNCompare((char *) buffer,""NETSCAPE2.0"",11) == 0 ?
                MagickTrue : MagickFalse;
            if (loop != MagickFalse)
              {
                while (ReadBlobBlock(image,buffer) != 0)
                  iterations=(size_t) ((buffer[2] << 8) | buffer[1]);
                break;
              }
            else
              {
                char
                  name[MagickPathExtent];

                int
                  block_length,
                  info_length,
                  reserved_length;

                MagickBooleanType
                  i8bim,
                  icc,
                  iptc,
                  magick;

                StringInfo
                  *profile;

                unsigned char
                  *info;

                /*
                  Store GIF application extension as a generic profile.
                */
                icc=LocaleNCompare((char *) buffer,""ICCRGBG1012"",11) == 0 ?
                  MagickTrue : MagickFalse;
                magick=LocaleNCompare((char *) buffer,""ImageMagick"",11) == 0 ?
                  MagickTrue : MagickFalse;
                i8bim=LocaleNCompare((char *) buffer,""MGK8BIM0000"",11) == 0 ?
                  MagickTrue : MagickFalse;
                iptc=LocaleNCompare((char *) buffer,""MGKIPTC0000"",11) == 0 ?
                  MagickTrue : MagickFalse;
                number_extensionss++;
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""    Reading GIF application extension"");
                info=(unsigned char *) AcquireQuantumMemory(255UL,
                  sizeof(*info));
                if (info == (unsigned char *) NULL)
                  {
                    meta_image=DestroyImage(meta_image);
                    ThrowReaderException(ResourceLimitError,
                      ""MemoryAllocationFailed"");
                  }
                reserved_length=255;
                for (info_length=0; ; )
                {
                  block_length=(int) ReadBlobBlock(image,&info[info_length]);
                  if (block_length == 0)
                    break;
                  info_length+=block_length;
                  if (info_length > (reserved_length-255))
                    {
                      reserved_length+=4096;
                      info=(unsigned char *) ResizeQuantumMemory(info,(size_t)
                        reserved_length,sizeof(*info));
                      if (info == (unsigned char *) NULL)
                        {
                          meta_image=DestroyImage(meta_image);
                          ThrowReaderException(ResourceLimitError,
                            ""MemoryAllocationFailed"");
                        }
                    }
                }
                profile=BlobToStringInfo(info,(size_t) info_length);
                if (profile == (StringInfo *) NULL)
                  {
                    meta_image=DestroyImage(meta_image);
                    ThrowReaderException(ResourceLimitError,
                      ""MemoryAllocationFailed"");
                  }
                if (i8bim != MagickFalse)
                  (void) CopyMagickString(name,""8bim"",sizeof(name));
                else if (icc != MagickFalse)
                  (void) CopyMagickString(name,""icc"",sizeof(name));
                else if (iptc != MagickFalse)
                  (void) CopyMagickString(name,""iptc"",sizeof(name));
                else if (magick != MagickFalse)
                  {
                    (void) CopyMagickString(name,""magick"",sizeof(name));
                    meta_image->gamma=StringToDouble((char *) info+6,
                      (char **) NULL);
                  }
                else
                  (void) FormatLocaleString(name,sizeof(name),""gif:%.11s"",
                    buffer);
                info=(unsigned char *) RelinquishMagickMemory(info);
                if (magick == MagickFalse)
                  (void) SetImageProfile(meta_image,name,profile,exception);
                profile=DestroyStringInfo(profile);
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      profile name=%s"",name);
              }
            break;
          }
          default:
          {
            while (ReadBlobBlock(image,buffer) != 0) ;
            break;
          }
        }
      }
    if (c != (unsigned char) ',')
      continue;
    if (image_count != 0)
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
      }
    image_count++;
    /*
      Read image attributes.
    */
    meta_image->scene=image->scene;
    (void) CloneImageProperties(image,meta_image);
    DestroyImageProperties(meta_image);
    (void) CloneImageProfiles(image,meta_image);
    DestroyImageProfiles(meta_image);
    image->storage_class=PseudoClass;
    image->compression=LZWCompression;
    page.x=(ssize_t) ReadBlobLSBShort(image);
    page.y=(ssize_t) ReadBlobLSBShort(image);
    image->columns=ReadBlobLSBShort(image);
    image->rows=ReadBlobLSBShort(image);
    image->depth=8;
    flag=(unsigned char) ReadBlobByte(image);
    image->interlace=BitSet((int) flag,0x40) != 0 ? GIFInterlace : NoInterlace;
    image->colors=BitSet((int) flag,0x80) == 0 ? global_colors : one <<
      ((size_t) (flag & 0x07)+1);
    if (opacity >= (ssize_t) image->colors)
      opacity=(-1);
    image->page.width=page.width;
    image->page.height=page.height;
    image->page.y=page.y;
    image->page.x=page.x;
    image->delay=delay;
    image->ticks_per_second=100;
    image->dispose=(DisposeType) dispose;
    image->iterations=iterations;
    image->alpha_trait=opacity >= 0 ? BlendPixelTrait : UndefinedPixelTrait;
    delay=0;
    dispose=0;
    if ((image->columns == 0) || (image->rows == 0))
      {
        global_colormap=(unsigned char *) RelinquishMagickMemory(
          global_colormap);
        meta_image=DestroyImage(meta_image);
        ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
      }
    /*
      Inititialize colormap.
    */
    if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
      {
        global_colormap=(unsigned char *) RelinquishMagickMemory(
          global_colormap);
        meta_image=DestroyImage(meta_image);
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    if (BitSet((int) flag,0x80) == 0)
      {
        /*
          Use global colormap.
        */
        p=global_colormap;
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);
          if (i == opacity)
            {
              image->colormap[i].alpha=(double) TransparentAlpha;
              image->transparent_color=image->colormap[opacity];
            }
        }
        image->background_color=image->colormap[MagickMin((ssize_t) background,
          (ssize_t) image->colors-1)];
      }
    else
      {
        unsigned char
          *colormap;

        /*
          Read local colormap.
        */
        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,3*
          sizeof(*colormap));
        if (colormap == (unsigned char *) NULL)
          {
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            meta_image=DestroyImage(meta_image);
            ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
          }
        count=ReadBlob(image,(3*image->colors)*sizeof(*colormap),colormap);
        if (count != (ssize_t) (3*image->colors))
          {
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            colormap=(unsigned char *) RelinquishMagickMemory(colormap);
            meta_image=DestroyImage(meta_image);
            ThrowReaderException(CorruptImageError,
              ""InsufficientImageDataInFile"");
          }
        p=colormap;
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);
          if (i == opacity)
            image->colormap[i].alpha=(double) TransparentAlpha;
        }
        colormap=(unsigned char *) RelinquishMagickMemory(colormap);
      }
    if (image->gamma == 1.0)
      {
        for (i=0; i < (ssize_t) image->colors; i++)
          if (IsPixelInfoGray(image->colormap+i) == MagickFalse)
            break;
        (void) SetImageColorspace(image,i == (ssize_t) image->colors ? 
          GRAYColorspace : RGBColorspace,exception);
      }
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    /*
      Decode image.
    */
    if (image_info->ping != MagickFalse)
      status=PingGIFImage(image,exception);
    else
      status=DecodeImage(image,opacity,exception);
    if ((image_info->ping == MagickFalse) && (status == MagickFalse))
      {
        global_colormap=(unsigned char *) RelinquishMagickMemory(
          global_colormap);
        meta_image=DestroyImage(meta_image);
        ThrowReaderException(CorruptImageError,""CorruptImage"");
      }
    duration+=image->delay*image->iterations;
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    opacity=(-1);
    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) image->scene-
      1,image->scene);
    if (status == MagickFalse)
      break;
  }
  image->duration=duration;
  meta_image=DestroyImage(meta_image);
  global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);
  if ((image->columns == 0) || (image->rows == 0))
    ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",180897,"static Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define BitSet(byte,bit)  (((byte) & (bit)) == (bit))
#define LSBFirstOrder(x,y)  (((y) << 8) | (x))

  Image
    *image,
    *meta_image;

  int
    number_extensionss=0;

  MagickBooleanType
    status;

  RectangleInfo
    page;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    delay,
    dispose,
    duration,
    global_colors,
    image_count,
    iterations,
    one;

  ssize_t
    count,
    opacity;

  unsigned char
    background,
    c,
    flag,
    *global_colormap,
    buffer[257];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Determine if this a GIF file.
  */
  count=ReadBlob(image,6,buffer);
  if ((count != 6) || ((LocaleNCompare((char *) buffer,""GIF87"",5) != 0) &&
      (LocaleNCompare((char *) buffer,""GIF89"",5) != 0)))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  page.width=ReadBlobLSBShort(image);
  page.height=ReadBlobLSBShort(image);
  flag=(unsigned char) ReadBlobByte(image);
  background=(unsigned char) ReadBlobByte(image);
  c=(unsigned char) ReadBlobByte(image);  /* reserved */
  one=1;
  global_colors=one << (((size_t) flag & 0x07)+1);
  global_colormap=(unsigned char *) AcquireQuantumMemory((size_t)
     MagickMax(global_colors,256),3UL*sizeof(*global_colormap));
   if (global_colormap == (unsigned char *) NULL)
     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
   if (BitSet((int) flag,0x80) != 0)
     {
       count=ReadBlob(image,(size_t) (3*global_colors),global_colormap);
      if (count != (ssize_t) (3*global_colors))
        {
          global_colormap=(unsigned char *) RelinquishMagickMemory(
            global_colormap);
          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
        }
    }
  delay=0;
  dispose=0;
  duration=0;
  iterations=1;
  opacity=(-1);
  image_count=0;
  meta_image=AcquireImage(image_info,exception);  /* metadata container */
  for ( ; ; )
  {
    count=ReadBlob(image,1,&c);
    if (count != 1)
      break;
    if (c == (unsigned char) ';')
      break;  /* terminator */
    if (c == (unsigned char) '!')
      {
        /*
          GIF Extension block.
        */
        count=ReadBlob(image,1,&c);
        if (count != 1)
          {
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            meta_image=DestroyImage(meta_image);
            ThrowReaderException(CorruptImageError,
              ""UnableToReadExtensionBlock"");
          }
        switch (c)
        {
          case 0xf9:
          {
            /*
              Read graphics control extension.
            */
            while (ReadBlobBlock(image,buffer) != 0) ;
            dispose=(size_t) (buffer[0] >> 2);
            delay=(size_t) ((buffer[2] << 8) | buffer[1]);
            if ((ssize_t) (buffer[0] & 0x01) == 0x01)
              opacity=(ssize_t) buffer[3];
            break;
          }
          case 0xfe:
          {
            char
              *comments;

            size_t
              length;

            /*
              Read comment extension.
            */
            comments=AcquireString((char *) NULL);
            for (length=0; ; length+=count)
            {
              count=(ssize_t) ReadBlobBlock(image,buffer);
              if (count == 0)
                break;
              buffer[count]='\0';
              (void) ConcatenateString(&comments,(const char *) buffer);
            }
            (void) SetImageProperty(meta_image,""comment"",comments,exception);
            comments=DestroyString(comments);
            break;
          }
          case 0xff:
          {
            MagickBooleanType
              loop;

            /*
              Read Netscape Loop extension.
            */
            loop=MagickFalse;
            if (ReadBlobBlock(image,buffer) != 0)
              loop=LocaleNCompare((char *) buffer,""NETSCAPE2.0"",11) == 0 ?
                MagickTrue : MagickFalse;
            if (loop != MagickFalse)
              {
                while (ReadBlobBlock(image,buffer) != 0)
                  iterations=(size_t) ((buffer[2] << 8) | buffer[1]);
                break;
              }
            else
              {
                char
                  name[MagickPathExtent];

                int
                  block_length,
                  info_length,
                  reserved_length;

                MagickBooleanType
                  i8bim,
                  icc,
                  iptc,
                  magick;

                StringInfo
                  *profile;

                unsigned char
                  *info;

                /*
                  Store GIF application extension as a generic profile.
                */
                icc=LocaleNCompare((char *) buffer,""ICCRGBG1012"",11) == 0 ?
                  MagickTrue : MagickFalse;
                magick=LocaleNCompare((char *) buffer,""ImageMagick"",11) == 0 ?
                  MagickTrue : MagickFalse;
                i8bim=LocaleNCompare((char *) buffer,""MGK8BIM0000"",11) == 0 ?
                  MagickTrue : MagickFalse;
                iptc=LocaleNCompare((char *) buffer,""MGKIPTC0000"",11) == 0 ?
                  MagickTrue : MagickFalse;
                number_extensionss++;
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""    Reading GIF application extension"");
                info=(unsigned char *) AcquireQuantumMemory(255UL,
                  sizeof(*info));
                if (info == (unsigned char *) NULL)
                  {
                    meta_image=DestroyImage(meta_image);
                    ThrowReaderException(ResourceLimitError,
                      ""MemoryAllocationFailed"");
                  }
                reserved_length=255;
                for (info_length=0; ; )
                {
                  block_length=(int) ReadBlobBlock(image,&info[info_length]);
                  if (block_length == 0)
                    break;
                  info_length+=block_length;
                  if (info_length > (reserved_length-255))
                    {
                      reserved_length+=4096;
                      info=(unsigned char *) ResizeQuantumMemory(info,(size_t)
                        reserved_length,sizeof(*info));
                      if (info == (unsigned char *) NULL)
                        {
                          meta_image=DestroyImage(meta_image);
                          ThrowReaderException(ResourceLimitError,
                            ""MemoryAllocationFailed"");
                        }
                    }
                }
                profile=BlobToStringInfo(info,(size_t) info_length);
                if (profile == (StringInfo *) NULL)
                  {
                    meta_image=DestroyImage(meta_image);
                    ThrowReaderException(ResourceLimitError,
                      ""MemoryAllocationFailed"");
                  }
                if (i8bim != MagickFalse)
                  (void) CopyMagickString(name,""8bim"",sizeof(name));
                else if (icc != MagickFalse)
                  (void) CopyMagickString(name,""icc"",sizeof(name));
                else if (iptc != MagickFalse)
                  (void) CopyMagickString(name,""iptc"",sizeof(name));
                else if (magick != MagickFalse)
                  {
                    (void) CopyMagickString(name,""magick"",sizeof(name));
                    meta_image->gamma=StringToDouble((char *) info+6,
                      (char **) NULL);
                  }
                else
                  (void) FormatLocaleString(name,sizeof(name),""gif:%.11s"",
                    buffer);
                info=(unsigned char *) RelinquishMagickMemory(info);
                if (magick == MagickFalse)
                  (void) SetImageProfile(meta_image,name,profile,exception);
                profile=DestroyStringInfo(profile);
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      profile name=%s"",name);
              }
            break;
          }
          default:
          {
            while (ReadBlobBlock(image,buffer) != 0) ;
            break;
          }
        }
      }
    if (c != (unsigned char) ',')
      continue;
    if (image_count != 0)
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
      }
    image_count++;
    /*
      Read image attributes.
    */
    meta_image->scene=image->scene;
    (void) CloneImageProperties(image,meta_image);
    DestroyImageProperties(meta_image);
    (void) CloneImageProfiles(image,meta_image);
    DestroyImageProfiles(meta_image);
    image->storage_class=PseudoClass;
    image->compression=LZWCompression;
    page.x=(ssize_t) ReadBlobLSBShort(image);
    page.y=(ssize_t) ReadBlobLSBShort(image);
    image->columns=ReadBlobLSBShort(image);
    image->rows=ReadBlobLSBShort(image);
    image->depth=8;
    flag=(unsigned char) ReadBlobByte(image);
    image->interlace=BitSet((int) flag,0x40) != 0 ? GIFInterlace : NoInterlace;
    image->colors=BitSet((int) flag,0x80) == 0 ? global_colors : one <<
      ((size_t) (flag & 0x07)+1);
    if (opacity >= (ssize_t) image->colors)
      opacity=(-1);
    image->page.width=page.width;
    image->page.height=page.height;
    image->page.y=page.y;
    image->page.x=page.x;
    image->delay=delay;
    image->ticks_per_second=100;
    image->dispose=(DisposeType) dispose;
    image->iterations=iterations;
    image->alpha_trait=opacity >= 0 ? BlendPixelTrait : UndefinedPixelTrait;
    delay=0;
    dispose=0;
    if ((image->columns == 0) || (image->rows == 0))
      {
        global_colormap=(unsigned char *) RelinquishMagickMemory(
          global_colormap);
        meta_image=DestroyImage(meta_image);
        ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
      }
    /*
      Inititialize colormap.
    */
    if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
      {
        global_colormap=(unsigned char *) RelinquishMagickMemory(
          global_colormap);
        meta_image=DestroyImage(meta_image);
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    if (BitSet((int) flag,0x80) == 0)
      {
        /*
          Use global colormap.
        */
        p=global_colormap;
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);
          if (i == opacity)
            {
              image->colormap[i].alpha=(double) TransparentAlpha;
              image->transparent_color=image->colormap[opacity];
            }
        }
        image->background_color=image->colormap[MagickMin((ssize_t) background,
          (ssize_t) image->colors-1)];
      }
    else
      {
        unsigned char
          *colormap;

        /*
          Read local colormap.
        */
        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,3*
          sizeof(*colormap));
        if (colormap == (unsigned char *) NULL)
          {
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            meta_image=DestroyImage(meta_image);
            ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
          }
        count=ReadBlob(image,(3*image->colors)*sizeof(*colormap),colormap);
        if (count != (ssize_t) (3*image->colors))
          {
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            colormap=(unsigned char *) RelinquishMagickMemory(colormap);
            meta_image=DestroyImage(meta_image);
            ThrowReaderException(CorruptImageError,
              ""InsufficientImageDataInFile"");
          }
        p=colormap;
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);
          if (i == opacity)
            image->colormap[i].alpha=(double) TransparentAlpha;
        }
        colormap=(unsigned char *) RelinquishMagickMemory(colormap);
      }
    if (image->gamma == 1.0)
      {
        for (i=0; i < (ssize_t) image->colors; i++)
          if (IsPixelInfoGray(image->colormap+i) == MagickFalse)
            break;
        (void) SetImageColorspace(image,i == (ssize_t) image->colors ? 
          GRAYColorspace : RGBColorspace,exception);
      }
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    /*
      Decode image.
    */
    if (image_info->ping != MagickFalse)
      status=PingGIFImage(image,exception);
    else
      status=DecodeImage(image,opacity,exception);
    if ((image_info->ping == MagickFalse) && (status == MagickFalse))
      {
        global_colormap=(unsigned char *) RelinquishMagickMemory(
          global_colormap);
        meta_image=DestroyImage(meta_image);
        ThrowReaderException(CorruptImageError,""CorruptImage"");
      }
    duration+=image->delay*image->iterations;
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    opacity=(-1);
    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) image->scene-
      1,image->scene);
    if (status == MagickFalse)
      break;
  }
  image->duration=duration;
  meta_image=DestroyImage(meta_image);
  global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);
  if ((image->columns == 0) || (image->rows == 0))
    ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","static Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define BitSet(byte,bit)  (((byte) & (bit)) == (bit))
#define LSBFirstOrder(x,y)  (((y) << 8) | (x))

  Image
    *image,
    *meta_image;

  int
    number_extensionss=0;

  MagickBooleanType
    status;

  RectangleInfo
    page;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    delay,
    dispose,
    duration,
    global_colors,
    image_count,
    iterations,
    one;

  ssize_t
    count,
    opacity;

  unsigned char
    background,
    c,
    flag,
    *global_colormap,
    buffer[257];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Determine if this a GIF file.
  */
  count=ReadBlob(image,6,buffer);
  if ((count != 6) || ((LocaleNCompare((char *) buffer,""GIF87"",5) != 0) &&
      (LocaleNCompare((char *) buffer,""GIF89"",5) != 0)))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  page.width=ReadBlobLSBShort(image);
  page.height=ReadBlobLSBShort(image);
  flag=(unsigned char) ReadBlobByte(image);
  background=(unsigned char) ReadBlobByte(image);
  c=(unsigned char) ReadBlobByte(image);  /* reserved */
  one=1;
  global_colors=one << (((size_t) flag & 0x07)+1);
  global_colormap=(unsigned char *) AcquireQuantumMemory((size_t)
     MagickMax(global_colors,256),3UL*sizeof(*global_colormap));
   if (global_colormap == (unsigned char *) NULL)
     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  (void) ResetMagickMemory(global_colormap,0,3*MagickMax(global_colors,256)*
    sizeof(*global_colormap));
   if (BitSet((int) flag,0x80) != 0)
     {
       count=ReadBlob(image,(size_t) (3*global_colors),global_colormap);
      if (count != (ssize_t) (3*global_colors))
        {
          global_colormap=(unsigned char *) RelinquishMagickMemory(
            global_colormap);
          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
        }
    }
  delay=0;
  dispose=0;
  duration=0;
  iterations=1;
  opacity=(-1);
  image_count=0;
  meta_image=AcquireImage(image_info,exception);  /* metadata container */
  for ( ; ; )
  {
    count=ReadBlob(image,1,&c);
    if (count != 1)
      break;
    if (c == (unsigned char) ';')
      break;  /* terminator */
    if (c == (unsigned char) '!')
      {
        /*
          GIF Extension block.
        */
        count=ReadBlob(image,1,&c);
        if (count != 1)
          {
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            meta_image=DestroyImage(meta_image);
            ThrowReaderException(CorruptImageError,
              ""UnableToReadExtensionBlock"");
          }
        switch (c)
        {
          case 0xf9:
          {
            /*
              Read graphics control extension.
            */
            while (ReadBlobBlock(image,buffer) != 0) ;
            dispose=(size_t) (buffer[0] >> 2);
            delay=(size_t) ((buffer[2] << 8) | buffer[1]);
            if ((ssize_t) (buffer[0] & 0x01) == 0x01)
              opacity=(ssize_t) buffer[3];
            break;
          }
          case 0xfe:
          {
            char
              *comments;

            size_t
              length;

            /*
              Read comment extension.
            */
            comments=AcquireString((char *) NULL);
            for (length=0; ; length+=count)
            {
              count=(ssize_t) ReadBlobBlock(image,buffer);
              if (count == 0)
                break;
              buffer[count]='\0';
              (void) ConcatenateString(&comments,(const char *) buffer);
            }
            (void) SetImageProperty(meta_image,""comment"",comments,exception);
            comments=DestroyString(comments);
            break;
          }
          case 0xff:
          {
            MagickBooleanType
              loop;

            /*
              Read Netscape Loop extension.
            */
            loop=MagickFalse;
            if (ReadBlobBlock(image,buffer) != 0)
              loop=LocaleNCompare((char *) buffer,""NETSCAPE2.0"",11) == 0 ?
                MagickTrue : MagickFalse;
            if (loop != MagickFalse)
              {
                while (ReadBlobBlock(image,buffer) != 0)
                  iterations=(size_t) ((buffer[2] << 8) | buffer[1]);
                break;
              }
            else
              {
                char
                  name[MagickPathExtent];

                int
                  block_length,
                  info_length,
                  reserved_length;

                MagickBooleanType
                  i8bim,
                  icc,
                  iptc,
                  magick;

                StringInfo
                  *profile;

                unsigned char
                  *info;

                /*
                  Store GIF application extension as a generic profile.
                */
                icc=LocaleNCompare((char *) buffer,""ICCRGBG1012"",11) == 0 ?
                  MagickTrue : MagickFalse;
                magick=LocaleNCompare((char *) buffer,""ImageMagick"",11) == 0 ?
                  MagickTrue : MagickFalse;
                i8bim=LocaleNCompare((char *) buffer,""MGK8BIM0000"",11) == 0 ?
                  MagickTrue : MagickFalse;
                iptc=LocaleNCompare((char *) buffer,""MGKIPTC0000"",11) == 0 ?
                  MagickTrue : MagickFalse;
                number_extensionss++;
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""    Reading GIF application extension"");
                info=(unsigned char *) AcquireQuantumMemory(255UL,
                  sizeof(*info));
                if (info == (unsigned char *) NULL)
                  {
                    meta_image=DestroyImage(meta_image);
                    ThrowReaderException(ResourceLimitError,
                      ""MemoryAllocationFailed"");
                  }
                reserved_length=255;
                for (info_length=0; ; )
                {
                  block_length=(int) ReadBlobBlock(image,&info[info_length]);
                  if (block_length == 0)
                    break;
                  info_length+=block_length;
                  if (info_length > (reserved_length-255))
                    {
                      reserved_length+=4096;
                      info=(unsigned char *) ResizeQuantumMemory(info,(size_t)
                        reserved_length,sizeof(*info));
                      if (info == (unsigned char *) NULL)
                        {
                          meta_image=DestroyImage(meta_image);
                          ThrowReaderException(ResourceLimitError,
                            ""MemoryAllocationFailed"");
                        }
                    }
                }
                profile=BlobToStringInfo(info,(size_t) info_length);
                if (profile == (StringInfo *) NULL)
                  {
                    meta_image=DestroyImage(meta_image);
                    ThrowReaderException(ResourceLimitError,
                      ""MemoryAllocationFailed"");
                  }
                if (i8bim != MagickFalse)
                  (void) CopyMagickString(name,""8bim"",sizeof(name));
                else if (icc != MagickFalse)
                  (void) CopyMagickString(name,""icc"",sizeof(name));
                else if (iptc != MagickFalse)
                  (void) CopyMagickString(name,""iptc"",sizeof(name));
                else if (magick != MagickFalse)
                  {
                    (void) CopyMagickString(name,""magick"",sizeof(name));
                    meta_image->gamma=StringToDouble((char *) info+6,
                      (char **) NULL);
                  }
                else
                  (void) FormatLocaleString(name,sizeof(name),""gif:%.11s"",
                    buffer);
                info=(unsigned char *) RelinquishMagickMemory(info);
                if (magick == MagickFalse)
                  (void) SetImageProfile(meta_image,name,profile,exception);
                profile=DestroyStringInfo(profile);
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      profile name=%s"",name);
              }
            break;
          }
          default:
          {
            while (ReadBlobBlock(image,buffer) != 0) ;
            break;
          }
        }
      }
    if (c != (unsigned char) ',')
      continue;
    if (image_count != 0)
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
      }
    image_count++;
    /*
      Read image attributes.
    */
    meta_image->scene=image->scene;
    (void) CloneImageProperties(image,meta_image);
    DestroyImageProperties(meta_image);
    (void) CloneImageProfiles(image,meta_image);
    DestroyImageProfiles(meta_image);
    image->storage_class=PseudoClass;
    image->compression=LZWCompression;
    page.x=(ssize_t) ReadBlobLSBShort(image);
    page.y=(ssize_t) ReadBlobLSBShort(image);
    image->columns=ReadBlobLSBShort(image);
    image->rows=ReadBlobLSBShort(image);
    image->depth=8;
    flag=(unsigned char) ReadBlobByte(image);
    image->interlace=BitSet((int) flag,0x40) != 0 ? GIFInterlace : NoInterlace;
    image->colors=BitSet((int) flag,0x80) == 0 ? global_colors : one <<
      ((size_t) (flag & 0x07)+1);
    if (opacity >= (ssize_t) image->colors)
      opacity=(-1);
    image->page.width=page.width;
    image->page.height=page.height;
    image->page.y=page.y;
    image->page.x=page.x;
    image->delay=delay;
    image->ticks_per_second=100;
    image->dispose=(DisposeType) dispose;
    image->iterations=iterations;
    image->alpha_trait=opacity >= 0 ? BlendPixelTrait : UndefinedPixelTrait;
    delay=0;
    dispose=0;
    if ((image->columns == 0) || (image->rows == 0))
      {
        global_colormap=(unsigned char *) RelinquishMagickMemory(
          global_colormap);
        meta_image=DestroyImage(meta_image);
        ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
      }
    /*
      Inititialize colormap.
    */
    if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
      {
        global_colormap=(unsigned char *) RelinquishMagickMemory(
          global_colormap);
        meta_image=DestroyImage(meta_image);
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    if (BitSet((int) flag,0x80) == 0)
      {
        /*
          Use global colormap.
        */
        p=global_colormap;
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);
          if (i == opacity)
            {
              image->colormap[i].alpha=(double) TransparentAlpha;
              image->transparent_color=image->colormap[opacity];
            }
        }
        image->background_color=image->colormap[MagickMin((ssize_t) background,
          (ssize_t) image->colors-1)];
      }
    else
      {
        unsigned char
          *colormap;

        /*
          Read local colormap.
        */
        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,3*
          sizeof(*colormap));
        if (colormap == (unsigned char *) NULL)
          {
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            meta_image=DestroyImage(meta_image);
            ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
          }
        count=ReadBlob(image,(3*image->colors)*sizeof(*colormap),colormap);
        if (count != (ssize_t) (3*image->colors))
          {
            global_colormap=(unsigned char *) RelinquishMagickMemory(
              global_colormap);
            colormap=(unsigned char *) RelinquishMagickMemory(colormap);
            meta_image=DestroyImage(meta_image);
            ThrowReaderException(CorruptImageError,
              ""InsufficientImageDataInFile"");
          }
        p=colormap;
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);
          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);
          if (i == opacity)
            image->colormap[i].alpha=(double) TransparentAlpha;
        }
        colormap=(unsigned char *) RelinquishMagickMemory(colormap);
      }
    if (image->gamma == 1.0)
      {
        for (i=0; i < (ssize_t) image->colors; i++)
          if (IsPixelInfoGray(image->colormap+i) == MagickFalse)
            break;
        (void) SetImageColorspace(image,i == (ssize_t) image->colors ? 
          GRAYColorspace : RGBColorspace,exception);
      }
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    /*
      Decode image.
    */
    if (image_info->ping != MagickFalse)
      status=PingGIFImage(image,exception);
    else
      status=DecodeImage(image,opacity,exception);
    if ((image_info->ping == MagickFalse) && (status == MagickFalse))
      {
        global_colormap=(unsigned char *) RelinquishMagickMemory(
          global_colormap);
        meta_image=DestroyImage(meta_image);
        ThrowReaderException(CorruptImageError,""CorruptImage"");
      }
    duration+=image->delay*image->iterations;
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    opacity=(-1);
    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) image->scene-
      1,image->scene);
    if (status == MagickFalse)
      break;
  }
  image->duration=duration;
  meta_image=DestroyImage(meta_image);
  global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);
  if ((image->columns == 0) || (image->rows == 0))
    ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","The `ReadGIFImage` function is designed to read and decode GIF image files, handling both the image data and associated metadata. It begins by validating the input parameters and opening the image file, then checks the file header to confirm it is a valid GIF format. The function reads global color maps, image dimensions, and various GIF extensions, including graphics control and comment extensions. It processes multiple images within a GIF, managing properties like disposal methods and delays. Finally, it decodes the image data, sets the image properties, and returns the first image in the list, ensuring proper memory management throughout.","The provided code is responsible for reading and decoding GIF image files, ensuring the integrity of the file format and extracting both image data and metadata. It begins by validating the input and opening the file, then checks the header to confirm it is a valid GIF. The code processes global color maps and various extensions, such as graphics control and comments, while managing multiple images within a single GIF. It sets properties like disposal methods and delays, decodes the image data, and returns the first image in the list, all while maintaining efficient memory management.","The vulnerability in the original code stemmed from a lack of proper initialization for the global color map, which could lead to memory corruption or undefined behavior if the GIF file did not contain sufficient data. Specifically, the code did not reset the memory allocated for the global color map, potentially leaving it in an inconsistent state. The fix involved adding a memory reset operation using `ResetMagickMemory`, ensuring that the global color map is initialized to zero before it is populated with data. This change enhances the robustness of the code by preventing the use of uninitialized memory, thereby mitigating potential security risks.","The vulnerability in the original code was due to insufficient initialization of memory allocated for the color map, which could lead to memory corruption or unpredictable behavior when processing GIF files with inadequate data. This oversight could allow for the use of uninitialized memory, posing security risks. The fix involved implementing a memory reset operation to ensure that the allocated memory for the color map is properly initialized to zero before being populated with actual data. This change enhances the code's stability and security by preventing the potential exploitation of uninitialized memory, thereby mitigating associated risks.","The vulnerability was fixed by adding a memory reset operation using `ResetMagickMemory` for the `global_colormap` after it was allocated. This ensures that the memory is initialized to zero, preventing any potential use of uninitialized data that could lead to memory corruption or undefined behavior. Specifically, the line `ResetMagickMemory(global_colormap, 0, 3 * MagickMax(global_colors, 256) * sizeof(*global_colormap));` was introduced to clear the memory before it is populated with color data. This change enhances the code's reliability and security when handling GIF files with insufficient data.","The vulnerability was addressed by incorporating a memory reset operation immediately after allocating memory for the color map. This step ensures that the allocated memory is initialized to zero, thereby preventing the use of any uninitialized data that could lead to memory corruption or unpredictable behavior. By clearing the memory before it is populated with actual color data, the fix enhances the stability and security of the code, mitigating the risks associated with processing GIF files that may contain insufficient data. This change ultimately contributes to more robust and reliable image handling.","5, 5","5, 5","4,3","5,5"
67,67,180942,180942,,Local,Not required,,CVE-2017-14140,https://www.cvedetails.com/cve/CVE-2017-14140/,CWE-200,Low,Partial,,,2017-09-05,2.1,"The move_pages system call in mm/migrate.c in the Linux kernel before 4.12.9 doesn't check the effective uid of the target process, enabling a local attacker to learn the memory layout of a setuid executable despite ASLR.",2018-04-11,+Info ,2,https://github.com/torvalds/linux/commit/197e7e521384a23b9e585178f3f11c9fa08274b9,197e7e521384a23b9e585178f3f11c9fa08274b9,"Sanitize 'move_pages()' permission checks

The 'move_paghes()' system call was introduced long long ago with the
same permission checks as for sending a signal (except using
CAP_SYS_NICE instead of CAP_SYS_KILL for the overriding capability).

That turns out to not be a great choice - while the system call really
only moves physical page allocations around (and you need other
capabilities to do a lot of it), you can check the return value to map
out some the virtual address choices and defeat ASLR of a binary that
still shares your uid.

So change the access checks to the more common 'ptrace_may_access()'
model instead.

This tightens the access checks for the uid, and also effectively
changes the CAP_SYS_NICE check to CAP_SYS_PTRACE, but it's unlikely that
anybody really _uses_ this legacy system call any more (we hav ebetter
NUMA placement models these days), so I expect nobody to notice.

Famous last words.

Reported-by: Otto Ebeling <otto.ebeling@iki.fi>
Acked-by: Eric W. Biederman <ebiederm@xmission.com>
Cc: Willy Tarreau <w@1wt.eu>
Cc: stable@kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",8,mm/migrate.c,"{""sha"": ""e84eeb4e43566c7b1ee85e3759b1b60b72c1c532"", ""filename"": ""mm/migrate.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 8, ""changes"": 11, ""blob_url"": ""https://github.com/torvalds/linux/blob/197e7e521384a23b9e585178f3f11c9fa08274b9/mm/migrate.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/197e7e521384a23b9e585178f3f11c9fa08274b9/mm/migrate.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/migrate.c?ref=197e7e521384a23b9e585178f3f11c9fa08274b9"", ""patch"": ""@@ -41,6 +41,7 @@\n #include <linux/page_idle.h>\n #include <linux/page_owner.h>\n #include <linux/sched/mm.h>\n+#include <linux/ptrace.h>\n \n #include <asm/tlbflush.h>\n \n@@ -1652,7 +1653,6 @@ SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,\n \t\tconst int __user *, nodes,\n \t\tint __user *, status, int, flags)\n {\n-\tconst struct cred *cred = current_cred(), *tcred;\n \tstruct task_struct *task;\n \tstruct mm_struct *mm;\n \tint err;\n@@ -1676,14 +1676,9 @@ SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,\n \n \t/*\n \t * Check if this process has the right to modify the specified\n-\t * process. The right exists if the process has administrative\n-\t * capabilities, superuser privileges or the same\n-\t * userid as the target process.\n+\t * process. Use the regular \""ptrace_may_access()\"" checks.\n \t */\n-\ttcred = __task_cred(task);\n-\tif (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&\n-\t    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&\n-\t    !capable(CAP_SYS_NICE)) {\n+\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {\n \t\trcu_read_unlock();\n \t\terr = -EPERM;\n \t\tgoto out;""}","SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,
		const void __user * __user *, pages,
 		const int __user *, nodes,
 		int __user *, status, int, flags)
 {
 	struct task_struct *task;
 	struct mm_struct *mm;
 	int err;
	nodemask_t task_nodes;

	/* Check flags */
	if (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))
		return -EINVAL;

	if ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))
		return -EPERM;

	/* Find the mm_struct */
	rcu_read_lock();
	task = pid ? find_task_by_vpid(pid) : current;
	if (!task) {
		rcu_read_unlock();
		return -ESRCH;
	}
	get_task_struct(task);
 
 	/*
 	 * Check if this process has the right to modify the specified
	 * process. Use the regular ""ptrace_may_access()"" checks.
 	 */
	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {
 		rcu_read_unlock();
 		err = -EPERM;
 		goto out;
	}
	rcu_read_unlock();

 	err = security_task_movememory(task);
 	if (err)
		goto out;

	task_nodes = cpuset_mems_allowed(task);
	mm = get_task_mm(task);
	put_task_struct(task);

	if (!mm)
		return -EINVAL;

	if (nodes)
		err = do_pages_move(mm, task_nodes, nr_pages, pages,
				    nodes, status, flags);
	else
		err = do_pages_stat(mm, nr_pages, pages, status);

	mmput(mm);
	return err;

out:
	put_task_struct(task);
	return err;
}
","SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,
		const void __user * __user *, pages,
 		const int __user *, nodes,
 		int __user *, status, int, flags)
 {
	const struct cred *cred = current_cred(), *tcred;
 	struct task_struct *task;
 	struct mm_struct *mm;
 	int err;
	nodemask_t task_nodes;

	/* Check flags */
	if (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))
		return -EINVAL;

	if ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))
		return -EPERM;

	/* Find the mm_struct */
	rcu_read_lock();
	task = pid ? find_task_by_vpid(pid) : current;
	if (!task) {
		rcu_read_unlock();
		return -ESRCH;
	}
	get_task_struct(task);
 
 	/*
 	 * Check if this process has the right to modify the specified
	 * process. The right exists if the process has administrative
	 * capabilities, superuser privileges or the same
	 * userid as the target process.
 	 */
	tcred = __task_cred(task);
	if (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&
	    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&
	    !capable(CAP_SYS_NICE)) {
 		rcu_read_unlock();
 		err = -EPERM;
 		goto out;
	}
	rcu_read_unlock();

 	err = security_task_movememory(task);
 	if (err)
		goto out;

	task_nodes = cpuset_mems_allowed(task);
	mm = get_task_mm(task);
	put_task_struct(task);

	if (!mm)
		return -EINVAL;

	if (nodes)
		err = do_pages_move(mm, task_nodes, nr_pages, pages,
				    nodes, status, flags);
	else
		err = do_pages_stat(mm, nr_pages, pages, status);

	mmput(mm);
	return err;

out:
	put_task_struct(task);
	return err;
}
",C,"	 * process. Use the regular ""ptrace_may_access()"" checks.
	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {
","	const struct cred *cred = current_cred(), *tcred;
	 * process. The right exists if the process has administrative
	 * capabilities, superuser privileges or the same
	 * userid as the target process.
	tcred = __task_cred(task);
	if (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&
	    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&
	    !capable(CAP_SYS_NICE)) {
",,"@@ -41,6 +41,7 @@
 #include <linux/page_idle.h>
 #include <linux/page_owner.h>
 #include <linux/sched/mm.h>
+#include <linux/ptrace.h>
 
 #include <asm/tlbflush.h>
 
@@ -1652,7 +1653,6 @@ SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,
 		const int __user *, nodes,
 		int __user *, status, int, flags)
 {
-	const struct cred *cred = current_cred(), *tcred;
 	struct task_struct *task;
 	struct mm_struct *mm;
 	int err;
@@ -1676,14 +1676,9 @@ SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,
 
 	/*
 	 * Check if this process has the right to modify the specified
-	 * process. The right exists if the process has administrative
-	 * capabilities, superuser privileges or the same
-	 * userid as the target process.
+	 * process. Use the regular ""ptrace_may_access()"" checks.
 	 */
-	tcred = __task_cred(task);
-	if (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&
-	    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&
-	    !capable(CAP_SYS_NICE)) {
+	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {
 		rcu_read_unlock();
 		err = -EPERM;
 		goto out;",linux,197e7e521384a23b9e585178f3f11c9fa08274b9,7f680d7ec3153dffc4d37aea517ead2b9fb9b8e9,1,"SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,
		const void __user * __user *, pages,
 		const int __user *, nodes,
 		int __user *, status, int, flags)
 {
//flaw_line_below:
	const struct cred *cred = current_cred(), *tcred;
 	struct task_struct *task;
 	struct mm_struct *mm;
 	int err;
	nodemask_t task_nodes;

	/* Check flags */
	if (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))
		return -EINVAL;

	if ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))
		return -EPERM;

	/* Find the mm_struct */
	rcu_read_lock();
	task = pid ? find_task_by_vpid(pid) : current;
	if (!task) {
		rcu_read_unlock();
		return -ESRCH;
	}
	get_task_struct(task);
 
 	/*
 	 * Check if this process has the right to modify the specified
//flaw_line_below:
	 * process. The right exists if the process has administrative
//flaw_line_below:
	 * capabilities, superuser privileges or the same
//flaw_line_below:
	 * userid as the target process.
//fix_flaw_line_below:
//	 * process. Use the regular ""ptrace_may_access()"" checks.
 	 */
//flaw_line_below:
	tcred = __task_cred(task);
//flaw_line_below:
	if (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&
//flaw_line_below:
	    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&
//flaw_line_below:
	    !capable(CAP_SYS_NICE)) {
//fix_flaw_line_below:
//	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {
 		rcu_read_unlock();
 		err = -EPERM;
 		goto out;
	}
	rcu_read_unlock();

 	err = security_task_movememory(task);
 	if (err)
		goto out;

	task_nodes = cpuset_mems_allowed(task);
	mm = get_task_mm(task);
	put_task_struct(task);

	if (!mm)
		return -EINVAL;

	if (nodes)
		err = do_pages_move(mm, task_nodes, nr_pages, pages,
				    nodes, status, flags);
	else
		err = do_pages_stat(mm, nr_pages, pages, status);

	mmput(mm);
	return err;

out:
	put_task_struct(task);
	return err;
}
",180942,"SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,
		const void __user * __user *, pages,
 		const int __user *, nodes,
 		int __user *, status, int, flags)
 {
	const struct cred *cred = current_cred(), *tcred;
 	struct task_struct *task;
 	struct mm_struct *mm;
 	int err;
	nodemask_t task_nodes;

	/* Check flags */
	if (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))
		return -EINVAL;

	if ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))
		return -EPERM;

	/* Find the mm_struct */
	rcu_read_lock();
	task = pid ? find_task_by_vpid(pid) : current;
	if (!task) {
		rcu_read_unlock();
		return -ESRCH;
	}
	get_task_struct(task);
 
 	/*
 	 * Check if this process has the right to modify the specified
	 * process. The right exists if the process has administrative
	 * capabilities, superuser privileges or the same
	 * userid as the target process.
 	 */
	tcred = __task_cred(task);
	if (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&
	    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&
	    !capable(CAP_SYS_NICE)) {
 		rcu_read_unlock();
 		err = -EPERM;
 		goto out;
	}
	rcu_read_unlock();

 	err = security_task_movememory(task);
 	if (err)
		goto out;

	task_nodes = cpuset_mems_allowed(task);
	mm = get_task_mm(task);
	put_task_struct(task);

	if (!mm)
		return -EINVAL;

	if (nodes)
		err = do_pages_move(mm, task_nodes, nr_pages, pages,
				    nodes, status, flags);
	else
		err = do_pages_stat(mm, nr_pages, pages, status);

	mmput(mm);
	return err;

out:
	put_task_struct(task);
	return err;
}
","SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,
		const void __user * __user *, pages,
 		const int __user *, nodes,
 		int __user *, status, int, flags)
 {
 	struct task_struct *task;
 	struct mm_struct *mm;
 	int err;
	nodemask_t task_nodes;

	/* Check flags */
	if (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))
		return -EINVAL;

	if ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))
		return -EPERM;

	/* Find the mm_struct */
	rcu_read_lock();
	task = pid ? find_task_by_vpid(pid) : current;
	if (!task) {
		rcu_read_unlock();
		return -ESRCH;
	}
	get_task_struct(task);
 
 	/*
 	 * Check if this process has the right to modify the specified
	 * process. Use the regular ""ptrace_may_access()"" checks.
 	 */
	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {
 		rcu_read_unlock();
 		err = -EPERM;
 		goto out;
	}
	rcu_read_unlock();

 	err = security_task_movememory(task);
 	if (err)
		goto out;

	task_nodes = cpuset_mems_allowed(task);
	mm = get_task_mm(task);
	put_task_struct(task);

	if (!mm)
		return -EINVAL;

	if (nodes)
		err = do_pages_move(mm, task_nodes, nr_pages, pages,
				    nodes, status, flags);
	else
		err = do_pages_stat(mm, nr_pages, pages, status);

	mmput(mm);
	return err;

out:
	put_task_struct(task);
	return err;
}
","The provided code defines a system call in the Linux kernel, `move_pages`, which facilitates the movement of memory pages between nodes in a NUMA (Non-Uniform Memory Access) architecture. It takes parameters such as the target process ID, the number of pages to move, arrays of page addresses and node identifiers, a status array for reporting results, and flags to control the operation. The function first checks permissions and validates the input, ensuring the calling process has the necessary rights to modify the target process's memory. It then either moves the specified pages or retrieves their status, returning an error code if any checks fail or if the operation cannot be completed.","The code implements a system call that allows a process to move memory pages between different nodes in a NUMA architecture or to retrieve their status. It begins by validating the input parameters and checking the caller's permissions to ensure they have the right to modify the target process's memory. After confirming the necessary rights, it either executes the page movement or gathers information about the specified pages. The function handles various error conditions, returning appropriate error codes if any checks fail or if the requested operation cannot be performed, ensuring safe and controlled memory management.","The vulnerability in the original code stemmed from inadequate permission checks, allowing processes to exploit the `move_pages` system call to infer memory layout and defeat Address Space Layout Randomization (ASLR) by leveraging the return values. The fix implemented a more stringent access control mechanism by replacing the original checks with `ptrace_may_access`, which ensures that only processes with appropriate permissions can access the target process's memory. This change not only tightens the access checks based on user IDs but also modifies the capability requirement from `CAP_SYS_NICE` to `CAP_SYS_PTRACE`, enhancing overall security.","The vulnerability in the original code arose from insufficient permission checks, which allowed processes to exploit the system call to infer memory layout and bypass security measures like Address Space Layout Randomization (ASLR). This was due to the use of outdated permission checks that were not stringent enough for the operations being performed. The fix involved replacing these checks with a more robust model that enforces stricter access controls, ensuring that only processes with the appropriate permissions can interact with the target process's memory. This change enhances security by preventing unauthorized access and potential exploitation of memory information.","The vulnerability was fixed by replacing the original permission checks with the `ptrace_may_access` function, which enforces stricter access controls based on user IDs. This change ensures that only processes with the appropriate permissions can access the memory of the target process, thereby mitigating the risk of inferring memory layout and defeating ASLR. Additionally, the capability requirement was effectively changed from `CAP_SYS_NICE` to `CAP_SYS_PTRACE`, tightening the security model. This adjustment not only enhances the overall integrity of the system call but also aligns it with more modern security practices.","The vulnerability was addressed by implementing a more stringent access control mechanism that replaced the original permission checks. This new approach ensures that only processes with the appropriate permissions can access the memory of the target process, thereby reducing the risk of unauthorized memory access and exploitation. Additionally, the capability requirement was updated to align with modern security standards, further tightening the access controls. These changes enhance the overall security of the system call, preventing potential attackers from inferring memory layout and bypassing security measures designed to protect the system's integrity.","5,5","5,5","4,4","4,4"
68,68,180958,180958,,Local,Not required,,CVE-2017-13695,https://www.cvedetails.com/cve/CVE-2017-13695/,CWE-200,Low,Partial,,,2017-08-25,2.1,"The acpi_ns_evaluate() function in drivers/acpi/acpica/nseval.c in the Linux kernel through 4.12.9 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.",2018-09-11,Bypass +Info ,10,https://github.com/acpica/acpica/pull/296/commits/37f2c716f2c6ab14c3ba557a539c3ee3224931b5,37f2c716f2c6ab14c3ba557a539c3ee3224931b5,"acpi: acpica: fix acpi operand cache leak in nseval.c

I found an ACPI cache leak in ACPI early termination and boot continuing case.

When early termination occurs due to malicious ACPI table, Linux kernel
terminates ACPI function and continues to boot process. While kernel terminates
ACPI function, kmem_cache_destroy() reports Acpi-Operand cache leak.

Boot log of ACPI operand cache leak is as follows:
>[    0.464168] ACPI: Added _OSI(Module Device)
>[    0.467022] ACPI: Added _OSI(Processor Device)
>[    0.469376] ACPI: Added _OSI(3.0 _SCP Extensions)
>[    0.471647] ACPI: Added _OSI(Processor Aggregator Device)
>[    0.477997] ACPI Error: Null stack entry at ffff880215c0aad8 (20170303/exresop-174)
>[    0.482706] ACPI Exception: AE_AML_INTERNAL, While resolving operands for [OpcodeName unavailable] (20170303/dswexec-461)
>[    0.487503] ACPI Error: Method parse/execution failed [\DBG] (Node ffff88021710ab40), AE_AML_INTERNAL (20170303/psparse-543)
>[    0.492136] ACPI Error: Method parse/execution failed [\_SB._INI] (Node ffff88021710a618), AE_AML_INTERNAL (20170303/psparse-543)
>[    0.497683] ACPI: Interpreter enabled
>[    0.499385] ACPI: (supports S0)
>[    0.501151] ACPI: Using IOAPIC for interrupt routing
>[    0.503342] ACPI Error: Null stack entry at ffff880215c0aad8 (20170303/exresop-174)
>[    0.506522] ACPI Exception: AE_AML_INTERNAL, While resolving operands for [OpcodeName unavailable] (20170303/dswexec-461)
>[    0.510463] ACPI Error: Method parse/execution failed [\DBG] (Node ffff88021710ab40), AE_AML_INTERNAL (20170303/psparse-543)
>[    0.514477] ACPI Error: Method parse/execution failed [\_PIC] (Node ffff88021710ab18), AE_AML_INTERNAL (20170303/psparse-543)
>[    0.518867] ACPI Exception: AE_AML_INTERNAL, Evaluating _PIC (20170303/bus-991)
>[    0.522384] kmem_cache_destroy Acpi-Operand: Slab cache still has objects
>[    0.524597] CPU: 1 PID: 1 Comm: swapper/0 Not tainted 4.12.0-rc5 #26
>[    0.526795] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
>[    0.529668] Call Trace:
>[    0.530811]  ? dump_stack+0x5c/0x81
>[    0.532240]  ? kmem_cache_destroy+0x1aa/0x1c0
>[    0.533905]  ? acpi_os_delete_cache+0xa/0x10
>[    0.535497]  ? acpi_ut_delete_caches+0x3f/0x7b
>[    0.537237]  ? acpi_terminate+0xa/0x14
>[    0.538701]  ? acpi_init+0x2af/0x34f
>[    0.540008]  ? acpi_sleep_proc_init+0x27/0x27
>[    0.541593]  ? do_one_initcall+0x4e/0x1a0
>[    0.543008]  ? kernel_init_freeable+0x19e/0x21f
>[    0.546202]  ? rest_init+0x80/0x80
>[    0.547513]  ? kernel_init+0xa/0x100
>[    0.548817]  ? ret_from_fork+0x25/0x30
>[    0.550587] vgaarb: loaded
>[    0.551716] EDAC MC: Ver: 3.0.0
>[    0.553744] PCI: Probing PCI hardware
>[    0.555038] PCI host bridge to bus 0000:00
> ... Continue to boot and log is omitted ...

I analyzed this memory leak in detail and found AcpiNsEvaluate() function
only removes Info->ReturnObject in AE_CTRL_RETURN_VALUE case. But, when errors
occur, the status value is not AE_CTRL_RETURN_VALUE, and Info->ReturnObject is
also not null. Therefore, this causes acpi operand memory leak.

This cache leak causes a security threat because an old kernel (<= 4.9) shows
memory locations of kernel functions in stack dump. Some malicious users
could use this information to neutralize kernel ASLR.

I made a patch to fix ACPI operand cache leak.

Signed-off-by: Seunghun Han <kkamagui@gmail.com>",0,source/components/namespace/nseval.c,"{""sha"": ""f9913398e56ed6864cecf25bfd9c2017530c6eec"", ""filename"": ""source/components/namespace/nseval.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 0, ""changes"": 10, ""blob_url"": ""https://github.com/acpica/acpica/blob/37f2c716f2c6ab14c3ba557a539c3ee3224931b5/source/components/namespace/nseval.c"", ""raw_url"": ""https://github.com/acpica/acpica/raw/37f2c716f2c6ab14c3ba557a539c3ee3224931b5/source/components/namespace/nseval.c"", ""contents_url"": ""https://api.github.com/repos/acpica/acpica/contents/source/components/namespace/nseval.c?ref=37f2c716f2c6ab14c3ba557a539c3ee3224931b5"", ""patch"": ""@@ -428,6 +428,16 @@ AcpiNsEvaluate (\n \n         Status = AE_OK;\n     }\n+    else if (ACPI_FAILURE(Status)) \n+    {\n+        /* If ReturnObject exists, delete it */\n+\n+        if (Info->ReturnObject) \n+        {\n+            AcpiUtRemoveReference (Info->ReturnObject);\n+            Info->ReturnObject = NULL;\n+        }\n+    }\n \n     ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,\n         \""*** Completed evaluation of object %s ***\\n\"",""}","AcpiNsEvaluate (
    ACPI_EVALUATE_INFO      *Info)
{
    ACPI_STATUS             Status;


    ACPI_FUNCTION_TRACE (NsEvaluate);


    if (!Info)
    {
        return_ACPI_STATUS (AE_BAD_PARAMETER);
    }

    if (!Info->Node)
    {
        /*
         * Get the actual namespace node for the target object if we
         * need to. Handles these cases:
         *
         * 1) Null node, valid pathname from root (absolute path)
         * 2) Node and valid pathname (path relative to Node)
         * 3) Node, Null pathname
         */
        Status = AcpiNsGetNode (Info->PrefixNode, Info->RelativePathname,
            ACPI_NS_NO_UPSEARCH, &Info->Node);
        if (ACPI_FAILURE (Status))
        {
            return_ACPI_STATUS (Status);
        }
    }

    /*
     * For a method alias, we must grab the actual method node so that
     * proper scoping context will be established before execution.
     */
    if (AcpiNsGetType (Info->Node) == ACPI_TYPE_LOCAL_METHOD_ALIAS)
    {
        Info->Node = ACPI_CAST_PTR (
            ACPI_NAMESPACE_NODE, Info->Node->Object);
    }

    /* Complete the info block initialization */

    Info->ReturnObject = NULL;
    Info->NodeFlags = Info->Node->Flags;
    Info->ObjDesc = AcpiNsGetAttachedObject (Info->Node);

    ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, ""%s [%p] Value %p\n"",
        Info->RelativePathname, Info->Node,
        AcpiNsGetAttachedObject (Info->Node)));

    /* Get info if we have a predefined name (_HID, etc.) */

    Info->Predefined = AcpiUtMatchPredefinedMethod (Info->Node->Name.Ascii);

    /* Get the full pathname to the object, for use in warning messages */

    Info->FullPathname = AcpiNsGetNormalizedPathname (Info->Node, TRUE);
    if (!Info->FullPathname)
    {
        return_ACPI_STATUS (AE_NO_MEMORY);
    }

    /* Count the number of arguments being passed in */

    Info->ParamCount = 0;
    if (Info->Parameters)
    {
        while (Info->Parameters[Info->ParamCount])
        {
            Info->ParamCount++;
        }

        /* Warn on impossible argument count */

        if (Info->ParamCount > ACPI_METHOD_NUM_ARGS)
        {
            ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, ACPI_WARN_ALWAYS,
                ""Excess arguments (%u) - using only %u"",
                Info->ParamCount, ACPI_METHOD_NUM_ARGS));

            Info->ParamCount = ACPI_METHOD_NUM_ARGS;
        }
    }

    /*
     * For predefined names: Check that the declared argument count
     * matches the ACPI spec -- otherwise this is a BIOS error.
     */
    AcpiNsCheckAcpiCompliance (Info->FullPathname, Info->Node,
        Info->Predefined);

    /*
     * For all names: Check that the incoming argument count for
     * this method/object matches the actual ASL/AML definition.
     */
    AcpiNsCheckArgumentCount (Info->FullPathname, Info->Node,
        Info->ParamCount, Info->Predefined);

    /* For predefined names: Typecheck all incoming arguments */

    AcpiNsCheckArgumentTypes (Info);

    /*
     * Three major evaluation cases:
     *
     * 1) Object types that cannot be evaluated by definition
     * 2) The object is a control method -- execute it
     * 3) The object is not a method -- just return it's current value
     */
    switch (AcpiNsGetType (Info->Node))
    {
    case ACPI_TYPE_DEVICE:
    case ACPI_TYPE_EVENT:
    case ACPI_TYPE_MUTEX:
    case ACPI_TYPE_REGION:
    case ACPI_TYPE_THERMAL:
    case ACPI_TYPE_LOCAL_SCOPE:
        /*
         * 1) Disallow evaluation of certain object types. For these,
         *    object evaluation is undefined and not supported.
         */
        ACPI_ERROR ((AE_INFO,
            ""%s: Evaluation of object type [%s] is not supported"",
            Info->FullPathname,
            AcpiUtGetTypeName (Info->Node->Type)));

        Status = AE_TYPE;
        goto Cleanup;

    case ACPI_TYPE_METHOD:
        /*
         * 2) Object is a control method - execute it
         */

        /* Verify that there is a method object associated with this node */

        if (!Info->ObjDesc)
        {
            ACPI_ERROR ((AE_INFO, ""%s: Method has no attached sub-object"",
                Info->FullPathname));
            Status = AE_NULL_OBJECT;
            goto Cleanup;
        }

        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
            ""**** Execute method [%s] at AML address %p length %X\n"",
            Info->FullPathname,
            Info->ObjDesc->Method.AmlStart + 1,
            Info->ObjDesc->Method.AmlLength - 1));

        /*
         * Any namespace deletion must acquire both the namespace and
         * interpreter locks to ensure that no thread is using the portion of
         * the namespace that is being deleted.
         *
         * Execute the method via the interpreter. The interpreter is locked
         * here before calling into the AML parser
         */
        AcpiExEnterInterpreter ();
        Status = AcpiPsExecuteMethod (Info);
        AcpiExExitInterpreter ();
        break;

    default:
        /*
         * 3) All other non-method objects -- get the current object value
         */

        /*
         * Some objects require additional resolution steps (e.g., the Node
         * may be a field that must be read, etc.) -- we can't just grab
         * the object out of the node.
         *
         * Use ResolveNodeToValue() to get the associated value.
         *
         * NOTE: we can get away with passing in NULL for a walk state because
         * the Node is guaranteed to not be a reference to either a method
         * local or a method argument (because this interface is never called
         * from a running method.)
         *
         * Even though we do not directly invoke the interpreter for object
         * resolution, we must lock it because we could access an OpRegion.
         * The OpRegion access code assumes that the interpreter is locked.
         */
        AcpiExEnterInterpreter ();

        /* TBD: ResolveNodeToValue has a strange interface, fix */

        Info->ReturnObject = ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, Info->Node);

        Status = AcpiExResolveNodeToValue (ACPI_CAST_INDIRECT_PTR (
            ACPI_NAMESPACE_NODE, &Info->ReturnObject), NULL);
        AcpiExExitInterpreter ();

        if (ACPI_FAILURE (Status))
        {
            Info->ReturnObject = NULL;
            goto Cleanup;
        }

        ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, ""Returned object %p [%s]\n"",
            Info->ReturnObject,
            AcpiUtGetObjectTypeName (Info->ReturnObject)));

        Status = AE_CTRL_RETURN_VALUE; /* Always has a ""return value"" */
        break;
    }

    /*
     * For predefined names, check the return value against the ACPI
     * specification. Some incorrect return value types are repaired.
     */
    (void) AcpiNsCheckReturnValue (Info->Node, Info, Info->ParamCount,
        Status, &Info->ReturnObject);

    /* Check if there is a return value that must be dealt with */

    if (Status == AE_CTRL_RETURN_VALUE)
    {
        /* If caller does not want the return value, delete it */

        if (Info->Flags & ACPI_IGNORE_RETURN_VALUE)
        {
            AcpiUtRemoveReference (Info->ReturnObject);
            Info->ReturnObject = NULL;
        }

        /* Map AE_CTRL_RETURN_VALUE to AE_OK, we are done with it */
 
         Status = AE_OK;
     }
    else if (ACPI_FAILURE(Status)) 
    {
        /* If ReturnObject exists, delete it */

        if (Info->ReturnObject) 
        {
            AcpiUtRemoveReference (Info->ReturnObject);
            Info->ReturnObject = NULL;
        }
    }
 
     ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
         ""*** Completed evaluation of object %s ***\n"",
        Info->RelativePathname));

Cleanup:
    /*
     * Namespace was unlocked by the handling AcpiNs* function, so we
     * just free the pathname and return
     */
    ACPI_FREE (Info->FullPathname);
    Info->FullPathname = NULL;
    return_ACPI_STATUS (Status);
}
","AcpiNsEvaluate (
    ACPI_EVALUATE_INFO      *Info)
{
    ACPI_STATUS             Status;


    ACPI_FUNCTION_TRACE (NsEvaluate);


    if (!Info)
    {
        return_ACPI_STATUS (AE_BAD_PARAMETER);
    }

    if (!Info->Node)
    {
        /*
         * Get the actual namespace node for the target object if we
         * need to. Handles these cases:
         *
         * 1) Null node, valid pathname from root (absolute path)
         * 2) Node and valid pathname (path relative to Node)
         * 3) Node, Null pathname
         */
        Status = AcpiNsGetNode (Info->PrefixNode, Info->RelativePathname,
            ACPI_NS_NO_UPSEARCH, &Info->Node);
        if (ACPI_FAILURE (Status))
        {
            return_ACPI_STATUS (Status);
        }
    }

    /*
     * For a method alias, we must grab the actual method node so that
     * proper scoping context will be established before execution.
     */
    if (AcpiNsGetType (Info->Node) == ACPI_TYPE_LOCAL_METHOD_ALIAS)
    {
        Info->Node = ACPI_CAST_PTR (
            ACPI_NAMESPACE_NODE, Info->Node->Object);
    }

    /* Complete the info block initialization */

    Info->ReturnObject = NULL;
    Info->NodeFlags = Info->Node->Flags;
    Info->ObjDesc = AcpiNsGetAttachedObject (Info->Node);

    ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, ""%s [%p] Value %p\n"",
        Info->RelativePathname, Info->Node,
        AcpiNsGetAttachedObject (Info->Node)));

    /* Get info if we have a predefined name (_HID, etc.) */

    Info->Predefined = AcpiUtMatchPredefinedMethod (Info->Node->Name.Ascii);

    /* Get the full pathname to the object, for use in warning messages */

    Info->FullPathname = AcpiNsGetNormalizedPathname (Info->Node, TRUE);
    if (!Info->FullPathname)
    {
        return_ACPI_STATUS (AE_NO_MEMORY);
    }

    /* Count the number of arguments being passed in */

    Info->ParamCount = 0;
    if (Info->Parameters)
    {
        while (Info->Parameters[Info->ParamCount])
        {
            Info->ParamCount++;
        }

        /* Warn on impossible argument count */

        if (Info->ParamCount > ACPI_METHOD_NUM_ARGS)
        {
            ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, ACPI_WARN_ALWAYS,
                ""Excess arguments (%u) - using only %u"",
                Info->ParamCount, ACPI_METHOD_NUM_ARGS));

            Info->ParamCount = ACPI_METHOD_NUM_ARGS;
        }
    }

    /*
     * For predefined names: Check that the declared argument count
     * matches the ACPI spec -- otherwise this is a BIOS error.
     */
    AcpiNsCheckAcpiCompliance (Info->FullPathname, Info->Node,
        Info->Predefined);

    /*
     * For all names: Check that the incoming argument count for
     * this method/object matches the actual ASL/AML definition.
     */
    AcpiNsCheckArgumentCount (Info->FullPathname, Info->Node,
        Info->ParamCount, Info->Predefined);

    /* For predefined names: Typecheck all incoming arguments */

    AcpiNsCheckArgumentTypes (Info);

    /*
     * Three major evaluation cases:
     *
     * 1) Object types that cannot be evaluated by definition
     * 2) The object is a control method -- execute it
     * 3) The object is not a method -- just return it's current value
     */
    switch (AcpiNsGetType (Info->Node))
    {
    case ACPI_TYPE_DEVICE:
    case ACPI_TYPE_EVENT:
    case ACPI_TYPE_MUTEX:
    case ACPI_TYPE_REGION:
    case ACPI_TYPE_THERMAL:
    case ACPI_TYPE_LOCAL_SCOPE:
        /*
         * 1) Disallow evaluation of certain object types. For these,
         *    object evaluation is undefined and not supported.
         */
        ACPI_ERROR ((AE_INFO,
            ""%s: Evaluation of object type [%s] is not supported"",
            Info->FullPathname,
            AcpiUtGetTypeName (Info->Node->Type)));

        Status = AE_TYPE;
        goto Cleanup;

    case ACPI_TYPE_METHOD:
        /*
         * 2) Object is a control method - execute it
         */

        /* Verify that there is a method object associated with this node */

        if (!Info->ObjDesc)
        {
            ACPI_ERROR ((AE_INFO, ""%s: Method has no attached sub-object"",
                Info->FullPathname));
            Status = AE_NULL_OBJECT;
            goto Cleanup;
        }

        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
            ""**** Execute method [%s] at AML address %p length %X\n"",
            Info->FullPathname,
            Info->ObjDesc->Method.AmlStart + 1,
            Info->ObjDesc->Method.AmlLength - 1));

        /*
         * Any namespace deletion must acquire both the namespace and
         * interpreter locks to ensure that no thread is using the portion of
         * the namespace that is being deleted.
         *
         * Execute the method via the interpreter. The interpreter is locked
         * here before calling into the AML parser
         */
        AcpiExEnterInterpreter ();
        Status = AcpiPsExecuteMethod (Info);
        AcpiExExitInterpreter ();
        break;

    default:
        /*
         * 3) All other non-method objects -- get the current object value
         */

        /*
         * Some objects require additional resolution steps (e.g., the Node
         * may be a field that must be read, etc.) -- we can't just grab
         * the object out of the node.
         *
         * Use ResolveNodeToValue() to get the associated value.
         *
         * NOTE: we can get away with passing in NULL for a walk state because
         * the Node is guaranteed to not be a reference to either a method
         * local or a method argument (because this interface is never called
         * from a running method.)
         *
         * Even though we do not directly invoke the interpreter for object
         * resolution, we must lock it because we could access an OpRegion.
         * The OpRegion access code assumes that the interpreter is locked.
         */
        AcpiExEnterInterpreter ();

        /* TBD: ResolveNodeToValue has a strange interface, fix */

        Info->ReturnObject = ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, Info->Node);

        Status = AcpiExResolveNodeToValue (ACPI_CAST_INDIRECT_PTR (
            ACPI_NAMESPACE_NODE, &Info->ReturnObject), NULL);
        AcpiExExitInterpreter ();

        if (ACPI_FAILURE (Status))
        {
            Info->ReturnObject = NULL;
            goto Cleanup;
        }

        ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, ""Returned object %p [%s]\n"",
            Info->ReturnObject,
            AcpiUtGetObjectTypeName (Info->ReturnObject)));

        Status = AE_CTRL_RETURN_VALUE; /* Always has a ""return value"" */
        break;
    }

    /*
     * For predefined names, check the return value against the ACPI
     * specification. Some incorrect return value types are repaired.
     */
    (void) AcpiNsCheckReturnValue (Info->Node, Info, Info->ParamCount,
        Status, &Info->ReturnObject);

    /* Check if there is a return value that must be dealt with */

    if (Status == AE_CTRL_RETURN_VALUE)
    {
        /* If caller does not want the return value, delete it */

        if (Info->Flags & ACPI_IGNORE_RETURN_VALUE)
        {
            AcpiUtRemoveReference (Info->ReturnObject);
            Info->ReturnObject = NULL;
        }

        /* Map AE_CTRL_RETURN_VALUE to AE_OK, we are done with it */
 
         Status = AE_OK;
     }
 
     ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
         ""*** Completed evaluation of object %s ***\n"",
        Info->RelativePathname));

Cleanup:
    /*
     * Namespace was unlocked by the handling AcpiNs* function, so we
     * just free the pathname and return
     */
    ACPI_FREE (Info->FullPathname);
    Info->FullPathname = NULL;
    return_ACPI_STATUS (Status);
}
",C,"    else if (ACPI_FAILURE(Status)) 
    {
        /* If ReturnObject exists, delete it */

        if (Info->ReturnObject) 
        {
            AcpiUtRemoveReference (Info->ReturnObject);
            Info->ReturnObject = NULL;
        }
    }
",,,"@@ -428,6 +428,16 @@ AcpiNsEvaluate (
 
         Status = AE_OK;
     }
+    else if (ACPI_FAILURE(Status)) 
+    {
+        /* If ReturnObject exists, delete it */
+
+        if (Info->ReturnObject) 
+        {
+            AcpiUtRemoveReference (Info->ReturnObject);
+            Info->ReturnObject = NULL;
+        }
+    }
 
     ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
         ""*** Completed evaluation of object %s ***\n"",",acpica,37f2c716f2c6ab14c3ba557a539c3ee3224931b5,b542af9a4caeb8397c08421d2a4f2f60952f9e79,1,"AcpiNsEvaluate (
    ACPI_EVALUATE_INFO      *Info)
{
    ACPI_STATUS             Status;


    ACPI_FUNCTION_TRACE (NsEvaluate);


    if (!Info)
    {
        return_ACPI_STATUS (AE_BAD_PARAMETER);
    }

    if (!Info->Node)
    {
        /*
         * Get the actual namespace node for the target object if we
         * need to. Handles these cases:
         *
         * 1) Null node, valid pathname from root (absolute path)
         * 2) Node and valid pathname (path relative to Node)
         * 3) Node, Null pathname
         */
        Status = AcpiNsGetNode (Info->PrefixNode, Info->RelativePathname,
            ACPI_NS_NO_UPSEARCH, &Info->Node);
        if (ACPI_FAILURE (Status))
        {
            return_ACPI_STATUS (Status);
        }
    }

    /*
     * For a method alias, we must grab the actual method node so that
     * proper scoping context will be established before execution.
     */
    if (AcpiNsGetType (Info->Node) == ACPI_TYPE_LOCAL_METHOD_ALIAS)
    {
        Info->Node = ACPI_CAST_PTR (
            ACPI_NAMESPACE_NODE, Info->Node->Object);
    }

    /* Complete the info block initialization */

    Info->ReturnObject = NULL;
    Info->NodeFlags = Info->Node->Flags;
    Info->ObjDesc = AcpiNsGetAttachedObject (Info->Node);

    ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, ""%s [%p] Value %p\n"",
        Info->RelativePathname, Info->Node,
        AcpiNsGetAttachedObject (Info->Node)));

    /* Get info if we have a predefined name (_HID, etc.) */

    Info->Predefined = AcpiUtMatchPredefinedMethod (Info->Node->Name.Ascii);

    /* Get the full pathname to the object, for use in warning messages */

    Info->FullPathname = AcpiNsGetNormalizedPathname (Info->Node, TRUE);
    if (!Info->FullPathname)
    {
        return_ACPI_STATUS (AE_NO_MEMORY);
    }

    /* Count the number of arguments being passed in */

    Info->ParamCount = 0;
    if (Info->Parameters)
    {
        while (Info->Parameters[Info->ParamCount])
        {
            Info->ParamCount++;
        }

        /* Warn on impossible argument count */

        if (Info->ParamCount > ACPI_METHOD_NUM_ARGS)
        {
            ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, ACPI_WARN_ALWAYS,
                ""Excess arguments (%u) - using only %u"",
                Info->ParamCount, ACPI_METHOD_NUM_ARGS));

            Info->ParamCount = ACPI_METHOD_NUM_ARGS;
        }
    }

    /*
     * For predefined names: Check that the declared argument count
     * matches the ACPI spec -- otherwise this is a BIOS error.
     */
    AcpiNsCheckAcpiCompliance (Info->FullPathname, Info->Node,
        Info->Predefined);

    /*
     * For all names: Check that the incoming argument count for
     * this method/object matches the actual ASL/AML definition.
     */
    AcpiNsCheckArgumentCount (Info->FullPathname, Info->Node,
        Info->ParamCount, Info->Predefined);

    /* For predefined names: Typecheck all incoming arguments */

    AcpiNsCheckArgumentTypes (Info);

    /*
     * Three major evaluation cases:
     *
     * 1) Object types that cannot be evaluated by definition
     * 2) The object is a control method -- execute it
     * 3) The object is not a method -- just return it's current value
     */
    switch (AcpiNsGetType (Info->Node))
    {
    case ACPI_TYPE_DEVICE:
    case ACPI_TYPE_EVENT:
    case ACPI_TYPE_MUTEX:
    case ACPI_TYPE_REGION:
    case ACPI_TYPE_THERMAL:
    case ACPI_TYPE_LOCAL_SCOPE:
        /*
         * 1) Disallow evaluation of certain object types. For these,
         *    object evaluation is undefined and not supported.
         */
        ACPI_ERROR ((AE_INFO,
            ""%s: Evaluation of object type [%s] is not supported"",
            Info->FullPathname,
            AcpiUtGetTypeName (Info->Node->Type)));

        Status = AE_TYPE;
        goto Cleanup;

    case ACPI_TYPE_METHOD:
        /*
         * 2) Object is a control method - execute it
         */

        /* Verify that there is a method object associated with this node */

        if (!Info->ObjDesc)
        {
            ACPI_ERROR ((AE_INFO, ""%s: Method has no attached sub-object"",
                Info->FullPathname));
            Status = AE_NULL_OBJECT;
            goto Cleanup;
        }

        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
            ""**** Execute method [%s] at AML address %p length %X\n"",
            Info->FullPathname,
            Info->ObjDesc->Method.AmlStart + 1,
            Info->ObjDesc->Method.AmlLength - 1));

        /*
         * Any namespace deletion must acquire both the namespace and
         * interpreter locks to ensure that no thread is using the portion of
         * the namespace that is being deleted.
         *
         * Execute the method via the interpreter. The interpreter is locked
         * here before calling into the AML parser
         */
        AcpiExEnterInterpreter ();
        Status = AcpiPsExecuteMethod (Info);
        AcpiExExitInterpreter ();
        break;

    default:
        /*
         * 3) All other non-method objects -- get the current object value
         */

        /*
         * Some objects require additional resolution steps (e.g., the Node
         * may be a field that must be read, etc.) -- we can't just grab
         * the object out of the node.
         *
         * Use ResolveNodeToValue() to get the associated value.
         *
         * NOTE: we can get away with passing in NULL for a walk state because
         * the Node is guaranteed to not be a reference to either a method
         * local or a method argument (because this interface is never called
         * from a running method.)
         *
         * Even though we do not directly invoke the interpreter for object
         * resolution, we must lock it because we could access an OpRegion.
         * The OpRegion access code assumes that the interpreter is locked.
         */
        AcpiExEnterInterpreter ();

        /* TBD: ResolveNodeToValue has a strange interface, fix */

        Info->ReturnObject = ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, Info->Node);

        Status = AcpiExResolveNodeToValue (ACPI_CAST_INDIRECT_PTR (
            ACPI_NAMESPACE_NODE, &Info->ReturnObject), NULL);
        AcpiExExitInterpreter ();

        if (ACPI_FAILURE (Status))
        {
            Info->ReturnObject = NULL;
            goto Cleanup;
        }

        ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, ""Returned object %p [%s]\n"",
            Info->ReturnObject,
            AcpiUtGetObjectTypeName (Info->ReturnObject)));

        Status = AE_CTRL_RETURN_VALUE; /* Always has a ""return value"" */
        break;
    }

    /*
     * For predefined names, check the return value against the ACPI
     * specification. Some incorrect return value types are repaired.
     */
    (void) AcpiNsCheckReturnValue (Info->Node, Info, Info->ParamCount,
        Status, &Info->ReturnObject);

    /* Check if there is a return value that must be dealt with */

    if (Status == AE_CTRL_RETURN_VALUE)
    {
        /* If caller does not want the return value, delete it */

        if (Info->Flags & ACPI_IGNORE_RETURN_VALUE)
        {
            AcpiUtRemoveReference (Info->ReturnObject);
            Info->ReturnObject = NULL;
        }

        /* Map AE_CTRL_RETURN_VALUE to AE_OK, we are done with it */
 
         Status = AE_OK;
     }
//fix_flaw_line_below:
//    else if (ACPI_FAILURE(Status)) 
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//        /* If ReturnObject exists, delete it */
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        if (Info->ReturnObject) 
//fix_flaw_line_below:
//        {
//fix_flaw_line_below:
//            AcpiUtRemoveReference (Info->ReturnObject);
//fix_flaw_line_below:
//            Info->ReturnObject = NULL;
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//    }
 
     ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
         ""*** Completed evaluation of object %s ***\n"",
        Info->RelativePathname));

Cleanup:
    /*
     * Namespace was unlocked by the handling AcpiNs* function, so we
     * just free the pathname and return
     */
    ACPI_FREE (Info->FullPathname);
    Info->FullPathname = NULL;
    return_ACPI_STATUS (Status);
}
",180958,"AcpiNsEvaluate (
    ACPI_EVALUATE_INFO      *Info)
{
    ACPI_STATUS             Status;


    ACPI_FUNCTION_TRACE (NsEvaluate);


    if (!Info)
    {
        return_ACPI_STATUS (AE_BAD_PARAMETER);
    }

    if (!Info->Node)
    {
        /*
         * Get the actual namespace node for the target object if we
         * need to. Handles these cases:
         *
         * 1) Null node, valid pathname from root (absolute path)
         * 2) Node and valid pathname (path relative to Node)
         * 3) Node, Null pathname
         */
        Status = AcpiNsGetNode (Info->PrefixNode, Info->RelativePathname,
            ACPI_NS_NO_UPSEARCH, &Info->Node);
        if (ACPI_FAILURE (Status))
        {
            return_ACPI_STATUS (Status);
        }
    }

    /*
     * For a method alias, we must grab the actual method node so that
     * proper scoping context will be established before execution.
     */
    if (AcpiNsGetType (Info->Node) == ACPI_TYPE_LOCAL_METHOD_ALIAS)
    {
        Info->Node = ACPI_CAST_PTR (
            ACPI_NAMESPACE_NODE, Info->Node->Object);
    }

    /* Complete the info block initialization */

    Info->ReturnObject = NULL;
    Info->NodeFlags = Info->Node->Flags;
    Info->ObjDesc = AcpiNsGetAttachedObject (Info->Node);

    ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, ""%s [%p] Value %p\n"",
        Info->RelativePathname, Info->Node,
        AcpiNsGetAttachedObject (Info->Node)));

    /* Get info if we have a predefined name (_HID, etc.) */

    Info->Predefined = AcpiUtMatchPredefinedMethod (Info->Node->Name.Ascii);

    /* Get the full pathname to the object, for use in warning messages */

    Info->FullPathname = AcpiNsGetNormalizedPathname (Info->Node, TRUE);
    if (!Info->FullPathname)
    {
        return_ACPI_STATUS (AE_NO_MEMORY);
    }

    /* Count the number of arguments being passed in */

    Info->ParamCount = 0;
    if (Info->Parameters)
    {
        while (Info->Parameters[Info->ParamCount])
        {
            Info->ParamCount++;
        }

        /* Warn on impossible argument count */

        if (Info->ParamCount > ACPI_METHOD_NUM_ARGS)
        {
            ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, ACPI_WARN_ALWAYS,
                ""Excess arguments (%u) - using only %u"",
                Info->ParamCount, ACPI_METHOD_NUM_ARGS));

            Info->ParamCount = ACPI_METHOD_NUM_ARGS;
        }
    }

    /*
     * For predefined names: Check that the declared argument count
     * matches the ACPI spec -- otherwise this is a BIOS error.
     */
    AcpiNsCheckAcpiCompliance (Info->FullPathname, Info->Node,
        Info->Predefined);

    /*
     * For all names: Check that the incoming argument count for
     * this method/object matches the actual ASL/AML definition.
     */
    AcpiNsCheckArgumentCount (Info->FullPathname, Info->Node,
        Info->ParamCount, Info->Predefined);

    /* For predefined names: Typecheck all incoming arguments */

    AcpiNsCheckArgumentTypes (Info);

    /*
     * Three major evaluation cases:
     *
     * 1) Object types that cannot be evaluated by definition
     * 2) The object is a control method -- execute it
     * 3) The object is not a method -- just return it's current value
     */
    switch (AcpiNsGetType (Info->Node))
    {
    case ACPI_TYPE_DEVICE:
    case ACPI_TYPE_EVENT:
    case ACPI_TYPE_MUTEX:
    case ACPI_TYPE_REGION:
    case ACPI_TYPE_THERMAL:
    case ACPI_TYPE_LOCAL_SCOPE:
        /*
         * 1) Disallow evaluation of certain object types. For these,
         *    object evaluation is undefined and not supported.
         */
        ACPI_ERROR ((AE_INFO,
            ""%s: Evaluation of object type [%s] is not supported"",
            Info->FullPathname,
            AcpiUtGetTypeName (Info->Node->Type)));

        Status = AE_TYPE;
        goto Cleanup;

    case ACPI_TYPE_METHOD:
        /*
         * 2) Object is a control method - execute it
         */

        /* Verify that there is a method object associated with this node */

        if (!Info->ObjDesc)
        {
            ACPI_ERROR ((AE_INFO, ""%s: Method has no attached sub-object"",
                Info->FullPathname));
            Status = AE_NULL_OBJECT;
            goto Cleanup;
        }

        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
            ""**** Execute method [%s] at AML address %p length %X\n"",
            Info->FullPathname,
            Info->ObjDesc->Method.AmlStart + 1,
            Info->ObjDesc->Method.AmlLength - 1));

        /*
         * Any namespace deletion must acquire both the namespace and
         * interpreter locks to ensure that no thread is using the portion of
         * the namespace that is being deleted.
         *
         * Execute the method via the interpreter. The interpreter is locked
         * here before calling into the AML parser
         */
        AcpiExEnterInterpreter ();
        Status = AcpiPsExecuteMethod (Info);
        AcpiExExitInterpreter ();
        break;

    default:
        /*
         * 3) All other non-method objects -- get the current object value
         */

        /*
         * Some objects require additional resolution steps (e.g., the Node
         * may be a field that must be read, etc.) -- we can't just grab
         * the object out of the node.
         *
         * Use ResolveNodeToValue() to get the associated value.
         *
         * NOTE: we can get away with passing in NULL for a walk state because
         * the Node is guaranteed to not be a reference to either a method
         * local or a method argument (because this interface is never called
         * from a running method.)
         *
         * Even though we do not directly invoke the interpreter for object
         * resolution, we must lock it because we could access an OpRegion.
         * The OpRegion access code assumes that the interpreter is locked.
         */
        AcpiExEnterInterpreter ();

        /* TBD: ResolveNodeToValue has a strange interface, fix */

        Info->ReturnObject = ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, Info->Node);

        Status = AcpiExResolveNodeToValue (ACPI_CAST_INDIRECT_PTR (
            ACPI_NAMESPACE_NODE, &Info->ReturnObject), NULL);
        AcpiExExitInterpreter ();

        if (ACPI_FAILURE (Status))
        {
            Info->ReturnObject = NULL;
            goto Cleanup;
        }

        ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, ""Returned object %p [%s]\n"",
            Info->ReturnObject,
            AcpiUtGetObjectTypeName (Info->ReturnObject)));

        Status = AE_CTRL_RETURN_VALUE; /* Always has a ""return value"" */
        break;
    }

    /*
     * For predefined names, check the return value against the ACPI
     * specification. Some incorrect return value types are repaired.
     */
    (void) AcpiNsCheckReturnValue (Info->Node, Info, Info->ParamCount,
        Status, &Info->ReturnObject);

    /* Check if there is a return value that must be dealt with */

    if (Status == AE_CTRL_RETURN_VALUE)
    {
        /* If caller does not want the return value, delete it */

        if (Info->Flags & ACPI_IGNORE_RETURN_VALUE)
        {
            AcpiUtRemoveReference (Info->ReturnObject);
            Info->ReturnObject = NULL;
        }

        /* Map AE_CTRL_RETURN_VALUE to AE_OK, we are done with it */
 
         Status = AE_OK;
     }
 
     ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
         ""*** Completed evaluation of object %s ***\n"",
        Info->RelativePathname));

Cleanup:
    /*
     * Namespace was unlocked by the handling AcpiNs* function, so we
     * just free the pathname and return
     */
    ACPI_FREE (Info->FullPathname);
    Info->FullPathname = NULL;
    return_ACPI_STATUS (Status);
}
","AcpiNsEvaluate (
    ACPI_EVALUATE_INFO      *Info)
{
    ACPI_STATUS             Status;


    ACPI_FUNCTION_TRACE (NsEvaluate);


    if (!Info)
    {
        return_ACPI_STATUS (AE_BAD_PARAMETER);
    }

    if (!Info->Node)
    {
        /*
         * Get the actual namespace node for the target object if we
         * need to. Handles these cases:
         *
         * 1) Null node, valid pathname from root (absolute path)
         * 2) Node and valid pathname (path relative to Node)
         * 3) Node, Null pathname
         */
        Status = AcpiNsGetNode (Info->PrefixNode, Info->RelativePathname,
            ACPI_NS_NO_UPSEARCH, &Info->Node);
        if (ACPI_FAILURE (Status))
        {
            return_ACPI_STATUS (Status);
        }
    }

    /*
     * For a method alias, we must grab the actual method node so that
     * proper scoping context will be established before execution.
     */
    if (AcpiNsGetType (Info->Node) == ACPI_TYPE_LOCAL_METHOD_ALIAS)
    {
        Info->Node = ACPI_CAST_PTR (
            ACPI_NAMESPACE_NODE, Info->Node->Object);
    }

    /* Complete the info block initialization */

    Info->ReturnObject = NULL;
    Info->NodeFlags = Info->Node->Flags;
    Info->ObjDesc = AcpiNsGetAttachedObject (Info->Node);

    ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, ""%s [%p] Value %p\n"",
        Info->RelativePathname, Info->Node,
        AcpiNsGetAttachedObject (Info->Node)));

    /* Get info if we have a predefined name (_HID, etc.) */

    Info->Predefined = AcpiUtMatchPredefinedMethod (Info->Node->Name.Ascii);

    /* Get the full pathname to the object, for use in warning messages */

    Info->FullPathname = AcpiNsGetNormalizedPathname (Info->Node, TRUE);
    if (!Info->FullPathname)
    {
        return_ACPI_STATUS (AE_NO_MEMORY);
    }

    /* Count the number of arguments being passed in */

    Info->ParamCount = 0;
    if (Info->Parameters)
    {
        while (Info->Parameters[Info->ParamCount])
        {
            Info->ParamCount++;
        }

        /* Warn on impossible argument count */

        if (Info->ParamCount > ACPI_METHOD_NUM_ARGS)
        {
            ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, ACPI_WARN_ALWAYS,
                ""Excess arguments (%u) - using only %u"",
                Info->ParamCount, ACPI_METHOD_NUM_ARGS));

            Info->ParamCount = ACPI_METHOD_NUM_ARGS;
        }
    }

    /*
     * For predefined names: Check that the declared argument count
     * matches the ACPI spec -- otherwise this is a BIOS error.
     */
    AcpiNsCheckAcpiCompliance (Info->FullPathname, Info->Node,
        Info->Predefined);

    /*
     * For all names: Check that the incoming argument count for
     * this method/object matches the actual ASL/AML definition.
     */
    AcpiNsCheckArgumentCount (Info->FullPathname, Info->Node,
        Info->ParamCount, Info->Predefined);

    /* For predefined names: Typecheck all incoming arguments */

    AcpiNsCheckArgumentTypes (Info);

    /*
     * Three major evaluation cases:
     *
     * 1) Object types that cannot be evaluated by definition
     * 2) The object is a control method -- execute it
     * 3) The object is not a method -- just return it's current value
     */
    switch (AcpiNsGetType (Info->Node))
    {
    case ACPI_TYPE_DEVICE:
    case ACPI_TYPE_EVENT:
    case ACPI_TYPE_MUTEX:
    case ACPI_TYPE_REGION:
    case ACPI_TYPE_THERMAL:
    case ACPI_TYPE_LOCAL_SCOPE:
        /*
         * 1) Disallow evaluation of certain object types. For these,
         *    object evaluation is undefined and not supported.
         */
        ACPI_ERROR ((AE_INFO,
            ""%s: Evaluation of object type [%s] is not supported"",
            Info->FullPathname,
            AcpiUtGetTypeName (Info->Node->Type)));

        Status = AE_TYPE;
        goto Cleanup;

    case ACPI_TYPE_METHOD:
        /*
         * 2) Object is a control method - execute it
         */

        /* Verify that there is a method object associated with this node */

        if (!Info->ObjDesc)
        {
            ACPI_ERROR ((AE_INFO, ""%s: Method has no attached sub-object"",
                Info->FullPathname));
            Status = AE_NULL_OBJECT;
            goto Cleanup;
        }

        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
            ""**** Execute method [%s] at AML address %p length %X\n"",
            Info->FullPathname,
            Info->ObjDesc->Method.AmlStart + 1,
            Info->ObjDesc->Method.AmlLength - 1));

        /*
         * Any namespace deletion must acquire both the namespace and
         * interpreter locks to ensure that no thread is using the portion of
         * the namespace that is being deleted.
         *
         * Execute the method via the interpreter. The interpreter is locked
         * here before calling into the AML parser
         */
        AcpiExEnterInterpreter ();
        Status = AcpiPsExecuteMethod (Info);
        AcpiExExitInterpreter ();
        break;

    default:
        /*
         * 3) All other non-method objects -- get the current object value
         */

        /*
         * Some objects require additional resolution steps (e.g., the Node
         * may be a field that must be read, etc.) -- we can't just grab
         * the object out of the node.
         *
         * Use ResolveNodeToValue() to get the associated value.
         *
         * NOTE: we can get away with passing in NULL for a walk state because
         * the Node is guaranteed to not be a reference to either a method
         * local or a method argument (because this interface is never called
         * from a running method.)
         *
         * Even though we do not directly invoke the interpreter for object
         * resolution, we must lock it because we could access an OpRegion.
         * The OpRegion access code assumes that the interpreter is locked.
         */
        AcpiExEnterInterpreter ();

        /* TBD: ResolveNodeToValue has a strange interface, fix */

        Info->ReturnObject = ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, Info->Node);

        Status = AcpiExResolveNodeToValue (ACPI_CAST_INDIRECT_PTR (
            ACPI_NAMESPACE_NODE, &Info->ReturnObject), NULL);
        AcpiExExitInterpreter ();

        if (ACPI_FAILURE (Status))
        {
            Info->ReturnObject = NULL;
            goto Cleanup;
        }

        ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, ""Returned object %p [%s]\n"",
            Info->ReturnObject,
            AcpiUtGetObjectTypeName (Info->ReturnObject)));

        Status = AE_CTRL_RETURN_VALUE; /* Always has a ""return value"" */
        break;
    }

    /*
     * For predefined names, check the return value against the ACPI
     * specification. Some incorrect return value types are repaired.
     */
    (void) AcpiNsCheckReturnValue (Info->Node, Info, Info->ParamCount,
        Status, &Info->ReturnObject);

    /* Check if there is a return value that must be dealt with */

    if (Status == AE_CTRL_RETURN_VALUE)
    {
        /* If caller does not want the return value, delete it */

        if (Info->Flags & ACPI_IGNORE_RETURN_VALUE)
        {
            AcpiUtRemoveReference (Info->ReturnObject);
            Info->ReturnObject = NULL;
        }

        /* Map AE_CTRL_RETURN_VALUE to AE_OK, we are done with it */
 
         Status = AE_OK;
     }
    else if (ACPI_FAILURE(Status)) 
    {
        /* If ReturnObject exists, delete it */

        if (Info->ReturnObject) 
        {
            AcpiUtRemoveReference (Info->ReturnObject);
            Info->ReturnObject = NULL;
        }
    }
 
     ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
         ""*** Completed evaluation of object %s ***\n"",
        Info->RelativePathname));

Cleanup:
    /*
     * Namespace was unlocked by the handling AcpiNs* function, so we
     * just free the pathname and return
     */
    ACPI_FREE (Info->FullPathname);
    Info->FullPathname = NULL;
    return_ACPI_STATUS (Status);
}
","The `AcpiNsEvaluate` function evaluates an ACPI (Advanced Configuration and Power Interface) namespace object based on the provided `ACPI_EVALUATE_INFO` structure. It first checks for valid parameters and retrieves the corresponding namespace node if necessary. The function handles method aliases, counts input parameters, and verifies compliance with ACPI specifications. Depending on the object type, it either executes a control method, retrieves the current value of non-method objects, or raises errors for unsupported types. Finally, it checks the return value against ACPI standards, cleans up resources, and returns the evaluation status, ensuring proper memory management throughout the process.","The code evaluates an object within a namespace by first validating input parameters and retrieving the appropriate node if necessary. It handles method aliases and counts the number of input parameters while ensuring compliance with specifications. Depending on the object's type, it either executes a method, retrieves the current value of non-method objects, or raises errors for unsupported types. The function also checks the return value against standards, manages memory effectively, and ensures proper cleanup of resources before returning the evaluation status, thereby maintaining the integrity of the namespace and its associated objects.","The vulnerability in the original code stemmed from a failure to properly manage memory for the return object when errors occurred during the evaluation process. Specifically, the function only removed the return object when the status indicated a successful return value, leaving the return object allocated in cases of errors, which led to a memory leak. In the fixed code, an additional check was introduced to ensure that if the status indicated a failure, the return object would be removed and set to null, thus preventing the memory leak and ensuring proper cleanup of resources in all scenarios.","The vulnerability in the original code was due to improper memory management, specifically a cache leak that occurred when the evaluation function encountered errors. The function only removed the return object when a specific success status was returned, leaving the return object allocated in cases of failure, which led to memory not being freed. This could potentially expose sensitive information in memory, posing a security risk. The fix involved adding a check to ensure that the return object is also removed and set to null in cases of failure, thereby preventing the memory leak and enhancing overall security.","The vulnerability was fixed by modifying the handling of the return object in the evaluation function. In the updated code, an additional check was introduced to ensure that if the status indicated a failure, specifically when the status was not equal to `AE_CTRL_RETURN_VALUE`, the return object was removed using `AcpiUtRemoveReference`, and set to null. This change ensures that the return object is properly cleaned up in all scenarios, preventing memory leaks and addressing the issue of unfreed memory that could lead to security vulnerabilities during early termination of the ACPI function.","The vulnerability was fixed by enhancing the memory management process within the evaluation function. The updated code introduced an additional check to ensure that the allocated return object is properly released in cases of failure, not just when a specific success status is returned. This change guarantees that the return object is cleaned up regardless of the evaluation outcome, effectively preventing memory leaks. By ensuring that all allocated resources are appropriately freed, the fix mitigates the risk of exposing sensitive information and improves the overall security of the system during early termination scenarios.","4, 4","5,5","5,5","5,5"
69,69,180959,180959,,Local,Not required,,CVE-2017-13694,https://www.cvedetails.com/cve/CVE-2017-13694/,CWE-200,Low,Partial,,,2017-08-25,2.1,"The acpi_ps_complete_final_op() function in drivers/acpi/acpica/psobject.c in the Linux kernel through 4.12.9 does not flush the node and node_ext caches and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.",2017-09-20,Bypass +Info ,16,https://github.com/acpica/acpica/pull/278/commits/4a0243ecb4c94e2d73510d096c5ea4d0711fc6c0,4a0243ecb4c94e2d73510d096c5ea4d0711fc6c0,"acpi: acpica: fix acpi parse and parseext cache leaks

I'm Seunghun Han, and I work for National Security Research Institute of
South Korea.

I have been doing a research on ACPI and found an ACPI cache leak in ACPI
early abort cases.

Boot log of ACPI cache leak is as follows:
[    0.352414] ACPI: Added _OSI(Module Device)
[    0.353182] ACPI: Added _OSI(Processor Device)
[    0.353182] ACPI: Added _OSI(3.0 _SCP Extensions)
[    0.353182] ACPI: Added _OSI(Processor Aggregator Device)
[    0.356028] ACPI: Unable to start the ACPI Interpreter
[    0.356799] ACPI Error: Could not remove SCI handler (20170303/evmisc-281)
[    0.360215] kmem_cache_destroy Acpi-State: Slab cache still has objects
[    0.360648] CPU: 0 PID: 1 Comm: swapper/0 Tainted: G        W
4.12.0-rc4-next-20170608+ #10
[    0.361273] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS
VirtualBox 12/01/2006
[    0.361873] Call Trace:
[    0.362243]  ? dump_stack+0x5c/0x81
[    0.362591]  ? kmem_cache_destroy+0x1aa/0x1c0
[    0.362944]  ? acpi_sleep_proc_init+0x27/0x27
[    0.363296]  ? acpi_os_delete_cache+0xa/0x10
[    0.363646]  ? acpi_ut_delete_caches+0x6d/0x7b
[    0.364000]  ? acpi_terminate+0xa/0x14
[    0.364000]  ? acpi_init+0x2af/0x34f
[    0.364000]  ? __class_create+0x4c/0x80
[    0.364000]  ? video_setup+0x7f/0x7f
[    0.364000]  ? acpi_sleep_proc_init+0x27/0x27
[    0.364000]  ? do_one_initcall+0x4e/0x1a0
[    0.364000]  ? kernel_init_freeable+0x189/0x20a
[    0.364000]  ? rest_init+0xc0/0xc0
[    0.364000]  ? kernel_init+0xa/0x100
[    0.364000]  ? ret_from_fork+0x25/0x30

I analyzed this memory leak in detail. I found that “Acpi-State” cache and
“Acpi-Parse” cache were merged because the size of cache objects was same
slab cache size.

I finally found “Acpi-Parse” cache and “Acpi-ParseExt” cache were leaked
using SLAB_NEVER_MERGE flag in kmem_cache_create() function.

Real ACPI cache leak point is as follows:
[    0.360101] ACPI: Added _OSI(Module Device)
[    0.360101] ACPI: Added _OSI(Processor Device)
[    0.360101] ACPI: Added _OSI(3.0 _SCP Extensions)
[    0.361043] ACPI: Added _OSI(Processor Aggregator Device)
[    0.364016] ACPI: Unable to start the ACPI Interpreter
[    0.365061] ACPI Error: Could not remove SCI handler (20170303/evmisc-281)
[    0.368174] kmem_cache_destroy Acpi-Parse: Slab cache still has objects
[    0.369332] CPU: 1 PID: 1 Comm: swapper/0 Tainted: G        W
4.12.0-rc4-next-20170608+ #8
[    0.371256] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS
VirtualBox 12/01/2006
[    0.372000] Call Trace:
[    0.372000]  ? dump_stack+0x5c/0x81
[    0.372000]  ? kmem_cache_destroy+0x1aa/0x1c0
[    0.372000]  ? acpi_sleep_proc_init+0x27/0x27
[    0.372000]  ? acpi_os_delete_cache+0xa/0x10
[    0.372000]  ? acpi_ut_delete_caches+0x56/0x7b
[    0.372000]  ? acpi_terminate+0xa/0x14
[    0.372000]  ? acpi_init+0x2af/0x34f
[    0.372000]  ? __class_create+0x4c/0x80
[    0.372000]  ? video_setup+0x7f/0x7f
[    0.372000]  ? acpi_sleep_proc_init+0x27/0x27
[    0.372000]  ? do_one_initcall+0x4e/0x1a0
[    0.372000]  ? kernel_init_freeable+0x189/0x20a
[    0.372000]  ? rest_init+0xc0/0xc0
[    0.372000]  ? kernel_init+0xa/0x100
[    0.372000]  ? ret_from_fork+0x25/0x30
[    0.388039] kmem_cache_destroy Acpi-ParseExt: Slab cache still has objects
[    0.389063] CPU: 1 PID: 1 Comm: swapper/0 Tainted: G        W
4.12.0-rc4-next-20170608+ #8
[    0.390557] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS
VirtualBox 12/01/2006
[    0.392000] Call Trace:
[    0.392000]  ? dump_stack+0x5c/0x81
[    0.392000]  ? kmem_cache_destroy+0x1aa/0x1c0
[    0.392000]  ? acpi_sleep_proc_init+0x27/0x27
[    0.392000]  ? acpi_os_delete_cache+0xa/0x10
[    0.392000]  ? acpi_ut_delete_caches+0x6d/0x7b
[    0.392000]  ? acpi_terminate+0xa/0x14
[    0.392000]  ? acpi_init+0x2af/0x34f
[    0.392000]  ? __class_create+0x4c/0x80
[    0.392000]  ? video_setup+0x7f/0x7f
[    0.392000]  ? acpi_sleep_proc_init+0x27/0x27
[    0.392000]  ? do_one_initcall+0x4e/0x1a0
[    0.392000]  ? kernel_init_freeable+0x189/0x20a
[    0.392000]  ? rest_init+0xc0/0xc0
[    0.392000]  ? kernel_init+0xa/0x100
[    0.392000]  ? ret_from_fork+0x25/0x30

When early abort is occurred due to invalid ACPI information, Linux kernel
terminates ACPI by calling acpi_terminate() function. The function calls
acpi_ut_delete_caches() function to delete local caches (acpi_gbl_namespace_
cache, state_cache, operand_cache, ps_node_cache, ps_node_ext_cache).

But the deletion codes in acpi_ut_delete_caches() function only delete
slab caches using kmem_cache_destroy() function, therefore the cache
objects should be flushed before acpi_ut_delete_caches() function.

“Acpi-Parse” cache and “Acpi-ParseExt” cache are used in an AML parse
function, acpi_ps_parse_loop(). The function should have flush codes to
handle an error state due to invalid AML codes.

This cache leak has a security threat because an old kernel (<= 4.9) shows
memory locations of kernel functions in stack dump. Some malicious users
could use this information to neutralize kernel ASLR.

To fix ACPI cache leak for enhancing security, I made a patch which has
flush codes in acpi_ps_parse_loop() function.

I hope that this patch improves the security of Linux kernel.

Thank you.

Signed-off-by: Seunghun Han <kkamagui@gmail.com>",24,source/components/parser/psobject.c,"{""sha"": ""6f9bf2370c4d663e27725f7f6b87cd73a1ef7431"", ""filename"": ""source/components/parser/psobject.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 28, ""changes"": 44, ""blob_url"": ""https://github.com/acpica/acpica/blob/4a0243ecb4c94e2d73510d096c5ea4d0711fc6c0/source/components/parser/psobject.c"", ""raw_url"": ""https://github.com/acpica/acpica/raw/4a0243ecb4c94e2d73510d096c5ea4d0711fc6c0/source/components/parser/psobject.c"", ""contents_url"": ""https://api.github.com/repos/acpica/acpica/contents/source/components/parser/psobject.c?ref=4a0243ecb4c94e2d73510d096c5ea4d0711fc6c0"", ""patch"": ""@@ -768,7 +768,8 @@ AcpiPsCompleteFinalOp (\n     ACPI_PARSE_OBJECT       *Op,\n     ACPI_STATUS             Status)\n {\n-    ACPI_STATUS             Status2;\n+    ACPI_STATUS             ReturnStatus = AE_OK;\n+    BOOLEAN                 Ascending = TRUE;\n \n \n     ACPI_FUNCTION_TRACE_PTR (PsCompleteFinalOp, WalkState);\n@@ -785,7 +786,7 @@ AcpiPsCompleteFinalOp (\n     {\n         if (Op)\n         {\n-            if (WalkState->AscendingCallback != NULL)\n+            if (Ascending && WalkState->AscendingCallback != NULL)\n             {\n                 WalkState->Op = Op;\n                 WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);\n@@ -804,41 +805,28 @@ AcpiPsCompleteFinalOp (\n \n                 if (Status == AE_CTRL_TERMINATE)\n                 {\n-                    Status = AE_OK;\n-\n-                    /* Clean up */\n-                    do\n-                    {\n-                        if (Op)\n-                        {\n-                            Status2 = AcpiPsCompleteThisOp (WalkState, Op);\n-                            if (ACPI_FAILURE (Status2))\n-                            {\n-                                return_ACPI_STATUS (Status2);\n-                            }\n-                        }\n-\n-                        AcpiPsPopScope (&(WalkState->ParserState), &Op,\n-                            &WalkState->ArgTypes, &WalkState->ArgCount);\n-\n-                    } while (Op);\n-\n-                    return_ACPI_STATUS (Status);\n+                    Ascending = FALSE;\n+                    ReturnStatus = AE_CTRL_TERMINATE;\n                 }\n \n                 else if (ACPI_FAILURE (Status))\n                 {\n                     /* First error is most important */\n \n-                    (void) AcpiPsCompleteThisOp (WalkState, Op);\n-                    return_ACPI_STATUS (Status);\n+                    Ascending = FALSE;\n+                    ReturnStatus = Status;\n                 }\n             }\n \n-            Status2 = AcpiPsCompleteThisOp (WalkState, Op);\n-            if (ACPI_FAILURE (Status2))\n+            Status = AcpiPsCompleteThisOp (WalkState, Op);\n+            if (ACPI_FAILURE (Status))\n             {\n-                return_ACPI_STATUS (Status2);\n+                Ascending = FALSE;\n+                if (ACPI_SUCCESS (ReturnStatus) ||\n+                    ReturnStatus == AE_CTRL_TERMINATE)\n+                {\n+                    ReturnStatus = Status;\n+                }\n             }\n         }\n \n@@ -847,5 +835,5 @@ AcpiPsCompleteFinalOp (\n \n     } while (Op);\n \n-    return_ACPI_STATUS (Status);\n+    return_ACPI_STATUS (ReturnStatus);\n }""}","AcpiPsCompleteFinalOp (
    ACPI_WALK_STATE         *WalkState,
     ACPI_PARSE_OBJECT       *Op,
     ACPI_STATUS             Status)
 {
    ACPI_STATUS             ReturnStatus = AE_OK;
    BOOLEAN                 Ascending = TRUE;
 
 
     ACPI_FUNCTION_TRACE_PTR (PsCompleteFinalOp, WalkState);


    /*
     * Complete the last Op (if not completed), and clear the scope stack.
     * It is easily possible to end an AML ""package"" with an unbounded number
     * of open scopes (such as when several ASL blocks are closed with
     * sequential closing braces). We want to terminate each one cleanly.
     */
    ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, ""AML package complete at Op %p\n"", Op));
    do
     {
         if (Op)
         {
            if (Ascending && WalkState->AscendingCallback != NULL)
             {
                 WalkState->Op = Op;
                 WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
                WalkState->Opcode = Op->Common.AmlOpcode;

                Status = WalkState->AscendingCallback (WalkState);
                Status = AcpiPsNextParseState (WalkState, Op, Status);
                if (Status == AE_CTRL_PENDING)
                {
                    Status = AcpiPsCompleteOp (WalkState, &Op, AE_OK);
                    if (ACPI_FAILURE (Status))
                    {
                        return_ACPI_STATUS (Status);
                    }
                }
 
                 if (Status == AE_CTRL_TERMINATE)
                 {
                    Ascending = FALSE;
                    ReturnStatus = AE_CTRL_TERMINATE;
                 }
 
                 else if (ACPI_FAILURE (Status))
                 {
                     /* First error is most important */
 
                    Ascending = FALSE;
                    ReturnStatus = Status;
                 }
             }
 
            Status = AcpiPsCompleteThisOp (WalkState, Op);
            if (ACPI_FAILURE (Status))
             {
                Ascending = FALSE;
                if (ACPI_SUCCESS (ReturnStatus) ||
                    ReturnStatus == AE_CTRL_TERMINATE)
                {
                    ReturnStatus = Status;
                }
             }
         }
 
        AcpiPsPopScope (&(WalkState->ParserState), &Op, &WalkState->ArgTypes,
            &WalkState->ArgCount);
 
     } while (Op);
 
    return_ACPI_STATUS (ReturnStatus);
 }
","AcpiPsCompleteFinalOp (
    ACPI_WALK_STATE         *WalkState,
     ACPI_PARSE_OBJECT       *Op,
     ACPI_STATUS             Status)
 {
    ACPI_STATUS             Status2;
 
 
     ACPI_FUNCTION_TRACE_PTR (PsCompleteFinalOp, WalkState);


    /*
     * Complete the last Op (if not completed), and clear the scope stack.
     * It is easily possible to end an AML ""package"" with an unbounded number
     * of open scopes (such as when several ASL blocks are closed with
     * sequential closing braces). We want to terminate each one cleanly.
     */
    ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, ""AML package complete at Op %p\n"", Op));
    do
     {
         if (Op)
         {
            if (WalkState->AscendingCallback != NULL)
             {
                 WalkState->Op = Op;
                 WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
                WalkState->Opcode = Op->Common.AmlOpcode;

                Status = WalkState->AscendingCallback (WalkState);
                Status = AcpiPsNextParseState (WalkState, Op, Status);
                if (Status == AE_CTRL_PENDING)
                {
                    Status = AcpiPsCompleteOp (WalkState, &Op, AE_OK);
                    if (ACPI_FAILURE (Status))
                    {
                        return_ACPI_STATUS (Status);
                    }
                }
 
                 if (Status == AE_CTRL_TERMINATE)
                 {
                    Status = AE_OK;
                    /* Clean up */
                    do
                    {
                        if (Op)
                        {
                            Status2 = AcpiPsCompleteThisOp (WalkState, Op);
                            if (ACPI_FAILURE (Status2))
                            {
                                return_ACPI_STATUS (Status2);
                            }
                        }
                        AcpiPsPopScope (&(WalkState->ParserState), &Op,
                            &WalkState->ArgTypes, &WalkState->ArgCount);
                    } while (Op);
                    return_ACPI_STATUS (Status);
                 }
 
                 else if (ACPI_FAILURE (Status))
                 {
                     /* First error is most important */
 
                    (void) AcpiPsCompleteThisOp (WalkState, Op);
                    return_ACPI_STATUS (Status);
                 }
             }
 
            Status2 = AcpiPsCompleteThisOp (WalkState, Op);
            if (ACPI_FAILURE (Status2))
             {
                return_ACPI_STATUS (Status2);
             }
         }
 
        AcpiPsPopScope (&(WalkState->ParserState), &Op, &WalkState->ArgTypes,
            &WalkState->ArgCount);
 
     } while (Op);
 
    return_ACPI_STATUS (Status);
 }
",C,"    ACPI_STATUS             ReturnStatus = AE_OK;
    BOOLEAN                 Ascending = TRUE;
            if (Ascending && WalkState->AscendingCallback != NULL)
                    Ascending = FALSE;
                    ReturnStatus = AE_CTRL_TERMINATE;
                    Ascending = FALSE;
                    ReturnStatus = Status;
            Status = AcpiPsCompleteThisOp (WalkState, Op);
            if (ACPI_FAILURE (Status))
                Ascending = FALSE;
                if (ACPI_SUCCESS (ReturnStatus) ||
                    ReturnStatus == AE_CTRL_TERMINATE)
                {
                    ReturnStatus = Status;
                }
    return_ACPI_STATUS (ReturnStatus);
","    ACPI_STATUS             Status2;
            if (WalkState->AscendingCallback != NULL)
                    Status = AE_OK;
                    /* Clean up */
                    do
                    {
                        if (Op)
                        {
                            Status2 = AcpiPsCompleteThisOp (WalkState, Op);
                            if (ACPI_FAILURE (Status2))
                            {
                                return_ACPI_STATUS (Status2);
                            }
                        }
                        AcpiPsPopScope (&(WalkState->ParserState), &Op,
                            &WalkState->ArgTypes, &WalkState->ArgCount);
                    } while (Op);
                    return_ACPI_STATUS (Status);
                    (void) AcpiPsCompleteThisOp (WalkState, Op);
                    return_ACPI_STATUS (Status);
            Status2 = AcpiPsCompleteThisOp (WalkState, Op);
            if (ACPI_FAILURE (Status2))
                return_ACPI_STATUS (Status2);
    return_ACPI_STATUS (Status);
",,"@@ -768,7 +768,8 @@ AcpiPsCompleteFinalOp (
     ACPI_PARSE_OBJECT       *Op,
     ACPI_STATUS             Status)
 {
-    ACPI_STATUS             Status2;
+    ACPI_STATUS             ReturnStatus = AE_OK;
+    BOOLEAN                 Ascending = TRUE;
 
 
     ACPI_FUNCTION_TRACE_PTR (PsCompleteFinalOp, WalkState);
@@ -785,7 +786,7 @@ AcpiPsCompleteFinalOp (
     {
         if (Op)
         {
-            if (WalkState->AscendingCallback != NULL)
+            if (Ascending && WalkState->AscendingCallback != NULL)
             {
                 WalkState->Op = Op;
                 WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
@@ -804,41 +805,28 @@ AcpiPsCompleteFinalOp (
 
                 if (Status == AE_CTRL_TERMINATE)
                 {
-                    Status = AE_OK;
-
-                    /* Clean up */
-                    do
-                    {
-                        if (Op)
-                        {
-                            Status2 = AcpiPsCompleteThisOp (WalkState, Op);
-                            if (ACPI_FAILURE (Status2))
-                            {
-                                return_ACPI_STATUS (Status2);
-                            }
-                        }
-
-                        AcpiPsPopScope (&(WalkState->ParserState), &Op,
-                            &WalkState->ArgTypes, &WalkState->ArgCount);
-
-                    } while (Op);
-
-                    return_ACPI_STATUS (Status);
+                    Ascending = FALSE;
+                    ReturnStatus = AE_CTRL_TERMINATE;
                 }
 
                 else if (ACPI_FAILURE (Status))
                 {
                     /* First error is most important */
 
-                    (void) AcpiPsCompleteThisOp (WalkState, Op);
-                    return_ACPI_STATUS (Status);
+                    Ascending = FALSE;
+                    ReturnStatus = Status;
                 }
             }
 
-            Status2 = AcpiPsCompleteThisOp (WalkState, Op);
-            if (ACPI_FAILURE (Status2))
+            Status = AcpiPsCompleteThisOp (WalkState, Op);
+            if (ACPI_FAILURE (Status))
             {
-                return_ACPI_STATUS (Status2);
+                Ascending = FALSE;
+                if (ACPI_SUCCESS (ReturnStatus) ||
+                    ReturnStatus == AE_CTRL_TERMINATE)
+                {
+                    ReturnStatus = Status;
+                }
             }
         }
 
@@ -847,5 +835,5 @@ AcpiPsCompleteFinalOp (
 
     } while (Op);
 
-    return_ACPI_STATUS (Status);
+    return_ACPI_STATUS (ReturnStatus);
 }",acpica,4a0243ecb4c94e2d73510d096c5ea4d0711fc6c0,2058b3bf5deecb9644d676703bd97d1bce5e612a,1,"AcpiPsCompleteFinalOp (
    ACPI_WALK_STATE         *WalkState,
     ACPI_PARSE_OBJECT       *Op,
     ACPI_STATUS             Status)
 {
//flaw_line_below:
    ACPI_STATUS             Status2;
//fix_flaw_line_below:
//    ACPI_STATUS             ReturnStatus = AE_OK;
//fix_flaw_line_below:
//    BOOLEAN                 Ascending = TRUE;
 
 
     ACPI_FUNCTION_TRACE_PTR (PsCompleteFinalOp, WalkState);


    /*
     * Complete the last Op (if not completed), and clear the scope stack.
     * It is easily possible to end an AML ""package"" with an unbounded number
     * of open scopes (such as when several ASL blocks are closed with
     * sequential closing braces). We want to terminate each one cleanly.
     */
    ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, ""AML package complete at Op %p\n"", Op));
    do
     {
         if (Op)
         {
//flaw_line_below:
            if (WalkState->AscendingCallback != NULL)
//fix_flaw_line_below:
//            if (Ascending && WalkState->AscendingCallback != NULL)
             {
                 WalkState->Op = Op;
                 WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
                WalkState->Opcode = Op->Common.AmlOpcode;

                Status = WalkState->AscendingCallback (WalkState);
                Status = AcpiPsNextParseState (WalkState, Op, Status);
                if (Status == AE_CTRL_PENDING)
                {
                    Status = AcpiPsCompleteOp (WalkState, &Op, AE_OK);
                    if (ACPI_FAILURE (Status))
                    {
                        return_ACPI_STATUS (Status);
                    }
                }
 
                 if (Status == AE_CTRL_TERMINATE)
                 {
//flaw_line_below:
                    Status = AE_OK;
//flaw_line_below:

//flaw_line_below:
                    /* Clean up */
//flaw_line_below:
                    do
//flaw_line_below:
                    {
//flaw_line_below:
                        if (Op)
//flaw_line_below:
                        {
//flaw_line_below:
                            Status2 = AcpiPsCompleteThisOp (WalkState, Op);
//flaw_line_below:
                            if (ACPI_FAILURE (Status2))
//flaw_line_below:
                            {
//flaw_line_below:
                                return_ACPI_STATUS (Status2);
//flaw_line_below:
                            }
//flaw_line_below:
                        }
//flaw_line_below:

//flaw_line_below:
                        AcpiPsPopScope (&(WalkState->ParserState), &Op,
//flaw_line_below:
                            &WalkState->ArgTypes, &WalkState->ArgCount);
//flaw_line_below:

//flaw_line_below:
                    } while (Op);
//flaw_line_below:

//flaw_line_below:
                    return_ACPI_STATUS (Status);
//fix_flaw_line_below:
//                    Ascending = FALSE;
//fix_flaw_line_below:
//                    ReturnStatus = AE_CTRL_TERMINATE;
                 }
 
                 else if (ACPI_FAILURE (Status))
                 {
                     /* First error is most important */
 
//flaw_line_below:
                    (void) AcpiPsCompleteThisOp (WalkState, Op);
//flaw_line_below:
                    return_ACPI_STATUS (Status);
//fix_flaw_line_below:
//                    Ascending = FALSE;
//fix_flaw_line_below:
//                    ReturnStatus = Status;
                 }
             }
 
//flaw_line_below:
            Status2 = AcpiPsCompleteThisOp (WalkState, Op);
//flaw_line_below:
            if (ACPI_FAILURE (Status2))
//fix_flaw_line_below:
//            Status = AcpiPsCompleteThisOp (WalkState, Op);
//fix_flaw_line_below:
//            if (ACPI_FAILURE (Status))
             {
//flaw_line_below:
                return_ACPI_STATUS (Status2);
//fix_flaw_line_below:
//                Ascending = FALSE;
//fix_flaw_line_below:
//                if (ACPI_SUCCESS (ReturnStatus) ||
//fix_flaw_line_below:
//                    ReturnStatus == AE_CTRL_TERMINATE)
//fix_flaw_line_below:
//                {
//fix_flaw_line_below:
//                    ReturnStatus = Status;
//fix_flaw_line_below:
//                }
             }
         }
 
        AcpiPsPopScope (&(WalkState->ParserState), &Op, &WalkState->ArgTypes,
            &WalkState->ArgCount);
 
     } while (Op);
 
//flaw_line_below:
    return_ACPI_STATUS (Status);
//fix_flaw_line_below:
//    return_ACPI_STATUS (ReturnStatus);
 }
",180959,"AcpiPsCompleteFinalOp (
    ACPI_WALK_STATE         *WalkState,
     ACPI_PARSE_OBJECT       *Op,
     ACPI_STATUS             Status)
 {
    ACPI_STATUS             Status2;
 
 
     ACPI_FUNCTION_TRACE_PTR (PsCompleteFinalOp, WalkState);


    /*
     * Complete the last Op (if not completed), and clear the scope stack.
     * It is easily possible to end an AML ""package"" with an unbounded number
     * of open scopes (such as when several ASL blocks are closed with
     * sequential closing braces). We want to terminate each one cleanly.
     */
    ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, ""AML package complete at Op %p\n"", Op));
    do
     {
         if (Op)
         {
            if (WalkState->AscendingCallback != NULL)
             {
                 WalkState->Op = Op;
                 WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
                WalkState->Opcode = Op->Common.AmlOpcode;

                Status = WalkState->AscendingCallback (WalkState);
                Status = AcpiPsNextParseState (WalkState, Op, Status);
                if (Status == AE_CTRL_PENDING)
                {
                    Status = AcpiPsCompleteOp (WalkState, &Op, AE_OK);
                    if (ACPI_FAILURE (Status))
                    {
                        return_ACPI_STATUS (Status);
                    }
                }
 
                 if (Status == AE_CTRL_TERMINATE)
                 {
                    Status = AE_OK;
                    /* Clean up */
                    do
                    {
                        if (Op)
                        {
                            Status2 = AcpiPsCompleteThisOp (WalkState, Op);
                            if (ACPI_FAILURE (Status2))
                            {
                                return_ACPI_STATUS (Status2);
                            }
                        }
                        AcpiPsPopScope (&(WalkState->ParserState), &Op,
                            &WalkState->ArgTypes, &WalkState->ArgCount);
                    } while (Op);
                    return_ACPI_STATUS (Status);
                 }
 
                 else if (ACPI_FAILURE (Status))
                 {
                     /* First error is most important */
 
                    (void) AcpiPsCompleteThisOp (WalkState, Op);
                    return_ACPI_STATUS (Status);
                 }
             }
 
            Status2 = AcpiPsCompleteThisOp (WalkState, Op);
            if (ACPI_FAILURE (Status2))
             {
                return_ACPI_STATUS (Status2);
             }
         }
 
        AcpiPsPopScope (&(WalkState->ParserState), &Op, &WalkState->ArgTypes,
            &WalkState->ArgCount);
 
     } while (Op);
 
    return_ACPI_STATUS (Status);
 }
","AcpiPsCompleteFinalOp (
    ACPI_WALK_STATE         *WalkState,
     ACPI_PARSE_OBJECT       *Op,
     ACPI_STATUS             Status)
 {
    ACPI_STATUS             ReturnStatus = AE_OK;
    BOOLEAN                 Ascending = TRUE;
 
 
     ACPI_FUNCTION_TRACE_PTR (PsCompleteFinalOp, WalkState);


    /*
     * Complete the last Op (if not completed), and clear the scope stack.
     * It is easily possible to end an AML ""package"" with an unbounded number
     * of open scopes (such as when several ASL blocks are closed with
     * sequential closing braces). We want to terminate each one cleanly.
     */
    ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, ""AML package complete at Op %p\n"", Op));
    do
     {
         if (Op)
         {
            if (Ascending && WalkState->AscendingCallback != NULL)
             {
                 WalkState->Op = Op;
                 WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
                WalkState->Opcode = Op->Common.AmlOpcode;

                Status = WalkState->AscendingCallback (WalkState);
                Status = AcpiPsNextParseState (WalkState, Op, Status);
                if (Status == AE_CTRL_PENDING)
                {
                    Status = AcpiPsCompleteOp (WalkState, &Op, AE_OK);
                    if (ACPI_FAILURE (Status))
                    {
                        return_ACPI_STATUS (Status);
                    }
                }
 
                 if (Status == AE_CTRL_TERMINATE)
                 {
                    Ascending = FALSE;
                    ReturnStatus = AE_CTRL_TERMINATE;
                 }
 
                 else if (ACPI_FAILURE (Status))
                 {
                     /* First error is most important */
 
                    Ascending = FALSE;
                    ReturnStatus = Status;
                 }
             }
 
            Status = AcpiPsCompleteThisOp (WalkState, Op);
            if (ACPI_FAILURE (Status))
             {
                Ascending = FALSE;
                if (ACPI_SUCCESS (ReturnStatus) ||
                    ReturnStatus == AE_CTRL_TERMINATE)
                {
                    ReturnStatus = Status;
                }
             }
         }
 
        AcpiPsPopScope (&(WalkState->ParserState), &Op, &WalkState->ArgTypes,
            &WalkState->ArgCount);
 
     } while (Op);
 
    return_ACPI_STATUS (ReturnStatus);
 }
","The `AcpiPsCompleteFinalOp` function is designed to finalize the parsing of an ACPI (Advanced Configuration and Power Interface) operation, ensuring that any incomplete operations are properly completed and that the scope stack is cleared. It takes a `WalkState` structure, a parse object `Op`, and a status code as parameters. The function checks if there are any remaining operations to process, invoking a callback if necessary, and handles various control statuses, including termination and error conditions. Ultimately, it ensures that all operations are completed cleanly, managing the parser's state and returning the final status of the operation.","The provided code is responsible for finalizing the parsing of a sequence of operations in a configuration and power management context. It ensures that any incomplete operations are properly completed and that the scope stack is cleared, which is crucial when multiple blocks are closed sequentially. The function processes each operation, invoking callbacks as needed, and handles various control statuses, including termination and errors. Ultimately, it guarantees that all operations are concluded cleanly, maintaining the integrity of the parser's state and returning the final status of the parsing process.","The vulnerability in the original code stemmed from a failure to properly manage memory caches during early abort scenarios in the ACPI parsing process, leading to potential memory leaks. Specifically, when invalid ACPI information was encountered, the caches for parsing operations were not flushed before being destroyed, resulting in leftover objects in the cache. The fixed code introduced flushing mechanisms within the parsing loop to ensure that all cache objects were cleared before the caches were destroyed, thereby preventing leaks and enhancing security by mitigating the risk of exposing sensitive memory locations that could be exploited by malicious users.","The vulnerability in the original code was due to improper management of memory caches during early abort scenarios in the ACPI parsing process, which could lead to memory leaks. Specifically, when invalid ACPI information was encountered, the caches were not flushed before being destroyed, resulting in leftover objects that could be exploited. The fix introduced flushing mechanisms within the parsing loop to ensure that all cache objects were cleared before the caches were destroyed. This change mitigated the risk of exposing sensitive memory locations, thereby enhancing the overall security of the system.","The vulnerability was fixed by introducing flushing mechanisms within the `acpi_ps_parse_loop()` function to ensure that the caches for parsing operations, specifically the ""Acpi-Parse"" and ""Acpi-ParseExt"" caches, were properly cleared before being destroyed. The updated code checks for error states and invokes the necessary flush operations to handle any remaining cache objects. This ensures that when the `acpi_ut_delete_caches()` function is called, all relevant cache objects are removed, preventing memory leaks and enhancing security by mitigating the risk of exposing sensitive memory locations during early abort scenarios.","The vulnerability was addressed by implementing mechanisms to ensure that memory caches were properly cleared before being destroyed during error handling scenarios. This involved adding flushing operations within the parsing process to handle any remaining cache objects when invalid information was encountered. By ensuring that all relevant cache data was removed prior to the deletion of the caches, the fix effectively prevented memory leaks. This change not only improved memory management but also enhanced security by reducing the risk of exposing sensitive information that could be exploited during early abort situations.","4,4","1, 2","4,4","5,4"
70,70,180960,180960,,Local,Not required,,CVE-2017-13693,https://www.cvedetails.com/cve/CVE-2017-13693/,CWE-200,Low,Complete,,,2017-08-25,4.9,"The acpi_ds_create_operands() function in drivers/acpi/acpica/dsutils.c in the Linux kernel through 4.12.9 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.",2017-09-20,Bypass +Info ,8,https://github.com/acpica/acpica/pull/295/commits/987a3b5cf7175916e2a4b6ea5b8e70f830dfe732,987a3b5cf7175916e2a4b6ea5b8e70f830dfe732,"acpi: acpica: fix acpi operand cache leak in dswstate.c

I found an ACPI cache leak in ACPI early termination and boot continuing case.

When early termination occurs due to malicious ACPI table, Linux kernel
terminates ACPI function and continues to boot process. While kernel terminates
ACPI function, kmem_cache_destroy() reports Acpi-Operand cache leak.

Boot log of ACPI operand cache leak is as follows:
>[    0.585957] ACPI: Added _OSI(Module Device)
>[    0.587218] ACPI: Added _OSI(Processor Device)
>[    0.588530] ACPI: Added _OSI(3.0 _SCP Extensions)
>[    0.589790] ACPI: Added _OSI(Processor Aggregator Device)
>[    0.591534] ACPI Error: Illegal I/O port address/length above 64K: C806E00000004002/0x2 (20170303/hwvalid-155)
>[    0.594351] ACPI Exception: AE_LIMIT, Unable to initialize fixed events (20170303/evevent-88)
>[    0.597858] ACPI: Unable to start the ACPI Interpreter
>[    0.599162] ACPI Error: Could not remove SCI handler (20170303/evmisc-281)
>[    0.601836] kmem_cache_destroy Acpi-Operand: Slab cache still has objects
>[    0.603556] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.12.0-rc5 #26
>[    0.605159] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
>[    0.609177] Call Trace:
>[    0.610063]  ? dump_stack+0x5c/0x81
>[    0.611118]  ? kmem_cache_destroy+0x1aa/0x1c0
>[    0.612632]  ? acpi_sleep_proc_init+0x27/0x27
>[    0.613906]  ? acpi_os_delete_cache+0xa/0x10
>[    0.617986]  ? acpi_ut_delete_caches+0x3f/0x7b
>[    0.619293]  ? acpi_terminate+0xa/0x14
>[    0.620394]  ? acpi_init+0x2af/0x34f
>[    0.621616]  ? __class_create+0x4c/0x80
>[    0.623412]  ? video_setup+0x7f/0x7f
>[    0.624585]  ? acpi_sleep_proc_init+0x27/0x27
>[    0.625861]  ? do_one_initcall+0x4e/0x1a0
>[    0.627513]  ? kernel_init_freeable+0x19e/0x21f
>[    0.628972]  ? rest_init+0x80/0x80
>[    0.630043]  ? kernel_init+0xa/0x100
>[    0.631084]  ? ret_from_fork+0x25/0x30
>[    0.633343] vgaarb: loaded
>[    0.635036] EDAC MC: Ver: 3.0.0
>[    0.638601] PCI: Probing PCI hardware
>[    0.639833] PCI host bridge to bus 0000:00
>[    0.641031] pci_bus 0000:00: root bus resource [io  0x0000-0xffff]
> ... Continue to boot and log is omitted ...

I analyzed this memory leak in detail and found acpi_ds_obj_stack_pop_and_
delete() function miscalculated the top of the stack. acpi_ds_obj_stack_push()
function uses walk_state->operand_index for start position of the top, but
acpi_ds_obj_stack_pop_and_delete() function considers index 0 for it.
Therefore, this causes acpi operand memory leak.

This cache leak causes a security threat because an old kernel (<= 4.9) shows
memory locations of kernel functions in stack dump. Some malicious users
could use this information to neutralize kernel ASLR.

I made a patch to fix ACPI operand cache leak.

Signed-off-by: Seunghun Han <kkamagui@gmail.com>",1,source/components/dispatcher/dsutils.c,"{""sha"": ""e0c934f5ecfc49216d4ef0cd8c68482dc010d335"", ""filename"": ""source/components/dispatcher/dsutils.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/acpica/acpica/blob/987a3b5cf7175916e2a4b6ea5b8e70f830dfe732/source/components/dispatcher/dsutils.c"", ""raw_url"": ""https://github.com/acpica/acpica/raw/987a3b5cf7175916e2a4b6ea5b8e70f830dfe732/source/components/dispatcher/dsutils.c"", ""contents_url"": ""https://api.github.com/repos/acpica/acpica/contents/source/components/dispatcher/dsutils.c?ref=987a3b5cf7175916e2a4b6ea5b8e70f830dfe732"", ""patch"": ""@@ -868,6 +868,8 @@ AcpiDsCreateOperands (\n     ACPI_PARSE_OBJECT       *Arguments[ACPI_OBJ_NUM_OPERANDS];\n     UINT32                  ArgCount = 0;\n     UINT32                  Index = WalkState->NumOperands;\n+    UINT32                  PrevNumOperands = WalkState->NumOperands;\n+    UINT32                  NewNumOperands;\n     UINT32                  i;\n \n \n@@ -900,6 +902,7 @@ AcpiDsCreateOperands (\n \n     /* Create the interpreter arguments, in reverse order */\n \n+    NewNumOperands = Index;\n     Index--;\n     for (i = 0; i < ArgCount; i++)\n     {\n@@ -927,7 +930,11 @@ AcpiDsCreateOperands (\n      * pop everything off of the operand stack and delete those\n      * objects\n      */\n-    AcpiDsObjStackPopAndDelete (ArgCount, WalkState);\n+    WalkState->NumOperands = i;\n+    AcpiDsObjStackPopAndDelete (NewNumOperands, WalkState);\n+\n+    /* Restore operand count */\n+    WalkState->NumOperands = PrevNumOperands;\n \n     ACPI_EXCEPTION ((AE_INFO, Status, \""While creating Arg %u\"", Index));\n     return_ACPI_STATUS (Status);""}","AcpiDsCreateOperands (
    ACPI_WALK_STATE         *WalkState,
    ACPI_PARSE_OBJECT       *FirstArg)
{
    ACPI_STATUS             Status = AE_OK;
    ACPI_PARSE_OBJECT       *Arg;
     ACPI_PARSE_OBJECT       *Arguments[ACPI_OBJ_NUM_OPERANDS];
     UINT32                  ArgCount = 0;
     UINT32                  Index = WalkState->NumOperands;
    UINT32                  PrevNumOperands = WalkState->NumOperands;
    UINT32                  NewNumOperands;
     UINT32                  i;
 
 
    ACPI_FUNCTION_TRACE_PTR (DsCreateOperands, FirstArg);


    /* Get all arguments in the list */

    Arg = FirstArg;
    while (Arg)
    {
        if (Index >= ACPI_OBJ_NUM_OPERANDS)
        {
            return_ACPI_STATUS (AE_BAD_DATA);
        }

        Arguments[Index] = Arg;
        WalkState->Operands [Index] = NULL;

        /* Move on to next argument, if any */

        Arg = Arg->Common.Next;
        ArgCount++;
        Index++;
    }

    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
        ""NumOperands %d, ArgCount %d, Index %d\n"",
        WalkState->NumOperands, ArgCount, Index));
 
     /* Create the interpreter arguments, in reverse order */
 
    NewNumOperands = Index;
     Index--;
     for (i = 0; i < ArgCount; i++)
     {
        Arg = Arguments[Index];
        WalkState->OperandIndex = (UINT8) Index;

        Status = AcpiDsCreateOperand (WalkState, Arg, Index);
        if (ACPI_FAILURE (Status))
        {
            goto Cleanup;
        }

        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
            ""Created Arg #%u (%p) %u args total\n"",
            Index, Arg, ArgCount));
        Index--;
    }

    return_ACPI_STATUS (Status);


Cleanup:
    /*
     * We must undo everything done above; meaning that we must
      * pop everything off of the operand stack and delete those
      * objects
      */
    WalkState->NumOperands = i;
    AcpiDsObjStackPopAndDelete (NewNumOperands, WalkState);

    /* Restore operand count */
    WalkState->NumOperands = PrevNumOperands;
 
     ACPI_EXCEPTION ((AE_INFO, Status, ""While creating Arg %u"", Index));
     return_ACPI_STATUS (Status);
}
","AcpiDsCreateOperands (
    ACPI_WALK_STATE         *WalkState,
    ACPI_PARSE_OBJECT       *FirstArg)
{
    ACPI_STATUS             Status = AE_OK;
    ACPI_PARSE_OBJECT       *Arg;
     ACPI_PARSE_OBJECT       *Arguments[ACPI_OBJ_NUM_OPERANDS];
     UINT32                  ArgCount = 0;
     UINT32                  Index = WalkState->NumOperands;
     UINT32                  i;
 
 
    ACPI_FUNCTION_TRACE_PTR (DsCreateOperands, FirstArg);


    /* Get all arguments in the list */

    Arg = FirstArg;
    while (Arg)
    {
        if (Index >= ACPI_OBJ_NUM_OPERANDS)
        {
            return_ACPI_STATUS (AE_BAD_DATA);
        }

        Arguments[Index] = Arg;
        WalkState->Operands [Index] = NULL;

        /* Move on to next argument, if any */

        Arg = Arg->Common.Next;
        ArgCount++;
        Index++;
    }

    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
        ""NumOperands %d, ArgCount %d, Index %d\n"",
        WalkState->NumOperands, ArgCount, Index));
 
     /* Create the interpreter arguments, in reverse order */
 
     Index--;
     for (i = 0; i < ArgCount; i++)
     {
        Arg = Arguments[Index];
        WalkState->OperandIndex = (UINT8) Index;

        Status = AcpiDsCreateOperand (WalkState, Arg, Index);
        if (ACPI_FAILURE (Status))
        {
            goto Cleanup;
        }

        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
            ""Created Arg #%u (%p) %u args total\n"",
            Index, Arg, ArgCount));
        Index--;
    }

    return_ACPI_STATUS (Status);


Cleanup:
    /*
     * We must undo everything done above; meaning that we must
      * pop everything off of the operand stack and delete those
      * objects
      */
    AcpiDsObjStackPopAndDelete (ArgCount, WalkState);
 
     ACPI_EXCEPTION ((AE_INFO, Status, ""While creating Arg %u"", Index));
     return_ACPI_STATUS (Status);
}
",C,"    UINT32                  PrevNumOperands = WalkState->NumOperands;
    UINT32                  NewNumOperands;
    NewNumOperands = Index;
    WalkState->NumOperands = i;
    AcpiDsObjStackPopAndDelete (NewNumOperands, WalkState);

    /* Restore operand count */
    WalkState->NumOperands = PrevNumOperands;
","    AcpiDsObjStackPopAndDelete (ArgCount, WalkState);
",,"@@ -868,6 +868,8 @@ AcpiDsCreateOperands (
     ACPI_PARSE_OBJECT       *Arguments[ACPI_OBJ_NUM_OPERANDS];
     UINT32                  ArgCount = 0;
     UINT32                  Index = WalkState->NumOperands;
+    UINT32                  PrevNumOperands = WalkState->NumOperands;
+    UINT32                  NewNumOperands;
     UINT32                  i;
 
 
@@ -900,6 +902,7 @@ AcpiDsCreateOperands (
 
     /* Create the interpreter arguments, in reverse order */
 
+    NewNumOperands = Index;
     Index--;
     for (i = 0; i < ArgCount; i++)
     {
@@ -927,7 +930,11 @@ AcpiDsCreateOperands (
      * pop everything off of the operand stack and delete those
      * objects
      */
-    AcpiDsObjStackPopAndDelete (ArgCount, WalkState);
+    WalkState->NumOperands = i;
+    AcpiDsObjStackPopAndDelete (NewNumOperands, WalkState);
+
+    /* Restore operand count */
+    WalkState->NumOperands = PrevNumOperands;
 
     ACPI_EXCEPTION ((AE_INFO, Status, ""While creating Arg %u"", Index));
     return_ACPI_STATUS (Status);",acpica,987a3b5cf7175916e2a4b6ea5b8e70f830dfe732,b542af9a4caeb8397c08421d2a4f2f60952f9e79,1,"AcpiDsCreateOperands (
    ACPI_WALK_STATE         *WalkState,
    ACPI_PARSE_OBJECT       *FirstArg)
{
    ACPI_STATUS             Status = AE_OK;
    ACPI_PARSE_OBJECT       *Arg;
     ACPI_PARSE_OBJECT       *Arguments[ACPI_OBJ_NUM_OPERANDS];
     UINT32                  ArgCount = 0;
     UINT32                  Index = WalkState->NumOperands;
//fix_flaw_line_below:
//    UINT32                  PrevNumOperands = WalkState->NumOperands;
//fix_flaw_line_below:
//    UINT32                  NewNumOperands;
     UINT32                  i;
 
 
    ACPI_FUNCTION_TRACE_PTR (DsCreateOperands, FirstArg);


    /* Get all arguments in the list */

    Arg = FirstArg;
    while (Arg)
    {
        if (Index >= ACPI_OBJ_NUM_OPERANDS)
        {
            return_ACPI_STATUS (AE_BAD_DATA);
        }

        Arguments[Index] = Arg;
        WalkState->Operands [Index] = NULL;

        /* Move on to next argument, if any */

        Arg = Arg->Common.Next;
        ArgCount++;
        Index++;
    }

    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
        ""NumOperands %d, ArgCount %d, Index %d\n"",
        WalkState->NumOperands, ArgCount, Index));
 
     /* Create the interpreter arguments, in reverse order */
 
//fix_flaw_line_below:
//    NewNumOperands = Index;
     Index--;
     for (i = 0; i < ArgCount; i++)
     {
        Arg = Arguments[Index];
        WalkState->OperandIndex = (UINT8) Index;

        Status = AcpiDsCreateOperand (WalkState, Arg, Index);
        if (ACPI_FAILURE (Status))
        {
            goto Cleanup;
        }

        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
            ""Created Arg #%u (%p) %u args total\n"",
            Index, Arg, ArgCount));
        Index--;
    }

    return_ACPI_STATUS (Status);


Cleanup:
    /*
     * We must undo everything done above; meaning that we must
      * pop everything off of the operand stack and delete those
      * objects
      */
//flaw_line_below:
    AcpiDsObjStackPopAndDelete (ArgCount, WalkState);
//fix_flaw_line_below:
//    WalkState->NumOperands = i;
//fix_flaw_line_below:
//    AcpiDsObjStackPopAndDelete (NewNumOperands, WalkState);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    /* Restore operand count */
//fix_flaw_line_below:
//    WalkState->NumOperands = PrevNumOperands;
 
     ACPI_EXCEPTION ((AE_INFO, Status, ""While creating Arg %u"", Index));
     return_ACPI_STATUS (Status);
}
",180960,"AcpiDsCreateOperands (
    ACPI_WALK_STATE         *WalkState,
    ACPI_PARSE_OBJECT       *FirstArg)
{
    ACPI_STATUS             Status = AE_OK;
    ACPI_PARSE_OBJECT       *Arg;
     ACPI_PARSE_OBJECT       *Arguments[ACPI_OBJ_NUM_OPERANDS];
     UINT32                  ArgCount = 0;
     UINT32                  Index = WalkState->NumOperands;
     UINT32                  i;
 
 
    ACPI_FUNCTION_TRACE_PTR (DsCreateOperands, FirstArg);


    /* Get all arguments in the list */

    Arg = FirstArg;
    while (Arg)
    {
        if (Index >= ACPI_OBJ_NUM_OPERANDS)
        {
            return_ACPI_STATUS (AE_BAD_DATA);
        }

        Arguments[Index] = Arg;
        WalkState->Operands [Index] = NULL;

        /* Move on to next argument, if any */

        Arg = Arg->Common.Next;
        ArgCount++;
        Index++;
    }

    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
        ""NumOperands %d, ArgCount %d, Index %d\n"",
        WalkState->NumOperands, ArgCount, Index));
 
     /* Create the interpreter arguments, in reverse order */
 
     Index--;
     for (i = 0; i < ArgCount; i++)
     {
        Arg = Arguments[Index];
        WalkState->OperandIndex = (UINT8) Index;

        Status = AcpiDsCreateOperand (WalkState, Arg, Index);
        if (ACPI_FAILURE (Status))
        {
            goto Cleanup;
        }

        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
            ""Created Arg #%u (%p) %u args total\n"",
            Index, Arg, ArgCount));
        Index--;
    }

    return_ACPI_STATUS (Status);


Cleanup:
    /*
     * We must undo everything done above; meaning that we must
      * pop everything off of the operand stack and delete those
      * objects
      */
    AcpiDsObjStackPopAndDelete (ArgCount, WalkState);
 
     ACPI_EXCEPTION ((AE_INFO, Status, ""While creating Arg %u"", Index));
     return_ACPI_STATUS (Status);
}
","AcpiDsCreateOperands (
    ACPI_WALK_STATE         *WalkState,
    ACPI_PARSE_OBJECT       *FirstArg)
{
    ACPI_STATUS             Status = AE_OK;
    ACPI_PARSE_OBJECT       *Arg;
     ACPI_PARSE_OBJECT       *Arguments[ACPI_OBJ_NUM_OPERANDS];
     UINT32                  ArgCount = 0;
     UINT32                  Index = WalkState->NumOperands;
    UINT32                  PrevNumOperands = WalkState->NumOperands;
    UINT32                  NewNumOperands;
     UINT32                  i;
 
 
    ACPI_FUNCTION_TRACE_PTR (DsCreateOperands, FirstArg);


    /* Get all arguments in the list */

    Arg = FirstArg;
    while (Arg)
    {
        if (Index >= ACPI_OBJ_NUM_OPERANDS)
        {
            return_ACPI_STATUS (AE_BAD_DATA);
        }

        Arguments[Index] = Arg;
        WalkState->Operands [Index] = NULL;

        /* Move on to next argument, if any */

        Arg = Arg->Common.Next;
        ArgCount++;
        Index++;
    }

    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
        ""NumOperands %d, ArgCount %d, Index %d\n"",
        WalkState->NumOperands, ArgCount, Index));
 
     /* Create the interpreter arguments, in reverse order */
 
    NewNumOperands = Index;
     Index--;
     for (i = 0; i < ArgCount; i++)
     {
        Arg = Arguments[Index];
        WalkState->OperandIndex = (UINT8) Index;

        Status = AcpiDsCreateOperand (WalkState, Arg, Index);
        if (ACPI_FAILURE (Status))
        {
            goto Cleanup;
        }

        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
            ""Created Arg #%u (%p) %u args total\n"",
            Index, Arg, ArgCount));
        Index--;
    }

    return_ACPI_STATUS (Status);


Cleanup:
    /*
     * We must undo everything done above; meaning that we must
      * pop everything off of the operand stack and delete those
      * objects
      */
    WalkState->NumOperands = i;
    AcpiDsObjStackPopAndDelete (NewNumOperands, WalkState);

    /* Restore operand count */
    WalkState->NumOperands = PrevNumOperands;
 
     ACPI_EXCEPTION ((AE_INFO, Status, ""While creating Arg %u"", Index));
     return_ACPI_STATUS (Status);
}
","The `AcpiDsCreateOperands` function processes a list of arguments for an ACPI (Advanced Configuration and Power Interface) operation, creating operand objects from the provided arguments. It initializes an array to hold the arguments and iterates through the linked list of `ACPI_PARSE_OBJECT` structures, storing them in the array while checking for overflow. After collecting the arguments, it creates operand objects in reverse order, updating the `WalkState` structure accordingly. If any errors occur during operand creation, it cleans up by popping and deleting the created objects from the operand stack, ensuring proper memory management and error handling.","The code defines a function that processes a list of arguments for a specific operation, creating corresponding operand objects. It begins by initializing an array to store the arguments and iterates through a linked list to collect them, ensuring that the number of arguments does not exceed a predefined limit. After gathering the arguments, the function creates the operand objects in reverse order while updating the state information. If any errors arise during this process, it performs cleanup by removing and deleting the created objects, thereby maintaining proper memory management and handling potential issues effectively.","The vulnerability in the original code stemmed from a miscalculation of the operand stack's top position during cleanup, leading to a memory leak when the ACPI function was terminated prematurely. Specifically, the cleanup function incorrectly assumed the stack started at index 0, while the push function used the `WalkState->OperandIndex` to determine the top of the stack. This discrepancy resulted in untracked operand objects remaining in memory, causing a cache leak. The fix involved introducing a new variable to store the current number of operands and ensuring that the cleanup function accurately reflected the state of the operand stack, thus preventing the memory leak.","The vulnerability in the original code was due to a misalignment in how the operand stack's top position was calculated during cleanup, leading to a memory leak when the ACPI function was terminated unexpectedly. Specifically, the cleanup process incorrectly assumed the stack started at the first index, while the push operation used a different index to track the top of the stack. This inconsistency resulted in untracked memory objects remaining, which could be exploited to reveal sensitive information. The fix involved accurately tracking the number of operands and ensuring the cleanup function correctly referenced the current state of the stack, thereby preventing the memory leak.","The vulnerability was fixed by introducing a new variable to store the current number of operands, specifically `NewNumOperands`, which accurately reflects the state of the operand stack during cleanup. The cleanup function was modified to use this variable when calling the `AcpiDsObjStackPopAndDelete` function, ensuring that the correct number of operands was removed from the stack. Additionally, the previous operand count was preserved using `PrevNumOperands`, allowing for proper restoration after cleanup. This adjustment ensured that the cleanup process correctly accounted for all operands, thereby preventing the memory leak that could occur during early termination.","The vulnerability was addressed by accurately tracking the number of operands in the stack during the cleanup process. A new variable was introduced to store the current count of operands, ensuring that the cleanup function correctly referenced this count when removing objects from the stack. Additionally, the previous operand count was preserved to allow for proper restoration after the cleanup. These changes ensured that all operands were accounted for during cleanup, effectively preventing the memory leak that could occur when the function was terminated unexpectedly, thus enhancing the overall stability and security of the system.","5,5","5,5","4,4","4,4"
71,71,180982,180982,,Remote,Not required,,CVE-2017-13143,https://www.cvedetails.com/cve/CVE-2017-13143/,CWE-200,Low,Partial,,,2017-08-23,5.0,"In ImageMagick before 6.9.7-6 and 7.x before 7.0.4-6, the ReadMATImage function in coders/mat.c uses uninitialized data, which might allow remote attackers to obtain sensitive information from process memory.",2018-06-13,+Info ,1,https://github.com/ImageMagick/ImageMagick/commit/51b0ae01709adc1e4a9245e158ef17b85a110960,51b0ae01709adc1e4a9245e158ef17b85a110960,https://github.com/ImageMagick/ImageMagick/issues/362,0,coders/mat.c,"{""sha"": ""cf2190bf373a28e1ee6008ba2d33c8e0cc0779fc"", ""filename"": ""coders/mat.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/51b0ae01709adc1e4a9245e158ef17b85a110960/coders/mat.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/51b0ae01709adc1e4a9245e158ef17b85a110960/coders/mat.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/mat.c?ref=51b0ae01709adc1e4a9245e158ef17b85a110960"", ""patch"": ""@@ -1123,6 +1123,7 @@ RestoreMSCWarning\n     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n     if (BImgBuff == NULL)\n       ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n+    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n \n     MinVal = 0;\n     MaxVal = 0;""}","static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  register Quantum *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  image = AcquireImage(image_info,exception);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  clone_info=CloneImageInfo(image_info);
  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
MATLAB_KO: ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           (void) ReadBlobXXXLong(image2);
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
            ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

    NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        image->type=GrayscaleType;
        SetImageColorspace(image,GRAYColorspace,exception);
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));

  /* ----- Load raster data ----- */
     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
     if (BImgBuff == NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));
 
     MinVal = 0;
     MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (Quantum *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(image,q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
    quantum_info=DestroyQuantumInfo(quantum_info);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
            exception);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
            exception);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image,exception);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }
    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
        }
  }

  RelinquishMagickMemory(BImgBuff);
END_OF_READING:
  clone_info=DestroyImageInfo(clone_info);
  CloseBlob(image);


  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if(image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  return (image);
}
","static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  register Quantum *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  image = AcquireImage(image_info,exception);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  clone_info=CloneImageInfo(image_info);
  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
MATLAB_KO: ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           (void) ReadBlobXXXLong(image2);
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
            ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

    NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        image->type=GrayscaleType;
        SetImageColorspace(image,GRAYColorspace,exception);
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));

  /* ----- Load raster data ----- */
     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
     if (BImgBuff == NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
 
     MinVal = 0;
     MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (Quantum *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(image,q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
    quantum_info=DestroyQuantumInfo(quantum_info);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
            exception);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
            exception);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image,exception);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }
    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
        }
  }

  RelinquishMagickMemory(BImgBuff);
END_OF_READING:
  clone_info=DestroyImageInfo(clone_info);
  CloseBlob(image);


  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if(image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  return (image);
}
",C,"    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));
",,,"@@ -1123,6 +1123,7 @@ RestoreMSCWarning
     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
     if (BImgBuff == NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
+    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));
 
     MinVal = 0;
     MaxVal = 0;",ImageMagick,51b0ae01709adc1e4a9245e158ef17b85a110960,4a44cbd6d4dad0aa5723603fe884360b5e997d6d,1,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  register Quantum *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  image = AcquireImage(image_info,exception);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  clone_info=CloneImageInfo(image_info);
  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
MATLAB_KO: ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           (void) ReadBlobXXXLong(image2);
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
            ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

    NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        image->type=GrayscaleType;
        SetImageColorspace(image,GRAYColorspace,exception);
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));

  /* ----- Load raster data ----- */
     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
     if (BImgBuff == NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
//fix_flaw_line_below:
//    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));
 
     MinVal = 0;
     MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (Quantum *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(image,q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
    quantum_info=DestroyQuantumInfo(quantum_info);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
            exception);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
            exception);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image,exception);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }
    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
        }
  }

  RelinquishMagickMemory(BImgBuff);
END_OF_READING:
  clone_info=DestroyImageInfo(clone_info);
  CloseBlob(image);


  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if(image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  return (image);
}
",180982,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  register Quantum *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  image = AcquireImage(image_info,exception);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  clone_info=CloneImageInfo(image_info);
  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
MATLAB_KO: ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           (void) ReadBlobXXXLong(image2);
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
            ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

    NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        image->type=GrayscaleType;
        SetImageColorspace(image,GRAYColorspace,exception);
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));

  /* ----- Load raster data ----- */
     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
     if (BImgBuff == NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
 
     MinVal = 0;
     MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (Quantum *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(image,q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
    quantum_info=DestroyQuantumInfo(quantum_info);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
            exception);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
            exception);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image,exception);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }
    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
        }
  }

  RelinquishMagickMemory(BImgBuff);
END_OF_READING:
  clone_info=DestroyImageInfo(clone_info);
  CloseBlob(image);


  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if(image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  return (image);
}
","static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  register Quantum *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  image = AcquireImage(image_info,exception);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  clone_info=CloneImageInfo(image_info);
  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
MATLAB_KO: ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           (void) ReadBlobXXXLong(image2);
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
            ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

    NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        image->type=GrayscaleType;
        SetImageColorspace(image,GRAYColorspace,exception);
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));

  /* ----- Load raster data ----- */
     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
     if (BImgBuff == NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));
 
     MinVal = 0;
     MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (Quantum *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(image,q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
    quantum_info=DestroyQuantumInfo(quantum_info);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
            exception);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
            exception);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image,exception);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }
    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
        }
  }

  RelinquishMagickMemory(BImgBuff);
END_OF_READING:
  clone_info=DestroyImageInfo(clone_info);
  CloseBlob(image);


  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if(image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  return (image);
}
","The `ReadMATImage` function is designed to read MATLAB image files and convert them into a format usable by the MagickCore image processing library. It begins by validating input parameters and opening the image file, then reads the MATLAB header to determine the file's structure and data type. The function supports various data types, including integers and floating-point numbers, and handles both 2D and multi-dimensional matrices. It processes the image data, including potential complex values, and manages memory allocation for pixel data. Finally, it rotates the image if necessary, cleans up resources, and returns the constructed image or an error if the process fails.","The provided code defines a function that reads MATLAB image files and converts them into a compatible image format for processing. It begins by validating input parameters and opening the specified image file, then extracts the header information to determine the file's structure and data type. The function supports various data types and handles both two-dimensional and multi-dimensional matrices. It processes the image data, including potential complex values, while managing memory allocation for pixel data. Finally, the function cleans up resources and returns the constructed image or an error if any issues arise during the reading process.","The vulnerability in the original code stemmed from a lack of proper memory initialization for the buffer used to store image data, which could lead to reading uninitialized memory and potential information leakage. Specifically, the buffer was allocated but not reset, allowing any residual data to remain. The fix involved adding a memory reset function to initialize the buffer to zero after allocation, ensuring that it does not contain any garbage values. This change enhances security by preventing the exposure of sensitive data and ensuring that the image processing operates on a clean slate.","The vulnerability in the original code was due to the allocation of memory for a buffer without initializing it, which could lead to the use of uninitialized data during image processing. This oversight posed a risk of information leakage, as the buffer might contain sensitive data from previous operations. The fix involved adding a step to reset the allocated memory to zero immediately after allocation, ensuring that the buffer starts with a clean state. This change mitigates the risk of exposing unintended data and enhances the overall security and reliability of the image processing functionality.","The vulnerability was fixed by introducing a memory reset function immediately after allocating the buffer for image data. Specifically, the code added a call to `ResetMagickMemory`, which initializes the allocated buffer to zero, ensuring that it does not contain any residual data from previous operations. This change was implemented right after the allocation of the buffer using `AcquireQuantumMemory`, addressing the risk of using uninitialized memory. By ensuring that the buffer starts with a clean state, the fix effectively prevents potential information leakage and enhances the security of the image processing routine.","The vulnerability was fixed by adding a step to initialize the allocated memory buffer immediately after its creation. This involved resetting the memory to zero, ensuring that it does not contain any leftover data from previous operations. By implementing this change, the code prevents the use of uninitialized memory, which could lead to unintended data exposure or security risks. This enhancement not only improves the reliability of the image processing functionality but also mitigates the potential for information leakage, thereby strengthening the overall security of the application.","5, 5","5, 5","4,5","4,5"
72,72,181208,181208,,Remote,Not required,,CVE-2017-11448,https://www.cvedetails.com/cve/CVE-2017-11448/,CWE-200,Medium,Partial,,,2017-07-19,4.3,The ReadJPEGImage function in coders/jpeg.c in ImageMagick before 7.0.6-1 allows remote attackers to obtain sensitive information from uninitialized memory locations via a crafted file.,2017-07-20,+Info ,2,https://github.com/ImageMagick/ImageMagick/commit/1737ac82b335e53376382c07b9a500d73dd2aa11,1737ac82b335e53376382c07b9a500d73dd2aa11,Zero pixel buffer,0,coders/jpeg.c,"{""sha"": ""3c093c1173c619313fe0b60771e3a931e76b7eea"", ""filename"": ""coders/jpeg.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/1737ac82b335e53376382c07b9a500d73dd2aa11/coders/jpeg.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/1737ac82b335e53376382c07b9a500d73dd2aa11/coders/jpeg.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/jpeg.c?ref=1737ac82b335e53376382c07b9a500d73dd2aa11"", ""patch"": ""@@ -1293,6 +1293,8 @@ static Image *ReadJPEGImage(const ImageInfo *image_info,\n       ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n     }\n   jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n+  (void) ResetMagickMemory(jpeg_pixels,0,image->columns* \n+    jpeg_info.output_components*sizeof(*jpeg_pixels));\n   /*\n     Convert JPEG pixels to pixel packets.\n   */""}","static Image *ReadJPEGImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  char
    value[MaxTextExtent];

  const char
    *option;

  ErrorManager
    error_manager;

  Image
    *image;

  IndexPacket
    index;

  JSAMPLE
    *volatile jpeg_pixels;

  JSAMPROW
    scanline[1];

  MagickBooleanType
    debug,
    status;

  MagickSizeType
    number_pixels;

  MemoryInfo
    *memory_info;

  register ssize_t
    i;

  struct jpeg_decompress_struct
    jpeg_info;

  struct jpeg_error_mgr
    jpeg_error;

  register JSAMPLE
    *p;

  size_t
    units;

  ssize_t
    y;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  debug=IsEventLogging();
  (void) debug;
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Verify that file size large enough to contain a JPEG datastream.
  */
  if (GetBlobSize(image) < 107)
    ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
  /*
    Initialize JPEG parameters.
  */
  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));
  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));
  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));
  jpeg_info.err=jpeg_std_error(&jpeg_error);
  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;
  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;
  memory_info=(MemoryInfo *) NULL;
  error_manager.image=image;
  if (setjmp(error_manager.error_recovery) != 0)
    {
      jpeg_destroy_decompress(&jpeg_info);
      if (error_manager.profile != (StringInfo *) NULL)
        error_manager.profile=DestroyStringInfo(error_manager.profile);
      (void) CloseBlob(image);
      number_pixels=(MagickSizeType) image->columns*image->rows;
      if (number_pixels != 0)
        return(GetFirstImageInList(image));
      InheritException(exception,&image->exception);
      return(DestroyImage(image));
    }
  jpeg_info.client_data=(void *) &error_manager;
  jpeg_create_decompress(&jpeg_info);
  JPEGSourceManager(&jpeg_info,image);
  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);
  option=GetImageOption(image_info,""profile:skip"");
  if (IsOptionMember(""ICC"",option) == MagickFalse)
    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);
  if (IsOptionMember(""IPTC"",option) == MagickFalse)
    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);
  for (i=1; i < 16; i++)
    if ((i != 2) && (i != 13) && (i != 14))
      if (IsOptionMember(""APP"",option) == MagickFalse)
        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);
  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);
  if ((image_info->colorspace == YCbCrColorspace) ||
      (image_info->colorspace == Rec601YCbCrColorspace) ||
      (image_info->colorspace == Rec709YCbCrColorspace))
    jpeg_info.out_color_space=JCS_YCbCr;
  /*
    Set image resolution.
  */
  units=0;
  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&
      (jpeg_info.Y_density != 1))
    {
      image->x_resolution=(double) jpeg_info.X_density;
      image->y_resolution=(double) jpeg_info.Y_density;
      units=(size_t) jpeg_info.density_unit;
    }
  if (units == 1)
    image->units=PixelsPerInchResolution;
  if (units == 2)
    image->units=PixelsPerCentimeterResolution;
  number_pixels=(MagickSizeType) image->columns*image->rows;
  option=GetImageOption(image_info,""jpeg:size"");
  if ((option != (const char *) NULL) &&
      (jpeg_info.out_color_space != JCS_YCbCr))
    {
      double
        scale_factor;

      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      /*
        Scale the image.
      */
      flags=ParseGeometry(option,&geometry_info);
      if ((flags & SigmaValue) == 0)
        geometry_info.sigma=geometry_info.rho;
      jpeg_calc_output_dimensions(&jpeg_info);
      image->magick_columns=jpeg_info.output_width;
      image->magick_rows=jpeg_info.output_height;
      scale_factor=1.0;
      if (geometry_info.rho != 0.0)
        scale_factor=jpeg_info.output_width/geometry_info.rho;
      if ((geometry_info.sigma != 0.0) &&
          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))
        scale_factor=jpeg_info.output_height/geometry_info.sigma;
      jpeg_info.scale_num=1U;
      jpeg_info.scale_denom=(unsigned int) scale_factor;
      jpeg_calc_output_dimensions(&jpeg_info);
      if (image->debug != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Scale factor: %.20g"",(double) scale_factor);
    }
#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)
#if defined(D_LOSSLESS_SUPPORTED)
  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?
    JPEGInterlace : NoInterlace;
  image->compression=jpeg_info.process == JPROC_LOSSLESS ?
    LosslessJPEGCompression : JPEGCompression;
  if (jpeg_info.data_precision > 8)
    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
      ""12-bit JPEG not supported. Reducing pixel data to 8 bits"",""`%s'"",
      image->filename);
  if (jpeg_info.data_precision == 16)
    jpeg_info.data_precision=12;
#else
  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :
    NoInterlace;
  image->compression=JPEGCompression;
#endif
#else
  image->compression=JPEGCompression;
  image->interlace=JPEGInterlace;
#endif
  option=GetImageOption(image_info,""jpeg:colors"");
  if (option != (const char *) NULL)
    {
      /*
        Let the JPEG library quantize for us.
      */
      jpeg_info.quantize_colors=TRUE;
      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);
    }
  option=GetImageOption(image_info,""jpeg:block-smoothing"");
  if (option != (const char *) NULL)
    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :
      FALSE;
  jpeg_info.dct_method=JDCT_FLOAT;
  option=GetImageOption(image_info,""jpeg:dct-method"");
  if (option != (const char *) NULL)
    switch (*option)
    {
      case 'D':
      case 'd':
      {
        if (LocaleCompare(option,""default"") == 0)
          jpeg_info.dct_method=JDCT_DEFAULT;
        break;
      }
      case 'F':
      case 'f':
      {
        if (LocaleCompare(option,""fastest"") == 0)
          jpeg_info.dct_method=JDCT_FASTEST;
        if (LocaleCompare(option,""float"") == 0)
          jpeg_info.dct_method=JDCT_FLOAT;
        break;
      }
      case 'I':
      case 'i':
      {
        if (LocaleCompare(option,""ifast"") == 0)
          jpeg_info.dct_method=JDCT_IFAST;
        if (LocaleCompare(option,""islow"") == 0)
          jpeg_info.dct_method=JDCT_ISLOW;
        break;
      }
    }
  option=GetImageOption(image_info,""jpeg:fancy-upsampling"");
  if (option != (const char *) NULL)
    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :
      FALSE;
  (void) jpeg_start_decompress(&jpeg_info);
  image->columns=jpeg_info.output_width;
  image->rows=jpeg_info.output_height;
  image->depth=(size_t) jpeg_info.data_precision;
  switch (jpeg_info.out_color_space)
  {
    case JCS_RGB:
    default:
    {
      (void) SetImageColorspace(image,sRGBColorspace);
      break;
    }
    case JCS_GRAYSCALE:
    {
      (void) SetImageColorspace(image,GRAYColorspace);
      break;
    }
    case JCS_YCbCr:
    {
      (void) SetImageColorspace(image,YCbCrColorspace);
      break;
    }
    case JCS_CMYK:
    {
      (void) SetImageColorspace(image,CMYKColorspace);
      break;
    }
  }
  if (IsITUFaxImage(image) != MagickFalse)
    {
      (void) SetImageColorspace(image,LabColorspace);
      jpeg_info.out_color_space=JCS_YCbCr;
    }
  option=GetImageOption(image_info,""jpeg:colors"");
  if (option != (const char *) NULL)
    if (AcquireImageColormap(image,StringToUnsignedLong(option)) == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
  if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))
    {
      size_t
        colors;

      colors=(size_t) GetQuantumRange(image->depth)+1;
      if (AcquireImageColormap(image,colors) == MagickFalse)
        {
          InheritException(exception,&image->exception);
          return(DestroyImageList(image));
        }
    }
  if (image->debug != MagickFalse)
    {
      if (image->interlace != NoInterlace)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Interlace: progressive"");
      else
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Interlace: nonprogressive"");
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Data precision: %d"",
        (int) jpeg_info.data_precision);
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Geometry: %dx%d"",
        (int) jpeg_info.output_width,(int) jpeg_info.output_height);
    }
  JPEGSetImageQuality(&jpeg_info,image);
  JPEGSetImageSamplingFactor(&jpeg_info,image);
  (void) FormatLocaleString(value,MaxTextExtent,""%.20g"",(double)
    jpeg_info.out_color_space);
  (void) SetImageProperty(image,""jpeg:colorspace"",value);
  if (image_info->ping != MagickFalse)
    {
      jpeg_destroy_decompress(&jpeg_info);
      (void) CloseBlob(image);
      return(GetFirstImageInList(image));
    }
  status=SetImageExtent(image,image->columns,image->rows);
  if (status == MagickFalse)
    {
      jpeg_destroy_decompress(&jpeg_info);
      InheritException(exception,&image->exception);
      return(DestroyImageList(image));
    }
  if ((jpeg_info.output_components != 1) &&
      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))
    {
      jpeg_destroy_decompress(&jpeg_info);
      ThrowReaderException(CorruptImageError,""ImageTypeNotSupported"");
    }
  memory_info=AcquireVirtualMemory((size_t) image->columns,
    jpeg_info.output_components*sizeof(*jpeg_pixels));
  if (memory_info == (MemoryInfo *) NULL)
    {
      jpeg_destroy_decompress(&jpeg_info);
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     }
   jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);
  (void) ResetMagickMemory(jpeg_pixels,0,image->columns* 
    jpeg_info.output_components*sizeof(*jpeg_pixels));
   /*
     Convert JPEG pixels to pixel packets.
   */
  if (setjmp(error_manager.error_recovery) != 0)
    {
      if (memory_info != (MemoryInfo *) NULL)
        memory_info=RelinquishVirtualMemory(memory_info);
      jpeg_destroy_decompress(&jpeg_info);
      (void) CloseBlob(image);
      number_pixels=(MagickSizeType) image->columns*image->rows;
      if (number_pixels != 0)
        return(GetFirstImageInList(image));
      return(DestroyImage(image));
    }
  if (jpeg_info.quantize_colors != 0)
    {
      image->colors=(size_t) jpeg_info.actual_number_of_colors;
      if (jpeg_info.out_color_space == JCS_GRAYSCALE)
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);
          image->colormap[i].green=image->colormap[i].red;
          image->colormap[i].blue=image->colormap[i].red;
          image->colormap[i].opacity=OpaqueOpacity;
        }
      else
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);
          image->colormap[i].green=ScaleCharToQuantum(jpeg_info.colormap[1][i]);
          image->colormap[i].blue=ScaleCharToQuantum(jpeg_info.colormap[2][i]);
          image->colormap[i].opacity=OpaqueOpacity;
        }
    }
  scanline[0]=(JSAMPROW) jpeg_pixels;
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register IndexPacket
      *magick_restrict indexes;

    register ssize_t
      x;

    register PixelPacket
      *magick_restrict q;

    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)
      {
        (void) ThrowMagickException(exception,GetMagickModule(),
          CorruptImageWarning,""SkipToSyncByte"",""`%s'"",image->filename);
        continue;
      }
    p=jpeg_pixels;
    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (PixelPacket *) NULL)
      break;
    indexes=GetAuthenticIndexQueue(image);
    if (jpeg_info.data_precision > 8)
      {
        unsigned short
          scale;

        scale=65535/(unsigned short) GetQuantumRange((size_t)
          jpeg_info.data_precision);
        if (jpeg_info.output_components == 1)
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            size_t
              pixel;

            pixel=(size_t) (scale*GETJSAMPLE(*p));
            index=ConstrainColormapIndex(image,pixel);
            SetPixelIndex(indexes+x,index);
            SetPixelRGBO(q,image->colormap+(ssize_t) index);
            p++;
            q++;
          }
        else
          if (image->colorspace != CMYKColorspace)
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelRed(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelGreen(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelBlue(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelOpacity(q,OpaqueOpacity);
              q++;
            }
          else
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelCyan(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelMagenta(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelYellow(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelBlack(indexes+x,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelOpacity(q,OpaqueOpacity);
              q++;
            }
      }
    else
      if (jpeg_info.output_components == 1)
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          index=ConstrainColormapIndex(image,(size_t) GETJSAMPLE(*p));
          SetPixelIndex(indexes+x,index);
          SetPixelRGBO(q,image->colormap+(ssize_t) index);
          p++;
          q++;
        }
      else
        if (image->colorspace != CMYKColorspace)
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelGreen(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelBlue(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelOpacity(q,OpaqueOpacity);
            q++;
          }
        else
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelCyan(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelMagenta(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelYellow(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelBlack(indexes+x,QuantumRange-ScaleCharToQuantum(
              (unsigned char) GETJSAMPLE(*p++)));
            SetPixelOpacity(q,OpaqueOpacity);
            q++;
          }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
      image->rows);
    if (status == MagickFalse)
      {
        jpeg_abort_decompress(&jpeg_info);
        break;
      }
  }
  if (status != MagickFalse)
    {
      error_manager.finished=MagickTrue;
      if (setjmp(error_manager.error_recovery) == 0)
        (void) jpeg_finish_decompress(&jpeg_info);
    }
  /*
    Free jpeg resources.
  */
  jpeg_destroy_decompress(&jpeg_info);
  memory_info=RelinquishVirtualMemory(memory_info);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","static Image *ReadJPEGImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  char
    value[MaxTextExtent];

  const char
    *option;

  ErrorManager
    error_manager;

  Image
    *image;

  IndexPacket
    index;

  JSAMPLE
    *volatile jpeg_pixels;

  JSAMPROW
    scanline[1];

  MagickBooleanType
    debug,
    status;

  MagickSizeType
    number_pixels;

  MemoryInfo
    *memory_info;

  register ssize_t
    i;

  struct jpeg_decompress_struct
    jpeg_info;

  struct jpeg_error_mgr
    jpeg_error;

  register JSAMPLE
    *p;

  size_t
    units;

  ssize_t
    y;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  debug=IsEventLogging();
  (void) debug;
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Verify that file size large enough to contain a JPEG datastream.
  */
  if (GetBlobSize(image) < 107)
    ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
  /*
    Initialize JPEG parameters.
  */
  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));
  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));
  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));
  jpeg_info.err=jpeg_std_error(&jpeg_error);
  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;
  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;
  memory_info=(MemoryInfo *) NULL;
  error_manager.image=image;
  if (setjmp(error_manager.error_recovery) != 0)
    {
      jpeg_destroy_decompress(&jpeg_info);
      if (error_manager.profile != (StringInfo *) NULL)
        error_manager.profile=DestroyStringInfo(error_manager.profile);
      (void) CloseBlob(image);
      number_pixels=(MagickSizeType) image->columns*image->rows;
      if (number_pixels != 0)
        return(GetFirstImageInList(image));
      InheritException(exception,&image->exception);
      return(DestroyImage(image));
    }
  jpeg_info.client_data=(void *) &error_manager;
  jpeg_create_decompress(&jpeg_info);
  JPEGSourceManager(&jpeg_info,image);
  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);
  option=GetImageOption(image_info,""profile:skip"");
  if (IsOptionMember(""ICC"",option) == MagickFalse)
    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);
  if (IsOptionMember(""IPTC"",option) == MagickFalse)
    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);
  for (i=1; i < 16; i++)
    if ((i != 2) && (i != 13) && (i != 14))
      if (IsOptionMember(""APP"",option) == MagickFalse)
        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);
  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);
  if ((image_info->colorspace == YCbCrColorspace) ||
      (image_info->colorspace == Rec601YCbCrColorspace) ||
      (image_info->colorspace == Rec709YCbCrColorspace))
    jpeg_info.out_color_space=JCS_YCbCr;
  /*
    Set image resolution.
  */
  units=0;
  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&
      (jpeg_info.Y_density != 1))
    {
      image->x_resolution=(double) jpeg_info.X_density;
      image->y_resolution=(double) jpeg_info.Y_density;
      units=(size_t) jpeg_info.density_unit;
    }
  if (units == 1)
    image->units=PixelsPerInchResolution;
  if (units == 2)
    image->units=PixelsPerCentimeterResolution;
  number_pixels=(MagickSizeType) image->columns*image->rows;
  option=GetImageOption(image_info,""jpeg:size"");
  if ((option != (const char *) NULL) &&
      (jpeg_info.out_color_space != JCS_YCbCr))
    {
      double
        scale_factor;

      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      /*
        Scale the image.
      */
      flags=ParseGeometry(option,&geometry_info);
      if ((flags & SigmaValue) == 0)
        geometry_info.sigma=geometry_info.rho;
      jpeg_calc_output_dimensions(&jpeg_info);
      image->magick_columns=jpeg_info.output_width;
      image->magick_rows=jpeg_info.output_height;
      scale_factor=1.0;
      if (geometry_info.rho != 0.0)
        scale_factor=jpeg_info.output_width/geometry_info.rho;
      if ((geometry_info.sigma != 0.0) &&
          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))
        scale_factor=jpeg_info.output_height/geometry_info.sigma;
      jpeg_info.scale_num=1U;
      jpeg_info.scale_denom=(unsigned int) scale_factor;
      jpeg_calc_output_dimensions(&jpeg_info);
      if (image->debug != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Scale factor: %.20g"",(double) scale_factor);
    }
#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)
#if defined(D_LOSSLESS_SUPPORTED)
  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?
    JPEGInterlace : NoInterlace;
  image->compression=jpeg_info.process == JPROC_LOSSLESS ?
    LosslessJPEGCompression : JPEGCompression;
  if (jpeg_info.data_precision > 8)
    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
      ""12-bit JPEG not supported. Reducing pixel data to 8 bits"",""`%s'"",
      image->filename);
  if (jpeg_info.data_precision == 16)
    jpeg_info.data_precision=12;
#else
  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :
    NoInterlace;
  image->compression=JPEGCompression;
#endif
#else
  image->compression=JPEGCompression;
  image->interlace=JPEGInterlace;
#endif
  option=GetImageOption(image_info,""jpeg:colors"");
  if (option != (const char *) NULL)
    {
      /*
        Let the JPEG library quantize for us.
      */
      jpeg_info.quantize_colors=TRUE;
      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);
    }
  option=GetImageOption(image_info,""jpeg:block-smoothing"");
  if (option != (const char *) NULL)
    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :
      FALSE;
  jpeg_info.dct_method=JDCT_FLOAT;
  option=GetImageOption(image_info,""jpeg:dct-method"");
  if (option != (const char *) NULL)
    switch (*option)
    {
      case 'D':
      case 'd':
      {
        if (LocaleCompare(option,""default"") == 0)
          jpeg_info.dct_method=JDCT_DEFAULT;
        break;
      }
      case 'F':
      case 'f':
      {
        if (LocaleCompare(option,""fastest"") == 0)
          jpeg_info.dct_method=JDCT_FASTEST;
        if (LocaleCompare(option,""float"") == 0)
          jpeg_info.dct_method=JDCT_FLOAT;
        break;
      }
      case 'I':
      case 'i':
      {
        if (LocaleCompare(option,""ifast"") == 0)
          jpeg_info.dct_method=JDCT_IFAST;
        if (LocaleCompare(option,""islow"") == 0)
          jpeg_info.dct_method=JDCT_ISLOW;
        break;
      }
    }
  option=GetImageOption(image_info,""jpeg:fancy-upsampling"");
  if (option != (const char *) NULL)
    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :
      FALSE;
  (void) jpeg_start_decompress(&jpeg_info);
  image->columns=jpeg_info.output_width;
  image->rows=jpeg_info.output_height;
  image->depth=(size_t) jpeg_info.data_precision;
  switch (jpeg_info.out_color_space)
  {
    case JCS_RGB:
    default:
    {
      (void) SetImageColorspace(image,sRGBColorspace);
      break;
    }
    case JCS_GRAYSCALE:
    {
      (void) SetImageColorspace(image,GRAYColorspace);
      break;
    }
    case JCS_YCbCr:
    {
      (void) SetImageColorspace(image,YCbCrColorspace);
      break;
    }
    case JCS_CMYK:
    {
      (void) SetImageColorspace(image,CMYKColorspace);
      break;
    }
  }
  if (IsITUFaxImage(image) != MagickFalse)
    {
      (void) SetImageColorspace(image,LabColorspace);
      jpeg_info.out_color_space=JCS_YCbCr;
    }
  option=GetImageOption(image_info,""jpeg:colors"");
  if (option != (const char *) NULL)
    if (AcquireImageColormap(image,StringToUnsignedLong(option)) == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
  if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))
    {
      size_t
        colors;

      colors=(size_t) GetQuantumRange(image->depth)+1;
      if (AcquireImageColormap(image,colors) == MagickFalse)
        {
          InheritException(exception,&image->exception);
          return(DestroyImageList(image));
        }
    }
  if (image->debug != MagickFalse)
    {
      if (image->interlace != NoInterlace)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Interlace: progressive"");
      else
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Interlace: nonprogressive"");
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Data precision: %d"",
        (int) jpeg_info.data_precision);
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Geometry: %dx%d"",
        (int) jpeg_info.output_width,(int) jpeg_info.output_height);
    }
  JPEGSetImageQuality(&jpeg_info,image);
  JPEGSetImageSamplingFactor(&jpeg_info,image);
  (void) FormatLocaleString(value,MaxTextExtent,""%.20g"",(double)
    jpeg_info.out_color_space);
  (void) SetImageProperty(image,""jpeg:colorspace"",value);
  if (image_info->ping != MagickFalse)
    {
      jpeg_destroy_decompress(&jpeg_info);
      (void) CloseBlob(image);
      return(GetFirstImageInList(image));
    }
  status=SetImageExtent(image,image->columns,image->rows);
  if (status == MagickFalse)
    {
      jpeg_destroy_decompress(&jpeg_info);
      InheritException(exception,&image->exception);
      return(DestroyImageList(image));
    }
  if ((jpeg_info.output_components != 1) &&
      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))
    {
      jpeg_destroy_decompress(&jpeg_info);
      ThrowReaderException(CorruptImageError,""ImageTypeNotSupported"");
    }
  memory_info=AcquireVirtualMemory((size_t) image->columns,
    jpeg_info.output_components*sizeof(*jpeg_pixels));
  if (memory_info == (MemoryInfo *) NULL)
    {
      jpeg_destroy_decompress(&jpeg_info);
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     }
   jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);
   /*
     Convert JPEG pixels to pixel packets.
   */
  if (setjmp(error_manager.error_recovery) != 0)
    {
      if (memory_info != (MemoryInfo *) NULL)
        memory_info=RelinquishVirtualMemory(memory_info);
      jpeg_destroy_decompress(&jpeg_info);
      (void) CloseBlob(image);
      number_pixels=(MagickSizeType) image->columns*image->rows;
      if (number_pixels != 0)
        return(GetFirstImageInList(image));
      return(DestroyImage(image));
    }
  if (jpeg_info.quantize_colors != 0)
    {
      image->colors=(size_t) jpeg_info.actual_number_of_colors;
      if (jpeg_info.out_color_space == JCS_GRAYSCALE)
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);
          image->colormap[i].green=image->colormap[i].red;
          image->colormap[i].blue=image->colormap[i].red;
          image->colormap[i].opacity=OpaqueOpacity;
        }
      else
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);
          image->colormap[i].green=ScaleCharToQuantum(jpeg_info.colormap[1][i]);
          image->colormap[i].blue=ScaleCharToQuantum(jpeg_info.colormap[2][i]);
          image->colormap[i].opacity=OpaqueOpacity;
        }
    }
  scanline[0]=(JSAMPROW) jpeg_pixels;
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register IndexPacket
      *magick_restrict indexes;

    register ssize_t
      x;

    register PixelPacket
      *magick_restrict q;

    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)
      {
        (void) ThrowMagickException(exception,GetMagickModule(),
          CorruptImageWarning,""SkipToSyncByte"",""`%s'"",image->filename);
        continue;
      }
    p=jpeg_pixels;
    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (PixelPacket *) NULL)
      break;
    indexes=GetAuthenticIndexQueue(image);
    if (jpeg_info.data_precision > 8)
      {
        unsigned short
          scale;

        scale=65535/(unsigned short) GetQuantumRange((size_t)
          jpeg_info.data_precision);
        if (jpeg_info.output_components == 1)
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            size_t
              pixel;

            pixel=(size_t) (scale*GETJSAMPLE(*p));
            index=ConstrainColormapIndex(image,pixel);
            SetPixelIndex(indexes+x,index);
            SetPixelRGBO(q,image->colormap+(ssize_t) index);
            p++;
            q++;
          }
        else
          if (image->colorspace != CMYKColorspace)
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelRed(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelGreen(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelBlue(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelOpacity(q,OpaqueOpacity);
              q++;
            }
          else
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelCyan(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelMagenta(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelYellow(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelBlack(indexes+x,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelOpacity(q,OpaqueOpacity);
              q++;
            }
      }
    else
      if (jpeg_info.output_components == 1)
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          index=ConstrainColormapIndex(image,(size_t) GETJSAMPLE(*p));
          SetPixelIndex(indexes+x,index);
          SetPixelRGBO(q,image->colormap+(ssize_t) index);
          p++;
          q++;
        }
      else
        if (image->colorspace != CMYKColorspace)
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelGreen(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelBlue(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelOpacity(q,OpaqueOpacity);
            q++;
          }
        else
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelCyan(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelMagenta(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelYellow(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelBlack(indexes+x,QuantumRange-ScaleCharToQuantum(
              (unsigned char) GETJSAMPLE(*p++)));
            SetPixelOpacity(q,OpaqueOpacity);
            q++;
          }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
      image->rows);
    if (status == MagickFalse)
      {
        jpeg_abort_decompress(&jpeg_info);
        break;
      }
  }
  if (status != MagickFalse)
    {
      error_manager.finished=MagickTrue;
      if (setjmp(error_manager.error_recovery) == 0)
        (void) jpeg_finish_decompress(&jpeg_info);
    }
  /*
    Free jpeg resources.
  */
  jpeg_destroy_decompress(&jpeg_info);
  memory_info=RelinquishVirtualMemory(memory_info);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",C,"  (void) ResetMagickMemory(jpeg_pixels,0,image->columns* 
    jpeg_info.output_components*sizeof(*jpeg_pixels));
",,,"@@ -1293,6 +1293,8 @@ static Image *ReadJPEGImage(const ImageInfo *image_info,
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     }
   jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);
+  (void) ResetMagickMemory(jpeg_pixels,0,image->columns* 
+    jpeg_info.output_components*sizeof(*jpeg_pixels));
   /*
     Convert JPEG pixels to pixel packets.
   */",ImageMagick,1737ac82b335e53376382c07b9a500d73dd2aa11,5660836f9197107e9c38f14f27a45c2d9f26afe2,1,"static Image *ReadJPEGImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  char
    value[MaxTextExtent];

  const char
    *option;

  ErrorManager
    error_manager;

  Image
    *image;

  IndexPacket
    index;

  JSAMPLE
    *volatile jpeg_pixels;

  JSAMPROW
    scanline[1];

  MagickBooleanType
    debug,
    status;

  MagickSizeType
    number_pixels;

  MemoryInfo
    *memory_info;

  register ssize_t
    i;

  struct jpeg_decompress_struct
    jpeg_info;

  struct jpeg_error_mgr
    jpeg_error;

  register JSAMPLE
    *p;

  size_t
    units;

  ssize_t
    y;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  debug=IsEventLogging();
  (void) debug;
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Verify that file size large enough to contain a JPEG datastream.
  */
  if (GetBlobSize(image) < 107)
    ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
  /*
    Initialize JPEG parameters.
  */
  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));
  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));
  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));
  jpeg_info.err=jpeg_std_error(&jpeg_error);
  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;
  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;
  memory_info=(MemoryInfo *) NULL;
  error_manager.image=image;
  if (setjmp(error_manager.error_recovery) != 0)
    {
      jpeg_destroy_decompress(&jpeg_info);
      if (error_manager.profile != (StringInfo *) NULL)
        error_manager.profile=DestroyStringInfo(error_manager.profile);
      (void) CloseBlob(image);
      number_pixels=(MagickSizeType) image->columns*image->rows;
      if (number_pixels != 0)
        return(GetFirstImageInList(image));
      InheritException(exception,&image->exception);
      return(DestroyImage(image));
    }
  jpeg_info.client_data=(void *) &error_manager;
  jpeg_create_decompress(&jpeg_info);
  JPEGSourceManager(&jpeg_info,image);
  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);
  option=GetImageOption(image_info,""profile:skip"");
  if (IsOptionMember(""ICC"",option) == MagickFalse)
    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);
  if (IsOptionMember(""IPTC"",option) == MagickFalse)
    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);
  for (i=1; i < 16; i++)
    if ((i != 2) && (i != 13) && (i != 14))
      if (IsOptionMember(""APP"",option) == MagickFalse)
        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);
  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);
  if ((image_info->colorspace == YCbCrColorspace) ||
      (image_info->colorspace == Rec601YCbCrColorspace) ||
      (image_info->colorspace == Rec709YCbCrColorspace))
    jpeg_info.out_color_space=JCS_YCbCr;
  /*
    Set image resolution.
  */
  units=0;
  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&
      (jpeg_info.Y_density != 1))
    {
      image->x_resolution=(double) jpeg_info.X_density;
      image->y_resolution=(double) jpeg_info.Y_density;
      units=(size_t) jpeg_info.density_unit;
    }
  if (units == 1)
    image->units=PixelsPerInchResolution;
  if (units == 2)
    image->units=PixelsPerCentimeterResolution;
  number_pixels=(MagickSizeType) image->columns*image->rows;
  option=GetImageOption(image_info,""jpeg:size"");
  if ((option != (const char *) NULL) &&
      (jpeg_info.out_color_space != JCS_YCbCr))
    {
      double
        scale_factor;

      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      /*
        Scale the image.
      */
      flags=ParseGeometry(option,&geometry_info);
      if ((flags & SigmaValue) == 0)
        geometry_info.sigma=geometry_info.rho;
      jpeg_calc_output_dimensions(&jpeg_info);
      image->magick_columns=jpeg_info.output_width;
      image->magick_rows=jpeg_info.output_height;
      scale_factor=1.0;
      if (geometry_info.rho != 0.0)
        scale_factor=jpeg_info.output_width/geometry_info.rho;
      if ((geometry_info.sigma != 0.0) &&
          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))
        scale_factor=jpeg_info.output_height/geometry_info.sigma;
      jpeg_info.scale_num=1U;
      jpeg_info.scale_denom=(unsigned int) scale_factor;
      jpeg_calc_output_dimensions(&jpeg_info);
      if (image->debug != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Scale factor: %.20g"",(double) scale_factor);
    }
#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)
#if defined(D_LOSSLESS_SUPPORTED)
  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?
    JPEGInterlace : NoInterlace;
  image->compression=jpeg_info.process == JPROC_LOSSLESS ?
    LosslessJPEGCompression : JPEGCompression;
  if (jpeg_info.data_precision > 8)
    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
      ""12-bit JPEG not supported. Reducing pixel data to 8 bits"",""`%s'"",
      image->filename);
  if (jpeg_info.data_precision == 16)
    jpeg_info.data_precision=12;
#else
  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :
    NoInterlace;
  image->compression=JPEGCompression;
#endif
#else
  image->compression=JPEGCompression;
  image->interlace=JPEGInterlace;
#endif
  option=GetImageOption(image_info,""jpeg:colors"");
  if (option != (const char *) NULL)
    {
      /*
        Let the JPEG library quantize for us.
      */
      jpeg_info.quantize_colors=TRUE;
      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);
    }
  option=GetImageOption(image_info,""jpeg:block-smoothing"");
  if (option != (const char *) NULL)
    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :
      FALSE;
  jpeg_info.dct_method=JDCT_FLOAT;
  option=GetImageOption(image_info,""jpeg:dct-method"");
  if (option != (const char *) NULL)
    switch (*option)
    {
      case 'D':
      case 'd':
      {
        if (LocaleCompare(option,""default"") == 0)
          jpeg_info.dct_method=JDCT_DEFAULT;
        break;
      }
      case 'F':
      case 'f':
      {
        if (LocaleCompare(option,""fastest"") == 0)
          jpeg_info.dct_method=JDCT_FASTEST;
        if (LocaleCompare(option,""float"") == 0)
          jpeg_info.dct_method=JDCT_FLOAT;
        break;
      }
      case 'I':
      case 'i':
      {
        if (LocaleCompare(option,""ifast"") == 0)
          jpeg_info.dct_method=JDCT_IFAST;
        if (LocaleCompare(option,""islow"") == 0)
          jpeg_info.dct_method=JDCT_ISLOW;
        break;
      }
    }
  option=GetImageOption(image_info,""jpeg:fancy-upsampling"");
  if (option != (const char *) NULL)
    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :
      FALSE;
  (void) jpeg_start_decompress(&jpeg_info);
  image->columns=jpeg_info.output_width;
  image->rows=jpeg_info.output_height;
  image->depth=(size_t) jpeg_info.data_precision;
  switch (jpeg_info.out_color_space)
  {
    case JCS_RGB:
    default:
    {
      (void) SetImageColorspace(image,sRGBColorspace);
      break;
    }
    case JCS_GRAYSCALE:
    {
      (void) SetImageColorspace(image,GRAYColorspace);
      break;
    }
    case JCS_YCbCr:
    {
      (void) SetImageColorspace(image,YCbCrColorspace);
      break;
    }
    case JCS_CMYK:
    {
      (void) SetImageColorspace(image,CMYKColorspace);
      break;
    }
  }
  if (IsITUFaxImage(image) != MagickFalse)
    {
      (void) SetImageColorspace(image,LabColorspace);
      jpeg_info.out_color_space=JCS_YCbCr;
    }
  option=GetImageOption(image_info,""jpeg:colors"");
  if (option != (const char *) NULL)
    if (AcquireImageColormap(image,StringToUnsignedLong(option)) == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
  if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))
    {
      size_t
        colors;

      colors=(size_t) GetQuantumRange(image->depth)+1;
      if (AcquireImageColormap(image,colors) == MagickFalse)
        {
          InheritException(exception,&image->exception);
          return(DestroyImageList(image));
        }
    }
  if (image->debug != MagickFalse)
    {
      if (image->interlace != NoInterlace)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Interlace: progressive"");
      else
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Interlace: nonprogressive"");
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Data precision: %d"",
        (int) jpeg_info.data_precision);
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Geometry: %dx%d"",
        (int) jpeg_info.output_width,(int) jpeg_info.output_height);
    }
  JPEGSetImageQuality(&jpeg_info,image);
  JPEGSetImageSamplingFactor(&jpeg_info,image);
  (void) FormatLocaleString(value,MaxTextExtent,""%.20g"",(double)
    jpeg_info.out_color_space);
  (void) SetImageProperty(image,""jpeg:colorspace"",value);
  if (image_info->ping != MagickFalse)
    {
      jpeg_destroy_decompress(&jpeg_info);
      (void) CloseBlob(image);
      return(GetFirstImageInList(image));
    }
  status=SetImageExtent(image,image->columns,image->rows);
  if (status == MagickFalse)
    {
      jpeg_destroy_decompress(&jpeg_info);
      InheritException(exception,&image->exception);
      return(DestroyImageList(image));
    }
  if ((jpeg_info.output_components != 1) &&
      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))
    {
      jpeg_destroy_decompress(&jpeg_info);
      ThrowReaderException(CorruptImageError,""ImageTypeNotSupported"");
    }
  memory_info=AcquireVirtualMemory((size_t) image->columns,
    jpeg_info.output_components*sizeof(*jpeg_pixels));
  if (memory_info == (MemoryInfo *) NULL)
    {
      jpeg_destroy_decompress(&jpeg_info);
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     }
   jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);
//fix_flaw_line_below:
//  (void) ResetMagickMemory(jpeg_pixels,0,image->columns* 
//fix_flaw_line_below:
//    jpeg_info.output_components*sizeof(*jpeg_pixels));
   /*
     Convert JPEG pixels to pixel packets.
   */
  if (setjmp(error_manager.error_recovery) != 0)
    {
      if (memory_info != (MemoryInfo *) NULL)
        memory_info=RelinquishVirtualMemory(memory_info);
      jpeg_destroy_decompress(&jpeg_info);
      (void) CloseBlob(image);
      number_pixels=(MagickSizeType) image->columns*image->rows;
      if (number_pixels != 0)
        return(GetFirstImageInList(image));
      return(DestroyImage(image));
    }
  if (jpeg_info.quantize_colors != 0)
    {
      image->colors=(size_t) jpeg_info.actual_number_of_colors;
      if (jpeg_info.out_color_space == JCS_GRAYSCALE)
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);
          image->colormap[i].green=image->colormap[i].red;
          image->colormap[i].blue=image->colormap[i].red;
          image->colormap[i].opacity=OpaqueOpacity;
        }
      else
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);
          image->colormap[i].green=ScaleCharToQuantum(jpeg_info.colormap[1][i]);
          image->colormap[i].blue=ScaleCharToQuantum(jpeg_info.colormap[2][i]);
          image->colormap[i].opacity=OpaqueOpacity;
        }
    }
  scanline[0]=(JSAMPROW) jpeg_pixels;
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register IndexPacket
      *magick_restrict indexes;

    register ssize_t
      x;

    register PixelPacket
      *magick_restrict q;

    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)
      {
        (void) ThrowMagickException(exception,GetMagickModule(),
          CorruptImageWarning,""SkipToSyncByte"",""`%s'"",image->filename);
        continue;
      }
    p=jpeg_pixels;
    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (PixelPacket *) NULL)
      break;
    indexes=GetAuthenticIndexQueue(image);
    if (jpeg_info.data_precision > 8)
      {
        unsigned short
          scale;

        scale=65535/(unsigned short) GetQuantumRange((size_t)
          jpeg_info.data_precision);
        if (jpeg_info.output_components == 1)
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            size_t
              pixel;

            pixel=(size_t) (scale*GETJSAMPLE(*p));
            index=ConstrainColormapIndex(image,pixel);
            SetPixelIndex(indexes+x,index);
            SetPixelRGBO(q,image->colormap+(ssize_t) index);
            p++;
            q++;
          }
        else
          if (image->colorspace != CMYKColorspace)
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelRed(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelGreen(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelBlue(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelOpacity(q,OpaqueOpacity);
              q++;
            }
          else
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelCyan(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelMagenta(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelYellow(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelBlack(indexes+x,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelOpacity(q,OpaqueOpacity);
              q++;
            }
      }
    else
      if (jpeg_info.output_components == 1)
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          index=ConstrainColormapIndex(image,(size_t) GETJSAMPLE(*p));
          SetPixelIndex(indexes+x,index);
          SetPixelRGBO(q,image->colormap+(ssize_t) index);
          p++;
          q++;
        }
      else
        if (image->colorspace != CMYKColorspace)
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelGreen(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelBlue(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelOpacity(q,OpaqueOpacity);
            q++;
          }
        else
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelCyan(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelMagenta(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelYellow(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelBlack(indexes+x,QuantumRange-ScaleCharToQuantum(
              (unsigned char) GETJSAMPLE(*p++)));
            SetPixelOpacity(q,OpaqueOpacity);
            q++;
          }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
      image->rows);
    if (status == MagickFalse)
      {
        jpeg_abort_decompress(&jpeg_info);
        break;
      }
  }
  if (status != MagickFalse)
    {
      error_manager.finished=MagickTrue;
      if (setjmp(error_manager.error_recovery) == 0)
        (void) jpeg_finish_decompress(&jpeg_info);
    }
  /*
    Free jpeg resources.
  */
  jpeg_destroy_decompress(&jpeg_info);
  memory_info=RelinquishVirtualMemory(memory_info);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",181208,"static Image *ReadJPEGImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  char
    value[MaxTextExtent];

  const char
    *option;

  ErrorManager
    error_manager;

  Image
    *image;

  IndexPacket
    index;

  JSAMPLE
    *volatile jpeg_pixels;

  JSAMPROW
    scanline[1];

  MagickBooleanType
    debug,
    status;

  MagickSizeType
    number_pixels;

  MemoryInfo
    *memory_info;

  register ssize_t
    i;

  struct jpeg_decompress_struct
    jpeg_info;

  struct jpeg_error_mgr
    jpeg_error;

  register JSAMPLE
    *p;

  size_t
    units;

  ssize_t
    y;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  debug=IsEventLogging();
  (void) debug;
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Verify that file size large enough to contain a JPEG datastream.
  */
  if (GetBlobSize(image) < 107)
    ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
  /*
    Initialize JPEG parameters.
  */
  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));
  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));
  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));
  jpeg_info.err=jpeg_std_error(&jpeg_error);
  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;
  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;
  memory_info=(MemoryInfo *) NULL;
  error_manager.image=image;
  if (setjmp(error_manager.error_recovery) != 0)
    {
      jpeg_destroy_decompress(&jpeg_info);
      if (error_manager.profile != (StringInfo *) NULL)
        error_manager.profile=DestroyStringInfo(error_manager.profile);
      (void) CloseBlob(image);
      number_pixels=(MagickSizeType) image->columns*image->rows;
      if (number_pixels != 0)
        return(GetFirstImageInList(image));
      InheritException(exception,&image->exception);
      return(DestroyImage(image));
    }
  jpeg_info.client_data=(void *) &error_manager;
  jpeg_create_decompress(&jpeg_info);
  JPEGSourceManager(&jpeg_info,image);
  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);
  option=GetImageOption(image_info,""profile:skip"");
  if (IsOptionMember(""ICC"",option) == MagickFalse)
    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);
  if (IsOptionMember(""IPTC"",option) == MagickFalse)
    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);
  for (i=1; i < 16; i++)
    if ((i != 2) && (i != 13) && (i != 14))
      if (IsOptionMember(""APP"",option) == MagickFalse)
        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);
  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);
  if ((image_info->colorspace == YCbCrColorspace) ||
      (image_info->colorspace == Rec601YCbCrColorspace) ||
      (image_info->colorspace == Rec709YCbCrColorspace))
    jpeg_info.out_color_space=JCS_YCbCr;
  /*
    Set image resolution.
  */
  units=0;
  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&
      (jpeg_info.Y_density != 1))
    {
      image->x_resolution=(double) jpeg_info.X_density;
      image->y_resolution=(double) jpeg_info.Y_density;
      units=(size_t) jpeg_info.density_unit;
    }
  if (units == 1)
    image->units=PixelsPerInchResolution;
  if (units == 2)
    image->units=PixelsPerCentimeterResolution;
  number_pixels=(MagickSizeType) image->columns*image->rows;
  option=GetImageOption(image_info,""jpeg:size"");
  if ((option != (const char *) NULL) &&
      (jpeg_info.out_color_space != JCS_YCbCr))
    {
      double
        scale_factor;

      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      /*
        Scale the image.
      */
      flags=ParseGeometry(option,&geometry_info);
      if ((flags & SigmaValue) == 0)
        geometry_info.sigma=geometry_info.rho;
      jpeg_calc_output_dimensions(&jpeg_info);
      image->magick_columns=jpeg_info.output_width;
      image->magick_rows=jpeg_info.output_height;
      scale_factor=1.0;
      if (geometry_info.rho != 0.0)
        scale_factor=jpeg_info.output_width/geometry_info.rho;
      if ((geometry_info.sigma != 0.0) &&
          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))
        scale_factor=jpeg_info.output_height/geometry_info.sigma;
      jpeg_info.scale_num=1U;
      jpeg_info.scale_denom=(unsigned int) scale_factor;
      jpeg_calc_output_dimensions(&jpeg_info);
      if (image->debug != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Scale factor: %.20g"",(double) scale_factor);
    }
#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)
#if defined(D_LOSSLESS_SUPPORTED)
  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?
    JPEGInterlace : NoInterlace;
  image->compression=jpeg_info.process == JPROC_LOSSLESS ?
    LosslessJPEGCompression : JPEGCompression;
  if (jpeg_info.data_precision > 8)
    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
      ""12-bit JPEG not supported. Reducing pixel data to 8 bits"",""`%s'"",
      image->filename);
  if (jpeg_info.data_precision == 16)
    jpeg_info.data_precision=12;
#else
  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :
    NoInterlace;
  image->compression=JPEGCompression;
#endif
#else
  image->compression=JPEGCompression;
  image->interlace=JPEGInterlace;
#endif
  option=GetImageOption(image_info,""jpeg:colors"");
  if (option != (const char *) NULL)
    {
      /*
        Let the JPEG library quantize for us.
      */
      jpeg_info.quantize_colors=TRUE;
      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);
    }
  option=GetImageOption(image_info,""jpeg:block-smoothing"");
  if (option != (const char *) NULL)
    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :
      FALSE;
  jpeg_info.dct_method=JDCT_FLOAT;
  option=GetImageOption(image_info,""jpeg:dct-method"");
  if (option != (const char *) NULL)
    switch (*option)
    {
      case 'D':
      case 'd':
      {
        if (LocaleCompare(option,""default"") == 0)
          jpeg_info.dct_method=JDCT_DEFAULT;
        break;
      }
      case 'F':
      case 'f':
      {
        if (LocaleCompare(option,""fastest"") == 0)
          jpeg_info.dct_method=JDCT_FASTEST;
        if (LocaleCompare(option,""float"") == 0)
          jpeg_info.dct_method=JDCT_FLOAT;
        break;
      }
      case 'I':
      case 'i':
      {
        if (LocaleCompare(option,""ifast"") == 0)
          jpeg_info.dct_method=JDCT_IFAST;
        if (LocaleCompare(option,""islow"") == 0)
          jpeg_info.dct_method=JDCT_ISLOW;
        break;
      }
    }
  option=GetImageOption(image_info,""jpeg:fancy-upsampling"");
  if (option != (const char *) NULL)
    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :
      FALSE;
  (void) jpeg_start_decompress(&jpeg_info);
  image->columns=jpeg_info.output_width;
  image->rows=jpeg_info.output_height;
  image->depth=(size_t) jpeg_info.data_precision;
  switch (jpeg_info.out_color_space)
  {
    case JCS_RGB:
    default:
    {
      (void) SetImageColorspace(image,sRGBColorspace);
      break;
    }
    case JCS_GRAYSCALE:
    {
      (void) SetImageColorspace(image,GRAYColorspace);
      break;
    }
    case JCS_YCbCr:
    {
      (void) SetImageColorspace(image,YCbCrColorspace);
      break;
    }
    case JCS_CMYK:
    {
      (void) SetImageColorspace(image,CMYKColorspace);
      break;
    }
  }
  if (IsITUFaxImage(image) != MagickFalse)
    {
      (void) SetImageColorspace(image,LabColorspace);
      jpeg_info.out_color_space=JCS_YCbCr;
    }
  option=GetImageOption(image_info,""jpeg:colors"");
  if (option != (const char *) NULL)
    if (AcquireImageColormap(image,StringToUnsignedLong(option)) == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
  if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))
    {
      size_t
        colors;

      colors=(size_t) GetQuantumRange(image->depth)+1;
      if (AcquireImageColormap(image,colors) == MagickFalse)
        {
          InheritException(exception,&image->exception);
          return(DestroyImageList(image));
        }
    }
  if (image->debug != MagickFalse)
    {
      if (image->interlace != NoInterlace)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Interlace: progressive"");
      else
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Interlace: nonprogressive"");
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Data precision: %d"",
        (int) jpeg_info.data_precision);
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Geometry: %dx%d"",
        (int) jpeg_info.output_width,(int) jpeg_info.output_height);
    }
  JPEGSetImageQuality(&jpeg_info,image);
  JPEGSetImageSamplingFactor(&jpeg_info,image);
  (void) FormatLocaleString(value,MaxTextExtent,""%.20g"",(double)
    jpeg_info.out_color_space);
  (void) SetImageProperty(image,""jpeg:colorspace"",value);
  if (image_info->ping != MagickFalse)
    {
      jpeg_destroy_decompress(&jpeg_info);
      (void) CloseBlob(image);
      return(GetFirstImageInList(image));
    }
  status=SetImageExtent(image,image->columns,image->rows);
  if (status == MagickFalse)
    {
      jpeg_destroy_decompress(&jpeg_info);
      InheritException(exception,&image->exception);
      return(DestroyImageList(image));
    }
  if ((jpeg_info.output_components != 1) &&
      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))
    {
      jpeg_destroy_decompress(&jpeg_info);
      ThrowReaderException(CorruptImageError,""ImageTypeNotSupported"");
    }
  memory_info=AcquireVirtualMemory((size_t) image->columns,
    jpeg_info.output_components*sizeof(*jpeg_pixels));
  if (memory_info == (MemoryInfo *) NULL)
    {
      jpeg_destroy_decompress(&jpeg_info);
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     }
   jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);
   /*
     Convert JPEG pixels to pixel packets.
   */
  if (setjmp(error_manager.error_recovery) != 0)
    {
      if (memory_info != (MemoryInfo *) NULL)
        memory_info=RelinquishVirtualMemory(memory_info);
      jpeg_destroy_decompress(&jpeg_info);
      (void) CloseBlob(image);
      number_pixels=(MagickSizeType) image->columns*image->rows;
      if (number_pixels != 0)
        return(GetFirstImageInList(image));
      return(DestroyImage(image));
    }
  if (jpeg_info.quantize_colors != 0)
    {
      image->colors=(size_t) jpeg_info.actual_number_of_colors;
      if (jpeg_info.out_color_space == JCS_GRAYSCALE)
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);
          image->colormap[i].green=image->colormap[i].red;
          image->colormap[i].blue=image->colormap[i].red;
          image->colormap[i].opacity=OpaqueOpacity;
        }
      else
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);
          image->colormap[i].green=ScaleCharToQuantum(jpeg_info.colormap[1][i]);
          image->colormap[i].blue=ScaleCharToQuantum(jpeg_info.colormap[2][i]);
          image->colormap[i].opacity=OpaqueOpacity;
        }
    }
  scanline[0]=(JSAMPROW) jpeg_pixels;
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register IndexPacket
      *magick_restrict indexes;

    register ssize_t
      x;

    register PixelPacket
      *magick_restrict q;

    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)
      {
        (void) ThrowMagickException(exception,GetMagickModule(),
          CorruptImageWarning,""SkipToSyncByte"",""`%s'"",image->filename);
        continue;
      }
    p=jpeg_pixels;
    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (PixelPacket *) NULL)
      break;
    indexes=GetAuthenticIndexQueue(image);
    if (jpeg_info.data_precision > 8)
      {
        unsigned short
          scale;

        scale=65535/(unsigned short) GetQuantumRange((size_t)
          jpeg_info.data_precision);
        if (jpeg_info.output_components == 1)
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            size_t
              pixel;

            pixel=(size_t) (scale*GETJSAMPLE(*p));
            index=ConstrainColormapIndex(image,pixel);
            SetPixelIndex(indexes+x,index);
            SetPixelRGBO(q,image->colormap+(ssize_t) index);
            p++;
            q++;
          }
        else
          if (image->colorspace != CMYKColorspace)
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelRed(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelGreen(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelBlue(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelOpacity(q,OpaqueOpacity);
              q++;
            }
          else
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelCyan(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelMagenta(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelYellow(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelBlack(indexes+x,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelOpacity(q,OpaqueOpacity);
              q++;
            }
      }
    else
      if (jpeg_info.output_components == 1)
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          index=ConstrainColormapIndex(image,(size_t) GETJSAMPLE(*p));
          SetPixelIndex(indexes+x,index);
          SetPixelRGBO(q,image->colormap+(ssize_t) index);
          p++;
          q++;
        }
      else
        if (image->colorspace != CMYKColorspace)
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelGreen(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelBlue(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelOpacity(q,OpaqueOpacity);
            q++;
          }
        else
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelCyan(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelMagenta(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelYellow(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelBlack(indexes+x,QuantumRange-ScaleCharToQuantum(
              (unsigned char) GETJSAMPLE(*p++)));
            SetPixelOpacity(q,OpaqueOpacity);
            q++;
          }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
      image->rows);
    if (status == MagickFalse)
      {
        jpeg_abort_decompress(&jpeg_info);
        break;
      }
  }
  if (status != MagickFalse)
    {
      error_manager.finished=MagickTrue;
      if (setjmp(error_manager.error_recovery) == 0)
        (void) jpeg_finish_decompress(&jpeg_info);
    }
  /*
    Free jpeg resources.
  */
  jpeg_destroy_decompress(&jpeg_info);
  memory_info=RelinquishVirtualMemory(memory_info);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","static Image *ReadJPEGImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  char
    value[MaxTextExtent];

  const char
    *option;

  ErrorManager
    error_manager;

  Image
    *image;

  IndexPacket
    index;

  JSAMPLE
    *volatile jpeg_pixels;

  JSAMPROW
    scanline[1];

  MagickBooleanType
    debug,
    status;

  MagickSizeType
    number_pixels;

  MemoryInfo
    *memory_info;

  register ssize_t
    i;

  struct jpeg_decompress_struct
    jpeg_info;

  struct jpeg_error_mgr
    jpeg_error;

  register JSAMPLE
    *p;

  size_t
    units;

  ssize_t
    y;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  debug=IsEventLogging();
  (void) debug;
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Verify that file size large enough to contain a JPEG datastream.
  */
  if (GetBlobSize(image) < 107)
    ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
  /*
    Initialize JPEG parameters.
  */
  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));
  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));
  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));
  jpeg_info.err=jpeg_std_error(&jpeg_error);
  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;
  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;
  memory_info=(MemoryInfo *) NULL;
  error_manager.image=image;
  if (setjmp(error_manager.error_recovery) != 0)
    {
      jpeg_destroy_decompress(&jpeg_info);
      if (error_manager.profile != (StringInfo *) NULL)
        error_manager.profile=DestroyStringInfo(error_manager.profile);
      (void) CloseBlob(image);
      number_pixels=(MagickSizeType) image->columns*image->rows;
      if (number_pixels != 0)
        return(GetFirstImageInList(image));
      InheritException(exception,&image->exception);
      return(DestroyImage(image));
    }
  jpeg_info.client_data=(void *) &error_manager;
  jpeg_create_decompress(&jpeg_info);
  JPEGSourceManager(&jpeg_info,image);
  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);
  option=GetImageOption(image_info,""profile:skip"");
  if (IsOptionMember(""ICC"",option) == MagickFalse)
    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);
  if (IsOptionMember(""IPTC"",option) == MagickFalse)
    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);
  for (i=1; i < 16; i++)
    if ((i != 2) && (i != 13) && (i != 14))
      if (IsOptionMember(""APP"",option) == MagickFalse)
        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);
  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);
  if ((image_info->colorspace == YCbCrColorspace) ||
      (image_info->colorspace == Rec601YCbCrColorspace) ||
      (image_info->colorspace == Rec709YCbCrColorspace))
    jpeg_info.out_color_space=JCS_YCbCr;
  /*
    Set image resolution.
  */
  units=0;
  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&
      (jpeg_info.Y_density != 1))
    {
      image->x_resolution=(double) jpeg_info.X_density;
      image->y_resolution=(double) jpeg_info.Y_density;
      units=(size_t) jpeg_info.density_unit;
    }
  if (units == 1)
    image->units=PixelsPerInchResolution;
  if (units == 2)
    image->units=PixelsPerCentimeterResolution;
  number_pixels=(MagickSizeType) image->columns*image->rows;
  option=GetImageOption(image_info,""jpeg:size"");
  if ((option != (const char *) NULL) &&
      (jpeg_info.out_color_space != JCS_YCbCr))
    {
      double
        scale_factor;

      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      /*
        Scale the image.
      */
      flags=ParseGeometry(option,&geometry_info);
      if ((flags & SigmaValue) == 0)
        geometry_info.sigma=geometry_info.rho;
      jpeg_calc_output_dimensions(&jpeg_info);
      image->magick_columns=jpeg_info.output_width;
      image->magick_rows=jpeg_info.output_height;
      scale_factor=1.0;
      if (geometry_info.rho != 0.0)
        scale_factor=jpeg_info.output_width/geometry_info.rho;
      if ((geometry_info.sigma != 0.0) &&
          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))
        scale_factor=jpeg_info.output_height/geometry_info.sigma;
      jpeg_info.scale_num=1U;
      jpeg_info.scale_denom=(unsigned int) scale_factor;
      jpeg_calc_output_dimensions(&jpeg_info);
      if (image->debug != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Scale factor: %.20g"",(double) scale_factor);
    }
#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)
#if defined(D_LOSSLESS_SUPPORTED)
  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?
    JPEGInterlace : NoInterlace;
  image->compression=jpeg_info.process == JPROC_LOSSLESS ?
    LosslessJPEGCompression : JPEGCompression;
  if (jpeg_info.data_precision > 8)
    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
      ""12-bit JPEG not supported. Reducing pixel data to 8 bits"",""`%s'"",
      image->filename);
  if (jpeg_info.data_precision == 16)
    jpeg_info.data_precision=12;
#else
  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :
    NoInterlace;
  image->compression=JPEGCompression;
#endif
#else
  image->compression=JPEGCompression;
  image->interlace=JPEGInterlace;
#endif
  option=GetImageOption(image_info,""jpeg:colors"");
  if (option != (const char *) NULL)
    {
      /*
        Let the JPEG library quantize for us.
      */
      jpeg_info.quantize_colors=TRUE;
      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);
    }
  option=GetImageOption(image_info,""jpeg:block-smoothing"");
  if (option != (const char *) NULL)
    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :
      FALSE;
  jpeg_info.dct_method=JDCT_FLOAT;
  option=GetImageOption(image_info,""jpeg:dct-method"");
  if (option != (const char *) NULL)
    switch (*option)
    {
      case 'D':
      case 'd':
      {
        if (LocaleCompare(option,""default"") == 0)
          jpeg_info.dct_method=JDCT_DEFAULT;
        break;
      }
      case 'F':
      case 'f':
      {
        if (LocaleCompare(option,""fastest"") == 0)
          jpeg_info.dct_method=JDCT_FASTEST;
        if (LocaleCompare(option,""float"") == 0)
          jpeg_info.dct_method=JDCT_FLOAT;
        break;
      }
      case 'I':
      case 'i':
      {
        if (LocaleCompare(option,""ifast"") == 0)
          jpeg_info.dct_method=JDCT_IFAST;
        if (LocaleCompare(option,""islow"") == 0)
          jpeg_info.dct_method=JDCT_ISLOW;
        break;
      }
    }
  option=GetImageOption(image_info,""jpeg:fancy-upsampling"");
  if (option != (const char *) NULL)
    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :
      FALSE;
  (void) jpeg_start_decompress(&jpeg_info);
  image->columns=jpeg_info.output_width;
  image->rows=jpeg_info.output_height;
  image->depth=(size_t) jpeg_info.data_precision;
  switch (jpeg_info.out_color_space)
  {
    case JCS_RGB:
    default:
    {
      (void) SetImageColorspace(image,sRGBColorspace);
      break;
    }
    case JCS_GRAYSCALE:
    {
      (void) SetImageColorspace(image,GRAYColorspace);
      break;
    }
    case JCS_YCbCr:
    {
      (void) SetImageColorspace(image,YCbCrColorspace);
      break;
    }
    case JCS_CMYK:
    {
      (void) SetImageColorspace(image,CMYKColorspace);
      break;
    }
  }
  if (IsITUFaxImage(image) != MagickFalse)
    {
      (void) SetImageColorspace(image,LabColorspace);
      jpeg_info.out_color_space=JCS_YCbCr;
    }
  option=GetImageOption(image_info,""jpeg:colors"");
  if (option != (const char *) NULL)
    if (AcquireImageColormap(image,StringToUnsignedLong(option)) == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
  if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))
    {
      size_t
        colors;

      colors=(size_t) GetQuantumRange(image->depth)+1;
      if (AcquireImageColormap(image,colors) == MagickFalse)
        {
          InheritException(exception,&image->exception);
          return(DestroyImageList(image));
        }
    }
  if (image->debug != MagickFalse)
    {
      if (image->interlace != NoInterlace)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Interlace: progressive"");
      else
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Interlace: nonprogressive"");
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Data precision: %d"",
        (int) jpeg_info.data_precision);
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Geometry: %dx%d"",
        (int) jpeg_info.output_width,(int) jpeg_info.output_height);
    }
  JPEGSetImageQuality(&jpeg_info,image);
  JPEGSetImageSamplingFactor(&jpeg_info,image);
  (void) FormatLocaleString(value,MaxTextExtent,""%.20g"",(double)
    jpeg_info.out_color_space);
  (void) SetImageProperty(image,""jpeg:colorspace"",value);
  if (image_info->ping != MagickFalse)
    {
      jpeg_destroy_decompress(&jpeg_info);
      (void) CloseBlob(image);
      return(GetFirstImageInList(image));
    }
  status=SetImageExtent(image,image->columns,image->rows);
  if (status == MagickFalse)
    {
      jpeg_destroy_decompress(&jpeg_info);
      InheritException(exception,&image->exception);
      return(DestroyImageList(image));
    }
  if ((jpeg_info.output_components != 1) &&
      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))
    {
      jpeg_destroy_decompress(&jpeg_info);
      ThrowReaderException(CorruptImageError,""ImageTypeNotSupported"");
    }
  memory_info=AcquireVirtualMemory((size_t) image->columns,
    jpeg_info.output_components*sizeof(*jpeg_pixels));
  if (memory_info == (MemoryInfo *) NULL)
    {
      jpeg_destroy_decompress(&jpeg_info);
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     }
   jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);
  (void) ResetMagickMemory(jpeg_pixels,0,image->columns* 
    jpeg_info.output_components*sizeof(*jpeg_pixels));
   /*
     Convert JPEG pixels to pixel packets.
   */
  if (setjmp(error_manager.error_recovery) != 0)
    {
      if (memory_info != (MemoryInfo *) NULL)
        memory_info=RelinquishVirtualMemory(memory_info);
      jpeg_destroy_decompress(&jpeg_info);
      (void) CloseBlob(image);
      number_pixels=(MagickSizeType) image->columns*image->rows;
      if (number_pixels != 0)
        return(GetFirstImageInList(image));
      return(DestroyImage(image));
    }
  if (jpeg_info.quantize_colors != 0)
    {
      image->colors=(size_t) jpeg_info.actual_number_of_colors;
      if (jpeg_info.out_color_space == JCS_GRAYSCALE)
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);
          image->colormap[i].green=image->colormap[i].red;
          image->colormap[i].blue=image->colormap[i].red;
          image->colormap[i].opacity=OpaqueOpacity;
        }
      else
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);
          image->colormap[i].green=ScaleCharToQuantum(jpeg_info.colormap[1][i]);
          image->colormap[i].blue=ScaleCharToQuantum(jpeg_info.colormap[2][i]);
          image->colormap[i].opacity=OpaqueOpacity;
        }
    }
  scanline[0]=(JSAMPROW) jpeg_pixels;
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register IndexPacket
      *magick_restrict indexes;

    register ssize_t
      x;

    register PixelPacket
      *magick_restrict q;

    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)
      {
        (void) ThrowMagickException(exception,GetMagickModule(),
          CorruptImageWarning,""SkipToSyncByte"",""`%s'"",image->filename);
        continue;
      }
    p=jpeg_pixels;
    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (PixelPacket *) NULL)
      break;
    indexes=GetAuthenticIndexQueue(image);
    if (jpeg_info.data_precision > 8)
      {
        unsigned short
          scale;

        scale=65535/(unsigned short) GetQuantumRange((size_t)
          jpeg_info.data_precision);
        if (jpeg_info.output_components == 1)
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            size_t
              pixel;

            pixel=(size_t) (scale*GETJSAMPLE(*p));
            index=ConstrainColormapIndex(image,pixel);
            SetPixelIndex(indexes+x,index);
            SetPixelRGBO(q,image->colormap+(ssize_t) index);
            p++;
            q++;
          }
        else
          if (image->colorspace != CMYKColorspace)
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelRed(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelGreen(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelBlue(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelOpacity(q,OpaqueOpacity);
              q++;
            }
          else
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelCyan(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelMagenta(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelYellow(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelBlack(indexes+x,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelOpacity(q,OpaqueOpacity);
              q++;
            }
      }
    else
      if (jpeg_info.output_components == 1)
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          index=ConstrainColormapIndex(image,(size_t) GETJSAMPLE(*p));
          SetPixelIndex(indexes+x,index);
          SetPixelRGBO(q,image->colormap+(ssize_t) index);
          p++;
          q++;
        }
      else
        if (image->colorspace != CMYKColorspace)
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelGreen(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelBlue(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelOpacity(q,OpaqueOpacity);
            q++;
          }
        else
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelCyan(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelMagenta(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelYellow(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelBlack(indexes+x,QuantumRange-ScaleCharToQuantum(
              (unsigned char) GETJSAMPLE(*p++)));
            SetPixelOpacity(q,OpaqueOpacity);
            q++;
          }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
      image->rows);
    if (status == MagickFalse)
      {
        jpeg_abort_decompress(&jpeg_info);
        break;
      }
  }
  if (status != MagickFalse)
    {
      error_manager.finished=MagickTrue;
      if (setjmp(error_manager.error_recovery) == 0)
        (void) jpeg_finish_decompress(&jpeg_info);
    }
  /*
    Free jpeg resources.
  */
  jpeg_destroy_decompress(&jpeg_info);
  memory_info=RelinquishVirtualMemory(memory_info);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","The `ReadJPEGImage` function is designed to read and decode JPEG images into a format suitable for further processing. It begins by validating input parameters and opening the image file, ensuring it contains sufficient data. The function initializes JPEG decompression structures and sets up error handling. It processes JPEG markers to extract metadata, such as color space and resolution, and configures the image's properties accordingly. The function then reads pixel data line by line, converting it into the appropriate pixel format while managing color quantization and scaling. Finally, it cleans up resources and returns the decoded image.","The code defines a function that reads and decodes JPEG images, converting them into a format suitable for further manipulation. It begins by validating input parameters and opening the image file, ensuring it contains enough data. The function initializes necessary structures for decompression and sets up error handling. It processes metadata to extract information such as color space and resolution, configuring the image properties accordingly. The pixel data is read line by line, converting it into the appropriate format while managing color quantization. Finally, the function cleans up resources and returns the decoded image.","The vulnerability in the original code stemmed from the lack of initialization for the pixel buffer, which could lead to undefined behavior or memory corruption when processing JPEG images. Specifically, the `jpeg_pixels` buffer was not reset before being used to store pixel data, potentially containing garbage values. The fix involved adding a line to reset the memory of the `jpeg_pixels` buffer to zero, ensuring that it is properly initialized before any pixel data is read into it. This change mitigates the risk of processing invalid or uninitialized data, enhancing the stability and security of the image reading function.","The vulnerability in the original code arose from the uninitialized pixel buffer, which could lead to unpredictable behavior or memory corruption when processing image data. Without proper initialization, the buffer might contain residual data, resulting in incorrect pixel values being processed. The fix involved explicitly resetting the pixel buffer to zero before it was used to store any pixel data. This ensured that the buffer started with a clean state, eliminating the risk of processing invalid or garbage data and thereby enhancing the reliability and security of the image reading functionality.","The vulnerability was fixed by adding a line to reset the memory of the `jpeg_pixels` buffer to zero using the `ResetMagickMemory` function. This change ensures that the buffer is properly initialized before any pixel data is read into it, preventing the use of uninitialized memory that could lead to undefined behavior. By explicitly setting the buffer to zero, the code guarantees that any subsequent operations on the pixel data will work with a clean slate, thus enhancing the stability and security of the image processing function. This adjustment effectively mitigates the risk associated with processing garbage values.","The vulnerability was addressed by implementing a memory reset for the pixel buffer before it was utilized for storing image data. This adjustment ensured that the buffer was initialized to a known state, eliminating the risk of processing any residual or garbage values that could lead to unpredictable behavior or memory corruption. By explicitly clearing the buffer, the code now guarantees that all pixel data operations are performed on a clean slate, thereby enhancing the reliability and security of the image processing functionality and preventing potential issues related to uninitialized memory.","4,4","4, 4","4,5","5,5"
73,73,181231,181231,,Local,Not required,,CVE-2017-10911,https://www.cvedetails.com/cve/CVE-2017-10911/,CWE-200,Low,Complete,,,2017-07-04,4.9,"The make_response function in drivers/block/xen-blkback/blkback.c in the Linux kernel before 4.11.8 allows guest OS users to obtain sensitive information from host OS (or other guest OS) kernel memory by leveraging the copying of uninitialized padding fields in Xen block-interface response structures, aka XSA-216.",2018-09-07,+Info ,12,https://github.com/torvalds/linux/commit/089bc0143f489bd3a4578bdff5f4ca68fb26f341,089bc0143f489bd3a4578bdff5f4ca68fb26f341,"xen-blkback: don't leak stack data via response ring

Rather than constructing a local structure instance on the stack, fill
the fields directly on the shared ring, just like other backends do.
Build on the fact that all response structure flavors are actually
identical (the old code did make this assumption too).

This is XSA-216.

Cc: stable@vger.kernel.org

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>",10,drivers/block/xen-blkback/blkback.c,"{""sha"": ""0e824091a12fac8757c2ade5d4e5dae6a1470cbd"", ""filename"": ""drivers/block/xen-blkback/blkback.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 11, ""changes"": 23, ""blob_url"": ""https://github.com/torvalds/linux/blob/089bc0143f489bd3a4578bdff5f4ca68fb26f341/drivers/block/xen-blkback/blkback.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/089bc0143f489bd3a4578bdff5f4ca68fb26f341/drivers/block/xen-blkback/blkback.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/block/xen-blkback/blkback.c?ref=089bc0143f489bd3a4578bdff5f4ca68fb26f341"", ""patch"": ""@@ -1433,34 +1433,35 @@ static int dispatch_rw_block_io(struct xen_blkif_ring *ring,\n static void make_response(struct xen_blkif_ring *ring, u64 id,\n \t\t\t  unsigned short op, int st)\n {\n-\tstruct blkif_response  resp;\n+\tstruct blkif_response *resp;\n \tunsigned long     flags;\n \tunion blkif_back_rings *blk_rings;\n \tint notify;\n \n-\tresp.id        = id;\n-\tresp.operation = op;\n-\tresp.status    = st;\n-\n \tspin_lock_irqsave(&ring->blk_ring_lock, flags);\n \tblk_rings = &ring->blk_rings;\n \t/* Place on the response ring for the relevant domain. */\n \tswitch (ring->blkif->blk_protocol) {\n \tcase BLKIF_PROTOCOL_NATIVE:\n-\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),\n-\t\t       &resp, sizeof(resp));\n+\t\tresp = RING_GET_RESPONSE(&blk_rings->native,\n+\t\t\t\t\t blk_rings->native.rsp_prod_pvt);\n \t\tbreak;\n \tcase BLKIF_PROTOCOL_X86_32:\n-\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),\n-\t\t       &resp, sizeof(resp));\n+\t\tresp = RING_GET_RESPONSE(&blk_rings->x86_32,\n+\t\t\t\t\t blk_rings->x86_32.rsp_prod_pvt);\n \t\tbreak;\n \tcase BLKIF_PROTOCOL_X86_64:\n-\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),\n-\t\t       &resp, sizeof(resp));\n+\t\tresp = RING_GET_RESPONSE(&blk_rings->x86_64,\n+\t\t\t\t\t blk_rings->x86_64.rsp_prod_pvt);\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n+\n+\tresp->id        = id;\n+\tresp->operation = op;\n+\tresp->status    = st;\n+\n \tblk_rings->common.rsp_prod_pvt++;\n \tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\n \tspin_unlock_irqrestore(&ring->blk_ring_lock, flags);""}<_**next**_>{""sha"": ""ecb35fe8ca8dbb54f36a85513a09064819acd67a"", ""filename"": ""drivers/block/xen-blkback/common.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 20, ""changes"": 25, ""blob_url"": ""https://github.com/torvalds/linux/blob/089bc0143f489bd3a4578bdff5f4ca68fb26f341/drivers/block/xen-blkback/common.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/089bc0143f489bd3a4578bdff5f4ca68fb26f341/drivers/block/xen-blkback/common.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/block/xen-blkback/common.h?ref=089bc0143f489bd3a4578bdff5f4ca68fb26f341"", ""patch"": ""@@ -75,9 +75,8 @@ extern unsigned int xenblk_max_queues;\n struct blkif_common_request {\n \tchar dummy;\n };\n-struct blkif_common_response {\n-\tchar dummy;\n-};\n+\n+/* i386 protocol version */\n \n struct blkif_x86_32_request_rw {\n \tuint8_t        nr_segments;  /* number of segments                   */\n@@ -129,14 +128,6 @@ struct blkif_x86_32_request {\n \t} u;\n } __attribute__((__packed__));\n \n-/* i386 protocol version */\n-#pragma pack(push, 4)\n-struct blkif_x86_32_response {\n-\tuint64_t        id;              /* copied from request */\n-\tuint8_t         operation;       /* copied from request */\n-\tint16_t         status;          /* BLKIF_RSP_???       */\n-};\n-#pragma pack(pop)\n /* x86_64 protocol version */\n \n struct blkif_x86_64_request_rw {\n@@ -193,18 +184,12 @@ struct blkif_x86_64_request {\n \t} u;\n } __attribute__((__packed__));\n \n-struct blkif_x86_64_response {\n-\tuint64_t       __attribute__((__aligned__(8))) id;\n-\tuint8_t         operation;       /* copied from request */\n-\tint16_t         status;          /* BLKIF_RSP_???       */\n-};\n-\n DEFINE_RING_TYPES(blkif_common, struct blkif_common_request,\n-\t\t  struct blkif_common_response);\n+\t\t  struct blkif_response);\n DEFINE_RING_TYPES(blkif_x86_32, struct blkif_x86_32_request,\n-\t\t  struct blkif_x86_32_response);\n+\t\t  struct blkif_response __packed);\n DEFINE_RING_TYPES(blkif_x86_64, struct blkif_x86_64_request,\n-\t\t  struct blkif_x86_64_response);\n+\t\t  struct blkif_response);\n \n union blkif_back_rings {\n \tstruct blkif_back_ring        native;""}"," static void make_response(struct xen_blkif_ring *ring, u64 id,
 			  unsigned short op, int st)
 {
	struct blkif_response *resp;
 	unsigned long     flags;
 	union blkif_back_rings *blk_rings;
 	int notify;
 
 	spin_lock_irqsave(&ring->blk_ring_lock, flags);
 	blk_rings = &ring->blk_rings;
 	/* Place on the response ring for the relevant domain. */
 	switch (ring->blkif->blk_protocol) {
 	case BLKIF_PROTOCOL_NATIVE:
		resp = RING_GET_RESPONSE(&blk_rings->native,
					 blk_rings->native.rsp_prod_pvt);
 		break;
 	case BLKIF_PROTOCOL_X86_32:
		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
					 blk_rings->x86_32.rsp_prod_pvt);
 		break;
 	case BLKIF_PROTOCOL_X86_64:
		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
					 blk_rings->x86_64.rsp_prod_pvt);
 		break;
 	default:
 		BUG();
 	}

	resp->id        = id;
	resp->operation = op;
	resp->status    = st;

 	blk_rings->common.rsp_prod_pvt++;
 	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);
 	spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
	if (notify)
		notify_remote_via_irq(ring->irq);
}
"," static void make_response(struct xen_blkif_ring *ring, u64 id,
 			  unsigned short op, int st)
 {
	struct blkif_response  resp;
 	unsigned long     flags;
 	union blkif_back_rings *blk_rings;
 	int notify;
 
	resp.id        = id;
	resp.operation = op;
	resp.status    = st;
 	spin_lock_irqsave(&ring->blk_ring_lock, flags);
 	blk_rings = &ring->blk_rings;
 	/* Place on the response ring for the relevant domain. */
 	switch (ring->blkif->blk_protocol) {
 	case BLKIF_PROTOCOL_NATIVE:
		memcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),
		       &resp, sizeof(resp));
 		break;
 	case BLKIF_PROTOCOL_X86_32:
		memcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),
		       &resp, sizeof(resp));
 		break;
 	case BLKIF_PROTOCOL_X86_64:
		memcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),
		       &resp, sizeof(resp));
 		break;
 	default:
 		BUG();
 	}
 	blk_rings->common.rsp_prod_pvt++;
 	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);
 	spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
	if (notify)
		notify_remote_via_irq(ring->irq);
}
",C,"	struct blkif_response *resp;
		resp = RING_GET_RESPONSE(&blk_rings->native,
					 blk_rings->native.rsp_prod_pvt);
		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
					 blk_rings->x86_32.rsp_prod_pvt);
		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
					 blk_rings->x86_64.rsp_prod_pvt);

	resp->id        = id;
	resp->operation = op;
	resp->status    = st;

","	struct blkif_response  resp;
	resp.id        = id;
	resp.operation = op;
	resp.status    = st;
		memcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),
		       &resp, sizeof(resp));
		memcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),
		       &resp, sizeof(resp));
		memcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),
		       &resp, sizeof(resp));
",,"@@ -1433,34 +1433,35 @@ static int dispatch_rw_block_io(struct xen_blkif_ring *ring,
 static void make_response(struct xen_blkif_ring *ring, u64 id,
 			  unsigned short op, int st)
 {
-	struct blkif_response  resp;
+	struct blkif_response *resp;
 	unsigned long     flags;
 	union blkif_back_rings *blk_rings;
 	int notify;
 
-	resp.id        = id;
-	resp.operation = op;
-	resp.status    = st;
-
 	spin_lock_irqsave(&ring->blk_ring_lock, flags);
 	blk_rings = &ring->blk_rings;
 	/* Place on the response ring for the relevant domain. */
 	switch (ring->blkif->blk_protocol) {
 	case BLKIF_PROTOCOL_NATIVE:
-		memcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),
-		       &resp, sizeof(resp));
+		resp = RING_GET_RESPONSE(&blk_rings->native,
+					 blk_rings->native.rsp_prod_pvt);
 		break;
 	case BLKIF_PROTOCOL_X86_32:
-		memcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),
-		       &resp, sizeof(resp));
+		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
+					 blk_rings->x86_32.rsp_prod_pvt);
 		break;
 	case BLKIF_PROTOCOL_X86_64:
-		memcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),
-		       &resp, sizeof(resp));
+		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
+					 blk_rings->x86_64.rsp_prod_pvt);
 		break;
 	default:
 		BUG();
 	}
+
+	resp->id        = id;
+	resp->operation = op;
+	resp->status    = st;
+
 	blk_rings->common.rsp_prod_pvt++;
 	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);
 	spin_unlock_irqrestore(&ring->blk_ring_lock, flags);",linux,089bc0143f489bd3a4578bdff5f4ca68fb26f341,a24fa22ce22ae302b3bf8f7008896d52d5d57b8d,1," static void make_response(struct xen_blkif_ring *ring, u64 id,
 			  unsigned short op, int st)
 {
//flaw_line_below:
	struct blkif_response  resp;
//fix_flaw_line_below:
//	struct blkif_response *resp;
 	unsigned long     flags;
 	union blkif_back_rings *blk_rings;
 	int notify;
 
//flaw_line_below:
	resp.id        = id;
//flaw_line_below:
	resp.operation = op;
//flaw_line_below:
	resp.status    = st;
//flaw_line_below:

 	spin_lock_irqsave(&ring->blk_ring_lock, flags);
 	blk_rings = &ring->blk_rings;
 	/* Place on the response ring for the relevant domain. */
 	switch (ring->blkif->blk_protocol) {
 	case BLKIF_PROTOCOL_NATIVE:
//flaw_line_below:
		memcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),
//flaw_line_below:
		       &resp, sizeof(resp));
//fix_flaw_line_below:
//		resp = RING_GET_RESPONSE(&blk_rings->native,
//fix_flaw_line_below:
//					 blk_rings->native.rsp_prod_pvt);
 		break;
 	case BLKIF_PROTOCOL_X86_32:
//flaw_line_below:
		memcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),
//flaw_line_below:
		       &resp, sizeof(resp));
//fix_flaw_line_below:
//		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
//fix_flaw_line_below:
//					 blk_rings->x86_32.rsp_prod_pvt);
 		break;
 	case BLKIF_PROTOCOL_X86_64:
//flaw_line_below:
		memcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),
//flaw_line_below:
		       &resp, sizeof(resp));
//fix_flaw_line_below:
//		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
//fix_flaw_line_below:
//					 blk_rings->x86_64.rsp_prod_pvt);
 		break;
 	default:
 		BUG();
 	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	resp->id        = id;
//fix_flaw_line_below:
//	resp->operation = op;
//fix_flaw_line_below:
//	resp->status    = st;
//fix_flaw_line_below:
//
 	blk_rings->common.rsp_prod_pvt++;
 	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);
 	spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
	if (notify)
		notify_remote_via_irq(ring->irq);
}
",181231," static void make_response(struct xen_blkif_ring *ring, u64 id,
 			  unsigned short op, int st)
 {
	struct blkif_response  resp;
 	unsigned long     flags;
 	union blkif_back_rings *blk_rings;
 	int notify;
 
	resp.id        = id;
	resp.operation = op;
	resp.status    = st;
 	spin_lock_irqsave(&ring->blk_ring_lock, flags);
 	blk_rings = &ring->blk_rings;
 	/* Place on the response ring for the relevant domain. */
 	switch (ring->blkif->blk_protocol) {
 	case BLKIF_PROTOCOL_NATIVE:
		memcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),
		       &resp, sizeof(resp));
 		break;
 	case BLKIF_PROTOCOL_X86_32:
		memcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),
		       &resp, sizeof(resp));
 		break;
 	case BLKIF_PROTOCOL_X86_64:
		memcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),
		       &resp, sizeof(resp));
 		break;
 	default:
 		BUG();
 	}
 	blk_rings->common.rsp_prod_pvt++;
 	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);
 	spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
	if (notify)
		notify_remote_via_irq(ring->irq);
}
"," static void make_response(struct xen_blkif_ring *ring, u64 id,
 			  unsigned short op, int st)
 {
	struct blkif_response *resp;
 	unsigned long     flags;
 	union blkif_back_rings *blk_rings;
 	int notify;
 
 	spin_lock_irqsave(&ring->blk_ring_lock, flags);
 	blk_rings = &ring->blk_rings;
 	/* Place on the response ring for the relevant domain. */
 	switch (ring->blkif->blk_protocol) {
 	case BLKIF_PROTOCOL_NATIVE:
		resp = RING_GET_RESPONSE(&blk_rings->native,
					 blk_rings->native.rsp_prod_pvt);
 		break;
 	case BLKIF_PROTOCOL_X86_32:
		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
					 blk_rings->x86_32.rsp_prod_pvt);
 		break;
 	case BLKIF_PROTOCOL_X86_64:
		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
					 blk_rings->x86_64.rsp_prod_pvt);
 		break;
 	default:
 		BUG();
 	}

	resp->id        = id;
	resp->operation = op;
	resp->status    = st;

 	blk_rings->common.rsp_prod_pvt++;
 	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);
 	spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
	if (notify)
		notify_remote_via_irq(ring->irq);
}
","The `make_response` function constructs and sends a response for a block I/O operation in a Xen virtualized environment. It initializes a `blkif_response` structure with the provided operation ID, operation type, and status. The function acquires a spinlock to ensure thread safety while accessing the response ring associated with the specified `xen_blkif_ring`. Depending on the block protocol (native, x86_32, or x86_64), it copies the response data to the appropriate response ring. After updating the response producer index, it checks if a notification is needed and, if so, triggers an interrupt to notify the remote domain. Finally, it releases the spinlock.","The function is responsible for creating and sending a response for a block I/O operation within a virtualized environment. It initializes a response structure with specific identifiers and status information. To ensure safe access to shared resources, it acquires a lock before interacting with the response queue. Based on the communication protocol in use, it copies the response data to the appropriate location in the response queue. After updating the necessary indices, it checks if a notification to the remote domain is required and triggers an interrupt if needed, before releasing the lock to allow other operations to proceed.","The vulnerability in the original code stemmed from constructing a response structure on the stack, which could potentially expose sensitive stack data through the response ring, leading to information leakage. In the fixed code, this issue was addressed by directly filling the fields of the response structure in the shared ring instead of using a local stack instance. This change ensures that the response data is safely written to a designated area in memory that is intended for communication, thereby preventing any unintended exposure of stack data while maintaining the integrity of the response mechanism across different protocols.","The vulnerability in the original code arose from the use of a local structure on the stack to create a response, which risked leaking sensitive stack data through the response mechanism. This could potentially expose internal state information to unauthorized entities. The fix involved eliminating the local stack instance and instead directly populating the response fields in the designated shared memory area. This approach not only mitigated the risk of data leakage but also aligned the implementation with practices used by other backends, ensuring consistency and security in handling response data across the system.","The vulnerability was fixed by replacing the local stack instance of the response structure with direct assignments to the response fields in the shared ring. In the updated code, instead of creating a local variable for the response, the code retrieves a pointer to the appropriate response location using the `RING_GET_RESPONSE` function for each protocol. This allows the fields `id`, `operation`, and `status` to be filled directly in the shared memory area, thereby preventing any leakage of stack data. This change ensures that sensitive information remains secure and is not inadvertently exposed through the response mechanism.","The vulnerability was fixed by eliminating the use of a local stack-based structure for creating responses and instead directly populating the response fields in the designated shared memory area. This change involved retrieving a pointer to the appropriate response location based on the communication protocol, allowing the necessary data to be written directly to that location. By doing so, the risk of leaking sensitive stack data through the response mechanism was mitigated, ensuring that only the intended information is communicated while maintaining the integrity and security of the system's response handling.","4,4","5,5","4,4","4,5"
74,74,181245,181245,,Remote,Not required,,CVE-2017-9993,https://www.cvedetails.com/cve/CVE-2017-9993/,CWE-200,Low,Partial,,,2017-06-28,5.0,"FFmpeg before 2.8.12, 3.0.x and 3.1.x before 3.1.9, 3.2.x before 3.2.6, and 3.3.x before 3.3.2 does not properly restrict HTTP Live Streaming filename extensions and demuxer names, which allows attackers to read arbitrary files via crafted playlist data.",2019-01-08,+Info ,3,https://github.com/FFmpeg/FFmpeg/commit/a5d849b149ca67ced2d271dc84db0bc95a548abb,a5d849b149ca67ced2d271dc84db0bc95a548abb,"avformat/avidec: Limit formats in gab2 to srt and ass/ssa

This prevents part of one exploit leading to an information leak

Found-by: Emil Lerner and Pavel Cheremushkin
Reported-by: Thierry Foucu <tfoucu@google.com>

Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",0,libavformat/avidec.c,"{""sha"": ""df520920671241daa367b2a38eaa4ca2bfe58081"", ""filename"": ""libavformat/avidec.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/a5d849b149ca67ced2d271dc84db0bc95a548abb/libavformat/avidec.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/a5d849b149ca67ced2d271dc84db0bc95a548abb/libavformat/avidec.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavformat/avidec.c?ref=a5d849b149ca67ced2d271dc84db0bc95a548abb"", ""patch"": ""@@ -1099,6 +1099,9 @@ static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)\n         if (!sub_demuxer)\n             goto error;\n \n+        if (strcmp(sub_demuxer->name, \""srt\"") && strcmp(sub_demuxer->name, \""ass\""))\n+            goto error;\n+\n         if (!(ast->sub_ctx = avformat_alloc_context()))\n             goto error;\n ""}","static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)
{
    if (pkt->size >= 7 &&
        pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&
        !strcmp(pkt->data, ""GAB2"") && AV_RL16(pkt->data + 5) == 2) {
        uint8_t desc[256];
        int score      = AVPROBE_SCORE_EXTENSION, ret;
        AVIStream *ast = st->priv_data;
        AVInputFormat *sub_demuxer;
        AVRational time_base;
        int size;
        AVIOContext *pb = avio_alloc_context(pkt->data + 7,
                                             pkt->size - 7,
                                             0, NULL, NULL, NULL, NULL);
        AVProbeData pd;
        unsigned int desc_len = avio_rl32(pb);

        if (desc_len > pb->buf_end - pb->buf_ptr)
            goto error;

        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));
        avio_skip(pb, desc_len - ret);
        if (*desc)
            av_dict_set(&st->metadata, ""title"", desc, 0);

        avio_rl16(pb);   /* flags? */
        avio_rl32(pb);   /* data size */

        size = pb->buf_end - pb->buf_ptr;
        pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),
                             .buf_size = size };
        if (!pd.buf)
            goto error;
        memcpy(pd.buf, pb->buf_ptr, size);
        sub_demuxer = av_probe_input_format2(&pd, 1, &score);
        av_freep(&pd.buf);
         if (!sub_demuxer)
             goto error;
 
        if (strcmp(sub_demuxer->name, ""srt"") && strcmp(sub_demuxer->name, ""ass""))
            goto error;

         if (!(ast->sub_ctx = avformat_alloc_context()))
             goto error;
 
        ast->sub_ctx->pb = pb;

        if (ff_copy_whiteblacklists(ast->sub_ctx, s) < 0)
            goto error;

        if (!avformat_open_input(&ast->sub_ctx, """", sub_demuxer, NULL)) {
            if (ast->sub_ctx->nb_streams != 1)
                goto error;
            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);
            avcodec_parameters_copy(st->codecpar, ast->sub_ctx->streams[0]->codecpar);
            time_base = ast->sub_ctx->streams[0]->time_base;
            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);
        }
        ast->sub_buffer = pkt->data;
        memset(pkt, 0, sizeof(*pkt));
        return 1;

error:
        av_freep(&ast->sub_ctx);
        av_freep(&pb);
    }
    return 0;
}
","static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)
{
    if (pkt->size >= 7 &&
        pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&
        !strcmp(pkt->data, ""GAB2"") && AV_RL16(pkt->data + 5) == 2) {
        uint8_t desc[256];
        int score      = AVPROBE_SCORE_EXTENSION, ret;
        AVIStream *ast = st->priv_data;
        AVInputFormat *sub_demuxer;
        AVRational time_base;
        int size;
        AVIOContext *pb = avio_alloc_context(pkt->data + 7,
                                             pkt->size - 7,
                                             0, NULL, NULL, NULL, NULL);
        AVProbeData pd;
        unsigned int desc_len = avio_rl32(pb);

        if (desc_len > pb->buf_end - pb->buf_ptr)
            goto error;

        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));
        avio_skip(pb, desc_len - ret);
        if (*desc)
            av_dict_set(&st->metadata, ""title"", desc, 0);

        avio_rl16(pb);   /* flags? */
        avio_rl32(pb);   /* data size */

        size = pb->buf_end - pb->buf_ptr;
        pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),
                             .buf_size = size };
        if (!pd.buf)
            goto error;
        memcpy(pd.buf, pb->buf_ptr, size);
        sub_demuxer = av_probe_input_format2(&pd, 1, &score);
        av_freep(&pd.buf);
         if (!sub_demuxer)
             goto error;
 
         if (!(ast->sub_ctx = avformat_alloc_context()))
             goto error;
 
        ast->sub_ctx->pb = pb;

        if (ff_copy_whiteblacklists(ast->sub_ctx, s) < 0)
            goto error;

        if (!avformat_open_input(&ast->sub_ctx, """", sub_demuxer, NULL)) {
            if (ast->sub_ctx->nb_streams != 1)
                goto error;
            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);
            avcodec_parameters_copy(st->codecpar, ast->sub_ctx->streams[0]->codecpar);
            time_base = ast->sub_ctx->streams[0]->time_base;
            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);
        }
        ast->sub_buffer = pkt->data;
        memset(pkt, 0, sizeof(*pkt));
        return 1;

error:
        av_freep(&ast->sub_ctx);
        av_freep(&pb);
    }
    return 0;
}
",C,"        if (strcmp(sub_demuxer->name, ""srt"") && strcmp(sub_demuxer->name, ""ass""))
            goto error;

",,,"@@ -1099,6 +1099,9 @@ static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)
         if (!sub_demuxer)
             goto error;
 
+        if (strcmp(sub_demuxer->name, ""srt"") && strcmp(sub_demuxer->name, ""ass""))
+            goto error;
+
         if (!(ast->sub_ctx = avformat_alloc_context()))
             goto error;
 ",FFmpeg,a5d849b149ca67ced2d271dc84db0bc95a548abb,78f6ec32a37215f21e1efb299e233f1c0e031a0b,1,"static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)
{
    if (pkt->size >= 7 &&
        pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&
        !strcmp(pkt->data, ""GAB2"") && AV_RL16(pkt->data + 5) == 2) {
        uint8_t desc[256];
        int score      = AVPROBE_SCORE_EXTENSION, ret;
        AVIStream *ast = st->priv_data;
        AVInputFormat *sub_demuxer;
        AVRational time_base;
        int size;
        AVIOContext *pb = avio_alloc_context(pkt->data + 7,
                                             pkt->size - 7,
                                             0, NULL, NULL, NULL, NULL);
        AVProbeData pd;
        unsigned int desc_len = avio_rl32(pb);

        if (desc_len > pb->buf_end - pb->buf_ptr)
            goto error;

        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));
        avio_skip(pb, desc_len - ret);
        if (*desc)
            av_dict_set(&st->metadata, ""title"", desc, 0);

        avio_rl16(pb);   /* flags? */
        avio_rl32(pb);   /* data size */

        size = pb->buf_end - pb->buf_ptr;
        pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),
                             .buf_size = size };
        if (!pd.buf)
            goto error;
        memcpy(pd.buf, pb->buf_ptr, size);
        sub_demuxer = av_probe_input_format2(&pd, 1, &score);
        av_freep(&pd.buf);
         if (!sub_demuxer)
             goto error;
 
//fix_flaw_line_below:
//        if (strcmp(sub_demuxer->name, ""srt"") && strcmp(sub_demuxer->name, ""ass""))
//fix_flaw_line_below:
//            goto error;
//fix_flaw_line_below:
//
         if (!(ast->sub_ctx = avformat_alloc_context()))
             goto error;
 
        ast->sub_ctx->pb = pb;

        if (ff_copy_whiteblacklists(ast->sub_ctx, s) < 0)
            goto error;

        if (!avformat_open_input(&ast->sub_ctx, """", sub_demuxer, NULL)) {
            if (ast->sub_ctx->nb_streams != 1)
                goto error;
            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);
            avcodec_parameters_copy(st->codecpar, ast->sub_ctx->streams[0]->codecpar);
            time_base = ast->sub_ctx->streams[0]->time_base;
            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);
        }
        ast->sub_buffer = pkt->data;
        memset(pkt, 0, sizeof(*pkt));
        return 1;

error:
        av_freep(&ast->sub_ctx);
        av_freep(&pb);
    }
    return 0;
}
",181245,"static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)
{
    if (pkt->size >= 7 &&
        pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&
        !strcmp(pkt->data, ""GAB2"") && AV_RL16(pkt->data + 5) == 2) {
        uint8_t desc[256];
        int score      = AVPROBE_SCORE_EXTENSION, ret;
        AVIStream *ast = st->priv_data;
        AVInputFormat *sub_demuxer;
        AVRational time_base;
        int size;
        AVIOContext *pb = avio_alloc_context(pkt->data + 7,
                                             pkt->size - 7,
                                             0, NULL, NULL, NULL, NULL);
        AVProbeData pd;
        unsigned int desc_len = avio_rl32(pb);

        if (desc_len > pb->buf_end - pb->buf_ptr)
            goto error;

        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));
        avio_skip(pb, desc_len - ret);
        if (*desc)
            av_dict_set(&st->metadata, ""title"", desc, 0);

        avio_rl16(pb);   /* flags? */
        avio_rl32(pb);   /* data size */

        size = pb->buf_end - pb->buf_ptr;
        pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),
                             .buf_size = size };
        if (!pd.buf)
            goto error;
        memcpy(pd.buf, pb->buf_ptr, size);
        sub_demuxer = av_probe_input_format2(&pd, 1, &score);
        av_freep(&pd.buf);
         if (!sub_demuxer)
             goto error;
 
         if (!(ast->sub_ctx = avformat_alloc_context()))
             goto error;
 
        ast->sub_ctx->pb = pb;

        if (ff_copy_whiteblacklists(ast->sub_ctx, s) < 0)
            goto error;

        if (!avformat_open_input(&ast->sub_ctx, """", sub_demuxer, NULL)) {
            if (ast->sub_ctx->nb_streams != 1)
                goto error;
            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);
            avcodec_parameters_copy(st->codecpar, ast->sub_ctx->streams[0]->codecpar);
            time_base = ast->sub_ctx->streams[0]->time_base;
            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);
        }
        ast->sub_buffer = pkt->data;
        memset(pkt, 0, sizeof(*pkt));
        return 1;

error:
        av_freep(&ast->sub_ctx);
        av_freep(&pb);
    }
    return 0;
}
","static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)
{
    if (pkt->size >= 7 &&
        pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&
        !strcmp(pkt->data, ""GAB2"") && AV_RL16(pkt->data + 5) == 2) {
        uint8_t desc[256];
        int score      = AVPROBE_SCORE_EXTENSION, ret;
        AVIStream *ast = st->priv_data;
        AVInputFormat *sub_demuxer;
        AVRational time_base;
        int size;
        AVIOContext *pb = avio_alloc_context(pkt->data + 7,
                                             pkt->size - 7,
                                             0, NULL, NULL, NULL, NULL);
        AVProbeData pd;
        unsigned int desc_len = avio_rl32(pb);

        if (desc_len > pb->buf_end - pb->buf_ptr)
            goto error;

        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));
        avio_skip(pb, desc_len - ret);
        if (*desc)
            av_dict_set(&st->metadata, ""title"", desc, 0);

        avio_rl16(pb);   /* flags? */
        avio_rl32(pb);   /* data size */

        size = pb->buf_end - pb->buf_ptr;
        pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),
                             .buf_size = size };
        if (!pd.buf)
            goto error;
        memcpy(pd.buf, pb->buf_ptr, size);
        sub_demuxer = av_probe_input_format2(&pd, 1, &score);
        av_freep(&pd.buf);
         if (!sub_demuxer)
             goto error;
 
        if (strcmp(sub_demuxer->name, ""srt"") && strcmp(sub_demuxer->name, ""ass""))
            goto error;

         if (!(ast->sub_ctx = avformat_alloc_context()))
             goto error;
 
        ast->sub_ctx->pb = pb;

        if (ff_copy_whiteblacklists(ast->sub_ctx, s) < 0)
            goto error;

        if (!avformat_open_input(&ast->sub_ctx, """", sub_demuxer, NULL)) {
            if (ast->sub_ctx->nb_streams != 1)
                goto error;
            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);
            avcodec_parameters_copy(st->codecpar, ast->sub_ctx->streams[0]->codecpar);
            time_base = ast->sub_ctx->streams[0]->time_base;
            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);
        }
        ast->sub_buffer = pkt->data;
        memset(pkt, 0, sizeof(*pkt));
        return 1;

error:
        av_freep(&ast->sub_ctx);
        av_freep(&pb);
    }
    return 0;
}
","The `read_gab2_sub` function processes a GAB2 subtitle packet within an AVFormatContext. It first checks if the packet meets specific size and format criteria, including a ""GAB2"" identifier and a version number. If valid, it initializes an AVIOContext to read the subtitle data, extracts metadata such as the title, and allocates a new context for the subtitle stream. The function attempts to open the appropriate input format for the subtitle data and, if successful, copies codec parameters and sets the presentation timestamp information. If any step fails, it cleans up allocated resources and returns an error.","The function processes a specific type of subtitle packet by first validating its format and size. Upon confirmation, it initializes a context to read the subtitle data, extracts metadata such as the title, and allocates a new context for the subtitle stream. It then attempts to identify the appropriate input format for the subtitle data and, if successful, copies necessary codec parameters and sets the timing information for playback. In case of any errors during these operations, it ensures proper cleanup of allocated resources before returning an error status.","The vulnerability in the original code stemmed from a lack of validation on the input format after probing, allowing potentially malicious subtitle formats to be processed, which could lead to an information leak. Specifically, the code did not restrict the accepted formats, enabling exploitation through unexpected data types. The fix introduced a check to ensure that only specific formats, namely ""srt"" and ""ass,"" are accepted after probing the input format. This additional validation mitigates the risk of processing harmful data, thereby preventing the potential exploit and enhancing the overall security of the subtitle handling functionality.","The vulnerability in the original code arose from insufficient validation of the input formats, allowing potentially harmful subtitle formats to be processed, which could lead to an information leak. This lack of restrictions meant that malicious data could exploit the system. The fix implemented a validation step that limits the accepted formats to only specific, safe types. By ensuring that only these designated formats are processed, the risk of handling unexpected or harmful data is significantly reduced, thereby enhancing the security of the subtitle handling functionality and preventing potential exploits.","The vulnerability was fixed by adding a validation check after probing the input format to ensure that only specific formats, namely ""srt"" and ""ass,"" are accepted. This was achieved by introducing a conditional statement that compares the name of the identified input format against these allowed types. If the format does not match either of the specified names, the code proceeds to the error handling section, effectively preventing any further processing of potentially harmful data. This additional layer of validation mitigates the risk of information leaks and enhances the overall security of the subtitle processing functionality.","The vulnerability was addressed by implementing a validation step that restricts the accepted input formats to only specific, safe types. This was done by adding a conditional check that compares the identified format against a predefined list of allowed formats. If the format does not match any of the specified types, the code redirects to an error handling routine, effectively preventing further processing of potentially harmful data. This enhancement significantly reduces the risk of exploitation and information leaks, thereby improving the security of the subtitle processing functionality.","4,5","4,4","3,4","4,5"
75,75,181265,181265,,Local,Not required,,CVE-2017-9605,https://www.cvedetails.com/cve/CVE-2017-9605/,CWE-200,Low,Complete,,,2017-06-13,4.9,"The vmw_gb_surface_define_ioctl function (accessible via DRM_IOCTL_VMW_GB_SURFACE_CREATE) in drivers/gpu/drm/vmwgfx/vmwgfx_surface.c in the Linux kernel through 4.11.4 defines a backup_handle variable but does not give it an initial value. If one attempts to create a GB surface, with a previously allocated DMA buffer to be used as a backup buffer, the backup_handle variable does not get written to and is then later returned to user space, allowing local users to obtain sensitive information from uninitialized kernel memory via a crafted ioctl call.",2017-11-03,+Info ,11,https://github.com/torvalds/linux/commit/07678eca2cf9c9a18584e546c2b2a0d0c9a3150c,07678eca2cf9c9a18584e546c2b2a0d0c9a3150c,"drm/vmwgfx: Make sure backup_handle is always valid

When vmw_gb_surface_define_ioctl() is called with an existing buffer,
we end up returning an uninitialized variable in the backup_handle.

The fix is to first initialize backup_handle to 0 just to be sure, and
second, when a user-provided buffer is found, we will use the
req->buffer_handle as the backup_handle.

Cc: <stable@vger.kernel.org>
Reported-by: Murray McAllister <murray.mcallister@insomniasec.com>
Signed-off-by: Sinclair Yeh <syeh@vmware.com>
Reviewed-by: Deepak Rawat <drawat@vmware.com>",7,drivers/gpu/drm/vmwgfx/vmwgfx_surface.c,"{""sha"": ""834bb10973a2eb87ec37c05a364e5d95b2184343"", ""filename"": ""drivers/gpu/drm/vmwgfx/vmwgfx_surface.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 7, ""changes"": 18, ""blob_url"": ""https://github.com/torvalds/linux/blob/07678eca2cf9c9a18584e546c2b2a0d0c9a3150c/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/07678eca2cf9c9a18584e546c2b2a0d0c9a3150c/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c?ref=07678eca2cf9c9a18584e546c2b2a0d0c9a3150c"", ""patch"": ""@@ -1274,7 +1274,7 @@ int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,\n \tstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\n \tint ret;\n \tuint32_t size;\n-\tuint32_t backup_handle;\n+\tuint32_t backup_handle = 0;\n \n \tif (req->multisample_count != 0)\n \t\treturn -EINVAL;\n@@ -1317,12 +1317,16 @@ int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,\n \t\tret = vmw_user_dmabuf_lookup(tfile, req->buffer_handle,\n \t\t\t\t\t     &res->backup,\n \t\t\t\t\t     &user_srf->backup_base);\n-\t\tif (ret == 0 && res->backup->base.num_pages * PAGE_SIZE <\n-\t\t    res->backup_size) {\n-\t\t\tDRM_ERROR(\""Surface backup buffer is too small.\\n\"");\n-\t\t\tvmw_dmabuf_unreference(&res->backup);\n-\t\t\tret = -EINVAL;\n-\t\t\tgoto out_unlock;\n+\t\tif (ret == 0) {\n+\t\t\tif (res->backup->base.num_pages * PAGE_SIZE <\n+\t\t\t    res->backup_size) {\n+\t\t\t\tDRM_ERROR(\""Surface backup buffer is too small.\\n\"");\n+\t\t\t\tvmw_dmabuf_unreference(&res->backup);\n+\t\t\t\tret = -EINVAL;\n+\t\t\t\tgoto out_unlock;\n+\t\t\t} else {\n+\t\t\t\tbackup_handle = req->buffer_handle;\n+\t\t\t}\n \t\t}\n \t} else if (req->drm_surface_flags & drm_vmw_surface_flag_create_buffer)\n \t\tret = vmw_user_dmabuf_alloc(dev_priv, tfile,""}","int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,
				struct drm_file *file_priv)
{
	struct vmw_private *dev_priv = vmw_priv(dev);
	struct vmw_user_surface *user_srf;
	struct vmw_surface *srf;
	struct vmw_resource *res;
	struct vmw_resource *tmp;
	union drm_vmw_gb_surface_create_arg *arg =
	    (union drm_vmw_gb_surface_create_arg *)data;
	struct drm_vmw_gb_surface_create_req *req = &arg->req;
	struct drm_vmw_gb_surface_create_rep *rep = &arg->rep;
 	struct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;
 	int ret;
 	uint32_t size;
	uint32_t backup_handle = 0;
 
 	if (req->multisample_count != 0)
 		return -EINVAL;

	if (req->mip_levels > DRM_VMW_MAX_MIP_LEVELS)
		return -EINVAL;

	if (unlikely(vmw_user_surface_size == 0))
		vmw_user_surface_size = ttm_round_pot(sizeof(*user_srf)) +
			128;

	size = vmw_user_surface_size + 128;

	/* Define a surface based on the parameters. */
	ret = vmw_surface_gb_priv_define(dev,
			size,
			req->svga3d_flags,
			req->format,
			req->drm_surface_flags & drm_vmw_surface_flag_scanout,
			req->mip_levels,
			req->multisample_count,
			req->array_size,
			req->base_size,
			&srf);
	if (unlikely(ret != 0))
		return ret;

	user_srf = container_of(srf, struct vmw_user_surface, srf);
	if (drm_is_primary_client(file_priv))
		user_srf->master = drm_master_get(file_priv->master);

	ret = ttm_read_lock(&dev_priv->reservation_sem, true);
	if (unlikely(ret != 0))
		return ret;

	res = &user_srf->srf.res;


	if (req->buffer_handle != SVGA3D_INVALID_ID) {
 		ret = vmw_user_dmabuf_lookup(tfile, req->buffer_handle,
 					     &res->backup,
 					     &user_srf->backup_base);
		if (ret == 0) {
			if (res->backup->base.num_pages * PAGE_SIZE <
			    res->backup_size) {
				DRM_ERROR(""Surface backup buffer is too small.\n"");
				vmw_dmabuf_unreference(&res->backup);
				ret = -EINVAL;
				goto out_unlock;
			} else {
				backup_handle = req->buffer_handle;
			}
 		}
 	} else if (req->drm_surface_flags & drm_vmw_surface_flag_create_buffer)
 		ret = vmw_user_dmabuf_alloc(dev_priv, tfile,
					    res->backup_size,
					    req->drm_surface_flags &
					    drm_vmw_surface_flag_shareable,
					    &backup_handle,
					    &res->backup,
					    &user_srf->backup_base);

	if (unlikely(ret != 0)) {
		vmw_resource_unreference(&res);
		goto out_unlock;
	}

	tmp = vmw_resource_reference(res);
	ret = ttm_prime_object_init(tfile, res->backup_size, &user_srf->prime,
				    req->drm_surface_flags &
				    drm_vmw_surface_flag_shareable,
				    VMW_RES_SURFACE,
				    &vmw_user_surface_base_release, NULL);

	if (unlikely(ret != 0)) {
		vmw_resource_unreference(&tmp);
		vmw_resource_unreference(&res);
		goto out_unlock;
	}

	rep->handle      = user_srf->prime.base.hash.key;
	rep->backup_size = res->backup_size;
	if (res->backup) {
		rep->buffer_map_handle =
			drm_vma_node_offset_addr(&res->backup->base.vma_node);
		rep->buffer_size = res->backup->base.num_pages * PAGE_SIZE;
		rep->buffer_handle = backup_handle;
	} else {
		rep->buffer_map_handle = 0;
		rep->buffer_size = 0;
		rep->buffer_handle = SVGA3D_INVALID_ID;
	}

	vmw_resource_unreference(&res);

out_unlock:
	ttm_read_unlock(&dev_priv->reservation_sem);
	return ret;
}
","int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,
				struct drm_file *file_priv)
{
	struct vmw_private *dev_priv = vmw_priv(dev);
	struct vmw_user_surface *user_srf;
	struct vmw_surface *srf;
	struct vmw_resource *res;
	struct vmw_resource *tmp;
	union drm_vmw_gb_surface_create_arg *arg =
	    (union drm_vmw_gb_surface_create_arg *)data;
	struct drm_vmw_gb_surface_create_req *req = &arg->req;
	struct drm_vmw_gb_surface_create_rep *rep = &arg->rep;
 	struct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;
 	int ret;
 	uint32_t size;
	uint32_t backup_handle;
 
 	if (req->multisample_count != 0)
 		return -EINVAL;

	if (req->mip_levels > DRM_VMW_MAX_MIP_LEVELS)
		return -EINVAL;

	if (unlikely(vmw_user_surface_size == 0))
		vmw_user_surface_size = ttm_round_pot(sizeof(*user_srf)) +
			128;

	size = vmw_user_surface_size + 128;

	/* Define a surface based on the parameters. */
	ret = vmw_surface_gb_priv_define(dev,
			size,
			req->svga3d_flags,
			req->format,
			req->drm_surface_flags & drm_vmw_surface_flag_scanout,
			req->mip_levels,
			req->multisample_count,
			req->array_size,
			req->base_size,
			&srf);
	if (unlikely(ret != 0))
		return ret;

	user_srf = container_of(srf, struct vmw_user_surface, srf);
	if (drm_is_primary_client(file_priv))
		user_srf->master = drm_master_get(file_priv->master);

	ret = ttm_read_lock(&dev_priv->reservation_sem, true);
	if (unlikely(ret != 0))
		return ret;

	res = &user_srf->srf.res;


	if (req->buffer_handle != SVGA3D_INVALID_ID) {
 		ret = vmw_user_dmabuf_lookup(tfile, req->buffer_handle,
 					     &res->backup,
 					     &user_srf->backup_base);
		if (ret == 0 && res->backup->base.num_pages * PAGE_SIZE <
		    res->backup_size) {
			DRM_ERROR(""Surface backup buffer is too small.\n"");
			vmw_dmabuf_unreference(&res->backup);
			ret = -EINVAL;
			goto out_unlock;
 		}
 	} else if (req->drm_surface_flags & drm_vmw_surface_flag_create_buffer)
 		ret = vmw_user_dmabuf_alloc(dev_priv, tfile,
					    res->backup_size,
					    req->drm_surface_flags &
					    drm_vmw_surface_flag_shareable,
					    &backup_handle,
					    &res->backup,
					    &user_srf->backup_base);

	if (unlikely(ret != 0)) {
		vmw_resource_unreference(&res);
		goto out_unlock;
	}

	tmp = vmw_resource_reference(res);
	ret = ttm_prime_object_init(tfile, res->backup_size, &user_srf->prime,
				    req->drm_surface_flags &
				    drm_vmw_surface_flag_shareable,
				    VMW_RES_SURFACE,
				    &vmw_user_surface_base_release, NULL);

	if (unlikely(ret != 0)) {
		vmw_resource_unreference(&tmp);
		vmw_resource_unreference(&res);
		goto out_unlock;
	}

	rep->handle      = user_srf->prime.base.hash.key;
	rep->backup_size = res->backup_size;
	if (res->backup) {
		rep->buffer_map_handle =
			drm_vma_node_offset_addr(&res->backup->base.vma_node);
		rep->buffer_size = res->backup->base.num_pages * PAGE_SIZE;
		rep->buffer_handle = backup_handle;
	} else {
		rep->buffer_map_handle = 0;
		rep->buffer_size = 0;
		rep->buffer_handle = SVGA3D_INVALID_ID;
	}

	vmw_resource_unreference(&res);

out_unlock:
	ttm_read_unlock(&dev_priv->reservation_sem);
	return ret;
}
",C,"	uint32_t backup_handle = 0;
		if (ret == 0) {
			if (res->backup->base.num_pages * PAGE_SIZE <
			    res->backup_size) {
				DRM_ERROR(""Surface backup buffer is too small.\n"");
				vmw_dmabuf_unreference(&res->backup);
				ret = -EINVAL;
				goto out_unlock;
			} else {
				backup_handle = req->buffer_handle;
			}
","	uint32_t backup_handle;
		if (ret == 0 && res->backup->base.num_pages * PAGE_SIZE <
		    res->backup_size) {
			DRM_ERROR(""Surface backup buffer is too small.\n"");
			vmw_dmabuf_unreference(&res->backup);
			ret = -EINVAL;
			goto out_unlock;
",,"@@ -1274,7 +1274,7 @@ int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,
 	struct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;
 	int ret;
 	uint32_t size;
-	uint32_t backup_handle;
+	uint32_t backup_handle = 0;
 
 	if (req->multisample_count != 0)
 		return -EINVAL;
@@ -1317,12 +1317,16 @@ int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,
 		ret = vmw_user_dmabuf_lookup(tfile, req->buffer_handle,
 					     &res->backup,
 					     &user_srf->backup_base);
-		if (ret == 0 && res->backup->base.num_pages * PAGE_SIZE <
-		    res->backup_size) {
-			DRM_ERROR(""Surface backup buffer is too small.\n"");
-			vmw_dmabuf_unreference(&res->backup);
-			ret = -EINVAL;
-			goto out_unlock;
+		if (ret == 0) {
+			if (res->backup->base.num_pages * PAGE_SIZE <
+			    res->backup_size) {
+				DRM_ERROR(""Surface backup buffer is too small.\n"");
+				vmw_dmabuf_unreference(&res->backup);
+				ret = -EINVAL;
+				goto out_unlock;
+			} else {
+				backup_handle = req->buffer_handle;
+			}
 		}
 	} else if (req->drm_surface_flags & drm_vmw_surface_flag_create_buffer)
 		ret = vmw_user_dmabuf_alloc(dev_priv, tfile,",linux,07678eca2cf9c9a18584e546c2b2a0d0c9a3150c,f0c62e9878024300319ba2438adc7b06c6b9c448,1,"int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,
				struct drm_file *file_priv)
{
	struct vmw_private *dev_priv = vmw_priv(dev);
	struct vmw_user_surface *user_srf;
	struct vmw_surface *srf;
	struct vmw_resource *res;
	struct vmw_resource *tmp;
	union drm_vmw_gb_surface_create_arg *arg =
	    (union drm_vmw_gb_surface_create_arg *)data;
	struct drm_vmw_gb_surface_create_req *req = &arg->req;
	struct drm_vmw_gb_surface_create_rep *rep = &arg->rep;
 	struct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;
 	int ret;
 	uint32_t size;
//flaw_line_below:
	uint32_t backup_handle;
//fix_flaw_line_below:
//	uint32_t backup_handle = 0;
 
 	if (req->multisample_count != 0)
 		return -EINVAL;

	if (req->mip_levels > DRM_VMW_MAX_MIP_LEVELS)
		return -EINVAL;

	if (unlikely(vmw_user_surface_size == 0))
		vmw_user_surface_size = ttm_round_pot(sizeof(*user_srf)) +
			128;

	size = vmw_user_surface_size + 128;

	/* Define a surface based on the parameters. */
	ret = vmw_surface_gb_priv_define(dev,
			size,
			req->svga3d_flags,
			req->format,
			req->drm_surface_flags & drm_vmw_surface_flag_scanout,
			req->mip_levels,
			req->multisample_count,
			req->array_size,
			req->base_size,
			&srf);
	if (unlikely(ret != 0))
		return ret;

	user_srf = container_of(srf, struct vmw_user_surface, srf);
	if (drm_is_primary_client(file_priv))
		user_srf->master = drm_master_get(file_priv->master);

	ret = ttm_read_lock(&dev_priv->reservation_sem, true);
	if (unlikely(ret != 0))
		return ret;

	res = &user_srf->srf.res;


	if (req->buffer_handle != SVGA3D_INVALID_ID) {
 		ret = vmw_user_dmabuf_lookup(tfile, req->buffer_handle,
 					     &res->backup,
 					     &user_srf->backup_base);
//flaw_line_below:
		if (ret == 0 && res->backup->base.num_pages * PAGE_SIZE <
//flaw_line_below:
		    res->backup_size) {
//flaw_line_below:
			DRM_ERROR(""Surface backup buffer is too small.\n"");
//flaw_line_below:
			vmw_dmabuf_unreference(&res->backup);
//flaw_line_below:
			ret = -EINVAL;
//flaw_line_below:
			goto out_unlock;
//fix_flaw_line_below:
//		if (ret == 0) {
//fix_flaw_line_below:
//			if (res->backup->base.num_pages * PAGE_SIZE <
//fix_flaw_line_below:
//			    res->backup_size) {
//fix_flaw_line_below:
//				DRM_ERROR(""Surface backup buffer is too small.\n"");
//fix_flaw_line_below:
//				vmw_dmabuf_unreference(&res->backup);
//fix_flaw_line_below:
//				ret = -EINVAL;
//fix_flaw_line_below:
//				goto out_unlock;
//fix_flaw_line_below:
//			} else {
//fix_flaw_line_below:
//				backup_handle = req->buffer_handle;
//fix_flaw_line_below:
//			}
 		}
 	} else if (req->drm_surface_flags & drm_vmw_surface_flag_create_buffer)
 		ret = vmw_user_dmabuf_alloc(dev_priv, tfile,
					    res->backup_size,
					    req->drm_surface_flags &
					    drm_vmw_surface_flag_shareable,
					    &backup_handle,
					    &res->backup,
					    &user_srf->backup_base);

	if (unlikely(ret != 0)) {
		vmw_resource_unreference(&res);
		goto out_unlock;
	}

	tmp = vmw_resource_reference(res);
	ret = ttm_prime_object_init(tfile, res->backup_size, &user_srf->prime,
				    req->drm_surface_flags &
				    drm_vmw_surface_flag_shareable,
				    VMW_RES_SURFACE,
				    &vmw_user_surface_base_release, NULL);

	if (unlikely(ret != 0)) {
		vmw_resource_unreference(&tmp);
		vmw_resource_unreference(&res);
		goto out_unlock;
	}

	rep->handle      = user_srf->prime.base.hash.key;
	rep->backup_size = res->backup_size;
	if (res->backup) {
		rep->buffer_map_handle =
			drm_vma_node_offset_addr(&res->backup->base.vma_node);
		rep->buffer_size = res->backup->base.num_pages * PAGE_SIZE;
		rep->buffer_handle = backup_handle;
	} else {
		rep->buffer_map_handle = 0;
		rep->buffer_size = 0;
		rep->buffer_handle = SVGA3D_INVALID_ID;
	}

	vmw_resource_unreference(&res);

out_unlock:
	ttm_read_unlock(&dev_priv->reservation_sem);
	return ret;
}
",181265,"int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,
				struct drm_file *file_priv)
{
	struct vmw_private *dev_priv = vmw_priv(dev);
	struct vmw_user_surface *user_srf;
	struct vmw_surface *srf;
	struct vmw_resource *res;
	struct vmw_resource *tmp;
	union drm_vmw_gb_surface_create_arg *arg =
	    (union drm_vmw_gb_surface_create_arg *)data;
	struct drm_vmw_gb_surface_create_req *req = &arg->req;
	struct drm_vmw_gb_surface_create_rep *rep = &arg->rep;
 	struct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;
 	int ret;
 	uint32_t size;
	uint32_t backup_handle;
 
 	if (req->multisample_count != 0)
 		return -EINVAL;

	if (req->mip_levels > DRM_VMW_MAX_MIP_LEVELS)
		return -EINVAL;

	if (unlikely(vmw_user_surface_size == 0))
		vmw_user_surface_size = ttm_round_pot(sizeof(*user_srf)) +
			128;

	size = vmw_user_surface_size + 128;

	/* Define a surface based on the parameters. */
	ret = vmw_surface_gb_priv_define(dev,
			size,
			req->svga3d_flags,
			req->format,
			req->drm_surface_flags & drm_vmw_surface_flag_scanout,
			req->mip_levels,
			req->multisample_count,
			req->array_size,
			req->base_size,
			&srf);
	if (unlikely(ret != 0))
		return ret;

	user_srf = container_of(srf, struct vmw_user_surface, srf);
	if (drm_is_primary_client(file_priv))
		user_srf->master = drm_master_get(file_priv->master);

	ret = ttm_read_lock(&dev_priv->reservation_sem, true);
	if (unlikely(ret != 0))
		return ret;

	res = &user_srf->srf.res;


	if (req->buffer_handle != SVGA3D_INVALID_ID) {
 		ret = vmw_user_dmabuf_lookup(tfile, req->buffer_handle,
 					     &res->backup,
 					     &user_srf->backup_base);
		if (ret == 0 && res->backup->base.num_pages * PAGE_SIZE <
		    res->backup_size) {
			DRM_ERROR(""Surface backup buffer is too small.\n"");
			vmw_dmabuf_unreference(&res->backup);
			ret = -EINVAL;
			goto out_unlock;
 		}
 	} else if (req->drm_surface_flags & drm_vmw_surface_flag_create_buffer)
 		ret = vmw_user_dmabuf_alloc(dev_priv, tfile,
					    res->backup_size,
					    req->drm_surface_flags &
					    drm_vmw_surface_flag_shareable,
					    &backup_handle,
					    &res->backup,
					    &user_srf->backup_base);

	if (unlikely(ret != 0)) {
		vmw_resource_unreference(&res);
		goto out_unlock;
	}

	tmp = vmw_resource_reference(res);
	ret = ttm_prime_object_init(tfile, res->backup_size, &user_srf->prime,
				    req->drm_surface_flags &
				    drm_vmw_surface_flag_shareable,
				    VMW_RES_SURFACE,
				    &vmw_user_surface_base_release, NULL);

	if (unlikely(ret != 0)) {
		vmw_resource_unreference(&tmp);
		vmw_resource_unreference(&res);
		goto out_unlock;
	}

	rep->handle      = user_srf->prime.base.hash.key;
	rep->backup_size = res->backup_size;
	if (res->backup) {
		rep->buffer_map_handle =
			drm_vma_node_offset_addr(&res->backup->base.vma_node);
		rep->buffer_size = res->backup->base.num_pages * PAGE_SIZE;
		rep->buffer_handle = backup_handle;
	} else {
		rep->buffer_map_handle = 0;
		rep->buffer_size = 0;
		rep->buffer_handle = SVGA3D_INVALID_ID;
	}

	vmw_resource_unreference(&res);

out_unlock:
	ttm_read_unlock(&dev_priv->reservation_sem);
	return ret;
}
","int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,
				struct drm_file *file_priv)
{
	struct vmw_private *dev_priv = vmw_priv(dev);
	struct vmw_user_surface *user_srf;
	struct vmw_surface *srf;
	struct vmw_resource *res;
	struct vmw_resource *tmp;
	union drm_vmw_gb_surface_create_arg *arg =
	    (union drm_vmw_gb_surface_create_arg *)data;
	struct drm_vmw_gb_surface_create_req *req = &arg->req;
	struct drm_vmw_gb_surface_create_rep *rep = &arg->rep;
 	struct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;
 	int ret;
 	uint32_t size;
	uint32_t backup_handle = 0;
 
 	if (req->multisample_count != 0)
 		return -EINVAL;

	if (req->mip_levels > DRM_VMW_MAX_MIP_LEVELS)
		return -EINVAL;

	if (unlikely(vmw_user_surface_size == 0))
		vmw_user_surface_size = ttm_round_pot(sizeof(*user_srf)) +
			128;

	size = vmw_user_surface_size + 128;

	/* Define a surface based on the parameters. */
	ret = vmw_surface_gb_priv_define(dev,
			size,
			req->svga3d_flags,
			req->format,
			req->drm_surface_flags & drm_vmw_surface_flag_scanout,
			req->mip_levels,
			req->multisample_count,
			req->array_size,
			req->base_size,
			&srf);
	if (unlikely(ret != 0))
		return ret;

	user_srf = container_of(srf, struct vmw_user_surface, srf);
	if (drm_is_primary_client(file_priv))
		user_srf->master = drm_master_get(file_priv->master);

	ret = ttm_read_lock(&dev_priv->reservation_sem, true);
	if (unlikely(ret != 0))
		return ret;

	res = &user_srf->srf.res;


	if (req->buffer_handle != SVGA3D_INVALID_ID) {
 		ret = vmw_user_dmabuf_lookup(tfile, req->buffer_handle,
 					     &res->backup,
 					     &user_srf->backup_base);
		if (ret == 0) {
			if (res->backup->base.num_pages * PAGE_SIZE <
			    res->backup_size) {
				DRM_ERROR(""Surface backup buffer is too small.\n"");
				vmw_dmabuf_unreference(&res->backup);
				ret = -EINVAL;
				goto out_unlock;
			} else {
				backup_handle = req->buffer_handle;
			}
 		}
 	} else if (req->drm_surface_flags & drm_vmw_surface_flag_create_buffer)
 		ret = vmw_user_dmabuf_alloc(dev_priv, tfile,
					    res->backup_size,
					    req->drm_surface_flags &
					    drm_vmw_surface_flag_shareable,
					    &backup_handle,
					    &res->backup,
					    &user_srf->backup_base);

	if (unlikely(ret != 0)) {
		vmw_resource_unreference(&res);
		goto out_unlock;
	}

	tmp = vmw_resource_reference(res);
	ret = ttm_prime_object_init(tfile, res->backup_size, &user_srf->prime,
				    req->drm_surface_flags &
				    drm_vmw_surface_flag_shareable,
				    VMW_RES_SURFACE,
				    &vmw_user_surface_base_release, NULL);

	if (unlikely(ret != 0)) {
		vmw_resource_unreference(&tmp);
		vmw_resource_unreference(&res);
		goto out_unlock;
	}

	rep->handle      = user_srf->prime.base.hash.key;
	rep->backup_size = res->backup_size;
	if (res->backup) {
		rep->buffer_map_handle =
			drm_vma_node_offset_addr(&res->backup->base.vma_node);
		rep->buffer_size = res->backup->base.num_pages * PAGE_SIZE;
		rep->buffer_handle = backup_handle;
	} else {
		rep->buffer_map_handle = 0;
		rep->buffer_size = 0;
		rep->buffer_handle = SVGA3D_INVALID_ID;
	}

	vmw_resource_unreference(&res);

out_unlock:
	ttm_read_unlock(&dev_priv->reservation_sem);
	return ret;
}
","The `vmw_gb_surface_define_ioctl` function is responsible for defining a graphics surface in a virtualized environment using the Direct Rendering Manager (DRM) framework. It begins by validating input parameters, such as multisampling and mip levels, and calculates the required surface size. The function then attempts to create a surface based on the provided specifications, including format and flags. It manages memory for a backup buffer, either by looking it up or allocating it, and initializes a prime object for efficient buffer sharing. Finally, it populates a response structure with surface details and handles, ensuring proper resource management throughout the process.","The code defines a function that manages the creation of a graphics surface in a virtualized environment. It begins by validating input parameters related to surface characteristics and calculates the necessary size for the surface. The function then attempts to create the surface based on the specified attributes and manages memory for a backup buffer, either by retrieving an existing one or allocating a new one. It initializes a structure for efficient buffer sharing and populates a response with details about the created surface, ensuring proper resource management and error handling throughout the process.","The vulnerability in the original code stemmed from the potential use of an uninitialized variable, `backup_handle`, when a user-provided buffer was found. If the function was called with an existing buffer, it could return an invalid or garbage value for `backup_handle`, leading to undefined behavior or security issues. The fix involved initializing `backup_handle` to zero at the start of the function, ensuring it has a valid state. Additionally, when a valid user buffer is found, the code now correctly assigns `req->buffer_handle` to `backup_handle`, guaranteeing that it always holds a valid reference.","The vulnerability in the original code arose from the possibility of returning an uninitialized variable when a function was called with an existing buffer, which could lead to undefined behavior or security risks. This situation occurred because the variable intended to hold a reference to the buffer was not properly initialized, potentially exposing the system to invalid memory access. The fix involved initializing this variable to a known state at the beginning of the function, ensuring it starts with a valid value. Additionally, when a valid user buffer is detected, the code now correctly assigns the appropriate reference to this variable, enhancing overall stability and security.","The vulnerability was fixed by initializing the `backup_handle` variable to zero at the start of the function, ensuring it has a valid state before any operations are performed. This prevents the return of an uninitialized value when the function is called with an existing buffer. Additionally, when a user-provided buffer is found during the lookup process, the code now assigns `req->buffer_handle` to `backup_handle`, ensuring that it holds a valid reference. These changes collectively enhance the reliability of the function and mitigate the risk of undefined behavior or security issues.","The vulnerability was addressed by ensuring that the variable intended to hold a reference to the buffer is initialized to a known value at the beginning of the function. This prevents the risk of returning an uninitialized value, which could lead to undefined behavior. Additionally, when a valid user-provided buffer is detected, the code now correctly assigns the appropriate reference to this variable. These modifications enhance the overall stability and security of the function by guaranteeing that it always operates with valid data, thereby reducing the potential for memory access issues.","4,4","5,5","4,4","4,4"
76,76,181292,181292,,Local,Not required,,CVE-2017-9150,https://www.cvedetails.com/cve/CVE-2017-9150/,CWE-200,Low,Partial,,,2017-05-22,2.1,"The do_check function in kernel/bpf/verifier.c in the Linux kernel before 4.11.1 does not make the allow_ptr_leaks value available for restricting the output of the print_bpf_insn function, which allows local users to obtain sensitive address information via crafted bpf system calls.",2017-09-08,+Info ,1,https://github.com/torvalds/linux/commit/0d0e57697f162da4aa218b5feafe614fb666db07,0d0e57697f162da4aa218b5feafe614fb666db07,"bpf: don't let ldimm64 leak map addresses on unprivileged

The patch fixes two things at once:

1) It checks the env->allow_ptr_leaks and only prints the map address to
   the log if we have the privileges to do so, otherwise it just dumps 0
   as we would when kptr_restrict is enabled on %pK. Given the latter is
   off by default and not every distro sets it, I don't want to rely on
   this, hence the 0 by default for unprivileged.

2) Printing of ldimm64 in the verifier log is currently broken in that
   we don't print the full immediate, but only the 32 bit part of the
   first insn part for ldimm64. Thus, fix this up as well; it's okay to
   access, since we verified all ldimm64 earlier already (including just
   constants) through replace_map_fd_with_map_ptr().

Fixes: 1be7f75d1668 (""bpf: enable non-root eBPF programs"")
Fixes: cbd357008604 (""bpf: verifier (add ability to receive verification log)"")
Reported-by: Jann Horn <jannh@google.com>
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Acked-by: Alexei Starovoitov <ast@kernel.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,kernel/bpf/verifier.c,"{""sha"": ""c5b56c92f8e255d1b13634ad07c460969484f2f4"", ""filename"": ""kernel/bpf/verifier.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 5, ""changes"": 21, ""blob_url"": ""https://github.com/torvalds/linux/blob/0d0e57697f162da4aa218b5feafe614fb666db07/kernel/bpf/verifier.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0d0e57697f162da4aa218b5feafe614fb666db07/kernel/bpf/verifier.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/bpf/verifier.c?ref=0d0e57697f162da4aa218b5feafe614fb666db07"", ""patch"": ""@@ -298,7 +298,8 @@ static const char *const bpf_jmp_string[16] = {\n \t[BPF_EXIT >> 4] = \""exit\"",\n };\n \n-static void print_bpf_insn(struct bpf_insn *insn)\n+static void print_bpf_insn(const struct bpf_verifier_env *env,\n+\t\t\t   const struct bpf_insn *insn)\n {\n \tu8 class = BPF_CLASS(insn->code);\n \n@@ -362,9 +363,19 @@ static void print_bpf_insn(struct bpf_insn *insn)\n \t\t\t\tinsn->code,\n \t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n \t\t\t\tinsn->src_reg, insn->imm);\n-\t\t} else if (BPF_MODE(insn->code) == BPF_IMM) {\n-\t\t\tverbose(\""(%02x) r%d = 0x%x\\n\"",\n-\t\t\t\tinsn->code, insn->dst_reg, insn->imm);\n+\t\t} else if (BPF_MODE(insn->code) == BPF_IMM &&\n+\t\t\t   BPF_SIZE(insn->code) == BPF_DW) {\n+\t\t\t/* At this point, we already made sure that the second\n+\t\t\t * part of the ldimm64 insn is accessible.\n+\t\t\t */\n+\t\t\tu64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;\n+\t\t\tbool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;\n+\n+\t\t\tif (map_ptr && !env->allow_ptr_leaks)\n+\t\t\t\timm = 0;\n+\n+\t\t\tverbose(\""(%02x) r%d = 0x%llx\\n\"", insn->code,\n+\t\t\t\tinsn->dst_reg, (unsigned long long)imm);\n \t\t} else {\n \t\t\tverbose(\""BUG_ld_%02x\\n\"", insn->code);\n \t\t\treturn;\n@@ -2853,7 +2864,7 @@ static int do_check(struct bpf_verifier_env *env)\n \n \t\tif (log_level) {\n \t\t\tverbose(\""%d: \"", insn_idx);\n-\t\t\tprint_bpf_insn(insn);\n+\t\t\tprint_bpf_insn(env, insn);\n \t\t}\n \n \t\terr = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);""}","static int do_check(struct bpf_verifier_env *env)
{
	struct bpf_verifier_state *state = &env->cur_state;
	struct bpf_insn *insns = env->prog->insnsi;
	struct bpf_reg_state *regs = state->regs;
	int insn_cnt = env->prog->len;
	int insn_idx, prev_insn_idx = 0;
	int insn_processed = 0;
	bool do_print_state = false;

	init_reg_state(regs);
	insn_idx = 0;
	env->varlen_map_value_access = false;
	for (;;) {
		struct bpf_insn *insn;
		u8 class;
		int err;

		if (insn_idx >= insn_cnt) {
			verbose(""invalid insn idx %d insn_cnt %d\n"",
				insn_idx, insn_cnt);
			return -EFAULT;
		}

		insn = &insns[insn_idx];
		class = BPF_CLASS(insn->code);

		if (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {
			verbose(""BPF program is too large. Processed %d insn\n"",
				insn_processed);
			return -E2BIG;
		}

		err = is_state_visited(env, insn_idx);
		if (err < 0)
			return err;
		if (err == 1) {
			/* found equivalent state, can prune the search */
			if (log_level) {
				if (do_print_state)
					verbose(""\nfrom %d to %d: safe\n"",
						prev_insn_idx, insn_idx);
				else
					verbose(""%d: safe\n"", insn_idx);
			}
			goto process_bpf_exit;
		}

		if (log_level && do_print_state) {
			verbose(""\nfrom %d to %d:"", prev_insn_idx, insn_idx);
			print_verifier_state(&env->cur_state);
			do_print_state = false;
		}
 
 		if (log_level) {
 			verbose(""%d: "", insn_idx);
			print_bpf_insn(env, insn);
 		}
 
 		err = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);
		if (err)
			return err;

		if (class == BPF_ALU || class == BPF_ALU64) {
			err = check_alu_op(env, insn);
			if (err)
				return err;

		} else if (class == BPF_LDX) {
			enum bpf_reg_type *prev_src_type, src_reg_type;

			/* check for reserved fields is already done */

			/* check src operand */
			err = check_reg_arg(regs, insn->src_reg, SRC_OP);
			if (err)
				return err;

			err = check_reg_arg(regs, insn->dst_reg, DST_OP_NO_MARK);
			if (err)
				return err;

			src_reg_type = regs[insn->src_reg].type;

			/* check that memory (src_reg + off) is readable,
			 * the state of dst_reg will be updated by this func
			 */
			err = check_mem_access(env, insn->src_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_READ,
					       insn->dst_reg);
			if (err)
				return err;

			if (BPF_SIZE(insn->code) != BPF_W &&
			    BPF_SIZE(insn->code) != BPF_DW) {
				insn_idx++;
				continue;
			}

			prev_src_type = &env->insn_aux_data[insn_idx].ptr_type;

			if (*prev_src_type == NOT_INIT) {
				/* saw a valid insn
				 * dst_reg = *(u32 *)(src_reg + off)
				 * save type to validate intersecting paths
				 */
				*prev_src_type = src_reg_type;

			} else if (src_reg_type != *prev_src_type &&
				   (src_reg_type == PTR_TO_CTX ||
				    *prev_src_type == PTR_TO_CTX)) {
				/* ABuser program is trying to use the same insn
				 * dst_reg = *(u32*) (src_reg + off)
				 * with different pointer types:
				 * src_reg == ctx in one branch and
				 * src_reg == stack|map in some other branch.
				 * Reject it.
				 */
				verbose(""same insn cannot be used with different pointers\n"");
				return -EINVAL;
			}

		} else if (class == BPF_STX) {
			enum bpf_reg_type *prev_dst_type, dst_reg_type;

			if (BPF_MODE(insn->code) == BPF_XADD) {
				err = check_xadd(env, insn);
				if (err)
					return err;
				insn_idx++;
				continue;
			}

			/* check src1 operand */
			err = check_reg_arg(regs, insn->src_reg, SRC_OP);
			if (err)
				return err;
			/* check src2 operand */
			err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
			if (err)
				return err;

			dst_reg_type = regs[insn->dst_reg].type;

			/* check that memory (dst_reg + off) is writeable */
			err = check_mem_access(env, insn->dst_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_WRITE,
					       insn->src_reg);
			if (err)
				return err;

			prev_dst_type = &env->insn_aux_data[insn_idx].ptr_type;

			if (*prev_dst_type == NOT_INIT) {
				*prev_dst_type = dst_reg_type;
			} else if (dst_reg_type != *prev_dst_type &&
				   (dst_reg_type == PTR_TO_CTX ||
				    *prev_dst_type == PTR_TO_CTX)) {
				verbose(""same insn cannot be used with different pointers\n"");
				return -EINVAL;
			}

		} else if (class == BPF_ST) {
			if (BPF_MODE(insn->code) != BPF_MEM ||
			    insn->src_reg != BPF_REG_0) {
				verbose(""BPF_ST uses reserved fields\n"");
				return -EINVAL;
			}
			/* check src operand */
			err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
			if (err)
				return err;

			/* check that memory (dst_reg + off) is writeable */
			err = check_mem_access(env, insn->dst_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_WRITE,
					       -1);
			if (err)
				return err;

		} else if (class == BPF_JMP) {
			u8 opcode = BPF_OP(insn->code);

			if (opcode == BPF_CALL) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->off != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_CALL uses reserved fields\n"");
					return -EINVAL;
				}

				err = check_call(env, insn->imm, insn_idx);
				if (err)
					return err;

			} else if (opcode == BPF_JA) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->imm != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_JA uses reserved fields\n"");
					return -EINVAL;
				}

				insn_idx += insn->off + 1;
				continue;

			} else if (opcode == BPF_EXIT) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->imm != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_EXIT uses reserved fields\n"");
					return -EINVAL;
				}

				/* eBPF calling convetion is such that R0 is used
				 * to return the value from eBPF program.
				 * Make sure that it's readable at this time
				 * of bpf_exit, which means that program wrote
				 * something into it earlier
				 */
				err = check_reg_arg(regs, BPF_REG_0, SRC_OP);
				if (err)
					return err;

				if (is_pointer_value(env, BPF_REG_0)) {
					verbose(""R0 leaks addr as return value\n"");
					return -EACCES;
				}

process_bpf_exit:
				insn_idx = pop_stack(env, &prev_insn_idx);
				if (insn_idx < 0) {
					break;
				} else {
					do_print_state = true;
					continue;
				}
			} else {
				err = check_cond_jmp_op(env, insn, &insn_idx);
				if (err)
					return err;
			}
		} else if (class == BPF_LD) {
			u8 mode = BPF_MODE(insn->code);

			if (mode == BPF_ABS || mode == BPF_IND) {
				err = check_ld_abs(env, insn);
				if (err)
					return err;

			} else if (mode == BPF_IMM) {
				err = check_ld_imm(env, insn);
				if (err)
					return err;

				insn_idx++;
			} else {
				verbose(""invalid BPF_LD mode\n"");
				return -EINVAL;
			}
			reset_reg_range_values(regs, insn->dst_reg);
		} else {
			verbose(""unknown insn class %d\n"", class);
			return -EINVAL;
		}

		insn_idx++;
	}

	verbose(""processed %d insns\n"", insn_processed);
	return 0;
}
","static int do_check(struct bpf_verifier_env *env)
{
	struct bpf_verifier_state *state = &env->cur_state;
	struct bpf_insn *insns = env->prog->insnsi;
	struct bpf_reg_state *regs = state->regs;
	int insn_cnt = env->prog->len;
	int insn_idx, prev_insn_idx = 0;
	int insn_processed = 0;
	bool do_print_state = false;

	init_reg_state(regs);
	insn_idx = 0;
	env->varlen_map_value_access = false;
	for (;;) {
		struct bpf_insn *insn;
		u8 class;
		int err;

		if (insn_idx >= insn_cnt) {
			verbose(""invalid insn idx %d insn_cnt %d\n"",
				insn_idx, insn_cnt);
			return -EFAULT;
		}

		insn = &insns[insn_idx];
		class = BPF_CLASS(insn->code);

		if (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {
			verbose(""BPF program is too large. Processed %d insn\n"",
				insn_processed);
			return -E2BIG;
		}

		err = is_state_visited(env, insn_idx);
		if (err < 0)
			return err;
		if (err == 1) {
			/* found equivalent state, can prune the search */
			if (log_level) {
				if (do_print_state)
					verbose(""\nfrom %d to %d: safe\n"",
						prev_insn_idx, insn_idx);
				else
					verbose(""%d: safe\n"", insn_idx);
			}
			goto process_bpf_exit;
		}

		if (log_level && do_print_state) {
			verbose(""\nfrom %d to %d:"", prev_insn_idx, insn_idx);
			print_verifier_state(&env->cur_state);
			do_print_state = false;
		}
 
 		if (log_level) {
 			verbose(""%d: "", insn_idx);
			print_bpf_insn(insn);
 		}
 
 		err = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);
		if (err)
			return err;

		if (class == BPF_ALU || class == BPF_ALU64) {
			err = check_alu_op(env, insn);
			if (err)
				return err;

		} else if (class == BPF_LDX) {
			enum bpf_reg_type *prev_src_type, src_reg_type;

			/* check for reserved fields is already done */

			/* check src operand */
			err = check_reg_arg(regs, insn->src_reg, SRC_OP);
			if (err)
				return err;

			err = check_reg_arg(regs, insn->dst_reg, DST_OP_NO_MARK);
			if (err)
				return err;

			src_reg_type = regs[insn->src_reg].type;

			/* check that memory (src_reg + off) is readable,
			 * the state of dst_reg will be updated by this func
			 */
			err = check_mem_access(env, insn->src_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_READ,
					       insn->dst_reg);
			if (err)
				return err;

			if (BPF_SIZE(insn->code) != BPF_W &&
			    BPF_SIZE(insn->code) != BPF_DW) {
				insn_idx++;
				continue;
			}

			prev_src_type = &env->insn_aux_data[insn_idx].ptr_type;

			if (*prev_src_type == NOT_INIT) {
				/* saw a valid insn
				 * dst_reg = *(u32 *)(src_reg + off)
				 * save type to validate intersecting paths
				 */
				*prev_src_type = src_reg_type;

			} else if (src_reg_type != *prev_src_type &&
				   (src_reg_type == PTR_TO_CTX ||
				    *prev_src_type == PTR_TO_CTX)) {
				/* ABuser program is trying to use the same insn
				 * dst_reg = *(u32*) (src_reg + off)
				 * with different pointer types:
				 * src_reg == ctx in one branch and
				 * src_reg == stack|map in some other branch.
				 * Reject it.
				 */
				verbose(""same insn cannot be used with different pointers\n"");
				return -EINVAL;
			}

		} else if (class == BPF_STX) {
			enum bpf_reg_type *prev_dst_type, dst_reg_type;

			if (BPF_MODE(insn->code) == BPF_XADD) {
				err = check_xadd(env, insn);
				if (err)
					return err;
				insn_idx++;
				continue;
			}

			/* check src1 operand */
			err = check_reg_arg(regs, insn->src_reg, SRC_OP);
			if (err)
				return err;
			/* check src2 operand */
			err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
			if (err)
				return err;

			dst_reg_type = regs[insn->dst_reg].type;

			/* check that memory (dst_reg + off) is writeable */
			err = check_mem_access(env, insn->dst_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_WRITE,
					       insn->src_reg);
			if (err)
				return err;

			prev_dst_type = &env->insn_aux_data[insn_idx].ptr_type;

			if (*prev_dst_type == NOT_INIT) {
				*prev_dst_type = dst_reg_type;
			} else if (dst_reg_type != *prev_dst_type &&
				   (dst_reg_type == PTR_TO_CTX ||
				    *prev_dst_type == PTR_TO_CTX)) {
				verbose(""same insn cannot be used with different pointers\n"");
				return -EINVAL;
			}

		} else if (class == BPF_ST) {
			if (BPF_MODE(insn->code) != BPF_MEM ||
			    insn->src_reg != BPF_REG_0) {
				verbose(""BPF_ST uses reserved fields\n"");
				return -EINVAL;
			}
			/* check src operand */
			err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
			if (err)
				return err;

			/* check that memory (dst_reg + off) is writeable */
			err = check_mem_access(env, insn->dst_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_WRITE,
					       -1);
			if (err)
				return err;

		} else if (class == BPF_JMP) {
			u8 opcode = BPF_OP(insn->code);

			if (opcode == BPF_CALL) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->off != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_CALL uses reserved fields\n"");
					return -EINVAL;
				}

				err = check_call(env, insn->imm, insn_idx);
				if (err)
					return err;

			} else if (opcode == BPF_JA) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->imm != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_JA uses reserved fields\n"");
					return -EINVAL;
				}

				insn_idx += insn->off + 1;
				continue;

			} else if (opcode == BPF_EXIT) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->imm != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_EXIT uses reserved fields\n"");
					return -EINVAL;
				}

				/* eBPF calling convetion is such that R0 is used
				 * to return the value from eBPF program.
				 * Make sure that it's readable at this time
				 * of bpf_exit, which means that program wrote
				 * something into it earlier
				 */
				err = check_reg_arg(regs, BPF_REG_0, SRC_OP);
				if (err)
					return err;

				if (is_pointer_value(env, BPF_REG_0)) {
					verbose(""R0 leaks addr as return value\n"");
					return -EACCES;
				}

process_bpf_exit:
				insn_idx = pop_stack(env, &prev_insn_idx);
				if (insn_idx < 0) {
					break;
				} else {
					do_print_state = true;
					continue;
				}
			} else {
				err = check_cond_jmp_op(env, insn, &insn_idx);
				if (err)
					return err;
			}
		} else if (class == BPF_LD) {
			u8 mode = BPF_MODE(insn->code);

			if (mode == BPF_ABS || mode == BPF_IND) {
				err = check_ld_abs(env, insn);
				if (err)
					return err;

			} else if (mode == BPF_IMM) {
				err = check_ld_imm(env, insn);
				if (err)
					return err;

				insn_idx++;
			} else {
				verbose(""invalid BPF_LD mode\n"");
				return -EINVAL;
			}
			reset_reg_range_values(regs, insn->dst_reg);
		} else {
			verbose(""unknown insn class %d\n"", class);
			return -EINVAL;
		}

		insn_idx++;
	}

	verbose(""processed %d insns\n"", insn_processed);
	return 0;
}
",C,"			print_bpf_insn(env, insn);
","			print_bpf_insn(insn);
",,"@@ -298,7 +298,8 @@ static const char *const bpf_jmp_string[16] = {
 	[BPF_EXIT >> 4] = ""exit"",
 };
 
-static void print_bpf_insn(struct bpf_insn *insn)
+static void print_bpf_insn(const struct bpf_verifier_env *env,
+			   const struct bpf_insn *insn)
 {
 	u8 class = BPF_CLASS(insn->code);
 
@@ -362,9 +363,19 @@ static void print_bpf_insn(struct bpf_insn *insn)
 				insn->code,
 				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
 				insn->src_reg, insn->imm);
-		} else if (BPF_MODE(insn->code) == BPF_IMM) {
-			verbose(""(%02x) r%d = 0x%x\n"",
-				insn->code, insn->dst_reg, insn->imm);
+		} else if (BPF_MODE(insn->code) == BPF_IMM &&
+			   BPF_SIZE(insn->code) == BPF_DW) {
+			/* At this point, we already made sure that the second
+			 * part of the ldimm64 insn is accessible.
+			 */
+			u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;
+			bool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;
+
+			if (map_ptr && !env->allow_ptr_leaks)
+				imm = 0;
+
+			verbose(""(%02x) r%d = 0x%llx\n"", insn->code,
+				insn->dst_reg, (unsigned long long)imm);
 		} else {
 			verbose(""BUG_ld_%02x\n"", insn->code);
 			return;
@@ -2853,7 +2864,7 @@ static int do_check(struct bpf_verifier_env *env)
 
 		if (log_level) {
 			verbose(""%d: "", insn_idx);
-			print_bpf_insn(insn);
+			print_bpf_insn(env, insn);
 		}
 
 		err = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);",linux,0d0e57697f162da4aa218b5feafe614fb666db07,871ff2ebe0af0d7f1050bfc8bce62fddea2b12ec,1,"static int do_check(struct bpf_verifier_env *env)
{
	struct bpf_verifier_state *state = &env->cur_state;
	struct bpf_insn *insns = env->prog->insnsi;
	struct bpf_reg_state *regs = state->regs;
	int insn_cnt = env->prog->len;
	int insn_idx, prev_insn_idx = 0;
	int insn_processed = 0;
	bool do_print_state = false;

	init_reg_state(regs);
	insn_idx = 0;
	env->varlen_map_value_access = false;
	for (;;) {
		struct bpf_insn *insn;
		u8 class;
		int err;

		if (insn_idx >= insn_cnt) {
			verbose(""invalid insn idx %d insn_cnt %d\n"",
				insn_idx, insn_cnt);
			return -EFAULT;
		}

		insn = &insns[insn_idx];
		class = BPF_CLASS(insn->code);

		if (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {
			verbose(""BPF program is too large. Processed %d insn\n"",
				insn_processed);
			return -E2BIG;
		}

		err = is_state_visited(env, insn_idx);
		if (err < 0)
			return err;
		if (err == 1) {
			/* found equivalent state, can prune the search */
			if (log_level) {
				if (do_print_state)
					verbose(""\nfrom %d to %d: safe\n"",
						prev_insn_idx, insn_idx);
				else
					verbose(""%d: safe\n"", insn_idx);
			}
			goto process_bpf_exit;
		}

		if (log_level && do_print_state) {
			verbose(""\nfrom %d to %d:"", prev_insn_idx, insn_idx);
			print_verifier_state(&env->cur_state);
			do_print_state = false;
		}
 
 		if (log_level) {
 			verbose(""%d: "", insn_idx);
//flaw_line_below:
			print_bpf_insn(insn);
//fix_flaw_line_below:
//			print_bpf_insn(env, insn);
 		}
 
 		err = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);
		if (err)
			return err;

		if (class == BPF_ALU || class == BPF_ALU64) {
			err = check_alu_op(env, insn);
			if (err)
				return err;

		} else if (class == BPF_LDX) {
			enum bpf_reg_type *prev_src_type, src_reg_type;

			/* check for reserved fields is already done */

			/* check src operand */
			err = check_reg_arg(regs, insn->src_reg, SRC_OP);
			if (err)
				return err;

			err = check_reg_arg(regs, insn->dst_reg, DST_OP_NO_MARK);
			if (err)
				return err;

			src_reg_type = regs[insn->src_reg].type;

			/* check that memory (src_reg + off) is readable,
			 * the state of dst_reg will be updated by this func
			 */
			err = check_mem_access(env, insn->src_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_READ,
					       insn->dst_reg);
			if (err)
				return err;

			if (BPF_SIZE(insn->code) != BPF_W &&
			    BPF_SIZE(insn->code) != BPF_DW) {
				insn_idx++;
				continue;
			}

			prev_src_type = &env->insn_aux_data[insn_idx].ptr_type;

			if (*prev_src_type == NOT_INIT) {
				/* saw a valid insn
				 * dst_reg = *(u32 *)(src_reg + off)
				 * save type to validate intersecting paths
				 */
				*prev_src_type = src_reg_type;

			} else if (src_reg_type != *prev_src_type &&
				   (src_reg_type == PTR_TO_CTX ||
				    *prev_src_type == PTR_TO_CTX)) {
				/* ABuser program is trying to use the same insn
				 * dst_reg = *(u32*) (src_reg + off)
				 * with different pointer types:
				 * src_reg == ctx in one branch and
				 * src_reg == stack|map in some other branch.
				 * Reject it.
				 */
				verbose(""same insn cannot be used with different pointers\n"");
				return -EINVAL;
			}

		} else if (class == BPF_STX) {
			enum bpf_reg_type *prev_dst_type, dst_reg_type;

			if (BPF_MODE(insn->code) == BPF_XADD) {
				err = check_xadd(env, insn);
				if (err)
					return err;
				insn_idx++;
				continue;
			}

			/* check src1 operand */
			err = check_reg_arg(regs, insn->src_reg, SRC_OP);
			if (err)
				return err;
			/* check src2 operand */
			err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
			if (err)
				return err;

			dst_reg_type = regs[insn->dst_reg].type;

			/* check that memory (dst_reg + off) is writeable */
			err = check_mem_access(env, insn->dst_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_WRITE,
					       insn->src_reg);
			if (err)
				return err;

			prev_dst_type = &env->insn_aux_data[insn_idx].ptr_type;

			if (*prev_dst_type == NOT_INIT) {
				*prev_dst_type = dst_reg_type;
			} else if (dst_reg_type != *prev_dst_type &&
				   (dst_reg_type == PTR_TO_CTX ||
				    *prev_dst_type == PTR_TO_CTX)) {
				verbose(""same insn cannot be used with different pointers\n"");
				return -EINVAL;
			}

		} else if (class == BPF_ST) {
			if (BPF_MODE(insn->code) != BPF_MEM ||
			    insn->src_reg != BPF_REG_0) {
				verbose(""BPF_ST uses reserved fields\n"");
				return -EINVAL;
			}
			/* check src operand */
			err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
			if (err)
				return err;

			/* check that memory (dst_reg + off) is writeable */
			err = check_mem_access(env, insn->dst_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_WRITE,
					       -1);
			if (err)
				return err;

		} else if (class == BPF_JMP) {
			u8 opcode = BPF_OP(insn->code);

			if (opcode == BPF_CALL) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->off != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_CALL uses reserved fields\n"");
					return -EINVAL;
				}

				err = check_call(env, insn->imm, insn_idx);
				if (err)
					return err;

			} else if (opcode == BPF_JA) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->imm != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_JA uses reserved fields\n"");
					return -EINVAL;
				}

				insn_idx += insn->off + 1;
				continue;

			} else if (opcode == BPF_EXIT) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->imm != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_EXIT uses reserved fields\n"");
					return -EINVAL;
				}

				/* eBPF calling convetion is such that R0 is used
				 * to return the value from eBPF program.
				 * Make sure that it's readable at this time
				 * of bpf_exit, which means that program wrote
				 * something into it earlier
				 */
				err = check_reg_arg(regs, BPF_REG_0, SRC_OP);
				if (err)
					return err;

				if (is_pointer_value(env, BPF_REG_0)) {
					verbose(""R0 leaks addr as return value\n"");
					return -EACCES;
				}

process_bpf_exit:
				insn_idx = pop_stack(env, &prev_insn_idx);
				if (insn_idx < 0) {
					break;
				} else {
					do_print_state = true;
					continue;
				}
			} else {
				err = check_cond_jmp_op(env, insn, &insn_idx);
				if (err)
					return err;
			}
		} else if (class == BPF_LD) {
			u8 mode = BPF_MODE(insn->code);

			if (mode == BPF_ABS || mode == BPF_IND) {
				err = check_ld_abs(env, insn);
				if (err)
					return err;

			} else if (mode == BPF_IMM) {
				err = check_ld_imm(env, insn);
				if (err)
					return err;

				insn_idx++;
			} else {
				verbose(""invalid BPF_LD mode\n"");
				return -EINVAL;
			}
			reset_reg_range_values(regs, insn->dst_reg);
		} else {
			verbose(""unknown insn class %d\n"", class);
			return -EINVAL;
		}

		insn_idx++;
	}

	verbose(""processed %d insns\n"", insn_processed);
	return 0;
}
",181292,"static int do_check(struct bpf_verifier_env *env)
{
	struct bpf_verifier_state *state = &env->cur_state;
	struct bpf_insn *insns = env->prog->insnsi;
	struct bpf_reg_state *regs = state->regs;
	int insn_cnt = env->prog->len;
	int insn_idx, prev_insn_idx = 0;
	int insn_processed = 0;
	bool do_print_state = false;

	init_reg_state(regs);
	insn_idx = 0;
	env->varlen_map_value_access = false;
	for (;;) {
		struct bpf_insn *insn;
		u8 class;
		int err;

		if (insn_idx >= insn_cnt) {
			verbose(""invalid insn idx %d insn_cnt %d\n"",
				insn_idx, insn_cnt);
			return -EFAULT;
		}

		insn = &insns[insn_idx];
		class = BPF_CLASS(insn->code);

		if (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {
			verbose(""BPF program is too large. Processed %d insn\n"",
				insn_processed);
			return -E2BIG;
		}

		err = is_state_visited(env, insn_idx);
		if (err < 0)
			return err;
		if (err == 1) {
			/* found equivalent state, can prune the search */
			if (log_level) {
				if (do_print_state)
					verbose(""\nfrom %d to %d: safe\n"",
						prev_insn_idx, insn_idx);
				else
					verbose(""%d: safe\n"", insn_idx);
			}
			goto process_bpf_exit;
		}

		if (log_level && do_print_state) {
			verbose(""\nfrom %d to %d:"", prev_insn_idx, insn_idx);
			print_verifier_state(&env->cur_state);
			do_print_state = false;
		}
 
 		if (log_level) {
 			verbose(""%d: "", insn_idx);
			print_bpf_insn(insn);
 		}
 
 		err = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);
		if (err)
			return err;

		if (class == BPF_ALU || class == BPF_ALU64) {
			err = check_alu_op(env, insn);
			if (err)
				return err;

		} else if (class == BPF_LDX) {
			enum bpf_reg_type *prev_src_type, src_reg_type;

			/* check for reserved fields is already done */

			/* check src operand */
			err = check_reg_arg(regs, insn->src_reg, SRC_OP);
			if (err)
				return err;

			err = check_reg_arg(regs, insn->dst_reg, DST_OP_NO_MARK);
			if (err)
				return err;

			src_reg_type = regs[insn->src_reg].type;

			/* check that memory (src_reg + off) is readable,
			 * the state of dst_reg will be updated by this func
			 */
			err = check_mem_access(env, insn->src_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_READ,
					       insn->dst_reg);
			if (err)
				return err;

			if (BPF_SIZE(insn->code) != BPF_W &&
			    BPF_SIZE(insn->code) != BPF_DW) {
				insn_idx++;
				continue;
			}

			prev_src_type = &env->insn_aux_data[insn_idx].ptr_type;

			if (*prev_src_type == NOT_INIT) {
				/* saw a valid insn
				 * dst_reg = *(u32 *)(src_reg + off)
				 * save type to validate intersecting paths
				 */
				*prev_src_type = src_reg_type;

			} else if (src_reg_type != *prev_src_type &&
				   (src_reg_type == PTR_TO_CTX ||
				    *prev_src_type == PTR_TO_CTX)) {
				/* ABuser program is trying to use the same insn
				 * dst_reg = *(u32*) (src_reg + off)
				 * with different pointer types:
				 * src_reg == ctx in one branch and
				 * src_reg == stack|map in some other branch.
				 * Reject it.
				 */
				verbose(""same insn cannot be used with different pointers\n"");
				return -EINVAL;
			}

		} else if (class == BPF_STX) {
			enum bpf_reg_type *prev_dst_type, dst_reg_type;

			if (BPF_MODE(insn->code) == BPF_XADD) {
				err = check_xadd(env, insn);
				if (err)
					return err;
				insn_idx++;
				continue;
			}

			/* check src1 operand */
			err = check_reg_arg(regs, insn->src_reg, SRC_OP);
			if (err)
				return err;
			/* check src2 operand */
			err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
			if (err)
				return err;

			dst_reg_type = regs[insn->dst_reg].type;

			/* check that memory (dst_reg + off) is writeable */
			err = check_mem_access(env, insn->dst_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_WRITE,
					       insn->src_reg);
			if (err)
				return err;

			prev_dst_type = &env->insn_aux_data[insn_idx].ptr_type;

			if (*prev_dst_type == NOT_INIT) {
				*prev_dst_type = dst_reg_type;
			} else if (dst_reg_type != *prev_dst_type &&
				   (dst_reg_type == PTR_TO_CTX ||
				    *prev_dst_type == PTR_TO_CTX)) {
				verbose(""same insn cannot be used with different pointers\n"");
				return -EINVAL;
			}

		} else if (class == BPF_ST) {
			if (BPF_MODE(insn->code) != BPF_MEM ||
			    insn->src_reg != BPF_REG_0) {
				verbose(""BPF_ST uses reserved fields\n"");
				return -EINVAL;
			}
			/* check src operand */
			err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
			if (err)
				return err;

			/* check that memory (dst_reg + off) is writeable */
			err = check_mem_access(env, insn->dst_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_WRITE,
					       -1);
			if (err)
				return err;

		} else if (class == BPF_JMP) {
			u8 opcode = BPF_OP(insn->code);

			if (opcode == BPF_CALL) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->off != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_CALL uses reserved fields\n"");
					return -EINVAL;
				}

				err = check_call(env, insn->imm, insn_idx);
				if (err)
					return err;

			} else if (opcode == BPF_JA) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->imm != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_JA uses reserved fields\n"");
					return -EINVAL;
				}

				insn_idx += insn->off + 1;
				continue;

			} else if (opcode == BPF_EXIT) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->imm != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_EXIT uses reserved fields\n"");
					return -EINVAL;
				}

				/* eBPF calling convetion is such that R0 is used
				 * to return the value from eBPF program.
				 * Make sure that it's readable at this time
				 * of bpf_exit, which means that program wrote
				 * something into it earlier
				 */
				err = check_reg_arg(regs, BPF_REG_0, SRC_OP);
				if (err)
					return err;

				if (is_pointer_value(env, BPF_REG_0)) {
					verbose(""R0 leaks addr as return value\n"");
					return -EACCES;
				}

process_bpf_exit:
				insn_idx = pop_stack(env, &prev_insn_idx);
				if (insn_idx < 0) {
					break;
				} else {
					do_print_state = true;
					continue;
				}
			} else {
				err = check_cond_jmp_op(env, insn, &insn_idx);
				if (err)
					return err;
			}
		} else if (class == BPF_LD) {
			u8 mode = BPF_MODE(insn->code);

			if (mode == BPF_ABS || mode == BPF_IND) {
				err = check_ld_abs(env, insn);
				if (err)
					return err;

			} else if (mode == BPF_IMM) {
				err = check_ld_imm(env, insn);
				if (err)
					return err;

				insn_idx++;
			} else {
				verbose(""invalid BPF_LD mode\n"");
				return -EINVAL;
			}
			reset_reg_range_values(regs, insn->dst_reg);
		} else {
			verbose(""unknown insn class %d\n"", class);
			return -EINVAL;
		}

		insn_idx++;
	}

	verbose(""processed %d insns\n"", insn_processed);
	return 0;
}
","static int do_check(struct bpf_verifier_env *env)
{
	struct bpf_verifier_state *state = &env->cur_state;
	struct bpf_insn *insns = env->prog->insnsi;
	struct bpf_reg_state *regs = state->regs;
	int insn_cnt = env->prog->len;
	int insn_idx, prev_insn_idx = 0;
	int insn_processed = 0;
	bool do_print_state = false;

	init_reg_state(regs);
	insn_idx = 0;
	env->varlen_map_value_access = false;
	for (;;) {
		struct bpf_insn *insn;
		u8 class;
		int err;

		if (insn_idx >= insn_cnt) {
			verbose(""invalid insn idx %d insn_cnt %d\n"",
				insn_idx, insn_cnt);
			return -EFAULT;
		}

		insn = &insns[insn_idx];
		class = BPF_CLASS(insn->code);

		if (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {
			verbose(""BPF program is too large. Processed %d insn\n"",
				insn_processed);
			return -E2BIG;
		}

		err = is_state_visited(env, insn_idx);
		if (err < 0)
			return err;
		if (err == 1) {
			/* found equivalent state, can prune the search */
			if (log_level) {
				if (do_print_state)
					verbose(""\nfrom %d to %d: safe\n"",
						prev_insn_idx, insn_idx);
				else
					verbose(""%d: safe\n"", insn_idx);
			}
			goto process_bpf_exit;
		}

		if (log_level && do_print_state) {
			verbose(""\nfrom %d to %d:"", prev_insn_idx, insn_idx);
			print_verifier_state(&env->cur_state);
			do_print_state = false;
		}
 
 		if (log_level) {
 			verbose(""%d: "", insn_idx);
			print_bpf_insn(env, insn);
 		}
 
 		err = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);
		if (err)
			return err;

		if (class == BPF_ALU || class == BPF_ALU64) {
			err = check_alu_op(env, insn);
			if (err)
				return err;

		} else if (class == BPF_LDX) {
			enum bpf_reg_type *prev_src_type, src_reg_type;

			/* check for reserved fields is already done */

			/* check src operand */
			err = check_reg_arg(regs, insn->src_reg, SRC_OP);
			if (err)
				return err;

			err = check_reg_arg(regs, insn->dst_reg, DST_OP_NO_MARK);
			if (err)
				return err;

			src_reg_type = regs[insn->src_reg].type;

			/* check that memory (src_reg + off) is readable,
			 * the state of dst_reg will be updated by this func
			 */
			err = check_mem_access(env, insn->src_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_READ,
					       insn->dst_reg);
			if (err)
				return err;

			if (BPF_SIZE(insn->code) != BPF_W &&
			    BPF_SIZE(insn->code) != BPF_DW) {
				insn_idx++;
				continue;
			}

			prev_src_type = &env->insn_aux_data[insn_idx].ptr_type;

			if (*prev_src_type == NOT_INIT) {
				/* saw a valid insn
				 * dst_reg = *(u32 *)(src_reg + off)
				 * save type to validate intersecting paths
				 */
				*prev_src_type = src_reg_type;

			} else if (src_reg_type != *prev_src_type &&
				   (src_reg_type == PTR_TO_CTX ||
				    *prev_src_type == PTR_TO_CTX)) {
				/* ABuser program is trying to use the same insn
				 * dst_reg = *(u32*) (src_reg + off)
				 * with different pointer types:
				 * src_reg == ctx in one branch and
				 * src_reg == stack|map in some other branch.
				 * Reject it.
				 */
				verbose(""same insn cannot be used with different pointers\n"");
				return -EINVAL;
			}

		} else if (class == BPF_STX) {
			enum bpf_reg_type *prev_dst_type, dst_reg_type;

			if (BPF_MODE(insn->code) == BPF_XADD) {
				err = check_xadd(env, insn);
				if (err)
					return err;
				insn_idx++;
				continue;
			}

			/* check src1 operand */
			err = check_reg_arg(regs, insn->src_reg, SRC_OP);
			if (err)
				return err;
			/* check src2 operand */
			err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
			if (err)
				return err;

			dst_reg_type = regs[insn->dst_reg].type;

			/* check that memory (dst_reg + off) is writeable */
			err = check_mem_access(env, insn->dst_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_WRITE,
					       insn->src_reg);
			if (err)
				return err;

			prev_dst_type = &env->insn_aux_data[insn_idx].ptr_type;

			if (*prev_dst_type == NOT_INIT) {
				*prev_dst_type = dst_reg_type;
			} else if (dst_reg_type != *prev_dst_type &&
				   (dst_reg_type == PTR_TO_CTX ||
				    *prev_dst_type == PTR_TO_CTX)) {
				verbose(""same insn cannot be used with different pointers\n"");
				return -EINVAL;
			}

		} else if (class == BPF_ST) {
			if (BPF_MODE(insn->code) != BPF_MEM ||
			    insn->src_reg != BPF_REG_0) {
				verbose(""BPF_ST uses reserved fields\n"");
				return -EINVAL;
			}
			/* check src operand */
			err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
			if (err)
				return err;

			/* check that memory (dst_reg + off) is writeable */
			err = check_mem_access(env, insn->dst_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_WRITE,
					       -1);
			if (err)
				return err;

		} else if (class == BPF_JMP) {
			u8 opcode = BPF_OP(insn->code);

			if (opcode == BPF_CALL) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->off != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_CALL uses reserved fields\n"");
					return -EINVAL;
				}

				err = check_call(env, insn->imm, insn_idx);
				if (err)
					return err;

			} else if (opcode == BPF_JA) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->imm != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_JA uses reserved fields\n"");
					return -EINVAL;
				}

				insn_idx += insn->off + 1;
				continue;

			} else if (opcode == BPF_EXIT) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->imm != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_EXIT uses reserved fields\n"");
					return -EINVAL;
				}

				/* eBPF calling convetion is such that R0 is used
				 * to return the value from eBPF program.
				 * Make sure that it's readable at this time
				 * of bpf_exit, which means that program wrote
				 * something into it earlier
				 */
				err = check_reg_arg(regs, BPF_REG_0, SRC_OP);
				if (err)
					return err;

				if (is_pointer_value(env, BPF_REG_0)) {
					verbose(""R0 leaks addr as return value\n"");
					return -EACCES;
				}

process_bpf_exit:
				insn_idx = pop_stack(env, &prev_insn_idx);
				if (insn_idx < 0) {
					break;
				} else {
					do_print_state = true;
					continue;
				}
			} else {
				err = check_cond_jmp_op(env, insn, &insn_idx);
				if (err)
					return err;
			}
		} else if (class == BPF_LD) {
			u8 mode = BPF_MODE(insn->code);

			if (mode == BPF_ABS || mode == BPF_IND) {
				err = check_ld_abs(env, insn);
				if (err)
					return err;

			} else if (mode == BPF_IMM) {
				err = check_ld_imm(env, insn);
				if (err)
					return err;

				insn_idx++;
			} else {
				verbose(""invalid BPF_LD mode\n"");
				return -EINVAL;
			}
			reset_reg_range_values(regs, insn->dst_reg);
		} else {
			verbose(""unknown insn class %d\n"", class);
			return -EINVAL;
		}

		insn_idx++;
	}

	verbose(""processed %d insns\n"", insn_processed);
	return 0;
}
","The provided code implements a BPF (Berkeley Packet Filter) verifier function that checks the validity of a BPF program's instructions. It iterates through each instruction, validating operations such as arithmetic, memory access, and control flow while ensuring compliance with predefined constraints. The function maintains a state for registers and tracks instruction processing to prevent excessive complexity. It also handles special cases for specific instruction types, such as jumps and calls, and checks for potential errors like using reserved fields or mismatched pointer types. Ultimately, it ensures that the BPF program adheres to safety and correctness standards before execution.","The code implements a verifier for a specific type of program, ensuring that its instructions are valid and safe for execution. It processes each instruction sequentially, checking for compliance with operational rules, such as valid memory access and correct usage of registers. The verifier tracks the state of the program, preventing excessive complexity and identifying equivalent states to optimize processing. It also handles special cases for control flow and ensures that reserved fields are not misused. Ultimately, the function aims to confirm the program's correctness and safety before it can be executed.","The vulnerability in the original code allowed unprivileged users to leak sensitive map addresses through the logging of immediate values in the `ldimm64` instruction, potentially exposing memory addresses that should remain confidential. This was addressed in the fixed code by introducing a check for the `env->allow_ptr_leaks` variable, ensuring that map addresses are only logged if the user has the necessary privileges. Additionally, the fix corrected the logging of `ldimm64` to print the full immediate value instead of just the lower 32 bits, thereby preventing incomplete or misleading information from being logged while maintaining security.","The vulnerability in the original code allowed unprivileged users to inadvertently expose sensitive memory addresses through logging when using specific instructions, potentially leading to security risks. This was particularly concerning as it could reveal internal map addresses that should remain confidential. The fix implemented a check to ensure that such addresses are only logged if the user has the appropriate privileges, defaulting to a safer output for unprivileged users. Additionally, the logging mechanism was corrected to display the complete immediate value for the instruction, rather than just a truncated portion, ensuring accurate and secure logging.","The vulnerability was fixed by introducing a check for the `env->allow_ptr_leaks` variable, which ensures that map addresses are only printed to the log if the user has the necessary privileges. If the user is unprivileged, the code defaults to logging a value of zero, preventing sensitive information from being exposed. Additionally, the logging mechanism for the `ldimm64` instruction was corrected to print the full immediate value instead of just the lower 32 bits, ensuring that the output is both accurate and secure while maintaining compliance with the verification process.","The vulnerability was addressed by implementing a privilege check that restricts the logging of sensitive memory addresses to only those users with the appropriate permissions. For unprivileged users, the code now defaults to logging a safe value, thereby preventing the exposure of confidential information. Additionally, the logging mechanism was improved to ensure that complete and accurate values are printed, rather than truncated or partial data. This dual approach enhances security by safeguarding sensitive information while ensuring that the logging remains informative and reliable for authorized users.","5,5","5,5","4,4","4,4"
77,77,181293,181293,,Local,Not required,,CVE-2017-9150,https://www.cvedetails.com/cve/CVE-2017-9150/,CWE-200,Low,Partial,,,2017-05-22,2.1,"The do_check function in kernel/bpf/verifier.c in the Linux kernel before 4.11.1 does not make the allow_ptr_leaks value available for restricting the output of the print_bpf_insn function, which allows local users to obtain sensitive address information via crafted bpf system calls.",2017-09-08,+Info ,15,https://github.com/torvalds/linux/commit/0d0e57697f162da4aa218b5feafe614fb666db07,0d0e57697f162da4aa218b5feafe614fb666db07,"bpf: don't let ldimm64 leak map addresses on unprivileged

The patch fixes two things at once:

1) It checks the env->allow_ptr_leaks and only prints the map address to
   the log if we have the privileges to do so, otherwise it just dumps 0
   as we would when kptr_restrict is enabled on %pK. Given the latter is
   off by default and not every distro sets it, I don't want to rely on
   this, hence the 0 by default for unprivileged.

2) Printing of ldimm64 in the verifier log is currently broken in that
   we don't print the full immediate, but only the 32 bit part of the
   first insn part for ldimm64. Thus, fix this up as well; it's okay to
   access, since we verified all ldimm64 earlier already (including just
   constants) through replace_map_fd_with_map_ptr().

Fixes: 1be7f75d1668 (""bpf: enable non-root eBPF programs"")
Fixes: cbd357008604 (""bpf: verifier (add ability to receive verification log)"")
Reported-by: Jann Horn <jannh@google.com>
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Acked-by: Alexei Starovoitov <ast@kernel.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",3,kernel/bpf/verifier.c,"{""sha"": ""c5b56c92f8e255d1b13634ad07c460969484f2f4"", ""filename"": ""kernel/bpf/verifier.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 5, ""changes"": 21, ""blob_url"": ""https://github.com/torvalds/linux/blob/0d0e57697f162da4aa218b5feafe614fb666db07/kernel/bpf/verifier.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0d0e57697f162da4aa218b5feafe614fb666db07/kernel/bpf/verifier.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/bpf/verifier.c?ref=0d0e57697f162da4aa218b5feafe614fb666db07"", ""patch"": ""@@ -298,7 +298,8 @@ static const char *const bpf_jmp_string[16] = {\n \t[BPF_EXIT >> 4] = \""exit\"",\n };\n \n-static void print_bpf_insn(struct bpf_insn *insn)\n+static void print_bpf_insn(const struct bpf_verifier_env *env,\n+\t\t\t   const struct bpf_insn *insn)\n {\n \tu8 class = BPF_CLASS(insn->code);\n \n@@ -362,9 +363,19 @@ static void print_bpf_insn(struct bpf_insn *insn)\n \t\t\t\tinsn->code,\n \t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n \t\t\t\tinsn->src_reg, insn->imm);\n-\t\t} else if (BPF_MODE(insn->code) == BPF_IMM) {\n-\t\t\tverbose(\""(%02x) r%d = 0x%x\\n\"",\n-\t\t\t\tinsn->code, insn->dst_reg, insn->imm);\n+\t\t} else if (BPF_MODE(insn->code) == BPF_IMM &&\n+\t\t\t   BPF_SIZE(insn->code) == BPF_DW) {\n+\t\t\t/* At this point, we already made sure that the second\n+\t\t\t * part of the ldimm64 insn is accessible.\n+\t\t\t */\n+\t\t\tu64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;\n+\t\t\tbool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;\n+\n+\t\t\tif (map_ptr && !env->allow_ptr_leaks)\n+\t\t\t\timm = 0;\n+\n+\t\t\tverbose(\""(%02x) r%d = 0x%llx\\n\"", insn->code,\n+\t\t\t\tinsn->dst_reg, (unsigned long long)imm);\n \t\t} else {\n \t\t\tverbose(\""BUG_ld_%02x\\n\"", insn->code);\n \t\t\treturn;\n@@ -2853,7 +2864,7 @@ static int do_check(struct bpf_verifier_env *env)\n \n \t\tif (log_level) {\n \t\t\tverbose(\""%d: \"", insn_idx);\n-\t\t\tprint_bpf_insn(insn);\n+\t\t\tprint_bpf_insn(env, insn);\n \t\t}\n \n \t\terr = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);""}","static void print_bpf_insn(struct bpf_insn *insn)
static void print_bpf_insn(const struct bpf_verifier_env *env,
			   const struct bpf_insn *insn)
 {
 	u8 class = BPF_CLASS(insn->code);
 
	if (class == BPF_ALU || class == BPF_ALU64) {
		if (BPF_SRC(insn->code) == BPF_X)
			verbose(""(%02x) %sr%d %s %sr%d\n"",
				insn->code, class == BPF_ALU ? ""(u32) "" : """",
				insn->dst_reg,
				bpf_alu_string[BPF_OP(insn->code) >> 4],
				class == BPF_ALU ? ""(u32) "" : """",
				insn->src_reg);
		else
			verbose(""(%02x) %sr%d %s %s%d\n"",
				insn->code, class == BPF_ALU ? ""(u32) "" : """",
				insn->dst_reg,
				bpf_alu_string[BPF_OP(insn->code) >> 4],
				class == BPF_ALU ? ""(u32) "" : """",
				insn->imm);
	} else if (class == BPF_STX) {
		if (BPF_MODE(insn->code) == BPF_MEM)
			verbose(""(%02x) *(%s *)(r%d %+d) = r%d\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->dst_reg,
				insn->off, insn->src_reg);
		else if (BPF_MODE(insn->code) == BPF_XADD)
			verbose(""(%02x) lock *(%s *)(r%d %+d) += r%d\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->dst_reg, insn->off,
				insn->src_reg);
		else
			verbose(""BUG_%02x\n"", insn->code);
	} else if (class == BPF_ST) {
		if (BPF_MODE(insn->code) != BPF_MEM) {
			verbose(""BUG_st_%02x\n"", insn->code);
			return;
		}
		verbose(""(%02x) *(%s *)(r%d %+d) = %d\n"",
			insn->code,
			bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
			insn->dst_reg,
			insn->off, insn->imm);
	} else if (class == BPF_LDX) {
		if (BPF_MODE(insn->code) != BPF_MEM) {
			verbose(""BUG_ldx_%02x\n"", insn->code);
			return;
		}
		verbose(""(%02x) r%d = *(%s *)(r%d %+d)\n"",
			insn->code, insn->dst_reg,
			bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
			insn->src_reg, insn->off);
	} else if (class == BPF_LD) {
		if (BPF_MODE(insn->code) == BPF_ABS) {
			verbose(""(%02x) r0 = *(%s *)skb[%d]\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->imm);
		} else if (BPF_MODE(insn->code) == BPF_IND) {
			verbose(""(%02x) r0 = *(%s *)skb[r%d + %d]\n"",
 				insn->code,
 				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
 				insn->src_reg, insn->imm);
		} else if (BPF_MODE(insn->code) == BPF_IMM &&
			   BPF_SIZE(insn->code) == BPF_DW) {
			/* At this point, we already made sure that the second
			 * part of the ldimm64 insn is accessible.
			 */
			u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;
			bool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;

			if (map_ptr && !env->allow_ptr_leaks)
				imm = 0;

			verbose(""(%02x) r%d = 0x%llx\n"", insn->code,
				insn->dst_reg, (unsigned long long)imm);
 		} else {
 			verbose(""BUG_ld_%02x\n"", insn->code);
 			return;
		}
	} else if (class == BPF_JMP) {
		u8 opcode = BPF_OP(insn->code);

		if (opcode == BPF_CALL) {
			verbose(""(%02x) call %s#%d\n"", insn->code,
				func_id_name(insn->imm), insn->imm);
		} else if (insn->code == (BPF_JMP | BPF_JA)) {
			verbose(""(%02x) goto pc%+d\n"",
				insn->code, insn->off);
		} else if (insn->code == (BPF_JMP | BPF_EXIT)) {
			verbose(""(%02x) exit\n"", insn->code);
		} else if (BPF_SRC(insn->code) == BPF_X) {
			verbose(""(%02x) if r%d %s r%d goto pc%+d\n"",
				insn->code, insn->dst_reg,
				bpf_jmp_string[BPF_OP(insn->code) >> 4],
				insn->src_reg, insn->off);
		} else {
			verbose(""(%02x) if r%d %s 0x%x goto pc%+d\n"",
				insn->code, insn->dst_reg,
				bpf_jmp_string[BPF_OP(insn->code) >> 4],
				insn->imm, insn->off);
		}
	} else {
		verbose(""(%02x) %s\n"", insn->code, bpf_class_string[class]);
	}
}
","static void print_bpf_insn(struct bpf_insn *insn)
 {
 	u8 class = BPF_CLASS(insn->code);
 
	if (class == BPF_ALU || class == BPF_ALU64) {
		if (BPF_SRC(insn->code) == BPF_X)
			verbose(""(%02x) %sr%d %s %sr%d\n"",
				insn->code, class == BPF_ALU ? ""(u32) "" : """",
				insn->dst_reg,
				bpf_alu_string[BPF_OP(insn->code) >> 4],
				class == BPF_ALU ? ""(u32) "" : """",
				insn->src_reg);
		else
			verbose(""(%02x) %sr%d %s %s%d\n"",
				insn->code, class == BPF_ALU ? ""(u32) "" : """",
				insn->dst_reg,
				bpf_alu_string[BPF_OP(insn->code) >> 4],
				class == BPF_ALU ? ""(u32) "" : """",
				insn->imm);
	} else if (class == BPF_STX) {
		if (BPF_MODE(insn->code) == BPF_MEM)
			verbose(""(%02x) *(%s *)(r%d %+d) = r%d\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->dst_reg,
				insn->off, insn->src_reg);
		else if (BPF_MODE(insn->code) == BPF_XADD)
			verbose(""(%02x) lock *(%s *)(r%d %+d) += r%d\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->dst_reg, insn->off,
				insn->src_reg);
		else
			verbose(""BUG_%02x\n"", insn->code);
	} else if (class == BPF_ST) {
		if (BPF_MODE(insn->code) != BPF_MEM) {
			verbose(""BUG_st_%02x\n"", insn->code);
			return;
		}
		verbose(""(%02x) *(%s *)(r%d %+d) = %d\n"",
			insn->code,
			bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
			insn->dst_reg,
			insn->off, insn->imm);
	} else if (class == BPF_LDX) {
		if (BPF_MODE(insn->code) != BPF_MEM) {
			verbose(""BUG_ldx_%02x\n"", insn->code);
			return;
		}
		verbose(""(%02x) r%d = *(%s *)(r%d %+d)\n"",
			insn->code, insn->dst_reg,
			bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
			insn->src_reg, insn->off);
	} else if (class == BPF_LD) {
		if (BPF_MODE(insn->code) == BPF_ABS) {
			verbose(""(%02x) r0 = *(%s *)skb[%d]\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->imm);
		} else if (BPF_MODE(insn->code) == BPF_IND) {
			verbose(""(%02x) r0 = *(%s *)skb[r%d + %d]\n"",
 				insn->code,
 				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
 				insn->src_reg, insn->imm);
		} else if (BPF_MODE(insn->code) == BPF_IMM) {
			verbose(""(%02x) r%d = 0x%x\n"",
				insn->code, insn->dst_reg, insn->imm);
 		} else {
 			verbose(""BUG_ld_%02x\n"", insn->code);
 			return;
		}
	} else if (class == BPF_JMP) {
		u8 opcode = BPF_OP(insn->code);

		if (opcode == BPF_CALL) {
			verbose(""(%02x) call %s#%d\n"", insn->code,
				func_id_name(insn->imm), insn->imm);
		} else if (insn->code == (BPF_JMP | BPF_JA)) {
			verbose(""(%02x) goto pc%+d\n"",
				insn->code, insn->off);
		} else if (insn->code == (BPF_JMP | BPF_EXIT)) {
			verbose(""(%02x) exit\n"", insn->code);
		} else if (BPF_SRC(insn->code) == BPF_X) {
			verbose(""(%02x) if r%d %s r%d goto pc%+d\n"",
				insn->code, insn->dst_reg,
				bpf_jmp_string[BPF_OP(insn->code) >> 4],
				insn->src_reg, insn->off);
		} else {
			verbose(""(%02x) if r%d %s 0x%x goto pc%+d\n"",
				insn->code, insn->dst_reg,
				bpf_jmp_string[BPF_OP(insn->code) >> 4],
				insn->imm, insn->off);
		}
	} else {
		verbose(""(%02x) %s\n"", insn->code, bpf_class_string[class]);
	}
}
",C,"static void print_bpf_insn(const struct bpf_verifier_env *env,
			   const struct bpf_insn *insn)
		} else if (BPF_MODE(insn->code) == BPF_IMM &&
			   BPF_SIZE(insn->code) == BPF_DW) {
			/* At this point, we already made sure that the second
			 * part of the ldimm64 insn is accessible.
			 */
			u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;
			bool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;

			if (map_ptr && !env->allow_ptr_leaks)
				imm = 0;

			verbose(""(%02x) r%d = 0x%llx\n"", insn->code,
				insn->dst_reg, (unsigned long long)imm);
","		} else if (BPF_MODE(insn->code) == BPF_IMM) {
			verbose(""(%02x) r%d = 0x%x\n"",
				insn->code, insn->dst_reg, insn->imm);
",,"@@ -298,7 +298,8 @@ static const char *const bpf_jmp_string[16] = {
 	[BPF_EXIT >> 4] = ""exit"",
 };
 
-static void print_bpf_insn(struct bpf_insn *insn)
+static void print_bpf_insn(const struct bpf_verifier_env *env,
+			   const struct bpf_insn *insn)
 {
 	u8 class = BPF_CLASS(insn->code);
 
@@ -362,9 +363,19 @@ static void print_bpf_insn(struct bpf_insn *insn)
 				insn->code,
 				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
 				insn->src_reg, insn->imm);
-		} else if (BPF_MODE(insn->code) == BPF_IMM) {
-			verbose(""(%02x) r%d = 0x%x\n"",
-				insn->code, insn->dst_reg, insn->imm);
+		} else if (BPF_MODE(insn->code) == BPF_IMM &&
+			   BPF_SIZE(insn->code) == BPF_DW) {
+			/* At this point, we already made sure that the second
+			 * part of the ldimm64 insn is accessible.
+			 */
+			u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;
+			bool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;
+
+			if (map_ptr && !env->allow_ptr_leaks)
+				imm = 0;
+
+			verbose(""(%02x) r%d = 0x%llx\n"", insn->code,
+				insn->dst_reg, (unsigned long long)imm);
 		} else {
 			verbose(""BUG_ld_%02x\n"", insn->code);
 			return;
@@ -2853,7 +2864,7 @@ static int do_check(struct bpf_verifier_env *env)
 
 		if (log_level) {
 			verbose(""%d: "", insn_idx);
-			print_bpf_insn(insn);
+			print_bpf_insn(env, insn);
 		}
 
 		err = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);",linux,0d0e57697f162da4aa218b5feafe614fb666db07,871ff2ebe0af0d7f1050bfc8bce62fddea2b12ec,1,"static void print_bpf_insn(struct bpf_insn *insn)
//fix_flaw_line_below:
//static void print_bpf_insn(const struct bpf_verifier_env *env,
//fix_flaw_line_below:
//			   const struct bpf_insn *insn)
 {
 	u8 class = BPF_CLASS(insn->code);
 
	if (class == BPF_ALU || class == BPF_ALU64) {
		if (BPF_SRC(insn->code) == BPF_X)
			verbose(""(%02x) %sr%d %s %sr%d\n"",
				insn->code, class == BPF_ALU ? ""(u32) "" : """",
				insn->dst_reg,
				bpf_alu_string[BPF_OP(insn->code) >> 4],
				class == BPF_ALU ? ""(u32) "" : """",
				insn->src_reg);
		else
			verbose(""(%02x) %sr%d %s %s%d\n"",
				insn->code, class == BPF_ALU ? ""(u32) "" : """",
				insn->dst_reg,
				bpf_alu_string[BPF_OP(insn->code) >> 4],
				class == BPF_ALU ? ""(u32) "" : """",
				insn->imm);
	} else if (class == BPF_STX) {
		if (BPF_MODE(insn->code) == BPF_MEM)
			verbose(""(%02x) *(%s *)(r%d %+d) = r%d\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->dst_reg,
				insn->off, insn->src_reg);
		else if (BPF_MODE(insn->code) == BPF_XADD)
			verbose(""(%02x) lock *(%s *)(r%d %+d) += r%d\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->dst_reg, insn->off,
				insn->src_reg);
		else
			verbose(""BUG_%02x\n"", insn->code);
	} else if (class == BPF_ST) {
		if (BPF_MODE(insn->code) != BPF_MEM) {
			verbose(""BUG_st_%02x\n"", insn->code);
			return;
		}
		verbose(""(%02x) *(%s *)(r%d %+d) = %d\n"",
			insn->code,
			bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
			insn->dst_reg,
			insn->off, insn->imm);
	} else if (class == BPF_LDX) {
		if (BPF_MODE(insn->code) != BPF_MEM) {
			verbose(""BUG_ldx_%02x\n"", insn->code);
			return;
		}
		verbose(""(%02x) r%d = *(%s *)(r%d %+d)\n"",
			insn->code, insn->dst_reg,
			bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
			insn->src_reg, insn->off);
	} else if (class == BPF_LD) {
		if (BPF_MODE(insn->code) == BPF_ABS) {
			verbose(""(%02x) r0 = *(%s *)skb[%d]\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->imm);
		} else if (BPF_MODE(insn->code) == BPF_IND) {
			verbose(""(%02x) r0 = *(%s *)skb[r%d + %d]\n"",
 				insn->code,
 				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
 				insn->src_reg, insn->imm);
//flaw_line_below:
		} else if (BPF_MODE(insn->code) == BPF_IMM) {
//flaw_line_below:
			verbose(""(%02x) r%d = 0x%x\n"",
//flaw_line_below:
				insn->code, insn->dst_reg, insn->imm);
//fix_flaw_line_below:
//		} else if (BPF_MODE(insn->code) == BPF_IMM &&
//fix_flaw_line_below:
//			   BPF_SIZE(insn->code) == BPF_DW) {
//fix_flaw_line_below:
//			/* At this point, we already made sure that the second
//fix_flaw_line_below:
//			 * part of the ldimm64 insn is accessible.
//fix_flaw_line_below:
//			 */
//fix_flaw_line_below:
//			u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;
//fix_flaw_line_below:
//			bool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//			if (map_ptr && !env->allow_ptr_leaks)
//fix_flaw_line_below:
//				imm = 0;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//			verbose(""(%02x) r%d = 0x%llx\n"", insn->code,
//fix_flaw_line_below:
//				insn->dst_reg, (unsigned long long)imm);
 		} else {
 			verbose(""BUG_ld_%02x\n"", insn->code);
 			return;
		}
	} else if (class == BPF_JMP) {
		u8 opcode = BPF_OP(insn->code);

		if (opcode == BPF_CALL) {
			verbose(""(%02x) call %s#%d\n"", insn->code,
				func_id_name(insn->imm), insn->imm);
		} else if (insn->code == (BPF_JMP | BPF_JA)) {
			verbose(""(%02x) goto pc%+d\n"",
				insn->code, insn->off);
		} else if (insn->code == (BPF_JMP | BPF_EXIT)) {
			verbose(""(%02x) exit\n"", insn->code);
		} else if (BPF_SRC(insn->code) == BPF_X) {
			verbose(""(%02x) if r%d %s r%d goto pc%+d\n"",
				insn->code, insn->dst_reg,
				bpf_jmp_string[BPF_OP(insn->code) >> 4],
				insn->src_reg, insn->off);
		} else {
			verbose(""(%02x) if r%d %s 0x%x goto pc%+d\n"",
				insn->code, insn->dst_reg,
				bpf_jmp_string[BPF_OP(insn->code) >> 4],
				insn->imm, insn->off);
		}
	} else {
		verbose(""(%02x) %s\n"", insn->code, bpf_class_string[class]);
	}
}
",181293,"static void print_bpf_insn(struct bpf_insn *insn)
 {
 	u8 class = BPF_CLASS(insn->code);
 
	if (class == BPF_ALU || class == BPF_ALU64) {
		if (BPF_SRC(insn->code) == BPF_X)
			verbose(""(%02x) %sr%d %s %sr%d\n"",
				insn->code, class == BPF_ALU ? ""(u32) "" : """",
				insn->dst_reg,
				bpf_alu_string[BPF_OP(insn->code) >> 4],
				class == BPF_ALU ? ""(u32) "" : """",
				insn->src_reg);
		else
			verbose(""(%02x) %sr%d %s %s%d\n"",
				insn->code, class == BPF_ALU ? ""(u32) "" : """",
				insn->dst_reg,
				bpf_alu_string[BPF_OP(insn->code) >> 4],
				class == BPF_ALU ? ""(u32) "" : """",
				insn->imm);
	} else if (class == BPF_STX) {
		if (BPF_MODE(insn->code) == BPF_MEM)
			verbose(""(%02x) *(%s *)(r%d %+d) = r%d\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->dst_reg,
				insn->off, insn->src_reg);
		else if (BPF_MODE(insn->code) == BPF_XADD)
			verbose(""(%02x) lock *(%s *)(r%d %+d) += r%d\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->dst_reg, insn->off,
				insn->src_reg);
		else
			verbose(""BUG_%02x\n"", insn->code);
	} else if (class == BPF_ST) {
		if (BPF_MODE(insn->code) != BPF_MEM) {
			verbose(""BUG_st_%02x\n"", insn->code);
			return;
		}
		verbose(""(%02x) *(%s *)(r%d %+d) = %d\n"",
			insn->code,
			bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
			insn->dst_reg,
			insn->off, insn->imm);
	} else if (class == BPF_LDX) {
		if (BPF_MODE(insn->code) != BPF_MEM) {
			verbose(""BUG_ldx_%02x\n"", insn->code);
			return;
		}
		verbose(""(%02x) r%d = *(%s *)(r%d %+d)\n"",
			insn->code, insn->dst_reg,
			bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
			insn->src_reg, insn->off);
	} else if (class == BPF_LD) {
		if (BPF_MODE(insn->code) == BPF_ABS) {
			verbose(""(%02x) r0 = *(%s *)skb[%d]\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->imm);
		} else if (BPF_MODE(insn->code) == BPF_IND) {
			verbose(""(%02x) r0 = *(%s *)skb[r%d + %d]\n"",
 				insn->code,
 				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
 				insn->src_reg, insn->imm);
		} else if (BPF_MODE(insn->code) == BPF_IMM) {
			verbose(""(%02x) r%d = 0x%x\n"",
				insn->code, insn->dst_reg, insn->imm);
 		} else {
 			verbose(""BUG_ld_%02x\n"", insn->code);
 			return;
		}
	} else if (class == BPF_JMP) {
		u8 opcode = BPF_OP(insn->code);

		if (opcode == BPF_CALL) {
			verbose(""(%02x) call %s#%d\n"", insn->code,
				func_id_name(insn->imm), insn->imm);
		} else if (insn->code == (BPF_JMP | BPF_JA)) {
			verbose(""(%02x) goto pc%+d\n"",
				insn->code, insn->off);
		} else if (insn->code == (BPF_JMP | BPF_EXIT)) {
			verbose(""(%02x) exit\n"", insn->code);
		} else if (BPF_SRC(insn->code) == BPF_X) {
			verbose(""(%02x) if r%d %s r%d goto pc%+d\n"",
				insn->code, insn->dst_reg,
				bpf_jmp_string[BPF_OP(insn->code) >> 4],
				insn->src_reg, insn->off);
		} else {
			verbose(""(%02x) if r%d %s 0x%x goto pc%+d\n"",
				insn->code, insn->dst_reg,
				bpf_jmp_string[BPF_OP(insn->code) >> 4],
				insn->imm, insn->off);
		}
	} else {
		verbose(""(%02x) %s\n"", insn->code, bpf_class_string[class]);
	}
}
","static void print_bpf_insn(struct bpf_insn *insn)
static void print_bpf_insn(const struct bpf_verifier_env *env,
			   const struct bpf_insn *insn)
 {
 	u8 class = BPF_CLASS(insn->code);
 
	if (class == BPF_ALU || class == BPF_ALU64) {
		if (BPF_SRC(insn->code) == BPF_X)
			verbose(""(%02x) %sr%d %s %sr%d\n"",
				insn->code, class == BPF_ALU ? ""(u32) "" : """",
				insn->dst_reg,
				bpf_alu_string[BPF_OP(insn->code) >> 4],
				class == BPF_ALU ? ""(u32) "" : """",
				insn->src_reg);
		else
			verbose(""(%02x) %sr%d %s %s%d\n"",
				insn->code, class == BPF_ALU ? ""(u32) "" : """",
				insn->dst_reg,
				bpf_alu_string[BPF_OP(insn->code) >> 4],
				class == BPF_ALU ? ""(u32) "" : """",
				insn->imm);
	} else if (class == BPF_STX) {
		if (BPF_MODE(insn->code) == BPF_MEM)
			verbose(""(%02x) *(%s *)(r%d %+d) = r%d\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->dst_reg,
				insn->off, insn->src_reg);
		else if (BPF_MODE(insn->code) == BPF_XADD)
			verbose(""(%02x) lock *(%s *)(r%d %+d) += r%d\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->dst_reg, insn->off,
				insn->src_reg);
		else
			verbose(""BUG_%02x\n"", insn->code);
	} else if (class == BPF_ST) {
		if (BPF_MODE(insn->code) != BPF_MEM) {
			verbose(""BUG_st_%02x\n"", insn->code);
			return;
		}
		verbose(""(%02x) *(%s *)(r%d %+d) = %d\n"",
			insn->code,
			bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
			insn->dst_reg,
			insn->off, insn->imm);
	} else if (class == BPF_LDX) {
		if (BPF_MODE(insn->code) != BPF_MEM) {
			verbose(""BUG_ldx_%02x\n"", insn->code);
			return;
		}
		verbose(""(%02x) r%d = *(%s *)(r%d %+d)\n"",
			insn->code, insn->dst_reg,
			bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
			insn->src_reg, insn->off);
	} else if (class == BPF_LD) {
		if (BPF_MODE(insn->code) == BPF_ABS) {
			verbose(""(%02x) r0 = *(%s *)skb[%d]\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->imm);
		} else if (BPF_MODE(insn->code) == BPF_IND) {
			verbose(""(%02x) r0 = *(%s *)skb[r%d + %d]\n"",
 				insn->code,
 				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
 				insn->src_reg, insn->imm);
		} else if (BPF_MODE(insn->code) == BPF_IMM &&
			   BPF_SIZE(insn->code) == BPF_DW) {
			/* At this point, we already made sure that the second
			 * part of the ldimm64 insn is accessible.
			 */
			u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;
			bool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;

			if (map_ptr && !env->allow_ptr_leaks)
				imm = 0;

			verbose(""(%02x) r%d = 0x%llx\n"", insn->code,
				insn->dst_reg, (unsigned long long)imm);
 		} else {
 			verbose(""BUG_ld_%02x\n"", insn->code);
 			return;
		}
	} else if (class == BPF_JMP) {
		u8 opcode = BPF_OP(insn->code);

		if (opcode == BPF_CALL) {
			verbose(""(%02x) call %s#%d\n"", insn->code,
				func_id_name(insn->imm), insn->imm);
		} else if (insn->code == (BPF_JMP | BPF_JA)) {
			verbose(""(%02x) goto pc%+d\n"",
				insn->code, insn->off);
		} else if (insn->code == (BPF_JMP | BPF_EXIT)) {
			verbose(""(%02x) exit\n"", insn->code);
		} else if (BPF_SRC(insn->code) == BPF_X) {
			verbose(""(%02x) if r%d %s r%d goto pc%+d\n"",
				insn->code, insn->dst_reg,
				bpf_jmp_string[BPF_OP(insn->code) >> 4],
				insn->src_reg, insn->off);
		} else {
			verbose(""(%02x) if r%d %s 0x%x goto pc%+d\n"",
				insn->code, insn->dst_reg,
				bpf_jmp_string[BPF_OP(insn->code) >> 4],
				insn->imm, insn->off);
		}
	} else {
		verbose(""(%02x) %s\n"", insn->code, bpf_class_string[class]);
	}
}
","The `print_bpf_insn` function interprets and prints the details of a BPF (Berkeley Packet Filter) instruction based on its type and operation code. It first determines the instruction class (e.g., ALU, STX, ST, LDX, LD, JMP) and then formats the output accordingly, using the `verbose` function to display the instruction's code, destination and source registers, immediate values, and offsets. The function handles various cases, including arithmetic operations, memory accesses, and jumps, while also checking for potential errors in instruction modes. This comprehensive output aids in debugging and understanding BPF instructions.","The provided code defines a function that interprets and displays the details of a specific type of instruction used in packet filtering. It categorizes the instruction based on its operation type, such as arithmetic, memory access, or control flow, and formats the output to show relevant information, including registers, immediate values, and offsets. The function also includes error handling for unexpected instruction modes. By generating a detailed textual representation of the instruction, it aids in understanding and debugging the behavior of the packet filtering mechanism.","The vulnerability in the original code allowed unprivileged users to leak sensitive map addresses when using the `ldimm64` instruction, potentially exposing memory addresses that should remain confidential. This occurred because the code printed the map address without checking the privilege level of the user. The fix introduced a check for `env->allow_ptr_leaks`, ensuring that map addresses are only printed if the user has the necessary privileges; otherwise, it outputs a default value of zero. Additionally, the fix corrected the printing of the full immediate value for `ldimm64`, which was previously incomplete, ensuring accurate logging of the instruction.","The vulnerability in the original code allowed unprivileged users to inadvertently expose sensitive memory addresses associated with maps when using a specific instruction, which could lead to security risks. This occurred because the code printed these addresses without verifying the user's privilege level. The fix implemented a check to ensure that addresses are only logged if the user has the appropriate permissions; otherwise, a default value is printed to prevent leakage. Additionally, the fix corrected the logging of a specific instruction to ensure that the complete immediate value is printed, addressing a previous oversight in the output.","The vulnerability was fixed by introducing a check for the `env->allow_ptr_leaks` variable, which determines whether the user has the necessary privileges to view sensitive map addresses. If the user lacks the required permissions, the code now outputs a default value of zero instead of the actual address, preventing potential leaks. Additionally, the fix corrected the logging of the `ldimm64` instruction by ensuring that both parts of the immediate value are printed correctly, rather than just the 32-bit portion from the first instruction part, thereby providing accurate and complete information in the logs.","The vulnerability was addressed by implementing a privilege check that restricts the logging of sensitive memory addresses to users with the appropriate permissions. If a user lacks the necessary privileges, the code now outputs a default value instead of the actual address, effectively preventing any potential leaks of sensitive information. Additionally, the fix improved the logging of a specific instruction by ensuring that the complete immediate value is printed, rather than just a portion, thus providing accurate and comprehensive information in the logs while maintaining security.","4,4","5,5","4,4","5,5"
78,78,181298,181298,,Remote,Not required,,CVE-2017-9098,https://www.cvedetails.com/cve/CVE-2017-9098/,CWE-200,Low,Partial,,,2017-05-19,5.0,"ImageMagick before 7.0.5-2 and GraphicsMagick before 1.3.24 use uninitialized memory in the RLE decoder, allowing an attacker to leak sensitive information from process memory space, as demonstrated by remote attacks against ImageMagick code in a long-running server process that converts image data on behalf of multiple users. This is caused by a missing initialization step in the ReadRLEImage function in coders/rle.c.",2018-08-03,+Info ,1,https://github.com/ImageMagick/ImageMagick/commit/1c358ffe0049f768dd49a8a889c1cbf99ac9849b,1c358ffe0049f768dd49a8a889c1cbf99ac9849b,Reset memory for RLE decoder (patch provided by scarybeasts),0,coders/rle.c,"{""sha"": ""2318901ec4945da136b7afb6289206a42798ca18"", ""filename"": ""coders/rle.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/1c358ffe0049f768dd49a8a889c1cbf99ac9849b/coders/rle.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/1c358ffe0049f768dd49a8a889c1cbf99ac9849b/coders/rle.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/rle.c?ref=1c358ffe0049f768dd49a8a889c1cbf99ac9849b"", ""patch"": ""@@ -328,6 +328,7 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     pixel_info_length=image->columns*image->rows*\n       MagickMax(number_planes_filled,4);\n     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n+    (void) ResetMagickMemory(pixels,0,pixel_info_length);\n     if ((flags & 0x01) && !(flags & 0x02))\n       {\n         ssize_t""}","static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define SkipLinesOp  0x01
#define SetColorOp  0x02
#define SkipPixelsOp  0x03
#define ByteDataOp  0x05
#define RunDataOp  0x06
#define EOFOp  0x07

  char
    magick[12];

  Image
    *image;

  int
    opcode,
    operand,
    status;

  MagickStatusType
    flags;

  MagickSizeType
    number_pixels;

  MemoryInfo
    *pixel_info;

  Quantum
    index;

  register ssize_t
    x;

  register Quantum
    *q;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    bits_per_pixel,
    map_length,
    number_colormaps,
    number_planes,
    number_planes_filled,
    one,
    pixel_info_length;

  ssize_t
    count,
    offset,
    y;

  unsigned char
    background_color[256],
    *colormap,
    pixel,
    plane,
    *pixels;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  /*
    Determine if this a RLE file.
  */
  count=ReadBlob(image,2,(unsigned char *) magick);
  if ((count != 2) || (memcmp(magick,""\122\314"",2) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  do
  {
    /*
      Read image header.
    */
    image->page.x=ReadBlobLSBShort(image);
    image->page.y=ReadBlobLSBShort(image);
    image->columns=ReadBlobLSBShort(image);
    image->rows=ReadBlobLSBShort(image);
    flags=(MagickStatusType) ReadBlobByte(image);
    image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;
    number_planes=(size_t) ReadBlobByte(image);
    bits_per_pixel=(size_t) ReadBlobByte(image);
    number_colormaps=(size_t) ReadBlobByte(image);
    map_length=(unsigned char) ReadBlobByte(image);
    if (map_length >= 22)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    one=1;
    map_length=one << map_length;
    if ((number_planes == 0) || (number_planes == 2) ||
        ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||
        (image->columns == 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if (flags & 0x02)
      {
        /*
          No background color-- initialize to black.
        */
        for (i=0; i < (ssize_t) number_planes; i++)
          background_color[i]=0;
        (void) ReadBlobByte(image);
      }
    else
      {
        /*
          Initialize background color.
        */
        p=background_color;
        for (i=0; i < (ssize_t) number_planes; i++)
          *p++=(unsigned char) ReadBlobByte(image);
      }
    if ((number_planes & 0x01) == 0)
      (void) ReadBlobByte(image);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    colormap=(unsigned char *) NULL;
    if (number_colormaps != 0)
      {
        /*
          Read image colormaps.
        */
        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,
          3*map_length*sizeof(*colormap));
        if (colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        p=colormap;
        for (i=0; i < (ssize_t) number_colormaps; i++)
          for (x=0; x < (ssize_t) map_length; x++)
            *p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));
      }
    if ((flags & 0x08) != 0)
      {
        char
          *comment;

        size_t
          length;

        /*
          Read image comment.
        */
        length=ReadBlobLSBShort(image);
        if (length != 0)
          {
            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));
            if (comment == (char *) NULL)
              ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
            count=ReadBlob(image,length-1,(unsigned char *) comment);
            comment[length-1]='\0';
            (void) SetImageProperty(image,""comment"",comment,exception);
            comment=DestroyString(comment);
            if ((length & 0x01) == 0)
              (void) ReadBlobByte(image);
          }
      }
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    /*
      Allocate RLE pixels.
    */
    if (image->alpha_trait != UndefinedPixelTrait)
      number_planes++;
    number_pixels=(MagickSizeType) image->columns*image->rows;
    number_planes_filled=(number_planes % 2 == 0) ? number_planes :
      number_planes+1;
    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*
         number_planes_filled))
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    pixel_info=AcquireVirtualMemory(image->columns,image->rows*
      MagickMax(number_planes_filled,4)*sizeof(*pixels));
    if (pixel_info == (MemoryInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     pixel_info_length=image->columns*image->rows*
       MagickMax(number_planes_filled,4);
     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
    (void) ResetMagickMemory(pixels,0,pixel_info_length);
     if ((flags & 0x01) && !(flags & 0x02))
       {
         ssize_t
          j;

        /*
          Set background color.
        */
        p=pixels;
        for (i=0; i < (ssize_t) number_pixels; i++)
        {
          if (image->alpha_trait == UndefinedPixelTrait)
            for (j=0; j < (ssize_t) number_planes; j++)
              *p++=background_color[j];
          else
            {
              for (j=0; j < (ssize_t) (number_planes-1); j++)
                *p++=background_color[j];
              *p++=0;  /* initialize matte channel */
            }
        }
      }
    /*
      Read runlength-encoded image.
    */
    plane=0;
    x=0;
    y=0;
    opcode=ReadBlobByte(image);
    do
    {
      switch (opcode & 0x3f)
      {
        case SkipLinesOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          x=0;
          y+=operand;
          break;
        }
        case SetColorOp:
        {
          operand=ReadBlobByte(image);
          plane=(unsigned char) operand;
          if (plane == 255)
            plane=(unsigned char) (number_planes-1);
          x=0;
          break;
        }
        case SkipPixelsOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          x+=operand;
          break;
        }
        case ByteDataOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          offset=((image->rows-y-1)*image->columns*number_planes)+x*
            number_planes+plane;
          operand++;
          if ((offset < 0) ||
              (offset+((size_t) operand*number_planes) > pixel_info_length))
            {
              if (number_colormaps != 0)
                colormap=(unsigned char *) RelinquishMagickMemory(colormap);
              pixel_info=RelinquishVirtualMemory(pixel_info);
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            }
          p=pixels+offset;
          for (i=0; i < (ssize_t) operand; i++)
          {
            pixel=(unsigned char) ReadBlobByte(image);
            if ((y < (ssize_t) image->rows) &&
                ((x+i) < (ssize_t) image->columns))
              *p=pixel;
            p+=number_planes;
          }
          if (operand & 0x01)
            (void) ReadBlobByte(image);
          x+=operand;
          break;
        }
        case RunDataOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          pixel=(unsigned char) ReadBlobByte(image);
          (void) ReadBlobByte(image);
          offset=((image->rows-y-1)*image->columns*number_planes)+x*
            number_planes+plane;
          operand++;
          if ((offset < 0) ||
              (offset+((size_t) operand*number_planes) > pixel_info_length))
            {
              if (number_colormaps != 0)
                colormap=(unsigned char *) RelinquishMagickMemory(colormap);
              pixel_info=RelinquishVirtualMemory(pixel_info);
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            }
          p=pixels+offset;
          for (i=0; i < (ssize_t) operand; i++)
          {
            if ((y < (ssize_t) image->rows) &&
                ((x+i) < (ssize_t) image->columns))
              *p=pixel;
            p+=number_planes;
          }
          x+=operand;
          break;
        }
        default:
          break;
      }
      opcode=ReadBlobByte(image);
    } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));
    if (number_colormaps != 0)
      {
        MagickStatusType
          mask;

        /*
          Apply colormap affineation to image.
        */
        mask=(MagickStatusType) (map_length-1);
        p=pixels;
        x=(ssize_t) number_planes;
        if (number_colormaps == 1)
          for (i=0; i < (ssize_t) number_pixels; i++)
          {
            ValidateColormapValue(image,*p & mask,&index,exception);
            *p=colormap[(ssize_t) index];
            p++;
          }
        else
          if ((number_planes >= 3) && (number_colormaps >= 3))
            for (i=0; i < (ssize_t) number_pixels; i++)
              for (x=0; x < (ssize_t) number_planes; x++)
              {
                ValidateColormapValue(image,(size_t) (x*map_length+
                    (*p & mask)),&index,exception);
                *p=colormap[(ssize_t) index];
                p++;
              }
        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))
          {
            colormap=(unsigned char *) RelinquishMagickMemory(colormap);
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
          }
      }
    /*
      Initialize image structure.
    */
    if (number_planes >= 3)
      {
        /*
          Convert raster image to DirectClass pixel packets.
        */
        p=pixels;
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(image,ScaleCharToQuantum(*p++),q);
            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
            if (image->alpha_trait != UndefinedPixelTrait)
              SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      }
    else
      {
        /*
          Create colormap.
        */
        if (number_colormaps == 0)
          map_length=256;
        if (AcquireImageColormap(image,map_length,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        p=colormap;
        if (number_colormaps == 1)
          for (i=0; i < (ssize_t) image->colors; i++)
          {
            /*
              Pseudocolor.
            */
            image->colormap[i].red=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
            image->colormap[i].green=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
            image->colormap[i].blue=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
          }
        else
          if (number_colormaps > 1)
            for (i=0; i < (ssize_t) image->colors; i++)
            {
              image->colormap[i].red=(MagickRealType)
                ScaleCharToQuantum(*p);
              image->colormap[i].green=(MagickRealType)
                ScaleCharToQuantum(*(p+map_length));
              image->colormap[i].blue=(MagickRealType)
                ScaleCharToQuantum(*(p+map_length*2));
              p++;
            }
        p=pixels;
        if (image->alpha_trait == UndefinedPixelTrait)
          {
            /*
              Convert raster image to PseudoClass pixel packets.
            */
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                SetPixelIndex(image,*p++,q);
                q+=GetPixelChannels(image);
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
            (void) SyncImage(image,exception);
          }
        else
          {
            /*
              Image has a matte channel-- promote to DirectClass.
            */
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);
                SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].red),q);
                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);
                SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].green),q);
                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);
                SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].blue),q);
                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
                q+=GetPixelChannels(image);
              }
              if (x < (ssize_t) image->columns)
                break;
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
            image->colormap=(PixelInfo *) RelinquishMagickMemory(
              image->colormap);
            image->storage_class=DirectClass;
            image->colors=0;
          }
      }
    if (number_colormaps != 0)
      colormap=(unsigned char *) RelinquishMagickMemory(colormap);
    pixel_info=RelinquishVirtualMemory(pixel_info);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    (void) ReadBlobByte(image);
    count=ReadBlob(image,2,(unsigned char *) magick);
    if ((count != 0) && (memcmp(magick,""\122\314"",2) == 0))
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while ((count != 0) && (memcmp(magick,""\122\314"",2) == 0));
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define SkipLinesOp  0x01
#define SetColorOp  0x02
#define SkipPixelsOp  0x03
#define ByteDataOp  0x05
#define RunDataOp  0x06
#define EOFOp  0x07

  char
    magick[12];

  Image
    *image;

  int
    opcode,
    operand,
    status;

  MagickStatusType
    flags;

  MagickSizeType
    number_pixels;

  MemoryInfo
    *pixel_info;

  Quantum
    index;

  register ssize_t
    x;

  register Quantum
    *q;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    bits_per_pixel,
    map_length,
    number_colormaps,
    number_planes,
    number_planes_filled,
    one,
    pixel_info_length;

  ssize_t
    count,
    offset,
    y;

  unsigned char
    background_color[256],
    *colormap,
    pixel,
    plane,
    *pixels;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  /*
    Determine if this a RLE file.
  */
  count=ReadBlob(image,2,(unsigned char *) magick);
  if ((count != 2) || (memcmp(magick,""\122\314"",2) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  do
  {
    /*
      Read image header.
    */
    image->page.x=ReadBlobLSBShort(image);
    image->page.y=ReadBlobLSBShort(image);
    image->columns=ReadBlobLSBShort(image);
    image->rows=ReadBlobLSBShort(image);
    flags=(MagickStatusType) ReadBlobByte(image);
    image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;
    number_planes=(size_t) ReadBlobByte(image);
    bits_per_pixel=(size_t) ReadBlobByte(image);
    number_colormaps=(size_t) ReadBlobByte(image);
    map_length=(unsigned char) ReadBlobByte(image);
    if (map_length >= 22)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    one=1;
    map_length=one << map_length;
    if ((number_planes == 0) || (number_planes == 2) ||
        ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||
        (image->columns == 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if (flags & 0x02)
      {
        /*
          No background color-- initialize to black.
        */
        for (i=0; i < (ssize_t) number_planes; i++)
          background_color[i]=0;
        (void) ReadBlobByte(image);
      }
    else
      {
        /*
          Initialize background color.
        */
        p=background_color;
        for (i=0; i < (ssize_t) number_planes; i++)
          *p++=(unsigned char) ReadBlobByte(image);
      }
    if ((number_planes & 0x01) == 0)
      (void) ReadBlobByte(image);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    colormap=(unsigned char *) NULL;
    if (number_colormaps != 0)
      {
        /*
          Read image colormaps.
        */
        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,
          3*map_length*sizeof(*colormap));
        if (colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        p=colormap;
        for (i=0; i < (ssize_t) number_colormaps; i++)
          for (x=0; x < (ssize_t) map_length; x++)
            *p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));
      }
    if ((flags & 0x08) != 0)
      {
        char
          *comment;

        size_t
          length;

        /*
          Read image comment.
        */
        length=ReadBlobLSBShort(image);
        if (length != 0)
          {
            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));
            if (comment == (char *) NULL)
              ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
            count=ReadBlob(image,length-1,(unsigned char *) comment);
            comment[length-1]='\0';
            (void) SetImageProperty(image,""comment"",comment,exception);
            comment=DestroyString(comment);
            if ((length & 0x01) == 0)
              (void) ReadBlobByte(image);
          }
      }
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    /*
      Allocate RLE pixels.
    */
    if (image->alpha_trait != UndefinedPixelTrait)
      number_planes++;
    number_pixels=(MagickSizeType) image->columns*image->rows;
    number_planes_filled=(number_planes % 2 == 0) ? number_planes :
      number_planes+1;
    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*
         number_planes_filled))
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    pixel_info=AcquireVirtualMemory(image->columns,image->rows*
      MagickMax(number_planes_filled,4)*sizeof(*pixels));
    if (pixel_info == (MemoryInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     pixel_info_length=image->columns*image->rows*
       MagickMax(number_planes_filled,4);
     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
     if ((flags & 0x01) && !(flags & 0x02))
       {
         ssize_t
          j;

        /*
          Set background color.
        */
        p=pixels;
        for (i=0; i < (ssize_t) number_pixels; i++)
        {
          if (image->alpha_trait == UndefinedPixelTrait)
            for (j=0; j < (ssize_t) number_planes; j++)
              *p++=background_color[j];
          else
            {
              for (j=0; j < (ssize_t) (number_planes-1); j++)
                *p++=background_color[j];
              *p++=0;  /* initialize matte channel */
            }
        }
      }
    /*
      Read runlength-encoded image.
    */
    plane=0;
    x=0;
    y=0;
    opcode=ReadBlobByte(image);
    do
    {
      switch (opcode & 0x3f)
      {
        case SkipLinesOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          x=0;
          y+=operand;
          break;
        }
        case SetColorOp:
        {
          operand=ReadBlobByte(image);
          plane=(unsigned char) operand;
          if (plane == 255)
            plane=(unsigned char) (number_planes-1);
          x=0;
          break;
        }
        case SkipPixelsOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          x+=operand;
          break;
        }
        case ByteDataOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          offset=((image->rows-y-1)*image->columns*number_planes)+x*
            number_planes+plane;
          operand++;
          if ((offset < 0) ||
              (offset+((size_t) operand*number_planes) > pixel_info_length))
            {
              if (number_colormaps != 0)
                colormap=(unsigned char *) RelinquishMagickMemory(colormap);
              pixel_info=RelinquishVirtualMemory(pixel_info);
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            }
          p=pixels+offset;
          for (i=0; i < (ssize_t) operand; i++)
          {
            pixel=(unsigned char) ReadBlobByte(image);
            if ((y < (ssize_t) image->rows) &&
                ((x+i) < (ssize_t) image->columns))
              *p=pixel;
            p+=number_planes;
          }
          if (operand & 0x01)
            (void) ReadBlobByte(image);
          x+=operand;
          break;
        }
        case RunDataOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          pixel=(unsigned char) ReadBlobByte(image);
          (void) ReadBlobByte(image);
          offset=((image->rows-y-1)*image->columns*number_planes)+x*
            number_planes+plane;
          operand++;
          if ((offset < 0) ||
              (offset+((size_t) operand*number_planes) > pixel_info_length))
            {
              if (number_colormaps != 0)
                colormap=(unsigned char *) RelinquishMagickMemory(colormap);
              pixel_info=RelinquishVirtualMemory(pixel_info);
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            }
          p=pixels+offset;
          for (i=0; i < (ssize_t) operand; i++)
          {
            if ((y < (ssize_t) image->rows) &&
                ((x+i) < (ssize_t) image->columns))
              *p=pixel;
            p+=number_planes;
          }
          x+=operand;
          break;
        }
        default:
          break;
      }
      opcode=ReadBlobByte(image);
    } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));
    if (number_colormaps != 0)
      {
        MagickStatusType
          mask;

        /*
          Apply colormap affineation to image.
        */
        mask=(MagickStatusType) (map_length-1);
        p=pixels;
        x=(ssize_t) number_planes;
        if (number_colormaps == 1)
          for (i=0; i < (ssize_t) number_pixels; i++)
          {
            ValidateColormapValue(image,*p & mask,&index,exception);
            *p=colormap[(ssize_t) index];
            p++;
          }
        else
          if ((number_planes >= 3) && (number_colormaps >= 3))
            for (i=0; i < (ssize_t) number_pixels; i++)
              for (x=0; x < (ssize_t) number_planes; x++)
              {
                ValidateColormapValue(image,(size_t) (x*map_length+
                    (*p & mask)),&index,exception);
                *p=colormap[(ssize_t) index];
                p++;
              }
        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))
          {
            colormap=(unsigned char *) RelinquishMagickMemory(colormap);
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
          }
      }
    /*
      Initialize image structure.
    */
    if (number_planes >= 3)
      {
        /*
          Convert raster image to DirectClass pixel packets.
        */
        p=pixels;
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(image,ScaleCharToQuantum(*p++),q);
            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
            if (image->alpha_trait != UndefinedPixelTrait)
              SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      }
    else
      {
        /*
          Create colormap.
        */
        if (number_colormaps == 0)
          map_length=256;
        if (AcquireImageColormap(image,map_length,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        p=colormap;
        if (number_colormaps == 1)
          for (i=0; i < (ssize_t) image->colors; i++)
          {
            /*
              Pseudocolor.
            */
            image->colormap[i].red=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
            image->colormap[i].green=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
            image->colormap[i].blue=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
          }
        else
          if (number_colormaps > 1)
            for (i=0; i < (ssize_t) image->colors; i++)
            {
              image->colormap[i].red=(MagickRealType)
                ScaleCharToQuantum(*p);
              image->colormap[i].green=(MagickRealType)
                ScaleCharToQuantum(*(p+map_length));
              image->colormap[i].blue=(MagickRealType)
                ScaleCharToQuantum(*(p+map_length*2));
              p++;
            }
        p=pixels;
        if (image->alpha_trait == UndefinedPixelTrait)
          {
            /*
              Convert raster image to PseudoClass pixel packets.
            */
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                SetPixelIndex(image,*p++,q);
                q+=GetPixelChannels(image);
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
            (void) SyncImage(image,exception);
          }
        else
          {
            /*
              Image has a matte channel-- promote to DirectClass.
            */
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);
                SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].red),q);
                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);
                SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].green),q);
                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);
                SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].blue),q);
                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
                q+=GetPixelChannels(image);
              }
              if (x < (ssize_t) image->columns)
                break;
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
            image->colormap=(PixelInfo *) RelinquishMagickMemory(
              image->colormap);
            image->storage_class=DirectClass;
            image->colors=0;
          }
      }
    if (number_colormaps != 0)
      colormap=(unsigned char *) RelinquishMagickMemory(colormap);
    pixel_info=RelinquishVirtualMemory(pixel_info);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    (void) ReadBlobByte(image);
    count=ReadBlob(image,2,(unsigned char *) magick);
    if ((count != 0) && (memcmp(magick,""\122\314"",2) == 0))
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while ((count != 0) && (memcmp(magick,""\122\314"",2) == 0));
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",C,"    (void) ResetMagickMemory(pixels,0,pixel_info_length);
",,,"@@ -328,6 +328,7 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)
     pixel_info_length=image->columns*image->rows*
       MagickMax(number_planes_filled,4);
     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
+    (void) ResetMagickMemory(pixels,0,pixel_info_length);
     if ((flags & 0x01) && !(flags & 0x02))
       {
         ssize_t",ImageMagick,1c358ffe0049f768dd49a8a889c1cbf99ac9849b,0375c7318734648d93c3002e4e49954adc634f2b,1,"static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define SkipLinesOp  0x01
#define SetColorOp  0x02
#define SkipPixelsOp  0x03
#define ByteDataOp  0x05
#define RunDataOp  0x06
#define EOFOp  0x07

  char
    magick[12];

  Image
    *image;

  int
    opcode,
    operand,
    status;

  MagickStatusType
    flags;

  MagickSizeType
    number_pixels;

  MemoryInfo
    *pixel_info;

  Quantum
    index;

  register ssize_t
    x;

  register Quantum
    *q;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    bits_per_pixel,
    map_length,
    number_colormaps,
    number_planes,
    number_planes_filled,
    one,
    pixel_info_length;

  ssize_t
    count,
    offset,
    y;

  unsigned char
    background_color[256],
    *colormap,
    pixel,
    plane,
    *pixels;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  /*
    Determine if this a RLE file.
  */
  count=ReadBlob(image,2,(unsigned char *) magick);
  if ((count != 2) || (memcmp(magick,""\122\314"",2) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  do
  {
    /*
      Read image header.
    */
    image->page.x=ReadBlobLSBShort(image);
    image->page.y=ReadBlobLSBShort(image);
    image->columns=ReadBlobLSBShort(image);
    image->rows=ReadBlobLSBShort(image);
    flags=(MagickStatusType) ReadBlobByte(image);
    image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;
    number_planes=(size_t) ReadBlobByte(image);
    bits_per_pixel=(size_t) ReadBlobByte(image);
    number_colormaps=(size_t) ReadBlobByte(image);
    map_length=(unsigned char) ReadBlobByte(image);
    if (map_length >= 22)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    one=1;
    map_length=one << map_length;
    if ((number_planes == 0) || (number_planes == 2) ||
        ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||
        (image->columns == 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if (flags & 0x02)
      {
        /*
          No background color-- initialize to black.
        */
        for (i=0; i < (ssize_t) number_planes; i++)
          background_color[i]=0;
        (void) ReadBlobByte(image);
      }
    else
      {
        /*
          Initialize background color.
        */
        p=background_color;
        for (i=0; i < (ssize_t) number_planes; i++)
          *p++=(unsigned char) ReadBlobByte(image);
      }
    if ((number_planes & 0x01) == 0)
      (void) ReadBlobByte(image);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    colormap=(unsigned char *) NULL;
    if (number_colormaps != 0)
      {
        /*
          Read image colormaps.
        */
        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,
          3*map_length*sizeof(*colormap));
        if (colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        p=colormap;
        for (i=0; i < (ssize_t) number_colormaps; i++)
          for (x=0; x < (ssize_t) map_length; x++)
            *p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));
      }
    if ((flags & 0x08) != 0)
      {
        char
          *comment;

        size_t
          length;

        /*
          Read image comment.
        */
        length=ReadBlobLSBShort(image);
        if (length != 0)
          {
            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));
            if (comment == (char *) NULL)
              ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
            count=ReadBlob(image,length-1,(unsigned char *) comment);
            comment[length-1]='\0';
            (void) SetImageProperty(image,""comment"",comment,exception);
            comment=DestroyString(comment);
            if ((length & 0x01) == 0)
              (void) ReadBlobByte(image);
          }
      }
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    /*
      Allocate RLE pixels.
    */
    if (image->alpha_trait != UndefinedPixelTrait)
      number_planes++;
    number_pixels=(MagickSizeType) image->columns*image->rows;
    number_planes_filled=(number_planes % 2 == 0) ? number_planes :
      number_planes+1;
    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*
         number_planes_filled))
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    pixel_info=AcquireVirtualMemory(image->columns,image->rows*
      MagickMax(number_planes_filled,4)*sizeof(*pixels));
    if (pixel_info == (MemoryInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     pixel_info_length=image->columns*image->rows*
       MagickMax(number_planes_filled,4);
     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
//fix_flaw_line_below:
//    (void) ResetMagickMemory(pixels,0,pixel_info_length);
     if ((flags & 0x01) && !(flags & 0x02))
       {
         ssize_t
          j;

        /*
          Set background color.
        */
        p=pixels;
        for (i=0; i < (ssize_t) number_pixels; i++)
        {
          if (image->alpha_trait == UndefinedPixelTrait)
            for (j=0; j < (ssize_t) number_planes; j++)
              *p++=background_color[j];
          else
            {
              for (j=0; j < (ssize_t) (number_planes-1); j++)
                *p++=background_color[j];
              *p++=0;  /* initialize matte channel */
            }
        }
      }
    /*
      Read runlength-encoded image.
    */
    plane=0;
    x=0;
    y=0;
    opcode=ReadBlobByte(image);
    do
    {
      switch (opcode & 0x3f)
      {
        case SkipLinesOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          x=0;
          y+=operand;
          break;
        }
        case SetColorOp:
        {
          operand=ReadBlobByte(image);
          plane=(unsigned char) operand;
          if (plane == 255)
            plane=(unsigned char) (number_planes-1);
          x=0;
          break;
        }
        case SkipPixelsOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          x+=operand;
          break;
        }
        case ByteDataOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          offset=((image->rows-y-1)*image->columns*number_planes)+x*
            number_planes+plane;
          operand++;
          if ((offset < 0) ||
              (offset+((size_t) operand*number_planes) > pixel_info_length))
            {
              if (number_colormaps != 0)
                colormap=(unsigned char *) RelinquishMagickMemory(colormap);
              pixel_info=RelinquishVirtualMemory(pixel_info);
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            }
          p=pixels+offset;
          for (i=0; i < (ssize_t) operand; i++)
          {
            pixel=(unsigned char) ReadBlobByte(image);
            if ((y < (ssize_t) image->rows) &&
                ((x+i) < (ssize_t) image->columns))
              *p=pixel;
            p+=number_planes;
          }
          if (operand & 0x01)
            (void) ReadBlobByte(image);
          x+=operand;
          break;
        }
        case RunDataOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          pixel=(unsigned char) ReadBlobByte(image);
          (void) ReadBlobByte(image);
          offset=((image->rows-y-1)*image->columns*number_planes)+x*
            number_planes+plane;
          operand++;
          if ((offset < 0) ||
              (offset+((size_t) operand*number_planes) > pixel_info_length))
            {
              if (number_colormaps != 0)
                colormap=(unsigned char *) RelinquishMagickMemory(colormap);
              pixel_info=RelinquishVirtualMemory(pixel_info);
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            }
          p=pixels+offset;
          for (i=0; i < (ssize_t) operand; i++)
          {
            if ((y < (ssize_t) image->rows) &&
                ((x+i) < (ssize_t) image->columns))
              *p=pixel;
            p+=number_planes;
          }
          x+=operand;
          break;
        }
        default:
          break;
      }
      opcode=ReadBlobByte(image);
    } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));
    if (number_colormaps != 0)
      {
        MagickStatusType
          mask;

        /*
          Apply colormap affineation to image.
        */
        mask=(MagickStatusType) (map_length-1);
        p=pixels;
        x=(ssize_t) number_planes;
        if (number_colormaps == 1)
          for (i=0; i < (ssize_t) number_pixels; i++)
          {
            ValidateColormapValue(image,*p & mask,&index,exception);
            *p=colormap[(ssize_t) index];
            p++;
          }
        else
          if ((number_planes >= 3) && (number_colormaps >= 3))
            for (i=0; i < (ssize_t) number_pixels; i++)
              for (x=0; x < (ssize_t) number_planes; x++)
              {
                ValidateColormapValue(image,(size_t) (x*map_length+
                    (*p & mask)),&index,exception);
                *p=colormap[(ssize_t) index];
                p++;
              }
        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))
          {
            colormap=(unsigned char *) RelinquishMagickMemory(colormap);
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
          }
      }
    /*
      Initialize image structure.
    */
    if (number_planes >= 3)
      {
        /*
          Convert raster image to DirectClass pixel packets.
        */
        p=pixels;
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(image,ScaleCharToQuantum(*p++),q);
            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
            if (image->alpha_trait != UndefinedPixelTrait)
              SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      }
    else
      {
        /*
          Create colormap.
        */
        if (number_colormaps == 0)
          map_length=256;
        if (AcquireImageColormap(image,map_length,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        p=colormap;
        if (number_colormaps == 1)
          for (i=0; i < (ssize_t) image->colors; i++)
          {
            /*
              Pseudocolor.
            */
            image->colormap[i].red=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
            image->colormap[i].green=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
            image->colormap[i].blue=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
          }
        else
          if (number_colormaps > 1)
            for (i=0; i < (ssize_t) image->colors; i++)
            {
              image->colormap[i].red=(MagickRealType)
                ScaleCharToQuantum(*p);
              image->colormap[i].green=(MagickRealType)
                ScaleCharToQuantum(*(p+map_length));
              image->colormap[i].blue=(MagickRealType)
                ScaleCharToQuantum(*(p+map_length*2));
              p++;
            }
        p=pixels;
        if (image->alpha_trait == UndefinedPixelTrait)
          {
            /*
              Convert raster image to PseudoClass pixel packets.
            */
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                SetPixelIndex(image,*p++,q);
                q+=GetPixelChannels(image);
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
            (void) SyncImage(image,exception);
          }
        else
          {
            /*
              Image has a matte channel-- promote to DirectClass.
            */
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);
                SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].red),q);
                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);
                SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].green),q);
                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);
                SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].blue),q);
                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
                q+=GetPixelChannels(image);
              }
              if (x < (ssize_t) image->columns)
                break;
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
            image->colormap=(PixelInfo *) RelinquishMagickMemory(
              image->colormap);
            image->storage_class=DirectClass;
            image->colors=0;
          }
      }
    if (number_colormaps != 0)
      colormap=(unsigned char *) RelinquishMagickMemory(colormap);
    pixel_info=RelinquishVirtualMemory(pixel_info);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    (void) ReadBlobByte(image);
    count=ReadBlob(image,2,(unsigned char *) magick);
    if ((count != 0) && (memcmp(magick,""\122\314"",2) == 0))
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while ((count != 0) && (memcmp(magick,""\122\314"",2) == 0));
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",181298,"static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define SkipLinesOp  0x01
#define SetColorOp  0x02
#define SkipPixelsOp  0x03
#define ByteDataOp  0x05
#define RunDataOp  0x06
#define EOFOp  0x07

  char
    magick[12];

  Image
    *image;

  int
    opcode,
    operand,
    status;

  MagickStatusType
    flags;

  MagickSizeType
    number_pixels;

  MemoryInfo
    *pixel_info;

  Quantum
    index;

  register ssize_t
    x;

  register Quantum
    *q;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    bits_per_pixel,
    map_length,
    number_colormaps,
    number_planes,
    number_planes_filled,
    one,
    pixel_info_length;

  ssize_t
    count,
    offset,
    y;

  unsigned char
    background_color[256],
    *colormap,
    pixel,
    plane,
    *pixels;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  /*
    Determine if this a RLE file.
  */
  count=ReadBlob(image,2,(unsigned char *) magick);
  if ((count != 2) || (memcmp(magick,""\122\314"",2) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  do
  {
    /*
      Read image header.
    */
    image->page.x=ReadBlobLSBShort(image);
    image->page.y=ReadBlobLSBShort(image);
    image->columns=ReadBlobLSBShort(image);
    image->rows=ReadBlobLSBShort(image);
    flags=(MagickStatusType) ReadBlobByte(image);
    image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;
    number_planes=(size_t) ReadBlobByte(image);
    bits_per_pixel=(size_t) ReadBlobByte(image);
    number_colormaps=(size_t) ReadBlobByte(image);
    map_length=(unsigned char) ReadBlobByte(image);
    if (map_length >= 22)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    one=1;
    map_length=one << map_length;
    if ((number_planes == 0) || (number_planes == 2) ||
        ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||
        (image->columns == 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if (flags & 0x02)
      {
        /*
          No background color-- initialize to black.
        */
        for (i=0; i < (ssize_t) number_planes; i++)
          background_color[i]=0;
        (void) ReadBlobByte(image);
      }
    else
      {
        /*
          Initialize background color.
        */
        p=background_color;
        for (i=0; i < (ssize_t) number_planes; i++)
          *p++=(unsigned char) ReadBlobByte(image);
      }
    if ((number_planes & 0x01) == 0)
      (void) ReadBlobByte(image);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    colormap=(unsigned char *) NULL;
    if (number_colormaps != 0)
      {
        /*
          Read image colormaps.
        */
        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,
          3*map_length*sizeof(*colormap));
        if (colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        p=colormap;
        for (i=0; i < (ssize_t) number_colormaps; i++)
          for (x=0; x < (ssize_t) map_length; x++)
            *p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));
      }
    if ((flags & 0x08) != 0)
      {
        char
          *comment;

        size_t
          length;

        /*
          Read image comment.
        */
        length=ReadBlobLSBShort(image);
        if (length != 0)
          {
            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));
            if (comment == (char *) NULL)
              ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
            count=ReadBlob(image,length-1,(unsigned char *) comment);
            comment[length-1]='\0';
            (void) SetImageProperty(image,""comment"",comment,exception);
            comment=DestroyString(comment);
            if ((length & 0x01) == 0)
              (void) ReadBlobByte(image);
          }
      }
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    /*
      Allocate RLE pixels.
    */
    if (image->alpha_trait != UndefinedPixelTrait)
      number_planes++;
    number_pixels=(MagickSizeType) image->columns*image->rows;
    number_planes_filled=(number_planes % 2 == 0) ? number_planes :
      number_planes+1;
    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*
         number_planes_filled))
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    pixel_info=AcquireVirtualMemory(image->columns,image->rows*
      MagickMax(number_planes_filled,4)*sizeof(*pixels));
    if (pixel_info == (MemoryInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     pixel_info_length=image->columns*image->rows*
       MagickMax(number_planes_filled,4);
     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
     if ((flags & 0x01) && !(flags & 0x02))
       {
         ssize_t
          j;

        /*
          Set background color.
        */
        p=pixels;
        for (i=0; i < (ssize_t) number_pixels; i++)
        {
          if (image->alpha_trait == UndefinedPixelTrait)
            for (j=0; j < (ssize_t) number_planes; j++)
              *p++=background_color[j];
          else
            {
              for (j=0; j < (ssize_t) (number_planes-1); j++)
                *p++=background_color[j];
              *p++=0;  /* initialize matte channel */
            }
        }
      }
    /*
      Read runlength-encoded image.
    */
    plane=0;
    x=0;
    y=0;
    opcode=ReadBlobByte(image);
    do
    {
      switch (opcode & 0x3f)
      {
        case SkipLinesOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          x=0;
          y+=operand;
          break;
        }
        case SetColorOp:
        {
          operand=ReadBlobByte(image);
          plane=(unsigned char) operand;
          if (plane == 255)
            plane=(unsigned char) (number_planes-1);
          x=0;
          break;
        }
        case SkipPixelsOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          x+=operand;
          break;
        }
        case ByteDataOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          offset=((image->rows-y-1)*image->columns*number_planes)+x*
            number_planes+plane;
          operand++;
          if ((offset < 0) ||
              (offset+((size_t) operand*number_planes) > pixel_info_length))
            {
              if (number_colormaps != 0)
                colormap=(unsigned char *) RelinquishMagickMemory(colormap);
              pixel_info=RelinquishVirtualMemory(pixel_info);
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            }
          p=pixels+offset;
          for (i=0; i < (ssize_t) operand; i++)
          {
            pixel=(unsigned char) ReadBlobByte(image);
            if ((y < (ssize_t) image->rows) &&
                ((x+i) < (ssize_t) image->columns))
              *p=pixel;
            p+=number_planes;
          }
          if (operand & 0x01)
            (void) ReadBlobByte(image);
          x+=operand;
          break;
        }
        case RunDataOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          pixel=(unsigned char) ReadBlobByte(image);
          (void) ReadBlobByte(image);
          offset=((image->rows-y-1)*image->columns*number_planes)+x*
            number_planes+plane;
          operand++;
          if ((offset < 0) ||
              (offset+((size_t) operand*number_planes) > pixel_info_length))
            {
              if (number_colormaps != 0)
                colormap=(unsigned char *) RelinquishMagickMemory(colormap);
              pixel_info=RelinquishVirtualMemory(pixel_info);
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            }
          p=pixels+offset;
          for (i=0; i < (ssize_t) operand; i++)
          {
            if ((y < (ssize_t) image->rows) &&
                ((x+i) < (ssize_t) image->columns))
              *p=pixel;
            p+=number_planes;
          }
          x+=operand;
          break;
        }
        default:
          break;
      }
      opcode=ReadBlobByte(image);
    } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));
    if (number_colormaps != 0)
      {
        MagickStatusType
          mask;

        /*
          Apply colormap affineation to image.
        */
        mask=(MagickStatusType) (map_length-1);
        p=pixels;
        x=(ssize_t) number_planes;
        if (number_colormaps == 1)
          for (i=0; i < (ssize_t) number_pixels; i++)
          {
            ValidateColormapValue(image,*p & mask,&index,exception);
            *p=colormap[(ssize_t) index];
            p++;
          }
        else
          if ((number_planes >= 3) && (number_colormaps >= 3))
            for (i=0; i < (ssize_t) number_pixels; i++)
              for (x=0; x < (ssize_t) number_planes; x++)
              {
                ValidateColormapValue(image,(size_t) (x*map_length+
                    (*p & mask)),&index,exception);
                *p=colormap[(ssize_t) index];
                p++;
              }
        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))
          {
            colormap=(unsigned char *) RelinquishMagickMemory(colormap);
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
          }
      }
    /*
      Initialize image structure.
    */
    if (number_planes >= 3)
      {
        /*
          Convert raster image to DirectClass pixel packets.
        */
        p=pixels;
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(image,ScaleCharToQuantum(*p++),q);
            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
            if (image->alpha_trait != UndefinedPixelTrait)
              SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      }
    else
      {
        /*
          Create colormap.
        */
        if (number_colormaps == 0)
          map_length=256;
        if (AcquireImageColormap(image,map_length,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        p=colormap;
        if (number_colormaps == 1)
          for (i=0; i < (ssize_t) image->colors; i++)
          {
            /*
              Pseudocolor.
            */
            image->colormap[i].red=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
            image->colormap[i].green=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
            image->colormap[i].blue=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
          }
        else
          if (number_colormaps > 1)
            for (i=0; i < (ssize_t) image->colors; i++)
            {
              image->colormap[i].red=(MagickRealType)
                ScaleCharToQuantum(*p);
              image->colormap[i].green=(MagickRealType)
                ScaleCharToQuantum(*(p+map_length));
              image->colormap[i].blue=(MagickRealType)
                ScaleCharToQuantum(*(p+map_length*2));
              p++;
            }
        p=pixels;
        if (image->alpha_trait == UndefinedPixelTrait)
          {
            /*
              Convert raster image to PseudoClass pixel packets.
            */
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                SetPixelIndex(image,*p++,q);
                q+=GetPixelChannels(image);
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
            (void) SyncImage(image,exception);
          }
        else
          {
            /*
              Image has a matte channel-- promote to DirectClass.
            */
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);
                SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].red),q);
                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);
                SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].green),q);
                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);
                SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].blue),q);
                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
                q+=GetPixelChannels(image);
              }
              if (x < (ssize_t) image->columns)
                break;
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
            image->colormap=(PixelInfo *) RelinquishMagickMemory(
              image->colormap);
            image->storage_class=DirectClass;
            image->colors=0;
          }
      }
    if (number_colormaps != 0)
      colormap=(unsigned char *) RelinquishMagickMemory(colormap);
    pixel_info=RelinquishVirtualMemory(pixel_info);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    (void) ReadBlobByte(image);
    count=ReadBlob(image,2,(unsigned char *) magick);
    if ((count != 0) && (memcmp(magick,""\122\314"",2) == 0))
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while ((count != 0) && (memcmp(magick,""\122\314"",2) == 0));
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define SkipLinesOp  0x01
#define SetColorOp  0x02
#define SkipPixelsOp  0x03
#define ByteDataOp  0x05
#define RunDataOp  0x06
#define EOFOp  0x07

  char
    magick[12];

  Image
    *image;

  int
    opcode,
    operand,
    status;

  MagickStatusType
    flags;

  MagickSizeType
    number_pixels;

  MemoryInfo
    *pixel_info;

  Quantum
    index;

  register ssize_t
    x;

  register Quantum
    *q;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    bits_per_pixel,
    map_length,
    number_colormaps,
    number_planes,
    number_planes_filled,
    one,
    pixel_info_length;

  ssize_t
    count,
    offset,
    y;

  unsigned char
    background_color[256],
    *colormap,
    pixel,
    plane,
    *pixels;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  /*
    Determine if this a RLE file.
  */
  count=ReadBlob(image,2,(unsigned char *) magick);
  if ((count != 2) || (memcmp(magick,""\122\314"",2) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  do
  {
    /*
      Read image header.
    */
    image->page.x=ReadBlobLSBShort(image);
    image->page.y=ReadBlobLSBShort(image);
    image->columns=ReadBlobLSBShort(image);
    image->rows=ReadBlobLSBShort(image);
    flags=(MagickStatusType) ReadBlobByte(image);
    image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;
    number_planes=(size_t) ReadBlobByte(image);
    bits_per_pixel=(size_t) ReadBlobByte(image);
    number_colormaps=(size_t) ReadBlobByte(image);
    map_length=(unsigned char) ReadBlobByte(image);
    if (map_length >= 22)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    one=1;
    map_length=one << map_length;
    if ((number_planes == 0) || (number_planes == 2) ||
        ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||
        (image->columns == 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if (flags & 0x02)
      {
        /*
          No background color-- initialize to black.
        */
        for (i=0; i < (ssize_t) number_planes; i++)
          background_color[i]=0;
        (void) ReadBlobByte(image);
      }
    else
      {
        /*
          Initialize background color.
        */
        p=background_color;
        for (i=0; i < (ssize_t) number_planes; i++)
          *p++=(unsigned char) ReadBlobByte(image);
      }
    if ((number_planes & 0x01) == 0)
      (void) ReadBlobByte(image);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    colormap=(unsigned char *) NULL;
    if (number_colormaps != 0)
      {
        /*
          Read image colormaps.
        */
        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,
          3*map_length*sizeof(*colormap));
        if (colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        p=colormap;
        for (i=0; i < (ssize_t) number_colormaps; i++)
          for (x=0; x < (ssize_t) map_length; x++)
            *p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));
      }
    if ((flags & 0x08) != 0)
      {
        char
          *comment;

        size_t
          length;

        /*
          Read image comment.
        */
        length=ReadBlobLSBShort(image);
        if (length != 0)
          {
            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));
            if (comment == (char *) NULL)
              ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
            count=ReadBlob(image,length-1,(unsigned char *) comment);
            comment[length-1]='\0';
            (void) SetImageProperty(image,""comment"",comment,exception);
            comment=DestroyString(comment);
            if ((length & 0x01) == 0)
              (void) ReadBlobByte(image);
          }
      }
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    /*
      Allocate RLE pixels.
    */
    if (image->alpha_trait != UndefinedPixelTrait)
      number_planes++;
    number_pixels=(MagickSizeType) image->columns*image->rows;
    number_planes_filled=(number_planes % 2 == 0) ? number_planes :
      number_planes+1;
    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*
         number_planes_filled))
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    pixel_info=AcquireVirtualMemory(image->columns,image->rows*
      MagickMax(number_planes_filled,4)*sizeof(*pixels));
    if (pixel_info == (MemoryInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     pixel_info_length=image->columns*image->rows*
       MagickMax(number_planes_filled,4);
     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
    (void) ResetMagickMemory(pixels,0,pixel_info_length);
     if ((flags & 0x01) && !(flags & 0x02))
       {
         ssize_t
          j;

        /*
          Set background color.
        */
        p=pixels;
        for (i=0; i < (ssize_t) number_pixels; i++)
        {
          if (image->alpha_trait == UndefinedPixelTrait)
            for (j=0; j < (ssize_t) number_planes; j++)
              *p++=background_color[j];
          else
            {
              for (j=0; j < (ssize_t) (number_planes-1); j++)
                *p++=background_color[j];
              *p++=0;  /* initialize matte channel */
            }
        }
      }
    /*
      Read runlength-encoded image.
    */
    plane=0;
    x=0;
    y=0;
    opcode=ReadBlobByte(image);
    do
    {
      switch (opcode & 0x3f)
      {
        case SkipLinesOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          x=0;
          y+=operand;
          break;
        }
        case SetColorOp:
        {
          operand=ReadBlobByte(image);
          plane=(unsigned char) operand;
          if (plane == 255)
            plane=(unsigned char) (number_planes-1);
          x=0;
          break;
        }
        case SkipPixelsOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          x+=operand;
          break;
        }
        case ByteDataOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          offset=((image->rows-y-1)*image->columns*number_planes)+x*
            number_planes+plane;
          operand++;
          if ((offset < 0) ||
              (offset+((size_t) operand*number_planes) > pixel_info_length))
            {
              if (number_colormaps != 0)
                colormap=(unsigned char *) RelinquishMagickMemory(colormap);
              pixel_info=RelinquishVirtualMemory(pixel_info);
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            }
          p=pixels+offset;
          for (i=0; i < (ssize_t) operand; i++)
          {
            pixel=(unsigned char) ReadBlobByte(image);
            if ((y < (ssize_t) image->rows) &&
                ((x+i) < (ssize_t) image->columns))
              *p=pixel;
            p+=number_planes;
          }
          if (operand & 0x01)
            (void) ReadBlobByte(image);
          x+=operand;
          break;
        }
        case RunDataOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=ReadBlobLSBSignedShort(image);
          pixel=(unsigned char) ReadBlobByte(image);
          (void) ReadBlobByte(image);
          offset=((image->rows-y-1)*image->columns*number_planes)+x*
            number_planes+plane;
          operand++;
          if ((offset < 0) ||
              (offset+((size_t) operand*number_planes) > pixel_info_length))
            {
              if (number_colormaps != 0)
                colormap=(unsigned char *) RelinquishMagickMemory(colormap);
              pixel_info=RelinquishVirtualMemory(pixel_info);
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            }
          p=pixels+offset;
          for (i=0; i < (ssize_t) operand; i++)
          {
            if ((y < (ssize_t) image->rows) &&
                ((x+i) < (ssize_t) image->columns))
              *p=pixel;
            p+=number_planes;
          }
          x+=operand;
          break;
        }
        default:
          break;
      }
      opcode=ReadBlobByte(image);
    } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));
    if (number_colormaps != 0)
      {
        MagickStatusType
          mask;

        /*
          Apply colormap affineation to image.
        */
        mask=(MagickStatusType) (map_length-1);
        p=pixels;
        x=(ssize_t) number_planes;
        if (number_colormaps == 1)
          for (i=0; i < (ssize_t) number_pixels; i++)
          {
            ValidateColormapValue(image,*p & mask,&index,exception);
            *p=colormap[(ssize_t) index];
            p++;
          }
        else
          if ((number_planes >= 3) && (number_colormaps >= 3))
            for (i=0; i < (ssize_t) number_pixels; i++)
              for (x=0; x < (ssize_t) number_planes; x++)
              {
                ValidateColormapValue(image,(size_t) (x*map_length+
                    (*p & mask)),&index,exception);
                *p=colormap[(ssize_t) index];
                p++;
              }
        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))
          {
            colormap=(unsigned char *) RelinquishMagickMemory(colormap);
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
          }
      }
    /*
      Initialize image structure.
    */
    if (number_planes >= 3)
      {
        /*
          Convert raster image to DirectClass pixel packets.
        */
        p=pixels;
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(image,ScaleCharToQuantum(*p++),q);
            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
            if (image->alpha_trait != UndefinedPixelTrait)
              SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      }
    else
      {
        /*
          Create colormap.
        */
        if (number_colormaps == 0)
          map_length=256;
        if (AcquireImageColormap(image,map_length,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        p=colormap;
        if (number_colormaps == 1)
          for (i=0; i < (ssize_t) image->colors; i++)
          {
            /*
              Pseudocolor.
            */
            image->colormap[i].red=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
            image->colormap[i].green=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
            image->colormap[i].blue=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
          }
        else
          if (number_colormaps > 1)
            for (i=0; i < (ssize_t) image->colors; i++)
            {
              image->colormap[i].red=(MagickRealType)
                ScaleCharToQuantum(*p);
              image->colormap[i].green=(MagickRealType)
                ScaleCharToQuantum(*(p+map_length));
              image->colormap[i].blue=(MagickRealType)
                ScaleCharToQuantum(*(p+map_length*2));
              p++;
            }
        p=pixels;
        if (image->alpha_trait == UndefinedPixelTrait)
          {
            /*
              Convert raster image to PseudoClass pixel packets.
            */
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                SetPixelIndex(image,*p++,q);
                q+=GetPixelChannels(image);
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
            (void) SyncImage(image,exception);
          }
        else
          {
            /*
              Image has a matte channel-- promote to DirectClass.
            */
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);
                SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].red),q);
                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);
                SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].green),q);
                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);
                SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].blue),q);
                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
                q+=GetPixelChannels(image);
              }
              if (x < (ssize_t) image->columns)
                break;
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
            image->colormap=(PixelInfo *) RelinquishMagickMemory(
              image->colormap);
            image->storage_class=DirectClass;
            image->colors=0;
          }
      }
    if (number_colormaps != 0)
      colormap=(unsigned char *) RelinquishMagickMemory(colormap);
    pixel_info=RelinquishVirtualMemory(pixel_info);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    (void) ReadBlobByte(image);
    count=ReadBlob(image,2,(unsigned char *) magick);
    if ((count != 0) && (memcmp(magick,""\122\314"",2) == 0))
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while ((count != 0) && (memcmp(magick,""\122\314"",2) == 0));
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","The `ReadRLEImage` function is designed to read and decode images stored in a run-length encoded (RLE) format. It begins by validating the input parameters and opening the image file, checking for a valid RLE header. The function then reads various image properties, such as dimensions, color planes, and colormaps, while handling background colors and comments. It allocates memory for pixel data and processes the RLE data using defined operations like skipping lines, setting colors, and reading pixel values. Finally, it populates the image structure with pixel data, manages colormaps, and prepares for potential multiple images in a single file, returning the first image in the list.","The provided code is responsible for reading and decoding images stored in a specific run-length encoded format. It begins by validating input parameters and opening the image file, ensuring the header is correct. The code then extracts essential image properties, such as dimensions and color information, while managing background colors and comments. It allocates memory for pixel data and processes the encoded image data using various operations to handle pixel manipulation. Finally, the code populates the image structure with the decoded pixel information, supports colormaps, and prepares for multiple images within a single file, returning the first image.","The vulnerability in the original code stemmed from the lack of proper initialization of the pixel data buffer, which could lead to the use of uninitialized memory when processing images. Specifically, the pixel buffer was allocated but not reset, potentially allowing sensitive data to leak or causing unpredictable behavior. The fix involved adding a memory reset operation using `ResetMagickMemory(pixels, 0, pixel_info_length)`, ensuring that the allocated pixel buffer is initialized to zero before it is used. This change mitigates the risk of using uninitialized memory, enhancing the security and stability of the image processing function.","The vulnerability in the original code was due to the lack of initialization for the memory allocated for pixel data, which could lead to the use of uninitialized memory. This oversight posed risks such as leaking sensitive information or causing unpredictable behavior during image processing. The fix involved implementing a memory reset operation to ensure that the allocated memory was cleared and set to a known state before being utilized. This change effectively mitigated the risks associated with uninitialized memory, enhancing both the security and reliability of the image decoding process.","The vulnerability was fixed by adding a memory reset operation using `ResetMagickMemory(pixels, 0, pixel_info_length)` after the pixel buffer was allocated. This function initializes the allocated memory for the pixel data to zero, ensuring that any previously stored data is cleared. By doing so, the code prevents the use of uninitialized memory, which could lead to unpredictable behavior or security issues. This change enhances the reliability of the image processing function by ensuring that the pixel buffer starts in a known state before it is populated with image data.","The vulnerability was addressed by incorporating a memory reset operation immediately after allocating memory for the pixel data. This operation ensures that the allocated memory is initialized to a known state, effectively clearing any residual data that could lead to unpredictable behavior or security risks. By setting the memory to zero, the code prevents the potential use of uninitialized values during image processing, thereby enhancing the reliability and security of the function. This change ensures that the pixel buffer is safe to use, mitigating risks associated with uninitialized memory.","5,5","5, 5","4,3","5,5"
79,79,181560,181560,,Local,Not required,,CVE-2017-5550,https://www.cvedetails.com/cve/CVE-2017-5550/,CWE-200,Low,Partial,,,2017-02-06,2.1,Off-by-one error in the pipe_advance function in lib/iov_iter.c in the Linux kernel before 4.9.5 allows local users to obtain sensitive information from uninitialized heap-memory locations in opportunistic circumstances by reading from a pipe after an incorrect buffer-release decision.,2017-02-09,+Info ,10,https://github.com/torvalds/linux/commit/b9dc6f65bc5e232d1c05fe34b5daadc7e8bbf1fb,b9dc6f65bc5e232d1c05fe34b5daadc7e8bbf1fb,"fix a fencepost error in pipe_advance()

The logics in pipe_advance() used to release all buffers past the new
position failed in cases when the number of buffers to release was equal
to pipe->buffers.  If that happened, none of them had been released,
leaving pipe full.  Worse, it was trivial to trigger and we end up with
pipe full of uninitialized pages.  IOW, it's an infoleak.

Cc: stable@vger.kernel.org # v4.9
Reported-by: ""Alan J. Wylie"" <alan@wylie.me.uk>
Tested-by: ""Alan J. Wylie"" <alan@wylie.me.uk>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",21,lib/iov_iter.c,"{""sha"": ""e68604ae3cedf41ce98bc06de2142629fa115cbd"", ""filename"": ""lib/iov_iter.c"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 23, ""changes"": 54, ""blob_url"": ""https://github.com/torvalds/linux/blob/b9dc6f65bc5e232d1c05fe34b5daadc7e8bbf1fb/lib/iov_iter.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/b9dc6f65bc5e232d1c05fe34b5daadc7e8bbf1fb/lib/iov_iter.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/lib/iov_iter.c?ref=b9dc6f65bc5e232d1c05fe34b5daadc7e8bbf1fb"", ""patch"": ""@@ -730,43 +730,50 @@ size_t iov_iter_copy_from_user_atomic(struct page *page,\n }\n EXPORT_SYMBOL(iov_iter_copy_from_user_atomic);\n \n+static inline void pipe_truncate(struct iov_iter *i)\n+{\n+\tstruct pipe_inode_info *pipe = i->pipe;\n+\tif (pipe->nrbufs) {\n+\t\tsize_t off = i->iov_offset;\n+\t\tint idx = i->idx;\n+\t\tint nrbufs = (idx - pipe->curbuf) & (pipe->buffers - 1);\n+\t\tif (off) {\n+\t\t\tpipe->bufs[idx].len = off - pipe->bufs[idx].offset;\n+\t\t\tidx = next_idx(idx, pipe);\n+\t\t\tnrbufs++;\n+\t\t}\n+\t\twhile (pipe->nrbufs > nrbufs) {\n+\t\t\tpipe_buf_release(pipe, &pipe->bufs[idx]);\n+\t\t\tidx = next_idx(idx, pipe);\n+\t\t\tpipe->nrbufs--;\n+\t\t}\n+\t}\n+}\n+\n static void pipe_advance(struct iov_iter *i, size_t size)\n {\n \tstruct pipe_inode_info *pipe = i->pipe;\n-\tstruct pipe_buffer *buf;\n-\tint idx = i->idx;\n-\tsize_t off = i->iov_offset, orig_sz;\n-\t\n \tif (unlikely(i->count < size))\n \t\tsize = i->count;\n-\torig_sz = size;\n-\n \tif (size) {\n+\t\tstruct pipe_buffer *buf;\n+\t\tsize_t off = i->iov_offset, left = size;\n+\t\tint idx = i->idx;\n \t\tif (off) /* make it relative to the beginning of buffer */\n-\t\t\tsize += off - pipe->bufs[idx].offset;\n+\t\t\tleft += off - pipe->bufs[idx].offset;\n \t\twhile (1) {\n \t\t\tbuf = &pipe->bufs[idx];\n-\t\t\tif (size <= buf->len)\n+\t\t\tif (left <= buf->len)\n \t\t\t\tbreak;\n-\t\t\tsize -= buf->len;\n+\t\t\tleft -= buf->len;\n \t\t\tidx = next_idx(idx, pipe);\n \t\t}\n-\t\tbuf->len = size;\n \t\ti->idx = idx;\n-\t\toff = i->iov_offset = buf->offset + size;\n-\t}\n-\tif (off)\n-\t\tidx = next_idx(idx, pipe);\n-\tif (pipe->nrbufs) {\n-\t\tint unused = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n-\t\t/* [curbuf,unused) is in use.  Free [idx,unused) */\n-\t\twhile (idx != unused) {\n-\t\t\tpipe_buf_release(pipe, &pipe->bufs[idx]);\n-\t\t\tidx = next_idx(idx, pipe);\n-\t\t\tpipe->nrbufs--;\n-\t\t}\n+\t\ti->iov_offset = buf->offset + left;\n \t}\n-\ti->count -= orig_sz;\n+\ti->count -= size;\n+\t/* ... and discard everything past that point */\n+\tpipe_truncate(i);\n }\n \n void iov_iter_advance(struct iov_iter *i, size_t size)\n@@ -826,6 +833,7 @@ void iov_iter_pipe(struct iov_iter *i, int direction,\n \t\t\tsize_t count)\n {\n \tBUG_ON(direction != ITER_PIPE);\n+\tWARN_ON(pipe->nrbufs == pipe->buffers);\n \ti->type = direction;\n \ti->pipe = pipe;\n \ti->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);""}"," static void pipe_advance(struct iov_iter *i, size_t size)
 {
 	struct pipe_inode_info *pipe = i->pipe;
 	if (unlikely(i->count < size))
 		size = i->count;
 	if (size) {
		struct pipe_buffer *buf;
		size_t off = i->iov_offset, left = size;
		int idx = i->idx;
 		if (off) /* make it relative to the beginning of buffer */
			left += off - pipe->bufs[idx].offset;
 		while (1) {
 			buf = &pipe->bufs[idx];
			if (left <= buf->len)
 				break;
			left -= buf->len;
 			idx = next_idx(idx, pipe);
 		}
 		i->idx = idx;
		i->iov_offset = buf->offset + left;
 	}
	i->count -= size;
	/* ... and discard everything past that point */
	pipe_truncate(i);
 }
"," static void pipe_advance(struct iov_iter *i, size_t size)
 {
 	struct pipe_inode_info *pipe = i->pipe;
	struct pipe_buffer *buf;
	int idx = i->idx;
	size_t off = i->iov_offset, orig_sz;
 	if (unlikely(i->count < size))
 		size = i->count;
	orig_sz = size;
 	if (size) {
 		if (off) /* make it relative to the beginning of buffer */
			size += off - pipe->bufs[idx].offset;
 		while (1) {
 			buf = &pipe->bufs[idx];
			if (size <= buf->len)
 				break;
			size -= buf->len;
 			idx = next_idx(idx, pipe);
 		}
		buf->len = size;
 		i->idx = idx;
		off = i->iov_offset = buf->offset + size;
	}
	if (off)
		idx = next_idx(idx, pipe);
	if (pipe->nrbufs) {
		int unused = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
		/* [curbuf,unused) is in use.  Free [idx,unused) */
		while (idx != unused) {
			pipe_buf_release(pipe, &pipe->bufs[idx]);
			idx = next_idx(idx, pipe);
			pipe->nrbufs--;
		}
 	}
	i->count -= orig_sz;
 }
",C,"		struct pipe_buffer *buf;
		size_t off = i->iov_offset, left = size;
		int idx = i->idx;
			left += off - pipe->bufs[idx].offset;
			if (left <= buf->len)
			left -= buf->len;
		i->iov_offset = buf->offset + left;
	i->count -= size;
	/* ... and discard everything past that point */
	pipe_truncate(i);
","	struct pipe_buffer *buf;
	int idx = i->idx;
	size_t off = i->iov_offset, orig_sz;
	orig_sz = size;
			size += off - pipe->bufs[idx].offset;
			if (size <= buf->len)
			size -= buf->len;
		buf->len = size;
		off = i->iov_offset = buf->offset + size;
	}
	if (off)
		idx = next_idx(idx, pipe);
	if (pipe->nrbufs) {
		int unused = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
		/* [curbuf,unused) is in use.  Free [idx,unused) */
		while (idx != unused) {
			pipe_buf_release(pipe, &pipe->bufs[idx]);
			idx = next_idx(idx, pipe);
			pipe->nrbufs--;
		}
	i->count -= orig_sz;
",,"@@ -730,43 +730,50 @@ size_t iov_iter_copy_from_user_atomic(struct page *page,
 }
 EXPORT_SYMBOL(iov_iter_copy_from_user_atomic);
 
+static inline void pipe_truncate(struct iov_iter *i)
+{
+	struct pipe_inode_info *pipe = i->pipe;
+	if (pipe->nrbufs) {
+		size_t off = i->iov_offset;
+		int idx = i->idx;
+		int nrbufs = (idx - pipe->curbuf) & (pipe->buffers - 1);
+		if (off) {
+			pipe->bufs[idx].len = off - pipe->bufs[idx].offset;
+			idx = next_idx(idx, pipe);
+			nrbufs++;
+		}
+		while (pipe->nrbufs > nrbufs) {
+			pipe_buf_release(pipe, &pipe->bufs[idx]);
+			idx = next_idx(idx, pipe);
+			pipe->nrbufs--;
+		}
+	}
+}
+
 static void pipe_advance(struct iov_iter *i, size_t size)
 {
 	struct pipe_inode_info *pipe = i->pipe;
-	struct pipe_buffer *buf;
-	int idx = i->idx;
-	size_t off = i->iov_offset, orig_sz;
-	
 	if (unlikely(i->count < size))
 		size = i->count;
-	orig_sz = size;
-
 	if (size) {
+		struct pipe_buffer *buf;
+		size_t off = i->iov_offset, left = size;
+		int idx = i->idx;
 		if (off) /* make it relative to the beginning of buffer */
-			size += off - pipe->bufs[idx].offset;
+			left += off - pipe->bufs[idx].offset;
 		while (1) {
 			buf = &pipe->bufs[idx];
-			if (size <= buf->len)
+			if (left <= buf->len)
 				break;
-			size -= buf->len;
+			left -= buf->len;
 			idx = next_idx(idx, pipe);
 		}
-		buf->len = size;
 		i->idx = idx;
-		off = i->iov_offset = buf->offset + size;
-	}
-	if (off)
-		idx = next_idx(idx, pipe);
-	if (pipe->nrbufs) {
-		int unused = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
-		/* [curbuf,unused) is in use.  Free [idx,unused) */
-		while (idx != unused) {
-			pipe_buf_release(pipe, &pipe->bufs[idx]);
-			idx = next_idx(idx, pipe);
-			pipe->nrbufs--;
-		}
+		i->iov_offset = buf->offset + left;
 	}
-	i->count -= orig_sz;
+	i->count -= size;
+	/* ... and discard everything past that point */
+	pipe_truncate(i);
 }
 
 void iov_iter_advance(struct iov_iter *i, size_t size)
@@ -826,6 +833,7 @@ void iov_iter_pipe(struct iov_iter *i, int direction,
 			size_t count)
 {
 	BUG_ON(direction != ITER_PIPE);
+	WARN_ON(pipe->nrbufs == pipe->buffers);
 	i->type = direction;
 	i->pipe = pipe;
 	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);",linux,b9dc6f65bc5e232d1c05fe34b5daadc7e8bbf1fb,4d22c75d4c7b5c5f4bd31054f09103ee490878fd,1," static void pipe_advance(struct iov_iter *i, size_t size)
 {
 	struct pipe_inode_info *pipe = i->pipe;
//flaw_line_below:
	struct pipe_buffer *buf;
//flaw_line_below:
	int idx = i->idx;
//flaw_line_below:
	size_t off = i->iov_offset, orig_sz;
//flaw_line_below:
	
 	if (unlikely(i->count < size))
 		size = i->count;
//flaw_line_below:
	orig_sz = size;
//flaw_line_below:

 	if (size) {
//fix_flaw_line_below:
//		struct pipe_buffer *buf;
//fix_flaw_line_below:
//		size_t off = i->iov_offset, left = size;
//fix_flaw_line_below:
//		int idx = i->idx;
 		if (off) /* make it relative to the beginning of buffer */
//flaw_line_below:
			size += off - pipe->bufs[idx].offset;
//fix_flaw_line_below:
//			left += off - pipe->bufs[idx].offset;
 		while (1) {
 			buf = &pipe->bufs[idx];
//flaw_line_below:
			if (size <= buf->len)
//fix_flaw_line_below:
//			if (left <= buf->len)
 				break;
//flaw_line_below:
			size -= buf->len;
//fix_flaw_line_below:
//			left -= buf->len;
 			idx = next_idx(idx, pipe);
 		}
//flaw_line_below:
		buf->len = size;
 		i->idx = idx;
//flaw_line_below:
		off = i->iov_offset = buf->offset + size;
//flaw_line_below:
	}
//flaw_line_below:
	if (off)
//flaw_line_below:
		idx = next_idx(idx, pipe);
//flaw_line_below:
	if (pipe->nrbufs) {
//flaw_line_below:
		int unused = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
//flaw_line_below:
		/* [curbuf,unused) is in use.  Free [idx,unused) */
//flaw_line_below:
		while (idx != unused) {
//flaw_line_below:
			pipe_buf_release(pipe, &pipe->bufs[idx]);
//flaw_line_below:
			idx = next_idx(idx, pipe);
//flaw_line_below:
			pipe->nrbufs--;
//flaw_line_below:
		}
//fix_flaw_line_below:
//		i->iov_offset = buf->offset + left;
 	}
//flaw_line_below:
	i->count -= orig_sz;
//fix_flaw_line_below:
//	i->count -= size;
//fix_flaw_line_below:
//	/* ... and discard everything past that point */
//fix_flaw_line_below:
//	pipe_truncate(i);
 }
",181560," static void pipe_advance(struct iov_iter *i, size_t size)
 {
 	struct pipe_inode_info *pipe = i->pipe;
	struct pipe_buffer *buf;
	int idx = i->idx;
	size_t off = i->iov_offset, orig_sz;
 	if (unlikely(i->count < size))
 		size = i->count;
	orig_sz = size;
 	if (size) {
 		if (off) /* make it relative to the beginning of buffer */
			size += off - pipe->bufs[idx].offset;
 		while (1) {
 			buf = &pipe->bufs[idx];
			if (size <= buf->len)
 				break;
			size -= buf->len;
 			idx = next_idx(idx, pipe);
 		}
		buf->len = size;
 		i->idx = idx;
		off = i->iov_offset = buf->offset + size;
	}
	if (off)
		idx = next_idx(idx, pipe);
	if (pipe->nrbufs) {
		int unused = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
		/* [curbuf,unused) is in use.  Free [idx,unused) */
		while (idx != unused) {
			pipe_buf_release(pipe, &pipe->bufs[idx]);
			idx = next_idx(idx, pipe);
			pipe->nrbufs--;
		}
 	}
	i->count -= orig_sz;
 }
"," static void pipe_advance(struct iov_iter *i, size_t size)
 {
 	struct pipe_inode_info *pipe = i->pipe;
 	if (unlikely(i->count < size))
 		size = i->count;
 	if (size) {
		struct pipe_buffer *buf;
		size_t off = i->iov_offset, left = size;
		int idx = i->idx;
 		if (off) /* make it relative to the beginning of buffer */
			left += off - pipe->bufs[idx].offset;
 		while (1) {
 			buf = &pipe->bufs[idx];
			if (left <= buf->len)
 				break;
			left -= buf->len;
 			idx = next_idx(idx, pipe);
 		}
 		i->idx = idx;
		i->iov_offset = buf->offset + left;
 	}
	i->count -= size;
	/* ... and discard everything past that point */
	pipe_truncate(i);
 }
","The `pipe_advance` function is designed to manage the advancement of a read or write operation on a pipe's buffer in a kernel context. It takes an `iov_iter` structure, which contains information about the current position in the pipe, and a size parameter indicating how much data to advance. The function first checks if the requested size exceeds the available data, adjusting accordingly. It then iterates through the pipe's buffers, updating the length of the current buffer and the index for the next buffer as necessary. Finally, it releases any unused buffers and updates the count of remaining data in the `iov_iter`.","The provided function manages the advancement of data processing within a pipe's buffer system. It begins by determining the amount of data to advance, ensuring it does not exceed the available data. The function then adjusts the size to account for any offset from the beginning of the current buffer. It iterates through the buffers, updating the length of the current buffer and tracking the position for the next buffer as needed. Finally, it releases any buffers that are no longer in use and updates the count of remaining data to reflect the advancement made.","The vulnerability in the original code stemmed from a fencepost error in the logic that released buffers beyond the new position, which failed when the number of buffers to release equaled the total number of buffers. This oversight resulted in uninitialized pages remaining in the pipe, leading to a potential information leak. The fix addressed this issue by introducing a dedicated function, `pipe_truncate`, to ensure that all buffers past the new position are properly discarded, regardless of the number of buffers involved. This change effectively mitigated the risk of leaving the pipe full of uninitialized data.","The vulnerability in the original code arose from a logic error that prevented the proper release of buffers when the number of buffers to be discarded matched the total number of buffers available. This oversight resulted in uninitialized memory remaining in the system, creating a potential information leak that could be exploited. The fix addressed this issue by implementing a dedicated mechanism to ensure that all buffers beyond the new position are correctly released, regardless of their count. This change effectively eliminated the risk of leaving uninitialized data in the system, thereby enhancing security.","The vulnerability was fixed by introducing the `pipe_truncate` function, which ensures that all buffers beyond the new position are properly released, addressing the previous logic error in the `pipe_advance` function. In the original code, when the number of buffers to release equaled the total number of buffers, none were released, leaving uninitialized pages in the pipe. The updated logic now guarantees that regardless of the count, the buffers are discarded correctly, preventing the information leak. This change enhances the overall integrity of the pipe management by ensuring that no uninitialized data remains accessible.","The vulnerability was fixed by implementing a dedicated mechanism to ensure that all buffers beyond the new position are correctly released, regardless of their count. This change addressed the previous logic error that allowed uninitialized memory to remain in the system when the number of buffers to discard matched the total available. By ensuring that all excess buffers are properly handled, the fix effectively eliminated the risk of information leaks, thereby enhancing the security and integrity of the memory management process. This adjustment ensures that no uninitialized data is left accessible in the system.","4,4","4,4","4,4","4,4"
80,80,181622,181622,,Remote,Not required,,CVE-2017-0377,https://www.cvedetails.com/cve/CVE-2017-0377/,CWE-200,Low,Partial,,,2017-07-02,5.0,"Tor 0.3.x before 0.3.0.9 has a guard-selection algorithm that only considers the exit relay (not the exit relay's family), which might allow remote attackers to defeat intended anonymity properties by leveraging the existence of large families.",2017-07-14,+Info ,6,https://github.com/torproject/tor/commit/665baf5ed5c6186d973c46cdea165c0548027350,665baf5ed5c6186d973c46cdea165c0548027350,"Consider the exit family when applying guard restrictions.

When the new path selection logic went into place, I accidentally
dropped the code that considered the _family_ of the exit node when
deciding if the guard was usable, and we didn't catch that during
code review.

This patch makes the guard_restriction_t code consider the exit
family as well, and adds some (hopefully redundant) checks for the
case where we lack a node_t for a guard but we have a bridge_info_t
for it.

Fixes bug 22753; bugfix on 0.3.0.1-alpha. Tracked as TROVE-2016-006
and CVE-2017-0377.",0,src/or/entrynodes.c,"{""sha"": ""32a6dfa56c91d4df10c90a584e07956a6d334d79"", ""filename"": ""changes/bug22753"", ""status"": ""added"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/torproject/tor/blob/665baf5ed5c6186d973c46cdea165c0548027350/changes/bug22753"", ""raw_url"": ""https://github.com/torproject/tor/raw/665baf5ed5c6186d973c46cdea165c0548027350/changes/bug22753"", ""contents_url"": ""https://api.github.com/repos/torproject/tor/contents/changes/bug22753?ref=665baf5ed5c6186d973c46cdea165c0548027350"", ""patch"": ""@@ -0,0 +1,7 @@\n+  o Major bugfixes (path selection, security):\n+    - When choosing which guard to use for a circuit, avoid the\n+      exit's family along with the exit itself. Previously, the new\n+      guard selection logic avoided the exit, but did not consider\n+      its family.  Fixes bug 22753; bugfix on 0.3.0.1-alpha. Tracked\n+      as TROVE-2016-006 and CVE-2017-0377.\n+""}<_**next**_>{""sha"": ""ccb080880c13dc2968a12c0e144ece79416e78f7"", ""filename"": ""src/or/entrynodes.c"", ""status"": ""modified"", ""additions"": 38, ""deletions"": 1, ""changes"": 39, ""blob_url"": ""https://github.com/torproject/tor/blob/665baf5ed5c6186d973c46cdea165c0548027350/src/or/entrynodes.c"", ""raw_url"": ""https://github.com/torproject/tor/raw/665baf5ed5c6186d973c46cdea165c0548027350/src/or/entrynodes.c"", ""contents_url"": ""https://api.github.com/repos/torproject/tor/contents/src/or/entrynodes.c?ref=665baf5ed5c6186d973c46cdea165c0548027350"", ""patch"": ""@@ -1428,6 +1428,38 @@ entry_guard_passes_filter(const or_options_t *options, guard_selection_t *gs,\n   }\n }\n \n+/** Return true iff <b>guard</b> is in the same family as <b>node</b>.\n+ */\n+static int\n+guard_in_node_family(const entry_guard_t *guard, const node_t *node)\n+{\n+  const node_t *guard_node = node_get_by_id(guard->identity);\n+  if (guard_node) {\n+    return nodes_in_same_family(guard_node, node);\n+  } else {\n+    /* If we don't have a node_t for the guard node, we might have\n+     * a bridge_info_t for it. So let's check to see whether the bridge\n+     * address matches has any family issues.\n+     *\n+     * (Strictly speaking, I believe this check is unnecessary, since we only\n+     * use it to avoid the exit's family when building circuits, and we don't\n+     * build multihop circuits until we have a routerinfo_t for the\n+     * bridge... at which point, we'll also have a node_t for the\n+     * bridge. Nonetheless, it seems wise to include it, in case our\n+     * assumptions change down the road.  -nickm.)\n+     */\n+    if (get_options()->EnforceDistinctSubnets && guard->bridge_addr) {\n+      tor_addr_t node_addr;\n+      node_get_addr(node, &node_addr);\n+      if (addrs_in_same_network_family(&node_addr,\n+                                       &guard->bridge_addr->addr)) {\n+        return 1;\n+      }\n+    }\n+    return 0;\n+  }\n+}\n+\n /**\n  * Return true iff <b>guard</b> obeys the restrictions defined in <b>rst</b>.\n  * (If <b>rst</b> is NULL, there are no restrictions.)\n@@ -1440,7 +1472,12 @@ entry_guard_obeys_restriction(const entry_guard_t *guard,\n   if (! rst)\n     return 1; // No restriction?  No problem.\n \n-  // Only one kind of restriction exists right now\n+  // Only one kind of restriction exists right now: excluding an exit\n+  // ID and all of its family.\n+  const node_t *node = node_get_by_id((const char*)rst->exclude_id);\n+  if (node && guard_in_node_family(guard, node))\n+    return 0;\n+\n   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);\n }\n ""}<_**next**_>{""sha"": ""6ccc48f32f60f6905d78222d1b677a239ac3de54"", ""filename"": ""src/or/entrynodes.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/torproject/tor/blob/665baf5ed5c6186d973c46cdea165c0548027350/src/or/entrynodes.h"", ""raw_url"": ""https://github.com/torproject/tor/raw/665baf5ed5c6186d973c46cdea165c0548027350/src/or/entrynodes.h"", ""contents_url"": ""https://api.github.com/repos/torproject/tor/contents/src/or/entrynodes.h?ref=665baf5ed5c6186d973c46cdea165c0548027350"", ""patch"": ""@@ -276,16 +276,17 @@ struct entry_guard_handle_t;\n  * A restriction to remember which entry guards are off-limits for a given\n  * circuit.\n  *\n- * Right now, we only use restrictions to block a single guard from being\n- * selected; this mechanism is designed to be more extensible in the future,\n- * however.\n+ * Right now, we only use restrictions to block a single guard and its family\n+ * from being selected; this mechanism is designed to be more extensible in\n+ * the future, however.\n  *\n  * Note: This mechanism is NOT for recording which guards are never to be\n  * used: only which guards cannot be used on <em>one particular circuit</em>.\n  */\n struct entry_guard_restriction_t {\n   /**\n-   * The guard's RSA identity digest must not equal this.\n+   * The guard's RSA identity digest must not equal this; and it must not\n+   * be in the same family as any node with this digest.\n    */\n   uint8_t exclude_id[DIGEST_LEN];\n };""}<_**next**_>{""sha"": ""2ca52e74b52edbcc0becaa43d2c3d567dcc29ef1"", ""filename"": ""src/or/nodelist.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torproject/tor/blob/665baf5ed5c6186d973c46cdea165c0548027350/src/or/nodelist.c"", ""raw_url"": ""https://github.com/torproject/tor/raw/665baf5ed5c6186d973c46cdea165c0548027350/src/or/nodelist.c"", ""contents_url"": ""https://api.github.com/repos/torproject/tor/contents/src/or/nodelist.c?ref=665baf5ed5c6186d973c46cdea165c0548027350"", ""patch"": ""@@ -1343,7 +1343,7 @@ nodelist_refresh_countries(void)\n \n /** Return true iff router1 and router2 have similar enough network addresses\n  * that we should treat them as being in the same family */\n-static inline int\n+int\n addrs_in_same_network_family(const tor_addr_t *a1,\n                              const tor_addr_t *a2)\n {""}<_**next**_>{""sha"": ""4e5301df6b975327cd3c524d5364901fe81f03df"", ""filename"": ""src/or/nodelist.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torproject/tor/blob/665baf5ed5c6186d973c46cdea165c0548027350/src/or/nodelist.h"", ""raw_url"": ""https://github.com/torproject/tor/raw/665baf5ed5c6186d973c46cdea165c0548027350/src/or/nodelist.h"", ""contents_url"": ""https://api.github.com/repos/torproject/tor/contents/src/or/nodelist.h?ref=665baf5ed5c6186d973c46cdea165c0548027350"", ""patch"": ""@@ -94,6 +94,8 @@ int node_is_unreliable(const node_t *router, int need_uptime,\n int router_exit_policy_all_nodes_reject(const tor_addr_t *addr, uint16_t port,\n                                         int need_uptime);\n void router_set_status(const char *digest, int up);\n+int addrs_in_same_network_family(const tor_addr_t *a1,\n+                                 const tor_addr_t *a2);\n \n /** router_have_minimum_dir_info tests to see if we have enough\n  * descriptor information to create circuits.""}","entry_guard_obeys_restriction(const entry_guard_t *guard,
                              const entry_guard_restriction_t *rst)
{
  tor_assert(guard);
   if (! rst)
     return 1; // No restriction?  No problem.
 
  // Only one kind of restriction exists right now: excluding an exit
  // ID and all of its family.
  const node_t *node = node_get_by_id((const char*)rst->exclude_id);
  if (node && guard_in_node_family(guard, node))
    return 0;

   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);
 }
","entry_guard_obeys_restriction(const entry_guard_t *guard,
                              const entry_guard_restriction_t *rst)
{
  tor_assert(guard);
   if (! rst)
     return 1; // No restriction?  No problem.
 
   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);
 }
",C,"  // Only one kind of restriction exists right now: excluding an exit
  // ID and all of its family.
  const node_t *node = node_get_by_id((const char*)rst->exclude_id);
  if (node && guard_in_node_family(guard, node))
    return 0;

",,,"@@ -1428,6 +1428,38 @@ entry_guard_passes_filter(const or_options_t *options, guard_selection_t *gs,
   }
 }
 
+/** Return true iff <b>guard</b> is in the same family as <b>node</b>.
+ */
+static int
+guard_in_node_family(const entry_guard_t *guard, const node_t *node)
+{
+  const node_t *guard_node = node_get_by_id(guard->identity);
+  if (guard_node) {
+    return nodes_in_same_family(guard_node, node);
+  } else {
+    /* If we don't have a node_t for the guard node, we might have
+     * a bridge_info_t for it. So let's check to see whether the bridge
+     * address matches has any family issues.
+     *
+     * (Strictly speaking, I believe this check is unnecessary, since we only
+     * use it to avoid the exit's family when building circuits, and we don't
+     * build multihop circuits until we have a routerinfo_t for the
+     * bridge... at which point, we'll also have a node_t for the
+     * bridge. Nonetheless, it seems wise to include it, in case our
+     * assumptions change down the road.  -nickm.)
+     */
+    if (get_options()->EnforceDistinctSubnets && guard->bridge_addr) {
+      tor_addr_t node_addr;
+      node_get_addr(node, &node_addr);
+      if (addrs_in_same_network_family(&node_addr,
+                                       &guard->bridge_addr->addr)) {
+        return 1;
+      }
+    }
+    return 0;
+  }
+}
+
 /**
  * Return true iff <b>guard</b> obeys the restrictions defined in <b>rst</b>.
  * (If <b>rst</b> is NULL, there are no restrictions.)
@@ -1440,7 +1472,12 @@ entry_guard_obeys_restriction(const entry_guard_t *guard,
   if (! rst)
     return 1; // No restriction?  No problem.
 
-  // Only one kind of restriction exists right now
+  // Only one kind of restriction exists right now: excluding an exit
+  // ID and all of its family.
+  const node_t *node = node_get_by_id((const char*)rst->exclude_id);
+  if (node && guard_in_node_family(guard, node))
+    return 0;
+
   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);
 }
 ",tor,665baf5ed5c6186d973c46cdea165c0548027350,a242d194c74b318b8ee4b347efd09ed13d0d2549,1,"entry_guard_obeys_restriction(const entry_guard_t *guard,
                              const entry_guard_restriction_t *rst)
{
  tor_assert(guard);
   if (! rst)
     return 1; // No restriction?  No problem.
 
//flaw_line_below:
  // Only one kind of restriction exists right now
//fix_flaw_line_below:
//  // Only one kind of restriction exists right now: excluding an exit
//fix_flaw_line_below:
//  // ID and all of its family.
//fix_flaw_line_below:
//  const node_t *node = node_get_by_id((const char*)rst->exclude_id);
//fix_flaw_line_below:
//  if (node && guard_in_node_family(guard, node))
//fix_flaw_line_below:
//    return 0;
//fix_flaw_line_below:
//
   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);
 }
",181622,"entry_guard_obeys_restriction(const entry_guard_t *guard,
                              const entry_guard_restriction_t *rst)
{
  tor_assert(guard);
   if (! rst)
     return 1; // No restriction?  No problem.
 
   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);
 }
","entry_guard_obeys_restriction(const entry_guard_t *guard,
                              const entry_guard_restriction_t *rst)
{
  tor_assert(guard);
   if (! rst)
     return 1; // No restriction?  No problem.
 
  // Only one kind of restriction exists right now: excluding an exit
  // ID and all of its family.
  const node_t *node = node_get_by_id((const char*)rst->exclude_id);
  if (node && guard_in_node_family(guard, node))
    return 0;

   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);
 }
","The function `entry_guard_obeys_restriction` checks whether a given entry guard complies with specified restrictions. It takes two parameters: a pointer to an `entry_guard_t` structure representing the guard and a pointer to an `entry_guard_restriction_t` structure defining the restrictions. The function first asserts that the guard is not null. If the restriction is null, it returns 1, indicating no restrictions apply. Otherwise, it compares the guard's identity with the restricted identity using `tor_memneq`, returning the result of this comparison. If the identities differ, the guard obeys the restriction; otherwise, it does not.","The code defines a function that determines whether a specified entry guard adheres to certain restrictions. It first checks if the guard is valid and, if no restrictions are provided, it concludes that compliance is not an issue. If restrictions are present, the function compares the identity of the guard against a specified exclusion criterion. The outcome of this comparison indicates whether the guard is compliant with the restrictions: if the identities are different, the guard is considered to be following the restrictions; if they are the same, the guard does not comply.","The vulnerability in the original code stemmed from the lack of consideration for the family of exit nodes when determining if an entry guard was usable, which could allow restricted guards to be incorrectly accepted. The fixed code addresses this by introducing a check that retrieves a node based on the exclusion ID and verifies if the guard belongs to the same family as that node. If a match is found, the function returns 0, indicating the guard does not comply with the restriction. This enhancement ensures that both the guard and its family are evaluated against the specified restrictions, improving security.","The vulnerability in the original code arose from the omission of checks related to the family of exit nodes when assessing the usability of entry guards. This oversight could lead to the acceptance of guards that should have been restricted, potentially compromising security. The revised code rectifies this issue by reintroducing logic that evaluates whether the entry guard belongs to the same family as the excluded exit node. Additionally, it incorporates checks to handle cases where information about the guard is incomplete, thereby enhancing the robustness of the restriction enforcement and preventing unauthorized access.","The vulnerability was fixed by reintroducing logic that considers the family of exit nodes when applying guard restrictions. The updated code retrieves a node using the exclusion ID and checks if the entry guard belongs to the same family as that node through the `guard_in_node_family` function. If a match is found, the function returns 0, indicating that the guard does not comply with the restriction. Additionally, the code includes checks for scenarios where a node may not be available but a bridge information structure exists, ensuring comprehensive evaluation of guard usability against the specified restrictions.","The vulnerability was fixed by reintroducing checks that evaluate the relationship between entry guards and the family of exit nodes when applying restrictions. The updated logic retrieves information about the exit node associated with the exclusion criteria and verifies if the entry guard belongs to the same family. If a match is found, the function indicates that the guard does not comply with the restrictions. Additionally, the fix includes safeguards for situations where complete information about the guard may be unavailable, ensuring a thorough assessment of guard usability against the defined restrictions and enhancing overall security.","4,3","5,5","4,4","4, 4"
81,81,182124,182124,,Local,Not required,,CVE-2018-20511,https://www.cvedetails.com/cve/CVE-2018-20511/,CWE-200,Low,Partial,,,2018-12-27,2.1,An issue was discovered in the Linux kernel before 4.18.11. The ipddp_ioctl function in drivers/net/appletalk/ipddp.c allows local users to obtain sensitive kernel address information by leveraging CAP_NET_ADMIN to read the ipddp_route dev and next fields via an SIOCFINDIPDDPRT ioctl call.,2019-04-01,+Info ,6,https://github.com/torvalds/linux/commit/9824dfae5741275473a23a7ed5756c7b6efacc9d,9824dfae5741275473a23a7ed5756c7b6efacc9d,"net/appletalk: fix minor pointer leak to userspace in SIOCFINDIPDDPRT

Fields ->dev and ->next of struct ipddp_route may be copied to
userspace on the SIOCFINDIPDDPRT ioctl. This is only accessible
to CAP_NET_ADMIN though. Let's manually copy the relevant fields
instead of using memcpy().

BugLink: http://blog.infosectcbr.com.au/2018/09/linux-kernel-infoleaks.html
Cc: Jann Horn <jannh@google.com>
Signed-off-by: Willy Tarreau <w@1wt.eu>
Signed-off-by: David S. Miller <davem@davemloft.net>",2,drivers/net/appletalk/ipddp.c,"{""sha"": ""3d27616d9c85540304a8d78c4a2f050c0866b9a2"", ""filename"": ""drivers/net/appletalk/ipddp.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 2, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/9824dfae5741275473a23a7ed5756c7b6efacc9d/drivers/net/appletalk/ipddp.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9824dfae5741275473a23a7ed5756c7b6efacc9d/drivers/net/appletalk/ipddp.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/appletalk/ipddp.c?ref=9824dfae5741275473a23a7ed5756c7b6efacc9d"", ""patch"": ""@@ -283,8 +283,12 @@ static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n                 case SIOCFINDIPDDPRT:\n \t\t\tspin_lock_bh(&ipddp_route_lock);\n \t\t\trp = __ipddp_find_route(&rcp);\n-\t\t\tif (rp)\n-\t\t\t\tmemcpy(&rcp2, rp, sizeof(rcp2));\n+\t\t\tif (rp) {\n+\t\t\t\tmemset(&rcp2, 0, sizeof(rcp2));\n+\t\t\t\trcp2.ip    = rp->ip;\n+\t\t\t\trcp2.at    = rp->at;\n+\t\t\t\trcp2.flags = rp->flags;\n+\t\t\t}\n \t\t\tspin_unlock_bh(&ipddp_route_lock);\n \n \t\t\tif (rp) {""}","static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
{
        struct ipddp_route __user *rt = ifr->ifr_data;
        struct ipddp_route rcp, rcp2, *rp;

        if(!capable(CAP_NET_ADMIN))
                return -EPERM;

	if(copy_from_user(&rcp, rt, sizeof(rcp)))
		return -EFAULT;

        switch(cmd)
        {
		case SIOCADDIPDDPRT:
                        return ipddp_create(&rcp);

                 case SIOCFINDIPDDPRT:
 			spin_lock_bh(&ipddp_route_lock);
 			rp = __ipddp_find_route(&rcp);
			if (rp) {
				memset(&rcp2, 0, sizeof(rcp2));
				rcp2.ip    = rp->ip;
				rcp2.at    = rp->at;
				rcp2.flags = rp->flags;
			}
 			spin_unlock_bh(&ipddp_route_lock);
 
 			if (rp) {
				if (copy_to_user(rt, &rcp2,
						 sizeof(struct ipddp_route)))
					return -EFAULT;
				return 0;
			} else
				return -ENOENT;

                case SIOCDELIPDDPRT:
                        return ipddp_delete(&rcp);

                default:
                        return -EINVAL;
        }
}
","static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
{
        struct ipddp_route __user *rt = ifr->ifr_data;
        struct ipddp_route rcp, rcp2, *rp;

        if(!capable(CAP_NET_ADMIN))
                return -EPERM;

	if(copy_from_user(&rcp, rt, sizeof(rcp)))
		return -EFAULT;

        switch(cmd)
        {
		case SIOCADDIPDDPRT:
                        return ipddp_create(&rcp);

                 case SIOCFINDIPDDPRT:
 			spin_lock_bh(&ipddp_route_lock);
 			rp = __ipddp_find_route(&rcp);
			if (rp)
				memcpy(&rcp2, rp, sizeof(rcp2));
 			spin_unlock_bh(&ipddp_route_lock);
 
 			if (rp) {
				if (copy_to_user(rt, &rcp2,
						 sizeof(struct ipddp_route)))
					return -EFAULT;
				return 0;
			} else
				return -ENOENT;

                case SIOCDELIPDDPRT:
                        return ipddp_delete(&rcp);

                default:
                        return -EINVAL;
        }
}
",C,"			if (rp) {
				memset(&rcp2, 0, sizeof(rcp2));
				rcp2.ip    = rp->ip;
				rcp2.at    = rp->at;
				rcp2.flags = rp->flags;
			}
","			if (rp)
				memcpy(&rcp2, rp, sizeof(rcp2));
",,"@@ -283,8 +283,12 @@ static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
                 case SIOCFINDIPDDPRT:
 			spin_lock_bh(&ipddp_route_lock);
 			rp = __ipddp_find_route(&rcp);
-			if (rp)
-				memcpy(&rcp2, rp, sizeof(rcp2));
+			if (rp) {
+				memset(&rcp2, 0, sizeof(rcp2));
+				rcp2.ip    = rp->ip;
+				rcp2.at    = rp->at;
+				rcp2.flags = rp->flags;
+			}
 			spin_unlock_bh(&ipddp_route_lock);
 
 			if (rp) {",linux,9824dfae5741275473a23a7ed5756c7b6efacc9d,018349d70f28a78d5343b3660cb66e1667005f8a,1,"static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
{
        struct ipddp_route __user *rt = ifr->ifr_data;
        struct ipddp_route rcp, rcp2, *rp;

        if(!capable(CAP_NET_ADMIN))
                return -EPERM;

	if(copy_from_user(&rcp, rt, sizeof(rcp)))
		return -EFAULT;

        switch(cmd)
        {
		case SIOCADDIPDDPRT:
                        return ipddp_create(&rcp);

                 case SIOCFINDIPDDPRT:
 			spin_lock_bh(&ipddp_route_lock);
 			rp = __ipddp_find_route(&rcp);
//flaw_line_below:
			if (rp)
//flaw_line_below:
				memcpy(&rcp2, rp, sizeof(rcp2));
//fix_flaw_line_below:
//			if (rp) {
//fix_flaw_line_below:
//				memset(&rcp2, 0, sizeof(rcp2));
//fix_flaw_line_below:
//				rcp2.ip    = rp->ip;
//fix_flaw_line_below:
//				rcp2.at    = rp->at;
//fix_flaw_line_below:
//				rcp2.flags = rp->flags;
//fix_flaw_line_below:
//			}
 			spin_unlock_bh(&ipddp_route_lock);
 
 			if (rp) {
				if (copy_to_user(rt, &rcp2,
						 sizeof(struct ipddp_route)))
					return -EFAULT;
				return 0;
			} else
				return -ENOENT;

                case SIOCDELIPDDPRT:
                        return ipddp_delete(&rcp);

                default:
                        return -EINVAL;
        }
}
",182124,"static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
{
        struct ipddp_route __user *rt = ifr->ifr_data;
        struct ipddp_route rcp, rcp2, *rp;

        if(!capable(CAP_NET_ADMIN))
                return -EPERM;

	if(copy_from_user(&rcp, rt, sizeof(rcp)))
		return -EFAULT;

        switch(cmd)
        {
		case SIOCADDIPDDPRT:
                        return ipddp_create(&rcp);

                 case SIOCFINDIPDDPRT:
 			spin_lock_bh(&ipddp_route_lock);
 			rp = __ipddp_find_route(&rcp);
			if (rp)
				memcpy(&rcp2, rp, sizeof(rcp2));
 			spin_unlock_bh(&ipddp_route_lock);
 
 			if (rp) {
				if (copy_to_user(rt, &rcp2,
						 sizeof(struct ipddp_route)))
					return -EFAULT;
				return 0;
			} else
				return -ENOENT;

                case SIOCDELIPDDPRT:
                        return ipddp_delete(&rcp);

                default:
                        return -EINVAL;
        }
}
","static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
{
        struct ipddp_route __user *rt = ifr->ifr_data;
        struct ipddp_route rcp, rcp2, *rp;

        if(!capable(CAP_NET_ADMIN))
                return -EPERM;

	if(copy_from_user(&rcp, rt, sizeof(rcp)))
		return -EFAULT;

        switch(cmd)
        {
		case SIOCADDIPDDPRT:
                        return ipddp_create(&rcp);

                 case SIOCFINDIPDDPRT:
 			spin_lock_bh(&ipddp_route_lock);
 			rp = __ipddp_find_route(&rcp);
			if (rp) {
				memset(&rcp2, 0, sizeof(rcp2));
				rcp2.ip    = rp->ip;
				rcp2.at    = rp->at;
				rcp2.flags = rp->flags;
			}
 			spin_unlock_bh(&ipddp_route_lock);
 
 			if (rp) {
				if (copy_to_user(rt, &rcp2,
						 sizeof(struct ipddp_route)))
					return -EFAULT;
				return 0;
			} else
				return -ENOENT;

                case SIOCDELIPDDPRT:
                        return ipddp_delete(&rcp);

                default:
                        return -EINVAL;
        }
}
","The `ipddp_ioctl` function is a network device control handler that manages IPDDP (Internet Protocol Datagram Delivery Protocol) routes based on commands received through the `cmd` parameter. It first checks if the caller has the necessary administrative privileges. The function then copies route data from user space to kernel space and processes commands to add, find, or delete routes. For adding and deleting routes, it calls respective functions, while for finding routes, it locks the route list, searches for the specified route, and returns the result to user space. If an invalid command is provided, it returns an error.","The provided code defines a function that handles control commands for managing network routes in a specific protocol. It begins by verifying if the caller has the necessary administrative permissions. The function then retrieves route data from user space and processes various commands to add, find, or delete routes. For adding and deleting, it invokes corresponding operations, while for finding a route, it locks the route list, searches for the specified entry, and returns the result back to user space. If an unrecognized command is received, the function returns an error indicating invalid input.","The vulnerability in the original code arises from the potential leakage of sensitive fields, specifically `dev` and `next`, from the `ipddp_route` structure to user space during the SIOCFINDIPDDPRT command. This could expose internal kernel data to user processes, even though access is restricted to users with administrative privileges. The fix implemented in the updated code involves manually copying only the relevant fields (`ip`, `at`, and `flags`) from the found route to a separate structure, ensuring that sensitive information is not inadvertently shared with user space, thus mitigating the risk of information leakage.","The vulnerability in the original code stems from the unintentional exposure of sensitive internal data to user space during a specific command execution, where certain fields of a structure could be copied directly to user space. This could lead to information leaks, even though access was restricted to users with administrative privileges. The fix implemented in the revised code involves replacing the direct copying method with a manual selection of only the necessary fields to be shared. This approach ensures that sensitive information remains protected and is not inadvertently disclosed to user processes, thereby enhancing security.","The vulnerability was fixed by replacing the direct copying of the entire structure to user space with a manual copying of only the relevant fields. In the updated code, after finding the route, the fields `ip`, `at`, and `flags` are explicitly assigned from the found route to a new structure, while the sensitive fields `dev` and `next` are omitted. This change prevents the potential leakage of internal pointers to user space, ensuring that only safe and necessary information is shared. By using this selective copying approach, the risk of exposing sensitive kernel data is effectively mitigated.","The vulnerability was fixed by changing the method of transferring data to user space from a direct copy of an entire structure to a selective copying of only the necessary fields. This approach involved explicitly assigning only the safe and relevant information to a new structure, thereby excluding sensitive internal data that could lead to information leaks. By implementing this targeted copying strategy, the code ensures that only appropriate data is shared with user processes, effectively mitigating the risk of exposing sensitive kernel information while maintaining the intended functionality.","5,5","5,5","4,4","4,4"
82,82,182171,182171,,Local,Not required,,CVE-2018-18710,https://www.cvedetails.com/cve/CVE-2018-18710/,CWE-200,Low,Partial,,,2018-10-29,2.1,An issue was discovered in the Linux kernel through 4.19. An information leak in cdrom_ioctl_select_disc in drivers/cdrom/cdrom.c could be used by local attackers to read kernel memory because a cast from unsigned long to int interferes with bounds checking. This is similar to CVE-2018-10940 and CVE-2018-16658.,2019-04-03,+Info ,1,https://github.com/torvalds/linux/commit/e4f3aa2e1e67bb48dfbaaf1cad59013d5a5bc276,e4f3aa2e1e67bb48dfbaaf1cad59013d5a5bc276,"cdrom: fix improper type cast, which can leat to information leak.

There is another cast from unsigned long to int which causes
a bounds check to fail with specially crafted input. The value is
then used as an index in the slot array in cdrom_slot_status().

This issue is similar to CVE-2018-16658 and CVE-2018-10940.

Signed-off-by: Young_X <YangX92@hotmail.com>
Signed-off-by: Jens Axboe <axboe@kernel.dk>",1,drivers/cdrom/cdrom.c,"{""sha"": ""10802d1fc554c02a696371639a3869f22c06736c"", ""filename"": ""drivers/cdrom/cdrom.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/e4f3aa2e1e67bb48dfbaaf1cad59013d5a5bc276/drivers/cdrom/cdrom.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e4f3aa2e1e67bb48dfbaaf1cad59013d5a5bc276/drivers/cdrom/cdrom.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/cdrom/cdrom.c?ref=e4f3aa2e1e67bb48dfbaaf1cad59013d5a5bc276"", ""patch"": ""@@ -2445,7 +2445,7 @@ static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n \t\treturn -ENOSYS;\n \n \tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n-\t\tif ((int)arg >= cdi->capacity)\n+\t\tif (arg >= cdi->capacity)\n \t\t\treturn -EINVAL;\n \t}\n ""}","static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,
		unsigned long arg)
{
	cd_dbg(CD_DO_IOCTL, ""entering CDROM_SELECT_DISC\n"");

	if (!CDROM_CAN(CDC_SELECT_DISC))
 		return -ENOSYS;
 
 	if (arg != CDSL_CURRENT && arg != CDSL_NONE) {
		if (arg >= cdi->capacity)
 			return -EINVAL;
 	}
 
	/*
	 * ->select_disc is a hook to allow a driver-specific way of
	 * seleting disc.  However, since there is no equivalent hook for
	 * cdrom_slot_status this may not actually be useful...
	 */
	if (cdi->ops->select_disc)
		return cdi->ops->select_disc(cdi, arg);

	cd_dbg(CD_CHANGER, ""Using generic cdrom_select_disc()\n"");
	return cdrom_select_disc(cdi, arg);
}
","static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,
		unsigned long arg)
{
	cd_dbg(CD_DO_IOCTL, ""entering CDROM_SELECT_DISC\n"");

	if (!CDROM_CAN(CDC_SELECT_DISC))
 		return -ENOSYS;
 
 	if (arg != CDSL_CURRENT && arg != CDSL_NONE) {
		if ((int)arg >= cdi->capacity)
 			return -EINVAL;
 	}
 
	/*
	 * ->select_disc is a hook to allow a driver-specific way of
	 * seleting disc.  However, since there is no equivalent hook for
	 * cdrom_slot_status this may not actually be useful...
	 */
	if (cdi->ops->select_disc)
		return cdi->ops->select_disc(cdi, arg);

	cd_dbg(CD_CHANGER, ""Using generic cdrom_select_disc()\n"");
	return cdrom_select_disc(cdi, arg);
}
",C,"		if (arg >= cdi->capacity)
","		if ((int)arg >= cdi->capacity)
",,"@@ -2445,7 +2445,7 @@ static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,
 		return -ENOSYS;
 
 	if (arg != CDSL_CURRENT && arg != CDSL_NONE) {
-		if ((int)arg >= cdi->capacity)
+		if (arg >= cdi->capacity)
 			return -EINVAL;
 	}
 ",linux,e4f3aa2e1e67bb48dfbaaf1cad59013d5a5bc276,fb6360b1ef33b7799e6a81e1075a47e3b8ae01fd,1,"static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,
		unsigned long arg)
{
	cd_dbg(CD_DO_IOCTL, ""entering CDROM_SELECT_DISC\n"");

	if (!CDROM_CAN(CDC_SELECT_DISC))
 		return -ENOSYS;
 
 	if (arg != CDSL_CURRENT && arg != CDSL_NONE) {
//flaw_line_below:
		if ((int)arg >= cdi->capacity)
//fix_flaw_line_below:
//		if (arg >= cdi->capacity)
 			return -EINVAL;
 	}
 
	/*
	 * ->select_disc is a hook to allow a driver-specific way of
	 * seleting disc.  However, since there is no equivalent hook for
	 * cdrom_slot_status this may not actually be useful...
	 */
	if (cdi->ops->select_disc)
		return cdi->ops->select_disc(cdi, arg);

	cd_dbg(CD_CHANGER, ""Using generic cdrom_select_disc()\n"");
	return cdrom_select_disc(cdi, arg);
}
",182171,"static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,
		unsigned long arg)
{
	cd_dbg(CD_DO_IOCTL, ""entering CDROM_SELECT_DISC\n"");

	if (!CDROM_CAN(CDC_SELECT_DISC))
 		return -ENOSYS;
 
 	if (arg != CDSL_CURRENT && arg != CDSL_NONE) {
		if ((int)arg >= cdi->capacity)
 			return -EINVAL;
 	}
 
	/*
	 * ->select_disc is a hook to allow a driver-specific way of
	 * seleting disc.  However, since there is no equivalent hook for
	 * cdrom_slot_status this may not actually be useful...
	 */
	if (cdi->ops->select_disc)
		return cdi->ops->select_disc(cdi, arg);

	cd_dbg(CD_CHANGER, ""Using generic cdrom_select_disc()\n"");
	return cdrom_select_disc(cdi, arg);
}
","static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,
		unsigned long arg)
{
	cd_dbg(CD_DO_IOCTL, ""entering CDROM_SELECT_DISC\n"");

	if (!CDROM_CAN(CDC_SELECT_DISC))
 		return -ENOSYS;
 
 	if (arg != CDSL_CURRENT && arg != CDSL_NONE) {
		if (arg >= cdi->capacity)
 			return -EINVAL;
 	}
 
	/*
	 * ->select_disc is a hook to allow a driver-specific way of
	 * seleting disc.  However, since there is no equivalent hook for
	 * cdrom_slot_status this may not actually be useful...
	 */
	if (cdi->ops->select_disc)
		return cdi->ops->select_disc(cdi, arg);

	cd_dbg(CD_CHANGER, ""Using generic cdrom_select_disc()\n"");
	return cdrom_select_disc(cdi, arg);
}
","The `cdrom_ioctl_select_disc` function is designed to handle the selection of a disc in a CD-ROM device. It first checks if the device supports the selection operation; if not, it returns an error. The function validates the provided argument to ensure it is either the current disc or a valid disc index within the device's capacity. If a specific driver implementation for selecting a disc exists, it invokes that method; otherwise, it defaults to a generic selection function. Debugging messages are logged to track the function's execution and decisions made during the process.","The provided code defines a function that manages the selection of a disc in a CD-ROM device. It begins by verifying if the device supports the selection operation; if not, it returns an error. The function checks the input argument to ensure it corresponds to either the currently selected disc or a valid index within the device's capacity. If a specific method for selecting a disc is available, it calls that method; otherwise, it falls back on a standard selection process. Throughout the execution, debugging information is logged to monitor the function's flow and decisions.","The vulnerability in the original code arises from an improper type cast from `unsigned long` to `int`, which can lead to a failure in bounds checking when the input is specially crafted. This allows an attacker to provide an out-of-bounds index that could be used in the `cdrom_slot_status()` function, potentially leading to an information leak. The fix addresses this issue by ensuring that the argument is properly validated against the device's capacity before being used as an index, thus preventing any out-of-bounds access and enhancing the overall security of the code.","The vulnerability in the original code stems from an improper type cast that converts an unsigned long value to an int, which can lead to inadequate bounds checking when handling specially crafted input. This flaw allows an attacker to exploit the system by providing an out-of-bounds index, potentially resulting in an information leak when accessing an array. The fix rectifies this issue by ensuring that the input is thoroughly validated against the device's capacity before being used as an index, thereby preventing any out-of-bounds access and enhancing the security of the code.","The vulnerability was fixed by modifying the bounds check for the `arg` variable to ensure it is properly validated against the device's capacity before being used as an index. In the updated code, the condition checks if `arg` is not equal to specific constants and then verifies that `arg` is less than `cdi->capacity`. This change prevents the improper type cast from leading to an out-of-bounds access in the `cdrom_slot_status()` function. By enforcing this validation, the code now safeguards against potential information leaks caused by specially crafted input.","The vulnerability was addressed by enhancing the validation process for the input argument to ensure it falls within acceptable bounds before being used as an index. The updated code includes a check that confirms the input is either a specific constant or a valid index that does not exceed the device's capacity. This adjustment prevents the possibility of out-of-bounds access, which could lead to information leaks. By implementing these stricter checks, the code now effectively mitigates the risk associated with improperly cast values and reinforces overall security.","4,4","4, 4","4,3","4,4"
83,83,182276,182276,,Remote,Not required,,CVE-2018-15473,https://www.cvedetails.com/cve/CVE-2018-15473/,CWE-200,Low,Partial,,,2018-08-17,5.0,"OpenSSH through 7.7 is prone to a user enumeration vulnerability due to not delaying bailout for an invalid authenticating user until after the packet containing the request has been fully parsed, related to auth2-gss.c, auth2-hostbased.c, and auth2-pubkey.c.",2019-08-06,+Info ,6,https://github.com/openbsd/src/commit/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0,779974d35b4859c07bc3cb8a12c74b43b0a7d1e0,"delay bailout for invalid authenticating user until after the packet
containing the request has been fully parsed. Reported by Dariusz Tytko
and Michał Sajdak; ok deraadt",2,usr.bin/ssh/auth2-gss.c,"{""sha"": ""c919ef4c353bc8885ad696db8e8997a468463b1f"", ""filename"": ""usr.bin/ssh/auth2-gss.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 4, ""changes"": 11, ""blob_url"": ""https://github.com/openbsd/src/blob/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0/usr.bin/ssh/auth2-gss.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0/usr.bin/ssh/auth2-gss.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/auth2-gss.c?ref=779974d35b4859c07bc3cb8a12c74b43b0a7d1e0"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: auth2-gss.c,v 1.28 2018/07/10 09:13:30 djm Exp $ */\n+/* $OpenBSD: auth2-gss.c,v 1.29 2018/07/31 03:10:27 djm Exp $ */\n \n /*\n  * Copyright (c) 2001-2003 Simon Wilkinson. All rights reserved.\n@@ -65,9 +65,6 @@ userauth_gssapi(struct ssh *ssh)\n \tsize_t len;\n \tu_char *doid = NULL;\n \n-\tif (!authctxt->valid || authctxt->user == NULL)\n-\t\treturn (0);\n-\n \tif ((r = sshpkt_get_u32(ssh, &mechs)) != 0)\n \t\tfatal(\""%s: %s\"", __func__, ssh_err(r));\n \n@@ -101,6 +98,12 @@ userauth_gssapi(struct ssh *ssh)\n \t\treturn (0);\n \t}\n \n+\tif (!authctxt->valid || authctxt->user == NULL) {\n+\t\tdebug2(\""%s: disabled because of invalid user\"", __func__);\n+\t\tfree(doid);\n+\t\treturn (0);\n+\t}\n+\n \tif (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {\n \t\tif (ctxt != NULL)\n \t\t\tssh_gssapi_delete_ctx(&ctxt);""}<_**next**_>{""sha"": ""fb5e5f42272401d4839e87f58ed3939864feff8e"", ""filename"": ""usr.bin/ssh/auth2-hostbased.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 5, ""changes"": 11, ""blob_url"": ""https://github.com/openbsd/src/blob/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0/usr.bin/ssh/auth2-hostbased.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0/usr.bin/ssh/auth2-hostbased.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/auth2-hostbased.c?ref=779974d35b4859c07bc3cb8a12c74b43b0a7d1e0"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: auth2-hostbased.c,v 1.35 2018/07/09 21:35:50 markus Exp $ */\n+/* $OpenBSD: auth2-hostbased.c,v 1.36 2018/07/31 03:10:27 djm Exp $ */\n /*\n  * Copyright (c) 2000 Markus Friedl.  All rights reserved.\n  *\n@@ -66,10 +66,6 @@ userauth_hostbased(struct ssh *ssh)\n \tsize_t alen, blen, slen;\n \tint r, pktype, authenticated = 0;\n \n-\tif (!authctxt->valid) {\n-\t\tdebug2(\""%s: disabled because of invalid user\"", __func__);\n-\t\treturn 0;\n-\t}\n \t/* XXX use sshkey_froms() */\n \tif ((r = sshpkt_get_cstring(ssh, &pkalg, &alen)) != 0 ||\n \t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0 ||\n@@ -116,6 +112,11 @@ userauth_hostbased(struct ssh *ssh)\n \t\tgoto done;\n \t}\n \n+\tif (!authctxt->valid || authctxt->user == NULL) {\n+\t\tdebug2(\""%s: disabled because of invalid user\"", __func__);\n+\t\tgoto done;\n+\t}\n+\n \tif ((b = sshbuf_new()) == NULL)\n \t\tfatal(\""%s: sshbuf_new failed\"", __func__);\n \t/* reconstruct packet */""}<_**next**_>{""sha"": ""af9e5f04c45f7eb47ff3ad37655d5d49fc9a24a9"", ""filename"": ""usr.bin/ssh/auth2-pubkey.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 10, ""changes"": 25, ""blob_url"": ""https://github.com/openbsd/src/blob/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0/usr.bin/ssh/auth2-pubkey.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0/usr.bin/ssh/auth2-pubkey.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/auth2-pubkey.c?ref=779974d35b4859c07bc3cb8a12c74b43b0a7d1e0"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: auth2-pubkey.c,v 1.82 2018/07/11 18:55:11 markus Exp $ */\n+/* $OpenBSD: auth2-pubkey.c,v 1.83 2018/07/31 03:10:27 djm Exp $ */\n /*\n  * Copyright (c) 2000 Markus Friedl.  All rights reserved.\n  *\n@@ -86,19 +86,15 @@ userauth_pubkey(struct ssh *ssh)\n {\n \tAuthctxt *authctxt = ssh->authctxt;\n \tstruct passwd *pw = authctxt->pw;\n-\tstruct sshbuf *b;\n+\tstruct sshbuf *b = NULL;\n \tstruct sshkey *key = NULL;\n-\tchar *pkalg, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;\n-\tu_char *pkblob, *sig, have_sig;\n+\tchar *pkalg = NULL, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;\n+\tu_char *pkblob = NULL, *sig = NULL, have_sig;\n \tsize_t blen, slen;\n \tint r, pktype;\n \tint authenticated = 0;\n \tstruct sshauthopt *authopts = NULL;\n \n-\tif (!authctxt->valid) {\n-\t\tdebug2(\""%s: disabled because of invalid user\"", __func__);\n-\t\treturn 0;\n-\t}\n \tif ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||\n \t    (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||\n \t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)\n@@ -164,6 +160,11 @@ userauth_pubkey(struct ssh *ssh)\n \t\t\t\tfatal(\""%s: sshbuf_put_string session id: %s\"",\n \t\t\t\t    __func__, ssh_err(r));\n \t\t}\n+\t\tif (!authctxt->valid || authctxt->user == NULL) {\n+\t\t\tdebug2(\""%s: disabled because of invalid user\"",\n+\t\t\t    __func__);\n+\t\t\tgoto done;\n+\t\t}\n \t\t/* reconstruct packet */\n \t\txasprintf(&userstyle, \""%s%s%s\"", authctxt->user,\n \t\t    authctxt->style ? \"":\"" : \""\"",\n@@ -180,7 +181,6 @@ userauth_pubkey(struct ssh *ssh)\n #ifdef DEBUG_PK\n \t\tsshbuf_dump(b, stderr);\n #endif\n-\n \t\t/* test for correct signature */\n \t\tauthenticated = 0;\n \t\tif (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&\n@@ -191,7 +191,6 @@ userauth_pubkey(struct ssh *ssh)\n \t\t\tauthenticated = 1;\n \t\t}\n \t\tsshbuf_free(b);\n-\t\tfree(sig);\n \t\tauth2_record_key(authctxt, authenticated, key);\n \t} else {\n \t\tdebug(\""%s: test pkalg %s pkblob %s%s%s\"",\n@@ -202,6 +201,11 @@ userauth_pubkey(struct ssh *ssh)\n \t\tif ((r = sshpkt_get_end(ssh)) != 0)\n \t\t\tfatal(\""%s: %s\"", __func__, ssh_err(r));\n \n+\t\tif (!authctxt->valid || authctxt->user == NULL) {\n+\t\t\tdebug2(\""%s: disabled because of invalid user\"",\n+\t\t\t    __func__);\n+\t\t\tgoto done;\n+\t\t}\n \t\t/* XXX fake reply and always send PK_OK ? */\n \t\t/*\n \t\t * XXX this allows testing whether a user is allowed\n@@ -235,6 +239,7 @@ userauth_pubkey(struct ssh *ssh)\n \tfree(pkblob);\n \tfree(key_s);\n \tfree(ca_s);\n+\tfree(sig);\n \treturn authenticated;\n }\n ""}","userauth_gssapi(struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	gss_OID_desc goid = {0, NULL};
	Gssctxt *ctxt = NULL;
	int r, present;
	u_int mechs;
	OM_uint32 ms;
 	size_t len;
 	u_char *doid = NULL;
 
 	if ((r = sshpkt_get_u32(ssh, &mechs)) != 0)
 		fatal(""%s: %s"", __func__, ssh_err(r));
 
	if (mechs == 0) {
		debug(""Mechanism negotiation is not supported"");
		return (0);
	}

	do {
		mechs--;

		free(doid);

		present = 0;
		if ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)
			fatal(""%s: %s"", __func__, ssh_err(r));

		if (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&
		    doid[1] == len - 2) {
			goid.elements = doid + 2;
			goid.length   = len - 2;
			ssh_gssapi_test_oid_supported(&ms, &goid, &present);
		} else {
			logit(""Badly formed OID received"");
		}
	} while (mechs > 0 && !present);

	if (!present) {
		free(doid);
		authctxt->server_caused_failure = 1;
 		return (0);
 	}
 
	if (!authctxt->valid || authctxt->user == NULL) {
		debug2(""%s: disabled because of invalid user"", __func__);
		free(doid);
		return (0);
	}

 	if (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {
 		if (ctxt != NULL)
 			ssh_gssapi_delete_ctx(&ctxt);
		free(doid);
		authctxt->server_caused_failure = 1;
		return (0);
	}

	authctxt->methoddata = (void *)ctxt;

	/* Return the OID that we received */
	if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||
	    (r = sshpkt_put_string(ssh, doid, len)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0)
		fatal(""%s: %s"", __func__, ssh_err(r));

	free(doid);

	ssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);
	ssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);
	authctxt->postponed = 1;

	return (0);
}
","userauth_gssapi(struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	gss_OID_desc goid = {0, NULL};
	Gssctxt *ctxt = NULL;
	int r, present;
	u_int mechs;
	OM_uint32 ms;
 	size_t len;
 	u_char *doid = NULL;
 
	if (!authctxt->valid || authctxt->user == NULL)
		return (0);
 	if ((r = sshpkt_get_u32(ssh, &mechs)) != 0)
 		fatal(""%s: %s"", __func__, ssh_err(r));
 
	if (mechs == 0) {
		debug(""Mechanism negotiation is not supported"");
		return (0);
	}

	do {
		mechs--;

		free(doid);

		present = 0;
		if ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)
			fatal(""%s: %s"", __func__, ssh_err(r));

		if (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&
		    doid[1] == len - 2) {
			goid.elements = doid + 2;
			goid.length   = len - 2;
			ssh_gssapi_test_oid_supported(&ms, &goid, &present);
		} else {
			logit(""Badly formed OID received"");
		}
	} while (mechs > 0 && !present);

	if (!present) {
		free(doid);
		authctxt->server_caused_failure = 1;
 		return (0);
 	}
 
 	if (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {
 		if (ctxt != NULL)
 			ssh_gssapi_delete_ctx(&ctxt);
		free(doid);
		authctxt->server_caused_failure = 1;
		return (0);
	}

	authctxt->methoddata = (void *)ctxt;

	/* Return the OID that we received */
	if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||
	    (r = sshpkt_put_string(ssh, doid, len)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0)
		fatal(""%s: %s"", __func__, ssh_err(r));

	free(doid);

	ssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);
	ssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);
	authctxt->postponed = 1;

	return (0);
}
",C,"	if (!authctxt->valid || authctxt->user == NULL) {
		debug2(""%s: disabled because of invalid user"", __func__);
		free(doid);
		return (0);
	}

","	if (!authctxt->valid || authctxt->user == NULL)
		return (0);
",,"@@ -1,4 +1,4 @@
-/* $OpenBSD: auth2-gss.c,v 1.28 2018/07/10 09:13:30 djm Exp $ */
+/* $OpenBSD: auth2-gss.c,v 1.29 2018/07/31 03:10:27 djm Exp $ */
 
 /*
  * Copyright (c) 2001-2003 Simon Wilkinson. All rights reserved.
@@ -65,9 +65,6 @@ userauth_gssapi(struct ssh *ssh)
 	size_t len;
 	u_char *doid = NULL;
 
-	if (!authctxt->valid || authctxt->user == NULL)
-		return (0);
-
 	if ((r = sshpkt_get_u32(ssh, &mechs)) != 0)
 		fatal(""%s: %s"", __func__, ssh_err(r));
 
@@ -101,6 +98,12 @@ userauth_gssapi(struct ssh *ssh)
 		return (0);
 	}
 
+	if (!authctxt->valid || authctxt->user == NULL) {
+		debug2(""%s: disabled because of invalid user"", __func__);
+		free(doid);
+		return (0);
+	}
+
 	if (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {
 		if (ctxt != NULL)
 			ssh_gssapi_delete_ctx(&ctxt);",src,779974d35b4859c07bc3cb8a12c74b43b0a7d1e0,1addc7ae5beca221ada86e5a67a6872f22c23fd1,1,"userauth_gssapi(struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	gss_OID_desc goid = {0, NULL};
	Gssctxt *ctxt = NULL;
	int r, present;
	u_int mechs;
	OM_uint32 ms;
 	size_t len;
 	u_char *doid = NULL;
 
//flaw_line_below:
	if (!authctxt->valid || authctxt->user == NULL)
//flaw_line_below:
		return (0);
//flaw_line_below:

 	if ((r = sshpkt_get_u32(ssh, &mechs)) != 0)
 		fatal(""%s: %s"", __func__, ssh_err(r));
 
	if (mechs == 0) {
		debug(""Mechanism negotiation is not supported"");
		return (0);
	}

	do {
		mechs--;

		free(doid);

		present = 0;
		if ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)
			fatal(""%s: %s"", __func__, ssh_err(r));

		if (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&
		    doid[1] == len - 2) {
			goid.elements = doid + 2;
			goid.length   = len - 2;
			ssh_gssapi_test_oid_supported(&ms, &goid, &present);
		} else {
			logit(""Badly formed OID received"");
		}
	} while (mechs > 0 && !present);

	if (!present) {
		free(doid);
		authctxt->server_caused_failure = 1;
 		return (0);
 	}
 
//fix_flaw_line_below:
//	if (!authctxt->valid || authctxt->user == NULL) {
//fix_flaw_line_below:
//		debug2(""%s: disabled because of invalid user"", __func__);
//fix_flaw_line_below:
//		free(doid);
//fix_flaw_line_below:
//		return (0);
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	if (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {
 		if (ctxt != NULL)
 			ssh_gssapi_delete_ctx(&ctxt);
		free(doid);
		authctxt->server_caused_failure = 1;
		return (0);
	}

	authctxt->methoddata = (void *)ctxt;

	/* Return the OID that we received */
	if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||
	    (r = sshpkt_put_string(ssh, doid, len)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0)
		fatal(""%s: %s"", __func__, ssh_err(r));

	free(doid);

	ssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);
	ssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);
	authctxt->postponed = 1;

	return (0);
}
",182276,"userauth_gssapi(struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	gss_OID_desc goid = {0, NULL};
	Gssctxt *ctxt = NULL;
	int r, present;
	u_int mechs;
	OM_uint32 ms;
 	size_t len;
 	u_char *doid = NULL;
 
	if (!authctxt->valid || authctxt->user == NULL)
		return (0);
 	if ((r = sshpkt_get_u32(ssh, &mechs)) != 0)
 		fatal(""%s: %s"", __func__, ssh_err(r));
 
	if (mechs == 0) {
		debug(""Mechanism negotiation is not supported"");
		return (0);
	}

	do {
		mechs--;

		free(doid);

		present = 0;
		if ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)
			fatal(""%s: %s"", __func__, ssh_err(r));

		if (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&
		    doid[1] == len - 2) {
			goid.elements = doid + 2;
			goid.length   = len - 2;
			ssh_gssapi_test_oid_supported(&ms, &goid, &present);
		} else {
			logit(""Badly formed OID received"");
		}
	} while (mechs > 0 && !present);

	if (!present) {
		free(doid);
		authctxt->server_caused_failure = 1;
 		return (0);
 	}
 
 	if (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {
 		if (ctxt != NULL)
 			ssh_gssapi_delete_ctx(&ctxt);
		free(doid);
		authctxt->server_caused_failure = 1;
		return (0);
	}

	authctxt->methoddata = (void *)ctxt;

	/* Return the OID that we received */
	if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||
	    (r = sshpkt_put_string(ssh, doid, len)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0)
		fatal(""%s: %s"", __func__, ssh_err(r));

	free(doid);

	ssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);
	ssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);
	authctxt->postponed = 1;

	return (0);
}
","userauth_gssapi(struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	gss_OID_desc goid = {0, NULL};
	Gssctxt *ctxt = NULL;
	int r, present;
	u_int mechs;
	OM_uint32 ms;
 	size_t len;
 	u_char *doid = NULL;
 
 	if ((r = sshpkt_get_u32(ssh, &mechs)) != 0)
 		fatal(""%s: %s"", __func__, ssh_err(r));
 
	if (mechs == 0) {
		debug(""Mechanism negotiation is not supported"");
		return (0);
	}

	do {
		mechs--;

		free(doid);

		present = 0;
		if ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)
			fatal(""%s: %s"", __func__, ssh_err(r));

		if (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&
		    doid[1] == len - 2) {
			goid.elements = doid + 2;
			goid.length   = len - 2;
			ssh_gssapi_test_oid_supported(&ms, &goid, &present);
		} else {
			logit(""Badly formed OID received"");
		}
	} while (mechs > 0 && !present);

	if (!present) {
		free(doid);
		authctxt->server_caused_failure = 1;
 		return (0);
 	}
 
	if (!authctxt->valid || authctxt->user == NULL) {
		debug2(""%s: disabled because of invalid user"", __func__);
		free(doid);
		return (0);
	}

 	if (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {
 		if (ctxt != NULL)
 			ssh_gssapi_delete_ctx(&ctxt);
		free(doid);
		authctxt->server_caused_failure = 1;
		return (0);
	}

	authctxt->methoddata = (void *)ctxt;

	/* Return the OID that we received */
	if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||
	    (r = sshpkt_put_string(ssh, doid, len)) != 0 ||
	    (r = sshpkt_send(ssh)) != 0)
		fatal(""%s: %s"", __func__, ssh_err(r));

	free(doid);

	ssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);
	ssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);
	authctxt->postponed = 1;

	return (0);
}
","The `userauth_gssapi` function facilitates GSSAPI-based user authentication in an SSH context. It first checks the validity of the authentication context and retrieves the number of mechanisms supported. If no mechanisms are available, it logs a debug message and exits. The function then processes the received OID (Object Identifier) strings, validating their format and checking if they are supported. If a valid mechanism is found, it establishes a GSSAPI context. Finally, it sends a response back to the client with the OID and sets up message dispatching for further GSSAPI token exchanges, marking the authentication as postponed.","The function manages GSSAPI-based user authentication within an SSH session. It begins by verifying the authentication context and checking for supported mechanisms. If no mechanisms are available, it logs a message and exits. The function processes incoming identifiers, ensuring they are correctly formatted and supported. Upon finding a valid mechanism, it establishes a context for GSSAPI communication. It then sends a response back to the client containing the identifier and prepares for further exchanges of authentication tokens, indicating that the authentication process is temporarily paused for additional steps.","The vulnerability in the original code stemmed from prematurely checking the validity of the authentication context before fully processing the incoming packet. This could lead to a situation where an invalid user was rejected without properly parsing the request, potentially allowing for improper handling of authentication mechanisms. The fix involved moving the validity check for the authentication context to a later point in the code, specifically after the packet containing the request had been completely parsed. This change ensures that all necessary data is processed before determining if the user is valid, enhancing the robustness of the authentication flow.","The vulnerability in the original code arose from an early validation check of the user's authentication context, which could lead to rejecting an invalid user before fully processing the incoming request packet. This premature check risked improper handling of authentication mechanisms and could potentially allow for exploitation. The fix involved delaying the validation of the user's authenticity until after the entire request packet had been parsed. This adjustment ensures that all relevant data is considered before determining the validity of the user, thereby improving the security and integrity of the authentication process.","The vulnerability was fixed by relocating the check for the validity of the authentication context to a point after the packet containing the request had been fully parsed. In the updated code, the condition that checks if the authentication context is valid or if the user is null was moved below the parsing of the mechanisms and identifiers. This change ensures that the code first processes the incoming packet, including the retrieval of the mechanisms and identifiers, before determining if the user is valid. As a result, the authentication process is more robust and less prone to premature failures.","The vulnerability was addressed by postponing the validation of the user's authentication context until after the complete parsing of the incoming request packet. This adjustment allowed the code to first process all relevant data, including mechanisms and identifiers, before checking if the user was valid. By ensuring that the authentication context was evaluated only after the necessary information had been gathered, the fix improved the overall robustness of the authentication process, reducing the risk of premature rejections and enhancing the security of the system against potential exploitation.","4,4","5,5","4,4","4,4"
84,84,182277,182277,,Remote,Not required,,CVE-2018-15473,https://www.cvedetails.com/cve/CVE-2018-15473/,CWE-200,Low,Partial,,,2018-08-17,5.0,"OpenSSH through 7.7 is prone to a user enumeration vulnerability due to not delaying bailout for an invalid authenticating user until after the packet containing the request has been fully parsed, related to auth2-gss.c, auth2-hostbased.c, and auth2-pubkey.c.",2019-08-06,+Info ,5,https://github.com/openbsd/src/commit/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0,779974d35b4859c07bc3cb8a12c74b43b0a7d1e0,"delay bailout for invalid authenticating user until after the packet
containing the request has been fully parsed. Reported by Dariusz Tytko
and Michał Sajdak; ok deraadt",4,usr.bin/ssh/auth2-hostbased.c,"{""sha"": ""c919ef4c353bc8885ad696db8e8997a468463b1f"", ""filename"": ""usr.bin/ssh/auth2-gss.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 4, ""changes"": 11, ""blob_url"": ""https://github.com/openbsd/src/blob/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0/usr.bin/ssh/auth2-gss.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0/usr.bin/ssh/auth2-gss.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/auth2-gss.c?ref=779974d35b4859c07bc3cb8a12c74b43b0a7d1e0"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: auth2-gss.c,v 1.28 2018/07/10 09:13:30 djm Exp $ */\n+/* $OpenBSD: auth2-gss.c,v 1.29 2018/07/31 03:10:27 djm Exp $ */\n \n /*\n  * Copyright (c) 2001-2003 Simon Wilkinson. All rights reserved.\n@@ -65,9 +65,6 @@ userauth_gssapi(struct ssh *ssh)\n \tsize_t len;\n \tu_char *doid = NULL;\n \n-\tif (!authctxt->valid || authctxt->user == NULL)\n-\t\treturn (0);\n-\n \tif ((r = sshpkt_get_u32(ssh, &mechs)) != 0)\n \t\tfatal(\""%s: %s\"", __func__, ssh_err(r));\n \n@@ -101,6 +98,12 @@ userauth_gssapi(struct ssh *ssh)\n \t\treturn (0);\n \t}\n \n+\tif (!authctxt->valid || authctxt->user == NULL) {\n+\t\tdebug2(\""%s: disabled because of invalid user\"", __func__);\n+\t\tfree(doid);\n+\t\treturn (0);\n+\t}\n+\n \tif (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {\n \t\tif (ctxt != NULL)\n \t\t\tssh_gssapi_delete_ctx(&ctxt);""}<_**next**_>{""sha"": ""fb5e5f42272401d4839e87f58ed3939864feff8e"", ""filename"": ""usr.bin/ssh/auth2-hostbased.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 5, ""changes"": 11, ""blob_url"": ""https://github.com/openbsd/src/blob/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0/usr.bin/ssh/auth2-hostbased.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0/usr.bin/ssh/auth2-hostbased.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/auth2-hostbased.c?ref=779974d35b4859c07bc3cb8a12c74b43b0a7d1e0"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: auth2-hostbased.c,v 1.35 2018/07/09 21:35:50 markus Exp $ */\n+/* $OpenBSD: auth2-hostbased.c,v 1.36 2018/07/31 03:10:27 djm Exp $ */\n /*\n  * Copyright (c) 2000 Markus Friedl.  All rights reserved.\n  *\n@@ -66,10 +66,6 @@ userauth_hostbased(struct ssh *ssh)\n \tsize_t alen, blen, slen;\n \tint r, pktype, authenticated = 0;\n \n-\tif (!authctxt->valid) {\n-\t\tdebug2(\""%s: disabled because of invalid user\"", __func__);\n-\t\treturn 0;\n-\t}\n \t/* XXX use sshkey_froms() */\n \tif ((r = sshpkt_get_cstring(ssh, &pkalg, &alen)) != 0 ||\n \t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0 ||\n@@ -116,6 +112,11 @@ userauth_hostbased(struct ssh *ssh)\n \t\tgoto done;\n \t}\n \n+\tif (!authctxt->valid || authctxt->user == NULL) {\n+\t\tdebug2(\""%s: disabled because of invalid user\"", __func__);\n+\t\tgoto done;\n+\t}\n+\n \tif ((b = sshbuf_new()) == NULL)\n \t\tfatal(\""%s: sshbuf_new failed\"", __func__);\n \t/* reconstruct packet */""}<_**next**_>{""sha"": ""af9e5f04c45f7eb47ff3ad37655d5d49fc9a24a9"", ""filename"": ""usr.bin/ssh/auth2-pubkey.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 10, ""changes"": 25, ""blob_url"": ""https://github.com/openbsd/src/blob/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0/usr.bin/ssh/auth2-pubkey.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0/usr.bin/ssh/auth2-pubkey.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/auth2-pubkey.c?ref=779974d35b4859c07bc3cb8a12c74b43b0a7d1e0"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: auth2-pubkey.c,v 1.82 2018/07/11 18:55:11 markus Exp $ */\n+/* $OpenBSD: auth2-pubkey.c,v 1.83 2018/07/31 03:10:27 djm Exp $ */\n /*\n  * Copyright (c) 2000 Markus Friedl.  All rights reserved.\n  *\n@@ -86,19 +86,15 @@ userauth_pubkey(struct ssh *ssh)\n {\n \tAuthctxt *authctxt = ssh->authctxt;\n \tstruct passwd *pw = authctxt->pw;\n-\tstruct sshbuf *b;\n+\tstruct sshbuf *b = NULL;\n \tstruct sshkey *key = NULL;\n-\tchar *pkalg, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;\n-\tu_char *pkblob, *sig, have_sig;\n+\tchar *pkalg = NULL, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;\n+\tu_char *pkblob = NULL, *sig = NULL, have_sig;\n \tsize_t blen, slen;\n \tint r, pktype;\n \tint authenticated = 0;\n \tstruct sshauthopt *authopts = NULL;\n \n-\tif (!authctxt->valid) {\n-\t\tdebug2(\""%s: disabled because of invalid user\"", __func__);\n-\t\treturn 0;\n-\t}\n \tif ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||\n \t    (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||\n \t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)\n@@ -164,6 +160,11 @@ userauth_pubkey(struct ssh *ssh)\n \t\t\t\tfatal(\""%s: sshbuf_put_string session id: %s\"",\n \t\t\t\t    __func__, ssh_err(r));\n \t\t}\n+\t\tif (!authctxt->valid || authctxt->user == NULL) {\n+\t\t\tdebug2(\""%s: disabled because of invalid user\"",\n+\t\t\t    __func__);\n+\t\t\tgoto done;\n+\t\t}\n \t\t/* reconstruct packet */\n \t\txasprintf(&userstyle, \""%s%s%s\"", authctxt->user,\n \t\t    authctxt->style ? \"":\"" : \""\"",\n@@ -180,7 +181,6 @@ userauth_pubkey(struct ssh *ssh)\n #ifdef DEBUG_PK\n \t\tsshbuf_dump(b, stderr);\n #endif\n-\n \t\t/* test for correct signature */\n \t\tauthenticated = 0;\n \t\tif (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&\n@@ -191,7 +191,6 @@ userauth_pubkey(struct ssh *ssh)\n \t\t\tauthenticated = 1;\n \t\t}\n \t\tsshbuf_free(b);\n-\t\tfree(sig);\n \t\tauth2_record_key(authctxt, authenticated, key);\n \t} else {\n \t\tdebug(\""%s: test pkalg %s pkblob %s%s%s\"",\n@@ -202,6 +201,11 @@ userauth_pubkey(struct ssh *ssh)\n \t\tif ((r = sshpkt_get_end(ssh)) != 0)\n \t\t\tfatal(\""%s: %s\"", __func__, ssh_err(r));\n \n+\t\tif (!authctxt->valid || authctxt->user == NULL) {\n+\t\t\tdebug2(\""%s: disabled because of invalid user\"",\n+\t\t\t    __func__);\n+\t\t\tgoto done;\n+\t\t}\n \t\t/* XXX fake reply and always send PK_OK ? */\n \t\t/*\n \t\t * XXX this allows testing whether a user is allowed\n@@ -235,6 +239,7 @@ userauth_pubkey(struct ssh *ssh)\n \tfree(pkblob);\n \tfree(key_s);\n \tfree(ca_s);\n+\tfree(sig);\n \treturn authenticated;\n }\n ""}","userauth_hostbased(struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	struct sshbuf *b;
	struct sshkey *key = NULL;
	char *pkalg, *cuser, *chost;
	u_char *pkblob, *sig;
 	size_t alen, blen, slen;
 	int r, pktype, authenticated = 0;
 
 	/* XXX use sshkey_froms() */
 	if ((r = sshpkt_get_cstring(ssh, &pkalg, &alen)) != 0 ||
 	    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0 ||
	    (r = sshpkt_get_cstring(ssh, &chost, NULL)) != 0 ||
	    (r = sshpkt_get_cstring(ssh, &cuser, NULL)) != 0 ||
	    (r = sshpkt_get_string(ssh, &sig, &slen)) != 0)
		fatal(""%s: packet parsing: %s"", __func__, ssh_err(r));

	debug(""%s: cuser %s chost %s pkalg %s slen %zu"", __func__,
	    cuser, chost, pkalg, slen);
#ifdef DEBUG_PK
	debug(""signature:"");
	sshbuf_dump_data(sig, siglen, stderr);
#endif
	pktype = sshkey_type_from_name(pkalg);
	if (pktype == KEY_UNSPEC) {
		/* this is perfectly legal */
		logit(""%s: unsupported public key algorithm: %s"",
		    __func__, pkalg);
		goto done;
	}
	if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {
		error(""%s: key_from_blob: %s"", __func__, ssh_err(r));
		goto done;
	}
	if (key == NULL) {
		error(""%s: cannot decode key: %s"", __func__, pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error(""%s: type mismatch for decoded key ""
		    ""(received %d, expected %d)"", __func__, key->type, pktype);
		goto done;
	}
	if (sshkey_type_plain(key->type) == KEY_RSA &&
	    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {
		error(""Refusing RSA key because peer uses unsafe ""
		    ""signature format"");
		goto done;
	}
	if (match_pattern_list(pkalg, options.hostbased_key_types, 0) != 1) {
		logit(""%s: key type %s not in HostbasedAcceptedKeyTypes"",
		    __func__, sshkey_type(key));
 		goto done;
 	}
 
	if (!authctxt->valid || authctxt->user == NULL) {
		debug2(""%s: disabled because of invalid user"", __func__);
		goto done;
	}

 	if ((b = sshbuf_new()) == NULL)
 		fatal(""%s: sshbuf_new failed"", __func__);
 	/* reconstruct packet */
	if ((r = sshbuf_put_string(b, session_id2, session_id2_len)) != 0 ||
	    (r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||
	    (r = sshbuf_put_cstring(b, authctxt->user)) != 0 ||
	    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||
	    (r = sshbuf_put_cstring(b, ""hostbased"")) != 0 ||
	    (r = sshbuf_put_string(b, pkalg, alen)) != 0 ||
	    (r = sshbuf_put_string(b, pkblob, blen)) != 0 ||
	    (r = sshbuf_put_cstring(b, chost)) != 0 ||
	    (r = sshbuf_put_cstring(b, cuser)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));
#ifdef DEBUG_PK
	sshbuf_dump(b, stderr);
#endif

	auth2_record_info(authctxt,
	    ""client user \""%.100s\"", client host \""%.100s\"""", cuser, chost);

	/* test for allowed key and correct signature */
	authenticated = 0;
	if (PRIVSEP(hostbased_key_allowed(authctxt->pw, cuser, chost, key)) &&
	    PRIVSEP(sshkey_verify(key, sig, slen,
	    sshbuf_ptr(b), sshbuf_len(b), pkalg, ssh->compat)) == 0)
		authenticated = 1;

	auth2_record_key(authctxt, authenticated, key);
	sshbuf_free(b);
done:
	debug2(""%s: authenticated %d"", __func__, authenticated);
	sshkey_free(key);
	free(pkalg);
	free(pkblob);
	free(cuser);
	free(chost);
	free(sig);
	return authenticated;
}
","userauth_hostbased(struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	struct sshbuf *b;
	struct sshkey *key = NULL;
	char *pkalg, *cuser, *chost;
	u_char *pkblob, *sig;
 	size_t alen, blen, slen;
 	int r, pktype, authenticated = 0;
 
	if (!authctxt->valid) {
		debug2(""%s: disabled because of invalid user"", __func__);
		return 0;
	}
 	/* XXX use sshkey_froms() */
 	if ((r = sshpkt_get_cstring(ssh, &pkalg, &alen)) != 0 ||
 	    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0 ||
	    (r = sshpkt_get_cstring(ssh, &chost, NULL)) != 0 ||
	    (r = sshpkt_get_cstring(ssh, &cuser, NULL)) != 0 ||
	    (r = sshpkt_get_string(ssh, &sig, &slen)) != 0)
		fatal(""%s: packet parsing: %s"", __func__, ssh_err(r));

	debug(""%s: cuser %s chost %s pkalg %s slen %zu"", __func__,
	    cuser, chost, pkalg, slen);
#ifdef DEBUG_PK
	debug(""signature:"");
	sshbuf_dump_data(sig, siglen, stderr);
#endif
	pktype = sshkey_type_from_name(pkalg);
	if (pktype == KEY_UNSPEC) {
		/* this is perfectly legal */
		logit(""%s: unsupported public key algorithm: %s"",
		    __func__, pkalg);
		goto done;
	}
	if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {
		error(""%s: key_from_blob: %s"", __func__, ssh_err(r));
		goto done;
	}
	if (key == NULL) {
		error(""%s: cannot decode key: %s"", __func__, pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error(""%s: type mismatch for decoded key ""
		    ""(received %d, expected %d)"", __func__, key->type, pktype);
		goto done;
	}
	if (sshkey_type_plain(key->type) == KEY_RSA &&
	    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {
		error(""Refusing RSA key because peer uses unsafe ""
		    ""signature format"");
		goto done;
	}
	if (match_pattern_list(pkalg, options.hostbased_key_types, 0) != 1) {
		logit(""%s: key type %s not in HostbasedAcceptedKeyTypes"",
		    __func__, sshkey_type(key));
 		goto done;
 	}
 
 	if ((b = sshbuf_new()) == NULL)
 		fatal(""%s: sshbuf_new failed"", __func__);
 	/* reconstruct packet */
	if ((r = sshbuf_put_string(b, session_id2, session_id2_len)) != 0 ||
	    (r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||
	    (r = sshbuf_put_cstring(b, authctxt->user)) != 0 ||
	    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||
	    (r = sshbuf_put_cstring(b, ""hostbased"")) != 0 ||
	    (r = sshbuf_put_string(b, pkalg, alen)) != 0 ||
	    (r = sshbuf_put_string(b, pkblob, blen)) != 0 ||
	    (r = sshbuf_put_cstring(b, chost)) != 0 ||
	    (r = sshbuf_put_cstring(b, cuser)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));
#ifdef DEBUG_PK
	sshbuf_dump(b, stderr);
#endif

	auth2_record_info(authctxt,
	    ""client user \""%.100s\"", client host \""%.100s\"""", cuser, chost);

	/* test for allowed key and correct signature */
	authenticated = 0;
	if (PRIVSEP(hostbased_key_allowed(authctxt->pw, cuser, chost, key)) &&
	    PRIVSEP(sshkey_verify(key, sig, slen,
	    sshbuf_ptr(b), sshbuf_len(b), pkalg, ssh->compat)) == 0)
		authenticated = 1;

	auth2_record_key(authctxt, authenticated, key);
	sshbuf_free(b);
done:
	debug2(""%s: authenticated %d"", __func__, authenticated);
	sshkey_free(key);
	free(pkalg);
	free(pkblob);
	free(cuser);
	free(chost);
	free(sig);
	return authenticated;
}
",C,"	if (!authctxt->valid || authctxt->user == NULL) {
		debug2(""%s: disabled because of invalid user"", __func__);
		goto done;
	}

","	if (!authctxt->valid) {
		debug2(""%s: disabled because of invalid user"", __func__);
		return 0;
	}
",,"@@ -1,4 +1,4 @@
-/* $OpenBSD: auth2-hostbased.c,v 1.35 2018/07/09 21:35:50 markus Exp $ */
+/* $OpenBSD: auth2-hostbased.c,v 1.36 2018/07/31 03:10:27 djm Exp $ */
 /*
  * Copyright (c) 2000 Markus Friedl.  All rights reserved.
  *
@@ -66,10 +66,6 @@ userauth_hostbased(struct ssh *ssh)
 	size_t alen, blen, slen;
 	int r, pktype, authenticated = 0;
 
-	if (!authctxt->valid) {
-		debug2(""%s: disabled because of invalid user"", __func__);
-		return 0;
-	}
 	/* XXX use sshkey_froms() */
 	if ((r = sshpkt_get_cstring(ssh, &pkalg, &alen)) != 0 ||
 	    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0 ||
@@ -116,6 +112,11 @@ userauth_hostbased(struct ssh *ssh)
 		goto done;
 	}
 
+	if (!authctxt->valid || authctxt->user == NULL) {
+		debug2(""%s: disabled because of invalid user"", __func__);
+		goto done;
+	}
+
 	if ((b = sshbuf_new()) == NULL)
 		fatal(""%s: sshbuf_new failed"", __func__);
 	/* reconstruct packet */",src,779974d35b4859c07bc3cb8a12c74b43b0a7d1e0,1addc7ae5beca221ada86e5a67a6872f22c23fd1,1,"userauth_hostbased(struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	struct sshbuf *b;
	struct sshkey *key = NULL;
	char *pkalg, *cuser, *chost;
	u_char *pkblob, *sig;
 	size_t alen, blen, slen;
 	int r, pktype, authenticated = 0;
 
//flaw_line_below:
	if (!authctxt->valid) {
//flaw_line_below:
		debug2(""%s: disabled because of invalid user"", __func__);
//flaw_line_below:
		return 0;
//flaw_line_below:
	}
 	/* XXX use sshkey_froms() */
 	if ((r = sshpkt_get_cstring(ssh, &pkalg, &alen)) != 0 ||
 	    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0 ||
	    (r = sshpkt_get_cstring(ssh, &chost, NULL)) != 0 ||
	    (r = sshpkt_get_cstring(ssh, &cuser, NULL)) != 0 ||
	    (r = sshpkt_get_string(ssh, &sig, &slen)) != 0)
		fatal(""%s: packet parsing: %s"", __func__, ssh_err(r));

	debug(""%s: cuser %s chost %s pkalg %s slen %zu"", __func__,
	    cuser, chost, pkalg, slen);
#ifdef DEBUG_PK
	debug(""signature:"");
	sshbuf_dump_data(sig, siglen, stderr);
#endif
	pktype = sshkey_type_from_name(pkalg);
	if (pktype == KEY_UNSPEC) {
		/* this is perfectly legal */
		logit(""%s: unsupported public key algorithm: %s"",
		    __func__, pkalg);
		goto done;
	}
	if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {
		error(""%s: key_from_blob: %s"", __func__, ssh_err(r));
		goto done;
	}
	if (key == NULL) {
		error(""%s: cannot decode key: %s"", __func__, pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error(""%s: type mismatch for decoded key ""
		    ""(received %d, expected %d)"", __func__, key->type, pktype);
		goto done;
	}
	if (sshkey_type_plain(key->type) == KEY_RSA &&
	    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {
		error(""Refusing RSA key because peer uses unsafe ""
		    ""signature format"");
		goto done;
	}
	if (match_pattern_list(pkalg, options.hostbased_key_types, 0) != 1) {
		logit(""%s: key type %s not in HostbasedAcceptedKeyTypes"",
		    __func__, sshkey_type(key));
 		goto done;
 	}
 
//fix_flaw_line_below:
//	if (!authctxt->valid || authctxt->user == NULL) {
//fix_flaw_line_below:
//		debug2(""%s: disabled because of invalid user"", __func__);
//fix_flaw_line_below:
//		goto done;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	if ((b = sshbuf_new()) == NULL)
 		fatal(""%s: sshbuf_new failed"", __func__);
 	/* reconstruct packet */
	if ((r = sshbuf_put_string(b, session_id2, session_id2_len)) != 0 ||
	    (r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||
	    (r = sshbuf_put_cstring(b, authctxt->user)) != 0 ||
	    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||
	    (r = sshbuf_put_cstring(b, ""hostbased"")) != 0 ||
	    (r = sshbuf_put_string(b, pkalg, alen)) != 0 ||
	    (r = sshbuf_put_string(b, pkblob, blen)) != 0 ||
	    (r = sshbuf_put_cstring(b, chost)) != 0 ||
	    (r = sshbuf_put_cstring(b, cuser)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));
#ifdef DEBUG_PK
	sshbuf_dump(b, stderr);
#endif

	auth2_record_info(authctxt,
	    ""client user \""%.100s\"", client host \""%.100s\"""", cuser, chost);

	/* test for allowed key and correct signature */
	authenticated = 0;
	if (PRIVSEP(hostbased_key_allowed(authctxt->pw, cuser, chost, key)) &&
	    PRIVSEP(sshkey_verify(key, sig, slen,
	    sshbuf_ptr(b), sshbuf_len(b), pkalg, ssh->compat)) == 0)
		authenticated = 1;

	auth2_record_key(authctxt, authenticated, key);
	sshbuf_free(b);
done:
	debug2(""%s: authenticated %d"", __func__, authenticated);
	sshkey_free(key);
	free(pkalg);
	free(pkblob);
	free(cuser);
	free(chost);
	free(sig);
	return authenticated;
}
",182277,"userauth_hostbased(struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	struct sshbuf *b;
	struct sshkey *key = NULL;
	char *pkalg, *cuser, *chost;
	u_char *pkblob, *sig;
 	size_t alen, blen, slen;
 	int r, pktype, authenticated = 0;
 
	if (!authctxt->valid) {
		debug2(""%s: disabled because of invalid user"", __func__);
		return 0;
	}
 	/* XXX use sshkey_froms() */
 	if ((r = sshpkt_get_cstring(ssh, &pkalg, &alen)) != 0 ||
 	    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0 ||
	    (r = sshpkt_get_cstring(ssh, &chost, NULL)) != 0 ||
	    (r = sshpkt_get_cstring(ssh, &cuser, NULL)) != 0 ||
	    (r = sshpkt_get_string(ssh, &sig, &slen)) != 0)
		fatal(""%s: packet parsing: %s"", __func__, ssh_err(r));

	debug(""%s: cuser %s chost %s pkalg %s slen %zu"", __func__,
	    cuser, chost, pkalg, slen);
#ifdef DEBUG_PK
	debug(""signature:"");
	sshbuf_dump_data(sig, siglen, stderr);
#endif
	pktype = sshkey_type_from_name(pkalg);
	if (pktype == KEY_UNSPEC) {
		/* this is perfectly legal */
		logit(""%s: unsupported public key algorithm: %s"",
		    __func__, pkalg);
		goto done;
	}
	if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {
		error(""%s: key_from_blob: %s"", __func__, ssh_err(r));
		goto done;
	}
	if (key == NULL) {
		error(""%s: cannot decode key: %s"", __func__, pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error(""%s: type mismatch for decoded key ""
		    ""(received %d, expected %d)"", __func__, key->type, pktype);
		goto done;
	}
	if (sshkey_type_plain(key->type) == KEY_RSA &&
	    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {
		error(""Refusing RSA key because peer uses unsafe ""
		    ""signature format"");
		goto done;
	}
	if (match_pattern_list(pkalg, options.hostbased_key_types, 0) != 1) {
		logit(""%s: key type %s not in HostbasedAcceptedKeyTypes"",
		    __func__, sshkey_type(key));
 		goto done;
 	}
 
 	if ((b = sshbuf_new()) == NULL)
 		fatal(""%s: sshbuf_new failed"", __func__);
 	/* reconstruct packet */
	if ((r = sshbuf_put_string(b, session_id2, session_id2_len)) != 0 ||
	    (r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||
	    (r = sshbuf_put_cstring(b, authctxt->user)) != 0 ||
	    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||
	    (r = sshbuf_put_cstring(b, ""hostbased"")) != 0 ||
	    (r = sshbuf_put_string(b, pkalg, alen)) != 0 ||
	    (r = sshbuf_put_string(b, pkblob, blen)) != 0 ||
	    (r = sshbuf_put_cstring(b, chost)) != 0 ||
	    (r = sshbuf_put_cstring(b, cuser)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));
#ifdef DEBUG_PK
	sshbuf_dump(b, stderr);
#endif

	auth2_record_info(authctxt,
	    ""client user \""%.100s\"", client host \""%.100s\"""", cuser, chost);

	/* test for allowed key and correct signature */
	authenticated = 0;
	if (PRIVSEP(hostbased_key_allowed(authctxt->pw, cuser, chost, key)) &&
	    PRIVSEP(sshkey_verify(key, sig, slen,
	    sshbuf_ptr(b), sshbuf_len(b), pkalg, ssh->compat)) == 0)
		authenticated = 1;

	auth2_record_key(authctxt, authenticated, key);
	sshbuf_free(b);
done:
	debug2(""%s: authenticated %d"", __func__, authenticated);
	sshkey_free(key);
	free(pkalg);
	free(pkblob);
	free(cuser);
	free(chost);
	free(sig);
	return authenticated;
}
","userauth_hostbased(struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	struct sshbuf *b;
	struct sshkey *key = NULL;
	char *pkalg, *cuser, *chost;
	u_char *pkblob, *sig;
 	size_t alen, blen, slen;
 	int r, pktype, authenticated = 0;
 
 	/* XXX use sshkey_froms() */
 	if ((r = sshpkt_get_cstring(ssh, &pkalg, &alen)) != 0 ||
 	    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0 ||
	    (r = sshpkt_get_cstring(ssh, &chost, NULL)) != 0 ||
	    (r = sshpkt_get_cstring(ssh, &cuser, NULL)) != 0 ||
	    (r = sshpkt_get_string(ssh, &sig, &slen)) != 0)
		fatal(""%s: packet parsing: %s"", __func__, ssh_err(r));

	debug(""%s: cuser %s chost %s pkalg %s slen %zu"", __func__,
	    cuser, chost, pkalg, slen);
#ifdef DEBUG_PK
	debug(""signature:"");
	sshbuf_dump_data(sig, siglen, stderr);
#endif
	pktype = sshkey_type_from_name(pkalg);
	if (pktype == KEY_UNSPEC) {
		/* this is perfectly legal */
		logit(""%s: unsupported public key algorithm: %s"",
		    __func__, pkalg);
		goto done;
	}
	if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {
		error(""%s: key_from_blob: %s"", __func__, ssh_err(r));
		goto done;
	}
	if (key == NULL) {
		error(""%s: cannot decode key: %s"", __func__, pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error(""%s: type mismatch for decoded key ""
		    ""(received %d, expected %d)"", __func__, key->type, pktype);
		goto done;
	}
	if (sshkey_type_plain(key->type) == KEY_RSA &&
	    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {
		error(""Refusing RSA key because peer uses unsafe ""
		    ""signature format"");
		goto done;
	}
	if (match_pattern_list(pkalg, options.hostbased_key_types, 0) != 1) {
		logit(""%s: key type %s not in HostbasedAcceptedKeyTypes"",
		    __func__, sshkey_type(key));
 		goto done;
 	}
 
	if (!authctxt->valid || authctxt->user == NULL) {
		debug2(""%s: disabled because of invalid user"", __func__);
		goto done;
	}

 	if ((b = sshbuf_new()) == NULL)
 		fatal(""%s: sshbuf_new failed"", __func__);
 	/* reconstruct packet */
	if ((r = sshbuf_put_string(b, session_id2, session_id2_len)) != 0 ||
	    (r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||
	    (r = sshbuf_put_cstring(b, authctxt->user)) != 0 ||
	    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||
	    (r = sshbuf_put_cstring(b, ""hostbased"")) != 0 ||
	    (r = sshbuf_put_string(b, pkalg, alen)) != 0 ||
	    (r = sshbuf_put_string(b, pkblob, blen)) != 0 ||
	    (r = sshbuf_put_cstring(b, chost)) != 0 ||
	    (r = sshbuf_put_cstring(b, cuser)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));
#ifdef DEBUG_PK
	sshbuf_dump(b, stderr);
#endif

	auth2_record_info(authctxt,
	    ""client user \""%.100s\"", client host \""%.100s\"""", cuser, chost);

	/* test for allowed key and correct signature */
	authenticated = 0;
	if (PRIVSEP(hostbased_key_allowed(authctxt->pw, cuser, chost, key)) &&
	    PRIVSEP(sshkey_verify(key, sig, slen,
	    sshbuf_ptr(b), sshbuf_len(b), pkalg, ssh->compat)) == 0)
		authenticated = 1;

	auth2_record_key(authctxt, authenticated, key);
	sshbuf_free(b);
done:
	debug2(""%s: authenticated %d"", __func__, authenticated);
	sshkey_free(key);
	free(pkalg);
	free(pkblob);
	free(cuser);
	free(chost);
	free(sig);
	return authenticated;
}
","The `userauth_hostbased` function implements host-based authentication for an SSH connection. It begins by validating the user context and parsing incoming packets to extract the public key algorithm, public key blob, client user, client host, and signature. The function checks for key type compatibility and verifies that the key is allowed based on predefined options. It reconstructs a packet containing authentication details and verifies the signature against the provided key. If all checks pass, it marks the user as authenticated; otherwise, it logs errors and cleans up resources before returning the authentication status.","The function facilitates host-based authentication in an SSH context by first validating the user and parsing incoming data packets to retrieve necessary authentication information. It checks the compatibility of the public key algorithm and ensures the key is permitted based on predefined criteria. After reconstructing a packet with the authentication details, it verifies the signature against the provided key. If all conditions are satisfied, the user is authenticated; otherwise, errors are logged, and resources are cleaned up before returning the authentication result, indicating whether the process was successful or not.","The vulnerability in the original code stemmed from prematurely checking the validity of the user context before fully parsing the incoming authentication packet. This could lead to situations where the function would fail to process valid authentication requests due to an invalid user state, potentially allowing attackers to exploit this by sending crafted packets. The fix involved delaying the validity check for the user until after the packet parsing was complete, ensuring that all necessary data was processed before determining if the user context was valid, thus enhancing the robustness of the authentication process.","The vulnerability in the original code arose from checking the validity of the user context too early, before fully processing the incoming authentication request. This could lead to legitimate authentication attempts being rejected if the user context was deemed invalid, potentially allowing attackers to exploit this flaw by sending specially crafted packets. The fix involved postponing the validity check until after the entire packet had been parsed, ensuring that all relevant data was considered before determining the user's validity. This change enhances the security and reliability of the authentication process by preventing premature failures.","The vulnerability was fixed by moving the check for the validity of the user context to occur after the packet parsing was completed. In the updated code, the condition that checks if the user context is valid was modified to occur after the parsing of the packet, which includes retrieving the public key algorithm, public key blob, client user, and client host. This change ensures that the function processes all necessary authentication data before determining if the user context is valid, thereby preventing premature rejection of valid authentication requests and enhancing overall security.","The vulnerability was addressed by rearranging the order of operations in the code to delay the validity check of the user context until after the complete parsing of the authentication request packet. This adjustment ensures that all relevant data is processed before determining the user's validity, preventing legitimate authentication attempts from being incorrectly rejected. By allowing the function to fully analyze the incoming request first, the fix enhances the robustness of the authentication mechanism and mitigates the risk of exploitation through crafted packets that could otherwise bypass security checks.","4,5","2, 2","4,4","4,4"
85,85,182278,182278,,Remote,Not required,,CVE-2018-15473,https://www.cvedetails.com/cve/CVE-2018-15473/,CWE-200,Low,Partial,,,2018-08-17,5.0,"OpenSSH through 7.7 is prone to a user enumeration vulnerability due to not delaying bailout for an invalid authenticating user until after the packet containing the request has been fully parsed, related to auth2-gss.c, auth2-hostbased.c, and auth2-pubkey.c.",2019-08-06,+Info ,14,https://github.com/openbsd/src/commit/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0,779974d35b4859c07bc3cb8a12c74b43b0a7d1e0,"delay bailout for invalid authenticating user until after the packet
containing the request has been fully parsed. Reported by Dariusz Tytko
and Michał Sajdak; ok deraadt",8,usr.bin/ssh/auth2-pubkey.c,"{""sha"": ""c919ef4c353bc8885ad696db8e8997a468463b1f"", ""filename"": ""usr.bin/ssh/auth2-gss.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 4, ""changes"": 11, ""blob_url"": ""https://github.com/openbsd/src/blob/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0/usr.bin/ssh/auth2-gss.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0/usr.bin/ssh/auth2-gss.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/auth2-gss.c?ref=779974d35b4859c07bc3cb8a12c74b43b0a7d1e0"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: auth2-gss.c,v 1.28 2018/07/10 09:13:30 djm Exp $ */\n+/* $OpenBSD: auth2-gss.c,v 1.29 2018/07/31 03:10:27 djm Exp $ */\n \n /*\n  * Copyright (c) 2001-2003 Simon Wilkinson. All rights reserved.\n@@ -65,9 +65,6 @@ userauth_gssapi(struct ssh *ssh)\n \tsize_t len;\n \tu_char *doid = NULL;\n \n-\tif (!authctxt->valid || authctxt->user == NULL)\n-\t\treturn (0);\n-\n \tif ((r = sshpkt_get_u32(ssh, &mechs)) != 0)\n \t\tfatal(\""%s: %s\"", __func__, ssh_err(r));\n \n@@ -101,6 +98,12 @@ userauth_gssapi(struct ssh *ssh)\n \t\treturn (0);\n \t}\n \n+\tif (!authctxt->valid || authctxt->user == NULL) {\n+\t\tdebug2(\""%s: disabled because of invalid user\"", __func__);\n+\t\tfree(doid);\n+\t\treturn (0);\n+\t}\n+\n \tif (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {\n \t\tif (ctxt != NULL)\n \t\t\tssh_gssapi_delete_ctx(&ctxt);""}<_**next**_>{""sha"": ""fb5e5f42272401d4839e87f58ed3939864feff8e"", ""filename"": ""usr.bin/ssh/auth2-hostbased.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 5, ""changes"": 11, ""blob_url"": ""https://github.com/openbsd/src/blob/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0/usr.bin/ssh/auth2-hostbased.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0/usr.bin/ssh/auth2-hostbased.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/auth2-hostbased.c?ref=779974d35b4859c07bc3cb8a12c74b43b0a7d1e0"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: auth2-hostbased.c,v 1.35 2018/07/09 21:35:50 markus Exp $ */\n+/* $OpenBSD: auth2-hostbased.c,v 1.36 2018/07/31 03:10:27 djm Exp $ */\n /*\n  * Copyright (c) 2000 Markus Friedl.  All rights reserved.\n  *\n@@ -66,10 +66,6 @@ userauth_hostbased(struct ssh *ssh)\n \tsize_t alen, blen, slen;\n \tint r, pktype, authenticated = 0;\n \n-\tif (!authctxt->valid) {\n-\t\tdebug2(\""%s: disabled because of invalid user\"", __func__);\n-\t\treturn 0;\n-\t}\n \t/* XXX use sshkey_froms() */\n \tif ((r = sshpkt_get_cstring(ssh, &pkalg, &alen)) != 0 ||\n \t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0 ||\n@@ -116,6 +112,11 @@ userauth_hostbased(struct ssh *ssh)\n \t\tgoto done;\n \t}\n \n+\tif (!authctxt->valid || authctxt->user == NULL) {\n+\t\tdebug2(\""%s: disabled because of invalid user\"", __func__);\n+\t\tgoto done;\n+\t}\n+\n \tif ((b = sshbuf_new()) == NULL)\n \t\tfatal(\""%s: sshbuf_new failed\"", __func__);\n \t/* reconstruct packet */""}<_**next**_>{""sha"": ""af9e5f04c45f7eb47ff3ad37655d5d49fc9a24a9"", ""filename"": ""usr.bin/ssh/auth2-pubkey.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 10, ""changes"": 25, ""blob_url"": ""https://github.com/openbsd/src/blob/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0/usr.bin/ssh/auth2-pubkey.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0/usr.bin/ssh/auth2-pubkey.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/auth2-pubkey.c?ref=779974d35b4859c07bc3cb8a12c74b43b0a7d1e0"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: auth2-pubkey.c,v 1.82 2018/07/11 18:55:11 markus Exp $ */\n+/* $OpenBSD: auth2-pubkey.c,v 1.83 2018/07/31 03:10:27 djm Exp $ */\n /*\n  * Copyright (c) 2000 Markus Friedl.  All rights reserved.\n  *\n@@ -86,19 +86,15 @@ userauth_pubkey(struct ssh *ssh)\n {\n \tAuthctxt *authctxt = ssh->authctxt;\n \tstruct passwd *pw = authctxt->pw;\n-\tstruct sshbuf *b;\n+\tstruct sshbuf *b = NULL;\n \tstruct sshkey *key = NULL;\n-\tchar *pkalg, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;\n-\tu_char *pkblob, *sig, have_sig;\n+\tchar *pkalg = NULL, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;\n+\tu_char *pkblob = NULL, *sig = NULL, have_sig;\n \tsize_t blen, slen;\n \tint r, pktype;\n \tint authenticated = 0;\n \tstruct sshauthopt *authopts = NULL;\n \n-\tif (!authctxt->valid) {\n-\t\tdebug2(\""%s: disabled because of invalid user\"", __func__);\n-\t\treturn 0;\n-\t}\n \tif ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||\n \t    (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||\n \t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)\n@@ -164,6 +160,11 @@ userauth_pubkey(struct ssh *ssh)\n \t\t\t\tfatal(\""%s: sshbuf_put_string session id: %s\"",\n \t\t\t\t    __func__, ssh_err(r));\n \t\t}\n+\t\tif (!authctxt->valid || authctxt->user == NULL) {\n+\t\t\tdebug2(\""%s: disabled because of invalid user\"",\n+\t\t\t    __func__);\n+\t\t\tgoto done;\n+\t\t}\n \t\t/* reconstruct packet */\n \t\txasprintf(&userstyle, \""%s%s%s\"", authctxt->user,\n \t\t    authctxt->style ? \"":\"" : \""\"",\n@@ -180,7 +181,6 @@ userauth_pubkey(struct ssh *ssh)\n #ifdef DEBUG_PK\n \t\tsshbuf_dump(b, stderr);\n #endif\n-\n \t\t/* test for correct signature */\n \t\tauthenticated = 0;\n \t\tif (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&\n@@ -191,7 +191,6 @@ userauth_pubkey(struct ssh *ssh)\n \t\t\tauthenticated = 1;\n \t\t}\n \t\tsshbuf_free(b);\n-\t\tfree(sig);\n \t\tauth2_record_key(authctxt, authenticated, key);\n \t} else {\n \t\tdebug(\""%s: test pkalg %s pkblob %s%s%s\"",\n@@ -202,6 +201,11 @@ userauth_pubkey(struct ssh *ssh)\n \t\tif ((r = sshpkt_get_end(ssh)) != 0)\n \t\t\tfatal(\""%s: %s\"", __func__, ssh_err(r));\n \n+\t\tif (!authctxt->valid || authctxt->user == NULL) {\n+\t\t\tdebug2(\""%s: disabled because of invalid user\"",\n+\t\t\t    __func__);\n+\t\t\tgoto done;\n+\t\t}\n \t\t/* XXX fake reply and always send PK_OK ? */\n \t\t/*\n \t\t * XXX this allows testing whether a user is allowed\n@@ -235,6 +239,7 @@ userauth_pubkey(struct ssh *ssh)\n \tfree(pkblob);\n \tfree(key_s);\n \tfree(ca_s);\n+\tfree(sig);\n \treturn authenticated;\n }\n ""}","userauth_pubkey(struct ssh *ssh)
 {
 	Authctxt *authctxt = ssh->authctxt;
 	struct passwd *pw = authctxt->pw;
	struct sshbuf *b = NULL;
 	struct sshkey *key = NULL;
	char *pkalg = NULL, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;
	u_char *pkblob = NULL, *sig = NULL, have_sig;
 	size_t blen, slen;
 	int r, pktype;
 	int authenticated = 0;
 	struct sshauthopt *authopts = NULL;
 
 	if ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||
 	    (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||
 	    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)
		fatal(""%s: parse request failed: %s"", __func__, ssh_err(r));
	pktype = sshkey_type_from_name(pkalg);
	if (pktype == KEY_UNSPEC) {
		/* this is perfectly legal */
		verbose(""%s: unsupported public key algorithm: %s"",
		    __func__, pkalg);
		goto done;
	}
	if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {
		error(""%s: could not parse key: %s"", __func__, ssh_err(r));
		goto done;
	}
	if (key == NULL) {
		error(""%s: cannot decode key: %s"", __func__, pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error(""%s: type mismatch for decoded key ""
		    ""(received %d, expected %d)"", __func__, key->type, pktype);
		goto done;
	}
	if (sshkey_type_plain(key->type) == KEY_RSA &&
	    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {
		logit(""Refusing RSA key because client uses unsafe ""
		    ""signature scheme"");
		goto done;
	}
	if (auth2_key_already_used(authctxt, key)) {
		logit(""refusing previously-used %s key"", sshkey_type(key));
		goto done;
	}
	if (match_pattern_list(pkalg, options.pubkey_key_types, 0) != 1) {
		logit(""%s: key type %s not in PubkeyAcceptedKeyTypes"",
		    __func__, sshkey_ssh_name(key));
		goto done;
	}

	key_s = format_key(key);
	if (sshkey_is_cert(key))
		ca_s = format_key(key->cert->signature_key);

	if (have_sig) {
		debug3(""%s: have %s signature for %s%s%s"",
		    __func__, pkalg, key_s,
		    ca_s == NULL ? """" : "" CA "",
		    ca_s == NULL ? """" : ca_s);
		if ((r = sshpkt_get_string(ssh, &sig, &slen)) != 0 ||
		    (r = sshpkt_get_end(ssh)) != 0)
			fatal(""%s: %s"", __func__, ssh_err(r));
		if ((b = sshbuf_new()) == NULL)
			fatal(""%s: sshbuf_new failed"", __func__);
		if (ssh->compat & SSH_OLD_SESSIONID) {
			if ((r = sshbuf_put(b, session_id2,
			    session_id2_len)) != 0)
				fatal(""%s: sshbuf_put session id: %s"",
				    __func__, ssh_err(r));
		} else {
			if ((r = sshbuf_put_string(b, session_id2,
			    session_id2_len)) != 0)
 				fatal(""%s: sshbuf_put_string session id: %s"",
 				    __func__, ssh_err(r));
 		}
		if (!authctxt->valid || authctxt->user == NULL) {
			debug2(""%s: disabled because of invalid user"",
			    __func__);
			goto done;
		}
 		/* reconstruct packet */
 		xasprintf(&userstyle, ""%s%s%s"", authctxt->user,
 		    authctxt->style ? "":"" : """",
		    authctxt->style ? authctxt->style : """");
		if ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||
		    (r = sshbuf_put_cstring(b, userstyle)) != 0 ||
		    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||
		    (r = sshbuf_put_cstring(b, ""publickey"")) != 0 ||
		    (r = sshbuf_put_u8(b, have_sig)) != 0 ||
		    (r = sshbuf_put_cstring(b, pkalg) != 0) ||
		    (r = sshbuf_put_string(b, pkblob, blen)) != 0)
			fatal(""%s: build packet failed: %s"",
			    __func__, ssh_err(r));
 #ifdef DEBUG_PK
 		sshbuf_dump(b, stderr);
 #endif
 		/* test for correct signature */
 		authenticated = 0;
 		if (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&
		    PRIVSEP(sshkey_verify(key, sig, slen,
		    sshbuf_ptr(b), sshbuf_len(b),
		    (ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL,
		    ssh->compat)) == 0) {
 			authenticated = 1;
 		}
 		sshbuf_free(b);
 		auth2_record_key(authctxt, authenticated, key);
 	} else {
 		debug(""%s: test pkalg %s pkblob %s%s%s"",
		    __func__, pkalg, key_s,
		    ca_s == NULL ? """" : "" CA "",
		    ca_s == NULL ? """" : ca_s);

 		if ((r = sshpkt_get_end(ssh)) != 0)
 			fatal(""%s: %s"", __func__, ssh_err(r));
 
		if (!authctxt->valid || authctxt->user == NULL) {
			debug2(""%s: disabled because of invalid user"",
			    __func__);
			goto done;
		}
 		/* XXX fake reply and always send PK_OK ? */
 		/*
 		 * XXX this allows testing whether a user is allowed
		 * to login: if you happen to have a valid pubkey this
		 * message is sent. the message is NEVER sent at all
		 * if a user is not allowed to login. is this an
		 * issue? -markus
		 */
		if (PRIVSEP(user_key_allowed(ssh, pw, key, 0, NULL))) {
			if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_PK_OK))
			    != 0 ||
			    (r = sshpkt_put_cstring(ssh, pkalg)) != 0 ||
			    (r = sshpkt_put_string(ssh, pkblob, blen)) != 0 ||
			    (r = sshpkt_send(ssh)) != 0 ||
			    (r = ssh_packet_write_wait(ssh)) != 0)
				fatal(""%s: %s"", __func__, ssh_err(r));
			authctxt->postponed = 1;
		}
	}
done:
	if (authenticated == 1 && auth_activate_options(ssh, authopts) != 0) {
		debug(""%s: key options inconsistent with existing"", __func__);
		authenticated = 0;
	}
	debug2(""%s: authenticated %d pkalg %s"", __func__, authenticated, pkalg);

	sshauthopt_free(authopts);
	sshkey_free(key);
	free(userstyle);
	free(pkalg);
 	free(pkblob);
 	free(key_s);
 	free(ca_s);
	free(sig);
 	return authenticated;
 }
","userauth_pubkey(struct ssh *ssh)
 {
 	Authctxt *authctxt = ssh->authctxt;
 	struct passwd *pw = authctxt->pw;
	struct sshbuf *b;
 	struct sshkey *key = NULL;
	char *pkalg, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;
	u_char *pkblob, *sig, have_sig;
 	size_t blen, slen;
 	int r, pktype;
 	int authenticated = 0;
 	struct sshauthopt *authopts = NULL;
 
	if (!authctxt->valid) {
		debug2(""%s: disabled because of invalid user"", __func__);
		return 0;
	}
 	if ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||
 	    (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||
 	    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)
		fatal(""%s: parse request failed: %s"", __func__, ssh_err(r));
	pktype = sshkey_type_from_name(pkalg);
	if (pktype == KEY_UNSPEC) {
		/* this is perfectly legal */
		verbose(""%s: unsupported public key algorithm: %s"",
		    __func__, pkalg);
		goto done;
	}
	if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {
		error(""%s: could not parse key: %s"", __func__, ssh_err(r));
		goto done;
	}
	if (key == NULL) {
		error(""%s: cannot decode key: %s"", __func__, pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error(""%s: type mismatch for decoded key ""
		    ""(received %d, expected %d)"", __func__, key->type, pktype);
		goto done;
	}
	if (sshkey_type_plain(key->type) == KEY_RSA &&
	    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {
		logit(""Refusing RSA key because client uses unsafe ""
		    ""signature scheme"");
		goto done;
	}
	if (auth2_key_already_used(authctxt, key)) {
		logit(""refusing previously-used %s key"", sshkey_type(key));
		goto done;
	}
	if (match_pattern_list(pkalg, options.pubkey_key_types, 0) != 1) {
		logit(""%s: key type %s not in PubkeyAcceptedKeyTypes"",
		    __func__, sshkey_ssh_name(key));
		goto done;
	}

	key_s = format_key(key);
	if (sshkey_is_cert(key))
		ca_s = format_key(key->cert->signature_key);

	if (have_sig) {
		debug3(""%s: have %s signature for %s%s%s"",
		    __func__, pkalg, key_s,
		    ca_s == NULL ? """" : "" CA "",
		    ca_s == NULL ? """" : ca_s);
		if ((r = sshpkt_get_string(ssh, &sig, &slen)) != 0 ||
		    (r = sshpkt_get_end(ssh)) != 0)
			fatal(""%s: %s"", __func__, ssh_err(r));
		if ((b = sshbuf_new()) == NULL)
			fatal(""%s: sshbuf_new failed"", __func__);
		if (ssh->compat & SSH_OLD_SESSIONID) {
			if ((r = sshbuf_put(b, session_id2,
			    session_id2_len)) != 0)
				fatal(""%s: sshbuf_put session id: %s"",
				    __func__, ssh_err(r));
		} else {
			if ((r = sshbuf_put_string(b, session_id2,
			    session_id2_len)) != 0)
 				fatal(""%s: sshbuf_put_string session id: %s"",
 				    __func__, ssh_err(r));
 		}
 		/* reconstruct packet */
 		xasprintf(&userstyle, ""%s%s%s"", authctxt->user,
 		    authctxt->style ? "":"" : """",
		    authctxt->style ? authctxt->style : """");
		if ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||
		    (r = sshbuf_put_cstring(b, userstyle)) != 0 ||
		    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||
		    (r = sshbuf_put_cstring(b, ""publickey"")) != 0 ||
		    (r = sshbuf_put_u8(b, have_sig)) != 0 ||
		    (r = sshbuf_put_cstring(b, pkalg) != 0) ||
		    (r = sshbuf_put_string(b, pkblob, blen)) != 0)
			fatal(""%s: build packet failed: %s"",
			    __func__, ssh_err(r));
 #ifdef DEBUG_PK
 		sshbuf_dump(b, stderr);
 #endif
 		/* test for correct signature */
 		authenticated = 0;
 		if (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&
		    PRIVSEP(sshkey_verify(key, sig, slen,
		    sshbuf_ptr(b), sshbuf_len(b),
		    (ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL,
		    ssh->compat)) == 0) {
 			authenticated = 1;
 		}
 		sshbuf_free(b);
		free(sig);
 		auth2_record_key(authctxt, authenticated, key);
 	} else {
 		debug(""%s: test pkalg %s pkblob %s%s%s"",
		    __func__, pkalg, key_s,
		    ca_s == NULL ? """" : "" CA "",
		    ca_s == NULL ? """" : ca_s);

 		if ((r = sshpkt_get_end(ssh)) != 0)
 			fatal(""%s: %s"", __func__, ssh_err(r));
 
 		/* XXX fake reply and always send PK_OK ? */
 		/*
 		 * XXX this allows testing whether a user is allowed
		 * to login: if you happen to have a valid pubkey this
		 * message is sent. the message is NEVER sent at all
		 * if a user is not allowed to login. is this an
		 * issue? -markus
		 */
		if (PRIVSEP(user_key_allowed(ssh, pw, key, 0, NULL))) {
			if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_PK_OK))
			    != 0 ||
			    (r = sshpkt_put_cstring(ssh, pkalg)) != 0 ||
			    (r = sshpkt_put_string(ssh, pkblob, blen)) != 0 ||
			    (r = sshpkt_send(ssh)) != 0 ||
			    (r = ssh_packet_write_wait(ssh)) != 0)
				fatal(""%s: %s"", __func__, ssh_err(r));
			authctxt->postponed = 1;
		}
	}
done:
	if (authenticated == 1 && auth_activate_options(ssh, authopts) != 0) {
		debug(""%s: key options inconsistent with existing"", __func__);
		authenticated = 0;
	}
	debug2(""%s: authenticated %d pkalg %s"", __func__, authenticated, pkalg);

	sshauthopt_free(authopts);
	sshkey_free(key);
	free(userstyle);
	free(pkalg);
 	free(pkblob);
 	free(key_s);
 	free(ca_s);
 	return authenticated;
 }
",C,"	struct sshbuf *b = NULL;
	char *pkalg = NULL, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;
	u_char *pkblob = NULL, *sig = NULL, have_sig;
		if (!authctxt->valid || authctxt->user == NULL) {
			debug2(""%s: disabled because of invalid user"",
			    __func__);
			goto done;
		}
		if (!authctxt->valid || authctxt->user == NULL) {
			debug2(""%s: disabled because of invalid user"",
			    __func__);
			goto done;
		}
	free(sig);
","	struct sshbuf *b;
	char *pkalg, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;
	u_char *pkblob, *sig, have_sig;
	if (!authctxt->valid) {
		debug2(""%s: disabled because of invalid user"", __func__);
		return 0;
	}
		free(sig);
",,"@@ -1,4 +1,4 @@
-/* $OpenBSD: auth2-pubkey.c,v 1.82 2018/07/11 18:55:11 markus Exp $ */
+/* $OpenBSD: auth2-pubkey.c,v 1.83 2018/07/31 03:10:27 djm Exp $ */
 /*
  * Copyright (c) 2000 Markus Friedl.  All rights reserved.
  *
@@ -86,19 +86,15 @@ userauth_pubkey(struct ssh *ssh)
 {
 	Authctxt *authctxt = ssh->authctxt;
 	struct passwd *pw = authctxt->pw;
-	struct sshbuf *b;
+	struct sshbuf *b = NULL;
 	struct sshkey *key = NULL;
-	char *pkalg, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;
-	u_char *pkblob, *sig, have_sig;
+	char *pkalg = NULL, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;
+	u_char *pkblob = NULL, *sig = NULL, have_sig;
 	size_t blen, slen;
 	int r, pktype;
 	int authenticated = 0;
 	struct sshauthopt *authopts = NULL;
 
-	if (!authctxt->valid) {
-		debug2(""%s: disabled because of invalid user"", __func__);
-		return 0;
-	}
 	if ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||
 	    (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||
 	    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)
@@ -164,6 +160,11 @@ userauth_pubkey(struct ssh *ssh)
 				fatal(""%s: sshbuf_put_string session id: %s"",
 				    __func__, ssh_err(r));
 		}
+		if (!authctxt->valid || authctxt->user == NULL) {
+			debug2(""%s: disabled because of invalid user"",
+			    __func__);
+			goto done;
+		}
 		/* reconstruct packet */
 		xasprintf(&userstyle, ""%s%s%s"", authctxt->user,
 		    authctxt->style ? "":"" : """",
@@ -180,7 +181,6 @@ userauth_pubkey(struct ssh *ssh)
 #ifdef DEBUG_PK
 		sshbuf_dump(b, stderr);
 #endif
-
 		/* test for correct signature */
 		authenticated = 0;
 		if (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&
@@ -191,7 +191,6 @@ userauth_pubkey(struct ssh *ssh)
 			authenticated = 1;
 		}
 		sshbuf_free(b);
-		free(sig);
 		auth2_record_key(authctxt, authenticated, key);
 	} else {
 		debug(""%s: test pkalg %s pkblob %s%s%s"",
@@ -202,6 +201,11 @@ userauth_pubkey(struct ssh *ssh)
 		if ((r = sshpkt_get_end(ssh)) != 0)
 			fatal(""%s: %s"", __func__, ssh_err(r));
 
+		if (!authctxt->valid || authctxt->user == NULL) {
+			debug2(""%s: disabled because of invalid user"",
+			    __func__);
+			goto done;
+		}
 		/* XXX fake reply and always send PK_OK ? */
 		/*
 		 * XXX this allows testing whether a user is allowed
@@ -235,6 +239,7 @@ userauth_pubkey(struct ssh *ssh)
 	free(pkblob);
 	free(key_s);
 	free(ca_s);
+	free(sig);
 	return authenticated;
 }
 ",src,779974d35b4859c07bc3cb8a12c74b43b0a7d1e0,1addc7ae5beca221ada86e5a67a6872f22c23fd1,1,"userauth_pubkey(struct ssh *ssh)
 {
 	Authctxt *authctxt = ssh->authctxt;
 	struct passwd *pw = authctxt->pw;
//flaw_line_below:
	struct sshbuf *b;
//fix_flaw_line_below:
//	struct sshbuf *b = NULL;
 	struct sshkey *key = NULL;
//flaw_line_below:
	char *pkalg, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;
//flaw_line_below:
	u_char *pkblob, *sig, have_sig;
//fix_flaw_line_below:
//	char *pkalg = NULL, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;
//fix_flaw_line_below:
//	u_char *pkblob = NULL, *sig = NULL, have_sig;
 	size_t blen, slen;
 	int r, pktype;
 	int authenticated = 0;
 	struct sshauthopt *authopts = NULL;
 
//flaw_line_below:
	if (!authctxt->valid) {
//flaw_line_below:
		debug2(""%s: disabled because of invalid user"", __func__);
//flaw_line_below:
		return 0;
//flaw_line_below:
	}
 	if ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||
 	    (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||
 	    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)
		fatal(""%s: parse request failed: %s"", __func__, ssh_err(r));
	pktype = sshkey_type_from_name(pkalg);
	if (pktype == KEY_UNSPEC) {
		/* this is perfectly legal */
		verbose(""%s: unsupported public key algorithm: %s"",
		    __func__, pkalg);
		goto done;
	}
	if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {
		error(""%s: could not parse key: %s"", __func__, ssh_err(r));
		goto done;
	}
	if (key == NULL) {
		error(""%s: cannot decode key: %s"", __func__, pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error(""%s: type mismatch for decoded key ""
		    ""(received %d, expected %d)"", __func__, key->type, pktype);
		goto done;
	}
	if (sshkey_type_plain(key->type) == KEY_RSA &&
	    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {
		logit(""Refusing RSA key because client uses unsafe ""
		    ""signature scheme"");
		goto done;
	}
	if (auth2_key_already_used(authctxt, key)) {
		logit(""refusing previously-used %s key"", sshkey_type(key));
		goto done;
	}
	if (match_pattern_list(pkalg, options.pubkey_key_types, 0) != 1) {
		logit(""%s: key type %s not in PubkeyAcceptedKeyTypes"",
		    __func__, sshkey_ssh_name(key));
		goto done;
	}

	key_s = format_key(key);
	if (sshkey_is_cert(key))
		ca_s = format_key(key->cert->signature_key);

	if (have_sig) {
		debug3(""%s: have %s signature for %s%s%s"",
		    __func__, pkalg, key_s,
		    ca_s == NULL ? """" : "" CA "",
		    ca_s == NULL ? """" : ca_s);
		if ((r = sshpkt_get_string(ssh, &sig, &slen)) != 0 ||
		    (r = sshpkt_get_end(ssh)) != 0)
			fatal(""%s: %s"", __func__, ssh_err(r));
		if ((b = sshbuf_new()) == NULL)
			fatal(""%s: sshbuf_new failed"", __func__);
		if (ssh->compat & SSH_OLD_SESSIONID) {
			if ((r = sshbuf_put(b, session_id2,
			    session_id2_len)) != 0)
				fatal(""%s: sshbuf_put session id: %s"",
				    __func__, ssh_err(r));
		} else {
			if ((r = sshbuf_put_string(b, session_id2,
			    session_id2_len)) != 0)
 				fatal(""%s: sshbuf_put_string session id: %s"",
 				    __func__, ssh_err(r));
 		}
//fix_flaw_line_below:
//		if (!authctxt->valid || authctxt->user == NULL) {
//fix_flaw_line_below:
//			debug2(""%s: disabled because of invalid user"",
//fix_flaw_line_below:
//			    __func__);
//fix_flaw_line_below:
//			goto done;
//fix_flaw_line_below:
//		}
 		/* reconstruct packet */
 		xasprintf(&userstyle, ""%s%s%s"", authctxt->user,
 		    authctxt->style ? "":"" : """",
		    authctxt->style ? authctxt->style : """");
		if ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||
		    (r = sshbuf_put_cstring(b, userstyle)) != 0 ||
		    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||
		    (r = sshbuf_put_cstring(b, ""publickey"")) != 0 ||
		    (r = sshbuf_put_u8(b, have_sig)) != 0 ||
		    (r = sshbuf_put_cstring(b, pkalg) != 0) ||
		    (r = sshbuf_put_string(b, pkblob, blen)) != 0)
			fatal(""%s: build packet failed: %s"",
			    __func__, ssh_err(r));
 #ifdef DEBUG_PK
 		sshbuf_dump(b, stderr);
 #endif
//flaw_line_below:

 		/* test for correct signature */
 		authenticated = 0;
 		if (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&
		    PRIVSEP(sshkey_verify(key, sig, slen,
		    sshbuf_ptr(b), sshbuf_len(b),
		    (ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL,
		    ssh->compat)) == 0) {
 			authenticated = 1;
 		}
 		sshbuf_free(b);
//flaw_line_below:
		free(sig);
 		auth2_record_key(authctxt, authenticated, key);
 	} else {
 		debug(""%s: test pkalg %s pkblob %s%s%s"",
		    __func__, pkalg, key_s,
		    ca_s == NULL ? """" : "" CA "",
		    ca_s == NULL ? """" : ca_s);

 		if ((r = sshpkt_get_end(ssh)) != 0)
 			fatal(""%s: %s"", __func__, ssh_err(r));
 
//fix_flaw_line_below:
//		if (!authctxt->valid || authctxt->user == NULL) {
//fix_flaw_line_below:
//			debug2(""%s: disabled because of invalid user"",
//fix_flaw_line_below:
//			    __func__);
//fix_flaw_line_below:
//			goto done;
//fix_flaw_line_below:
//		}
 		/* XXX fake reply and always send PK_OK ? */
 		/*
 		 * XXX this allows testing whether a user is allowed
		 * to login: if you happen to have a valid pubkey this
		 * message is sent. the message is NEVER sent at all
		 * if a user is not allowed to login. is this an
		 * issue? -markus
		 */
		if (PRIVSEP(user_key_allowed(ssh, pw, key, 0, NULL))) {
			if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_PK_OK))
			    != 0 ||
			    (r = sshpkt_put_cstring(ssh, pkalg)) != 0 ||
			    (r = sshpkt_put_string(ssh, pkblob, blen)) != 0 ||
			    (r = sshpkt_send(ssh)) != 0 ||
			    (r = ssh_packet_write_wait(ssh)) != 0)
				fatal(""%s: %s"", __func__, ssh_err(r));
			authctxt->postponed = 1;
		}
	}
done:
	if (authenticated == 1 && auth_activate_options(ssh, authopts) != 0) {
		debug(""%s: key options inconsistent with existing"", __func__);
		authenticated = 0;
	}
	debug2(""%s: authenticated %d pkalg %s"", __func__, authenticated, pkalg);

	sshauthopt_free(authopts);
	sshkey_free(key);
	free(userstyle);
	free(pkalg);
 	free(pkblob);
 	free(key_s);
 	free(ca_s);
//fix_flaw_line_below:
//	free(sig);
 	return authenticated;
 }
",182278,"userauth_pubkey(struct ssh *ssh)
 {
 	Authctxt *authctxt = ssh->authctxt;
 	struct passwd *pw = authctxt->pw;
	struct sshbuf *b;
 	struct sshkey *key = NULL;
	char *pkalg, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;
	u_char *pkblob, *sig, have_sig;
 	size_t blen, slen;
 	int r, pktype;
 	int authenticated = 0;
 	struct sshauthopt *authopts = NULL;
 
	if (!authctxt->valid) {
		debug2(""%s: disabled because of invalid user"", __func__);
		return 0;
	}
 	if ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||
 	    (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||
 	    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)
		fatal(""%s: parse request failed: %s"", __func__, ssh_err(r));
	pktype = sshkey_type_from_name(pkalg);
	if (pktype == KEY_UNSPEC) {
		/* this is perfectly legal */
		verbose(""%s: unsupported public key algorithm: %s"",
		    __func__, pkalg);
		goto done;
	}
	if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {
		error(""%s: could not parse key: %s"", __func__, ssh_err(r));
		goto done;
	}
	if (key == NULL) {
		error(""%s: cannot decode key: %s"", __func__, pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error(""%s: type mismatch for decoded key ""
		    ""(received %d, expected %d)"", __func__, key->type, pktype);
		goto done;
	}
	if (sshkey_type_plain(key->type) == KEY_RSA &&
	    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {
		logit(""Refusing RSA key because client uses unsafe ""
		    ""signature scheme"");
		goto done;
	}
	if (auth2_key_already_used(authctxt, key)) {
		logit(""refusing previously-used %s key"", sshkey_type(key));
		goto done;
	}
	if (match_pattern_list(pkalg, options.pubkey_key_types, 0) != 1) {
		logit(""%s: key type %s not in PubkeyAcceptedKeyTypes"",
		    __func__, sshkey_ssh_name(key));
		goto done;
	}

	key_s = format_key(key);
	if (sshkey_is_cert(key))
		ca_s = format_key(key->cert->signature_key);

	if (have_sig) {
		debug3(""%s: have %s signature for %s%s%s"",
		    __func__, pkalg, key_s,
		    ca_s == NULL ? """" : "" CA "",
		    ca_s == NULL ? """" : ca_s);
		if ((r = sshpkt_get_string(ssh, &sig, &slen)) != 0 ||
		    (r = sshpkt_get_end(ssh)) != 0)
			fatal(""%s: %s"", __func__, ssh_err(r));
		if ((b = sshbuf_new()) == NULL)
			fatal(""%s: sshbuf_new failed"", __func__);
		if (ssh->compat & SSH_OLD_SESSIONID) {
			if ((r = sshbuf_put(b, session_id2,
			    session_id2_len)) != 0)
				fatal(""%s: sshbuf_put session id: %s"",
				    __func__, ssh_err(r));
		} else {
			if ((r = sshbuf_put_string(b, session_id2,
			    session_id2_len)) != 0)
 				fatal(""%s: sshbuf_put_string session id: %s"",
 				    __func__, ssh_err(r));
 		}
 		/* reconstruct packet */
 		xasprintf(&userstyle, ""%s%s%s"", authctxt->user,
 		    authctxt->style ? "":"" : """",
		    authctxt->style ? authctxt->style : """");
		if ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||
		    (r = sshbuf_put_cstring(b, userstyle)) != 0 ||
		    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||
		    (r = sshbuf_put_cstring(b, ""publickey"")) != 0 ||
		    (r = sshbuf_put_u8(b, have_sig)) != 0 ||
		    (r = sshbuf_put_cstring(b, pkalg) != 0) ||
		    (r = sshbuf_put_string(b, pkblob, blen)) != 0)
			fatal(""%s: build packet failed: %s"",
			    __func__, ssh_err(r));
 #ifdef DEBUG_PK
 		sshbuf_dump(b, stderr);
 #endif
 		/* test for correct signature */
 		authenticated = 0;
 		if (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&
		    PRIVSEP(sshkey_verify(key, sig, slen,
		    sshbuf_ptr(b), sshbuf_len(b),
		    (ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL,
		    ssh->compat)) == 0) {
 			authenticated = 1;
 		}
 		sshbuf_free(b);
		free(sig);
 		auth2_record_key(authctxt, authenticated, key);
 	} else {
 		debug(""%s: test pkalg %s pkblob %s%s%s"",
		    __func__, pkalg, key_s,
		    ca_s == NULL ? """" : "" CA "",
		    ca_s == NULL ? """" : ca_s);

 		if ((r = sshpkt_get_end(ssh)) != 0)
 			fatal(""%s: %s"", __func__, ssh_err(r));
 
 		/* XXX fake reply and always send PK_OK ? */
 		/*
 		 * XXX this allows testing whether a user is allowed
		 * to login: if you happen to have a valid pubkey this
		 * message is sent. the message is NEVER sent at all
		 * if a user is not allowed to login. is this an
		 * issue? -markus
		 */
		if (PRIVSEP(user_key_allowed(ssh, pw, key, 0, NULL))) {
			if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_PK_OK))
			    != 0 ||
			    (r = sshpkt_put_cstring(ssh, pkalg)) != 0 ||
			    (r = sshpkt_put_string(ssh, pkblob, blen)) != 0 ||
			    (r = sshpkt_send(ssh)) != 0 ||
			    (r = ssh_packet_write_wait(ssh)) != 0)
				fatal(""%s: %s"", __func__, ssh_err(r));
			authctxt->postponed = 1;
		}
	}
done:
	if (authenticated == 1 && auth_activate_options(ssh, authopts) != 0) {
		debug(""%s: key options inconsistent with existing"", __func__);
		authenticated = 0;
	}
	debug2(""%s: authenticated %d pkalg %s"", __func__, authenticated, pkalg);

	sshauthopt_free(authopts);
	sshkey_free(key);
	free(userstyle);
	free(pkalg);
 	free(pkblob);
 	free(key_s);
 	free(ca_s);
 	return authenticated;
 }
","userauth_pubkey(struct ssh *ssh)
 {
 	Authctxt *authctxt = ssh->authctxt;
 	struct passwd *pw = authctxt->pw;
	struct sshbuf *b = NULL;
 	struct sshkey *key = NULL;
	char *pkalg = NULL, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;
	u_char *pkblob = NULL, *sig = NULL, have_sig;
 	size_t blen, slen;
 	int r, pktype;
 	int authenticated = 0;
 	struct sshauthopt *authopts = NULL;
 
 	if ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||
 	    (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||
 	    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)
		fatal(""%s: parse request failed: %s"", __func__, ssh_err(r));
	pktype = sshkey_type_from_name(pkalg);
	if (pktype == KEY_UNSPEC) {
		/* this is perfectly legal */
		verbose(""%s: unsupported public key algorithm: %s"",
		    __func__, pkalg);
		goto done;
	}
	if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {
		error(""%s: could not parse key: %s"", __func__, ssh_err(r));
		goto done;
	}
	if (key == NULL) {
		error(""%s: cannot decode key: %s"", __func__, pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error(""%s: type mismatch for decoded key ""
		    ""(received %d, expected %d)"", __func__, key->type, pktype);
		goto done;
	}
	if (sshkey_type_plain(key->type) == KEY_RSA &&
	    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {
		logit(""Refusing RSA key because client uses unsafe ""
		    ""signature scheme"");
		goto done;
	}
	if (auth2_key_already_used(authctxt, key)) {
		logit(""refusing previously-used %s key"", sshkey_type(key));
		goto done;
	}
	if (match_pattern_list(pkalg, options.pubkey_key_types, 0) != 1) {
		logit(""%s: key type %s not in PubkeyAcceptedKeyTypes"",
		    __func__, sshkey_ssh_name(key));
		goto done;
	}

	key_s = format_key(key);
	if (sshkey_is_cert(key))
		ca_s = format_key(key->cert->signature_key);

	if (have_sig) {
		debug3(""%s: have %s signature for %s%s%s"",
		    __func__, pkalg, key_s,
		    ca_s == NULL ? """" : "" CA "",
		    ca_s == NULL ? """" : ca_s);
		if ((r = sshpkt_get_string(ssh, &sig, &slen)) != 0 ||
		    (r = sshpkt_get_end(ssh)) != 0)
			fatal(""%s: %s"", __func__, ssh_err(r));
		if ((b = sshbuf_new()) == NULL)
			fatal(""%s: sshbuf_new failed"", __func__);
		if (ssh->compat & SSH_OLD_SESSIONID) {
			if ((r = sshbuf_put(b, session_id2,
			    session_id2_len)) != 0)
				fatal(""%s: sshbuf_put session id: %s"",
				    __func__, ssh_err(r));
		} else {
			if ((r = sshbuf_put_string(b, session_id2,
			    session_id2_len)) != 0)
 				fatal(""%s: sshbuf_put_string session id: %s"",
 				    __func__, ssh_err(r));
 		}
		if (!authctxt->valid || authctxt->user == NULL) {
			debug2(""%s: disabled because of invalid user"",
			    __func__);
			goto done;
		}
 		/* reconstruct packet */
 		xasprintf(&userstyle, ""%s%s%s"", authctxt->user,
 		    authctxt->style ? "":"" : """",
		    authctxt->style ? authctxt->style : """");
		if ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||
		    (r = sshbuf_put_cstring(b, userstyle)) != 0 ||
		    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||
		    (r = sshbuf_put_cstring(b, ""publickey"")) != 0 ||
		    (r = sshbuf_put_u8(b, have_sig)) != 0 ||
		    (r = sshbuf_put_cstring(b, pkalg) != 0) ||
		    (r = sshbuf_put_string(b, pkblob, blen)) != 0)
			fatal(""%s: build packet failed: %s"",
			    __func__, ssh_err(r));
 #ifdef DEBUG_PK
 		sshbuf_dump(b, stderr);
 #endif
 		/* test for correct signature */
 		authenticated = 0;
 		if (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&
		    PRIVSEP(sshkey_verify(key, sig, slen,
		    sshbuf_ptr(b), sshbuf_len(b),
		    (ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL,
		    ssh->compat)) == 0) {
 			authenticated = 1;
 		}
 		sshbuf_free(b);
 		auth2_record_key(authctxt, authenticated, key);
 	} else {
 		debug(""%s: test pkalg %s pkblob %s%s%s"",
		    __func__, pkalg, key_s,
		    ca_s == NULL ? """" : "" CA "",
		    ca_s == NULL ? """" : ca_s);

 		if ((r = sshpkt_get_end(ssh)) != 0)
 			fatal(""%s: %s"", __func__, ssh_err(r));
 
		if (!authctxt->valid || authctxt->user == NULL) {
			debug2(""%s: disabled because of invalid user"",
			    __func__);
			goto done;
		}
 		/* XXX fake reply and always send PK_OK ? */
 		/*
 		 * XXX this allows testing whether a user is allowed
		 * to login: if you happen to have a valid pubkey this
		 * message is sent. the message is NEVER sent at all
		 * if a user is not allowed to login. is this an
		 * issue? -markus
		 */
		if (PRIVSEP(user_key_allowed(ssh, pw, key, 0, NULL))) {
			if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_PK_OK))
			    != 0 ||
			    (r = sshpkt_put_cstring(ssh, pkalg)) != 0 ||
			    (r = sshpkt_put_string(ssh, pkblob, blen)) != 0 ||
			    (r = sshpkt_send(ssh)) != 0 ||
			    (r = ssh_packet_write_wait(ssh)) != 0)
				fatal(""%s: %s"", __func__, ssh_err(r));
			authctxt->postponed = 1;
		}
	}
done:
	if (authenticated == 1 && auth_activate_options(ssh, authopts) != 0) {
		debug(""%s: key options inconsistent with existing"", __func__);
		authenticated = 0;
	}
	debug2(""%s: authenticated %d pkalg %s"", __func__, authenticated, pkalg);

	sshauthopt_free(authopts);
	sshkey_free(key);
	free(userstyle);
	free(pkalg);
 	free(pkblob);
 	free(key_s);
 	free(ca_s);
	free(sig);
 	return authenticated;
 }
","The `userauth_pubkey` function handles public key authentication for SSH sessions. It begins by validating the user context and parsing the incoming packet for the public key algorithm and key blob. The function checks for key type compatibility, ensures the key hasn't been previously used, and verifies that the key type is accepted. If a signature is present, it reconstructs the packet and verifies the signature against the public key. If successful, it marks the user as authenticated. If no signature is provided, it checks if the user is allowed to log in based on the public key and sends a response accordingly. Finally, it cleans up resources and returns the authentication status.","The code implements a public key authentication mechanism for an SSH session. It begins by validating the user context and parsing the incoming authentication request for the public key algorithm and key data. The function checks for compatibility of the key type, ensures it hasn't been previously used, and verifies that it is an accepted type. If a signature is present, it reconstructs the necessary data to verify the signature against the public key. If successful, the user is authenticated; otherwise, it checks if the user is allowed to log in based on the public key and responds accordingly. Finally, it cleans up resources and returns the authentication status.","The vulnerability in the original code stemmed from prematurely terminating the authentication process if the user context was invalid, which could allow an attacker to infer valid usernames based on the server's response. Specifically, the check for a valid user occurred before fully parsing the incoming authentication request, potentially leaking information about the existence of valid users. The fix involved delaying this check until after the request packet was completely parsed, ensuring that the server does not reveal whether a username is valid or not until all relevant data has been processed, thus enhancing security against user enumeration attacks.","The vulnerability in the original code allowed an attacker to infer valid usernames based on the server's response, as the authentication process would terminate early if the user context was invalid. This premature check revealed whether a username existed, potentially enabling user enumeration attacks. The fix involved delaying the validation of the user context until after the entire authentication request packet was parsed. By doing so, the server no longer disclosed information about valid usernames prematurely, thereby enhancing security and preventing attackers from easily determining which usernames were valid.","The vulnerability was fixed by moving the check for a valid user context to occur after the entire authentication request packet has been parsed. In the updated code, the condition that checks if the user context is valid or if the user is null was relocated to follow the parsing of the packet, specifically after the calls to retrieve the signature and key blob. This change ensures that the server does not prematurely terminate the authentication process, allowing it to fully process the request before determining the validity of the user, thus preventing the disclosure of valid usernames.","The vulnerability was fixed by restructuring the code to delay the validation of the user context until after the entire authentication request packet had been fully parsed. This change prevents the server from prematurely terminating the authentication process based on user validity, which could inadvertently reveal information about valid usernames. By ensuring that the request is completely processed before checking the user context, the updated code enhances security by eliminating the potential for user enumeration attacks, thereby safeguarding sensitive information about user accounts.","5,4","5, 5","4, 4","4,4"
86,86,182279,182279,,Remote,Not required,,CVE-2018-15132,https://www.cvedetails.com/cve/CVE-2018-15132/,CWE-200,Low,Partial,,,2018-08-07,5.0,"An issue was discovered in ext/standard/link_win32.c in PHP before 5.6.37, 7.0.x before 7.0.31, 7.1.x before 7.1.20, and 7.2.x before 7.2.8. The linkinfo function on Windows doesn't implement the open_basedir check. This could be abused to find files on paths outside of the allowed directories.",2018-11-08,+Info ,11,https://github.com/php/php-src/commit/f151e048ed27f6f4eef729f3310d053ab5da71d4,f151e048ed27f6f4eef729f3310d053ab5da71d4,Fixed bug #76459 windows linkinfo lacks openbasedir check,0,ext/standard/link_win32.c,"{""sha"": ""0068a3edb1c6bac289637617d9d0b0e227be95ad"", ""filename"": ""ext/standard/link_win32.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/php/php-src/blob/f151e048ed27f6f4eef729f3310d053ab5da71d4/ext/standard/link_win32.c"", ""raw_url"": ""https://github.com/php/php-src/raw/f151e048ed27f6f4eef729f3310d053ab5da71d4/ext/standard/link_win32.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/standard/link_win32.c?ref=f151e048ed27f6f4eef729f3310d053ab5da71d4"", ""patch"": ""@@ -87,6 +87,7 @@ PHP_FUNCTION(readlink)\n PHP_FUNCTION(linkinfo)\n {\n \tchar *link;\n+\tchar *dirname;\n \tsize_t link_len;\n \tzend_stat_t sb;\n \tint ret;\n@@ -95,12 +96,22 @@ PHP_FUNCTION(linkinfo)\n \t\treturn;\n \t}\n \n+\tdirname = estrndup(link, link_len);\n+\tphp_dirname(dirname, link_len);\n+\n+\tif (php_check_open_basedir(dirname)) {\n+\t\tefree(dirname);\n+\t\tRETURN_FALSE;\n+\t}\n+\n \tret = VCWD_STAT(link, &sb);\n \tif (ret == -1) {\n \t\tphp_error_docref(NULL, E_WARNING, \""%s\"", strerror(errno));\n+\t\tefree(dirname);\n \t\tRETURN_LONG(Z_L(-1));\n \t}\n \n+\tefree(dirname);\n \tRETURN_LONG((zend_long) sb.st_dev);\n }\n /* }}} */""}"," PHP_FUNCTION(linkinfo)
 {
 	char *link;
	char *dirname;
 	size_t link_len;
 	zend_stat_t sb;
 	int ret;

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""p"", &link, &link_len) == FAILURE) {
 		return;
 	}
 
	dirname = estrndup(link, link_len);
	php_dirname(dirname, link_len);

	if (php_check_open_basedir(dirname)) {
		efree(dirname);
		RETURN_FALSE;
	}

 	ret = VCWD_STAT(link, &sb);
 	if (ret == -1) {
 		php_error_docref(NULL, E_WARNING, ""%s"", strerror(errno));
		efree(dirname);
 		RETURN_LONG(Z_L(-1));
 	}
 
	efree(dirname);
 	RETURN_LONG((zend_long) sb.st_dev);
 }
"," PHP_FUNCTION(linkinfo)
 {
 	char *link;
 	size_t link_len;
 	zend_stat_t sb;
 	int ret;

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""p"", &link, &link_len) == FAILURE) {
 		return;
 	}
 
 	ret = VCWD_STAT(link, &sb);
 	if (ret == -1) {
 		php_error_docref(NULL, E_WARNING, ""%s"", strerror(errno));
 		RETURN_LONG(Z_L(-1));
 	}
 
 	RETURN_LONG((zend_long) sb.st_dev);
 }
",C,"	char *dirname;
	dirname = estrndup(link, link_len);
	php_dirname(dirname, link_len);

	if (php_check_open_basedir(dirname)) {
		efree(dirname);
		RETURN_FALSE;
	}

		efree(dirname);
	efree(dirname);
",,,"@@ -87,6 +87,7 @@ PHP_FUNCTION(readlink)
 PHP_FUNCTION(linkinfo)
 {
 	char *link;
+	char *dirname;
 	size_t link_len;
 	zend_stat_t sb;
 	int ret;
@@ -95,12 +96,22 @@ PHP_FUNCTION(linkinfo)
 		return;
 	}
 
+	dirname = estrndup(link, link_len);
+	php_dirname(dirname, link_len);
+
+	if (php_check_open_basedir(dirname)) {
+		efree(dirname);
+		RETURN_FALSE;
+	}
+
 	ret = VCWD_STAT(link, &sb);
 	if (ret == -1) {
 		php_error_docref(NULL, E_WARNING, ""%s"", strerror(errno));
+		efree(dirname);
 		RETURN_LONG(Z_L(-1));
 	}
 
+	efree(dirname);
 	RETURN_LONG((zend_long) sb.st_dev);
 }
 /* }}} */",php-src,f151e048ed27f6f4eef729f3310d053ab5da71d4,5ac5f313bd129007c59ac842985bfdb35258f37d,1," PHP_FUNCTION(linkinfo)
 {
 	char *link;
//fix_flaw_line_below:
//	char *dirname;
 	size_t link_len;
 	zend_stat_t sb;
 	int ret;

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""p"", &link, &link_len) == FAILURE) {
 		return;
 	}
 
//fix_flaw_line_below:
//	dirname = estrndup(link, link_len);
//fix_flaw_line_below:
//	php_dirname(dirname, link_len);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (php_check_open_basedir(dirname)) {
//fix_flaw_line_below:
//		efree(dirname);
//fix_flaw_line_below:
//		RETURN_FALSE;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	ret = VCWD_STAT(link, &sb);
 	if (ret == -1) {
 		php_error_docref(NULL, E_WARNING, ""%s"", strerror(errno));
//fix_flaw_line_below:
//		efree(dirname);
 		RETURN_LONG(Z_L(-1));
 	}
 
//fix_flaw_line_below:
//	efree(dirname);
 	RETURN_LONG((zend_long) sb.st_dev);
 }
",182279," PHP_FUNCTION(linkinfo)
 {
 	char *link;
 	size_t link_len;
 	zend_stat_t sb;
 	int ret;

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""p"", &link, &link_len) == FAILURE) {
 		return;
 	}
 
 	ret = VCWD_STAT(link, &sb);
 	if (ret == -1) {
 		php_error_docref(NULL, E_WARNING, ""%s"", strerror(errno));
 		RETURN_LONG(Z_L(-1));
 	}
 
 	RETURN_LONG((zend_long) sb.st_dev);
 }
"," PHP_FUNCTION(linkinfo)
 {
 	char *link;
	char *dirname;
 	size_t link_len;
 	zend_stat_t sb;
 	int ret;

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""p"", &link, &link_len) == FAILURE) {
 		return;
 	}
 
	dirname = estrndup(link, link_len);
	php_dirname(dirname, link_len);

	if (php_check_open_basedir(dirname)) {
		efree(dirname);
		RETURN_FALSE;
	}

 	ret = VCWD_STAT(link, &sb);
 	if (ret == -1) {
 		php_error_docref(NULL, E_WARNING, ""%s"", strerror(errno));
		efree(dirname);
 		RETURN_LONG(Z_L(-1));
 	}
 
	efree(dirname);
 	RETURN_LONG((zend_long) sb.st_dev);
 }
","The provided PHP code defines a function named `linkinfo`, which retrieves and returns the device ID of a specified file or symbolic link. It begins by parsing the input parameters to obtain the file path as a string. The function then uses the `VCWD_STAT` function to gather file statistics, storing the results in a `zend_stat_t` structure. If the `VCWD_STAT` call fails, it triggers a warning with the corresponding error message and returns -1. If successful, it returns the device ID from the `st_dev` field of the statistics structure, indicating the device on which the file resides.","The code defines a function that retrieves the device ID of a specified file or symbolic link. It begins by accepting a file path as input and checks for any parsing errors. The function then attempts to gather file statistics, which include various attributes of the file. If the attempt to retrieve these statistics fails, it generates a warning with the relevant error message and returns a value indicating failure. If successful, the function returns the device ID, which indicates the specific device on which the file is located, providing useful information about the file's storage context.","The vulnerability in the original code arises from the lack of an open_basedir check, which allows access to files outside the specified directory restrictions, potentially leading to unauthorized file access. In the fixed code, a new variable is introduced to store a duplicate of the input link, and the `php_dirname` function is called to extract the directory name. Before attempting to retrieve file statistics, the code now checks if the directory is within the allowed paths using `php_check_open_basedir`. If the check fails, it frees the allocated memory and returns false, effectively preventing unauthorized access to files outside the designated directories.","The vulnerability in the original code stems from the absence of a check to restrict file access based on specified directory limitations, which could allow unauthorized access to files outside permitted paths. This oversight could lead to security risks, particularly in environments where sensitive files are present. In the revised code, a mechanism was introduced to extract the directory from the input path and verify it against the allowed directories. If the directory is not permitted, the code now appropriately handles the situation by freeing allocated resources and returning a failure response, thereby enhancing security by enforcing access restrictions.","The vulnerability was fixed by introducing a check for the directory of the input link before accessing its statistics. The code now uses `estrndup` to create a duplicate of the input link and then calls `php_dirname` to extract the directory name. This directory is subsequently validated with `php_check_open_basedir`, which ensures that the directory is within the allowed paths. If the check fails, the code frees the allocated memory using `efree` and returns false, preventing unauthorized access to files outside the designated directories and enhancing overall security.","The vulnerability was addressed by implementing a check to ensure that the directory of the specified file is within the allowed access paths. The code now creates a duplicate of the input path to extract the directory name, which is then validated against the defined restrictions. If the directory is found to be outside the permitted paths, the code appropriately handles the situation by freeing any allocated resources and returning a failure response. This enhancement effectively prevents unauthorized access to files, thereby strengthening security and ensuring compliance with directory access restrictions.","4,4","0,4","5,4","4,4"
87,87,182391,182391,,Local,Not required,,CVE-2018-11508,https://www.cvedetails.com/cve/CVE-2018-11508/,CWE-200,Low,Partial,,,2018-05-28,2.1,The compat_get_timex function in kernel/compat.c in the Linux kernel before 4.16.9 allows local users to obtain sensitive information from kernel memory via adjtimex.,2019-01-22,+Info ,1,https://github.com/torvalds/linux/commit/0a0b98734479aa5b3c671d5190e86273372cab95,0a0b98734479aa5b3c671d5190e86273372cab95,"compat: fix 4-byte infoleak via uninitialized struct field

Commit 3a4d44b61625 (""ntp: Move adjtimex related compat syscalls to
native counterparts"") removed the memset() in compat_get_timex().  Since
then, the compat adjtimex syscall can invoke do_adjtimex() with an
uninitialized ->tai.

If do_adjtimex() doesn't write to ->tai (e.g.  because the arguments are
invalid), compat_put_timex() then copies the uninitialized ->tai field
to userspace.

Fix it by adding the memset() back.

Fixes: 3a4d44b61625 (""ntp: Move adjtimex related compat syscalls to native counterparts"")
Signed-off-by: Jann Horn <jannh@google.com>
Acked-by: Kees Cook <keescook@chromium.org>
Acked-by: Al Viro <viro@zeniv.linux.org.uk>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,kernel/compat.c,"{""sha"": ""92d8c98c0f57ac92aacd888d9342debcdec46cdb"", ""filename"": ""kernel/compat.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/0a0b98734479aa5b3c671d5190e86273372cab95/kernel/compat.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0a0b98734479aa5b3c671d5190e86273372cab95/kernel/compat.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/compat.c?ref=0a0b98734479aa5b3c671d5190e86273372cab95"", ""patch"": ""@@ -34,6 +34,7 @@ int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)\n {\n \tstruct compat_timex tx32;\n \n+\tmemset(txc, 0, sizeof(struct timex));\n \tif (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))\n \t\treturn -EFAULT;\n ""}","int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)
 {
 	struct compat_timex tx32;
 
	memset(txc, 0, sizeof(struct timex));
 	if (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))
 		return -EFAULT;
 
	txc->modes = tx32.modes;
	txc->offset = tx32.offset;
	txc->freq = tx32.freq;
	txc->maxerror = tx32.maxerror;
	txc->esterror = tx32.esterror;
	txc->status = tx32.status;
	txc->constant = tx32.constant;
	txc->precision = tx32.precision;
	txc->tolerance = tx32.tolerance;
	txc->time.tv_sec = tx32.time.tv_sec;
	txc->time.tv_usec = tx32.time.tv_usec;
	txc->tick = tx32.tick;
	txc->ppsfreq = tx32.ppsfreq;
	txc->jitter = tx32.jitter;
	txc->shift = tx32.shift;
	txc->stabil = tx32.stabil;
	txc->jitcnt = tx32.jitcnt;
	txc->calcnt = tx32.calcnt;
	txc->errcnt = tx32.errcnt;
	txc->stbcnt = tx32.stbcnt;

	return 0;
}
","int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)
 {
 	struct compat_timex tx32;
 
 	if (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))
 		return -EFAULT;
 
	txc->modes = tx32.modes;
	txc->offset = tx32.offset;
	txc->freq = tx32.freq;
	txc->maxerror = tx32.maxerror;
	txc->esterror = tx32.esterror;
	txc->status = tx32.status;
	txc->constant = tx32.constant;
	txc->precision = tx32.precision;
	txc->tolerance = tx32.tolerance;
	txc->time.tv_sec = tx32.time.tv_sec;
	txc->time.tv_usec = tx32.time.tv_usec;
	txc->tick = tx32.tick;
	txc->ppsfreq = tx32.ppsfreq;
	txc->jitter = tx32.jitter;
	txc->shift = tx32.shift;
	txc->stabil = tx32.stabil;
	txc->jitcnt = tx32.jitcnt;
	txc->calcnt = tx32.calcnt;
	txc->errcnt = tx32.errcnt;
	txc->stbcnt = tx32.stbcnt;

	return 0;
}
",C,"	memset(txc, 0, sizeof(struct timex));
",,,"@@ -34,6 +34,7 @@ int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)
 {
 	struct compat_timex tx32;
 
+	memset(txc, 0, sizeof(struct timex));
 	if (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))
 		return -EFAULT;
 ",linux,0a0b98734479aa5b3c671d5190e86273372cab95,94d7dbf108813ea45a91e27e9a8bd231d5a23fa7,1,"int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)
 {
 	struct compat_timex tx32;
 
//fix_flaw_line_below:
//	memset(txc, 0, sizeof(struct timex));
 	if (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))
 		return -EFAULT;
 
	txc->modes = tx32.modes;
	txc->offset = tx32.offset;
	txc->freq = tx32.freq;
	txc->maxerror = tx32.maxerror;
	txc->esterror = tx32.esterror;
	txc->status = tx32.status;
	txc->constant = tx32.constant;
	txc->precision = tx32.precision;
	txc->tolerance = tx32.tolerance;
	txc->time.tv_sec = tx32.time.tv_sec;
	txc->time.tv_usec = tx32.time.tv_usec;
	txc->tick = tx32.tick;
	txc->ppsfreq = tx32.ppsfreq;
	txc->jitter = tx32.jitter;
	txc->shift = tx32.shift;
	txc->stabil = tx32.stabil;
	txc->jitcnt = tx32.jitcnt;
	txc->calcnt = tx32.calcnt;
	txc->errcnt = tx32.errcnt;
	txc->stbcnt = tx32.stbcnt;

	return 0;
}
",182391,"int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)
 {
 	struct compat_timex tx32;
 
 	if (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))
 		return -EFAULT;
 
	txc->modes = tx32.modes;
	txc->offset = tx32.offset;
	txc->freq = tx32.freq;
	txc->maxerror = tx32.maxerror;
	txc->esterror = tx32.esterror;
	txc->status = tx32.status;
	txc->constant = tx32.constant;
	txc->precision = tx32.precision;
	txc->tolerance = tx32.tolerance;
	txc->time.tv_sec = tx32.time.tv_sec;
	txc->time.tv_usec = tx32.time.tv_usec;
	txc->tick = tx32.tick;
	txc->ppsfreq = tx32.ppsfreq;
	txc->jitter = tx32.jitter;
	txc->shift = tx32.shift;
	txc->stabil = tx32.stabil;
	txc->jitcnt = tx32.jitcnt;
	txc->calcnt = tx32.calcnt;
	txc->errcnt = tx32.errcnt;
	txc->stbcnt = tx32.stbcnt;

	return 0;
}
","int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)
 {
 	struct compat_timex tx32;
 
	memset(txc, 0, sizeof(struct timex));
 	if (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))
 		return -EFAULT;
 
	txc->modes = tx32.modes;
	txc->offset = tx32.offset;
	txc->freq = tx32.freq;
	txc->maxerror = tx32.maxerror;
	txc->esterror = tx32.esterror;
	txc->status = tx32.status;
	txc->constant = tx32.constant;
	txc->precision = tx32.precision;
	txc->tolerance = tx32.tolerance;
	txc->time.tv_sec = tx32.time.tv_sec;
	txc->time.tv_usec = tx32.time.tv_usec;
	txc->tick = tx32.tick;
	txc->ppsfreq = tx32.ppsfreq;
	txc->jitter = tx32.jitter;
	txc->shift = tx32.shift;
	txc->stabil = tx32.stabil;
	txc->jitcnt = tx32.jitcnt;
	txc->calcnt = tx32.calcnt;
	txc->errcnt = tx32.errcnt;
	txc->stbcnt = tx32.stbcnt;

	return 0;
}
","The `compat_get_timex` function is designed to retrieve and convert timing information from a user-space structure (`compat_timex`) to a kernel-space structure (`timex`). It first attempts to copy the user-space data into a local variable (`tx32`) using `copy_from_user`, checking for errors in the process. If the copy is successful, it transfers the relevant fields from the `compat_timex` structure to the `timex` structure, effectively updating the kernel's timing parameters with the values provided by the user. The function returns 0 on success or -EFAULT if an error occurs during the copy operation.","The provided code defines a function that facilitates the transfer of timing information from a user-space structure to a kernel-space structure. It begins by attempting to copy data from the user-space input into a local variable, checking for any errors during this process. Upon successful copying, it updates various timing parameters in the kernel structure with the values obtained from the user input. The function concludes by returning a success indicator or an error code if the data transfer fails, ensuring that the kernel can accurately reflect the timing information provided by the user.","The vulnerability in the original code stemmed from the removal of the `memset()` function, which left the kernel-space structure uninitialized. This allowed the `tai` field to potentially contain garbage values when passed to the `do_adjtimex()` function, leading to an information leak if the `tai` field was copied back to user-space without being set. The fix involved reintroducing the `memset()` function to initialize the entire kernel structure to zero before copying data from the user-space structure. This ensures that all fields, including `tai`, are properly initialized, preventing any uninitialized data from being exposed to user-space.","The vulnerability in the original code arose from the removal of an initialization step, which left a specific field in the kernel structure uninitialized. This oversight meant that if a subsequent function was called without writing to this field—perhaps due to invalid input—the uninitialized data could be inadvertently copied back to user-space, leading to potential information leaks. The fix involved reintroducing the initialization step to ensure that all fields in the structure were set to a known state before any data was copied from user-space, thereby preventing any exposure of uninitialized data to user-space applications.","The vulnerability was fixed by reintroducing the `memset()` function to initialize the kernel-space structure to zero before any data is copied from the user-space structure. This ensures that all fields, including the critical `tai` field, are set to a known value, preventing any uninitialized data from being passed to the `do_adjtimex()` function. By doing this, if `do_adjtimex()` does not modify the `tai` field due to invalid arguments, the subsequent call to `compat_put_timex()` will not copy any garbage values back to user-space, thus eliminating the risk of information leakage.","The vulnerability was addressed by reintroducing an initialization step that sets all fields of the kernel structure to zero before any data is copied from the user-space structure. This ensures that all fields start with a known value, preventing any uninitialized data from being inadvertently passed to subsequent functions. As a result, if the function responsible for processing the data does not modify certain fields due to invalid input, there will be no risk of leaking garbage values back to user-space. This fix effectively eliminates the potential for information leakage and enhances the overall security of the code.","5,5","5,5","4,4","5, 5"
88,88,182440,182440,,Remote,Not required,Partial,CVE-2018-9275,https://www.cvedetails.com/cve/CVE-2018-9275/,CWE-200,Low,Partial,,,2018-04-04,6.4,"In check_user_token in util.c in the Yubico PAM module (aka pam_yubico) 2.18 through 2.25, successful logins can leak file descriptors to the auth mapping file, which can lead to information disclosure (serial number of a device) and/or DoS (reaching the maximum number of file descriptors).",2018-05-21,+Info ,2,https://github.com/Yubico/yubico-pam/commit/0f6ceabab0a8849b47f67d727aa526c2656089ba,0f6ceabab0a8849b47f67d727aa526c2656089ba,"util: make sure to close the authfile before returning success

fixes #136",0,util.c,"{""sha"": ""32bca06a04996410a985ec212766c7412a676290"", ""filename"": ""util.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/Yubico/yubico-pam/blob/0f6ceabab0a8849b47f67d727aa526c2656089ba/util.c"", ""raw_url"": ""https://github.com/Yubico/yubico-pam/raw/0f6ceabab0a8849b47f67d727aa526c2656089ba/util.c"", ""contents_url"": ""https://api.github.com/repos/Yubico/yubico-pam/contents/util.c?ref=0f6ceabab0a8849b47f67d727aa526c2656089ba"", ""patch"": ""@@ -167,6 +167,8 @@ check_user_token (const char *authfile,\n \t\t{\n \t\t  if(verbose)\n \t\t      D (debug_file, \""Match user/token as %s/%s\"", username, otp_id);\n+\n+\t\t  fclose(opwfile);\n \t\t  return AUTH_FOUND;\n \t\t}\n \t    }""}","check_user_token (const char *authfile,
		  const char *username,
		  const char *otp_id,
		  int verbose,
                  FILE *debug_file)
{
  char buf[1024];
  char *s_user, *s_token;
  int retval = AUTH_ERROR;
  int fd;
  struct stat st;
  FILE *opwfile;

  fd = open(authfile, O_RDONLY, 0);
  if (fd < 0) {
      if(verbose)
	  D (debug_file, ""Cannot open file: %s (%s)"", authfile, strerror(errno));
      return retval;
  }

  if (fstat(fd, &st) < 0) {
      if(verbose)
	  D (debug_file, ""Cannot stat file: %s (%s)"", authfile, strerror(errno));
      close(fd);
      return retval;
  }

  if (!S_ISREG(st.st_mode)) {
      if(verbose)
	  D (debug_file, ""%s is not a regular file"", authfile);
      close(fd);
      return retval;
  }

  opwfile = fdopen(fd, ""r"");
  if (opwfile == NULL) {
      if(verbose)
	  D (debug_file, ""fdopen: %s"", strerror(errno));
      close(fd);
      return retval;
  }

  retval = AUTH_NO_TOKENS;
  while (fgets (buf, 1024, opwfile))
    {
      char *saveptr = NULL;
      if (buf[strlen (buf) - 1] == '\n')
	buf[strlen (buf) - 1] = '\0';
      if (buf[0] == '#') {
          /* This is a comment and we may skip it. */
          if(verbose)
              D (debug_file, ""Skipping comment line: %s"", buf);
          continue;
      }
      if(verbose)
	  D (debug_file, ""Authorization line: %s"", buf);
      s_user = strtok_r (buf, "":"", &saveptr);
      if (s_user && strcmp (username, s_user) == 0)
	{
	  if(verbose)
	      D (debug_file, ""Matched user: %s"", s_user);
      retval = AUTH_NOT_FOUND; /* We found at least one line for the user */
	  do
	    {
	      s_token = strtok_r (NULL, "":"", &saveptr);
	      if(verbose)
		  D (debug_file, ""Authorization token: %s"", s_token);
	      if (s_token && otp_id && strcmp (otp_id, s_token) == 0)
 		{
 		  if(verbose)
 		      D (debug_file, ""Match user/token as %s/%s"", username, otp_id);

		  fclose(opwfile);
 		  return AUTH_FOUND;
 		}
 	    }
	  while (s_token != NULL);
	}
    }

  fclose (opwfile);

  return retval;
}
","check_user_token (const char *authfile,
		  const char *username,
		  const char *otp_id,
		  int verbose,
                  FILE *debug_file)
{
  char buf[1024];
  char *s_user, *s_token;
  int retval = AUTH_ERROR;
  int fd;
  struct stat st;
  FILE *opwfile;

  fd = open(authfile, O_RDONLY, 0);
  if (fd < 0) {
      if(verbose)
	  D (debug_file, ""Cannot open file: %s (%s)"", authfile, strerror(errno));
      return retval;
  }

  if (fstat(fd, &st) < 0) {
      if(verbose)
	  D (debug_file, ""Cannot stat file: %s (%s)"", authfile, strerror(errno));
      close(fd);
      return retval;
  }

  if (!S_ISREG(st.st_mode)) {
      if(verbose)
	  D (debug_file, ""%s is not a regular file"", authfile);
      close(fd);
      return retval;
  }

  opwfile = fdopen(fd, ""r"");
  if (opwfile == NULL) {
      if(verbose)
	  D (debug_file, ""fdopen: %s"", strerror(errno));
      close(fd);
      return retval;
  }

  retval = AUTH_NO_TOKENS;
  while (fgets (buf, 1024, opwfile))
    {
      char *saveptr = NULL;
      if (buf[strlen (buf) - 1] == '\n')
	buf[strlen (buf) - 1] = '\0';
      if (buf[0] == '#') {
          /* This is a comment and we may skip it. */
          if(verbose)
              D (debug_file, ""Skipping comment line: %s"", buf);
          continue;
      }
      if(verbose)
	  D (debug_file, ""Authorization line: %s"", buf);
      s_user = strtok_r (buf, "":"", &saveptr);
      if (s_user && strcmp (username, s_user) == 0)
	{
	  if(verbose)
	      D (debug_file, ""Matched user: %s"", s_user);
      retval = AUTH_NOT_FOUND; /* We found at least one line for the user */
	  do
	    {
	      s_token = strtok_r (NULL, "":"", &saveptr);
	      if(verbose)
		  D (debug_file, ""Authorization token: %s"", s_token);
	      if (s_token && otp_id && strcmp (otp_id, s_token) == 0)
 		{
 		  if(verbose)
 		      D (debug_file, ""Match user/token as %s/%s"", username, otp_id);
 		  return AUTH_FOUND;
 		}
 	    }
	  while (s_token != NULL);
	}
    }

  fclose (opwfile);

  return retval;
}
",C,"
		  fclose(opwfile);
",,,"@@ -167,6 +167,8 @@ check_user_token (const char *authfile,
 		{
 		  if(verbose)
 		      D (debug_file, ""Match user/token as %s/%s"", username, otp_id);
+
+		  fclose(opwfile);
 		  return AUTH_FOUND;
 		}
 	    }",yubico-pam,0f6ceabab0a8849b47f67d727aa526c2656089ba,af53411f7d7eac9414b929995b9dc44a7075924f,1,"check_user_token (const char *authfile,
		  const char *username,
		  const char *otp_id,
		  int verbose,
                  FILE *debug_file)
{
  char buf[1024];
  char *s_user, *s_token;
  int retval = AUTH_ERROR;
  int fd;
  struct stat st;
  FILE *opwfile;

  fd = open(authfile, O_RDONLY, 0);
  if (fd < 0) {
      if(verbose)
	  D (debug_file, ""Cannot open file: %s (%s)"", authfile, strerror(errno));
      return retval;
  }

  if (fstat(fd, &st) < 0) {
      if(verbose)
	  D (debug_file, ""Cannot stat file: %s (%s)"", authfile, strerror(errno));
      close(fd);
      return retval;
  }

  if (!S_ISREG(st.st_mode)) {
      if(verbose)
	  D (debug_file, ""%s is not a regular file"", authfile);
      close(fd);
      return retval;
  }

  opwfile = fdopen(fd, ""r"");
  if (opwfile == NULL) {
      if(verbose)
	  D (debug_file, ""fdopen: %s"", strerror(errno));
      close(fd);
      return retval;
  }

  retval = AUTH_NO_TOKENS;
  while (fgets (buf, 1024, opwfile))
    {
      char *saveptr = NULL;
      if (buf[strlen (buf) - 1] == '\n')
	buf[strlen (buf) - 1] = '\0';
      if (buf[0] == '#') {
          /* This is a comment and we may skip it. */
          if(verbose)
              D (debug_file, ""Skipping comment line: %s"", buf);
          continue;
      }
      if(verbose)
	  D (debug_file, ""Authorization line: %s"", buf);
      s_user = strtok_r (buf, "":"", &saveptr);
      if (s_user && strcmp (username, s_user) == 0)
	{
	  if(verbose)
	      D (debug_file, ""Matched user: %s"", s_user);
      retval = AUTH_NOT_FOUND; /* We found at least one line for the user */
	  do
	    {
	      s_token = strtok_r (NULL, "":"", &saveptr);
	      if(verbose)
		  D (debug_file, ""Authorization token: %s"", s_token);
	      if (s_token && otp_id && strcmp (otp_id, s_token) == 0)
 		{
 		  if(verbose)
 		      D (debug_file, ""Match user/token as %s/%s"", username, otp_id);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//		  fclose(opwfile);
 		  return AUTH_FOUND;
 		}
 	    }
	  while (s_token != NULL);
	}
    }

  fclose (opwfile);

  return retval;
}
",182440,"check_user_token (const char *authfile,
		  const char *username,
		  const char *otp_id,
		  int verbose,
                  FILE *debug_file)
{
  char buf[1024];
  char *s_user, *s_token;
  int retval = AUTH_ERROR;
  int fd;
  struct stat st;
  FILE *opwfile;

  fd = open(authfile, O_RDONLY, 0);
  if (fd < 0) {
      if(verbose)
	  D (debug_file, ""Cannot open file: %s (%s)"", authfile, strerror(errno));
      return retval;
  }

  if (fstat(fd, &st) < 0) {
      if(verbose)
	  D (debug_file, ""Cannot stat file: %s (%s)"", authfile, strerror(errno));
      close(fd);
      return retval;
  }

  if (!S_ISREG(st.st_mode)) {
      if(verbose)
	  D (debug_file, ""%s is not a regular file"", authfile);
      close(fd);
      return retval;
  }

  opwfile = fdopen(fd, ""r"");
  if (opwfile == NULL) {
      if(verbose)
	  D (debug_file, ""fdopen: %s"", strerror(errno));
      close(fd);
      return retval;
  }

  retval = AUTH_NO_TOKENS;
  while (fgets (buf, 1024, opwfile))
    {
      char *saveptr = NULL;
      if (buf[strlen (buf) - 1] == '\n')
	buf[strlen (buf) - 1] = '\0';
      if (buf[0] == '#') {
          /* This is a comment and we may skip it. */
          if(verbose)
              D (debug_file, ""Skipping comment line: %s"", buf);
          continue;
      }
      if(verbose)
	  D (debug_file, ""Authorization line: %s"", buf);
      s_user = strtok_r (buf, "":"", &saveptr);
      if (s_user && strcmp (username, s_user) == 0)
	{
	  if(verbose)
	      D (debug_file, ""Matched user: %s"", s_user);
      retval = AUTH_NOT_FOUND; /* We found at least one line for the user */
	  do
	    {
	      s_token = strtok_r (NULL, "":"", &saveptr);
	      if(verbose)
		  D (debug_file, ""Authorization token: %s"", s_token);
	      if (s_token && otp_id && strcmp (otp_id, s_token) == 0)
 		{
 		  if(verbose)
 		      D (debug_file, ""Match user/token as %s/%s"", username, otp_id);
 		  return AUTH_FOUND;
 		}
 	    }
	  while (s_token != NULL);
	}
    }

  fclose (opwfile);

  return retval;
}
","check_user_token (const char *authfile,
		  const char *username,
		  const char *otp_id,
		  int verbose,
                  FILE *debug_file)
{
  char buf[1024];
  char *s_user, *s_token;
  int retval = AUTH_ERROR;
  int fd;
  struct stat st;
  FILE *opwfile;

  fd = open(authfile, O_RDONLY, 0);
  if (fd < 0) {
      if(verbose)
	  D (debug_file, ""Cannot open file: %s (%s)"", authfile, strerror(errno));
      return retval;
  }

  if (fstat(fd, &st) < 0) {
      if(verbose)
	  D (debug_file, ""Cannot stat file: %s (%s)"", authfile, strerror(errno));
      close(fd);
      return retval;
  }

  if (!S_ISREG(st.st_mode)) {
      if(verbose)
	  D (debug_file, ""%s is not a regular file"", authfile);
      close(fd);
      return retval;
  }

  opwfile = fdopen(fd, ""r"");
  if (opwfile == NULL) {
      if(verbose)
	  D (debug_file, ""fdopen: %s"", strerror(errno));
      close(fd);
      return retval;
  }

  retval = AUTH_NO_TOKENS;
  while (fgets (buf, 1024, opwfile))
    {
      char *saveptr = NULL;
      if (buf[strlen (buf) - 1] == '\n')
	buf[strlen (buf) - 1] = '\0';
      if (buf[0] == '#') {
          /* This is a comment and we may skip it. */
          if(verbose)
              D (debug_file, ""Skipping comment line: %s"", buf);
          continue;
      }
      if(verbose)
	  D (debug_file, ""Authorization line: %s"", buf);
      s_user = strtok_r (buf, "":"", &saveptr);
      if (s_user && strcmp (username, s_user) == 0)
	{
	  if(verbose)
	      D (debug_file, ""Matched user: %s"", s_user);
      retval = AUTH_NOT_FOUND; /* We found at least one line for the user */
	  do
	    {
	      s_token = strtok_r (NULL, "":"", &saveptr);
	      if(verbose)
		  D (debug_file, ""Authorization token: %s"", s_token);
	      if (s_token && otp_id && strcmp (otp_id, s_token) == 0)
 		{
 		  if(verbose)
 		      D (debug_file, ""Match user/token as %s/%s"", username, otp_id);

		  fclose(opwfile);
 		  return AUTH_FOUND;
 		}
 	    }
	  while (s_token != NULL);
	}
    }

  fclose (opwfile);

  return retval;
}
","The `check_user_token` function verifies a user's one-time password (OTP) against stored tokens in a specified authentication file. It opens the file, checks its validity, and reads it line by line, skipping comments. For each line, it extracts the username and associated tokens, comparing them with the provided username and OTP ID. If a match is found, it returns `AUTH_FOUND`; if the user is found but no matching token exists, it returns `AUTH_NOT_FOUND`. If the user is not found, it returns `AUTH_NO_TOKENS`. Verbose logging can be enabled for debugging purposes.","The code checks a user's one-time password against a list of stored tokens in a specified authentication file. It begins by attempting to open the file and verifies its validity, ensuring it is a regular file. The code then reads the file line by line, ignoring comments, and extracts usernames and their associated tokens. It compares the provided username and password with those in the file. If a match is found, it confirms the authentication; if the user exists without a matching token, it indicates the absence of a valid token, and if the user is not found, it returns an appropriate error.","The vulnerability in the original code arises from the potential for resource leaks, specifically failing to close the authentication file after successfully finding a matching user and token. This could lead to file descriptor exhaustion if the function is called repeatedly. In the fixed code, the addition of `fclose(opwfile);` before returning `AUTH_FOUND` ensures that the file is properly closed when a successful authentication occurs. This change mitigates the risk of resource leaks, maintaining system stability and preventing potential denial-of-service conditions due to unclosed file descriptors.","The vulnerability in the original code stems from not closing the authentication file after successfully verifying a user's credentials, which can lead to resource leaks and potential exhaustion of file descriptors over time. This oversight could result in degraded system performance or even crashes if the function is invoked repeatedly without proper cleanup. The fix addresses this issue by ensuring that the file is closed immediately before returning a success status, thereby preventing resource leaks and maintaining system stability. This change enhances the overall reliability of the code by managing resources more effectively.","The vulnerability was fixed by adding a call to `fclose(opwfile);` immediately before returning `AUTH_FOUND` in the code. This ensures that the authentication file, which is opened with `fdopen`, is properly closed when a successful match is found between the user and the token. By closing the file descriptor, the code prevents resource leaks that could occur if the function is called multiple times without closing the file, thereby mitigating the risk of file descriptor exhaustion and enhancing the overall stability and reliability of the application.","The vulnerability was fixed by ensuring that the authentication file is properly closed before returning a success status after a successful user and token match. This change prevents resource leaks that could occur if the function is called multiple times without closing the file, which could lead to exhaustion of system resources. By implementing this fix, the code now effectively manages file descriptors, thereby enhancing the stability and reliability of the application while reducing the risk of performance degradation or crashes due to unclosed resources.","5,5","5,5","4,4","5,5"
89,89,182516,182516,,Remote,Not required,,CVE-2018-6412,https://www.cvedetails.com/cve/CVE-2018-6412/,CWE-200,Low,Partial,,,2018-01-31,5.0,"In the function sbusfb_ioctl_helper() in drivers/video/fbdev/sbuslib.c in the Linux kernel through 4.15, an integer signedness error allows arbitrary information leakage for the FBIOPUTCMAP_SPARC and FBIOGETCMAP_SPARC commands.",2018-03-11,+Info ,2,https://github.com/torvalds/linux/commit/250c6c49e3b68756b14983c076183568636e2bde,250c6c49e3b68756b14983c076183568636e2bde,"fbdev: Fixing arbitrary kernel leak in case FBIOGETCMAP_SPARC in sbusfb_ioctl_helper().

Fixing arbitrary kernel leak in case FBIOGETCMAP_SPARC in
sbusfb_ioctl_helper().

'index' is defined as an int in sbusfb_ioctl_helper().
We retrieve this from the user:
if (get_user(index, &c->index) ||
    __get_user(count, &c->count) ||
    __get_user(ured, &c->red) ||
    __get_user(ugreen, &c->green) ||
    __get_user(ublue, &c->blue))
       return -EFAULT;

and then we use 'index' in the following way:
red = cmap->red[index + i] >> 8;
green = cmap->green[index + i] >> 8;
blue = cmap->blue[index + i] >> 8;

This is a classic information leak vulnerability. 'index' should be
an unsigned int, given its usage above.

This patch is straight-forward; it changes 'index' to unsigned int
in two switch-cases: FBIOGETCMAP_SPARC && FBIOPUTCMAP_SPARC.

This patch fixes CVE-2018-6412.

Signed-off-by: Peter Malone <peter.malone@gmail.com>
Acked-by: Mathieu Malaterre <malat@debian.org>
Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>",2,drivers/video/fbdev/sbuslib.c,"{""sha"": ""a436d44f1b7fbf4e2fe2447de21a6aa5a4903cde"", ""filename"": ""drivers/video/fbdev/sbuslib.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/250c6c49e3b68756b14983c076183568636e2bde/drivers/video/fbdev/sbuslib.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/250c6c49e3b68756b14983c076183568636e2bde/drivers/video/fbdev/sbuslib.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/video/fbdev/sbuslib.c?ref=250c6c49e3b68756b14983c076183568636e2bde"", ""patch"": ""@@ -122,7 +122,7 @@ int sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,\n \t\tunsigned char __user *ured;\n \t\tunsigned char __user *ugreen;\n \t\tunsigned char __user *ublue;\n-\t\tint index, count, i;\n+\t\tunsigned int index, count, i;\n \n \t\tif (get_user(index, &c->index) ||\n \t\t    __get_user(count, &c->count) ||\n@@ -161,7 +161,7 @@ int sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,\n \t\tunsigned char __user *ugreen;\n \t\tunsigned char __user *ublue;\n \t\tstruct fb_cmap *cmap = &info->cmap;\n-\t\tint index, count, i;\n+\t\tunsigned int index, count, i;\n \t\tu8 red, green, blue;\n \n \t\tif (get_user(index, &c->index) ||""}","int sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,
			struct fb_info *info,
			int type, int fb_depth, unsigned long fb_size)
{
	switch(cmd) {
	case FBIOGTYPE: {
		struct fbtype __user *f = (struct fbtype __user *) arg;

		if (put_user(type, &f->fb_type) ||
		    __put_user(info->var.yres, &f->fb_height) ||
		    __put_user(info->var.xres, &f->fb_width) ||
		    __put_user(fb_depth, &f->fb_depth) ||
		    __put_user(0, &f->fb_cmsize) ||
		    __put_user(fb_size, &f->fb_cmsize))
			return -EFAULT;
		return 0;
	}
	case FBIOPUTCMAP_SPARC: {
		struct fbcmap __user *c = (struct fbcmap __user *) arg;
		struct fb_cmap cmap;
		u16 red, green, blue;
		u8 red8, green8, blue8;
 		unsigned char __user *ured;
 		unsigned char __user *ugreen;
 		unsigned char __user *ublue;
		unsigned int index, count, i;
 
 		if (get_user(index, &c->index) ||
 		    __get_user(count, &c->count) ||
		    __get_user(ured, &c->red) ||
		    __get_user(ugreen, &c->green) ||
		    __get_user(ublue, &c->blue))
			return -EFAULT;

		cmap.len = 1;
		cmap.red = &red;
		cmap.green = &green;
		cmap.blue = &blue;
		cmap.transp = NULL;
		for (i = 0; i < count; i++) {
			int err;

			if (get_user(red8, &ured[i]) ||
			    get_user(green8, &ugreen[i]) ||
			    get_user(blue8, &ublue[i]))
				return -EFAULT;

			red = red8 << 8;
			green = green8 << 8;
			blue = blue8 << 8;

			cmap.start = index + i;
			err = fb_set_cmap(&cmap, info);
			if (err)
				return err;
		}
		return 0;
	}
	case FBIOGETCMAP_SPARC: {
		struct fbcmap __user *c = (struct fbcmap __user *) arg;
		unsigned char __user *ured;
 		unsigned char __user *ugreen;
 		unsigned char __user *ublue;
 		struct fb_cmap *cmap = &info->cmap;
		unsigned int index, count, i;
 		u8 red, green, blue;
 
 		if (get_user(index, &c->index) ||
		    __get_user(count, &c->count) ||
		    __get_user(ured, &c->red) ||
		    __get_user(ugreen, &c->green) ||
		    __get_user(ublue, &c->blue))
			return -EFAULT;

		if (index + count > cmap->len)
			return -EINVAL;

		for (i = 0; i < count; i++) {
			red = cmap->red[index + i] >> 8;
			green = cmap->green[index + i] >> 8;
			blue = cmap->blue[index + i] >> 8;
			if (put_user(red, &ured[i]) ||
			    put_user(green, &ugreen[i]) ||
			    put_user(blue, &ublue[i]))
				return -EFAULT;
		}
		return 0;
	}
	default:
		return -EINVAL;
	}
}
","int sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,
			struct fb_info *info,
			int type, int fb_depth, unsigned long fb_size)
{
	switch(cmd) {
	case FBIOGTYPE: {
		struct fbtype __user *f = (struct fbtype __user *) arg;

		if (put_user(type, &f->fb_type) ||
		    __put_user(info->var.yres, &f->fb_height) ||
		    __put_user(info->var.xres, &f->fb_width) ||
		    __put_user(fb_depth, &f->fb_depth) ||
		    __put_user(0, &f->fb_cmsize) ||
		    __put_user(fb_size, &f->fb_cmsize))
			return -EFAULT;
		return 0;
	}
	case FBIOPUTCMAP_SPARC: {
		struct fbcmap __user *c = (struct fbcmap __user *) arg;
		struct fb_cmap cmap;
		u16 red, green, blue;
		u8 red8, green8, blue8;
 		unsigned char __user *ured;
 		unsigned char __user *ugreen;
 		unsigned char __user *ublue;
		int index, count, i;
 
 		if (get_user(index, &c->index) ||
 		    __get_user(count, &c->count) ||
		    __get_user(ured, &c->red) ||
		    __get_user(ugreen, &c->green) ||
		    __get_user(ublue, &c->blue))
			return -EFAULT;

		cmap.len = 1;
		cmap.red = &red;
		cmap.green = &green;
		cmap.blue = &blue;
		cmap.transp = NULL;
		for (i = 0; i < count; i++) {
			int err;

			if (get_user(red8, &ured[i]) ||
			    get_user(green8, &ugreen[i]) ||
			    get_user(blue8, &ublue[i]))
				return -EFAULT;

			red = red8 << 8;
			green = green8 << 8;
			blue = blue8 << 8;

			cmap.start = index + i;
			err = fb_set_cmap(&cmap, info);
			if (err)
				return err;
		}
		return 0;
	}
	case FBIOGETCMAP_SPARC: {
		struct fbcmap __user *c = (struct fbcmap __user *) arg;
		unsigned char __user *ured;
 		unsigned char __user *ugreen;
 		unsigned char __user *ublue;
 		struct fb_cmap *cmap = &info->cmap;
		int index, count, i;
 		u8 red, green, blue;
 
 		if (get_user(index, &c->index) ||
		    __get_user(count, &c->count) ||
		    __get_user(ured, &c->red) ||
		    __get_user(ugreen, &c->green) ||
		    __get_user(ublue, &c->blue))
			return -EFAULT;

		if (index + count > cmap->len)
			return -EINVAL;

		for (i = 0; i < count; i++) {
			red = cmap->red[index + i] >> 8;
			green = cmap->green[index + i] >> 8;
			blue = cmap->blue[index + i] >> 8;
			if (put_user(red, &ured[i]) ||
			    put_user(green, &ugreen[i]) ||
			    put_user(blue, &ublue[i]))
				return -EFAULT;
		}
		return 0;
	}
	default:
		return -EINVAL;
	}
}
",C,"		unsigned int index, count, i;
		unsigned int index, count, i;
","		int index, count, i;
		int index, count, i;
",,"@@ -122,7 +122,7 @@ int sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,
 		unsigned char __user *ured;
 		unsigned char __user *ugreen;
 		unsigned char __user *ublue;
-		int index, count, i;
+		unsigned int index, count, i;
 
 		if (get_user(index, &c->index) ||
 		    __get_user(count, &c->count) ||
@@ -161,7 +161,7 @@ int sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,
 		unsigned char __user *ugreen;
 		unsigned char __user *ublue;
 		struct fb_cmap *cmap = &info->cmap;
-		int index, count, i;
+		unsigned int index, count, i;
 		u8 red, green, blue;
 
 		if (get_user(index, &c->index) ||",linux,250c6c49e3b68756b14983c076183568636e2bde,5fe9cfbe44b6892e17f803125c4761221b0175c6,1,"int sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,
			struct fb_info *info,
			int type, int fb_depth, unsigned long fb_size)
{
	switch(cmd) {
	case FBIOGTYPE: {
		struct fbtype __user *f = (struct fbtype __user *) arg;

		if (put_user(type, &f->fb_type) ||
		    __put_user(info->var.yres, &f->fb_height) ||
		    __put_user(info->var.xres, &f->fb_width) ||
		    __put_user(fb_depth, &f->fb_depth) ||
		    __put_user(0, &f->fb_cmsize) ||
		    __put_user(fb_size, &f->fb_cmsize))
			return -EFAULT;
		return 0;
	}
	case FBIOPUTCMAP_SPARC: {
		struct fbcmap __user *c = (struct fbcmap __user *) arg;
		struct fb_cmap cmap;
		u16 red, green, blue;
		u8 red8, green8, blue8;
 		unsigned char __user *ured;
 		unsigned char __user *ugreen;
 		unsigned char __user *ublue;
//flaw_line_below:
		int index, count, i;
//fix_flaw_line_below:
//		unsigned int index, count, i;
 
 		if (get_user(index, &c->index) ||
 		    __get_user(count, &c->count) ||
		    __get_user(ured, &c->red) ||
		    __get_user(ugreen, &c->green) ||
		    __get_user(ublue, &c->blue))
			return -EFAULT;

		cmap.len = 1;
		cmap.red = &red;
		cmap.green = &green;
		cmap.blue = &blue;
		cmap.transp = NULL;
		for (i = 0; i < count; i++) {
			int err;

			if (get_user(red8, &ured[i]) ||
			    get_user(green8, &ugreen[i]) ||
			    get_user(blue8, &ublue[i]))
				return -EFAULT;

			red = red8 << 8;
			green = green8 << 8;
			blue = blue8 << 8;

			cmap.start = index + i;
			err = fb_set_cmap(&cmap, info);
			if (err)
				return err;
		}
		return 0;
	}
	case FBIOGETCMAP_SPARC: {
		struct fbcmap __user *c = (struct fbcmap __user *) arg;
		unsigned char __user *ured;
 		unsigned char __user *ugreen;
 		unsigned char __user *ublue;
 		struct fb_cmap *cmap = &info->cmap;
//flaw_line_below:
		int index, count, i;
//fix_flaw_line_below:
//		unsigned int index, count, i;
 		u8 red, green, blue;
 
 		if (get_user(index, &c->index) ||
		    __get_user(count, &c->count) ||
		    __get_user(ured, &c->red) ||
		    __get_user(ugreen, &c->green) ||
		    __get_user(ublue, &c->blue))
			return -EFAULT;

		if (index + count > cmap->len)
			return -EINVAL;

		for (i = 0; i < count; i++) {
			red = cmap->red[index + i] >> 8;
			green = cmap->green[index + i] >> 8;
			blue = cmap->blue[index + i] >> 8;
			if (put_user(red, &ured[i]) ||
			    put_user(green, &ugreen[i]) ||
			    put_user(blue, &ublue[i]))
				return -EFAULT;
		}
		return 0;
	}
	default:
		return -EINVAL;
	}
}
",182516,"int sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,
			struct fb_info *info,
			int type, int fb_depth, unsigned long fb_size)
{
	switch(cmd) {
	case FBIOGTYPE: {
		struct fbtype __user *f = (struct fbtype __user *) arg;

		if (put_user(type, &f->fb_type) ||
		    __put_user(info->var.yres, &f->fb_height) ||
		    __put_user(info->var.xres, &f->fb_width) ||
		    __put_user(fb_depth, &f->fb_depth) ||
		    __put_user(0, &f->fb_cmsize) ||
		    __put_user(fb_size, &f->fb_cmsize))
			return -EFAULT;
		return 0;
	}
	case FBIOPUTCMAP_SPARC: {
		struct fbcmap __user *c = (struct fbcmap __user *) arg;
		struct fb_cmap cmap;
		u16 red, green, blue;
		u8 red8, green8, blue8;
 		unsigned char __user *ured;
 		unsigned char __user *ugreen;
 		unsigned char __user *ublue;
		int index, count, i;
 
 		if (get_user(index, &c->index) ||
 		    __get_user(count, &c->count) ||
		    __get_user(ured, &c->red) ||
		    __get_user(ugreen, &c->green) ||
		    __get_user(ublue, &c->blue))
			return -EFAULT;

		cmap.len = 1;
		cmap.red = &red;
		cmap.green = &green;
		cmap.blue = &blue;
		cmap.transp = NULL;
		for (i = 0; i < count; i++) {
			int err;

			if (get_user(red8, &ured[i]) ||
			    get_user(green8, &ugreen[i]) ||
			    get_user(blue8, &ublue[i]))
				return -EFAULT;

			red = red8 << 8;
			green = green8 << 8;
			blue = blue8 << 8;

			cmap.start = index + i;
			err = fb_set_cmap(&cmap, info);
			if (err)
				return err;
		}
		return 0;
	}
	case FBIOGETCMAP_SPARC: {
		struct fbcmap __user *c = (struct fbcmap __user *) arg;
		unsigned char __user *ured;
 		unsigned char __user *ugreen;
 		unsigned char __user *ublue;
 		struct fb_cmap *cmap = &info->cmap;
		int index, count, i;
 		u8 red, green, blue;
 
 		if (get_user(index, &c->index) ||
		    __get_user(count, &c->count) ||
		    __get_user(ured, &c->red) ||
		    __get_user(ugreen, &c->green) ||
		    __get_user(ublue, &c->blue))
			return -EFAULT;

		if (index + count > cmap->len)
			return -EINVAL;

		for (i = 0; i < count; i++) {
			red = cmap->red[index + i] >> 8;
			green = cmap->green[index + i] >> 8;
			blue = cmap->blue[index + i] >> 8;
			if (put_user(red, &ured[i]) ||
			    put_user(green, &ugreen[i]) ||
			    put_user(blue, &ublue[i]))
				return -EFAULT;
		}
		return 0;
	}
	default:
		return -EINVAL;
	}
}
","int sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,
			struct fb_info *info,
			int type, int fb_depth, unsigned long fb_size)
{
	switch(cmd) {
	case FBIOGTYPE: {
		struct fbtype __user *f = (struct fbtype __user *) arg;

		if (put_user(type, &f->fb_type) ||
		    __put_user(info->var.yres, &f->fb_height) ||
		    __put_user(info->var.xres, &f->fb_width) ||
		    __put_user(fb_depth, &f->fb_depth) ||
		    __put_user(0, &f->fb_cmsize) ||
		    __put_user(fb_size, &f->fb_cmsize))
			return -EFAULT;
		return 0;
	}
	case FBIOPUTCMAP_SPARC: {
		struct fbcmap __user *c = (struct fbcmap __user *) arg;
		struct fb_cmap cmap;
		u16 red, green, blue;
		u8 red8, green8, blue8;
 		unsigned char __user *ured;
 		unsigned char __user *ugreen;
 		unsigned char __user *ublue;
		unsigned int index, count, i;
 
 		if (get_user(index, &c->index) ||
 		    __get_user(count, &c->count) ||
		    __get_user(ured, &c->red) ||
		    __get_user(ugreen, &c->green) ||
		    __get_user(ublue, &c->blue))
			return -EFAULT;

		cmap.len = 1;
		cmap.red = &red;
		cmap.green = &green;
		cmap.blue = &blue;
		cmap.transp = NULL;
		for (i = 0; i < count; i++) {
			int err;

			if (get_user(red8, &ured[i]) ||
			    get_user(green8, &ugreen[i]) ||
			    get_user(blue8, &ublue[i]))
				return -EFAULT;

			red = red8 << 8;
			green = green8 << 8;
			blue = blue8 << 8;

			cmap.start = index + i;
			err = fb_set_cmap(&cmap, info);
			if (err)
				return err;
		}
		return 0;
	}
	case FBIOGETCMAP_SPARC: {
		struct fbcmap __user *c = (struct fbcmap __user *) arg;
		unsigned char __user *ured;
 		unsigned char __user *ugreen;
 		unsigned char __user *ublue;
 		struct fb_cmap *cmap = &info->cmap;
		unsigned int index, count, i;
 		u8 red, green, blue;
 
 		if (get_user(index, &c->index) ||
		    __get_user(count, &c->count) ||
		    __get_user(ured, &c->red) ||
		    __get_user(ugreen, &c->green) ||
		    __get_user(ublue, &c->blue))
			return -EFAULT;

		if (index + count > cmap->len)
			return -EINVAL;

		for (i = 0; i < count; i++) {
			red = cmap->red[index + i] >> 8;
			green = cmap->green[index + i] >> 8;
			blue = cmap->blue[index + i] >> 8;
			if (put_user(red, &ured[i]) ||
			    put_user(green, &ugreen[i]) ||
			    put_user(blue, &ublue[i]))
				return -EFAULT;
		}
		return 0;
	}
	default:
		return -EINVAL;
	}
}
","The `sbusfb_ioctl_helper` function handles various framebuffer-related commands in a device driver context, specifically for managing framebuffer properties and color maps. It processes commands such as `FBIOGTYPE` to retrieve framebuffer type and dimensions, `FBIOPUTCMAP_SPARC` to set color maps by reading user-provided color values and updating the framebuffer's color map, and `FBIOGETCMAP_SPARC` to retrieve color map values for a specified range. The function ensures safe data transfer between user space and kernel space, returning appropriate error codes for invalid operations or memory access issues.","The provided code implements a function that manages framebuffer operations in a device driver, allowing interaction with user space through specific commands. It retrieves framebuffer characteristics such as type and dimensions, and facilitates the setting and getting of color maps. The function ensures safe communication between user and kernel space by validating memory access and handling errors appropriately. It processes requests to update color values based on user input and returns relevant information or error codes, ensuring that the framebuffer's state is accurately maintained and manipulated according to user commands.","The vulnerability in the original code stemmed from the use of a signed integer for the variable `index`, which was derived from user input. This allowed for the possibility of negative values, leading to an information leak when accessing kernel memory arrays, as negative indices could cause out-of-bounds reads. The fix involved changing the type of `index` to an unsigned integer in both the `FBIOGETCMAP_SPARC` and `FBIOPUTCMAP_SPARC` cases. This change ensures that `index` can only hold non-negative values, preventing the potential for accessing invalid memory locations and thus mitigating the information leak vulnerability.","The vulnerability in the original code arose from using a signed integer to handle user-provided input, which could potentially be negative. This allowed for the possibility of accessing memory outside the intended bounds, leading to an arbitrary kernel memory leak when retrieving color values. The fix involved changing the type of the variable to an unsigned integer, ensuring that it could only represent non-negative values. This adjustment prevents out-of-bounds memory access, thereby eliminating the risk of leaking sensitive kernel information and enhancing the overall security of the code.","The vulnerability was fixed by changing the type of the variable `index` from a signed integer to an unsigned integer in the `FBIOGETCMAP_SPARC` and `FBIOPUTCMAP_SPARC` cases. This modification ensures that the value of `index`, which is retrieved from user input using `get_user`, cannot be negative. Consequently, when `index` is used to access elements in the color map arrays, it prevents out-of-bounds access that could lead to arbitrary kernel memory leaks. This change effectively mitigates the risk associated with the original information leak vulnerability, enhancing the security of the function.","The vulnerability was addressed by changing the data type of a critical variable from a signed to an unsigned integer. This adjustment ensures that the variable can only hold non-negative values, thereby preventing the possibility of negative input from user space. As a result, when accessing memory based on this variable, the code is safeguarded against out-of-bounds access, which could lead to unintended exposure of sensitive kernel memory. This fix effectively eliminates the risk of arbitrary memory leaks, enhancing the overall security and stability of the code.","5, 4","5,5","4,4","5, 4"
90,90,182682,182682,,Remote,Not required,,CVE-2019-16714,https://www.cvedetails.com/cve/CVE-2019-16714/,CWE-200,Low,Partial,,,2019-09-23,5.0,"In the Linux kernel before 5.2.14, rds6_inc_info_copy in net/rds/recv.c allows attackers to obtain sensitive information from kernel stack memory because tos and flags fields are not initialized.",2019-09-24,+Info ,3,https://github.com/torvalds/linux/commit/7d0a06586b2686ba80c4a2da5f91cb10ffbea736,7d0a06586b2686ba80c4a2da5f91cb10ffbea736,"net/rds: Fix info leak in rds6_inc_info_copy()

The rds6_inc_info_copy() function has a couple struct members which
are leaking stack information.  The ->tos field should hold actual
information and the ->flags field needs to be zeroed out.

Fixes: 3eb450367d08 (""rds: add type of service(tos) infrastructure"")
Fixes: b7ff8b1036f0 (""rds: Extend RDS API for IPv6 support"")
Reported-by: 黄ID蝴蝶 <butterflyhuangxx@gmail.com>
Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
Signed-off-by: Ka-Cheong Poon <ka-cheong.poon@oracle.com>
Acked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/rds/recv.c,"{""sha"": ""a42ba7fa06d5d0a04e9829ffdf5561c3e648353a"", ""filename"": ""net/rds/recv.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/7d0a06586b2686ba80c4a2da5f91cb10ffbea736/net/rds/recv.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/7d0a06586b2686ba80c4a2da5f91cb10ffbea736/net/rds/recv.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/rds/recv.c?ref=7d0a06586b2686ba80c4a2da5f91cb10ffbea736"", ""patch"": ""@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2006, 2018 Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2019 Oracle and/or its affiliates. All rights reserved.\n  *\n  * This software is available to you under a choice of one of two\n  * licenses.  You may choose to be licensed under the terms of the GNU\n@@ -811,6 +811,7 @@ void rds6_inc_info_copy(struct rds_incoming *inc,\n \n \tminfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n \tminfo6.len = be32_to_cpu(inc->i_hdr.h_len);\n+\tminfo6.tos = inc->i_conn->c_tos;\n \n \tif (flip) {\n \t\tminfo6.laddr = *daddr;\n@@ -824,6 +825,8 @@ void rds6_inc_info_copy(struct rds_incoming *inc,\n \t\tminfo6.fport = inc->i_hdr.h_dport;\n \t}\n \n+\tminfo6.flags = 0;\n+\n \trds_info_copy(iter, &minfo6, sizeof(minfo6));\n }\n #endif""}","void rds6_inc_info_copy(struct rds_incoming *inc,
			struct rds_info_iterator *iter,
			struct in6_addr *saddr, struct in6_addr *daddr,
			int flip)
{
	struct rds6_info_message minfo6;
 
 	minfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);
 	minfo6.len = be32_to_cpu(inc->i_hdr.h_len);
	minfo6.tos = inc->i_conn->c_tos;
 
 	if (flip) {
 		minfo6.laddr = *daddr;
		minfo6.faddr = *saddr;
		minfo6.lport = inc->i_hdr.h_dport;
		minfo6.fport = inc->i_hdr.h_sport;
	} else {
		minfo6.laddr = *saddr;
		minfo6.faddr = *daddr;
		minfo6.lport = inc->i_hdr.h_sport;
 		minfo6.fport = inc->i_hdr.h_dport;
 	}
 
	minfo6.flags = 0;

 	rds_info_copy(iter, &minfo6, sizeof(minfo6));
 }
","void rds6_inc_info_copy(struct rds_incoming *inc,
			struct rds_info_iterator *iter,
			struct in6_addr *saddr, struct in6_addr *daddr,
			int flip)
{
	struct rds6_info_message minfo6;
 
 	minfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);
 	minfo6.len = be32_to_cpu(inc->i_hdr.h_len);
 
 	if (flip) {
 		minfo6.laddr = *daddr;
		minfo6.faddr = *saddr;
		minfo6.lport = inc->i_hdr.h_dport;
		minfo6.fport = inc->i_hdr.h_sport;
	} else {
		minfo6.laddr = *saddr;
		minfo6.faddr = *daddr;
		minfo6.lport = inc->i_hdr.h_sport;
 		minfo6.fport = inc->i_hdr.h_dport;
 	}
 
 	rds_info_copy(iter, &minfo6, sizeof(minfo6));
 }
",C,"	minfo6.tos = inc->i_conn->c_tos;
	minfo6.flags = 0;

",,,"@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2018 Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2019 Oracle and/or its affiliates. All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
@@ -811,6 +811,7 @@ void rds6_inc_info_copy(struct rds_incoming *inc,
 
 	minfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);
 	minfo6.len = be32_to_cpu(inc->i_hdr.h_len);
+	minfo6.tos = inc->i_conn->c_tos;
 
 	if (flip) {
 		minfo6.laddr = *daddr;
@@ -824,6 +825,8 @@ void rds6_inc_info_copy(struct rds_incoming *inc,
 		minfo6.fport = inc->i_hdr.h_dport;
 	}
 
+	minfo6.flags = 0;
+
 	rds_info_copy(iter, &minfo6, sizeof(minfo6));
 }
 #endif",linux,7d0a06586b2686ba80c4a2da5f91cb10ffbea736,2c1644cf6d46a8267d79ed95cb9b563839346562,1,"void rds6_inc_info_copy(struct rds_incoming *inc,
			struct rds_info_iterator *iter,
			struct in6_addr *saddr, struct in6_addr *daddr,
			int flip)
{
	struct rds6_info_message minfo6;
 
 	minfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);
 	minfo6.len = be32_to_cpu(inc->i_hdr.h_len);
//fix_flaw_line_below:
//	minfo6.tos = inc->i_conn->c_tos;
 
 	if (flip) {
 		minfo6.laddr = *daddr;
		minfo6.faddr = *saddr;
		minfo6.lport = inc->i_hdr.h_dport;
		minfo6.fport = inc->i_hdr.h_sport;
	} else {
		minfo6.laddr = *saddr;
		minfo6.faddr = *daddr;
		minfo6.lport = inc->i_hdr.h_sport;
 		minfo6.fport = inc->i_hdr.h_dport;
 	}
 
//fix_flaw_line_below:
//	minfo6.flags = 0;
//fix_flaw_line_below:
//
 	rds_info_copy(iter, &minfo6, sizeof(minfo6));
 }
",182682,"void rds6_inc_info_copy(struct rds_incoming *inc,
			struct rds_info_iterator *iter,
			struct in6_addr *saddr, struct in6_addr *daddr,
			int flip)
{
	struct rds6_info_message minfo6;
 
 	minfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);
 	minfo6.len = be32_to_cpu(inc->i_hdr.h_len);
 
 	if (flip) {
 		minfo6.laddr = *daddr;
		minfo6.faddr = *saddr;
		minfo6.lport = inc->i_hdr.h_dport;
		minfo6.fport = inc->i_hdr.h_sport;
	} else {
		minfo6.laddr = *saddr;
		minfo6.faddr = *daddr;
		minfo6.lport = inc->i_hdr.h_sport;
 		minfo6.fport = inc->i_hdr.h_dport;
 	}
 
 	rds_info_copy(iter, &minfo6, sizeof(minfo6));
 }
","void rds6_inc_info_copy(struct rds_incoming *inc,
			struct rds_info_iterator *iter,
			struct in6_addr *saddr, struct in6_addr *daddr,
			int flip)
{
	struct rds6_info_message minfo6;
 
 	minfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);
 	minfo6.len = be32_to_cpu(inc->i_hdr.h_len);
	minfo6.tos = inc->i_conn->c_tos;
 
 	if (flip) {
 		minfo6.laddr = *daddr;
		minfo6.faddr = *saddr;
		minfo6.lport = inc->i_hdr.h_dport;
		minfo6.fport = inc->i_hdr.h_sport;
	} else {
		minfo6.laddr = *saddr;
		minfo6.faddr = *daddr;
		minfo6.lport = inc->i_hdr.h_sport;
 		minfo6.fport = inc->i_hdr.h_dport;
 	}
 
	minfo6.flags = 0;

 	rds_info_copy(iter, &minfo6, sizeof(minfo6));
 }
","The `rds6_inc_info_copy` function is designed to populate an `rds6_info_message` structure with information from an incoming RDS (Reliable Datagram Sockets) message, specifically for IPv6 addresses. It takes parameters for the incoming message, an iterator for RDS information, source and destination IPv6 addresses, and a flag to determine whether to flip the addresses and ports. The function extracts the sequence number and length from the incoming message header, assigns the appropriate local and foreign addresses and ports based on the `flip` flag, and then copies this information into the iterator using the `rds_info_copy` function.","The provided code defines a function that processes incoming network messages by extracting relevant information and storing it in a structured format. It retrieves the sequence number and length from the message header and determines the appropriate local and foreign addresses and ports based on a specified condition. Depending on this condition, the function either retains or swaps the source and destination details. Finally, it copies the assembled information into a designated iterator for further use, ensuring that the data is organized and accessible for subsequent operations in the network communication process.","The vulnerability in the original code stemmed from the `rds6_info_message` structure leaking sensitive stack information through its `tos` and `flags` fields. Specifically, the `tos` field was not properly initialized, potentially exposing uninitialized data, while the `flags` field was left with residual values from the stack. The fixed code addresses this issue by explicitly assigning the `tos` field with the actual value from the connection structure and ensuring that the `flags` field is zeroed out before use. This prevents any unintended information leakage and enhances the security of the function.","The vulnerability in the original code was due to certain fields in a data structure leaking uninitialized stack information, which could potentially expose sensitive data. Specifically, one field was not assigned a proper value, leading to the risk of revealing residual data from previous operations, while another field retained arbitrary values from the stack. The fix involved ensuring that the problematic field was populated with valid information from the connection context, and another field was explicitly set to zero. This effectively mitigated the risk of information leakage and improved the overall security of the function.","The vulnerability was fixed by modifying the `rds6_inc_info_copy` function to properly initialize the `tos` field with the actual value from the connection structure, ensuring it no longer contained uninitialized data. Additionally, the `flags` field was explicitly set to zero, preventing it from retaining any arbitrary values from the stack. These changes ensure that both fields contain valid and expected information, thereby eliminating the risk of leaking sensitive stack data. This enhances the security of the function by ensuring that all fields are correctly populated before being used or copied.","The vulnerability was addressed by ensuring that specific fields in the data structure were properly initialized before use. One field was assigned a valid value from the connection context, replacing any uninitialized data that could lead to information leakage. Additionally, another field was explicitly set to zero, preventing it from containing any residual values from previous operations. These modifications ensured that all relevant fields contained only appropriate and expected information, effectively mitigating the risk of exposing sensitive data and enhancing the overall security of the function.","4,4","4,4","4,5","4,4"
91,91,182836,182836,,Remote,Not required,,CVE-2019-12209,https://www.cvedetails.com/cve/CVE-2019-12209/,CWE-200,Low,Partial,,,2019-06-04,5.0,"Yubico pam-u2f 1.0.7 attempts parsing of the configured authfile (default $HOME/.config/Yubico/u2f_keys) as root (unless openasuser was enabled), and does not properly verify that the path lacks symlinks pointing to other files on the system owned by root. If the debug option is enabled in the PAM configuration, part of the file contents of a symlink target will be logged, possibly revealing sensitive information.",2019-06-19,+Info ,21,https://github.com/Yubico/pam-u2f/commit/7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3,7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3,"Drop privileges by default when opening user-related files

The module is typically executed as root and would sometimes
open files or follow symlinks that could be controlled from the
outside.

Drop privileges to the target user before opening any files.

Fixes CVE-2019-12209.

Thanks to Matthias Gerstner of the SUSE Security Team for reporting
the issue.",9,pam-u2f.c,"{""sha"": ""d7619394fcf06748b612e980b50fcabea419d52e"", ""filename"": ""Makefile.am"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/Yubico/pam-u2f/blob/7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3/Makefile.am"", ""raw_url"": ""https://github.com/Yubico/pam-u2f/raw/7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/Yubico/pam-u2f/contents/Makefile.am?ref=7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3"", ""patch"": ""@@ -13,6 +13,7 @@ lib_LTLIBRARIES = pam_u2f.la\n \n pam_u2f_la_SOURCES = pam-u2f.c\n pam_u2f_la_SOURCES += util.c util.h\n+pam_u2f_la_SOURCES += drop_privs.h drop_privs.c\n \n pam_u2f_la_LIBADD = -lpam\n pam_u2f_la_LIBADD += $(LIBU2FHOST_LIBS) $(LIBU2FSERVER_LIBS)""}<_**next**_>{""sha"": ""04f95417101b5cabcb1b66e53cb12be42d265481"", ""filename"": ""README"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 0, ""changes"": 18, ""blob_url"": ""https://github.com/Yubico/pam-u2f/blob/7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3/README"", ""raw_url"": ""https://github.com/Yubico/pam-u2f/raw/7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3/README"", ""contents_url"": ""https://api.github.com/repos/Yubico/pam-u2f/contents/README?ref=7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3"", ""patch"": ""@@ -114,6 +114,8 @@ openasuser::\n Setuid to the authenticating user when opening the authfile. Useful when the\n user's home is stored on an NFS volume mounted with the root_squash option\n (which maps root to nobody which will not be able to read the file).\n+Note that after release 1.0.8 this is done by default when no global\n+authfile or XDG_CONFIG_HOME environment variable has been set.\n \n alwaysok::\n Set to enable all authentication attempts to succeed (aka presentation mode).\n@@ -164,6 +166,11 @@ mappings will not be used and the opposite applies if user home directory\n mappings are being used, the central authorization mappings file will not\n be used.\n \n+By default the mapping file inside a home directory will be opened as\n+the target user, whereas the central file will be opened as `root`. If\n+the `XDG_CONFIG_HOME` variable is set, privileges will not be dropped\n+unless the `openasuser` configuration setting is set.\n+\n IMPORTANT: Using pam-u2f to secure the login to a computer while\n storing the mapping file in an encrypted home directory, will result\n in the impossibility of logging into the system. The partition is\n@@ -184,6 +191,10 @@ looks like:\n \n  auth sufficient pam_u2f.so authfile=/etc/u2f_mappings\n \n+If you do not set the `openasuser` setting, the authfile will be opened\n+and parsed as `root` so make sure it has the correct owner and\n+permissions set.\n+\n IMPORTANT: On dynamics networks (e.g. where hostnames are set by DHCP),\n users should not rely on the default origin and appid (\""pam://$HOSTNAME\"")\n but set those parameters explicitly to the same value.\n@@ -197,6 +208,13 @@ line:\n \n This is much the same concept as the SSH authorized_keys file.\n \n+In this case, pam-u2f will drop privileges and read the mapping file\n+as that user. This happens regardless of the `openasuser` option being\n+set.\n+\n+Note that if you set the XDG_CONFIG_HOME variable, privileges will not\n+be dropped by default. Consider also setting `openasuser` in that case.\n+\n [[registration]]\n Obtaining key-handles and public keys\n -------------------------------------""}<_**next**_>{""sha"": ""1ec2566732313f8427bd99b0dbcf14a49fd7c38f"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/Yubico/pam-u2f/blob/7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3/configure.ac"", ""raw_url"": ""https://github.com/Yubico/pam-u2f/raw/7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3/configure.ac"", ""contents_url"": ""https://api.github.com/repos/Yubico/pam-u2f/contents/configure.ac?ref=7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3"", ""patch"": ""@@ -37,6 +37,8 @@ AC_CHECK_HEADERS([security/pam_modules.h security/_pam_macros.h security/pam_mod\n    #include <security/pam_appl.h>])\n AC_CHECK_LIB([pam], [pam_start])\n \n+AC_SEARCH_LIBS([pam_modutil_drop_priv], [\""pam\""], [AC_DEFINE([HAVE_PAM_MODUTIL_DROP_PRIV], [1])])\n+\n case \""$host\"" in\n      *darwin*)  PAMDIR=\""/usr/lib/pam\"";;\n      *linux*)   PAMDIR=\""/lib/x86_64-linux-gnu/security\"";;\n@@ -71,6 +73,8 @@ AC_ARG_VAR([CWFLAGS], [Warning flags])\n AX_CHECK_COMPILE_FLAG([-Wall], [CWFLAGS=\""-Wall\""])\n AX_CHECK_COMPILE_FLAG([-Wextra], [CWFLAGS=\""$CWFLAGS -Wextra\""])\n AX_CHECK_COMPILE_FLAG([-Wconversion], [CWFLAGS=\""$CWFLAGS -Wconversion\""])\n+# Because pam headers are doing sign-conversion, see PAM_MODUTIL_DEF_PRIVS in pam_modutil.h\n+AX_CHECK_COMPILE_FLAG([-Wconversion], [CWFLAGS=\""$CWFLAGS -Wno-sign-conversion\""])\n AX_CHECK_COMPILE_FLAG([-Wpedantic], [CWFLAGS=\""$CWFLAGS -Wpedantic\""])\n AX_CHECK_COMPILE_FLAG([-Wformat=2], [CWFLAGS=\""$CWFLAGS -Wformat=2\""])\n AX_CHECK_COMPILE_FLAG([-Wstrict-prototypes], [CWFLAGS=\""$CWFLAGS -Wstrict-prototypes\""])""}<_**next**_>{""sha"": ""7fe35c5172db7426d7ebad4ea1711242e566c15c"", ""filename"": ""drop_privs.c"", ""status"": ""added"", ""additions"": 129, ""deletions"": 0, ""changes"": 129, ""blob_url"": ""https://github.com/Yubico/pam-u2f/blob/7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3/drop_privs.c"", ""raw_url"": ""https://github.com/Yubico/pam-u2f/raw/7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3/drop_privs.c"", ""contents_url"": ""https://api.github.com/repos/Yubico/pam-u2f/contents/drop_privs.c?ref=7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3"", ""patch"": ""@@ -0,0 +1,129 @@\n+/* Written by Ricky Zhou <ricky@fedoraproject.org>\n+ * Fredrik Thulin <fredrik@yubico.com> implemented pam_modutil_drop_priv\n+ *\n+ * Copyright (c) 2011-2014 Yubico AB\n+ * Copyright (c) 2011 Ricky Zhou <ricky@fedoraproject.org>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are\n+ * met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.\n+ *\n+ *     * Redistributions in binary form must reproduce the above\n+ *       copyright notice, this list of conditions and the following\n+ *       disclaimer in the documentation and/or other materials provided\n+ *       with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \""AS IS\"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#ifndef HAVE_PAM_MODUTIL_DROP_PRIV\n+\n+#include <unistd.h>\n+#include <pwd.h>\n+#include <grp.h>\n+#include <errno.h>\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#include \""drop_privs.h\""\n+#include \""util.h\""\n+\n+#ifdef HAVE_SECURITY_PAM_APPL_H\n+#include <security/pam_appl.h>\n+#endif\n+#ifdef HAVE_SECURITY_PAM_MODULES_H\n+#include <security/pam_modules.h>\n+#endif\n+\n+\n+int pam_modutil_drop_priv(pam_handle_t *pamh, struct _ykpam_privs *privs, struct passwd *pw) {\n+    privs->saved_euid = geteuid();\n+    privs->saved_egid = getegid();\n+\n+    if ((privs->saved_euid == pw->pw_uid) && (privs->saved_egid == pw->pw_gid)) {\n+        D (privs->debug_file, \""Privilges already dropped, pretend it is all right\"");\n+        return 0;\n+    }\n+\n+    privs->saved_groups_length = getgroups(0, NULL);\n+    if (privs->saved_groups_length < 0) {\n+        D (privs->debug_file, \""getgroups: %s\"", strerror(errno));\n+        return -1;\n+    }\n+\n+    if (privs->saved_groups_length > SAVED_GROUPS_MAX_LEN) {\n+        D (privs->debug_file, \""too many groups, limiting.\"");\n+        privs->saved_groups_length = SAVED_GROUPS_MAX_LEN;\n+    }\n+\n+    if (privs->saved_groups_length > 0) {\n+        if (getgroups(privs->saved_groups_length, privs->saved_groups) < 0) {\n+            D (privs->debug_file, \""getgroups: %s\"", strerror(errno));\n+            goto free_out;\n+        }\n+    }\n+\n+    if (initgroups(pw->pw_name, pw->pw_gid) < 0) {\n+        D (privs->debug_file, \""initgroups: %s\"", strerror(errno));\n+        goto free_out;\n+    }\n+\n+    if (setegid(pw->pw_gid) < 0) {\n+        D (privs->debug_file, \""setegid: %s\"", strerror(errno));\n+        goto free_out;\n+    }\n+\n+    if (seteuid(pw->pw_uid) < 0) {\n+        D (privs->debug_file, \""seteuid: %s\"", strerror(errno));\n+        goto free_out;\n+    }\n+\n+    return 0;\n+free_out:\n+    return -1;\n+}\n+\n+int pam_modutil_regain_priv(pam_handle_t *pamh, struct _ykpam_privs *privs) {\n+    if ((privs->saved_euid == geteuid()) && (privs->saved_egid == getegid())) {\n+        D (privs->debug_file, \""Privilges already as requested, pretend it is all right\"");\n+        return 0;\n+    }\n+\n+    if (seteuid(privs->saved_euid) < 0) {\n+        D (privs->debug_file, \""seteuid: %s\"", strerror(errno));\n+        return -1;\n+    }\n+\n+    if (setegid(privs->saved_egid) < 0) {\n+        D (privs->debug_file, \""setegid: %s\"", strerror(errno));\n+        return -1;\n+    }\n+\n+    if (setgroups(privs->saved_groups_length, privs->saved_groups) < 0) {\n+        D (privs->debug_file, \""setgroups: %s\"", strerror(errno));\n+        return -1;\n+    }\n+\n+    return 0;\n+}\n+\n+#else\n+\n+// drop_privs.c:124: warning: ISO C forbids an empty translation unit [-Wpedantic]\n+typedef int make_iso_compilers_happy;\n+\n+#endif // HAVE_PAM_MODUTIL_DROP_PRIV""}<_**next**_>{""sha"": ""2d25a19196ba02554f4607d66bf85eefb9aef2b0"", ""filename"": ""drop_privs.h"", ""status"": ""added"", ""additions"": 64, ""deletions"": 0, ""changes"": 64, ""blob_url"": ""https://github.com/Yubico/pam-u2f/blob/7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3/drop_privs.h"", ""raw_url"": ""https://github.com/Yubico/pam-u2f/raw/7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3/drop_privs.h"", ""contents_url"": ""https://api.github.com/repos/Yubico/pam-u2f/contents/drop_privs.h?ref=7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3"", ""patch"": ""@@ -0,0 +1,64 @@\n+/* Copyright (c) 2011-2014 Yubico AB\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are\n+ * met:\n+ *\n+ *     * Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.\n+ *\n+ *     * Redistributions in binary form must reproduce the above\n+ *       copyright notice, this list of conditions and the following\n+ *       disclaimer in the documentation and/or other materials provided\n+ *       with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+ * \""AS IS\"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#ifndef __PAM_U2F_DROP_PRIVS_H_INCLUDED__\n+#define __PAM_U2F_DROP_PRIVS_H_INCLUDED__\n+\n+#ifdef HAVE_PAM_MODUTIL_DROP_PRIV\n+#include <security/pam_modutil.h>\n+#else\n+\n+#include <pwd.h>\n+#include <stdio.h>\n+\n+#ifdef HAVE_SECURITY_PAM_APPL_H\n+#include <security/pam_appl.h>\n+#endif\n+#ifdef HAVE_SECURITY_PAM_MODULES_H\n+#include <security/pam_modules.h>\n+#endif\n+\n+#define SAVED_GROUPS_MAX_LEN 64 /* as pam_modutil.. */\n+\n+struct _ykpam_privs {\n+  uid_t saved_euid;\n+  gid_t saved_egid;\n+  gid_t *saved_groups;\n+  int saved_groups_length;\n+  FILE *debug_file;\n+};\n+\n+#define PAM_MODUTIL_DEF_PRIVS(n) \\\n+  gid_t n##_saved_groups[SAVED_GROUPS_MAX_LEN]; \\\n+  struct _ykpam_privs n = {-1, -1, n##_saved_groups, SAVED_GROUPS_MAX_LEN, cfg->debug_file}\n+\n+int pam_modutil_drop_priv(pam_handle_t *, struct _ykpam_privs *, struct passwd *);\n+int pam_modutil_regain_priv(pam_handle_t *, struct _ykpam_privs *);\n+\n+#endif\n+#endif""}<_**next**_>{""sha"": ""b01697c202474a8462afbdf59ea3ccbc9d513154"", ""filename"": ""pam-u2f.c"", ""status"": ""modified"", ""additions"": 22, ""deletions"": 9, ""changes"": 31, ""blob_url"": ""https://github.com/Yubico/pam-u2f/blob/7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3/pam-u2f.c"", ""raw_url"": ""https://github.com/Yubico/pam-u2f/raw/7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3/pam-u2f.c"", ""contents_url"": ""https://api.github.com/repos/Yubico/pam-u2f/contents/pam-u2f.c?ref=7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3"", ""patch"": ""@@ -20,6 +20,7 @@\n #include <errno.h>\n \n #include \""util.h\""\n+#include \""drop_privs.h\""\n \n /* If secure_getenv is not defined, define it here */\n #ifndef HAVE_SECURE_GETENV\n@@ -148,11 +149,12 @@ int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,\n   int retval = PAM_IGNORE;\n   device_t *devices = NULL;\n   unsigned n_devices = 0;\n-  int openasuser;\n+  int openasuser = 0;\n   int should_free_origin = 0;\n   int should_free_appid = 0;\n   int should_free_auth_file = 0;\n   int should_free_authpending_file = 0;\n+  PAM_MODUTIL_DEF_PRIVS(privs);\n \n   parse_cfg(flags, argc, argv, cfg);\n \n@@ -235,6 +237,9 @@ int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,\n         goto done;\n       }\n \n+      /* Opening a file in a users $HOME, need to drop privs for security */\n+      openasuser = geteuid() == 0 ? 1 : 0;\n+\n       snprintf(buf, authfile_dir_len,\n                \""%s/.config%s\"", pw->pw_dir, DEFAULT_AUTHFILE);\n     } else {\n@@ -250,9 +255,14 @@ int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,\n \n       snprintf(buf, authfile_dir_len,\n                \""%s%s\"", authfile_dir, DEFAULT_AUTHFILE);\n+\n+      if (!openasuser) {\n+\tDBG(\""WARNING: not dropping privileges when reading %s, please \""\n+\t    \""consider setting openasuser=1 in the module configuration\"", buf);\n+      }\n     }\n \n-    DBG(\""Using default authentication file %s\"", buf);\n+    DBG(\""Using authentication file %s\"", buf);\n \n     cfg->auth_file = buf; /* cfg takes ownership */\n     should_free_auth_file = 1;\n@@ -261,25 +271,28 @@ int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,\n     DBG(\""Using authentication file %s\"", cfg->auth_file);\n   }\n \n-  openasuser = geteuid() == 0 && cfg->openasuser;\n+  if (!openasuser) {\n+    openasuser = geteuid() == 0 && cfg->openasuser;\n+  }\n   if (openasuser) {\n-    if (seteuid(pw_s.pw_uid)) {\n-      DBG(\""Unable to switch user to uid %i\"", pw_s.pw_uid);\n+    DBG(\""Dropping privileges\"");\n+    if (pam_modutil_drop_priv(pamh, &privs, pw)) {\n+      DBG(\""Unable to switch user to uid %i\"", pw->pw_uid);\n       retval = PAM_IGNORE;\n       goto done;\n     }\n-    DBG(\""Switched to uid %i\"", pw_s.pw_uid);\n+    DBG(\""Switched to uid %i\"", pw->pw_uid);\n   }\n   retval = get_devices_from_authfile(cfg->auth_file, user, cfg->max_devs,\n                                      cfg->debug, cfg->debug_file,\n                                      devices, &n_devices);\n   if (openasuser) {\n-    if (seteuid(0)) {\n-      DBG(\""Unable to switch back to uid 0\"");\n+    if (pam_modutil_regain_priv(pamh, &privs)) {\n+      DBG(\""could not restore privileges\"");\n       retval = PAM_IGNORE;\n       goto done;\n     }\n-    DBG(\""Switched back to uid 0\"");\n+    DBG(\""Restored privileges\"");\n   }\n \n   if (retval != 1) {""}","int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,
                        const char **argv) {

  struct passwd *pw = NULL, pw_s;
  const char *user = NULL;

  cfg_t cfg_st;
  cfg_t *cfg = &cfg_st;
  char buffer[BUFSIZE];
  char *buf = NULL;
  char *authfile_dir;
  size_t authfile_dir_len;
  int pgu_ret, gpn_ret;
   int retval = PAM_IGNORE;
   device_t *devices = NULL;
   unsigned n_devices = 0;
  int openasuser = 0;
   int should_free_origin = 0;
   int should_free_appid = 0;
   int should_free_auth_file = 0;
   int should_free_authpending_file = 0;
  PAM_MODUTIL_DEF_PRIVS(privs);
 
   parse_cfg(flags, argc, argv, cfg);
 
  if (!cfg->origin) {
    strcpy(buffer, DEFAULT_ORIGIN_PREFIX);

    if (gethostname(buffer + strlen(DEFAULT_ORIGIN_PREFIX),
                    BUFSIZE - strlen(DEFAULT_ORIGIN_PREFIX)) == -1) {
      DBG(""Unable to get host name"");
      goto done;
    }
    DBG(""Origin not specified, using \""%s\"""", buffer);
    cfg->origin = strdup(buffer);
    if (!cfg->origin) {
      DBG(""Unable to allocate memory"");
      goto done;
    } else {
      should_free_origin = 1;
    }
  }

  if (!cfg->appid) {
    DBG(""Appid not specified, using the same value of origin (%s)"",
         cfg->origin);
    cfg->appid = strdup(cfg->origin);
    if (!cfg->appid) {
      DBG(""Unable to allocate memory"")
      goto done;
    } else {
      should_free_appid = 1;
    }
  }

  if (cfg->max_devs == 0) {
    DBG(""Maximum devices number not set. Using default (%d)"", MAX_DEVS);
    cfg->max_devs = MAX_DEVS;
  }

  devices = malloc(sizeof(device_t) * cfg->max_devs);
  if (!devices) {
    DBG(""Unable to allocate memory"");
    retval = PAM_IGNORE;
    goto done;
  }

  pgu_ret = pam_get_user(pamh, &user, NULL);
  if (pgu_ret != PAM_SUCCESS || user == NULL) {
    DBG(""Unable to access user %s"", user);
    retval = PAM_CONV_ERR;
    goto done;
  }

  DBG(""Requesting authentication for user %s"", user);

  gpn_ret = getpwnam_r(user, &pw_s, buffer, sizeof(buffer), &pw);
  if (gpn_ret != 0 || pw == NULL || pw->pw_dir == NULL ||
      pw->pw_dir[0] != '/') {
    DBG(""Unable to retrieve credentials for user %s, (%s)"", user,
         strerror(errno));
    retval = PAM_USER_UNKNOWN;
    goto done;
  }

  DBG(""Found user %s"", user);
  DBG(""Home directory for %s is %s"", user, pw->pw_dir);

  if (!cfg->auth_file) {
    buf = NULL;
    authfile_dir = secure_getenv(DEFAULT_AUTHFILE_DIR_VAR);
    if (!authfile_dir) {
      DBG(""Variable %s is not set. Using default value ($HOME/.config/)"",
           DEFAULT_AUTHFILE_DIR_VAR);
      authfile_dir_len =
        strlen(pw->pw_dir) + strlen(""/.config"") + strlen(DEFAULT_AUTHFILE) + 1;
      buf = malloc(sizeof(char) * (authfile_dir_len));

      if (!buf) {
        DBG(""Unable to allocate memory"");
        retval = PAM_IGNORE;
         goto done;
       }
 
      /* Opening a file in a users $HOME, need to drop privs for security */
      openasuser = geteuid() == 0 ? 1 : 0;

       snprintf(buf, authfile_dir_len,
                ""%s/.config%s"", pw->pw_dir, DEFAULT_AUTHFILE);
     } else {
      DBG(""Variable %s set to %s"", DEFAULT_AUTHFILE_DIR_VAR, authfile_dir);
      authfile_dir_len = strlen(authfile_dir) + strlen(DEFAULT_AUTHFILE) + 1;
      buf = malloc(sizeof(char) * (authfile_dir_len));

      if (!buf) {
        DBG(""Unable to allocate memory"");
        retval = PAM_IGNORE;
        goto done;
      }
 
       snprintf(buf, authfile_dir_len,
                ""%s%s"", authfile_dir, DEFAULT_AUTHFILE);

      if (!openasuser) {
	DBG(""WARNING: not dropping privileges when reading %s, please ""
	    ""consider setting openasuser=1 in the module configuration"", buf);
      }
     }
 
    DBG(""Using authentication file %s"", buf);
 
     cfg->auth_file = buf; /* cfg takes ownership */
     should_free_auth_file = 1;
    buf = NULL;
  } else {
     DBG(""Using authentication file %s"", cfg->auth_file);
   }
 
  if (!openasuser) {
    openasuser = geteuid() == 0 && cfg->openasuser;
  }
   if (openasuser) {
    DBG(""Dropping privileges"");
    if (pam_modutil_drop_priv(pamh, &privs, pw)) {
      DBG(""Unable to switch user to uid %i"", pw->pw_uid);
       retval = PAM_IGNORE;
       goto done;
     }
    DBG(""Switched to uid %i"", pw->pw_uid);
   }
   retval = get_devices_from_authfile(cfg->auth_file, user, cfg->max_devs,
                                      cfg->debug, cfg->debug_file,
                                      devices, &n_devices);
   if (openasuser) {
    if (pam_modutil_regain_priv(pamh, &privs)) {
      DBG(""could not restore privileges"");
       retval = PAM_IGNORE;
       goto done;
     }
    DBG(""Restored privileges"");
   }
 
   if (retval != 1) {
    n_devices = 0;
  }

  if (n_devices == 0) {
    if (cfg->nouserok) {
      DBG(""Found no devices but nouserok specified. Skipping authentication"");
      retval = PAM_SUCCESS;
      goto done;
    } else if (retval != 1) {
      DBG(""Unable to get devices from file %s"", cfg->auth_file);
      retval = PAM_AUTHINFO_UNAVAIL;
      goto done;
    } else {
      DBG(""Found no devices. Aborting."");
      retval = PAM_AUTHINFO_UNAVAIL;
      goto done;
    }
  }

  if (!cfg->authpending_file) {
    int actual_size = snprintf(buffer, BUFSIZE, DEFAULT_AUTHPENDING_FILE_PATH, getuid());
    if (actual_size >= 0 && actual_size < BUFSIZE) {
      cfg->authpending_file = strdup(buffer);
    }
    if (!cfg->authpending_file) {
      DBG(""Unable to allocate memory for the authpending_file, touch request notifications will not be emitted"");
    } else {
      should_free_authpending_file = 1;
    }
  } else {
    if (strlen(cfg->authpending_file) == 0) {
      DBG(""authpending_file is set to an empty value, touch request notifications will be disabled"");
      cfg->authpending_file = NULL;
    }
  }

  int authpending_file_descriptor = -1;
  if (cfg->authpending_file) {
    DBG(""Using file '%s' for emitting touch request notifications"", cfg->authpending_file);

    authpending_file_descriptor =
      open(cfg->authpending_file, O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY, 0664);
    if (authpending_file_descriptor < 0) {
      DBG(""Unable to emit 'authentication started' notification by opening the file '%s', (%s)"",
          cfg->authpending_file, strerror(errno));
    }
  }

  if (cfg->manual == 0) {
    if (cfg->interactive) {
      converse(pamh, PAM_PROMPT_ECHO_ON,
               cfg->prompt != NULL ? cfg->prompt : DEFAULT_PROMPT);
    }

    retval = do_authentication(cfg, devices, n_devices, pamh);
  } else {
    retval = do_manual_authentication(cfg, devices, n_devices, pamh);
  }

  if (authpending_file_descriptor >= 0) {
    if (close(authpending_file_descriptor) < 0) {
      DBG(""Unable to emit 'authentication stopped' notification by closing the file '%s', (%s)"",
          cfg->authpending_file, strerror(errno));
    }
  }

  if (retval != 1) {
    DBG(""do_authentication returned %d"", retval);
    retval = PAM_AUTH_ERR;
    goto done;
  }

  retval = PAM_SUCCESS;

done:
  free_devices(devices, n_devices);

  if (buf) {
    free(buf);
    buf = NULL;
  }

  if (should_free_origin) {
    free((char *) cfg->origin);
    cfg->origin = NULL;
  }

  if (should_free_appid) {
    free((char *) cfg->appid);
    cfg->appid = NULL;
  }

  if (should_free_auth_file) {
    free((char *) cfg->auth_file);
    cfg->auth_file = NULL;
  }

  if (should_free_authpending_file) {
    free((char *) cfg->authpending_file);
    cfg->authpending_file = NULL;
  }

  if (cfg->alwaysok && retval != PAM_SUCCESS) {
    DBG(""alwaysok needed (otherwise return with %d)"", retval);
    retval = PAM_SUCCESS;
  }
  DBG(""done. [%s]"", pam_strerror(pamh, retval));

  if (cfg->is_custom_debug_file) {
    fclose(cfg->debug_file);
  }

  return retval;
}
","int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,
                        const char **argv) {

  struct passwd *pw = NULL, pw_s;
  const char *user = NULL;

  cfg_t cfg_st;
  cfg_t *cfg = &cfg_st;
  char buffer[BUFSIZE];
  char *buf = NULL;
  char *authfile_dir;
  size_t authfile_dir_len;
  int pgu_ret, gpn_ret;
   int retval = PAM_IGNORE;
   device_t *devices = NULL;
   unsigned n_devices = 0;
  int openasuser;
   int should_free_origin = 0;
   int should_free_appid = 0;
   int should_free_auth_file = 0;
   int should_free_authpending_file = 0;
 
   parse_cfg(flags, argc, argv, cfg);
 
  if (!cfg->origin) {
    strcpy(buffer, DEFAULT_ORIGIN_PREFIX);

    if (gethostname(buffer + strlen(DEFAULT_ORIGIN_PREFIX),
                    BUFSIZE - strlen(DEFAULT_ORIGIN_PREFIX)) == -1) {
      DBG(""Unable to get host name"");
      goto done;
    }
    DBG(""Origin not specified, using \""%s\"""", buffer);
    cfg->origin = strdup(buffer);
    if (!cfg->origin) {
      DBG(""Unable to allocate memory"");
      goto done;
    } else {
      should_free_origin = 1;
    }
  }

  if (!cfg->appid) {
    DBG(""Appid not specified, using the same value of origin (%s)"",
         cfg->origin);
    cfg->appid = strdup(cfg->origin);
    if (!cfg->appid) {
      DBG(""Unable to allocate memory"")
      goto done;
    } else {
      should_free_appid = 1;
    }
  }

  if (cfg->max_devs == 0) {
    DBG(""Maximum devices number not set. Using default (%d)"", MAX_DEVS);
    cfg->max_devs = MAX_DEVS;
  }

  devices = malloc(sizeof(device_t) * cfg->max_devs);
  if (!devices) {
    DBG(""Unable to allocate memory"");
    retval = PAM_IGNORE;
    goto done;
  }

  pgu_ret = pam_get_user(pamh, &user, NULL);
  if (pgu_ret != PAM_SUCCESS || user == NULL) {
    DBG(""Unable to access user %s"", user);
    retval = PAM_CONV_ERR;
    goto done;
  }

  DBG(""Requesting authentication for user %s"", user);

  gpn_ret = getpwnam_r(user, &pw_s, buffer, sizeof(buffer), &pw);
  if (gpn_ret != 0 || pw == NULL || pw->pw_dir == NULL ||
      pw->pw_dir[0] != '/') {
    DBG(""Unable to retrieve credentials for user %s, (%s)"", user,
         strerror(errno));
    retval = PAM_USER_UNKNOWN;
    goto done;
  }

  DBG(""Found user %s"", user);
  DBG(""Home directory for %s is %s"", user, pw->pw_dir);

  if (!cfg->auth_file) {
    buf = NULL;
    authfile_dir = secure_getenv(DEFAULT_AUTHFILE_DIR_VAR);
    if (!authfile_dir) {
      DBG(""Variable %s is not set. Using default value ($HOME/.config/)"",
           DEFAULT_AUTHFILE_DIR_VAR);
      authfile_dir_len =
        strlen(pw->pw_dir) + strlen(""/.config"") + strlen(DEFAULT_AUTHFILE) + 1;
      buf = malloc(sizeof(char) * (authfile_dir_len));

      if (!buf) {
        DBG(""Unable to allocate memory"");
        retval = PAM_IGNORE;
         goto done;
       }
 
       snprintf(buf, authfile_dir_len,
                ""%s/.config%s"", pw->pw_dir, DEFAULT_AUTHFILE);
     } else {
      DBG(""Variable %s set to %s"", DEFAULT_AUTHFILE_DIR_VAR, authfile_dir);
      authfile_dir_len = strlen(authfile_dir) + strlen(DEFAULT_AUTHFILE) + 1;
      buf = malloc(sizeof(char) * (authfile_dir_len));

      if (!buf) {
        DBG(""Unable to allocate memory"");
        retval = PAM_IGNORE;
        goto done;
      }
 
       snprintf(buf, authfile_dir_len,
                ""%s%s"", authfile_dir, DEFAULT_AUTHFILE);
     }
 
    DBG(""Using default authentication file %s"", buf);
 
     cfg->auth_file = buf; /* cfg takes ownership */
     should_free_auth_file = 1;
    buf = NULL;
  } else {
     DBG(""Using authentication file %s"", cfg->auth_file);
   }
 
  openasuser = geteuid() == 0 && cfg->openasuser;
   if (openasuser) {
    if (seteuid(pw_s.pw_uid)) {
      DBG(""Unable to switch user to uid %i"", pw_s.pw_uid);
       retval = PAM_IGNORE;
       goto done;
     }
    DBG(""Switched to uid %i"", pw_s.pw_uid);
   }
   retval = get_devices_from_authfile(cfg->auth_file, user, cfg->max_devs,
                                      cfg->debug, cfg->debug_file,
                                      devices, &n_devices);
   if (openasuser) {
    if (seteuid(0)) {
      DBG(""Unable to switch back to uid 0"");
       retval = PAM_IGNORE;
       goto done;
     }
    DBG(""Switched back to uid 0"");
   }
 
   if (retval != 1) {
    n_devices = 0;
  }

  if (n_devices == 0) {
    if (cfg->nouserok) {
      DBG(""Found no devices but nouserok specified. Skipping authentication"");
      retval = PAM_SUCCESS;
      goto done;
    } else if (retval != 1) {
      DBG(""Unable to get devices from file %s"", cfg->auth_file);
      retval = PAM_AUTHINFO_UNAVAIL;
      goto done;
    } else {
      DBG(""Found no devices. Aborting."");
      retval = PAM_AUTHINFO_UNAVAIL;
      goto done;
    }
  }

  if (!cfg->authpending_file) {
    int actual_size = snprintf(buffer, BUFSIZE, DEFAULT_AUTHPENDING_FILE_PATH, getuid());
    if (actual_size >= 0 && actual_size < BUFSIZE) {
      cfg->authpending_file = strdup(buffer);
    }
    if (!cfg->authpending_file) {
      DBG(""Unable to allocate memory for the authpending_file, touch request notifications will not be emitted"");
    } else {
      should_free_authpending_file = 1;
    }
  } else {
    if (strlen(cfg->authpending_file) == 0) {
      DBG(""authpending_file is set to an empty value, touch request notifications will be disabled"");
      cfg->authpending_file = NULL;
    }
  }

  int authpending_file_descriptor = -1;
  if (cfg->authpending_file) {
    DBG(""Using file '%s' for emitting touch request notifications"", cfg->authpending_file);

    authpending_file_descriptor =
      open(cfg->authpending_file, O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY, 0664);
    if (authpending_file_descriptor < 0) {
      DBG(""Unable to emit 'authentication started' notification by opening the file '%s', (%s)"",
          cfg->authpending_file, strerror(errno));
    }
  }

  if (cfg->manual == 0) {
    if (cfg->interactive) {
      converse(pamh, PAM_PROMPT_ECHO_ON,
               cfg->prompt != NULL ? cfg->prompt : DEFAULT_PROMPT);
    }

    retval = do_authentication(cfg, devices, n_devices, pamh);
  } else {
    retval = do_manual_authentication(cfg, devices, n_devices, pamh);
  }

  if (authpending_file_descriptor >= 0) {
    if (close(authpending_file_descriptor) < 0) {
      DBG(""Unable to emit 'authentication stopped' notification by closing the file '%s', (%s)"",
          cfg->authpending_file, strerror(errno));
    }
  }

  if (retval != 1) {
    DBG(""do_authentication returned %d"", retval);
    retval = PAM_AUTH_ERR;
    goto done;
  }

  retval = PAM_SUCCESS;

done:
  free_devices(devices, n_devices);

  if (buf) {
    free(buf);
    buf = NULL;
  }

  if (should_free_origin) {
    free((char *) cfg->origin);
    cfg->origin = NULL;
  }

  if (should_free_appid) {
    free((char *) cfg->appid);
    cfg->appid = NULL;
  }

  if (should_free_auth_file) {
    free((char *) cfg->auth_file);
    cfg->auth_file = NULL;
  }

  if (should_free_authpending_file) {
    free((char *) cfg->authpending_file);
    cfg->authpending_file = NULL;
  }

  if (cfg->alwaysok && retval != PAM_SUCCESS) {
    DBG(""alwaysok needed (otherwise return with %d)"", retval);
    retval = PAM_SUCCESS;
  }
  DBG(""done. [%s]"", pam_strerror(pamh, retval));

  if (cfg->is_custom_debug_file) {
    fclose(cfg->debug_file);
  }

  return retval;
}
",C,"  int openasuser = 0;
  PAM_MODUTIL_DEF_PRIVS(privs);
      /* Opening a file in a users $HOME, need to drop privs for security */
      openasuser = geteuid() == 0 ? 1 : 0;


      if (!openasuser) {
	DBG(""WARNING: not dropping privileges when reading %s, please ""
	    ""consider setting openasuser=1 in the module configuration"", buf);
      }
    DBG(""Using authentication file %s"", buf);
  if (!openasuser) {
    openasuser = geteuid() == 0 && cfg->openasuser;
  }
    DBG(""Dropping privileges"");
    if (pam_modutil_drop_priv(pamh, &privs, pw)) {
      DBG(""Unable to switch user to uid %i"", pw->pw_uid);
    DBG(""Switched to uid %i"", pw->pw_uid);
    if (pam_modutil_regain_priv(pamh, &privs)) {
      DBG(""could not restore privileges"");
    DBG(""Restored privileges"");
","  int openasuser;
    DBG(""Using default authentication file %s"", buf);
  openasuser = geteuid() == 0 && cfg->openasuser;
    if (seteuid(pw_s.pw_uid)) {
      DBG(""Unable to switch user to uid %i"", pw_s.pw_uid);
    DBG(""Switched to uid %i"", pw_s.pw_uid);
    if (seteuid(0)) {
      DBG(""Unable to switch back to uid 0"");
    DBG(""Switched back to uid 0"");
",,"@@ -20,6 +20,7 @@
 #include <errno.h>
 
 #include ""util.h""
+#include ""drop_privs.h""
 
 /* If secure_getenv is not defined, define it here */
 #ifndef HAVE_SECURE_GETENV
@@ -148,11 +149,12 @@ int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,
   int retval = PAM_IGNORE;
   device_t *devices = NULL;
   unsigned n_devices = 0;
-  int openasuser;
+  int openasuser = 0;
   int should_free_origin = 0;
   int should_free_appid = 0;
   int should_free_auth_file = 0;
   int should_free_authpending_file = 0;
+  PAM_MODUTIL_DEF_PRIVS(privs);
 
   parse_cfg(flags, argc, argv, cfg);
 
@@ -235,6 +237,9 @@ int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,
         goto done;
       }
 
+      /* Opening a file in a users $HOME, need to drop privs for security */
+      openasuser = geteuid() == 0 ? 1 : 0;
+
       snprintf(buf, authfile_dir_len,
                ""%s/.config%s"", pw->pw_dir, DEFAULT_AUTHFILE);
     } else {
@@ -250,9 +255,14 @@ int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,
 
       snprintf(buf, authfile_dir_len,
                ""%s%s"", authfile_dir, DEFAULT_AUTHFILE);
+
+      if (!openasuser) {
+	DBG(""WARNING: not dropping privileges when reading %s, please ""
+	    ""consider setting openasuser=1 in the module configuration"", buf);
+      }
     }
 
-    DBG(""Using default authentication file %s"", buf);
+    DBG(""Using authentication file %s"", buf);
 
     cfg->auth_file = buf; /* cfg takes ownership */
     should_free_auth_file = 1;
@@ -261,25 +271,28 @@ int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,
     DBG(""Using authentication file %s"", cfg->auth_file);
   }
 
-  openasuser = geteuid() == 0 && cfg->openasuser;
+  if (!openasuser) {
+    openasuser = geteuid() == 0 && cfg->openasuser;
+  }
   if (openasuser) {
-    if (seteuid(pw_s.pw_uid)) {
-      DBG(""Unable to switch user to uid %i"", pw_s.pw_uid);
+    DBG(""Dropping privileges"");
+    if (pam_modutil_drop_priv(pamh, &privs, pw)) {
+      DBG(""Unable to switch user to uid %i"", pw->pw_uid);
       retval = PAM_IGNORE;
       goto done;
     }
-    DBG(""Switched to uid %i"", pw_s.pw_uid);
+    DBG(""Switched to uid %i"", pw->pw_uid);
   }
   retval = get_devices_from_authfile(cfg->auth_file, user, cfg->max_devs,
                                      cfg->debug, cfg->debug_file,
                                      devices, &n_devices);
   if (openasuser) {
-    if (seteuid(0)) {
-      DBG(""Unable to switch back to uid 0"");
+    if (pam_modutil_regain_priv(pamh, &privs)) {
+      DBG(""could not restore privileges"");
       retval = PAM_IGNORE;
       goto done;
     }
-    DBG(""Switched back to uid 0"");
+    DBG(""Restored privileges"");
   }
 
   if (retval != 1) {",pam-u2f,7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3,18b1914e32b74ff52000f10e97067e841e5fff62,1,"int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,
                        const char **argv) {

  struct passwd *pw = NULL, pw_s;
  const char *user = NULL;

  cfg_t cfg_st;
  cfg_t *cfg = &cfg_st;
  char buffer[BUFSIZE];
  char *buf = NULL;
  char *authfile_dir;
  size_t authfile_dir_len;
  int pgu_ret, gpn_ret;
   int retval = PAM_IGNORE;
   device_t *devices = NULL;
   unsigned n_devices = 0;
//flaw_line_below:
  int openasuser;
//fix_flaw_line_below:
//  int openasuser = 0;
   int should_free_origin = 0;
   int should_free_appid = 0;
   int should_free_auth_file = 0;
   int should_free_authpending_file = 0;
//fix_flaw_line_below:
//  PAM_MODUTIL_DEF_PRIVS(privs);
 
   parse_cfg(flags, argc, argv, cfg);
 
  if (!cfg->origin) {
    strcpy(buffer, DEFAULT_ORIGIN_PREFIX);

    if (gethostname(buffer + strlen(DEFAULT_ORIGIN_PREFIX),
                    BUFSIZE - strlen(DEFAULT_ORIGIN_PREFIX)) == -1) {
      DBG(""Unable to get host name"");
      goto done;
    }
    DBG(""Origin not specified, using \""%s\"""", buffer);
    cfg->origin = strdup(buffer);
    if (!cfg->origin) {
      DBG(""Unable to allocate memory"");
      goto done;
    } else {
      should_free_origin = 1;
    }
  }

  if (!cfg->appid) {
    DBG(""Appid not specified, using the same value of origin (%s)"",
         cfg->origin);
    cfg->appid = strdup(cfg->origin);
    if (!cfg->appid) {
      DBG(""Unable to allocate memory"")
      goto done;
    } else {
      should_free_appid = 1;
    }
  }

  if (cfg->max_devs == 0) {
    DBG(""Maximum devices number not set. Using default (%d)"", MAX_DEVS);
    cfg->max_devs = MAX_DEVS;
  }

  devices = malloc(sizeof(device_t) * cfg->max_devs);
  if (!devices) {
    DBG(""Unable to allocate memory"");
    retval = PAM_IGNORE;
    goto done;
  }

  pgu_ret = pam_get_user(pamh, &user, NULL);
  if (pgu_ret != PAM_SUCCESS || user == NULL) {
    DBG(""Unable to access user %s"", user);
    retval = PAM_CONV_ERR;
    goto done;
  }

  DBG(""Requesting authentication for user %s"", user);

  gpn_ret = getpwnam_r(user, &pw_s, buffer, sizeof(buffer), &pw);
  if (gpn_ret != 0 || pw == NULL || pw->pw_dir == NULL ||
      pw->pw_dir[0] != '/') {
    DBG(""Unable to retrieve credentials for user %s, (%s)"", user,
         strerror(errno));
    retval = PAM_USER_UNKNOWN;
    goto done;
  }

  DBG(""Found user %s"", user);
  DBG(""Home directory for %s is %s"", user, pw->pw_dir);

  if (!cfg->auth_file) {
    buf = NULL;
    authfile_dir = secure_getenv(DEFAULT_AUTHFILE_DIR_VAR);
    if (!authfile_dir) {
      DBG(""Variable %s is not set. Using default value ($HOME/.config/)"",
           DEFAULT_AUTHFILE_DIR_VAR);
      authfile_dir_len =
        strlen(pw->pw_dir) + strlen(""/.config"") + strlen(DEFAULT_AUTHFILE) + 1;
      buf = malloc(sizeof(char) * (authfile_dir_len));

      if (!buf) {
        DBG(""Unable to allocate memory"");
        retval = PAM_IGNORE;
         goto done;
       }
 
//fix_flaw_line_below:
//      /* Opening a file in a users $HOME, need to drop privs for security */
//fix_flaw_line_below:
//      openasuser = geteuid() == 0 ? 1 : 0;
//fix_flaw_line_below:
//
       snprintf(buf, authfile_dir_len,
                ""%s/.config%s"", pw->pw_dir, DEFAULT_AUTHFILE);
     } else {
      DBG(""Variable %s set to %s"", DEFAULT_AUTHFILE_DIR_VAR, authfile_dir);
      authfile_dir_len = strlen(authfile_dir) + strlen(DEFAULT_AUTHFILE) + 1;
      buf = malloc(sizeof(char) * (authfile_dir_len));

      if (!buf) {
        DBG(""Unable to allocate memory"");
        retval = PAM_IGNORE;
        goto done;
      }
 
       snprintf(buf, authfile_dir_len,
                ""%s%s"", authfile_dir, DEFAULT_AUTHFILE);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//      if (!openasuser) {
//fix_flaw_line_below:
//	DBG(""WARNING: not dropping privileges when reading %s, please ""
//fix_flaw_line_below:
//	    ""consider setting openasuser=1 in the module configuration"", buf);
//fix_flaw_line_below:
//      }
     }
 
//flaw_line_below:
    DBG(""Using default authentication file %s"", buf);
//fix_flaw_line_below:
//    DBG(""Using authentication file %s"", buf);
 
     cfg->auth_file = buf; /* cfg takes ownership */
     should_free_auth_file = 1;
    buf = NULL;
  } else {
     DBG(""Using authentication file %s"", cfg->auth_file);
   }
 
//flaw_line_below:
  openasuser = geteuid() == 0 && cfg->openasuser;
//fix_flaw_line_below:
//  if (!openasuser) {
//fix_flaw_line_below:
//    openasuser = geteuid() == 0 && cfg->openasuser;
//fix_flaw_line_below:
//  }
   if (openasuser) {
//flaw_line_below:
    if (seteuid(pw_s.pw_uid)) {
//flaw_line_below:
      DBG(""Unable to switch user to uid %i"", pw_s.pw_uid);
//fix_flaw_line_below:
//    DBG(""Dropping privileges"");
//fix_flaw_line_below:
//    if (pam_modutil_drop_priv(pamh, &privs, pw)) {
//fix_flaw_line_below:
//      DBG(""Unable to switch user to uid %i"", pw->pw_uid);
       retval = PAM_IGNORE;
       goto done;
     }
//flaw_line_below:
    DBG(""Switched to uid %i"", pw_s.pw_uid);
//fix_flaw_line_below:
//    DBG(""Switched to uid %i"", pw->pw_uid);
   }
   retval = get_devices_from_authfile(cfg->auth_file, user, cfg->max_devs,
                                      cfg->debug, cfg->debug_file,
                                      devices, &n_devices);
   if (openasuser) {
//flaw_line_below:
    if (seteuid(0)) {
//flaw_line_below:
      DBG(""Unable to switch back to uid 0"");
//fix_flaw_line_below:
//    if (pam_modutil_regain_priv(pamh, &privs)) {
//fix_flaw_line_below:
//      DBG(""could not restore privileges"");
       retval = PAM_IGNORE;
       goto done;
     }
//flaw_line_below:
    DBG(""Switched back to uid 0"");
//fix_flaw_line_below:
//    DBG(""Restored privileges"");
   }
 
   if (retval != 1) {
    // for nouserok; make sure errors in get_devices_from_authfile don't
    // result in valid devices
    n_devices = 0;
  }

  if (n_devices == 0) {
    if (cfg->nouserok) {
      DBG(""Found no devices but nouserok specified. Skipping authentication"");
      retval = PAM_SUCCESS;
      goto done;
    } else if (retval != 1) {
      DBG(""Unable to get devices from file %s"", cfg->auth_file);
      retval = PAM_AUTHINFO_UNAVAIL;
      goto done;
    } else {
      DBG(""Found no devices. Aborting."");
      retval = PAM_AUTHINFO_UNAVAIL;
      goto done;
    }
  }

  // Determine the full path for authpending_file in order to emit touch request notifications
  if (!cfg->authpending_file) {
    int actual_size = snprintf(buffer, BUFSIZE, DEFAULT_AUTHPENDING_FILE_PATH, getuid());
    if (actual_size >= 0 && actual_size < BUFSIZE) {
      cfg->authpending_file = strdup(buffer);
    }
    if (!cfg->authpending_file) {
      DBG(""Unable to allocate memory for the authpending_file, touch request notifications will not be emitted"");
    } else {
      should_free_authpending_file = 1;
    }
  } else {
    if (strlen(cfg->authpending_file) == 0) {
      DBG(""authpending_file is set to an empty value, touch request notifications will be disabled"");
      cfg->authpending_file = NULL;
    }
  }

  int authpending_file_descriptor = -1;
  if (cfg->authpending_file) {
    DBG(""Using file '%s' for emitting touch request notifications"", cfg->authpending_file);

    // Open (or create) the authpending_file to indicate that we start waiting for a touch
    authpending_file_descriptor =
      open(cfg->authpending_file, O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY, 0664);
    if (authpending_file_descriptor < 0) {
      DBG(""Unable to emit 'authentication started' notification by opening the file '%s', (%s)"",
          cfg->authpending_file, strerror(errno));
    }
  }

  if (cfg->manual == 0) {
    if (cfg->interactive) {
      converse(pamh, PAM_PROMPT_ECHO_ON,
               cfg->prompt != NULL ? cfg->prompt : DEFAULT_PROMPT);
    }

    retval = do_authentication(cfg, devices, n_devices, pamh);
  } else {
    retval = do_manual_authentication(cfg, devices, n_devices, pamh);
  }

  // Close the authpending_file to indicate that we stop waiting for a touch
  if (authpending_file_descriptor >= 0) {
    if (close(authpending_file_descriptor) < 0) {
      DBG(""Unable to emit 'authentication stopped' notification by closing the file '%s', (%s)"",
          cfg->authpending_file, strerror(errno));
    }
  }

  if (retval != 1) {
    DBG(""do_authentication returned %d"", retval);
    retval = PAM_AUTH_ERR;
    goto done;
  }

  retval = PAM_SUCCESS;

done:
  free_devices(devices, n_devices);

  if (buf) {
    free(buf);
    buf = NULL;
  }

  if (should_free_origin) {
    free((char *) cfg->origin);
    cfg->origin = NULL;
  }

  if (should_free_appid) {
    free((char *) cfg->appid);
    cfg->appid = NULL;
  }

  if (should_free_auth_file) {
    free((char *) cfg->auth_file);
    cfg->auth_file = NULL;
  }

  if (should_free_authpending_file) {
    free((char *) cfg->authpending_file);
    cfg->authpending_file = NULL;
  }

  if (cfg->alwaysok && retval != PAM_SUCCESS) {
    DBG(""alwaysok needed (otherwise return with %d)"", retval);
    retval = PAM_SUCCESS;
  }
  DBG(""done. [%s]"", pam_strerror(pamh, retval));

  if (cfg->is_custom_debug_file) {
    fclose(cfg->debug_file);
  }

  return retval;
}
",182836,"int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,
                        const char **argv) {

  struct passwd *pw = NULL, pw_s;
  const char *user = NULL;

  cfg_t cfg_st;
  cfg_t *cfg = &cfg_st;
  char buffer[BUFSIZE];
  char *buf = NULL;
  char *authfile_dir;
  size_t authfile_dir_len;
  int pgu_ret, gpn_ret;
   int retval = PAM_IGNORE;
   device_t *devices = NULL;
   unsigned n_devices = 0;
  int openasuser;
   int should_free_origin = 0;
   int should_free_appid = 0;
   int should_free_auth_file = 0;
   int should_free_authpending_file = 0;
 
   parse_cfg(flags, argc, argv, cfg);
 
  if (!cfg->origin) {
    strcpy(buffer, DEFAULT_ORIGIN_PREFIX);

    if (gethostname(buffer + strlen(DEFAULT_ORIGIN_PREFIX),
                    BUFSIZE - strlen(DEFAULT_ORIGIN_PREFIX)) == -1) {
      DBG(""Unable to get host name"");
      goto done;
    }
    DBG(""Origin not specified, using \""%s\"""", buffer);
    cfg->origin = strdup(buffer);
    if (!cfg->origin) {
      DBG(""Unable to allocate memory"");
      goto done;
    } else {
      should_free_origin = 1;
    }
  }

  if (!cfg->appid) {
    DBG(""Appid not specified, using the same value of origin (%s)"",
         cfg->origin);
    cfg->appid = strdup(cfg->origin);
    if (!cfg->appid) {
      DBG(""Unable to allocate memory"")
      goto done;
    } else {
      should_free_appid = 1;
    }
  }

  if (cfg->max_devs == 0) {
    DBG(""Maximum devices number not set. Using default (%d)"", MAX_DEVS);
    cfg->max_devs = MAX_DEVS;
  }

  devices = malloc(sizeof(device_t) * cfg->max_devs);
  if (!devices) {
    DBG(""Unable to allocate memory"");
    retval = PAM_IGNORE;
    goto done;
  }

  pgu_ret = pam_get_user(pamh, &user, NULL);
  if (pgu_ret != PAM_SUCCESS || user == NULL) {
    DBG(""Unable to access user %s"", user);
    retval = PAM_CONV_ERR;
    goto done;
  }

  DBG(""Requesting authentication for user %s"", user);

  gpn_ret = getpwnam_r(user, &pw_s, buffer, sizeof(buffer), &pw);
  if (gpn_ret != 0 || pw == NULL || pw->pw_dir == NULL ||
      pw->pw_dir[0] != '/') {
    DBG(""Unable to retrieve credentials for user %s, (%s)"", user,
         strerror(errno));
    retval = PAM_USER_UNKNOWN;
    goto done;
  }

  DBG(""Found user %s"", user);
  DBG(""Home directory for %s is %s"", user, pw->pw_dir);

  if (!cfg->auth_file) {
    buf = NULL;
    authfile_dir = secure_getenv(DEFAULT_AUTHFILE_DIR_VAR);
    if (!authfile_dir) {
      DBG(""Variable %s is not set. Using default value ($HOME/.config/)"",
           DEFAULT_AUTHFILE_DIR_VAR);
      authfile_dir_len =
        strlen(pw->pw_dir) + strlen(""/.config"") + strlen(DEFAULT_AUTHFILE) + 1;
      buf = malloc(sizeof(char) * (authfile_dir_len));

      if (!buf) {
        DBG(""Unable to allocate memory"");
        retval = PAM_IGNORE;
         goto done;
       }
 
       snprintf(buf, authfile_dir_len,
                ""%s/.config%s"", pw->pw_dir, DEFAULT_AUTHFILE);
     } else {
      DBG(""Variable %s set to %s"", DEFAULT_AUTHFILE_DIR_VAR, authfile_dir);
      authfile_dir_len = strlen(authfile_dir) + strlen(DEFAULT_AUTHFILE) + 1;
      buf = malloc(sizeof(char) * (authfile_dir_len));

      if (!buf) {
        DBG(""Unable to allocate memory"");
        retval = PAM_IGNORE;
        goto done;
      }
 
       snprintf(buf, authfile_dir_len,
                ""%s%s"", authfile_dir, DEFAULT_AUTHFILE);
     }
 
    DBG(""Using default authentication file %s"", buf);
 
     cfg->auth_file = buf; /* cfg takes ownership */
     should_free_auth_file = 1;
    buf = NULL;
  } else {
     DBG(""Using authentication file %s"", cfg->auth_file);
   }
 
  openasuser = geteuid() == 0 && cfg->openasuser;
   if (openasuser) {
    if (seteuid(pw_s.pw_uid)) {
      DBG(""Unable to switch user to uid %i"", pw_s.pw_uid);
       retval = PAM_IGNORE;
       goto done;
     }
    DBG(""Switched to uid %i"", pw_s.pw_uid);
   }
   retval = get_devices_from_authfile(cfg->auth_file, user, cfg->max_devs,
                                      cfg->debug, cfg->debug_file,
                                      devices, &n_devices);
   if (openasuser) {
    if (seteuid(0)) {
      DBG(""Unable to switch back to uid 0"");
       retval = PAM_IGNORE;
       goto done;
     }
    DBG(""Switched back to uid 0"");
   }
 
   if (retval != 1) {
    n_devices = 0;
  }

  if (n_devices == 0) {
    if (cfg->nouserok) {
      DBG(""Found no devices but nouserok specified. Skipping authentication"");
      retval = PAM_SUCCESS;
      goto done;
    } else if (retval != 1) {
      DBG(""Unable to get devices from file %s"", cfg->auth_file);
      retval = PAM_AUTHINFO_UNAVAIL;
      goto done;
    } else {
      DBG(""Found no devices. Aborting."");
      retval = PAM_AUTHINFO_UNAVAIL;
      goto done;
    }
  }

  if (!cfg->authpending_file) {
    int actual_size = snprintf(buffer, BUFSIZE, DEFAULT_AUTHPENDING_FILE_PATH, getuid());
    if (actual_size >= 0 && actual_size < BUFSIZE) {
      cfg->authpending_file = strdup(buffer);
    }
    if (!cfg->authpending_file) {
      DBG(""Unable to allocate memory for the authpending_file, touch request notifications will not be emitted"");
    } else {
      should_free_authpending_file = 1;
    }
  } else {
    if (strlen(cfg->authpending_file) == 0) {
      DBG(""authpending_file is set to an empty value, touch request notifications will be disabled"");
      cfg->authpending_file = NULL;
    }
  }

  int authpending_file_descriptor = -1;
  if (cfg->authpending_file) {
    DBG(""Using file '%s' for emitting touch request notifications"", cfg->authpending_file);

    authpending_file_descriptor =
      open(cfg->authpending_file, O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY, 0664);
    if (authpending_file_descriptor < 0) {
      DBG(""Unable to emit 'authentication started' notification by opening the file '%s', (%s)"",
          cfg->authpending_file, strerror(errno));
    }
  }

  if (cfg->manual == 0) {
    if (cfg->interactive) {
      converse(pamh, PAM_PROMPT_ECHO_ON,
               cfg->prompt != NULL ? cfg->prompt : DEFAULT_PROMPT);
    }

    retval = do_authentication(cfg, devices, n_devices, pamh);
  } else {
    retval = do_manual_authentication(cfg, devices, n_devices, pamh);
  }

  if (authpending_file_descriptor >= 0) {
    if (close(authpending_file_descriptor) < 0) {
      DBG(""Unable to emit 'authentication stopped' notification by closing the file '%s', (%s)"",
          cfg->authpending_file, strerror(errno));
    }
  }

  if (retval != 1) {
    DBG(""do_authentication returned %d"", retval);
    retval = PAM_AUTH_ERR;
    goto done;
  }

  retval = PAM_SUCCESS;

done:
  free_devices(devices, n_devices);

  if (buf) {
    free(buf);
    buf = NULL;
  }

  if (should_free_origin) {
    free((char *) cfg->origin);
    cfg->origin = NULL;
  }

  if (should_free_appid) {
    free((char *) cfg->appid);
    cfg->appid = NULL;
  }

  if (should_free_auth_file) {
    free((char *) cfg->auth_file);
    cfg->auth_file = NULL;
  }

  if (should_free_authpending_file) {
    free((char *) cfg->authpending_file);
    cfg->authpending_file = NULL;
  }

  if (cfg->alwaysok && retval != PAM_SUCCESS) {
    DBG(""alwaysok needed (otherwise return with %d)"", retval);
    retval = PAM_SUCCESS;
  }
  DBG(""done. [%s]"", pam_strerror(pamh, retval));

  if (cfg->is_custom_debug_file) {
    fclose(cfg->debug_file);
  }

  return retval;
}
","int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,
                        const char **argv) {

  struct passwd *pw = NULL, pw_s;
  const char *user = NULL;

  cfg_t cfg_st;
  cfg_t *cfg = &cfg_st;
  char buffer[BUFSIZE];
  char *buf = NULL;
  char *authfile_dir;
  size_t authfile_dir_len;
  int pgu_ret, gpn_ret;
   int retval = PAM_IGNORE;
   device_t *devices = NULL;
   unsigned n_devices = 0;
  int openasuser = 0;
   int should_free_origin = 0;
   int should_free_appid = 0;
   int should_free_auth_file = 0;
   int should_free_authpending_file = 0;
  PAM_MODUTIL_DEF_PRIVS(privs);
 
   parse_cfg(flags, argc, argv, cfg);
 
  if (!cfg->origin) {
    strcpy(buffer, DEFAULT_ORIGIN_PREFIX);

    if (gethostname(buffer + strlen(DEFAULT_ORIGIN_PREFIX),
                    BUFSIZE - strlen(DEFAULT_ORIGIN_PREFIX)) == -1) {
      DBG(""Unable to get host name"");
      goto done;
    }
    DBG(""Origin not specified, using \""%s\"""", buffer);
    cfg->origin = strdup(buffer);
    if (!cfg->origin) {
      DBG(""Unable to allocate memory"");
      goto done;
    } else {
      should_free_origin = 1;
    }
  }

  if (!cfg->appid) {
    DBG(""Appid not specified, using the same value of origin (%s)"",
         cfg->origin);
    cfg->appid = strdup(cfg->origin);
    if (!cfg->appid) {
      DBG(""Unable to allocate memory"")
      goto done;
    } else {
      should_free_appid = 1;
    }
  }

  if (cfg->max_devs == 0) {
    DBG(""Maximum devices number not set. Using default (%d)"", MAX_DEVS);
    cfg->max_devs = MAX_DEVS;
  }

  devices = malloc(sizeof(device_t) * cfg->max_devs);
  if (!devices) {
    DBG(""Unable to allocate memory"");
    retval = PAM_IGNORE;
    goto done;
  }

  pgu_ret = pam_get_user(pamh, &user, NULL);
  if (pgu_ret != PAM_SUCCESS || user == NULL) {
    DBG(""Unable to access user %s"", user);
    retval = PAM_CONV_ERR;
    goto done;
  }

  DBG(""Requesting authentication for user %s"", user);

  gpn_ret = getpwnam_r(user, &pw_s, buffer, sizeof(buffer), &pw);
  if (gpn_ret != 0 || pw == NULL || pw->pw_dir == NULL ||
      pw->pw_dir[0] != '/') {
    DBG(""Unable to retrieve credentials for user %s, (%s)"", user,
         strerror(errno));
    retval = PAM_USER_UNKNOWN;
    goto done;
  }

  DBG(""Found user %s"", user);
  DBG(""Home directory for %s is %s"", user, pw->pw_dir);

  if (!cfg->auth_file) {
    buf = NULL;
    authfile_dir = secure_getenv(DEFAULT_AUTHFILE_DIR_VAR);
    if (!authfile_dir) {
      DBG(""Variable %s is not set. Using default value ($HOME/.config/)"",
           DEFAULT_AUTHFILE_DIR_VAR);
      authfile_dir_len =
        strlen(pw->pw_dir) + strlen(""/.config"") + strlen(DEFAULT_AUTHFILE) + 1;
      buf = malloc(sizeof(char) * (authfile_dir_len));

      if (!buf) {
        DBG(""Unable to allocate memory"");
        retval = PAM_IGNORE;
         goto done;
       }
 
      /* Opening a file in a users $HOME, need to drop privs for security */
      openasuser = geteuid() == 0 ? 1 : 0;

       snprintf(buf, authfile_dir_len,
                ""%s/.config%s"", pw->pw_dir, DEFAULT_AUTHFILE);
     } else {
      DBG(""Variable %s set to %s"", DEFAULT_AUTHFILE_DIR_VAR, authfile_dir);
      authfile_dir_len = strlen(authfile_dir) + strlen(DEFAULT_AUTHFILE) + 1;
      buf = malloc(sizeof(char) * (authfile_dir_len));

      if (!buf) {
        DBG(""Unable to allocate memory"");
        retval = PAM_IGNORE;
        goto done;
      }
 
       snprintf(buf, authfile_dir_len,
                ""%s%s"", authfile_dir, DEFAULT_AUTHFILE);

      if (!openasuser) {
	DBG(""WARNING: not dropping privileges when reading %s, please ""
	    ""consider setting openasuser=1 in the module configuration"", buf);
      }
     }
 
    DBG(""Using authentication file %s"", buf);
 
     cfg->auth_file = buf; /* cfg takes ownership */
     should_free_auth_file = 1;
    buf = NULL;
  } else {
     DBG(""Using authentication file %s"", cfg->auth_file);
   }
 
  if (!openasuser) {
    openasuser = geteuid() == 0 && cfg->openasuser;
  }
   if (openasuser) {
    DBG(""Dropping privileges"");
    if (pam_modutil_drop_priv(pamh, &privs, pw)) {
      DBG(""Unable to switch user to uid %i"", pw->pw_uid);
       retval = PAM_IGNORE;
       goto done;
     }
    DBG(""Switched to uid %i"", pw->pw_uid);
   }
   retval = get_devices_from_authfile(cfg->auth_file, user, cfg->max_devs,
                                      cfg->debug, cfg->debug_file,
                                      devices, &n_devices);
   if (openasuser) {
    if (pam_modutil_regain_priv(pamh, &privs)) {
      DBG(""could not restore privileges"");
       retval = PAM_IGNORE;
       goto done;
     }
    DBG(""Restored privileges"");
   }
 
   if (retval != 1) {
    n_devices = 0;
  }

  if (n_devices == 0) {
    if (cfg->nouserok) {
      DBG(""Found no devices but nouserok specified. Skipping authentication"");
      retval = PAM_SUCCESS;
      goto done;
    } else if (retval != 1) {
      DBG(""Unable to get devices from file %s"", cfg->auth_file);
      retval = PAM_AUTHINFO_UNAVAIL;
      goto done;
    } else {
      DBG(""Found no devices. Aborting."");
      retval = PAM_AUTHINFO_UNAVAIL;
      goto done;
    }
  }

  if (!cfg->authpending_file) {
    int actual_size = snprintf(buffer, BUFSIZE, DEFAULT_AUTHPENDING_FILE_PATH, getuid());
    if (actual_size >= 0 && actual_size < BUFSIZE) {
      cfg->authpending_file = strdup(buffer);
    }
    if (!cfg->authpending_file) {
      DBG(""Unable to allocate memory for the authpending_file, touch request notifications will not be emitted"");
    } else {
      should_free_authpending_file = 1;
    }
  } else {
    if (strlen(cfg->authpending_file) == 0) {
      DBG(""authpending_file is set to an empty value, touch request notifications will be disabled"");
      cfg->authpending_file = NULL;
    }
  }

  int authpending_file_descriptor = -1;
  if (cfg->authpending_file) {
    DBG(""Using file '%s' for emitting touch request notifications"", cfg->authpending_file);

    authpending_file_descriptor =
      open(cfg->authpending_file, O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY, 0664);
    if (authpending_file_descriptor < 0) {
      DBG(""Unable to emit 'authentication started' notification by opening the file '%s', (%s)"",
          cfg->authpending_file, strerror(errno));
    }
  }

  if (cfg->manual == 0) {
    if (cfg->interactive) {
      converse(pamh, PAM_PROMPT_ECHO_ON,
               cfg->prompt != NULL ? cfg->prompt : DEFAULT_PROMPT);
    }

    retval = do_authentication(cfg, devices, n_devices, pamh);
  } else {
    retval = do_manual_authentication(cfg, devices, n_devices, pamh);
  }

  if (authpending_file_descriptor >= 0) {
    if (close(authpending_file_descriptor) < 0) {
      DBG(""Unable to emit 'authentication stopped' notification by closing the file '%s', (%s)"",
          cfg->authpending_file, strerror(errno));
    }
  }

  if (retval != 1) {
    DBG(""do_authentication returned %d"", retval);
    retval = PAM_AUTH_ERR;
    goto done;
  }

  retval = PAM_SUCCESS;

done:
  free_devices(devices, n_devices);

  if (buf) {
    free(buf);
    buf = NULL;
  }

  if (should_free_origin) {
    free((char *) cfg->origin);
    cfg->origin = NULL;
  }

  if (should_free_appid) {
    free((char *) cfg->appid);
    cfg->appid = NULL;
  }

  if (should_free_auth_file) {
    free((char *) cfg->auth_file);
    cfg->auth_file = NULL;
  }

  if (should_free_authpending_file) {
    free((char *) cfg->authpending_file);
    cfg->authpending_file = NULL;
  }

  if (cfg->alwaysok && retval != PAM_SUCCESS) {
    DBG(""alwaysok needed (otherwise return with %d)"", retval);
    retval = PAM_SUCCESS;
  }
  DBG(""done. [%s]"", pam_strerror(pamh, retval));

  if (cfg->is_custom_debug_file) {
    fclose(cfg->debug_file);
  }

  return retval;
}
","The provided code implements a PAM (Pluggable Authentication Module) function for user authentication, handling various configurations and user-specific settings. It begins by parsing configuration options and setting defaults for origin, app ID, and maximum devices. The function retrieves the user's credentials and home directory, then determines the appropriate authentication file. It manages user permissions, retrieves device information from the authentication file, and handles notifications for authentication status. Depending on the configuration, it either performs interactive or manual authentication. Finally, it cleans up allocated resources and returns the authentication result, indicating success or failure.","The code implements a user authentication process within a PAM module, managing various configuration settings and defaults. It begins by parsing input parameters and establishing necessary values for user identification and device limits. The function retrieves user credentials and their home directory, then determines the appropriate authentication file to use. It handles user permissions for accessing resources and retrieves device information for authentication. Depending on the configuration, it can perform either interactive or manual authentication. Finally, the code cleans up allocated resources and returns the result of the authentication attempt, indicating success or failure.","The vulnerability in the original code stemmed from the fact that it operated with elevated privileges (as root) when accessing user-related files, which could potentially allow an attacker to manipulate these files or symlinks, leading to unauthorized access or privilege escalation. The fix implemented in the updated code involves explicitly dropping privileges to the target user before opening any user-related files, ensuring that the module operates with the least privilege necessary. This change enhances security by preventing unauthorized file access and mitigating risks associated with running as root, thus addressing the reported vulnerability.","The vulnerability in the original code arose from executing the module with root privileges while accessing user-related files, which could allow an attacker to exploit this access to manipulate files or symlinks, leading to potential unauthorized actions. The fix implemented in the updated code involves dropping privileges to the target user before any file operations are performed. This change ensures that the module operates with the minimum necessary privileges, significantly reducing the risk of unauthorized access and enhancing overall security by preventing the exploitation of elevated permissions when handling user-specific files.","The vulnerability was fixed by introducing a mechanism to drop privileges before accessing user-related files. In the updated code, the `pam_modutil_drop_priv` function is called to switch the effective user ID to the target user's ID before opening any files, ensuring that the module no longer operates with root privileges. This is particularly important when constructing the authentication file path, as it prevents unauthorized access to sensitive user data. Additionally, the code checks the `openasuser` variable to determine whether to drop privileges, enhancing security by ensuring that file operations are performed with the least privilege necessary.","The vulnerability was addressed by implementing a mechanism to drop elevated privileges before accessing user-related files. This change ensures that the module operates under the target user's permissions rather than as root, significantly reducing the risk of unauthorized access or manipulation of sensitive files. By switching to the target user's identity prior to any file operations, the code prevents potential exploitation that could arise from running with higher privileges. This approach enhances security by enforcing the principle of least privilege, ensuring that file access is limited to what is necessary for the user's authentication process.","4,4","5,5","4,3","4,5"
92,92,182840,182840,,Remote,Not required,,CVE-2019-12107,https://www.cvedetails.com/cve/CVE-2019-12107/,CWE-200,Low,Partial,,,2019-05-15,5.0,The upnp_event_prepare function in upnpevents.c in MiniUPnP MiniUPnPd through 2.1 allows a remote attacker to leak information from the heap due to improper validation of an snprintf return value.,2019-05-30,+Info ,26,https://github.com/miniupnp/miniupnp/commit/bec6ccec63cadc95655721bc0e1dd49dac759d94,bec6ccec63cadc95655721bc0e1dd49dac759d94,upnp_event_prepare(): check the return value of snprintf(),11,miniupnpd/upnpevents.c,"{""sha"": ""3bc402f37e00d24a037b78719f62f83bc720a9d1"", ""filename"": ""miniupnpd/upnpevents.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 11, ""changes"": 37, ""blob_url"": ""https://github.com/miniupnp/miniupnp/blob/bec6ccec63cadc95655721bc0e1dd49dac759d94/miniupnpd/upnpevents.c"", ""raw_url"": ""https://github.com/miniupnp/miniupnp/raw/bec6ccec63cadc95655721bc0e1dd49dac759d94/miniupnpd/upnpevents.c"", ""contents_url"": ""https://api.github.com/repos/miniupnp/miniupnp/contents/miniupnpd/upnpevents.c?ref=bec6ccec63cadc95655721bc0e1dd49dac759d94"", ""patch"": ""@@ -443,19 +443,34 @@ static void upnp_event_prepare(struct upnp_event_notify * obj)\n \t\tl = 0;\n \t}\n \tobj->buffersize = 1024;\n-\tobj->buffer = malloc(obj->buffersize);\n-\tif(!obj->buffer) {\n-\t\tsyslog(LOG_ERR, \""%s: malloc returned NULL\"", \""upnp_event_prepare\"");\n-\t\tif(xml) {\n-\t\t\tfree(xml);\n+\tfor (;;) {\n+\t\tobj->buffer = malloc(obj->buffersize);\n+\t\tif(!obj->buffer) {\n+\t\t\tsyslog(LOG_ERR, \""%s: malloc returned NULL\"", \""upnp_event_prepare\"");\n+\t\t\tif(xml) {\n+\t\t\t\tfree(xml);\n+\t\t\t}\n+\t\t\tobj->state = EError;\n+\t\t\treturn;\n \t\t}\n-\t\tobj->state = EError;\n-\t\treturn;\n+\t\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n+\t\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n+\t\t                       obj->sub->uuid, obj->sub->seq,\n+\t\t                       l, xml);\n+\t\tif (obj->tosend < 0) {\n+\t\t\tsyslog(LOG_ERR, \""%s: snprintf() failed\"", \""upnp_event_prepare\"");\n+\t\t\tif(xml) {\n+\t\t\t\tfree(xml);\n+\t\t\t}\n+\t\t\tobj->state = EError;\n+\t\t\treturn;\n+\t\t} else if (obj->tosend < obj->buffersize) {\n+\t\t\tbreak; /* the buffer was large enough */\n+\t\t}\n+\t\t/* Try again with a buffer big enough */\n+\t\tfree(obj->buffer);\n+\t\tobj->buffersize = obj->tosend + 1;\t/* reserve space for the final 0 */\n \t}\n-\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n-\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n-\t                       obj->sub->uuid, obj->sub->seq,\n-\t                       l, xml);\n \tif(xml) {\n \t\tfree(xml);\n \t\txml = NULL;""}","static void upnp_event_prepare(struct upnp_event_notify * obj)
{
	static const char notifymsg[] =
		""NOTIFY %s HTTP/1.1\r\n""
		""Host: %s%s\r\n""
#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)
		""Content-Type: text/xml\r\n""	/* UDA v1.0 */
#else
		""Content-Type: text/xml; charset=\""utf-8\""\r\n""	/* UDA v1.1 or later */
#endif
		""Content-Length: %d\r\n""
		""NT: upnp:event\r\n""
		""NTS: upnp:propchange\r\n""
		""SID: %s\r\n""
		""SEQ: %u\r\n""
		""Connection: close\r\n""
		""Cache-Control: no-cache\r\n""
		""\r\n""
		""%.*s\r\n"";
	char * xml;
	int l;
	if(obj->sub == NULL) {
		obj->state = EError;
		return;
	}
	switch(obj->sub->service) {
	case EWanCFG:
		xml = getVarsWANCfg(&l);
		break;
	case EWanIPC:
		xml = getVarsWANIPCn(&l);
		break;
#ifdef ENABLE_L3F_SERVICE
	case EL3F:
		xml = getVarsL3F(&l);
		break;
#endif
#ifdef ENABLE_6FC_SERVICE
	case E6FC:
		xml = getVars6FC(&l);
		break;
#endif
#ifdef ENABLE_DP_SERVICE
	case EDP:
		xml = getVarsDP(&l);
		break;
#endif
	default:
		xml = NULL;
 		l = 0;
 	}
 	obj->buffersize = 1024;
	for (;;) {
		obj->buffer = malloc(obj->buffersize);
		if(!obj->buffer) {
			syslog(LOG_ERR, ""%s: malloc returned NULL"", ""upnp_event_prepare"");
			if(xml) {
				free(xml);
			}
			obj->state = EError;
			return;
 		}
		obj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,
		                       obj->path, obj->addrstr, obj->portstr, l+2,
		                       obj->sub->uuid, obj->sub->seq,
		                       l, xml);
		if (obj->tosend < 0) {
			syslog(LOG_ERR, ""%s: snprintf() failed"", ""upnp_event_prepare"");
			if(xml) {
				free(xml);
			}
			obj->state = EError;
			return;
		} else if (obj->tosend < obj->buffersize) {
			break; /* the buffer was large enough */
		}
		/* Try again with a buffer big enough */
		free(obj->buffer);
		obj->buffersize = obj->tosend + 1;	/* reserve space for the final 0 */
 	}
 	if(xml) {
 		free(xml);
 		xml = NULL;
	}
	obj->state = ESending;
}
","static void upnp_event_prepare(struct upnp_event_notify * obj)
{
	static const char notifymsg[] =
		""NOTIFY %s HTTP/1.1\r\n""
		""Host: %s%s\r\n""
#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)
		""Content-Type: text/xml\r\n""	/* UDA v1.0 */
#else
		""Content-Type: text/xml; charset=\""utf-8\""\r\n""	/* UDA v1.1 or later */
#endif
		""Content-Length: %d\r\n""
		""NT: upnp:event\r\n""
		""NTS: upnp:propchange\r\n""
		""SID: %s\r\n""
		""SEQ: %u\r\n""
		""Connection: close\r\n""
		""Cache-Control: no-cache\r\n""
		""\r\n""
		""%.*s\r\n"";
	char * xml;
	int l;
	if(obj->sub == NULL) {
		obj->state = EError;
		return;
	}
	switch(obj->sub->service) {
	case EWanCFG:
		xml = getVarsWANCfg(&l);
		break;
	case EWanIPC:
		xml = getVarsWANIPCn(&l);
		break;
#ifdef ENABLE_L3F_SERVICE
	case EL3F:
		xml = getVarsL3F(&l);
		break;
#endif
#ifdef ENABLE_6FC_SERVICE
	case E6FC:
		xml = getVars6FC(&l);
		break;
#endif
#ifdef ENABLE_DP_SERVICE
	case EDP:
		xml = getVarsDP(&l);
		break;
#endif
	default:
		xml = NULL;
 		l = 0;
 	}
 	obj->buffersize = 1024;
	obj->buffer = malloc(obj->buffersize);
	if(!obj->buffer) {
		syslog(LOG_ERR, ""%s: malloc returned NULL"", ""upnp_event_prepare"");
		if(xml) {
			free(xml);
 		}
		obj->state = EError;
		return;
 	}
	obj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,
	                       obj->path, obj->addrstr, obj->portstr, l+2,
	                       obj->sub->uuid, obj->sub->seq,
	                       l, xml);
 	if(xml) {
 		free(xml);
 		xml = NULL;
	}
	obj->state = ESending;
}
",C,"	for (;;) {
		obj->buffer = malloc(obj->buffersize);
		if(!obj->buffer) {
			syslog(LOG_ERR, ""%s: malloc returned NULL"", ""upnp_event_prepare"");
			if(xml) {
				free(xml);
			}
			obj->state = EError;
			return;
		obj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,
		                       obj->path, obj->addrstr, obj->portstr, l+2,
		                       obj->sub->uuid, obj->sub->seq,
		                       l, xml);
		if (obj->tosend < 0) {
			syslog(LOG_ERR, ""%s: snprintf() failed"", ""upnp_event_prepare"");
			if(xml) {
				free(xml);
			}
			obj->state = EError;
			return;
		} else if (obj->tosend < obj->buffersize) {
			break; /* the buffer was large enough */
		}
		/* Try again with a buffer big enough */
		free(obj->buffer);
		obj->buffersize = obj->tosend + 1;	/* reserve space for the final 0 */
","	obj->buffer = malloc(obj->buffersize);
	if(!obj->buffer) {
		syslog(LOG_ERR, ""%s: malloc returned NULL"", ""upnp_event_prepare"");
		if(xml) {
			free(xml);
		obj->state = EError;
		return;
	obj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,
	                       obj->path, obj->addrstr, obj->portstr, l+2,
	                       obj->sub->uuid, obj->sub->seq,
	                       l, xml);
",,"@@ -443,19 +443,34 @@ static void upnp_event_prepare(struct upnp_event_notify * obj)
 		l = 0;
 	}
 	obj->buffersize = 1024;
-	obj->buffer = malloc(obj->buffersize);
-	if(!obj->buffer) {
-		syslog(LOG_ERR, ""%s: malloc returned NULL"", ""upnp_event_prepare"");
-		if(xml) {
-			free(xml);
+	for (;;) {
+		obj->buffer = malloc(obj->buffersize);
+		if(!obj->buffer) {
+			syslog(LOG_ERR, ""%s: malloc returned NULL"", ""upnp_event_prepare"");
+			if(xml) {
+				free(xml);
+			}
+			obj->state = EError;
+			return;
 		}
-		obj->state = EError;
-		return;
+		obj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,
+		                       obj->path, obj->addrstr, obj->portstr, l+2,
+		                       obj->sub->uuid, obj->sub->seq,
+		                       l, xml);
+		if (obj->tosend < 0) {
+			syslog(LOG_ERR, ""%s: snprintf() failed"", ""upnp_event_prepare"");
+			if(xml) {
+				free(xml);
+			}
+			obj->state = EError;
+			return;
+		} else if (obj->tosend < obj->buffersize) {
+			break; /* the buffer was large enough */
+		}
+		/* Try again with a buffer big enough */
+		free(obj->buffer);
+		obj->buffersize = obj->tosend + 1;	/* reserve space for the final 0 */
 	}
-	obj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,
-	                       obj->path, obj->addrstr, obj->portstr, l+2,
-	                       obj->sub->uuid, obj->sub->seq,
-	                       l, xml);
 	if(xml) {
 		free(xml);
 		xml = NULL;",miniupnp,bec6ccec63cadc95655721bc0e1dd49dac759d94,cd506a67e174a45c6a202eff182a712955ed6d6f,1,"static void upnp_event_prepare(struct upnp_event_notify * obj)
{
	static const char notifymsg[] =
		""NOTIFY %s HTTP/1.1\r\n""
		""Host: %s%s\r\n""
#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)
		""Content-Type: text/xml\r\n""	/* UDA v1.0 */
#else
		""Content-Type: text/xml; charset=\""utf-8\""\r\n""	/* UDA v1.1 or later */
#endif
		""Content-Length: %d\r\n""
		""NT: upnp:event\r\n""
		""NTS: upnp:propchange\r\n""
		""SID: %s\r\n""
		""SEQ: %u\r\n""
		""Connection: close\r\n""
		""Cache-Control: no-cache\r\n""
		""\r\n""
		""%.*s\r\n"";
	char * xml;
	int l;
	if(obj->sub == NULL) {
		obj->state = EError;
		return;
	}
	switch(obj->sub->service) {
	case EWanCFG:
		xml = getVarsWANCfg(&l);
		break;
	case EWanIPC:
		xml = getVarsWANIPCn(&l);
		break;
#ifdef ENABLE_L3F_SERVICE
	case EL3F:
		xml = getVarsL3F(&l);
		break;
#endif
#ifdef ENABLE_6FC_SERVICE
	case E6FC:
		xml = getVars6FC(&l);
		break;
#endif
#ifdef ENABLE_DP_SERVICE
	case EDP:
		xml = getVarsDP(&l);
		break;
#endif
	default:
		xml = NULL;
 		l = 0;
 	}
 	obj->buffersize = 1024;
//flaw_line_below:
	obj->buffer = malloc(obj->buffersize);
//flaw_line_below:
	if(!obj->buffer) {
//flaw_line_below:
		syslog(LOG_ERR, ""%s: malloc returned NULL"", ""upnp_event_prepare"");
//flaw_line_below:
		if(xml) {
//flaw_line_below:
			free(xml);
//fix_flaw_line_below:
//	for (;;) {
//fix_flaw_line_below:
//		obj->buffer = malloc(obj->buffersize);
//fix_flaw_line_below:
//		if(!obj->buffer) {
//fix_flaw_line_below:
//			syslog(LOG_ERR, ""%s: malloc returned NULL"", ""upnp_event_prepare"");
//fix_flaw_line_below:
//			if(xml) {
//fix_flaw_line_below:
//				free(xml);
//fix_flaw_line_below:
//			}
//fix_flaw_line_below:
//			obj->state = EError;
//fix_flaw_line_below:
//			return;
 		}
//flaw_line_below:
		obj->state = EError;
//flaw_line_below:
		return;
//fix_flaw_line_below:
//		obj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,
//fix_flaw_line_below:
//		                       obj->path, obj->addrstr, obj->portstr, l+2,
//fix_flaw_line_below:
//		                       obj->sub->uuid, obj->sub->seq,
//fix_flaw_line_below:
//		                       l, xml);
//fix_flaw_line_below:
//		if (obj->tosend < 0) {
//fix_flaw_line_below:
//			syslog(LOG_ERR, ""%s: snprintf() failed"", ""upnp_event_prepare"");
//fix_flaw_line_below:
//			if(xml) {
//fix_flaw_line_below:
//				free(xml);
//fix_flaw_line_below:
//			}
//fix_flaw_line_below:
//			obj->state = EError;
//fix_flaw_line_below:
//			return;
//fix_flaw_line_below:
//		} else if (obj->tosend < obj->buffersize) {
//fix_flaw_line_below:
//			break; /* the buffer was large enough */
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//		/* Try again with a buffer big enough */
//fix_flaw_line_below:
//		free(obj->buffer);
//fix_flaw_line_below:
//		obj->buffersize = obj->tosend + 1;	/* reserve space for the final 0 */
 	}
//flaw_line_below:
	obj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,
//flaw_line_below:
	                       obj->path, obj->addrstr, obj->portstr, l+2,
//flaw_line_below:
	                       obj->sub->uuid, obj->sub->seq,
//flaw_line_below:
	                       l, xml);
 	if(xml) {
 		free(xml);
 		xml = NULL;
	}
	obj->state = ESending;
}
",182840,"static void upnp_event_prepare(struct upnp_event_notify * obj)
{
	static const char notifymsg[] =
		""NOTIFY %s HTTP/1.1\r\n""
		""Host: %s%s\r\n""
#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)
		""Content-Type: text/xml\r\n""	/* UDA v1.0 */
#else
		""Content-Type: text/xml; charset=\""utf-8\""\r\n""	/* UDA v1.1 or later */
#endif
		""Content-Length: %d\r\n""
		""NT: upnp:event\r\n""
		""NTS: upnp:propchange\r\n""
		""SID: %s\r\n""
		""SEQ: %u\r\n""
		""Connection: close\r\n""
		""Cache-Control: no-cache\r\n""
		""\r\n""
		""%.*s\r\n"";
	char * xml;
	int l;
	if(obj->sub == NULL) {
		obj->state = EError;
		return;
	}
	switch(obj->sub->service) {
	case EWanCFG:
		xml = getVarsWANCfg(&l);
		break;
	case EWanIPC:
		xml = getVarsWANIPCn(&l);
		break;
#ifdef ENABLE_L3F_SERVICE
	case EL3F:
		xml = getVarsL3F(&l);
		break;
#endif
#ifdef ENABLE_6FC_SERVICE
	case E6FC:
		xml = getVars6FC(&l);
		break;
#endif
#ifdef ENABLE_DP_SERVICE
	case EDP:
		xml = getVarsDP(&l);
		break;
#endif
	default:
		xml = NULL;
 		l = 0;
 	}
 	obj->buffersize = 1024;
	obj->buffer = malloc(obj->buffersize);
	if(!obj->buffer) {
		syslog(LOG_ERR, ""%s: malloc returned NULL"", ""upnp_event_prepare"");
		if(xml) {
			free(xml);
 		}
		obj->state = EError;
		return;
 	}
	obj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,
	                       obj->path, obj->addrstr, obj->portstr, l+2,
	                       obj->sub->uuid, obj->sub->seq,
	                       l, xml);
 	if(xml) {
 		free(xml);
 		xml = NULL;
	}
	obj->state = ESending;
}
","static void upnp_event_prepare(struct upnp_event_notify * obj)
{
	static const char notifymsg[] =
		""NOTIFY %s HTTP/1.1\r\n""
		""Host: %s%s\r\n""
#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)
		""Content-Type: text/xml\r\n""	/* UDA v1.0 */
#else
		""Content-Type: text/xml; charset=\""utf-8\""\r\n""	/* UDA v1.1 or later */
#endif
		""Content-Length: %d\r\n""
		""NT: upnp:event\r\n""
		""NTS: upnp:propchange\r\n""
		""SID: %s\r\n""
		""SEQ: %u\r\n""
		""Connection: close\r\n""
		""Cache-Control: no-cache\r\n""
		""\r\n""
		""%.*s\r\n"";
	char * xml;
	int l;
	if(obj->sub == NULL) {
		obj->state = EError;
		return;
	}
	switch(obj->sub->service) {
	case EWanCFG:
		xml = getVarsWANCfg(&l);
		break;
	case EWanIPC:
		xml = getVarsWANIPCn(&l);
		break;
#ifdef ENABLE_L3F_SERVICE
	case EL3F:
		xml = getVarsL3F(&l);
		break;
#endif
#ifdef ENABLE_6FC_SERVICE
	case E6FC:
		xml = getVars6FC(&l);
		break;
#endif
#ifdef ENABLE_DP_SERVICE
	case EDP:
		xml = getVarsDP(&l);
		break;
#endif
	default:
		xml = NULL;
 		l = 0;
 	}
 	obj->buffersize = 1024;
	for (;;) {
		obj->buffer = malloc(obj->buffersize);
		if(!obj->buffer) {
			syslog(LOG_ERR, ""%s: malloc returned NULL"", ""upnp_event_prepare"");
			if(xml) {
				free(xml);
			}
			obj->state = EError;
			return;
 		}
		obj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,
		                       obj->path, obj->addrstr, obj->portstr, l+2,
		                       obj->sub->uuid, obj->sub->seq,
		                       l, xml);
		if (obj->tosend < 0) {
			syslog(LOG_ERR, ""%s: snprintf() failed"", ""upnp_event_prepare"");
			if(xml) {
				free(xml);
			}
			obj->state = EError;
			return;
		} else if (obj->tosend < obj->buffersize) {
			break; /* the buffer was large enough */
		}
		/* Try again with a buffer big enough */
		free(obj->buffer);
		obj->buffersize = obj->tosend + 1;	/* reserve space for the final 0 */
 	}
 	if(xml) {
 		free(xml);
 		xml = NULL;
	}
	obj->state = ESending;
}
","The `upnp_event_prepare` function prepares a UPnP (Universal Plug and Play) notification message for sending to a subscribed client. It constructs a formatted HTTP/1.1 NOTIFY message based on the subscription details, including the service type, and retrieves the relevant XML data representing the current state of the service. The function checks for a valid subscription and allocates a buffer for the message. If memory allocation fails, it logs an error and updates the state to indicate an error. Finally, it populates the buffer with the formatted message and sets the state to indicate that the message is ready to be sent.","The function prepares a notification message for a UPnP event by constructing an HTTP NOTIFY message based on subscription details. It checks if the subscription is valid and retrieves the corresponding XML data representing the service's current state. If memory allocation for the message buffer fails, it logs an error and updates the state to indicate failure. Once the buffer is successfully allocated, the function formats the notification message with the necessary headers and the XML data, then updates the state to indicate that the message is ready to be sent to the subscribed client.","The vulnerability in the original code stemmed from the lack of error handling for the return value of the `snprintf` function, which could lead to buffer overflows or memory corruption if the formatted message exceeded the allocated buffer size. In the fixed code, a loop was introduced to check the return value of `snprintf`. If the return value indicated that the buffer was insufficient, the code would free the previously allocated buffer and allocate a new one with an appropriate size based on the required length, ensuring that the message would fit and preventing potential vulnerabilities related to memory management.","The vulnerability in the original code arose from the failure to check the return value of a function responsible for formatting a message, which could lead to buffer overflows if the message exceeded the allocated size. This oversight could result in memory corruption or crashes, posing a security risk. The fix involved implementing a loop that verifies the return value of the formatting function. If the buffer was insufficient, the code would free the existing memory and allocate a new buffer with an appropriate size, ensuring that the message would fit correctly and enhancing overall memory safety.","The vulnerability was fixed by adding a loop that checks the return value of the `snprintf` function, which formats the notification message. If `snprintf` indicates that the buffer is too small (i.e., the return value is greater than or equal to the buffer size), the code frees the previously allocated buffer and reallocates a new one with a size based on the return value plus one for the null terminator. This ensures that the buffer is always large enough to hold the formatted message, thereby preventing buffer overflows and enhancing memory safety in the function.","The vulnerability was addressed by implementing a loop that checks the result of the message formatting operation. If the result indicates that the allocated buffer is insufficient to hold the formatted message, the code frees the existing memory and allocates a new buffer with an appropriate size based on the required length. This adjustment ensures that the buffer can accommodate the entire message, preventing potential buffer overflows and memory corruption. By continuously verifying the buffer size until it is adequate, the fix enhances the overall safety and reliability of the code.","5,5","5,5","4,4","5,5"
93,93,182887,182887,,Remote,Not required,,CVE-2019-10639,https://www.cvedetails.com/cve/CVE-2019-10639/,CWE-200,Low,Partial,,,2019-07-05,5.0,"The Linux kernel 4.x (starting from 4.1) and 5.x before 5.0.8 allows Information Exposure (partial kernel address disclosure), leading to a KASLR bypass. Specifically, it is possible to extract the KASLR kernel image offset using the IP ID values the kernel produces for connection-less protocols (e.g., UDP and ICMP). When such traffic is sent to multiple destination IP addresses, it is possible to obtain hash collisions (of indices to the counter array) and thereby obtain the hashing key (via enumeration). This key contains enough bits from a kernel address (of a static variable) so when the key is extracted (via enumeration), the offset of the kernel image is exposed. This attack can be carried out remotely, by the attacker forcing the target device to send UDP or ICMP (or certain other) traffic to attacker-controlled IP addresses. Forcing a server to send UDP traffic is trivial if the server is a DNS server. ICMP traffic is trivial if the server answers ICMP Echo requests (ping). For client targets, if the target visits the attacker's web page, then WebRTC or gQUIC can be used to force UDP traffic to attacker-controlled IP addresses. NOTE: this attack against KASLR became viable in 4.1 because IP ID generation was changed to have a dependency on an address associated with a network namespace.",2019-07-19,Bypass +Info ,1,https://github.com/torvalds/linux/commit/355b98553789b646ed97ad801a619ff898471b92,355b98553789b646ed97ad801a619ff898471b92,"netns: provide pure entropy for net_hash_mix()

net_hash_mix() currently uses kernel address of a struct net,
and is used in many places that could be used to reveal this
address to a patient attacker, thus defeating KASLR, for
the typical case (initial net namespace, &init_net is
not dynamically allocated)

I believe the original implementation tried to avoid spending
too many cycles in this function, but security comes first.

Also provide entropy regardless of CONFIG_NET_NS.

Fixes: 0b4419162aa6 (""netns: introduce the net_hash_mix ""salt"" for hashes"")
Signed-off-by: Eric Dumazet <edumazet@google.com>
Reported-by: Amit Klein <aksecurity@gmail.com>
Reported-by: Benny Pinkas <benny@pinkas.net>
Cc: Pavel Emelyanov <xemul@openvz.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/core/net_namespace.c,"{""sha"": ""12689ddfc24c44fe3297d1eda548811d8061670b"", ""filename"": ""include/net/net_namespace.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/355b98553789b646ed97ad801a619ff898471b92/include/net/net_namespace.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/355b98553789b646ed97ad801a619ff898471b92/include/net/net_namespace.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/net/net_namespace.h?ref=355b98553789b646ed97ad801a619ff898471b92"", ""patch"": ""@@ -59,6 +59,7 @@ struct net {\n \t\t\t\t\t\t */\n \tspinlock_t\t\trules_mod_lock;\n \n+\tu32\t\t\thash_mix;\n \tatomic64_t\t\tcookie_gen;\n \n \tstruct list_head\tlist;\t\t/* list of network namespaces */""}<_**next**_>{""sha"": ""d9b665151f3d9e916f35620141542a5a145e6123"", ""filename"": ""include/net/netns/hash.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 8, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/355b98553789b646ed97ad801a619ff898471b92/include/net/netns/hash.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/355b98553789b646ed97ad801a619ff898471b92/include/net/netns/hash.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/net/netns/hash.h?ref=355b98553789b646ed97ad801a619ff898471b92"", ""patch"": ""@@ -2,16 +2,10 @@\n #ifndef __NET_NS_HASH_H__\n #define __NET_NS_HASH_H__\n \n-#include <asm/cache.h>\n-\n-struct net;\n+#include <net/net_namespace.h>\n \n static inline u32 net_hash_mix(const struct net *net)\n {\n-#ifdef CONFIG_NET_NS\n-\treturn (u32)(((unsigned long)net) >> ilog2(sizeof(*net)));\n-#else\n-\treturn 0;\n-#endif\n+\treturn net->hash_mix;\n }\n #endif""}<_**next**_>{""sha"": ""7e6dcc6257011d8b60e132e97a0db229c39d1daf"", ""filename"": ""net/core/net_namespace.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/355b98553789b646ed97ad801a619ff898471b92/net/core/net_namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/355b98553789b646ed97ad801a619ff898471b92/net/core/net_namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/core/net_namespace.c?ref=355b98553789b646ed97ad801a619ff898471b92"", ""patch"": ""@@ -304,6 +304,7 @@ static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)\n \n \trefcount_set(&net->count, 1);\n \trefcount_set(&net->passive, 1);\n+\tget_random_bytes(&net->hash_mix, sizeof(u32));\n \tnet->dev_base_seq = 1;\n \tnet->user_ns = user_ns;\n \tidr_init(&net->netns_ids);""}","static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)
{
	/* Must be called with pernet_ops_rwsem held */
	const struct pernet_operations *ops, *saved_ops;
	int error = 0;
	LIST_HEAD(net_exit_list);
 
 	refcount_set(&net->count, 1);
 	refcount_set(&net->passive, 1);
	get_random_bytes(&net->hash_mix, sizeof(u32));
 	net->dev_base_seq = 1;
 	net->user_ns = user_ns;
 	idr_init(&net->netns_ids);
	spin_lock_init(&net->nsid_lock);
	mutex_init(&net->ipv4.ra_mutex);

	list_for_each_entry(ops, &pernet_list, list) {
		error = ops_init(ops, net);
		if (error < 0)
			goto out_undo;
	}
	down_write(&net_rwsem);
	list_add_tail_rcu(&net->list, &net_namespace_list);
	up_write(&net_rwsem);
out:
	return error;

out_undo:
	/* Walk through the list backwards calling the exit functions
	 * for the pernet modules whose init functions did not fail.
	 */
	list_add(&net->exit_list, &net_exit_list);
	saved_ops = ops;
	list_for_each_entry_continue_reverse(ops, &pernet_list, list)
		ops_exit_list(ops, &net_exit_list);

	ops = saved_ops;
	list_for_each_entry_continue_reverse(ops, &pernet_list, list)
		ops_free_list(ops, &net_exit_list);

	rcu_barrier();
	goto out;
}
","static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)
{
	/* Must be called with pernet_ops_rwsem held */
	const struct pernet_operations *ops, *saved_ops;
	int error = 0;
	LIST_HEAD(net_exit_list);
 
 	refcount_set(&net->count, 1);
 	refcount_set(&net->passive, 1);
 	net->dev_base_seq = 1;
 	net->user_ns = user_ns;
 	idr_init(&net->netns_ids);
	spin_lock_init(&net->nsid_lock);
	mutex_init(&net->ipv4.ra_mutex);

	list_for_each_entry(ops, &pernet_list, list) {
		error = ops_init(ops, net);
		if (error < 0)
			goto out_undo;
	}
	down_write(&net_rwsem);
	list_add_tail_rcu(&net->list, &net_namespace_list);
	up_write(&net_rwsem);
out:
	return error;

out_undo:
	/* Walk through the list backwards calling the exit functions
	 * for the pernet modules whose init functions did not fail.
	 */
	list_add(&net->exit_list, &net_exit_list);
	saved_ops = ops;
	list_for_each_entry_continue_reverse(ops, &pernet_list, list)
		ops_exit_list(ops, &net_exit_list);

	ops = saved_ops;
	list_for_each_entry_continue_reverse(ops, &pernet_list, list)
		ops_free_list(ops, &net_exit_list);

	rcu_barrier();
	goto out;
}
",C,"	get_random_bytes(&net->hash_mix, sizeof(u32));
",,,"@@ -304,6 +304,7 @@ static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)
 
 	refcount_set(&net->count, 1);
 	refcount_set(&net->passive, 1);
+	get_random_bytes(&net->hash_mix, sizeof(u32));
 	net->dev_base_seq = 1;
 	net->user_ns = user_ns;
 	idr_init(&net->netns_ids);",linux,355b98553789b646ed97ad801a619ff898471b92,6289d0facd9ebce4cc83e5da39e15643ee998dc5,1,"static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)
{
	/* Must be called with pernet_ops_rwsem held */
	const struct pernet_operations *ops, *saved_ops;
	int error = 0;
	LIST_HEAD(net_exit_list);
 
 	refcount_set(&net->count, 1);
 	refcount_set(&net->passive, 1);
//fix_flaw_line_below:
//	get_random_bytes(&net->hash_mix, sizeof(u32));
 	net->dev_base_seq = 1;
 	net->user_ns = user_ns;
 	idr_init(&net->netns_ids);
	spin_lock_init(&net->nsid_lock);
	mutex_init(&net->ipv4.ra_mutex);

	list_for_each_entry(ops, &pernet_list, list) {
		error = ops_init(ops, net);
		if (error < 0)
			goto out_undo;
	}
	down_write(&net_rwsem);
	list_add_tail_rcu(&net->list, &net_namespace_list);
	up_write(&net_rwsem);
out:
	return error;

out_undo:
	/* Walk through the list backwards calling the exit functions
	 * for the pernet modules whose init functions did not fail.
	 */
	list_add(&net->exit_list, &net_exit_list);
	saved_ops = ops;
	list_for_each_entry_continue_reverse(ops, &pernet_list, list)
		ops_exit_list(ops, &net_exit_list);

	ops = saved_ops;
	list_for_each_entry_continue_reverse(ops, &pernet_list, list)
		ops_free_list(ops, &net_exit_list);

	rcu_barrier();
	goto out;
}
",182887,"static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)
{
	/* Must be called with pernet_ops_rwsem held */
	const struct pernet_operations *ops, *saved_ops;
	int error = 0;
	LIST_HEAD(net_exit_list);
 
 	refcount_set(&net->count, 1);
 	refcount_set(&net->passive, 1);
 	net->dev_base_seq = 1;
 	net->user_ns = user_ns;
 	idr_init(&net->netns_ids);
	spin_lock_init(&net->nsid_lock);
	mutex_init(&net->ipv4.ra_mutex);

	list_for_each_entry(ops, &pernet_list, list) {
		error = ops_init(ops, net);
		if (error < 0)
			goto out_undo;
	}
	down_write(&net_rwsem);
	list_add_tail_rcu(&net->list, &net_namespace_list);
	up_write(&net_rwsem);
out:
	return error;

out_undo:
	/* Walk through the list backwards calling the exit functions
	 * for the pernet modules whose init functions did not fail.
	 */
	list_add(&net->exit_list, &net_exit_list);
	saved_ops = ops;
	list_for_each_entry_continue_reverse(ops, &pernet_list, list)
		ops_exit_list(ops, &net_exit_list);

	ops = saved_ops;
	list_for_each_entry_continue_reverse(ops, &pernet_list, list)
		ops_free_list(ops, &net_exit_list);

	rcu_barrier();
	goto out;
}
","static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)
{
	/* Must be called with pernet_ops_rwsem held */
	const struct pernet_operations *ops, *saved_ops;
	int error = 0;
	LIST_HEAD(net_exit_list);
 
 	refcount_set(&net->count, 1);
 	refcount_set(&net->passive, 1);
	get_random_bytes(&net->hash_mix, sizeof(u32));
 	net->dev_base_seq = 1;
 	net->user_ns = user_ns;
 	idr_init(&net->netns_ids);
	spin_lock_init(&net->nsid_lock);
	mutex_init(&net->ipv4.ra_mutex);

	list_for_each_entry(ops, &pernet_list, list) {
		error = ops_init(ops, net);
		if (error < 0)
			goto out_undo;
	}
	down_write(&net_rwsem);
	list_add_tail_rcu(&net->list, &net_namespace_list);
	up_write(&net_rwsem);
out:
	return error;

out_undo:
	/* Walk through the list backwards calling the exit functions
	 * for the pernet modules whose init functions did not fail.
	 */
	list_add(&net->exit_list, &net_exit_list);
	saved_ops = ops;
	list_for_each_entry_continue_reverse(ops, &pernet_list, list)
		ops_exit_list(ops, &net_exit_list);

	ops = saved_ops;
	list_for_each_entry_continue_reverse(ops, &pernet_list, list)
		ops_free_list(ops, &net_exit_list);

	rcu_barrier();
	goto out;
}
","The `setup_net` function initializes a network namespace structure in the Linux kernel, ensuring that it is called with the appropriate locks held. It sets initial reference counts, assigns a user namespace, and initializes various data structures related to the network namespace. The function iterates through a list of per-network operations, calling their initialization functions and handling any errors that arise. If an error occurs, it undoes the successful initializations by calling the corresponding exit functions in reverse order. Finally, it adds the new network namespace to a global list and returns the error status, if any.","The code defines a function that initializes a network namespace within the Linux kernel, ensuring proper synchronization during the process. It sets initial reference counts and prepares various data structures related to the namespace. The function iterates through a list of operations, invoking their initialization routines while managing any errors that may occur. In the event of an error, it reverses the initialization by calling the corresponding cleanup routines for successfully initialized components. Ultimately, the function adds the new namespace to a global list and returns an error code if any issues were encountered during the initialization process.","The vulnerability in the original code stemmed from using the kernel address of a network structure to generate a hash, which could potentially expose this address to attackers, thereby undermining Kernel Address Space Layout Randomization (KASLR). This risk was particularly pronounced in the initial network namespace, where the address was static and predictable. The fix introduced a call to `get_random_bytes` to populate the `hash_mix` variable with pure entropy, ensuring that the hash generation process is secure and does not rely on potentially exploitable kernel addresses. This change enhances security by providing randomness regardless of the network namespace configuration.","The vulnerability in the original code arose from using a kernel structure's address to generate a hash, which could be exploited by attackers to reveal this address, thereby compromising Kernel Address Space Layout Randomization (KASLR). This was particularly concerning in the initial network namespace, where the address was static and predictable. The fix addressed this issue by introducing a mechanism to generate pure entropy for the hash, ensuring that the process no longer relied on potentially exploitable addresses. This enhancement significantly improved security by providing randomness in hash generation, regardless of the network namespace configuration.","The vulnerability was fixed by adding a call to `get_random_bytes` to populate the `hash_mix` variable with pure entropy, replacing the previous reliance on the kernel address of a network structure for hash generation. This change ensures that the hash is generated using random data, thereby preventing attackers from deducing the kernel address and circumventing Kernel Address Space Layout Randomization (KASLR). By providing this randomness regardless of the network namespace configuration, the fix enhances the overall security of the system, making it more resilient against potential address disclosure attacks.","The vulnerability was fixed by introducing a mechanism to generate random data for hash generation, eliminating the reliance on predictable kernel addresses. This change ensures that the hash is derived from pure entropy, which prevents attackers from deducing sensitive information about the kernel's memory layout. By providing randomness in the hashing process, the fix enhances security and protects against potential address disclosure attacks, thereby reinforcing the integrity of the system's memory management and maintaining the effectiveness of security features like Kernel Address Space Layout Randomization.","5,4","5,5","4, 4","4,3"
94,94,182985,182985,,Remote,Not required,,CVE-2018-18839,https://www.cvedetails.com/cve/CVE-2018-18839/,CWE-200,Low,Partial,,,2019-06-18,5.0,** DISPUTED ** An issue was discovered in Netdata 1.10.0. Full Path Disclosure (FPD) exists via api/v1/alarms. NOTE: the vendor says *is intentional.*,2019-06-18,+Info ,8,https://github.com/netdata/netdata/commit/92327c9ec211bd1616315abcb255861b130b97ca,92327c9ec211bd1616315abcb255861b130b97ca,fixed vulnerabilities identified by red4sec.com (#4521),0,web/api/web_api_v1.c,"{""sha"": ""07a9f8069e1d3aeb46bf168b3eaad886e1ea4251"", ""filename"": ""libnetdata/url/url.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/netdata/netdata/blob/92327c9ec211bd1616315abcb255861b130b97ca/libnetdata/url/url.c"", ""raw_url"": ""https://github.com/netdata/netdata/raw/92327c9ec211bd1616315abcb255861b130b97ca/libnetdata/url/url.c"", ""contents_url"": ""https://api.github.com/repos/netdata/netdata/contents/libnetdata/url/url.c?ref=92327c9ec211bd1616315abcb255861b130b97ca"", ""patch"": ""@@ -60,7 +60,9 @@ char *url_decode_r(char *to, char *url, size_t size) {\n     while(*s && d < e) {\n         if(unlikely(*s == '%')) {\n             if(likely(s[1] && s[2])) {\n-                *d++ = from_hex(s[1]) << 4 | from_hex(s[2]);\n+                char t = from_hex(s[1]) << 4 | from_hex(s[2]);\n+                // avoid HTTP header injection\n+                *d++ = (char)((isprint(t))? t : ' ');\n                 s += 2;\n             }\n         }""}<_**next**_>{""sha"": ""1e03828e40430dfab3b4265a5df7d0a7a4bc9236"", ""filename"": ""web/api/web_api_v1.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 0, ""changes"": 17, ""blob_url"": ""https://github.com/netdata/netdata/blob/92327c9ec211bd1616315abcb255861b130b97ca/web/api/web_api_v1.c"", ""raw_url"": ""https://github.com/netdata/netdata/raw/92327c9ec211bd1616315abcb255861b130b97ca/web/api/web_api_v1.c"", ""contents_url"": ""https://api.github.com/repos/netdata/netdata/contents/web/api/web_api_v1.c?ref=92327c9ec211bd1616315abcb255861b130b97ca"", ""patch"": ""@@ -233,6 +233,15 @@ inline int web_client_api_request_v1_chart(RRDHOST *host, struct web_client *w,\n     return web_client_api_request_single_chart(host, w, url, rrd_stats_api_v1_chart);\n }\n \n+void fix_google_param(char *s) {\n+    if(unlikely(!s)) return;\n+\n+    for( ; *s ;s++) {\n+        if(!isalnum(*s) && *s != '.' && *s != '_' && *s != '-')\n+            *s = '_';\n+    }\n+}\n+\n // returns the HTTP code\n inline int web_client_api_request_v1_data(RRDHOST *host, struct web_client *w, char *url) {\n     debug(D_WEB_CLIENT, \""%llu: API v1 data with URL '%s'\"", w->id, url);\n@@ -332,6 +341,14 @@ inline int web_client_api_request_v1_data(RRDHOST *host, struct web_client *w, c\n         }\n     }\n \n+    // validate the google parameters given\n+    fix_google_param(google_out);\n+    fix_google_param(google_sig);\n+    fix_google_param(google_reqId);\n+    fix_google_param(google_version);\n+    fix_google_param(responseHandler);\n+    fix_google_param(outFileName);\n+\n     if(!chart || !*chart) {\n         buffer_sprintf(w->response.data, \""No chart id is given at the request.\"");\n         goto cleanup;""}"," inline int web_client_api_request_v1_data(RRDHOST *host, struct web_client *w, char *url) {
     debug(D_WEB_CLIENT, ""%llu: API v1 data with URL '%s'"", w->id, url);

    int ret = 400;
    BUFFER *dimensions = NULL;

    buffer_flush(w->response.data);

    char    *google_version = ""0.6"",
            *google_reqId = ""0"",
            *google_sig = ""0"",
            *google_out = ""json"",
            *responseHandler = NULL,
            *outFileName = NULL;

    time_t last_timestamp_in_data = 0, google_timestamp = 0;

    char *chart = NULL
    , *before_str = NULL
    , *after_str = NULL
    , *group_time_str = NULL
    , *points_str = NULL;

    int group = RRDR_GROUPING_AVERAGE;
    uint32_t format = DATASOURCE_JSON;
    uint32_t options = 0x00000000;

    while(url) {
        char *value = mystrsep(&url, ""?&"");
        if(!value || !*value) continue;

        char *name = mystrsep(&value, ""="");
        if(!name || !*name) continue;
        if(!value || !*value) continue;

        debug(D_WEB_CLIENT, ""%llu: API v1 data query param '%s' with value '%s'"", w->id, name, value);


        if(!strcmp(name, ""chart"")) chart = value;
        else if(!strcmp(name, ""dimension"") || !strcmp(name, ""dim"") || !strcmp(name, ""dimensions"") || !strcmp(name, ""dims"")) {
            if(!dimensions) dimensions = buffer_create(100);
            buffer_strcat(dimensions, ""|"");
            buffer_strcat(dimensions, value);
        }
        else if(!strcmp(name, ""after"")) after_str = value;
        else if(!strcmp(name, ""before"")) before_str = value;
        else if(!strcmp(name, ""points"")) points_str = value;
        else if(!strcmp(name, ""gtime"")) group_time_str = value;
        else if(!strcmp(name, ""group"")) {
            group = web_client_api_request_v1_data_group(value, RRDR_GROUPING_AVERAGE);
        }
        else if(!strcmp(name, ""format"")) {
            format = web_client_api_request_v1_data_format(value);
        }
        else if(!strcmp(name, ""options"")) {
            options |= web_client_api_request_v1_data_options(value);
        }
        else if(!strcmp(name, ""callback"")) {
            responseHandler = value;
        }
        else if(!strcmp(name, ""filename"")) {
            outFileName = value;
        }
        else if(!strcmp(name, ""tqx"")) {
            char *tqx_name, *tqx_value;

            while(value) {
                tqx_value = mystrsep(&value, "";"");
                if(!tqx_value || !*tqx_value) continue;

                tqx_name = mystrsep(&tqx_value, "":"");
                if(!tqx_name || !*tqx_name) continue;
                if(!tqx_value || !*tqx_value) continue;

                if(!strcmp(tqx_name, ""version""))
                    google_version = tqx_value;
                else if(!strcmp(tqx_name, ""reqId""))
                    google_reqId = tqx_value;
                else if(!strcmp(tqx_name, ""sig"")) {
                    google_sig = tqx_value;
                    google_timestamp = strtoul(google_sig, NULL, 0);
                }
                else if(!strcmp(tqx_name, ""out"")) {
                    google_out = tqx_value;
                    format = web_client_api_request_v1_data_google_format(google_out);
                }
                else if(!strcmp(tqx_name, ""responseHandler""))
                    responseHandler = tqx_value;
                else if(!strcmp(tqx_name, ""outFileName""))
                    outFileName = tqx_value;
            }
         }
     }
 
    // validate the google parameters given
    fix_google_param(google_out);
    fix_google_param(google_sig);
    fix_google_param(google_reqId);
    fix_google_param(google_version);
    fix_google_param(responseHandler);
    fix_google_param(outFileName);

     if(!chart || !*chart) {
         buffer_sprintf(w->response.data, ""No chart id is given at the request."");
         goto cleanup;
    }

    RRDSET *st = rrdset_find(host, chart);
    if(!st) st = rrdset_find_byname(host, chart);
    if(!st) {
        buffer_strcat(w->response.data, ""Chart is not found: "");
        buffer_strcat_htmlescape(w->response.data, chart);
        ret = 404;
        goto cleanup;
    }
    st->last_accessed_time = now_realtime_sec();

    long long before = (before_str && *before_str)?str2l(before_str):0;
    long long after  = (after_str  && *after_str) ?str2l(after_str):0;
    int       points = (points_str && *points_str)?str2i(points_str):0;
    long      group_time = (group_time_str && *group_time_str)?str2l(group_time_str):0;

    debug(D_WEB_CLIENT, ""%llu: API command 'data' for chart '%s', dimensions '%s', after '%lld', before '%lld', points '%d', group '%d', format '%u', options '0x%08x'""
          , w->id
          , chart
          , (dimensions)?buffer_tostring(dimensions):""""
          , after
          , before
          , points
          , group
          , format
          , options
    );

    if(outFileName && *outFileName) {
        buffer_sprintf(w->response.header, ""Content-Disposition: attachment; filename=\""%s\""\r\n"", outFileName);
        debug(D_WEB_CLIENT, ""%llu: generating outfilename header: '%s'"", w->id, outFileName);
    }

    if(format == DATASOURCE_DATATABLE_JSONP) {
        if(responseHandler == NULL)
            responseHandler = ""google.visualization.Query.setResponse"";

        debug(D_WEB_CLIENT_ACCESS, ""%llu: GOOGLE JSON/JSONP: version = '%s', reqId = '%s', sig = '%s', out = '%s', responseHandler = '%s', outFileName = '%s'"",
                w->id, google_version, google_reqId, google_sig, google_out, responseHandler, outFileName
        );

        buffer_sprintf(w->response.data,
                ""%s({version:'%s',reqId:'%s',status:'ok',sig:'%ld',table:"",
                responseHandler, google_version, google_reqId, st->last_updated.tv_sec);
    }
    else if(format == DATASOURCE_JSONP) {
        if(responseHandler == NULL)
            responseHandler = ""callback"";

        buffer_strcat(w->response.data, responseHandler);
        buffer_strcat(w->response.data, ""("");
    }

    ret = rrdset2anything_api_v1(st, w->response.data, dimensions, format, points, after, before, group, group_time
                                 , options, &last_timestamp_in_data);

    if(format == DATASOURCE_DATATABLE_JSONP) {
        if(google_timestamp < last_timestamp_in_data)
            buffer_strcat(w->response.data, ""});"");

        else {
            buffer_flush(w->response.data);
            buffer_sprintf(w->response.data,
                    ""%s({version:'%s',reqId:'%s',status:'error',errors:[{reason:'not_modified',message:'Data not modified'}]});"",
                    responseHandler, google_version, google_reqId);
        }
    }
    else if(format == DATASOURCE_JSONP)
        buffer_strcat(w->response.data, "");"");

    cleanup:
    buffer_free(dimensions);
    return ret;
}
"," inline int web_client_api_request_v1_data(RRDHOST *host, struct web_client *w, char *url) {
     debug(D_WEB_CLIENT, ""%llu: API v1 data with URL '%s'"", w->id, url);

    int ret = 400;
    BUFFER *dimensions = NULL;

    buffer_flush(w->response.data);

    char    *google_version = ""0.6"",
            *google_reqId = ""0"",
            *google_sig = ""0"",
            *google_out = ""json"",
            *responseHandler = NULL,
            *outFileName = NULL;

    time_t last_timestamp_in_data = 0, google_timestamp = 0;

    char *chart = NULL
    , *before_str = NULL
    , *after_str = NULL
    , *group_time_str = NULL
    , *points_str = NULL;

    int group = RRDR_GROUPING_AVERAGE;
    uint32_t format = DATASOURCE_JSON;
    uint32_t options = 0x00000000;

    while(url) {
        char *value = mystrsep(&url, ""?&"");
        if(!value || !*value) continue;

        char *name = mystrsep(&value, ""="");
        if(!name || !*name) continue;
        if(!value || !*value) continue;

        debug(D_WEB_CLIENT, ""%llu: API v1 data query param '%s' with value '%s'"", w->id, name, value);


        if(!strcmp(name, ""chart"")) chart = value;
        else if(!strcmp(name, ""dimension"") || !strcmp(name, ""dim"") || !strcmp(name, ""dimensions"") || !strcmp(name, ""dims"")) {
            if(!dimensions) dimensions = buffer_create(100);
            buffer_strcat(dimensions, ""|"");
            buffer_strcat(dimensions, value);
        }
        else if(!strcmp(name, ""after"")) after_str = value;
        else if(!strcmp(name, ""before"")) before_str = value;
        else if(!strcmp(name, ""points"")) points_str = value;
        else if(!strcmp(name, ""gtime"")) group_time_str = value;
        else if(!strcmp(name, ""group"")) {
            group = web_client_api_request_v1_data_group(value, RRDR_GROUPING_AVERAGE);
        }
        else if(!strcmp(name, ""format"")) {
            format = web_client_api_request_v1_data_format(value);
        }
        else if(!strcmp(name, ""options"")) {
            options |= web_client_api_request_v1_data_options(value);
        }
        else if(!strcmp(name, ""callback"")) {
            responseHandler = value;
        }
        else if(!strcmp(name, ""filename"")) {
            outFileName = value;
        }
        else if(!strcmp(name, ""tqx"")) {
            char *tqx_name, *tqx_value;

            while(value) {
                tqx_value = mystrsep(&value, "";"");
                if(!tqx_value || !*tqx_value) continue;

                tqx_name = mystrsep(&tqx_value, "":"");
                if(!tqx_name || !*tqx_name) continue;
                if(!tqx_value || !*tqx_value) continue;

                if(!strcmp(tqx_name, ""version""))
                    google_version = tqx_value;
                else if(!strcmp(tqx_name, ""reqId""))
                    google_reqId = tqx_value;
                else if(!strcmp(tqx_name, ""sig"")) {
                    google_sig = tqx_value;
                    google_timestamp = strtoul(google_sig, NULL, 0);
                }
                else if(!strcmp(tqx_name, ""out"")) {
                    google_out = tqx_value;
                    format = web_client_api_request_v1_data_google_format(google_out);
                }
                else if(!strcmp(tqx_name, ""responseHandler""))
                    responseHandler = tqx_value;
                else if(!strcmp(tqx_name, ""outFileName""))
                    outFileName = tqx_value;
            }
         }
     }
 
     if(!chart || !*chart) {
         buffer_sprintf(w->response.data, ""No chart id is given at the request."");
         goto cleanup;
    }

    RRDSET *st = rrdset_find(host, chart);
    if(!st) st = rrdset_find_byname(host, chart);
    if(!st) {
        buffer_strcat(w->response.data, ""Chart is not found: "");
        buffer_strcat_htmlescape(w->response.data, chart);
        ret = 404;
        goto cleanup;
    }
    st->last_accessed_time = now_realtime_sec();

    long long before = (before_str && *before_str)?str2l(before_str):0;
    long long after  = (after_str  && *after_str) ?str2l(after_str):0;
    int       points = (points_str && *points_str)?str2i(points_str):0;
    long      group_time = (group_time_str && *group_time_str)?str2l(group_time_str):0;

    debug(D_WEB_CLIENT, ""%llu: API command 'data' for chart '%s', dimensions '%s', after '%lld', before '%lld', points '%d', group '%d', format '%u', options '0x%08x'""
          , w->id
          , chart
          , (dimensions)?buffer_tostring(dimensions):""""
          , after
          , before
          , points
          , group
          , format
          , options
    );

    if(outFileName && *outFileName) {
        buffer_sprintf(w->response.header, ""Content-Disposition: attachment; filename=\""%s\""\r\n"", outFileName);
        debug(D_WEB_CLIENT, ""%llu: generating outfilename header: '%s'"", w->id, outFileName);
    }

    if(format == DATASOURCE_DATATABLE_JSONP) {
        if(responseHandler == NULL)
            responseHandler = ""google.visualization.Query.setResponse"";

        debug(D_WEB_CLIENT_ACCESS, ""%llu: GOOGLE JSON/JSONP: version = '%s', reqId = '%s', sig = '%s', out = '%s', responseHandler = '%s', outFileName = '%s'"",
                w->id, google_version, google_reqId, google_sig, google_out, responseHandler, outFileName
        );

        buffer_sprintf(w->response.data,
                ""%s({version:'%s',reqId:'%s',status:'ok',sig:'%ld',table:"",
                responseHandler, google_version, google_reqId, st->last_updated.tv_sec);
    }
    else if(format == DATASOURCE_JSONP) {
        if(responseHandler == NULL)
            responseHandler = ""callback"";

        buffer_strcat(w->response.data, responseHandler);
        buffer_strcat(w->response.data, ""("");
    }

    ret = rrdset2anything_api_v1(st, w->response.data, dimensions, format, points, after, before, group, group_time
                                 , options, &last_timestamp_in_data);

    if(format == DATASOURCE_DATATABLE_JSONP) {
        if(google_timestamp < last_timestamp_in_data)
            buffer_strcat(w->response.data, ""});"");

        else {
            buffer_flush(w->response.data);
            buffer_sprintf(w->response.data,
                    ""%s({version:'%s',reqId:'%s',status:'error',errors:[{reason:'not_modified',message:'Data not modified'}]});"",
                    responseHandler, google_version, google_reqId);
        }
    }
    else if(format == DATASOURCE_JSONP)
        buffer_strcat(w->response.data, "");"");

    cleanup:
    buffer_free(dimensions);
    return ret;
}
",C,"    // validate the google parameters given
    fix_google_param(google_out);
    fix_google_param(google_sig);
    fix_google_param(google_reqId);
    fix_google_param(google_version);
    fix_google_param(responseHandler);
    fix_google_param(outFileName);

",,,"@@ -233,6 +233,15 @@ inline int web_client_api_request_v1_chart(RRDHOST *host, struct web_client *w,
     return web_client_api_request_single_chart(host, w, url, rrd_stats_api_v1_chart);
 }
 
+void fix_google_param(char *s) {
+    if(unlikely(!s)) return;
+
+    for( ; *s ;s++) {
+        if(!isalnum(*s) && *s != '.' && *s != '_' && *s != '-')
+            *s = '_';
+    }
+}
+
 // returns the HTTP code
 inline int web_client_api_request_v1_data(RRDHOST *host, struct web_client *w, char *url) {
     debug(D_WEB_CLIENT, ""%llu: API v1 data with URL '%s'"", w->id, url);
@@ -332,6 +341,14 @@ inline int web_client_api_request_v1_data(RRDHOST *host, struct web_client *w, c
         }
     }
 
+    // validate the google parameters given
+    fix_google_param(google_out);
+    fix_google_param(google_sig);
+    fix_google_param(google_reqId);
+    fix_google_param(google_version);
+    fix_google_param(responseHandler);
+    fix_google_param(outFileName);
+
     if(!chart || !*chart) {
         buffer_sprintf(w->response.data, ""No chart id is given at the request."");
         goto cleanup;",netdata,92327c9ec211bd1616315abcb255861b130b97ca,a35bd00fbf8f2578ec0c660b532e925911191b43,1," inline int web_client_api_request_v1_data(RRDHOST *host, struct web_client *w, char *url) {
     debug(D_WEB_CLIENT, ""%llu: API v1 data with URL '%s'"", w->id, url);

    int ret = 400;
    BUFFER *dimensions = NULL;

    buffer_flush(w->response.data);

    char    *google_version = ""0.6"",
            *google_reqId = ""0"",
            *google_sig = ""0"",
            *google_out = ""json"",
            *responseHandler = NULL,
            *outFileName = NULL;

    time_t last_timestamp_in_data = 0, google_timestamp = 0;

    char *chart = NULL
    , *before_str = NULL
    , *after_str = NULL
    , *group_time_str = NULL
    , *points_str = NULL;

    int group = RRDR_GROUPING_AVERAGE;
    uint32_t format = DATASOURCE_JSON;
    uint32_t options = 0x00000000;

    while(url) {
        char *value = mystrsep(&url, ""?&"");
        if(!value || !*value) continue;

        char *name = mystrsep(&value, ""="");
        if(!name || !*name) continue;
        if(!value || !*value) continue;

        debug(D_WEB_CLIENT, ""%llu: API v1 data query param '%s' with value '%s'"", w->id, name, value);

        // name and value are now the parameters
        // they are not null and not empty

        if(!strcmp(name, ""chart"")) chart = value;
        else if(!strcmp(name, ""dimension"") || !strcmp(name, ""dim"") || !strcmp(name, ""dimensions"") || !strcmp(name, ""dims"")) {
            if(!dimensions) dimensions = buffer_create(100);
            buffer_strcat(dimensions, ""|"");
            buffer_strcat(dimensions, value);
        }
        else if(!strcmp(name, ""after"")) after_str = value;
        else if(!strcmp(name, ""before"")) before_str = value;
        else if(!strcmp(name, ""points"")) points_str = value;
        else if(!strcmp(name, ""gtime"")) group_time_str = value;
        else if(!strcmp(name, ""group"")) {
            group = web_client_api_request_v1_data_group(value, RRDR_GROUPING_AVERAGE);
        }
        else if(!strcmp(name, ""format"")) {
            format = web_client_api_request_v1_data_format(value);
        }
        else if(!strcmp(name, ""options"")) {
            options |= web_client_api_request_v1_data_options(value);
        }
        else if(!strcmp(name, ""callback"")) {
            responseHandler = value;
        }
        else if(!strcmp(name, ""filename"")) {
            outFileName = value;
        }
        else if(!strcmp(name, ""tqx"")) {
            // parse Google Visualization API options
            // https://developers.google.com/chart/interactive/docs/dev/implementing_data_source
            char *tqx_name, *tqx_value;

            while(value) {
                tqx_value = mystrsep(&value, "";"");
                if(!tqx_value || !*tqx_value) continue;

                tqx_name = mystrsep(&tqx_value, "":"");
                if(!tqx_name || !*tqx_name) continue;
                if(!tqx_value || !*tqx_value) continue;

                if(!strcmp(tqx_name, ""version""))
                    google_version = tqx_value;
                else if(!strcmp(tqx_name, ""reqId""))
                    google_reqId = tqx_value;
                else if(!strcmp(tqx_name, ""sig"")) {
                    google_sig = tqx_value;
                    google_timestamp = strtoul(google_sig, NULL, 0);
                }
                else if(!strcmp(tqx_name, ""out"")) {
                    google_out = tqx_value;
                    format = web_client_api_request_v1_data_google_format(google_out);
                }
                else if(!strcmp(tqx_name, ""responseHandler""))
                    responseHandler = tqx_value;
                else if(!strcmp(tqx_name, ""outFileName""))
                    outFileName = tqx_value;
            }
         }
     }
 
//fix_flaw_line_below:
//    // validate the google parameters given
//fix_flaw_line_below:
//    fix_google_param(google_out);
//fix_flaw_line_below:
//    fix_google_param(google_sig);
//fix_flaw_line_below:
//    fix_google_param(google_reqId);
//fix_flaw_line_below:
//    fix_google_param(google_version);
//fix_flaw_line_below:
//    fix_google_param(responseHandler);
//fix_flaw_line_below:
//    fix_google_param(outFileName);
//fix_flaw_line_below:
//
     if(!chart || !*chart) {
         buffer_sprintf(w->response.data, ""No chart id is given at the request."");
         goto cleanup;
    }

    RRDSET *st = rrdset_find(host, chart);
    if(!st) st = rrdset_find_byname(host, chart);
    if(!st) {
        buffer_strcat(w->response.data, ""Chart is not found: "");
        buffer_strcat_htmlescape(w->response.data, chart);
        ret = 404;
        goto cleanup;
    }
    st->last_accessed_time = now_realtime_sec();

    long long before = (before_str && *before_str)?str2l(before_str):0;
    long long after  = (after_str  && *after_str) ?str2l(after_str):0;
    int       points = (points_str && *points_str)?str2i(points_str):0;
    long      group_time = (group_time_str && *group_time_str)?str2l(group_time_str):0;

    debug(D_WEB_CLIENT, ""%llu: API command 'data' for chart '%s', dimensions '%s', after '%lld', before '%lld', points '%d', group '%d', format '%u', options '0x%08x'""
          , w->id
          , chart
          , (dimensions)?buffer_tostring(dimensions):""""
          , after
          , before
          , points
          , group
          , format
          , options
    );

    if(outFileName && *outFileName) {
        buffer_sprintf(w->response.header, ""Content-Disposition: attachment; filename=\""%s\""\r\n"", outFileName);
        debug(D_WEB_CLIENT, ""%llu: generating outfilename header: '%s'"", w->id, outFileName);
    }

    if(format == DATASOURCE_DATATABLE_JSONP) {
        if(responseHandler == NULL)
            responseHandler = ""google.visualization.Query.setResponse"";

        debug(D_WEB_CLIENT_ACCESS, ""%llu: GOOGLE JSON/JSONP: version = '%s', reqId = '%s', sig = '%s', out = '%s', responseHandler = '%s', outFileName = '%s'"",
                w->id, google_version, google_reqId, google_sig, google_out, responseHandler, outFileName
        );

        buffer_sprintf(w->response.data,
                ""%s({version:'%s',reqId:'%s',status:'ok',sig:'%ld',table:"",
                responseHandler, google_version, google_reqId, st->last_updated.tv_sec);
    }
    else if(format == DATASOURCE_JSONP) {
        if(responseHandler == NULL)
            responseHandler = ""callback"";

        buffer_strcat(w->response.data, responseHandler);
        buffer_strcat(w->response.data, ""("");
    }

    ret = rrdset2anything_api_v1(st, w->response.data, dimensions, format, points, after, before, group, group_time
                                 , options, &last_timestamp_in_data);

    if(format == DATASOURCE_DATATABLE_JSONP) {
        if(google_timestamp < last_timestamp_in_data)
            buffer_strcat(w->response.data, ""});"");

        else {
            // the client already has the latest data
            buffer_flush(w->response.data);
            buffer_sprintf(w->response.data,
                    ""%s({version:'%s',reqId:'%s',status:'error',errors:[{reason:'not_modified',message:'Data not modified'}]});"",
                    responseHandler, google_version, google_reqId);
        }
    }
    else if(format == DATASOURCE_JSONP)
        buffer_strcat(w->response.data, "");"");

    cleanup:
    buffer_free(dimensions);
    return ret;
}
",182985,"inline int web_client_api_request_v1_data(RRDHOST *host, struct web_client *w, char *url) {
    debug(D_WEB_CLIENT, ""%llu: API v1 data with URL '%s'"", w->id, url);

    int ret = 400;
    BUFFER *dimensions = NULL;

    buffer_flush(w->response.data);

    char    *google_version = ""0.6"",
            *google_reqId = ""0"",
            *google_sig = ""0"",
            *google_out = ""json"",
            *responseHandler = NULL,
            *outFileName = NULL;

    time_t last_timestamp_in_data = 0, google_timestamp = 0;

    char *chart = NULL
    , *before_str = NULL
    , *after_str = NULL
    , *group_time_str = NULL
    , *points_str = NULL;

    int group = RRDR_GROUPING_AVERAGE;
    uint32_t format = DATASOURCE_JSON;
    uint32_t options = 0x00000000;

    while(url) {
        char *value = mystrsep(&url, ""?&"");
        if(!value || !*value) continue;

        char *name = mystrsep(&value, ""="");
        if(!name || !*name) continue;
        if(!value || !*value) continue;

        debug(D_WEB_CLIENT, ""%llu: API v1 data query param '%s' with value '%s'"", w->id, name, value);

        // name and value are now the parameters
        // they are not null and not empty

        if(!strcmp(name, ""chart"")) chart = value;
        else if(!strcmp(name, ""dimension"") || !strcmp(name, ""dim"") || !strcmp(name, ""dimensions"") || !strcmp(name, ""dims"")) {
            if(!dimensions) dimensions = buffer_create(100);
            buffer_strcat(dimensions, ""|"");
            buffer_strcat(dimensions, value);
        }
        else if(!strcmp(name, ""after"")) after_str = value;
        else if(!strcmp(name, ""before"")) before_str = value;
        else if(!strcmp(name, ""points"")) points_str = value;
        else if(!strcmp(name, ""gtime"")) group_time_str = value;
        else if(!strcmp(name, ""group"")) {
            group = web_client_api_request_v1_data_group(value, RRDR_GROUPING_AVERAGE);
        }
        else if(!strcmp(name, ""format"")) {
            format = web_client_api_request_v1_data_format(value);
        }
        else if(!strcmp(name, ""options"")) {
            options |= web_client_api_request_v1_data_options(value);
        }
        else if(!strcmp(name, ""callback"")) {
            responseHandler = value;
        }
        else if(!strcmp(name, ""filename"")) {
            outFileName = value;
        }
        else if(!strcmp(name, ""tqx"")) {
            // parse Google Visualization API options
            // https://developers.google.com/chart/interactive/docs/dev/implementing_data_source
            char *tqx_name, *tqx_value;

            while(value) {
                tqx_value = mystrsep(&value, "";"");
                if(!tqx_value || !*tqx_value) continue;

                tqx_name = mystrsep(&tqx_value, "":"");
                if(!tqx_name || !*tqx_name) continue;
                if(!tqx_value || !*tqx_value) continue;

                if(!strcmp(tqx_name, ""version""))
                    google_version = tqx_value;
                else if(!strcmp(tqx_name, ""reqId""))
                    google_reqId = tqx_value;
                else if(!strcmp(tqx_name, ""sig"")) {
                    google_sig = tqx_value;
                    google_timestamp = strtoul(google_sig, NULL, 0);
                }
                else if(!strcmp(tqx_name, ""out"")) {
                    google_out = tqx_value;
                    format = web_client_api_request_v1_data_google_format(google_out);
                }
                else if(!strcmp(tqx_name, ""responseHandler""))
                    responseHandler = tqx_value;
                else if(!strcmp(tqx_name, ""outFileName""))
                    outFileName = tqx_value;
            }
        }
    }

    if(!chart || !*chart) {
        buffer_sprintf(w->response.data, ""No chart id is given at the request."");
        goto cleanup;
    }

    RRDSET *st = rrdset_find(host, chart);
    if(!st) st = rrdset_find_byname(host, chart);
    if(!st) {
        buffer_strcat(w->response.data, ""Chart is not found: "");
        buffer_strcat_htmlescape(w->response.data, chart);
        ret = 404;
        goto cleanup;
    }
    st->last_accessed_time = now_realtime_sec();

    long long before = (before_str && *before_str)?str2l(before_str):0;
    long long after  = (after_str  && *after_str) ?str2l(after_str):0;
    int       points = (points_str && *points_str)?str2i(points_str):0;
    long      group_time = (group_time_str && *group_time_str)?str2l(group_time_str):0;

    debug(D_WEB_CLIENT, ""%llu: API command 'data' for chart '%s', dimensions '%s', after '%lld', before '%lld', points '%d', group '%d', format '%u', options '0x%08x'""
          , w->id
          , chart
          , (dimensions)?buffer_tostring(dimensions):""""
          , after
          , before
          , points
          , group
          , format
          , options
    );

    if(outFileName && *outFileName) {
        buffer_sprintf(w->response.header, ""Content-Disposition: attachment; filename=\""%s\""\r\n"", outFileName);
        debug(D_WEB_CLIENT, ""%llu: generating outfilename header: '%s'"", w->id, outFileName);
    }

    if(format == DATASOURCE_DATATABLE_JSONP) {
        if(responseHandler == NULL)
            responseHandler = ""google.visualization.Query.setResponse"";

        debug(D_WEB_CLIENT_ACCESS, ""%llu: GOOGLE JSON/JSONP: version = '%s', reqId = '%s', sig = '%s', out = '%s', responseHandler = '%s', outFileName = '%s'"",
                w->id, google_version, google_reqId, google_sig, google_out, responseHandler, outFileName
        );

        buffer_sprintf(w->response.data,
                ""%s({version:'%s',reqId:'%s',status:'ok',sig:'%ld',table:"",
                responseHandler, google_version, google_reqId, st->last_updated.tv_sec);
    }
    else if(format == DATASOURCE_JSONP) {
        if(responseHandler == NULL)
            responseHandler = ""callback"";

        buffer_strcat(w->response.data, responseHandler);
        buffer_strcat(w->response.data, ""("");
    }

    ret = rrdset2anything_api_v1(st, w->response.data, dimensions, format, points, after, before, group, group_time
                                 , options, &last_timestamp_in_data);

    if(format == DATASOURCE_DATATABLE_JSONP) {
        if(google_timestamp < last_timestamp_in_data)
            buffer_strcat(w->response.data, ""});"");

        else {
            // the client already has the latest data
            buffer_flush(w->response.data);
            buffer_sprintf(w->response.data,
                    ""%s({version:'%s',reqId:'%s',status:'error',errors:[{reason:'not_modified',message:'Data not modified'}]});"",
                    responseHandler, google_version, google_reqId);
        }
    }
    else if(format == DATASOURCE_JSONP)
        buffer_strcat(w->response.data, "");"");

    cleanup:
    buffer_free(dimensions);
    return ret;
}"," inline int web_client_api_request_v1_data(RRDHOST *host, struct web_client *w, char *url) {
     debug(D_WEB_CLIENT, ""%llu: API v1 data with URL '%s'"", w->id, url);

    int ret = 400;
    BUFFER *dimensions = NULL;

    buffer_flush(w->response.data);

    char    *google_version = ""0.6"",
            *google_reqId = ""0"",
            *google_sig = ""0"",
            *google_out = ""json"",
            *responseHandler = NULL,
            *outFileName = NULL;

    time_t last_timestamp_in_data = 0, google_timestamp = 0;

    char *chart = NULL
    , *before_str = NULL
    , *after_str = NULL
    , *group_time_str = NULL
    , *points_str = NULL;

    int group = RRDR_GROUPING_AVERAGE;
    uint32_t format = DATASOURCE_JSON;
    uint32_t options = 0x00000000;

    while(url) {
        char *value = mystrsep(&url, ""?&"");
        if(!value || !*value) continue;

        char *name = mystrsep(&value, ""="");
        if(!name || !*name) continue;
        if(!value || !*value) continue;

        debug(D_WEB_CLIENT, ""%llu: API v1 data query param '%s' with value '%s'"", w->id, name, value);


        if(!strcmp(name, ""chart"")) chart = value;
        else if(!strcmp(name, ""dimension"") || !strcmp(name, ""dim"") || !strcmp(name, ""dimensions"") || !strcmp(name, ""dims"")) {
            if(!dimensions) dimensions = buffer_create(100);
            buffer_strcat(dimensions, ""|"");
            buffer_strcat(dimensions, value);
        }
        else if(!strcmp(name, ""after"")) after_str = value;
        else if(!strcmp(name, ""before"")) before_str = value;
        else if(!strcmp(name, ""points"")) points_str = value;
        else if(!strcmp(name, ""gtime"")) group_time_str = value;
        else if(!strcmp(name, ""group"")) {
            group = web_client_api_request_v1_data_group(value, RRDR_GROUPING_AVERAGE);
        }
        else if(!strcmp(name, ""format"")) {
            format = web_client_api_request_v1_data_format(value);
        }
        else if(!strcmp(name, ""options"")) {
            options |= web_client_api_request_v1_data_options(value);
        }
        else if(!strcmp(name, ""callback"")) {
            responseHandler = value;
        }
        else if(!strcmp(name, ""filename"")) {
            outFileName = value;
        }
        else if(!strcmp(name, ""tqx"")) {
            char *tqx_name, *tqx_value;

            while(value) {
                tqx_value = mystrsep(&value, "";"");
                if(!tqx_value || !*tqx_value) continue;

                tqx_name = mystrsep(&tqx_value, "":"");
                if(!tqx_name || !*tqx_name) continue;
                if(!tqx_value || !*tqx_value) continue;

                if(!strcmp(tqx_name, ""version""))
                    google_version = tqx_value;
                else if(!strcmp(tqx_name, ""reqId""))
                    google_reqId = tqx_value;
                else if(!strcmp(tqx_name, ""sig"")) {
                    google_sig = tqx_value;
                    google_timestamp = strtoul(google_sig, NULL, 0);
                }
                else if(!strcmp(tqx_name, ""out"")) {
                    google_out = tqx_value;
                    format = web_client_api_request_v1_data_google_format(google_out);
                }
                else if(!strcmp(tqx_name, ""responseHandler""))
                    responseHandler = tqx_value;
                else if(!strcmp(tqx_name, ""outFileName""))
                    outFileName = tqx_value;
            }
         }
     }
 
    // validate the google parameters given
    fix_google_param(google_out);
    fix_google_param(google_sig);
    fix_google_param(google_reqId);
    fix_google_param(google_version);
    fix_google_param(responseHandler);
    fix_google_param(outFileName);

     if(!chart || !*chart) {
         buffer_sprintf(w->response.data, ""No chart id is given at the request."");
         goto cleanup;
    }

    RRDSET *st = rrdset_find(host, chart);
    if(!st) st = rrdset_find_byname(host, chart);
    if(!st) {
        buffer_strcat(w->response.data, ""Chart is not found: "");
        buffer_strcat_htmlescape(w->response.data, chart);
        ret = 404;
        goto cleanup;
    }
    st->last_accessed_time = now_realtime_sec();

    long long before = (before_str && *before_str)?str2l(before_str):0;
    long long after  = (after_str  && *after_str) ?str2l(after_str):0;
    int       points = (points_str && *points_str)?str2i(points_str):0;
    long      group_time = (group_time_str && *group_time_str)?str2l(group_time_str):0;

    debug(D_WEB_CLIENT, ""%llu: API command 'data' for chart '%s', dimensions '%s', after '%lld', before '%lld', points '%d', group '%d', format '%u', options '0x%08x'""
          , w->id
          , chart
          , (dimensions)?buffer_tostring(dimensions):""""
          , after
          , before
          , points
          , group
          , format
          , options
    );

    if(outFileName && *outFileName) {
        buffer_sprintf(w->response.header, ""Content-Disposition: attachment; filename=\""%s\""\r\n"", outFileName);
        debug(D_WEB_CLIENT, ""%llu: generating outfilename header: '%s'"", w->id, outFileName);
    }

    if(format == DATASOURCE_DATATABLE_JSONP) {
        if(responseHandler == NULL)
            responseHandler = ""google.visualization.Query.setResponse"";

        debug(D_WEB_CLIENT_ACCESS, ""%llu: GOOGLE JSON/JSONP: version = '%s', reqId = '%s', sig = '%s', out = '%s', responseHandler = '%s', outFileName = '%s'"",
                w->id, google_version, google_reqId, google_sig, google_out, responseHandler, outFileName
        );

        buffer_sprintf(w->response.data,
                ""%s({version:'%s',reqId:'%s',status:'ok',sig:'%ld',table:"",
                responseHandler, google_version, google_reqId, st->last_updated.tv_sec);
    }
    else if(format == DATASOURCE_JSONP) {
        if(responseHandler == NULL)
            responseHandler = ""callback"";

        buffer_strcat(w->response.data, responseHandler);
        buffer_strcat(w->response.data, ""("");
    }

    ret = rrdset2anything_api_v1(st, w->response.data, dimensions, format, points, after, before, group, group_time
                                 , options, &last_timestamp_in_data);

    if(format == DATASOURCE_DATATABLE_JSONP) {
        if(google_timestamp < last_timestamp_in_data)
            buffer_strcat(w->response.data, ""});"");

        else {
            buffer_flush(w->response.data);
            buffer_sprintf(w->response.data,
                    ""%s({version:'%s',reqId:'%s',status:'error',errors:[{reason:'not_modified',message:'Data not modified'}]});"",
                    responseHandler, google_version, google_reqId);
        }
    }
    else if(format == DATASOURCE_JSONP)
        buffer_strcat(w->response.data, "");"");

    cleanup:
    buffer_free(dimensions);
    return ret;
}
","The provided code defines a function that processes API requests for data retrieval from a web client, specifically targeting version 1 of an API. It begins by parsing the URL for various parameters such as chart ID, dimensions, time constraints, and output format. The function validates the presence of a chart and retrieves the corresponding data set. It constructs a response based on the specified format, which can include JSON or JSONP, and handles optional parameters for file output and Google Visualization API specifics. Finally, it returns an HTTP status code indicating the success or failure of the request while managing memory for any allocated buffers.","The code implements a function that handles API requests for retrieving data from a web client. It begins by parsing a provided URL to extract various parameters related to the data request, such as chart identification, dimensions, time constraints, and output format. The function checks for the existence of the specified chart and retrieves the corresponding data set. It constructs a response in the requested format, which may include JSON or JSONP, and manages optional parameters for file output. Finally, it returns an appropriate HTTP status code to indicate the outcome of the request while ensuring proper memory management.","The vulnerability in the original code stemmed from the lack of validation for user-supplied parameters, such as the Google parameters, which could lead to injection attacks or unexpected behavior. Specifically, parameters like `google_out`, `google_sig`, `google_reqId`, `google_version`, `responseHandler`, and `outFileName` were directly used without sanitization. The fix introduced a validation step by calling a function to sanitize these parameters before they were utilized, ensuring that any potentially harmful input was properly handled. This change mitigated the risk of injection attacks and improved the overall security of the API request handling.","The vulnerability in the original code arose from the absence of validation for user-supplied parameters, which could allow for injection attacks or manipulation of the API's behavior. This lack of sanitization meant that potentially harmful input could be processed without checks, leading to security risks. The fix implemented a validation mechanism that sanitizes these parameters before they are used, ensuring that any malicious or unexpected input is properly handled. This change significantly enhanced the security of the API request handling by preventing the exploitation of the vulnerabilities identified in the original code.","The vulnerability was fixed by introducing a validation step for user-supplied parameters immediately after they were parsed. The code now calls the `fix_google_param` function for each of the parameters, including `google_out`, `google_sig`, `google_reqId`, `google_version`, `responseHandler`, and `outFileName`. This function sanitizes the input, ensuring that any potentially harmful characters or patterns are removed or neutralized before the parameters are used in further processing. By implementing this validation, the code mitigates the risk of injection attacks and enhances the overall security of the API request handling.","The vulnerability was addressed by adding a validation mechanism that sanitizes user-supplied parameters immediately after they are extracted from the input. This new step ensures that any potentially harmful or malicious content is filtered out before the parameters are utilized in the processing logic. By implementing this sanitization process, the code effectively reduces the risk of injection attacks and other security issues that could arise from unvalidated input. This enhancement significantly improves the overall security posture of the application by ensuring that only safe and expected data is processed.","4, 4","3,3","3,4","4,4"
95,95,183068,183068,,Local,Not required,,CVE-2012-6546,https://www.cvedetails.com/cve/CVE-2012-6546/,CWE-200,Medium,Partial,,,2013-03-15,1.9,"The ATM implementation in the Linux kernel before 3.6 does not initialize certain structures, which allows local users to obtain sensitive information from kernel stack memory via a crafted application.",2019-04-22,+Info ,1,https://github.com/torvalds/linux/commit/3c0c5cfdcd4d69ffc4b9c0907cec99039f30a50a,3c0c5cfdcd4d69ffc4b9c0907cec99039f30a50a,"atm: fix info leak via getsockname()

The ATM code fails to initialize the two padding bytes of struct
sockaddr_atmpvc inserted for alignment. Add an explicit memset(0)
before filling the structure to avoid the info leak.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/atm/pvc.c,"{""sha"": ""ae0324021407c2b61aaf7c45a39bebb9d419972c"", ""filename"": ""net/atm/pvc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/3c0c5cfdcd4d69ffc4b9c0907cec99039f30a50a/net/atm/pvc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/3c0c5cfdcd4d69ffc4b9c0907cec99039f30a50a/net/atm/pvc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/atm/pvc.c?ref=3c0c5cfdcd4d69ffc4b9c0907cec99039f30a50a"", ""patch"": ""@@ -95,6 +95,7 @@ static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,\n \t\treturn -ENOTCONN;\n \t*sockaddr_len = sizeof(struct sockaddr_atmpvc);\n \taddr = (struct sockaddr_atmpvc *)sockaddr;\n+\tmemset(addr, 0, sizeof(*addr));\n \taddr->sap_family = AF_ATMPVC;\n \taddr->sap_addr.itf = vcc->dev->number;\n \taddr->sap_addr.vpi = vcc->vpi;""}","static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,
		       int *sockaddr_len, int peer)
{
	struct sockaddr_atmpvc *addr;
	struct atm_vcc *vcc = ATM_SD(sock);

	if (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))
 		return -ENOTCONN;
 	*sockaddr_len = sizeof(struct sockaddr_atmpvc);
 	addr = (struct sockaddr_atmpvc *)sockaddr;
	memset(addr, 0, sizeof(*addr));
 	addr->sap_family = AF_ATMPVC;
 	addr->sap_addr.itf = vcc->dev->number;
 	addr->sap_addr.vpi = vcc->vpi;
	addr->sap_addr.vci = vcc->vci;
	return 0;
}
","static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,
		       int *sockaddr_len, int peer)
{
	struct sockaddr_atmpvc *addr;
	struct atm_vcc *vcc = ATM_SD(sock);

	if (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))
 		return -ENOTCONN;
 	*sockaddr_len = sizeof(struct sockaddr_atmpvc);
 	addr = (struct sockaddr_atmpvc *)sockaddr;
 	addr->sap_family = AF_ATMPVC;
 	addr->sap_addr.itf = vcc->dev->number;
 	addr->sap_addr.vpi = vcc->vpi;
	addr->sap_addr.vci = vcc->vci;
	return 0;
}
",C,"	memset(addr, 0, sizeof(*addr));
",,,"@@ -95,6 +95,7 @@ static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,
 		return -ENOTCONN;
 	*sockaddr_len = sizeof(struct sockaddr_atmpvc);
 	addr = (struct sockaddr_atmpvc *)sockaddr;
+	memset(addr, 0, sizeof(*addr));
 	addr->sap_family = AF_ATMPVC;
 	addr->sap_addr.itf = vcc->dev->number;
 	addr->sap_addr.vpi = vcc->vpi;",linux,3c0c5cfdcd4d69ffc4b9c0907cec99039f30a50a,e862f1a9b7df4e8196ebec45ac62295138aa3fc2,1,"static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,
		       int *sockaddr_len, int peer)
{
	struct sockaddr_atmpvc *addr;
	struct atm_vcc *vcc = ATM_SD(sock);

	if (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))
 		return -ENOTCONN;
 	*sockaddr_len = sizeof(struct sockaddr_atmpvc);
 	addr = (struct sockaddr_atmpvc *)sockaddr;
//fix_flaw_line_below:
//	memset(addr, 0, sizeof(*addr));
 	addr->sap_family = AF_ATMPVC;
 	addr->sap_addr.itf = vcc->dev->number;
 	addr->sap_addr.vpi = vcc->vpi;
	addr->sap_addr.vci = vcc->vci;
	return 0;
}
",183068,"static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,
		       int *sockaddr_len, int peer)
{
	struct sockaddr_atmpvc *addr;
	struct atm_vcc *vcc = ATM_SD(sock);

	if (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))
 		return -ENOTCONN;
 	*sockaddr_len = sizeof(struct sockaddr_atmpvc);
 	addr = (struct sockaddr_atmpvc *)sockaddr;
 	addr->sap_family = AF_ATMPVC;
 	addr->sap_addr.itf = vcc->dev->number;
 	addr->sap_addr.vpi = vcc->vpi;
	addr->sap_addr.vci = vcc->vci;
	return 0;
}
","static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,
		       int *sockaddr_len, int peer)
{
	struct sockaddr_atmpvc *addr;
	struct atm_vcc *vcc = ATM_SD(sock);

	if (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))
 		return -ENOTCONN;
 	*sockaddr_len = sizeof(struct sockaddr_atmpvc);
 	addr = (struct sockaddr_atmpvc *)sockaddr;
	memset(addr, 0, sizeof(*addr));
 	addr->sap_family = AF_ATMPVC;
 	addr->sap_addr.itf = vcc->dev->number;
 	addr->sap_addr.vpi = vcc->vpi;
	addr->sap_addr.vci = vcc->vci;
	return 0;
}
","The `pvc_getname` function retrieves the address information associated with a given ATM (Asynchronous Transfer Mode) virtual circuit connection represented by a socket. It first checks if the virtual circuit control block (`vcc`) is valid and connected; if not, it returns an error. If valid, it populates a `sockaddr_atmpvc` structure with the address family, interface number, and virtual path identifier (VPI) and virtual channel identifier (VCI) from the `vcc`. The function sets the length of the address structure and returns zero to indicate success, allowing the caller to access the ATM PVC address details.","The provided code defines a function that retrieves and populates address information for an ATM virtual circuit connection associated with a socket. It first checks the validity and connection status of the virtual circuit; if the connection is not established, it returns an error. Upon successful validation, the function fills a specific address structure with details such as the address family, interface number, and identifiers for the virtual path and channel. It also sets the length of the address structure before returning a success indicator, enabling the caller to access the relevant ATM connection details.","The vulnerability in the original code arises from the failure to initialize the padding bytes in the `sockaddr_atmpvc` structure, which could lead to an information leak by exposing uninitialized memory contents. This occurs because the structure is directly populated without clearing its memory first. The fix implemented in the changed code involves adding a `memset(addr, 0, sizeof(*addr));` line before populating the structure. This ensures that all bytes, including the padding, are set to zero, thereby preventing any sensitive or unintended data from being exposed when the address structure is returned.","The vulnerability in the original code stems from not initializing the padding bytes in a specific structure, which could inadvertently expose uninitialized memory contents, leading to potential information leaks. This oversight allows sensitive data from previous operations to be returned when the structure is accessed. The fix implemented in the updated code involves explicitly clearing the entire structure's memory before populating it with valid data. By ensuring that all bytes, including the padding, are set to zero, the risk of leaking unintended information is mitigated, thereby enhancing the security of the code.","The vulnerability was fixed by adding a `memset(addr, 0, sizeof(*addr));` line before populating the `sockaddr_atmpvc` structure in the updated code. This explicit memory initialization ensures that all bytes of the structure, including the padding bytes that were previously uninitialized, are set to zero. By doing this, the code prevents any leakage of sensitive or unintended data that could have been present in those padding bytes. Consequently, when the structure is returned, it contains only the intended values, thereby enhancing the security and integrity of the information being provided.","The vulnerability was addressed by incorporating a memory-clearing operation before populating the structure with valid data. This addition ensures that all bytes within the structure, including any padding, are initialized to zero. By explicitly setting the memory to a known state, the risk of exposing uninitialized or sensitive data is eliminated. As a result, when the structure is accessed later, it contains only the intended values, thereby preventing any potential information leaks and enhancing the overall security of the code. This fix effectively safeguards against unintended data exposure in the application.","5,4","5,4","4,3","5,5"
96,96,183070,183070,,Local,Not required,,CVE-2012-6545,https://www.cvedetails.com/cve/CVE-2012-6545/,CWE-200,Medium,Partial,,,2013-03-15,1.9,"The Bluetooth RFCOMM implementation in the Linux kernel before 3.6 does not properly initialize certain structures, which allows local users to obtain sensitive information from kernel memory via a crafted application.",2019-04-22,+Info ,1,https://github.com/torvalds/linux/commit/f9432c5ec8b1e9a09b9b0e5569e3c73db8de432a,f9432c5ec8b1e9a09b9b0e5569e3c73db8de432a,"Bluetooth: RFCOMM - Fix info leak in ioctl(RFCOMMGETDEVLIST)

The RFCOMM code fails to initialize the two padding bytes of struct
rfcomm_dev_list_req inserted for alignment before copying it to
userland. Additionally there are two padding bytes in each instance of
struct rfcomm_dev_info. The ioctl() that for disclosures two bytes plus
dev_num times two bytes uninitialized kernel heap memory.

Allocate the memory using kzalloc() to fix this issue.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Marcel Holtmann <marcel@holtmann.org>
Cc: Gustavo Padovan <gustavo@padovan.org>
Cc: Johan Hedberg <johan.hedberg@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/bluetooth/rfcomm/tty.c,"{""sha"": ""56f182393c4c7d278a391c1cbf0cccc7ed4424e3"", ""filename"": ""net/bluetooth/rfcomm/tty.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/f9432c5ec8b1e9a09b9b0e5569e3c73db8de432a/net/bluetooth/rfcomm/tty.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f9432c5ec8b1e9a09b9b0e5569e3c73db8de432a/net/bluetooth/rfcomm/tty.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/bluetooth/rfcomm/tty.c?ref=f9432c5ec8b1e9a09b9b0e5569e3c73db8de432a"", ""patch"": ""@@ -456,7 +456,7 @@ static int rfcomm_get_dev_list(void __user *arg)\n \n \tsize = sizeof(*dl) + dev_num * sizeof(*di);\n \n-\tdl = kmalloc(size, GFP_KERNEL);\n+\tdl = kzalloc(size, GFP_KERNEL);\n \tif (!dl)\n \t\treturn -ENOMEM;\n ""}","static int rfcomm_get_dev_list(void __user *arg)
{
	struct rfcomm_dev *dev;
	struct rfcomm_dev_list_req *dl;
	struct rfcomm_dev_info *di;
	int n = 0, size, err;
	u16 dev_num;

	BT_DBG("""");

	if (get_user(dev_num, (u16 __user *) arg))
		return -EFAULT;

	if (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))
		return -EINVAL;
 
 	size = sizeof(*dl) + dev_num * sizeof(*di);
 
	dl = kzalloc(size, GFP_KERNEL);
 	if (!dl)
 		return -ENOMEM;
 
	di = dl->dev_info;

	spin_lock(&rfcomm_dev_lock);

	list_for_each_entry(dev, &rfcomm_dev_list, list) {
		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
			continue;
		(di + n)->id      = dev->id;
		(di + n)->flags   = dev->flags;
		(di + n)->state   = dev->dlc->state;
		(di + n)->channel = dev->channel;
		bacpy(&(di + n)->src, &dev->src);
		bacpy(&(di + n)->dst, &dev->dst);
		if (++n >= dev_num)
			break;
	}

	spin_unlock(&rfcomm_dev_lock);

	dl->dev_num = n;
	size = sizeof(*dl) + n * sizeof(*di);

	err = copy_to_user(arg, dl, size);
	kfree(dl);

	return err ? -EFAULT : 0;
}
","static int rfcomm_get_dev_list(void __user *arg)
{
	struct rfcomm_dev *dev;
	struct rfcomm_dev_list_req *dl;
	struct rfcomm_dev_info *di;
	int n = 0, size, err;
	u16 dev_num;

	BT_DBG("""");

	if (get_user(dev_num, (u16 __user *) arg))
		return -EFAULT;

	if (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))
		return -EINVAL;
 
 	size = sizeof(*dl) + dev_num * sizeof(*di);
 
	dl = kmalloc(size, GFP_KERNEL);
 	if (!dl)
 		return -ENOMEM;
 
	di = dl->dev_info;

	spin_lock(&rfcomm_dev_lock);

	list_for_each_entry(dev, &rfcomm_dev_list, list) {
		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
			continue;
		(di + n)->id      = dev->id;
		(di + n)->flags   = dev->flags;
		(di + n)->state   = dev->dlc->state;
		(di + n)->channel = dev->channel;
		bacpy(&(di + n)->src, &dev->src);
		bacpy(&(di + n)->dst, &dev->dst);
		if (++n >= dev_num)
			break;
	}

	spin_unlock(&rfcomm_dev_lock);

	dl->dev_num = n;
	size = sizeof(*dl) + n * sizeof(*di);

	err = copy_to_user(arg, dl, size);
	kfree(dl);

	return err ? -EFAULT : 0;
}
",C,"	dl = kzalloc(size, GFP_KERNEL);
","	dl = kmalloc(size, GFP_KERNEL);
",,"@@ -456,7 +456,7 @@ static int rfcomm_get_dev_list(void __user *arg)
 
 	size = sizeof(*dl) + dev_num * sizeof(*di);
 
-	dl = kmalloc(size, GFP_KERNEL);
+	dl = kzalloc(size, GFP_KERNEL);
 	if (!dl)
 		return -ENOMEM;
 ",linux,f9432c5ec8b1e9a09b9b0e5569e3c73db8de432a,9ad2de43f1aee7e7274a4e0d41465489299e344b,1,"static int rfcomm_get_dev_list(void __user *arg)
{
	struct rfcomm_dev *dev;
	struct rfcomm_dev_list_req *dl;
	struct rfcomm_dev_info *di;
	int n = 0, size, err;
	u16 dev_num;

	BT_DBG("""");

	if (get_user(dev_num, (u16 __user *) arg))
		return -EFAULT;

	if (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))
		return -EINVAL;
 
 	size = sizeof(*dl) + dev_num * sizeof(*di);
 
//flaw_line_below:
	dl = kmalloc(size, GFP_KERNEL);
//fix_flaw_line_below:
//	dl = kzalloc(size, GFP_KERNEL);
 	if (!dl)
 		return -ENOMEM;
 
	di = dl->dev_info;

	spin_lock(&rfcomm_dev_lock);

	list_for_each_entry(dev, &rfcomm_dev_list, list) {
		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
			continue;
		(di + n)->id      = dev->id;
		(di + n)->flags   = dev->flags;
		(di + n)->state   = dev->dlc->state;
		(di + n)->channel = dev->channel;
		bacpy(&(di + n)->src, &dev->src);
		bacpy(&(di + n)->dst, &dev->dst);
		if (++n >= dev_num)
			break;
	}

	spin_unlock(&rfcomm_dev_lock);

	dl->dev_num = n;
	size = sizeof(*dl) + n * sizeof(*di);

	err = copy_to_user(arg, dl, size);
	kfree(dl);

	return err ? -EFAULT : 0;
}
",183070,"static int rfcomm_get_dev_list(void __user *arg)
{
	struct rfcomm_dev *dev;
	struct rfcomm_dev_list_req *dl;
	struct rfcomm_dev_info *di;
	int n = 0, size, err;
	u16 dev_num;

	BT_DBG("""");

	if (get_user(dev_num, (u16 __user *) arg))
		return -EFAULT;

	if (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))
		return -EINVAL;
 
 	size = sizeof(*dl) + dev_num * sizeof(*di);
 
	dl = kmalloc(size, GFP_KERNEL);
 	if (!dl)
 		return -ENOMEM;
 
	di = dl->dev_info;

	spin_lock(&rfcomm_dev_lock);

	list_for_each_entry(dev, &rfcomm_dev_list, list) {
		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
			continue;
		(di + n)->id      = dev->id;
		(di + n)->flags   = dev->flags;
		(di + n)->state   = dev->dlc->state;
		(di + n)->channel = dev->channel;
		bacpy(&(di + n)->src, &dev->src);
		bacpy(&(di + n)->dst, &dev->dst);
		if (++n >= dev_num)
			break;
	}

	spin_unlock(&rfcomm_dev_lock);

	dl->dev_num = n;
	size = sizeof(*dl) + n * sizeof(*di);

	err = copy_to_user(arg, dl, size);
	kfree(dl);

	return err ? -EFAULT : 0;
}
","static int rfcomm_get_dev_list(void __user *arg)
{
	struct rfcomm_dev *dev;
	struct rfcomm_dev_list_req *dl;
	struct rfcomm_dev_info *di;
	int n = 0, size, err;
	u16 dev_num;

	BT_DBG("""");

	if (get_user(dev_num, (u16 __user *) arg))
		return -EFAULT;

	if (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))
		return -EINVAL;
 
 	size = sizeof(*dl) + dev_num * sizeof(*di);
 
	dl = kzalloc(size, GFP_KERNEL);
 	if (!dl)
 		return -ENOMEM;
 
	di = dl->dev_info;

	spin_lock(&rfcomm_dev_lock);

	list_for_each_entry(dev, &rfcomm_dev_list, list) {
		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
			continue;
		(di + n)->id      = dev->id;
		(di + n)->flags   = dev->flags;
		(di + n)->state   = dev->dlc->state;
		(di + n)->channel = dev->channel;
		bacpy(&(di + n)->src, &dev->src);
		bacpy(&(di + n)->dst, &dev->dst);
		if (++n >= dev_num)
			break;
	}

	spin_unlock(&rfcomm_dev_lock);

	dl->dev_num = n;
	size = sizeof(*dl) + n * sizeof(*di);

	err = copy_to_user(arg, dl, size);
	kfree(dl);

	return err ? -EFAULT : 0;
}
","The `rfcomm_get_dev_list` function retrieves a list of RFCOMM devices and their associated information for user-space access. It first checks the validity of the requested number of devices and allocates memory for the device list. The function then locks the device list to safely iterate through it, collecting details such as device ID, flags, state, channel, and source/destination addresses for each active device. After populating the list, it unlocks the device list, copies the data back to user space, and frees the allocated memory. Finally, it returns an error code if the copy operation fails or zero on success.","The code defines a function that retrieves a list of active devices and their details for user-space access. It begins by validating the requested number of devices and allocating memory for the device list. The function then locks the device list to ensure safe access while iterating through it, collecting information such as device identifiers, status flags, connection states, and communication channels. After populating the list, it unlocks the device list, copies the collected data back to user space, and releases the allocated memory. Finally, it returns an error code if the data transfer fails or indicates success otherwise.","The vulnerability in the original code stemmed from failing to initialize padding bytes in the structure used to transfer device information to user space, which could lead to an information leak of uninitialized kernel heap memory. Specifically, the padding bytes in both the `rfcomm_dev_list_req` and `rfcomm_dev_info` structures were not set, allowing potentially sensitive data to be exposed. The fix involved replacing the memory allocation function with `kzalloc`, which initializes the allocated memory to zero, ensuring that all bytes, including padding, are properly set before copying the data to user space, thus preventing any information leakage.","The vulnerability in the original code was due to uninitialized padding bytes in the structures used for transferring device information to user space, which could inadvertently expose sensitive data from the kernel's memory. Specifically, the lack of initialization allowed uninitialized memory content to be copied, leading to potential information leaks. The fix involved using a memory allocation method that initializes all bytes to zero, ensuring that both the padding and the actual data are properly set before being sent to user space. This change effectively mitigated the risk of leaking uninitialized memory contents.","The vulnerability was fixed by replacing the memory allocation function from `kmalloc` to `kzalloc` for the `dl` variable, which is responsible for holding the device list request structure. Unlike `kmalloc`, which allocates memory without initializing it, `kzalloc` initializes all allocated memory to zero, ensuring that any padding bytes in the `rfcomm_dev_list_req` and `rfcomm_dev_info` structures are set to a known value. This change prevents the exposure of uninitialized kernel heap memory when the data is copied to user space, thereby eliminating the risk of information leakage.","The vulnerability was addressed by changing the memory allocation method to one that initializes all allocated memory to zero. This ensured that any padding bytes within the structures used for transferring data to user space were properly set, preventing the exposure of uninitialized memory contents. By ensuring that all bytes, including those that could potentially contain sensitive information, were initialized, the risk of leaking uninitialized kernel memory was effectively mitigated. This fix enhances the security of the data transfer process by ensuring that only valid, initialized data is sent to user space.","5,5","5,5","5,5","5,5"
97,97,183071,183071,,Local,Not required,,CVE-2012-6544,https://www.cvedetails.com/cve/CVE-2012-6544/,CWE-200,Medium,Partial,,,2013-03-15,1.9,"The Bluetooth protocol stack in the Linux kernel before 3.6 does not properly initialize certain structures, which allows local users to obtain sensitive information from kernel stack memory via a crafted application that targets the (1) L2CAP or (2) HCI implementation.",2019-04-22,+Info ,1,https://github.com/torvalds/linux/commit/792039c73cf176c8e39a6e8beef2c94ff46522ed,792039c73cf176c8e39a6e8beef2c94ff46522ed,"Bluetooth: L2CAP - Fix info leak via getsockname()

The L2CAP code fails to initialize the l2_bdaddr_type member of struct
sockaddr_l2 and the padding byte added for alignment. It that for leaks
two bytes kernel stack via the getsockname() syscall. Add an explicit
memset(0) before filling the structure to avoid the info leak.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Marcel Holtmann <marcel@holtmann.org>
Cc: Gustavo Padovan <gustavo@padovan.org>
Cc: Johan Hedberg <johan.hedberg@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/bluetooth/l2cap_sock.c,"{""sha"": ""1497edd191a2e04ee3121624db92547059f24369"", ""filename"": ""net/bluetooth/l2cap_sock.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/792039c73cf176c8e39a6e8beef2c94ff46522ed/net/bluetooth/l2cap_sock.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/792039c73cf176c8e39a6e8beef2c94ff46522ed/net/bluetooth/l2cap_sock.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/bluetooth/l2cap_sock.c?ref=792039c73cf176c8e39a6e8beef2c94ff46522ed"", ""patch"": ""@@ -245,6 +245,7 @@ static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *l\n \n \tBT_DBG(\""sock %p, sk %p\"", sock, sk);\n \n+\tmemset(la, 0, sizeof(struct sockaddr_l2));\n \taddr->sa_family = AF_BLUETOOTH;\n \t*len = sizeof(struct sockaddr_l2);\n ""}","static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)
{
	struct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;
	struct sock *sk = sock->sk;
	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 
 	BT_DBG(""sock %p, sk %p"", sock, sk);
 
	memset(la, 0, sizeof(struct sockaddr_l2));
 	addr->sa_family = AF_BLUETOOTH;
 	*len = sizeof(struct sockaddr_l2);
 
	if (peer) {
		la->l2_psm = chan->psm;
		bacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);
		la->l2_cid = cpu_to_le16(chan->dcid);
	} else {
		la->l2_psm = chan->sport;
		bacpy(&la->l2_bdaddr, &bt_sk(sk)->src);
		la->l2_cid = cpu_to_le16(chan->scid);
	}

	return 0;
}
","static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)
{
	struct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;
	struct sock *sk = sock->sk;
	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 
 	BT_DBG(""sock %p, sk %p"", sock, sk);
 
 	addr->sa_family = AF_BLUETOOTH;
 	*len = sizeof(struct sockaddr_l2);
 
	if (peer) {
		la->l2_psm = chan->psm;
		bacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);
		la->l2_cid = cpu_to_le16(chan->dcid);
	} else {
		la->l2_psm = chan->sport;
		bacpy(&la->l2_bdaddr, &bt_sk(sk)->src);
		la->l2_cid = cpu_to_le16(chan->scid);
	}

	return 0;
}
",C,"	memset(la, 0, sizeof(struct sockaddr_l2));
",,,"@@ -245,6 +245,7 @@ static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *l
 
 	BT_DBG(""sock %p, sk %p"", sock, sk);
 
+	memset(la, 0, sizeof(struct sockaddr_l2));
 	addr->sa_family = AF_BLUETOOTH;
 	*len = sizeof(struct sockaddr_l2);
 ",linux,792039c73cf176c8e39a6e8beef2c94ff46522ed,9344a972961d1a6d2c04d9008b13617bcb6ec2ef,1,"static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)
{
	struct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;
	struct sock *sk = sock->sk;
	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 
 	BT_DBG(""sock %p, sk %p"", sock, sk);
 
//fix_flaw_line_below:
//	memset(la, 0, sizeof(struct sockaddr_l2));
 	addr->sa_family = AF_BLUETOOTH;
 	*len = sizeof(struct sockaddr_l2);
 
	if (peer) {
		la->l2_psm = chan->psm;
		bacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);
		la->l2_cid = cpu_to_le16(chan->dcid);
	} else {
		la->l2_psm = chan->sport;
		bacpy(&la->l2_bdaddr, &bt_sk(sk)->src);
		la->l2_cid = cpu_to_le16(chan->scid);
	}

	return 0;
}
",183071,"static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)
{
	struct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;
	struct sock *sk = sock->sk;
	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 
 	BT_DBG(""sock %p, sk %p"", sock, sk);
 
 	addr->sa_family = AF_BLUETOOTH;
 	*len = sizeof(struct sockaddr_l2);
 
	if (peer) {
		la->l2_psm = chan->psm;
		bacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);
		la->l2_cid = cpu_to_le16(chan->dcid);
	} else {
		la->l2_psm = chan->sport;
		bacpy(&la->l2_bdaddr, &bt_sk(sk)->src);
		la->l2_cid = cpu_to_le16(chan->scid);
	}

	return 0;
}
","static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)
{
	struct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;
	struct sock *sk = sock->sk;
	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 
 	BT_DBG(""sock %p, sk %p"", sock, sk);
 
	memset(la, 0, sizeof(struct sockaddr_l2));
 	addr->sa_family = AF_BLUETOOTH;
 	*len = sizeof(struct sockaddr_l2);
 
	if (peer) {
		la->l2_psm = chan->psm;
		bacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);
		la->l2_cid = cpu_to_le16(chan->dcid);
	} else {
		la->l2_psm = chan->sport;
		bacpy(&la->l2_bdaddr, &bt_sk(sk)->src);
		la->l2_cid = cpu_to_le16(chan->scid);
	}

	return 0;
}
","The `l2cap_sock_getname` function retrieves the address information associated with a Bluetooth L2CAP socket. It takes a socket structure, a sockaddr structure for output, a pointer to an integer for the length, and a flag indicating whether to retrieve peer or local information. The function initializes the address family to Bluetooth and sets the length to the size of the sockaddr_l2 structure. Depending on the `peer` flag, it populates the sockaddr_l2 structure with either the local or peer channel parameters, including the Protocol/Service Multiplexer (PSM), Bluetooth device address, and channel identifier (CID), before returning 0 to indicate success.","The provided code defines a function that retrieves and populates address information for a Bluetooth socket. It initializes the address family and sets the length of the address structure. Based on a specified flag, the function fills in details related to either the local or peer connection, including service identifiers and Bluetooth device addresses. This allows the function to differentiate between local and remote endpoints, ensuring that the correct parameters are assigned. The function ultimately returns a success indicator, confirming that the address information has been successfully populated.","The vulnerability in the original code arises from the failure to initialize the `l2_bdaddr_type` member of the `sockaddr_l2` structure, which could lead to an information leak of two bytes from the kernel stack when the `getsockname()` syscall is invoked. This uninitialized data could potentially expose sensitive information. The fix implemented in the updated code involves adding a `memset(la, 0, sizeof(struct sockaddr_l2));` statement before populating the structure. This ensures that all members of the `sockaddr_l2` structure, including any padding bytes, are explicitly set to zero, thereby preventing any leakage of uninitialized data.","The vulnerability in the original code stems from the failure to initialize certain members of a structure, which could lead to the unintentional exposure of sensitive data from the kernel stack when a specific system call is made. This oversight allowed uninitialized bytes, including padding, to be returned, potentially leaking information. The fix involved adding a memory initialization step to ensure that all bytes in the structure are set to zero before any data is populated. This change effectively prevents any leakage of uninitialized data, thereby enhancing the security of the code.","The vulnerability was fixed by adding a `memset(la, 0, sizeof(struct sockaddr_l2));` statement at the beginning of the function. This line ensures that all members of the `sockaddr_l2` structure, including the `l2_bdaddr_type` and any padding bytes, are explicitly initialized to zero before any data is assigned. By doing this, the code prevents the leakage of uninitialized data from the kernel stack when the `getsockname()` syscall is called. This change effectively mitigates the risk of exposing sensitive information, thereby enhancing the overall security of the implementation.","The vulnerability was addressed by incorporating a memory initialization step that sets all bytes of the affected structure to zero before any data is populated. This ensures that all members, including those that could potentially contain sensitive information, are explicitly cleared. By doing so, the code prevents the exposure of uninitialized data that could leak information from the kernel stack during specific system calls. This fix effectively eliminates the risk of information leakage, thereby enhancing the security and integrity of the code.","5,5","5,5","4,4","5,5"
98,98,183072,183072,,Local,Not required,,CVE-2012-6544,https://www.cvedetails.com/cve/CVE-2012-6544/,CWE-200,Medium,Partial,,,2013-03-15,1.9,"The Bluetooth protocol stack in the Linux kernel before 3.6 does not properly initialize certain structures, which allows local users to obtain sensitive information from kernel stack memory via a crafted application that targets the (1) L2CAP or (2) HCI implementation.",2019-04-22,+Info ,1,https://github.com/torvalds/linux/commit/3f68ba07b1da811bf383b4b701b129bfcb2e4988,3f68ba07b1da811bf383b4b701b129bfcb2e4988,"Bluetooth: HCI - Fix info leak via getsockname()

The HCI code fails to initialize the hci_channel member of struct
sockaddr_hci and that for leaks two bytes kernel stack via the
getsockname() syscall. Initialize hci_channel with 0 to avoid the
info leak.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Marcel Holtmann <marcel@holtmann.org>
Cc: Gustavo Padovan <gustavo@padovan.org>
Cc: Johan Hedberg <johan.hedberg@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/bluetooth/hci_sock.c,"{""sha"": ""19fdac78e555b97c44dd6826bc60ef89a888395b"", ""filename"": ""net/bluetooth/hci_sock.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/3f68ba07b1da811bf383b4b701b129bfcb2e4988/net/bluetooth/hci_sock.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/3f68ba07b1da811bf383b4b701b129bfcb2e4988/net/bluetooth/hci_sock.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/bluetooth/hci_sock.c?ref=3f68ba07b1da811bf383b4b701b129bfcb2e4988"", ""patch"": ""@@ -694,6 +694,7 @@ static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,\n \t*addr_len = sizeof(*haddr);\n \thaddr->hci_family = AF_BLUETOOTH;\n \thaddr->hci_dev    = hdev->id;\n+\thaddr->hci_channel= 0;\n \n \trelease_sock(sk);\n \treturn 0;""}","static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,
			    int *addr_len, int peer)
{
	struct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;
	struct sock *sk = sock->sk;
	struct hci_dev *hdev = hci_pi(sk)->hdev;

	BT_DBG(""sock %p sk %p"", sock, sk);

	if (!hdev)
		return -EBADFD;

	lock_sock(sk);

 	*addr_len = sizeof(*haddr);
 	haddr->hci_family = AF_BLUETOOTH;
 	haddr->hci_dev    = hdev->id;
	haddr->hci_channel= 0;
 
 	release_sock(sk);
 	return 0;
}
","static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,
			    int *addr_len, int peer)
{
	struct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;
	struct sock *sk = sock->sk;
	struct hci_dev *hdev = hci_pi(sk)->hdev;

	BT_DBG(""sock %p sk %p"", sock, sk);

	if (!hdev)
		return -EBADFD;

	lock_sock(sk);

 	*addr_len = sizeof(*haddr);
 	haddr->hci_family = AF_BLUETOOTH;
 	haddr->hci_dev    = hdev->id;
 
 	release_sock(sk);
 	return 0;
}
",C,"	haddr->hci_channel= 0;
",,,"@@ -694,6 +694,7 @@ static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,
 	*addr_len = sizeof(*haddr);
 	haddr->hci_family = AF_BLUETOOTH;
 	haddr->hci_dev    = hdev->id;
+	haddr->hci_channel= 0;
 
 	release_sock(sk);
 	return 0;",linux,3f68ba07b1da811bf383b4b701b129bfcb2e4988,e15ca9a0ef9a86f0477530b0f44a725d67f889ee,1,"static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,
			    int *addr_len, int peer)
{
	struct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;
	struct sock *sk = sock->sk;
	struct hci_dev *hdev = hci_pi(sk)->hdev;

	BT_DBG(""sock %p sk %p"", sock, sk);

	if (!hdev)
		return -EBADFD;

	lock_sock(sk);

 	*addr_len = sizeof(*haddr);
 	haddr->hci_family = AF_BLUETOOTH;
 	haddr->hci_dev    = hdev->id;
//fix_flaw_line_below:
//	haddr->hci_channel= 0;
 
 	release_sock(sk);
 	return 0;
}
",183072,"static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,
			    int *addr_len, int peer)
{
	struct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;
	struct sock *sk = sock->sk;
	struct hci_dev *hdev = hci_pi(sk)->hdev;

	BT_DBG(""sock %p sk %p"", sock, sk);

	if (!hdev)
		return -EBADFD;

	lock_sock(sk);

 	*addr_len = sizeof(*haddr);
 	haddr->hci_family = AF_BLUETOOTH;
 	haddr->hci_dev    = hdev->id;
 
 	release_sock(sk);
 	return 0;
}
","static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,
			    int *addr_len, int peer)
{
	struct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;
	struct sock *sk = sock->sk;
	struct hci_dev *hdev = hci_pi(sk)->hdev;

	BT_DBG(""sock %p sk %p"", sock, sk);

	if (!hdev)
		return -EBADFD;

	lock_sock(sk);

 	*addr_len = sizeof(*haddr);
 	haddr->hci_family = AF_BLUETOOTH;
 	haddr->hci_dev    = hdev->id;
	haddr->hci_channel= 0;
 
 	release_sock(sk);
 	return 0;
}
","The `hci_sock_getname` function retrieves the address information associated with a Bluetooth socket. It takes a pointer to a socket structure, a pointer to a sockaddr structure for output, a pointer to an integer for the address length, and a flag indicating whether to get the peer address. The function first checks if the associated Bluetooth device is valid; if not, it returns an error. It then locks the socket, populates the sockaddr_hci structure with the Bluetooth family and device ID, releases the socket lock, and returns success. This function is essential for managing Bluetooth socket connections.","The provided code defines a function that retrieves the address information for a Bluetooth socket. It checks the validity of the associated Bluetooth device and returns an error if it is not valid. Upon confirming the device's validity, the function locks the socket to ensure safe access, then populates a structure with the necessary address details, including the Bluetooth family and device identifier. After updating the address information, it releases the lock on the socket and indicates successful completion. This functionality is crucial for managing and accessing Bluetooth socket connections effectively.","The vulnerability in the original code arises from the failure to initialize the `hci_channel` member of the `sockaddr_hci` structure, which could lead to an information leak of two bytes from the kernel stack when the `getsockname()` syscall is invoked. This uninitialized data could potentially expose sensitive information. The fix addresses this issue by explicitly setting `haddr->hci_channel` to 0 before releasing the socket lock. This initialization ensures that no residual data from the stack is leaked, thereby enhancing the security of the code and preventing unintended information exposure.","The vulnerability in the original code stems from the failure to initialize a specific member of a structure, which could inadvertently expose two bytes of sensitive data from the kernel stack during a system call. This uninitialized data could lead to information leaks, potentially compromising system security. The fix addresses this issue by explicitly setting the problematic member to zero before the function completes. This initialization ensures that no residual or sensitive data is leaked, thereby mitigating the risk of information exposure and enhancing the overall security of the code.","The vulnerability was fixed by explicitly initializing the `hci_channel` member of the `sockaddr_hci` structure to zero. In the modified code, after setting the `hci_family` and `hci_dev` members, the line `haddr->hci_channel = 0;` was added. This change ensures that the `hci_channel` member does not contain any residual data from the kernel stack, which could lead to an information leak during the execution of the `getsockname()` syscall. By initializing this member, the code prevents the exposure of sensitive information, thereby enhancing security.","The vulnerability was fixed by ensuring that a specific member of a structure was explicitly initialized to zero before the function completed. This change prevents any uninitialized data from being inadvertently exposed, which could lead to information leaks during system calls. By setting this member to a known value, the code eliminates the risk of residual data from the kernel stack being accessed, thereby safeguarding sensitive information. This enhancement improves the overall security of the code by ensuring that all relevant data is properly initialized before being returned or used.","5,5","5,5","4,4","4,4"
99,99,185167,185167,,Remote,Not required,,CVE-2013-0909,https://www.cvedetails.com/cve/CVE-2013-0909/,CWE-200,Low,Partial,,,2013-03-05,5.0,The XSS Auditor in Google Chrome before 25.0.1364.152 allows remote attackers to obtain sensitive HTTP Referer information via unspecified vectors.,2017-09-18,XSS +Info ,13,https://github.com/chromium/chromium/commit/537abce1bcf7378e760e904d6e5540a02a2fca9f,537abce1bcf7378e760e904d6e5540a02a2fca9f,"[content shell] reset the CWD after each layout test

BUG=111316
R=marja@chromium.org

Review URL: https://codereview.chromium.org/11633017

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@173906 0039d316-1c4b-4281-b951-d872f2087c98",0,content/shell/shell_browser_main.cc,"{""sha"": ""cc7bc42f97f7ecbdb741983ef83dec9a55809bf2"", ""filename"": ""content/shell/shell_browser_main.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/537abce1bcf7378e760e904d6e5540a02a2fca9f/content/shell/shell_browser_main.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/537abce1bcf7378e760e904d6e5540a02a2fca9f/content/shell/shell_browser_main.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/shell/shell_browser_main.cc?ref=537abce1bcf7378e760e904d6e5540a02a2fca9f"", ""patch"": ""@@ -135,6 +135,13 @@ int ShellBrowserMain(const content::MainFunctionParams& parameters) {\n     std::cout.flush();\n #endif\n \n+    FilePath original_cwd;\n+    {\n+      // We're outside of the message loop here, and this is a test.\n+      base::ThreadRestrictions::ScopedAllowIO allow_io;\n+      file_util::GetCurrentDirectory(&original_cwd);\n+    }\n+\n     while (GetNextTest(args, &command_line_position, &test_string)) {\n       if (test_string.empty())\n         continue;\n@@ -154,6 +161,12 @@ int ShellBrowserMain(const content::MainFunctionParams& parameters) {\n       ran_at_least_once = true;\n       main_runner_->Run();\n \n+      {\n+        // We're outside of the message loop here, and this is a test.\n+        base::ThreadRestrictions::ScopedAllowIO allow_io;\n+        file_util::SetCurrentDirectory(original_cwd);\n+      }\n+\n       if (!content::WebKitTestController::Get()->ResetAfterLayoutTest())\n         break;\n     }""}","int ShellBrowserMain(const content::MainFunctionParams& parameters) {
  bool layout_test_mode =
      CommandLine::ForCurrentProcess()->HasSwitch(switches::kDumpRenderTree);
  base::ScopedTempDir browser_context_path_for_layout_tests;

  if (layout_test_mode) {
    CHECK(browser_context_path_for_layout_tests.CreateUniqueTempDir());
    CHECK(!browser_context_path_for_layout_tests.path().MaybeAsASCII().empty());
    CommandLine::ForCurrentProcess()->AppendSwitchASCII(
        switches::kContentShellDataPath,
        browser_context_path_for_layout_tests.path().MaybeAsASCII());
  }

  scoped_ptr<content::BrowserMainRunner> main_runner_(
      content::BrowserMainRunner::Create());

  int exit_code = main_runner_->Initialize(parameters);

  if (exit_code >= 0)
    return exit_code;

  if (CommandLine::ForCurrentProcess()->HasSwitch(
        switches::kCheckLayoutTestSysDeps)) {
    MessageLoop::current()->PostTask(FROM_HERE, MessageLoop::QuitClosure());
    main_runner_->Run();
    main_runner_->Shutdown();
    return 0;
  }

  if (layout_test_mode) {
    content::WebKitTestController test_controller;
    std::string test_string;
    CommandLine::StringVector args =
        CommandLine::ForCurrentProcess()->GetArgs();
    size_t command_line_position = 0;
    bool ran_at_least_once = false;

#if defined(OS_ANDROID)
    std::cout << ""#READY\n"";
     std::cout.flush();
 #endif
 
    FilePath original_cwd;
    {
      // We're outside of the message loop here, and this is a test.
      base::ThreadRestrictions::ScopedAllowIO allow_io;
      file_util::GetCurrentDirectory(&original_cwd);
    }

     while (GetNextTest(args, &command_line_position, &test_string)) {
       if (test_string.empty())
         continue;
      if (test_string == ""QUIT"")
        break;

      bool enable_pixel_dumps;
      std::string pixel_hash;
      FilePath cwd;
      GURL test_url = GetURLForLayoutTest(
          test_string, &cwd, &enable_pixel_dumps, &pixel_hash);
      if (!content::WebKitTestController::Get()->PrepareForLayoutTest(
              test_url, cwd, enable_pixel_dumps, pixel_hash)) {
        break;
      }

       ran_at_least_once = true;
       main_runner_->Run();
 
      {
        // We're outside of the message loop here, and this is a test.
        base::ThreadRestrictions::ScopedAllowIO allow_io;
        file_util::SetCurrentDirectory(original_cwd);
      }

       if (!content::WebKitTestController::Get()->ResetAfterLayoutTest())
         break;
     }
    if (!ran_at_least_once) {
      MessageLoop::current()->PostTask(FROM_HERE, MessageLoop::QuitClosure());
      main_runner_->Run();
    }
    exit_code = 0;
  } else {
    exit_code = main_runner_->Run();
  }

  main_runner_->Shutdown();

  return exit_code;
}
","int ShellBrowserMain(const content::MainFunctionParams& parameters) {
  bool layout_test_mode =
      CommandLine::ForCurrentProcess()->HasSwitch(switches::kDumpRenderTree);
  base::ScopedTempDir browser_context_path_for_layout_tests;

  if (layout_test_mode) {
    CHECK(browser_context_path_for_layout_tests.CreateUniqueTempDir());
    CHECK(!browser_context_path_for_layout_tests.path().MaybeAsASCII().empty());
    CommandLine::ForCurrentProcess()->AppendSwitchASCII(
        switches::kContentShellDataPath,
        browser_context_path_for_layout_tests.path().MaybeAsASCII());
  }

  scoped_ptr<content::BrowserMainRunner> main_runner_(
      content::BrowserMainRunner::Create());

  int exit_code = main_runner_->Initialize(parameters);

  if (exit_code >= 0)
    return exit_code;

  if (CommandLine::ForCurrentProcess()->HasSwitch(
        switches::kCheckLayoutTestSysDeps)) {
    MessageLoop::current()->PostTask(FROM_HERE, MessageLoop::QuitClosure());
    main_runner_->Run();
    main_runner_->Shutdown();
    return 0;
  }

  if (layout_test_mode) {
    content::WebKitTestController test_controller;
    std::string test_string;
    CommandLine::StringVector args =
        CommandLine::ForCurrentProcess()->GetArgs();
    size_t command_line_position = 0;
    bool ran_at_least_once = false;

#if defined(OS_ANDROID)
    std::cout << ""#READY\n"";
     std::cout.flush();
 #endif
 
     while (GetNextTest(args, &command_line_position, &test_string)) {
       if (test_string.empty())
         continue;
      if (test_string == ""QUIT"")
        break;

      bool enable_pixel_dumps;
      std::string pixel_hash;
      FilePath cwd;
      GURL test_url = GetURLForLayoutTest(
          test_string, &cwd, &enable_pixel_dumps, &pixel_hash);
      if (!content::WebKitTestController::Get()->PrepareForLayoutTest(
              test_url, cwd, enable_pixel_dumps, pixel_hash)) {
        break;
      }

       ran_at_least_once = true;
       main_runner_->Run();
 
       if (!content::WebKitTestController::Get()->ResetAfterLayoutTest())
         break;
     }
    if (!ran_at_least_once) {
      MessageLoop::current()->PostTask(FROM_HERE, MessageLoop::QuitClosure());
      main_runner_->Run();
    }
    exit_code = 0;
  } else {
    exit_code = main_runner_->Run();
  }

  main_runner_->Shutdown();

  return exit_code;
}
",C,"    FilePath original_cwd;
    {
      // We're outside of the message loop here, and this is a test.
      base::ThreadRestrictions::ScopedAllowIO allow_io;
      file_util::GetCurrentDirectory(&original_cwd);
    }

      {
        // We're outside of the message loop here, and this is a test.
        base::ThreadRestrictions::ScopedAllowIO allow_io;
        file_util::SetCurrentDirectory(original_cwd);
      }

",,,"@@ -135,6 +135,13 @@ int ShellBrowserMain(const content::MainFunctionParams& parameters) {
     std::cout.flush();
 #endif
 
+    FilePath original_cwd;
+    {
+      // We're outside of the message loop here, and this is a test.
+      base::ThreadRestrictions::ScopedAllowIO allow_io;
+      file_util::GetCurrentDirectory(&original_cwd);
+    }
+
     while (GetNextTest(args, &command_line_position, &test_string)) {
       if (test_string.empty())
         continue;
@@ -154,6 +161,12 @@ int ShellBrowserMain(const content::MainFunctionParams& parameters) {
       ran_at_least_once = true;
       main_runner_->Run();
 
+      {
+        // We're outside of the message loop here, and this is a test.
+        base::ThreadRestrictions::ScopedAllowIO allow_io;
+        file_util::SetCurrentDirectory(original_cwd);
+      }
+
       if (!content::WebKitTestController::Get()->ResetAfterLayoutTest())
         break;
     }",Chrome,537abce1bcf7378e760e904d6e5540a02a2fca9f,bb70d7c2f2283cfaf3c474c78c339714b1530d5f,1,"int ShellBrowserMain(const content::MainFunctionParams& parameters) {
  bool layout_test_mode =
      CommandLine::ForCurrentProcess()->HasSwitch(switches::kDumpRenderTree);
  base::ScopedTempDir browser_context_path_for_layout_tests;

  if (layout_test_mode) {
    CHECK(browser_context_path_for_layout_tests.CreateUniqueTempDir());
    CHECK(!browser_context_path_for_layout_tests.path().MaybeAsASCII().empty());
    CommandLine::ForCurrentProcess()->AppendSwitchASCII(
        switches::kContentShellDataPath,
        browser_context_path_for_layout_tests.path().MaybeAsASCII());
  }

  scoped_ptr<content::BrowserMainRunner> main_runner_(
      content::BrowserMainRunner::Create());

  int exit_code = main_runner_->Initialize(parameters);

  if (exit_code >= 0)
    return exit_code;

  if (CommandLine::ForCurrentProcess()->HasSwitch(
        switches::kCheckLayoutTestSysDeps)) {
    MessageLoop::current()->PostTask(FROM_HERE, MessageLoop::QuitClosure());
    main_runner_->Run();
    main_runner_->Shutdown();
    return 0;
  }

  if (layout_test_mode) {
    content::WebKitTestController test_controller;
    std::string test_string;
    CommandLine::StringVector args =
        CommandLine::ForCurrentProcess()->GetArgs();
    size_t command_line_position = 0;
    bool ran_at_least_once = false;

#if defined(OS_ANDROID)
    std::cout << ""#READY\n"";
     std::cout.flush();
 #endif
 
//fix_flaw_line_below:
//    FilePath original_cwd;
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//      // We're outside of the message loop here, and this is a test.
//fix_flaw_line_below:
//      base::ThreadRestrictions::ScopedAllowIO allow_io;
//fix_flaw_line_below:
//      file_util::GetCurrentDirectory(&original_cwd);
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     while (GetNextTest(args, &command_line_position, &test_string)) {
       if (test_string.empty())
         continue;
      if (test_string == ""QUIT"")
        break;

      bool enable_pixel_dumps;
      std::string pixel_hash;
      FilePath cwd;
      GURL test_url = GetURLForLayoutTest(
          test_string, &cwd, &enable_pixel_dumps, &pixel_hash);
      if (!content::WebKitTestController::Get()->PrepareForLayoutTest(
              test_url, cwd, enable_pixel_dumps, pixel_hash)) {
        break;
      }

       ran_at_least_once = true;
       main_runner_->Run();
 
//fix_flaw_line_below:
//      {
//fix_flaw_line_below:
//        // We're outside of the message loop here, and this is a test.
//fix_flaw_line_below:
//        base::ThreadRestrictions::ScopedAllowIO allow_io;
//fix_flaw_line_below:
//        file_util::SetCurrentDirectory(original_cwd);
//fix_flaw_line_below:
//      }
//fix_flaw_line_below:
//
       if (!content::WebKitTestController::Get()->ResetAfterLayoutTest())
         break;
     }
    if (!ran_at_least_once) {
      MessageLoop::current()->PostTask(FROM_HERE, MessageLoop::QuitClosure());
      main_runner_->Run();
    }
    exit_code = 0;
  } else {
    exit_code = main_runner_->Run();
  }

  main_runner_->Shutdown();

  return exit_code;
}
",185167,"int ShellBrowserMain(const content::MainFunctionParams& parameters) {
  bool layout_test_mode =
      CommandLine::ForCurrentProcess()->HasSwitch(switches::kDumpRenderTree);
  base::ScopedTempDir browser_context_path_for_layout_tests;

  if (layout_test_mode) {
    CHECK(browser_context_path_for_layout_tests.CreateUniqueTempDir());
    CHECK(!browser_context_path_for_layout_tests.path().MaybeAsASCII().empty());
    CommandLine::ForCurrentProcess()->AppendSwitchASCII(
        switches::kContentShellDataPath,
        browser_context_path_for_layout_tests.path().MaybeAsASCII());
  }

  scoped_ptr<content::BrowserMainRunner> main_runner_(
      content::BrowserMainRunner::Create());

  int exit_code = main_runner_->Initialize(parameters);

  if (exit_code >= 0)
    return exit_code;

  if (CommandLine::ForCurrentProcess()->HasSwitch(
        switches::kCheckLayoutTestSysDeps)) {
    MessageLoop::current()->PostTask(FROM_HERE, MessageLoop::QuitClosure());
    main_runner_->Run();
    main_runner_->Shutdown();
    return 0;
  }

  if (layout_test_mode) {
    content::WebKitTestController test_controller;
    std::string test_string;
    CommandLine::StringVector args =
        CommandLine::ForCurrentProcess()->GetArgs();
    size_t command_line_position = 0;
    bool ran_at_least_once = false;

#if defined(OS_ANDROID)
    std::cout << ""#READY\n"";
     std::cout.flush();
 #endif
 
     while (GetNextTest(args, &command_line_position, &test_string)) {
       if (test_string.empty())
         continue;
      if (test_string == ""QUIT"")
        break;

      bool enable_pixel_dumps;
      std::string pixel_hash;
      FilePath cwd;
      GURL test_url = GetURLForLayoutTest(
          test_string, &cwd, &enable_pixel_dumps, &pixel_hash);
      if (!content::WebKitTestController::Get()->PrepareForLayoutTest(
              test_url, cwd, enable_pixel_dumps, pixel_hash)) {
        break;
      }

       ran_at_least_once = true;
       main_runner_->Run();
 
       if (!content::WebKitTestController::Get()->ResetAfterLayoutTest())
         break;
     }
    if (!ran_at_least_once) {
      MessageLoop::current()->PostTask(FROM_HERE, MessageLoop::QuitClosure());
      main_runner_->Run();
    }
    exit_code = 0;
  } else {
    exit_code = main_runner_->Run();
  }

  main_runner_->Shutdown();

  return exit_code;
}
","int ShellBrowserMain(const content::MainFunctionParams& parameters) {
  bool layout_test_mode =
      CommandLine::ForCurrentProcess()->HasSwitch(switches::kDumpRenderTree);
  base::ScopedTempDir browser_context_path_for_layout_tests;

  if (layout_test_mode) {
    CHECK(browser_context_path_for_layout_tests.CreateUniqueTempDir());
    CHECK(!browser_context_path_for_layout_tests.path().MaybeAsASCII().empty());
    CommandLine::ForCurrentProcess()->AppendSwitchASCII(
        switches::kContentShellDataPath,
        browser_context_path_for_layout_tests.path().MaybeAsASCII());
  }

  scoped_ptr<content::BrowserMainRunner> main_runner_(
      content::BrowserMainRunner::Create());

  int exit_code = main_runner_->Initialize(parameters);

  if (exit_code >= 0)
    return exit_code;

  if (CommandLine::ForCurrentProcess()->HasSwitch(
        switches::kCheckLayoutTestSysDeps)) {
    MessageLoop::current()->PostTask(FROM_HERE, MessageLoop::QuitClosure());
    main_runner_->Run();
    main_runner_->Shutdown();
    return 0;
  }

  if (layout_test_mode) {
    content::WebKitTestController test_controller;
    std::string test_string;
    CommandLine::StringVector args =
        CommandLine::ForCurrentProcess()->GetArgs();
    size_t command_line_position = 0;
    bool ran_at_least_once = false;

#if defined(OS_ANDROID)
    std::cout << ""#READY\n"";
     std::cout.flush();
 #endif
 
    FilePath original_cwd;
    {
      // We're outside of the message loop here, and this is a test.
      base::ThreadRestrictions::ScopedAllowIO allow_io;
      file_util::GetCurrentDirectory(&original_cwd);
    }

     while (GetNextTest(args, &command_line_position, &test_string)) {
       if (test_string.empty())
         continue;
      if (test_string == ""QUIT"")
        break;

      bool enable_pixel_dumps;
      std::string pixel_hash;
      FilePath cwd;
      GURL test_url = GetURLForLayoutTest(
          test_string, &cwd, &enable_pixel_dumps, &pixel_hash);
      if (!content::WebKitTestController::Get()->PrepareForLayoutTest(
              test_url, cwd, enable_pixel_dumps, pixel_hash)) {
        break;
      }

       ran_at_least_once = true;
       main_runner_->Run();
 
      {
        // We're outside of the message loop here, and this is a test.
        base::ThreadRestrictions::ScopedAllowIO allow_io;
        file_util::SetCurrentDirectory(original_cwd);
      }

       if (!content::WebKitTestController::Get()->ResetAfterLayoutTest())
         break;
     }
    if (!ran_at_least_once) {
      MessageLoop::current()->PostTask(FROM_HERE, MessageLoop::QuitClosure());
      main_runner_->Run();
    }
    exit_code = 0;
  } else {
    exit_code = main_runner_->Run();
  }

  main_runner_->Shutdown();

  return exit_code;
}
","The `ShellBrowserMain` function initializes and runs a browser instance, primarily for layout testing. It first checks if the process is in layout test mode, creating a temporary directory for test data if so. The function then initializes a `BrowserMainRunner` and handles command-line switches to either check system dependencies or execute layout tests. If in layout test mode, it iterates through test cases, preparing and running each test while managing the test environment. Finally, it shuts down the main runner and returns the exit code, indicating the success or failure of the operations performed.","The code initializes and manages a browser instance for layout testing, determining if it should operate in a specific test mode. It creates a temporary directory for test data if needed and sets up the main runner for the browser. The function checks for command-line options to either verify system dependencies or execute a series of layout tests. During the testing phase, it prepares the environment for each test case, runs the tests, and ensures proper cleanup afterward. Finally, it shuts down the browser instance and returns an exit code to indicate the outcome of the operations.","The vulnerability in the original code stemmed from not resetting the current working directory (CWD) after executing each layout test, which could lead to unintended side effects or inconsistencies in subsequent tests. This oversight could allow tests to interfere with one another by relying on a shared state. The fix involved introducing a mechanism to store the original CWD before running the tests and then resetting it back to this original state after each test execution. This change ensures that each test runs in a clean environment, preventing any potential contamination from previous tests and enhancing overall test reliability.","The vulnerability in the original code arose from the failure to reset the current working directory after each layout test, which could lead to tests affecting one another due to shared state. This lack of isolation could result in inconsistent test results and unintended interactions between tests. The fix addressed this issue by implementing a mechanism to store the original working directory before executing each test and ensuring it was restored afterward. This change effectively isolated each test's environment, preventing contamination and enhancing the reliability and accuracy of the testing process.","The vulnerability was fixed by introducing a mechanism to store the original current working directory using a specific variable before executing each layout test. The code captures the original directory and, after running each test, it resets the current directory back to this original value using a scoped thread restriction that allows I/O operations. This ensures that each test runs in a clean environment, free from the influence of previous tests. By implementing this reset process, the code enhances test isolation and reliability, preventing unintended side effects that could arise from shared state between tests.","The vulnerability was fixed by implementing a mechanism to capture the original working directory before executing each layout test and ensuring that it is restored afterward. This involved storing the initial directory state and then resetting it after each test execution. By allowing I/O operations during this process, the code guarantees that each test runs in a clean and isolated environment, free from any influence or changes made by previous tests. This enhancement improves the reliability and accuracy of the testing process, preventing unintended interactions and ensuring consistent test results.","5,5","5, 5","4,4","4,4"
100,100,185986,185986,,Remote,Not required,,CVE-2016-5166,https://www.cvedetails.com/cve/CVE-2016-5166/,CWE-200,High,Partial,,,2016-09-11,2.6,"The download implementation in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly restrict saving a file:// URL that is referenced by an http:// URL, which makes it easier for user-assisted remote attackers to discover NetNTLM hashes and conduct SMB relay attacks via a crafted web page that is accessed with the *Save page as* menu choice.",2018-10-30,+Info ,17,https://github.com/chromium/chromium/commit/5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce,5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce,"[Android WebAPK] Send share target information in WebAPK updates

This CL plumbs through share target information for WebAPK updates.

Chromium detects Web Manifest updates (including Web Manifest share
target updates) and requests an update.
Currently, depending on whether the Web Manifest is for an intranet
site, the updated WebAPK would either:
- no longer be able handle share intents (even if the Web Manifest
  share target information was not deleted)
- be created with the same share intent handlers as the current WebAPK
  (regardless of whether the Web Manifest share target information has
   changed).

This CL plumbs through the share target information from
WebApkUpdateDataFetcher#onDataAvailable() to
WebApkUpdateManager::StoreWebApkUpdateRequestToFile()

BUG=912945

Change-Id: Ie416570533abc848eeb23de8c197b44f2a1fd028
Reviewed-on: https://chromium-review.googlesource.com/c/1369709
Commit-Queue: Peter Kotwicz <pkotwicz@chromium.org>
Reviewed-by: Dominick Ng <dominickn@chromium.org>
Cr-Commit-Position: refs/heads/master@{#616429}",0,chrome/browser/android/webapk/webapk_update_manager.cc,"{""sha"": ""5ddc4cd19a8f0026ebdfd4f6c1fac6bc5117168a"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/webapps/WebApkInfo.java"", ""status"": ""modified"", ""additions"": 90, ""deletions"": 56, ""changes"": 146, ""blob_url"": ""https://github.com/chromium/chromium/blob/5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce/chrome/android/java/src/org/chromium/chrome/browser/webapps/WebApkInfo.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce/chrome/android/java/src/org/chromium/chrome/browser/webapps/WebApkInfo.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/webapps/WebApkInfo.java?ref=5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce"", ""patch"": ""@@ -4,17 +4,14 @@\n \n package org.chromium.chrome.browser.webapps;\n \n-import android.annotation.TargetApi;\n import android.content.Intent;\n-import android.content.pm.ActivityInfo;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageManager;\n import android.content.pm.ResolveInfo;\n import android.content.res.Resources;\n import android.graphics.Bitmap;\n import android.graphics.drawable.BitmapDrawable;\n import android.net.Uri;\n-import android.os.Build;\n import android.os.Bundle;\n import android.support.annotation.IntDef;\n import android.text.TextUtils;\n@@ -35,6 +32,7 @@\n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n@@ -51,6 +49,57 @@\n         public String shareActivityClassName;\n     }\n \n+    /**\n+     * Stores information about the WebAPK's share intent handlers.\n+     * TODO(crbug.com/912954): add share target V2 parameters once the server supports them.\n+     */\n+    public static class ShareTarget {\n+        private static final int ACTION_INDEX = 0;\n+        private static final int PARAM_TITLE_INDEX = 1;\n+        private static final int PARAM_TEXT_INDEX = 2;\n+        private static final int PARAM_URL_INDEX = 3;\n+        private String[] mData;\n+\n+        public ShareTarget() {\n+            this(null, null, null, null);\n+        }\n+\n+        public ShareTarget(String action, String paramTitle, String paramText, String paramUrl) {\n+            mData = new String[4];\n+            mData[ACTION_INDEX] = replaceNullWithEmpty(action);\n+            mData[PARAM_TITLE_INDEX] = replaceNullWithEmpty(paramTitle);\n+            mData[PARAM_TEXT_INDEX] = replaceNullWithEmpty(paramText);\n+            mData[PARAM_URL_INDEX] = replaceNullWithEmpty(paramUrl);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (!(o instanceof ShareTarget)) return false;\n+            return Arrays.equals(mData, ((ShareTarget) o).mData);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Arrays.hashCode(mData);\n+        }\n+\n+        public String getAction() {\n+            return mData[ACTION_INDEX];\n+        }\n+\n+        public String getParamTitle() {\n+            return mData[PARAM_TITLE_INDEX];\n+        }\n+\n+        public String getParamText() {\n+            return mData[PARAM_TEXT_INDEX];\n+        }\n+\n+        public String getParamUrl() {\n+            return mData[PARAM_URL_INDEX];\n+        }\n+    }\n+\n     public static final String RESOURCE_NAME = \""name\"";\n     public static final String RESOURCE_SHORT_NAME = \""short_name\"";\n     public static final String RESOURCE_STRING_TYPE = \""string\"";\n@@ -72,8 +121,7 @@\n     private String mManifestUrl;\n     private String mManifestStartUrl;\n     private @WebApkDistributor int mDistributor;\n-    // A serialized string of the Share Target details (if any) for the WebAPK.\n-    private String mSerializedShareTarget;\n+    private ShareTarget mShareTarget;\n     private Map<String, String> mIconUrlToMurmur2HashMap;\n     private boolean mUseTransparentSplash;\n \n@@ -230,14 +278,14 @@ public static WebApkInfo create(String webApkPackageName, String url, int source\n \n         int splashIconId = IntentUtils.safeGetInt(bundle, WebApkMetaDataKeys.SPLASH_ID, 0);\n         Bitmap splashIcon = decodeBitmapFromDrawable(res, splashIconId);\n-        String serializedShareTarget = extractSerializedShareTarget(webApkPackageName);\n+        ShareTarget shareTarget = extractAndMergeShareTargets(webApkPackageName);\n \n         return create(WebApkConstants.WEBAPK_ID_PREFIX + webApkPackageName, url, scope,\n                 new Icon(primaryIcon), new Icon(badgeIcon), new Icon(splashIcon), name, shortName,\n                 displayMode, orientation, source, themeColor, backgroundColor, webApkPackageName,\n                 shellApkVersion, manifestUrl, manifestStartUrl, distributor,\n-                iconUrlToMurmur2HashMap, serializedShareTarget, forceNavigation,\n-                useTransparentSplash, shareData);\n+                iconUrlToMurmur2HashMap, shareTarget, forceNavigation, useTransparentSplash,\n+                shareData);\n     }\n \n     /**\n@@ -265,8 +313,7 @@ public static WebApkInfo create(String webApkPackageName, String url, int source\n      * @param distributor             The source from where the WebAPK is installed.\n      * @param iconUrlToMurmur2HashMap Map of the WebAPK's icon URLs to Murmur2 hashes of the\n      *                                icon untransformed bytes.\n-     * @param serializedShareTarget   The serialized string of the Share Target details (if any) for\n-     *                                the WebAPK.\n+     * @param shareTarget             Data about WebAPK's share intent handlers.\n      * @param forceNavigation         Whether the WebAPK should navigate to {@link url} if the\n      *                                WebAPK is already open.\n      * @param useTransparentSplash    Whether the WebApkActivity should be fully transparent while\n@@ -278,7 +325,7 @@ public static WebApkInfo create(String id, String url, String scope, Icon primar\n             @WebDisplayMode int displayMode, int orientation, int source, long themeColor,\n             long backgroundColor, String webApkPackageName, int shellApkVersion, String manifestUrl,\n             String manifestStartUrl, @WebApkDistributor int distributor,\n-            Map<String, String> iconUrlToMurmur2HashMap, String serializedShareTarget,\n+            Map<String, String> iconUrlToMurmur2HashMap, ShareTarget shareTarget,\n             boolean forceNavigation, boolean useTransparentSplash, ShareData shareData) {\n         if (id == null || url == null || manifestStartUrl == null || webApkPackageName == null) {\n             Log.e(TAG,\n@@ -297,16 +344,16 @@ public static WebApkInfo create(String id, String url, String scope, Icon primar\n         return new WebApkInfo(id, url, scope, primaryIcon, badgeIcon, splashIcon, name, shortName,\n                 displayMode, orientation, source, themeColor, backgroundColor, webApkPackageName,\n                 shellApkVersion, manifestUrl, manifestStartUrl, distributor,\n-                iconUrlToMurmur2HashMap, serializedShareTarget, forceNavigation,\n-                useTransparentSplash, shareData);\n+                iconUrlToMurmur2HashMap, shareTarget, forceNavigation, useTransparentSplash,\n+                shareData);\n     }\n \n     protected WebApkInfo(String id, String url, String scope, Icon primaryIcon, Icon badgeIcon,\n             Icon splashIcon, String name, String shortName, @WebDisplayMode int displayMode,\n             int orientation, int source, long themeColor, long backgroundColor,\n             String webApkPackageName, int shellApkVersion, String manifestUrl,\n             String manifestStartUrl, @WebApkDistributor int distributor,\n-            Map<String, String> iconUrlToMurmur2HashMap, String serializedShareTarget,\n+            Map<String, String> iconUrlToMurmur2HashMap, ShareTarget shareTarget,\n             boolean forceNavigation, boolean useTransparentSplash, ShareData shareData) {\n         super(id, url, scope, primaryIcon, name, shortName, displayMode, orientation, source,\n                 themeColor, backgroundColor, null /* splash_screen_url */,\n@@ -319,9 +366,13 @@ protected WebApkInfo(String id, String url, String scope, Icon primaryIcon, Icon\n         mManifestStartUrl = manifestStartUrl;\n         mDistributor = distributor;\n         mIconUrlToMurmur2HashMap = iconUrlToMurmur2HashMap;\n-        mSerializedShareTarget = serializedShareTarget;\n         mUseTransparentSplash = useTransparentSplash;\n         mShareData = shareData;\n+\n+        mShareTarget = shareTarget;\n+        if (mShareTarget == null) {\n+            mShareTarget = new ShareTarget();\n+        }\n     }\n \n     protected WebApkInfo() {}\n@@ -340,11 +391,9 @@ public Bitmap splashIcon() {\n         return (mSplashIcon == null) ? null : mSplashIcon.decoded();\n     }\n \n-    /**\n-     * Returns the serialized string which contains all of the information about a share target.\n-     */\n-    public String serializedShareTarget() {\n-        return mSerializedShareTarget;\n+    /** Returns data about the WebAPK's share intent handlers. */\n+    public ShareTarget shareTarget() {\n+        return mShareTarget;\n     }\n \n     @Override\n@@ -510,49 +559,34 @@ private static int orientationFromString(String orientation) {\n         }\n     }\n \n-    /**\n-     * Returns the serialized string which contains all of the information about a share target for\n-     * the given WebAPK. Returns null if there isn't a ShareActivity declared in the WebAPK.\n-     */\n-    @TargetApi(Build.VERSION_CODES.KITKAT)\n-    static String extractSerializedShareTarget(String webApkPackageName) {\n+    /** Returns data about the share intent handlers for the given WebAPK. */\n+    private static ShareTarget extractAndMergeShareTargets(String webApkPackageName) {\n         Intent shareIntent = new Intent();\n         shareIntent.setAction(Intent.ACTION_SEND);\n         shareIntent.setPackage(webApkPackageName);\n         shareIntent.setType(\""text/plain\"");\n-        List<ResolveInfo> resInfos =\n+        List<ResolveInfo> resolveInfos =\n                 ContextUtils.getApplicationContext().getPackageManager().queryIntentActivities(\n                         shareIntent, PackageManager.GET_META_DATA);\n-        if (resInfos.isEmpty()) return null;\n-\n-        ActivityInfo activityInfo = resInfos.get(0).activityInfo;\n-        if (activityInfo.metaData == null) return null;\n-\n-        Bundle metaData = activityInfo.metaData;\n-        return getSerializedShareTarget(metaData.getString(WebApkMetaDataKeys.SHARE_ACTION),\n-                metaData.getString(WebApkMetaDataKeys.SHARE_METHOD),\n-                metaData.getString(WebApkMetaDataKeys.SHARE_ENCTYPE),\n-                metaData.getString(WebApkMetaDataKeys.SHARE_PARAM_TITLE),\n-                metaData.getString(WebApkMetaDataKeys.SHARE_PARAM_TEXT),\n-                metaData.getString(WebApkMetaDataKeys.SHARE_PARAM_URL),\n-                metaData.getString(WebApkMetaDataKeys.SHARE_PARAM_NAMES),\n-                metaData.getString(WebApkMetaDataKeys.SHARE_PARAM_ACCEPTS));\n-    }\n \n-    /**\n-     * Returns the serialized Share Target String.\n-     */\n-    static String getSerializedShareTarget(String shareAction, String shareMethod,\n-            String shareEnctype, String shareParamsTitle, String shareParamsText,\n-            String shareParamsUrl, String shareParamsNames, String shareParamsAccepts) {\n-        if (TextUtils.isEmpty(shareAction)) return null;\n-\n-        return String.format(\""action: \\\""%s\\\"", method: \\\""%s\\\"", enctype: \\\""%s\\\"", title: \\\""%s\\\""\""\n-                        + \""text: \\\""%s\\\"", url: \\\""%s\\\"", names: \\\""%s\\\"", accepts: \\\""%s\\\""\"",\n-                shareAction, replaceNullWithEmpty(shareMethod), replaceNullWithEmpty(shareEnctype),\n-                replaceNullWithEmpty(shareParamsTitle), replaceNullWithEmpty(shareParamsText),\n-                replaceNullWithEmpty(shareParamsUrl), replaceNullWithEmpty(shareParamsNames),\n-                replaceNullWithEmpty(shareParamsAccepts));\n+        for (ResolveInfo resolveInfo : resolveInfos) {\n+            Bundle shareTargetMetaData = resolveInfo.activityInfo.metaData;\n+            if (shareTargetMetaData == null\n+                    || WebApkShareTargetUtil.methodFromShareTargetMetaDataIsPost(\n+                            shareTargetMetaData)) {\n+                continue;\n+            }\n+\n+            return new ShareTarget(\n+                    IntentUtils.safeGetString(shareTargetMetaData, WebApkMetaDataKeys.SHARE_ACTION),\n+                    IntentUtils.safeGetString(\n+                            shareTargetMetaData, WebApkMetaDataKeys.SHARE_PARAM_TITLE),\n+                    IntentUtils.safeGetString(\n+                            shareTargetMetaData, WebApkMetaDataKeys.SHARE_PARAM_TEXT),\n+                    IntentUtils.safeGetString(\n+                            shareTargetMetaData, WebApkMetaDataKeys.SHARE_PARAM_URL));\n+        }\n+        return null;\n     }\n \n     /** Returns the value if it is non-null. Returns an empty string otherwise. */""}<_**next**_>{""sha"": ""10c40ab0c2d6afdbff2fc13016c0d9a05bd8b6cf"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/webapps/WebApkShareTargetUtil.java"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 6, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce/chrome/android/java/src/org/chromium/chrome/browser/webapps/WebApkShareTargetUtil.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce/chrome/android/java/src/org/chromium/chrome/browser/webapps/WebApkShareTargetUtil.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/webapps/WebApkShareTargetUtil.java?ref=5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce"", ""patch"": ""@@ -62,11 +62,6 @@ private static Bundle computeShareTargetMetaData(\n         return shareActivityInfo.metaData;\n     }\n \n-    private static boolean methodFromMetaDataIsPost(Bundle metaData) {\n-        String method = IntentUtils.safeGetString(metaData, WebApkMetaDataKeys.SHARE_METHOD);\n-        return method != null && \""POST\"".equals(method.toUpperCase(Locale.ENGLISH));\n-    }\n-\n     private static boolean enctypeFromMetaDataIsMultipart(Bundle metaData) {\n         String enctype = IntentUtils.safeGetString(metaData, WebApkMetaDataKeys.SHARE_ENCTYPE);\n         return enctype != null && \""multipart/form-data\"".equals(enctype.toLowerCase(Locale.ENGLISH));\n@@ -229,10 +224,16 @@ protected static PostData computeUrlEncodedPostData(\n         return postData;\n     }\n \n+    protected static boolean methodFromShareTargetMetaDataIsPost(Bundle metaData) {\n+        String method = IntentUtils.safeGetString(metaData, WebApkMetaDataKeys.SHARE_METHOD);\n+        return method != null && \""POST\"".equals(method.toUpperCase(Locale.ENGLISH));\n+    }\n+\n     protected static PostData computePostData(\n             String apkPackageName, WebApkInfo.ShareData shareData) {\n         Bundle shareTargetMetaData = computeShareTargetMetaData(apkPackageName, shareData);\n-        if (shareTargetMetaData == null || !methodFromMetaDataIsPost(shareTargetMetaData)) {\n+        if (shareTargetMetaData == null\n+                || !methodFromShareTargetMetaDataIsPost(shareTargetMetaData)) {\n             return null;\n         }\n         if (enctypeFromMetaDataIsMultipart(shareTargetMetaData)) {""}<_**next**_>{""sha"": ""4536174e1c143b178a9a7b47fc0225f251d6864f"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/webapps/WebApkUpdateDataFetcher.java"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce/chrome/android/java/src/org/chromium/chrome/browser/webapps/WebApkUpdateDataFetcher.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce/chrome/android/java/src/org/chromium/chrome/browser/webapps/WebApkUpdateDataFetcher.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/webapps/WebApkUpdateDataFetcher.java?ref=5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce"", ""patch"": ""@@ -112,15 +112,15 @@ protected void onDataAvailable(String manifestStartUrl, String scopeUrl, String\n             iconUrlToMurmur2HashMap.put(iconUrl, murmur2Hash);\n         }\n \n-        String serializedShareTarget = WebApkInfo.getSerializedShareTarget(shareAction, null, null,\n-                shareParamsTitle, shareParamsText, shareParamsUrl, null, null);\n+        WebApkInfo.ShareTarget shareTarget = new WebApkInfo.ShareTarget(\n+                shareAction, shareParamsTitle, shareParamsText, shareParamsUrl);\n \n         WebApkInfo info = WebApkInfo.create(mOldInfo.id(), mOldInfo.uri().toString(), scopeUrl,\n                 new WebApkInfo.Icon(primaryIconBitmap), new WebApkInfo.Icon(badgeIconBitmap), null,\n                 name, shortName, displayMode, orientation, mOldInfo.source(), themeColor,\n                 backgroundColor, mOldInfo.webApkPackageName(), mOldInfo.shellApkVersion(),\n                 mOldInfo.manifestUrl(), manifestStartUrl, WebApkInfo.WebApkDistributor.BROWSER,\n-                iconUrlToMurmur2HashMap, serializedShareTarget, mOldInfo.shouldForceNavigation(),\n+                iconUrlToMurmur2HashMap, shareTarget, mOldInfo.shouldForceNavigation(),\n                 mOldInfo.useTransparentSplash(), null);\n         mObserver.onGotManifestData(info, primaryIconUrl, badgeIconUrl);\n     }""}<_**next**_>{""sha"": ""52603a592a0c339211b2518b44fb075cdcaa6152"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/webapps/WebApkUpdateManager.java"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 5, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce/chrome/android/java/src/org/chromium/chrome/browser/webapps/WebApkUpdateManager.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce/chrome/android/java/src/org/chromium/chrome/browser/webapps/WebApkUpdateManager.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/webapps/WebApkUpdateManager.java?ref=5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce"", ""patch"": ""@@ -329,8 +329,7 @@ private void onFinishedUpdate(@WebApkInstallResult int result, boolean relaxUpda\n             return WebApkUpdateReason.ORIENTATION_DIFFERS;\n         } else if (oldInfo.displayMode() != fetchedInfo.displayMode()) {\n             return WebApkUpdateReason.DISPLAY_MODE_DIFFERS;\n-        } else if (!TextUtils.equals(\n-                           oldInfo.serializedShareTarget(), fetchedInfo.serializedShareTarget())) {\n+        } else if (!oldInfo.shareTarget().equals(fetchedInfo.shareTarget())) {\n             return WebApkUpdateReason.WEB_SHARE_TARGET_DIFFERS;\n         }\n         return WebApkUpdateReason.NONE;\n@@ -369,6 +368,8 @@ protected void storeWebApkUpdateRequestToFile(String updateRequestPath, WebApkIn\n                 info.scopeUri().toString(), info.name(), info.shortName(), primaryIconUrl,\n                 info.icon(), badgeIconUrl, info.badgeIcon(), iconUrls, iconHashes,\n                 info.displayMode(), info.orientation(), info.themeColor(), info.backgroundColor(),\n+                info.shareTarget().getAction(), info.shareTarget().getParamTitle(),\n+                info.shareTarget().getParamText(), info.shareTarget().getParamUrl(),\n                 info.manifestUrl(), info.webApkPackageName(), versionCode, isManifestStale,\n                 updateReason, callback);\n     }\n@@ -381,9 +382,10 @@ private static native void nativeStoreWebApkUpdateRequestToFile(String updateReq\n             String startUrl, String scope, String name, String shortName, String primaryIconUrl,\n             Bitmap primaryIcon, String badgeIconUrl, Bitmap badgeIcon, String[] iconUrls,\n             String[] iconHashes, @WebDisplayMode int displayMode, int orientation, long themeColor,\n-            long backgroundColor, String manifestUrl, String webApkPackage, int webApkVersion,\n-            boolean isManifestStale, @WebApkUpdateReason int updateReason,\n-            Callback<Boolean> callback);\n+            long backgroundColor, String shareTargetAction, String shareTargetParamTitle,\n+            String shareTargetParamText, String shareTargetParamUrl, String manifestUrl,\n+            String webApkPackage, int webApkVersion, boolean isManifestStale,\n+            @WebApkUpdateReason int updateReason, Callback<Boolean> callback);\n     private static native void nativeUpdateWebApkFromFile(\n             String updateRequestPath, WebApkUpdateCallback callback);\n }""}<_**next**_>{""sha"": ""2a805d02e7e97146e73764587635f5cccb6f4a2d"", ""filename"": ""chrome/android/junit/src/org/chromium/chrome/browser/webapps/WebApkInfoTest.java"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 18, ""changes"": 46, ""blob_url"": ""https://github.com/chromium/chromium/blob/5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce/chrome/android/junit/src/org/chromium/chrome/browser/webapps/WebApkInfoTest.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce/chrome/android/junit/src/org/chromium/chrome/browser/webapps/WebApkInfoTest.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/junit/src/org/chromium/chrome/browser/webapps/WebApkInfoTest.java?ref=5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce"", ""patch"": ""@@ -114,9 +114,14 @@ public void testSanity() {\n         bundle.putString(WebApkMetaDataKeys.START_URL, START_URL);\n         bundle.putString(WebApkMetaDataKeys.ICON_URLS_AND_ICON_MURMUR2_HASHES,\n                 ICON_URL + \"" \"" + ICON_MURMUR2_HASH);\n-        bundle.putString(WebApkMetaDataKeys.SHARE_METHOD, \""GET\"");\n+\n+        Bundle shareActivityBundle = new Bundle();\n+        shareActivityBundle.putString(WebApkMetaDataKeys.SHARE_ACTION, \""action0\"");\n+        shareActivityBundle.putString(WebApkMetaDataKeys.SHARE_PARAM_TITLE, \""title0\"");\n+        shareActivityBundle.putString(WebApkMetaDataKeys.SHARE_PARAM_TEXT, \""text0\"");\n+        shareActivityBundle.putString(WebApkMetaDataKeys.SHARE_PARAM_URL, \""url0\"");\n         WebApkTestHelper.registerWebApkWithMetaData(\n-                WEBAPK_PACKAGE_NAME, bundle, null /* shareTargetMetaData */);\n+                WEBAPK_PACKAGE_NAME, bundle, new Bundle[] {shareActivityBundle});\n \n         Intent intent = new Intent();\n         intent.putExtra(WebApkConstants.EXTRA_WEBAPK_PACKAGE_NAME, WEBAPK_PACKAGE_NAME);\n@@ -155,6 +160,13 @@ public void testSanity() {\n         Assert.assertEquals(null, info.icon());\n         Assert.assertEquals(null, info.badgeIcon());\n         Assert.assertEquals(null, info.splashIcon());\n+\n+        WebApkInfo.ShareTarget shareTarget = info.shareTarget();\n+        Assert.assertNotNull(shareTarget);\n+        Assert.assertEquals(\""action0\"", shareTarget.getAction());\n+        Assert.assertEquals(\""title0\"", shareTarget.getParamTitle());\n+        Assert.assertEquals(\""text0\"", shareTarget.getParamText());\n+        Assert.assertEquals(\""url0\"", shareTarget.getParamUrl());\n     }\n \n     /**\n@@ -432,23 +444,21 @@ public void testWebApkDistributorDefaultValue() {\n         Assert.assertEquals(WebApkInfo.WebApkDistributor.OTHER, info.distributor());\n     }\n \n-    // Test whether getSerializedShareTarget can handle special characters\n+    /**\n+     * Test that {@link WebApkInfo#shareTarget()} returns a non-null but empty object if the WebAPK\n+     * does not handle share intents.\n+     */\n     @Test\n-    public void testGetSerializedShareTarget() {\n-        String serializedShareTarget =\n-                WebApkInfo.getSerializedShareTarget(\""\\n\"", \""\\\\\"", \""\"", \""\"", \""\"", \""\"", \""\"", \""\"");\n-        Assert.assertEquals(\""action: \\\""\\n\\\"", method: \\\""\\\\\\\"", enctype: \\\""\\\"", title: \\\""\\\""\""\n-                        + \""text: \\\""\\\"", url: \\\""\\\"", names: \\\""\\\"", accepts: \\\""\\\""\"",\n-                serializedShareTarget);\n-    }\n+    public void testGetShareTargetNotNullEvenIfDoesNotHandleShareIntents() {\n+        Bundle bundle = new Bundle();\n+        bundle.putString(WebApkMetaDataKeys.START_URL, START_URL);\n+        WebApkTestHelper.registerWebApkWithMetaData(WEBAPK_PACKAGE_NAME, bundle, null);\n+        Intent intent = new Intent();\n+        intent.putExtra(WebApkConstants.EXTRA_WEBAPK_PACKAGE_NAME, WEBAPK_PACKAGE_NAME);\n+        intent.putExtra(ShortcutHelper.EXTRA_URL, START_URL);\n+        WebApkInfo info = WebApkInfo.create(intent);\n \n-    // Test that getSerializedShareTarget() returns the same result for empty and null parameters.\n-    @Test\n-    public void testGetSerializedShareTargetNullValues() {\n-        String serializedShareTarget1 = WebApkInfo.getSerializedShareTarget(\n-                \""action\"", \""\"", \""\"", \""awesome title\"", \""\"", \""\"", \""\"", \""\"");\n-        String serializedShareTarget2 = WebApkInfo.getSerializedShareTarget(\n-                \""action\"", null, null, \""awesome title\"", \""\"", \""\"", \""\"", \""\"");\n-        Assert.assertEquals(serializedShareTarget1, serializedShareTarget2);\n+        Assert.assertNotNull(info.shareTarget());\n+        Assert.assertEquals(\""\"", info.shareTarget().getAction());\n     }\n }""}<_**next**_>{""sha"": ""84f2f632c09b551d00e2538637fe245e7b36a420"", ""filename"": ""chrome/android/junit/src/org/chromium/chrome/browser/webapps/WebApkUpdateManagerUnitTest.java"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce/chrome/android/junit/src/org/chromium/chrome/browser/webapps/WebApkUpdateManagerUnitTest.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce/chrome/android/junit/src/org/chromium/chrome/browser/webapps/WebApkUpdateManagerUnitTest.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/junit/src/org/chromium/chrome/browser/webapps/WebApkUpdateManagerUnitTest.java?ref=5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce"", ""patch"": ""@@ -271,8 +271,8 @@ private static WebApkInfo infoFromManifestData(ManifestData manifestData) {\n                 manifestData.themeColor, manifestData.backgroundColor, kPackageName, -1,\n                 WEB_MANIFEST_URL, manifestData.startUrl, WebApkInfo.WebApkDistributor.BROWSER,\n                 manifestData.iconUrlToMurmur2HashMap,\n-                WebApkInfo.getSerializedShareTarget(manifestData.shareTargetAction, null, null,\n-                        manifestData.shareTargetParamTitle, null, null, null, null),\n+                new WebApkInfo.ShareTarget(manifestData.shareTargetAction,\n+                        manifestData.shareTargetParamTitle, null, null),\n                 false /* forceNavigation */, false /* useTransparentSplash */, null);\n     }\n ""}<_**next**_>{""sha"": ""96da1fd051baf860db3683d3d837fdf462260689"", ""filename"": ""chrome/browser/android/webapk/webapk_update_manager.cc"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 0, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce/chrome/browser/android/webapk/webapk_update_manager.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce/chrome/browser/android/webapk/webapk_update_manager.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/webapk/webapk_update_manager.cc?ref=5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce"", ""patch"": ""@@ -61,6 +61,10 @@ static void JNI_WebApkUpdateManager_StoreWebApkUpdateRequestToFile(\n     jint java_orientation,\n     jlong java_theme_color,\n     jlong java_background_color,\n+    const JavaParamRef<jstring>& java_share_target_action,\n+    const JavaParamRef<jstring>& java_share_target_param_title,\n+    const JavaParamRef<jstring>& java_share_target_param_text,\n+    const JavaParamRef<jstring>& java_share_target_param_url,\n     const JavaParamRef<jstring>& java_web_manifest_url,\n     const JavaParamRef<jstring>& java_webapk_package,\n     jint java_webapk_version,\n@@ -88,6 +92,19 @@ static void JNI_WebApkUpdateManager_StoreWebApkUpdateRequestToFile(\n       GURL(ConvertJavaStringToUTF8(env, java_badge_icon_url));\n   info.manifest_url = GURL(ConvertJavaStringToUTF8(env, java_web_manifest_url));\n \n+  GURL share_target_action =\n+      GURL(ConvertJavaStringToUTF8(env, java_share_target_action));\n+  if (!share_target_action.is_empty()) {\n+    info.share_target = ShareTarget();\n+    info.share_target->action = share_target_action;\n+    info.share_target->params.title =\n+        ConvertJavaStringToUTF16(java_share_target_param_title);\n+    info.share_target->params.text =\n+        ConvertJavaStringToUTF16(java_share_target_param_text);\n+    info.share_target->params.url =\n+        ConvertJavaStringToUTF16(java_share_target_param_url);\n+  }\n+\n   base::android::AppendJavaStringArrayToStringVector(env, java_icon_urls,\n                                                      &info.icon_urls);\n ""}","static void JNI_WebApkUpdateManager_StoreWebApkUpdateRequestToFile(
    JNIEnv* env,
    const JavaParamRef<jstring>& java_update_request_path,
    const JavaParamRef<jstring>& java_start_url,
    const JavaParamRef<jstring>& java_scope,
    const JavaParamRef<jstring>& java_name,
    const JavaParamRef<jstring>& java_short_name,
    const JavaParamRef<jstring>& java_primary_icon_url,
    const JavaParamRef<jobject>& java_primary_icon_bitmap,
    const JavaParamRef<jstring>& java_badge_icon_url,
    const JavaParamRef<jobject>& java_badge_icon_bitmap,
    const JavaParamRef<jobjectArray>& java_icon_urls,
    const JavaParamRef<jobjectArray>& java_icon_hashes,
    jint java_display_mode,
     jint java_orientation,
     jlong java_theme_color,
     jlong java_background_color,
    const JavaParamRef<jstring>& java_share_target_action,
    const JavaParamRef<jstring>& java_share_target_param_title,
    const JavaParamRef<jstring>& java_share_target_param_text,
    const JavaParamRef<jstring>& java_share_target_param_url,
     const JavaParamRef<jstring>& java_web_manifest_url,
     const JavaParamRef<jstring>& java_webapk_package,
     jint java_webapk_version,
    jboolean java_is_manifest_stale,
    jint java_update_reason,
    const JavaParamRef<jobject>& java_callback) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);

  std::string update_request_path =
      ConvertJavaStringToUTF8(env, java_update_request_path);

  ShortcutInfo info(GURL(ConvertJavaStringToUTF8(env, java_start_url)));
  info.scope = GURL(ConvertJavaStringToUTF8(env, java_scope));
  info.name = ConvertJavaStringToUTF16(env, java_name);
  info.short_name = ConvertJavaStringToUTF16(env, java_short_name);
  info.user_title = info.short_name;
  info.display = static_cast<blink::WebDisplayMode>(java_display_mode);
  info.orientation =
      static_cast<blink::WebScreenOrientationLockType>(java_orientation);
  info.theme_color = (int64_t)java_theme_color;
  info.background_color = (int64_t)java_background_color;
  info.best_primary_icon_url =
      GURL(ConvertJavaStringToUTF8(env, java_primary_icon_url));
  info.best_badge_icon_url =
       GURL(ConvertJavaStringToUTF8(env, java_badge_icon_url));
   info.manifest_url = GURL(ConvertJavaStringToUTF8(env, java_web_manifest_url));
 
  GURL share_target_action =
      GURL(ConvertJavaStringToUTF8(env, java_share_target_action));
  if (!share_target_action.is_empty()) {
    info.share_target = ShareTarget();
    info.share_target->action = share_target_action;
    info.share_target->params.title =
        ConvertJavaStringToUTF16(java_share_target_param_title);
    info.share_target->params.text =
        ConvertJavaStringToUTF16(java_share_target_param_text);
    info.share_target->params.url =
        ConvertJavaStringToUTF16(java_share_target_param_url);
  }

   base::android::AppendJavaStringArrayToStringVector(env, java_icon_urls,
                                                      &info.icon_urls);
 
  std::vector<std::string> icon_hashes;
  base::android::AppendJavaStringArrayToStringVector(env, java_icon_hashes,
                                                     &icon_hashes);

  std::map<std::string, std::string> icon_url_to_murmur2_hash;
  for (size_t i = 0; i < info.icon_urls.size(); ++i)
    icon_url_to_murmur2_hash[info.icon_urls[i]] = icon_hashes[i];

  gfx::JavaBitmap java_primary_icon_bitmap_lock(java_primary_icon_bitmap);
  SkBitmap primary_icon =
      gfx::CreateSkBitmapFromJavaBitmap(java_primary_icon_bitmap_lock);
  primary_icon.setImmutable();

  SkBitmap badge_icon;
  if (!java_badge_icon_bitmap.is_null()) {
    gfx::JavaBitmap java_badge_icon_bitmap_lock(java_badge_icon_bitmap);
    gfx::CreateSkBitmapFromJavaBitmap(java_badge_icon_bitmap_lock);
    badge_icon.setImmutable();
  }

  std::string webapk_package;
  ConvertJavaStringToUTF8(env, java_webapk_package, &webapk_package);

  WebApkUpdateReason update_reason =
      static_cast<WebApkUpdateReason>(java_update_reason);

  WebApkInstaller::StoreUpdateRequestToFile(
      base::FilePath(update_request_path), info, primary_icon, badge_icon,
      webapk_package, std::to_string(java_webapk_version),
      icon_url_to_murmur2_hash, java_is_manifest_stale, update_reason,
      base::BindOnce(&base::android::RunBooleanCallbackAndroid,
                     ScopedJavaGlobalRef<jobject>(java_callback)));
}
","static void JNI_WebApkUpdateManager_StoreWebApkUpdateRequestToFile(
    JNIEnv* env,
    const JavaParamRef<jstring>& java_update_request_path,
    const JavaParamRef<jstring>& java_start_url,
    const JavaParamRef<jstring>& java_scope,
    const JavaParamRef<jstring>& java_name,
    const JavaParamRef<jstring>& java_short_name,
    const JavaParamRef<jstring>& java_primary_icon_url,
    const JavaParamRef<jobject>& java_primary_icon_bitmap,
    const JavaParamRef<jstring>& java_badge_icon_url,
    const JavaParamRef<jobject>& java_badge_icon_bitmap,
    const JavaParamRef<jobjectArray>& java_icon_urls,
    const JavaParamRef<jobjectArray>& java_icon_hashes,
    jint java_display_mode,
     jint java_orientation,
     jlong java_theme_color,
     jlong java_background_color,
     const JavaParamRef<jstring>& java_web_manifest_url,
     const JavaParamRef<jstring>& java_webapk_package,
     jint java_webapk_version,
    jboolean java_is_manifest_stale,
    jint java_update_reason,
    const JavaParamRef<jobject>& java_callback) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);

  std::string update_request_path =
      ConvertJavaStringToUTF8(env, java_update_request_path);

  ShortcutInfo info(GURL(ConvertJavaStringToUTF8(env, java_start_url)));
  info.scope = GURL(ConvertJavaStringToUTF8(env, java_scope));
  info.name = ConvertJavaStringToUTF16(env, java_name);
  info.short_name = ConvertJavaStringToUTF16(env, java_short_name);
  info.user_title = info.short_name;
  info.display = static_cast<blink::WebDisplayMode>(java_display_mode);
  info.orientation =
      static_cast<blink::WebScreenOrientationLockType>(java_orientation);
  info.theme_color = (int64_t)java_theme_color;
  info.background_color = (int64_t)java_background_color;
  info.best_primary_icon_url =
      GURL(ConvertJavaStringToUTF8(env, java_primary_icon_url));
  info.best_badge_icon_url =
       GURL(ConvertJavaStringToUTF8(env, java_badge_icon_url));
   info.manifest_url = GURL(ConvertJavaStringToUTF8(env, java_web_manifest_url));
 
   base::android::AppendJavaStringArrayToStringVector(env, java_icon_urls,
                                                      &info.icon_urls);
 
  std::vector<std::string> icon_hashes;
  base::android::AppendJavaStringArrayToStringVector(env, java_icon_hashes,
                                                     &icon_hashes);

  std::map<std::string, std::string> icon_url_to_murmur2_hash;
  for (size_t i = 0; i < info.icon_urls.size(); ++i)
    icon_url_to_murmur2_hash[info.icon_urls[i]] = icon_hashes[i];

  gfx::JavaBitmap java_primary_icon_bitmap_lock(java_primary_icon_bitmap);
  SkBitmap primary_icon =
      gfx::CreateSkBitmapFromJavaBitmap(java_primary_icon_bitmap_lock);
  primary_icon.setImmutable();

  SkBitmap badge_icon;
  if (!java_badge_icon_bitmap.is_null()) {
    gfx::JavaBitmap java_badge_icon_bitmap_lock(java_badge_icon_bitmap);
    gfx::CreateSkBitmapFromJavaBitmap(java_badge_icon_bitmap_lock);
    badge_icon.setImmutable();
  }

  std::string webapk_package;
  ConvertJavaStringToUTF8(env, java_webapk_package, &webapk_package);

  WebApkUpdateReason update_reason =
      static_cast<WebApkUpdateReason>(java_update_reason);

  WebApkInstaller::StoreUpdateRequestToFile(
      base::FilePath(update_request_path), info, primary_icon, badge_icon,
      webapk_package, std::to_string(java_webapk_version),
      icon_url_to_murmur2_hash, java_is_manifest_stale, update_reason,
      base::BindOnce(&base::android::RunBooleanCallbackAndroid,
                     ScopedJavaGlobalRef<jobject>(java_callback)));
}
",C,"    const JavaParamRef<jstring>& java_share_target_action,
    const JavaParamRef<jstring>& java_share_target_param_title,
    const JavaParamRef<jstring>& java_share_target_param_text,
    const JavaParamRef<jstring>& java_share_target_param_url,
  GURL share_target_action =
      GURL(ConvertJavaStringToUTF8(env, java_share_target_action));
  if (!share_target_action.is_empty()) {
    info.share_target = ShareTarget();
    info.share_target->action = share_target_action;
    info.share_target->params.title =
        ConvertJavaStringToUTF16(java_share_target_param_title);
    info.share_target->params.text =
        ConvertJavaStringToUTF16(java_share_target_param_text);
    info.share_target->params.url =
        ConvertJavaStringToUTF16(java_share_target_param_url);
  }

",,,"@@ -61,6 +61,10 @@ static void JNI_WebApkUpdateManager_StoreWebApkUpdateRequestToFile(
     jint java_orientation,
     jlong java_theme_color,
     jlong java_background_color,
+    const JavaParamRef<jstring>& java_share_target_action,
+    const JavaParamRef<jstring>& java_share_target_param_title,
+    const JavaParamRef<jstring>& java_share_target_param_text,
+    const JavaParamRef<jstring>& java_share_target_param_url,
     const JavaParamRef<jstring>& java_web_manifest_url,
     const JavaParamRef<jstring>& java_webapk_package,
     jint java_webapk_version,
@@ -88,6 +92,19 @@ static void JNI_WebApkUpdateManager_StoreWebApkUpdateRequestToFile(
       GURL(ConvertJavaStringToUTF8(env, java_badge_icon_url));
   info.manifest_url = GURL(ConvertJavaStringToUTF8(env, java_web_manifest_url));
 
+  GURL share_target_action =
+      GURL(ConvertJavaStringToUTF8(env, java_share_target_action));
+  if (!share_target_action.is_empty()) {
+    info.share_target = ShareTarget();
+    info.share_target->action = share_target_action;
+    info.share_target->params.title =
+        ConvertJavaStringToUTF16(java_share_target_param_title);
+    info.share_target->params.text =
+        ConvertJavaStringToUTF16(java_share_target_param_text);
+    info.share_target->params.url =
+        ConvertJavaStringToUTF16(java_share_target_param_url);
+  }
+
   base::android::AppendJavaStringArrayToStringVector(env, java_icon_urls,
                                                      &info.icon_urls);
 ",Chrome,5da127a872b1e2c9fb1cf128ae309b4d6ce4e3ce,aae48161b1e8ea097affafdccb15d431099ff02f,1,"static void JNI_WebApkUpdateManager_StoreWebApkUpdateRequestToFile(
    JNIEnv* env,
    const JavaParamRef<jstring>& java_update_request_path,
    const JavaParamRef<jstring>& java_start_url,
    const JavaParamRef<jstring>& java_scope,
    const JavaParamRef<jstring>& java_name,
    const JavaParamRef<jstring>& java_short_name,
    const JavaParamRef<jstring>& java_primary_icon_url,
    const JavaParamRef<jobject>& java_primary_icon_bitmap,
    const JavaParamRef<jstring>& java_badge_icon_url,
    const JavaParamRef<jobject>& java_badge_icon_bitmap,
    const JavaParamRef<jobjectArray>& java_icon_urls,
    const JavaParamRef<jobjectArray>& java_icon_hashes,
    jint java_display_mode,
     jint java_orientation,
     jlong java_theme_color,
     jlong java_background_color,
//fix_flaw_line_below:
//    const JavaParamRef<jstring>& java_share_target_action,
//fix_flaw_line_below:
//    const JavaParamRef<jstring>& java_share_target_param_title,
//fix_flaw_line_below:
//    const JavaParamRef<jstring>& java_share_target_param_text,
//fix_flaw_line_below:
//    const JavaParamRef<jstring>& java_share_target_param_url,
     const JavaParamRef<jstring>& java_web_manifest_url,
     const JavaParamRef<jstring>& java_webapk_package,
     jint java_webapk_version,
    jboolean java_is_manifest_stale,
    jint java_update_reason,
    const JavaParamRef<jobject>& java_callback) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);

  std::string update_request_path =
      ConvertJavaStringToUTF8(env, java_update_request_path);

  ShortcutInfo info(GURL(ConvertJavaStringToUTF8(env, java_start_url)));
  info.scope = GURL(ConvertJavaStringToUTF8(env, java_scope));
  info.name = ConvertJavaStringToUTF16(env, java_name);
  info.short_name = ConvertJavaStringToUTF16(env, java_short_name);
  info.user_title = info.short_name;
  info.display = static_cast<blink::WebDisplayMode>(java_display_mode);
  info.orientation =
      static_cast<blink::WebScreenOrientationLockType>(java_orientation);
  info.theme_color = (int64_t)java_theme_color;
  info.background_color = (int64_t)java_background_color;
  info.best_primary_icon_url =
      GURL(ConvertJavaStringToUTF8(env, java_primary_icon_url));
  info.best_badge_icon_url =
       GURL(ConvertJavaStringToUTF8(env, java_badge_icon_url));
   info.manifest_url = GURL(ConvertJavaStringToUTF8(env, java_web_manifest_url));
 
//fix_flaw_line_below:
//  GURL share_target_action =
//fix_flaw_line_below:
//      GURL(ConvertJavaStringToUTF8(env, java_share_target_action));
//fix_flaw_line_below:
//  if (!share_target_action.is_empty()) {
//fix_flaw_line_below:
//    info.share_target = ShareTarget();
//fix_flaw_line_below:
//    info.share_target->action = share_target_action;
//fix_flaw_line_below:
//    info.share_target->params.title =
//fix_flaw_line_below:
//        ConvertJavaStringToUTF16(java_share_target_param_title);
//fix_flaw_line_below:
//    info.share_target->params.text =
//fix_flaw_line_below:
//        ConvertJavaStringToUTF16(java_share_target_param_text);
//fix_flaw_line_below:
//    info.share_target->params.url =
//fix_flaw_line_below:
//        ConvertJavaStringToUTF16(java_share_target_param_url);
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   base::android::AppendJavaStringArrayToStringVector(env, java_icon_urls,
                                                      &info.icon_urls);
 
  std::vector<std::string> icon_hashes;
  base::android::AppendJavaStringArrayToStringVector(env, java_icon_hashes,
                                                     &icon_hashes);

  std::map<std::string, std::string> icon_url_to_murmur2_hash;
  for (size_t i = 0; i < info.icon_urls.size(); ++i)
    icon_url_to_murmur2_hash[info.icon_urls[i]] = icon_hashes[i];

  gfx::JavaBitmap java_primary_icon_bitmap_lock(java_primary_icon_bitmap);
  SkBitmap primary_icon =
      gfx::CreateSkBitmapFromJavaBitmap(java_primary_icon_bitmap_lock);
  primary_icon.setImmutable();

  SkBitmap badge_icon;
  if (!java_badge_icon_bitmap.is_null()) {
    gfx::JavaBitmap java_badge_icon_bitmap_lock(java_badge_icon_bitmap);
    gfx::CreateSkBitmapFromJavaBitmap(java_badge_icon_bitmap_lock);
    badge_icon.setImmutable();
  }

  std::string webapk_package;
  ConvertJavaStringToUTF8(env, java_webapk_package, &webapk_package);

  WebApkUpdateReason update_reason =
      static_cast<WebApkUpdateReason>(java_update_reason);

  WebApkInstaller::StoreUpdateRequestToFile(
      base::FilePath(update_request_path), info, primary_icon, badge_icon,
      webapk_package, std::to_string(java_webapk_version),
      icon_url_to_murmur2_hash, java_is_manifest_stale, update_reason,
      base::BindOnce(&base::android::RunBooleanCallbackAndroid,
                     ScopedJavaGlobalRef<jobject>(java_callback)));
}
",185986,"static void JNI_WebApkUpdateManager_StoreWebApkUpdateRequestToFile(
    JNIEnv* env,
    const JavaParamRef<jstring>& java_update_request_path,
    const JavaParamRef<jstring>& java_start_url,
    const JavaParamRef<jstring>& java_scope,
    const JavaParamRef<jstring>& java_name,
    const JavaParamRef<jstring>& java_short_name,
    const JavaParamRef<jstring>& java_primary_icon_url,
    const JavaParamRef<jobject>& java_primary_icon_bitmap,
    const JavaParamRef<jstring>& java_badge_icon_url,
    const JavaParamRef<jobject>& java_badge_icon_bitmap,
    const JavaParamRef<jobjectArray>& java_icon_urls,
    const JavaParamRef<jobjectArray>& java_icon_hashes,
    jint java_display_mode,
     jint java_orientation,
     jlong java_theme_color,
     jlong java_background_color,
     const JavaParamRef<jstring>& java_web_manifest_url,
     const JavaParamRef<jstring>& java_webapk_package,
     jint java_webapk_version,
    jboolean java_is_manifest_stale,
    jint java_update_reason,
    const JavaParamRef<jobject>& java_callback) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);

  std::string update_request_path =
      ConvertJavaStringToUTF8(env, java_update_request_path);

  ShortcutInfo info(GURL(ConvertJavaStringToUTF8(env, java_start_url)));
  info.scope = GURL(ConvertJavaStringToUTF8(env, java_scope));
  info.name = ConvertJavaStringToUTF16(env, java_name);
  info.short_name = ConvertJavaStringToUTF16(env, java_short_name);
  info.user_title = info.short_name;
  info.display = static_cast<blink::WebDisplayMode>(java_display_mode);
  info.orientation =
      static_cast<blink::WebScreenOrientationLockType>(java_orientation);
  info.theme_color = (int64_t)java_theme_color;
  info.background_color = (int64_t)java_background_color;
  info.best_primary_icon_url =
      GURL(ConvertJavaStringToUTF8(env, java_primary_icon_url));
  info.best_badge_icon_url =
       GURL(ConvertJavaStringToUTF8(env, java_badge_icon_url));
   info.manifest_url = GURL(ConvertJavaStringToUTF8(env, java_web_manifest_url));
 
   base::android::AppendJavaStringArrayToStringVector(env, java_icon_urls,
                                                      &info.icon_urls);
 
  std::vector<std::string> icon_hashes;
  base::android::AppendJavaStringArrayToStringVector(env, java_icon_hashes,
                                                     &icon_hashes);

  std::map<std::string, std::string> icon_url_to_murmur2_hash;
  for (size_t i = 0; i < info.icon_urls.size(); ++i)
    icon_url_to_murmur2_hash[info.icon_urls[i]] = icon_hashes[i];

  gfx::JavaBitmap java_primary_icon_bitmap_lock(java_primary_icon_bitmap);
  SkBitmap primary_icon =
      gfx::CreateSkBitmapFromJavaBitmap(java_primary_icon_bitmap_lock);
  primary_icon.setImmutable();

  SkBitmap badge_icon;
  if (!java_badge_icon_bitmap.is_null()) {
    gfx::JavaBitmap java_badge_icon_bitmap_lock(java_badge_icon_bitmap);
    gfx::CreateSkBitmapFromJavaBitmap(java_badge_icon_bitmap_lock);
    badge_icon.setImmutable();
  }

  std::string webapk_package;
  ConvertJavaStringToUTF8(env, java_webapk_package, &webapk_package);

  WebApkUpdateReason update_reason =
      static_cast<WebApkUpdateReason>(java_update_reason);

  WebApkInstaller::StoreUpdateRequestToFile(
      base::FilePath(update_request_path), info, primary_icon, badge_icon,
      webapk_package, std::to_string(java_webapk_version),
      icon_url_to_murmur2_hash, java_is_manifest_stale, update_reason,
      base::BindOnce(&base::android::RunBooleanCallbackAndroid,
                     ScopedJavaGlobalRef<jobject>(java_callback)));
}
","static void JNI_WebApkUpdateManager_StoreWebApkUpdateRequestToFile(
    JNIEnv* env,
    const JavaParamRef<jstring>& java_update_request_path,
    const JavaParamRef<jstring>& java_start_url,
    const JavaParamRef<jstring>& java_scope,
    const JavaParamRef<jstring>& java_name,
    const JavaParamRef<jstring>& java_short_name,
    const JavaParamRef<jstring>& java_primary_icon_url,
    const JavaParamRef<jobject>& java_primary_icon_bitmap,
    const JavaParamRef<jstring>& java_badge_icon_url,
    const JavaParamRef<jobject>& java_badge_icon_bitmap,
    const JavaParamRef<jobjectArray>& java_icon_urls,
    const JavaParamRef<jobjectArray>& java_icon_hashes,
    jint java_display_mode,
     jint java_orientation,
     jlong java_theme_color,
     jlong java_background_color,
    const JavaParamRef<jstring>& java_share_target_action,
    const JavaParamRef<jstring>& java_share_target_param_title,
    const JavaParamRef<jstring>& java_share_target_param_text,
    const JavaParamRef<jstring>& java_share_target_param_url,
     const JavaParamRef<jstring>& java_web_manifest_url,
     const JavaParamRef<jstring>& java_webapk_package,
     jint java_webapk_version,
    jboolean java_is_manifest_stale,
    jint java_update_reason,
    const JavaParamRef<jobject>& java_callback) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);

  std::string update_request_path =
      ConvertJavaStringToUTF8(env, java_update_request_path);

  ShortcutInfo info(GURL(ConvertJavaStringToUTF8(env, java_start_url)));
  info.scope = GURL(ConvertJavaStringToUTF8(env, java_scope));
  info.name = ConvertJavaStringToUTF16(env, java_name);
  info.short_name = ConvertJavaStringToUTF16(env, java_short_name);
  info.user_title = info.short_name;
  info.display = static_cast<blink::WebDisplayMode>(java_display_mode);
  info.orientation =
      static_cast<blink::WebScreenOrientationLockType>(java_orientation);
  info.theme_color = (int64_t)java_theme_color;
  info.background_color = (int64_t)java_background_color;
  info.best_primary_icon_url =
      GURL(ConvertJavaStringToUTF8(env, java_primary_icon_url));
  info.best_badge_icon_url =
       GURL(ConvertJavaStringToUTF8(env, java_badge_icon_url));
   info.manifest_url = GURL(ConvertJavaStringToUTF8(env, java_web_manifest_url));
 
  GURL share_target_action =
      GURL(ConvertJavaStringToUTF8(env, java_share_target_action));
  if (!share_target_action.is_empty()) {
    info.share_target = ShareTarget();
    info.share_target->action = share_target_action;
    info.share_target->params.title =
        ConvertJavaStringToUTF16(java_share_target_param_title);
    info.share_target->params.text =
        ConvertJavaStringToUTF16(java_share_target_param_text);
    info.share_target->params.url =
        ConvertJavaStringToUTF16(java_share_target_param_url);
  }

   base::android::AppendJavaStringArrayToStringVector(env, java_icon_urls,
                                                      &info.icon_urls);
 
  std::vector<std::string> icon_hashes;
  base::android::AppendJavaStringArrayToStringVector(env, java_icon_hashes,
                                                     &icon_hashes);

  std::map<std::string, std::string> icon_url_to_murmur2_hash;
  for (size_t i = 0; i < info.icon_urls.size(); ++i)
    icon_url_to_murmur2_hash[info.icon_urls[i]] = icon_hashes[i];

  gfx::JavaBitmap java_primary_icon_bitmap_lock(java_primary_icon_bitmap);
  SkBitmap primary_icon =
      gfx::CreateSkBitmapFromJavaBitmap(java_primary_icon_bitmap_lock);
  primary_icon.setImmutable();

  SkBitmap badge_icon;
  if (!java_badge_icon_bitmap.is_null()) {
    gfx::JavaBitmap java_badge_icon_bitmap_lock(java_badge_icon_bitmap);
    gfx::CreateSkBitmapFromJavaBitmap(java_badge_icon_bitmap_lock);
    badge_icon.setImmutable();
  }

  std::string webapk_package;
  ConvertJavaStringToUTF8(env, java_webapk_package, &webapk_package);

  WebApkUpdateReason update_reason =
      static_cast<WebApkUpdateReason>(java_update_reason);

  WebApkInstaller::StoreUpdateRequestToFile(
      base::FilePath(update_request_path), info, primary_icon, badge_icon,
      webapk_package, std::to_string(java_webapk_version),
      icon_url_to_murmur2_hash, java_is_manifest_stale, update_reason,
      base::BindOnce(&base::android::RunBooleanCallbackAndroid,
                     ScopedJavaGlobalRef<jobject>(java_callback)));
}
","The provided code defines a function that stores a WebAPK update request to a specified file. It takes various parameters, including paths, URLs, icons, and display settings, which are converted from Java types to C++ types. The function constructs a `ShortcutInfo` object with details such as the start URL, scope, name, and icon URLs. It processes bitmap images for the primary and badge icons, and maps icon URLs to their corresponding hashes. Finally, it calls `WebApkInstaller::StoreUpdateRequestToFile` to save the update request, using a callback to notify the completion of the operation.","The code defines a function that facilitates the storage of a WebAPK update request to a specified file. It processes various input parameters, including paths, URLs, and display settings, converting them from Java to C++ types. The function constructs an object containing essential information about the WebAPK, such as its name, icons, and display properties. It also handles bitmap images for the primary and badge icons, mapping icon URLs to their corresponding hashes. Finally, the function invokes a method to save the update request, utilizing a callback to indicate the completion of the operation.","The vulnerability in the original code stemmed from the lack of handling for share target information in WebAPK updates, which could lead to inconsistencies in how share intents were processed. Specifically, if the Web Manifest was updated, the updated WebAPK might not correctly reflect changes to share target parameters, potentially causing it to either lose the ability to handle share intents or retain outdated handlers. The fix introduced additional parameters for share target action and parameters, ensuring that this information is properly passed and stored during the update process, thereby maintaining the correct functionality of share intents in the updated WebAPK.","The vulnerability in the original code arose from the failure to properly handle updates to share target information in WebAPK updates, which could lead to incorrect behavior when processing share intents. Specifically, if the Web Manifest was updated, the WebAPK might either lose the ability to handle share intents or retain outdated handlers, resulting in inconsistencies. The fix addressed this issue by ensuring that share target information is explicitly passed and stored during the update process, allowing the updated WebAPK to accurately reflect any changes in share target parameters and maintain proper functionality for handling share intents.","The vulnerability was fixed by introducing additional parameters for share target information in the update request handling function. Specifically, the code now includes parameters for share target action, title, text, and URL, which are converted from Java types to the appropriate C++ types. This information is then assigned to the share target structure within the `ShortcutInfo` object. By ensuring that the share target information is properly populated and passed to the `WebApkInstaller::StoreUpdateRequestToFile` function, the updated WebAPK can accurately reflect any changes in the Web Manifest, thus maintaining the correct handling of share intents.","The vulnerability was addressed by incorporating additional parameters to capture share target information during the update process. This enhancement ensures that relevant details, such as the action, title, text, and URL associated with share targets, are properly processed and stored. By explicitly including this information in the update request, the system can accurately reflect any changes made in the Web Manifest. As a result, the updated application can maintain consistent and correct handling of share intents, preventing issues related to outdated or missing share target configurations.","4,4","1, 4","4, 4","4, 5"
101,101,186227,186227,,Remote,Not required,,CVE-2016-1698,https://www.cvedetails.com/cve/CVE-2016-1698/,CWE-200,Medium,Partial,,,2016-06-05,4.3,"The createCustomType function in extensions/renderer/resources/binding.js in the extension bindings in Google Chrome before 51.0.2704.79 does not validate module types, which might allow attackers to load arbitrary modules or obtain sensitive information by leveraging a poisoned definition.",2018-10-30,+Info ,1,https://github.com/chromium/chromium/commit/5fb2548448bd1b76a59d941b729d7a7f90d53bc8,5fb2548448bd1b76a59d941b729d7a7f90d53bc8,"[Extensions] Finish freezing schema

BUG=604901
BUG=603725
BUG=591164

Review URL: https://codereview.chromium.org/1906593002

Cr-Commit-Position: refs/heads/master@{#388945}",1,extensions/renderer/v8_schema_registry.cc,"{""sha"": ""c3c0c9a3816571778ee2885de7908c91d8a3e3b2"", ""filename"": ""chrome/renderer/resources/extensions/chrome_setting.js"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 6, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/chrome/renderer/resources/extensions/chrome_setting.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/chrome/renderer/resources/extensions/chrome_setting.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/renderer/resources/extensions/chrome_setting.js?ref=5fb2548448bd1b76a59d941b729d7a7f90d53bc8"", ""patch"": ""@@ -8,10 +8,11 @@ var validate = require('schemaUtils').validate;\n \n function extendSchema(schema) {\n   var extendedSchema = $Array.slice(schema);\n-  extendedSchema.unshift({'type': 'string'});\n+  $Array.unshift(extendedSchema, {'type': 'string'});\n   return extendedSchema;\n }\n \n+// TODO(devlin): Maybe find a way to combine this and ContentSetting.\n function ChromeSetting(prefKey, valueSchema) {\n   this.get = function(details, callback) {\n     var getSchema = this.functionSchemas.get.definition.parameters;\n@@ -21,13 +22,24 @@ function ChromeSetting(prefKey, valueSchema) {\n                        extendSchema(getSchema));\n   };\n   this.set = function(details, callback) {\n-    var setSchema = $Array.slice(\n-        this.functionSchemas.set.definition.parameters);\n-    setSchema[0].properties.value = valueSchema;\n-    validate([details, callback], setSchema);\n+    // The set schema included in the Schema object is generic, since it varies\n+    // per-setting. However, this is only ever for a single setting, so we can\n+    // enforce the types more thoroughly.\n+    var rawSetSchema = this.functionSchemas.set.definition.parameters;\n+    var rawSettingParam = rawSetSchema[0];\n+    var props = $Object.assign({}, rawSettingParam.properties);\n+    props.value = valueSchema;\n+    var modSettingParam = {\n+      name: rawSettingParam.name,\n+      type: rawSettingParam.type,\n+      properties: props,\n+    };\n+    var modSetSchema = $Array.slice(rawSetSchema);\n+    modSetSchema[0] = modSettingParam;\n+    validate([details, callback], modSetSchema);\n     return sendRequest('types.ChromeSetting.set',\n                        [prefKey, details, callback],\n-                       extendSchema(setSchema));\n+                       extendSchema(modSetSchema));\n   };\n   this.clear = function(details, callback) {\n     var clearSchema = this.functionSchemas.clear.definition.parameters;""}<_**next**_>{""sha"": ""98fb95a890bd98aa23bf4d7026a8176b098b8b66"", ""filename"": ""chrome/renderer/resources/extensions/content_setting.js"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 6, ""changes"": 23, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/chrome/renderer/resources/extensions/content_setting.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/chrome/renderer/resources/extensions/content_setting.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/renderer/resources/extensions/content_setting.js?ref=5fb2548448bd1b76a59d941b729d7a7f90d53bc8"", ""patch"": ""@@ -9,7 +9,7 @@ var validate = require('schemaUtils').validate;\n \n function extendSchema(schema) {\n   var extendedSchema = $Array.slice(schema);\n-  extendedSchema.unshift({'type': 'string'});\n+  $Array.unshift(extendedSchema, {'type': 'string'});\n   return extendedSchema;\n }\n \n@@ -22,13 +22,24 @@ function ContentSetting(contentType, settingSchema) {\n                        extendSchema(getSchema));\n   };\n   this.set = function(details, callback) {\n-    var setSchema = $Array.slice(\n-        this.functionSchemas.set.definition.parameters);\n-    setSchema[0].properties.setting = settingSchema;\n-    validate([details, callback], setSchema);\n+    // The set schema included in the Schema object is generic, since it varies\n+    // per-setting. However, this is only ever for a single setting, so we can\n+    // enforce the types more thoroughly.\n+    var rawSetSchema = this.functionSchemas.set.definition.parameters;\n+    var rawSettingParam = rawSetSchema[0];\n+    var props = $Object.assign({}, rawSettingParam.properties);\n+    props.setting = settingSchema;\n+    var modSettingParam = {\n+      name: rawSettingParam.name,\n+      type: rawSettingParam.type,\n+      properties: props,\n+    };\n+    var modSetSchema = $Array.slice(rawSetSchema);\n+    modSetSchema[0] = modSettingParam;\n+    validate([details, callback], rawSetSchema);\n     return sendRequest('contentSettings.set',\n                        [contentType, details, callback],\n-                       extendSchema(setSchema));\n+                       extendSchema(modSetSchema));\n   };\n   this.clear = function(details, callback) {\n     var clearSchema = this.functionSchemas.clear.definition.parameters;""}<_**next**_>{""sha"": ""50b729c3e8fe3edb72fced88ef2730994ce66c43"", ""filename"": ""chrome/test/data/extensions/api_test/stubs_app/background.js"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/chrome/test/data/extensions/api_test/stubs_app/background.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/chrome/test/data/extensions/api_test/stubs_app/background.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/data/extensions/api_test/stubs_app/background.js?ref=5fb2548448bd1b76a59d941b729d7a7f90d53bc8"", ""patch"": ""@@ -22,7 +22,8 @@ function getApiPaths() {\n     [module.functions, module.events].forEach(function(section) {\n       if (typeof(section) == \""undefined\"")\n         return;\n-      section.forEach(function(entry) {\n+      // Pieces of the module don't inherit from Array/Object.\n+      Array.prototype.forEach.call(section, function(entry) {\n         apiPaths.push(namespace + \"".\"" + entry.name);\n       });\n     });""}<_**next**_>{""sha"": ""fe066f23f5ac6a63890a3be7c87853176ba4a8eb"", ""filename"": ""extensions/renderer/resources/binding.js"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 1, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/extensions/renderer/resources/binding.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/extensions/renderer/resources/binding.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/renderer/resources/binding.js?ref=5fb2548448bd1b76a59d941b729d7a7f90d53bc8"", ""patch"": ""@@ -494,7 +494,17 @@ Binding.prototype = {\n           return;\n         }\n \n-        var value = propertyDef.value;\n+        // |value| is eventually added to |m|, the exposed API. Make copies\n+        // of everything from the schema. (The schema is also frozen, so as long\n+        // as we don't make any modifications, shallow copies are fine.)\n+        var value;\n+        if ($Array.isArray(propertyDef.value))\n+          value = $Array.slice(propertyDef.value);\n+        else if (typeof propertyDef.value === 'object')\n+          value = $Object.assign({}, propertyDef.value);\n+        else\n+          value = propertyDef.value;\n+\n         if (value) {\n           // Values may just have raw types as defined in the JSON, such\n           // as \""WINDOW_ID_NONE\"": { \""value\"": -1 }. We handle this here.""}<_**next**_>{""sha"": ""a6d64cf6fd98ec7eea428be9aaa66c63c390f9cc"", ""filename"": ""extensions/renderer/resources/event.js"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/extensions/renderer/resources/event.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/extensions/renderer/resources/event.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/renderer/resources/event.js?ref=5fb2548448bd1b76a59d941b729d7a7f90d53bc8"", ""patch"": ""@@ -139,7 +139,7 @@\n       }\n     }\n \n-    var options = opt_eventOptions || {};\n+    var options = $Object.assign({}, opt_eventOptions || {});\n     merge(options, {\n       // Event supports adding listeners with filters (\""filtered events\""), for\n       // example as used in the webNavigation API.\n@@ -415,7 +415,7 @@\n       return {\n         'type': 'array',\n         'items': {\n-          'choices': typesList.map(function(el) {return {'$ref': el};})\n+          'choices': $Array.map(typesList, function(el) {return {'$ref': el};})\n         }\n       };\n     };""}<_**next**_>{""sha"": ""447d1ea21c232df7e5c2252383437caf095300d7"", ""filename"": ""extensions/renderer/resources/json_schema.js"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/extensions/renderer/resources/json_schema.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/extensions/renderer/resources/json_schema.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/renderer/resources/json_schema.js?ref=5fb2548448bd1b76a59d941b729d7a7f90d53bc8"", ""patch"": ""@@ -330,7 +330,7 @@ JSONSchemaValidator.prototype.validateEnum = function(instance, schema, path) {\n   }\n \n   this.addError(path, \""invalidEnum\"",\n-                [schema.enum.map(enumToString).join(\"", \"")]);\n+                [$Array.join($Array.map(schema.enum, enumToString), \"", \"")]);\n   return false;\n };\n ""}<_**next**_>{""sha"": ""b14d2eb548d617a55da74287a75a6c4e65523ee2"", ""filename"": ""extensions/renderer/resources/schema_utils.js"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/extensions/renderer/resources/schema_utils.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/extensions/renderer/resources/schema_utils.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/renderer/resources/schema_utils.js?ref=5fb2548448bd1b76a59d941b729d7a7f90d53bc8"", ""patch"": ""@@ -86,15 +86,15 @@ function getParameterSignatureString(name, definedSignature) {\n       return \""optional \"" + typeName;\n     return typeName;\n   };\n-  var typeNames = definedSignature.map(getSchemaTypeString);\n+  var typeNames = $Array.map(definedSignature, getSchemaTypeString);\n   return name + \""(\"" + typeNames.join(\"", \"") + \"")\"";\n };\n \n // Returns a string representing a call to an API function.\n // Example return value for call: chrome.windows.get(1, callback) is:\n // \""windows.get(int, function)\""\n function getArgumentSignatureString(name, args) {\n-  var typeNames = args.map(JSONSchemaValidator.getType);\n+  var typeNames = $Array.map(args, JSONSchemaValidator.getType);\n   return name + \""(\"" + typeNames.join(\"", \"") + \"")\"";\n };\n ""}<_**next**_>{""sha"": ""4ff6bbdb6d0476fbc88d71eb3e51e79baf6d954d"", ""filename"": ""extensions/renderer/resources/storage_area.js"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/extensions/renderer/resources/storage_area.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/extensions/renderer/resources/storage_area.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/renderer/resources/storage_area.js?ref=5fb2548448bd1b76a59d941b729d7a7f90d53bc8"", ""patch"": ""@@ -8,7 +8,7 @@ var sendRequest = require('sendRequest').sendRequest;\n \n function extendSchema(schema) {\n   var extendedSchema = $Array.slice(schema);\n-  extendedSchema.unshift({'type': 'string'});\n+  $Array.unshift(extendedSchema, {'type': 'string'});\n   return extendedSchema;\n }\n ""}<_**next**_>{""sha"": ""eee1356272ed1fe7d182cb6a6343480f3f07b441"", ""filename"": ""extensions/renderer/resources/utils.js"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/extensions/renderer/resources/utils.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/extensions/renderer/resources/utils.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/renderer/resources/utils.js?ref=5fb2548448bd1b76a59d941b729d7a7f90d53bc8"", ""patch"": ""@@ -33,7 +33,7 @@ function forEach(obj, f, self) {\n  */\n function lookup(array_of_dictionaries, field, value) {\n   var filter = function (dict) {return dict[field] == value;};\n-  var matches = array_of_dictionaries.filter(filter);\n+  var matches = $Array.filter(array_of_dictionaries, filter);\n   if (matches.length == 0) {\n     return undefined;\n   } else if (matches.length == 1) {""}<_**next**_>{""sha"": ""1b87bc74272072c5d3f349f62a138c03e0f3511f"", ""filename"": ""extensions/renderer/safe_builtins.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/extensions/renderer/safe_builtins.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/extensions/renderer/safe_builtins.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/renderer/safe_builtins.cc?ref=5fb2548448bd1b76a59d941b729d7a7f90d53bc8"", ""patch"": ""@@ -70,12 +70,14 @@ const char kScript[] =\n     \""saveBuiltin(Object,\\n\""\n     \""            ['hasOwnProperty'],\\n\""\n     \""            ['create', 'defineProperty', 'freeze',\\n\""\n-    \""             'getOwnPropertyDescriptor', 'getPrototypeOf', 'keys']);\\n\""\n+    \""             'getOwnPropertyDescriptor', 'getPrototypeOf', 'keys',\\n\""\n+    \""             'assign']);\\n\""\n     \""saveBuiltin(Function,\\n\""\n     \""            ['apply', 'bind', 'call']);\\n\""\n     \""saveBuiltin(Array,\\n\""\n     \""            ['concat', 'forEach', 'indexOf', 'join', 'push', 'slice',\\n\""\n-    \""             'splice', 'map', 'filter']);\\n\""\n+    \""             'splice', 'map', 'filter', 'unshift'],\\n\""\n+    \""            ['isArray']);\\n\""\n     \""saveBuiltin(String,\\n\""\n     \""            ['indexOf', 'slice', 'split', 'substr', 'toUpperCase',\\n\""\n     \""             'replace']);\\n\""""}<_**next**_>{""sha"": ""85adc928f6f7af825c56d3c35db624d00070a46e"", ""filename"": ""extensions/renderer/v8_schema_registry.cc"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 1, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/extensions/renderer/v8_schema_registry.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5fb2548448bd1b76a59d941b729d7a7f90d53bc8/extensions/renderer/v8_schema_registry.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/renderer/v8_schema_registry.cc?ref=5fb2548448bd1b76a59d941b729d7a7f90d53bc8"", ""patch"": ""@@ -21,6 +21,22 @@ namespace extensions {\n \n namespace {\n \n+// Recursively freezes every v8 object on |object|.\n+void DeepFreeze(const v8::Local<v8::Object>& object,\n+                const v8::Local<v8::Context>& context) {\n+  // Don't let the object trace upwards via the prototype.\n+  v8::Maybe<bool> maybe =\n+      object->SetPrototype(context, v8::Null(context->GetIsolate()));\n+  CHECK(maybe.IsJust() && maybe.FromJust());\n+  v8::Local<v8::Array> property_names = object->GetOwnPropertyNames();\n+  for (uint32_t i = 0; i < property_names->Length(); ++i) {\n+    v8::Local<v8::Value> child = object->Get(property_names->Get(i));\n+    if (child->IsObject())\n+      DeepFreeze(v8::Local<v8::Object>::Cast(child), context);\n+  }\n+  object->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen);\n+}\n+\n class SchemaRegistryNativeHandler : public ObjectBackedNativeHandler {\n  public:\n   SchemaRegistryNativeHandler(V8SchemaRegistry* registry,\n@@ -105,7 +121,7 @@ v8::Local<v8::Object> V8SchemaRegistry::GetSchema(const std::string& api) {\n   CHECK(!value.IsEmpty());\n \n   v8::Local<v8::Object> v8_schema(v8::Local<v8::Object>::Cast(value));\n-  v8_schema->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen);\n+  DeepFreeze(v8_schema, context);\n   schema_cache_->Set(api, v8_schema);\n \n   return handle_scope.Escape(v8_schema);""}","v8::Local<v8::Object> V8SchemaRegistry::GetSchema(const std::string& api) {
  if (schema_cache_ != NULL) {
    v8::Local<v8::Object> cached_schema = schema_cache_->Get(api);
    if (!cached_schema.IsEmpty()) {
      return cached_schema;
    }
  }


  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::EscapableHandleScope handle_scope(isolate);
  v8::Local<v8::Context> context = GetOrCreateContext(isolate);
  v8::Context::Scope context_scope(context);

  const base::DictionaryValue* schema =
      ExtensionAPI::GetSharedInstance()->GetSchema(api);
  CHECK(schema) << api;
  std::unique_ptr<V8ValueConverter> v8_value_converter(
      V8ValueConverter::create());
  v8::Local<v8::Value> value = v8_value_converter->ToV8Value(schema, context);
   CHECK(!value.IsEmpty());
 
   v8::Local<v8::Object> v8_schema(v8::Local<v8::Object>::Cast(value));
  DeepFreeze(v8_schema, context);
   schema_cache_->Set(api, v8_schema);
 
   return handle_scope.Escape(v8_schema);
}
","v8::Local<v8::Object> V8SchemaRegistry::GetSchema(const std::string& api) {
  if (schema_cache_ != NULL) {
    v8::Local<v8::Object> cached_schema = schema_cache_->Get(api);
    if (!cached_schema.IsEmpty()) {
      return cached_schema;
    }
  }


  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::EscapableHandleScope handle_scope(isolate);
  v8::Local<v8::Context> context = GetOrCreateContext(isolate);
  v8::Context::Scope context_scope(context);

  const base::DictionaryValue* schema =
      ExtensionAPI::GetSharedInstance()->GetSchema(api);
  CHECK(schema) << api;
  std::unique_ptr<V8ValueConverter> v8_value_converter(
      V8ValueConverter::create());
  v8::Local<v8::Value> value = v8_value_converter->ToV8Value(schema, context);
   CHECK(!value.IsEmpty());
 
   v8::Local<v8::Object> v8_schema(v8::Local<v8::Object>::Cast(value));
  v8_schema->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen);
   schema_cache_->Set(api, v8_schema);
 
   return handle_scope.Escape(v8_schema);
}
",C,"  DeepFreeze(v8_schema, context);
","  v8_schema->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen);
",,"@@ -21,6 +21,22 @@ namespace extensions {
 
 namespace {
 
+// Recursively freezes every v8 object on |object|.
+void DeepFreeze(const v8::Local<v8::Object>& object,
+                const v8::Local<v8::Context>& context) {
+  // Don't let the object trace upwards via the prototype.
+  v8::Maybe<bool> maybe =
+      object->SetPrototype(context, v8::Null(context->GetIsolate()));
+  CHECK(maybe.IsJust() && maybe.FromJust());
+  v8::Local<v8::Array> property_names = object->GetOwnPropertyNames();
+  for (uint32_t i = 0; i < property_names->Length(); ++i) {
+    v8::Local<v8::Value> child = object->Get(property_names->Get(i));
+    if (child->IsObject())
+      DeepFreeze(v8::Local<v8::Object>::Cast(child), context);
+  }
+  object->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen);
+}
+
 class SchemaRegistryNativeHandler : public ObjectBackedNativeHandler {
  public:
   SchemaRegistryNativeHandler(V8SchemaRegistry* registry,
@@ -105,7 +121,7 @@ v8::Local<v8::Object> V8SchemaRegistry::GetSchema(const std::string& api) {
   CHECK(!value.IsEmpty());
 
   v8::Local<v8::Object> v8_schema(v8::Local<v8::Object>::Cast(value));
-  v8_schema->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen);
+  DeepFreeze(v8_schema, context);
   schema_cache_->Set(api, v8_schema);
 
   return handle_scope.Escape(v8_schema);",Chrome,5fb2548448bd1b76a59d941b729d7a7f90d53bc8,b4d6bf98e54db861b8d9adc7642c47b1677b8f40,1,"v8::Local<v8::Object> V8SchemaRegistry::GetSchema(const std::string& api) {
  if (schema_cache_ != NULL) {
    v8::Local<v8::Object> cached_schema = schema_cache_->Get(api);
    if (!cached_schema.IsEmpty()) {
      return cached_schema;
    }
  }

  // Slow path: Need to build schema first.

  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::EscapableHandleScope handle_scope(isolate);
  v8::Local<v8::Context> context = GetOrCreateContext(isolate);
  v8::Context::Scope context_scope(context);

  const base::DictionaryValue* schema =
      ExtensionAPI::GetSharedInstance()->GetSchema(api);
  CHECK(schema) << api;
  std::unique_ptr<V8ValueConverter> v8_value_converter(
      V8ValueConverter::create());
  v8::Local<v8::Value> value = v8_value_converter->ToV8Value(schema, context);
   CHECK(!value.IsEmpty());
 
   v8::Local<v8::Object> v8_schema(v8::Local<v8::Object>::Cast(value));
//flaw_line_below:
  v8_schema->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen);
//fix_flaw_line_below:
//  DeepFreeze(v8_schema, context);
   schema_cache_->Set(api, v8_schema);
 
   return handle_scope.Escape(v8_schema);
}
",186227,"v8::Local<v8::Object> V8SchemaRegistry::GetSchema(const std::string& api) {
  if (schema_cache_ != NULL) {
    v8::Local<v8::Object> cached_schema = schema_cache_->Get(api);
    if (!cached_schema.IsEmpty()) {
      return cached_schema;
    }
  }


  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::EscapableHandleScope handle_scope(isolate);
  v8::Local<v8::Context> context = GetOrCreateContext(isolate);
  v8::Context::Scope context_scope(context);

  const base::DictionaryValue* schema =
      ExtensionAPI::GetSharedInstance()->GetSchema(api);
  CHECK(schema) << api;
  std::unique_ptr<V8ValueConverter> v8_value_converter(
      V8ValueConverter::create());
  v8::Local<v8::Value> value = v8_value_converter->ToV8Value(schema, context);
   CHECK(!value.IsEmpty());
 
   v8::Local<v8::Object> v8_schema(v8::Local<v8::Object>::Cast(value));
  v8_schema->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen);
   schema_cache_->Set(api, v8_schema);
 
   return handle_scope.Escape(v8_schema);
}
","v8::Local<v8::Object> V8SchemaRegistry::GetSchema(const std::string& api) {
  if (schema_cache_ != NULL) {
    v8::Local<v8::Object> cached_schema = schema_cache_->Get(api);
    if (!cached_schema.IsEmpty()) {
      return cached_schema;
    }
  }


  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::EscapableHandleScope handle_scope(isolate);
  v8::Local<v8::Context> context = GetOrCreateContext(isolate);
  v8::Context::Scope context_scope(context);

  const base::DictionaryValue* schema =
      ExtensionAPI::GetSharedInstance()->GetSchema(api);
  CHECK(schema) << api;
  std::unique_ptr<V8ValueConverter> v8_value_converter(
      V8ValueConverter::create());
  v8::Local<v8::Value> value = v8_value_converter->ToV8Value(schema, context);
   CHECK(!value.IsEmpty());
 
   v8::Local<v8::Object> v8_schema(v8::Local<v8::Object>::Cast(value));
  DeepFreeze(v8_schema, context);
   schema_cache_->Set(api, v8_schema);
 
   return handle_scope.Escape(v8_schema);
}
","The `GetSchema` function in the `V8SchemaRegistry` class retrieves a schema associated with a given API string. It first checks a cache for an existing schema; if found, it returns the cached version. If not, it creates a new V8 context and retrieves the schema from the `ExtensionAPI`. The schema is converted into a V8 value using a `V8ValueConverter`, ensuring it is not empty. The resulting V8 object is then set to a frozen integrity level for immutability and stored in the cache before being returned, ensuring efficient future access.","The provided code defines a function that retrieves a schema associated with a specified API. It first checks if the schema is already stored in a cache and returns it if available. If not, the function creates a new execution context and retrieves the schema from a shared instance. The schema is then converted into a specific format suitable for the execution environment, ensuring it is valid. The resulting object is marked as immutable to prevent modifications and is stored in the cache for future access, enhancing efficiency in subsequent retrievals.","The vulnerability in the original code stemmed from the use of `SetIntegrityLevel` to freeze the schema object, which may not have adequately prevented modifications to the schema's properties or methods, potentially leading to security issues. The fix involved replacing this with a more robust approach by using the `DeepFreeze` function, which ensures that the entire object, including its nested properties, is made immutable. This change enhances the integrity of the schema object, preventing any unintended alterations and addressing the identified security bugs, thereby reinforcing the overall stability and security of the code.","The vulnerability in the original code was related to insufficient protection of the schema object, which could allow unauthorized modifications, potentially compromising security. This inadequacy arose from a method that did not fully prevent changes to the schema's properties or methods. The fix implemented a more comprehensive approach to ensure that the entire schema object, including all its nested elements, was rendered immutable. This enhancement effectively eliminated the risk of unintended alterations, thereby addressing the identified security issues and reinforcing the integrity of the schema within the system.","The vulnerability was fixed by replacing the `SetIntegrityLevel` function with `DeepFreeze`, which ensures that not only the schema object itself but also all its nested properties are made immutable. This change guarantees that the schema cannot be altered in any way after it has been created, addressing the security concerns associated with potential modifications. By implementing this more robust freezing mechanism, the code enhances the integrity and security of the schema, effectively preventing unauthorized changes and ensuring that the schema remains consistent and reliable throughout its lifecycle.","The vulnerability was fixed by implementing a more comprehensive method to ensure the immutability of the schema object. Instead of using a previous approach that only partially protected the object, the new solution fully prevents any modifications to the schema and its nested properties. This enhancement effectively secures the schema against unauthorized changes, addressing the identified security issues. By ensuring that the entire structure is rendered immutable, the fix reinforces the integrity and reliability of the schema, thereby mitigating potential risks associated with data manipulation and enhancing overall system security.","3, 4","4,4","4,4","3, 3"
102,102,186512,186512,,Remote,Not required,,CVE-2016-5220,https://www.cvedetails.com/cve/CVE-2016-5220/,CWE-200,Medium,Partial,,,2017-01-19,4.3,"PDFium in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android incorrectly handled navigation within PDFs, which allowed a remote attacker to read local files via a crafted PDF file.",2018-01-04,+Info ,4,https://github.com/chromium/chromium/commit/c6f0d22d508a551a40fc8bd7418941b77435aac3,c6f0d22d508a551a40fc8bd7418941b77435aac3,"omnibox: experiment with restoring placeholder when caret shows

Shows the ""Search Google or type a URL"" omnibox placeholder even when
the caret (text edit cursor) is showing / when focused. views::Textfield
works this way, as does <input placeholder="""">. Omnibox and the NTP's
""fakebox"" are exceptions in this regard and this experiment makes this
more consistent.

R=tommycli@chromium.org
BUG=955585

Change-Id: I23c299c0973f2feb43f7a2be3bd3425a80b06c2d
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1582315
Commit-Queue: Dan Beam <dbeam@chromium.org>
Reviewed-by: Tommy Li <tommycli@chromium.org>
Cr-Commit-Position: refs/heads/master@{#654279}",1,chrome/browser/ui/views/omnibox/omnibox_view_views.cc,"{""sha"": ""c544137e4824456db82dd618232f66c8717d0ba3"", ""filename"": ""chrome/browser/ui/views/omnibox/omnibox_view_views.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c6f0d22d508a551a40fc8bd7418941b77435aac3/chrome/browser/ui/views/omnibox/omnibox_view_views.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c6f0d22d508a551a40fc8bd7418941b77435aac3/chrome/browser/ui/views/omnibox/omnibox_view_views.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/omnibox/omnibox_view_views.cc?ref=c6f0d22d508a551a40fc8bd7418941b77435aac3"", ""patch"": ""@@ -1420,8 +1420,11 @@ void OmniboxViewViews::ExecuteTextEditCommand(ui::TextEditCommand command) {\n }\n \n bool OmniboxViewViews::ShouldShowPlaceholderText() const {\n+  bool show_with_caret = base::FeatureList::IsEnabled(\n+      omnibox::kUIExperimentShowPlaceholderWhenCaretShowing);\n   return Textfield::ShouldShowPlaceholderText() &&\n-         !model()->is_caret_visible() && !model()->is_keyword_selected();\n+         (show_with_caret || !model()->is_caret_visible()) &&\n+         !model()->is_keyword_selected();\n }\n \n #if defined(OS_CHROMEOS)""}<_**next**_>{""sha"": ""cda0d0127a494001aaf3d688e8765a901000e7f2"", ""filename"": ""components/omnibox/common/omnibox_features.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c6f0d22d508a551a40fc8bd7418941b77435aac3/components/omnibox/common/omnibox_features.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c6f0d22d508a551a40fc8bd7418941b77435aac3/components/omnibox/common/omnibox_features.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/omnibox/common/omnibox_features.cc?ref=c6f0d22d508a551a40fc8bd7418941b77435aac3"", ""patch"": ""@@ -258,6 +258,14 @@ const base::Feature kUIExperimentUnboldSuggestionText{\n     \""OmniboxUIExperimentUnboldSuggestionText\"",\n     base::FEATURE_DISABLED_BY_DEFAULT};\n \n+// Shows the \""Search Google or type a URL\"" omnibox placeholder even when the\n+// caret (text edit cursor) is showing / when focused. views::Textfield works\n+// this way, as does <input placeholder=\""\"">. Omnibox and the NTP's \""fakebox\""\n+// are exceptions in this regard and this experiment makes this more consistent.\n+const base::Feature kUIExperimentShowPlaceholderWhenCaretShowing{\n+    \""OmniboxUIExperimentShowPlaceholderWhenCaretShowing\"",\n+    base::FEATURE_DISABLED_BY_DEFAULT};\n+\n // Feature used to enable speculatively starting a service worker associated\n // with the destination of the default match when the user's input looks like a\n // query.""}<_**next**_>{""sha"": ""02b8932de791771ceaed9b05898b32310decf352"", ""filename"": ""components/omnibox/common/omnibox_features.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c6f0d22d508a551a40fc8bd7418941b77435aac3/components/omnibox/common/omnibox_features.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c6f0d22d508a551a40fc8bd7418941b77435aac3/components/omnibox/common/omnibox_features.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/omnibox/common/omnibox_features.h?ref=c6f0d22d508a551a40fc8bd7418941b77435aac3"", ""patch"": ""@@ -9,6 +9,7 @@\n \n namespace omnibox {\n \n+// TODO(dbeam): why is this list not sorted alphabetically?\n extern const base::Feature kHideFileUrlScheme;\n extern const base::Feature kHideSteadyStateUrlScheme;\n extern const base::Feature kHideSteadyStateUrlTrivialSubdomains;\n@@ -45,6 +46,7 @@ extern const base::Feature kUIExperimentBoldUserTextOnSearchSuggestions;\n extern const base::Feature kUIExperimentWhiteBackgroundOnBlur;\n extern const base::Feature kUIExperimentUseGenericSearchEngineIcon;\n extern const base::Feature kUIExperimentUnboldSuggestionText;\n+extern const base::Feature kUIExperimentShowPlaceholderWhenCaretShowing;\n extern const base::Feature kSpeculativeServiceWorkerStartOnQueryInput;\n extern const base::Feature kDocumentProvider;\n extern const base::Feature kDedupeGoogleDriveURLs;""}"," bool OmniboxViewViews::ShouldShowPlaceholderText() const {
  bool show_with_caret = base::FeatureList::IsEnabled(
      omnibox::kUIExperimentShowPlaceholderWhenCaretShowing);
   return Textfield::ShouldShowPlaceholderText() &&
         (show_with_caret || !model()->is_caret_visible()) &&
         !model()->is_keyword_selected();
 }
"," bool OmniboxViewViews::ShouldShowPlaceholderText() const {
   return Textfield::ShouldShowPlaceholderText() &&
         !model()->is_caret_visible() && !model()->is_keyword_selected();
 }
",C,"  bool show_with_caret = base::FeatureList::IsEnabled(
      omnibox::kUIExperimentShowPlaceholderWhenCaretShowing);
         (show_with_caret || !model()->is_caret_visible()) &&
         !model()->is_keyword_selected();
","         !model()->is_caret_visible() && !model()->is_keyword_selected();
",,"@@ -1420,8 +1420,11 @@ void OmniboxViewViews::ExecuteTextEditCommand(ui::TextEditCommand command) {
 }
 
 bool OmniboxViewViews::ShouldShowPlaceholderText() const {
+  bool show_with_caret = base::FeatureList::IsEnabled(
+      omnibox::kUIExperimentShowPlaceholderWhenCaretShowing);
   return Textfield::ShouldShowPlaceholderText() &&
-         !model()->is_caret_visible() && !model()->is_keyword_selected();
+         (show_with_caret || !model()->is_caret_visible()) &&
+         !model()->is_keyword_selected();
 }
 
 #if defined(OS_CHROMEOS)",Chrome,c6f0d22d508a551a40fc8bd7418941b77435aac3,e953a30757c1b52bb57209f19d22bb2afce67a71,1," bool OmniboxViewViews::ShouldShowPlaceholderText() const {
//fix_flaw_line_below:
//  bool show_with_caret = base::FeatureList::IsEnabled(
//fix_flaw_line_below:
//      omnibox::kUIExperimentShowPlaceholderWhenCaretShowing);
   return Textfield::ShouldShowPlaceholderText() &&
//flaw_line_below:
         !model()->is_caret_visible() && !model()->is_keyword_selected();
//fix_flaw_line_below:
//         (show_with_caret || !model()->is_caret_visible()) &&
//fix_flaw_line_below:
//         !model()->is_keyword_selected();
 }
",186512," bool OmniboxViewViews::ShouldShowPlaceholderText() const {
   return Textfield::ShouldShowPlaceholderText() &&
         !model()->is_caret_visible() && !model()->is_keyword_selected();
 }
"," bool OmniboxViewViews::ShouldShowPlaceholderText() const {
  bool show_with_caret = base::FeatureList::IsEnabled(
      omnibox::kUIExperimentShowPlaceholderWhenCaretShowing);
   return Textfield::ShouldShowPlaceholderText() &&
         (show_with_caret || !model()->is_caret_visible()) &&
         !model()->is_keyword_selected();
 }
","The `ShouldShowPlaceholderText` function in the `OmniboxViewViews` class determines whether to display placeholder text in a text field. It returns a boolean value based on three conditions: first, it checks if the base class `Textfield` allows for placeholder text to be shown; second, it verifies that the caret (text cursor) is not currently visible; and third, it ensures that no keyword is selected in the model. If all these conditions are met, the function returns true, indicating that the placeholder text should be displayed; otherwise, it returns false.","The provided code defines a method that determines whether to display placeholder text in a user interface element. It evaluates several conditions to make this decision: it checks if the element is allowed to show placeholder text, ensures that the text cursor is not visible, and confirms that no specific keyword is currently selected. If all these criteria are satisfied, the method indicates that the placeholder text should be shown; otherwise, it indicates that it should not be displayed. This functionality enhances user experience by providing guidance when the input field is empty and not actively being edited.","The vulnerability in the original code stemmed from the fact that placeholder text was not displayed when the text cursor was visible, which deviated from standard behavior in similar UI elements. This inconsistency could confuse users, as they might expect to see placeholder text even when the input field is focused. The fixed code addresses this by introducing a feature flag, `show_with_caret`, which allows the placeholder to be displayed when the caret is visible, provided that the feature is enabled. This change aligns the behavior of the omnibox with other text fields, enhancing user experience and consistency.","The vulnerability in the original code was that it prevented the display of placeholder text when the text cursor was visible, which was inconsistent with standard user interface behavior found in other input fields. This could lead to user confusion, as they might expect to see guidance text even when the input area was focused. The fix introduced a feature that allows the placeholder to be shown while the cursor is present, aligning the omnibox's behavior with that of other text fields. This change enhances usability by providing consistent visual cues to users, regardless of the input state.","The vulnerability was fixed by introducing a feature flag, `show_with_caret`, which allows the placeholder text to be displayed even when the caret is visible. In the updated code, the condition for showing the placeholder now includes a check for this feature flag, enabling the placeholder to appear if the feature is enabled, regardless of the caret's visibility. This change modifies the return statement to incorporate the new condition, ensuring that the placeholder can be shown when the caret is present, thus aligning the omnibox's behavior with standard practices found in other text fields and enhancing user experience.","The vulnerability was addressed by implementing a feature that allows the placeholder text to be displayed even when the text cursor is visible. This was achieved by adding a condition that checks if the feature is enabled, thereby allowing the placeholder to appear regardless of the cursor's presence. The updated logic ensures that the placeholder can be shown when the input field is focused, aligning the behavior of the omnibox with standard practices found in other input elements. This change enhances user experience by providing consistent visual guidance, regardless of whether the input area is actively being edited.","5,5","5,5","4,5","4,4"
103,103,186671,186671,,Remote,Not required,,CVE-2018-6053,https://www.cvedetails.com/cve/CVE-2018-6053/,CWE-200,Medium,Partial,,,2018-09-25,4.3,Inappropriate implementation in New Tab Page in Google Chrome prior to 64.0.3282.119 allowed a local attacker to view website thumbnail images after clearing browser data via a crafted HTML page.,2018-11-20,+Info ,1,https://github.com/chromium/chromium/commit/6c6888565ff1fde9ef21ef17c27ad4c8304643d2,6c6888565ff1fde9ef21ef17c27ad4c8304643d2,"TopSites: Clear thumbnails from the cache when their URLs get removed

We already cleared the thumbnails from persistent storage, but they
remained in the in-memory cache, so they remained accessible (until the
next Chrome restart) even after all browsing data was cleared.

Bug: 758169
Change-Id: Id916d22358430a82e6d5043ac04fa463a32f824f
Reviewed-on: https://chromium-review.googlesource.com/758640
Commit-Queue: Marc Treib <treib@chromium.org>
Reviewed-by: Sylvain Defresne <sdefresne@chromium.org>
Cr-Commit-Position: refs/heads/master@{#514861}",0,components/history/core/browser/top_sites_impl.cc,"{""sha"": ""b4465d3320f655b2a573a60b87c494a553e5bcc6"", ""filename"": ""components/history/core/browser/top_sites_cache.cc"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 0, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/6c6888565ff1fde9ef21ef17c27ad4c8304643d2/components/history/core/browser/top_sites_cache.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/6c6888565ff1fde9ef21ef17c27ad4c8304643d2/components/history/core/browser/top_sites_cache.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/history/core/browser/top_sites_cache.cc?ref=6c6888565ff1fde9ef21ef17c27ad4c8304643d2"", ""patch"": ""@@ -39,6 +39,16 @@ void TopSitesCache::SetThumbnails(const URLToImagesMap& images) {\n   images_ = images;\n }\n \n+void TopSitesCache::ClearUnreferencedThumbnails() {\n+  URLToImagesMap images_to_keep;\n+  for (const std::pair<GURL, Images>& entry : images_) {\n+    if (IsKnownURL(entry.first)) {\n+      images_to_keep.insert(entry);\n+    }\n+  }\n+  images_ = std::move(images_to_keep);\n+}\n+\n Images* TopSitesCache::GetImage(const GURL& url) {\n   return &images_[GetCanonicalURL(url)];\n }""}<_**next**_>{""sha"": ""65f861e2124e4f989bc327c50387ea2a33707339"", ""filename"": ""components/history/core/browser/top_sites_cache.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/6c6888565ff1fde9ef21ef17c27ad4c8304643d2/components/history/core/browser/top_sites_cache.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/6c6888565ff1fde9ef21ef17c27ad4c8304643d2/components/history/core/browser/top_sites_cache.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/history/core/browser/top_sites_cache.h?ref=6c6888565ff1fde9ef21ef17c27ad4c8304643d2"", ""patch"": ""@@ -51,6 +51,8 @@ class TopSitesCache {\n   void SetThumbnails(const URLToImagesMap& images);\n   const URLToImagesMap& images() const { return images_; }\n \n+  void ClearUnreferencedThumbnails();\n+\n   // Returns the thumbnail as an Image for the specified url. This adds an entry\n   // for |url| if one has not yet been added.\n   Images* GetImage(const GURL& url);""}<_**next**_>{""sha"": ""c317f3cab7de728d14f97f10350feda71171fe95"", ""filename"": ""components/history/core/browser/top_sites_cache_unittest.cc"", ""status"": ""modified"", ""additions"": 46, ""deletions"": 0, ""changes"": 46, ""blob_url"": ""https://github.com/chromium/chromium/blob/6c6888565ff1fde9ef21ef17c27ad4c8304643d2/components/history/core/browser/top_sites_cache_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/6c6888565ff1fde9ef21ef17c27ad4c8304643d2/components/history/core/browser/top_sites_cache_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/history/core/browser/top_sites_cache_unittest.cc?ref=6c6888565ff1fde9ef21ef17c27ad4c8304643d2"", ""patch"": ""@@ -7,9 +7,12 @@\n #include <stddef.h>\n \n #include <set>\n+#include <string>\n+#include <vector>\n \n #include \""base/logging.h\""\n #include \""base/macros.h\""\n+#include \""base/memory/ref_counted_memory.h\""\n #include \""base/strings/string16.h\""\n #include \""base/strings/string_number_conversions.h\""\n #include \""base/strings/utf_string_conversions.h\""\n@@ -35,6 +38,11 @@ class TopSitesCacheTest : public testing::Test {\n   // Initializes |top_sites_| and |cache_| based on |spec|.\n   void InitTopSiteCache(const char** spec, size_t size);\n \n+  bool HasPageThumbnail(const GURL& url) {\n+    scoped_refptr<base::RefCountedMemory> memory;\n+    return cache_.GetPageThumbnail(url, &memory);\n+  }\n+\n   MostVisitedURLList top_sites_;\n   TopSitesCache cache_;\n \n@@ -255,6 +263,44 @@ TEST_F(TopSitesCacheTest, CacheForcedURLs) {\n   EXPECT_EQ(2u, cache_.GetNumNonForcedURLs());\n }\n \n+TEST_F(TopSitesCacheTest, ClearUnreferencedThumbnails) {\n+  InitTopSiteCache(kTopSitesSpecBasic, arraysize(kTopSitesSpecBasic));\n+\n+  // A \""primary\"" URL.\n+  const GURL url1(\""http://www.google.com\"");\n+  ASSERT_TRUE(cache_.IsKnownURL(url1));\n+  // A URL that's part of a redirect chain.\n+  const GURL url2(\""https://www.gogle.com\"");\n+  ASSERT_TRUE(cache_.IsKnownURL(url2));\n+\n+  // Add thumbnails for these two URLs.\n+  Images thumbnail1;\n+  thumbnail1.thumbnail =\n+      new base::RefCountedBytes(std::vector<unsigned char>());\n+  Images thumbnail2;\n+  thumbnail2.thumbnail =\n+      new base::RefCountedBytes(std::vector<unsigned char>());\n+  URLToImagesMap images;\n+  images[cache_.GetCanonicalURL(url1)] = thumbnail1;\n+  images[cache_.GetCanonicalURL(url2)] = thumbnail2;\n+  cache_.SetThumbnails(images);\n+\n+  ASSERT_TRUE(HasPageThumbnail(url1));\n+  ASSERT_TRUE(HasPageThumbnail(url2));\n+\n+  // Since both URLs are known, ClearUnreferencedThumbnails should do nothing.\n+  cache_.ClearUnreferencedThumbnails();\n+  EXPECT_TRUE(HasPageThumbnail(url1));\n+  EXPECT_TRUE(HasPageThumbnail(url2));\n+\n+  // After the top sites themselves are cleared, ClearUnreferencedThumbnails\n+  // should clear the corresponding thumbnails.\n+  cache_.SetTopSites(MostVisitedURLList());\n+  cache_.ClearUnreferencedThumbnails();\n+  EXPECT_FALSE(HasPageThumbnail(url1));\n+  EXPECT_FALSE(HasPageThumbnail(url2));\n+}\n+\n }  // namespace\n \n }  // namespace history""}<_**next**_>{""sha"": ""908fc22844a8a1d080ab18fcb182c603d44b49f8"", ""filename"": ""components/history/core/browser/top_sites_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/6c6888565ff1fde9ef21ef17c27ad4c8304643d2/components/history/core/browser/top_sites_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/6c6888565ff1fde9ef21ef17c27ad4c8304643d2/components/history/core/browser/top_sites_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/history/core/browser/top_sites_impl.cc?ref=6c6888565ff1fde9ef21ef17c27ad4c8304643d2"", ""patch"": ""@@ -756,6 +756,7 @@ void TopSitesImpl::SetTopSites(const MostVisitedURLList& new_top_sites,\n   // thread safe cache ...) as this method is invoked during startup at which\n   // point the caches haven't been updated yet.\n   cache_->SetTopSites(top_sites);\n+  cache_->ClearUnreferencedThumbnails();\n \n   // See if we have any temp thumbnails for the new sites, and promote them to\n   // proper thumbnails.""}<_**next**_>{""sha"": ""a47746b5cbb8235bf5dc539c11766aff43df1f14"", ""filename"": ""components/history/core/browser/top_sites_impl_unittest.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/6c6888565ff1fde9ef21ef17c27ad4c8304643d2/components/history/core/browser/top_sites_impl_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/6c6888565ff1fde9ef21ef17c27ad4c8304643d2/components/history/core/browser/top_sites_impl_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/history/core/browser/top_sites_impl_unittest.cc?ref=6c6888565ff1fde9ef21ef17c27ad4c8304643d2"", ""patch"": ""@@ -629,6 +629,8 @@ TEST_F(TopSitesImplTest, ThumbnailRemoved) {\n \n   // Reset the thumbnails and make sure we don't get it back.\n   SetTopSites(MostVisitedURLList());\n+  EXPECT_FALSE(top_sites()->GetPageThumbnail(url, false, &result));\n+  // Recreating the TopSites object should also not bring it back.\n   RefreshTopSitesAndRecreate();\n   EXPECT_FALSE(top_sites()->GetPageThumbnail(url, false, &result));\n }""}","void TopSitesImpl::SetTopSites(const MostVisitedURLList& new_top_sites,
                               const CallLocation location) {
  DCHECK(thread_checker_.CalledOnValidThread());

  MostVisitedURLList top_sites(new_top_sites);
  size_t num_forced_urls = MergeCachedForcedURLs(&top_sites);
  AddPrepopulatedPages(&top_sites, num_forced_urls);

  TopSitesDelta delta;
  DiffMostVisited(cache_->top_sites(), top_sites, &delta);

  TopSitesBackend::RecordHistogram record_or_not =
      TopSitesBackend::RECORD_HISTOGRAM_NO;

  if (location == CALL_LOCATION_FROM_ON_GOT_MOST_VISITED_THUMBNAILS &&
      !histogram_recorded_) {
    size_t delta_size =
        delta.deleted.size() + delta.added.size() + delta.moved.size();
    UMA_HISTOGRAM_COUNTS_100(""History.FirstSetTopSitesDeltaSize"", delta_size);
    record_or_not = TopSitesBackend::RECORD_HISTOGRAM_YES;
    histogram_recorded_ = true;
  }

  bool should_notify_observers = false;
  if (!delta.deleted.empty() || !delta.added.empty() || !delta.moved.empty()) {
    backend_->UpdateTopSites(delta, record_or_not);
    should_notify_observers = true;
  }
  if (!should_notify_observers)
    should_notify_observers = DoTitlesDiffer(cache_->top_sites(), top_sites);

   cache_->SetTopSites(top_sites);
  cache_->ClearUnreferencedThumbnails();
 
  if (!temp_images_.empty()) {
    for (const MostVisitedURL& mv : top_sites) {
      const GURL& canonical_url = cache_->GetCanonicalURL(mv.url);
      for (TempImages::iterator it = temp_images_.begin();
           it != temp_images_.end(); ++it) {
        if (canonical_url == cache_->GetCanonicalURL(it->first)) {
          bool success = SetPageThumbnailEncoded(
              mv.url, it->second.thumbnail.get(), it->second.thumbnail_score);
          if (success) {
            UMA_HISTOGRAM_ENUMERATION(""Thumbnails.AddedToTopSites"",
                                      THUMBNAIL_PROMOTED_TEMP_TO_REGULAR,
                                      THUMBNAIL_EVENT_COUNT);
          }
          temp_images_.erase(it);
          break;
        }
      }
    }
  }

  if (top_sites.size() - num_forced_urls >= kNonForcedTopSitesNumber)
    temp_images_.clear();

  ResetThreadSafeCache();
  ResetThreadSafeImageCache();

  if (should_notify_observers) {
    if (location == CALL_LOCATION_FROM_FORCED_URLS)
      NotifyTopSitesChanged(TopSitesObserver::ChangeReason::FORCED_URL);
    else
      NotifyTopSitesChanged(TopSitesObserver::ChangeReason::MOST_VISITED);
  }

}
","void TopSitesImpl::SetTopSites(const MostVisitedURLList& new_top_sites,
                               const CallLocation location) {
  DCHECK(thread_checker_.CalledOnValidThread());

  MostVisitedURLList top_sites(new_top_sites);
  size_t num_forced_urls = MergeCachedForcedURLs(&top_sites);
  AddPrepopulatedPages(&top_sites, num_forced_urls);

  TopSitesDelta delta;
  DiffMostVisited(cache_->top_sites(), top_sites, &delta);

  TopSitesBackend::RecordHistogram record_or_not =
      TopSitesBackend::RECORD_HISTOGRAM_NO;

  if (location == CALL_LOCATION_FROM_ON_GOT_MOST_VISITED_THUMBNAILS &&
      !histogram_recorded_) {
    size_t delta_size =
        delta.deleted.size() + delta.added.size() + delta.moved.size();
    UMA_HISTOGRAM_COUNTS_100(""History.FirstSetTopSitesDeltaSize"", delta_size);
    record_or_not = TopSitesBackend::RECORD_HISTOGRAM_YES;
    histogram_recorded_ = true;
  }

  bool should_notify_observers = false;
  if (!delta.deleted.empty() || !delta.added.empty() || !delta.moved.empty()) {
    backend_->UpdateTopSites(delta, record_or_not);
    should_notify_observers = true;
  }
  if (!should_notify_observers)
    should_notify_observers = DoTitlesDiffer(cache_->top_sites(), top_sites);

   cache_->SetTopSites(top_sites);
 
  if (!temp_images_.empty()) {
    for (const MostVisitedURL& mv : top_sites) {
      const GURL& canonical_url = cache_->GetCanonicalURL(mv.url);
      for (TempImages::iterator it = temp_images_.begin();
           it != temp_images_.end(); ++it) {
        if (canonical_url == cache_->GetCanonicalURL(it->first)) {
          bool success = SetPageThumbnailEncoded(
              mv.url, it->second.thumbnail.get(), it->second.thumbnail_score);
          if (success) {
            UMA_HISTOGRAM_ENUMERATION(""Thumbnails.AddedToTopSites"",
                                      THUMBNAIL_PROMOTED_TEMP_TO_REGULAR,
                                      THUMBNAIL_EVENT_COUNT);
          }
          temp_images_.erase(it);
          break;
        }
      }
    }
  }

  if (top_sites.size() - num_forced_urls >= kNonForcedTopSitesNumber)
    temp_images_.clear();

  ResetThreadSafeCache();
  ResetThreadSafeImageCache();

  if (should_notify_observers) {
    if (location == CALL_LOCATION_FROM_FORCED_URLS)
      NotifyTopSitesChanged(TopSitesObserver::ChangeReason::FORCED_URL);
    else
      NotifyTopSitesChanged(TopSitesObserver::ChangeReason::MOST_VISITED);
  }

}
",C,"  cache_->ClearUnreferencedThumbnails();
",,,"@@ -756,6 +756,7 @@ void TopSitesImpl::SetTopSites(const MostVisitedURLList& new_top_sites,
   // thread safe cache ...) as this method is invoked during startup at which
   // point the caches haven't been updated yet.
   cache_->SetTopSites(top_sites);
+  cache_->ClearUnreferencedThumbnails();
 
   // See if we have any temp thumbnails for the new sites, and promote them to
   // proper thumbnails.",Chrome,6c6888565ff1fde9ef21ef17c27ad4c8304643d2,757a87fd741f94f65167ef8ad8bfdd71ede7fc48,1,"void TopSitesImpl::SetTopSites(const MostVisitedURLList& new_top_sites,
                               const CallLocation location) {
  DCHECK(thread_checker_.CalledOnValidThread());

  MostVisitedURLList top_sites(new_top_sites);
  size_t num_forced_urls = MergeCachedForcedURLs(&top_sites);
  AddPrepopulatedPages(&top_sites, num_forced_urls);

  TopSitesDelta delta;
  DiffMostVisited(cache_->top_sites(), top_sites, &delta);

  TopSitesBackend::RecordHistogram record_or_not =
      TopSitesBackend::RECORD_HISTOGRAM_NO;

  // Record the delta size into a histogram if this function is called from
  // function OnGotMostVisitedThumbnails and no histogram value has been
  // recorded before.
  if (location == CALL_LOCATION_FROM_ON_GOT_MOST_VISITED_THUMBNAILS &&
      !histogram_recorded_) {
    size_t delta_size =
        delta.deleted.size() + delta.added.size() + delta.moved.size();
    UMA_HISTOGRAM_COUNTS_100(""History.FirstSetTopSitesDeltaSize"", delta_size);
    // Will be passed to TopSitesBackend to let it record the histogram too.
    record_or_not = TopSitesBackend::RECORD_HISTOGRAM_YES;
    // Change it to true so that the histogram will not be recorded any more.
    histogram_recorded_ = true;
  }

  bool should_notify_observers = false;
  // If there is a change in urls, update the db and notify observers.
  if (!delta.deleted.empty() || !delta.added.empty() || !delta.moved.empty()) {
    backend_->UpdateTopSites(delta, record_or_not);
    should_notify_observers = true;
  }
  // If there is no url change in top sites, check if the titles have changes.
  // Notify observers if there's a change in titles.
  if (!should_notify_observers)
    should_notify_observers = DoTitlesDiffer(cache_->top_sites(), top_sites);

  // We always do the following steps (setting top sites in cache, and resetting
   // thread safe cache ...) as this method is invoked during startup at which
   // point the caches haven't been updated yet.
   cache_->SetTopSites(top_sites);
//fix_flaw_line_below:
//  cache_->ClearUnreferencedThumbnails();
 
   // See if we have any temp thumbnails for the new sites, and promote them to
   // proper thumbnails.
  if (!temp_images_.empty()) {
    for (const MostVisitedURL& mv : top_sites) {
      const GURL& canonical_url = cache_->GetCanonicalURL(mv.url);
      // At the time we get the thumbnail redirects aren't known, so we have to
      // iterate through all the images.
      for (TempImages::iterator it = temp_images_.begin();
           it != temp_images_.end(); ++it) {
        if (canonical_url == cache_->GetCanonicalURL(it->first)) {
          bool success = SetPageThumbnailEncoded(
              mv.url, it->second.thumbnail.get(), it->second.thumbnail_score);
          // TODO(treib): We shouldn't have a non-temp thumbnail yet at this
          // point, so this should always succeed, but it doesn't - see
          // crbug.com/735395.
          if (success) {
            UMA_HISTOGRAM_ENUMERATION(""Thumbnails.AddedToTopSites"",
                                      THUMBNAIL_PROMOTED_TEMP_TO_REGULAR,
                                      THUMBNAIL_EVENT_COUNT);
          }
          temp_images_.erase(it);
          break;
        }
      }
    }
  }

  if (top_sites.size() - num_forced_urls >= kNonForcedTopSitesNumber)
    temp_images_.clear();

  ResetThreadSafeCache();
  ResetThreadSafeImageCache();

  if (should_notify_observers) {
    if (location == CALL_LOCATION_FROM_FORCED_URLS)
      NotifyTopSitesChanged(TopSitesObserver::ChangeReason::FORCED_URL);
    else
      NotifyTopSitesChanged(TopSitesObserver::ChangeReason::MOST_VISITED);
  }

}
",186671,"void TopSitesImpl::SetTopSites(const MostVisitedURLList& new_top_sites,
                               const CallLocation location) {
  DCHECK(thread_checker_.CalledOnValidThread());

  MostVisitedURLList top_sites(new_top_sites);
  size_t num_forced_urls = MergeCachedForcedURLs(&top_sites);
  AddPrepopulatedPages(&top_sites, num_forced_urls);

  TopSitesDelta delta;
  DiffMostVisited(cache_->top_sites(), top_sites, &delta);

  TopSitesBackend::RecordHistogram record_or_not =
      TopSitesBackend::RECORD_HISTOGRAM_NO;

  if (location == CALL_LOCATION_FROM_ON_GOT_MOST_VISITED_THUMBNAILS &&
      !histogram_recorded_) {
    size_t delta_size =
        delta.deleted.size() + delta.added.size() + delta.moved.size();
    UMA_HISTOGRAM_COUNTS_100(""History.FirstSetTopSitesDeltaSize"", delta_size);
    record_or_not = TopSitesBackend::RECORD_HISTOGRAM_YES;
    histogram_recorded_ = true;
  }

  bool should_notify_observers = false;
  if (!delta.deleted.empty() || !delta.added.empty() || !delta.moved.empty()) {
    backend_->UpdateTopSites(delta, record_or_not);
    should_notify_observers = true;
  }
  if (!should_notify_observers)
    should_notify_observers = DoTitlesDiffer(cache_->top_sites(), top_sites);

   cache_->SetTopSites(top_sites);
 
  if (!temp_images_.empty()) {
    for (const MostVisitedURL& mv : top_sites) {
      const GURL& canonical_url = cache_->GetCanonicalURL(mv.url);
      for (TempImages::iterator it = temp_images_.begin();
           it != temp_images_.end(); ++it) {
        if (canonical_url == cache_->GetCanonicalURL(it->first)) {
          bool success = SetPageThumbnailEncoded(
              mv.url, it->second.thumbnail.get(), it->second.thumbnail_score);
          if (success) {
            UMA_HISTOGRAM_ENUMERATION(""Thumbnails.AddedToTopSites"",
                                      THUMBNAIL_PROMOTED_TEMP_TO_REGULAR,
                                      THUMBNAIL_EVENT_COUNT);
          }
          temp_images_.erase(it);
          break;
        }
      }
    }
  }

  if (top_sites.size() - num_forced_urls >= kNonForcedTopSitesNumber)
    temp_images_.clear();

  ResetThreadSafeCache();
  ResetThreadSafeImageCache();

  if (should_notify_observers) {
    if (location == CALL_LOCATION_FROM_FORCED_URLS)
      NotifyTopSitesChanged(TopSitesObserver::ChangeReason::FORCED_URL);
    else
      NotifyTopSitesChanged(TopSitesObserver::ChangeReason::MOST_VISITED);
  }

}
","void TopSitesImpl::SetTopSites(const MostVisitedURLList& new_top_sites,
                               const CallLocation location) {
  DCHECK(thread_checker_.CalledOnValidThread());

  MostVisitedURLList top_sites(new_top_sites);
  size_t num_forced_urls = MergeCachedForcedURLs(&top_sites);
  AddPrepopulatedPages(&top_sites, num_forced_urls);

  TopSitesDelta delta;
  DiffMostVisited(cache_->top_sites(), top_sites, &delta);

  TopSitesBackend::RecordHistogram record_or_not =
      TopSitesBackend::RECORD_HISTOGRAM_NO;

  if (location == CALL_LOCATION_FROM_ON_GOT_MOST_VISITED_THUMBNAILS &&
      !histogram_recorded_) {
    size_t delta_size =
        delta.deleted.size() + delta.added.size() + delta.moved.size();
    UMA_HISTOGRAM_COUNTS_100(""History.FirstSetTopSitesDeltaSize"", delta_size);
    record_or_not = TopSitesBackend::RECORD_HISTOGRAM_YES;
    histogram_recorded_ = true;
  }

  bool should_notify_observers = false;
  if (!delta.deleted.empty() || !delta.added.empty() || !delta.moved.empty()) {
    backend_->UpdateTopSites(delta, record_or_not);
    should_notify_observers = true;
  }
  if (!should_notify_observers)
    should_notify_observers = DoTitlesDiffer(cache_->top_sites(), top_sites);

   cache_->SetTopSites(top_sites);
  cache_->ClearUnreferencedThumbnails();
 
  if (!temp_images_.empty()) {
    for (const MostVisitedURL& mv : top_sites) {
      const GURL& canonical_url = cache_->GetCanonicalURL(mv.url);
      for (TempImages::iterator it = temp_images_.begin();
           it != temp_images_.end(); ++it) {
        if (canonical_url == cache_->GetCanonicalURL(it->first)) {
          bool success = SetPageThumbnailEncoded(
              mv.url, it->second.thumbnail.get(), it->second.thumbnail_score);
          if (success) {
            UMA_HISTOGRAM_ENUMERATION(""Thumbnails.AddedToTopSites"",
                                      THUMBNAIL_PROMOTED_TEMP_TO_REGULAR,
                                      THUMBNAIL_EVENT_COUNT);
          }
          temp_images_.erase(it);
          break;
        }
      }
    }
  }

  if (top_sites.size() - num_forced_urls >= kNonForcedTopSitesNumber)
    temp_images_.clear();

  ResetThreadSafeCache();
  ResetThreadSafeImageCache();

  if (should_notify_observers) {
    if (location == CALL_LOCATION_FROM_FORCED_URLS)
      NotifyTopSitesChanged(TopSitesObserver::ChangeReason::FORCED_URL);
    else
      NotifyTopSitesChanged(TopSitesObserver::ChangeReason::MOST_VISITED);
  }

}
","The `SetTopSites` function updates the list of most visited URLs by merging new data with cached entries, handling forced URLs, and adding prepopulated pages. It calculates the differences between the current and new top sites, potentially recording histogram data based on the call location. If there are changes, it updates the backend and checks if observers need to be notified. The function also manages temporary images associated with the URLs, ensuring thumbnails are set correctly. Finally, it resets caches and notifies observers of any changes, distinguishing between forced and regular updates.","The function updates a list of frequently visited URLs by integrating new data with existing cached entries while managing specific forced URLs and adding predefined pages. It assesses the differences between the current and updated lists, potentially logging statistical data based on the context of the update. If changes are detected, it refreshes the backend and determines whether observers should be informed. Additionally, it processes temporary images linked to the URLs, ensuring that thumbnails are appropriately assigned. Finally, it clears caches and notifies observers of any modifications, distinguishing between mandatory and regular updates.","The vulnerability in the original code stemmed from the failure to clear thumbnails from the in-memory cache after their associated URLs were removed, allowing access to potentially sensitive data even after browsing data was cleared. This oversight meant that thumbnails persisted in memory until the next application restart, posing a privacy risk. The fix implemented in the updated code involved adding a call to `cache_->ClearUnreferencedThumbnails()`, ensuring that any thumbnails linked to deleted URLs were also removed from the in-memory cache, thereby enhancing data privacy and security by preventing unauthorized access to stale thumbnail data.","The vulnerability in the original code was due to the failure to remove thumbnails from the in-memory cache after their associated URLs were deleted, allowing access to potentially sensitive thumbnail data even after the browsing data had been cleared. This oversight meant that users could inadvertently access stale data until the application was restarted. The fix addressed this issue by implementing a mechanism to clear the thumbnails from the in-memory cache whenever the URLs were removed, ensuring that no residual data remained accessible, thereby enhancing user privacy and data security.","The vulnerability was fixed by adding a call to `cache_->ClearUnreferencedThumbnails()` in the updated code. This function ensures that any thumbnails associated with URLs that have been removed are also cleared from the in-memory cache. By implementing this change, the code now effectively removes stale thumbnail data, preventing it from being accessible after the browsing data has been cleared. This enhancement ensures that sensitive thumbnail information does not persist in memory until the next application restart, thereby improving user privacy and data security.","The vulnerability was addressed by implementing a mechanism to clear thumbnails from the in-memory cache whenever their associated URLs were removed. This change ensures that any thumbnail data that is no longer relevant is promptly deleted, preventing access to potentially sensitive information after browsing data has been cleared. By ensuring that stale data does not persist in memory until the next application restart, the fix significantly enhances user privacy and data security, effectively mitigating the risk of unauthorized access to outdated thumbnail information.","5,5","5, 5","5,5","4,4"
104,104,186771,186771,,Remote,Not required,,CVE-2018-6117,https://www.cvedetails.com/cve/CVE-2018-6117/,CWE-200,Medium,Partial,,,2019-01-09,4.3,Confusing settings in Autofill in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to obtain potentially sensitive information from process memory via a crafted HTML page.,2019-01-15,+Info ,3,https://github.com/chromium/chromium/commit/52f6eb4221430b6248fd5a59bec53bfef9fdd9a7,52f6eb4221430b6248fd5a59bec53bfef9fdd9a7,"[md-settings] Clarify Password Saving and Autofill Toggles

This change clarifies the wording around the password saving and
autofill toggles.

Bug: 822465
Cq-Include-Trybots: master.tryserver.chromium.linux:closure_compilation
Change-Id: I91b31fe61cd0754239f7908e8c04c7e69b72f670
Reviewed-on: https://chromium-review.googlesource.com/970541
Commit-Queue: Jan Wilken Dörrie <jdoerrie@chromium.org>
Reviewed-by: Vaclav Brozek <vabr@chromium.org>
Reviewed-by: Jochen Eisinger <jochen@chromium.org>
Cr-Commit-Position: refs/heads/master@{#544661}",0,chrome/browser/ui/webui/settings/md_settings_localized_strings_provider.cc,"{""sha"": ""2ce25524cf5dec0eb6f91951e97bfe2b16489d4a"", ""filename"": ""chrome/app/settings_strings.grdp"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/52f6eb4221430b6248fd5a59bec53bfef9fdd9a7/chrome/app/settings_strings.grdp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/52f6eb4221430b6248fd5a59bec53bfef9fdd9a7/chrome/app/settings_strings.grdp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/app/settings_strings.grdp?ref=52f6eb4221430b6248fd5a59bec53bfef9fdd9a7"", ""patch"": ""@@ -518,6 +518,9 @@\n   <message name=\""IDS_SETTINGS_GOOGLE_PAYMENTS\"" desc=\""Label used to differentiate when an address or credit card entry comes from Google Pay. This should follow the casing of the 'Google Pay' brand. 'Google Pay' should not be translated as it is the product name.\"">\n     Google Pay\n   </message>\n+  <message name=\""IDS_SETTINGS_AUTOFILL_TOGGLE_LABEL\"" desc=\""Label for a toggle that allows users to control whether forms should be autofilled with data such as addresses and credit cards, but not passwords.\"">\n+    Autofill forms\n+  </message>\n   <message name=\""IDS_SETTINGS_AUTOFILL_ADDRESSES_HEADING\"" desc=\""Title for the list of addresses that chrome has saved for use in filling in forms.\"">\n     Addresses\n   </message>\n@@ -581,6 +584,9 @@\n   <message name=\""IDS_SETTINGS_PASSWORDS\"" desc=\""Name for the password section and toggle\"">\n     Manage passwords\n   </message>\n+  <message name=\""IDS_SETTINGS_PASSWORDS_SAVE_PASSWORDS_TOGGLE_LABEL\"" desc=\""Label for a toggle that allows users to be prompted if they want to save their passwords when logging into webpages.\"">\n+    Offer to save passwords\n+  </message>\n   <message name=\""IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_LABEL\"" desc=\""Label for a checkbox that allows users to sign in automatically to websites when their credentials are already saved.\"">\n     Auto Sign-in\n   </message>""}<_**next**_>{""sha"": ""f45443606dceade6769cbaff49d05d1cfe3df0a8"", ""filename"": ""chrome/browser/resources/settings/passwords_and_forms_page/autofill_section.html"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/52f6eb4221430b6248fd5a59bec53bfef9fdd9a7/chrome/browser/resources/settings/passwords_and_forms_page/autofill_section.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/52f6eb4221430b6248fd5a59bec53bfef9fdd9a7/chrome/browser/resources/settings/passwords_and_forms_page/autofill_section.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/resources/settings/passwords_and_forms_page/autofill_section.html?ref=52f6eb4221430b6248fd5a59bec53bfef9fdd9a7"", ""patch"": ""@@ -65,9 +65,9 @@\n       }\n     </style>\n     <settings-toggle-button id=\""autofillToggle\""\n-        class=\""first primary-toggle\""\n+        class=\""first\""\n         aria-label=\""$i18n{autofill}\"" no-extension-indicator\n-        label=\""[[getOnOffLabel_(prefs.autofill.enabled.value)]]\""\n+        label=\""$i18n{autofillFormsLabel}\""\n         pref=\""{{prefs.autofill.enabled}}\"">\n     </settings-toggle-button>\n     <template is=\""dom-if\"" if=\""[[prefs.autofill.enabled.extensionId]]\"">""}<_**next**_>{""sha"": ""147f3ecfaff2882bff43a5d355cf003638c94c04"", ""filename"": ""chrome/browser/resources/settings/passwords_and_forms_page/passwords_section.html"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/52f6eb4221430b6248fd5a59bec53bfef9fdd9a7/chrome/browser/resources/settings/passwords_and_forms_page/passwords_section.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/52f6eb4221430b6248fd5a59bec53bfef9fdd9a7/chrome/browser/resources/settings/passwords_and_forms_page/passwords_section.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/resources/settings/passwords_and_forms_page/passwords_section.html?ref=52f6eb4221430b6248fd5a59bec53bfef9fdd9a7"", ""patch"": ""@@ -55,9 +55,9 @@\n       }\n    </style>\n     <settings-toggle-button id=\""passwordToggle\""\n-        class=\""first primary-toggle\""\n+        class=\""first\""\n         aria-label=\""$i18n{passwords}\"" no-extension-indicator\n-        label=\""[[getOnOffLabel_(prefs.credentials_enable_service.value)]]\""\n+        label=\""$i18n{passwordsSavePasswordsLabel}\""\n         pref=\""{{prefs.credentials_enable_service}}\"">\n     </settings-toggle-button>\n     <template is=\""dom-if\""""}<_**next**_>{""sha"": ""4425a0d7df501120c6098c6dd17bf9bf37cd2524"", ""filename"": ""chrome/browser/ui/webui/settings/md_settings_localized_strings_provider.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/52f6eb4221430b6248fd5a59bec53bfef9fdd9a7/chrome/browser/ui/webui/settings/md_settings_localized_strings_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/52f6eb4221430b6248fd5a59bec53bfef9fdd9a7/chrome/browser/ui/webui/settings/md_settings_localized_strings_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/webui/settings/md_settings_localized_strings_provider.cc?ref=52f6eb4221430b6248fd5a59bec53bfef9fdd9a7"", ""patch"": ""@@ -1319,6 +1319,7 @@ void AddPasswordsAndFormsStrings(content::WebUIDataSource* html_source) {\n       {\""autofill\"", IDS_SETTINGS_AUTOFILL},\n       {\""googlePayments\"", IDS_SETTINGS_GOOGLE_PAYMENTS},\n       {\""googlePaymentsCached\"", IDS_SETTINGS_GOOGLE_PAYMENTS_CACHED},\n+      {\""autofillFormsLabel\"", IDS_SETTINGS_AUTOFILL_TOGGLE_LABEL},\n       {\""addresses\"", IDS_SETTINGS_AUTOFILL_ADDRESSES_HEADING},\n       {\""addAddressTitle\"", IDS_SETTINGS_AUTOFILL_ADDRESSES_ADD_TITLE},\n       {\""editAddressTitle\"", IDS_SETTINGS_AUTOFILL_ADDRESSES_EDIT_TITLE},\n@@ -1340,6 +1341,8 @@ void AddPasswordsAndFormsStrings(content::WebUIDataSource* html_source) {\n       {\""addCreditCardTitle\"", IDS_SETTINGS_ADD_CREDIT_CARD_TITLE},\n       {\""autofillDetail\"", IDS_SETTINGS_AUTOFILL_DETAIL},\n       {\""passwords\"", IDS_SETTINGS_PASSWORDS},\n+      {\""passwordsSavePasswordsLabel\"",\n+       IDS_SETTINGS_PASSWORDS_SAVE_PASSWORDS_TOGGLE_LABEL},\n       {\""passwordsAutosigninLabel\"",\n        IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_LABEL},\n       {\""passwordsAutosigninDescription\"",""}","void AddPasswordsAndFormsStrings(content::WebUIDataSource* html_source) {
  LocalizedString localized_strings[] = {
      {""passwordsAndAutofillPageTitle"",
       IDS_SETTINGS_PASSWORDS_AND_AUTOFILL_PAGE_TITLE},
       {""autofill"", IDS_SETTINGS_AUTOFILL},
       {""googlePayments"", IDS_SETTINGS_GOOGLE_PAYMENTS},
       {""googlePaymentsCached"", IDS_SETTINGS_GOOGLE_PAYMENTS_CACHED},
      {""autofillFormsLabel"", IDS_SETTINGS_AUTOFILL_TOGGLE_LABEL},
       {""addresses"", IDS_SETTINGS_AUTOFILL_ADDRESSES_HEADING},
       {""addAddressTitle"", IDS_SETTINGS_AUTOFILL_ADDRESSES_ADD_TITLE},
       {""editAddressTitle"", IDS_SETTINGS_AUTOFILL_ADDRESSES_EDIT_TITLE},
      {""addressCountry"", IDS_SETTINGS_AUTOFILL_ADDRESSES_COUNTRY},
      {""addressPhone"", IDS_SETTINGS_AUTOFILL_ADDRESSES_PHONE},
      {""addressEmail"", IDS_SETTINGS_AUTOFILL_ADDRESSES_EMAIL},
      {""removeAddress"", IDS_SETTINGS_ADDRESS_REMOVE},
      {""creditCards"", IDS_SETTINGS_AUTOFILL_CREDIT_CARD_HEADING},
      {""removeCreditCard"", IDS_SETTINGS_CREDIT_CARD_REMOVE},
      {""clearCreditCard"", IDS_SETTINGS_CREDIT_CARD_CLEAR},
      {""creditCardType"", IDS_SETTINGS_AUTOFILL_CREDIT_CARD_TYPE_COLUMN_LABEL},
      {""creditCardExpiration"", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_DATE},
      {""creditCardName"", IDS_SETTINGS_NAME_ON_CREDIT_CARD},
      {""creditCardNumber"", IDS_SETTINGS_CREDIT_CARD_NUMBER},
      {""creditCardExpirationMonth"", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_MONTH},
      {""creditCardExpirationYear"", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_YEAR},
      {""creditCardExpired"", IDS_SETTINGS_CREDIT_CARD_EXPIRED},
      {""editCreditCardTitle"", IDS_SETTINGS_EDIT_CREDIT_CARD_TITLE},
       {""addCreditCardTitle"", IDS_SETTINGS_ADD_CREDIT_CARD_TITLE},
       {""autofillDetail"", IDS_SETTINGS_AUTOFILL_DETAIL},
       {""passwords"", IDS_SETTINGS_PASSWORDS},
      {""passwordsSavePasswordsLabel"",
       IDS_SETTINGS_PASSWORDS_SAVE_PASSWORDS_TOGGLE_LABEL},
       {""passwordsAutosigninLabel"",
        IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_LABEL},
       {""passwordsAutosigninDescription"",
       IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_DESC},
      {""passwordsDetail"", IDS_SETTINGS_PASSWORDS_DETAIL},
      {""savedPasswordsHeading"", IDS_SETTINGS_PASSWORDS_SAVED_HEADING},
      {""passwordExceptionsHeading"", IDS_SETTINGS_PASSWORDS_EXCEPTIONS_HEADING},
      {""deletePasswordException"", IDS_SETTINGS_PASSWORDS_DELETE_EXCEPTION},
      {""removePassword"", IDS_SETTINGS_PASSWORD_REMOVE},
      {""searchPasswords"", IDS_SETTINGS_PASSWORD_SEARCH},
      {""showPassword"", IDS_SETTINGS_PASSWORD_SHOW},
      {""hidePassword"", IDS_SETTINGS_PASSWORD_HIDE},
      {""passwordDetailsTitle"", IDS_SETTINGS_PASSWORDS_VIEW_DETAILS_TITLE},
      {""passwordViewDetails"", IDS_SETTINGS_PASSWORD_DETAILS},
      {""editPasswordWebsiteLabel"", IDS_SETTINGS_PASSWORDS_WEBSITE},
      {""editPasswordUsernameLabel"", IDS_SETTINGS_PASSWORDS_USERNAME},
      {""editPasswordPasswordLabel"", IDS_SETTINGS_PASSWORDS_PASSWORD},
      {""noAddressesFound"", IDS_SETTINGS_ADDRESS_NONE},
      {""noCreditCardsFound"", IDS_SETTINGS_CREDIT_CARD_NONE},
      {""noCreditCardsPolicy"", IDS_SETTINGS_CREDIT_CARD_DISABLED},
      {""noPasswordsFound"", IDS_SETTINGS_PASSWORDS_NONE},
      {""noExceptionsFound"", IDS_SETTINGS_PASSWORDS_EXCEPTIONS_NONE},
      {""import"", IDS_PASSWORD_MANAGER_IMPORT_BUTTON},
      {""exportMenuItem"", IDS_SETTINGS_PASSWORDS_EXPORT_MENU_ITEM},
      {""undoRemovePassword"", IDS_SETTINGS_PASSWORD_UNDO},
      {""passwordDeleted"", IDS_SETTINGS_PASSWORD_DELETED_PASSWORD},
      {""exportPasswordsTitle"", IDS_SETTINGS_PASSWORDS_EXPORT_TITLE},
      {""exportPasswordsDescription"", IDS_SETTINGS_PASSWORDS_EXPORT_DESCRIPTION},
      {""exportPasswords"", IDS_SETTINGS_PASSWORDS_EXPORT},
      {""exportingPasswordsTitle"", IDS_SETTINGS_PASSWORDS_EXPORTING_TITLE},
      {""exportPasswordsTryAgain"", IDS_SETTINGS_PASSWORDS_EXPORT_TRY_AGAIN},
      {""exportPasswordsFailTitle"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TITLE},
      {""exportPasswordsFailTips"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIPS},
      {""exportPasswordsFailTipsEnoughSpace"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIP_ENOUGH_SPACE},
      {""exportPasswordsFailTipsAnotherFolder"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIP_ANOTHER_FOLDER}};

  html_source->AddString(
      ""managePasswordsLabel"",
      l10n_util::GetStringFUTF16(
          IDS_SETTINGS_PASSWORDS_MANAGE_PASSWORDS,
          base::ASCIIToUTF16(
              password_manager::kPasswordManagerAccountDashboardURL)));
  html_source->AddString(""passwordManagerLearnMoreURL"",
                         chrome::kPasswordManagerLearnMoreURL);
  html_source->AddString(""manageAddressesUrl"",
                         autofill::payments::GetManageAddressesUrl(0).spec());
  html_source->AddString(""manageCreditCardsUrl"",
                         autofill::payments::GetManageInstrumentsUrl(0).spec());

  AddLocalizedStringsBulk(html_source, localized_strings,
                          arraysize(localized_strings));
}
","void AddPasswordsAndFormsStrings(content::WebUIDataSource* html_source) {
  LocalizedString localized_strings[] = {
      {""passwordsAndAutofillPageTitle"",
       IDS_SETTINGS_PASSWORDS_AND_AUTOFILL_PAGE_TITLE},
       {""autofill"", IDS_SETTINGS_AUTOFILL},
       {""googlePayments"", IDS_SETTINGS_GOOGLE_PAYMENTS},
       {""googlePaymentsCached"", IDS_SETTINGS_GOOGLE_PAYMENTS_CACHED},
       {""addresses"", IDS_SETTINGS_AUTOFILL_ADDRESSES_HEADING},
       {""addAddressTitle"", IDS_SETTINGS_AUTOFILL_ADDRESSES_ADD_TITLE},
       {""editAddressTitle"", IDS_SETTINGS_AUTOFILL_ADDRESSES_EDIT_TITLE},
      {""addressCountry"", IDS_SETTINGS_AUTOFILL_ADDRESSES_COUNTRY},
      {""addressPhone"", IDS_SETTINGS_AUTOFILL_ADDRESSES_PHONE},
      {""addressEmail"", IDS_SETTINGS_AUTOFILL_ADDRESSES_EMAIL},
      {""removeAddress"", IDS_SETTINGS_ADDRESS_REMOVE},
      {""creditCards"", IDS_SETTINGS_AUTOFILL_CREDIT_CARD_HEADING},
      {""removeCreditCard"", IDS_SETTINGS_CREDIT_CARD_REMOVE},
      {""clearCreditCard"", IDS_SETTINGS_CREDIT_CARD_CLEAR},
      {""creditCardType"", IDS_SETTINGS_AUTOFILL_CREDIT_CARD_TYPE_COLUMN_LABEL},
      {""creditCardExpiration"", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_DATE},
      {""creditCardName"", IDS_SETTINGS_NAME_ON_CREDIT_CARD},
      {""creditCardNumber"", IDS_SETTINGS_CREDIT_CARD_NUMBER},
      {""creditCardExpirationMonth"", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_MONTH},
      {""creditCardExpirationYear"", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_YEAR},
      {""creditCardExpired"", IDS_SETTINGS_CREDIT_CARD_EXPIRED},
      {""editCreditCardTitle"", IDS_SETTINGS_EDIT_CREDIT_CARD_TITLE},
       {""addCreditCardTitle"", IDS_SETTINGS_ADD_CREDIT_CARD_TITLE},
       {""autofillDetail"", IDS_SETTINGS_AUTOFILL_DETAIL},
       {""passwords"", IDS_SETTINGS_PASSWORDS},
       {""passwordsAutosigninLabel"",
        IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_LABEL},
       {""passwordsAutosigninDescription"",
       IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_DESC},
      {""passwordsDetail"", IDS_SETTINGS_PASSWORDS_DETAIL},
      {""savedPasswordsHeading"", IDS_SETTINGS_PASSWORDS_SAVED_HEADING},
      {""passwordExceptionsHeading"", IDS_SETTINGS_PASSWORDS_EXCEPTIONS_HEADING},
      {""deletePasswordException"", IDS_SETTINGS_PASSWORDS_DELETE_EXCEPTION},
      {""removePassword"", IDS_SETTINGS_PASSWORD_REMOVE},
      {""searchPasswords"", IDS_SETTINGS_PASSWORD_SEARCH},
      {""showPassword"", IDS_SETTINGS_PASSWORD_SHOW},
      {""hidePassword"", IDS_SETTINGS_PASSWORD_HIDE},
      {""passwordDetailsTitle"", IDS_SETTINGS_PASSWORDS_VIEW_DETAILS_TITLE},
      {""passwordViewDetails"", IDS_SETTINGS_PASSWORD_DETAILS},
      {""editPasswordWebsiteLabel"", IDS_SETTINGS_PASSWORDS_WEBSITE},
      {""editPasswordUsernameLabel"", IDS_SETTINGS_PASSWORDS_USERNAME},
      {""editPasswordPasswordLabel"", IDS_SETTINGS_PASSWORDS_PASSWORD},
      {""noAddressesFound"", IDS_SETTINGS_ADDRESS_NONE},
      {""noCreditCardsFound"", IDS_SETTINGS_CREDIT_CARD_NONE},
      {""noCreditCardsPolicy"", IDS_SETTINGS_CREDIT_CARD_DISABLED},
      {""noPasswordsFound"", IDS_SETTINGS_PASSWORDS_NONE},
      {""noExceptionsFound"", IDS_SETTINGS_PASSWORDS_EXCEPTIONS_NONE},
      {""import"", IDS_PASSWORD_MANAGER_IMPORT_BUTTON},
      {""exportMenuItem"", IDS_SETTINGS_PASSWORDS_EXPORT_MENU_ITEM},
      {""undoRemovePassword"", IDS_SETTINGS_PASSWORD_UNDO},
      {""passwordDeleted"", IDS_SETTINGS_PASSWORD_DELETED_PASSWORD},
      {""exportPasswordsTitle"", IDS_SETTINGS_PASSWORDS_EXPORT_TITLE},
      {""exportPasswordsDescription"", IDS_SETTINGS_PASSWORDS_EXPORT_DESCRIPTION},
      {""exportPasswords"", IDS_SETTINGS_PASSWORDS_EXPORT},
      {""exportingPasswordsTitle"", IDS_SETTINGS_PASSWORDS_EXPORTING_TITLE},
      {""exportPasswordsTryAgain"", IDS_SETTINGS_PASSWORDS_EXPORT_TRY_AGAIN},
      {""exportPasswordsFailTitle"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TITLE},
      {""exportPasswordsFailTips"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIPS},
      {""exportPasswordsFailTipsEnoughSpace"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIP_ENOUGH_SPACE},
      {""exportPasswordsFailTipsAnotherFolder"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIP_ANOTHER_FOLDER}};

  html_source->AddString(
      ""managePasswordsLabel"",
      l10n_util::GetStringFUTF16(
          IDS_SETTINGS_PASSWORDS_MANAGE_PASSWORDS,
          base::ASCIIToUTF16(
              password_manager::kPasswordManagerAccountDashboardURL)));
  html_source->AddString(""passwordManagerLearnMoreURL"",
                         chrome::kPasswordManagerLearnMoreURL);
  html_source->AddString(""manageAddressesUrl"",
                         autofill::payments::GetManageAddressesUrl(0).spec());
  html_source->AddString(""manageCreditCardsUrl"",
                         autofill::payments::GetManageInstrumentsUrl(0).spec());

  AddLocalizedStringsBulk(html_source, localized_strings,
                          arraysize(localized_strings));
}
",C,"      {""autofillFormsLabel"", IDS_SETTINGS_AUTOFILL_TOGGLE_LABEL},
      {""passwordsSavePasswordsLabel"",
       IDS_SETTINGS_PASSWORDS_SAVE_PASSWORDS_TOGGLE_LABEL},
",,,"@@ -1319,6 +1319,7 @@ void AddPasswordsAndFormsStrings(content::WebUIDataSource* html_source) {
       {""autofill"", IDS_SETTINGS_AUTOFILL},
       {""googlePayments"", IDS_SETTINGS_GOOGLE_PAYMENTS},
       {""googlePaymentsCached"", IDS_SETTINGS_GOOGLE_PAYMENTS_CACHED},
+      {""autofillFormsLabel"", IDS_SETTINGS_AUTOFILL_TOGGLE_LABEL},
       {""addresses"", IDS_SETTINGS_AUTOFILL_ADDRESSES_HEADING},
       {""addAddressTitle"", IDS_SETTINGS_AUTOFILL_ADDRESSES_ADD_TITLE},
       {""editAddressTitle"", IDS_SETTINGS_AUTOFILL_ADDRESSES_EDIT_TITLE},
@@ -1340,6 +1341,8 @@ void AddPasswordsAndFormsStrings(content::WebUIDataSource* html_source) {
       {""addCreditCardTitle"", IDS_SETTINGS_ADD_CREDIT_CARD_TITLE},
       {""autofillDetail"", IDS_SETTINGS_AUTOFILL_DETAIL},
       {""passwords"", IDS_SETTINGS_PASSWORDS},
+      {""passwordsSavePasswordsLabel"",
+       IDS_SETTINGS_PASSWORDS_SAVE_PASSWORDS_TOGGLE_LABEL},
       {""passwordsAutosigninLabel"",
        IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_LABEL},
       {""passwordsAutosigninDescription"",",Chrome,52f6eb4221430b6248fd5a59bec53bfef9fdd9a7,fae0a74cddbda921bb57b22c37dbf5525d4d5da2,1,"void AddPasswordsAndFormsStrings(content::WebUIDataSource* html_source) {
  LocalizedString localized_strings[] = {
      {""passwordsAndAutofillPageTitle"",
       IDS_SETTINGS_PASSWORDS_AND_AUTOFILL_PAGE_TITLE},
       {""autofill"", IDS_SETTINGS_AUTOFILL},
       {""googlePayments"", IDS_SETTINGS_GOOGLE_PAYMENTS},
       {""googlePaymentsCached"", IDS_SETTINGS_GOOGLE_PAYMENTS_CACHED},
//fix_flaw_line_below:
//      {""autofillFormsLabel"", IDS_SETTINGS_AUTOFILL_TOGGLE_LABEL},
       {""addresses"", IDS_SETTINGS_AUTOFILL_ADDRESSES_HEADING},
       {""addAddressTitle"", IDS_SETTINGS_AUTOFILL_ADDRESSES_ADD_TITLE},
       {""editAddressTitle"", IDS_SETTINGS_AUTOFILL_ADDRESSES_EDIT_TITLE},
      {""addressCountry"", IDS_SETTINGS_AUTOFILL_ADDRESSES_COUNTRY},
      {""addressPhone"", IDS_SETTINGS_AUTOFILL_ADDRESSES_PHONE},
      {""addressEmail"", IDS_SETTINGS_AUTOFILL_ADDRESSES_EMAIL},
      {""removeAddress"", IDS_SETTINGS_ADDRESS_REMOVE},
      {""creditCards"", IDS_SETTINGS_AUTOFILL_CREDIT_CARD_HEADING},
      {""removeCreditCard"", IDS_SETTINGS_CREDIT_CARD_REMOVE},
      {""clearCreditCard"", IDS_SETTINGS_CREDIT_CARD_CLEAR},
      {""creditCardType"", IDS_SETTINGS_AUTOFILL_CREDIT_CARD_TYPE_COLUMN_LABEL},
      {""creditCardExpiration"", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_DATE},
      {""creditCardName"", IDS_SETTINGS_NAME_ON_CREDIT_CARD},
      {""creditCardNumber"", IDS_SETTINGS_CREDIT_CARD_NUMBER},
      {""creditCardExpirationMonth"", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_MONTH},
      {""creditCardExpirationYear"", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_YEAR},
      {""creditCardExpired"", IDS_SETTINGS_CREDIT_CARD_EXPIRED},
      {""editCreditCardTitle"", IDS_SETTINGS_EDIT_CREDIT_CARD_TITLE},
       {""addCreditCardTitle"", IDS_SETTINGS_ADD_CREDIT_CARD_TITLE},
       {""autofillDetail"", IDS_SETTINGS_AUTOFILL_DETAIL},
       {""passwords"", IDS_SETTINGS_PASSWORDS},
//fix_flaw_line_below:
//      {""passwordsSavePasswordsLabel"",
//fix_flaw_line_below:
//       IDS_SETTINGS_PASSWORDS_SAVE_PASSWORDS_TOGGLE_LABEL},
       {""passwordsAutosigninLabel"",
        IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_LABEL},
       {""passwordsAutosigninDescription"",
       IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_DESC},
      {""passwordsDetail"", IDS_SETTINGS_PASSWORDS_DETAIL},
      {""savedPasswordsHeading"", IDS_SETTINGS_PASSWORDS_SAVED_HEADING},
      {""passwordExceptionsHeading"", IDS_SETTINGS_PASSWORDS_EXCEPTIONS_HEADING},
      {""deletePasswordException"", IDS_SETTINGS_PASSWORDS_DELETE_EXCEPTION},
      {""removePassword"", IDS_SETTINGS_PASSWORD_REMOVE},
      {""searchPasswords"", IDS_SETTINGS_PASSWORD_SEARCH},
      {""showPassword"", IDS_SETTINGS_PASSWORD_SHOW},
      {""hidePassword"", IDS_SETTINGS_PASSWORD_HIDE},
      {""passwordDetailsTitle"", IDS_SETTINGS_PASSWORDS_VIEW_DETAILS_TITLE},
      {""passwordViewDetails"", IDS_SETTINGS_PASSWORD_DETAILS},
      {""editPasswordWebsiteLabel"", IDS_SETTINGS_PASSWORDS_WEBSITE},
      {""editPasswordUsernameLabel"", IDS_SETTINGS_PASSWORDS_USERNAME},
      {""editPasswordPasswordLabel"", IDS_SETTINGS_PASSWORDS_PASSWORD},
      {""noAddressesFound"", IDS_SETTINGS_ADDRESS_NONE},
      {""noCreditCardsFound"", IDS_SETTINGS_CREDIT_CARD_NONE},
      {""noCreditCardsPolicy"", IDS_SETTINGS_CREDIT_CARD_DISABLED},
      {""noPasswordsFound"", IDS_SETTINGS_PASSWORDS_NONE},
      {""noExceptionsFound"", IDS_SETTINGS_PASSWORDS_EXCEPTIONS_NONE},
      {""import"", IDS_PASSWORD_MANAGER_IMPORT_BUTTON},
      {""exportMenuItem"", IDS_SETTINGS_PASSWORDS_EXPORT_MENU_ITEM},
      {""undoRemovePassword"", IDS_SETTINGS_PASSWORD_UNDO},
      {""passwordDeleted"", IDS_SETTINGS_PASSWORD_DELETED_PASSWORD},
      {""exportPasswordsTitle"", IDS_SETTINGS_PASSWORDS_EXPORT_TITLE},
      {""exportPasswordsDescription"", IDS_SETTINGS_PASSWORDS_EXPORT_DESCRIPTION},
      {""exportPasswords"", IDS_SETTINGS_PASSWORDS_EXPORT},
      {""exportingPasswordsTitle"", IDS_SETTINGS_PASSWORDS_EXPORTING_TITLE},
      {""exportPasswordsTryAgain"", IDS_SETTINGS_PASSWORDS_EXPORT_TRY_AGAIN},
      {""exportPasswordsFailTitle"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TITLE},
      {""exportPasswordsFailTips"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIPS},
      {""exportPasswordsFailTipsEnoughSpace"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIP_ENOUGH_SPACE},
      {""exportPasswordsFailTipsAnotherFolder"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIP_ANOTHER_FOLDER}};

  html_source->AddString(
      ""managePasswordsLabel"",
      l10n_util::GetStringFUTF16(
          IDS_SETTINGS_PASSWORDS_MANAGE_PASSWORDS,
          base::ASCIIToUTF16(
              password_manager::kPasswordManagerAccountDashboardURL)));
  html_source->AddString(""passwordManagerLearnMoreURL"",
                         chrome::kPasswordManagerLearnMoreURL);
  html_source->AddString(""manageAddressesUrl"",
                         autofill::payments::GetManageAddressesUrl(0).spec());
  html_source->AddString(""manageCreditCardsUrl"",
                         autofill::payments::GetManageInstrumentsUrl(0).spec());

  AddLocalizedStringsBulk(html_source, localized_strings,
                          arraysize(localized_strings));
}
",186771,"void AddPasswordsAndFormsStrings(content::WebUIDataSource* html_source) {
  LocalizedString localized_strings[] = {
      {""passwordsAndAutofillPageTitle"",
       IDS_SETTINGS_PASSWORDS_AND_AUTOFILL_PAGE_TITLE},
       {""autofill"", IDS_SETTINGS_AUTOFILL},
       {""googlePayments"", IDS_SETTINGS_GOOGLE_PAYMENTS},
       {""googlePaymentsCached"", IDS_SETTINGS_GOOGLE_PAYMENTS_CACHED},
       {""addresses"", IDS_SETTINGS_AUTOFILL_ADDRESSES_HEADING},
       {""addAddressTitle"", IDS_SETTINGS_AUTOFILL_ADDRESSES_ADD_TITLE},
       {""editAddressTitle"", IDS_SETTINGS_AUTOFILL_ADDRESSES_EDIT_TITLE},
      {""addressCountry"", IDS_SETTINGS_AUTOFILL_ADDRESSES_COUNTRY},
      {""addressPhone"", IDS_SETTINGS_AUTOFILL_ADDRESSES_PHONE},
      {""addressEmail"", IDS_SETTINGS_AUTOFILL_ADDRESSES_EMAIL},
      {""removeAddress"", IDS_SETTINGS_ADDRESS_REMOVE},
      {""creditCards"", IDS_SETTINGS_AUTOFILL_CREDIT_CARD_HEADING},
      {""removeCreditCard"", IDS_SETTINGS_CREDIT_CARD_REMOVE},
      {""clearCreditCard"", IDS_SETTINGS_CREDIT_CARD_CLEAR},
      {""creditCardType"", IDS_SETTINGS_AUTOFILL_CREDIT_CARD_TYPE_COLUMN_LABEL},
      {""creditCardExpiration"", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_DATE},
      {""creditCardName"", IDS_SETTINGS_NAME_ON_CREDIT_CARD},
      {""creditCardNumber"", IDS_SETTINGS_CREDIT_CARD_NUMBER},
      {""creditCardExpirationMonth"", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_MONTH},
      {""creditCardExpirationYear"", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_YEAR},
      {""creditCardExpired"", IDS_SETTINGS_CREDIT_CARD_EXPIRED},
      {""editCreditCardTitle"", IDS_SETTINGS_EDIT_CREDIT_CARD_TITLE},
       {""addCreditCardTitle"", IDS_SETTINGS_ADD_CREDIT_CARD_TITLE},
       {""autofillDetail"", IDS_SETTINGS_AUTOFILL_DETAIL},
       {""passwords"", IDS_SETTINGS_PASSWORDS},
       {""passwordsAutosigninLabel"",
        IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_LABEL},
       {""passwordsAutosigninDescription"",
       IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_DESC},
      {""passwordsDetail"", IDS_SETTINGS_PASSWORDS_DETAIL},
      {""savedPasswordsHeading"", IDS_SETTINGS_PASSWORDS_SAVED_HEADING},
      {""passwordExceptionsHeading"", IDS_SETTINGS_PASSWORDS_EXCEPTIONS_HEADING},
      {""deletePasswordException"", IDS_SETTINGS_PASSWORDS_DELETE_EXCEPTION},
      {""removePassword"", IDS_SETTINGS_PASSWORD_REMOVE},
      {""searchPasswords"", IDS_SETTINGS_PASSWORD_SEARCH},
      {""showPassword"", IDS_SETTINGS_PASSWORD_SHOW},
      {""hidePassword"", IDS_SETTINGS_PASSWORD_HIDE},
      {""passwordDetailsTitle"", IDS_SETTINGS_PASSWORDS_VIEW_DETAILS_TITLE},
      {""passwordViewDetails"", IDS_SETTINGS_PASSWORD_DETAILS},
      {""editPasswordWebsiteLabel"", IDS_SETTINGS_PASSWORDS_WEBSITE},
      {""editPasswordUsernameLabel"", IDS_SETTINGS_PASSWORDS_USERNAME},
      {""editPasswordPasswordLabel"", IDS_SETTINGS_PASSWORDS_PASSWORD},
      {""noAddressesFound"", IDS_SETTINGS_ADDRESS_NONE},
      {""noCreditCardsFound"", IDS_SETTINGS_CREDIT_CARD_NONE},
      {""noCreditCardsPolicy"", IDS_SETTINGS_CREDIT_CARD_DISABLED},
      {""noPasswordsFound"", IDS_SETTINGS_PASSWORDS_NONE},
      {""noExceptionsFound"", IDS_SETTINGS_PASSWORDS_EXCEPTIONS_NONE},
      {""import"", IDS_PASSWORD_MANAGER_IMPORT_BUTTON},
      {""exportMenuItem"", IDS_SETTINGS_PASSWORDS_EXPORT_MENU_ITEM},
      {""undoRemovePassword"", IDS_SETTINGS_PASSWORD_UNDO},
      {""passwordDeleted"", IDS_SETTINGS_PASSWORD_DELETED_PASSWORD},
      {""exportPasswordsTitle"", IDS_SETTINGS_PASSWORDS_EXPORT_TITLE},
      {""exportPasswordsDescription"", IDS_SETTINGS_PASSWORDS_EXPORT_DESCRIPTION},
      {""exportPasswords"", IDS_SETTINGS_PASSWORDS_EXPORT},
      {""exportingPasswordsTitle"", IDS_SETTINGS_PASSWORDS_EXPORTING_TITLE},
      {""exportPasswordsTryAgain"", IDS_SETTINGS_PASSWORDS_EXPORT_TRY_AGAIN},
      {""exportPasswordsFailTitle"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TITLE},
      {""exportPasswordsFailTips"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIPS},
      {""exportPasswordsFailTipsEnoughSpace"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIP_ENOUGH_SPACE},
      {""exportPasswordsFailTipsAnotherFolder"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIP_ANOTHER_FOLDER}};

  html_source->AddString(
      ""managePasswordsLabel"",
      l10n_util::GetStringFUTF16(
          IDS_SETTINGS_PASSWORDS_MANAGE_PASSWORDS,
          base::ASCIIToUTF16(
              password_manager::kPasswordManagerAccountDashboardURL)));
  html_source->AddString(""passwordManagerLearnMoreURL"",
                         chrome::kPasswordManagerLearnMoreURL);
  html_source->AddString(""manageAddressesUrl"",
                         autofill::payments::GetManageAddressesUrl(0).spec());
  html_source->AddString(""manageCreditCardsUrl"",
                         autofill::payments::GetManageInstrumentsUrl(0).spec());

  AddLocalizedStringsBulk(html_source, localized_strings,
                          arraysize(localized_strings));
}
","void AddPasswordsAndFormsStrings(content::WebUIDataSource* html_source) {
  LocalizedString localized_strings[] = {
      {""passwordsAndAutofillPageTitle"",
       IDS_SETTINGS_PASSWORDS_AND_AUTOFILL_PAGE_TITLE},
       {""autofill"", IDS_SETTINGS_AUTOFILL},
       {""googlePayments"", IDS_SETTINGS_GOOGLE_PAYMENTS},
       {""googlePaymentsCached"", IDS_SETTINGS_GOOGLE_PAYMENTS_CACHED},
      {""autofillFormsLabel"", IDS_SETTINGS_AUTOFILL_TOGGLE_LABEL},
       {""addresses"", IDS_SETTINGS_AUTOFILL_ADDRESSES_HEADING},
       {""addAddressTitle"", IDS_SETTINGS_AUTOFILL_ADDRESSES_ADD_TITLE},
       {""editAddressTitle"", IDS_SETTINGS_AUTOFILL_ADDRESSES_EDIT_TITLE},
      {""addressCountry"", IDS_SETTINGS_AUTOFILL_ADDRESSES_COUNTRY},
      {""addressPhone"", IDS_SETTINGS_AUTOFILL_ADDRESSES_PHONE},
      {""addressEmail"", IDS_SETTINGS_AUTOFILL_ADDRESSES_EMAIL},
      {""removeAddress"", IDS_SETTINGS_ADDRESS_REMOVE},
      {""creditCards"", IDS_SETTINGS_AUTOFILL_CREDIT_CARD_HEADING},
      {""removeCreditCard"", IDS_SETTINGS_CREDIT_CARD_REMOVE},
      {""clearCreditCard"", IDS_SETTINGS_CREDIT_CARD_CLEAR},
      {""creditCardType"", IDS_SETTINGS_AUTOFILL_CREDIT_CARD_TYPE_COLUMN_LABEL},
      {""creditCardExpiration"", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_DATE},
      {""creditCardName"", IDS_SETTINGS_NAME_ON_CREDIT_CARD},
      {""creditCardNumber"", IDS_SETTINGS_CREDIT_CARD_NUMBER},
      {""creditCardExpirationMonth"", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_MONTH},
      {""creditCardExpirationYear"", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_YEAR},
      {""creditCardExpired"", IDS_SETTINGS_CREDIT_CARD_EXPIRED},
      {""editCreditCardTitle"", IDS_SETTINGS_EDIT_CREDIT_CARD_TITLE},
       {""addCreditCardTitle"", IDS_SETTINGS_ADD_CREDIT_CARD_TITLE},
       {""autofillDetail"", IDS_SETTINGS_AUTOFILL_DETAIL},
       {""passwords"", IDS_SETTINGS_PASSWORDS},
      {""passwordsSavePasswordsLabel"",
       IDS_SETTINGS_PASSWORDS_SAVE_PASSWORDS_TOGGLE_LABEL},
       {""passwordsAutosigninLabel"",
        IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_LABEL},
       {""passwordsAutosigninDescription"",
       IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_DESC},
      {""passwordsDetail"", IDS_SETTINGS_PASSWORDS_DETAIL},
      {""savedPasswordsHeading"", IDS_SETTINGS_PASSWORDS_SAVED_HEADING},
      {""passwordExceptionsHeading"", IDS_SETTINGS_PASSWORDS_EXCEPTIONS_HEADING},
      {""deletePasswordException"", IDS_SETTINGS_PASSWORDS_DELETE_EXCEPTION},
      {""removePassword"", IDS_SETTINGS_PASSWORD_REMOVE},
      {""searchPasswords"", IDS_SETTINGS_PASSWORD_SEARCH},
      {""showPassword"", IDS_SETTINGS_PASSWORD_SHOW},
      {""hidePassword"", IDS_SETTINGS_PASSWORD_HIDE},
      {""passwordDetailsTitle"", IDS_SETTINGS_PASSWORDS_VIEW_DETAILS_TITLE},
      {""passwordViewDetails"", IDS_SETTINGS_PASSWORD_DETAILS},
      {""editPasswordWebsiteLabel"", IDS_SETTINGS_PASSWORDS_WEBSITE},
      {""editPasswordUsernameLabel"", IDS_SETTINGS_PASSWORDS_USERNAME},
      {""editPasswordPasswordLabel"", IDS_SETTINGS_PASSWORDS_PASSWORD},
      {""noAddressesFound"", IDS_SETTINGS_ADDRESS_NONE},
      {""noCreditCardsFound"", IDS_SETTINGS_CREDIT_CARD_NONE},
      {""noCreditCardsPolicy"", IDS_SETTINGS_CREDIT_CARD_DISABLED},
      {""noPasswordsFound"", IDS_SETTINGS_PASSWORDS_NONE},
      {""noExceptionsFound"", IDS_SETTINGS_PASSWORDS_EXCEPTIONS_NONE},
      {""import"", IDS_PASSWORD_MANAGER_IMPORT_BUTTON},
      {""exportMenuItem"", IDS_SETTINGS_PASSWORDS_EXPORT_MENU_ITEM},
      {""undoRemovePassword"", IDS_SETTINGS_PASSWORD_UNDO},
      {""passwordDeleted"", IDS_SETTINGS_PASSWORD_DELETED_PASSWORD},
      {""exportPasswordsTitle"", IDS_SETTINGS_PASSWORDS_EXPORT_TITLE},
      {""exportPasswordsDescription"", IDS_SETTINGS_PASSWORDS_EXPORT_DESCRIPTION},
      {""exportPasswords"", IDS_SETTINGS_PASSWORDS_EXPORT},
      {""exportingPasswordsTitle"", IDS_SETTINGS_PASSWORDS_EXPORTING_TITLE},
      {""exportPasswordsTryAgain"", IDS_SETTINGS_PASSWORDS_EXPORT_TRY_AGAIN},
      {""exportPasswordsFailTitle"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TITLE},
      {""exportPasswordsFailTips"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIPS},
      {""exportPasswordsFailTipsEnoughSpace"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIP_ENOUGH_SPACE},
      {""exportPasswordsFailTipsAnotherFolder"",
       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIP_ANOTHER_FOLDER}};

  html_source->AddString(
      ""managePasswordsLabel"",
      l10n_util::GetStringFUTF16(
          IDS_SETTINGS_PASSWORDS_MANAGE_PASSWORDS,
          base::ASCIIToUTF16(
              password_manager::kPasswordManagerAccountDashboardURL)));
  html_source->AddString(""passwordManagerLearnMoreURL"",
                         chrome::kPasswordManagerLearnMoreURL);
  html_source->AddString(""manageAddressesUrl"",
                         autofill::payments::GetManageAddressesUrl(0).spec());
  html_source->AddString(""manageCreditCardsUrl"",
                         autofill::payments::GetManageInstrumentsUrl(0).spec());

  AddLocalizedStringsBulk(html_source, localized_strings,
                          arraysize(localized_strings));
}
","The `AddPasswordsAndFormsStrings` function populates a `WebUIDataSource` object with localized strings related to password and autofill management settings in a web application. It initializes an array of `LocalizedString` structures, each containing a key and a corresponding resource ID for various UI elements, such as titles, labels, and messages for managing passwords, credit cards, and addresses. Additionally, it adds specific strings for managing URLs related to password management and autofill features. The function also calls `AddLocalizedStringsBulk` to efficiently add all localized strings to the `html_source`.","The provided code defines a function that populates a web user interface data source with localized strings for managing passwords and autofill settings. It initializes an array of localized strings, each associated with specific user interface elements such as titles, labels, and messages related to passwords, credit cards, and addresses. The function also adds specific URLs for managing passwords and autofill features. By utilizing a bulk addition method, it efficiently incorporates all localized strings into the data source, enhancing the user experience by providing relevant and translated content for various settings.","The vulnerability in the original code stemmed from unclear labeling of user interface elements related to password saving and autofill features, which could lead to user confusion and improper usage of these functionalities. Specifically, the absence of explicit labels for toggles could result in users not understanding the implications of enabling or disabling these settings. The fixed code addressed this issue by adding clearer labels, such as ""passwordsSavePasswordsLabel"" and ""autofillFormsLabel,"" which provide better context and guidance for users, thereby enhancing usability and reducing the risk of misconfiguration.","The vulnerability in the original code was due to ambiguous labeling of user interface elements related to password saving and autofill settings, which could confuse users and lead to unintended actions. This lack of clarity might result in users not fully understanding the consequences of enabling or disabling these features. The fixed code addressed this issue by enhancing the clarity of the labels associated with these toggles, ensuring that users receive more explicit guidance. This improvement helps users make informed decisions regarding their settings, thereby reducing the risk of misconfiguration and enhancing overall usability.","The vulnerability was fixed by adding clearer labels for the password saving and autofill toggles in the updated code. Specifically, new entries such as ""passwordsSavePasswordsLabel"" and ""autofillFormsLabel"" were introduced to provide explicit descriptions of the functionalities associated with these settings. This change enhances user understanding by clearly indicating the purpose of each toggle, thereby reducing the likelihood of confusion. Additionally, the overall structure of the localized strings was maintained, ensuring that the new labels seamlessly integrated into the existing user interface, improving the overall user experience.","The vulnerability was fixed by enhancing the clarity of the user interface labels associated with password saving and autofill settings. The updated code introduced more descriptive labels that explicitly convey the purpose and functionality of the toggles, thereby reducing ambiguity. This change ensures that users can easily understand the implications of enabling or disabling these features, leading to more informed decision-making. By improving the wording and context of the settings, the update enhances the overall user experience and minimizes the risk of misconfiguration or confusion regarding these important functionalities.","4,4","1, 1","4,4","4,4"
105,105,187101,187101,,Local,Not required,,CVE-2018-20073,https://www.cvedetails.com/cve/CVE-2018-20073/,CWE-200,Low,Partial,,,2019-06-27,2.1,Use of extended attributes in downloads in Google Chrome prior to 72.0.3626.81 allowed a local attacker to read download URLs via the filesystem.,2019-07-30,+Info ,2,https://github.com/chromium/chromium/commit/2f01a0cb03732fdb982dd42786d95736322d2241,2f01a0cb03732fdb982dd42786d95736322d2241,"Disable setxattr calls from quarantine subsystem on Chrome OS.

BUG=733943

Change-Id: I6e743469a8dc91536e180ecf4ff0df0cf427037c
Reviewed-on: https://chromium-review.googlesource.com/c/1380571
Commit-Queue: Will Harris <wfh@chromium.org>
Reviewed-by: Raymes Khoury <raymes@chromium.org>
Reviewed-by: David Trainor <dtrainor@chromium.org>
Reviewed-by: Thiemo Nagel <tnagel@chromium.org>
Cr-Commit-Position: refs/heads/master@{#617961}",0,components/download/quarantine/quarantine_linux.cc,"{""sha"": ""d3c6d4bc7c31cc22624967dcbd745e220d57508b"", ""filename"": ""chrome/browser/download/download_browsertest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/2f01a0cb03732fdb982dd42786d95736322d2241/chrome/browser/download/download_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2f01a0cb03732fdb982dd42786d95736322d2241/chrome/browser/download/download_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/download/download_browsertest.cc?ref=2f01a0cb03732fdb982dd42786d95736322d2241"", ""patch"": ""@@ -1228,7 +1228,7 @@ IN_PROC_BROWSER_TEST_F(DownloadTest, DownloadMimeType) {\n   CheckDownload(browser(), file, file);\n }\n \n-#if defined(OS_WIN) || defined(OS_LINUX)\n+#if defined(OS_WIN) || (defined(OS_LINUX) && !defined(OS_CHROMEOS))\n // Download a file and confirm that the file is correctly quarantined.\n //\n // TODO(asanka): We should enable the test on Mac as well, but currently""}<_**next**_>{""sha"": ""40b5c1e17b0ec23a55aee75db650872d2833def5"", ""filename"": ""chrome/test/ppapi/ppapi_filechooser_browsertest.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 2, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/2f01a0cb03732fdb982dd42786d95736322d2241/chrome/test/ppapi/ppapi_filechooser_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2f01a0cb03732fdb982dd42786d95736322d2241/chrome/test/ppapi/ppapi_filechooser_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/ppapi/ppapi_filechooser_browsertest.cc?ref=2f01a0cb03732fdb982dd42786d95736322d2241"", ""patch"": ""@@ -12,6 +12,7 @@\n #include \""base/strings/string_piece.h\""\n #include \""base/strings/string_util.h\""\n #include \""base/threading/thread_restrictions.h\""\n+#include \""build/build_config.h\""\n #include \""chrome/browser/safe_browsing/download_protection/download_protection_util.h\""\n #include \""chrome/common/chrome_switches.h\""\n #include \""chrome/test/ppapi/ppapi_test.h\""\n@@ -234,12 +235,17 @@ IN_PROC_BROWSER_TEST_F(PPAPIFileChooserTest, FileChooser_SaveAs_Cancel) {\n   RunTestViaHTTP(\""FileChooser_SaveAsCancel\"");\n }\n \n-#if defined(OS_WIN) || defined(OS_LINUX)\n+#if defined(OS_WIN) || defined(OS_LINUX) && !defined(OS_CHROMEOS)\n // On Windows, tests that a file downloaded via PPAPI FileChooser API has the\n // mark-of-the-web. The PPAPI FileChooser implementation invokes QuarantineFile\n // in order to mark the file as being downloaded from the web as soon as the\n // file is created. This MOTW prevents the file being opened without due\n // security warnings if the file is executable.\n+//\n+// On Linux Desktop, the setxattr call is made to set 'user.xdg.origin.url' and\n+// the non-standard 'user.xdg.referrer.url' extended attributes to accomplish\n+// the same thing. See\n+// https://www.freedesktop.org/wiki/CommonExtendedAttributes/.\n IN_PROC_BROWSER_TEST_F(PPAPIFileChooserTest, FileChooser_Quarantine) {\n   base::ScopedAllowBlockingForTesting allow_blocking;\n   base::ScopedTempDir temp_dir;\n@@ -259,7 +265,7 @@ IN_PROC_BROWSER_TEST_F(PPAPIFileChooserTest, FileChooser_Quarantine) {\n   ASSERT_TRUE(base::PathExists(actual_filename));\n   EXPECT_TRUE(download::IsFileQuarantined(actual_filename, GURL(), GURL()));\n }\n-#endif  // defined(OS_WIN) || defined(OS_LINUX)\n+#endif  // defined(OS_WIN) || defined(OS_LINUX) && !defined(OS_CHROMEOS)\n \n #if defined(FULL_SAFE_BROWSING)\n // These tests only make sense when SafeBrowsing is enabled. They verify""}<_**next**_>{""sha"": ""8683056aae53c2b9ef0e58da34358052f2ecdbb8"", ""filename"": ""components/download/quarantine/quarantine_linux.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/2f01a0cb03732fdb982dd42786d95736322d2241/components/download/quarantine/quarantine_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2f01a0cb03732fdb982dd42786d95736322d2241/components/download/quarantine/quarantine_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/download/quarantine/quarantine_linux.cc?ref=2f01a0cb03732fdb982dd42786d95736322d2241"", ""patch"": ""@@ -23,13 +23,17 @@ bool SetExtendedFileAttribute(const char* path,\n                               const char* value,\n                               size_t value_size,\n                               int flags) {\n+// On Chrome OS, there is no component that can validate these extended\n+// attributes so there is no need to set them.\n+#if !defined(OS_CHROMEOS)\n   base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);\n   int result = setxattr(path, name, value, value_size, flags);\n   if (result) {\n     DPLOG(ERROR) << \""Could not set extended attribute \"" << name << \"" on file \""\n                  << path;\n     return false;\n   }\n+#endif  // !defined(OS_CHROMEOS)\n   return true;\n }\n ""}<_**next**_>{""sha"": ""32164205d733c702f497e665a515be2ad1c24c23"", ""filename"": ""components/download/quarantine/quarantine_linux_unittest.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/2f01a0cb03732fdb982dd42786d95736322d2241/components/download/quarantine/quarantine_linux_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2f01a0cb03732fdb982dd42786d95736322d2241/components/download/quarantine/quarantine_linux_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/download/quarantine/quarantine_linux_unittest.cc?ref=2f01a0cb03732fdb982dd42786d95736322d2241"", ""patch"": ""@@ -50,12 +50,14 @@ class QuarantineLinuxTest : public testing::Test {\n \n  protected:\n   void SetUp() override {\n+#if !defined(OS_CHROMEOS)\n     ASSERT_TRUE(temp_dir_.CreateUniqueTempDir());\n     ASSERT_TRUE(\n         base::CreateTemporaryFileInDir(temp_dir_.GetPath(), &test_file_));\n     int result =\n         setxattr(test_file_.value().c_str(), \""user.test\"", \""test\"", 4, 0);\n     is_xattr_supported_ = (!result) || (errno != ENOTSUP);\n+#endif  // !defined(OS_CHROMEOS)\n     if (!is_xattr_supported_) {\n       LOG(WARNING) << \""Test will be skipped because extended attributes are \""\n                       \""not supported on this OS/file system.\"";""}","bool SetExtendedFileAttribute(const char* path,
                              const char* name,
                               const char* value,
                               size_t value_size,
                               int flags) {
//// On Chrome OS, there is no component that can validate these extended
//// attributes so there is no need to set them.
#if !defined(OS_CHROMEOS)
   base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);
   int result = setxattr(path, name, value, value_size, flags);
   if (result) {
     DPLOG(ERROR) << ""Could not set extended attribute "" << name << "" on file ""
                  << path;
     return false;
   }
#endif  // !defined(OS_CHROMEOS)
   return true;
 }
","bool SetExtendedFileAttribute(const char* path,
                              const char* name,
                               const char* value,
                               size_t value_size,
                               int flags) {
//// On Chrome OS, there is no component that can validate these extended
//// attributes so there is no need to set them.
   base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);
   int result = setxattr(path, name, value, value_size, flags);
   if (result) {
     DPLOG(ERROR) << ""Could not set extended attribute "" << name << "" on file ""
                  << path;
     return false;
   }
   return true;
 }
",C,"#if !defined(OS_CHROMEOS)
#endif  // !defined(OS_CHROMEOS)
",,,"@@ -23,13 +23,17 @@ bool SetExtendedFileAttribute(const char* path,
                               const char* value,
                               size_t value_size,
                               int flags) {
+// On Chrome OS, there is no component that can validate these extended
+// attributes so there is no need to set them.
+#if !defined(OS_CHROMEOS)
   base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);
   int result = setxattr(path, name, value, value_size, flags);
   if (result) {
     DPLOG(ERROR) << ""Could not set extended attribute "" << name << "" on file ""
                  << path;
     return false;
   }
+#endif  // !defined(OS_CHROMEOS)
   return true;
 }
 ",Chrome,2f01a0cb03732fdb982dd42786d95736322d2241,cee16261e5882721569635eae11831ef425c7574,1,"bool SetExtendedFileAttribute(const char* path,
                              const char* name,
                               const char* value,
                               size_t value_size,
                               int flags) {
//fix_flaw_line_below:
//// On Chrome OS, there is no component that can validate these extended
//fix_flaw_line_below:
//// attributes so there is no need to set them.
//fix_flaw_line_below:
//#if !defined(OS_CHROMEOS)
   base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);
   int result = setxattr(path, name, value, value_size, flags);
   if (result) {
     DPLOG(ERROR) << ""Could not set extended attribute "" << name << "" on file ""
                  << path;
     return false;
   }
//fix_flaw_line_below:
//#endif  // !defined(OS_CHROMEOS)
   return true;
 }
",187101,"bool SetExtendedFileAttribute(const char* path,
                              const char* name,
                               const char* value,
                               size_t value_size,
                               int flags) {
//// On Chrome OS, there is no component that can validate these extended
//// attributes so there is no need to set them.
   base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);
   int result = setxattr(path, name, value, value_size, flags);
   if (result) {
     DPLOG(ERROR) << ""Could not set extended attribute "" << name << "" on file ""
                  << path;
     return false;
   }
   return true;
 }
","bool SetExtendedFileAttribute(const char* path,
                              const char* name,
                               const char* value,
                               size_t value_size,
                               int flags) {
//// On Chrome OS, there is no component that can validate these extended
//// attributes so there is no need to set them.
#if !defined(OS_CHROMEOS)
   base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);
   int result = setxattr(path, name, value, value_size, flags);
   if (result) {
     DPLOG(ERROR) << ""Could not set extended attribute "" << name << "" on file ""
                  << path;
     return false;
   }
#endif  // !defined(OS_CHROMEOS)
   return true;
 }
","The `SetExtendedFileAttribute` function is designed to set extended file attributes on a specified file in a filesystem. It takes five parameters: the file path, the attribute name, the attribute value, the size of the value, and flags for additional options. The function first creates a scoped blocking call to ensure that the operation can safely block if necessary. It then attempts to set the extended attribute using the `setxattr` system call. If the operation fails, it logs an error message and returns `false`; otherwise, it returns `true`, indicating the attribute was successfully set.","The provided code defines a function that sets extended file attributes for a specified file in the filesystem. It begins by ensuring that the operation can block if necessary, allowing for safe execution. The function then attempts to apply the specified attribute to the file using a system call. If the operation is unsuccessful, it logs an error message indicating the failure and returns a false value. Conversely, if the attribute is set successfully, the function returns true, confirming the successful application of the extended attribute to the file.","The vulnerability in the original code arises from the lack of validation for extended file attributes on Chrome OS, which could lead to unintended behavior or security issues when setting these attributes. The fixed code addresses this vulnerability by introducing a preprocessor directive that conditionally compiles the attribute-setting logic only if the operating system is not Chrome OS. This means that the `setxattr` function call, along with the associated error logging, is disabled on Chrome OS, effectively preventing any potential misuse or errors related to unvalidated extended attributes in that environment.","The vulnerability in the original code stems from the lack of validation for extended file attributes on a specific operating system, which could lead to security risks or improper handling of file attributes. The fix implemented in the updated code involves disabling the functionality that sets these attributes when running on that operating system. By introducing a conditional compilation directive, the code ensures that the attribute-setting logic is not executed in this environment, thereby mitigating the risk of unintended consequences or security vulnerabilities associated with unvalidated attribute settings.","The vulnerability was fixed by introducing a preprocessor directive that conditionally excludes the execution of the `setxattr` function call on Chrome OS. In the updated code, the logic for setting extended file attributes is wrapped in a conditional compilation block that checks if the operating system is not defined as Chrome OS. This means that the `base::ScopedBlockingCall` and the subsequent error logging are only executed on supported platforms, effectively preventing any calls to `setxattr` in the quarantine subsystem on Chrome OS, thereby eliminating the risk associated with unvalidated extended attributes.","The vulnerability was addressed by implementing a conditional compilation directive that prevents the execution of the attribute-setting logic on a specific operating system. This change ensures that the functionality responsible for setting extended file attributes is entirely excluded from the code when running in that environment. As a result, any potential risks associated with unvalidated attribute settings are eliminated, as the code will not attempt to perform these operations where they could lead to security issues or unintended behavior. This effectively safeguards the system from misuse in the affected context.","5, 4","5, 5","5,5","4,4"
106,106,187127,187127,,Remote,Not required,,CVE-2018-6159,https://www.cvedetails.com/cve/CVE-2018-6159/,CWE-200,Medium,Partial,,,2019-06-27,4.3,Insufficient policy enforcement in ServiceWorker in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to obtain potentially sensitive information from process memory via a crafted HTML page.,2019-07-01,+Info ,4,https://github.com/chromium/chromium/commit/01b42e2bc2aac531b17596729ae4e5c223ae7124,01b42e2bc2aac531b17596729ae4e5c223ae7124,"Fix timing allow check algorithm for service workers

This CL uses the OriginalURLViaServiceWorker() in the timing allow check
algorithm if the response WasFetchedViaServiceWorker(). This way, if a
service worker changes a same origin request to become cross origin,
then the timing allow check algorithm will still fail.

resource-timing-worker.js is changed so it avoids an empty Response,
which is an odd case in terms of same origin checks.

Bug: 837275
Change-Id: I7e497a6fcc2ee14244121b915ca5f5cceded417a
Reviewed-on: https://chromium-review.googlesource.com/1038229
Commit-Queue: Nicolás Peña Moreno <npm@chromium.org>
Reviewed-by: Yoav Weiss <yoav@yoav.ws>
Reviewed-by: Timothy Dresser <tdresser@chromium.org>
Cr-Commit-Position: refs/heads/master@{#555476}",1,third_party/blink/renderer/core/timing/performance.cc,"{""sha"": ""827688df011ea9be216a7414b161dbb730f1b975"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resource-timing-cross-origin.https.html"", ""status"": ""added"", ""additions"": 52, ""deletions"": 0, ""changes"": 52, ""blob_url"": ""https://github.com/chromium/chromium/blob/01b42e2bc2aac531b17596729ae4e5c223ae7124/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resource-timing-cross-origin.https.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/01b42e2bc2aac531b17596729ae4e5c223ae7124/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resource-timing-cross-origin.https.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resource-timing-cross-origin.https.html?ref=01b42e2bc2aac531b17596729ae4e5c223ae7124"", ""patch"": ""@@ -0,0 +1,52 @@\n+<!DOCTYPE HTML>\n+<html>\n+<head>\n+<meta charset=\""utf-8\"" />\n+<title>This test validates Resource Timing for cross origin content fetched by Service Worker from an originally same-origin URL.</title>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+<script src=\""/common/get-host-info.sub.js\""></script>\n+<script src=\""resources/test-helpers.sub.js\""></script>\n+</head>\n+\n+<body>\n+<script>\n+async_test(function(t) {\n+    const worker_url = 'resources/worker-fetching-cross-origin.js';\n+    const scope = 'resources/iframe-with-image.html';\n+    let registration;\n+    service_worker_unregister_and_register(t, worker_url, scope)\n+    .then(function(r) {\n+        registration = r;\n+        return wait_for_state(t, r.installing, 'activated');\n+    })\n+    .then(function() {\n+        return with_iframe(scope);\n+    })\n+    .then(function(frame) {\n+        const frame_performance = frame.contentWindow.performance;\n+        // Check that there is one entry for which the timing allow check algorithm failed.\n+        const entries = frame_performance.getEntriesByType('resource');\n+        assert_equals(entries.length, 1);\n+        const entry = entries[0];\n+        assert_equals(entry.redirectStart, 0, 'redirectStart should be 0 in cross-origin request.');\n+        assert_equals(entry.redirectEnd, 0, 'redirectEnd should be 0 in cross-origin request.');\n+        assert_equals(entry.domainLookupStart, 0, 'domainLookupStart should be 0 in cross-origin request.');\n+        assert_equals(entry.domainLookupEnd, 0, 'domainLookupEnd should be 0 in cross-origin request.');\n+        assert_equals(entry.connectStart, 0, 'connectStart should be 0 in cross-origin request.');\n+        assert_equals(entry.connectEnd, 0, 'connectEnd should be 0 in cross-origin request.');\n+        assert_equals(entry.requestStart, 0, 'requestStart should be 0 in cross-origin request.');\n+        assert_equals(entry.responseStart, 0, 'responseStart should be 0 in cross-origin request.');\n+        assert_equals(entry.secureConnectionStart, 0, 'secureConnectionStart should be 0 in cross-origin request.');\n+        assert_equals(entry.decodedBodySize, 0, 'decodedBodySize should be 0 in cross-origin request.');\n+        frame.remove();\n+        return registration.unregister();\n+      })\n+    .then(function() {\n+        t.done();\n+      })\n+    .catch(unreached_rejection(t));\n+}, 'Test that timing allow check fails when service worker changes origin from same to cross origin.');\n+</script>\n+</body>\n+</html>""}<_**next**_>{""sha"": ""ce78840cb28310947f39232acd87fba0c0262f0b"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resources/iframe-with-image.html"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/01b42e2bc2aac531b17596729ae4e5c223ae7124/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resources/iframe-with-image.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/01b42e2bc2aac531b17596729ae4e5c223ae7124/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resources/iframe-with-image.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resources/iframe-with-image.html?ref=01b42e2bc2aac531b17596729ae4e5c223ae7124"", ""patch"": ""@@ -0,0 +1,2 @@\n+<!DOCTYPE html>\n+<img src=\""square\"">""}<_**next**_>{""sha"": ""c83e4851142677d9f21b427b4cb2f4b951942f53"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resources/resource-timing-worker.js"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 5, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/01b42e2bc2aac531b17596729ae4e5c223ae7124/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resources/resource-timing-worker.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/01b42e2bc2aac531b17596729ae4e5c223ae7124/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resources/resource-timing-worker.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resources/resource-timing-worker.js?ref=01b42e2bc2aac531b17596729ae4e5c223ae7124"", ""patch"": ""@@ -1,9 +1,5 @@\n self.addEventListener('fetch', function(event) {\n     if (event.request.url.indexOf('dummy.js') != -1) {\n-      event.respondWith(new Promise(resolve => {\n-        // Slightly delay the response so we ensure we get a non-zero\n-        // duration.\n-        setTimeout(_ => resolve(new Response()), 100);\n-      }));\n+      event.respondWith(fetch('empty.js'));\n     }\n   });""}<_**next**_>{""sha"": ""7341132745be2bee9e47114cda4167865e8a9699"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resources/square.png.sub.headers"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/01b42e2bc2aac531b17596729ae4e5c223ae7124/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resources/square.png.sub.headers"", ""raw_url"": ""https://github.com/chromium/chromium/raw/01b42e2bc2aac531b17596729ae4e5c223ae7124/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resources/square.png.sub.headers"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resources/square.png.sub.headers?ref=01b42e2bc2aac531b17596729ae4e5c223ae7124"", ""patch"": ""@@ -0,0 +1,2 @@\n+Content-Type: image/png\n+Access-Control-Allow-Origin: *""}<_**next**_>{""sha"": ""79f08991174cb50735f8bc0631876c22b3359be1"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resources/worker-fetching-cross-origin.js"", ""status"": ""added"", ""additions"": 10, ""deletions"": 0, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/01b42e2bc2aac531b17596729ae4e5c223ae7124/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resources/worker-fetching-cross-origin.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/01b42e2bc2aac531b17596729ae4e5c223ae7124/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resources/worker-fetching-cross-origin.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/resources/worker-fetching-cross-origin.js?ref=01b42e2bc2aac531b17596729ae4e5c223ae7124"", ""patch"": ""@@ -0,0 +1,10 @@\n+importScripts('/common/get-host-info.sub.js');\n+importScripts('test-helpers.sub.js');\n+\n+self.addEventListener('fetch', event => {\n+  const host_info = get_host_info();\n+  // The sneaky Service Worker changes the same-origin 'square' request for a cross-origin image.\n+  if (event.request.url.indexOf('square') != -1) {\n+    event.respondWith(fetch(host_info['HTTPS_REMOTE_ORIGIN'] + base_path() + 'square.png', {mode: 'cors'}));\n+  }\n+});""}<_**next**_>{""sha"": ""1f011dd6b307bc804fbcbfe190c060e7b8893c9f"", ""filename"": ""third_party/blink/renderer/core/timing/performance.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/01b42e2bc2aac531b17596729ae4e5c223ae7124/third_party/blink/renderer/core/timing/performance.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/01b42e2bc2aac531b17596729ae4e5c223ae7124/third_party/blink/renderer/core/timing/performance.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/timing/performance.cc?ref=01b42e2bc2aac531b17596729ae4e5c223ae7124"", ""patch"": ""@@ -275,8 +275,11 @@ bool Performance::PassesTimingAllowCheck(\n     const SecurityOrigin& initiator_security_origin,\n     const AtomicString& original_timing_allow_origin,\n     ExecutionContext* context) {\n+  const KURL& response_url = response.WasFetchedViaServiceWorker()\n+                                 ? response.OriginalURLViaServiceWorker()\n+                                 : response.Url();\n   scoped_refptr<const SecurityOrigin> resource_origin =\n-      SecurityOrigin::Create(response.Url());\n+      SecurityOrigin::Create(response_url);\n   if (resource_origin->IsSameSchemeHostPort(&initiator_security_origin))\n     return true;\n ""}","bool Performance::PassesTimingAllowCheck(
    const ResourceResponse& response,
     const SecurityOrigin& initiator_security_origin,
     const AtomicString& original_timing_allow_origin,
     ExecutionContext* context) {
  const KURL& response_url = response.WasFetchedViaServiceWorker()
                                 ? response.OriginalURLViaServiceWorker()
                                 : response.Url();
   scoped_refptr<const SecurityOrigin> resource_origin =
      SecurityOrigin::Create(response_url);
   if (resource_origin->IsSameSchemeHostPort(&initiator_security_origin))
     return true;
 
  const AtomicString& timing_allow_origin_string =
      original_timing_allow_origin.IsEmpty()
          ? response.HttpHeaderField(HTTPNames::Timing_Allow_Origin)
          : original_timing_allow_origin;
  if (timing_allow_origin_string.IsEmpty() ||
      EqualIgnoringASCIICase(timing_allow_origin_string, ""null""))
    return false;

  if (timing_allow_origin_string == ""*"") {
    UseCounter::Count(context, WebFeature::kStarInTimingAllowOrigin);
    return true;
  }

  const String& security_origin = initiator_security_origin.ToString();
  Vector<String> timing_allow_origins;
  timing_allow_origin_string.GetString().Split(',', timing_allow_origins);
  if (timing_allow_origins.size() > 1) {
    UseCounter::Count(context, WebFeature::kMultipleOriginsInTimingAllowOrigin);
  } else if (timing_allow_origins.size() == 1 &&
             timing_allow_origin_string != ""*"") {
    UseCounter::Count(context, WebFeature::kSingleOriginInTimingAllowOrigin);
  }
  for (const String& allow_origin : timing_allow_origins) {
    const String allow_origin_stripped = allow_origin.StripWhiteSpace();
    if (allow_origin_stripped == security_origin ||
        allow_origin_stripped == ""*"") {
      return true;
    }
  }

  return false;
}
","bool Performance::PassesTimingAllowCheck(
    const ResourceResponse& response,
     const SecurityOrigin& initiator_security_origin,
     const AtomicString& original_timing_allow_origin,
     ExecutionContext* context) {
   scoped_refptr<const SecurityOrigin> resource_origin =
      SecurityOrigin::Create(response.Url());
   if (resource_origin->IsSameSchemeHostPort(&initiator_security_origin))
     return true;
 
  const AtomicString& timing_allow_origin_string =
      original_timing_allow_origin.IsEmpty()
          ? response.HttpHeaderField(HTTPNames::Timing_Allow_Origin)
          : original_timing_allow_origin;
  if (timing_allow_origin_string.IsEmpty() ||
      EqualIgnoringASCIICase(timing_allow_origin_string, ""null""))
    return false;

  if (timing_allow_origin_string == ""*"") {
    UseCounter::Count(context, WebFeature::kStarInTimingAllowOrigin);
    return true;
  }

  const String& security_origin = initiator_security_origin.ToString();
  Vector<String> timing_allow_origins;
  timing_allow_origin_string.GetString().Split(',', timing_allow_origins);
  if (timing_allow_origins.size() > 1) {
    UseCounter::Count(context, WebFeature::kMultipleOriginsInTimingAllowOrigin);
  } else if (timing_allow_origins.size() == 1 &&
             timing_allow_origin_string != ""*"") {
    UseCounter::Count(context, WebFeature::kSingleOriginInTimingAllowOrigin);
  }
  for (const String& allow_origin : timing_allow_origins) {
    const String allow_origin_stripped = allow_origin.StripWhiteSpace();
    if (allow_origin_stripped == security_origin ||
        allow_origin_stripped == ""*"") {
      return true;
    }
  }

  return false;
}
",C,"  const KURL& response_url = response.WasFetchedViaServiceWorker()
                                 ? response.OriginalURLViaServiceWorker()
                                 : response.Url();
      SecurityOrigin::Create(response_url);
","      SecurityOrigin::Create(response.Url());
",,"@@ -275,8 +275,11 @@ bool Performance::PassesTimingAllowCheck(
     const SecurityOrigin& initiator_security_origin,
     const AtomicString& original_timing_allow_origin,
     ExecutionContext* context) {
+  const KURL& response_url = response.WasFetchedViaServiceWorker()
+                                 ? response.OriginalURLViaServiceWorker()
+                                 : response.Url();
   scoped_refptr<const SecurityOrigin> resource_origin =
-      SecurityOrigin::Create(response.Url());
+      SecurityOrigin::Create(response_url);
   if (resource_origin->IsSameSchemeHostPort(&initiator_security_origin))
     return true;
 ",Chrome,01b42e2bc2aac531b17596729ae4e5c223ae7124,ad8e5171e8f690cb17cd8ec3bff9528cb3fcab3c,1,"bool Performance::PassesTimingAllowCheck(
    const ResourceResponse& response,
     const SecurityOrigin& initiator_security_origin,
     const AtomicString& original_timing_allow_origin,
     ExecutionContext* context) {
//fix_flaw_line_below:
//  const KURL& response_url = response.WasFetchedViaServiceWorker()
//fix_flaw_line_below:
//                                 ? response.OriginalURLViaServiceWorker()
//fix_flaw_line_below:
//                                 : response.Url();
   scoped_refptr<const SecurityOrigin> resource_origin =
//flaw_line_below:
      SecurityOrigin::Create(response.Url());
//fix_flaw_line_below:
//      SecurityOrigin::Create(response_url);
   if (resource_origin->IsSameSchemeHostPort(&initiator_security_origin))
     return true;
 
  const AtomicString& timing_allow_origin_string =
      original_timing_allow_origin.IsEmpty()
          ? response.HttpHeaderField(HTTPNames::Timing_Allow_Origin)
          : original_timing_allow_origin;
  if (timing_allow_origin_string.IsEmpty() ||
      EqualIgnoringASCIICase(timing_allow_origin_string, ""null""))
    return false;

  // The condition below if only needed for use-counting purposes.
  if (timing_allow_origin_string == ""*"") {
    UseCounter::Count(context, WebFeature::kStarInTimingAllowOrigin);
    return true;
  }

  // TODO(yoav): Use CommaDelimitedHeaderSet instead of this one-off parsing
  // algorithm.
  const String& security_origin = initiator_security_origin.ToString();
  Vector<String> timing_allow_origins;
  timing_allow_origin_string.GetString().Split(',', timing_allow_origins);
  if (timing_allow_origins.size() > 1) {
    UseCounter::Count(context, WebFeature::kMultipleOriginsInTimingAllowOrigin);
  } else if (timing_allow_origins.size() == 1 &&
             timing_allow_origin_string != ""*"") {
    UseCounter::Count(context, WebFeature::kSingleOriginInTimingAllowOrigin);
  }
  for (const String& allow_origin : timing_allow_origins) {
    const String allow_origin_stripped = allow_origin.StripWhiteSpace();
    if (allow_origin_stripped == security_origin ||
        allow_origin_stripped == ""*"") {
      return true;
    }
  }

  return false;
}
",187127,"bool Performance::PassesTimingAllowCheck(
    const ResourceResponse& response,
     const SecurityOrigin& initiator_security_origin,
     const AtomicString& original_timing_allow_origin,
     ExecutionContext* context) {
   scoped_refptr<const SecurityOrigin> resource_origin =
      SecurityOrigin::Create(response.Url());
   if (resource_origin->IsSameSchemeHostPort(&initiator_security_origin))
     return true;
 
  const AtomicString& timing_allow_origin_string =
      original_timing_allow_origin.IsEmpty()
          ? response.HttpHeaderField(HTTPNames::Timing_Allow_Origin)
          : original_timing_allow_origin;
  if (timing_allow_origin_string.IsEmpty() ||
      EqualIgnoringASCIICase(timing_allow_origin_string, ""null""))
    return false;

  if (timing_allow_origin_string == ""*"") {
    UseCounter::Count(context, WebFeature::kStarInTimingAllowOrigin);
    return true;
  }

  const String& security_origin = initiator_security_origin.ToString();
  Vector<String> timing_allow_origins;
  timing_allow_origin_string.GetString().Split(',', timing_allow_origins);
  if (timing_allow_origins.size() > 1) {
    UseCounter::Count(context, WebFeature::kMultipleOriginsInTimingAllowOrigin);
  } else if (timing_allow_origins.size() == 1 &&
             timing_allow_origin_string != ""*"") {
    UseCounter::Count(context, WebFeature::kSingleOriginInTimingAllowOrigin);
  }
  for (const String& allow_origin : timing_allow_origins) {
    const String allow_origin_stripped = allow_origin.StripWhiteSpace();
    if (allow_origin_stripped == security_origin ||
        allow_origin_stripped == ""*"") {
      return true;
    }
  }

  return false;
}
","bool Performance::PassesTimingAllowCheck(
    const ResourceResponse& response,
     const SecurityOrigin& initiator_security_origin,
     const AtomicString& original_timing_allow_origin,
     ExecutionContext* context) {
  const KURL& response_url = response.WasFetchedViaServiceWorker()
                                 ? response.OriginalURLViaServiceWorker()
                                 : response.Url();
   scoped_refptr<const SecurityOrigin> resource_origin =
      SecurityOrigin::Create(response_url);
   if (resource_origin->IsSameSchemeHostPort(&initiator_security_origin))
     return true;
 
  const AtomicString& timing_allow_origin_string =
      original_timing_allow_origin.IsEmpty()
          ? response.HttpHeaderField(HTTPNames::Timing_Allow_Origin)
          : original_timing_allow_origin;
  if (timing_allow_origin_string.IsEmpty() ||
      EqualIgnoringASCIICase(timing_allow_origin_string, ""null""))
    return false;

  if (timing_allow_origin_string == ""*"") {
    UseCounter::Count(context, WebFeature::kStarInTimingAllowOrigin);
    return true;
  }

  const String& security_origin = initiator_security_origin.ToString();
  Vector<String> timing_allow_origins;
  timing_allow_origin_string.GetString().Split(',', timing_allow_origins);
  if (timing_allow_origins.size() > 1) {
    UseCounter::Count(context, WebFeature::kMultipleOriginsInTimingAllowOrigin);
  } else if (timing_allow_origins.size() == 1 &&
             timing_allow_origin_string != ""*"") {
    UseCounter::Count(context, WebFeature::kSingleOriginInTimingAllowOrigin);
  }
  for (const String& allow_origin : timing_allow_origins) {
    const String allow_origin_stripped = allow_origin.StripWhiteSpace();
    if (allow_origin_stripped == security_origin ||
        allow_origin_stripped == ""*"") {
      return true;
    }
  }

  return false;
}
","The `PassesTimingAllowCheck` function determines if a resource response meets the timing allow origin requirements based on the security origin of the initiator and the specified timing allow origin. It first checks if the resource's origin matches the initiator's origin; if so, it returns true. It then retrieves the timing allow origin string, validating it against various conditions, such as being empty or ""null."" If the string is ""*"", it counts a specific usage feature. The function further analyzes multiple origins, counting occurrences, and ultimately checks if any of the allowed origins match the initiator's origin, returning true if a match is found.","The function evaluates whether a resource response complies with timing allow origin policies based on the security context of the request initiator. It first checks if the resource and initiator share the same origin, returning true if they do. It then retrieves the timing allow origin information, assessing various conditions such as emptiness or specific values. The function counts occurrences of allowed origins and checks if any match the initiator's origin. Ultimately, it returns true if a valid match is found, ensuring that the resource adheres to security and timing policies.","The vulnerability in the original code stemmed from not properly handling responses fetched via service workers, which could lead to incorrect origin checks. Specifically, the code used the standard URL for origin comparison without considering if the response was altered by a service worker, potentially allowing cross-origin requests to pass the timing allow check. The fix involved using the `OriginalURLViaServiceWorker()` method when the response was fetched via a service worker, ensuring that the timing allow check accurately reflects any changes made by the service worker, thus preventing unintended cross-origin access.","The vulnerability in the original code arose from inadequate handling of responses modified by service workers, which could lead to incorrect origin checks and potentially allow unauthorized cross-origin access. Specifically, the code did not account for scenarios where a service worker could alter a same-origin request to a cross-origin one, thereby bypassing security checks. The fix implemented a mechanism to utilize the original URL provided by the service worker when performing the timing allow check, ensuring that any modifications made by the service worker are considered, thus reinforcing the integrity of the origin verification process.","The vulnerability was fixed by modifying the timing allow check algorithm to use `OriginalURLViaServiceWorker()` when the response indicated it was fetched via a service worker. This change ensures that if a service worker alters a same-origin request to become cross-origin, the timing allow check will accurately reflect this modification and fail as intended. Additionally, the code was updated to avoid processing empty responses, which could lead to ambiguous same-origin checks. These adjustments collectively enhance the security of the timing allow check by ensuring it accounts for service worker interventions.","The vulnerability was addressed by ensuring that the timing allow check algorithm correctly considers the original URL when a response is fetched through a service worker. This adjustment guarantees that any modifications made by the service worker, which could change a same-origin request to a cross-origin one, are properly accounted for during the security checks. Additionally, the implementation was refined to prevent the processing of empty responses, which could lead to ambiguous origin evaluations. These changes collectively strengthen the security framework by ensuring that the timing allow checks are robust against potential cross-origin access vulnerabilities.","4,4","4, 4","4,4","4,4"
107,107,187150,187150,,Remote,Not required,,CVE-2018-4117,https://www.cvedetails.com/cve/CVE-2018-4117/,CWE-200,Medium,Partial,,,2018-04-03,4.3,An issue was discovered in certain Apple products. iOS before 11.3 is affected. Safari before 11.1 is affected. iCloud before 7.4 on Windows is affected. iTunes before 12.7.4 on Windows is affected. watchOS before 4.3 is affected. The issue involves the fetch API in the *WebKit* component. It allows remote attackers to bypass the Same Origin Policy and obtain sensitive information via a crafted web site.,2018-11-09,Bypass +Info ,10,https://github.com/chromium/chromium/commit/a62f913109fc1566230f5963bbf69ee65274ebc8,a62f913109fc1566230f5963bbf69ee65274ebc8,"[Fetch API] Fix redirect leak on ""no-cors"" requests

The spec issue is now fixed, and this CL follows the spec change[1].

1: https://github.com/whatwg/fetch/commit/14858d3e9402285a7ff3b5e47a22896ff3adc95d

Bug: 791324
Change-Id: Ic3e3955f43578b38fc44a5a6b2a1b43d56a2becb
Reviewed-on: https://chromium-review.googlesource.com/1023613
Reviewed-by: Tsuyoshi Horo <horo@chromium.org>
Commit-Queue: Yutaka Hirano <yhirano@chromium.org>
Cr-Commit-Position: refs/heads/master@{#552964}",0,third_party/blink/renderer/core/fetch/fetch_manager.cc,"{""sha"": ""149f20c58c288723b2cb241a4e98a6a3f3c0b2cd"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/fetch/api/redirect/redirect-mode-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 64, ""changes"": 64, ""blob_url"": ""https://github.com/chromium/chromium/blob/79ca910048175c9118606b96a840516ace45f6c7/third_party/WebKit/LayoutTests/external/wpt/fetch/api/redirect/redirect-mode-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/79ca910048175c9118606b96a840516ace45f6c7/third_party/WebKit/LayoutTests/external/wpt/fetch/api/redirect/redirect-mode-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/fetch/api/redirect/redirect-mode-expected.txt?ref=79ca910048175c9118606b96a840516ace45f6c7"", ""patch"": ""@@ -1,64 +0,0 @@\n-This is a testharness.js-based test.\n-Found 60 tests; 55 PASS, 5 FAIL, 0 TIMEOUT, 0 NOTRUN.\n-PASS same-origin redirect 301 in error redirect and cors mode\n-PASS same-origin redirect 301 in error redirect and no-cors mode\n-PASS same-origin redirect 301 in manual redirect and cors mode\n-PASS same-origin redirect 301 in manual redirect and no-cors mode\n-PASS same-origin redirect 301 in follow redirect and cors mode\n-PASS same-origin redirect 301 in follow redirect and no-cors mode\n-PASS same-origin redirect 302 in error redirect and cors mode\n-PASS same-origin redirect 302 in error redirect and no-cors mode\n-PASS same-origin redirect 302 in manual redirect and cors mode\n-PASS same-origin redirect 302 in manual redirect and no-cors mode\n-PASS same-origin redirect 302 in follow redirect and cors mode\n-PASS same-origin redirect 302 in follow redirect and no-cors mode\n-PASS same-origin redirect 303 in error redirect and cors mode\n-PASS same-origin redirect 303 in error redirect and no-cors mode\n-PASS same-origin redirect 303 in manual redirect and cors mode\n-PASS same-origin redirect 303 in manual redirect and no-cors mode\n-PASS same-origin redirect 303 in follow redirect and cors mode\n-PASS same-origin redirect 303 in follow redirect and no-cors mode\n-PASS same-origin redirect 307 in error redirect and cors mode\n-PASS same-origin redirect 307 in error redirect and no-cors mode\n-PASS same-origin redirect 307 in manual redirect and cors mode\n-PASS same-origin redirect 307 in manual redirect and no-cors mode\n-PASS same-origin redirect 307 in follow redirect and cors mode\n-PASS same-origin redirect 307 in follow redirect and no-cors mode\n-PASS same-origin redirect 308 in error redirect and cors mode\n-PASS same-origin redirect 308 in error redirect and no-cors mode\n-PASS same-origin redirect 308 in manual redirect and cors mode\n-PASS same-origin redirect 308 in manual redirect and no-cors mode\n-PASS same-origin redirect 308 in follow redirect and cors mode\n-PASS same-origin redirect 308 in follow redirect and no-cors mode\n-PASS cross-origin redirect 301 in error redirect and cors mode\n-PASS cross-origin redirect 301 in error redirect and no-cors mode\n-PASS cross-origin redirect 301 in manual redirect and cors mode\n-FAIL cross-origin redirect 301 in manual redirect and no-cors mode assert_unreached: Should have rejected: undefined Reached unreachable code\n-PASS cross-origin redirect 301 in follow redirect and cors mode\n-PASS cross-origin redirect 301 in follow redirect and no-cors mode\n-PASS cross-origin redirect 302 in error redirect and cors mode\n-PASS cross-origin redirect 302 in error redirect and no-cors mode\n-PASS cross-origin redirect 302 in manual redirect and cors mode\n-FAIL cross-origin redirect 302 in manual redirect and no-cors mode assert_unreached: Should have rejected: undefined Reached unreachable code\n-PASS cross-origin redirect 302 in follow redirect and cors mode\n-PASS cross-origin redirect 302 in follow redirect and no-cors mode\n-PASS cross-origin redirect 303 in error redirect and cors mode\n-PASS cross-origin redirect 303 in error redirect and no-cors mode\n-PASS cross-origin redirect 303 in manual redirect and cors mode\n-FAIL cross-origin redirect 303 in manual redirect and no-cors mode assert_unreached: Should have rejected: undefined Reached unreachable code\n-PASS cross-origin redirect 303 in follow redirect and cors mode\n-PASS cross-origin redirect 303 in follow redirect and no-cors mode\n-PASS cross-origin redirect 307 in error redirect and cors mode\n-PASS cross-origin redirect 307 in error redirect and no-cors mode\n-PASS cross-origin redirect 307 in manual redirect and cors mode\n-FAIL cross-origin redirect 307 in manual redirect and no-cors mode assert_unreached: Should have rejected: undefined Reached unreachable code\n-PASS cross-origin redirect 307 in follow redirect and cors mode\n-PASS cross-origin redirect 307 in follow redirect and no-cors mode\n-PASS cross-origin redirect 308 in error redirect and cors mode\n-PASS cross-origin redirect 308 in error redirect and no-cors mode\n-PASS cross-origin redirect 308 in manual redirect and cors mode\n-FAIL cross-origin redirect 308 in manual redirect and no-cors mode assert_unreached: Should have rejected: undefined Reached unreachable code\n-PASS cross-origin redirect 308 in follow redirect and cors mode\n-PASS cross-origin redirect 308 in follow redirect and no-cors mode\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""149f20c58c288723b2cb241a4e98a6a3f3c0b2cd"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/fetch/api/redirect/redirect-mode-worker-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 64, ""changes"": 64, ""blob_url"": ""https://github.com/chromium/chromium/blob/79ca910048175c9118606b96a840516ace45f6c7/third_party/WebKit/LayoutTests/external/wpt/fetch/api/redirect/redirect-mode-worker-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/79ca910048175c9118606b96a840516ace45f6c7/third_party/WebKit/LayoutTests/external/wpt/fetch/api/redirect/redirect-mode-worker-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/fetch/api/redirect/redirect-mode-worker-expected.txt?ref=79ca910048175c9118606b96a840516ace45f6c7"", ""patch"": ""@@ -1,64 +0,0 @@\n-This is a testharness.js-based test.\n-Found 60 tests; 55 PASS, 5 FAIL, 0 TIMEOUT, 0 NOTRUN.\n-PASS same-origin redirect 301 in error redirect and cors mode\n-PASS same-origin redirect 301 in error redirect and no-cors mode\n-PASS same-origin redirect 301 in manual redirect and cors mode\n-PASS same-origin redirect 301 in manual redirect and no-cors mode\n-PASS same-origin redirect 301 in follow redirect and cors mode\n-PASS same-origin redirect 301 in follow redirect and no-cors mode\n-PASS same-origin redirect 302 in error redirect and cors mode\n-PASS same-origin redirect 302 in error redirect and no-cors mode\n-PASS same-origin redirect 302 in manual redirect and cors mode\n-PASS same-origin redirect 302 in manual redirect and no-cors mode\n-PASS same-origin redirect 302 in follow redirect and cors mode\n-PASS same-origin redirect 302 in follow redirect and no-cors mode\n-PASS same-origin redirect 303 in error redirect and cors mode\n-PASS same-origin redirect 303 in error redirect and no-cors mode\n-PASS same-origin redirect 303 in manual redirect and cors mode\n-PASS same-origin redirect 303 in manual redirect and no-cors mode\n-PASS same-origin redirect 303 in follow redirect and cors mode\n-PASS same-origin redirect 303 in follow redirect and no-cors mode\n-PASS same-origin redirect 307 in error redirect and cors mode\n-PASS same-origin redirect 307 in error redirect and no-cors mode\n-PASS same-origin redirect 307 in manual redirect and cors mode\n-PASS same-origin redirect 307 in manual redirect and no-cors mode\n-PASS same-origin redirect 307 in follow redirect and cors mode\n-PASS same-origin redirect 307 in follow redirect and no-cors mode\n-PASS same-origin redirect 308 in error redirect and cors mode\n-PASS same-origin redirect 308 in error redirect and no-cors mode\n-PASS same-origin redirect 308 in manual redirect and cors mode\n-PASS same-origin redirect 308 in manual redirect and no-cors mode\n-PASS same-origin redirect 308 in follow redirect and cors mode\n-PASS same-origin redirect 308 in follow redirect and no-cors mode\n-PASS cross-origin redirect 301 in error redirect and cors mode\n-PASS cross-origin redirect 301 in error redirect and no-cors mode\n-PASS cross-origin redirect 301 in manual redirect and cors mode\n-FAIL cross-origin redirect 301 in manual redirect and no-cors mode assert_unreached: Should have rejected: undefined Reached unreachable code\n-PASS cross-origin redirect 301 in follow redirect and cors mode\n-PASS cross-origin redirect 301 in follow redirect and no-cors mode\n-PASS cross-origin redirect 302 in error redirect and cors mode\n-PASS cross-origin redirect 302 in error redirect and no-cors mode\n-PASS cross-origin redirect 302 in manual redirect and cors mode\n-FAIL cross-origin redirect 302 in manual redirect and no-cors mode assert_unreached: Should have rejected: undefined Reached unreachable code\n-PASS cross-origin redirect 302 in follow redirect and cors mode\n-PASS cross-origin redirect 302 in follow redirect and no-cors mode\n-PASS cross-origin redirect 303 in error redirect and cors mode\n-PASS cross-origin redirect 303 in error redirect and no-cors mode\n-PASS cross-origin redirect 303 in manual redirect and cors mode\n-FAIL cross-origin redirect 303 in manual redirect and no-cors mode assert_unreached: Should have rejected: undefined Reached unreachable code\n-PASS cross-origin redirect 303 in follow redirect and cors mode\n-PASS cross-origin redirect 303 in follow redirect and no-cors mode\n-PASS cross-origin redirect 307 in error redirect and cors mode\n-PASS cross-origin redirect 307 in error redirect and no-cors mode\n-PASS cross-origin redirect 307 in manual redirect and cors mode\n-FAIL cross-origin redirect 307 in manual redirect and no-cors mode assert_unreached: Should have rejected: undefined Reached unreachable code\n-PASS cross-origin redirect 307 in follow redirect and cors mode\n-PASS cross-origin redirect 307 in follow redirect and no-cors mode\n-PASS cross-origin redirect 308 in error redirect and cors mode\n-PASS cross-origin redirect 308 in error redirect and no-cors mode\n-PASS cross-origin redirect 308 in manual redirect and cors mode\n-FAIL cross-origin redirect 308 in manual redirect and no-cors mode assert_unreached: Should have rejected: undefined Reached unreachable code\n-PASS cross-origin redirect 308 in follow redirect and cors mode\n-PASS cross-origin redirect 308 in follow redirect and no-cors mode\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""8ec810731657bd091913c0306c4f6d0602a6a936"", ""filename"": ""third_party/blink/renderer/core/fetch/fetch_manager.cc"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 0, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/a62f913109fc1566230f5963bbf69ee65274ebc8/third_party/blink/renderer/core/fetch/fetch_manager.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a62f913109fc1566230f5963bbf69ee65274ebc8/third_party/blink/renderer/core/fetch/fetch_manager.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/fetch/fetch_manager.cc?ref=a62f913109fc1566230f5963bbf69ee65274ebc8"", ""patch"": ""@@ -653,6 +653,16 @@ void FetchManager::Loader::Start() {\n \n   // \""- |request|'s mode is |no CORS|\""\n   if (fetch_request_data_->Mode() == FetchRequestMode::kNoCORS) {\n+    // \""If |request|'s redirect mode is not |follow|, then return a network\n+    // error.\n+    if (fetch_request_data_->Redirect() != FetchRedirectMode::kFollow) {\n+      PerformNetworkError(\""Fetch API cannot load \"" +\n+                          fetch_request_data_->Url().GetString() +\n+                          \"". Request mode is \\\""no-cors\\\"" but the redirect mode \""\n+                          \"" is not \\\""follow\\\"".\"");\n+      return;\n+    }\n+\n     // \""Set |request|'s response tainting to |opaque|.\""\n     fetch_request_data_->SetResponseTainting(FetchRequestData::kOpaqueTainting);\n     // \""The result of performing a scheme fetch using |request|.\""""}","void FetchManager::Loader::Start() {





  if (!ContentSecurityPolicy::ShouldBypassMainWorld(execution_context_) &&
      !execution_context_->GetContentSecurityPolicy()->AllowConnectToSource(
          fetch_request_data_->Url())) {
    PerformNetworkError(
        ""Refused to connect to '"" + fetch_request_data_->Url().ElidedString() +
        ""' because it violates the document's Content Security Policy."");
    return;
  }

  if ((SecurityOrigin::Create(fetch_request_data_->Url())
           ->IsSameSchemeHostPort(fetch_request_data_->Origin().get())) ||
      (fetch_request_data_->Url().ProtocolIsData() &&
       fetch_request_data_->SameOriginDataURLFlag()) ||
      (fetch_request_data_->Mode() == FetchRequestMode::kNavigate)) {
    PerformSchemeFetch();
    return;
  }

  if (fetch_request_data_->Mode() == FetchRequestMode::kSameOrigin) {
    PerformNetworkError(""Fetch API cannot load "" +
                        fetch_request_data_->Url().GetString() +
                        "". Request mode is \""same-origin\"" but the URL\'s ""
                        ""origin is not same as the request origin "" +
                        fetch_request_data_->Origin()->ToString() + ""."");
    return;
  }
 
   if (fetch_request_data_->Mode() == FetchRequestMode::kNoCORS) {
    // ""If |request|'s redirect mode is not |follow|, then return a network
    // error.
    if (fetch_request_data_->Redirect() != FetchRedirectMode::kFollow) {
      PerformNetworkError(""Fetch API cannot load "" +
                          fetch_request_data_->Url().GetString() +
                          "". Request mode is \""no-cors\"" but the redirect mode ""
                          "" is not \""follow\""."");
      return;
    }

     fetch_request_data_->SetResponseTainting(FetchRequestData::kOpaqueTainting);
    PerformSchemeFetch();
    return;
  }

  if (!SchemeRegistry::ShouldTreatURLSchemeAsSupportingFetchAPI(
          fetch_request_data_->Url().Protocol())) {
    PerformNetworkError(
        ""Fetch API cannot load "" + fetch_request_data_->Url().GetString() +
        "". URL scheme must be \""http\"" or \""https\"" for CORS request."");
    return;
  }

  fetch_request_data_->SetResponseTainting(FetchRequestData::kCORSTainting);

  PerformHTTPFetch();
}
","void FetchManager::Loader::Start() {





  if (!ContentSecurityPolicy::ShouldBypassMainWorld(execution_context_) &&
      !execution_context_->GetContentSecurityPolicy()->AllowConnectToSource(
          fetch_request_data_->Url())) {
    PerformNetworkError(
        ""Refused to connect to '"" + fetch_request_data_->Url().ElidedString() +
        ""' because it violates the document's Content Security Policy."");
    return;
  }

  if ((SecurityOrigin::Create(fetch_request_data_->Url())
           ->IsSameSchemeHostPort(fetch_request_data_->Origin().get())) ||
      (fetch_request_data_->Url().ProtocolIsData() &&
       fetch_request_data_->SameOriginDataURLFlag()) ||
      (fetch_request_data_->Mode() == FetchRequestMode::kNavigate)) {
    PerformSchemeFetch();
    return;
  }

  if (fetch_request_data_->Mode() == FetchRequestMode::kSameOrigin) {
    PerformNetworkError(""Fetch API cannot load "" +
                        fetch_request_data_->Url().GetString() +
                        "". Request mode is \""same-origin\"" but the URL\'s ""
                        ""origin is not same as the request origin "" +
                        fetch_request_data_->Origin()->ToString() + ""."");
    return;
  }
 
   if (fetch_request_data_->Mode() == FetchRequestMode::kNoCORS) {
     fetch_request_data_->SetResponseTainting(FetchRequestData::kOpaqueTainting);
    PerformSchemeFetch();
    return;
  }

  if (!SchemeRegistry::ShouldTreatURLSchemeAsSupportingFetchAPI(
          fetch_request_data_->Url().Protocol())) {
    PerformNetworkError(
        ""Fetch API cannot load "" + fetch_request_data_->Url().GetString() +
        "". URL scheme must be \""http\"" or \""https\"" for CORS request."");
    return;
  }

  fetch_request_data_->SetResponseTainting(FetchRequestData::kCORSTainting);

  PerformHTTPFetch();
}
",C,"    // ""If |request|'s redirect mode is not |follow|, then return a network
    // error.
    if (fetch_request_data_->Redirect() != FetchRedirectMode::kFollow) {
      PerformNetworkError(""Fetch API cannot load "" +
                          fetch_request_data_->Url().GetString() +
                          "". Request mode is \""no-cors\"" but the redirect mode ""
                          "" is not \""follow\""."");
      return;
    }

",,,"@@ -653,6 +653,16 @@ void FetchManager::Loader::Start() {
 
   // ""- |request|'s mode is |no CORS|""
   if (fetch_request_data_->Mode() == FetchRequestMode::kNoCORS) {
+    // ""If |request|'s redirect mode is not |follow|, then return a network
+    // error.
+    if (fetch_request_data_->Redirect() != FetchRedirectMode::kFollow) {
+      PerformNetworkError(""Fetch API cannot load "" +
+                          fetch_request_data_->Url().GetString() +
+                          "". Request mode is \""no-cors\"" but the redirect mode ""
+                          "" is not \""follow\""."");
+      return;
+    }
+
     // ""Set |request|'s response tainting to |opaque|.""
     fetch_request_data_->SetResponseTainting(FetchRequestData::kOpaqueTainting);
     // ""The result of performing a scheme fetch using |request|.""",Chrome,a62f913109fc1566230f5963bbf69ee65274ebc8,79ca910048175c9118606b96a840516ace45f6c7,1,"void FetchManager::Loader::Start() {
  // ""1. If |request|'s url contains a Known HSTS Host, modify it per the
  // requirements of the 'URI [sic] Loading and Port Mapping' chapter of HTTP
  // Strict Transport Security.""
  // FIXME: Implement this.

  // ""2. If |request|'s referrer is not none, set |request|'s referrer to the
  // result of invoking determine |request|'s referrer.""
  // We set the referrer using workerGlobalScope's URL in
  // WorkerThreadableLoader.

  // ""3. If |request|'s synchronous flag is unset and fetch is not invoked
  // recursively, run the remaining steps asynchronously.""
  // We don't support synchronous flag.

  // ""4. Let response be the value corresponding to the first matching
  // statement:""

  // ""- should fetching |request| be blocked as mixed content returns blocked""
  // We do mixed content checking in ResourceFetcher.

  // ""- should fetching |request| be blocked as content security returns
  //    blocked""
  if (!ContentSecurityPolicy::ShouldBypassMainWorld(execution_context_) &&
      !execution_context_->GetContentSecurityPolicy()->AllowConnectToSource(
          fetch_request_data_->Url())) {
    // ""A network error.""
    PerformNetworkError(
        ""Refused to connect to '"" + fetch_request_data_->Url().ElidedString() +
        ""' because it violates the document's Content Security Policy."");
    return;
  }

  // ""- |request|'s url's origin is |request|'s origin and the |CORS flag| is
  //    unset""
  // ""- |request|'s url's scheme is 'data' and |request|'s same-origin data
  //    URL flag is set""
  // ""- |request|'s url's scheme is 'about'""
  // Note we don't support to call this method with |CORS flag|
  // ""- |request|'s mode is |navigate|"".
  if ((SecurityOrigin::Create(fetch_request_data_->Url())
           ->IsSameSchemeHostPort(fetch_request_data_->Origin().get())) ||
      (fetch_request_data_->Url().ProtocolIsData() &&
       fetch_request_data_->SameOriginDataURLFlag()) ||
      (fetch_request_data_->Mode() == FetchRequestMode::kNavigate)) {
    // ""The result of performing a scheme fetch using request.""
    PerformSchemeFetch();
    return;
  }

  // ""- |request|'s mode is |same-origin|""
  if (fetch_request_data_->Mode() == FetchRequestMode::kSameOrigin) {
    // ""A network error.""
    PerformNetworkError(""Fetch API cannot load "" +
                        fetch_request_data_->Url().GetString() +
                        "". Request mode is \""same-origin\"" but the URL\'s ""
                        ""origin is not same as the request origin "" +
                        fetch_request_data_->Origin()->ToString() + ""."");
    return;
  }
 
   // ""- |request|'s mode is |no CORS|""
   if (fetch_request_data_->Mode() == FetchRequestMode::kNoCORS) {
//fix_flaw_line_below:
//    // ""If |request|'s redirect mode is not |follow|, then return a network
//fix_flaw_line_below:
//    // error.
//fix_flaw_line_below:
//    if (fetch_request_data_->Redirect() != FetchRedirectMode::kFollow) {
//fix_flaw_line_below:
//      PerformNetworkError(""Fetch API cannot load "" +
//fix_flaw_line_below:
//                          fetch_request_data_->Url().GetString() +
//fix_flaw_line_below:
//                          "". Request mode is \""no-cors\"" but the redirect mode ""
//fix_flaw_line_below:
//                          "" is not \""follow\""."");
//fix_flaw_line_below:
//      return;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     // ""Set |request|'s response tainting to |opaque|.""
     fetch_request_data_->SetResponseTainting(FetchRequestData::kOpaqueTainting);
     // ""The result of performing a scheme fetch using |request|.""
    PerformSchemeFetch();
    return;
  }

  // ""- |request|'s url's scheme is not one of 'http' and 'https'""
  // This may include other HTTP-like schemes if the embedder has added them
  // to SchemeRegistry::registerURLSchemeAsSupportingFetchAPI.
  if (!SchemeRegistry::ShouldTreatURLSchemeAsSupportingFetchAPI(
          fetch_request_data_->Url().Protocol())) {
    // ""A network error.""
    PerformNetworkError(
        ""Fetch API cannot load "" + fetch_request_data_->Url().GetString() +
        "". URL scheme must be \""http\"" or \""https\"" for CORS request."");
    return;
  }

  // ""Set |request|'s response tainting to |CORS|.""
  fetch_request_data_->SetResponseTainting(FetchRequestData::kCORSTainting);

  // ""The result of performing an HTTP fetch using |request| with the
  // |CORS flag| set.""
  PerformHTTPFetch();
}
",187150,"void FetchManager::Loader::Start() {





  if (!ContentSecurityPolicy::ShouldBypassMainWorld(execution_context_) &&
      !execution_context_->GetContentSecurityPolicy()->AllowConnectToSource(
          fetch_request_data_->Url())) {
    PerformNetworkError(
        ""Refused to connect to '"" + fetch_request_data_->Url().ElidedString() +
        ""' because it violates the document's Content Security Policy."");
    return;
  }

  if ((SecurityOrigin::Create(fetch_request_data_->Url())
           ->IsSameSchemeHostPort(fetch_request_data_->Origin().get())) ||
      (fetch_request_data_->Url().ProtocolIsData() &&
       fetch_request_data_->SameOriginDataURLFlag()) ||
      (fetch_request_data_->Mode() == FetchRequestMode::kNavigate)) {
    PerformSchemeFetch();
    return;
  }

  if (fetch_request_data_->Mode() == FetchRequestMode::kSameOrigin) {
    PerformNetworkError(""Fetch API cannot load "" +
                        fetch_request_data_->Url().GetString() +
                        "". Request mode is \""same-origin\"" but the URL\'s ""
                        ""origin is not same as the request origin "" +
                        fetch_request_data_->Origin()->ToString() + ""."");
    return;
  }
 
   if (fetch_request_data_->Mode() == FetchRequestMode::kNoCORS) {
     fetch_request_data_->SetResponseTainting(FetchRequestData::kOpaqueTainting);
    PerformSchemeFetch();
    return;
  }

  if (!SchemeRegistry::ShouldTreatURLSchemeAsSupportingFetchAPI(
          fetch_request_data_->Url().Protocol())) {
    PerformNetworkError(
        ""Fetch API cannot load "" + fetch_request_data_->Url().GetString() +
        "". URL scheme must be \""http\"" or \""https\"" for CORS request."");
    return;
  }

  fetch_request_data_->SetResponseTainting(FetchRequestData::kCORSTainting);

  PerformHTTPFetch();
}
","void FetchManager::Loader::Start() {





  if (!ContentSecurityPolicy::ShouldBypassMainWorld(execution_context_) &&
      !execution_context_->GetContentSecurityPolicy()->AllowConnectToSource(
          fetch_request_data_->Url())) {
    PerformNetworkError(
        ""Refused to connect to '"" + fetch_request_data_->Url().ElidedString() +
        ""' because it violates the document's Content Security Policy."");
    return;
  }

  if ((SecurityOrigin::Create(fetch_request_data_->Url())
           ->IsSameSchemeHostPort(fetch_request_data_->Origin().get())) ||
      (fetch_request_data_->Url().ProtocolIsData() &&
       fetch_request_data_->SameOriginDataURLFlag()) ||
      (fetch_request_data_->Mode() == FetchRequestMode::kNavigate)) {
    PerformSchemeFetch();
    return;
  }

  if (fetch_request_data_->Mode() == FetchRequestMode::kSameOrigin) {
    PerformNetworkError(""Fetch API cannot load "" +
                        fetch_request_data_->Url().GetString() +
                        "". Request mode is \""same-origin\"" but the URL\'s ""
                        ""origin is not same as the request origin "" +
                        fetch_request_data_->Origin()->ToString() + ""."");
    return;
  }
 
   if (fetch_request_data_->Mode() == FetchRequestMode::kNoCORS) {
    // ""If |request|'s redirect mode is not |follow|, then return a network
    // error.
    if (fetch_request_data_->Redirect() != FetchRedirectMode::kFollow) {
      PerformNetworkError(""Fetch API cannot load "" +
                          fetch_request_data_->Url().GetString() +
                          "". Request mode is \""no-cors\"" but the redirect mode ""
                          "" is not \""follow\""."");
      return;
    }

     fetch_request_data_->SetResponseTainting(FetchRequestData::kOpaqueTainting);
    PerformSchemeFetch();
    return;
  }

  if (!SchemeRegistry::ShouldTreatURLSchemeAsSupportingFetchAPI(
          fetch_request_data_->Url().Protocol())) {
    PerformNetworkError(
        ""Fetch API cannot load "" + fetch_request_data_->Url().GetString() +
        "". URL scheme must be \""http\"" or \""https\"" for CORS request."");
    return;
  }

  fetch_request_data_->SetResponseTainting(FetchRequestData::kCORSTainting);

  PerformHTTPFetch();
}
","The `FetchManager::Loader::Start` function initiates a fetch request while enforcing security policies and handling various request modes. It first checks if the request should bypass the Content Security Policy (CSP) and whether the URL is allowed by the CSP; if not, it logs a network error. The function then evaluates the request's origin and mode, determining if it can proceed with a scheme fetch or if it should return an error for same-origin violations. Additionally, it verifies the URL scheme, ensuring it is either HTTP or HTTPS for CORS requests, before finally setting the appropriate response tainting and executing an HTTP fetch.","The code defines a function that manages the initiation of a fetch request while adhering to security protocols. It first checks if the request complies with the Content Security Policy and whether the URL is permitted. Depending on the request's origin and mode, it determines if the fetch can proceed or if an error should be reported for violations. The function also ensures that the URL scheme is appropriate for cross-origin requests. Finally, it sets the response's security attributes and proceeds with the actual data fetching process, ensuring all security measures are respected throughout.","The vulnerability in the original code stemmed from allowing ""no-cors"" requests to proceed without properly validating the redirect mode, which could lead to unintended information leaks. Specifically, if the redirect mode was not set to ""follow,"" the fetch request could still be executed, potentially exposing sensitive data. The fix introduced a check to ensure that if the request mode is ""no-cors,"" the redirect mode must be ""follow."" If this condition is not met, a network error is triggered, effectively preventing the request from being processed and mitigating the risk of data leakage.","The vulnerability in the original code allowed ""no-cors"" requests to proceed without validating the redirect mode, which could lead to unintended data exposure through redirects. This oversight meant that if a redirect occurred, sensitive information could be leaked without proper checks. The fix implemented a validation step to ensure that when a request is classified as ""no-cors,"" the redirect mode must be set to ""follow."" If this condition is not satisfied, the request is halted, thereby preventing potential leaks and aligning the implementation with updated specifications to enhance security.","The vulnerability was fixed by introducing a validation check for the redirect mode when handling ""no-cors"" requests. Specifically, the code now verifies that if the request mode is set to ""no-cors,"" the redirect mode must be equal to ""follow."" This is done through the condition that checks `fetch_request_data_->Redirect() != FetchRedirectMode::kFollow`. If this condition is true, a network error is triggered, preventing the fetch from proceeding. This change ensures that requests cannot unintentionally expose sensitive data through redirects, thereby enhancing the security of the fetch operation.","The vulnerability was addressed by adding a crucial validation step that checks the redirect mode for ""no-cors"" requests. The updated code ensures that if a request is classified as ""no-cors,"" it must have its redirect mode set to ""follow."" If this requirement is not met, the request is halted, and a network error is triggered. This fix prevents the potential leakage of sensitive information through unintended redirects, thereby aligning the implementation with security best practices and ensuring that requests are processed in a manner that protects user data.","4, 5","5,5","4,4","5,4"
108,108,187243,187243,,Remote,Not required,,CVE-2018-6132,https://www.cvedetails.com/cve/CVE-2018-6132/,CWE-200,Medium,Partial,,,2019-06-27,4.3,Uninitialized data in WebRTC in Google Chrome prior to 67.0.3396.62 allowed a remote attacker to obtain potentially sensitive information from process memory via a crafted video file.,2019-06-28,+Info ,1,https://github.com/chromium/chromium/commit/a79e1bbb765af34d446e42d34cd00a312b381113,a79e1bbb765af34d446e42d34cd00a312b381113,"Fix wrapping behavior of description text in omnibox suggestion

This regression is introduced by
https://chromium-review.googlesource.com/c/chromium/src/+/827033

The description text should not wrap.

Bug: NONE
Cq-Include-Trybots: master.tryserver.chromium.android:android_optional_gpu_tests_rel;master.tryserver.chromium.linux:linux_optional_gpu_tests_rel;master.tryserver.chromium.mac:mac_optional_gpu_tests_rel;master.tryserver.chromium.win:win_optional_gpu_tests_rel
Change-Id: Iaac5e6176e1730853406602835d61fe1e80ec0d0
Reviewed-on: https://chromium-review.googlesource.com/839960
Reviewed-by: Christopher Grant <cjgrant@chromium.org>
Commit-Queue: Biao She <bshe@chromium.org>
Cr-Commit-Position: refs/heads/master@{#525806}",1,chrome/browser/vr/ui_scene_creator.cc,"{""sha"": ""731a8b1a844370a6fd89d5d2447e231470a16842"", ""filename"": ""chrome/browser/vr/ui_scene_creator.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/a79e1bbb765af34d446e42d34cd00a312b381113/chrome/browser/vr/ui_scene_creator.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a79e1bbb765af34d446e42d34cd00a312b381113/chrome/browser/vr/ui_scene_creator.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/vr/ui_scene_creator.cc?ref=a79e1bbb765af34d446e42d34cd00a312b381113"", ""patch"": ""@@ -123,7 +123,7 @@ void OnSuggestionModelAdded(UiScene* scene,\n   description_text->SetDrawPhase(kPhaseForeground);\n   description_text->SetType(kTypeOmniboxSuggestionDescriptionText);\n   description_text->set_hit_testable(false);\n-  content_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);\n+  description_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);\n   description_text->SetSize(kSuggestionTextFieldWidthDMM, 0);\n   description_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);\n   BindColor(model, description_text.get(),""}","void OnSuggestionModelAdded(UiScene* scene,
                            UiBrowserInterface* browser,
                            Model* model,
                            SuggestionBinding* element_binding) {
  auto icon = base::MakeUnique<VectorIcon>(100);
  icon->SetDrawPhase(kPhaseForeground);
  icon->SetType(kTypeOmniboxSuggestionIcon);
  icon->set_hit_testable(false);
  icon->SetSize(kSuggestionIconSizeDMM, kSuggestionIconSizeDMM);
  BindColor(model, icon.get(), &ColorScheme::omnibox_icon,
            &VectorIcon::SetColor);
  VectorIcon* p_icon = icon.get();

  auto icon_box = base::MakeUnique<UiElement>();
  icon_box->SetDrawPhase(kPhaseNone);
  icon_box->SetType(kTypeOmniboxSuggestionIconField);
  icon_box->SetSize(kSuggestionIconFieldWidthDMM, kSuggestionHeightDMM);
  icon_box->AddChild(std::move(icon));

  auto content_text = base::MakeUnique<Text>(kSuggestionContentTextHeightDMM);
  content_text->SetDrawPhase(kPhaseForeground);
  content_text->SetType(kTypeOmniboxSuggestionContentText);
  content_text->set_hit_testable(false);
  content_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);
  content_text->SetSize(kSuggestionTextFieldWidthDMM, 0);
  content_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);
  BindColor(model, content_text.get(), &ColorScheme::omnibox_suggestion_content,
            &Text::SetColor);
  Text* p_content_text = content_text.get();

  auto description_text =
      base::MakeUnique<Text>(kSuggestionDescriptionTextHeightDMM);
   description_text->SetDrawPhase(kPhaseForeground);
   description_text->SetType(kTypeOmniboxSuggestionDescriptionText);
   description_text->set_hit_testable(false);
  description_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);
   description_text->SetSize(kSuggestionTextFieldWidthDMM, 0);
   description_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);
   BindColor(model, description_text.get(),
            &ColorScheme::omnibox_suggestion_description, &Text::SetColor);
  Text* p_description_text = description_text.get();

  auto text_layout = base::MakeUnique<LinearLayout>(LinearLayout::kDown);
  text_layout->SetType(kTypeOmniboxSuggestionTextLayout);
  text_layout->set_hit_testable(false);
  text_layout->set_margin(kSuggestionLineGapDMM);
  text_layout->AddChild(std::move(content_text));
  text_layout->AddChild(std::move(description_text));

  auto right_margin = base::MakeUnique<UiElement>();
  right_margin->SetDrawPhase(kPhaseNone);
  right_margin->SetSize(kSuggestionRightMarginDMM, kSuggestionHeightDMM);

  auto suggestion_layout = base::MakeUnique<LinearLayout>(LinearLayout::kRight);
  suggestion_layout->SetType(kTypeOmniboxSuggestionLayout);
  suggestion_layout->set_hit_testable(false);
  suggestion_layout->AddChild(std::move(icon_box));
  suggestion_layout->AddChild(std::move(text_layout));
  suggestion_layout->AddChild(std::move(right_margin));

  auto background = Create<Button>(
      kNone, kPhaseForeground,
      base::BindRepeating(
          [](UiBrowserInterface* b, Model* m, SuggestionBinding* e) {
            b->Navigate(e->model()->destination);
            m->omnibox_input_active = false;
          },
          base::Unretained(browser), base::Unretained(model),
          base::Unretained(element_binding)));

  background->SetType(kTypeOmniboxSuggestionBackground);
  background->set_hit_testable(true);
  background->set_bubble_events(true);
  background->set_bounds_contain_children(true);
  background->set_hover_offset(0.0);
  BindButtonColors(model, background.get(),
                   &ColorScheme::suggestion_button_colors,
                   &Button::SetButtonColors);
  background->AddChild(std::move(suggestion_layout));

  element_binding->bindings().push_back(
      VR_BIND_FUNC(base::string16, SuggestionBinding, element_binding,
                   model()->content, Text, p_content_text, SetText));
  element_binding->bindings().push_back(
      base::MakeUnique<Binding<base::string16>>(
          base::BindRepeating(
              [](SuggestionBinding* m) { return m->model()->description; },
              base::Unretained(element_binding)),
          base::BindRepeating(
              [](Text* v, const base::string16& text) {
                v->SetVisibleImmediately(!text.empty());
                v->set_requires_layout(!text.empty());
                if (!text.empty()) {
                  v->SetText(text);
                }
              },
              base::Unretained(p_description_text))));
  element_binding->bindings().push_back(
      VR_BIND(AutocompleteMatch::Type, SuggestionBinding, element_binding,
              model()->type, VectorIcon, p_icon,
              SetIcon(AutocompleteMatch::TypeToVectorIcon(value))));
  element_binding->set_view(background.get());
  scene->AddUiElement(kOmniboxSuggestions, std::move(background));
}
","void OnSuggestionModelAdded(UiScene* scene,
                            UiBrowserInterface* browser,
                            Model* model,
                            SuggestionBinding* element_binding) {
  auto icon = base::MakeUnique<VectorIcon>(100);
  icon->SetDrawPhase(kPhaseForeground);
  icon->SetType(kTypeOmniboxSuggestionIcon);
  icon->set_hit_testable(false);
  icon->SetSize(kSuggestionIconSizeDMM, kSuggestionIconSizeDMM);
  BindColor(model, icon.get(), &ColorScheme::omnibox_icon,
            &VectorIcon::SetColor);
  VectorIcon* p_icon = icon.get();

  auto icon_box = base::MakeUnique<UiElement>();
  icon_box->SetDrawPhase(kPhaseNone);
  icon_box->SetType(kTypeOmniboxSuggestionIconField);
  icon_box->SetSize(kSuggestionIconFieldWidthDMM, kSuggestionHeightDMM);
  icon_box->AddChild(std::move(icon));

  auto content_text = base::MakeUnique<Text>(kSuggestionContentTextHeightDMM);
  content_text->SetDrawPhase(kPhaseForeground);
  content_text->SetType(kTypeOmniboxSuggestionContentText);
  content_text->set_hit_testable(false);
  content_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);
  content_text->SetSize(kSuggestionTextFieldWidthDMM, 0);
  content_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);
  BindColor(model, content_text.get(), &ColorScheme::omnibox_suggestion_content,
            &Text::SetColor);
  Text* p_content_text = content_text.get();

  auto description_text =
      base::MakeUnique<Text>(kSuggestionDescriptionTextHeightDMM);
   description_text->SetDrawPhase(kPhaseForeground);
   description_text->SetType(kTypeOmniboxSuggestionDescriptionText);
   description_text->set_hit_testable(false);
  content_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);
   description_text->SetSize(kSuggestionTextFieldWidthDMM, 0);
   description_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);
   BindColor(model, description_text.get(),
            &ColorScheme::omnibox_suggestion_description, &Text::SetColor);
  Text* p_description_text = description_text.get();

  auto text_layout = base::MakeUnique<LinearLayout>(LinearLayout::kDown);
  text_layout->SetType(kTypeOmniboxSuggestionTextLayout);
  text_layout->set_hit_testable(false);
  text_layout->set_margin(kSuggestionLineGapDMM);
  text_layout->AddChild(std::move(content_text));
  text_layout->AddChild(std::move(description_text));

  auto right_margin = base::MakeUnique<UiElement>();
  right_margin->SetDrawPhase(kPhaseNone);
  right_margin->SetSize(kSuggestionRightMarginDMM, kSuggestionHeightDMM);

  auto suggestion_layout = base::MakeUnique<LinearLayout>(LinearLayout::kRight);
  suggestion_layout->SetType(kTypeOmniboxSuggestionLayout);
  suggestion_layout->set_hit_testable(false);
  suggestion_layout->AddChild(std::move(icon_box));
  suggestion_layout->AddChild(std::move(text_layout));
  suggestion_layout->AddChild(std::move(right_margin));

  auto background = Create<Button>(
      kNone, kPhaseForeground,
      base::BindRepeating(
          [](UiBrowserInterface* b, Model* m, SuggestionBinding* e) {
            b->Navigate(e->model()->destination);
            m->omnibox_input_active = false;
          },
          base::Unretained(browser), base::Unretained(model),
          base::Unretained(element_binding)));

  background->SetType(kTypeOmniboxSuggestionBackground);
  background->set_hit_testable(true);
  background->set_bubble_events(true);
  background->set_bounds_contain_children(true);
  background->set_hover_offset(0.0);
  BindButtonColors(model, background.get(),
                   &ColorScheme::suggestion_button_colors,
                   &Button::SetButtonColors);
  background->AddChild(std::move(suggestion_layout));

  element_binding->bindings().push_back(
      VR_BIND_FUNC(base::string16, SuggestionBinding, element_binding,
                   model()->content, Text, p_content_text, SetText));
  element_binding->bindings().push_back(
      base::MakeUnique<Binding<base::string16>>(
          base::BindRepeating(
              [](SuggestionBinding* m) { return m->model()->description; },
              base::Unretained(element_binding)),
          base::BindRepeating(
              [](Text* v, const base::string16& text) {
                v->SetVisibleImmediately(!text.empty());
                v->set_requires_layout(!text.empty());
                if (!text.empty()) {
                  v->SetText(text);
                }
              },
              base::Unretained(p_description_text))));
  element_binding->bindings().push_back(
      VR_BIND(AutocompleteMatch::Type, SuggestionBinding, element_binding,
              model()->type, VectorIcon, p_icon,
              SetIcon(AutocompleteMatch::TypeToVectorIcon(value))));
  element_binding->set_view(background.get());
  scene->AddUiElement(kOmniboxSuggestions, std::move(background));
}
",C,"  description_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);
","  content_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);
",,"@@ -123,7 +123,7 @@ void OnSuggestionModelAdded(UiScene* scene,
   description_text->SetDrawPhase(kPhaseForeground);
   description_text->SetType(kTypeOmniboxSuggestionDescriptionText);
   description_text->set_hit_testable(false);
-  content_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);
+  description_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);
   description_text->SetSize(kSuggestionTextFieldWidthDMM, 0);
   description_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);
   BindColor(model, description_text.get(),",Chrome,a79e1bbb765af34d446e42d34cd00a312b381113,fe2c9b07629d1f19c2a95a447ee0fdcd0e9c7937,1,"void OnSuggestionModelAdded(UiScene* scene,
                            UiBrowserInterface* browser,
                            Model* model,
                            SuggestionBinding* element_binding) {
  auto icon = base::MakeUnique<VectorIcon>(100);
  icon->SetDrawPhase(kPhaseForeground);
  icon->SetType(kTypeOmniboxSuggestionIcon);
  icon->set_hit_testable(false);
  icon->SetSize(kSuggestionIconSizeDMM, kSuggestionIconSizeDMM);
  BindColor(model, icon.get(), &ColorScheme::omnibox_icon,
            &VectorIcon::SetColor);
  VectorIcon* p_icon = icon.get();

  auto icon_box = base::MakeUnique<UiElement>();
  icon_box->SetDrawPhase(kPhaseNone);
  icon_box->SetType(kTypeOmniboxSuggestionIconField);
  icon_box->SetSize(kSuggestionIconFieldWidthDMM, kSuggestionHeightDMM);
  icon_box->AddChild(std::move(icon));

  auto content_text = base::MakeUnique<Text>(kSuggestionContentTextHeightDMM);
  content_text->SetDrawPhase(kPhaseForeground);
  content_text->SetType(kTypeOmniboxSuggestionContentText);
  content_text->set_hit_testable(false);
  content_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);
  content_text->SetSize(kSuggestionTextFieldWidthDMM, 0);
  content_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);
  BindColor(model, content_text.get(), &ColorScheme::omnibox_suggestion_content,
            &Text::SetColor);
  Text* p_content_text = content_text.get();

  auto description_text =
      base::MakeUnique<Text>(kSuggestionDescriptionTextHeightDMM);
   description_text->SetDrawPhase(kPhaseForeground);
   description_text->SetType(kTypeOmniboxSuggestionDescriptionText);
   description_text->set_hit_testable(false);
//flaw_line_below:
  content_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);
//fix_flaw_line_below:
//  description_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);
   description_text->SetSize(kSuggestionTextFieldWidthDMM, 0);
   description_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);
   BindColor(model, description_text.get(),
            &ColorScheme::omnibox_suggestion_description, &Text::SetColor);
  Text* p_description_text = description_text.get();

  auto text_layout = base::MakeUnique<LinearLayout>(LinearLayout::kDown);
  text_layout->SetType(kTypeOmniboxSuggestionTextLayout);
  text_layout->set_hit_testable(false);
  text_layout->set_margin(kSuggestionLineGapDMM);
  text_layout->AddChild(std::move(content_text));
  text_layout->AddChild(std::move(description_text));

  auto right_margin = base::MakeUnique<UiElement>();
  right_margin->SetDrawPhase(kPhaseNone);
  right_margin->SetSize(kSuggestionRightMarginDMM, kSuggestionHeightDMM);

  auto suggestion_layout = base::MakeUnique<LinearLayout>(LinearLayout::kRight);
  suggestion_layout->SetType(kTypeOmniboxSuggestionLayout);
  suggestion_layout->set_hit_testable(false);
  suggestion_layout->AddChild(std::move(icon_box));
  suggestion_layout->AddChild(std::move(text_layout));
  suggestion_layout->AddChild(std::move(right_margin));

  auto background = Create<Button>(
      kNone, kPhaseForeground,
      base::BindRepeating(
          [](UiBrowserInterface* b, Model* m, SuggestionBinding* e) {
            b->Navigate(e->model()->destination);
            // TODO(vollick): set this as a side effect of navigating.
            m->omnibox_input_active = false;
          },
          base::Unretained(browser), base::Unretained(model),
          base::Unretained(element_binding)));

  background->SetType(kTypeOmniboxSuggestionBackground);
  background->set_hit_testable(true);
  background->set_bubble_events(true);
  background->set_bounds_contain_children(true);
  background->set_hover_offset(0.0);
  BindButtonColors(model, background.get(),
                   &ColorScheme::suggestion_button_colors,
                   &Button::SetButtonColors);
  background->AddChild(std::move(suggestion_layout));

  element_binding->bindings().push_back(
      VR_BIND_FUNC(base::string16, SuggestionBinding, element_binding,
                   model()->content, Text, p_content_text, SetText));
  element_binding->bindings().push_back(
      base::MakeUnique<Binding<base::string16>>(
          base::BindRepeating(
              [](SuggestionBinding* m) { return m->model()->description; },
              base::Unretained(element_binding)),
          base::BindRepeating(
              [](Text* v, const base::string16& text) {
                v->SetVisibleImmediately(!text.empty());
                v->set_requires_layout(!text.empty());
                if (!text.empty()) {
                  v->SetText(text);
                }
              },
              base::Unretained(p_description_text))));
  element_binding->bindings().push_back(
      VR_BIND(AutocompleteMatch::Type, SuggestionBinding, element_binding,
              model()->type, VectorIcon, p_icon,
              SetIcon(AutocompleteMatch::TypeToVectorIcon(value))));
  element_binding->set_view(background.get());
  scene->AddUiElement(kOmniboxSuggestions, std::move(background));
}
",187243,"void OnSuggestionModelAdded(UiScene* scene,
                            UiBrowserInterface* browser,
                            Model* model,
                            SuggestionBinding* element_binding) {
  auto icon = base::MakeUnique<VectorIcon>(100);
  icon->SetDrawPhase(kPhaseForeground);
  icon->SetType(kTypeOmniboxSuggestionIcon);
  icon->set_hit_testable(false);
  icon->SetSize(kSuggestionIconSizeDMM, kSuggestionIconSizeDMM);
  BindColor(model, icon.get(), &ColorScheme::omnibox_icon,
            &VectorIcon::SetColor);
  VectorIcon* p_icon = icon.get();

  auto icon_box = base::MakeUnique<UiElement>();
  icon_box->SetDrawPhase(kPhaseNone);
  icon_box->SetType(kTypeOmniboxSuggestionIconField);
  icon_box->SetSize(kSuggestionIconFieldWidthDMM, kSuggestionHeightDMM);
  icon_box->AddChild(std::move(icon));

  auto content_text = base::MakeUnique<Text>(kSuggestionContentTextHeightDMM);
  content_text->SetDrawPhase(kPhaseForeground);
  content_text->SetType(kTypeOmniboxSuggestionContentText);
  content_text->set_hit_testable(false);
  content_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);
  content_text->SetSize(kSuggestionTextFieldWidthDMM, 0);
  content_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);
  BindColor(model, content_text.get(), &ColorScheme::omnibox_suggestion_content,
            &Text::SetColor);
  Text* p_content_text = content_text.get();

  auto description_text =
      base::MakeUnique<Text>(kSuggestionDescriptionTextHeightDMM);
   description_text->SetDrawPhase(kPhaseForeground);
   description_text->SetType(kTypeOmniboxSuggestionDescriptionText);
   description_text->set_hit_testable(false);
  content_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);
   description_text->SetSize(kSuggestionTextFieldWidthDMM, 0);
   description_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);
   BindColor(model, description_text.get(),
            &ColorScheme::omnibox_suggestion_description, &Text::SetColor);
  Text* p_description_text = description_text.get();

  auto text_layout = base::MakeUnique<LinearLayout>(LinearLayout::kDown);
  text_layout->SetType(kTypeOmniboxSuggestionTextLayout);
  text_layout->set_hit_testable(false);
  text_layout->set_margin(kSuggestionLineGapDMM);
  text_layout->AddChild(std::move(content_text));
  text_layout->AddChild(std::move(description_text));

  auto right_margin = base::MakeUnique<UiElement>();
  right_margin->SetDrawPhase(kPhaseNone);
  right_margin->SetSize(kSuggestionRightMarginDMM, kSuggestionHeightDMM);

  auto suggestion_layout = base::MakeUnique<LinearLayout>(LinearLayout::kRight);
  suggestion_layout->SetType(kTypeOmniboxSuggestionLayout);
  suggestion_layout->set_hit_testable(false);
  suggestion_layout->AddChild(std::move(icon_box));
  suggestion_layout->AddChild(std::move(text_layout));
  suggestion_layout->AddChild(std::move(right_margin));

  auto background = Create<Button>(
      kNone, kPhaseForeground,
      base::BindRepeating(
          [](UiBrowserInterface* b, Model* m, SuggestionBinding* e) {
            b->Navigate(e->model()->destination);
            m->omnibox_input_active = false;
          },
          base::Unretained(browser), base::Unretained(model),
          base::Unretained(element_binding)));

  background->SetType(kTypeOmniboxSuggestionBackground);
  background->set_hit_testable(true);
  background->set_bubble_events(true);
  background->set_bounds_contain_children(true);
  background->set_hover_offset(0.0);
  BindButtonColors(model, background.get(),
                   &ColorScheme::suggestion_button_colors,
                   &Button::SetButtonColors);
  background->AddChild(std::move(suggestion_layout));

  element_binding->bindings().push_back(
      VR_BIND_FUNC(base::string16, SuggestionBinding, element_binding,
                   model()->content, Text, p_content_text, SetText));
  element_binding->bindings().push_back(
      base::MakeUnique<Binding<base::string16>>(
          base::BindRepeating(
              [](SuggestionBinding* m) { return m->model()->description; },
              base::Unretained(element_binding)),
          base::BindRepeating(
              [](Text* v, const base::string16& text) {
                v->SetVisibleImmediately(!text.empty());
                v->set_requires_layout(!text.empty());
                if (!text.empty()) {
                  v->SetText(text);
                }
              },
              base::Unretained(p_description_text))));
  element_binding->bindings().push_back(
      VR_BIND(AutocompleteMatch::Type, SuggestionBinding, element_binding,
              model()->type, VectorIcon, p_icon,
              SetIcon(AutocompleteMatch::TypeToVectorIcon(value))));
  element_binding->set_view(background.get());
  scene->AddUiElement(kOmniboxSuggestions, std::move(background));
}
","void OnSuggestionModelAdded(UiScene* scene,
                            UiBrowserInterface* browser,
                            Model* model,
                            SuggestionBinding* element_binding) {
  auto icon = base::MakeUnique<VectorIcon>(100);
  icon->SetDrawPhase(kPhaseForeground);
  icon->SetType(kTypeOmniboxSuggestionIcon);
  icon->set_hit_testable(false);
  icon->SetSize(kSuggestionIconSizeDMM, kSuggestionIconSizeDMM);
  BindColor(model, icon.get(), &ColorScheme::omnibox_icon,
            &VectorIcon::SetColor);
  VectorIcon* p_icon = icon.get();

  auto icon_box = base::MakeUnique<UiElement>();
  icon_box->SetDrawPhase(kPhaseNone);
  icon_box->SetType(kTypeOmniboxSuggestionIconField);
  icon_box->SetSize(kSuggestionIconFieldWidthDMM, kSuggestionHeightDMM);
  icon_box->AddChild(std::move(icon));

  auto content_text = base::MakeUnique<Text>(kSuggestionContentTextHeightDMM);
  content_text->SetDrawPhase(kPhaseForeground);
  content_text->SetType(kTypeOmniboxSuggestionContentText);
  content_text->set_hit_testable(false);
  content_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);
  content_text->SetSize(kSuggestionTextFieldWidthDMM, 0);
  content_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);
  BindColor(model, content_text.get(), &ColorScheme::omnibox_suggestion_content,
            &Text::SetColor);
  Text* p_content_text = content_text.get();

  auto description_text =
      base::MakeUnique<Text>(kSuggestionDescriptionTextHeightDMM);
   description_text->SetDrawPhase(kPhaseForeground);
   description_text->SetType(kTypeOmniboxSuggestionDescriptionText);
   description_text->set_hit_testable(false);
  description_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);
   description_text->SetSize(kSuggestionTextFieldWidthDMM, 0);
   description_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);
   BindColor(model, description_text.get(),
            &ColorScheme::omnibox_suggestion_description, &Text::SetColor);
  Text* p_description_text = description_text.get();

  auto text_layout = base::MakeUnique<LinearLayout>(LinearLayout::kDown);
  text_layout->SetType(kTypeOmniboxSuggestionTextLayout);
  text_layout->set_hit_testable(false);
  text_layout->set_margin(kSuggestionLineGapDMM);
  text_layout->AddChild(std::move(content_text));
  text_layout->AddChild(std::move(description_text));

  auto right_margin = base::MakeUnique<UiElement>();
  right_margin->SetDrawPhase(kPhaseNone);
  right_margin->SetSize(kSuggestionRightMarginDMM, kSuggestionHeightDMM);

  auto suggestion_layout = base::MakeUnique<LinearLayout>(LinearLayout::kRight);
  suggestion_layout->SetType(kTypeOmniboxSuggestionLayout);
  suggestion_layout->set_hit_testable(false);
  suggestion_layout->AddChild(std::move(icon_box));
  suggestion_layout->AddChild(std::move(text_layout));
  suggestion_layout->AddChild(std::move(right_margin));

  auto background = Create<Button>(
      kNone, kPhaseForeground,
      base::BindRepeating(
          [](UiBrowserInterface* b, Model* m, SuggestionBinding* e) {
            b->Navigate(e->model()->destination);
            m->omnibox_input_active = false;
          },
          base::Unretained(browser), base::Unretained(model),
          base::Unretained(element_binding)));

  background->SetType(kTypeOmniboxSuggestionBackground);
  background->set_hit_testable(true);
  background->set_bubble_events(true);
  background->set_bounds_contain_children(true);
  background->set_hover_offset(0.0);
  BindButtonColors(model, background.get(),
                   &ColorScheme::suggestion_button_colors,
                   &Button::SetButtonColors);
  background->AddChild(std::move(suggestion_layout));

  element_binding->bindings().push_back(
      VR_BIND_FUNC(base::string16, SuggestionBinding, element_binding,
                   model()->content, Text, p_content_text, SetText));
  element_binding->bindings().push_back(
      base::MakeUnique<Binding<base::string16>>(
          base::BindRepeating(
              [](SuggestionBinding* m) { return m->model()->description; },
              base::Unretained(element_binding)),
          base::BindRepeating(
              [](Text* v, const base::string16& text) {
                v->SetVisibleImmediately(!text.empty());
                v->set_requires_layout(!text.empty());
                if (!text.empty()) {
                  v->SetText(text);
                }
              },
              base::Unretained(p_description_text))));
  element_binding->bindings().push_back(
      VR_BIND(AutocompleteMatch::Type, SuggestionBinding, element_binding,
              model()->type, VectorIcon, p_icon,
              SetIcon(AutocompleteMatch::TypeToVectorIcon(value))));
  element_binding->set_view(background.get());
  scene->AddUiElement(kOmniboxSuggestions, std::move(background));
}
","The provided code defines a function that constructs and adds a user interface element for displaying omnibox suggestions in a browser. It creates a layout containing an icon, content text, and description text, all styled according to a specified color scheme. The function utilizes various UI components, such as `VectorIcon`, `Text`, and `LinearLayout`, to organize these elements visually. Additionally, it binds data from a model to the UI elements, ensuring that the displayed text and icon update dynamically based on user interactions. Finally, the assembled UI element is added to the scene, enabling user interaction with the suggestions.","The code defines a function that creates and configures a user interface element for displaying suggestions in a browser's omnibox. It constructs a layout that includes an icon, content text, and a description, all styled according to a specific color scheme. The function ensures that these elements are dynamically bound to a data model, allowing for real-time updates based on user interactions. Additionally, it sets up a background element that captures user input, enabling navigation to a selected suggestion. Finally, the complete suggestion element is added to the scene for user interaction.","The vulnerability in the original code stemmed from the description text wrapping unexpectedly, which could lead to a poor user experience by disrupting the intended layout of omnibox suggestions. This issue was introduced in a previous change that altered the text layout behavior. The fix involved ensuring that the description text was set to a single-line layout mode, preventing it from wrapping. By explicitly configuring the text layout mode for the description text, the updated code maintains a consistent and visually appealing presentation of suggestions, thereby enhancing usability and preventing layout issues.","The vulnerability in the original code was related to the description text wrapping unexpectedly, which compromised the visual integrity and usability of the omnibox suggestions. This issue arose from a previous change that inadvertently altered the text layout behavior, leading to a less coherent presentation. The fix involved explicitly setting the description text to a single-line layout mode, ensuring it would not wrap. This adjustment restored the intended design, maintaining a clean and user-friendly interface for displaying suggestions, thereby enhancing the overall user experience and preventing layout disruptions.","The vulnerability was fixed by explicitly setting the text layout mode of the description text to a single-line fixed width. In the updated code, the `SetTextLayoutMode` function was called with the appropriate layout mode for the description text, ensuring it would not wrap. This change was crucial in maintaining the visual consistency of the omnibox suggestions. Additionally, the `SetVisibleImmediately` and `set_requires_layout` functions were utilized to manage the visibility and layout requirements of the description text, further ensuring that the user interface remained clean and user-friendly without unexpected text wrapping.","The vulnerability was fixed by adjusting the layout settings for the description text to ensure it remained on a single line, preventing any unwanted wrapping. This involved explicitly configuring the text layout mode to a fixed width, which maintained the intended visual structure of the omnibox suggestions. Additionally, the code was updated to manage the visibility and layout requirements of the description text effectively, ensuring that it only displayed when appropriate. These changes collectively restored the user interface's clarity and usability, enhancing the overall experience by preventing layout disruptions.","4,5","4, 5","4, 5","4, 5"
109,109,187247,187247,,Remote,Not required,,CVE-2018-6134,https://www.cvedetails.com/cve/CVE-2018-6134/,CWE-200,Medium,Partial,,,2019-06-27,4.3,Information leak in Blink in Google Chrome prior to 67.0.3396.62 allowed a remote attacker to bypass no-referrer policy via a crafted HTML page.,2019-06-27,Bypass +Info ,5,https://github.com/chromium/chromium/commit/87e204e0aaf7445afbd0d50af6849d857517ae70,87e204e0aaf7445afbd0d50af6849d857517ae70,"Fix the |name| of PerformanceNavigationTiming

Previously, the |name| of a PerformanceNavigationTiming entry was the initial
URL (the request URL). After this CL, it is the response URL, so for example
a url of the form 'redirect?location=newLoc' will have 'newLoc' as the |name|.

Bug: 797465
Change-Id: Icab53ad8027d066422562c82bcf0354c264fea40
Reviewed-on: https://chromium-review.googlesource.com/996579
Reviewed-by: Yoav Weiss <yoav@yoav.ws>
Commit-Queue: Nicolás Peña Moreno <npm@chromium.org>
Cr-Commit-Position: refs/heads/master@{#548773}",4,third_party/WebKit/Source/core/timing/PerformanceNavigationTiming.cpp,"{""sha"": ""1d7f6c928ce63c94edc1491d2883c87331e38722"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/navigation-timing/nav2_test_redirect_server.html"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 4, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/87e204e0aaf7445afbd0d50af6849d857517ae70/third_party/WebKit/LayoutTests/external/wpt/navigation-timing/nav2_test_redirect_server.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/87e204e0aaf7445afbd0d50af6849d857517ae70/third_party/WebKit/LayoutTests/external/wpt/navigation-timing/nav2_test_redirect_server.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/navigation-timing/nav2_test_redirect_server.html?ref=87e204e0aaf7445afbd0d50af6849d857517ae70"", ""patch"": ""@@ -11,19 +11,21 @@\n         <script>\n \n             function verifyTimingEventOrder(eventOrder, timingEntry) {\n-                for (var i = 0; i < eventOrder.length - 1; i++) {\n+                for (let i = 0; i < eventOrder.length - 1; i++) {\n                     assert_true(timingEntry[eventOrder[i]] < timingEntry[eventOrder[i + 1]],\n                         \""Expected \"" + eventOrder[i] + \"" to be no greater than \"" + eventOrder[i + 1] + \"".\"");\n                 }\n             }\n \n             function onload_test()\n             {\n-                var frame_performance = document.getElementById(\""frameContext\"").contentWindow.performance;\n-                assert_equals(frame_performance.getEntriesByType(\""navigation\"")[0].type,\n+                const frame_performance = document.getElementById(\""frameContext\"").contentWindow.performance;\n+                const navigation_entry = frame_performance.getEntriesByType(\""navigation\"")[0];\n+                assert_equals(navigation_entry.type,\n                         \""navigate\"",\n                         \""Expected navigation type  to be navigate.\"");\n-                assert_equals(frame_performance.getEntriesByType(\""navigation\"")[0].redirectCount, 1, \""Expected redirectCount to be 1.\"");\n+                assert_equals(navigation_entry.redirectCount, 1, \""Expected redirectCount to be 1.\"");\n+                assert_equals(navigation_entry.name, 'http://' + document.location.host + '/navigation-timing/resources/blank_page_green.html');\n \n                 var timgingEvents = [\n                     'startTime',""}<_**next**_>{""sha"": ""2ff0d015578a9dc1ebc45e205315570263fdb1f8"", ""filename"": ""third_party/WebKit/Source/core/timing/PerformanceNavigationTiming.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/87e204e0aaf7445afbd0d50af6849d857517ae70/third_party/WebKit/Source/core/timing/PerformanceNavigationTiming.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/87e204e0aaf7445afbd0d50af6849d857517ae70/third_party/WebKit/Source/core/timing/PerformanceNavigationTiming.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/timing/PerformanceNavigationTiming.cpp?ref=87e204e0aaf7445afbd0d50af6849d857517ae70"", ""patch"": ""@@ -21,10 +21,11 @@ PerformanceNavigationTiming::PerformanceNavigationTiming(\n     ResourceTimingInfo* info,\n     TimeTicks time_origin,\n     const WebVector<WebServerTimingInfo>& server_timing)\n-    : PerformanceResourceTiming(info ? info->InitialURL().GetString() : \""\"",\n-                                \""navigation\"",\n-                                time_origin,\n-                                server_timing),\n+    : PerformanceResourceTiming(\n+          info ? info->FinalResponse().Url().GetString() : \""\"",\n+          \""navigation\"",\n+          time_origin,\n+          server_timing),\n       ContextClient(frame),\n       resource_timing_info_(info) {\n   DCHECK(frame);""}","PerformanceNavigationTiming::PerformanceNavigationTiming(
    LocalFrame* frame,
     ResourceTimingInfo* info,
     TimeTicks time_origin,
     const WebVector<WebServerTimingInfo>& server_timing)
    : PerformanceResourceTiming(
          info ? info->FinalResponse().Url().GetString() : """",
          ""navigation"",
          time_origin,
          server_timing),
       ContextClient(frame),
       resource_timing_info_(info) {
   DCHECK(frame);
  DCHECK(info);
}
","PerformanceNavigationTiming::PerformanceNavigationTiming(
    LocalFrame* frame,
     ResourceTimingInfo* info,
     TimeTicks time_origin,
     const WebVector<WebServerTimingInfo>& server_timing)
    : PerformanceResourceTiming(info ? info->InitialURL().GetString() : """",
                                ""navigation"",
                                time_origin,
                                server_timing),
       ContextClient(frame),
       resource_timing_info_(info) {
   DCHECK(frame);
  DCHECK(info);
}
",C,"    : PerformanceResourceTiming(
          info ? info->FinalResponse().Url().GetString() : """",
          ""navigation"",
          time_origin,
          server_timing),
","    : PerformanceResourceTiming(info ? info->InitialURL().GetString() : """",
                                ""navigation"",
                                time_origin,
                                server_timing),
",,"@@ -21,10 +21,11 @@ PerformanceNavigationTiming::PerformanceNavigationTiming(
     ResourceTimingInfo* info,
     TimeTicks time_origin,
     const WebVector<WebServerTimingInfo>& server_timing)
-    : PerformanceResourceTiming(info ? info->InitialURL().GetString() : """",
-                                ""navigation"",
-                                time_origin,
-                                server_timing),
+    : PerformanceResourceTiming(
+          info ? info->FinalResponse().Url().GetString() : """",
+          ""navigation"",
+          time_origin,
+          server_timing),
       ContextClient(frame),
       resource_timing_info_(info) {
   DCHECK(frame);",Chrome,87e204e0aaf7445afbd0d50af6849d857517ae70,36baddf27e21f4cc31aae61bffb22269b3787e5e,1,"PerformanceNavigationTiming::PerformanceNavigationTiming(
    LocalFrame* frame,
     ResourceTimingInfo* info,
     TimeTicks time_origin,
     const WebVector<WebServerTimingInfo>& server_timing)
//flaw_line_below:
    : PerformanceResourceTiming(info ? info->InitialURL().GetString() : """",
//flaw_line_below:
                                ""navigation"",
//flaw_line_below:
                                time_origin,
//flaw_line_below:
                                server_timing),
//fix_flaw_line_below:
//    : PerformanceResourceTiming(
//fix_flaw_line_below:
//          info ? info->FinalResponse().Url().GetString() : """",
//fix_flaw_line_below:
//          ""navigation"",
//fix_flaw_line_below:
//          time_origin,
//fix_flaw_line_below:
//          server_timing),
       ContextClient(frame),
       resource_timing_info_(info) {
   DCHECK(frame);
  DCHECK(info);
}
",187247,"PerformanceNavigationTiming::PerformanceNavigationTiming(
    LocalFrame* frame,
     ResourceTimingInfo* info,
     TimeTicks time_origin,
     const WebVector<WebServerTimingInfo>& server_timing)
    : PerformanceResourceTiming(info ? info->InitialURL().GetString() : """",
                                ""navigation"",
                                time_origin,
                                server_timing),
       ContextClient(frame),
       resource_timing_info_(info) {
   DCHECK(frame);
  DCHECK(info);
}
","PerformanceNavigationTiming::PerformanceNavigationTiming(
    LocalFrame* frame,
     ResourceTimingInfo* info,
     TimeTicks time_origin,
     const WebVector<WebServerTimingInfo>& server_timing)
    : PerformanceResourceTiming(
          info ? info->FinalResponse().Url().GetString() : """",
          ""navigation"",
          time_origin,
          server_timing),
       ContextClient(frame),
       resource_timing_info_(info) {
   DCHECK(frame);
  DCHECK(info);
}
","The provided code defines a constructor for the `PerformanceNavigationTiming` class, which is designed to capture and represent navigation timing metrics for web performance analysis. It initializes the base class `PerformanceResourceTiming` with parameters such as the initial URL, a resource type of ""navigation,"" the time origin, and server timing information. The constructor also initializes the `ContextClient` with a `LocalFrame` pointer and stores a reference to `ResourceTimingInfo`. The use of `DCHECK` ensures that both the `frame` and `info` pointers are valid, enforcing runtime checks for these critical dependencies.","The code defines a constructor for a class that captures navigation timing metrics related to web performance. It initializes the base class with essential parameters, including the initial URL, the type of resource being measured, the time origin, and server timing data. Additionally, it sets up a client context using a frame pointer and retains a reference to timing information. The constructor includes checks to ensure that both the frame and timing information are valid, thereby enforcing the integrity of the objects being created and preventing potential runtime errors.","The vulnerability in the original code stemmed from using the initial URL as the name for the `PerformanceNavigationTiming` entry, which could lead to misleading performance metrics, especially in cases of redirects. This could result in incorrect tracking of the final destination URL, as the initial request URL would not accurately reflect the user's navigation experience. The fix involved changing the name assignment to use the final response URL instead, ensuring that the entry accurately represents the URL the user ultimately navigated to, thus providing more reliable performance data and addressing the issue highlighted in the bug report.","The vulnerability in the original code arose from using the initial request URL as the identifier for navigation timing entries, which could lead to inaccuracies in performance metrics, particularly in scenarios involving redirects. This approach failed to reflect the actual URL that users navigated to, potentially misrepresenting their experience. The fix addressed this issue by changing the identifier to the final response URL, ensuring that the navigation timing entry accurately represents the destination URL. This adjustment enhances the reliability of performance data, providing a clearer picture of user navigation and addressing the concerns raised in the associated bug report.","The vulnerability was fixed by modifying the constructor of the `PerformanceNavigationTiming` class to use the final response URL instead of the initial URL for the entry's name. Specifically, the change involved replacing `info->InitialURL().GetString()` with `info->FinalResponse().Url().GetString()`. This adjustment ensures that the name accurately reflects the URL the user ultimately navigated to, particularly in cases of redirects. By making this change, the code now provides more reliable performance metrics, thereby improving the accuracy of navigation timing data and addressing the issues highlighted in the bug report.","The vulnerability was fixed by changing the method used to determine the identifier for navigation timing entries. Instead of using the initial request URL, which could misrepresent the user's final destination, the code now retrieves the final response URL. This adjustment ensures that the identifier accurately reflects the URL the user actually navigated to, particularly in scenarios involving redirects. By implementing this change, the code enhances the reliability of performance metrics, providing a clearer and more accurate representation of user navigation experiences, thus addressing the concerns raised in the associated bug report.","4,5","5, 5","4,5","4,5"
110,110,187249,187249,,Remote,Not required,,CVE-2018-6137,https://www.cvedetails.com/cve/CVE-2018-6137/,CWE-200,Medium,Partial,,,2019-01-09,4.3,CSS Paint API in Blink in Google Chrome prior to 67.0.3396.62 allowed a remote attacker to leak cross-origin data via a crafted HTML page.,2019-01-14,+Info ,6,https://github.com/chromium/chromium/commit/67d9b414fa64448abc398ae9fc57c3ddf5de5998,67d9b414fa64448abc398ae9fc57c3ddf5de5998,"[PaintWorklet] Do not paint when paint target is associated with a link

When the target element of a paint worklet has an associated link, then
the 'paint' function will be invoked when the link's href is changed
from a visited URL to an unvisited URL (or vice versa).

This CL changes the behavior by detecting whether the target element
of a paint worklet has an associated link or not. If it does, then don't
paint.

TBR=haraken@chromium.org

Bug: 835589
Change-Id: I5fdf85685f863c960a6f48cc9a345dda787bece1
Reviewed-on: https://chromium-review.googlesource.com/1035524
Reviewed-by: Xida Chen <xidachen@chromium.org>
Reviewed-by: Ian Kilpatrick <ikilpatrick@chromium.org>
Reviewed-by: Stephen McGruer <smcgruer@chromium.org>
Commit-Queue: Xida Chen <xidachen@chromium.org>
Cr-Commit-Position: refs/heads/master@{#555788}",1,third_party/blink/renderer/core/css/css_paint_value.cc,"{""sha"": ""1aaa34c60ac96d285e6499bb85ffc2d7c8e4e9c7"", ""filename"": ""third_party/blink/renderer/controller/BUILD.gn"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/controller/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/controller/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/controller/BUILD.gn?ref=67d9b414fa64448abc398ae9fc57c3ddf5de5998"", ""patch"": ""@@ -61,6 +61,7 @@ group(\""webkit_unit_tests_data\"") {\n     \""../core/testing/data/\"",\n     \""../core/paint/test_data/\"",\n     \""../core/animation/test_data/\"",\n+    \""../core/css/test_data/\"",\n   ]\n }\n ""}<_**next**_>{""sha"": ""4a61cbf15ce9dde587277d90f30e84079e9b0af1"", ""filename"": ""third_party/blink/renderer/core/BUILD.gn"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/BUILD.gn?ref=67d9b414fa64448abc398ae9fc57c3ddf5de5998"", ""patch"": ""@@ -1644,6 +1644,7 @@ jumbo_source_set(\""unit_tests\"") {\n     \""css/css_font_face_source_test.cc\"",\n     \""css/css_gradient_value_test.cc\"",\n     \""css/css_page_rule_test.cc\"",\n+    \""css/css_paint_value_test.cc\"",\n     \""css/css_selector_test.cc\"",\n     \""css/css_selector_watch_test.cc\"",\n     \""css/css_style_declaration_test.cc\"",""}<_**next**_>{""sha"": ""dd2cef1941980d4a3fb123eada063f56d5542c23"", ""filename"": ""third_party/blink/renderer/core/css/css_custom_ident_value.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/css_custom_ident_value.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/css_custom_ident_value.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/css/css_custom_ident_value.h?ref=67d9b414fa64448abc398ae9fc57c3ddf5de5998"", ""patch"": ""@@ -11,7 +11,7 @@\n \n namespace blink {\n \n-class CSSCustomIdentValue : public CSSValue {\n+class CORE_EXPORT CSSCustomIdentValue : public CSSValue {\n  public:\n   static CSSCustomIdentValue* Create(const AtomicString& str) {\n     return new CSSCustomIdentValue(str);""}<_**next**_>{""sha"": ""78a4816e04ff2d48a1721a0db2b86eb04b9c0768"", ""filename"": ""third_party/blink/renderer/core/css/css_paint_value.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/css_paint_value.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/css_paint_value.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/css/css_paint_value.cc?ref=67d9b414fa64448abc398ae9fc57c3ddf5de5998"", ""patch"": ""@@ -46,8 +46,13 @@ String CSSPaintValue::GetName() const {\n scoped_refptr<Image> CSSPaintValue::GetImage(\n     const ImageResourceObserver& client,\n     const Document& document,\n-    const ComputedStyle&,\n+    const ComputedStyle& style,\n     const FloatSize& target_size) {\n+  // https://crbug.com/835589: early exit when paint target is associated with\n+  // a link.\n+  if (style.InsideLink() != EInsideLink::kNotInsideLink)\n+    return nullptr;\n+\n   if (!generator_) {\n     generator_ = CSSPaintImageGenerator::Create(\n         GetName(), document, paint_image_generator_observer_);""}<_**next**_>{""sha"": ""fc879596b9b4f2f389e75f6fbb520feaa84ebbbc"", ""filename"": ""third_party/blink/renderer/core/css/css_paint_value.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/css_paint_value.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/css_paint_value.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/css/css_paint_value.h?ref=67d9b414fa64448abc398ae9fc57c3ddf5de5998"", ""patch"": ""@@ -15,7 +15,7 @@\n \n namespace blink {\n \n-class CSSPaintValue : public CSSImageGeneratorValue {\n+class CORE_EXPORT CSSPaintValue : public CSSImageGeneratorValue {\n  public:\n   static CSSPaintValue* Create(CSSCustomIdentValue* name) {\n     return new CSSPaintValue(name);""}<_**next**_>{""sha"": ""923faeaf8234d61e44100388a1636c12ca548cf7"", ""filename"": ""third_party/blink/renderer/core/css/css_paint_value_test.cc"", ""status"": ""added"", ""additions"": 81, ""deletions"": 0, ""changes"": 81, ""blob_url"": ""https://github.com/chromium/chromium/blob/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/css_paint_value_test.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/css_paint_value_test.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/css/css_paint_value_test.cc?ref=67d9b414fa64448abc398ae9fc57c3ddf5de5998"", ""patch"": ""@@ -0,0 +1,81 @@\n+// Copyright 2018 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""third_party/blink/renderer/core/css/css_paint_value.h\""\n+\n+#include <memory>\n+#include \""testing/gtest/include/gtest/gtest.h\""\n+#include \""third_party/blink/renderer/core/css/css_custom_ident_value.h\""\n+#include \""third_party/blink/renderer/core/dom/document.h\""\n+#include \""third_party/blink/renderer/core/frame/frame_test_helpers.h\""\n+#include \""third_party/blink/renderer/core/frame/web_local_frame_impl.h\""\n+#include \""third_party/blink/renderer/core/layout/layout_object.h\""\n+#include \""third_party/blink/renderer/core/style/computed_style.h\""\n+#include \""third_party/blink/renderer/core/testing/core_unit_test_helper.h\""\n+#include \""third_party/blink/renderer/platform/testing/unit_test_helpers.h\""\n+#include \""third_party/blink/renderer/platform/testing/url_test_helpers.h\""\n+\n+namespace blink {\n+\n+class CSSPaintValueTest : public RenderingTest {\n+ public:\n+  void LoadTestData(const std::string& file_name) {\n+    String testing_path = test::BlinkRootDir();\n+    testing_path.append(\""/renderer/core/css/test_data/\"");\n+    WebURL url = URLTestHelpers::RegisterMockedURLLoadFromBase(\n+        WebString::FromUTF8(base_url_), testing_path,\n+        WebString::FromUTF8(file_name));\n+    FrameTestHelpers::LoadFrame(helper_.GetWebView()->MainFrameImpl(),\n+                                base_url_ + file_name);\n+    ForceFullCompositingUpdate();\n+    URLTestHelpers::RegisterMockedURLUnregister(url);\n+  }\n+\n+  void ForceFullCompositingUpdate() {\n+    helper_.GetWebView()->UpdateAllLifecyclePhases();\n+  }\n+\n+  LocalFrame* GetFrame() const { return helper_.LocalMainFrame()->GetFrame(); }\n+\n+ private:\n+  void SetUp() override {\n+    RenderingTest::SetUp();\n+    EnableCompositing();\n+    helper_.Initialize(nullptr, nullptr, nullptr);\n+    base_url_ = \""https://www.test.com/\"";\n+  }\n+  FrameTestHelpers::WebViewHelper helper_;\n+  std::string base_url_;\n+};\n+\n+void CheckTargetObject(Document* document) {\n+  LayoutObject* target_layout_object =\n+      document->getElementById(\""target\"")->GetLayoutObject();\n+  EXPECT_NE(target_layout_object, nullptr);\n+  EXPECT_NE(target_layout_object->Style()->InsideLink(),\n+            EInsideLink::kNotInsideLink);\n+\n+  CSSPaintValue* css_paint_value =\n+      CSSPaintValue::Create(CSSCustomIdentValue::Create(\""linkpainter\""));\n+  EXPECT_EQ(css_paint_value->GetImage(*target_layout_object, *document,\n+                                      target_layout_object->StyleRef(),\n+                                      FloatSize(100.0f, 100.0f)),\n+            nullptr);\n+}\n+\n+// Regression test for https://crbug.com/835589.\n+TEST_F(CSSPaintValueTest, CSSPaintDoNotPaintForLink) {\n+  LoadTestData(\""csspaint-do-not-paint-for-link.html\"");\n+  Document* document = GetFrame()->GetDocument();\n+  CheckTargetObject(document);\n+}\n+\n+// Regression test for https://crbug.com/835589.\n+TEST_F(CSSPaintValueTest, CSSPaintDoNotPaintWhenParentHasLink) {\n+  LoadTestData(\""csspaint-do-not-paint-for-link-descendant.html\"");\n+  Document* document = GetFrame()->GetDocument();\n+  CheckTargetObject(document);\n+}\n+\n+}  // namespace blink""}<_**next**_>{""sha"": ""958ea8f4638e44921cd610c92504606b661c78d0"", ""filename"": ""third_party/blink/renderer/core/css/test_data/csspaint-do-not-paint-for-link-descendant.html"", ""status"": ""added"", ""additions"": 39, ""deletions"": 0, ""changes"": 39, ""blob_url"": ""https://github.com/chromium/chromium/blob/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/test_data/csspaint-do-not-paint-for-link-descendant.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/test_data/csspaint-do-not-paint-for-link-descendant.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/css/test_data/csspaint-do-not-paint-for-link-descendant.html?ref=67d9b414fa64448abc398ae9fc57c3ddf5de5998"", ""patch"": ""@@ -0,0 +1,39 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+<style>\n+a {\n+  width: 200px;\n+  height: 200px;\n+}\n+b {\n+  background-image: paint(linkpainter);\n+  width: 100px;\n+  height: 100px;\n+}\n+</style>\n+</head>\n+<body>\n+  <a id=\""ancestor\"">\n+    <b id=\""target\""></b>\n+  </a>\n+<script>\n+function addPaintletFromSource (src) {\n+  var uri = 'data:application/javascript;charset=utf-8;base64,' + btoa(src);\n+  CSS.paintWorklet.addModule(uri).then();\n+}\n+\n+addPaintletFromSource(`\n+  class LinkPainter {\n+    paint(ctx, geom) {\n+      ctx.fillStyle = 'black';\n+      ctx.fillRect(0, 0, geom.width, geom.height);\n+    }\n+  }\n+  registerPaint('linkpainter', LinkPainter);\n+`);\n+\n+ancestor.href = 'https://cs.chromium.org';\n+</script>\n+</body>\n+</html>""}<_**next**_>{""sha"": ""1d78b530ef889768c3cd7b24e92a337f7ab8e201"", ""filename"": ""third_party/blink/renderer/core/css/test_data/csspaint-do-not-paint-for-link.html"", ""status"": ""added"", ""additions"": 33, ""deletions"": 0, ""changes"": 33, ""blob_url"": ""https://github.com/chromium/chromium/blob/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/test_data/csspaint-do-not-paint-for-link.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/test_data/csspaint-do-not-paint-for-link.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/css/test_data/csspaint-do-not-paint-for-link.html?ref=67d9b414fa64448abc398ae9fc57c3ddf5de5998"", ""patch"": ""@@ -0,0 +1,33 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+<style>\n+a {\n+  background-image: paint(linkpainter);\n+  width: 100px;\n+  height: 100px;\n+}\n+</style>\n+</head>\n+<body>\n+  <a id=\""target\""></a>\n+<script>\n+function addPaintletFromSource (src) {\n+  var uri = 'data:application/javascript;charset=utf-8;base64,' + btoa(src);\n+  CSS.paintWorklet.addModule(uri).then();\n+}\n+\n+addPaintletFromSource(`\n+  class LinkPainter {\n+    paint(ctx, geom) {\n+      ctx.fillStyle = 'black';\n+      ctx.fillRect(0, 0, geom.width, geom.height);\n+    }\n+  }\n+  registerPaint('linkpainter', LinkPainter);\n+`);\n+\n+target.href = 'https://cs.chromium.org';\n+</script>\n+</body>\n+</html>""}<_**next**_>{""sha"": ""58e8e7882d8298630391836adafd8e248c3435b1"", ""filename"": ""third_party/blink/renderer/core/style/computed_style.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/style/computed_style.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/style/computed_style.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/style/computed_style.cc?ref=67d9b414fa64448abc398ae9fc57c3ddf5de5998"", ""patch"": ""@@ -721,6 +721,11 @@ bool ComputedStyle::DiffNeedsPaintInvalidationObject(\n bool ComputedStyle::DiffNeedsPaintInvalidationObjectForPaintImage(\n     const StyleImage& image,\n     const ComputedStyle& other) const {\n+  // https://crbug.com/835589: early exit when paint target is associated with\n+  // a link.\n+  if (InsideLink() != EInsideLink::kNotInsideLink)\n+    return false;\n+\n   CSSPaintValue* value = ToCSSPaintValue(image.CssValue());\n \n   // NOTE: If the invalidation properties vectors are null, we are invalid as""}"," scoped_refptr<Image> CSSPaintValue::GetImage(
     const ImageResourceObserver& client,
     const Document& document,
    const ComputedStyle& style,
     const FloatSize& target_size) {
  // https://crbug.com/835589: early exit when paint target is associated with
  // a link.
  if (style.InsideLink() != EInsideLink::kNotInsideLink)
    return nullptr;

   if (!generator_) {
     generator_ = CSSPaintImageGenerator::Create(
         GetName(), document, paint_image_generator_observer_);
  }

  if (!ParseInputArguments(document))
    return nullptr;

  return generator_->Paint(client, RoundedIntSize(target_size),
                           parsed_input_arguments_);
}
"," scoped_refptr<Image> CSSPaintValue::GetImage(
     const ImageResourceObserver& client,
     const Document& document,
    const ComputedStyle&,
     const FloatSize& target_size) {
   if (!generator_) {
     generator_ = CSSPaintImageGenerator::Create(
         GetName(), document, paint_image_generator_observer_);
  }

  if (!ParseInputArguments(document))
    return nullptr;

  return generator_->Paint(client, RoundedIntSize(target_size),
                           parsed_input_arguments_);
}
",C,"    const ComputedStyle& style,
  // https://crbug.com/835589: early exit when paint target is associated with
  // a link.
  if (style.InsideLink() != EInsideLink::kNotInsideLink)
    return nullptr;

","    const ComputedStyle&,
",,"@@ -46,8 +46,13 @@ String CSSPaintValue::GetName() const {
 scoped_refptr<Image> CSSPaintValue::GetImage(
     const ImageResourceObserver& client,
     const Document& document,
-    const ComputedStyle&,
+    const ComputedStyle& style,
     const FloatSize& target_size) {
+  // https://crbug.com/835589: early exit when paint target is associated with
+  // a link.
+  if (style.InsideLink() != EInsideLink::kNotInsideLink)
+    return nullptr;
+
   if (!generator_) {
     generator_ = CSSPaintImageGenerator::Create(
         GetName(), document, paint_image_generator_observer_);",Chrome,67d9b414fa64448abc398ae9fc57c3ddf5de5998,ad500fba0e02a219c6b8d7714a2bb56856234a3d,1," scoped_refptr<Image> CSSPaintValue::GetImage(
     const ImageResourceObserver& client,
     const Document& document,
//flaw_line_below:
    const ComputedStyle&,
//fix_flaw_line_below:
//    const ComputedStyle& style,
     const FloatSize& target_size) {
//fix_flaw_line_below:
//  // https://crbug.com/835589: early exit when paint target is associated with
//fix_flaw_line_below:
//  // a link.
//fix_flaw_line_below:
//  if (style.InsideLink() != EInsideLink::kNotInsideLink)
//fix_flaw_line_below:
//    return nullptr;
//fix_flaw_line_below:
//
   if (!generator_) {
     generator_ = CSSPaintImageGenerator::Create(
         GetName(), document, paint_image_generator_observer_);
  }

  if (!ParseInputArguments(document))
    return nullptr;

  return generator_->Paint(client, RoundedIntSize(target_size),
                           parsed_input_arguments_);
}
",187249," scoped_refptr<Image> CSSPaintValue::GetImage(
     const ImageResourceObserver& client,
     const Document& document,
    const ComputedStyle&,
     const FloatSize& target_size) {
   if (!generator_) {
     generator_ = CSSPaintImageGenerator::Create(
         GetName(), document, paint_image_generator_observer_);
  }

  if (!ParseInputArguments(document))
    return nullptr;

  return generator_->Paint(client, RoundedIntSize(target_size),
                           parsed_input_arguments_);
}
"," scoped_refptr<Image> CSSPaintValue::GetImage(
     const ImageResourceObserver& client,
     const Document& document,
    const ComputedStyle& style,
     const FloatSize& target_size) {
  // https://crbug.com/835589: early exit when paint target is associated with
  // a link.
  if (style.InsideLink() != EInsideLink::kNotInsideLink)
    return nullptr;

   if (!generator_) {
     generator_ = CSSPaintImageGenerator::Create(
         GetName(), document, paint_image_generator_observer_);
  }

  if (!ParseInputArguments(document))
    return nullptr;

  return generator_->Paint(client, RoundedIntSize(target_size),
                           parsed_input_arguments_);
}
","The provided code defines a method `GetImage` within the `CSSPaintValue` class, which retrieves an image based on specified parameters. It first checks if an image generator (`generator_`) exists; if not, it creates one using the `CSSPaintImageGenerator::Create` method, passing the name, document, and an observer. The method then validates the input arguments using `ParseInputArguments`, returning `nullptr` if they are invalid. Finally, if the arguments are valid, it calls the `Paint` method on the generator, passing the client, a rounded size of the target dimensions, and the parsed input arguments to generate and return the image.","The code defines a method that generates an image based on specific parameters. It first checks for the existence of an image generator and creates one if it is not already present, using relevant contextual information. The method then validates the input arguments, returning a null value if they are deemed invalid. If the arguments are valid, it proceeds to invoke a painting function on the generator, supplying the necessary client information, adjusted dimensions, and the validated arguments to produce and return the desired image. This process ensures that the image generation is contingent on valid inputs and the presence of a generator.","The vulnerability in the original code arises from the potential for the paint function to be invoked when the target element is associated with a link, leading to unintended behavior when the link's state changes (e.g., from visited to unvisited). This could result in incorrect rendering or performance issues. The fixed code addresses this vulnerability by introducing an early exit condition that checks if the target is inside a link. If it is, the function returns `nullptr`, preventing the painting process from occurring and thereby ensuring that the paint function does not execute under these circumstances.","The vulnerability in the original code stems from the fact that the painting function could be triggered when the target element is linked, leading to unintended rendering changes whenever the link's state transitions between visited and unvisited. This could disrupt the visual consistency and performance of the application. The fix implemented in the updated code introduces a check to determine if the target element is associated with a link. If it is, the painting process is aborted early, effectively preventing any painting actions from occurring in such scenarios and ensuring stable rendering behavior.","The vulnerability was fixed by adding an early exit condition that checks if the target element is inside a link using the `style.InsideLink()` function. If this check returns a value indicating that the element is associated with a link, the method immediately returns `nullptr`, preventing the painting process from proceeding. This change ensures that the `Paint` function is not invoked when the target is linked, thereby avoiding unintended rendering issues that could arise from changes in the link's state, such as transitioning between visited and unvisited URLs.","The vulnerability was addressed by implementing a check that determines whether the target element is associated with a link. If the element is found to be linked, the method exits early without proceeding to the painting process. This modification effectively prevents the painting function from being called in scenarios where the link's state could change, which previously led to unintended rendering behavior. By ensuring that painting does not occur for linked elements, the fix enhances the stability and visual consistency of the application, mitigating the risk of performance issues related to state transitions.","4,4","4, 4","3, 4","4,4"
111,111,187400,187400,,Remote,Not required,,CVE-2016-6722,https://www.cvedetails.com/cve/CVE-2016-6722/,CWE-200,Medium,Partial,,,2016-12-13,4.3,"An information disclosure vulnerability in libstagefright in Mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-11-01, and 7.0 before 2016-11-01 could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Android ID: A-31091777.",2016-12-14,+Info ,4,https://android.googlesource.com/platform/frameworks/av/+/89c03b3b9ff74a507a8b8334c50b08b334483556,89c03b3b9ff74a507a8b8334c50b08b334483556,"SampleIterator: clear members on seekTo error

Bug: 31091777
Change-Id: Iddf99d0011961d0fd3d755e57db4365b6a6a1193
(cherry picked from commit 03237ce0f9584c98ccda76c2474a4ae84c763f5b)
",2,media/libstagefright/SampleIterator.cpp,"{""filename"": ""media/libstagefright/SampleIterator.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/89c03b3b9ff74a507a8b8334c50b08b334483556/media/libstagefright/SampleIterator.cpp"", ""patch"": ""@@ -94,8 +94,6 @@\n\n         + mFirstChunk;\n \n     if (!mInitialized || chunk != mCurrentChunkIndex) {\n-        mCurrentChunkIndex = chunk;\n-\n         status_t err;\n         if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {\n             ALOGE(\""getChunkOffset return error\"");\n@@ -106,18 +104,21 @@\n\n \n         uint32_t firstChunkSampleIndex =\n             mFirstChunkSampleIndex\n-                + mSamplesPerChunk * (mCurrentChunkIndex - mFirstChunk);\n+                + mSamplesPerChunk * (chunk - mFirstChunk);\n \n         for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {\n             size_t sampleSize;\n             if ((err = getSampleSizeDirect(\n                             firstChunkSampleIndex + i, &sampleSize)) != OK) {\n                 ALOGE(\""getSampleSizeDirect return error\"");\n+                mCurrentChunkSampleSizes.clear();\n                 return err;\n             }\n \n             mCurrentChunkSampleSizes.push(sampleSize);\n         }\n+\n+        mCurrentChunkIndex = chunk;\n     }\n \n     uint32_t chunkRelativeSampleIndex =\n""}","status_t SampleIterator::seekTo(uint32_t sampleIndex) {
    ALOGV(""seekTo(%d)"", sampleIndex);

 if (sampleIndex >= mTable->mNumSampleSizes) {
 return ERROR_END_OF_STREAM;
 }

 if (mTable->mSampleToChunkOffset < 0
 || mTable->mChunkOffsetOffset < 0
 || mTable->mSampleSizeOffset < 0
 || mTable->mTimeToSampleCount == 0) {

 return ERROR_MALFORMED;
 }

 if (mInitialized && mCurrentSampleIndex == sampleIndex) {
 return OK;
 }

 if (!mInitialized || sampleIndex < mFirstChunkSampleIndex) {
        reset();
 }

 if (sampleIndex >= mStopChunkSampleIndex) {
 status_t err;
 if ((err = findChunkRange(sampleIndex)) != OK) {
            ALOGE(""findChunkRange failed"");
 return err;
 }
 }

    CHECK(sampleIndex < mStopChunkSampleIndex);

 if (mSamplesPerChunk == 0) {
        ALOGE(""b/22802344"");
 return ERROR_MALFORMED;
 }

 uint32_t chunk =
 (sampleIndex - mFirstChunkSampleIndex) / mSamplesPerChunk

         + mFirstChunk;
 
     if (!mInitialized || chunk != mCurrentChunkIndex) {
         status_t err;
         if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {
             ALOGE(""getChunkOffset return error"");
 return err;
 }

        mCurrentChunkSampleSizes.clear();

 
         uint32_t firstChunkSampleIndex =
             mFirstChunkSampleIndex
                + mSamplesPerChunk * (chunk - mFirstChunk);
 
         for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {
             size_t sampleSize;
             if ((err = getSampleSizeDirect(
                             firstChunkSampleIndex + i, &sampleSize)) != OK) {
                 ALOGE(""getSampleSizeDirect return error"");
                mCurrentChunkSampleSizes.clear();
                 return err;
             }
 
             mCurrentChunkSampleSizes.push(sampleSize);
         }

        mCurrentChunkIndex = chunk;
     }
 
     uint32_t chunkRelativeSampleIndex =
 (sampleIndex - mFirstChunkSampleIndex) % mSamplesPerChunk;

    mCurrentSampleOffset = mCurrentChunkOffset;
 for (uint32_t i = 0; i < chunkRelativeSampleIndex; ++i) {
        mCurrentSampleOffset += mCurrentChunkSampleSizes[i];
 }

    mCurrentSampleSize = mCurrentChunkSampleSizes[chunkRelativeSampleIndex];
 if (sampleIndex < mTTSSampleIndex) {
        mTimeToSampleIndex = 0;
        mTTSSampleIndex = 0;
        mTTSSampleTime = 0;
        mTTSCount = 0;
        mTTSDuration = 0;
 }

 status_t err;
 if ((err = findSampleTimeAndDuration(
            sampleIndex, &mCurrentSampleTime, &mCurrentSampleDuration)) != OK) {
        ALOGE(""findSampleTime return error"");
 return err;
 }

    mCurrentSampleIndex = sampleIndex;

    mInitialized = true;

 return OK;
}
","status_t SampleIterator::seekTo(uint32_t sampleIndex) {
    ALOGV(""seekTo(%d)"", sampleIndex);

 if (sampleIndex >= mTable->mNumSampleSizes) {
 return ERROR_END_OF_STREAM;
 }

 if (mTable->mSampleToChunkOffset < 0
 || mTable->mChunkOffsetOffset < 0
 || mTable->mSampleSizeOffset < 0
 || mTable->mTimeToSampleCount == 0) {

 return ERROR_MALFORMED;
 }

 if (mInitialized && mCurrentSampleIndex == sampleIndex) {
 return OK;
 }

 if (!mInitialized || sampleIndex < mFirstChunkSampleIndex) {
        reset();
 }

 if (sampleIndex >= mStopChunkSampleIndex) {
 status_t err;
 if ((err = findChunkRange(sampleIndex)) != OK) {
            ALOGE(""findChunkRange failed"");
 return err;
 }
 }

    CHECK(sampleIndex < mStopChunkSampleIndex);

 if (mSamplesPerChunk == 0) {
        ALOGE(""b/22802344"");
 return ERROR_MALFORMED;
 }

 uint32_t chunk =
 (sampleIndex - mFirstChunkSampleIndex) / mSamplesPerChunk

         + mFirstChunk;
 
     if (!mInitialized || chunk != mCurrentChunkIndex) {
        mCurrentChunkIndex = chunk;
         status_t err;
         if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {
             ALOGE(""getChunkOffset return error"");
 return err;
 }

        mCurrentChunkSampleSizes.clear();

 
         uint32_t firstChunkSampleIndex =
             mFirstChunkSampleIndex
                + mSamplesPerChunk * (mCurrentChunkIndex - mFirstChunk);
 
         for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {
             size_t sampleSize;
             if ((err = getSampleSizeDirect(
                             firstChunkSampleIndex + i, &sampleSize)) != OK) {
                 ALOGE(""getSampleSizeDirect return error"");
                 return err;
             }
 
             mCurrentChunkSampleSizes.push(sampleSize);
         }
     }
 
     uint32_t chunkRelativeSampleIndex =
 (sampleIndex - mFirstChunkSampleIndex) % mSamplesPerChunk;

    mCurrentSampleOffset = mCurrentChunkOffset;
 for (uint32_t i = 0; i < chunkRelativeSampleIndex; ++i) {
        mCurrentSampleOffset += mCurrentChunkSampleSizes[i];
 }

    mCurrentSampleSize = mCurrentChunkSampleSizes[chunkRelativeSampleIndex];
 if (sampleIndex < mTTSSampleIndex) {
        mTimeToSampleIndex = 0;
        mTTSSampleIndex = 0;
        mTTSSampleTime = 0;
        mTTSCount = 0;
        mTTSDuration = 0;
 }

 status_t err;
 if ((err = findSampleTimeAndDuration(
            sampleIndex, &mCurrentSampleTime, &mCurrentSampleDuration)) != OK) {
        ALOGE(""findSampleTime return error"");
 return err;
 }

    mCurrentSampleIndex = sampleIndex;

    mInitialized = true;

 return OK;
}
",C,"                + mSamplesPerChunk * (chunk - mFirstChunk);
                mCurrentChunkSampleSizes.clear();

        mCurrentChunkIndex = chunk;
","        mCurrentChunkIndex = chunk;
                + mSamplesPerChunk * (mCurrentChunkIndex - mFirstChunk);
",,"@@ -94,8 +94,6 @@

         + mFirstChunk;
 
     if (!mInitialized || chunk != mCurrentChunkIndex) {
-        mCurrentChunkIndex = chunk;
-
         status_t err;
         if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {
             ALOGE(""getChunkOffset return error"");
@@ -106,18 +104,21 @@

 
         uint32_t firstChunkSampleIndex =
             mFirstChunkSampleIndex
-                + mSamplesPerChunk * (mCurrentChunkIndex - mFirstChunk);
+                + mSamplesPerChunk * (chunk - mFirstChunk);
 
         for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {
             size_t sampleSize;
             if ((err = getSampleSizeDirect(
                             firstChunkSampleIndex + i, &sampleSize)) != OK) {
                 ALOGE(""getSampleSizeDirect return error"");
+                mCurrentChunkSampleSizes.clear();
                 return err;
             }
 
             mCurrentChunkSampleSizes.push(sampleSize);
         }
+
+        mCurrentChunkIndex = chunk;
     }
 
     uint32_t chunkRelativeSampleIndex =
",Android,https://android.googlesource.com/platform/frameworks/av/+/89c03b3b9ff74a507a8b8334c50b08b334483556/,https://android.googlesource.com/platform/frameworks/av/+/89c03b3b9ff74a507a8b8334c50b08b334483556%5E/,1,"status_t SampleIterator::seekTo(uint32_t sampleIndex) {
    ALOGV(""seekTo(%d)"", sampleIndex);

 if (sampleIndex >= mTable->mNumSampleSizes) {
 return ERROR_END_OF_STREAM;
 }

 if (mTable->mSampleToChunkOffset < 0
 || mTable->mChunkOffsetOffset < 0
 || mTable->mSampleSizeOffset < 0
 || mTable->mTimeToSampleCount == 0) {

 return ERROR_MALFORMED;
 }

 if (mInitialized && mCurrentSampleIndex == sampleIndex) {
 return OK;
 }

 if (!mInitialized || sampleIndex < mFirstChunkSampleIndex) {
        reset();
 }

 if (sampleIndex >= mStopChunkSampleIndex) {
 status_t err;
 if ((err = findChunkRange(sampleIndex)) != OK) {
            ALOGE(""findChunkRange failed"");
 return err;
 }
 }

    CHECK(sampleIndex < mStopChunkSampleIndex);

 if (mSamplesPerChunk == 0) {
        ALOGE(""b/22802344"");
 return ERROR_MALFORMED;
 }

 uint32_t chunk =
 (sampleIndex - mFirstChunkSampleIndex) / mSamplesPerChunk

         + mFirstChunk;
 
     if (!mInitialized || chunk != mCurrentChunkIndex) {
//flaw_line_below:
        mCurrentChunkIndex = chunk;
//flaw_line_below:

         status_t err;
         if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {
             ALOGE(""getChunkOffset return error"");
 return err;
 }

        mCurrentChunkSampleSizes.clear();

 
         uint32_t firstChunkSampleIndex =
             mFirstChunkSampleIndex
//flaw_line_below:
                + mSamplesPerChunk * (mCurrentChunkIndex - mFirstChunk);
//fix_flaw_line_below:
//                + mSamplesPerChunk * (chunk - mFirstChunk);
 
         for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {
             size_t sampleSize;
             if ((err = getSampleSizeDirect(
                             firstChunkSampleIndex + i, &sampleSize)) != OK) {
                 ALOGE(""getSampleSizeDirect return error"");
//fix_flaw_line_below:
//                mCurrentChunkSampleSizes.clear();
                 return err;
             }
 
             mCurrentChunkSampleSizes.push(sampleSize);
         }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        mCurrentChunkIndex = chunk;
     }
 
     uint32_t chunkRelativeSampleIndex =
 (sampleIndex - mFirstChunkSampleIndex) % mSamplesPerChunk;

    mCurrentSampleOffset = mCurrentChunkOffset;
 for (uint32_t i = 0; i < chunkRelativeSampleIndex; ++i) {
        mCurrentSampleOffset += mCurrentChunkSampleSizes[i];
 }

    mCurrentSampleSize = mCurrentChunkSampleSizes[chunkRelativeSampleIndex];
 if (sampleIndex < mTTSSampleIndex) {
        mTimeToSampleIndex = 0;
        mTTSSampleIndex = 0;
        mTTSSampleTime = 0;
        mTTSCount = 0;
        mTTSDuration = 0;
 }

 status_t err;
 if ((err = findSampleTimeAndDuration(
            sampleIndex, &mCurrentSampleTime, &mCurrentSampleDuration)) != OK) {
        ALOGE(""findSampleTime return error"");
 return err;
 }

    mCurrentSampleIndex = sampleIndex;

    mInitialized = true;

 return OK;
}
",187400,"status_t SampleIterator::seekTo(uint32_t sampleIndex) {
    ALOGV(""seekTo(%d)"", sampleIndex);

 if (sampleIndex >= mTable->mNumSampleSizes) {
 return ERROR_END_OF_STREAM;
 }

 if (mTable->mSampleToChunkOffset < 0
 || mTable->mChunkOffsetOffset < 0
 || mTable->mSampleSizeOffset < 0
 || mTable->mTimeToSampleCount == 0) {

 return ERROR_MALFORMED;
 }

 if (mInitialized && mCurrentSampleIndex == sampleIndex) {
 return OK;
 }

 if (!mInitialized || sampleIndex < mFirstChunkSampleIndex) {
        reset();
 }

 if (sampleIndex >= mStopChunkSampleIndex) {
 status_t err;
 if ((err = findChunkRange(sampleIndex)) != OK) {
            ALOGE(""findChunkRange failed"");
 return err;
 }
 }

    CHECK(sampleIndex < mStopChunkSampleIndex);

 if (mSamplesPerChunk == 0) {
        ALOGE(""b/22802344"");
 return ERROR_MALFORMED;
 }

 uint32_t chunk =
 (sampleIndex - mFirstChunkSampleIndex) / mSamplesPerChunk

         + mFirstChunk;
 
     if (!mInitialized || chunk != mCurrentChunkIndex) {
        mCurrentChunkIndex = chunk;
         status_t err;
         if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {
             ALOGE(""getChunkOffset return error"");
 return err;
 }

        mCurrentChunkSampleSizes.clear();

 
         uint32_t firstChunkSampleIndex =
             mFirstChunkSampleIndex
                + mSamplesPerChunk * (mCurrentChunkIndex - mFirstChunk);
 
         for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {
             size_t sampleSize;
             if ((err = getSampleSizeDirect(
                             firstChunkSampleIndex + i, &sampleSize)) != OK) {
                 ALOGE(""getSampleSizeDirect return error"");
                 return err;
             }
 
             mCurrentChunkSampleSizes.push(sampleSize);
         }
     }
 
     uint32_t chunkRelativeSampleIndex =
 (sampleIndex - mFirstChunkSampleIndex) % mSamplesPerChunk;

    mCurrentSampleOffset = mCurrentChunkOffset;
 for (uint32_t i = 0; i < chunkRelativeSampleIndex; ++i) {
        mCurrentSampleOffset += mCurrentChunkSampleSizes[i];
 }

    mCurrentSampleSize = mCurrentChunkSampleSizes[chunkRelativeSampleIndex];
 if (sampleIndex < mTTSSampleIndex) {
        mTimeToSampleIndex = 0;
        mTTSSampleIndex = 0;
        mTTSSampleTime = 0;
        mTTSCount = 0;
        mTTSDuration = 0;
 }

 status_t err;
 if ((err = findSampleTimeAndDuration(
            sampleIndex, &mCurrentSampleTime, &mCurrentSampleDuration)) != OK) {
        ALOGE(""findSampleTime return error"");
 return err;
 }

    mCurrentSampleIndex = sampleIndex;

    mInitialized = true;

 return OK;
}
","status_t SampleIterator::seekTo(uint32_t sampleIndex) {
    ALOGV(""seekTo(%d)"", sampleIndex);

 if (sampleIndex >= mTable->mNumSampleSizes) {
 return ERROR_END_OF_STREAM;
 }

 if (mTable->mSampleToChunkOffset < 0
 || mTable->mChunkOffsetOffset < 0
 || mTable->mSampleSizeOffset < 0
 || mTable->mTimeToSampleCount == 0) {

 return ERROR_MALFORMED;
 }

 if (mInitialized && mCurrentSampleIndex == sampleIndex) {
 return OK;
 }

 if (!mInitialized || sampleIndex < mFirstChunkSampleIndex) {
        reset();
 }

 if (sampleIndex >= mStopChunkSampleIndex) {
 status_t err;
 if ((err = findChunkRange(sampleIndex)) != OK) {
            ALOGE(""findChunkRange failed"");
 return err;
 }
 }

    CHECK(sampleIndex < mStopChunkSampleIndex);

 if (mSamplesPerChunk == 0) {
        ALOGE(""b/22802344"");
 return ERROR_MALFORMED;
 }

 uint32_t chunk =
 (sampleIndex - mFirstChunkSampleIndex) / mSamplesPerChunk

         + mFirstChunk;
 
     if (!mInitialized || chunk != mCurrentChunkIndex) {
         status_t err;
         if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {
             ALOGE(""getChunkOffset return error"");
 return err;
 }

        mCurrentChunkSampleSizes.clear();

 
         uint32_t firstChunkSampleIndex =
             mFirstChunkSampleIndex
                + mSamplesPerChunk * (chunk - mFirstChunk);
 
         for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {
             size_t sampleSize;
             if ((err = getSampleSizeDirect(
                             firstChunkSampleIndex + i, &sampleSize)) != OK) {
                 ALOGE(""getSampleSizeDirect return error"");
                mCurrentChunkSampleSizes.clear();
                 return err;
             }
 
             mCurrentChunkSampleSizes.push(sampleSize);
         }

        mCurrentChunkIndex = chunk;
     }
 
     uint32_t chunkRelativeSampleIndex =
 (sampleIndex - mFirstChunkSampleIndex) % mSamplesPerChunk;

    mCurrentSampleOffset = mCurrentChunkOffset;
 for (uint32_t i = 0; i < chunkRelativeSampleIndex; ++i) {
        mCurrentSampleOffset += mCurrentChunkSampleSizes[i];
 }

    mCurrentSampleSize = mCurrentChunkSampleSizes[chunkRelativeSampleIndex];
 if (sampleIndex < mTTSSampleIndex) {
        mTimeToSampleIndex = 0;
        mTTSSampleIndex = 0;
        mTTSSampleTime = 0;
        mTTSCount = 0;
        mTTSDuration = 0;
 }

 status_t err;
 if ((err = findSampleTimeAndDuration(
            sampleIndex, &mCurrentSampleTime, &mCurrentSampleDuration)) != OK) {
        ALOGE(""findSampleTime return error"");
 return err;
 }

    mCurrentSampleIndex = sampleIndex;

    mInitialized = true;

 return OK;
}
","The `seekTo` function in the `SampleIterator` class is designed to reposition the iterator to a specified sample index within a media stream. It first checks if the provided index is valid and if the necessary data structures are properly initialized. If the index is valid, it determines the corresponding chunk and retrieves the sample sizes for that chunk. The function then calculates the offset for the current sample and retrieves its time and duration. If any errors occur during these operations, appropriate error codes are returned. Finally, it updates the current sample index and marks the iterator as initialized, returning a success status.","The provided code defines a method that allows an iterator to seek to a specific sample within a media stream. It begins by validating the requested sample index and checking the integrity of necessary data structures. If the index is valid, the method identifies the corresponding chunk and retrieves the sizes of samples within that chunk. It then calculates the offset for the desired sample and retrieves its associated time and duration. Throughout the process, the method handles potential errors and updates the iterator's state, ultimately returning a status indicating success or failure of the operation.","The vulnerability in the original code arises from the lack of proper handling of member variables when an error occurs during the seeking process. Specifically, if an error is encountered while retrieving sample sizes or chunk offsets, the code does not clear the `mCurrentChunkSampleSizes`, potentially leading to the use of stale or invalid data in subsequent operations. The fix addresses this by ensuring that `mCurrentChunkSampleSizes` is cleared whenever an error occurs during the sample size retrieval, thus preventing the iterator from operating on corrupted or outdated data and enhancing the overall robustness of the seeking functionality.","The vulnerability in the original code stems from inadequate error handling during the seeking process, which could lead to the use of stale or invalid data if an error occurs while retrieving necessary information. Specifically, when an error arises, the code fails to clear certain member variables, allowing potentially corrupted data to persist. The fix addresses this issue by ensuring that these member variables are cleared whenever an error is encountered, thereby preventing the iterator from operating on outdated or incorrect data and enhancing the overall reliability and stability of the seeking functionality.","The vulnerability was fixed by adding a line to clear the `mCurrentChunkSampleSizes` member variable whenever an error occurs during the retrieval of sample sizes. Specifically, in the error handling section of the code, after the call to retrieve sample sizes, the code now includes a statement to clear this variable if an error is returned from the sample size retrieval function. This ensures that any stale or invalid data is removed, preventing the iterator from using potentially corrupted information in subsequent operations, thus enhancing the overall robustness of the seeking functionality.","The vulnerability was fixed by implementing a mechanism to clear specific member variables whenever an error occurs during the seeking process. This change ensures that if an error arises while retrieving necessary data, any potentially stale or invalid information is removed, preventing the iterator from operating on corrupted data. By explicitly resetting these member variables in the error handling sections, the code enhances its reliability and stability, ensuring that subsequent operations are based on valid and current data, thereby mitigating the risk of unexpected behavior or crashes.","4,5","5,5","4,4","4,4"
112,112,187409,187409,,Remote,Not required,,CVE-2016-3924,https://www.cvedetails.com/cve/CVE-2016-3924/,CWE-200,Medium,Partial,,,2016-10-10,4.3,"services/audioflinger/Effects.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 does not validate EFFECT_CMD_SET_PARAM and EFFECT_CMD_SET_PARAM_DEFERRED commands, which allows attackers to obtain sensitive information via a crafted application, aka internal bug 30204301.",2016-11-28,+Info ,16,https://android.googlesource.com/platform/frameworks/av/+/c894aa36be535886a8e5ff02cdbcd07dd24618f6,c894aa36be535886a8e5ff02cdbcd07dd24618f6,"Add EFFECT_CMD_SET_PARAM parameter checking

Bug: 30204301
Change-Id: Ib9c3ee1c2f23c96f8f7092dd9e146bc453d7a290
(cherry picked from commit e4a1d91501d47931dbae19c47815952378787ab6)
",0,services/audioflinger/Effects.cpp,"{""filename"": ""services/audioflinger/Effects.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c894aa36be535886a8e5ff02cdbcd07dd24618f6/services/audioflinger/Effects.cpp"", ""patch"": ""@@ -543,6 +543,13 @@\n\n     return NO_ERROR;\n }\n \n+// round up delta valid if value and divisor are positive.\n+template <typename T>\n+static T roundUpDelta(const T &value, const T &divisor) {\n+    T remainder = value % divisor;\n+    return remainder == 0 ? 0 : divisor - remainder;\n+}\n+\n status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,\n                                              uint32_t cmdSize,\n                                              void *pCmdData,\n@@ -564,6 +571,22 @@\n\n         android_errorWriteLog(0x534e4554, \""29251553\"");\n         return -EINVAL;\n     }\n+    if ((cmdCode == EFFECT_CMD_SET_PARAM\n+            || cmdCode == EFFECT_CMD_SET_PARAM_DEFERRED) &&  // DEFERRED not generally used\n+        (sizeof(effect_param_t) > cmdSize\n+            || ((effect_param_t *)pCmdData)->psize > cmdSize\n+                                                     - sizeof(effect_param_t)\n+            || ((effect_param_t *)pCmdData)->vsize > cmdSize\n+                                                     - sizeof(effect_param_t)\n+                                                     - ((effect_param_t *)pCmdData)->psize\n+            || roundUpDelta(((effect_param_t *)pCmdData)->psize, (uint32_t)sizeof(int)) >\n+                                                     cmdSize\n+                                                     - sizeof(effect_param_t)\n+                                                     - ((effect_param_t *)pCmdData)->psize\n+                                                     - ((effect_param_t *)pCmdData)->vsize)) {\n+        android_errorWriteLog(0x534e4554, \""30204301\"");\n+        return -EINVAL;\n+    }\n     status_t status = (*mEffectInterface)->command(mEffectInterface,\n                                                    cmdCode,\n                                                    cmdSize,\n""}"," status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,
                                              uint32_t cmdSize,
                                              void *pCmdData,
 uint32_t *replySize,
 void *pReplyData)
{
 Mutex::Autolock _l(mLock);
    ALOGVV(""command(), cmdCode: %d, mEffectInterface: %p"", cmdCode, mEffectInterface);

 if (mState == DESTROYED || mEffectInterface == NULL) {
 return NO_INIT;
 }
 if (mStatus != NO_ERROR) {
 return mStatus;
 }
 if (cmdCode == EFFECT_CMD_GET_PARAM &&
 (*replySize < sizeof(effect_param_t) ||
 ((effect_param_t *)pCmdData)->psize > *replySize - sizeof(effect_param_t))) {

         android_errorWriteLog(0x534e4554, ""29251553"");
         return -EINVAL;
     }
    if ((cmdCode == EFFECT_CMD_SET_PARAM
            || cmdCode == EFFECT_CMD_SET_PARAM_DEFERRED) &&  // DEFERRED not generally used
        (sizeof(effect_param_t) > cmdSize
            || ((effect_param_t *)pCmdData)->psize > cmdSize
                                                     - sizeof(effect_param_t)
            || ((effect_param_t *)pCmdData)->vsize > cmdSize
                                                     - sizeof(effect_param_t)
                                                     - ((effect_param_t *)pCmdData)->psize
            || roundUpDelta(((effect_param_t *)pCmdData)->psize, (uint32_t)sizeof(int)) >
                                                     cmdSize
                                                     - sizeof(effect_param_t)
                                                     - ((effect_param_t *)pCmdData)->psize
                                                     - ((effect_param_t *)pCmdData)->vsize)) {
        android_errorWriteLog(0x534e4554, ""30204301"");
        return -EINVAL;
    }
     status_t status = (*mEffectInterface)->command(mEffectInterface,
                                                    cmdCode,
                                                    cmdSize,
                                                   pCmdData,
                                                   replySize,
                                                   pReplyData);
 if (cmdCode != EFFECT_CMD_GET_PARAM && status == NO_ERROR) {
 uint32_t size = (replySize == NULL) ? 0 : *replySize;
 for (size_t i = 1; i < mHandles.size(); i++) {
 EffectHandle *h = mHandles[i];
 if (h != NULL && !h->destroyed_l()) {
                h->commandExecuted(cmdCode, cmdSize, pCmdData, size, pReplyData);
 }
 }
 }
 return status;
}
"," status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,
                                              uint32_t cmdSize,
                                              void *pCmdData,
 uint32_t *replySize,
 void *pReplyData)
{
 Mutex::Autolock _l(mLock);
    ALOGVV(""command(), cmdCode: %d, mEffectInterface: %p"", cmdCode, mEffectInterface);

 if (mState == DESTROYED || mEffectInterface == NULL) {
 return NO_INIT;
 }
 if (mStatus != NO_ERROR) {
 return mStatus;
 }
 if (cmdCode == EFFECT_CMD_GET_PARAM &&
 (*replySize < sizeof(effect_param_t) ||
 ((effect_param_t *)pCmdData)->psize > *replySize - sizeof(effect_param_t))) {

         android_errorWriteLog(0x534e4554, ""29251553"");
         return -EINVAL;
     }
     status_t status = (*mEffectInterface)->command(mEffectInterface,
                                                    cmdCode,
                                                    cmdSize,
                                                   pCmdData,
                                                   replySize,
                                                   pReplyData);
 if (cmdCode != EFFECT_CMD_GET_PARAM && status == NO_ERROR) {
 uint32_t size = (replySize == NULL) ? 0 : *replySize;
 for (size_t i = 1; i < mHandles.size(); i++) {
 EffectHandle *h = mHandles[i];
 if (h != NULL && !h->destroyed_l()) {
                h->commandExecuted(cmdCode, cmdSize, pCmdData, size, pReplyData);
 }
 }
 }
 return status;
}
",C,"    if ((cmdCode == EFFECT_CMD_SET_PARAM
            || cmdCode == EFFECT_CMD_SET_PARAM_DEFERRED) &&  // DEFERRED not generally used
        (sizeof(effect_param_t) > cmdSize
            || ((effect_param_t *)pCmdData)->psize > cmdSize
                                                     - sizeof(effect_param_t)
            || ((effect_param_t *)pCmdData)->vsize > cmdSize
                                                     - sizeof(effect_param_t)
                                                     - ((effect_param_t *)pCmdData)->psize
            || roundUpDelta(((effect_param_t *)pCmdData)->psize, (uint32_t)sizeof(int)) >
                                                     cmdSize
                                                     - sizeof(effect_param_t)
                                                     - ((effect_param_t *)pCmdData)->psize
                                                     - ((effect_param_t *)pCmdData)->vsize)) {
        android_errorWriteLog(0x534e4554, ""30204301"");
        return -EINVAL;
    }
",,,"@@ -543,6 +543,13 @@

     return NO_ERROR;
 }
 
+// round up delta valid if value and divisor are positive.
+template <typename T>
+static T roundUpDelta(const T &value, const T &divisor) {
+    T remainder = value % divisor;
+    return remainder == 0 ? 0 : divisor - remainder;
+}
+
 status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,
                                              uint32_t cmdSize,
                                              void *pCmdData,
@@ -564,6 +571,22 @@

         android_errorWriteLog(0x534e4554, ""29251553"");
         return -EINVAL;
     }
+    if ((cmdCode == EFFECT_CMD_SET_PARAM
+            || cmdCode == EFFECT_CMD_SET_PARAM_DEFERRED) &&  // DEFERRED not generally used
+        (sizeof(effect_param_t) > cmdSize
+            || ((effect_param_t *)pCmdData)->psize > cmdSize
+                                                     - sizeof(effect_param_t)
+            || ((effect_param_t *)pCmdData)->vsize > cmdSize
+                                                     - sizeof(effect_param_t)
+                                                     - ((effect_param_t *)pCmdData)->psize
+            || roundUpDelta(((effect_param_t *)pCmdData)->psize, (uint32_t)sizeof(int)) >
+                                                     cmdSize
+                                                     - sizeof(effect_param_t)
+                                                     - ((effect_param_t *)pCmdData)->psize
+                                                     - ((effect_param_t *)pCmdData)->vsize)) {
+        android_errorWriteLog(0x534e4554, ""30204301"");
+        return -EINVAL;
+    }
     status_t status = (*mEffectInterface)->command(mEffectInterface,
                                                    cmdCode,
                                                    cmdSize,
",Android,https://android.googlesource.com/platform/frameworks/av/+/c894aa36be535886a8e5ff02cdbcd07dd24618f6/,https://android.googlesource.com/platform/frameworks/av/+/c894aa36be535886a8e5ff02cdbcd07dd24618f6%5E/,1," status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,
                                              uint32_t cmdSize,
                                              void *pCmdData,
 uint32_t *replySize,
 void *pReplyData)
{
 Mutex::Autolock _l(mLock);
    ALOGVV(""command(), cmdCode: %d, mEffectInterface: %p"", cmdCode, mEffectInterface);

 if (mState == DESTROYED || mEffectInterface == NULL) {
 return NO_INIT;
 }
 if (mStatus != NO_ERROR) {
 return mStatus;
 }
 if (cmdCode == EFFECT_CMD_GET_PARAM &&
 (*replySize < sizeof(effect_param_t) ||
 ((effect_param_t *)pCmdData)->psize > *replySize - sizeof(effect_param_t))) {

         android_errorWriteLog(0x534e4554, ""29251553"");
         return -EINVAL;
     }
//fix_flaw_line_below:
//    if ((cmdCode == EFFECT_CMD_SET_PARAM
//fix_flaw_line_below:
//            || cmdCode == EFFECT_CMD_SET_PARAM_DEFERRED) &&  // DEFERRED not generally used
//fix_flaw_line_below:
//        (sizeof(effect_param_t) > cmdSize
//fix_flaw_line_below:
//            || ((effect_param_t *)pCmdData)->psize > cmdSize
//fix_flaw_line_below:
//                                                     - sizeof(effect_param_t)
//fix_flaw_line_below:
//            || ((effect_param_t *)pCmdData)->vsize > cmdSize
//fix_flaw_line_below:
//                                                     - sizeof(effect_param_t)
//fix_flaw_line_below:
//                                                     - ((effect_param_t *)pCmdData)->psize
//fix_flaw_line_below:
//            || roundUpDelta(((effect_param_t *)pCmdData)->psize, (uint32_t)sizeof(int)) >
//fix_flaw_line_below:
//                                                     cmdSize
//fix_flaw_line_below:
//                                                     - sizeof(effect_param_t)
//fix_flaw_line_below:
//                                                     - ((effect_param_t *)pCmdData)->psize
//fix_flaw_line_below:
//                                                     - ((effect_param_t *)pCmdData)->vsize)) {
//fix_flaw_line_below:
//        android_errorWriteLog(0x534e4554, ""30204301"");
//fix_flaw_line_below:
//        return -EINVAL;
//fix_flaw_line_below:
//    }
     status_t status = (*mEffectInterface)->command(mEffectInterface,
                                                    cmdCode,
                                                    cmdSize,
                                                   pCmdData,
                                                   replySize,
                                                   pReplyData);
 if (cmdCode != EFFECT_CMD_GET_PARAM && status == NO_ERROR) {
 uint32_t size = (replySize == NULL) ? 0 : *replySize;
 for (size_t i = 1; i < mHandles.size(); i++) {
 EffectHandle *h = mHandles[i];
 if (h != NULL && !h->destroyed_l()) {
                h->commandExecuted(cmdCode, cmdSize, pCmdData, size, pReplyData);
 }
 }
 }
 return status;
}
",187409," status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,
                                              uint32_t cmdSize,
                                              void *pCmdData,
 uint32_t *replySize,
 void *pReplyData)
{
 Mutex::Autolock _l(mLock);
    ALOGVV(""command(), cmdCode: %d, mEffectInterface: %p"", cmdCode, mEffectInterface);

 if (mState == DESTROYED || mEffectInterface == NULL) {
 return NO_INIT;
 }
 if (mStatus != NO_ERROR) {
 return mStatus;
 }
 if (cmdCode == EFFECT_CMD_GET_PARAM &&
 (*replySize < sizeof(effect_param_t) ||
 ((effect_param_t *)pCmdData)->psize > *replySize - sizeof(effect_param_t))) {

         android_errorWriteLog(0x534e4554, ""29251553"");
         return -EINVAL;
     }
     status_t status = (*mEffectInterface)->command(mEffectInterface,
                                                    cmdCode,
                                                    cmdSize,
                                                   pCmdData,
                                                   replySize,
                                                   pReplyData);
 if (cmdCode != EFFECT_CMD_GET_PARAM && status == NO_ERROR) {
 uint32_t size = (replySize == NULL) ? 0 : *replySize;
 for (size_t i = 1; i < mHandles.size(); i++) {
 EffectHandle *h = mHandles[i];
 if (h != NULL && !h->destroyed_l()) {
                h->commandExecuted(cmdCode, cmdSize, pCmdData, size, pReplyData);
 }
 }
 }
 return status;
}
"," status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,
                                              uint32_t cmdSize,
                                              void *pCmdData,
 uint32_t *replySize,
 void *pReplyData)
{
 Mutex::Autolock _l(mLock);
    ALOGVV(""command(), cmdCode: %d, mEffectInterface: %p"", cmdCode, mEffectInterface);

 if (mState == DESTROYED || mEffectInterface == NULL) {
 return NO_INIT;
 }
 if (mStatus != NO_ERROR) {
 return mStatus;
 }
 if (cmdCode == EFFECT_CMD_GET_PARAM &&
 (*replySize < sizeof(effect_param_t) ||
 ((effect_param_t *)pCmdData)->psize > *replySize - sizeof(effect_param_t))) {

         android_errorWriteLog(0x534e4554, ""29251553"");
         return -EINVAL;
     }
    if ((cmdCode == EFFECT_CMD_SET_PARAM
            || cmdCode == EFFECT_CMD_SET_PARAM_DEFERRED) &&  // DEFERRED not generally used
        (sizeof(effect_param_t) > cmdSize
            || ((effect_param_t *)pCmdData)->psize > cmdSize
                                                     - sizeof(effect_param_t)
            || ((effect_param_t *)pCmdData)->vsize > cmdSize
                                                     - sizeof(effect_param_t)
                                                     - ((effect_param_t *)pCmdData)->psize
            || roundUpDelta(((effect_param_t *)pCmdData)->psize, (uint32_t)sizeof(int)) >
                                                     cmdSize
                                                     - sizeof(effect_param_t)
                                                     - ((effect_param_t *)pCmdData)->psize
                                                     - ((effect_param_t *)pCmdData)->vsize)) {
        android_errorWriteLog(0x534e4554, ""30204301"");
        return -EINVAL;
    }
     status_t status = (*mEffectInterface)->command(mEffectInterface,
                                                    cmdCode,
                                                    cmdSize,
                                                   pCmdData,
                                                   replySize,
                                                   pReplyData);
 if (cmdCode != EFFECT_CMD_GET_PARAM && status == NO_ERROR) {
 uint32_t size = (replySize == NULL) ? 0 : *replySize;
 for (size_t i = 1; i < mHandles.size(); i++) {
 EffectHandle *h = mHandles[i];
 if (h != NULL && !h->destroyed_l()) {
                h->commandExecuted(cmdCode, cmdSize, pCmdData, size, pReplyData);
 }
 }
 }
 return status;
}
","The `AudioFlinger::EffectModule::command` function processes commands related to audio effects within the AudioFlinger framework. It first acquires a lock to ensure thread safety and checks the state of the effect module, returning an error if it is destroyed or uninitialized. The function validates the command parameters, particularly for the `EFFECT_CMD_GET_PARAM` command, ensuring the provided buffer sizes are adequate. It then delegates the command to the effect interface, handling the response and notifying any associated effect handles of the command execution if the command is successful. Finally, it returns the status of the command execution.","The provided code defines a function that manages audio effect commands within a system. It ensures thread safety by locking access and checks the state of the audio effect module to confirm it is operational. The function validates command parameters, particularly for retrieving effect parameters, to ensure the provided data buffers are sufficient. It then forwards the command to the appropriate audio effect interface and processes the response. If the command is executed successfully, it notifies any related audio effect handles about the command execution. Finally, the function returns the status of the command processing.","The vulnerability in the original code stemmed from insufficient validation of parameters for the `EFFECT_CMD_SET_PARAM` and `EFFECT_CMD_SET_PARAM_DEFERRED` commands, which could lead to buffer overflows or memory corruption if the provided sizes exceeded the allocated memory. The fixed code addresses this by adding comprehensive checks to ensure that the sizes of the parameters, including `psize` and `vsize`, do not exceed the total command size (`cmdSize`). This additional validation prevents potential exploitation by ensuring that all parameters are within safe limits before processing the command, thereby enhancing the overall security of the audio effect module.","The vulnerability in the original code was due to inadequate validation of parameters for specific commands, which could allow for buffer overflows or memory corruption if the input sizes exceeded the allocated memory. This lack of checks posed a risk of exploitation, potentially leading to crashes or unauthorized access. The fixed code addresses this issue by implementing thorough checks to ensure that all parameter sizes are within safe limits before processing the commands. This enhancement effectively mitigates the risk of memory-related vulnerabilities, thereby improving the security and stability of the audio processing system.","The vulnerability was fixed by adding comprehensive parameter size checks specifically for the `EFFECT_CMD_SET_PARAM` and `EFFECT_CMD_SET_PARAM_DEFERRED` commands. The updated code verifies that the sizes of `psize` and `vsize` do not exceed the total command size (`cmdSize`) and ensures that the combined sizes of these parameters, along with the size of the effect parameter structure, remain within the allocated memory limits. This additional validation prevents potential buffer overflows by ensuring that all parameters are properly sized before the command is processed, thereby enhancing the overall security of the audio effect module.","The vulnerability was fixed by implementing additional checks to validate the sizes of parameters associated with specific commands. The updated code ensures that the sizes of the parameters do not exceed the total allocated memory for the command, thereby preventing potential buffer overflows. By verifying that the combined sizes of the parameters are within safe limits before processing, the fix effectively mitigates the risk of memory corruption and enhances the overall security of the system. This proactive approach ensures that only properly sized and safe data is handled during command execution.","5,4","5, 5","5,4","4, 4"
113,113,187522,187522,,Remote,Not required,,CVE-2016-3837,https://www.cvedetails.com/cve/CVE-2016-3837/,CWE-200,Medium,Partial,,,2016-08-05,4.3,"service/jni/com_android_server_wifi_WifiNative.cpp in Wi-Fi in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to obtain sensitive information via a crafted application that provides a MAC address with too few characters, aka internal bug 28164077.",2016-11-28,+Info ,13,https://android.googlesource.com/platform/frameworks/opt/net/wifi/+/a209ff12ba9617c10550678ff93d01fb72a33399,a209ff12ba9617c10550678ff93d01fb72a33399,"Deal correctly with short strings

The parseMacAddress function anticipates only properly formed
MAC addresses (6 hexadecimal octets separated by "":"").  This
change properly deals with situations where the string is
shorter than expected, making sure that the passed in char*
reference in parseHexByte never exceeds the end of the string.

BUG: 28164077
TEST: Added a main function:

int main(int argc, char **argv) {
   unsigned char addr[6];
   if (argc > 1) {
      memset(addr, 0, sizeof(addr));
      parseMacAddress(argv[1], addr);
      printf(""Result: %02x:%02x:%02x:%02x:%02x:%02x\n"",
              addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
   }
}

Tested with """", ""a"" ""ab"" ""ab:c"" ""abxc"".

Change-Id: I0db8d0037e48b62333d475296a45b22ab0efe386
",5,service/jni/com_android_server_wifi_WifiNative.cpp,"{""filename"": ""service/jni/com_android_server_wifi_WifiNative.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/opt/net/wifi/+/a209ff12ba9617c10550678ff93d01fb72a33399/service/jni/com_android_server_wifi_WifiNative.cpp"", ""patch"": ""@@ -697,15 +697,23 @@\n\n }\n \n static byte parseHexByte(const char * &str) {\n+    if (str[0] == '\\0') {\n+        ALOGE(\""Passed an empty string\"");\n+        return 0;\n+    }\n     byte b = parseHexChar(str[0]);\n-    if (str[1] == ':' || str[1] == '\\0') {\n-        str += 2;\n-        return b;\n+    if (str[1] == '\\0' || str[1] == ':') {\n+        str ++;\n     } else {\n         b = b << 4 | parseHexChar(str[1]);\n-        str += 3;\n-        return b;\n+        str += 2;\n     }\n+\n+    // Skip trailing delimiter if not at the end of the string.\n+    if (str[0] != '\\0') {\n+        str++;\n+    }\n+    return b;\n }\n \n static void parseMacAddress(const char *str, mac_addr addr) {\n""}"," static byte parseHexByte(const char * &str) {
    if (str[0] == '\0') {
        ALOGE(""Passed an empty string"");
        return 0;
    }
     byte b = parseHexChar(str[0]);
    if (str[1] == '\0' || str[1] == ':') {
        str ++;
     } else {
         b = b << 4 | parseHexChar(str[1]);
        str += 2;
     }

    // Skip trailing delimiter if not at the end of the string.
    if (str[0] != '\0') {
        str++;
    }
    return b;
 }
"," static byte parseHexByte(const char * &str) {
     byte b = parseHexChar(str[0]);
    if (str[1] == ':' || str[1] == '\0') {
        str += 2;
        return b;
     } else {
         b = b << 4 | parseHexChar(str[1]);
        str += 3;
        return b;
     }
 }
",C,"    if (str[0] == '\0') {
        ALOGE(""Passed an empty string"");
        return 0;
    }
    if (str[1] == '\0' || str[1] == ':') {
        str ++;
        str += 2;

    // Skip trailing delimiter if not at the end of the string.
    if (str[0] != '\0') {
        str++;
    }
    return b;
","    if (str[1] == ':' || str[1] == '\0') {
        str += 2;
        return b;
        str += 3;
        return b;
",,"@@ -697,15 +697,23 @@

 }
 
 static byte parseHexByte(const char * &str) {
+    if (str[0] == '\0') {
+        ALOGE(""Passed an empty string"");
+        return 0;
+    }
     byte b = parseHexChar(str[0]);
-    if (str[1] == ':' || str[1] == '\0') {
-        str += 2;
-        return b;
+    if (str[1] == '\0' || str[1] == ':') {
+        str ++;
     } else {
         b = b << 4 | parseHexChar(str[1]);
-        str += 3;
-        return b;
+        str += 2;
     }
+
+    // Skip trailing delimiter if not at the end of the string.
+    if (str[0] != '\0') {
+        str++;
+    }
+    return b;
 }
 
 static void parseMacAddress(const char *str, mac_addr addr) {
",Android,https://android.googlesource.com/platform/frameworks/opt/net/wifi/+/a209ff12ba9617c10550678ff93d01fb72a33399/,https://android.googlesource.com/platform/frameworks/opt/net/wifi/+/a209ff12ba9617c10550678ff93d01fb72a33399%5E/,1," static byte parseHexByte(const char * &str) {
//fix_flaw_line_below:
//    if (str[0] == '\0') {
//fix_flaw_line_below:
//        ALOGE(""Passed an empty string"");
//fix_flaw_line_below:
//        return 0;
//fix_flaw_line_below:
//    }
     byte b = parseHexChar(str[0]);
//flaw_line_below:
    if (str[1] == ':' || str[1] == '\0') {
//flaw_line_below:
        str += 2;
//flaw_line_below:
        return b;
//fix_flaw_line_below:
//    if (str[1] == '\0' || str[1] == ':') {
//fix_flaw_line_below:
//        str ++;
     } else {
         b = b << 4 | parseHexChar(str[1]);
//flaw_line_below:
        str += 3;
//flaw_line_below:
        return b;
//fix_flaw_line_below:
//        str += 2;
     }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    // Skip trailing delimiter if not at the end of the string.
//fix_flaw_line_below:
//    if (str[0] != '\0') {
//fix_flaw_line_below:
//        str++;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//    return b;
 }
",187522," static byte parseHexByte(const char * &str) {
     byte b = parseHexChar(str[0]);
    if (str[1] == ':' || str[1] == '\0') {
        str += 2;
        return b;
     } else {
         b = b << 4 | parseHexChar(str[1]);
        str += 3;
        return b;
     }
 }
"," static byte parseHexByte(const char * &str) {
    if (str[0] == '\0') {
        ALOGE(""Passed an empty string"");
        return 0;
    }
     byte b = parseHexChar(str[0]);
    if (str[1] == '\0' || str[1] == ':') {
        str ++;
     } else {
         b = b << 4 | parseHexChar(str[1]);
        str += 2;
     }

    // Skip trailing delimiter if not at the end of the string.
    if (str[0] != '\0') {
        str++;
    }
    return b;
 }
","The `parseHexByte` function takes a reference to a character pointer `str` and parses a two-character hexadecimal representation into a byte. It first converts the first character of the string to a byte using the `parseHexChar` function. If the second character is either a colon or the null terminator, it increments the pointer by two and returns the byte. If the second character is not a colon or null, it combines the first byte with the value of the second character (also converted using `parseHexChar`), shifts the first byte left by four bits, and increments the pointer by three before returning the resulting byte.","The provided code defines a function that converts a two-character hexadecimal string into a byte value. It begins by interpreting the first character as a hexadecimal digit. If the second character is either a specific delimiter or the end of the string, the function updates the string pointer accordingly and returns the byte. If the second character is a valid hexadecimal digit, the function combines the values of both characters to form a complete byte, adjusts the string pointer to skip the processed characters, and then returns the resulting byte value.","The vulnerability in the original code arises from the lack of checks for empty or short strings, which could lead to accessing out-of-bounds memory when attempting to parse hexadecimal characters. Specifically, if the input string is empty or has fewer than two characters, the function would still attempt to access `str[0]` and `str[1]`, potentially causing undefined behavior. The fixed code addresses this by first checking if `str[0]` is null, logging an error if so, and ensuring that the pointer manipulation only occurs when valid characters are present, thus preventing out-of-bounds access and improving overall robustness.","The vulnerability in the original code stems from its inability to handle empty or short input strings, which could lead to accessing invalid memory locations when attempting to parse hexadecimal characters. This oversight could result in undefined behavior or crashes if the input does not meet the expected format. The revised code addresses this issue by implementing checks for string length before attempting to access characters, ensuring that operations only occur when valid data is present. This change prevents out-of-bounds access and enhances the function's robustness when processing potentially malformed input.","The vulnerability was fixed by adding a check for an empty string at the beginning of the function, which verifies if `str[0]` is null. If it is, an error message is logged, and the function returns early, preventing any further processing. Additionally, the code now correctly handles cases where the string is shorter than expected by adjusting the pointer manipulation based on the presence of valid characters. Specifically, the pointer is incremented only when valid characters are accessed, ensuring that the reference to the string does not exceed its bounds, thus preventing out-of-bounds memory access.","The vulnerability was addressed by implementing a preliminary check to ensure that the input string is not empty, which prevents any attempts to access characters in an invalid or non-existent string. This safeguard ensures that the function exits early if the input is inadequate, thereby avoiding potential out-of-bounds memory access. Additionally, the code was modified to handle shorter strings more gracefully by adjusting how the pointer is incremented based on the presence of valid characters, ensuring that all operations remain within the valid range of the input string and enhancing overall robustness against malformed input.","5,5","4,4","4,4","4,4"
114,114,187571,187571,,Remote,Not required,Partial,CVE-2016-3765,https://www.cvedetails.com/cve/CVE-2016-3765/,CWE-200,Low,Partial,,,2016-07-10,6.4,"decoder/impeg2d_bitstream.c in mediaserver in Android 6.x before 2016-07-01 allows attackers to obtain sensitive information from process memory or cause a denial of service (out-of-bounds read) via a crafted application, aka internal bug 28168413.",2016-07-12,DoS +Info ,12,https://android.googlesource.com/platform/external/libmpeg2/+/d1c775d1d8d2ed117d1e026719b7f9f089716597,d1c775d1d8d2ed117d1e026719b7f9f089716597,"Fixed out of bound read in flush_bits

Bug: 28168413
Change-Id: I3db5432a08daf665e160c0dab2d1928a576418b4
",1,decoder/impeg2d_bitstream.c,"{""filename"": ""decoder/impeg2d_bitstream.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/d1c775d1d8d2ed117d1e026719b7f9f089716597/decoder/impeg2d_bitstream.c"", ""patch"": ""@@ -191,12 +191,21 @@\n\n INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n-\n-\n-    if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+    if ((ps_stream->u4_offset + 64) < ps_stream->u4_max_offset)\n     {\n         FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n     }\n+    else\n+    {\n+        UWORD32     u4_temp;\n+\n+        if (((ps_stream->u4_offset & 0x1f) + u4_no_of_bits) >= 32)\n+        {\n+            ps_stream->u4_buf              = ps_stream->u4_buf_nxt;\n+            ps_stream->u4_buf_nxt          = 0;\n+        }\n+        ps_stream->u4_offset += u4_no_of_bits;\n+    }\n     return;\n }\n /******************************************************************************\n""}"," INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)
 {
     stream_t *ps_stream = (stream_t *)pv_ctxt;
    if ((ps_stream->u4_offset + 64) < ps_stream->u4_max_offset)
     {
         FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
     }
    else
    {
        UWORD32     u4_temp;

        if (((ps_stream->u4_offset & 0x1f) + u4_no_of_bits) >= 32)
        {
            ps_stream->u4_buf              = ps_stream->u4_buf_nxt;
            ps_stream->u4_buf_nxt          = 0;
        }
        ps_stream->u4_offset += u4_no_of_bits;
    }
     return;
 }
"," INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)
 {
     stream_t *ps_stream = (stream_t *)pv_ctxt;
    if (ps_stream->u4_offset < ps_stream->u4_max_offset)
     {
         FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
     }
     return;
 }
",C,"    if ((ps_stream->u4_offset + 64) < ps_stream->u4_max_offset)
    else
    {
        UWORD32     u4_temp;

        if (((ps_stream->u4_offset & 0x1f) + u4_no_of_bits) >= 32)
        {
            ps_stream->u4_buf              = ps_stream->u4_buf_nxt;
            ps_stream->u4_buf_nxt          = 0;
        }
        ps_stream->u4_offset += u4_no_of_bits;
    }
","    if (ps_stream->u4_offset < ps_stream->u4_max_offset)
",,"@@ -191,12 +191,21 @@

 INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)
 {
     stream_t *ps_stream = (stream_t *)pv_ctxt;
-
-
-    if (ps_stream->u4_offset < ps_stream->u4_max_offset)
+    if ((ps_stream->u4_offset + 64) < ps_stream->u4_max_offset)
     {
         FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
     }
+    else
+    {
+        UWORD32     u4_temp;
+
+        if (((ps_stream->u4_offset & 0x1f) + u4_no_of_bits) >= 32)
+        {
+            ps_stream->u4_buf              = ps_stream->u4_buf_nxt;
+            ps_stream->u4_buf_nxt          = 0;
+        }
+        ps_stream->u4_offset += u4_no_of_bits;
+    }
     return;
 }
 /******************************************************************************
",Android,https://android.googlesource.com/platform/external/libmpeg2/+/d1c775d1d8d2ed117d1e026719b7f9f089716597/,https://android.googlesource.com/platform/external/libmpeg2/+/d1c775d1d8d2ed117d1e026719b7f9f089716597%5E/,1," INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)
 {
     stream_t *ps_stream = (stream_t *)pv_ctxt;
//flaw_line_below:

//flaw_line_below:

//flaw_line_below:
    if (ps_stream->u4_offset < ps_stream->u4_max_offset)
//fix_flaw_line_below:
//    if ((ps_stream->u4_offset + 64) < ps_stream->u4_max_offset)
     {
         FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
     }
//fix_flaw_line_below:
//    else
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//        UWORD32     u4_temp;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        if (((ps_stream->u4_offset & 0x1f) + u4_no_of_bits) >= 32)
//fix_flaw_line_below:
//        {
//fix_flaw_line_below:
//            ps_stream->u4_buf              = ps_stream->u4_buf_nxt;
//fix_flaw_line_below:
//            ps_stream->u4_buf_nxt          = 0;
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//        ps_stream->u4_offset += u4_no_of_bits;
//fix_flaw_line_below:
//    }
     return;
 }
",187571," INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)
 {
     stream_t *ps_stream = (stream_t *)pv_ctxt;
    if (ps_stream->u4_offset < ps_stream->u4_max_offset)
     {
         FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
     }
     return;
 }
"," INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)
 {
     stream_t *ps_stream = (stream_t *)pv_ctxt;
    if ((ps_stream->u4_offset + 64) < ps_stream->u4_max_offset)
     {
         FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
     }
    else
    {
        UWORD32     u4_temp;

        if (((ps_stream->u4_offset & 0x1f) + u4_no_of_bits) >= 32)
        {
            ps_stream->u4_buf              = ps_stream->u4_buf_nxt;
            ps_stream->u4_buf_nxt          = 0;
        }
        ps_stream->u4_offset += u4_no_of_bits;
    }
     return;
 }
","The function `impeg2d_bit_stream_flush` is designed to flush a specified number of bits from a bit stream buffer, ensuring that the data is correctly written out. It takes two parameters: a context pointer `pv_ctxt`, which is cast to a `stream_t` structure, and `u4_no_of_bits`, indicating the number of bits to flush. The function first checks if the current offset in the stream is less than the maximum offset. If this condition is met, it calls the `FLUSH_BITS` macro to perform the flushing operation, utilizing various attributes of the `stream_t` structure to manage the buffer and offsets effectively.","The provided code defines a function that manages the flushing of bits from a bit stream buffer. It takes a context pointer and a specified number of bits to flush as input parameters. The function first checks if the current position in the stream is within the allowable limit. If so, it proceeds to execute a flushing operation that writes the specified bits from the buffer to an aligned storage area. This ensures that the data is correctly processed and stored, maintaining the integrity of the bit stream during operations.","The vulnerability in the original code stemmed from the potential for an out-of-bounds read when flushing bits, as it only checked if the current offset was less than the maximum offset. This could lead to accessing memory beyond the allocated buffer if the number of bits to flush exceeded the available space. The fixed code addresses this by adding a condition that ensures the sum of the current offset and a constant (64) remains less than the maximum offset. Additionally, it includes logic to reset the buffer when necessary, thereby preventing out-of-bounds access and ensuring safe memory operations during the flushing process.","The vulnerability in the original code was due to insufficient checks on the buffer's boundaries, which could lead to out-of-bounds memory access when flushing bits. This risk arose when the number of bits to be flushed exceeded the available space in the buffer, potentially causing undefined behavior or crashes. The fixed code addresses this issue by implementing a more robust condition that ensures the current position plus a defined constant remains within the buffer's limits. Additionally, it includes logic to manage the buffer state appropriately, thereby preventing any out-of-bounds reads and enhancing overall memory safety.","The vulnerability was fixed by modifying the condition that checks the current offset against the maximum offset. The updated code ensures that the sum of the current offset and a constant (64) is less than the maximum offset, preventing potential out-of-bounds reads. Additionally, the code introduces logic to handle the buffer state: if the combined offset and the number of bits to flush exceed a certain threshold, it resets the buffer by assigning the next buffer to the current one and clearing the next buffer. This comprehensive approach safeguards against memory access violations while maintaining proper buffer management.","The vulnerability was fixed by enhancing the boundary checks to ensure that the current position in the buffer, when combined with a defined constant, remains within the allocated limits. This adjustment prevents any potential out-of-bounds memory access during the flushing operation. Additionally, the updated code introduces logic to manage the buffer's state effectively; if the total bits to be flushed exceed a certain threshold, it resets the buffer appropriately. This comprehensive approach not only safeguards against memory access violations but also ensures that the buffer is correctly maintained throughout the flushing process.","4, 4","4,4","4,4","4,4"
115,115,187792,187792,,Remote,Not required,,CVE-2016-2499,https://www.cvedetails.com/cve/CVE-2016-2499/,CWE-200,Medium,Partial,,,2016-06-12,4.3,"AudioSource.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not initialize certain data, which allows attackers to obtain sensitive information via a crafted application, aka internal bug 27855172.",2016-06-14,+Info ,4,https://android.googlesource.com/platform/frameworks/av/+/dd3546765710ce8dd49eb23901d90345dec8282f,dd3546765710ce8dd49eb23901d90345dec8282f,"AudioSource: initialize variables

to prevent info leak

Bug: 27855172
Change-Id: I3d33e0a9cc5cf8a758d7b0794590b09c43a24561
",0,media/libstagefright/AudioSource.cpp,"{""filename"": ""media/libstagefright/AudioSource.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/dd3546765710ce8dd49eb23901d90345dec8282f/media/libstagefright/AudioSource.cpp"", ""patch"": ""@@ -55,8 +55,12 @@\n\n     : mStarted(false),\n       mSampleRate(sampleRate),\n       mOutSampleRate(outSampleRate > 0 ? outSampleRate : sampleRate),\n+      mTrackMaxAmplitude(false),\n+      mStartTimeUs(0),\n+      mMaxAmplitude(0),\n       mPrevSampleTimeUs(0),\n       mFirstSampleTimeUs(-1ll),\n+      mInitialReadTimeUs(0),\n       mNumFramesReceived(0),\n       mNumClientOwnedBuffers(0) {\n     ALOGV(\""sampleRate: %u, outSampleRate: %u, channelCount: %u\"",\n""}","AudioSource::AudioSource(
 audio_source_t inputSource, const String16 &opPackageName,
 uint32_t sampleRate, uint32_t channelCount, uint32_t outSampleRate)

     : mStarted(false),
       mSampleRate(sampleRate),
       mOutSampleRate(outSampleRate > 0 ? outSampleRate : sampleRate),
      mTrackMaxAmplitude(false),
      mStartTimeUs(0),
      mMaxAmplitude(0),
       mPrevSampleTimeUs(0),
       mFirstSampleTimeUs(-1ll),
      mInitialReadTimeUs(0),
       mNumFramesReceived(0),
       mNumClientOwnedBuffers(0) {
     ALOGV(""sampleRate: %u, outSampleRate: %u, channelCount: %u"",
            sampleRate, outSampleRate, channelCount);
    CHECK(channelCount == 1 || channelCount == 2);
    CHECK(sampleRate > 0);

 size_t minFrameCount;
 status_t status = AudioRecord::getMinFrameCount(&minFrameCount,
                                           sampleRate,
                                           AUDIO_FORMAT_PCM_16_BIT,
                                           audio_channel_in_mask_from_count(channelCount));
 if (status == OK) {
 uint32_t frameCount = kMaxBufferSize / sizeof(int16_t) / channelCount;

 size_t bufCount = 2;
 while ((bufCount * frameCount) < minFrameCount) {
            bufCount++;
 }

        mRecord = new AudioRecord(
                    inputSource, sampleRate, AUDIO_FORMAT_PCM_16_BIT,
                    audio_channel_in_mask_from_count(channelCount),
                    opPackageName,
 (size_t) (bufCount * frameCount),
 AudioRecordCallbackFunction,
 this,
                    frameCount /*notificationFrames*/);
        mInitCheck = mRecord->initCheck();
 if (mInitCheck != OK) {
            mRecord.clear();
 }
 } else {
        mInitCheck = status;
 }
}
","AudioSource::AudioSource(
 audio_source_t inputSource, const String16 &opPackageName,
 uint32_t sampleRate, uint32_t channelCount, uint32_t outSampleRate)

     : mStarted(false),
       mSampleRate(sampleRate),
       mOutSampleRate(outSampleRate > 0 ? outSampleRate : sampleRate),
       mPrevSampleTimeUs(0),
       mFirstSampleTimeUs(-1ll),
       mNumFramesReceived(0),
       mNumClientOwnedBuffers(0) {
     ALOGV(""sampleRate: %u, outSampleRate: %u, channelCount: %u"",
            sampleRate, outSampleRate, channelCount);
    CHECK(channelCount == 1 || channelCount == 2);
    CHECK(sampleRate > 0);

 size_t minFrameCount;
 status_t status = AudioRecord::getMinFrameCount(&minFrameCount,
                                           sampleRate,
                                           AUDIO_FORMAT_PCM_16_BIT,
                                           audio_channel_in_mask_from_count(channelCount));
 if (status == OK) {
 uint32_t frameCount = kMaxBufferSize / sizeof(int16_t) / channelCount;

 size_t bufCount = 2;
 while ((bufCount * frameCount) < minFrameCount) {
            bufCount++;
 }

        mRecord = new AudioRecord(
                    inputSource, sampleRate, AUDIO_FORMAT_PCM_16_BIT,
                    audio_channel_in_mask_from_count(channelCount),
                    opPackageName,
 (size_t) (bufCount * frameCount),
 AudioRecordCallbackFunction,
 this,
                    frameCount /*notificationFrames*/);
        mInitCheck = mRecord->initCheck();
 if (mInitCheck != OK) {
            mRecord.clear();
 }
 } else {
        mInitCheck = status;
 }
}
",C,"      mTrackMaxAmplitude(false),
      mStartTimeUs(0),
      mMaxAmplitude(0),
      mInitialReadTimeUs(0),
",,,"@@ -55,8 +55,12 @@

     : mStarted(false),
       mSampleRate(sampleRate),
       mOutSampleRate(outSampleRate > 0 ? outSampleRate : sampleRate),
+      mTrackMaxAmplitude(false),
+      mStartTimeUs(0),
+      mMaxAmplitude(0),
       mPrevSampleTimeUs(0),
       mFirstSampleTimeUs(-1ll),
+      mInitialReadTimeUs(0),
       mNumFramesReceived(0),
       mNumClientOwnedBuffers(0) {
     ALOGV(""sampleRate: %u, outSampleRate: %u, channelCount: %u"",
",Android,https://android.googlesource.com/platform/frameworks/av/+/dd3546765710ce8dd49eb23901d90345dec8282f/,https://android.googlesource.com/platform/frameworks/av/+/dd3546765710ce8dd49eb23901d90345dec8282f%5E/,1,"AudioSource::AudioSource(
 audio_source_t inputSource, const String16 &opPackageName,
 uint32_t sampleRate, uint32_t channelCount, uint32_t outSampleRate)

     : mStarted(false),
       mSampleRate(sampleRate),
       mOutSampleRate(outSampleRate > 0 ? outSampleRate : sampleRate),
//fix_flaw_line_below:
//      mTrackMaxAmplitude(false),
//fix_flaw_line_below:
//      mStartTimeUs(0),
//fix_flaw_line_below:
//      mMaxAmplitude(0),
       mPrevSampleTimeUs(0),
       mFirstSampleTimeUs(-1ll),
//fix_flaw_line_below:
//      mInitialReadTimeUs(0),
       mNumFramesReceived(0),
       mNumClientOwnedBuffers(0) {
     ALOGV(""sampleRate: %u, outSampleRate: %u, channelCount: %u"",
            sampleRate, outSampleRate, channelCount);
    CHECK(channelCount == 1 || channelCount == 2);
    CHECK(sampleRate > 0);

 size_t minFrameCount;
 status_t status = AudioRecord::getMinFrameCount(&minFrameCount,
                                           sampleRate,
                                           AUDIO_FORMAT_PCM_16_BIT,
                                           audio_channel_in_mask_from_count(channelCount));
 if (status == OK) {
 // make sure that the AudioRecord callback never returns more than the maximum
 // buffer size
 uint32_t frameCount = kMaxBufferSize / sizeof(int16_t) / channelCount;

 // make sure that the AudioRecord total buffer size is large enough
 size_t bufCount = 2;
 while ((bufCount * frameCount) < minFrameCount) {
            bufCount++;
 }

        mRecord = new AudioRecord(
                    inputSource, sampleRate, AUDIO_FORMAT_PCM_16_BIT,
                    audio_channel_in_mask_from_count(channelCount),
                    opPackageName,
 (size_t) (bufCount * frameCount),
 AudioRecordCallbackFunction,
 this,
                    frameCount /*notificationFrames*/);
        mInitCheck = mRecord->initCheck();
 if (mInitCheck != OK) {
            mRecord.clear();
 }
 } else {
        mInitCheck = status;
 }
}
",187792,"AudioSource::AudioSource(
 audio_source_t inputSource, const String16 &opPackageName,
 uint32_t sampleRate, uint32_t channelCount, uint32_t outSampleRate)

     : mStarted(false),
       mSampleRate(sampleRate),
       mOutSampleRate(outSampleRate > 0 ? outSampleRate : sampleRate),
       mPrevSampleTimeUs(0),
       mFirstSampleTimeUs(-1ll),
       mNumFramesReceived(0),
       mNumClientOwnedBuffers(0) {
     ALOGV(""sampleRate: %u, outSampleRate: %u, channelCount: %u"",
            sampleRate, outSampleRate, channelCount);
    CHECK(channelCount == 1 || channelCount == 2);
    CHECK(sampleRate > 0);

 size_t minFrameCount;
 status_t status = AudioRecord::getMinFrameCount(&minFrameCount,
                                           sampleRate,
                                           AUDIO_FORMAT_PCM_16_BIT,
                                           audio_channel_in_mask_from_count(channelCount));
 if (status == OK) {
 uint32_t frameCount = kMaxBufferSize / sizeof(int16_t) / channelCount;

 size_t bufCount = 2;
 while ((bufCount * frameCount) < minFrameCount) {
            bufCount++;
 }

        mRecord = new AudioRecord(
                    inputSource, sampleRate, AUDIO_FORMAT_PCM_16_BIT,
                    audio_channel_in_mask_from_count(channelCount),
                    opPackageName,
 (size_t) (bufCount * frameCount),
 AudioRecordCallbackFunction,
 this,
                    frameCount /*notificationFrames*/);
        mInitCheck = mRecord->initCheck();
 if (mInitCheck != OK) {
            mRecord.clear();
 }
 } else {
        mInitCheck = status;
 }
}
","AudioSource::AudioSource(
 audio_source_t inputSource, const String16 &opPackageName,
 uint32_t sampleRate, uint32_t channelCount, uint32_t outSampleRate)

     : mStarted(false),
       mSampleRate(sampleRate),
       mOutSampleRate(outSampleRate > 0 ? outSampleRate : sampleRate),
      mTrackMaxAmplitude(false),
      mStartTimeUs(0),
      mMaxAmplitude(0),
       mPrevSampleTimeUs(0),
       mFirstSampleTimeUs(-1ll),
      mInitialReadTimeUs(0),
       mNumFramesReceived(0),
       mNumClientOwnedBuffers(0) {
     ALOGV(""sampleRate: %u, outSampleRate: %u, channelCount: %u"",
            sampleRate, outSampleRate, channelCount);
    CHECK(channelCount == 1 || channelCount == 2);
    CHECK(sampleRate > 0);

 size_t minFrameCount;
 status_t status = AudioRecord::getMinFrameCount(&minFrameCount,
                                           sampleRate,
                                           AUDIO_FORMAT_PCM_16_BIT,
                                           audio_channel_in_mask_from_count(channelCount));
 if (status == OK) {
 uint32_t frameCount = kMaxBufferSize / sizeof(int16_t) / channelCount;

 size_t bufCount = 2;
 while ((bufCount * frameCount) < minFrameCount) {
            bufCount++;
 }

        mRecord = new AudioRecord(
                    inputSource, sampleRate, AUDIO_FORMAT_PCM_16_BIT,
                    audio_channel_in_mask_from_count(channelCount),
                    opPackageName,
 (size_t) (bufCount * frameCount),
 AudioRecordCallbackFunction,
 this,
                    frameCount /*notificationFrames*/);
        mInitCheck = mRecord->initCheck();
 if (mInitCheck != OK) {
            mRecord.clear();
 }
 } else {
        mInitCheck = status;
 }
}
","The `AudioSource` constructor initializes an audio source object with specified parameters such as input source, package name, sample rate, and channel count. It sets initial values for various member variables, including flags for starting the audio stream and tracking sample times and frame counts. The constructor checks that the channel count is either mono or stereo and that the sample rate is positive. It then retrieves the minimum frame count required for audio recording and calculates an appropriate buffer size. If successful, it creates an `AudioRecord` instance for audio input, ensuring proper initialization; otherwise, it records an error status.","The code defines a constructor for an audio source object that initializes various parameters related to audio recording, such as the input source, package name, sample rate, and channel configuration. It sets up initial states for the audio stream and checks the validity of the provided parameters. The constructor calculates the minimum required frame count for recording and determines an appropriate buffer size. If the setup is successful, it creates an audio recording instance to handle audio input, ensuring that it is properly initialized; otherwise, it captures an error status for further handling.","The vulnerability in the original code stemmed from uninitialized member variables, which could lead to information leakage, as their values might be exposed unintentionally. Specifically, variables like `mTrackMaxAmplitude`, `mStartTimeUs`, and `mMaxAmplitude` were not initialized, potentially allowing sensitive data to be read from memory. In the fixed code, these variables were explicitly initialized in the constructor's member initializer list, ensuring that they start with known values. This change mitigates the risk of leaking uninitialized data, thereby enhancing the security and reliability of the audio source object.","The vulnerability in the original code was due to the presence of uninitialized member variables, which could inadvertently expose sensitive information from memory, leading to potential information leaks. This lack of initialization meant that the values of these variables could be unpredictable, posing a security risk. In the revised code, the issue was addressed by explicitly initializing these member variables within the constructor. This change ensures that all variables start with defined values, thereby preventing any leakage of uninitialized data and enhancing the overall security and integrity of the audio source implementation.","The vulnerability was fixed by explicitly initializing previously uninitialized member variables in the constructor's initializer list. Specifically, variables such as `mTrackMaxAmplitude`, `mStartTimeUs`, and `mMaxAmplitude` were added with default values, ensuring they do not contain garbage data. This initialization prevents the risk of leaking sensitive information that could occur if these variables were read before being assigned a valid state. By ensuring that all member variables have defined values upon object creation, the code enhances security and mitigates the potential for information leaks, addressing the identified issue effectively.","The vulnerability was fixed by ensuring that all member variables are explicitly initialized in the constructor's initializer list. This change guarantees that the variables start with defined values rather than containing unpredictable or garbage data. By assigning default values to these variables, the code prevents the risk of leaking sensitive information that could occur if uninitialized data were accessed. This approach enhances the overall security of the implementation by eliminating the potential for information leaks, thereby ensuring that the object's state is consistent and reliable from the moment it is created.","5,4","5,5","4,4","5,5"
116,116,187981,187981,,Remote,Not required,,CVE-2016-0811,https://www.cvedetails.com/cve/CVE-2016-0811/,CWE-200,Low,Complete,,,2016-02-06,7.8,"Integer overflow in the BnCrypto::onTransact function in media/libmedia/ICrypto.cpp in libmediaplayerservice in Android 6.x before 2016-02-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, by triggering an improper size calculation, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25800375.",2016-03-14,Overflow Bypass +Info ,3,https://android.googlesource.com/platform%2Fframeworks%2Fav/+/22f824feac43d5758f9a70b77f2aca840ba62c3b,22f824feac43d5758f9a70b77f2aca840ba62c3b,"Fix security vulnerability in ICrypto DO NOT MERGE

b/25800375

Change-Id: I03c9395f7c7de4ac5813a1207452aac57aa39484
",1,media/libmedia/ICrypto.cpp,"{""filename"": ""media/libmedia/ICrypto.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/22f824feac43d5758f9a70b77f2aca840ba62c3b/media/libmedia/ICrypto.cpp"", ""patch"": ""@@ -321,7 +321,9 @@\n\n \n             if (overflow || sumSubsampleSizes != totalSize) {\n                 result = -EINVAL;\n-            } else if (offset + totalSize > sharedBuffer->size()) {\n+            } else if (totalSize > sharedBuffer->size()) {\n+                result = -EINVAL;\n+            } else if ((size_t)offset > sharedBuffer->size() - totalSize) {\n                 result = -EINVAL;\n             } else {\n                 result = decrypt(\n""}","status_t BnCrypto::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(ICrypto, data, reply);
            reply->writeInt32(initCheck());

 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(ICrypto, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(isCryptoSchemeSupported(uuid));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));

 size_t opaqueSize = data.readInt32();
 void *opaqueData = NULL;

 if (opaqueSize > 0) {
                opaqueData = malloc(opaqueSize);
                data.read(opaqueData, opaqueSize);
 }

            reply->writeInt32(createPlugin(uuid, opaqueData, opaqueSize));

 if (opaqueData != NULL) {
                free(opaqueData);
                opaqueData = NULL;
 }

 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(ICrypto, data, reply);
            reply->writeInt32(destroyPlugin());

 return OK;
 }

 case REQUIRES_SECURE_COMPONENT:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 const char *mime = data.readCString();
            reply->writeInt32(requiresSecureDecoderComponent(mime));

 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 bool secure = data.readInt32() != 0;
 CryptoPlugin::Mode mode = (CryptoPlugin::Mode)data.readInt32();

 uint8_t key[16];
            data.read(key, sizeof(key));

 uint8_t iv[16];
            data.read(iv, sizeof(iv));

 size_t totalSize = data.readInt32();
            sp<IMemory> sharedBuffer =
                interface_cast<IMemory>(data.readStrongBinder());
 int32_t offset = data.readInt32();

 int32_t numSubSamples = data.readInt32();

 CryptoPlugin::SubSample *subSamples =
 new CryptoPlugin::SubSample[numSubSamples];

            data.read(
                    subSamples,
 sizeof(CryptoPlugin::SubSample) * numSubSamples);

 void *secureBufferId, *dstPtr;
 if (secure) {
                secureBufferId = reinterpret_cast<void *>(static_cast<uintptr_t>(data.readInt64()));
 } else {
                dstPtr = calloc(1, totalSize);
 }

 AString errorDetailMsg;
 ssize_t result;

 size_t sumSubsampleSizes = 0;
 bool overflow = false;
 for (int32_t i = 0; i < numSubSamples; ++i) {
 CryptoPlugin::SubSample &ss = subSamples[i];
 if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfEncryptedData) {
                    sumSubsampleSizes += ss.mNumBytesOfEncryptedData;
 } else {
                    overflow = true;
 }
 if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfClearData) {
                    sumSubsampleSizes += ss.mNumBytesOfClearData;
 } else {
                    overflow = true;
 }
 }

 
             if (overflow || sumSubsampleSizes != totalSize) {
                 result = -EINVAL;
            } else if (totalSize > sharedBuffer->size()) {
                result = -EINVAL;
            } else if ((size_t)offset > sharedBuffer->size() - totalSize) {
                 result = -EINVAL;
             } else {
                 result = decrypt(
                    secure,
                    key,
                    iv,
                    mode,
                    sharedBuffer, offset,
                    subSamples, numSubSamples,
                    secure ? secureBufferId : dstPtr,
 &errorDetailMsg);
 }

            reply->writeInt32(result);

 if (isCryptoError(result)) {
                reply->writeCString(errorDetailMsg.c_str());
 }

 if (!secure) {
 if (result >= 0) {
                    CHECK_LE(result, static_cast<ssize_t>(totalSize));
                    reply->write(dstPtr, result);
 }
                free(dstPtr);
                dstPtr = NULL;
 }

 delete[] subSamples;
            subSamples = NULL;

 return OK;
 }

 case NOTIFY_RESOLUTION:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 int32_t width = data.readInt32();
 int32_t height = data.readInt32();
            notifyResolution(width, height);

 return OK;
 }

 case SET_MEDIADRM_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(setMediaDrmSession(sessionId));
 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","status_t BnCrypto::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(ICrypto, data, reply);
            reply->writeInt32(initCheck());

 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(ICrypto, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(isCryptoSchemeSupported(uuid));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));

 size_t opaqueSize = data.readInt32();
 void *opaqueData = NULL;

 if (opaqueSize > 0) {
                opaqueData = malloc(opaqueSize);
                data.read(opaqueData, opaqueSize);
 }

            reply->writeInt32(createPlugin(uuid, opaqueData, opaqueSize));

 if (opaqueData != NULL) {
                free(opaqueData);
                opaqueData = NULL;
 }

 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(ICrypto, data, reply);
            reply->writeInt32(destroyPlugin());

 return OK;
 }

 case REQUIRES_SECURE_COMPONENT:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 const char *mime = data.readCString();
            reply->writeInt32(requiresSecureDecoderComponent(mime));

 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 bool secure = data.readInt32() != 0;
 CryptoPlugin::Mode mode = (CryptoPlugin::Mode)data.readInt32();

 uint8_t key[16];
            data.read(key, sizeof(key));

 uint8_t iv[16];
            data.read(iv, sizeof(iv));

 size_t totalSize = data.readInt32();
            sp<IMemory> sharedBuffer =
                interface_cast<IMemory>(data.readStrongBinder());
 int32_t offset = data.readInt32();

 int32_t numSubSamples = data.readInt32();

 CryptoPlugin::SubSample *subSamples =
 new CryptoPlugin::SubSample[numSubSamples];

            data.read(
                    subSamples,
 sizeof(CryptoPlugin::SubSample) * numSubSamples);

 void *secureBufferId, *dstPtr;
 if (secure) {
                secureBufferId = reinterpret_cast<void *>(static_cast<uintptr_t>(data.readInt64()));
 } else {
                dstPtr = calloc(1, totalSize);
 }

 AString errorDetailMsg;
 ssize_t result;

 size_t sumSubsampleSizes = 0;
 bool overflow = false;
 for (int32_t i = 0; i < numSubSamples; ++i) {
 CryptoPlugin::SubSample &ss = subSamples[i];
 if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfEncryptedData) {
                    sumSubsampleSizes += ss.mNumBytesOfEncryptedData;
 } else {
                    overflow = true;
 }
 if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfClearData) {
                    sumSubsampleSizes += ss.mNumBytesOfClearData;
 } else {
                    overflow = true;
 }
 }

 
             if (overflow || sumSubsampleSizes != totalSize) {
                 result = -EINVAL;
            } else if (offset + totalSize > sharedBuffer->size()) {
                 result = -EINVAL;
             } else {
                 result = decrypt(
                    secure,
                    key,
                    iv,
                    mode,
                    sharedBuffer, offset,
                    subSamples, numSubSamples,
                    secure ? secureBufferId : dstPtr,
 &errorDetailMsg);
 }

            reply->writeInt32(result);

 if (isCryptoError(result)) {
                reply->writeCString(errorDetailMsg.c_str());
 }

 if (!secure) {
 if (result >= 0) {
                    CHECK_LE(result, static_cast<ssize_t>(totalSize));
                    reply->write(dstPtr, result);
 }
                free(dstPtr);
                dstPtr = NULL;
 }

 delete[] subSamples;
            subSamples = NULL;

 return OK;
 }

 case NOTIFY_RESOLUTION:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 int32_t width = data.readInt32();
 int32_t height = data.readInt32();
            notifyResolution(width, height);

 return OK;
 }

 case SET_MEDIADRM_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(setMediaDrmSession(sessionId));
 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
",C,"            } else if (totalSize > sharedBuffer->size()) {
                result = -EINVAL;
            } else if ((size_t)offset > sharedBuffer->size() - totalSize) {
","            } else if (offset + totalSize > sharedBuffer->size()) {
",,"@@ -321,7 +321,9 @@

 
             if (overflow || sumSubsampleSizes != totalSize) {
                 result = -EINVAL;
-            } else if (offset + totalSize > sharedBuffer->size()) {
+            } else if (totalSize > sharedBuffer->size()) {
+                result = -EINVAL;
+            } else if ((size_t)offset > sharedBuffer->size() - totalSize) {
                 result = -EINVAL;
             } else {
                 result = decrypt(
",Android,https://android.googlesource.com/platform/frameworks/av/+/22f824feac43d5758f9a70b77f2aca840ba62c3b/,https://android.googlesource.com/platform/frameworks/av/+/22f824feac43d5758f9a70b77f2aca840ba62c3b%5E/,1,"status_t BnCrypto::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(ICrypto, data, reply);
            reply->writeInt32(initCheck());

 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(ICrypto, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(isCryptoSchemeSupported(uuid));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));

 size_t opaqueSize = data.readInt32();
 void *opaqueData = NULL;

 if (opaqueSize > 0) {
                opaqueData = malloc(opaqueSize);
                data.read(opaqueData, opaqueSize);
 }

            reply->writeInt32(createPlugin(uuid, opaqueData, opaqueSize));

 if (opaqueData != NULL) {
                free(opaqueData);
                opaqueData = NULL;
 }

 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(ICrypto, data, reply);
            reply->writeInt32(destroyPlugin());

 return OK;
 }

 case REQUIRES_SECURE_COMPONENT:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 const char *mime = data.readCString();
            reply->writeInt32(requiresSecureDecoderComponent(mime));

 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 bool secure = data.readInt32() != 0;
 CryptoPlugin::Mode mode = (CryptoPlugin::Mode)data.readInt32();

 uint8_t key[16];
            data.read(key, sizeof(key));

 uint8_t iv[16];
            data.read(iv, sizeof(iv));

 size_t totalSize = data.readInt32();
            sp<IMemory> sharedBuffer =
                interface_cast<IMemory>(data.readStrongBinder());
 int32_t offset = data.readInt32();

 int32_t numSubSamples = data.readInt32();

 CryptoPlugin::SubSample *subSamples =
 new CryptoPlugin::SubSample[numSubSamples];

            data.read(
                    subSamples,
 sizeof(CryptoPlugin::SubSample) * numSubSamples);

 void *secureBufferId, *dstPtr;
 if (secure) {
                secureBufferId = reinterpret_cast<void *>(static_cast<uintptr_t>(data.readInt64()));
 } else {
                dstPtr = calloc(1, totalSize);
 }

 AString errorDetailMsg;
 ssize_t result;

 size_t sumSubsampleSizes = 0;
 bool overflow = false;
 for (int32_t i = 0; i < numSubSamples; ++i) {
 CryptoPlugin::SubSample &ss = subSamples[i];
 if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfEncryptedData) {
                    sumSubsampleSizes += ss.mNumBytesOfEncryptedData;
 } else {
                    overflow = true;
 }
 if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfClearData) {
                    sumSubsampleSizes += ss.mNumBytesOfClearData;
 } else {
                    overflow = true;
 }
 }

 
             if (overflow || sumSubsampleSizes != totalSize) {
                 result = -EINVAL;
//flaw_line_below:
            } else if (offset + totalSize > sharedBuffer->size()) {
//fix_flaw_line_below:
//            } else if (totalSize > sharedBuffer->size()) {
//fix_flaw_line_below:
//                result = -EINVAL;
//fix_flaw_line_below:
//            } else if ((size_t)offset > sharedBuffer->size() - totalSize) {
                 result = -EINVAL;
             } else {
                 result = decrypt(
                    secure,
                    key,
                    iv,
                    mode,
                    sharedBuffer, offset,
                    subSamples, numSubSamples,
                    secure ? secureBufferId : dstPtr,
 &errorDetailMsg);
 }

            reply->writeInt32(result);

 if (isCryptoError(result)) {
                reply->writeCString(errorDetailMsg.c_str());
 }

 if (!secure) {
 if (result >= 0) {
                    CHECK_LE(result, static_cast<ssize_t>(totalSize));
                    reply->write(dstPtr, result);
 }
                free(dstPtr);
                dstPtr = NULL;
 }

 delete[] subSamples;
            subSamples = NULL;

 return OK;
 }

 case NOTIFY_RESOLUTION:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 int32_t width = data.readInt32();
 int32_t height = data.readInt32();
            notifyResolution(width, height);

 return OK;
 }

 case SET_MEDIADRM_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(setMediaDrmSession(sessionId));
 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
",187981,"status_t BnCrypto::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(ICrypto, data, reply);
            reply->writeInt32(initCheck());

 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(ICrypto, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(isCryptoSchemeSupported(uuid));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));

 size_t opaqueSize = data.readInt32();
 void *opaqueData = NULL;

 if (opaqueSize > 0) {
                opaqueData = malloc(opaqueSize);
                data.read(opaqueData, opaqueSize);
 }

            reply->writeInt32(createPlugin(uuid, opaqueData, opaqueSize));

 if (opaqueData != NULL) {
                free(opaqueData);
                opaqueData = NULL;
 }

 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(ICrypto, data, reply);
            reply->writeInt32(destroyPlugin());

 return OK;
 }

 case REQUIRES_SECURE_COMPONENT:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 const char *mime = data.readCString();
            reply->writeInt32(requiresSecureDecoderComponent(mime));

 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 bool secure = data.readInt32() != 0;
 CryptoPlugin::Mode mode = (CryptoPlugin::Mode)data.readInt32();

 uint8_t key[16];
            data.read(key, sizeof(key));

 uint8_t iv[16];
            data.read(iv, sizeof(iv));

 size_t totalSize = data.readInt32();
            sp<IMemory> sharedBuffer =
                interface_cast<IMemory>(data.readStrongBinder());
 int32_t offset = data.readInt32();

 int32_t numSubSamples = data.readInt32();

 CryptoPlugin::SubSample *subSamples =
 new CryptoPlugin::SubSample[numSubSamples];

            data.read(
                    subSamples,
 sizeof(CryptoPlugin::SubSample) * numSubSamples);

 void *secureBufferId, *dstPtr;
 if (secure) {
                secureBufferId = reinterpret_cast<void *>(static_cast<uintptr_t>(data.readInt64()));
 } else {
                dstPtr = calloc(1, totalSize);
 }

 AString errorDetailMsg;
 ssize_t result;

 size_t sumSubsampleSizes = 0;
 bool overflow = false;
 for (int32_t i = 0; i < numSubSamples; ++i) {
 CryptoPlugin::SubSample &ss = subSamples[i];
 if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfEncryptedData) {
                    sumSubsampleSizes += ss.mNumBytesOfEncryptedData;
 } else {
                    overflow = true;
 }
 if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfClearData) {
                    sumSubsampleSizes += ss.mNumBytesOfClearData;
 } else {
                    overflow = true;
 }
 }

 
             if (overflow || sumSubsampleSizes != totalSize) {
                 result = -EINVAL;
            } else if (offset + totalSize > sharedBuffer->size()) {
                 result = -EINVAL;
             } else {
                 result = decrypt(
                    secure,
                    key,
                    iv,
                    mode,
                    sharedBuffer, offset,
                    subSamples, numSubSamples,
                    secure ? secureBufferId : dstPtr,
 &errorDetailMsg);
 }

            reply->writeInt32(result);

 if (isCryptoError(result)) {
                reply->writeCString(errorDetailMsg.c_str());
 }

 if (!secure) {
 if (result >= 0) {
                    CHECK_LE(result, static_cast<ssize_t>(totalSize));
                    reply->write(dstPtr, result);
 }
                free(dstPtr);
                dstPtr = NULL;
 }

 delete[] subSamples;
            subSamples = NULL;

 return OK;
 }

 case NOTIFY_RESOLUTION:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 int32_t width = data.readInt32();
 int32_t height = data.readInt32();
            notifyResolution(width, height);

 return OK;
 }

 case SET_MEDIADRM_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(setMediaDrmSession(sessionId));
 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","status_t BnCrypto::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(ICrypto, data, reply);
            reply->writeInt32(initCheck());

 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(ICrypto, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(isCryptoSchemeSupported(uuid));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));

 size_t opaqueSize = data.readInt32();
 void *opaqueData = NULL;

 if (opaqueSize > 0) {
                opaqueData = malloc(opaqueSize);
                data.read(opaqueData, opaqueSize);
 }

            reply->writeInt32(createPlugin(uuid, opaqueData, opaqueSize));

 if (opaqueData != NULL) {
                free(opaqueData);
                opaqueData = NULL;
 }

 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(ICrypto, data, reply);
            reply->writeInt32(destroyPlugin());

 return OK;
 }

 case REQUIRES_SECURE_COMPONENT:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 const char *mime = data.readCString();
            reply->writeInt32(requiresSecureDecoderComponent(mime));

 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 bool secure = data.readInt32() != 0;
 CryptoPlugin::Mode mode = (CryptoPlugin::Mode)data.readInt32();

 uint8_t key[16];
            data.read(key, sizeof(key));

 uint8_t iv[16];
            data.read(iv, sizeof(iv));

 size_t totalSize = data.readInt32();
            sp<IMemory> sharedBuffer =
                interface_cast<IMemory>(data.readStrongBinder());
 int32_t offset = data.readInt32();

 int32_t numSubSamples = data.readInt32();

 CryptoPlugin::SubSample *subSamples =
 new CryptoPlugin::SubSample[numSubSamples];

            data.read(
                    subSamples,
 sizeof(CryptoPlugin::SubSample) * numSubSamples);

 void *secureBufferId, *dstPtr;
 if (secure) {
                secureBufferId = reinterpret_cast<void *>(static_cast<uintptr_t>(data.readInt64()));
 } else {
                dstPtr = calloc(1, totalSize);
 }

 AString errorDetailMsg;
 ssize_t result;

 size_t sumSubsampleSizes = 0;
 bool overflow = false;
 for (int32_t i = 0; i < numSubSamples; ++i) {
 CryptoPlugin::SubSample &ss = subSamples[i];
 if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfEncryptedData) {
                    sumSubsampleSizes += ss.mNumBytesOfEncryptedData;
 } else {
                    overflow = true;
 }
 if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfClearData) {
                    sumSubsampleSizes += ss.mNumBytesOfClearData;
 } else {
                    overflow = true;
 }
 }

 
             if (overflow || sumSubsampleSizes != totalSize) {
                 result = -EINVAL;
            } else if (totalSize > sharedBuffer->size()) {
                result = -EINVAL;
            } else if ((size_t)offset > sharedBuffer->size() - totalSize) {
                 result = -EINVAL;
             } else {
                 result = decrypt(
                    secure,
                    key,
                    iv,
                    mode,
                    sharedBuffer, offset,
                    subSamples, numSubSamples,
                    secure ? secureBufferId : dstPtr,
 &errorDetailMsg);
 }

            reply->writeInt32(result);

 if (isCryptoError(result)) {
                reply->writeCString(errorDetailMsg.c_str());
 }

 if (!secure) {
 if (result >= 0) {
                    CHECK_LE(result, static_cast<ssize_t>(totalSize));
                    reply->write(dstPtr, result);
 }
                free(dstPtr);
                dstPtr = NULL;
 }

 delete[] subSamples;
            subSamples = NULL;

 return OK;
 }

 case NOTIFY_RESOLUTION:
 {
            CHECK_INTERFACE(ICrypto, data, reply);

 int32_t width = data.readInt32();
 int32_t height = data.readInt32();
            notifyResolution(width, height);

 return OK;
 }

 case SET_MEDIADRM_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(setMediaDrmSession(sessionId));
 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","The `BnCrypto::onTransact` function handles various transaction requests related to cryptographic operations, utilizing a switch-case structure to process different command codes. Each case checks the interface validity, reads necessary data from the `Parcel`, and performs specific actions such as initializing checks, verifying supported crypto schemes, creating or destroying plugins, and decrypting data. It manages memory allocation for opaque data and sub-samples, ensuring proper cleanup after operations. Additionally, it handles resolution notifications and Media DRM session settings, returning results and error messages as needed, while maintaining robust error checking throughout the process.","The provided code defines a function that processes various transaction requests related to cryptographic operations. It uses a switch-case structure to handle different command types, ensuring that the interface is valid before executing specific tasks. These tasks include checking initialization status, verifying supported cryptographic schemes, creating and destroying plugins, and performing decryption operations. The function also manages memory for temporary data and handles error checking throughout the process. Additionally, it can notify about resolution changes and manage media session settings, returning appropriate results and error messages as needed.","The vulnerability in the original code stemmed from insufficient checks on the size of the data being processed, particularly in the decryption case. Specifically, the code did not adequately verify that the total size of the data to be decrypted did not exceed the size of the shared buffer, which could lead to buffer overflows or memory corruption. In the fixed code, additional checks were introduced to ensure that both the total size and the offset were within valid bounds relative to the shared buffer's size, thereby preventing potential exploitation through improper memory access and enhancing overall security.","The vulnerability in the original code was due to inadequate validation of input sizes, particularly concerning the decryption process, which could lead to buffer overflows or memory corruption. This lack of checks allowed for potential exploitation by manipulating the size of the data being processed. In the revised code, additional safeguards were implemented to ensure that both the total size of the data and the offset were properly validated against the limits of the allocated memory. These enhancements effectively mitigated the risk of improper memory access, thereby improving the overall security of the system.","The vulnerability was fixed by adding crucial validation checks in the decryption case to ensure safe memory access. Specifically, the code now verifies that the `totalSize` does not exceed the size of the `sharedBuffer` and that the `offset` plus `totalSize` does not exceed the buffer's size. These checks prevent potential buffer overflows by ensuring that the data being processed remains within valid bounds. Additionally, the code checks for overflow conditions when summing the sizes of encrypted and clear data, enhancing the robustness of memory handling and reducing the risk of exploitation.","The vulnerability was addressed by implementing additional validation checks to ensure that the sizes of data being processed do not exceed the allocated memory limits. The revised code now verifies that the total size of the data and the offset are within safe bounds relative to the memory buffer, preventing potential buffer overflows. Furthermore, checks were added to detect any overflow conditions when calculating the sizes of encrypted and clear data. These enhancements significantly improve memory safety and reduce the risk of exploitation by ensuring that all data operations remain within valid and secure limits.","4, 5","5, 5","5,5","3, 4"
117,117,187995,187995,,Remote,Not required,,CVE-2017-0823,https://www.cvedetails.com/cve/CVE-2017-0823/,CWE-200,Low,Partial,,,2017-10-03,5.0,"An information disclosure vulnerability in the Android system (rild). Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-37896655.",2017-10-12,+Info ,7,https://android.googlesource.com/platform/hardware/ril/+/cd5f15f588a5d27e99ba12f057245bfe507f8c42,cd5f15f588a5d27e99ba12f057245bfe507f8c42,"DO NOT MERGE
Fix security vulnerability in pre-O rild code.

Remove wrong code for setup_data_call.
Add check for max address for RIL_DIAL.

Bug: 37896655
Test: Manual.
Change-Id: I05c027140ae828a2653794fcdd94e1b1a130941b
(cherry picked from commit dda24c6557911aa1f4708abbd6b2f20f0e205b9e)
",7,libril/ril.cpp,"{""filename"": ""libril/ril.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/hardware/ril/+/cd5f15f588a5d27e99ba12f057245bfe507f8c42/libril/ril.cpp"", ""patch"": ""@@ -4419,12 +4419,12 @@\n\n     int data;\n     unsigned int qxdm_data[6];\n     const char *deactData[1] = {\""1\""};\n-    char *actData[1];\n     RIL_Dial dialData;\n     int hangupData[1] = {1};\n     int number;\n     char **args;\n     RIL_SOCKET_ID socket_id = RIL_SOCKET_1;\n+    int MAX_DIAL_ADDRESS = 128;\n     int sim_id = 0;\n \n     RLOGI(\""debugCallback for socket %s\"", rilSocketIdToString(socket_id));\n@@ -4571,12 +4571,6 @@\n\n             // Set network selection automatic.\n             issueLocalRequest(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, NULL, 0, socket_id);\n             break;\n-        case 6:\n-            RLOGI(\""Debug port: Setup Data Call, Apn :%s\\n\"", args[1]);\n-            actData[0] = args[1];\n-            issueLocalRequest(RIL_REQUEST_SETUP_DATA_CALL, &actData,\n-                              sizeof(actData), socket_id);\n-            break;\n         case 7:\n             RLOGI(\""Debug port: Deactivate Data Call\"");\n             issueLocalRequest(RIL_REQUEST_DEACTIVATE_DATA_CALL, &deactData,\n@@ -4585,6 +4579,12 @@\n\n         case 8:\n             RLOGI(\""Debug port: Dial Call\"");\n             dialData.clir = 0;\n+            if (strlen(args[1]) > MAX_DIAL_ADDRESS) {\n+                RLOGE(\""Debug port: Error calling Dial\"");\n+                freeDebugCallbackArgs(number, args);\n+                close(acceptFD);\n+                return;\n+            }\n             dialData.address = args[1];\n             issueLocalRequest(RIL_REQUEST_DIAL, &dialData, sizeof(dialData), socket_id);\n             break;\n""}","static void debugCallback (int fd, short flags, void *param) {
 int acceptFD, option;
 struct sockaddr_un peeraddr;
 socklen_t socklen = sizeof (peeraddr);

     int data;
     unsigned int qxdm_data[6];
     const char *deactData[1] = {""1""};
     RIL_Dial dialData;
     int hangupData[1] = {1};
     int number;
     char **args;
     RIL_SOCKET_ID socket_id = RIL_SOCKET_1;
    int MAX_DIAL_ADDRESS = 128;
     int sim_id = 0;
 
     RLOGI(""debugCallback for socket %s"", rilSocketIdToString(socket_id));

    acceptFD = accept (fd, (sockaddr *) &peeraddr, &socklen);

 if (acceptFD < 0) {
        RLOGE (""error accepting on debug port: %d\n"", errno);
 return;
 }

 if (recv(acceptFD, &number, sizeof(int), 0) != sizeof(int)) {
        RLOGE (""error reading on socket: number of Args: \n"");
        close(acceptFD);
 return;
 }

 if (number < 0) {
        RLOGE (""Invalid number of arguments: \n"");
        close(acceptFD);
 return;
 }

    args = (char **) calloc(number, sizeof(char*));
 if (args == NULL) {
        RLOGE(""Memory allocation failed for debug args"");
        close(acceptFD);
 return;
 }

 for (int i = 0; i < number; i++) {
 int len;
 if (recv(acceptFD, &len, sizeof(int), 0) != sizeof(int)) {
            RLOGE (""error reading on socket: Len of Args: \n"");
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }
 if (len == INT_MAX || len < 0) {
            RLOGE(""Invalid value of len: \n"");
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }

        args[i] = (char *) calloc(len + 1, sizeof(char));
 if (args[i] == NULL) {
            RLOGE(""Memory allocation failed for debug args"");
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }
 if (recv(acceptFD, args[i], sizeof(char) * len, 0)
 != (int)sizeof(char) * len) {
            RLOGE (""error reading on socket: Args[%d] \n"", i);
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }
 char * buf = args[i];
        buf[len] = 0;
 if ((i+1) == number) {
 /* The last argument should be sim id 0(SIM1)~3(SIM4) */
            sim_id = atoi(args[i]);
 switch (sim_id) {
 case 0:
                    socket_id = RIL_SOCKET_1;
 break;
 #if (SIM_COUNT >= 2)
 case 1:
                    socket_id = RIL_SOCKET_2;
 break;
 #endif
 #if (SIM_COUNT >= 3)
 case 2:
                    socket_id = RIL_SOCKET_3;
 break;
 #endif
 #if (SIM_COUNT >= 4)
 case 3:
                    socket_id = RIL_SOCKET_4;
 break;
 #endif
 default:
                    socket_id = RIL_SOCKET_1;
 break;
 }
 }
 }

 switch (atoi(args[0])) {
 case 0:
            RLOGI (""Connection on debug port: issuing reset."");
            issueLocalRequest(RIL_REQUEST_RESET_RADIO, NULL, 0, socket_id);
 break;
 case 1:
            RLOGI (""Connection on debug port: issuing radio power off."");
            data = 0;
            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);
 if (socket_id == RIL_SOCKET_1 && s_ril_param_socket.fdCommand > 0) {
                close(s_ril_param_socket.fdCommand);
                s_ril_param_socket.fdCommand = -1;
 }
 #if (SIM_COUNT == 2)
 else if (socket_id == RIL_SOCKET_2 && s_ril_param_socket2.fdCommand > 0) {
                close(s_ril_param_socket2.fdCommand);
                s_ril_param_socket2.fdCommand = -1;
 }
 #endif
 break;
 case 2:
            RLOGI (""Debug port: issuing unsolicited voice network change."");
            RIL_UNSOL_RESPONSE(RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED, NULL, 0, socket_id);
 break;
 case 3:
            RLOGI (""Debug port: QXDM log enable."");
            qxdm_data[0] = 65536; // head.func_tag
            qxdm_data[1] = 16; // head.len
            qxdm_data[2] = 1; // mode: 1 for 'start logging'
            qxdm_data[3] = 32; // log_file_size: 32megabytes
            qxdm_data[4] = 0; // log_mask
            qxdm_data[5] = 8; // log_max_fileindex
            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,
 6 * sizeof(int), socket_id);
 break;
 case 4:
            RLOGI (""Debug port: QXDM log disable."");
            qxdm_data[0] = 65536;
            qxdm_data[1] = 16;
            qxdm_data[2] = 0; // mode: 0 for 'stop logging'
            qxdm_data[3] = 32;
            qxdm_data[4] = 0;
            qxdm_data[5] = 8;
            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,
 6 * sizeof(int), socket_id);
 break;
 case 5:
            RLOGI(""Debug port: Radio On"");
            data = 1;
            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);
            sleep(2);

             issueLocalRequest(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, NULL, 0, socket_id);
             break;
         case 7:
             RLOGI(""Debug port: Deactivate Data Call"");
             issueLocalRequest(RIL_REQUEST_DEACTIVATE_DATA_CALL, &deactData,
 sizeof(deactData), socket_id);
 break;

         case 8:
             RLOGI(""Debug port: Dial Call"");
             dialData.clir = 0;
            if (strlen(args[1]) > MAX_DIAL_ADDRESS) {
                RLOGE(""Debug port: Error calling Dial"");
                freeDebugCallbackArgs(number, args);
                close(acceptFD);
                return;
            }
             dialData.address = args[1];
             issueLocalRequest(RIL_REQUEST_DIAL, &dialData, sizeof(dialData), socket_id);
             break;
 case 9:
            RLOGI(""Debug port: Answer Call"");
            issueLocalRequest(RIL_REQUEST_ANSWER, NULL, 0, socket_id);
 break;
 case 10:
            RLOGI(""Debug port: End Call"");
            issueLocalRequest(RIL_REQUEST_HANGUP, &hangupData,
 sizeof(hangupData), socket_id);
 break;
 default:
            RLOGE (""Invalid request"");
 break;
 }
    freeDebugCallbackArgs(number, args);
    close(acceptFD);
}
","static void debugCallback (int fd, short flags, void *param) {
 int acceptFD, option;
 struct sockaddr_un peeraddr;
 socklen_t socklen = sizeof (peeraddr);

     int data;
     unsigned int qxdm_data[6];
     const char *deactData[1] = {""1""};
    char *actData[1];
     RIL_Dial dialData;
     int hangupData[1] = {1};
     int number;
     char **args;
     RIL_SOCKET_ID socket_id = RIL_SOCKET_1;
     int sim_id = 0;
 
     RLOGI(""debugCallback for socket %s"", rilSocketIdToString(socket_id));

    acceptFD = accept (fd, (sockaddr *) &peeraddr, &socklen);

 if (acceptFD < 0) {
        RLOGE (""error accepting on debug port: %d\n"", errno);
 return;
 }

 if (recv(acceptFD, &number, sizeof(int), 0) != sizeof(int)) {
        RLOGE (""error reading on socket: number of Args: \n"");
        close(acceptFD);
 return;
 }

 if (number < 0) {
        RLOGE (""Invalid number of arguments: \n"");
        close(acceptFD);
 return;
 }

    args = (char **) calloc(number, sizeof(char*));
 if (args == NULL) {
        RLOGE(""Memory allocation failed for debug args"");
        close(acceptFD);
 return;
 }

 for (int i = 0; i < number; i++) {
 int len;
 if (recv(acceptFD, &len, sizeof(int), 0) != sizeof(int)) {
            RLOGE (""error reading on socket: Len of Args: \n"");
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }
 if (len == INT_MAX || len < 0) {
            RLOGE(""Invalid value of len: \n"");
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }

        args[i] = (char *) calloc(len + 1, sizeof(char));
 if (args[i] == NULL) {
            RLOGE(""Memory allocation failed for debug args"");
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }
 if (recv(acceptFD, args[i], sizeof(char) * len, 0)
 != (int)sizeof(char) * len) {
            RLOGE (""error reading on socket: Args[%d] \n"", i);
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }
 char * buf = args[i];
        buf[len] = 0;
 if ((i+1) == number) {
 /* The last argument should be sim id 0(SIM1)~3(SIM4) */
            sim_id = atoi(args[i]);
 switch (sim_id) {
 case 0:
                    socket_id = RIL_SOCKET_1;
 break;
 #if (SIM_COUNT >= 2)
 case 1:
                    socket_id = RIL_SOCKET_2;
 break;
 #endif
 #if (SIM_COUNT >= 3)
 case 2:
                    socket_id = RIL_SOCKET_3;
 break;
 #endif
 #if (SIM_COUNT >= 4)
 case 3:
                    socket_id = RIL_SOCKET_4;
 break;
 #endif
 default:
                    socket_id = RIL_SOCKET_1;
 break;
 }
 }
 }

 switch (atoi(args[0])) {
 case 0:
            RLOGI (""Connection on debug port: issuing reset."");
            issueLocalRequest(RIL_REQUEST_RESET_RADIO, NULL, 0, socket_id);
 break;
 case 1:
            RLOGI (""Connection on debug port: issuing radio power off."");
            data = 0;
            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);
 if (socket_id == RIL_SOCKET_1 && s_ril_param_socket.fdCommand > 0) {
                close(s_ril_param_socket.fdCommand);
                s_ril_param_socket.fdCommand = -1;
 }
 #if (SIM_COUNT == 2)
 else if (socket_id == RIL_SOCKET_2 && s_ril_param_socket2.fdCommand > 0) {
                close(s_ril_param_socket2.fdCommand);
                s_ril_param_socket2.fdCommand = -1;
 }
 #endif
 break;
 case 2:
            RLOGI (""Debug port: issuing unsolicited voice network change."");
            RIL_UNSOL_RESPONSE(RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED, NULL, 0, socket_id);
 break;
 case 3:
            RLOGI (""Debug port: QXDM log enable."");
            qxdm_data[0] = 65536; // head.func_tag
            qxdm_data[1] = 16; // head.len
            qxdm_data[2] = 1; // mode: 1 for 'start logging'
            qxdm_data[3] = 32; // log_file_size: 32megabytes
            qxdm_data[4] = 0; // log_mask
            qxdm_data[5] = 8; // log_max_fileindex
            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,
 6 * sizeof(int), socket_id);
 break;
 case 4:
            RLOGI (""Debug port: QXDM log disable."");
            qxdm_data[0] = 65536;
            qxdm_data[1] = 16;
            qxdm_data[2] = 0; // mode: 0 for 'stop logging'
            qxdm_data[3] = 32;
            qxdm_data[4] = 0;
            qxdm_data[5] = 8;
            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,
 6 * sizeof(int), socket_id);
 break;
 case 5:
            RLOGI(""Debug port: Radio On"");
            data = 1;
            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);
            sleep(2);

             issueLocalRequest(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, NULL, 0, socket_id);
             break;
        case 6:
            RLOGI(""Debug port: Setup Data Call, Apn :%s\n"", args[1]);
            actData[0] = args[1];
            issueLocalRequest(RIL_REQUEST_SETUP_DATA_CALL, &actData,
                              sizeof(actData), socket_id);
            break;
         case 7:
             RLOGI(""Debug port: Deactivate Data Call"");
             issueLocalRequest(RIL_REQUEST_DEACTIVATE_DATA_CALL, &deactData,
 sizeof(deactData), socket_id);
 break;

         case 8:
             RLOGI(""Debug port: Dial Call"");
             dialData.clir = 0;
             dialData.address = args[1];
             issueLocalRequest(RIL_REQUEST_DIAL, &dialData, sizeof(dialData), socket_id);
             break;
 case 9:
            RLOGI(""Debug port: Answer Call"");
            issueLocalRequest(RIL_REQUEST_ANSWER, NULL, 0, socket_id);
 break;
 case 10:
            RLOGI(""Debug port: End Call"");
            issueLocalRequest(RIL_REQUEST_HANGUP, &hangupData,
 sizeof(hangupData), socket_id);
 break;
 default:
            RLOGE (""Invalid request"");
 break;
 }
    freeDebugCallbackArgs(number, args);
    close(acceptFD);
}
",C,"    int MAX_DIAL_ADDRESS = 128;
            if (strlen(args[1]) > MAX_DIAL_ADDRESS) {
                RLOGE(""Debug port: Error calling Dial"");
                freeDebugCallbackArgs(number, args);
                close(acceptFD);
                return;
            }
","    char *actData[1];
        case 6:
            RLOGI(""Debug port: Setup Data Call, Apn :%s\n"", args[1]);
            actData[0] = args[1];
            issueLocalRequest(RIL_REQUEST_SETUP_DATA_CALL, &actData,
                              sizeof(actData), socket_id);
            break;
",,"@@ -4419,12 +4419,12 @@

     int data;
     unsigned int qxdm_data[6];
     const char *deactData[1] = {""1""};
-    char *actData[1];
     RIL_Dial dialData;
     int hangupData[1] = {1};
     int number;
     char **args;
     RIL_SOCKET_ID socket_id = RIL_SOCKET_1;
+    int MAX_DIAL_ADDRESS = 128;
     int sim_id = 0;
 
     RLOGI(""debugCallback for socket %s"", rilSocketIdToString(socket_id));
@@ -4571,12 +4571,6 @@

             // Set network selection automatic.
             issueLocalRequest(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, NULL, 0, socket_id);
             break;
-        case 6:
-            RLOGI(""Debug port: Setup Data Call, Apn :%s\n"", args[1]);
-            actData[0] = args[1];
-            issueLocalRequest(RIL_REQUEST_SETUP_DATA_CALL, &actData,
-                              sizeof(actData), socket_id);
-            break;
         case 7:
             RLOGI(""Debug port: Deactivate Data Call"");
             issueLocalRequest(RIL_REQUEST_DEACTIVATE_DATA_CALL, &deactData,
@@ -4585,6 +4579,12 @@

         case 8:
             RLOGI(""Debug port: Dial Call"");
             dialData.clir = 0;
+            if (strlen(args[1]) > MAX_DIAL_ADDRESS) {
+                RLOGE(""Debug port: Error calling Dial"");
+                freeDebugCallbackArgs(number, args);
+                close(acceptFD);
+                return;
+            }
             dialData.address = args[1];
             issueLocalRequest(RIL_REQUEST_DIAL, &dialData, sizeof(dialData), socket_id);
             break;
",Android,https://android.googlesource.com/platform/hardware/ril/+/cd5f15f588a5d27e99ba12f057245bfe507f8c42/,https://android.googlesource.com/platform/hardware/ril/+/cd5f15f588a5d27e99ba12f057245bfe507f8c42%5E/,1,"static void debugCallback (int fd, short flags, void *param) {
 int acceptFD, option;
 struct sockaddr_un peeraddr;
 socklen_t socklen = sizeof (peeraddr);

     int data;
     unsigned int qxdm_data[6];
     const char *deactData[1] = {""1""};
//flaw_line_below:
    char *actData[1];
     RIL_Dial dialData;
     int hangupData[1] = {1};
     int number;
     char **args;
     RIL_SOCKET_ID socket_id = RIL_SOCKET_1;
//fix_flaw_line_below:
//    int MAX_DIAL_ADDRESS = 128;
     int sim_id = 0;
 
     RLOGI(""debugCallback for socket %s"", rilSocketIdToString(socket_id));

    acceptFD = accept (fd, (sockaddr *) &peeraddr, &socklen);

 if (acceptFD < 0) {
        RLOGE (""error accepting on debug port: %d\n"", errno);
 return;
 }

 if (recv(acceptFD, &number, sizeof(int), 0) != sizeof(int)) {
        RLOGE (""error reading on socket: number of Args: \n"");
        close(acceptFD);
 return;
 }

 if (number < 0) {
        RLOGE (""Invalid number of arguments: \n"");
        close(acceptFD);
 return;
 }

    args = (char **) calloc(number, sizeof(char*));
 if (args == NULL) {
        RLOGE(""Memory allocation failed for debug args"");
        close(acceptFD);
 return;
 }

 for (int i = 0; i < number; i++) {
 int len;
 if (recv(acceptFD, &len, sizeof(int), 0) != sizeof(int)) {
            RLOGE (""error reading on socket: Len of Args: \n"");
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }
 if (len == INT_MAX || len < 0) {
            RLOGE(""Invalid value of len: \n"");
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }

 // +1 for null-term
        args[i] = (char *) calloc(len + 1, sizeof(char));
 if (args[i] == NULL) {
            RLOGE(""Memory allocation failed for debug args"");
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }
 if (recv(acceptFD, args[i], sizeof(char) * len, 0)
 != (int)sizeof(char) * len) {
            RLOGE (""error reading on socket: Args[%d] \n"", i);
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }
 char * buf = args[i];
        buf[len] = 0;
 if ((i+1) == number) {
 /* The last argument should be sim id 0(SIM1)~3(SIM4) */
            sim_id = atoi(args[i]);
 switch (sim_id) {
 case 0:
                    socket_id = RIL_SOCKET_1;
 break;
 #if (SIM_COUNT >= 2)
 case 1:
                    socket_id = RIL_SOCKET_2;
 break;
 #endif
 #if (SIM_COUNT >= 3)
 case 2:
                    socket_id = RIL_SOCKET_3;
 break;
 #endif
 #if (SIM_COUNT >= 4)
 case 3:
                    socket_id = RIL_SOCKET_4;
 break;
 #endif
 default:
                    socket_id = RIL_SOCKET_1;
 break;
 }
 }
 }

 switch (atoi(args[0])) {
 case 0:
            RLOGI (""Connection on debug port: issuing reset."");
            issueLocalRequest(RIL_REQUEST_RESET_RADIO, NULL, 0, socket_id);
 break;
 case 1:
            RLOGI (""Connection on debug port: issuing radio power off."");
            data = 0;
            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);
 // Close the socket
 if (socket_id == RIL_SOCKET_1 && s_ril_param_socket.fdCommand > 0) {
                close(s_ril_param_socket.fdCommand);
                s_ril_param_socket.fdCommand = -1;
 }
 #if (SIM_COUNT == 2)
 else if (socket_id == RIL_SOCKET_2 && s_ril_param_socket2.fdCommand > 0) {
                close(s_ril_param_socket2.fdCommand);
                s_ril_param_socket2.fdCommand = -1;
 }
 #endif
 break;
 case 2:
            RLOGI (""Debug port: issuing unsolicited voice network change."");
            RIL_UNSOL_RESPONSE(RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED, NULL, 0, socket_id);
 break;
 case 3:
            RLOGI (""Debug port: QXDM log enable."");
            qxdm_data[0] = 65536; // head.func_tag
            qxdm_data[1] = 16; // head.len
            qxdm_data[2] = 1; // mode: 1 for 'start logging'
            qxdm_data[3] = 32; // log_file_size: 32megabytes
            qxdm_data[4] = 0; // log_mask
            qxdm_data[5] = 8; // log_max_fileindex
            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,
 6 * sizeof(int), socket_id);
 break;
 case 4:
            RLOGI (""Debug port: QXDM log disable."");
            qxdm_data[0] = 65536;
            qxdm_data[1] = 16;
            qxdm_data[2] = 0; // mode: 0 for 'stop logging'
            qxdm_data[3] = 32;
            qxdm_data[4] = 0;
            qxdm_data[5] = 8;
            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,
 6 * sizeof(int), socket_id);
 break;
 case 5:
            RLOGI(""Debug port: Radio On"");
            data = 1;
            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);
            sleep(2);

             // Set network selection automatic.
             issueLocalRequest(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, NULL, 0, socket_id);
             break;
//flaw_line_below:
        case 6:
//flaw_line_below:
            RLOGI(""Debug port: Setup Data Call, Apn :%s\n"", args[1]);
//flaw_line_below:
            actData[0] = args[1];
//flaw_line_below:
            issueLocalRequest(RIL_REQUEST_SETUP_DATA_CALL, &actData,
//flaw_line_below:
                              sizeof(actData), socket_id);
//flaw_line_below:
            break;
         case 7:
             RLOGI(""Debug port: Deactivate Data Call"");
             issueLocalRequest(RIL_REQUEST_DEACTIVATE_DATA_CALL, &deactData,
 sizeof(deactData), socket_id);
 break;

         case 8:
             RLOGI(""Debug port: Dial Call"");
             dialData.clir = 0;
//fix_flaw_line_below:
//            if (strlen(args[1]) > MAX_DIAL_ADDRESS) {
//fix_flaw_line_below:
//                RLOGE(""Debug port: Error calling Dial"");
//fix_flaw_line_below:
//                freeDebugCallbackArgs(number, args);
//fix_flaw_line_below:
//                close(acceptFD);
//fix_flaw_line_below:
//                return;
//fix_flaw_line_below:
//            }
             dialData.address = args[1];
             issueLocalRequest(RIL_REQUEST_DIAL, &dialData, sizeof(dialData), socket_id);
             break;
 case 9:
            RLOGI(""Debug port: Answer Call"");
            issueLocalRequest(RIL_REQUEST_ANSWER, NULL, 0, socket_id);
 break;
 case 10:
            RLOGI(""Debug port: End Call"");
            issueLocalRequest(RIL_REQUEST_HANGUP, &hangupData,
 sizeof(hangupData), socket_id);
 break;
 default:
            RLOGE (""Invalid request"");
 break;
 }
    freeDebugCallbackArgs(number, args);
    close(acceptFD);
}
",187995,"static void debugCallback (int fd, short flags, void *param) {
 int acceptFD, option;
 struct sockaddr_un peeraddr;
 socklen_t socklen = sizeof (peeraddr);

     int data;
     unsigned int qxdm_data[6];
     const char *deactData[1] = {""1""};
    char *actData[1];
     RIL_Dial dialData;
     int hangupData[1] = {1};
     int number;
     char **args;
     RIL_SOCKET_ID socket_id = RIL_SOCKET_1;
     int sim_id = 0;
 
     RLOGI(""debugCallback for socket %s"", rilSocketIdToString(socket_id));

    acceptFD = accept (fd, (sockaddr *) &peeraddr, &socklen);

 if (acceptFD < 0) {
        RLOGE (""error accepting on debug port: %d\n"", errno);
 return;
 }

 if (recv(acceptFD, &number, sizeof(int), 0) != sizeof(int)) {
        RLOGE (""error reading on socket: number of Args: \n"");
        close(acceptFD);
 return;
 }

 if (number < 0) {
        RLOGE (""Invalid number of arguments: \n"");
        close(acceptFD);
 return;
 }

    args = (char **) calloc(number, sizeof(char*));
 if (args == NULL) {
        RLOGE(""Memory allocation failed for debug args"");
        close(acceptFD);
 return;
 }

 for (int i = 0; i < number; i++) {
 int len;
 if (recv(acceptFD, &len, sizeof(int), 0) != sizeof(int)) {
            RLOGE (""error reading on socket: Len of Args: \n"");
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }
 if (len == INT_MAX || len < 0) {
            RLOGE(""Invalid value of len: \n"");
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }

        args[i] = (char *) calloc(len + 1, sizeof(char));
 if (args[i] == NULL) {
            RLOGE(""Memory allocation failed for debug args"");
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }
 if (recv(acceptFD, args[i], sizeof(char) * len, 0)
 != (int)sizeof(char) * len) {
            RLOGE (""error reading on socket: Args[%d] \n"", i);
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }
 char * buf = args[i];
        buf[len] = 0;
 if ((i+1) == number) {
 /* The last argument should be sim id 0(SIM1)~3(SIM4) */
            sim_id = atoi(args[i]);
 switch (sim_id) {
 case 0:
                    socket_id = RIL_SOCKET_1;
 break;
 #if (SIM_COUNT >= 2)
 case 1:
                    socket_id = RIL_SOCKET_2;
 break;
 #endif
 #if (SIM_COUNT >= 3)
 case 2:
                    socket_id = RIL_SOCKET_3;
 break;
 #endif
 #if (SIM_COUNT >= 4)
 case 3:
                    socket_id = RIL_SOCKET_4;
 break;
 #endif
 default:
                    socket_id = RIL_SOCKET_1;
 break;
 }
 }
 }

 switch (atoi(args[0])) {
 case 0:
            RLOGI (""Connection on debug port: issuing reset."");
            issueLocalRequest(RIL_REQUEST_RESET_RADIO, NULL, 0, socket_id);
 break;
 case 1:
            RLOGI (""Connection on debug port: issuing radio power off."");
            data = 0;
            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);
 if (socket_id == RIL_SOCKET_1 && s_ril_param_socket.fdCommand > 0) {
                close(s_ril_param_socket.fdCommand);
                s_ril_param_socket.fdCommand = -1;
 }
 #if (SIM_COUNT == 2)
 else if (socket_id == RIL_SOCKET_2 && s_ril_param_socket2.fdCommand > 0) {
                close(s_ril_param_socket2.fdCommand);
                s_ril_param_socket2.fdCommand = -1;
 }
 #endif
 break;
 case 2:
            RLOGI (""Debug port: issuing unsolicited voice network change."");
            RIL_UNSOL_RESPONSE(RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED, NULL, 0, socket_id);
 break;
 case 3:
            RLOGI (""Debug port: QXDM log enable."");
            qxdm_data[0] = 65536; // head.func_tag
            qxdm_data[1] = 16; // head.len
            qxdm_data[2] = 1; // mode: 1 for 'start logging'
            qxdm_data[3] = 32; // log_file_size: 32megabytes
            qxdm_data[4] = 0; // log_mask
            qxdm_data[5] = 8; // log_max_fileindex
            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,
 6 * sizeof(int), socket_id);
 break;
 case 4:
            RLOGI (""Debug port: QXDM log disable."");
            qxdm_data[0] = 65536;
            qxdm_data[1] = 16;
            qxdm_data[2] = 0; // mode: 0 for 'stop logging'
            qxdm_data[3] = 32;
            qxdm_data[4] = 0;
            qxdm_data[5] = 8;
            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,
 6 * sizeof(int), socket_id);
 break;
 case 5:
            RLOGI(""Debug port: Radio On"");
            data = 1;
            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);
            sleep(2);

             issueLocalRequest(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, NULL, 0, socket_id);
             break;
        case 6:
            RLOGI(""Debug port: Setup Data Call, Apn :%s\n"", args[1]);
            actData[0] = args[1];
            issueLocalRequest(RIL_REQUEST_SETUP_DATA_CALL, &actData,
                              sizeof(actData), socket_id);
            break;
         case 7:
             RLOGI(""Debug port: Deactivate Data Call"");
             issueLocalRequest(RIL_REQUEST_DEACTIVATE_DATA_CALL, &deactData,
 sizeof(deactData), socket_id);
 break;

         case 8:
             RLOGI(""Debug port: Dial Call"");
             dialData.clir = 0;
             dialData.address = args[1];
             issueLocalRequest(RIL_REQUEST_DIAL, &dialData, sizeof(dialData), socket_id);
             break;
 case 9:
            RLOGI(""Debug port: Answer Call"");
            issueLocalRequest(RIL_REQUEST_ANSWER, NULL, 0, socket_id);
 break;
 case 10:
            RLOGI(""Debug port: End Call"");
            issueLocalRequest(RIL_REQUEST_HANGUP, &hangupData,
 sizeof(hangupData), socket_id);
 break;
 default:
            RLOGE (""Invalid request"");
 break;
 }
    freeDebugCallbackArgs(number, args);
    close(acceptFD);
}
","static void debugCallback (int fd, short flags, void *param) {
 int acceptFD, option;
 struct sockaddr_un peeraddr;
 socklen_t socklen = sizeof (peeraddr);

     int data;
     unsigned int qxdm_data[6];
     const char *deactData[1] = {""1""};
     RIL_Dial dialData;
     int hangupData[1] = {1};
     int number;
     char **args;
     RIL_SOCKET_ID socket_id = RIL_SOCKET_1;
    int MAX_DIAL_ADDRESS = 128;
     int sim_id = 0;
 
     RLOGI(""debugCallback for socket %s"", rilSocketIdToString(socket_id));

    acceptFD = accept (fd, (sockaddr *) &peeraddr, &socklen);

 if (acceptFD < 0) {
        RLOGE (""error accepting on debug port: %d\n"", errno);
 return;
 }

 if (recv(acceptFD, &number, sizeof(int), 0) != sizeof(int)) {
        RLOGE (""error reading on socket: number of Args: \n"");
        close(acceptFD);
 return;
 }

 if (number < 0) {
        RLOGE (""Invalid number of arguments: \n"");
        close(acceptFD);
 return;
 }

    args = (char **) calloc(number, sizeof(char*));
 if (args == NULL) {
        RLOGE(""Memory allocation failed for debug args"");
        close(acceptFD);
 return;
 }

 for (int i = 0; i < number; i++) {
 int len;
 if (recv(acceptFD, &len, sizeof(int), 0) != sizeof(int)) {
            RLOGE (""error reading on socket: Len of Args: \n"");
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }
 if (len == INT_MAX || len < 0) {
            RLOGE(""Invalid value of len: \n"");
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }

        args[i] = (char *) calloc(len + 1, sizeof(char));
 if (args[i] == NULL) {
            RLOGE(""Memory allocation failed for debug args"");
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }
 if (recv(acceptFD, args[i], sizeof(char) * len, 0)
 != (int)sizeof(char) * len) {
            RLOGE (""error reading on socket: Args[%d] \n"", i);
            freeDebugCallbackArgs(i, args);
            close(acceptFD);
 return;
 }
 char * buf = args[i];
        buf[len] = 0;
 if ((i+1) == number) {
 /* The last argument should be sim id 0(SIM1)~3(SIM4) */
            sim_id = atoi(args[i]);
 switch (sim_id) {
 case 0:
                    socket_id = RIL_SOCKET_1;
 break;
 #if (SIM_COUNT >= 2)
 case 1:
                    socket_id = RIL_SOCKET_2;
 break;
 #endif
 #if (SIM_COUNT >= 3)
 case 2:
                    socket_id = RIL_SOCKET_3;
 break;
 #endif
 #if (SIM_COUNT >= 4)
 case 3:
                    socket_id = RIL_SOCKET_4;
 break;
 #endif
 default:
                    socket_id = RIL_SOCKET_1;
 break;
 }
 }
 }

 switch (atoi(args[0])) {
 case 0:
            RLOGI (""Connection on debug port: issuing reset."");
            issueLocalRequest(RIL_REQUEST_RESET_RADIO, NULL, 0, socket_id);
 break;
 case 1:
            RLOGI (""Connection on debug port: issuing radio power off."");
            data = 0;
            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);
 if (socket_id == RIL_SOCKET_1 && s_ril_param_socket.fdCommand > 0) {
                close(s_ril_param_socket.fdCommand);
                s_ril_param_socket.fdCommand = -1;
 }
 #if (SIM_COUNT == 2)
 else if (socket_id == RIL_SOCKET_2 && s_ril_param_socket2.fdCommand > 0) {
                close(s_ril_param_socket2.fdCommand);
                s_ril_param_socket2.fdCommand = -1;
 }
 #endif
 break;
 case 2:
            RLOGI (""Debug port: issuing unsolicited voice network change."");
            RIL_UNSOL_RESPONSE(RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED, NULL, 0, socket_id);
 break;
 case 3:
            RLOGI (""Debug port: QXDM log enable."");
            qxdm_data[0] = 65536; // head.func_tag
            qxdm_data[1] = 16; // head.len
            qxdm_data[2] = 1; // mode: 1 for 'start logging'
            qxdm_data[3] = 32; // log_file_size: 32megabytes
            qxdm_data[4] = 0; // log_mask
            qxdm_data[5] = 8; // log_max_fileindex
            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,
 6 * sizeof(int), socket_id);
 break;
 case 4:
            RLOGI (""Debug port: QXDM log disable."");
            qxdm_data[0] = 65536;
            qxdm_data[1] = 16;
            qxdm_data[2] = 0; // mode: 0 for 'stop logging'
            qxdm_data[3] = 32;
            qxdm_data[4] = 0;
            qxdm_data[5] = 8;
            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,
 6 * sizeof(int), socket_id);
 break;
 case 5:
            RLOGI(""Debug port: Radio On"");
            data = 1;
            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);
            sleep(2);

             issueLocalRequest(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, NULL, 0, socket_id);
             break;
         case 7:
             RLOGI(""Debug port: Deactivate Data Call"");
             issueLocalRequest(RIL_REQUEST_DEACTIVATE_DATA_CALL, &deactData,
 sizeof(deactData), socket_id);
 break;

         case 8:
             RLOGI(""Debug port: Dial Call"");
             dialData.clir = 0;
            if (strlen(args[1]) > MAX_DIAL_ADDRESS) {
                RLOGE(""Debug port: Error calling Dial"");
                freeDebugCallbackArgs(number, args);
                close(acceptFD);
                return;
            }
             dialData.address = args[1];
             issueLocalRequest(RIL_REQUEST_DIAL, &dialData, sizeof(dialData), socket_id);
             break;
 case 9:
            RLOGI(""Debug port: Answer Call"");
            issueLocalRequest(RIL_REQUEST_ANSWER, NULL, 0, socket_id);
 break;
 case 10:
            RLOGI(""Debug port: End Call"");
            issueLocalRequest(RIL_REQUEST_HANGUP, &hangupData,
 sizeof(hangupData), socket_id);
 break;
 default:
            RLOGE (""Invalid request"");
 break;
 }
    freeDebugCallbackArgs(number, args);
    close(acceptFD);
}
","The `debugCallback` function handles incoming debug commands over a socket connection, processing various requests related to radio and network operations. It begins by accepting a connection and reading the number of arguments sent. Based on the first argument, it executes specific actions such as resetting the radio, powering it off, managing network states, enabling or disabling QXDM logging, setting up or deactivating data calls, dialing, answering, or ending calls. The function also manages memory for the arguments and ensures proper error handling throughout the process, closing the socket connection upon completion.","The provided code defines a function that processes incoming debug commands through a socket connection, allowing for various radio and network operations. It begins by accepting a connection and reading the number of arguments sent by the client. Based on the first argument, it executes specific actions such as resetting the radio, managing power states, handling network changes, and controlling data calls. The function includes error handling for socket operations and memory management for the received arguments, ensuring that resources are properly released before closing the connection after processing the commands.","The vulnerability in the original code stemmed from a lack of validation for the length of the dial address, which could allow an attacker to send an excessively long string, potentially leading to buffer overflow or memory corruption. This was particularly concerning in the dial request handling, where the address was assigned without any checks. The fixed code introduces a validation step that checks if the length of the dial address exceeds a defined maximum limit. If the length is too long, an error is logged, and the function exits gracefully, thereby mitigating the risk of exploitation.","The vulnerability in the original code was due to insufficient validation of the length of a dial address, which could allow an attacker to exploit the system by sending an excessively long input, potentially leading to buffer overflow or memory corruption. This lack of checks posed a significant security risk when handling dial requests. The fixed code addresses this issue by implementing a validation mechanism that checks the length of the dial address against a predefined maximum limit. If the input exceeds this limit, an error is logged, and the function exits, effectively mitigating the risk of exploitation.","The vulnerability was fixed by adding a validation check for the length of the dial address before it is assigned. In the updated code, a condition checks if the length of the address exceeds the defined maximum limit, `MAX_DIAL_ADDRESS`. If the length is greater than this limit, an error message is logged, and the function calls `freeDebugCallbackArgs` to release any allocated memory for the arguments, followed by closing the socket with `close(acceptFD)`. This ensures that excessively long inputs are rejected, thereby preventing potential buffer overflow or memory corruption vulnerabilities.","The vulnerability was addressed by implementing a validation mechanism that checks the length of the dial address before processing it. The updated code introduces a condition that compares the length of the input against a predefined maximum limit. If the input exceeds this limit, an error is logged, and the function gracefully exits after releasing any allocated resources. This proactive approach prevents excessively long inputs from being processed, thereby mitigating the risk of buffer overflow or memory corruption, and enhancing the overall security of the system.","5,5","5,5","4,4","4,5"
118,118,187999,187999,,Remote,Not required,,CVE-2017-0817,https://www.cvedetails.com/cve/CVE-2017-0817/,CWE-200,Low,Partial,,,2017-10-03,5.0,"An information disclosure vulnerability in the Android media framework (libstagefright). Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-63522430.",2017-10-12,+Info ,7,https://android.googlesource.com/platform/frameworks/av/+/d834160d9759f1098df692b34e6eeb548f9e317b,d834160d9759f1098df692b34e6eeb548f9e317b,"Check buffer size in useBuffer in software components

Test: No more crash from oob read/write with running poc.
Bug: 63522430
Change-Id: I232d256eacdfaa9347902fe9b42650999f0d2d85
(cherry picked from commit 4e79910fdb303fd28a37a9401bed1b7fbccb1373)
",1,media/libstagefright/omx/SimpleSoftOMXComponent.cpp,"{""filename"": ""media/libstagefright/omx/SimpleSoftOMXComponent.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/d834160d9759f1098df692b34e6eeb548f9e317b/media/libstagefright/omx/SimpleSoftOMXComponent.cpp"", ""patch"": ""@@ -214,6 +214,13 @@\n\n     Mutex::Autolock autoLock(mLock);\n     CHECK_LT(portIndex, mPorts.size());\n \n+    PortInfo *port = &mPorts.editItemAt(portIndex);\n+    if (size < port->mDef.nBufferSize) {\n+        ALOGE(\""b/63522430, Buffer size is too small.\"");\n+        android_errorWriteLog(0x534e4554, \""63522430\"");\n+        return OMX_ErrorBadParameter;\n+    }\n+\n     *header = new OMX_BUFFERHEADERTYPE;\n     (*header)->nSize = sizeof(OMX_BUFFERHEADERTYPE);\n     (*header)->nVersion.s.nVersionMajor = 1;\n@@ -236,8 +243,6 @@\n\n     (*header)->nOutputPortIndex = portIndex;\n     (*header)->nInputPortIndex = portIndex;\n \n-    PortInfo *port = &mPorts.editItemAt(portIndex);\n-\n     CHECK(mState == OMX_StateLoaded || port->mDef.bEnabled == OMX_FALSE);\n \n     CHECK_LT(port->mBuffers.size(), port->mDef.nBufferCountActual);\n""}","OMX_ERRORTYPE SimpleSoftOMXComponent::useBuffer(
        OMX_BUFFERHEADERTYPE **header,
        OMX_U32 portIndex,
        OMX_PTR appPrivate,
        OMX_U32 size,
        OMX_U8 *ptr) {

     Mutex::Autolock autoLock(mLock);
     CHECK_LT(portIndex, mPorts.size());
 
    PortInfo *port = &mPorts.editItemAt(portIndex);
    if (size < port->mDef.nBufferSize) {
        ALOGE(""b/63522430, Buffer size is too small."");
        android_errorWriteLog(0x534e4554, ""63522430"");
        return OMX_ErrorBadParameter;
    }

     *header = new OMX_BUFFERHEADERTYPE;
     (*header)->nSize = sizeof(OMX_BUFFERHEADERTYPE);
     (*header)->nVersion.s.nVersionMajor = 1;
 (*header)->nVersion.s.nVersionMinor = 0;
 (*header)->nVersion.s.nRevision = 0;
 (*header)->nVersion.s.nStep = 0;
 (*header)->pBuffer = ptr;
 (*header)->nAllocLen = size;
 (*header)->nFilledLen = 0;
 (*header)->nOffset = 0;
 (*header)->pAppPrivate = appPrivate;
 (*header)->pPlatformPrivate = NULL;
 (*header)->pInputPortPrivate = NULL;
 (*header)->pOutputPortPrivate = NULL;
 (*header)->hMarkTargetComponent = NULL;
 (*header)->pMarkData = NULL;
 (*header)->nTickCount = 0;
 (*header)->nTimeStamp = 0;
 (*header)->nFlags = 0;

     (*header)->nOutputPortIndex = portIndex;
     (*header)->nInputPortIndex = portIndex;
 
     CHECK(mState == OMX_StateLoaded || port->mDef.bEnabled == OMX_FALSE);
 
     CHECK_LT(port->mBuffers.size(), port->mDef.nBufferCountActual);

    port->mBuffers.push();

 BufferInfo *buffer =
 &port->mBuffers.editItemAt(port->mBuffers.size() - 1);

    buffer->mHeader = *header;
    buffer->mOwnedByUs = false;

 if (port->mBuffers.size() == port->mDef.nBufferCountActual) {
        port->mDef.bPopulated = OMX_TRUE;
        checkTransitions();
 }

 return OMX_ErrorNone;
}
","OMX_ERRORTYPE SimpleSoftOMXComponent::useBuffer(
        OMX_BUFFERHEADERTYPE **header,
        OMX_U32 portIndex,
        OMX_PTR appPrivate,
        OMX_U32 size,
        OMX_U8 *ptr) {

     Mutex::Autolock autoLock(mLock);
     CHECK_LT(portIndex, mPorts.size());
 
     *header = new OMX_BUFFERHEADERTYPE;
     (*header)->nSize = sizeof(OMX_BUFFERHEADERTYPE);
     (*header)->nVersion.s.nVersionMajor = 1;
 (*header)->nVersion.s.nVersionMinor = 0;
 (*header)->nVersion.s.nRevision = 0;
 (*header)->nVersion.s.nStep = 0;
 (*header)->pBuffer = ptr;
 (*header)->nAllocLen = size;
 (*header)->nFilledLen = 0;
 (*header)->nOffset = 0;
 (*header)->pAppPrivate = appPrivate;
 (*header)->pPlatformPrivate = NULL;
 (*header)->pInputPortPrivate = NULL;
 (*header)->pOutputPortPrivate = NULL;
 (*header)->hMarkTargetComponent = NULL;
 (*header)->pMarkData = NULL;
 (*header)->nTickCount = 0;
 (*header)->nTimeStamp = 0;
 (*header)->nFlags = 0;

     (*header)->nOutputPortIndex = portIndex;
     (*header)->nInputPortIndex = portIndex;
 
    PortInfo *port = &mPorts.editItemAt(portIndex);
     CHECK(mState == OMX_StateLoaded || port->mDef.bEnabled == OMX_FALSE);
 
     CHECK_LT(port->mBuffers.size(), port->mDef.nBufferCountActual);

    port->mBuffers.push();

 BufferInfo *buffer =
 &port->mBuffers.editItemAt(port->mBuffers.size() - 1);

    buffer->mHeader = *header;
    buffer->mOwnedByUs = false;

 if (port->mBuffers.size() == port->mDef.nBufferCountActual) {
        port->mDef.bPopulated = OMX_TRUE;
        checkTransitions();
 }

 return OMX_ErrorNone;
}
",C,"    PortInfo *port = &mPorts.editItemAt(portIndex);
    if (size < port->mDef.nBufferSize) {
        ALOGE(""b/63522430, Buffer size is too small."");
        android_errorWriteLog(0x534e4554, ""63522430"");
        return OMX_ErrorBadParameter;
    }

","    PortInfo *port = &mPorts.editItemAt(portIndex);
",,"@@ -214,6 +214,13 @@

     Mutex::Autolock autoLock(mLock);
     CHECK_LT(portIndex, mPorts.size());
 
+    PortInfo *port = &mPorts.editItemAt(portIndex);
+    if (size < port->mDef.nBufferSize) {
+        ALOGE(""b/63522430, Buffer size is too small."");
+        android_errorWriteLog(0x534e4554, ""63522430"");
+        return OMX_ErrorBadParameter;
+    }
+
     *header = new OMX_BUFFERHEADERTYPE;
     (*header)->nSize = sizeof(OMX_BUFFERHEADERTYPE);
     (*header)->nVersion.s.nVersionMajor = 1;
@@ -236,8 +243,6 @@

     (*header)->nOutputPortIndex = portIndex;
     (*header)->nInputPortIndex = portIndex;
 
-    PortInfo *port = &mPorts.editItemAt(portIndex);
-
     CHECK(mState == OMX_StateLoaded || port->mDef.bEnabled == OMX_FALSE);
 
     CHECK_LT(port->mBuffers.size(), port->mDef.nBufferCountActual);
",Android,https://android.googlesource.com/platform/frameworks/av/+/d834160d9759f1098df692b34e6eeb548f9e317b/,https://android.googlesource.com/platform/frameworks/av/+/d834160d9759f1098df692b34e6eeb548f9e317b%5E/,1,"OMX_ERRORTYPE SimpleSoftOMXComponent::useBuffer(
        OMX_BUFFERHEADERTYPE **header,
        OMX_U32 portIndex,
        OMX_PTR appPrivate,
        OMX_U32 size,
        OMX_U8 *ptr) {

     Mutex::Autolock autoLock(mLock);
     CHECK_LT(portIndex, mPorts.size());
 
//fix_flaw_line_below:
//    PortInfo *port = &mPorts.editItemAt(portIndex);
//fix_flaw_line_below:
//    if (size < port->mDef.nBufferSize) {
//fix_flaw_line_below:
//        ALOGE(""b/63522430, Buffer size is too small."");
//fix_flaw_line_below:
//        android_errorWriteLog(0x534e4554, ""63522430"");
//fix_flaw_line_below:
//        return OMX_ErrorBadParameter;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     *header = new OMX_BUFFERHEADERTYPE;
     (*header)->nSize = sizeof(OMX_BUFFERHEADERTYPE);
     (*header)->nVersion.s.nVersionMajor = 1;
 (*header)->nVersion.s.nVersionMinor = 0;
 (*header)->nVersion.s.nRevision = 0;
 (*header)->nVersion.s.nStep = 0;
 (*header)->pBuffer = ptr;
 (*header)->nAllocLen = size;
 (*header)->nFilledLen = 0;
 (*header)->nOffset = 0;
 (*header)->pAppPrivate = appPrivate;
 (*header)->pPlatformPrivate = NULL;
 (*header)->pInputPortPrivate = NULL;
 (*header)->pOutputPortPrivate = NULL;
 (*header)->hMarkTargetComponent = NULL;
 (*header)->pMarkData = NULL;
 (*header)->nTickCount = 0;
 (*header)->nTimeStamp = 0;
 (*header)->nFlags = 0;

     (*header)->nOutputPortIndex = portIndex;
     (*header)->nInputPortIndex = portIndex;
 
//flaw_line_below:
    PortInfo *port = &mPorts.editItemAt(portIndex);
//flaw_line_below:

     CHECK(mState == OMX_StateLoaded || port->mDef.bEnabled == OMX_FALSE);
 
     CHECK_LT(port->mBuffers.size(), port->mDef.nBufferCountActual);

    port->mBuffers.push();

 BufferInfo *buffer =
 &port->mBuffers.editItemAt(port->mBuffers.size() - 1);

    buffer->mHeader = *header;
    buffer->mOwnedByUs = false;

 if (port->mBuffers.size() == port->mDef.nBufferCountActual) {
        port->mDef.bPopulated = OMX_TRUE;
        checkTransitions();
 }

 return OMX_ErrorNone;
}
",187999,"OMX_ERRORTYPE SimpleSoftOMXComponent::useBuffer(
        OMX_BUFFERHEADERTYPE **header,
        OMX_U32 portIndex,
        OMX_PTR appPrivate,
        OMX_U32 size,
        OMX_U8 *ptr) {

     Mutex::Autolock autoLock(mLock);
     CHECK_LT(portIndex, mPorts.size());
 
     *header = new OMX_BUFFERHEADERTYPE;
     (*header)->nSize = sizeof(OMX_BUFFERHEADERTYPE);
     (*header)->nVersion.s.nVersionMajor = 1;
 (*header)->nVersion.s.nVersionMinor = 0;
 (*header)->nVersion.s.nRevision = 0;
 (*header)->nVersion.s.nStep = 0;
 (*header)->pBuffer = ptr;
 (*header)->nAllocLen = size;
 (*header)->nFilledLen = 0;
 (*header)->nOffset = 0;
 (*header)->pAppPrivate = appPrivate;
 (*header)->pPlatformPrivate = NULL;
 (*header)->pInputPortPrivate = NULL;
 (*header)->pOutputPortPrivate = NULL;
 (*header)->hMarkTargetComponent = NULL;
 (*header)->pMarkData = NULL;
 (*header)->nTickCount = 0;
 (*header)->nTimeStamp = 0;
 (*header)->nFlags = 0;

     (*header)->nOutputPortIndex = portIndex;
     (*header)->nInputPortIndex = portIndex;
 
    PortInfo *port = &mPorts.editItemAt(portIndex);
     CHECK(mState == OMX_StateLoaded || port->mDef.bEnabled == OMX_FALSE);
 
     CHECK_LT(port->mBuffers.size(), port->mDef.nBufferCountActual);

    port->mBuffers.push();

 BufferInfo *buffer =
 &port->mBuffers.editItemAt(port->mBuffers.size() - 1);

    buffer->mHeader = *header;
    buffer->mOwnedByUs = false;

 if (port->mBuffers.size() == port->mDef.nBufferCountActual) {
        port->mDef.bPopulated = OMX_TRUE;
        checkTransitions();
 }

 return OMX_ErrorNone;
}
","OMX_ERRORTYPE SimpleSoftOMXComponent::useBuffer(
        OMX_BUFFERHEADERTYPE **header,
        OMX_U32 portIndex,
        OMX_PTR appPrivate,
        OMX_U32 size,
        OMX_U8 *ptr) {

     Mutex::Autolock autoLock(mLock);
     CHECK_LT(portIndex, mPorts.size());
 
    PortInfo *port = &mPorts.editItemAt(portIndex);
    if (size < port->mDef.nBufferSize) {
        ALOGE(""b/63522430, Buffer size is too small."");
        android_errorWriteLog(0x534e4554, ""63522430"");
        return OMX_ErrorBadParameter;
    }

     *header = new OMX_BUFFERHEADERTYPE;
     (*header)->nSize = sizeof(OMX_BUFFERHEADERTYPE);
     (*header)->nVersion.s.nVersionMajor = 1;
 (*header)->nVersion.s.nVersionMinor = 0;
 (*header)->nVersion.s.nRevision = 0;
 (*header)->nVersion.s.nStep = 0;
 (*header)->pBuffer = ptr;
 (*header)->nAllocLen = size;
 (*header)->nFilledLen = 0;
 (*header)->nOffset = 0;
 (*header)->pAppPrivate = appPrivate;
 (*header)->pPlatformPrivate = NULL;
 (*header)->pInputPortPrivate = NULL;
 (*header)->pOutputPortPrivate = NULL;
 (*header)->hMarkTargetComponent = NULL;
 (*header)->pMarkData = NULL;
 (*header)->nTickCount = 0;
 (*header)->nTimeStamp = 0;
 (*header)->nFlags = 0;

     (*header)->nOutputPortIndex = portIndex;
     (*header)->nInputPortIndex = portIndex;
 
     CHECK(mState == OMX_StateLoaded || port->mDef.bEnabled == OMX_FALSE);
 
     CHECK_LT(port->mBuffers.size(), port->mDef.nBufferCountActual);

    port->mBuffers.push();

 BufferInfo *buffer =
 &port->mBuffers.editItemAt(port->mBuffers.size() - 1);

    buffer->mHeader = *header;
    buffer->mOwnedByUs = false;

 if (port->mBuffers.size() == port->mDef.nBufferCountActual) {
        port->mDef.bPopulated = OMX_TRUE;
        checkTransitions();
 }

 return OMX_ErrorNone;
}
","The `useBuffer` function in the `SimpleSoftOMXComponent` class is designed to allocate and initialize an `OMX_BUFFERHEADERTYPE` structure for a specified port index. It first locks a mutex to ensure thread safety and checks that the provided port index is valid. The function then creates a new buffer header, setting various properties such as size, version, buffer pointer, allocation length, and private data pointers. It associates the buffer with the specified port, verifies the component's state, and checks if the number of buffers has reached the defined limit, updating the port's populated status accordingly. Finally, it returns an error code indicating success.","The provided code defines a function that allocates and initializes a buffer header for a multimedia component, ensuring thread safety during the process. It checks the validity of the specified port index and creates a new buffer header with various properties, including size, version, and buffer pointer. The function associates the buffer with the appropriate port and verifies the component's state, ensuring that the number of allocated buffers does not exceed a predefined limit. If the limit is reached, it updates the port's status to indicate that it is populated. The function concludes by returning a success indicator.","The vulnerability in the original code stemmed from a lack of validation for the buffer size before allocating a new buffer header, which could lead to out-of-bounds read/write operations if the provided size was smaller than the expected buffer size. This oversight could cause crashes or undefined behavior. The fixed code addresses this issue by introducing a check that compares the provided size against the expected buffer size defined in `port->mDef.nBufferSize`. If the size is insufficient, an error is logged, and the function returns an error code, thereby preventing potential memory corruption and ensuring safer buffer management.","The vulnerability in the original code arose from the absence of a check for the buffer size before allocating memory, which could lead to out-of-bounds read or write operations if an insufficient size was provided. This flaw could result in crashes or unpredictable behavior when the software attempted to access memory outside the allocated range. The fix implemented a validation step that compares the provided buffer size against a predefined expected size. If the provided size is too small, an error is logged, and the function returns an error code, effectively preventing potential memory corruption and enhancing overall stability.","The vulnerability was fixed by adding a validation check for the buffer size in the `useBuffer` function. Before allocating a new buffer header, the code now compares the provided size against `port->mDef.nBufferSize`. If the provided size is smaller, an error message is logged using `ALOGE`, and the function returns `OMX_ErrorBadParameter`. This ensures that only appropriately sized buffers are allocated, preventing out-of-bounds read/write operations that could lead to crashes or undefined behavior. This change enhances the robustness of the buffer management process within the software component.","The vulnerability was addressed by implementing a validation step that checks the size of the buffer before any memory allocation occurs. This new check ensures that the provided buffer size meets the required minimum threshold, preventing the allocation of insufficiently sized buffers. If the provided size is found to be inadequate, an error is logged, and the function returns an error code instead of proceeding with the allocation. This fix effectively mitigates the risk of out-of-bounds read or write operations, enhancing the stability and security of the software component.","4,5","5,5","4,4","5,5"
119,119,188057,188057,,Remote,Not required,,CVE-2017-0557,https://www.cvedetails.com/cve/CVE-2017-0557/,CWE-200,Medium,Partial,,,2017-04-07,4.3,"An information disclosure vulnerability in libmpeg2 in Mediaserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access data without permission. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-34093073.",2017-07-10,+Info ,17,https://android.googlesource.com/platform/external/libmpeg2/+/227c1f829127405e21dab1664393050c652ef71e,227c1f829127405e21dab1664393050c652ef71e,"Error Check for VLD Symbols Read

The maximum number of lead zeros in a VLD symbol (17 bits long) is 11.

Bug: 34093073
Change-Id: Ifd3f64a3a5199d6e4c33ca65449fc396cfb2f3fc
(cherry picked from commit 75e0ad5127752ce37e3fc78a156652e5da435f14)
",0,decoder/impeg2d_vld.c,"{""filename"": ""decoder/impeg2d_vld.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/227c1f829127405e21dab1664393050c652ef71e/decoder/impeg2d_vld.c"", ""patch"": ""@@ -638,6 +638,15 @@\n\n                 u4_sym_len = 17;\n                 IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,u4_sym_len)\n \n+                /* There cannot be more than 11 leading zeros in the decoded\n+                 * symbol. The symbol is only 17 bits long, so we subtract 15.\n+                 */\n+                lead_zeros = CLZ(u4_bits) - 15;\n+                if (lead_zeros > 11)\n+                {\n+                    return IMPEG2D_MB_DATA_DECODE_ERR;\n+                }\n+\n                 DecodedValue = gau2_impeg2d_tab_one_1_9[u4_bits >> 8];\n                 u4_sym_len = (DecodedValue & 0xf);\n                 u4_level = DecodedValue >> 9;\n@@ -809,6 +818,14 @@\n\n                 u4_sym_len = 17;\n                 IBITS_NXT(u4_buf, u4_buf_nxt, u4_offset, u4_bits, u4_sym_len)\n \n+                /* There cannot be more than 11 leading zeros in the decoded\n+                 * symbol. The symbol is only 17 bits long, so we subtract 15.\n+                 */\n+                lead_zeros = CLZ(u4_bits) - 15;\n+                if (lead_zeros > 11)\n+                {\n+                    return IMPEG2D_MB_DATA_DECODE_ERR;\n+                }\n \n                 DecodedValue = gau2_impeg2d_tab_zero_1_9[u4_bits >> 8];\n                 u4_sym_len = BITS(DecodedValue, 3, 0);\n""}","IMPEG2D_ERROR_CODES_T impeg2d_vld_decode(
 dec_state_t *ps_dec,
    WORD16      *pi2_outAddr, /*!< Address where decoded symbols will be stored */
 const UWORD8 *pu1_scan, /*!< Scan table to be used */
    UWORD8      *pu1_pos, /*!< Scan table to be used */
    UWORD16     u2_intra_flag, /*!< Intra Macroblock or not */
    UWORD16     u2_chroma_flag, /*!< Chroma Block or not */
    UWORD16     u2_d_picture, /*!< D Picture or not */
    UWORD16     u2_intra_vlc_format, /*!< Intra VLC format */
    UWORD16     u2_mpeg2, /*!< MPEG-2 or not */
    WORD32      *pi4_num_coeffs /*!< Returns the number of coeffs in block */
 )
{

    UWORD32 u4_sym_len;

    UWORD32 u4_decoded_value;
    UWORD32 u4_level_first_byte;
    WORD32  u4_level;
    UWORD32 u4_run, u4_numCoeffs;
    UWORD32 u4_buf;
    UWORD32 u4_buf_nxt;
    UWORD32 u4_offset;
    UWORD32 *pu4_buf_aligned;
    UWORD32 u4_bits;
 stream_t *ps_stream = &ps_dec->s_bit_stream;
    WORD32  u4_pos;
    UWORD32 u4_nz_cols;
    UWORD32 u4_nz_rows;

 *pi4_num_coeffs = 0;

    ps_dec->u4_non_zero_cols = 0;
    ps_dec->u4_non_zero_rows = 0;
    u4_nz_cols = ps_dec->u4_non_zero_cols;
    u4_nz_rows = ps_dec->u4_non_zero_rows;

    GET_TEMP_STREAM_DATA(u4_buf,u4_buf_nxt,u4_offset,pu4_buf_aligned,ps_stream)
 /**************************************************************************/
 /* Decode the DC coefficient in case of Intra block                       */
 /**************************************************************************/
 if(u2_intra_flag)
 {
        WORD32 dc_size;
        WORD32 dc_diff;
        WORD32 maxLen;
        WORD32 idx;


        maxLen = MPEG2_DCT_DC_SIZE_LEN;
        idx = 0;
 if(u2_chroma_flag != 0)
 {
            maxLen += 1;
            idx++;
 }


 {
            WORD16  end = 0;
            UWORD32 maxLen_tmp = maxLen;
            UWORD16 m_iBit;


 /* Get the maximum number of bits needed to decode a symbol */
            IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,maxLen)
 do
 {
                maxLen_tmp--;
 /* Read one bit at a time from the variable to decode the huffman code */
                m_iBit = (UWORD8)((u4_bits >> maxLen_tmp) & 0x1);

 /* Get the next node pointer or the symbol from the tree */
                end = gai2_impeg2d_dct_dc_size[idx][end][m_iBit];
 }while(end > 0);
            dc_size = end + MPEG2_DCT_DC_SIZE_OFFSET;

 /* Flush the appropriate number of bits from the stream */
            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,(maxLen - maxLen_tmp),pu4_buf_aligned)

 }



 if (dc_size != 0)
 {
            UWORD32 u4_bits;

            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, dc_size)
            dc_diff = u4_bits;

 if ((dc_diff & (1 << (dc_size - 1))) == 0) //v Probably the prediction algo?
                dc_diff -= (1 << dc_size) - 1;
 }
 else
 {
            dc_diff = 0;
 }


        pi2_outAddr[*pi4_num_coeffs] = dc_diff;
 /* This indicates the position of the coefficient. Since this is the DC
         * coefficient, we put the position as 0.
         */
        pu1_pos[*pi4_num_coeffs] = pu1_scan[0];
 (*pi4_num_coeffs)++;

 if (0 != dc_diff)
 {
            u4_nz_cols |= 0x01;
            u4_nz_rows |= 0x01;
 }

        u4_numCoeffs = 1;
 }
 /**************************************************************************/
 /* Decoding of first AC coefficient in case of non Intra block            */
 /**************************************************************************/
 else
 {
 /* First symbol can be 1s */
        UWORD32 u4_bits;

        IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,1)

 if(u4_bits == 1)
 {

            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,1, pu4_buf_aligned)
            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, 1)
 if(u4_bits == 1)
 {
                pi2_outAddr[*pi4_num_coeffs] = -1;
 }
 else
 {
                pi2_outAddr[*pi4_num_coeffs] = 1;
 }

 /* This indicates the position of the coefficient. Since this is the DC
             * coefficient, we put the position as 0.
             */
            pu1_pos[*pi4_num_coeffs] = pu1_scan[0];
 (*pi4_num_coeffs)++;
            u4_numCoeffs = 1;

            u4_nz_cols |= 0x01;
            u4_nz_rows |= 0x01;
 }
 else
 {
            u4_numCoeffs = 0;
 }
 }
 if (1 == u2_d_picture)
 {
        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)
        ps_dec->u4_non_zero_cols  = u4_nz_cols;
        ps_dec->u4_non_zero_rows  = u4_nz_rows;
 return ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE);
 }



 if (1 == u2_intra_vlc_format && u2_intra_flag)
 {

 while(1)
 {

                UWORD32 lead_zeros;
                WORD16 DecodedValue;


                 u4_sym_len = 17;
                 IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,u4_sym_len)
 
                /* There cannot be more than 11 leading zeros in the decoded
                 * symbol. The symbol is only 17 bits long, so we subtract 15.
                 */
                lead_zeros = CLZ(u4_bits) - 15;
                if (lead_zeros > 11)
                {
                    return IMPEG2D_MB_DATA_DECODE_ERR;
                }

                 DecodedValue = gau2_impeg2d_tab_one_1_9[u4_bits >> 8];
                 u4_sym_len = (DecodedValue & 0xf);
                 u4_level = DecodedValue >> 9;
 /* One table lookup */
 if(0 != u4_level)
 {
                    u4_run = ((DecodedValue >> 4) & 0x1f);
                    u4_numCoeffs       += u4_run;
                    u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
                    pu1_pos[*pi4_num_coeffs] = u4_pos;

                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                    pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 else
 {
 if (DecodedValue == END_OF_BLOCK_ONE)
 {
                        u4_sym_len = 4;

 break;
 }
 else
 {
 /*Second table lookup*/
                        lead_zeros = CLZ(u4_bits) - 20;/* -16 since we are dealing with WORD32 */
 if (0 != lead_zeros)
 {

                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;

 /* Flush the number of bits */
 if (1 == lead_zeros)
 {
                                u4_sym_len         = ((u4_bits & 0x18) >> 3) == 2 ? 11:10;
 }
 else
 {
                                u4_sym_len         = 11 + lead_zeros;
 }
 /* flushing */
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)

 /* Calculate the address */
                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;

 DecodedValue = gau2_impeg2d_tab_one_10_16[u4_bits];

                            u4_run = BITS(DecodedValue, 8,4);
                            u4_level = ((WORD16) DecodedValue) >> 9;

                            u4_numCoeffs       += u4_run;
                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 /*********************************************************************/
 /* MPEG2 Escape Code                                                 */
 /*********************************************************************/
 else if(u2_mpeg2 == 1)
 {
                            u4_sym_len         = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)
                                u4_decoded_value    = u4_bits;
                            u4_run             = (u4_decoded_value >> 12);
                            u4_level           = (u4_decoded_value & 0x0FFF);

 if (u4_level)
                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));

                            u4_numCoeffs       += u4_run;
                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 /*********************************************************************/
 /* MPEG1 Escape Code                                                 */
 /*********************************************************************/
 else
 {
 /*-----------------------------------------------------------
                            * MPEG-1 Stream
                            *
                            * <See D.9.3 of MPEG-2> Run-level escape syntax
                            * Run-level values that cannot be coded with a VLC are coded
                            * by the escape code '0000 01' followed by
                            * either a 14-bit FLC (127 <= level <= 127),
                            * or a 22-bit FLC (255 <= level <= 255).
                            * This is described in Annex B,B.5f of MPEG-1.standard
                            *-----------------------------------------------------------*/

 /*-----------------------------------------------------------
                            * First 6 bits are the value of the Run. Next is First 8 bits
                            * of Level. These bits decide whether it is 14 bit FLC or
                            * 22-bit FLC.
                            *
                            * If( first 8 bits of Level == '1000000' or '00000000')
                            *      then its is 22-bit FLC.
                            * else
                            *      it is 14-bit FLC.
                            *-----------------------------------------------------------*/
                            u4_sym_len         = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)
                                u4_decoded_value     = u4_bits;
                            u4_run              = (u4_decoded_value >> 8);
                            u4_level_first_byte = (u4_decoded_value & 0x0FF);
 if(u4_level_first_byte & 0x7F)
 {
 /*-------------------------------------------------------
                                * First 8 bits of level are neither 1000000 nor 00000000
                                * Hence 14-bit FLC (Last 8 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_First_Byte - 256 : Level_First_Byte
                                *-------------------------------------------------------*/
                                u4_level = (u4_level_first_byte -
 ((u4_level_first_byte & 0x80) << 1));
 }
 else
 {
 /*-------------------------------------------------------
                                * Next 8 bits are either 1000000 or 00000000
                                * Hence 22-bit FLC (Last 16 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_Second_Byte - 256 : Level_Second_Byte
                                *-------------------------------------------------------*/
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)
                                    u4_level = u4_bits;
                                u4_level = (u4_level - (u4_level_first_byte << 1));
 }
                            u4_numCoeffs += u4_run;

                            u4_pos = pu1_scan[u4_numCoeffs++ & 63];

                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 }
 }

                u4_nz_cols |= 1 << (u4_pos & 0x7);
                u4_nz_rows |= 1 << (u4_pos >> 0x3);

 if (u4_numCoeffs > 64)
 {
 return IMPEG2D_MB_TEX_DECODE_ERR;
 }

 }
            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)
 }
 else
 {
 while(1)
 {

                UWORD32 lead_zeros;
                UWORD16 DecodedValue;


                 u4_sym_len = 17;
                 IBITS_NXT(u4_buf, u4_buf_nxt, u4_offset, u4_bits, u4_sym_len)
 
                /* There cannot be more than 11 leading zeros in the decoded
                 * symbol. The symbol is only 17 bits long, so we subtract 15.
                 */
                lead_zeros = CLZ(u4_bits) - 15;
                if (lead_zeros > 11)
                {
                    return IMPEG2D_MB_DATA_DECODE_ERR;
                }
 
                 DecodedValue = gau2_impeg2d_tab_zero_1_9[u4_bits >> 8];
                 u4_sym_len = BITS(DecodedValue, 3, 0);
                u4_level = ((WORD16) DecodedValue) >> 9;

 if (0 != u4_level)
 {
                    u4_run = BITS(DecodedValue, 8,4);

                    u4_numCoeffs       += u4_run;

                    u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                    pu1_pos[*pi4_num_coeffs] = u4_pos;

                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                    pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 else
 {
 if(DecodedValue == END_OF_BLOCK_ZERO)
 {
                        u4_sym_len = 2;

 break;
 }
 else
 {
                        lead_zeros = CLZ(u4_bits) - 20;/* -15 since we are dealing with WORD32 */
 /*Second table lookup*/
 if (0 != lead_zeros)
 {
                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;

 /* Flush the number of bits */
                            u4_sym_len         = 11 + lead_zeros;

 /* Calculate the address */
                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;

 DecodedValue = gau2_impeg2d_tab_zero_10_16[u4_bits];

                            u4_run = BITS(DecodedValue, 8,4);
                            u4_level = ((WORD16) DecodedValue) >> 9;

                            u4_numCoeffs       += u4_run;

                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
 if (1 == lead_zeros)
                                u4_sym_len--;
 /* flushing */
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 /*Escape Sequence*/
 else if(u2_mpeg2 == 1)
 {
                            u4_sym_len         = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)
                            u4_decoded_value    = u4_bits;
                            u4_run             = (u4_decoded_value >> 12);
                            u4_level           = (u4_decoded_value & 0x0FFF);

 if (u4_level)
                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));

                            u4_numCoeffs           += u4_run;

                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 /*********************************************************************/
 /* MPEG1 Escape Code                                                 */
 /*********************************************************************/
 else
 {
 /*-----------------------------------------------------------
                            * MPEG-1 Stream
                            *
                            * <See D.9.3 of MPEG-2> Run-level escape syntax
                            * Run-level values that cannot be coded with a VLC are coded
                            * by the escape code '0000 01' followed by
                            * either a 14-bit FLC (127 <= level <= 127),
                            * or a 22-bit FLC (255 <= level <= 255).
                            * This is described in Annex B,B.5f of MPEG-1.standard
                            *-----------------------------------------------------------*/

 /*-----------------------------------------------------------
                            * First 6 bits are the value of the Run. Next is First 8 bits
                            * of Level. These bits decide whether it is 14 bit FLC or
                            * 22-bit FLC.
                            *
                            * If( first 8 bits of Level == '1000000' or '00000000')
                            *      then its is 22-bit FLC.
                            * else
                            *      it is 14-bit FLC.
                            *-----------------------------------------------------------*/
                            u4_sym_len             = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)
                            u4_decoded_value        = u4_bits;
                            u4_run                 = (u4_decoded_value >> 8);
                            u4_level_first_byte    = (u4_decoded_value & 0x0FF);
 if(u4_level_first_byte & 0x7F)
 {
 /*-------------------------------------------------------
                                * First 8 bits of level are neither 1000000 nor 00000000
                                * Hence 14-bit FLC (Last 8 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_First_Byte - 256 : Level_First_Byte
                                *-------------------------------------------------------*/
                                u4_level = (u4_level_first_byte -
 ((u4_level_first_byte & 0x80) << 1));
 }
 else
 {
 /*-------------------------------------------------------
                                * Next 8 bits are either 1000000 or 00000000
                                * Hence 22-bit FLC (Last 16 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_Second_Byte - 256 : Level_Second_Byte
                                *-------------------------------------------------------*/
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)
                                u4_level = u4_bits;
                                u4_level = (u4_level - (u4_level_first_byte << 1));
 }
                            u4_numCoeffs           += u4_run;

                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 }
 }

                u4_nz_cols |= 1 << (u4_pos & 0x7);
                u4_nz_rows |= 1 << (u4_pos >> 0x3);
 if (u4_numCoeffs > 64)
 {
 return IMPEG2D_MB_TEX_DECODE_ERR;
 }

 }

            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)

 }

        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)

        ps_dec->u4_non_zero_cols  = u4_nz_cols;
        ps_dec->u4_non_zero_rows  = u4_nz_rows;

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
","IMPEG2D_ERROR_CODES_T impeg2d_vld_decode(
 dec_state_t *ps_dec,
    WORD16      *pi2_outAddr, /*!< Address where decoded symbols will be stored */
 const UWORD8 *pu1_scan, /*!< Scan table to be used */
    UWORD8      *pu1_pos, /*!< Scan table to be used */
    UWORD16     u2_intra_flag, /*!< Intra Macroblock or not */
    UWORD16     u2_chroma_flag, /*!< Chroma Block or not */
    UWORD16     u2_d_picture, /*!< D Picture or not */
    UWORD16     u2_intra_vlc_format, /*!< Intra VLC format */
    UWORD16     u2_mpeg2, /*!< MPEG-2 or not */
    WORD32      *pi4_num_coeffs /*!< Returns the number of coeffs in block */
 )
{

    UWORD32 u4_sym_len;

    UWORD32 u4_decoded_value;
    UWORD32 u4_level_first_byte;
    WORD32  u4_level;
    UWORD32 u4_run, u4_numCoeffs;
    UWORD32 u4_buf;
    UWORD32 u4_buf_nxt;
    UWORD32 u4_offset;
    UWORD32 *pu4_buf_aligned;
    UWORD32 u4_bits;
 stream_t *ps_stream = &ps_dec->s_bit_stream;
    WORD32  u4_pos;
    UWORD32 u4_nz_cols;
    UWORD32 u4_nz_rows;

 *pi4_num_coeffs = 0;

    ps_dec->u4_non_zero_cols = 0;
    ps_dec->u4_non_zero_rows = 0;
    u4_nz_cols = ps_dec->u4_non_zero_cols;
    u4_nz_rows = ps_dec->u4_non_zero_rows;

    GET_TEMP_STREAM_DATA(u4_buf,u4_buf_nxt,u4_offset,pu4_buf_aligned,ps_stream)
 /**************************************************************************/
 /* Decode the DC coefficient in case of Intra block                       */
 /**************************************************************************/
 if(u2_intra_flag)
 {
        WORD32 dc_size;
        WORD32 dc_diff;
        WORD32 maxLen;
        WORD32 idx;


        maxLen = MPEG2_DCT_DC_SIZE_LEN;
        idx = 0;
 if(u2_chroma_flag != 0)
 {
            maxLen += 1;
            idx++;
 }


 {
            WORD16  end = 0;
            UWORD32 maxLen_tmp = maxLen;
            UWORD16 m_iBit;


 /* Get the maximum number of bits needed to decode a symbol */
            IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,maxLen)
 do
 {
                maxLen_tmp--;
 /* Read one bit at a time from the variable to decode the huffman code */
                m_iBit = (UWORD8)((u4_bits >> maxLen_tmp) & 0x1);

 /* Get the next node pointer or the symbol from the tree */
                end = gai2_impeg2d_dct_dc_size[idx][end][m_iBit];
 }while(end > 0);
            dc_size = end + MPEG2_DCT_DC_SIZE_OFFSET;

 /* Flush the appropriate number of bits from the stream */
            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,(maxLen - maxLen_tmp),pu4_buf_aligned)

 }



 if (dc_size != 0)
 {
            UWORD32 u4_bits;

            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, dc_size)
            dc_diff = u4_bits;

 if ((dc_diff & (1 << (dc_size - 1))) == 0) //v Probably the prediction algo?
                dc_diff -= (1 << dc_size) - 1;
 }
 else
 {
            dc_diff = 0;
 }


        pi2_outAddr[*pi4_num_coeffs] = dc_diff;
 /* This indicates the position of the coefficient. Since this is the DC
         * coefficient, we put the position as 0.
         */
        pu1_pos[*pi4_num_coeffs] = pu1_scan[0];
 (*pi4_num_coeffs)++;

 if (0 != dc_diff)
 {
            u4_nz_cols |= 0x01;
            u4_nz_rows |= 0x01;
 }

        u4_numCoeffs = 1;
 }
 /**************************************************************************/
 /* Decoding of first AC coefficient in case of non Intra block            */
 /**************************************************************************/
 else
 {
 /* First symbol can be 1s */
        UWORD32 u4_bits;

        IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,1)

 if(u4_bits == 1)
 {

            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,1, pu4_buf_aligned)
            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, 1)
 if(u4_bits == 1)
 {
                pi2_outAddr[*pi4_num_coeffs] = -1;
 }
 else
 {
                pi2_outAddr[*pi4_num_coeffs] = 1;
 }

 /* This indicates the position of the coefficient. Since this is the DC
             * coefficient, we put the position as 0.
             */
            pu1_pos[*pi4_num_coeffs] = pu1_scan[0];
 (*pi4_num_coeffs)++;
            u4_numCoeffs = 1;

            u4_nz_cols |= 0x01;
            u4_nz_rows |= 0x01;
 }
 else
 {
            u4_numCoeffs = 0;
 }
 }
 if (1 == u2_d_picture)
 {
        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)
        ps_dec->u4_non_zero_cols  = u4_nz_cols;
        ps_dec->u4_non_zero_rows  = u4_nz_rows;
 return ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE);
 }



 if (1 == u2_intra_vlc_format && u2_intra_flag)
 {

 while(1)
 {

                UWORD32 lead_zeros;
                WORD16 DecodedValue;


                 u4_sym_len = 17;
                 IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,u4_sym_len)
 
                 DecodedValue = gau2_impeg2d_tab_one_1_9[u4_bits >> 8];
                 u4_sym_len = (DecodedValue & 0xf);
                 u4_level = DecodedValue >> 9;
 /* One table lookup */
 if(0 != u4_level)
 {
                    u4_run = ((DecodedValue >> 4) & 0x1f);
                    u4_numCoeffs       += u4_run;
                    u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
                    pu1_pos[*pi4_num_coeffs] = u4_pos;

                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                    pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 else
 {
 if (DecodedValue == END_OF_BLOCK_ONE)
 {
                        u4_sym_len = 4;

 break;
 }
 else
 {
 /*Second table lookup*/
                        lead_zeros = CLZ(u4_bits) - 20;/* -16 since we are dealing with WORD32 */
 if (0 != lead_zeros)
 {

                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;

 /* Flush the number of bits */
 if (1 == lead_zeros)
 {
                                u4_sym_len         = ((u4_bits & 0x18) >> 3) == 2 ? 11:10;
 }
 else
 {
                                u4_sym_len         = 11 + lead_zeros;
 }
 /* flushing */
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)

 /* Calculate the address */
                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;

 DecodedValue = gau2_impeg2d_tab_one_10_16[u4_bits];

                            u4_run = BITS(DecodedValue, 8,4);
                            u4_level = ((WORD16) DecodedValue) >> 9;

                            u4_numCoeffs       += u4_run;
                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 /*********************************************************************/
 /* MPEG2 Escape Code                                                 */
 /*********************************************************************/
 else if(u2_mpeg2 == 1)
 {
                            u4_sym_len         = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)
                                u4_decoded_value    = u4_bits;
                            u4_run             = (u4_decoded_value >> 12);
                            u4_level           = (u4_decoded_value & 0x0FFF);

 if (u4_level)
                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));

                            u4_numCoeffs       += u4_run;
                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 /*********************************************************************/
 /* MPEG1 Escape Code                                                 */
 /*********************************************************************/
 else
 {
 /*-----------------------------------------------------------
                            * MPEG-1 Stream
                            *
                            * <See D.9.3 of MPEG-2> Run-level escape syntax
                            * Run-level values that cannot be coded with a VLC are coded
                            * by the escape code '0000 01' followed by
                            * either a 14-bit FLC (127 <= level <= 127),
                            * or a 22-bit FLC (255 <= level <= 255).
                            * This is described in Annex B,B.5f of MPEG-1.standard
                            *-----------------------------------------------------------*/

 /*-----------------------------------------------------------
                            * First 6 bits are the value of the Run. Next is First 8 bits
                            * of Level. These bits decide whether it is 14 bit FLC or
                            * 22-bit FLC.
                            *
                            * If( first 8 bits of Level == '1000000' or '00000000')
                            *      then its is 22-bit FLC.
                            * else
                            *      it is 14-bit FLC.
                            *-----------------------------------------------------------*/
                            u4_sym_len         = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)
                                u4_decoded_value     = u4_bits;
                            u4_run              = (u4_decoded_value >> 8);
                            u4_level_first_byte = (u4_decoded_value & 0x0FF);
 if(u4_level_first_byte & 0x7F)
 {
 /*-------------------------------------------------------
                                * First 8 bits of level are neither 1000000 nor 00000000
                                * Hence 14-bit FLC (Last 8 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_First_Byte - 256 : Level_First_Byte
                                *-------------------------------------------------------*/
                                u4_level = (u4_level_first_byte -
 ((u4_level_first_byte & 0x80) << 1));
 }
 else
 {
 /*-------------------------------------------------------
                                * Next 8 bits are either 1000000 or 00000000
                                * Hence 22-bit FLC (Last 16 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_Second_Byte - 256 : Level_Second_Byte
                                *-------------------------------------------------------*/
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)
                                    u4_level = u4_bits;
                                u4_level = (u4_level - (u4_level_first_byte << 1));
 }
                            u4_numCoeffs += u4_run;

                            u4_pos = pu1_scan[u4_numCoeffs++ & 63];

                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 }
 }

                u4_nz_cols |= 1 << (u4_pos & 0x7);
                u4_nz_rows |= 1 << (u4_pos >> 0x3);

 if (u4_numCoeffs > 64)
 {
 return IMPEG2D_MB_TEX_DECODE_ERR;
 }

 }
            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)
 }
 else
 {
 while(1)
 {

                UWORD32 lead_zeros;
                UWORD16 DecodedValue;


                 u4_sym_len = 17;
                 IBITS_NXT(u4_buf, u4_buf_nxt, u4_offset, u4_bits, u4_sym_len)
 
 
                 DecodedValue = gau2_impeg2d_tab_zero_1_9[u4_bits >> 8];
                 u4_sym_len = BITS(DecodedValue, 3, 0);
                u4_level = ((WORD16) DecodedValue) >> 9;

 if (0 != u4_level)
 {
                    u4_run = BITS(DecodedValue, 8,4);

                    u4_numCoeffs       += u4_run;

                    u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                    pu1_pos[*pi4_num_coeffs] = u4_pos;

                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                    pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 else
 {
 if(DecodedValue == END_OF_BLOCK_ZERO)
 {
                        u4_sym_len = 2;

 break;
 }
 else
 {
                        lead_zeros = CLZ(u4_bits) - 20;/* -15 since we are dealing with WORD32 */
 /*Second table lookup*/
 if (0 != lead_zeros)
 {
                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;

 /* Flush the number of bits */
                            u4_sym_len         = 11 + lead_zeros;

 /* Calculate the address */
                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;

 DecodedValue = gau2_impeg2d_tab_zero_10_16[u4_bits];

                            u4_run = BITS(DecodedValue, 8,4);
                            u4_level = ((WORD16) DecodedValue) >> 9;

                            u4_numCoeffs       += u4_run;

                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
 if (1 == lead_zeros)
                                u4_sym_len--;
 /* flushing */
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 /*Escape Sequence*/
 else if(u2_mpeg2 == 1)
 {
                            u4_sym_len         = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)
                            u4_decoded_value    = u4_bits;
                            u4_run             = (u4_decoded_value >> 12);
                            u4_level           = (u4_decoded_value & 0x0FFF);

 if (u4_level)
                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));

                            u4_numCoeffs           += u4_run;

                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 /*********************************************************************/
 /* MPEG1 Escape Code                                                 */
 /*********************************************************************/
 else
 {
 /*-----------------------------------------------------------
                            * MPEG-1 Stream
                            *
                            * <See D.9.3 of MPEG-2> Run-level escape syntax
                            * Run-level values that cannot be coded with a VLC are coded
                            * by the escape code '0000 01' followed by
                            * either a 14-bit FLC (127 <= level <= 127),
                            * or a 22-bit FLC (255 <= level <= 255).
                            * This is described in Annex B,B.5f of MPEG-1.standard
                            *-----------------------------------------------------------*/

 /*-----------------------------------------------------------
                            * First 6 bits are the value of the Run. Next is First 8 bits
                            * of Level. These bits decide whether it is 14 bit FLC or
                            * 22-bit FLC.
                            *
                            * If( first 8 bits of Level == '1000000' or '00000000')
                            *      then its is 22-bit FLC.
                            * else
                            *      it is 14-bit FLC.
                            *-----------------------------------------------------------*/
                            u4_sym_len             = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)
                            u4_decoded_value        = u4_bits;
                            u4_run                 = (u4_decoded_value >> 8);
                            u4_level_first_byte    = (u4_decoded_value & 0x0FF);
 if(u4_level_first_byte & 0x7F)
 {
 /*-------------------------------------------------------
                                * First 8 bits of level are neither 1000000 nor 00000000
                                * Hence 14-bit FLC (Last 8 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_First_Byte - 256 : Level_First_Byte
                                *-------------------------------------------------------*/
                                u4_level = (u4_level_first_byte -
 ((u4_level_first_byte & 0x80) << 1));
 }
 else
 {
 /*-------------------------------------------------------
                                * Next 8 bits are either 1000000 or 00000000
                                * Hence 22-bit FLC (Last 16 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_Second_Byte - 256 : Level_Second_Byte
                                *-------------------------------------------------------*/
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)
                                u4_level = u4_bits;
                                u4_level = (u4_level - (u4_level_first_byte << 1));
 }
                            u4_numCoeffs           += u4_run;

                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 }
 }

                u4_nz_cols |= 1 << (u4_pos & 0x7);
                u4_nz_rows |= 1 << (u4_pos >> 0x3);
 if (u4_numCoeffs > 64)
 {
 return IMPEG2D_MB_TEX_DECODE_ERR;
 }

 }

            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)

 }

        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)

        ps_dec->u4_non_zero_cols  = u4_nz_cols;
        ps_dec->u4_non_zero_rows  = u4_nz_rows;

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
",C,"                /* There cannot be more than 11 leading zeros in the decoded
                 * symbol. The symbol is only 17 bits long, so we subtract 15.
                 */
                lead_zeros = CLZ(u4_bits) - 15;
                if (lead_zeros > 11)
                {
                    return IMPEG2D_MB_DATA_DECODE_ERR;
                }

                /* There cannot be more than 11 leading zeros in the decoded
                 * symbol. The symbol is only 17 bits long, so we subtract 15.
                 */
                lead_zeros = CLZ(u4_bits) - 15;
                if (lead_zeros > 11)
                {
                    return IMPEG2D_MB_DATA_DECODE_ERR;
                }
",,,"@@ -638,6 +638,15 @@

                 u4_sym_len = 17;
                 IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,u4_sym_len)
 
+                /* There cannot be more than 11 leading zeros in the decoded
+                 * symbol. The symbol is only 17 bits long, so we subtract 15.
+                 */
+                lead_zeros = CLZ(u4_bits) - 15;
+                if (lead_zeros > 11)
+                {
+                    return IMPEG2D_MB_DATA_DECODE_ERR;
+                }
+
                 DecodedValue = gau2_impeg2d_tab_one_1_9[u4_bits >> 8];
                 u4_sym_len = (DecodedValue & 0xf);
                 u4_level = DecodedValue >> 9;
@@ -809,6 +818,14 @@

                 u4_sym_len = 17;
                 IBITS_NXT(u4_buf, u4_buf_nxt, u4_offset, u4_bits, u4_sym_len)
 
+                /* There cannot be more than 11 leading zeros in the decoded
+                 * symbol. The symbol is only 17 bits long, so we subtract 15.
+                 */
+                lead_zeros = CLZ(u4_bits) - 15;
+                if (lead_zeros > 11)
+                {
+                    return IMPEG2D_MB_DATA_DECODE_ERR;
+                }
 
                 DecodedValue = gau2_impeg2d_tab_zero_1_9[u4_bits >> 8];
                 u4_sym_len = BITS(DecodedValue, 3, 0);
",Android,https://android.googlesource.com/platform/external/libmpeg2/+/227c1f829127405e21dab1664393050c652ef71e/,https://android.googlesource.com/platform/external/libmpeg2/+/227c1f829127405e21dab1664393050c652ef71e%5E/,1,"IMPEG2D_ERROR_CODES_T impeg2d_vld_decode(
 dec_state_t *ps_dec,
    WORD16      *pi2_outAddr, /*!< Address where decoded symbols will be stored */
 const UWORD8 *pu1_scan, /*!< Scan table to be used */
    UWORD8      *pu1_pos, /*!< Scan table to be used */
    UWORD16     u2_intra_flag, /*!< Intra Macroblock or not */
    UWORD16     u2_chroma_flag, /*!< Chroma Block or not */
    UWORD16     u2_d_picture, /*!< D Picture or not */
    UWORD16     u2_intra_vlc_format, /*!< Intra VLC format */
    UWORD16     u2_mpeg2, /*!< MPEG-2 or not */
    WORD32      *pi4_num_coeffs /*!< Returns the number of coeffs in block */
 )
{

    UWORD32 u4_sym_len;

    UWORD32 u4_decoded_value;
    UWORD32 u4_level_first_byte;
    WORD32  u4_level;
    UWORD32 u4_run, u4_numCoeffs;
    UWORD32 u4_buf;
    UWORD32 u4_buf_nxt;
    UWORD32 u4_offset;
    UWORD32 *pu4_buf_aligned;
    UWORD32 u4_bits;
 stream_t *ps_stream = &ps_dec->s_bit_stream;
    WORD32  u4_pos;
    UWORD32 u4_nz_cols;
    UWORD32 u4_nz_rows;

 *pi4_num_coeffs = 0;

    ps_dec->u4_non_zero_cols = 0;
    ps_dec->u4_non_zero_rows = 0;
    u4_nz_cols = ps_dec->u4_non_zero_cols;
    u4_nz_rows = ps_dec->u4_non_zero_rows;

    GET_TEMP_STREAM_DATA(u4_buf,u4_buf_nxt,u4_offset,pu4_buf_aligned,ps_stream)
 /**************************************************************************/
 /* Decode the DC coefficient in case of Intra block                       */
 /**************************************************************************/
 if(u2_intra_flag)
 {
        WORD32 dc_size;
        WORD32 dc_diff;
        WORD32 maxLen;
        WORD32 idx;


        maxLen = MPEG2_DCT_DC_SIZE_LEN;
        idx = 0;
 if(u2_chroma_flag != 0)
 {
            maxLen += 1;
            idx++;
 }


 {
            WORD16  end = 0;
            UWORD32 maxLen_tmp = maxLen;
            UWORD16 m_iBit;


 /* Get the maximum number of bits needed to decode a symbol */
            IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,maxLen)
 do
 {
                maxLen_tmp--;
 /* Read one bit at a time from the variable to decode the huffman code */
                m_iBit = (UWORD8)((u4_bits >> maxLen_tmp) & 0x1);

 /* Get the next node pointer or the symbol from the tree */
                end = gai2_impeg2d_dct_dc_size[idx][end][m_iBit];
 }while(end > 0);
            dc_size = end + MPEG2_DCT_DC_SIZE_OFFSET;

 /* Flush the appropriate number of bits from the stream */
            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,(maxLen - maxLen_tmp),pu4_buf_aligned)

 }



 if (dc_size != 0)
 {
            UWORD32 u4_bits;

            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, dc_size)
            dc_diff = u4_bits;

 if ((dc_diff & (1 << (dc_size - 1))) == 0) //v Probably the prediction algo?
                dc_diff -= (1 << dc_size) - 1;
 }
 else
 {
            dc_diff = 0;
 }


        pi2_outAddr[*pi4_num_coeffs] = dc_diff;
 /* This indicates the position of the coefficient. Since this is the DC
         * coefficient, we put the position as 0.
         */
        pu1_pos[*pi4_num_coeffs] = pu1_scan[0];
 (*pi4_num_coeffs)++;

 if (0 != dc_diff)
 {
            u4_nz_cols |= 0x01;
            u4_nz_rows |= 0x01;
 }

        u4_numCoeffs = 1;
 }
 /**************************************************************************/
 /* Decoding of first AC coefficient in case of non Intra block            */
 /**************************************************************************/
 else
 {
 /* First symbol can be 1s */
        UWORD32 u4_bits;

        IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,1)

 if(u4_bits == 1)
 {

            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,1, pu4_buf_aligned)
            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, 1)
 if(u4_bits == 1)
 {
                pi2_outAddr[*pi4_num_coeffs] = -1;
 }
 else
 {
                pi2_outAddr[*pi4_num_coeffs] = 1;
 }

 /* This indicates the position of the coefficient. Since this is the DC
             * coefficient, we put the position as 0.
             */
            pu1_pos[*pi4_num_coeffs] = pu1_scan[0];
 (*pi4_num_coeffs)++;
            u4_numCoeffs = 1;

            u4_nz_cols |= 0x01;
            u4_nz_rows |= 0x01;
 }
 else
 {
            u4_numCoeffs = 0;
 }
 }
 if (1 == u2_d_picture)
 {
        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)
        ps_dec->u4_non_zero_cols  = u4_nz_cols;
        ps_dec->u4_non_zero_rows  = u4_nz_rows;
 return ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE);
 }



 if (1 == u2_intra_vlc_format && u2_intra_flag)
 {

 while(1)
 {
 //Putting the impeg2d_dec_ac_coeff_one function inline.

                UWORD32 lead_zeros;
                WORD16 DecodedValue;


                 u4_sym_len = 17;
                 IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,u4_sym_len)
 
//fix_flaw_line_below:
//                /* There cannot be more than 11 leading zeros in the decoded
//fix_flaw_line_below:
//                 * symbol. The symbol is only 17 bits long, so we subtract 15.
//fix_flaw_line_below:
//                 */
//fix_flaw_line_below:
//                lead_zeros = CLZ(u4_bits) - 15;
//fix_flaw_line_below:
//                if (lead_zeros > 11)
//fix_flaw_line_below:
//                {
//fix_flaw_line_below:
//                    return IMPEG2D_MB_DATA_DECODE_ERR;
//fix_flaw_line_below:
//                }
//fix_flaw_line_below:
//
                 DecodedValue = gau2_impeg2d_tab_one_1_9[u4_bits >> 8];
                 u4_sym_len = (DecodedValue & 0xf);
                 u4_level = DecodedValue >> 9;
 /* One table lookup */
 if(0 != u4_level)
 {
                    u4_run = ((DecodedValue >> 4) & 0x1f);
                    u4_numCoeffs       += u4_run;
                    u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
                    pu1_pos[*pi4_num_coeffs] = u4_pos;

                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                    pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 else
 {
 if (DecodedValue == END_OF_BLOCK_ONE)
 {
                        u4_sym_len = 4;

 break;
 }
 else
 {
 /*Second table lookup*/
                        lead_zeros = CLZ(u4_bits) - 20;/* -16 since we are dealing with WORD32 */
 if (0 != lead_zeros)
 {

                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;

 /* Flush the number of bits */
 if (1 == lead_zeros)
 {
                                u4_sym_len         = ((u4_bits & 0x18) >> 3) == 2 ? 11:10;
 }
 else
 {
                                u4_sym_len         = 11 + lead_zeros;
 }
 /* flushing */
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)

 /* Calculate the address */
                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;

 DecodedValue = gau2_impeg2d_tab_one_10_16[u4_bits];

                            u4_run = BITS(DecodedValue, 8,4);
                            u4_level = ((WORD16) DecodedValue) >> 9;

                            u4_numCoeffs       += u4_run;
                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 /*********************************************************************/
 /* MPEG2 Escape Code                                                 */
 /*********************************************************************/
 else if(u2_mpeg2 == 1)
 {
                            u4_sym_len         = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)
                                u4_decoded_value    = u4_bits;
                            u4_run             = (u4_decoded_value >> 12);
                            u4_level           = (u4_decoded_value & 0x0FFF);

 if (u4_level)
                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));

                            u4_numCoeffs       += u4_run;
                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 /*********************************************************************/
 /* MPEG1 Escape Code                                                 */
 /*********************************************************************/
 else
 {
 /*-----------------------------------------------------------
                            * MPEG-1 Stream
                            *
                            * <See D.9.3 of MPEG-2> Run-level escape syntax
                            * Run-level values that cannot be coded with a VLC are coded
                            * by the escape code '0000 01' followed by
                            * either a 14-bit FLC (127 <= level <= 127),
                            * or a 22-bit FLC (255 <= level <= 255).
                            * This is described in Annex B,B.5f of MPEG-1.standard
                            *-----------------------------------------------------------*/

 /*-----------------------------------------------------------
                            * First 6 bits are the value of the Run. Next is First 8 bits
                            * of Level. These bits decide whether it is 14 bit FLC or
                            * 22-bit FLC.
                            *
                            * If( first 8 bits of Level == '1000000' or '00000000')
                            *      then its is 22-bit FLC.
                            * else
                            *      it is 14-bit FLC.
                            *-----------------------------------------------------------*/
                            u4_sym_len         = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)
                                u4_decoded_value     = u4_bits;
                            u4_run              = (u4_decoded_value >> 8);
                            u4_level_first_byte = (u4_decoded_value & 0x0FF);
 if(u4_level_first_byte & 0x7F)
 {
 /*-------------------------------------------------------
                                * First 8 bits of level are neither 1000000 nor 00000000
                                * Hence 14-bit FLC (Last 8 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_First_Byte - 256 : Level_First_Byte
                                *-------------------------------------------------------*/
                                u4_level = (u4_level_first_byte -
 ((u4_level_first_byte & 0x80) << 1));
 }
 else
 {
 /*-------------------------------------------------------
                                * Next 8 bits are either 1000000 or 00000000
                                * Hence 22-bit FLC (Last 16 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_Second_Byte - 256 : Level_Second_Byte
                                *-------------------------------------------------------*/
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)
                                    u4_level = u4_bits;
                                u4_level = (u4_level - (u4_level_first_byte << 1));
 }
                            u4_numCoeffs += u4_run;

                            u4_pos = pu1_scan[u4_numCoeffs++ & 63];

                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 }
 }

                u4_nz_cols |= 1 << (u4_pos & 0x7);
                u4_nz_rows |= 1 << (u4_pos >> 0x3);

 if (u4_numCoeffs > 64)
 {
 return IMPEG2D_MB_TEX_DECODE_ERR;
 }

 }
            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)
 }
 else
 {
 // Inline
 while(1)
 {

                UWORD32 lead_zeros;
                UWORD16 DecodedValue;


                 u4_sym_len = 17;
                 IBITS_NXT(u4_buf, u4_buf_nxt, u4_offset, u4_bits, u4_sym_len)
 
//fix_flaw_line_below:
//                /* There cannot be more than 11 leading zeros in the decoded
//fix_flaw_line_below:
//                 * symbol. The symbol is only 17 bits long, so we subtract 15.
//fix_flaw_line_below:
//                 */
//fix_flaw_line_below:
//                lead_zeros = CLZ(u4_bits) - 15;
//fix_flaw_line_below:
//                if (lead_zeros > 11)
//fix_flaw_line_below:
//                {
//fix_flaw_line_below:
//                    return IMPEG2D_MB_DATA_DECODE_ERR;
//fix_flaw_line_below:
//                }
 
                 DecodedValue = gau2_impeg2d_tab_zero_1_9[u4_bits >> 8];
                 u4_sym_len = BITS(DecodedValue, 3, 0);
                u4_level = ((WORD16) DecodedValue) >> 9;

 if (0 != u4_level)
 {
                    u4_run = BITS(DecodedValue, 8,4);

                    u4_numCoeffs       += u4_run;

                    u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                    pu1_pos[*pi4_num_coeffs] = u4_pos;

                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                    pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 else
 {
 if(DecodedValue == END_OF_BLOCK_ZERO)
 {
                        u4_sym_len = 2;

 break;
 }
 else
 {
                        lead_zeros = CLZ(u4_bits) - 20;/* -15 since we are dealing with WORD32 */
 /*Second table lookup*/
 if (0 != lead_zeros)
 {
                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;

 /* Flush the number of bits */
                            u4_sym_len         = 11 + lead_zeros;

 /* Calculate the address */
                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;

 DecodedValue = gau2_impeg2d_tab_zero_10_16[u4_bits];

                            u4_run = BITS(DecodedValue, 8,4);
                            u4_level = ((WORD16) DecodedValue) >> 9;

                            u4_numCoeffs       += u4_run;

                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
 if (1 == lead_zeros)
                                u4_sym_len--;
 /* flushing */
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 /*Escape Sequence*/
 else if(u2_mpeg2 == 1)
 {
                            u4_sym_len         = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)
                            u4_decoded_value    = u4_bits;
                            u4_run             = (u4_decoded_value >> 12);
                            u4_level           = (u4_decoded_value & 0x0FFF);

 if (u4_level)
                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));

                            u4_numCoeffs           += u4_run;

                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 /*********************************************************************/
 /* MPEG1 Escape Code                                                 */
 /*********************************************************************/
 else
 {
 /*-----------------------------------------------------------
                            * MPEG-1 Stream
                            *
                            * <See D.9.3 of MPEG-2> Run-level escape syntax
                            * Run-level values that cannot be coded with a VLC are coded
                            * by the escape code '0000 01' followed by
                            * either a 14-bit FLC (127 <= level <= 127),
                            * or a 22-bit FLC (255 <= level <= 255).
                            * This is described in Annex B,B.5f of MPEG-1.standard
                            *-----------------------------------------------------------*/

 /*-----------------------------------------------------------
                            * First 6 bits are the value of the Run. Next is First 8 bits
                            * of Level. These bits decide whether it is 14 bit FLC or
                            * 22-bit FLC.
                            *
                            * If( first 8 bits of Level == '1000000' or '00000000')
                            *      then its is 22-bit FLC.
                            * else
                            *      it is 14-bit FLC.
                            *-----------------------------------------------------------*/
                            u4_sym_len             = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)
                            u4_decoded_value        = u4_bits;
                            u4_run                 = (u4_decoded_value >> 8);
                            u4_level_first_byte    = (u4_decoded_value & 0x0FF);
 if(u4_level_first_byte & 0x7F)
 {
 /*-------------------------------------------------------
                                * First 8 bits of level are neither 1000000 nor 00000000
                                * Hence 14-bit FLC (Last 8 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_First_Byte - 256 : Level_First_Byte
                                *-------------------------------------------------------*/
                                u4_level = (u4_level_first_byte -
 ((u4_level_first_byte & 0x80) << 1));
 }
 else
 {
 /*-------------------------------------------------------
                                * Next 8 bits are either 1000000 or 00000000
                                * Hence 22-bit FLC (Last 16 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_Second_Byte - 256 : Level_Second_Byte
                                *-------------------------------------------------------*/
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)
                                u4_level = u4_bits;
                                u4_level = (u4_level - (u4_level_first_byte << 1));
 }
                            u4_numCoeffs           += u4_run;

                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 }
 }

                u4_nz_cols |= 1 << (u4_pos & 0x7);
                u4_nz_rows |= 1 << (u4_pos >> 0x3);
 if (u4_numCoeffs > 64)
 {
 return IMPEG2D_MB_TEX_DECODE_ERR;
 }

 }

            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)

 }

        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)

        ps_dec->u4_non_zero_cols  = u4_nz_cols;
        ps_dec->u4_non_zero_rows  = u4_nz_rows;

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
",188057,"IMPEG2D_ERROR_CODES_T impeg2d_vld_decode(
 dec_state_t *ps_dec,
    WORD16      *pi2_outAddr, /*!< Address where decoded symbols will be stored */
 const UWORD8 *pu1_scan, /*!< Scan table to be used */
    UWORD8      *pu1_pos, /*!< Scan table to be used */
    UWORD16     u2_intra_flag, /*!< Intra Macroblock or not */
    UWORD16     u2_chroma_flag, /*!< Chroma Block or not */
    UWORD16     u2_d_picture, /*!< D Picture or not */
    UWORD16     u2_intra_vlc_format, /*!< Intra VLC format */
    UWORD16     u2_mpeg2, /*!< MPEG-2 or not */
    WORD32      *pi4_num_coeffs /*!< Returns the number of coeffs in block */
 )
{

    UWORD32 u4_sym_len;

    UWORD32 u4_decoded_value;
    UWORD32 u4_level_first_byte;
    WORD32  u4_level;
    UWORD32 u4_run, u4_numCoeffs;
    UWORD32 u4_buf;
    UWORD32 u4_buf_nxt;
    UWORD32 u4_offset;
    UWORD32 *pu4_buf_aligned;
    UWORD32 u4_bits;
 stream_t *ps_stream = &ps_dec->s_bit_stream;
    WORD32  u4_pos;
    UWORD32 u4_nz_cols;
    UWORD32 u4_nz_rows;

 *pi4_num_coeffs = 0;

    ps_dec->u4_non_zero_cols = 0;
    ps_dec->u4_non_zero_rows = 0;
    u4_nz_cols = ps_dec->u4_non_zero_cols;
    u4_nz_rows = ps_dec->u4_non_zero_rows;

    GET_TEMP_STREAM_DATA(u4_buf,u4_buf_nxt,u4_offset,pu4_buf_aligned,ps_stream)
 /**************************************************************************/
 /* Decode the DC coefficient in case of Intra block                       */
 /**************************************************************************/
 if(u2_intra_flag)
 {
        WORD32 dc_size;
        WORD32 dc_diff;
        WORD32 maxLen;
        WORD32 idx;


        maxLen = MPEG2_DCT_DC_SIZE_LEN;
        idx = 0;
 if(u2_chroma_flag != 0)
 {
            maxLen += 1;
            idx++;
 }


 {
            WORD16  end = 0;
            UWORD32 maxLen_tmp = maxLen;
            UWORD16 m_iBit;


 /* Get the maximum number of bits needed to decode a symbol */
            IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,maxLen)
 do
 {
                maxLen_tmp--;
 /* Read one bit at a time from the variable to decode the huffman code */
                m_iBit = (UWORD8)((u4_bits >> maxLen_tmp) & 0x1);

 /* Get the next node pointer or the symbol from the tree */
                end = gai2_impeg2d_dct_dc_size[idx][end][m_iBit];
 }while(end > 0);
            dc_size = end + MPEG2_DCT_DC_SIZE_OFFSET;

 /* Flush the appropriate number of bits from the stream */
            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,(maxLen - maxLen_tmp),pu4_buf_aligned)

 }



 if (dc_size != 0)
 {
            UWORD32 u4_bits;

            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, dc_size)
            dc_diff = u4_bits;

 if ((dc_diff & (1 << (dc_size - 1))) == 0) //v Probably the prediction algo?
                dc_diff -= (1 << dc_size) - 1;
 }
 else
 {
            dc_diff = 0;
 }


        pi2_outAddr[*pi4_num_coeffs] = dc_diff;
 /* This indicates the position of the coefficient. Since this is the DC
         * coefficient, we put the position as 0.
         */
        pu1_pos[*pi4_num_coeffs] = pu1_scan[0];
 (*pi4_num_coeffs)++;

 if (0 != dc_diff)
 {
            u4_nz_cols |= 0x01;
            u4_nz_rows |= 0x01;
 }

        u4_numCoeffs = 1;
 }
 /**************************************************************************/
 /* Decoding of first AC coefficient in case of non Intra block            */
 /**************************************************************************/
 else
 {
 /* First symbol can be 1s */
        UWORD32 u4_bits;

        IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,1)

 if(u4_bits == 1)
 {

            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,1, pu4_buf_aligned)
            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, 1)
 if(u4_bits == 1)
 {
                pi2_outAddr[*pi4_num_coeffs] = -1;
 }
 else
 {
                pi2_outAddr[*pi4_num_coeffs] = 1;
 }

 /* This indicates the position of the coefficient. Since this is the DC
             * coefficient, we put the position as 0.
             */
            pu1_pos[*pi4_num_coeffs] = pu1_scan[0];
 (*pi4_num_coeffs)++;
            u4_numCoeffs = 1;

            u4_nz_cols |= 0x01;
            u4_nz_rows |= 0x01;
 }
 else
 {
            u4_numCoeffs = 0;
 }
 }
 if (1 == u2_d_picture)
 {
        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)
        ps_dec->u4_non_zero_cols  = u4_nz_cols;
        ps_dec->u4_non_zero_rows  = u4_nz_rows;
 return ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE);
 }



 if (1 == u2_intra_vlc_format && u2_intra_flag)
 {

 while(1)
 {

                UWORD32 lead_zeros;
                WORD16 DecodedValue;


                 u4_sym_len = 17;
                 IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,u4_sym_len)
 
                 DecodedValue = gau2_impeg2d_tab_one_1_9[u4_bits >> 8];
                 u4_sym_len = (DecodedValue & 0xf);
                 u4_level = DecodedValue >> 9;
 /* One table lookup */
 if(0 != u4_level)
 {
                    u4_run = ((DecodedValue >> 4) & 0x1f);
                    u4_numCoeffs       += u4_run;
                    u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
                    pu1_pos[*pi4_num_coeffs] = u4_pos;

                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                    pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 else
 {
 if (DecodedValue == END_OF_BLOCK_ONE)
 {
                        u4_sym_len = 4;

 break;
 }
 else
 {
 /*Second table lookup*/
                        lead_zeros = CLZ(u4_bits) - 20;/* -16 since we are dealing with WORD32 */
 if (0 != lead_zeros)
 {

                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;

 /* Flush the number of bits */
 if (1 == lead_zeros)
 {
                                u4_sym_len         = ((u4_bits & 0x18) >> 3) == 2 ? 11:10;
 }
 else
 {
                                u4_sym_len         = 11 + lead_zeros;
 }
 /* flushing */
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)

 /* Calculate the address */
                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;

 DecodedValue = gau2_impeg2d_tab_one_10_16[u4_bits];

                            u4_run = BITS(DecodedValue, 8,4);
                            u4_level = ((WORD16) DecodedValue) >> 9;

                            u4_numCoeffs       += u4_run;
                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 /*********************************************************************/
 /* MPEG2 Escape Code                                                 */
 /*********************************************************************/
 else if(u2_mpeg2 == 1)
 {
                            u4_sym_len         = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)
                                u4_decoded_value    = u4_bits;
                            u4_run             = (u4_decoded_value >> 12);
                            u4_level           = (u4_decoded_value & 0x0FFF);

 if (u4_level)
                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));

                            u4_numCoeffs       += u4_run;
                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 /*********************************************************************/
 /* MPEG1 Escape Code                                                 */
 /*********************************************************************/
 else
 {
 /*-----------------------------------------------------------
                            * MPEG-1 Stream
                            *
                            * <See D.9.3 of MPEG-2> Run-level escape syntax
                            * Run-level values that cannot be coded with a VLC are coded
                            * by the escape code '0000 01' followed by
                            * either a 14-bit FLC (127 <= level <= 127),
                            * or a 22-bit FLC (255 <= level <= 255).
                            * This is described in Annex B,B.5f of MPEG-1.standard
                            *-----------------------------------------------------------*/

 /*-----------------------------------------------------------
                            * First 6 bits are the value of the Run. Next is First 8 bits
                            * of Level. These bits decide whether it is 14 bit FLC or
                            * 22-bit FLC.
                            *
                            * If( first 8 bits of Level == '1000000' or '00000000')
                            *      then its is 22-bit FLC.
                            * else
                            *      it is 14-bit FLC.
                            *-----------------------------------------------------------*/
                            u4_sym_len         = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)
                                u4_decoded_value     = u4_bits;
                            u4_run              = (u4_decoded_value >> 8);
                            u4_level_first_byte = (u4_decoded_value & 0x0FF);
 if(u4_level_first_byte & 0x7F)
 {
 /*-------------------------------------------------------
                                * First 8 bits of level are neither 1000000 nor 00000000
                                * Hence 14-bit FLC (Last 8 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_First_Byte - 256 : Level_First_Byte
                                *-------------------------------------------------------*/
                                u4_level = (u4_level_first_byte -
 ((u4_level_first_byte & 0x80) << 1));
 }
 else
 {
 /*-------------------------------------------------------
                                * Next 8 bits are either 1000000 or 00000000
                                * Hence 22-bit FLC (Last 16 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_Second_Byte - 256 : Level_Second_Byte
                                *-------------------------------------------------------*/
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)
                                    u4_level = u4_bits;
                                u4_level = (u4_level - (u4_level_first_byte << 1));
 }
                            u4_numCoeffs += u4_run;

                            u4_pos = pu1_scan[u4_numCoeffs++ & 63];

                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 }
 }

                u4_nz_cols |= 1 << (u4_pos & 0x7);
                u4_nz_rows |= 1 << (u4_pos >> 0x3);

 if (u4_numCoeffs > 64)
 {
 return IMPEG2D_MB_TEX_DECODE_ERR;
 }

 }
            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)
 }
 else
 {
 while(1)
 {

                UWORD32 lead_zeros;
                UWORD16 DecodedValue;


                 u4_sym_len = 17;
                 IBITS_NXT(u4_buf, u4_buf_nxt, u4_offset, u4_bits, u4_sym_len)
 
 
                 DecodedValue = gau2_impeg2d_tab_zero_1_9[u4_bits >> 8];
                 u4_sym_len = BITS(DecodedValue, 3, 0);
                u4_level = ((WORD16) DecodedValue) >> 9;

 if (0 != u4_level)
 {
                    u4_run = BITS(DecodedValue, 8,4);

                    u4_numCoeffs       += u4_run;

                    u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                    pu1_pos[*pi4_num_coeffs] = u4_pos;

                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                    pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 else
 {
 if(DecodedValue == END_OF_BLOCK_ZERO)
 {
                        u4_sym_len = 2;

 break;
 }
 else
 {
                        lead_zeros = CLZ(u4_bits) - 20;/* -15 since we are dealing with WORD32 */
 /*Second table lookup*/
 if (0 != lead_zeros)
 {
                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;

 /* Flush the number of bits */
                            u4_sym_len         = 11 + lead_zeros;

 /* Calculate the address */
                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;

 DecodedValue = gau2_impeg2d_tab_zero_10_16[u4_bits];

                            u4_run = BITS(DecodedValue, 8,4);
                            u4_level = ((WORD16) DecodedValue) >> 9;

                            u4_numCoeffs       += u4_run;

                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
 if (1 == lead_zeros)
                                u4_sym_len--;
 /* flushing */
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 /*Escape Sequence*/
 else if(u2_mpeg2 == 1)
 {
                            u4_sym_len         = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)
                            u4_decoded_value    = u4_bits;
                            u4_run             = (u4_decoded_value >> 12);
                            u4_level           = (u4_decoded_value & 0x0FFF);

 if (u4_level)
                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));

                            u4_numCoeffs           += u4_run;

                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 /*********************************************************************/
 /* MPEG1 Escape Code                                                 */
 /*********************************************************************/
 else
 {
 /*-----------------------------------------------------------
                            * MPEG-1 Stream
                            *
                            * <See D.9.3 of MPEG-2> Run-level escape syntax
                            * Run-level values that cannot be coded with a VLC are coded
                            * by the escape code '0000 01' followed by
                            * either a 14-bit FLC (127 <= level <= 127),
                            * or a 22-bit FLC (255 <= level <= 255).
                            * This is described in Annex B,B.5f of MPEG-1.standard
                            *-----------------------------------------------------------*/

 /*-----------------------------------------------------------
                            * First 6 bits are the value of the Run. Next is First 8 bits
                            * of Level. These bits decide whether it is 14 bit FLC or
                            * 22-bit FLC.
                            *
                            * If( first 8 bits of Level == '1000000' or '00000000')
                            *      then its is 22-bit FLC.
                            * else
                            *      it is 14-bit FLC.
                            *-----------------------------------------------------------*/
                            u4_sym_len             = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)
                            u4_decoded_value        = u4_bits;
                            u4_run                 = (u4_decoded_value >> 8);
                            u4_level_first_byte    = (u4_decoded_value & 0x0FF);
 if(u4_level_first_byte & 0x7F)
 {
 /*-------------------------------------------------------
                                * First 8 bits of level are neither 1000000 nor 00000000
                                * Hence 14-bit FLC (Last 8 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_First_Byte - 256 : Level_First_Byte
                                *-------------------------------------------------------*/
                                u4_level = (u4_level_first_byte -
 ((u4_level_first_byte & 0x80) << 1));
 }
 else
 {
 /*-------------------------------------------------------
                                * Next 8 bits are either 1000000 or 00000000
                                * Hence 22-bit FLC (Last 16 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_Second_Byte - 256 : Level_Second_Byte
                                *-------------------------------------------------------*/
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)
                                u4_level = u4_bits;
                                u4_level = (u4_level - (u4_level_first_byte << 1));
 }
                            u4_numCoeffs           += u4_run;

                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 }
 }

                u4_nz_cols |= 1 << (u4_pos & 0x7);
                u4_nz_rows |= 1 << (u4_pos >> 0x3);
 if (u4_numCoeffs > 64)
 {
 return IMPEG2D_MB_TEX_DECODE_ERR;
 }

 }

            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)

 }

        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)

        ps_dec->u4_non_zero_cols  = u4_nz_cols;
        ps_dec->u4_non_zero_rows  = u4_nz_rows;

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
","IMPEG2D_ERROR_CODES_T impeg2d_vld_decode(
 dec_state_t *ps_dec,
    WORD16      *pi2_outAddr, /*!< Address where decoded symbols will be stored */
 const UWORD8 *pu1_scan, /*!< Scan table to be used */
    UWORD8      *pu1_pos, /*!< Scan table to be used */
    UWORD16     u2_intra_flag, /*!< Intra Macroblock or not */
    UWORD16     u2_chroma_flag, /*!< Chroma Block or not */
    UWORD16     u2_d_picture, /*!< D Picture or not */
    UWORD16     u2_intra_vlc_format, /*!< Intra VLC format */
    UWORD16     u2_mpeg2, /*!< MPEG-2 or not */
    WORD32      *pi4_num_coeffs /*!< Returns the number of coeffs in block */
 )
{

    UWORD32 u4_sym_len;

    UWORD32 u4_decoded_value;
    UWORD32 u4_level_first_byte;
    WORD32  u4_level;
    UWORD32 u4_run, u4_numCoeffs;
    UWORD32 u4_buf;
    UWORD32 u4_buf_nxt;
    UWORD32 u4_offset;
    UWORD32 *pu4_buf_aligned;
    UWORD32 u4_bits;
 stream_t *ps_stream = &ps_dec->s_bit_stream;
    WORD32  u4_pos;
    UWORD32 u4_nz_cols;
    UWORD32 u4_nz_rows;

 *pi4_num_coeffs = 0;

    ps_dec->u4_non_zero_cols = 0;
    ps_dec->u4_non_zero_rows = 0;
    u4_nz_cols = ps_dec->u4_non_zero_cols;
    u4_nz_rows = ps_dec->u4_non_zero_rows;

    GET_TEMP_STREAM_DATA(u4_buf,u4_buf_nxt,u4_offset,pu4_buf_aligned,ps_stream)
 /**************************************************************************/
 /* Decode the DC coefficient in case of Intra block                       */
 /**************************************************************************/
 if(u2_intra_flag)
 {
        WORD32 dc_size;
        WORD32 dc_diff;
        WORD32 maxLen;
        WORD32 idx;


        maxLen = MPEG2_DCT_DC_SIZE_LEN;
        idx = 0;
 if(u2_chroma_flag != 0)
 {
            maxLen += 1;
            idx++;
 }


 {
            WORD16  end = 0;
            UWORD32 maxLen_tmp = maxLen;
            UWORD16 m_iBit;


 /* Get the maximum number of bits needed to decode a symbol */
            IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,maxLen)
 do
 {
                maxLen_tmp--;
 /* Read one bit at a time from the variable to decode the huffman code */
                m_iBit = (UWORD8)((u4_bits >> maxLen_tmp) & 0x1);

 /* Get the next node pointer or the symbol from the tree */
                end = gai2_impeg2d_dct_dc_size[idx][end][m_iBit];
 }while(end > 0);
            dc_size = end + MPEG2_DCT_DC_SIZE_OFFSET;

 /* Flush the appropriate number of bits from the stream */
            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,(maxLen - maxLen_tmp),pu4_buf_aligned)

 }



 if (dc_size != 0)
 {
            UWORD32 u4_bits;

            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, dc_size)
            dc_diff = u4_bits;

 if ((dc_diff & (1 << (dc_size - 1))) == 0) //v Probably the prediction algo?
                dc_diff -= (1 << dc_size) - 1;
 }
 else
 {
            dc_diff = 0;
 }


        pi2_outAddr[*pi4_num_coeffs] = dc_diff;
 /* This indicates the position of the coefficient. Since this is the DC
         * coefficient, we put the position as 0.
         */
        pu1_pos[*pi4_num_coeffs] = pu1_scan[0];
 (*pi4_num_coeffs)++;

 if (0 != dc_diff)
 {
            u4_nz_cols |= 0x01;
            u4_nz_rows |= 0x01;
 }

        u4_numCoeffs = 1;
 }
 /**************************************************************************/
 /* Decoding of first AC coefficient in case of non Intra block            */
 /**************************************************************************/
 else
 {
 /* First symbol can be 1s */
        UWORD32 u4_bits;

        IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,1)

 if(u4_bits == 1)
 {

            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,1, pu4_buf_aligned)
            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, 1)
 if(u4_bits == 1)
 {
                pi2_outAddr[*pi4_num_coeffs] = -1;
 }
 else
 {
                pi2_outAddr[*pi4_num_coeffs] = 1;
 }

 /* This indicates the position of the coefficient. Since this is the DC
             * coefficient, we put the position as 0.
             */
            pu1_pos[*pi4_num_coeffs] = pu1_scan[0];
 (*pi4_num_coeffs)++;
            u4_numCoeffs = 1;

            u4_nz_cols |= 0x01;
            u4_nz_rows |= 0x01;
 }
 else
 {
            u4_numCoeffs = 0;
 }
 }
 if (1 == u2_d_picture)
 {
        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)
        ps_dec->u4_non_zero_cols  = u4_nz_cols;
        ps_dec->u4_non_zero_rows  = u4_nz_rows;
 return ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE);
 }



 if (1 == u2_intra_vlc_format && u2_intra_flag)
 {

 while(1)
 {

                UWORD32 lead_zeros;
                WORD16 DecodedValue;


                 u4_sym_len = 17;
                 IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,u4_sym_len)
 
                /* There cannot be more than 11 leading zeros in the decoded
                 * symbol. The symbol is only 17 bits long, so we subtract 15.
                 */
                lead_zeros = CLZ(u4_bits) - 15;
                if (lead_zeros > 11)
                {
                    return IMPEG2D_MB_DATA_DECODE_ERR;
                }

                 DecodedValue = gau2_impeg2d_tab_one_1_9[u4_bits >> 8];
                 u4_sym_len = (DecodedValue & 0xf);
                 u4_level = DecodedValue >> 9;
 /* One table lookup */
 if(0 != u4_level)
 {
                    u4_run = ((DecodedValue >> 4) & 0x1f);
                    u4_numCoeffs       += u4_run;
                    u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
                    pu1_pos[*pi4_num_coeffs] = u4_pos;

                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                    pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 else
 {
 if (DecodedValue == END_OF_BLOCK_ONE)
 {
                        u4_sym_len = 4;

 break;
 }
 else
 {
 /*Second table lookup*/
                        lead_zeros = CLZ(u4_bits) - 20;/* -16 since we are dealing with WORD32 */
 if (0 != lead_zeros)
 {

                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;

 /* Flush the number of bits */
 if (1 == lead_zeros)
 {
                                u4_sym_len         = ((u4_bits & 0x18) >> 3) == 2 ? 11:10;
 }
 else
 {
                                u4_sym_len         = 11 + lead_zeros;
 }
 /* flushing */
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)

 /* Calculate the address */
                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;

 DecodedValue = gau2_impeg2d_tab_one_10_16[u4_bits];

                            u4_run = BITS(DecodedValue, 8,4);
                            u4_level = ((WORD16) DecodedValue) >> 9;

                            u4_numCoeffs       += u4_run;
                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 /*********************************************************************/
 /* MPEG2 Escape Code                                                 */
 /*********************************************************************/
 else if(u2_mpeg2 == 1)
 {
                            u4_sym_len         = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)
                                u4_decoded_value    = u4_bits;
                            u4_run             = (u4_decoded_value >> 12);
                            u4_level           = (u4_decoded_value & 0x0FFF);

 if (u4_level)
                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));

                            u4_numCoeffs       += u4_run;
                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 /*********************************************************************/
 /* MPEG1 Escape Code                                                 */
 /*********************************************************************/
 else
 {
 /*-----------------------------------------------------------
                            * MPEG-1 Stream
                            *
                            * <See D.9.3 of MPEG-2> Run-level escape syntax
                            * Run-level values that cannot be coded with a VLC are coded
                            * by the escape code '0000 01' followed by
                            * either a 14-bit FLC (127 <= level <= 127),
                            * or a 22-bit FLC (255 <= level <= 255).
                            * This is described in Annex B,B.5f of MPEG-1.standard
                            *-----------------------------------------------------------*/

 /*-----------------------------------------------------------
                            * First 6 bits are the value of the Run. Next is First 8 bits
                            * of Level. These bits decide whether it is 14 bit FLC or
                            * 22-bit FLC.
                            *
                            * If( first 8 bits of Level == '1000000' or '00000000')
                            *      then its is 22-bit FLC.
                            * else
                            *      it is 14-bit FLC.
                            *-----------------------------------------------------------*/
                            u4_sym_len         = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)
                                u4_decoded_value     = u4_bits;
                            u4_run              = (u4_decoded_value >> 8);
                            u4_level_first_byte = (u4_decoded_value & 0x0FF);
 if(u4_level_first_byte & 0x7F)
 {
 /*-------------------------------------------------------
                                * First 8 bits of level are neither 1000000 nor 00000000
                                * Hence 14-bit FLC (Last 8 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_First_Byte - 256 : Level_First_Byte
                                *-------------------------------------------------------*/
                                u4_level = (u4_level_first_byte -
 ((u4_level_first_byte & 0x80) << 1));
 }
 else
 {
 /*-------------------------------------------------------
                                * Next 8 bits are either 1000000 or 00000000
                                * Hence 22-bit FLC (Last 16 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_Second_Byte - 256 : Level_Second_Byte
                                *-------------------------------------------------------*/
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)
                                    u4_level = u4_bits;
                                u4_level = (u4_level - (u4_level_first_byte << 1));
 }
                            u4_numCoeffs += u4_run;

                            u4_pos = pu1_scan[u4_numCoeffs++ & 63];

                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 }
 }

                u4_nz_cols |= 1 << (u4_pos & 0x7);
                u4_nz_rows |= 1 << (u4_pos >> 0x3);

 if (u4_numCoeffs > 64)
 {
 return IMPEG2D_MB_TEX_DECODE_ERR;
 }

 }
            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)
 }
 else
 {
 while(1)
 {

                UWORD32 lead_zeros;
                UWORD16 DecodedValue;


                 u4_sym_len = 17;
                 IBITS_NXT(u4_buf, u4_buf_nxt, u4_offset, u4_bits, u4_sym_len)
 
                /* There cannot be more than 11 leading zeros in the decoded
                 * symbol. The symbol is only 17 bits long, so we subtract 15.
                 */
                lead_zeros = CLZ(u4_bits) - 15;
                if (lead_zeros > 11)
                {
                    return IMPEG2D_MB_DATA_DECODE_ERR;
                }
 
                 DecodedValue = gau2_impeg2d_tab_zero_1_9[u4_bits >> 8];
                 u4_sym_len = BITS(DecodedValue, 3, 0);
                u4_level = ((WORD16) DecodedValue) >> 9;

 if (0 != u4_level)
 {
                    u4_run = BITS(DecodedValue, 8,4);

                    u4_numCoeffs       += u4_run;

                    u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                    pu1_pos[*pi4_num_coeffs] = u4_pos;

                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                    pi2_outAddr[*pi4_num_coeffs] = u4_level;
 (*pi4_num_coeffs)++;
 }
 else
 {
 if(DecodedValue == END_OF_BLOCK_ZERO)
 {
                        u4_sym_len = 2;

 break;
 }
 else
 {
                        lead_zeros = CLZ(u4_bits) - 20;/* -15 since we are dealing with WORD32 */
 /*Second table lookup*/
 if (0 != lead_zeros)
 {
                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;

 /* Flush the number of bits */
                            u4_sym_len         = 11 + lead_zeros;

 /* Calculate the address */
                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;

 DecodedValue = gau2_impeg2d_tab_zero_10_16[u4_bits];

                            u4_run = BITS(DecodedValue, 8,4);
                            u4_level = ((WORD16) DecodedValue) >> 9;

                            u4_numCoeffs       += u4_run;

                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
 if (1 == lead_zeros)
                                u4_sym_len--;
 /* flushing */
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 /*Escape Sequence*/
 else if(u2_mpeg2 == 1)
 {
                            u4_sym_len         = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)
                            u4_decoded_value    = u4_bits;
                            u4_run             = (u4_decoded_value >> 12);
                            u4_level           = (u4_decoded_value & 0x0FFF);

 if (u4_level)
                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));

                            u4_numCoeffs           += u4_run;

                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 /*********************************************************************/
 /* MPEG1 Escape Code                                                 */
 /*********************************************************************/
 else
 {
 /*-----------------------------------------------------------
                            * MPEG-1 Stream
                            *
                            * <See D.9.3 of MPEG-2> Run-level escape syntax
                            * Run-level values that cannot be coded with a VLC are coded
                            * by the escape code '0000 01' followed by
                            * either a 14-bit FLC (127 <= level <= 127),
                            * or a 22-bit FLC (255 <= level <= 255).
                            * This is described in Annex B,B.5f of MPEG-1.standard
                            *-----------------------------------------------------------*/

 /*-----------------------------------------------------------
                            * First 6 bits are the value of the Run. Next is First 8 bits
                            * of Level. These bits decide whether it is 14 bit FLC or
                            * 22-bit FLC.
                            *
                            * If( first 8 bits of Level == '1000000' or '00000000')
                            *      then its is 22-bit FLC.
                            * else
                            *      it is 14-bit FLC.
                            *-----------------------------------------------------------*/
                            u4_sym_len             = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)
                            u4_decoded_value        = u4_bits;
                            u4_run                 = (u4_decoded_value >> 8);
                            u4_level_first_byte    = (u4_decoded_value & 0x0FF);
 if(u4_level_first_byte & 0x7F)
 {
 /*-------------------------------------------------------
                                * First 8 bits of level are neither 1000000 nor 00000000
                                * Hence 14-bit FLC (Last 8 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_First_Byte - 256 : Level_First_Byte
                                *-------------------------------------------------------*/
                                u4_level = (u4_level_first_byte -
 ((u4_level_first_byte & 0x80) << 1));
 }
 else
 {
 /*-------------------------------------------------------
                                * Next 8 bits are either 1000000 or 00000000
                                * Hence 22-bit FLC (Last 16 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_Second_Byte - 256 : Level_Second_Byte
                                *-------------------------------------------------------*/
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)
                                u4_level = u4_bits;
                                u4_level = (u4_level - (u4_level_first_byte << 1));
 }
                            u4_numCoeffs           += u4_run;

                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs] = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs] = u4_level;

 (*pi4_num_coeffs)++;
 }
 }
 }

                u4_nz_cols |= 1 << (u4_pos & 0x7);
                u4_nz_rows |= 1 << (u4_pos >> 0x3);
 if (u4_numCoeffs > 64)
 {
 return IMPEG2D_MB_TEX_DECODE_ERR;
 }

 }

            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)

 }

        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)

        ps_dec->u4_non_zero_cols  = u4_nz_cols;
        ps_dec->u4_non_zero_rows  = u4_nz_rows;

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
","The `impeg2d_vld_decode` function decodes variable-length coded (VLC) symbols from a bitstream for MPEG-2 video compression, specifically handling intra and non-intra macroblocks. It takes several parameters, including the decoding state, output address for decoded symbols, scan tables, flags for intra and chroma blocks, and a pointer to store the number of coefficients. The function processes the bitstream to extract DC and AC coefficients, managing Huffman decoding and escape sequences for values that cannot be directly represented. It updates the output address with decoded values and tracks the number of non-zero coefficients, returning an error code upon completion.","The provided code implements a decoding function for variable-length coded symbols in MPEG-2 video compression, focusing on both intra and non-intra macroblocks. It processes a bitstream to extract coefficients, handling different cases for DC and AC coefficients, including special escape sequences for values that cannot be directly represented. The function updates an output array with the decoded coefficients and tracks the number of non-zero coefficients, which are essential for reconstructing the video data. It also manages the state of the bitstream throughout the decoding process and returns an error code upon completion.","The vulnerability in the original code stemmed from a lack of validation for the number of leading zeros in variable-length decoded (VLD) symbols, which could lead to buffer overflows or incorrect decoding if the number exceeded the expected maximum of 11 for a 17-bit symbol. This was addressed in the fixed code by introducing a check that calculates the number of leading zeros and returns an error if this value exceeds 11. This safeguard ensures that the decoding process remains within safe limits, preventing potential exploitation or crashes due to malformed input.","The vulnerability in the original code was due to the absence of a check for the maximum number of leading zeros in variable-length decoded symbols, which could lead to buffer overflows or incorrect processing if the count exceeded the expected limit. This issue was addressed in the updated code by implementing a validation step that ensures the number of leading zeros does not exceed 11 for a 17-bit symbol. This fix enhances the robustness of the decoding process, preventing potential exploitation or crashes from malformed input and ensuring that the system handles data safely and correctly.","The vulnerability was fixed by adding a validation check for the number of leading zeros in the variable-length decoded symbols. In the updated code, the calculation of leading zeros is performed using a specific function, and if the result exceeds 11, an error code is returned. This check is implemented right after calculating the leading zeros from the decoded bits, ensuring that any symbol with an invalid number of leading zeros is promptly flagged. This enhancement prevents potential buffer overflows and ensures that the decoding process adheres to the expected limits, thereby improving overall code safety and reliability.","The vulnerability was fixed by introducing a validation mechanism that checks the number of leading zeros in the decoded symbols. The updated code calculates the leading zeros and ensures that this count does not exceed the maximum allowable limit. If the count is found to be greater than the specified threshold, the code returns an error, effectively preventing any further processing of potentially malformed data. This safeguard enhances the robustness of the decoding process, mitigating risks associated with buffer overflows and ensuring that the system can handle input safely and correctly.","4,5","4,4","4,4","4,4"
120,120,188058,188058,,Remote,Not required,,CVE-2017-0556,https://www.cvedetails.com/cve/CVE-2017-0556/,CWE-200,Medium,Partial,,,2017-04-07,4.3,"An information disclosure vulnerability in libmpeg2 in Mediaserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access data without permission. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-34093952.",2017-07-10,+Info ,4,https://android.googlesource.com/platform/external/libmpeg2/+/f301cff2c1ddd880d9a2c77b22602a137519867b,f301cff2c1ddd880d9a2c77b22602a137519867b,"Check for Valid Frame Rate in Header

Bug: 34093952
Change-Id: I9f009edda84555e8d14b138684a38114fb888bf8
(cherry picked from commit 3f068a4e66cc972cf798c79a196099bd7d3bfceb)
",0,decoder/impeg2d_dec_hdr.c,"{""filename"": ""decoder/impeg2d_dec_hdr.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/f301cff2c1ddd880d9a2c77b22602a137519867b/decoder/impeg2d_dec_hdr.c"", ""patch"": ""@@ -43,6 +43,10 @@\n\n #include \""impeg2d_pic_proc.h\""\n \n \n+/*****************************************************************************\n+* MPEG2 Constants for Parse Check\n+******************************************************************************/\n+#define MPEG2_MAX_FRAME_RATE_CODE   8\n \n /******************************************************************************\n *  Function Name   : impeg2d_next_start_code\n@@ -198,6 +202,10 @@\n\n     /* Frame rate code(4 bits)                                                */\n     /*------------------------------------------------------------------------*/\n     ps_dec->u2_frame_rate_code = impeg2d_bit_stream_get(ps_stream,4);\n+    if (ps_dec->u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE)\n+    {\n+        return IMPEG2D_FRM_HDR_DECODE_ERR;\n+    }\n     /*------------------------------------------------------------------------*/\n     /* Flush the following as they are not being used                         */\n     /* bit_rate_value (18 bits)                                               */\n""}","IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;
    UWORD16 u2_height;
    UWORD16 u2_width;

 if (impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != SEQUENCE_HEADER_CODE)
 {
        impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
 return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND;

 }
    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);

    u2_width    = impeg2d_bit_stream_get(ps_stream,12);
    u2_height   = impeg2d_bit_stream_get(ps_stream,12);

 if ((u2_width != ps_dec->u2_horizontal_size)
 || (u2_height != ps_dec->u2_vertical_size))
 {
 if (0 == ps_dec->u2_header_done)
 {
 /* This is the first time we are reading the resolution */
            ps_dec->u2_horizontal_size = u2_width;
            ps_dec->u2_vertical_size = u2_height;
 if (0 == ps_dec->u4_frm_buf_stride)
 {
                ps_dec->u4_frm_buf_stride  = (UWORD32) ALIGN16(u2_width);
 }
 }
 else
 {
 if((u2_width > ps_dec->u2_create_max_width)
 || (u2_height > ps_dec->u2_create_max_height))
 {
                IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;

                ps_dec->u2_reinit_max_height   = u2_height;
                ps_dec->u2_reinit_max_width    = u2_width;

 return e_error;
 }
 else
 {
 /* The resolution has changed */
 return (IMPEG2D_ERROR_CODES_T)IVD_RES_CHANGED;
 }
 }
 }

 if((ps_dec->u2_horizontal_size > ps_dec->u2_create_max_width)
 || (ps_dec->u2_vertical_size > ps_dec->u2_create_max_height))
 {
        IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;
 return SET_IVD_FATAL_ERROR(e_error);
 }


 /*------------------------------------------------------------------------*/
 /* Flush the following as they are not being used                         */
 /* aspect_ratio_info (4 bits)                                             */
 /*------------------------------------------------------------------------*/
    ps_dec->u2_aspect_ratio_info = impeg2d_bit_stream_get(ps_stream,4);

 /*------------------------------------------------------------------------*/

     /* Frame rate code(4 bits)                                                */
     /*------------------------------------------------------------------------*/
     ps_dec->u2_frame_rate_code = impeg2d_bit_stream_get(ps_stream,4);
    if (ps_dec->u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE)
    {
        return IMPEG2D_FRM_HDR_DECODE_ERR;
    }
     /*------------------------------------------------------------------------*/
     /* Flush the following as they are not being used                         */
     /* bit_rate_value (18 bits)                                               */
 /*------------------------------------------------------------------------*/
    impeg2d_bit_stream_flush(ps_stream,18);
    GET_MARKER_BIT(ps_dec,ps_stream);
 /*------------------------------------------------------------------------*/
 /* Flush the following as they are not being used                         */
 /* vbv_buffer_size_value(10 bits), constrained_parameter_flag (1 bit)     */
 /*------------------------------------------------------------------------*/
    impeg2d_bit_stream_flush(ps_stream,11);

 /*------------------------------------------------------------------------*/
 /* Quantization matrix for the intra blocks                               */
 /*------------------------------------------------------------------------*/
 if(impeg2d_bit_stream_get_bit(ps_stream) == 1)
 {
        UWORD16 i;
 for(i = 0; i < NUM_PELS_IN_BLOCK; i++)
 {
            ps_dec->au1_intra_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);
 }

 }
 else
 {
        memcpy(ps_dec->au1_intra_quant_matrix,gau1_impeg2_intra_quant_matrix_default,
                NUM_PELS_IN_BLOCK);
 }

 /*------------------------------------------------------------------------*/
 /* Quantization matrix for the inter blocks                               */
 /*------------------------------------------------------------------------*/
 if(impeg2d_bit_stream_get_bit(ps_stream) == 1)
 {
        UWORD16 i;
 for(i = 0; i < NUM_PELS_IN_BLOCK; i++)
 {
            ps_dec->au1_inter_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);
 }
 }
 else
 {
        memcpy(ps_dec->au1_inter_quant_matrix,gau1_impeg2_inter_quant_matrix_default,
            NUM_PELS_IN_BLOCK);
 }
    impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
","IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;
    UWORD16 u2_height;
    UWORD16 u2_width;

 if (impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != SEQUENCE_HEADER_CODE)
 {
        impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
 return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND;

 }
    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);

    u2_width    = impeg2d_bit_stream_get(ps_stream,12);
    u2_height   = impeg2d_bit_stream_get(ps_stream,12);

 if ((u2_width != ps_dec->u2_horizontal_size)
 || (u2_height != ps_dec->u2_vertical_size))
 {
 if (0 == ps_dec->u2_header_done)
 {
 /* This is the first time we are reading the resolution */
            ps_dec->u2_horizontal_size = u2_width;
            ps_dec->u2_vertical_size = u2_height;
 if (0 == ps_dec->u4_frm_buf_stride)
 {
                ps_dec->u4_frm_buf_stride  = (UWORD32) ALIGN16(u2_width);
 }
 }
 else
 {
 if((u2_width > ps_dec->u2_create_max_width)
 || (u2_height > ps_dec->u2_create_max_height))
 {
                IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;

                ps_dec->u2_reinit_max_height   = u2_height;
                ps_dec->u2_reinit_max_width    = u2_width;

 return e_error;
 }
 else
 {
 /* The resolution has changed */
 return (IMPEG2D_ERROR_CODES_T)IVD_RES_CHANGED;
 }
 }
 }

 if((ps_dec->u2_horizontal_size > ps_dec->u2_create_max_width)
 || (ps_dec->u2_vertical_size > ps_dec->u2_create_max_height))
 {
        IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;
 return SET_IVD_FATAL_ERROR(e_error);
 }


 /*------------------------------------------------------------------------*/
 /* Flush the following as they are not being used                         */
 /* aspect_ratio_info (4 bits)                                             */
 /*------------------------------------------------------------------------*/
    ps_dec->u2_aspect_ratio_info = impeg2d_bit_stream_get(ps_stream,4);

 /*------------------------------------------------------------------------*/

     /* Frame rate code(4 bits)                                                */
     /*------------------------------------------------------------------------*/
     ps_dec->u2_frame_rate_code = impeg2d_bit_stream_get(ps_stream,4);
     /*------------------------------------------------------------------------*/
     /* Flush the following as they are not being used                         */
     /* bit_rate_value (18 bits)                                               */
 /*------------------------------------------------------------------------*/
    impeg2d_bit_stream_flush(ps_stream,18);
    GET_MARKER_BIT(ps_dec,ps_stream);
 /*------------------------------------------------------------------------*/
 /* Flush the following as they are not being used                         */
 /* vbv_buffer_size_value(10 bits), constrained_parameter_flag (1 bit)     */
 /*------------------------------------------------------------------------*/
    impeg2d_bit_stream_flush(ps_stream,11);

 /*------------------------------------------------------------------------*/
 /* Quantization matrix for the intra blocks                               */
 /*------------------------------------------------------------------------*/
 if(impeg2d_bit_stream_get_bit(ps_stream) == 1)
 {
        UWORD16 i;
 for(i = 0; i < NUM_PELS_IN_BLOCK; i++)
 {
            ps_dec->au1_intra_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);
 }

 }
 else
 {
        memcpy(ps_dec->au1_intra_quant_matrix,gau1_impeg2_intra_quant_matrix_default,
                NUM_PELS_IN_BLOCK);
 }

 /*------------------------------------------------------------------------*/
 /* Quantization matrix for the inter blocks                               */
 /*------------------------------------------------------------------------*/
 if(impeg2d_bit_stream_get_bit(ps_stream) == 1)
 {
        UWORD16 i;
 for(i = 0; i < NUM_PELS_IN_BLOCK; i++)
 {
            ps_dec->au1_inter_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);
 }
 }
 else
 {
        memcpy(ps_dec->au1_inter_quant_matrix,gau1_impeg2_inter_quant_matrix_default,
            NUM_PELS_IN_BLOCK);
 }
    impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
",C,"    if (ps_dec->u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE)
    {
        return IMPEG2D_FRM_HDR_DECODE_ERR;
    }
",,,"@@ -43,6 +43,10 @@

 #include ""impeg2d_pic_proc.h""
 
 
+/*****************************************************************************
+* MPEG2 Constants for Parse Check
+******************************************************************************/
+#define MPEG2_MAX_FRAME_RATE_CODE   8
 
 /******************************************************************************
 *  Function Name   : impeg2d_next_start_code
@@ -198,6 +202,10 @@

     /* Frame rate code(4 bits)                                                */
     /*------------------------------------------------------------------------*/
     ps_dec->u2_frame_rate_code = impeg2d_bit_stream_get(ps_stream,4);
+    if (ps_dec->u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE)
+    {
+        return IMPEG2D_FRM_HDR_DECODE_ERR;
+    }
     /*------------------------------------------------------------------------*/
     /* Flush the following as they are not being used                         */
     /* bit_rate_value (18 bits)                                               */
",Android,https://android.googlesource.com/platform/external/libmpeg2/+/f301cff2c1ddd880d9a2c77b22602a137519867b/,https://android.googlesource.com/platform/external/libmpeg2/+/f301cff2c1ddd880d9a2c77b22602a137519867b%5E/,1,"IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;
    UWORD16 u2_height;
    UWORD16 u2_width;

 if (impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != SEQUENCE_HEADER_CODE)
 {
        impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
 return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND;

 }
    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);

    u2_width    = impeg2d_bit_stream_get(ps_stream,12);
    u2_height   = impeg2d_bit_stream_get(ps_stream,12);

 if ((u2_width != ps_dec->u2_horizontal_size)
 || (u2_height != ps_dec->u2_vertical_size))
 {
 if (0 == ps_dec->u2_header_done)
 {
 /* This is the first time we are reading the resolution */
            ps_dec->u2_horizontal_size = u2_width;
            ps_dec->u2_vertical_size = u2_height;
 if (0 == ps_dec->u4_frm_buf_stride)
 {
                ps_dec->u4_frm_buf_stride  = (UWORD32) ALIGN16(u2_width);
 }
 }
 else
 {
 if((u2_width > ps_dec->u2_create_max_width)
 || (u2_height > ps_dec->u2_create_max_height))
 {
                IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;

                ps_dec->u2_reinit_max_height   = u2_height;
                ps_dec->u2_reinit_max_width    = u2_width;

 return e_error;
 }
 else
 {
 /* The resolution has changed */
 return (IMPEG2D_ERROR_CODES_T)IVD_RES_CHANGED;
 }
 }
 }

 if((ps_dec->u2_horizontal_size > ps_dec->u2_create_max_width)
 || (ps_dec->u2_vertical_size > ps_dec->u2_create_max_height))
 {
        IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;
 return SET_IVD_FATAL_ERROR(e_error);
 }


 /*------------------------------------------------------------------------*/
 /* Flush the following as they are not being used                         */
 /* aspect_ratio_info (4 bits)                                             */
 /*------------------------------------------------------------------------*/
    ps_dec->u2_aspect_ratio_info = impeg2d_bit_stream_get(ps_stream,4);

 /*------------------------------------------------------------------------*/

     /* Frame rate code(4 bits)                                                */
     /*------------------------------------------------------------------------*/
     ps_dec->u2_frame_rate_code = impeg2d_bit_stream_get(ps_stream,4);
//fix_flaw_line_below:
//    if (ps_dec->u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE)
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//        return IMPEG2D_FRM_HDR_DECODE_ERR;
//fix_flaw_line_below:
//    }
     /*------------------------------------------------------------------------*/
     /* Flush the following as they are not being used                         */
     /* bit_rate_value (18 bits)                                               */
 /*------------------------------------------------------------------------*/
    impeg2d_bit_stream_flush(ps_stream,18);
    GET_MARKER_BIT(ps_dec,ps_stream);
 /*------------------------------------------------------------------------*/
 /* Flush the following as they are not being used                         */
 /* vbv_buffer_size_value(10 bits), constrained_parameter_flag (1 bit)     */
 /*------------------------------------------------------------------------*/
    impeg2d_bit_stream_flush(ps_stream,11);

 /*------------------------------------------------------------------------*/
 /* Quantization matrix for the intra blocks                               */
 /*------------------------------------------------------------------------*/
 if(impeg2d_bit_stream_get_bit(ps_stream) == 1)
 {
        UWORD16 i;
 for(i = 0; i < NUM_PELS_IN_BLOCK; i++)
 {
            ps_dec->au1_intra_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);
 }

 }
 else
 {
        memcpy(ps_dec->au1_intra_quant_matrix,gau1_impeg2_intra_quant_matrix_default,
                NUM_PELS_IN_BLOCK);
 }

 /*------------------------------------------------------------------------*/
 /* Quantization matrix for the inter blocks                               */
 /*------------------------------------------------------------------------*/
 if(impeg2d_bit_stream_get_bit(ps_stream) == 1)
 {
        UWORD16 i;
 for(i = 0; i < NUM_PELS_IN_BLOCK; i++)
 {
            ps_dec->au1_inter_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);
 }
 }
 else
 {
        memcpy(ps_dec->au1_inter_quant_matrix,gau1_impeg2_inter_quant_matrix_default,
            NUM_PELS_IN_BLOCK);
 }
    impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
",188058,"IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;
    UWORD16 u2_height;
    UWORD16 u2_width;

 if (impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != SEQUENCE_HEADER_CODE)
 {
        impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
 return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND;

 }
    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);

    u2_width    = impeg2d_bit_stream_get(ps_stream,12);
    u2_height   = impeg2d_bit_stream_get(ps_stream,12);

 if ((u2_width != ps_dec->u2_horizontal_size)
 || (u2_height != ps_dec->u2_vertical_size))
 {
 if (0 == ps_dec->u2_header_done)
 {
 /* This is the first time we are reading the resolution */
            ps_dec->u2_horizontal_size = u2_width;
            ps_dec->u2_vertical_size = u2_height;
 if (0 == ps_dec->u4_frm_buf_stride)
 {
                ps_dec->u4_frm_buf_stride  = (UWORD32) ALIGN16(u2_width);
 }
 }
 else
 {
 if((u2_width > ps_dec->u2_create_max_width)
 || (u2_height > ps_dec->u2_create_max_height))
 {
                IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;

                ps_dec->u2_reinit_max_height   = u2_height;
                ps_dec->u2_reinit_max_width    = u2_width;

 return e_error;
 }
 else
 {
 /* The resolution has changed */
 return (IMPEG2D_ERROR_CODES_T)IVD_RES_CHANGED;
 }
 }
 }

 if((ps_dec->u2_horizontal_size > ps_dec->u2_create_max_width)
 || (ps_dec->u2_vertical_size > ps_dec->u2_create_max_height))
 {
        IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;
 return SET_IVD_FATAL_ERROR(e_error);
 }


 /*------------------------------------------------------------------------*/
 /* Flush the following as they are not being used                         */
 /* aspect_ratio_info (4 bits)                                             */
 /*------------------------------------------------------------------------*/
    ps_dec->u2_aspect_ratio_info = impeg2d_bit_stream_get(ps_stream,4);

 /*------------------------------------------------------------------------*/

     /* Frame rate code(4 bits)                                                */
     /*------------------------------------------------------------------------*/
     ps_dec->u2_frame_rate_code = impeg2d_bit_stream_get(ps_stream,4);
     /*------------------------------------------------------------------------*/
     /* Flush the following as they are not being used                         */
     /* bit_rate_value (18 bits)                                               */
 /*------------------------------------------------------------------------*/
    impeg2d_bit_stream_flush(ps_stream,18);
    GET_MARKER_BIT(ps_dec,ps_stream);
 /*------------------------------------------------------------------------*/
 /* Flush the following as they are not being used                         */
 /* vbv_buffer_size_value(10 bits), constrained_parameter_flag (1 bit)     */
 /*------------------------------------------------------------------------*/
    impeg2d_bit_stream_flush(ps_stream,11);

 /*------------------------------------------------------------------------*/
 /* Quantization matrix for the intra blocks                               */
 /*------------------------------------------------------------------------*/
 if(impeg2d_bit_stream_get_bit(ps_stream) == 1)
 {
        UWORD16 i;
 for(i = 0; i < NUM_PELS_IN_BLOCK; i++)
 {
            ps_dec->au1_intra_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);
 }

 }
 else
 {
        memcpy(ps_dec->au1_intra_quant_matrix,gau1_impeg2_intra_quant_matrix_default,
                NUM_PELS_IN_BLOCK);
 }

 /*------------------------------------------------------------------------*/
 /* Quantization matrix for the inter blocks                               */
 /*------------------------------------------------------------------------*/
 if(impeg2d_bit_stream_get_bit(ps_stream) == 1)
 {
        UWORD16 i;
 for(i = 0; i < NUM_PELS_IN_BLOCK; i++)
 {
            ps_dec->au1_inter_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);
 }
 }
 else
 {
        memcpy(ps_dec->au1_inter_quant_matrix,gau1_impeg2_inter_quant_matrix_default,
            NUM_PELS_IN_BLOCK);
 }
    impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
","IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;
    UWORD16 u2_height;
    UWORD16 u2_width;

 if (impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != SEQUENCE_HEADER_CODE)
 {
        impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
 return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND;

 }
    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);

    u2_width    = impeg2d_bit_stream_get(ps_stream,12);
    u2_height   = impeg2d_bit_stream_get(ps_stream,12);

 if ((u2_width != ps_dec->u2_horizontal_size)
 || (u2_height != ps_dec->u2_vertical_size))
 {
 if (0 == ps_dec->u2_header_done)
 {
 /* This is the first time we are reading the resolution */
            ps_dec->u2_horizontal_size = u2_width;
            ps_dec->u2_vertical_size = u2_height;
 if (0 == ps_dec->u4_frm_buf_stride)
 {
                ps_dec->u4_frm_buf_stride  = (UWORD32) ALIGN16(u2_width);
 }
 }
 else
 {
 if((u2_width > ps_dec->u2_create_max_width)
 || (u2_height > ps_dec->u2_create_max_height))
 {
                IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;

                ps_dec->u2_reinit_max_height   = u2_height;
                ps_dec->u2_reinit_max_width    = u2_width;

 return e_error;
 }
 else
 {
 /* The resolution has changed */
 return (IMPEG2D_ERROR_CODES_T)IVD_RES_CHANGED;
 }
 }
 }

 if((ps_dec->u2_horizontal_size > ps_dec->u2_create_max_width)
 || (ps_dec->u2_vertical_size > ps_dec->u2_create_max_height))
 {
        IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;
 return SET_IVD_FATAL_ERROR(e_error);
 }


 /*------------------------------------------------------------------------*/
 /* Flush the following as they are not being used                         */
 /* aspect_ratio_info (4 bits)                                             */
 /*------------------------------------------------------------------------*/
    ps_dec->u2_aspect_ratio_info = impeg2d_bit_stream_get(ps_stream,4);

 /*------------------------------------------------------------------------*/

     /* Frame rate code(4 bits)                                                */
     /*------------------------------------------------------------------------*/
     ps_dec->u2_frame_rate_code = impeg2d_bit_stream_get(ps_stream,4);
    if (ps_dec->u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE)
    {
        return IMPEG2D_FRM_HDR_DECODE_ERR;
    }
     /*------------------------------------------------------------------------*/
     /* Flush the following as they are not being used                         */
     /* bit_rate_value (18 bits)                                               */
 /*------------------------------------------------------------------------*/
    impeg2d_bit_stream_flush(ps_stream,18);
    GET_MARKER_BIT(ps_dec,ps_stream);
 /*------------------------------------------------------------------------*/
 /* Flush the following as they are not being used                         */
 /* vbv_buffer_size_value(10 bits), constrained_parameter_flag (1 bit)     */
 /*------------------------------------------------------------------------*/
    impeg2d_bit_stream_flush(ps_stream,11);

 /*------------------------------------------------------------------------*/
 /* Quantization matrix for the intra blocks                               */
 /*------------------------------------------------------------------------*/
 if(impeg2d_bit_stream_get_bit(ps_stream) == 1)
 {
        UWORD16 i;
 for(i = 0; i < NUM_PELS_IN_BLOCK; i++)
 {
            ps_dec->au1_intra_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);
 }

 }
 else
 {
        memcpy(ps_dec->au1_intra_quant_matrix,gau1_impeg2_intra_quant_matrix_default,
                NUM_PELS_IN_BLOCK);
 }

 /*------------------------------------------------------------------------*/
 /* Quantization matrix for the inter blocks                               */
 /*------------------------------------------------------------------------*/
 if(impeg2d_bit_stream_get_bit(ps_stream) == 1)
 {
        UWORD16 i;
 for(i = 0; i < NUM_PELS_IN_BLOCK; i++)
 {
            ps_dec->au1_inter_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);
 }
 }
 else
 {
        memcpy(ps_dec->au1_inter_quant_matrix,gau1_impeg2_inter_quant_matrix_default,
            NUM_PELS_IN_BLOCK);
 }
    impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
","The function `impeg2d_dec_seq_hdr` processes the sequence header of an MPEG-2 video stream, extracting essential parameters such as width, height, aspect ratio, frame rate, and quantization matrices for intra and inter blocks. It first checks for the presence of a sequence header start code, retrieves the video dimensions, and validates them against predefined limits. If the dimensions change after the header has been processed, it returns an error. The function also handles flushing unused bits from the bitstream and initializes quantization matrices, either from the stream or default values, before concluding with a successful error code or an error indication.","The code processes the sequence header of a video stream, extracting key parameters such as resolution, aspect ratio, frame rate, and quantization matrices. It first verifies the presence of a specific start code, then retrieves and checks the video dimensions against predefined limits. If the dimensions change after initial processing, it returns an error. The code also discards unused bits from the stream and initializes quantization matrices, either from the stream data or default values. Finally, it concludes by returning a success or error status based on the processing results.","The vulnerability in the original code stemmed from the lack of validation for the frame rate extracted from the video stream header, which could lead to processing invalid or unsupported frame rates, potentially causing undefined behavior or crashes. The fixed code addresses this issue by introducing a check that verifies if the extracted frame rate exceeds a predefined maximum value. If the frame rate is invalid, the function returns an error code, ensuring that only valid frame rates are processed, thereby enhancing the robustness and stability of the video decoding functionality.","The vulnerability in the original code arose from the absence of validation for the frame rate extracted from the video stream header, which could allow unsupported or invalid frame rates to be processed, potentially leading to crashes or unpredictable behavior. The fixed code addresses this issue by implementing a check to ensure that the extracted frame rate does not exceed a predefined maximum limit. By returning an error when an invalid frame rate is detected, the code enhances the overall stability and reliability of the video decoding process, preventing issues related to improper frame rate handling.","The vulnerability was fixed by adding a validation check for the frame rate code extracted from the bitstream. In the updated code, after retrieving the frame rate, a conditional statement checks if the frame rate exceeds a predefined maximum value. If the condition is met, the function returns an error code indicating a decoding error. This ensures that only valid frame rates are processed, preventing potential crashes or undefined behavior that could arise from unsupported frame rates. This enhancement significantly improves the robustness of the video decoding functionality by enforcing stricter input validation.","The vulnerability was fixed by introducing a validation step that checks the extracted frame rate against a predefined maximum limit. This additional check ensures that any frame rate exceeding this limit triggers an error response, preventing the processing of invalid or unsupported frame rates. By implementing this safeguard, the code enhances its robustness and stability, effectively mitigating the risk of crashes or unpredictable behavior that could occur from handling improper frame rates. This change reinforces the overall integrity of the video decoding process by ensuring that only valid parameters are accepted.","4,4","3, 3","4,4","4,4"
121,121,188069,188069,,Remote,Not required,,CVE-2017-0547,https://www.cvedetails.com/cve/CVE-2017-0547/,CWE-200,Medium,Partial,,,2017-04-07,4.3,"An information disclosure vulnerability in libmedia in Mediaserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as High because it is a general bypass for operating system protections that isolate application data from other applications. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-33861560.",2017-07-10,Bypass +Info ,10,https://android.googlesource.com/platform/frameworks/av/+/9667e3eff2d34c3797c3b529370de47b2c1f1bf6,9667e3eff2d34c3797c3b529370de47b2c1f1bf6,"Fix overflow check and check read result

Bug: 33861560
Test: build
Change-Id: Ia85519766e19a6e37237166f309750b3e8323c4e
",5,media/libmedia/IHDCP.cpp,"{""filename"": ""media/libmedia/IHDCP.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/9667e3eff2d34c3797c3b529370de47b2c1f1bf6/media/libmedia/IHDCP.cpp"", ""patch"": ""@@ -241,14 +241,11 @@\n\n         case HDCP_ENCRYPT:\n         {\n             size_t size = data.readInt32();\n-            size_t bufSize = 2 * size;\n-\n-            // watch out for overflow\n             void *inData = NULL;\n-            if (bufSize > size) {\n-                inData = malloc(bufSize);\n+            // watch out for overflow\n+            if (size <= SIZE_MAX / 2) {\n+                inData = malloc(2 * size);\n             }\n-\n             if (inData == NULL) {\n                 reply->writeInt32(ERROR_OUT_OF_RANGE);\n                 return OK;\n@@ -256,11 +253,16 @@\n\n \n             void *outData = (uint8_t *)inData + size;\n \n-            data.read(inData, size);\n+            status_t err = data.read(inData, size);\n+            if (err != OK) {\n+                free(inData);\n+                reply->writeInt32(err);\n+                return OK;\n+            }\n \n             uint32_t streamCTR = data.readInt32();\n             uint64_t inputCTR;\n-            status_t err = encrypt(inData, size, streamCTR, &inputCTR, outData);\n+            err = encrypt(inData, size, streamCTR, &inputCTR, outData);\n \n             reply->writeInt32(err);\n \n""}","status_t BnHDCP::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case HDCP_SET_OBSERVER:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            sp<IHDCPObserver> observer =
                interface_cast<IHDCPObserver>(data.readStrongBinder());

            reply->writeInt32(setObserver(observer));
 return OK;
 }

 case HDCP_INIT_ASYNC:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

 const char *host = data.readCString();
 unsigned port = data.readInt32();

            reply->writeInt32(initAsync(host, port));
 return OK;
 }

 case HDCP_SHUTDOWN_ASYNC:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            reply->writeInt32(shutdownAsync());
 return OK;
 }

 case HDCP_GET_CAPS:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            reply->writeInt32(getCaps());
 return OK;
 }


         case HDCP_ENCRYPT:
         {
             size_t size = data.readInt32();
            // watch out for overflow
            if (size <= SIZE_MAX / 2) {
                inData = malloc(2 * size);
             }
             if (inData == NULL) {
                 reply->writeInt32(ERROR_OUT_OF_RANGE);
                 return OK;
 }

 
             void *outData = (uint8_t *)inData + size;
 
            status_t err = data.read(inData, size);
            if (err != OK) {
                free(inData);
                reply->writeInt32(err);
                return OK;
            }
 
             uint32_t streamCTR = data.readInt32();
             uint64_t inputCTR;
            err = encrypt(inData, size, streamCTR, &inputCTR, outData);
 
             reply->writeInt32(err);
 
 if (err == OK) {
                reply->writeInt64(inputCTR);
                reply->write(outData, size);
 }

            free(inData);
            inData = outData = NULL;

 return OK;
 }

 case HDCP_ENCRYPT_NATIVE:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
 size_t offset = data.readInt32();
 size_t size = data.readInt32();
 uint32_t streamCTR = data.readInt32();
 void *outData = malloc(size);
 uint64_t inputCTR;

 status_t err = encryptNative(graphicBuffer, offset, size,
                                         streamCTR, &inputCTR, outData);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt64(inputCTR);
                reply->write(outData, size);
 }

            free(outData);
            outData = NULL;

 return OK;
 }

 case HDCP_DECRYPT:
 {
 size_t size = data.readInt32();
 size_t bufSize = 2 * size;

 void *inData = NULL;
 if (bufSize > size) {
                inData = malloc(bufSize);
 }

 if (inData == NULL) {
                reply->writeInt32(ERROR_OUT_OF_RANGE);
 return OK;
 }

 void *outData = (uint8_t *)inData + size;

            data.read(inData, size);

 uint32_t streamCTR = data.readInt32();
 uint64_t inputCTR = data.readInt64();
 status_t err = decrypt(inData, size, streamCTR, inputCTR, outData);

            reply->writeInt32(err);

 if (err == OK) {
                reply->write(outData, size);
 }

            free(inData);
            inData = outData = NULL;

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","status_t BnHDCP::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case HDCP_SET_OBSERVER:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            sp<IHDCPObserver> observer =
                interface_cast<IHDCPObserver>(data.readStrongBinder());

            reply->writeInt32(setObserver(observer));
 return OK;
 }

 case HDCP_INIT_ASYNC:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

 const char *host = data.readCString();
 unsigned port = data.readInt32();

            reply->writeInt32(initAsync(host, port));
 return OK;
 }

 case HDCP_SHUTDOWN_ASYNC:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            reply->writeInt32(shutdownAsync());
 return OK;
 }

 case HDCP_GET_CAPS:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            reply->writeInt32(getCaps());
 return OK;
 }


         case HDCP_ENCRYPT:
         {
             size_t size = data.readInt32();
            size_t bufSize = 2 * size;
            if (bufSize > size) {
                inData = malloc(bufSize);
             }
             if (inData == NULL) {
                 reply->writeInt32(ERROR_OUT_OF_RANGE);
                 return OK;
 }

 
             void *outData = (uint8_t *)inData + size;
 
            data.read(inData, size);
 
             uint32_t streamCTR = data.readInt32();
             uint64_t inputCTR;
            status_t err = encrypt(inData, size, streamCTR, &inputCTR, outData);
 
             reply->writeInt32(err);
 
 if (err == OK) {
                reply->writeInt64(inputCTR);
                reply->write(outData, size);
 }

            free(inData);
            inData = outData = NULL;

 return OK;
 }

 case HDCP_ENCRYPT_NATIVE:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
 size_t offset = data.readInt32();
 size_t size = data.readInt32();
 uint32_t streamCTR = data.readInt32();
 void *outData = malloc(size);
 uint64_t inputCTR;

 status_t err = encryptNative(graphicBuffer, offset, size,
                                         streamCTR, &inputCTR, outData);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt64(inputCTR);
                reply->write(outData, size);
 }

            free(outData);
            outData = NULL;

 return OK;
 }

 case HDCP_DECRYPT:
 {
 size_t size = data.readInt32();
 size_t bufSize = 2 * size;

 void *inData = NULL;
 if (bufSize > size) {
                inData = malloc(bufSize);
 }

 if (inData == NULL) {
                reply->writeInt32(ERROR_OUT_OF_RANGE);
 return OK;
 }

 void *outData = (uint8_t *)inData + size;

            data.read(inData, size);

 uint32_t streamCTR = data.readInt32();
 uint64_t inputCTR = data.readInt64();
 status_t err = decrypt(inData, size, streamCTR, inputCTR, outData);

            reply->writeInt32(err);

 if (err == OK) {
                reply->write(outData, size);
 }

            free(inData);
            inData = outData = NULL;

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
",C,"            // watch out for overflow
            if (size <= SIZE_MAX / 2) {
                inData = malloc(2 * size);
            status_t err = data.read(inData, size);
            if (err != OK) {
                free(inData);
                reply->writeInt32(err);
                return OK;
            }
            err = encrypt(inData, size, streamCTR, &inputCTR, outData);
","            size_t bufSize = 2 * size;
            if (bufSize > size) {
                inData = malloc(bufSize);
            data.read(inData, size);
            status_t err = encrypt(inData, size, streamCTR, &inputCTR, outData);
",,"@@ -241,14 +241,11 @@

         case HDCP_ENCRYPT:
         {
             size_t size = data.readInt32();
-            size_t bufSize = 2 * size;
-
-            // watch out for overflow
             void *inData = NULL;
-            if (bufSize > size) {
-                inData = malloc(bufSize);
+            // watch out for overflow
+            if (size <= SIZE_MAX / 2) {
+                inData = malloc(2 * size);
             }
-
             if (inData == NULL) {
                 reply->writeInt32(ERROR_OUT_OF_RANGE);
                 return OK;
@@ -256,11 +253,16 @@

 
             void *outData = (uint8_t *)inData + size;
 
-            data.read(inData, size);
+            status_t err = data.read(inData, size);
+            if (err != OK) {
+                free(inData);
+                reply->writeInt32(err);
+                return OK;
+            }
 
             uint32_t streamCTR = data.readInt32();
             uint64_t inputCTR;
-            status_t err = encrypt(inData, size, streamCTR, &inputCTR, outData);
+            err = encrypt(inData, size, streamCTR, &inputCTR, outData);
 
             reply->writeInt32(err);
 
",Android,https://android.googlesource.com/platform/frameworks/av/+/9667e3eff2d34c3797c3b529370de47b2c1f1bf6/,https://android.googlesource.com/platform/frameworks/av/+/9667e3eff2d34c3797c3b529370de47b2c1f1bf6%5E/,1,"status_t BnHDCP::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case HDCP_SET_OBSERVER:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            sp<IHDCPObserver> observer =
                interface_cast<IHDCPObserver>(data.readStrongBinder());

            reply->writeInt32(setObserver(observer));
 return OK;
 }

 case HDCP_INIT_ASYNC:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

 const char *host = data.readCString();
 unsigned port = data.readInt32();

            reply->writeInt32(initAsync(host, port));
 return OK;
 }

 case HDCP_SHUTDOWN_ASYNC:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            reply->writeInt32(shutdownAsync());
 return OK;
 }

 case HDCP_GET_CAPS:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            reply->writeInt32(getCaps());
 return OK;
 }


         case HDCP_ENCRYPT:
         {
             size_t size = data.readInt32();
//flaw_line_below:
            size_t bufSize = 2 * size;
//flaw_line_below:

//flaw_line_below:
            // watch out for overflow
             void *inData = NULL;
//flaw_line_below:
            if (bufSize > size) {
//flaw_line_below:
                inData = malloc(bufSize);
//fix_flaw_line_below:
//            // watch out for overflow
//fix_flaw_line_below:
//            if (size <= SIZE_MAX / 2) {
//fix_flaw_line_below:
//                inData = malloc(2 * size);
             }
//flaw_line_below:

             if (inData == NULL) {
                 reply->writeInt32(ERROR_OUT_OF_RANGE);
                 return OK;
 }

 
             void *outData = (uint8_t *)inData + size;
 
//flaw_line_below:
            data.read(inData, size);
//fix_flaw_line_below:
//            status_t err = data.read(inData, size);
//fix_flaw_line_below:
//            if (err != OK) {
//fix_flaw_line_below:
//                free(inData);
//fix_flaw_line_below:
//                reply->writeInt32(err);
//fix_flaw_line_below:
//                return OK;
//fix_flaw_line_below:
//            }
 
             uint32_t streamCTR = data.readInt32();
             uint64_t inputCTR;
//flaw_line_below:
            status_t err = encrypt(inData, size, streamCTR, &inputCTR, outData);
//fix_flaw_line_below:
//            err = encrypt(inData, size, streamCTR, &inputCTR, outData);
 
             reply->writeInt32(err);
 
 if (err == OK) {
                reply->writeInt64(inputCTR);
                reply->write(outData, size);
 }

            free(inData);
            inData = outData = NULL;

 return OK;
 }

 case HDCP_ENCRYPT_NATIVE:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
 size_t offset = data.readInt32();
 size_t size = data.readInt32();
 uint32_t streamCTR = data.readInt32();
 void *outData = malloc(size);
 uint64_t inputCTR;

 status_t err = encryptNative(graphicBuffer, offset, size,
                                         streamCTR, &inputCTR, outData);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt64(inputCTR);
                reply->write(outData, size);
 }

            free(outData);
            outData = NULL;

 return OK;
 }

 case HDCP_DECRYPT:
 {
 size_t size = data.readInt32();
 size_t bufSize = 2 * size;

 // watch out for overflow
 void *inData = NULL;
 if (bufSize > size) {
                inData = malloc(bufSize);
 }

 if (inData == NULL) {
                reply->writeInt32(ERROR_OUT_OF_RANGE);
 return OK;
 }

 void *outData = (uint8_t *)inData + size;

            data.read(inData, size);

 uint32_t streamCTR = data.readInt32();
 uint64_t inputCTR = data.readInt64();
 status_t err = decrypt(inData, size, streamCTR, inputCTR, outData);

            reply->writeInt32(err);

 if (err == OK) {
                reply->write(outData, size);
 }

            free(inData);
            inData = outData = NULL;

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
",188069,"status_t BnHDCP::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case HDCP_SET_OBSERVER:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            sp<IHDCPObserver> observer =
                interface_cast<IHDCPObserver>(data.readStrongBinder());

            reply->writeInt32(setObserver(observer));
 return OK;
 }

 case HDCP_INIT_ASYNC:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

 const char *host = data.readCString();
 unsigned port = data.readInt32();

            reply->writeInt32(initAsync(host, port));
 return OK;
 }

 case HDCP_SHUTDOWN_ASYNC:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            reply->writeInt32(shutdownAsync());
 return OK;
 }

 case HDCP_GET_CAPS:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            reply->writeInt32(getCaps());
 return OK;
 }


         case HDCP_ENCRYPT:
         {
             size_t size = data.readInt32();
            size_t bufSize = 2 * size;
            if (bufSize > size) {
                inData = malloc(bufSize);
             }
             if (inData == NULL) {
                 reply->writeInt32(ERROR_OUT_OF_RANGE);
                 return OK;
 }

 
             void *outData = (uint8_t *)inData + size;
 
            data.read(inData, size);
 
             uint32_t streamCTR = data.readInt32();
             uint64_t inputCTR;
            status_t err = encrypt(inData, size, streamCTR, &inputCTR, outData);
 
             reply->writeInt32(err);
 
 if (err == OK) {
                reply->writeInt64(inputCTR);
                reply->write(outData, size);
 }

            free(inData);
            inData = outData = NULL;

 return OK;
 }

 case HDCP_ENCRYPT_NATIVE:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
 size_t offset = data.readInt32();
 size_t size = data.readInt32();
 uint32_t streamCTR = data.readInt32();
 void *outData = malloc(size);
 uint64_t inputCTR;

 status_t err = encryptNative(graphicBuffer, offset, size,
                                         streamCTR, &inputCTR, outData);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt64(inputCTR);
                reply->write(outData, size);
 }

            free(outData);
            outData = NULL;

 return OK;
 }

 case HDCP_DECRYPT:
 {
 size_t size = data.readInt32();
 size_t bufSize = 2 * size;

 void *inData = NULL;
 if (bufSize > size) {
                inData = malloc(bufSize);
 }

 if (inData == NULL) {
                reply->writeInt32(ERROR_OUT_OF_RANGE);
 return OK;
 }

 void *outData = (uint8_t *)inData + size;

            data.read(inData, size);

 uint32_t streamCTR = data.readInt32();
 uint64_t inputCTR = data.readInt64();
 status_t err = decrypt(inData, size, streamCTR, inputCTR, outData);

            reply->writeInt32(err);

 if (err == OK) {
                reply->write(outData, size);
 }

            free(inData);
            inData = outData = NULL;

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","status_t BnHDCP::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case HDCP_SET_OBSERVER:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            sp<IHDCPObserver> observer =
                interface_cast<IHDCPObserver>(data.readStrongBinder());

            reply->writeInt32(setObserver(observer));
 return OK;
 }

 case HDCP_INIT_ASYNC:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

 const char *host = data.readCString();
 unsigned port = data.readInt32();

            reply->writeInt32(initAsync(host, port));
 return OK;
 }

 case HDCP_SHUTDOWN_ASYNC:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            reply->writeInt32(shutdownAsync());
 return OK;
 }

 case HDCP_GET_CAPS:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            reply->writeInt32(getCaps());
 return OK;
 }


         case HDCP_ENCRYPT:
         {
             size_t size = data.readInt32();
            // watch out for overflow
            if (size <= SIZE_MAX / 2) {
                inData = malloc(2 * size);
             }
             if (inData == NULL) {
                 reply->writeInt32(ERROR_OUT_OF_RANGE);
                 return OK;
 }

 
             void *outData = (uint8_t *)inData + size;
 
            status_t err = data.read(inData, size);
            if (err != OK) {
                free(inData);
                reply->writeInt32(err);
                return OK;
            }
 
             uint32_t streamCTR = data.readInt32();
             uint64_t inputCTR;
            err = encrypt(inData, size, streamCTR, &inputCTR, outData);
 
             reply->writeInt32(err);
 
 if (err == OK) {
                reply->writeInt64(inputCTR);
                reply->write(outData, size);
 }

            free(inData);
            inData = outData = NULL;

 return OK;
 }

 case HDCP_ENCRYPT_NATIVE:
 {
            CHECK_INTERFACE(IHDCP, data, reply);

            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
 size_t offset = data.readInt32();
 size_t size = data.readInt32();
 uint32_t streamCTR = data.readInt32();
 void *outData = malloc(size);
 uint64_t inputCTR;

 status_t err = encryptNative(graphicBuffer, offset, size,
                                         streamCTR, &inputCTR, outData);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt64(inputCTR);
                reply->write(outData, size);
 }

            free(outData);
            outData = NULL;

 return OK;
 }

 case HDCP_DECRYPT:
 {
 size_t size = data.readInt32();
 size_t bufSize = 2 * size;

 void *inData = NULL;
 if (bufSize > size) {
                inData = malloc(bufSize);
 }

 if (inData == NULL) {
                reply->writeInt32(ERROR_OUT_OF_RANGE);
 return OK;
 }

 void *outData = (uint8_t *)inData + size;

            data.read(inData, size);

 uint32_t streamCTR = data.readInt32();
 uint64_t inputCTR = data.readInt64();
 status_t err = decrypt(inData, size, streamCTR, inputCTR, outData);

            reply->writeInt32(err);

 if (err == OK) {
                reply->write(outData, size);
 }

            free(inData);
            inData = outData = NULL;

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","The `BnHDCP::onTransact` function handles various HDCP (High-bandwidth Digital Content Protection) related transactions based on the provided `code`. It processes requests such as setting an observer, initializing and shutting down asynchronously, retrieving capabilities, and performing encryption and decryption operations. Each case checks the interface validity, reads necessary data from the `Parcel`, and executes the corresponding HDCP function, writing the results back to the `reply` parcel. Memory management is handled carefully, with dynamic allocations for input and output data, ensuring proper cleanup to prevent memory leaks. The function returns appropriate status codes for each operation.","The provided code defines a function that processes various requests related to digital content protection. It handles operations such as setting an observer, initializing and shutting down processes asynchronously, retrieving system capabilities, and performing encryption and decryption of data. Each request is validated, and necessary data is read from a communication parcel. The function executes the corresponding operation and writes the results back to the response parcel, ensuring proper memory management for dynamically allocated resources. It returns appropriate status codes to indicate the success or failure of each operation, maintaining robust error handling throughout.","The vulnerability in the original code stemmed from a potential integer overflow when calculating the buffer size for dynamic memory allocation in the encryption case. Specifically, the code multiplied the size read from the data by two without checking if this multiplication would exceed the maximum allowable size, leading to a risk of allocating insufficient memory and causing buffer overflows. The fix introduced a check to ensure that the size is within safe limits before performing the multiplication, thereby preventing overflow. Additionally, the code now verifies the result of the data read operation, ensuring that any read errors are handled appropriately.","The vulnerability in the original code was due to a lack of proper checks for integer overflow when calculating the size for memory allocation, which could lead to insufficient memory being allocated and potential buffer overflows. This risk was particularly pronounced when multiplying the size read from input data. The fix implemented a safeguard to ensure that the size would not exceed a certain threshold before performing the multiplication, thus preventing overflow. Additionally, the updated code now includes a verification step for the result of reading data, ensuring that any errors during this process are appropriately handled, enhancing overall robustness.","The vulnerability was fixed by adding a check to ensure that the size read from the data does not lead to an overflow when multiplied by two for memory allocation. Specifically, the condition `if (size <= SIZE_MAX / 2)` was introduced to verify that the size is safe for multiplication, preventing potential buffer overflows. Additionally, the code now checks the result of the `data.read` operation, ensuring that if an error occurs during reading, the allocated memory is freed, and an error code is returned. This enhances the overall safety and reliability of the memory handling in the encryption process.","The vulnerability was addressed by implementing a safeguard to prevent integer overflow during memory allocation. A condition was added to ensure that the size being processed would not exceed a certain threshold before performing any multiplication, thereby mitigating the risk of allocating insufficient memory. Additionally, the code now includes a verification step to check the outcome of reading data, ensuring that any errors encountered during this process are handled appropriately. This combination of checks enhances the overall safety and reliability of memory management, reducing the likelihood of buffer overflows and improving error handling.","5,5","4, 4","4,4","4,5"
122,122,188085,188085,,Remote,Not required,,CVE-2017-0396,https://www.cvedetails.com/cve/CVE-2017-0396/,CWE-200,Medium,Partial,,,2017-01-12,4.3,"An information disclosure vulnerability in visualizer/EffectVisualizer.cpp in libeffects in Mediaserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1. Android ID: A-31781965.",2017-01-18,+Info ,30,https://android.googlesource.com/platform/frameworks/av/+/557bd7bfe6c4895faee09e46fc9b5304a956c8b7,557bd7bfe6c4895faee09e46fc9b5304a956c8b7,"Visualizer: Check capture size and latency parameters

Bug: 31781965
Change-Id: I1c439a0d0f6aa0057b3c651499f28426e1e1f5e4
(cherry picked from commit 9a2732ba0a8d609ab040d2c1ddee28577ead9772)
",11,media/libeffects/visualizer/EffectVisualizer.cpp,"{""filename"": ""media/libeffects/visualizer/EffectVisualizer.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/557bd7bfe6c4895faee09e46fc9b5304a956c8b7/media/libeffects/visualizer/EffectVisualizer.cpp"", ""patch"": ""@@ -59,6 +59,8 @@\n\n \n #define DISCARD_MEASUREMENTS_TIME_MS 2000 // discard measurements older than this number of ms\n \n+#define MAX_LATENCY_MS 3000 // 3 seconds of latency for audio pipeline\n+\n // maximum number of buffers for which we keep track of the measurements\n #define MEASUREMENT_WINDOW_MAX_SIZE_IN_BUFFERS 25 // note: buffer index is stored in uint8_t\n \n@@ -521,18 +523,29 @@\n\n             break;\n         }\n         switch (*(uint32_t *)p->data) {\n-        case VISUALIZER_PARAM_CAPTURE_SIZE:\n-            pContext->mCaptureSize = *((uint32_t *)p->data + 1);\n-            ALOGV(\""set mCaptureSize = %\"" PRIu32, pContext->mCaptureSize);\n-            break;\n+        case VISUALIZER_PARAM_CAPTURE_SIZE: {\n+            const uint32_t captureSize = *((uint32_t *)p->data + 1);\n+            if (captureSize > VISUALIZER_CAPTURE_SIZE_MAX) {\n+                android_errorWriteLog(0x534e4554, \""31781965\"");\n+                *(int32_t *)pReplyData = -EINVAL;\n+                ALOGW(\""set mCaptureSize = %u > %u\"", captureSize, VISUALIZER_CAPTURE_SIZE_MAX);\n+            } else {\n+                pContext->mCaptureSize = captureSize;\n+                ALOGV(\""set mCaptureSize = %u\"", captureSize);\n+            }\n+            } break;\n         case VISUALIZER_PARAM_SCALING_MODE:\n             pContext->mScalingMode = *((uint32_t *)p->data + 1);\n             ALOGV(\""set mScalingMode = %\"" PRIu32, pContext->mScalingMode);\n             break;\n-        case VISUALIZER_PARAM_LATENCY:\n-            pContext->mLatency = *((uint32_t *)p->data + 1);\n-            ALOGV(\""set mLatency = %\"" PRIu32, pContext->mLatency);\n-            break;\n+        case VISUALIZER_PARAM_LATENCY: {\n+            uint32_t latency = *((uint32_t *)p->data + 1);\n+            if (latency > MAX_LATENCY_MS) {\n+                latency = MAX_LATENCY_MS; // clamp latency b/31781965\n+            }\n+            pContext->mLatency = latency;\n+            ALOGV(\""set mLatency = %u\"", latency);\n+            } break;\n         case VISUALIZER_PARAM_MEASUREMENT_MODE:\n             pContext->mMeasurementMode = *((uint32_t *)p->data + 1);\n             ALOGV(\""set mMeasurementMode = %\"" PRIu32, pContext->mMeasurementMode);\n@@ -571,10 +584,18 @@\n\n                 if (latencyMs < 0) {\n                     latencyMs = 0;\n                 }\n-                const uint32_t deltaSmpl =\n-                    pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;\n-                int32_t capturePoint = pContext->mCaptureIdx - captureSize - deltaSmpl;\n+                uint32_t deltaSmpl = captureSize\n+                        + pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;\n \n+                // large sample rate, latency, or capture size, could cause overflow.\n+                // do not offset more than the size of buffer.\n+                if (deltaSmpl > CAPTURE_BUF_SIZE) {\n+                    android_errorWriteLog(0x534e4554, \""31781965\"");\n+                    deltaSmpl = CAPTURE_BUF_SIZE;\n+                }\n+\n+                int32_t capturePoint = pContext->mCaptureIdx - deltaSmpl;\n+                // a negative capturePoint means we wrap the buffer.\n                 if (capturePoint < 0) {\n                     uint32_t size = -capturePoint;\n                     if (size > captureSize) {\n""}","int Visualizer_command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,
 void *pCmdData, uint32_t *replySize, void *pReplyData) {

 VisualizerContext * pContext = (VisualizerContext *)self;
 int retsize;

 if (pContext == NULL || pContext->mState == VISUALIZER_STATE_UNINITIALIZED) {
 return -EINVAL;
 }


 switch (cmdCode) {
 case EFFECT_CMD_INIT:
 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 *(int *) pReplyData = Visualizer_init(pContext);
 break;
 case EFFECT_CMD_SET_CONFIG:
 if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)
 || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 *(int *) pReplyData = Visualizer_setConfig(pContext,
 (effect_config_t *) pCmdData);
 break;
 case EFFECT_CMD_GET_CONFIG:
 if (pReplyData == NULL || replySize == NULL ||
 *replySize != sizeof(effect_config_t)) {
 return -EINVAL;
 }
 Visualizer_getConfig(pContext, (effect_config_t *)pReplyData);
 break;
 case EFFECT_CMD_RESET:
 Visualizer_reset(pContext);
 break;
 case EFFECT_CMD_ENABLE:
 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 if (pContext->mState != VISUALIZER_STATE_INITIALIZED) {
 return -ENOSYS;
 }
        pContext->mState = VISUALIZER_STATE_ACTIVE;
        ALOGV(""EFFECT_CMD_ENABLE() OK"");
 *(int *)pReplyData = 0;
 break;
 case EFFECT_CMD_DISABLE:
 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 if (pContext->mState != VISUALIZER_STATE_ACTIVE) {
 return -ENOSYS;
 }
        pContext->mState = VISUALIZER_STATE_INITIALIZED;
        ALOGV(""EFFECT_CMD_DISABLE() OK"");
 *(int *)pReplyData = 0;
 break;
 case EFFECT_CMD_GET_PARAM: {
 if (pCmdData == NULL ||
            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||
            pReplyData == NULL || replySize == NULL ||
 *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {
 return -EINVAL;
 }
        memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(uint32_t));
 effect_param_t *p = (effect_param_t *)pReplyData;
        p->status = 0;
 *replySize = sizeof(effect_param_t) + sizeof(uint32_t);
 if (p->psize != sizeof(uint32_t)) {
            p->status = -EINVAL;
 break;
 }
 switch (*(uint32_t *)p->data) {
 case VISUALIZER_PARAM_CAPTURE_SIZE:
            ALOGV(""get mCaptureSize = %"" PRIu32, pContext->mCaptureSize);
 *((uint32_t *)p->data + 1) = pContext->mCaptureSize;
            p->vsize = sizeof(uint32_t);
 *replySize += sizeof(uint32_t);
 break;
 case VISUALIZER_PARAM_SCALING_MODE:
            ALOGV(""get mScalingMode = %"" PRIu32, pContext->mScalingMode);
 *((uint32_t *)p->data + 1) = pContext->mScalingMode;
            p->vsize = sizeof(uint32_t);
 *replySize += sizeof(uint32_t);
 break;
 case VISUALIZER_PARAM_MEASUREMENT_MODE:
            ALOGV(""get mMeasurementMode = %"" PRIu32, pContext->mMeasurementMode);
 *((uint32_t *)p->data + 1) = pContext->mMeasurementMode;
            p->vsize = sizeof(uint32_t);
 *replySize += sizeof(uint32_t);
 break;
 default:
            p->status = -EINVAL;
 }
 } break;
 case EFFECT_CMD_SET_PARAM: {
 if (pCmdData == NULL ||
            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||
            pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {
 return -EINVAL;
 }
 *(int32_t *)pReplyData = 0;
 effect_param_t *p = (effect_param_t *)pCmdData;
 if (p->psize != sizeof(uint32_t) || p->vsize != sizeof(uint32_t)) {
 *(int32_t *)pReplyData = -EINVAL;

             break;
         }
         switch (*(uint32_t *)p->data) {
        case VISUALIZER_PARAM_CAPTURE_SIZE: {
            const uint32_t captureSize = *((uint32_t *)p->data + 1);
            if (captureSize > VISUALIZER_CAPTURE_SIZE_MAX) {
                android_errorWriteLog(0x534e4554, ""31781965"");
                *(int32_t *)pReplyData = -EINVAL;
                ALOGW(""set mCaptureSize = %u > %u"", captureSize, VISUALIZER_CAPTURE_SIZE_MAX);
            } else {
                pContext->mCaptureSize = captureSize;
                ALOGV(""set mCaptureSize = %u"", captureSize);
            }
            } break;
         case VISUALIZER_PARAM_SCALING_MODE:
             pContext->mScalingMode = *((uint32_t *)p->data + 1);
             ALOGV(""set mScalingMode = %"" PRIu32, pContext->mScalingMode);
             break;
        case VISUALIZER_PARAM_LATENCY: {
            uint32_t latency = *((uint32_t *)p->data + 1);
            if (latency > MAX_LATENCY_MS) {
                latency = MAX_LATENCY_MS; // clamp latency b/31781965
            }
            pContext->mLatency = latency;
            ALOGV(""set mLatency = %u"", latency);
            } break;
         case VISUALIZER_PARAM_MEASUREMENT_MODE:
             pContext->mMeasurementMode = *((uint32_t *)p->data + 1);
             ALOGV(""set mMeasurementMode = %"" PRIu32, pContext->mMeasurementMode);
 break;
 default:
 *(int32_t *)pReplyData = -EINVAL;
 }
 } break;
 case EFFECT_CMD_SET_DEVICE:
 case EFFECT_CMD_SET_VOLUME:
 case EFFECT_CMD_SET_AUDIO_MODE:
 break;


 case VISUALIZER_CMD_CAPTURE: {
 uint32_t captureSize = pContext->mCaptureSize;
 if (pReplyData == NULL || replySize == NULL || *replySize != captureSize) {
            ALOGV(""VISUALIZER_CMD_CAPTURE() error *replySize %"" PRIu32 "" captureSize %"" PRIu32,
 *replySize, captureSize);
 return -EINVAL;
 }
 if (pContext->mState == VISUALIZER_STATE_ACTIVE) {
 const uint32_t deltaMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);

 if ((pContext->mLastCaptureIdx == pContext->mCaptureIdx) &&
 (pContext->mBufferUpdateTime.tv_sec != 0) &&
 (deltaMs > MAX_STALL_TIME_MS)) {
                    ALOGV(""capture going to idle"");
                    pContext->mBufferUpdateTime.tv_sec = 0;
                    memset(pReplyData, 0x80, captureSize);
 } else {
 int32_t latencyMs = pContext->mLatency;
                latencyMs -= deltaMs;

                 if (latencyMs < 0) {
                     latencyMs = 0;
                 }
                uint32_t deltaSmpl = captureSize
                        + pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;
 
                // large sample rate, latency, or capture size, could cause overflow.
                // do not offset more than the size of buffer.
                if (deltaSmpl > CAPTURE_BUF_SIZE) {
                    android_errorWriteLog(0x534e4554, ""31781965"");
                    deltaSmpl = CAPTURE_BUF_SIZE;
                }

                int32_t capturePoint = pContext->mCaptureIdx - deltaSmpl;
                // a negative capturePoint means we wrap the buffer.
                 if (capturePoint < 0) {
                     uint32_t size = -capturePoint;
                     if (size > captureSize) {
                        size = captureSize;
 }
                    memcpy(pReplyData,
                           pContext->mCaptureBuf + CAPTURE_BUF_SIZE + capturePoint,
                           size);
                    pReplyData = (char *)pReplyData + size;
                    captureSize -= size;
                    capturePoint = 0;
 }
                memcpy(pReplyData,
                       pContext->mCaptureBuf + capturePoint,
                       captureSize);
 }

            pContext->mLastCaptureIdx = pContext->mCaptureIdx;
 } else {
            memset(pReplyData, 0x80, captureSize);
 }

 } break;

 case VISUALIZER_CMD_MEASURE: {
 if (pReplyData == NULL || replySize == NULL ||
 *replySize < (sizeof(int32_t) * MEASUREMENT_COUNT)) {
 if (replySize == NULL) {
                ALOGV(""VISUALIZER_CMD_MEASURE() error replySize NULL"");
 } else {
                ALOGV(""VISUALIZER_CMD_MEASURE() error *replySize %"" PRIu32
 "" < (sizeof(int32_t) * MEASUREMENT_COUNT) %"" PRIu32,
 *replySize,
 uint32_t(sizeof(int32_t)) * MEASUREMENT_COUNT);
 }
            android_errorWriteLog(0x534e4554, ""30229821"");
 return -EINVAL;
 }
 uint16_t peakU16 = 0;
 float sumRmsSquared = 0.0f;
 uint8_t nbValidMeasurements = 0;
 const int32_t delayMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);
 if (delayMs > DISCARD_MEASUREMENTS_TIME_MS) {
            ALOGV(""Discarding measurements, last measurement is %"" PRId32 ""ms old"", delayMs);
 for (uint32_t i=0 ; i<pContext->mMeasurementWindowSizeInBuffers ; i++) {
                pContext->mPastMeasurements[i].mIsValid = false;
                pContext->mPastMeasurements[i].mPeakU16 = 0;
                pContext->mPastMeasurements[i].mRmsSquared = 0;
 }
            pContext->mMeasurementBufferIdx = 0;
 } else {
 for (uint32_t i=0 ; i < pContext->mMeasurementWindowSizeInBuffers ; i++) {
 if (pContext->mPastMeasurements[i].mIsValid) {
 if (pContext->mPastMeasurements[i].mPeakU16 > peakU16) {
                        peakU16 = pContext->mPastMeasurements[i].mPeakU16;
 }
                    sumRmsSquared += pContext->mPastMeasurements[i].mRmsSquared;
                    nbValidMeasurements++;
 }
 }
 }
 float rms = nbValidMeasurements == 0 ? 0.0f : sqrtf(sumRmsSquared / nbValidMeasurements);
 int32_t* pIntReplyData = (int32_t*)pReplyData;
 if (rms < 0.000016f) {
            pIntReplyData[MEASUREMENT_IDX_RMS] = -9600; //-96dB
 } else {
            pIntReplyData[MEASUREMENT_IDX_RMS] = (int32_t) (2000 * log10(rms / 32767.0f));
 }
 if (peakU16 == 0) {
            pIntReplyData[MEASUREMENT_IDX_PEAK] = -9600; //-96dB
 } else {
            pIntReplyData[MEASUREMENT_IDX_PEAK] = (int32_t) (2000 * log10(peakU16 / 32767.0f));
 }
        ALOGV(""VISUALIZER_CMD_MEASURE peak=%"" PRIu16 "" (%"" PRId32 ""mB), rms=%.1f (%"" PRId32 ""mB)"",
                peakU16, pIntReplyData[MEASUREMENT_IDX_PEAK],
                rms, pIntReplyData[MEASUREMENT_IDX_RMS]);
 }
 break;

 default:
        ALOGW(""Visualizer_command invalid command %"" PRIu32, cmdCode);
 return -EINVAL;
 }

 return 0;
}
","int Visualizer_command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,
 void *pCmdData, uint32_t *replySize, void *pReplyData) {

 VisualizerContext * pContext = (VisualizerContext *)self;
 int retsize;

 if (pContext == NULL || pContext->mState == VISUALIZER_STATE_UNINITIALIZED) {
 return -EINVAL;
 }


 switch (cmdCode) {
 case EFFECT_CMD_INIT:
 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 *(int *) pReplyData = Visualizer_init(pContext);
 break;
 case EFFECT_CMD_SET_CONFIG:
 if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)
 || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 *(int *) pReplyData = Visualizer_setConfig(pContext,
 (effect_config_t *) pCmdData);
 break;
 case EFFECT_CMD_GET_CONFIG:
 if (pReplyData == NULL || replySize == NULL ||
 *replySize != sizeof(effect_config_t)) {
 return -EINVAL;
 }
 Visualizer_getConfig(pContext, (effect_config_t *)pReplyData);
 break;
 case EFFECT_CMD_RESET:
 Visualizer_reset(pContext);
 break;
 case EFFECT_CMD_ENABLE:
 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 if (pContext->mState != VISUALIZER_STATE_INITIALIZED) {
 return -ENOSYS;
 }
        pContext->mState = VISUALIZER_STATE_ACTIVE;
        ALOGV(""EFFECT_CMD_ENABLE() OK"");
 *(int *)pReplyData = 0;
 break;
 case EFFECT_CMD_DISABLE:
 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 if (pContext->mState != VISUALIZER_STATE_ACTIVE) {
 return -ENOSYS;
 }
        pContext->mState = VISUALIZER_STATE_INITIALIZED;
        ALOGV(""EFFECT_CMD_DISABLE() OK"");
 *(int *)pReplyData = 0;
 break;
 case EFFECT_CMD_GET_PARAM: {
 if (pCmdData == NULL ||
            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||
            pReplyData == NULL || replySize == NULL ||
 *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {
 return -EINVAL;
 }
        memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(uint32_t));
 effect_param_t *p = (effect_param_t *)pReplyData;
        p->status = 0;
 *replySize = sizeof(effect_param_t) + sizeof(uint32_t);
 if (p->psize != sizeof(uint32_t)) {
            p->status = -EINVAL;
 break;
 }
 switch (*(uint32_t *)p->data) {
 case VISUALIZER_PARAM_CAPTURE_SIZE:
            ALOGV(""get mCaptureSize = %"" PRIu32, pContext->mCaptureSize);
 *((uint32_t *)p->data + 1) = pContext->mCaptureSize;
            p->vsize = sizeof(uint32_t);
 *replySize += sizeof(uint32_t);
 break;
 case VISUALIZER_PARAM_SCALING_MODE:
            ALOGV(""get mScalingMode = %"" PRIu32, pContext->mScalingMode);
 *((uint32_t *)p->data + 1) = pContext->mScalingMode;
            p->vsize = sizeof(uint32_t);
 *replySize += sizeof(uint32_t);
 break;
 case VISUALIZER_PARAM_MEASUREMENT_MODE:
            ALOGV(""get mMeasurementMode = %"" PRIu32, pContext->mMeasurementMode);
 *((uint32_t *)p->data + 1) = pContext->mMeasurementMode;
            p->vsize = sizeof(uint32_t);
 *replySize += sizeof(uint32_t);
 break;
 default:
            p->status = -EINVAL;
 }
 } break;
 case EFFECT_CMD_SET_PARAM: {
 if (pCmdData == NULL ||
            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||
            pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {
 return -EINVAL;
 }
 *(int32_t *)pReplyData = 0;
 effect_param_t *p = (effect_param_t *)pCmdData;
 if (p->psize != sizeof(uint32_t) || p->vsize != sizeof(uint32_t)) {
 *(int32_t *)pReplyData = -EINVAL;

             break;
         }
         switch (*(uint32_t *)p->data) {
        case VISUALIZER_PARAM_CAPTURE_SIZE:
            pContext->mCaptureSize = *((uint32_t *)p->data + 1);
            ALOGV(""set mCaptureSize = %"" PRIu32, pContext->mCaptureSize);
            break;
         case VISUALIZER_PARAM_SCALING_MODE:
             pContext->mScalingMode = *((uint32_t *)p->data + 1);
             ALOGV(""set mScalingMode = %"" PRIu32, pContext->mScalingMode);
             break;
        case VISUALIZER_PARAM_LATENCY:
            pContext->mLatency = *((uint32_t *)p->data + 1);
            ALOGV(""set mLatency = %"" PRIu32, pContext->mLatency);
            break;
         case VISUALIZER_PARAM_MEASUREMENT_MODE:
             pContext->mMeasurementMode = *((uint32_t *)p->data + 1);
             ALOGV(""set mMeasurementMode = %"" PRIu32, pContext->mMeasurementMode);
 break;
 default:
 *(int32_t *)pReplyData = -EINVAL;
 }
 } break;
 case EFFECT_CMD_SET_DEVICE:
 case EFFECT_CMD_SET_VOLUME:
 case EFFECT_CMD_SET_AUDIO_MODE:
 break;


 case VISUALIZER_CMD_CAPTURE: {
 uint32_t captureSize = pContext->mCaptureSize;
 if (pReplyData == NULL || replySize == NULL || *replySize != captureSize) {
            ALOGV(""VISUALIZER_CMD_CAPTURE() error *replySize %"" PRIu32 "" captureSize %"" PRIu32,
 *replySize, captureSize);
 return -EINVAL;
 }
 if (pContext->mState == VISUALIZER_STATE_ACTIVE) {
 const uint32_t deltaMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);

 if ((pContext->mLastCaptureIdx == pContext->mCaptureIdx) &&
 (pContext->mBufferUpdateTime.tv_sec != 0) &&
 (deltaMs > MAX_STALL_TIME_MS)) {
                    ALOGV(""capture going to idle"");
                    pContext->mBufferUpdateTime.tv_sec = 0;
                    memset(pReplyData, 0x80, captureSize);
 } else {
 int32_t latencyMs = pContext->mLatency;
                latencyMs -= deltaMs;

                 if (latencyMs < 0) {
                     latencyMs = 0;
                 }
                const uint32_t deltaSmpl =
                    pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;
                int32_t capturePoint = pContext->mCaptureIdx - captureSize - deltaSmpl;
 
                 if (capturePoint < 0) {
                     uint32_t size = -capturePoint;
                     if (size > captureSize) {
                        size = captureSize;
 }
                    memcpy(pReplyData,
                           pContext->mCaptureBuf + CAPTURE_BUF_SIZE + capturePoint,
                           size);
                    pReplyData = (char *)pReplyData + size;
                    captureSize -= size;
                    capturePoint = 0;
 }
                memcpy(pReplyData,
                       pContext->mCaptureBuf + capturePoint,
                       captureSize);
 }

            pContext->mLastCaptureIdx = pContext->mCaptureIdx;
 } else {
            memset(pReplyData, 0x80, captureSize);
 }

 } break;

 case VISUALIZER_CMD_MEASURE: {
 if (pReplyData == NULL || replySize == NULL ||
 *replySize < (sizeof(int32_t) * MEASUREMENT_COUNT)) {
 if (replySize == NULL) {
                ALOGV(""VISUALIZER_CMD_MEASURE() error replySize NULL"");
 } else {
                ALOGV(""VISUALIZER_CMD_MEASURE() error *replySize %"" PRIu32
 "" < (sizeof(int32_t) * MEASUREMENT_COUNT) %"" PRIu32,
 *replySize,
 uint32_t(sizeof(int32_t)) * MEASUREMENT_COUNT);
 }
            android_errorWriteLog(0x534e4554, ""30229821"");
 return -EINVAL;
 }
 uint16_t peakU16 = 0;
 float sumRmsSquared = 0.0f;
 uint8_t nbValidMeasurements = 0;
 const int32_t delayMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);
 if (delayMs > DISCARD_MEASUREMENTS_TIME_MS) {
            ALOGV(""Discarding measurements, last measurement is %"" PRId32 ""ms old"", delayMs);
 for (uint32_t i=0 ; i<pContext->mMeasurementWindowSizeInBuffers ; i++) {
                pContext->mPastMeasurements[i].mIsValid = false;
                pContext->mPastMeasurements[i].mPeakU16 = 0;
                pContext->mPastMeasurements[i].mRmsSquared = 0;
 }
            pContext->mMeasurementBufferIdx = 0;
 } else {
 for (uint32_t i=0 ; i < pContext->mMeasurementWindowSizeInBuffers ; i++) {
 if (pContext->mPastMeasurements[i].mIsValid) {
 if (pContext->mPastMeasurements[i].mPeakU16 > peakU16) {
                        peakU16 = pContext->mPastMeasurements[i].mPeakU16;
 }
                    sumRmsSquared += pContext->mPastMeasurements[i].mRmsSquared;
                    nbValidMeasurements++;
 }
 }
 }
 float rms = nbValidMeasurements == 0 ? 0.0f : sqrtf(sumRmsSquared / nbValidMeasurements);
 int32_t* pIntReplyData = (int32_t*)pReplyData;
 if (rms < 0.000016f) {
            pIntReplyData[MEASUREMENT_IDX_RMS] = -9600; //-96dB
 } else {
            pIntReplyData[MEASUREMENT_IDX_RMS] = (int32_t) (2000 * log10(rms / 32767.0f));
 }
 if (peakU16 == 0) {
            pIntReplyData[MEASUREMENT_IDX_PEAK] = -9600; //-96dB
 } else {
            pIntReplyData[MEASUREMENT_IDX_PEAK] = (int32_t) (2000 * log10(peakU16 / 32767.0f));
 }
        ALOGV(""VISUALIZER_CMD_MEASURE peak=%"" PRIu16 "" (%"" PRId32 ""mB), rms=%.1f (%"" PRId32 ""mB)"",
                peakU16, pIntReplyData[MEASUREMENT_IDX_PEAK],
                rms, pIntReplyData[MEASUREMENT_IDX_RMS]);
 }
 break;

 default:
        ALOGW(""Visualizer_command invalid command %"" PRIu32, cmdCode);
 return -EINVAL;
 }

 return 0;
}
",C,"        case VISUALIZER_PARAM_CAPTURE_SIZE: {
            const uint32_t captureSize = *((uint32_t *)p->data + 1);
            if (captureSize > VISUALIZER_CAPTURE_SIZE_MAX) {
                android_errorWriteLog(0x534e4554, ""31781965"");
                *(int32_t *)pReplyData = -EINVAL;
                ALOGW(""set mCaptureSize = %u > %u"", captureSize, VISUALIZER_CAPTURE_SIZE_MAX);
            } else {
                pContext->mCaptureSize = captureSize;
                ALOGV(""set mCaptureSize = %u"", captureSize);
            }
            } break;
        case VISUALIZER_PARAM_LATENCY: {
            uint32_t latency = *((uint32_t *)p->data + 1);
            if (latency > MAX_LATENCY_MS) {
                latency = MAX_LATENCY_MS; // clamp latency b/31781965
            }
            pContext->mLatency = latency;
            ALOGV(""set mLatency = %u"", latency);
            } break;
                uint32_t deltaSmpl = captureSize
                        + pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;
                // large sample rate, latency, or capture size, could cause overflow.
                // do not offset more than the size of buffer.
                if (deltaSmpl > CAPTURE_BUF_SIZE) {
                    android_errorWriteLog(0x534e4554, ""31781965"");
                    deltaSmpl = CAPTURE_BUF_SIZE;
                }

                int32_t capturePoint = pContext->mCaptureIdx - deltaSmpl;
                // a negative capturePoint means we wrap the buffer.
","        case VISUALIZER_PARAM_CAPTURE_SIZE:
            pContext->mCaptureSize = *((uint32_t *)p->data + 1);
            ALOGV(""set mCaptureSize = %"" PRIu32, pContext->mCaptureSize);
            break;
        case VISUALIZER_PARAM_LATENCY:
            pContext->mLatency = *((uint32_t *)p->data + 1);
            ALOGV(""set mLatency = %"" PRIu32, pContext->mLatency);
            break;
                const uint32_t deltaSmpl =
                    pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;
                int32_t capturePoint = pContext->mCaptureIdx - captureSize - deltaSmpl;
",,"@@ -59,6 +59,8 @@

 
 #define DISCARD_MEASUREMENTS_TIME_MS 2000 // discard measurements older than this number of ms
 
+#define MAX_LATENCY_MS 3000 // 3 seconds of latency for audio pipeline
+
 // maximum number of buffers for which we keep track of the measurements
 #define MEASUREMENT_WINDOW_MAX_SIZE_IN_BUFFERS 25 // note: buffer index is stored in uint8_t
 
@@ -521,18 +523,29 @@

             break;
         }
         switch (*(uint32_t *)p->data) {
-        case VISUALIZER_PARAM_CAPTURE_SIZE:
-            pContext->mCaptureSize = *((uint32_t *)p->data + 1);
-            ALOGV(""set mCaptureSize = %"" PRIu32, pContext->mCaptureSize);
-            break;
+        case VISUALIZER_PARAM_CAPTURE_SIZE: {
+            const uint32_t captureSize = *((uint32_t *)p->data + 1);
+            if (captureSize > VISUALIZER_CAPTURE_SIZE_MAX) {
+                android_errorWriteLog(0x534e4554, ""31781965"");
+                *(int32_t *)pReplyData = -EINVAL;
+                ALOGW(""set mCaptureSize = %u > %u"", captureSize, VISUALIZER_CAPTURE_SIZE_MAX);
+            } else {
+                pContext->mCaptureSize = captureSize;
+                ALOGV(""set mCaptureSize = %u"", captureSize);
+            }
+            } break;
         case VISUALIZER_PARAM_SCALING_MODE:
             pContext->mScalingMode = *((uint32_t *)p->data + 1);
             ALOGV(""set mScalingMode = %"" PRIu32, pContext->mScalingMode);
             break;
-        case VISUALIZER_PARAM_LATENCY:
-            pContext->mLatency = *((uint32_t *)p->data + 1);
-            ALOGV(""set mLatency = %"" PRIu32, pContext->mLatency);
-            break;
+        case VISUALIZER_PARAM_LATENCY: {
+            uint32_t latency = *((uint32_t *)p->data + 1);
+            if (latency > MAX_LATENCY_MS) {
+                latency = MAX_LATENCY_MS; // clamp latency b/31781965
+            }
+            pContext->mLatency = latency;
+            ALOGV(""set mLatency = %u"", latency);
+            } break;
         case VISUALIZER_PARAM_MEASUREMENT_MODE:
             pContext->mMeasurementMode = *((uint32_t *)p->data + 1);
             ALOGV(""set mMeasurementMode = %"" PRIu32, pContext->mMeasurementMode);
@@ -571,10 +584,18 @@

                 if (latencyMs < 0) {
                     latencyMs = 0;
                 }
-                const uint32_t deltaSmpl =
-                    pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;
-                int32_t capturePoint = pContext->mCaptureIdx - captureSize - deltaSmpl;
+                uint32_t deltaSmpl = captureSize
+                        + pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;
 
+                // large sample rate, latency, or capture size, could cause overflow.
+                // do not offset more than the size of buffer.
+                if (deltaSmpl > CAPTURE_BUF_SIZE) {
+                    android_errorWriteLog(0x534e4554, ""31781965"");
+                    deltaSmpl = CAPTURE_BUF_SIZE;
+                }
+
+                int32_t capturePoint = pContext->mCaptureIdx - deltaSmpl;
+                // a negative capturePoint means we wrap the buffer.
                 if (capturePoint < 0) {
                     uint32_t size = -capturePoint;
                     if (size > captureSize) {
",Android,https://android.googlesource.com/platform/frameworks/av/+/557bd7bfe6c4895faee09e46fc9b5304a956c8b7/,https://android.googlesource.com/platform/frameworks/av/+/557bd7bfe6c4895faee09e46fc9b5304a956c8b7%5E/,1,"int Visualizer_command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,
 void *pCmdData, uint32_t *replySize, void *pReplyData) {

 VisualizerContext * pContext = (VisualizerContext *)self;
 int retsize;

 if (pContext == NULL || pContext->mState == VISUALIZER_STATE_UNINITIALIZED) {
 return -EINVAL;
 }

//    ALOGV(""Visualizer_command command %"" PRIu32 "" cmdSize %"" PRIu32, cmdCode, cmdSize);

 switch (cmdCode) {
 case EFFECT_CMD_INIT:
 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 *(int *) pReplyData = Visualizer_init(pContext);
 break;
 case EFFECT_CMD_SET_CONFIG:
 if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)
 || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 *(int *) pReplyData = Visualizer_setConfig(pContext,
 (effect_config_t *) pCmdData);
 break;
 case EFFECT_CMD_GET_CONFIG:
 if (pReplyData == NULL || replySize == NULL ||
 *replySize != sizeof(effect_config_t)) {
 return -EINVAL;
 }
 Visualizer_getConfig(pContext, (effect_config_t *)pReplyData);
 break;
 case EFFECT_CMD_RESET:
 Visualizer_reset(pContext);
 break;
 case EFFECT_CMD_ENABLE:
 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 if (pContext->mState != VISUALIZER_STATE_INITIALIZED) {
 return -ENOSYS;
 }
        pContext->mState = VISUALIZER_STATE_ACTIVE;
        ALOGV(""EFFECT_CMD_ENABLE() OK"");
 *(int *)pReplyData = 0;
 break;
 case EFFECT_CMD_DISABLE:
 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 if (pContext->mState != VISUALIZER_STATE_ACTIVE) {
 return -ENOSYS;
 }
        pContext->mState = VISUALIZER_STATE_INITIALIZED;
        ALOGV(""EFFECT_CMD_DISABLE() OK"");
 *(int *)pReplyData = 0;
 break;
 case EFFECT_CMD_GET_PARAM: {
 if (pCmdData == NULL ||
            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||
            pReplyData == NULL || replySize == NULL ||
 *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {
 return -EINVAL;
 }
        memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(uint32_t));
 effect_param_t *p = (effect_param_t *)pReplyData;
        p->status = 0;
 *replySize = sizeof(effect_param_t) + sizeof(uint32_t);
 if (p->psize != sizeof(uint32_t)) {
            p->status = -EINVAL;
 break;
 }
 switch (*(uint32_t *)p->data) {
 case VISUALIZER_PARAM_CAPTURE_SIZE:
            ALOGV(""get mCaptureSize = %"" PRIu32, pContext->mCaptureSize);
 *((uint32_t *)p->data + 1) = pContext->mCaptureSize;
            p->vsize = sizeof(uint32_t);
 *replySize += sizeof(uint32_t);
 break;
 case VISUALIZER_PARAM_SCALING_MODE:
            ALOGV(""get mScalingMode = %"" PRIu32, pContext->mScalingMode);
 *((uint32_t *)p->data + 1) = pContext->mScalingMode;
            p->vsize = sizeof(uint32_t);
 *replySize += sizeof(uint32_t);
 break;
 case VISUALIZER_PARAM_MEASUREMENT_MODE:
            ALOGV(""get mMeasurementMode = %"" PRIu32, pContext->mMeasurementMode);
 *((uint32_t *)p->data + 1) = pContext->mMeasurementMode;
            p->vsize = sizeof(uint32_t);
 *replySize += sizeof(uint32_t);
 break;
 default:
            p->status = -EINVAL;
 }
 } break;
 case EFFECT_CMD_SET_PARAM: {
 if (pCmdData == NULL ||
            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||
            pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {
 return -EINVAL;
 }
 *(int32_t *)pReplyData = 0;
 effect_param_t *p = (effect_param_t *)pCmdData;
 if (p->psize != sizeof(uint32_t) || p->vsize != sizeof(uint32_t)) {
 *(int32_t *)pReplyData = -EINVAL;

             break;
         }
         switch (*(uint32_t *)p->data) {
//flaw_line_below:
        case VISUALIZER_PARAM_CAPTURE_SIZE:
//flaw_line_below:
            pContext->mCaptureSize = *((uint32_t *)p->data + 1);
//flaw_line_below:
            ALOGV(""set mCaptureSize = %"" PRIu32, pContext->mCaptureSize);
//flaw_line_below:
            break;
//fix_flaw_line_below:
//        case VISUALIZER_PARAM_CAPTURE_SIZE: {
//fix_flaw_line_below:
//            const uint32_t captureSize = *((uint32_t *)p->data + 1);
//fix_flaw_line_below:
//            if (captureSize > VISUALIZER_CAPTURE_SIZE_MAX) {
//fix_flaw_line_below:
//                android_errorWriteLog(0x534e4554, ""31781965"");
//fix_flaw_line_below:
//                *(int32_t *)pReplyData = -EINVAL;
//fix_flaw_line_below:
//                ALOGW(""set mCaptureSize = %u > %u"", captureSize, VISUALIZER_CAPTURE_SIZE_MAX);
//fix_flaw_line_below:
//            } else {
//fix_flaw_line_below:
//                pContext->mCaptureSize = captureSize;
//fix_flaw_line_below:
//                ALOGV(""set mCaptureSize = %u"", captureSize);
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//            } break;
         case VISUALIZER_PARAM_SCALING_MODE:
             pContext->mScalingMode = *((uint32_t *)p->data + 1);
             ALOGV(""set mScalingMode = %"" PRIu32, pContext->mScalingMode);
             break;
//flaw_line_below:
        case VISUALIZER_PARAM_LATENCY:
//flaw_line_below:
            pContext->mLatency = *((uint32_t *)p->data + 1);
//flaw_line_below:
            ALOGV(""set mLatency = %"" PRIu32, pContext->mLatency);
//flaw_line_below:
            break;
//fix_flaw_line_below:
//        case VISUALIZER_PARAM_LATENCY: {
//fix_flaw_line_below:
//            uint32_t latency = *((uint32_t *)p->data + 1);
//fix_flaw_line_below:
//            if (latency > MAX_LATENCY_MS) {
//fix_flaw_line_below:
//                latency = MAX_LATENCY_MS; // clamp latency b/31781965
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//            pContext->mLatency = latency;
//fix_flaw_line_below:
//            ALOGV(""set mLatency = %u"", latency);
//fix_flaw_line_below:
//            } break;
         case VISUALIZER_PARAM_MEASUREMENT_MODE:
             pContext->mMeasurementMode = *((uint32_t *)p->data + 1);
             ALOGV(""set mMeasurementMode = %"" PRIu32, pContext->mMeasurementMode);
 break;
 default:
 *(int32_t *)pReplyData = -EINVAL;
 }
 } break;
 case EFFECT_CMD_SET_DEVICE:
 case EFFECT_CMD_SET_VOLUME:
 case EFFECT_CMD_SET_AUDIO_MODE:
 break;


 case VISUALIZER_CMD_CAPTURE: {
 uint32_t captureSize = pContext->mCaptureSize;
 if (pReplyData == NULL || replySize == NULL || *replySize != captureSize) {
            ALOGV(""VISUALIZER_CMD_CAPTURE() error *replySize %"" PRIu32 "" captureSize %"" PRIu32,
 *replySize, captureSize);
 return -EINVAL;
 }
 if (pContext->mState == VISUALIZER_STATE_ACTIVE) {
 const uint32_t deltaMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);

 // if audio framework has stopped playing audio although the effect is still
 // active we must clear the capture buffer to return silence
 if ((pContext->mLastCaptureIdx == pContext->mCaptureIdx) &&
 (pContext->mBufferUpdateTime.tv_sec != 0) &&
 (deltaMs > MAX_STALL_TIME_MS)) {
                    ALOGV(""capture going to idle"");
                    pContext->mBufferUpdateTime.tv_sec = 0;
                    memset(pReplyData, 0x80, captureSize);
 } else {
 int32_t latencyMs = pContext->mLatency;
                latencyMs -= deltaMs;

                 if (latencyMs < 0) {
                     latencyMs = 0;
                 }
//flaw_line_below:
                const uint32_t deltaSmpl =
//flaw_line_below:
                    pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;
//flaw_line_below:
                int32_t capturePoint = pContext->mCaptureIdx - captureSize - deltaSmpl;
//fix_flaw_line_below:
//                uint32_t deltaSmpl = captureSize
//fix_flaw_line_below:
//                        + pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;
 
//fix_flaw_line_below:
//                // large sample rate, latency, or capture size, could cause overflow.
//fix_flaw_line_below:
//                // do not offset more than the size of buffer.
//fix_flaw_line_below:
//                if (deltaSmpl > CAPTURE_BUF_SIZE) {
//fix_flaw_line_below:
//                    android_errorWriteLog(0x534e4554, ""31781965"");
//fix_flaw_line_below:
//                    deltaSmpl = CAPTURE_BUF_SIZE;
//fix_flaw_line_below:
//                }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//                int32_t capturePoint = pContext->mCaptureIdx - deltaSmpl;
//fix_flaw_line_below:
//                // a negative capturePoint means we wrap the buffer.
                 if (capturePoint < 0) {
                     uint32_t size = -capturePoint;
                     if (size > captureSize) {
                        size = captureSize;
 }
                    memcpy(pReplyData,
                           pContext->mCaptureBuf + CAPTURE_BUF_SIZE + capturePoint,
                           size);
                    pReplyData = (char *)pReplyData + size;
                    captureSize -= size;
                    capturePoint = 0;
 }
                memcpy(pReplyData,
                       pContext->mCaptureBuf + capturePoint,
                       captureSize);
 }

            pContext->mLastCaptureIdx = pContext->mCaptureIdx;
 } else {
            memset(pReplyData, 0x80, captureSize);
 }

 } break;

 case VISUALIZER_CMD_MEASURE: {
 if (pReplyData == NULL || replySize == NULL ||
 *replySize < (sizeof(int32_t) * MEASUREMENT_COUNT)) {
 if (replySize == NULL) {
                ALOGV(""VISUALIZER_CMD_MEASURE() error replySize NULL"");
 } else {
                ALOGV(""VISUALIZER_CMD_MEASURE() error *replySize %"" PRIu32
 "" < (sizeof(int32_t) * MEASUREMENT_COUNT) %"" PRIu32,
 *replySize,
 uint32_t(sizeof(int32_t)) * MEASUREMENT_COUNT);
 }
            android_errorWriteLog(0x534e4554, ""30229821"");
 return -EINVAL;
 }
 uint16_t peakU16 = 0;
 float sumRmsSquared = 0.0f;
 uint8_t nbValidMeasurements = 0;
 // reset measurements if last measurement was too long ago (which implies stored
 // measurements aren't relevant anymore and shouldn't bias the new one)
 const int32_t delayMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);
 if (delayMs > DISCARD_MEASUREMENTS_TIME_MS) {
            ALOGV(""Discarding measurements, last measurement is %"" PRId32 ""ms old"", delayMs);
 for (uint32_t i=0 ; i<pContext->mMeasurementWindowSizeInBuffers ; i++) {
                pContext->mPastMeasurements[i].mIsValid = false;
                pContext->mPastMeasurements[i].mPeakU16 = 0;
                pContext->mPastMeasurements[i].mRmsSquared = 0;
 }
            pContext->mMeasurementBufferIdx = 0;
 } else {
 // only use actual measurements, otherwise the first RMS measure happening before
 // MEASUREMENT_WINDOW_MAX_SIZE_IN_BUFFERS have been played will always be artificially
 // low
 for (uint32_t i=0 ; i < pContext->mMeasurementWindowSizeInBuffers ; i++) {
 if (pContext->mPastMeasurements[i].mIsValid) {
 if (pContext->mPastMeasurements[i].mPeakU16 > peakU16) {
                        peakU16 = pContext->mPastMeasurements[i].mPeakU16;
 }
                    sumRmsSquared += pContext->mPastMeasurements[i].mRmsSquared;
                    nbValidMeasurements++;
 }
 }
 }
 float rms = nbValidMeasurements == 0 ? 0.0f : sqrtf(sumRmsSquared / nbValidMeasurements);
 int32_t* pIntReplyData = (int32_t*)pReplyData;
 // convert from I16 sample values to mB and write results
 if (rms < 0.000016f) {
            pIntReplyData[MEASUREMENT_IDX_RMS] = -9600; //-96dB
 } else {
            pIntReplyData[MEASUREMENT_IDX_RMS] = (int32_t) (2000 * log10(rms / 32767.0f));
 }
 if (peakU16 == 0) {
            pIntReplyData[MEASUREMENT_IDX_PEAK] = -9600; //-96dB
 } else {
            pIntReplyData[MEASUREMENT_IDX_PEAK] = (int32_t) (2000 * log10(peakU16 / 32767.0f));
 }
        ALOGV(""VISUALIZER_CMD_MEASURE peak=%"" PRIu16 "" (%"" PRId32 ""mB), rms=%.1f (%"" PRId32 ""mB)"",
                peakU16, pIntReplyData[MEASUREMENT_IDX_PEAK],
                rms, pIntReplyData[MEASUREMENT_IDX_RMS]);
 }
 break;

 default:
        ALOGW(""Visualizer_command invalid command %"" PRIu32, cmdCode);
 return -EINVAL;
 }

 return 0;
}
",188085,"int Visualizer_command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,
 void *pCmdData, uint32_t *replySize, void *pReplyData) {

 VisualizerContext * pContext = (VisualizerContext *)self;
 int retsize;

 if (pContext == NULL || pContext->mState == VISUALIZER_STATE_UNINITIALIZED) {
 return -EINVAL;
 }


 switch (cmdCode) {
 case EFFECT_CMD_INIT:
 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 *(int *) pReplyData = Visualizer_init(pContext);
 break;
 case EFFECT_CMD_SET_CONFIG:
 if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)
 || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 *(int *) pReplyData = Visualizer_setConfig(pContext,
 (effect_config_t *) pCmdData);
 break;
 case EFFECT_CMD_GET_CONFIG:
 if (pReplyData == NULL || replySize == NULL ||
 *replySize != sizeof(effect_config_t)) {
 return -EINVAL;
 }
 Visualizer_getConfig(pContext, (effect_config_t *)pReplyData);
 break;
 case EFFECT_CMD_RESET:
 Visualizer_reset(pContext);
 break;
 case EFFECT_CMD_ENABLE:
 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 if (pContext->mState != VISUALIZER_STATE_INITIALIZED) {
 return -ENOSYS;
 }
        pContext->mState = VISUALIZER_STATE_ACTIVE;
        ALOGV(""EFFECT_CMD_ENABLE() OK"");
 *(int *)pReplyData = 0;
 break;
 case EFFECT_CMD_DISABLE:
 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 if (pContext->mState != VISUALIZER_STATE_ACTIVE) {
 return -ENOSYS;
 }
        pContext->mState = VISUALIZER_STATE_INITIALIZED;
        ALOGV(""EFFECT_CMD_DISABLE() OK"");
 *(int *)pReplyData = 0;
 break;
 case EFFECT_CMD_GET_PARAM: {
 if (pCmdData == NULL ||
            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||
            pReplyData == NULL || replySize == NULL ||
 *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {
 return -EINVAL;
 }
        memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(uint32_t));
 effect_param_t *p = (effect_param_t *)pReplyData;
        p->status = 0;
 *replySize = sizeof(effect_param_t) + sizeof(uint32_t);
 if (p->psize != sizeof(uint32_t)) {
            p->status = -EINVAL;
 break;
 }
 switch (*(uint32_t *)p->data) {
 case VISUALIZER_PARAM_CAPTURE_SIZE:
            ALOGV(""get mCaptureSize = %"" PRIu32, pContext->mCaptureSize);
 *((uint32_t *)p->data + 1) = pContext->mCaptureSize;
            p->vsize = sizeof(uint32_t);
 *replySize += sizeof(uint32_t);
 break;
 case VISUALIZER_PARAM_SCALING_MODE:
            ALOGV(""get mScalingMode = %"" PRIu32, pContext->mScalingMode);
 *((uint32_t *)p->data + 1) = pContext->mScalingMode;
            p->vsize = sizeof(uint32_t);
 *replySize += sizeof(uint32_t);
 break;
 case VISUALIZER_PARAM_MEASUREMENT_MODE:
            ALOGV(""get mMeasurementMode = %"" PRIu32, pContext->mMeasurementMode);
 *((uint32_t *)p->data + 1) = pContext->mMeasurementMode;
            p->vsize = sizeof(uint32_t);
 *replySize += sizeof(uint32_t);
 break;
 default:
            p->status = -EINVAL;
 }
 } break;
 case EFFECT_CMD_SET_PARAM: {
 if (pCmdData == NULL ||
            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||
            pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {
 return -EINVAL;
 }
 *(int32_t *)pReplyData = 0;
 effect_param_t *p = (effect_param_t *)pCmdData;
 if (p->psize != sizeof(uint32_t) || p->vsize != sizeof(uint32_t)) {
 *(int32_t *)pReplyData = -EINVAL;

             break;
         }
         switch (*(uint32_t *)p->data) {
        case VISUALIZER_PARAM_CAPTURE_SIZE:
            pContext->mCaptureSize = *((uint32_t *)p->data + 1);
            ALOGV(""set mCaptureSize = %"" PRIu32, pContext->mCaptureSize);
            break;
         case VISUALIZER_PARAM_SCALING_MODE:
             pContext->mScalingMode = *((uint32_t *)p->data + 1);
             ALOGV(""set mScalingMode = %"" PRIu32, pContext->mScalingMode);
             break;
        case VISUALIZER_PARAM_LATENCY:
            pContext->mLatency = *((uint32_t *)p->data + 1);
            ALOGV(""set mLatency = %"" PRIu32, pContext->mLatency);
            break;
         case VISUALIZER_PARAM_MEASUREMENT_MODE:
             pContext->mMeasurementMode = *((uint32_t *)p->data + 1);
             ALOGV(""set mMeasurementMode = %"" PRIu32, pContext->mMeasurementMode);
 break;
 default:
 *(int32_t *)pReplyData = -EINVAL;
 }
 } break;
 case EFFECT_CMD_SET_DEVICE:
 case EFFECT_CMD_SET_VOLUME:
 case EFFECT_CMD_SET_AUDIO_MODE:
 break;


 case VISUALIZER_CMD_CAPTURE: {
 uint32_t captureSize = pContext->mCaptureSize;
 if (pReplyData == NULL || replySize == NULL || *replySize != captureSize) {
            ALOGV(""VISUALIZER_CMD_CAPTURE() error *replySize %"" PRIu32 "" captureSize %"" PRIu32,
 *replySize, captureSize);
 return -EINVAL;
 }
 if (pContext->mState == VISUALIZER_STATE_ACTIVE) {
 const uint32_t deltaMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);

 if ((pContext->mLastCaptureIdx == pContext->mCaptureIdx) &&
 (pContext->mBufferUpdateTime.tv_sec != 0) &&
 (deltaMs > MAX_STALL_TIME_MS)) {
                    ALOGV(""capture going to idle"");
                    pContext->mBufferUpdateTime.tv_sec = 0;
                    memset(pReplyData, 0x80, captureSize);
 } else {
 int32_t latencyMs = pContext->mLatency;
                latencyMs -= deltaMs;

                 if (latencyMs < 0) {
                     latencyMs = 0;
                 }
                const uint32_t deltaSmpl =
                    pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;
                int32_t capturePoint = pContext->mCaptureIdx - captureSize - deltaSmpl;
 
                 if (capturePoint < 0) {
                     uint32_t size = -capturePoint;
                     if (size > captureSize) {
                        size = captureSize;
 }
                    memcpy(pReplyData,
                           pContext->mCaptureBuf + CAPTURE_BUF_SIZE + capturePoint,
                           size);
                    pReplyData = (char *)pReplyData + size;
                    captureSize -= size;
                    capturePoint = 0;
 }
                memcpy(pReplyData,
                       pContext->mCaptureBuf + capturePoint,
                       captureSize);
 }

            pContext->mLastCaptureIdx = pContext->mCaptureIdx;
 } else {
            memset(pReplyData, 0x80, captureSize);
 }

 } break;

 case VISUALIZER_CMD_MEASURE: {
 if (pReplyData == NULL || replySize == NULL ||
 *replySize < (sizeof(int32_t) * MEASUREMENT_COUNT)) {
 if (replySize == NULL) {
                ALOGV(""VISUALIZER_CMD_MEASURE() error replySize NULL"");
 } else {
                ALOGV(""VISUALIZER_CMD_MEASURE() error *replySize %"" PRIu32
 "" < (sizeof(int32_t) * MEASUREMENT_COUNT) %"" PRIu32,
 *replySize,
 uint32_t(sizeof(int32_t)) * MEASUREMENT_COUNT);
 }
            android_errorWriteLog(0x534e4554, ""30229821"");
 return -EINVAL;
 }
 uint16_t peakU16 = 0;
 float sumRmsSquared = 0.0f;
 uint8_t nbValidMeasurements = 0;
 const int32_t delayMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);
 if (delayMs > DISCARD_MEASUREMENTS_TIME_MS) {
            ALOGV(""Discarding measurements, last measurement is %"" PRId32 ""ms old"", delayMs);
 for (uint32_t i=0 ; i<pContext->mMeasurementWindowSizeInBuffers ; i++) {
                pContext->mPastMeasurements[i].mIsValid = false;
                pContext->mPastMeasurements[i].mPeakU16 = 0;
                pContext->mPastMeasurements[i].mRmsSquared = 0;
 }
            pContext->mMeasurementBufferIdx = 0;
 } else {
 for (uint32_t i=0 ; i < pContext->mMeasurementWindowSizeInBuffers ; i++) {
 if (pContext->mPastMeasurements[i].mIsValid) {
 if (pContext->mPastMeasurements[i].mPeakU16 > peakU16) {
                        peakU16 = pContext->mPastMeasurements[i].mPeakU16;
 }
                    sumRmsSquared += pContext->mPastMeasurements[i].mRmsSquared;
                    nbValidMeasurements++;
 }
 }
 }
 float rms = nbValidMeasurements == 0 ? 0.0f : sqrtf(sumRmsSquared / nbValidMeasurements);
 int32_t* pIntReplyData = (int32_t*)pReplyData;
 if (rms < 0.000016f) {
            pIntReplyData[MEASUREMENT_IDX_RMS] = -9600; //-96dB
 } else {
            pIntReplyData[MEASUREMENT_IDX_RMS] = (int32_t) (2000 * log10(rms / 32767.0f));
 }
 if (peakU16 == 0) {
            pIntReplyData[MEASUREMENT_IDX_PEAK] = -9600; //-96dB
 } else {
            pIntReplyData[MEASUREMENT_IDX_PEAK] = (int32_t) (2000 * log10(peakU16 / 32767.0f));
 }
        ALOGV(""VISUALIZER_CMD_MEASURE peak=%"" PRIu16 "" (%"" PRId32 ""mB), rms=%.1f (%"" PRId32 ""mB)"",
                peakU16, pIntReplyData[MEASUREMENT_IDX_PEAK],
                rms, pIntReplyData[MEASUREMENT_IDX_RMS]);
 }
 break;

 default:
        ALOGW(""Visualizer_command invalid command %"" PRIu32, cmdCode);
 return -EINVAL;
 }

 return 0;
}
","int Visualizer_command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,
 void *pCmdData, uint32_t *replySize, void *pReplyData) {

 VisualizerContext * pContext = (VisualizerContext *)self;
 int retsize;

 if (pContext == NULL || pContext->mState == VISUALIZER_STATE_UNINITIALIZED) {
 return -EINVAL;
 }


 switch (cmdCode) {
 case EFFECT_CMD_INIT:
 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 *(int *) pReplyData = Visualizer_init(pContext);
 break;
 case EFFECT_CMD_SET_CONFIG:
 if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)
 || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 *(int *) pReplyData = Visualizer_setConfig(pContext,
 (effect_config_t *) pCmdData);
 break;
 case EFFECT_CMD_GET_CONFIG:
 if (pReplyData == NULL || replySize == NULL ||
 *replySize != sizeof(effect_config_t)) {
 return -EINVAL;
 }
 Visualizer_getConfig(pContext, (effect_config_t *)pReplyData);
 break;
 case EFFECT_CMD_RESET:
 Visualizer_reset(pContext);
 break;
 case EFFECT_CMD_ENABLE:
 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 if (pContext->mState != VISUALIZER_STATE_INITIALIZED) {
 return -ENOSYS;
 }
        pContext->mState = VISUALIZER_STATE_ACTIVE;
        ALOGV(""EFFECT_CMD_ENABLE() OK"");
 *(int *)pReplyData = 0;
 break;
 case EFFECT_CMD_DISABLE:
 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
 return -EINVAL;
 }
 if (pContext->mState != VISUALIZER_STATE_ACTIVE) {
 return -ENOSYS;
 }
        pContext->mState = VISUALIZER_STATE_INITIALIZED;
        ALOGV(""EFFECT_CMD_DISABLE() OK"");
 *(int *)pReplyData = 0;
 break;
 case EFFECT_CMD_GET_PARAM: {
 if (pCmdData == NULL ||
            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||
            pReplyData == NULL || replySize == NULL ||
 *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {
 return -EINVAL;
 }
        memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(uint32_t));
 effect_param_t *p = (effect_param_t *)pReplyData;
        p->status = 0;
 *replySize = sizeof(effect_param_t) + sizeof(uint32_t);
 if (p->psize != sizeof(uint32_t)) {
            p->status = -EINVAL;
 break;
 }
 switch (*(uint32_t *)p->data) {
 case VISUALIZER_PARAM_CAPTURE_SIZE:
            ALOGV(""get mCaptureSize = %"" PRIu32, pContext->mCaptureSize);
 *((uint32_t *)p->data + 1) = pContext->mCaptureSize;
            p->vsize = sizeof(uint32_t);
 *replySize += sizeof(uint32_t);
 break;
 case VISUALIZER_PARAM_SCALING_MODE:
            ALOGV(""get mScalingMode = %"" PRIu32, pContext->mScalingMode);
 *((uint32_t *)p->data + 1) = pContext->mScalingMode;
            p->vsize = sizeof(uint32_t);
 *replySize += sizeof(uint32_t);
 break;
 case VISUALIZER_PARAM_MEASUREMENT_MODE:
            ALOGV(""get mMeasurementMode = %"" PRIu32, pContext->mMeasurementMode);
 *((uint32_t *)p->data + 1) = pContext->mMeasurementMode;
            p->vsize = sizeof(uint32_t);
 *replySize += sizeof(uint32_t);
 break;
 default:
            p->status = -EINVAL;
 }
 } break;
 case EFFECT_CMD_SET_PARAM: {
 if (pCmdData == NULL ||
            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||
            pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {
 return -EINVAL;
 }
 *(int32_t *)pReplyData = 0;
 effect_param_t *p = (effect_param_t *)pCmdData;
 if (p->psize != sizeof(uint32_t) || p->vsize != sizeof(uint32_t)) {
 *(int32_t *)pReplyData = -EINVAL;

             break;
         }
         switch (*(uint32_t *)p->data) {
        case VISUALIZER_PARAM_CAPTURE_SIZE: {
            const uint32_t captureSize = *((uint32_t *)p->data + 1);
            if (captureSize > VISUALIZER_CAPTURE_SIZE_MAX) {
                android_errorWriteLog(0x534e4554, ""31781965"");
                *(int32_t *)pReplyData = -EINVAL;
                ALOGW(""set mCaptureSize = %u > %u"", captureSize, VISUALIZER_CAPTURE_SIZE_MAX);
            } else {
                pContext->mCaptureSize = captureSize;
                ALOGV(""set mCaptureSize = %u"", captureSize);
            }
            } break;
         case VISUALIZER_PARAM_SCALING_MODE:
             pContext->mScalingMode = *((uint32_t *)p->data + 1);
             ALOGV(""set mScalingMode = %"" PRIu32, pContext->mScalingMode);
             break;
        case VISUALIZER_PARAM_LATENCY: {
            uint32_t latency = *((uint32_t *)p->data + 1);
            if (latency > MAX_LATENCY_MS) {
                latency = MAX_LATENCY_MS; // clamp latency b/31781965
            }
            pContext->mLatency = latency;
            ALOGV(""set mLatency = %u"", latency);
            } break;
         case VISUALIZER_PARAM_MEASUREMENT_MODE:
             pContext->mMeasurementMode = *((uint32_t *)p->data + 1);
             ALOGV(""set mMeasurementMode = %"" PRIu32, pContext->mMeasurementMode);
 break;
 default:
 *(int32_t *)pReplyData = -EINVAL;
 }
 } break;
 case EFFECT_CMD_SET_DEVICE:
 case EFFECT_CMD_SET_VOLUME:
 case EFFECT_CMD_SET_AUDIO_MODE:
 break;


 case VISUALIZER_CMD_CAPTURE: {
 uint32_t captureSize = pContext->mCaptureSize;
 if (pReplyData == NULL || replySize == NULL || *replySize != captureSize) {
            ALOGV(""VISUALIZER_CMD_CAPTURE() error *replySize %"" PRIu32 "" captureSize %"" PRIu32,
 *replySize, captureSize);
 return -EINVAL;
 }
 if (pContext->mState == VISUALIZER_STATE_ACTIVE) {
 const uint32_t deltaMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);

 if ((pContext->mLastCaptureIdx == pContext->mCaptureIdx) &&
 (pContext->mBufferUpdateTime.tv_sec != 0) &&
 (deltaMs > MAX_STALL_TIME_MS)) {
                    ALOGV(""capture going to idle"");
                    pContext->mBufferUpdateTime.tv_sec = 0;
                    memset(pReplyData, 0x80, captureSize);
 } else {
 int32_t latencyMs = pContext->mLatency;
                latencyMs -= deltaMs;

                 if (latencyMs < 0) {
                     latencyMs = 0;
                 }
                uint32_t deltaSmpl = captureSize
                        + pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;
 
                // large sample rate, latency, or capture size, could cause overflow.
                // do not offset more than the size of buffer.
                if (deltaSmpl > CAPTURE_BUF_SIZE) {
                    android_errorWriteLog(0x534e4554, ""31781965"");
                    deltaSmpl = CAPTURE_BUF_SIZE;
                }

                int32_t capturePoint = pContext->mCaptureIdx - deltaSmpl;
                // a negative capturePoint means we wrap the buffer.
                 if (capturePoint < 0) {
                     uint32_t size = -capturePoint;
                     if (size > captureSize) {
                        size = captureSize;
 }
                    memcpy(pReplyData,
                           pContext->mCaptureBuf + CAPTURE_BUF_SIZE + capturePoint,
                           size);
                    pReplyData = (char *)pReplyData + size;
                    captureSize -= size;
                    capturePoint = 0;
 }
                memcpy(pReplyData,
                       pContext->mCaptureBuf + capturePoint,
                       captureSize);
 }

            pContext->mLastCaptureIdx = pContext->mCaptureIdx;
 } else {
            memset(pReplyData, 0x80, captureSize);
 }

 } break;

 case VISUALIZER_CMD_MEASURE: {
 if (pReplyData == NULL || replySize == NULL ||
 *replySize < (sizeof(int32_t) * MEASUREMENT_COUNT)) {
 if (replySize == NULL) {
                ALOGV(""VISUALIZER_CMD_MEASURE() error replySize NULL"");
 } else {
                ALOGV(""VISUALIZER_CMD_MEASURE() error *replySize %"" PRIu32
 "" < (sizeof(int32_t) * MEASUREMENT_COUNT) %"" PRIu32,
 *replySize,
 uint32_t(sizeof(int32_t)) * MEASUREMENT_COUNT);
 }
            android_errorWriteLog(0x534e4554, ""30229821"");
 return -EINVAL;
 }
 uint16_t peakU16 = 0;
 float sumRmsSquared = 0.0f;
 uint8_t nbValidMeasurements = 0;
 const int32_t delayMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);
 if (delayMs > DISCARD_MEASUREMENTS_TIME_MS) {
            ALOGV(""Discarding measurements, last measurement is %"" PRId32 ""ms old"", delayMs);
 for (uint32_t i=0 ; i<pContext->mMeasurementWindowSizeInBuffers ; i++) {
                pContext->mPastMeasurements[i].mIsValid = false;
                pContext->mPastMeasurements[i].mPeakU16 = 0;
                pContext->mPastMeasurements[i].mRmsSquared = 0;
 }
            pContext->mMeasurementBufferIdx = 0;
 } else {
 for (uint32_t i=0 ; i < pContext->mMeasurementWindowSizeInBuffers ; i++) {
 if (pContext->mPastMeasurements[i].mIsValid) {
 if (pContext->mPastMeasurements[i].mPeakU16 > peakU16) {
                        peakU16 = pContext->mPastMeasurements[i].mPeakU16;
 }
                    sumRmsSquared += pContext->mPastMeasurements[i].mRmsSquared;
                    nbValidMeasurements++;
 }
 }
 }
 float rms = nbValidMeasurements == 0 ? 0.0f : sqrtf(sumRmsSquared / nbValidMeasurements);
 int32_t* pIntReplyData = (int32_t*)pReplyData;
 if (rms < 0.000016f) {
            pIntReplyData[MEASUREMENT_IDX_RMS] = -9600; //-96dB
 } else {
            pIntReplyData[MEASUREMENT_IDX_RMS] = (int32_t) (2000 * log10(rms / 32767.0f));
 }
 if (peakU16 == 0) {
            pIntReplyData[MEASUREMENT_IDX_PEAK] = -9600; //-96dB
 } else {
            pIntReplyData[MEASUREMENT_IDX_PEAK] = (int32_t) (2000 * log10(peakU16 / 32767.0f));
 }
        ALOGV(""VISUALIZER_CMD_MEASURE peak=%"" PRIu16 "" (%"" PRId32 ""mB), rms=%.1f (%"" PRId32 ""mB)"",
                peakU16, pIntReplyData[MEASUREMENT_IDX_PEAK],
                rms, pIntReplyData[MEASUREMENT_IDX_RMS]);
 }
 break;

 default:
        ALOGW(""Visualizer_command invalid command %"" PRIu32, cmdCode);
 return -EINVAL;
 }

 return 0;
}
","The `Visualizer_command` function processes various commands related to a visualizer effect in an audio processing context. It first checks the validity of the provided context and command parameters. Depending on the `cmdCode`, it can initialize the visualizer, set or get configuration parameters, enable or disable the effect, capture audio data, or measure audio characteristics like RMS and peak levels. Each command is validated for the correct data size and state, and appropriate actions are taken, such as updating context variables or returning measurement results. The function ensures robust error handling and logging throughout its execution.","The provided code defines a function that handles various commands for an audio visualizer effect, ensuring proper initialization and state management. It validates input parameters and executes specific actions based on the command type, such as initializing the visualizer, configuring settings, enabling or disabling the effect, capturing audio data, and measuring audio characteristics. The function also manages error handling by checking for invalid inputs and states, while logging relevant information throughout the process. Overall, it facilitates interaction with the visualizer by processing commands and returning appropriate responses based on the current context.","The vulnerability in the original code stemmed from the lack of validation for the capture size and latency parameters, which could allow an attacker to set these values beyond acceptable limits, potentially leading to buffer overflows or other unintended behaviors. In the fixed code, checks were introduced to ensure that the capture size does not exceed a predefined maximum value, and the latency is clamped to a maximum threshold. This prevents excessive values from being processed, thereby enhancing the robustness and security of the visualizer by mitigating risks associated with invalid parameter inputs.","The vulnerability in the original code arose from insufficient validation of parameters related to capture size and latency, which could allow malicious inputs to exceed safe limits, potentially leading to buffer overflows or crashes. The fix implemented checks to ensure that the capture size does not surpass a defined maximum and that the latency is capped at a safe threshold. By enforcing these constraints, the updated code mitigates the risk of processing invalid inputs, thereby enhancing the overall security and stability of the visualizer functionality.","The vulnerability was fixed by introducing validation checks for the capture size and latency parameters within the command handling logic. Specifically, the code now verifies that the capture size does not exceed a predefined maximum value, `VISUALIZER_CAPTURE_SIZE_MAX`, before updating the corresponding context variable. Additionally, the latency is clamped to a maximum value, `MAX_LATENCY_MS`, ensuring it remains within acceptable limits. These changes prevent the assignment of excessively large values to the context variables, thereby reducing the risk of buffer overflows and enhancing the overall robustness of the visualizer's functionality.","The vulnerability was addressed by implementing validation checks for critical parameters related to capture size and latency. The updated code ensures that the capture size is constrained to a maximum allowable limit, preventing excessively large values that could lead to buffer overflows. Additionally, the latency is capped to ensure it remains within a safe range. These measures effectively mitigate the risk of processing invalid inputs, enhancing the security and stability of the system by ensuring that only appropriate values are accepted and processed.","5, 5","5, 5","4, 4","4,4"
123,123,188105,188105,,Local,Not required,,CVE-2018-9499,https://www.cvedetails.com/cve/CVE-2018-9499/,CWE-200,Low,Complete,,,2018-10-02,4.9,"In readVector of iCrypto.cpp, there is a possible invalid read due to uninitialized data. This could lead to local information disclosure from the DRM server with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-79218474",2018-11-20,+Info ,7,https://android.googlesource.com/platform/frameworks/av/+/bf7a67c33c0f044abeef3b9746f434b7f3295bb1,bf7a67c33c0f044abeef3b9746f434b7f3295bb1,"Fix information disclosure in mediadrmserver

Test:POC provided in bug
Bug:79218474
Change-Id: Iba12c07a5e615f8ed234b01ac53e3559ba9ac12e
(cherry picked from commit c1bf68a8d1321d7cdf7da6933f0b89b171d251c6)
",2,drm/libmediadrm/ICrypto.cpp,"{""filename"": ""drm/libmediadrm/ICrypto.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/bf7a67c33c0f044abeef3b9746f434b7f3295bb1/drm/libmediadrm/ICrypto.cpp"", ""patch"": ""@@ -225,8 +225,13 @@\n\n \n void BnCrypto::readVector(const Parcel &data, Vector<uint8_t> &vector) const {\n     uint32_t size = data.readInt32();\n-    vector.insertAt((size_t)0, size);\n-    data.read(vector.editArray(), size);\n+    if (vector.insertAt((size_t)0, size) < 0) {\n+        vector.clear();\n+    }\n+    if (data.read(vector.editArray(), size) != NO_ERROR) {\n+        vector.clear();\n+        android_errorWriteWithInfoLog(0x534e4554, \""62872384\"", -1, NULL, 0);\n+    }\n }\n \n void BnCrypto::writeVector(Parcel *reply, Vector<uint8_t> const &vector) const {\n""}"," void BnCrypto::readVector(const Parcel &data, Vector<uint8_t> &vector) const {
     uint32_t size = data.readInt32();
    if (vector.insertAt((size_t)0, size) < 0) {
        vector.clear();
    }
    if (data.read(vector.editArray(), size) != NO_ERROR) {
        vector.clear();
        android_errorWriteWithInfoLog(0x534e4554, ""62872384"", -1, NULL, 0);
    }
 }
"," void BnCrypto::readVector(const Parcel &data, Vector<uint8_t> &vector) const {
     uint32_t size = data.readInt32();
    vector.insertAt((size_t)0, size);
    data.read(vector.editArray(), size);
 }
",C,"    if (vector.insertAt((size_t)0, size) < 0) {
        vector.clear();
    }
    if (data.read(vector.editArray(), size) != NO_ERROR) {
        vector.clear();
        android_errorWriteWithInfoLog(0x534e4554, ""62872384"", -1, NULL, 0);
    }
","    vector.insertAt((size_t)0, size);
    data.read(vector.editArray(), size);
",,"@@ -225,8 +225,13 @@

 
 void BnCrypto::readVector(const Parcel &data, Vector<uint8_t> &vector) const {
     uint32_t size = data.readInt32();
-    vector.insertAt((size_t)0, size);
-    data.read(vector.editArray(), size);
+    if (vector.insertAt((size_t)0, size) < 0) {
+        vector.clear();
+    }
+    if (data.read(vector.editArray(), size) != NO_ERROR) {
+        vector.clear();
+        android_errorWriteWithInfoLog(0x534e4554, ""62872384"", -1, NULL, 0);
+    }
 }
 
 void BnCrypto::writeVector(Parcel *reply, Vector<uint8_t> const &vector) const {
",Android,https://android.googlesource.com/platform/frameworks/av/+/bf7a67c33c0f044abeef3b9746f434b7f3295bb1/,https://android.googlesource.com/platform/frameworks/av/+/bf7a67c33c0f044abeef3b9746f434b7f3295bb1%5E/,1," void BnCrypto::readVector(const Parcel &data, Vector<uint8_t> &vector) const {
     uint32_t size = data.readInt32();
//flaw_line_below:
    vector.insertAt((size_t)0, size);
//flaw_line_below:
    data.read(vector.editArray(), size);
//fix_flaw_line_below:
//    if (vector.insertAt((size_t)0, size) < 0) {
//fix_flaw_line_below:
//        vector.clear();
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//    if (data.read(vector.editArray(), size) != NO_ERROR) {
//fix_flaw_line_below:
//        vector.clear();
//fix_flaw_line_below:
//        android_errorWriteWithInfoLog(0x534e4554, ""62872384"", -1, NULL, 0);
//fix_flaw_line_below:
//    }
 }
",188105," void BnCrypto::readVector(const Parcel &data, Vector<uint8_t> &vector) const {
     uint32_t size = data.readInt32();
    vector.insertAt((size_t)0, size);
    data.read(vector.editArray(), size);
 }
"," void BnCrypto::readVector(const Parcel &data, Vector<uint8_t> &vector) const {
     uint32_t size = data.readInt32();
    if (vector.insertAt((size_t)0, size) < 0) {
        vector.clear();
    }
    if (data.read(vector.editArray(), size) != NO_ERROR) {
        vector.clear();
        android_errorWriteWithInfoLog(0x534e4554, ""62872384"", -1, NULL, 0);
    }
 }
","The provided code defines a method `readVector` within the `BnCrypto` class, which reads a vector of unsigned 8-bit integers from a `Parcel` object. It first retrieves the size of the data to be read by calling `readInt32()` on the `data` object. Then, it initializes the `vector` by inserting a specified number of elements (equal to the size) at the beginning. Finally, it populates the vector with the actual data from the `Parcel` by reading `size` bytes into the vector's underlying array using `editArray()`. This method effectively facilitates the transfer of binary data into a dynamically sized vector.","The code defines a method that reads a sequence of bytes from a data source and stores them in a dynamic array. It begins by determining the number of bytes to read, which is specified in the data source. The method then initializes the dynamic array to accommodate this number of bytes. Finally, it retrieves the specified number of bytes from the data source and populates the dynamic array with this data. This functionality allows for efficient handling and storage of binary data in a flexible array structure.","The vulnerability in the original code arises from the lack of error handling when inserting elements into the dynamic array and reading data from the source. If the insertion fails or if reading the specified number of bytes does not succeed, the code does not adequately manage these failures, potentially leading to information disclosure or memory corruption. In the fixed code, error checks were added after the insertion and reading operations. If the insertion fails, the dynamic array is cleared, and if reading fails, it also clears the array and logs an error, thus preventing the exposure of invalid or uninitialized data.","The vulnerability in the original code stemmed from inadequate error handling during data insertion and reading operations, which could lead to information disclosure or memory corruption if these operations failed. Specifically, if the insertion of data into the dynamic array or the reading of bytes from the source encountered an error, the code did not manage these failures properly, potentially exposing invalid data. The fixed code introduced checks to verify the success of both operations. If either operation fails, the code now clears the dynamic array and logs an error, thereby preventing the risk of exposing uninitialized or erroneous data.","The vulnerability was fixed by adding error handling after critical operations in the code. Specifically, after the insertion of elements into the dynamic array using `insertAt`, the code checks if the operation was successful by evaluating the return value. If the insertion fails (indicated by a negative return value), the dynamic array is cleared to prevent any invalid data exposure. Additionally, after attempting to read data with `read`, the code checks for errors by comparing the result to `NO_ERROR`. If reading fails, it also clears the array and logs an error, ensuring that no uninitialized or erroneous data is accessible.","The vulnerability was addressed by implementing robust error handling mechanisms following critical operations. The code now checks the success of the data insertion process, and if it fails, it clears the dynamic array to prevent any exposure of invalid data. Additionally, after attempting to read data, the code verifies whether the operation was successful. If reading fails, it also clears the array and logs an error. These changes ensure that any failure in data handling is properly managed, thereby mitigating the risk of information disclosure or memory corruption due to uninitialized or erroneous data being accessed.","4,4","5,5","4,4","5, 5"
124,124,188127,188127,,Remote,Not required,Complete,CVE-2017-13204,https://www.cvedetails.com/cve/CVE-2017-13204/,CWE-200,Low,Partial,,,2018-01-12,8.5,"An information disclosure vulnerability in the Android media framework (libavc). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-64380237.",2018-01-25,+Info ,12,https://android.googlesource.com/platform/external/libavc/+/42cf02965b11c397dd37a0063e683cef005bc0ae,42cf02965b11c397dd37a0063e683cef005bc0ae,"Decoder: Detect change of mbaff flag in SPS

Change in Mbaff flag needs re-initialization of NMB group
and other variables in decoder context.

Bug: 64380237
Test: ran poc on ASAN before/after
Change-Id: I0fc65e4dfc3cc2c15528ec52da1782ecec61feab
(cherry picked from commit d524ba03101c0c662c9d365d7357536b42a0265e)
",2,decoder/ih264d_parse_headers.c,"{""filename"": ""decoder/ih264d_parse_headers.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libavc/+/42cf02965b11c397dd37a0063e683cef005bc0ae/decoder/ih264d_parse_headers.c"", ""patch"": ""@@ -479,7 +479,7 @@\n\n {\n     UWORD8 i;\n     dec_seq_params_t *ps_seq = NULL;\n-    UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id;\n+    UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id, u1_mb_aff_flag = 0;\n     UWORD16 i2_max_frm_num;\n     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n@@ -802,9 +802,19 @@\n\n     COPYTHECONTEXT(\""SPS: frame_mbs_only_flag\"", u1_frm);\n \n     if(!u1_frm)\n+        u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);\n+\n+    if((ps_dec->i4_header_decoded & 1)\n+                    && (ps_seq->u1_mb_aff_flag != u1_mb_aff_flag))\n+    {\n+        ps_dec->u1_res_changed = 1;\n+        return IVD_RES_CHANGED;\n+    }\n+\n+    if(!u1_frm)\n     {\n         u2_pic_ht <<= 1;\n-        ps_seq->u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);\n+        ps_seq->u1_mb_aff_flag = u1_mb_aff_flag;\n         COPYTHECONTEXT(\""SPS: mb_adaptive_frame_field_flag\"",\n                         ps_seq->u1_mb_aff_flag);\n \n""}","WORD32 ih264d_parse_sps(dec_struct_t *ps_dec, dec_bit_stream_t *ps_bitstrm)

 {
     UWORD8 i;
     dec_seq_params_t *ps_seq = NULL;
    UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id, u1_mb_aff_flag = 0;
     UWORD16 i2_max_frm_num;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
    UWORD8 u1_frm, uc_constraint_set0_flag, uc_constraint_set1_flag;
    WORD32 i4_cropped_ht, i4_cropped_wd;
    UWORD32 u4_temp;
    WORD32 pic_height_in_map_units_minus1 = 0;
    UWORD32 u2_pic_wd = 0;
    UWORD32 u2_pic_ht = 0;
    UWORD32 u2_frm_wd_y = 0;
    UWORD32 u2_frm_ht_y = 0;
    UWORD32 u2_frm_wd_uv = 0;
    UWORD32 u2_frm_ht_uv = 0;
    UWORD32 u2_crop_offset_y = 0;
    UWORD32 u2_crop_offset_uv = 0;
    WORD32 ret;
    UWORD32 u4_num_reorder_frames;
 /* High profile related syntax element */
    WORD32 i4_i;
 /* G050 */
    UWORD8 u1_frame_cropping_flag, u1_frame_cropping_rect_left_ofst,
                    u1_frame_cropping_rect_right_ofst,
                    u1_frame_cropping_rect_top_ofst,
                    u1_frame_cropping_rect_bottom_ofst;
 /* G050 */
 /*--------------------------------------------------------------------*/
 /* Decode seq_parameter_set_id and profile and level values           */
 /*--------------------------------------------------------------------*/
    SWITCHONTRACE;
    u1_profile_idc = ih264d_get_bits_h264(ps_bitstrm, 8);
    COPYTHECONTEXT(""SPS: profile_idc"",u1_profile_idc);

 /* G050 */
    uc_constraint_set0_flag = ih264d_get_bit_h264(ps_bitstrm);
    uc_constraint_set1_flag = ih264d_get_bit_h264(ps_bitstrm);
    ih264d_get_bit_h264(ps_bitstrm);

 /*****************************************************/
 /* Read 5 bits for uc_constraint_set3_flag (1 bit)   */
 /* and reserved_zero_4bits (4 bits) - Sushant        */
 /*****************************************************/
    ih264d_get_bits_h264(ps_bitstrm, 5);
 /* G050 */

 /* Check whether particular profile is suported or not */
 /* Check whether particular profile is suported or not */
 if((u1_profile_idc != MAIN_PROFILE_IDC) &&

 (u1_profile_idc != BASE_PROFILE_IDC) &&

 (u1_profile_idc != HIGH_PROFILE_IDC)

 )
 {

 /* Apart from Baseline, main and high profile,
         * only extended profile is supported provided
         * uc_constraint_set0_flag or uc_constraint_set1_flag are set to 1
         */
 if((u1_profile_idc != EXTENDED_PROFILE_IDC) ||
 ((uc_constraint_set1_flag != 1) && (uc_constraint_set0_flag != 1)))
 {
 return (ERROR_FEATURE_UNAVAIL);
 }
 }

    u1_level_idc = ih264d_get_bits_h264(ps_bitstrm, 8);



    COPYTHECONTEXT(""SPS: u4_level_idc"",u1_level_idc);

    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp & MASK_ERR_SEQ_SET_ID)
 return ERROR_INV_SPS_PPS_T;
    u1_seq_parameter_set_id = u4_temp;
    COPYTHECONTEXT(""SPS: seq_parameter_set_id"",
                    u1_seq_parameter_set_id);

 /*--------------------------------------------------------------------*/
 /* Find an seq param entry in seqparam array of decStruct             */
 /*--------------------------------------------------------------------*/

    ps_seq = ps_dec->pv_scratch_sps_pps;
 if(ps_dec->i4_header_decoded & 1)
 {
 *ps_seq = *ps_dec->ps_cur_sps;
 }


 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_profile_idc != u1_profile_idc))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_level_idc != u1_level_idc))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

    ps_seq->u1_profile_idc = u1_profile_idc;
    ps_seq->u1_level_idc = u1_level_idc;
    ps_seq->u1_seq_parameter_set_id = u1_seq_parameter_set_id;

 /*******************************************************************/
 /* Initializations for high profile - Sushant                      */
 /*******************************************************************/
    ps_seq->i4_chroma_format_idc = 1;
    ps_seq->i4_bit_depth_luma_minus8 = 0;
    ps_seq->i4_bit_depth_chroma_minus8 = 0;
    ps_seq->i4_qpprime_y_zero_transform_bypass_flag = 0;
    ps_seq->i4_seq_scaling_matrix_present_flag = 0;
 if(u1_profile_idc == HIGH_PROFILE_IDC)
 {

 /* reading chroma_format_idc   */
        ps_seq->i4_chroma_format_idc = ih264d_uev(pu4_bitstrm_ofst,
                                                  pu4_bitstrm_buf);

 /* Monochrome is not supported */
 if(ps_seq->i4_chroma_format_idc != 1)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading bit_depth_luma_minus8   */
        ps_seq->i4_bit_depth_luma_minus8 = ih264d_uev(pu4_bitstrm_ofst,
                                                      pu4_bitstrm_buf);

 if(ps_seq->i4_bit_depth_luma_minus8 != 0)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading bit_depth_chroma_minus8   */
        ps_seq->i4_bit_depth_chroma_minus8 = ih264d_uev(pu4_bitstrm_ofst,
                                                        pu4_bitstrm_buf);

 if(ps_seq->i4_bit_depth_chroma_minus8 != 0)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading qpprime_y_zero_transform_bypass_flag   */
        ps_seq->i4_qpprime_y_zero_transform_bypass_flag =
 (WORD32)ih264d_get_bit_h264(ps_bitstrm);

 if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading seq_scaling_matrix_present_flag   */
        ps_seq->i4_seq_scaling_matrix_present_flag =
 (WORD32)ih264d_get_bit_h264(ps_bitstrm);

 if(ps_seq->i4_seq_scaling_matrix_present_flag)
 {
 for(i4_i = 0; i4_i < 8; i4_i++)
 {
                ps_seq->u1_seq_scaling_list_present_flag[i4_i] =
                                ih264d_get_bit_h264(ps_bitstrm);

 /* initialize u1_use_default_scaling_matrix_flag[i4_i] to zero */
 /* before calling scaling list                             */
                ps_seq->u1_use_default_scaling_matrix_flag[i4_i] = 0;

 if(ps_seq->u1_seq_scaling_list_present_flag[i4_i])
 {
 if(i4_i < 6)
 {
                        ih264d_scaling_list(
                                        ps_seq->i2_scalinglist4x4[i4_i],
 16,
 &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                        ps_bitstrm);
 }
 else
 {
                        ih264d_scaling_list(
                                        ps_seq->i2_scalinglist8x8[i4_i - 6],
 64,
 &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                        ps_bitstrm);
 }
 }
 }
 }
 }
 /*--------------------------------------------------------------------*/
 /* Decode MaxFrameNum                                                 */
 /*--------------------------------------------------------------------*/
    u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > MAX_BITS_IN_FRAME_NUM)
 {
 return ERROR_INV_SPS_PPS_T;
 }
    ps_seq->u1_bits_in_frm_num = u4_temp;
    COPYTHECONTEXT(""SPS: log2_max_frame_num_minus4"",
 (ps_seq->u1_bits_in_frm_num - 4));

    i2_max_frm_num = (1 << (ps_seq->u1_bits_in_frm_num));
    ps_seq->u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1;
 /*--------------------------------------------------------------------*/
 /* Decode picture order count and related values                      */
 /*--------------------------------------------------------------------*/
    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

 if(u4_temp > MAX_PIC_ORDER_CNT_TYPE)
 {
 return ERROR_INV_POC_TYPE_T;
 }
    ps_seq->u1_pic_order_cnt_type = u4_temp;
    COPYTHECONTEXT(""SPS: pic_order_cnt_type"",ps_seq->u1_pic_order_cnt_type);

    ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = 1;
 if(ps_seq->u1_pic_order_cnt_type == 0)
 {
        u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > MAX_BITS_IN_POC_LSB)
 {
 return ERROR_INV_SPS_PPS_T;
 }
        ps_seq->u1_log2_max_pic_order_cnt_lsb_minus = u4_temp;
        ps_seq->i4_max_pic_order_cntLsb = (1 << u4_temp);
        COPYTHECONTEXT(""SPS: log2_max_pic_order_cnt_lsb_minus4"",(u4_temp - 4));
 }
 else if(ps_seq->u1_pic_order_cnt_type == 1)
 {
        ps_seq->u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264(
                        ps_bitstrm);
        COPYTHECONTEXT(""SPS: delta_pic_order_always_zero_flag"",
                        ps_seq->u1_delta_pic_order_always_zero_flag);

        ps_seq->i4_ofst_for_non_ref_pic = ih264d_sev(pu4_bitstrm_ofst,
                                                     pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: offset_for_non_ref_pic"",
                        ps_seq->i4_ofst_for_non_ref_pic);

        ps_seq->i4_ofst_for_top_to_bottom_field = ih264d_sev(
                        pu4_bitstrm_ofst, pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: offset_for_top_to_bottom_field"",
                        ps_seq->i4_ofst_for_top_to_bottom_field);

        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > 255)
 return ERROR_INV_SPS_PPS_T;
        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp;
        COPYTHECONTEXT(""SPS: num_ref_frames_in_pic_order_cnt_cycle"",
                        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle);

 for(i = 0; i < ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle; i++)
 {
            ps_seq->i4_ofst_for_ref_frame[i] = ih264d_sev(
                            pu4_bitstrm_ofst, pu4_bitstrm_buf);
            COPYTHECONTEXT(""SPS: offset_for_ref_frame"",
                            ps_seq->i4_ofst_for_ref_frame[i]);
 }
 }

    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

 if((u4_temp > H264_MAX_REF_PICS))
 {
 return ERROR_NUM_REF;
 }

 /* Compare with older num_ref_frames is header is already once */
 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_num_ref_frames != u4_temp))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

    ps_seq->u1_num_ref_frames = u4_temp;
    COPYTHECONTEXT(""SPS: num_ref_frames"",ps_seq->u1_num_ref_frames);

    ps_seq->u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264(
                    ps_bitstrm);
    COPYTHECONTEXT(""SPS: gaps_in_frame_num_value_allowed_flag"",
                    ps_seq->u1_gaps_in_frame_num_value_allowed_flag);

 /*--------------------------------------------------------------------*/
 /* Decode FrameWidth and FrameHeight and related values               */
 /*--------------------------------------------------------------------*/
    ps_seq->u2_frm_wd_in_mbs = 1
 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
    COPYTHECONTEXT(""SPS: pic_width_in_mbs_minus1"",
                    ps_seq->u2_frm_wd_in_mbs - 1);
    u2_pic_wd = (ps_seq->u2_frm_wd_in_mbs << 4);

    pic_height_in_map_units_minus1 = ih264d_uev(pu4_bitstrm_ofst,
                                                pu4_bitstrm_buf);
    ps_seq->u2_frm_ht_in_mbs = 1 + pic_height_in_map_units_minus1;

    u2_pic_ht = (ps_seq->u2_frm_ht_in_mbs << 4);

 /*--------------------------------------------------------------------*/
 /* Get the value of MaxMbAddress and Number of bits needed for it     */
 /*--------------------------------------------------------------------*/
    ps_seq->u2_max_mb_addr = (ps_seq->u2_frm_wd_in_mbs
 * ps_seq->u2_frm_ht_in_mbs) - 1;

    ps_seq->u2_total_num_of_mbs = ps_seq->u2_max_mb_addr + 1;

    ps_seq->u1_level_idc = ih264d_correct_level_idc(
                    u1_level_idc, ps_seq->u2_total_num_of_mbs);

    u1_frm = ih264d_get_bit_h264(ps_bitstrm);
 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_frame_mbs_only_flag != u1_frm))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

    ps_seq->u1_frame_mbs_only_flag = u1_frm;


     COPYTHECONTEXT(""SPS: frame_mbs_only_flag"", u1_frm);
 
     if(!u1_frm)
        u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);

    if((ps_dec->i4_header_decoded & 1)
                    && (ps_seq->u1_mb_aff_flag != u1_mb_aff_flag))
    {
        ps_dec->u1_res_changed = 1;
        return IVD_RES_CHANGED;
    }

    if(!u1_frm)
     {
         u2_pic_ht <<= 1;
        ps_seq->u1_mb_aff_flag = u1_mb_aff_flag;
         COPYTHECONTEXT(""SPS: mb_adaptive_frame_field_flag"",
                         ps_seq->u1_mb_aff_flag);
 
 }
 else
        ps_seq->u1_mb_aff_flag = 0;

    ps_seq->u1_direct_8x8_inference_flag = ih264d_get_bit_h264(ps_bitstrm);

    COPYTHECONTEXT(""SPS: direct_8x8_inference_flag"",
                    ps_seq->u1_direct_8x8_inference_flag);

 /* G050 */
    u1_frame_cropping_flag = ih264d_get_bit_h264(ps_bitstrm);
    COPYTHECONTEXT(""SPS: frame_cropping_flag"",u1_frame_cropping_flag);

 if(u1_frame_cropping_flag)
 {
        u1_frame_cropping_rect_left_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                      pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_left_offset"",
                        u1_frame_cropping_rect_left_ofst);
        u1_frame_cropping_rect_right_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                       pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_right_offset"",
                        u1_frame_cropping_rect_right_ofst);
        u1_frame_cropping_rect_top_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                     pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_top_offset"",
                        u1_frame_cropping_rect_top_ofst);
        u1_frame_cropping_rect_bottom_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                        pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_bottom_offset"",
                        u1_frame_cropping_rect_bottom_ofst);
 }
 /* G050 */

    ps_seq->u1_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm);
    COPYTHECONTEXT(""SPS: vui_parameters_present_flag"",
                    ps_seq->u1_vui_parameters_present_flag);

    u2_frm_wd_y = u2_pic_wd + (UWORD8)(PAD_LEN_Y_H << 1);
 if(1 == ps_dec->u4_share_disp_buf)
 {
 if(ps_dec->u4_app_disp_width > u2_frm_wd_y)
            u2_frm_wd_y = ps_dec->u4_app_disp_width;
 }

    u2_frm_ht_y = u2_pic_ht + (UWORD8)(PAD_LEN_Y_V << 2);
    u2_frm_wd_uv = u2_pic_wd + (UWORD8)(PAD_LEN_UV_H << 2);
    u2_frm_wd_uv = MAX(u2_frm_wd_uv, u2_frm_wd_y);

    u2_frm_ht_uv = (u2_pic_ht >> 1) + (UWORD8)(PAD_LEN_UV_V << 2);
    u2_frm_ht_uv = MAX(u2_frm_ht_uv, (u2_frm_ht_y >> 1));


 /* Calculate display picture width, height and start u4_ofst from YUV420 */
 /* pictute buffers as per cropping information parsed above             */
 {
        UWORD16 u2_rgt_ofst = 0;
        UWORD16 u2_lft_ofst = 0;
        UWORD16 u2_top_ofst = 0;
        UWORD16 u2_btm_ofst = 0;
        UWORD8 u1_frm_mbs_flag;
        UWORD8 u1_vert_mult_factor;

 if(u1_frame_cropping_flag)
 {
 /* Calculate right and left u4_ofst for cropped picture           */
            u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1;
            u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1;

 /* Know frame MBs only u4_flag                                      */
            u1_frm_mbs_flag = (1 == ps_seq->u1_frame_mbs_only_flag);

 /* Simplify the vertical u4_ofst calculation from field/frame     */
            u1_vert_mult_factor = (2 - u1_frm_mbs_flag);

 /* Calculate bottom and top u4_ofst for cropped  picture          */
            u2_btm_ofst = (u1_frame_cropping_rect_bottom_ofst
 << u1_vert_mult_factor);
            u2_top_ofst = (u1_frame_cropping_rect_top_ofst
 << u1_vert_mult_factor);
 }

 /* Calculate u4_ofst from start of YUV 420 picture buffer to start of*/
 /* cropped picture buffer                                           */
        u2_crop_offset_y = (u2_frm_wd_y * u2_top_ofst) + (u2_lft_ofst);
        u2_crop_offset_uv = (u2_frm_wd_uv * (u2_top_ofst >> 1))
 + (u2_lft_ofst >> 1) * YUV420SP_FACTOR;
 /* Calculate the display picture width and height based on crop      */
 /* information                                                       */
        i4_cropped_ht = u2_pic_ht - (u2_btm_ofst + u2_top_ofst);
        i4_cropped_wd = u2_pic_wd - (u2_rgt_ofst + u2_lft_ofst);

 if((i4_cropped_ht < MB_SIZE) || (i4_cropped_wd < MB_SIZE))
 {
 return ERROR_INV_SPS_PPS_T;
 }

 if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_wd != u2_pic_wd))
 {
            ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }
 if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_ht != u2_pic_ht))
 {
            ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

 /* Check for unsupported resolutions */
 if((u2_pic_wd > H264_MAX_FRAME_WIDTH) || (u2_pic_ht > H264_MAX_FRAME_HEIGHT)
 || (u2_pic_wd < H264_MIN_FRAME_WIDTH) || (u2_pic_ht < H264_MIN_FRAME_HEIGHT)
 || (u2_pic_wd * (UWORD32)u2_pic_ht > H264_MAX_FRAME_SIZE))
 {
 return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
 }

 /* If MBAff is enabled, decoder support is limited to streams with
         * width less than half of H264_MAX_FRAME_WIDTH.
         * In case of MBAff decoder processes two rows at a time
         */
 if((u2_pic_wd << ps_seq->u1_mb_aff_flag) > H264_MAX_FRAME_WIDTH)
 {
 return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
 }

 }

 /* Backup u4_num_reorder_frames if header is already decoded */
 if((ps_dec->i4_header_decoded & 1) &&
 (1 == ps_seq->u1_vui_parameters_present_flag) &&
 (1 == ps_seq->s_vui.u1_bitstream_restriction_flag))
 {
        u4_num_reorder_frames =  ps_seq->s_vui.u4_num_reorder_frames;
 }
 else
 {
        u4_num_reorder_frames = -1;
 }
 if(1 == ps_seq->u1_vui_parameters_present_flag)
 {
        ret = ih264d_parse_vui_parametres(&ps_seq->s_vui, ps_bitstrm);
 if(ret != OK)
 return ret;
 }

 /* Compare older u4_num_reorder_frames with the new one if header is already decoded */
 if((ps_dec->i4_header_decoded & 1) &&
 (-1 != (WORD32)u4_num_reorder_frames) &&
 (1 == ps_seq->u1_vui_parameters_present_flag) &&
 (1 == ps_seq->s_vui.u1_bitstream_restriction_flag) &&
 (ps_seq->s_vui.u4_num_reorder_frames != u4_num_reorder_frames))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

 /* In case bitstream read has exceeded the filled size, then
     return an error */
 if (ps_bitstrm->u4_ofst > ps_bitstrm->u4_max_ofst)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /*--------------------------------------------------------------------*/
 /* All initializations to ps_dec are beyond this point                */
 /*--------------------------------------------------------------------*/
    ps_dec->u2_disp_height = i4_cropped_ht;
    ps_dec->u2_disp_width = i4_cropped_wd;

    ps_dec->u2_pic_wd = u2_pic_wd;
    ps_dec->u2_pic_ht = u2_pic_ht;

 /* Determining the Width and Height of Frame from that of Picture */
    ps_dec->u2_frm_wd_y = u2_frm_wd_y;
    ps_dec->u2_frm_ht_y = u2_frm_ht_y;

    ps_dec->u2_frm_wd_uv = u2_frm_wd_uv;
    ps_dec->u2_frm_ht_uv = u2_frm_ht_uv;
    ps_dec->s_pad_mgr.u1_pad_len_y_v = (UWORD8)(PAD_LEN_Y_V << (1 - u1_frm));
    ps_dec->s_pad_mgr.u1_pad_len_cr_v = (UWORD8)(PAD_LEN_UV_V << (1 - u1_frm));

    ps_dec->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
    ps_dec->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs;

    ps_dec->u2_crop_offset_y = u2_crop_offset_y;
    ps_dec->u2_crop_offset_uv = u2_crop_offset_uv;

    ps_seq->u1_is_valid = TRUE;
    ps_dec->ps_sps[u1_seq_parameter_set_id] = *ps_seq;
    ps_dec->ps_cur_sps = &ps_dec->ps_sps[u1_seq_parameter_set_id];

 return OK;
}
","WORD32 ih264d_parse_sps(dec_struct_t *ps_dec, dec_bit_stream_t *ps_bitstrm)

 {
     UWORD8 i;
     dec_seq_params_t *ps_seq = NULL;
    UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id;
     UWORD16 i2_max_frm_num;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
    UWORD8 u1_frm, uc_constraint_set0_flag, uc_constraint_set1_flag;
    WORD32 i4_cropped_ht, i4_cropped_wd;
    UWORD32 u4_temp;
    WORD32 pic_height_in_map_units_minus1 = 0;
    UWORD32 u2_pic_wd = 0;
    UWORD32 u2_pic_ht = 0;
    UWORD32 u2_frm_wd_y = 0;
    UWORD32 u2_frm_ht_y = 0;
    UWORD32 u2_frm_wd_uv = 0;
    UWORD32 u2_frm_ht_uv = 0;
    UWORD32 u2_crop_offset_y = 0;
    UWORD32 u2_crop_offset_uv = 0;
    WORD32 ret;
    UWORD32 u4_num_reorder_frames;
 /* High profile related syntax element */
    WORD32 i4_i;
 /* G050 */
    UWORD8 u1_frame_cropping_flag, u1_frame_cropping_rect_left_ofst,
                    u1_frame_cropping_rect_right_ofst,
                    u1_frame_cropping_rect_top_ofst,
                    u1_frame_cropping_rect_bottom_ofst;
 /* G050 */
 /*--------------------------------------------------------------------*/
 /* Decode seq_parameter_set_id and profile and level values           */
 /*--------------------------------------------------------------------*/
    SWITCHONTRACE;
    u1_profile_idc = ih264d_get_bits_h264(ps_bitstrm, 8);
    COPYTHECONTEXT(""SPS: profile_idc"",u1_profile_idc);

 /* G050 */
    uc_constraint_set0_flag = ih264d_get_bit_h264(ps_bitstrm);
    uc_constraint_set1_flag = ih264d_get_bit_h264(ps_bitstrm);
    ih264d_get_bit_h264(ps_bitstrm);

 /*****************************************************/
 /* Read 5 bits for uc_constraint_set3_flag (1 bit)   */
 /* and reserved_zero_4bits (4 bits) - Sushant        */
 /*****************************************************/
    ih264d_get_bits_h264(ps_bitstrm, 5);
 /* G050 */

 /* Check whether particular profile is suported or not */
 /* Check whether particular profile is suported or not */
 if((u1_profile_idc != MAIN_PROFILE_IDC) &&

 (u1_profile_idc != BASE_PROFILE_IDC) &&

 (u1_profile_idc != HIGH_PROFILE_IDC)

 )
 {

 /* Apart from Baseline, main and high profile,
         * only extended profile is supported provided
         * uc_constraint_set0_flag or uc_constraint_set1_flag are set to 1
         */
 if((u1_profile_idc != EXTENDED_PROFILE_IDC) ||
 ((uc_constraint_set1_flag != 1) && (uc_constraint_set0_flag != 1)))
 {
 return (ERROR_FEATURE_UNAVAIL);
 }
 }

    u1_level_idc = ih264d_get_bits_h264(ps_bitstrm, 8);



    COPYTHECONTEXT(""SPS: u4_level_idc"",u1_level_idc);

    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp & MASK_ERR_SEQ_SET_ID)
 return ERROR_INV_SPS_PPS_T;
    u1_seq_parameter_set_id = u4_temp;
    COPYTHECONTEXT(""SPS: seq_parameter_set_id"",
                    u1_seq_parameter_set_id);

 /*--------------------------------------------------------------------*/
 /* Find an seq param entry in seqparam array of decStruct             */
 /*--------------------------------------------------------------------*/

    ps_seq = ps_dec->pv_scratch_sps_pps;
 if(ps_dec->i4_header_decoded & 1)
 {
 *ps_seq = *ps_dec->ps_cur_sps;
 }


 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_profile_idc != u1_profile_idc))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_level_idc != u1_level_idc))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

    ps_seq->u1_profile_idc = u1_profile_idc;
    ps_seq->u1_level_idc = u1_level_idc;
    ps_seq->u1_seq_parameter_set_id = u1_seq_parameter_set_id;

 /*******************************************************************/
 /* Initializations for high profile - Sushant                      */
 /*******************************************************************/
    ps_seq->i4_chroma_format_idc = 1;
    ps_seq->i4_bit_depth_luma_minus8 = 0;
    ps_seq->i4_bit_depth_chroma_minus8 = 0;
    ps_seq->i4_qpprime_y_zero_transform_bypass_flag = 0;
    ps_seq->i4_seq_scaling_matrix_present_flag = 0;
 if(u1_profile_idc == HIGH_PROFILE_IDC)
 {

 /* reading chroma_format_idc   */
        ps_seq->i4_chroma_format_idc = ih264d_uev(pu4_bitstrm_ofst,
                                                  pu4_bitstrm_buf);

 /* Monochrome is not supported */
 if(ps_seq->i4_chroma_format_idc != 1)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading bit_depth_luma_minus8   */
        ps_seq->i4_bit_depth_luma_minus8 = ih264d_uev(pu4_bitstrm_ofst,
                                                      pu4_bitstrm_buf);

 if(ps_seq->i4_bit_depth_luma_minus8 != 0)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading bit_depth_chroma_minus8   */
        ps_seq->i4_bit_depth_chroma_minus8 = ih264d_uev(pu4_bitstrm_ofst,
                                                        pu4_bitstrm_buf);

 if(ps_seq->i4_bit_depth_chroma_minus8 != 0)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading qpprime_y_zero_transform_bypass_flag   */
        ps_seq->i4_qpprime_y_zero_transform_bypass_flag =
 (WORD32)ih264d_get_bit_h264(ps_bitstrm);

 if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading seq_scaling_matrix_present_flag   */
        ps_seq->i4_seq_scaling_matrix_present_flag =
 (WORD32)ih264d_get_bit_h264(ps_bitstrm);

 if(ps_seq->i4_seq_scaling_matrix_present_flag)
 {
 for(i4_i = 0; i4_i < 8; i4_i++)
 {
                ps_seq->u1_seq_scaling_list_present_flag[i4_i] =
                                ih264d_get_bit_h264(ps_bitstrm);

 /* initialize u1_use_default_scaling_matrix_flag[i4_i] to zero */
 /* before calling scaling list                             */
                ps_seq->u1_use_default_scaling_matrix_flag[i4_i] = 0;

 if(ps_seq->u1_seq_scaling_list_present_flag[i4_i])
 {
 if(i4_i < 6)
 {
                        ih264d_scaling_list(
                                        ps_seq->i2_scalinglist4x4[i4_i],
 16,
 &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                        ps_bitstrm);
 }
 else
 {
                        ih264d_scaling_list(
                                        ps_seq->i2_scalinglist8x8[i4_i - 6],
 64,
 &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                        ps_bitstrm);
 }
 }
 }
 }
 }
 /*--------------------------------------------------------------------*/
 /* Decode MaxFrameNum                                                 */
 /*--------------------------------------------------------------------*/
    u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > MAX_BITS_IN_FRAME_NUM)
 {
 return ERROR_INV_SPS_PPS_T;
 }
    ps_seq->u1_bits_in_frm_num = u4_temp;
    COPYTHECONTEXT(""SPS: log2_max_frame_num_minus4"",
 (ps_seq->u1_bits_in_frm_num - 4));

    i2_max_frm_num = (1 << (ps_seq->u1_bits_in_frm_num));
    ps_seq->u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1;
 /*--------------------------------------------------------------------*/
 /* Decode picture order count and related values                      */
 /*--------------------------------------------------------------------*/
    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

 if(u4_temp > MAX_PIC_ORDER_CNT_TYPE)
 {
 return ERROR_INV_POC_TYPE_T;
 }
    ps_seq->u1_pic_order_cnt_type = u4_temp;
    COPYTHECONTEXT(""SPS: pic_order_cnt_type"",ps_seq->u1_pic_order_cnt_type);

    ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = 1;
 if(ps_seq->u1_pic_order_cnt_type == 0)
 {
        u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > MAX_BITS_IN_POC_LSB)
 {
 return ERROR_INV_SPS_PPS_T;
 }
        ps_seq->u1_log2_max_pic_order_cnt_lsb_minus = u4_temp;
        ps_seq->i4_max_pic_order_cntLsb = (1 << u4_temp);
        COPYTHECONTEXT(""SPS: log2_max_pic_order_cnt_lsb_minus4"",(u4_temp - 4));
 }
 else if(ps_seq->u1_pic_order_cnt_type == 1)
 {
        ps_seq->u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264(
                        ps_bitstrm);
        COPYTHECONTEXT(""SPS: delta_pic_order_always_zero_flag"",
                        ps_seq->u1_delta_pic_order_always_zero_flag);

        ps_seq->i4_ofst_for_non_ref_pic = ih264d_sev(pu4_bitstrm_ofst,
                                                     pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: offset_for_non_ref_pic"",
                        ps_seq->i4_ofst_for_non_ref_pic);

        ps_seq->i4_ofst_for_top_to_bottom_field = ih264d_sev(
                        pu4_bitstrm_ofst, pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: offset_for_top_to_bottom_field"",
                        ps_seq->i4_ofst_for_top_to_bottom_field);

        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > 255)
 return ERROR_INV_SPS_PPS_T;
        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp;
        COPYTHECONTEXT(""SPS: num_ref_frames_in_pic_order_cnt_cycle"",
                        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle);

 for(i = 0; i < ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle; i++)
 {
            ps_seq->i4_ofst_for_ref_frame[i] = ih264d_sev(
                            pu4_bitstrm_ofst, pu4_bitstrm_buf);
            COPYTHECONTEXT(""SPS: offset_for_ref_frame"",
                            ps_seq->i4_ofst_for_ref_frame[i]);
 }
 }

    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

 if((u4_temp > H264_MAX_REF_PICS))
 {
 return ERROR_NUM_REF;
 }

 /* Compare with older num_ref_frames is header is already once */
 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_num_ref_frames != u4_temp))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

    ps_seq->u1_num_ref_frames = u4_temp;
    COPYTHECONTEXT(""SPS: num_ref_frames"",ps_seq->u1_num_ref_frames);

    ps_seq->u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264(
                    ps_bitstrm);
    COPYTHECONTEXT(""SPS: gaps_in_frame_num_value_allowed_flag"",
                    ps_seq->u1_gaps_in_frame_num_value_allowed_flag);

 /*--------------------------------------------------------------------*/
 /* Decode FrameWidth and FrameHeight and related values               */
 /*--------------------------------------------------------------------*/
    ps_seq->u2_frm_wd_in_mbs = 1
 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
    COPYTHECONTEXT(""SPS: pic_width_in_mbs_minus1"",
                    ps_seq->u2_frm_wd_in_mbs - 1);
    u2_pic_wd = (ps_seq->u2_frm_wd_in_mbs << 4);

    pic_height_in_map_units_minus1 = ih264d_uev(pu4_bitstrm_ofst,
                                                pu4_bitstrm_buf);
    ps_seq->u2_frm_ht_in_mbs = 1 + pic_height_in_map_units_minus1;

    u2_pic_ht = (ps_seq->u2_frm_ht_in_mbs << 4);

 /*--------------------------------------------------------------------*/
 /* Get the value of MaxMbAddress and Number of bits needed for it     */
 /*--------------------------------------------------------------------*/
    ps_seq->u2_max_mb_addr = (ps_seq->u2_frm_wd_in_mbs
 * ps_seq->u2_frm_ht_in_mbs) - 1;

    ps_seq->u2_total_num_of_mbs = ps_seq->u2_max_mb_addr + 1;

    ps_seq->u1_level_idc = ih264d_correct_level_idc(
                    u1_level_idc, ps_seq->u2_total_num_of_mbs);

    u1_frm = ih264d_get_bit_h264(ps_bitstrm);
 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_frame_mbs_only_flag != u1_frm))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

    ps_seq->u1_frame_mbs_only_flag = u1_frm;


     COPYTHECONTEXT(""SPS: frame_mbs_only_flag"", u1_frm);
 
     if(!u1_frm)
     {
         u2_pic_ht <<= 1;
        ps_seq->u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT(""SPS: mb_adaptive_frame_field_flag"",
                         ps_seq->u1_mb_aff_flag);
 
 }
 else
        ps_seq->u1_mb_aff_flag = 0;

    ps_seq->u1_direct_8x8_inference_flag = ih264d_get_bit_h264(ps_bitstrm);

    COPYTHECONTEXT(""SPS: direct_8x8_inference_flag"",
                    ps_seq->u1_direct_8x8_inference_flag);

 /* G050 */
    u1_frame_cropping_flag = ih264d_get_bit_h264(ps_bitstrm);
    COPYTHECONTEXT(""SPS: frame_cropping_flag"",u1_frame_cropping_flag);

 if(u1_frame_cropping_flag)
 {
        u1_frame_cropping_rect_left_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                      pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_left_offset"",
                        u1_frame_cropping_rect_left_ofst);
        u1_frame_cropping_rect_right_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                       pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_right_offset"",
                        u1_frame_cropping_rect_right_ofst);
        u1_frame_cropping_rect_top_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                     pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_top_offset"",
                        u1_frame_cropping_rect_top_ofst);
        u1_frame_cropping_rect_bottom_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                        pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_bottom_offset"",
                        u1_frame_cropping_rect_bottom_ofst);
 }
 /* G050 */

    ps_seq->u1_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm);
    COPYTHECONTEXT(""SPS: vui_parameters_present_flag"",
                    ps_seq->u1_vui_parameters_present_flag);

    u2_frm_wd_y = u2_pic_wd + (UWORD8)(PAD_LEN_Y_H << 1);
 if(1 == ps_dec->u4_share_disp_buf)
 {
 if(ps_dec->u4_app_disp_width > u2_frm_wd_y)
            u2_frm_wd_y = ps_dec->u4_app_disp_width;
 }

    u2_frm_ht_y = u2_pic_ht + (UWORD8)(PAD_LEN_Y_V << 2);
    u2_frm_wd_uv = u2_pic_wd + (UWORD8)(PAD_LEN_UV_H << 2);
    u2_frm_wd_uv = MAX(u2_frm_wd_uv, u2_frm_wd_y);

    u2_frm_ht_uv = (u2_pic_ht >> 1) + (UWORD8)(PAD_LEN_UV_V << 2);
    u2_frm_ht_uv = MAX(u2_frm_ht_uv, (u2_frm_ht_y >> 1));


 /* Calculate display picture width, height and start u4_ofst from YUV420 */
 /* pictute buffers as per cropping information parsed above             */
 {
        UWORD16 u2_rgt_ofst = 0;
        UWORD16 u2_lft_ofst = 0;
        UWORD16 u2_top_ofst = 0;
        UWORD16 u2_btm_ofst = 0;
        UWORD8 u1_frm_mbs_flag;
        UWORD8 u1_vert_mult_factor;

 if(u1_frame_cropping_flag)
 {
 /* Calculate right and left u4_ofst for cropped picture           */
            u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1;
            u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1;

 /* Know frame MBs only u4_flag                                      */
            u1_frm_mbs_flag = (1 == ps_seq->u1_frame_mbs_only_flag);

 /* Simplify the vertical u4_ofst calculation from field/frame     */
            u1_vert_mult_factor = (2 - u1_frm_mbs_flag);

 /* Calculate bottom and top u4_ofst for cropped  picture          */
            u2_btm_ofst = (u1_frame_cropping_rect_bottom_ofst
 << u1_vert_mult_factor);
            u2_top_ofst = (u1_frame_cropping_rect_top_ofst
 << u1_vert_mult_factor);
 }

 /* Calculate u4_ofst from start of YUV 420 picture buffer to start of*/
 /* cropped picture buffer                                           */
        u2_crop_offset_y = (u2_frm_wd_y * u2_top_ofst) + (u2_lft_ofst);
        u2_crop_offset_uv = (u2_frm_wd_uv * (u2_top_ofst >> 1))
 + (u2_lft_ofst >> 1) * YUV420SP_FACTOR;
 /* Calculate the display picture width and height based on crop      */
 /* information                                                       */
        i4_cropped_ht = u2_pic_ht - (u2_btm_ofst + u2_top_ofst);
        i4_cropped_wd = u2_pic_wd - (u2_rgt_ofst + u2_lft_ofst);

 if((i4_cropped_ht < MB_SIZE) || (i4_cropped_wd < MB_SIZE))
 {
 return ERROR_INV_SPS_PPS_T;
 }

 if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_wd != u2_pic_wd))
 {
            ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }
 if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_ht != u2_pic_ht))
 {
            ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

 /* Check for unsupported resolutions */
 if((u2_pic_wd > H264_MAX_FRAME_WIDTH) || (u2_pic_ht > H264_MAX_FRAME_HEIGHT)
 || (u2_pic_wd < H264_MIN_FRAME_WIDTH) || (u2_pic_ht < H264_MIN_FRAME_HEIGHT)
 || (u2_pic_wd * (UWORD32)u2_pic_ht > H264_MAX_FRAME_SIZE))
 {
 return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
 }

 /* If MBAff is enabled, decoder support is limited to streams with
         * width less than half of H264_MAX_FRAME_WIDTH.
         * In case of MBAff decoder processes two rows at a time
         */
 if((u2_pic_wd << ps_seq->u1_mb_aff_flag) > H264_MAX_FRAME_WIDTH)
 {
 return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
 }

 }

 /* Backup u4_num_reorder_frames if header is already decoded */
 if((ps_dec->i4_header_decoded & 1) &&
 (1 == ps_seq->u1_vui_parameters_present_flag) &&
 (1 == ps_seq->s_vui.u1_bitstream_restriction_flag))
 {
        u4_num_reorder_frames =  ps_seq->s_vui.u4_num_reorder_frames;
 }
 else
 {
        u4_num_reorder_frames = -1;
 }
 if(1 == ps_seq->u1_vui_parameters_present_flag)
 {
        ret = ih264d_parse_vui_parametres(&ps_seq->s_vui, ps_bitstrm);
 if(ret != OK)
 return ret;
 }

 /* Compare older u4_num_reorder_frames with the new one if header is already decoded */
 if((ps_dec->i4_header_decoded & 1) &&
 (-1 != (WORD32)u4_num_reorder_frames) &&
 (1 == ps_seq->u1_vui_parameters_present_flag) &&
 (1 == ps_seq->s_vui.u1_bitstream_restriction_flag) &&
 (ps_seq->s_vui.u4_num_reorder_frames != u4_num_reorder_frames))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

 /* In case bitstream read has exceeded the filled size, then
     return an error */
 if (ps_bitstrm->u4_ofst > ps_bitstrm->u4_max_ofst)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /*--------------------------------------------------------------------*/
 /* All initializations to ps_dec are beyond this point                */
 /*--------------------------------------------------------------------*/
    ps_dec->u2_disp_height = i4_cropped_ht;
    ps_dec->u2_disp_width = i4_cropped_wd;

    ps_dec->u2_pic_wd = u2_pic_wd;
    ps_dec->u2_pic_ht = u2_pic_ht;

 /* Determining the Width and Height of Frame from that of Picture */
    ps_dec->u2_frm_wd_y = u2_frm_wd_y;
    ps_dec->u2_frm_ht_y = u2_frm_ht_y;

    ps_dec->u2_frm_wd_uv = u2_frm_wd_uv;
    ps_dec->u2_frm_ht_uv = u2_frm_ht_uv;
    ps_dec->s_pad_mgr.u1_pad_len_y_v = (UWORD8)(PAD_LEN_Y_V << (1 - u1_frm));
    ps_dec->s_pad_mgr.u1_pad_len_cr_v = (UWORD8)(PAD_LEN_UV_V << (1 - u1_frm));

    ps_dec->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
    ps_dec->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs;

    ps_dec->u2_crop_offset_y = u2_crop_offset_y;
    ps_dec->u2_crop_offset_uv = u2_crop_offset_uv;

    ps_seq->u1_is_valid = TRUE;
    ps_dec->ps_sps[u1_seq_parameter_set_id] = *ps_seq;
    ps_dec->ps_cur_sps = &ps_dec->ps_sps[u1_seq_parameter_set_id];

 return OK;
}
",C,"    UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id, u1_mb_aff_flag = 0;
        u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);

    if((ps_dec->i4_header_decoded & 1)
                    && (ps_seq->u1_mb_aff_flag != u1_mb_aff_flag))
    {
        ps_dec->u1_res_changed = 1;
        return IVD_RES_CHANGED;
    }

    if(!u1_frm)
        ps_seq->u1_mb_aff_flag = u1_mb_aff_flag;
","    UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id;
        ps_seq->u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);
",,"@@ -479,7 +479,7 @@

 {
     UWORD8 i;
     dec_seq_params_t *ps_seq = NULL;
-    UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id;
+    UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id, u1_mb_aff_flag = 0;
     UWORD16 i2_max_frm_num;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
@@ -802,9 +802,19 @@

     COPYTHECONTEXT(""SPS: frame_mbs_only_flag"", u1_frm);
 
     if(!u1_frm)
+        u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);
+
+    if((ps_dec->i4_header_decoded & 1)
+                    && (ps_seq->u1_mb_aff_flag != u1_mb_aff_flag))
+    {
+        ps_dec->u1_res_changed = 1;
+        return IVD_RES_CHANGED;
+    }
+
+    if(!u1_frm)
     {
         u2_pic_ht <<= 1;
-        ps_seq->u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);
+        ps_seq->u1_mb_aff_flag = u1_mb_aff_flag;
         COPYTHECONTEXT(""SPS: mb_adaptive_frame_field_flag"",
                         ps_seq->u1_mb_aff_flag);
 
",Android,https://android.googlesource.com/platform/external/libavc/+/42cf02965b11c397dd37a0063e683cef005bc0ae/,https://android.googlesource.com/platform/external/libavc/+/42cf02965b11c397dd37a0063e683cef005bc0ae%5E/,1,"WORD32 ih264d_parse_sps(dec_struct_t *ps_dec, dec_bit_stream_t *ps_bitstrm)

 {
     UWORD8 i;
     dec_seq_params_t *ps_seq = NULL;
//flaw_line_below:
    UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id;
//fix_flaw_line_below:
//    UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id, u1_mb_aff_flag = 0;
     UWORD16 i2_max_frm_num;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
    UWORD8 u1_frm, uc_constraint_set0_flag, uc_constraint_set1_flag;
    WORD32 i4_cropped_ht, i4_cropped_wd;
    UWORD32 u4_temp;
    WORD32 pic_height_in_map_units_minus1 = 0;
    UWORD32 u2_pic_wd = 0;
    UWORD32 u2_pic_ht = 0;
    UWORD32 u2_frm_wd_y = 0;
    UWORD32 u2_frm_ht_y = 0;
    UWORD32 u2_frm_wd_uv = 0;
    UWORD32 u2_frm_ht_uv = 0;
    UWORD32 u2_crop_offset_y = 0;
    UWORD32 u2_crop_offset_uv = 0;
    WORD32 ret;
    UWORD32 u4_num_reorder_frames;
 /* High profile related syntax element */
    WORD32 i4_i;
 /* G050 */
    UWORD8 u1_frame_cropping_flag, u1_frame_cropping_rect_left_ofst,
                    u1_frame_cropping_rect_right_ofst,
                    u1_frame_cropping_rect_top_ofst,
                    u1_frame_cropping_rect_bottom_ofst;
 /* G050 */
 /*--------------------------------------------------------------------*/
 /* Decode seq_parameter_set_id and profile and level values           */
 /*--------------------------------------------------------------------*/
    SWITCHONTRACE;
    u1_profile_idc = ih264d_get_bits_h264(ps_bitstrm, 8);
    COPYTHECONTEXT(""SPS: profile_idc"",u1_profile_idc);

 /* G050 */
    uc_constraint_set0_flag = ih264d_get_bit_h264(ps_bitstrm);
    uc_constraint_set1_flag = ih264d_get_bit_h264(ps_bitstrm);
    ih264d_get_bit_h264(ps_bitstrm);

 /*****************************************************/
 /* Read 5 bits for uc_constraint_set3_flag (1 bit)   */
 /* and reserved_zero_4bits (4 bits) - Sushant        */
 /*****************************************************/
    ih264d_get_bits_h264(ps_bitstrm, 5);
 /* G050 */

 /* Check whether particular profile is suported or not */
 /* Check whether particular profile is suported or not */
 if((u1_profile_idc != MAIN_PROFILE_IDC) &&

 (u1_profile_idc != BASE_PROFILE_IDC) &&

 (u1_profile_idc != HIGH_PROFILE_IDC)

 )
 {

 /* Apart from Baseline, main and high profile,
         * only extended profile is supported provided
         * uc_constraint_set0_flag or uc_constraint_set1_flag are set to 1
         */
 if((u1_profile_idc != EXTENDED_PROFILE_IDC) ||
 ((uc_constraint_set1_flag != 1) && (uc_constraint_set0_flag != 1)))
 {
 return (ERROR_FEATURE_UNAVAIL);
 }
 }

    u1_level_idc = ih264d_get_bits_h264(ps_bitstrm, 8);



    COPYTHECONTEXT(""SPS: u4_level_idc"",u1_level_idc);

    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp & MASK_ERR_SEQ_SET_ID)
 return ERROR_INV_SPS_PPS_T;
    u1_seq_parameter_set_id = u4_temp;
    COPYTHECONTEXT(""SPS: seq_parameter_set_id"",
                    u1_seq_parameter_set_id);

 /*--------------------------------------------------------------------*/
 /* Find an seq param entry in seqparam array of decStruct             */
 /*--------------------------------------------------------------------*/

    ps_seq = ps_dec->pv_scratch_sps_pps;
 if(ps_dec->i4_header_decoded & 1)
 {
 *ps_seq = *ps_dec->ps_cur_sps;
 }


 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_profile_idc != u1_profile_idc))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_level_idc != u1_level_idc))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

    ps_seq->u1_profile_idc = u1_profile_idc;
    ps_seq->u1_level_idc = u1_level_idc;
    ps_seq->u1_seq_parameter_set_id = u1_seq_parameter_set_id;

 /*******************************************************************/
 /* Initializations for high profile - Sushant                      */
 /*******************************************************************/
    ps_seq->i4_chroma_format_idc = 1;
    ps_seq->i4_bit_depth_luma_minus8 = 0;
    ps_seq->i4_bit_depth_chroma_minus8 = 0;
    ps_seq->i4_qpprime_y_zero_transform_bypass_flag = 0;
    ps_seq->i4_seq_scaling_matrix_present_flag = 0;
 if(u1_profile_idc == HIGH_PROFILE_IDC)
 {

 /* reading chroma_format_idc   */
        ps_seq->i4_chroma_format_idc = ih264d_uev(pu4_bitstrm_ofst,
                                                  pu4_bitstrm_buf);

 /* Monochrome is not supported */
 if(ps_seq->i4_chroma_format_idc != 1)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading bit_depth_luma_minus8   */
        ps_seq->i4_bit_depth_luma_minus8 = ih264d_uev(pu4_bitstrm_ofst,
                                                      pu4_bitstrm_buf);

 if(ps_seq->i4_bit_depth_luma_minus8 != 0)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading bit_depth_chroma_minus8   */
        ps_seq->i4_bit_depth_chroma_minus8 = ih264d_uev(pu4_bitstrm_ofst,
                                                        pu4_bitstrm_buf);

 if(ps_seq->i4_bit_depth_chroma_minus8 != 0)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading qpprime_y_zero_transform_bypass_flag   */
        ps_seq->i4_qpprime_y_zero_transform_bypass_flag =
 (WORD32)ih264d_get_bit_h264(ps_bitstrm);

 if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading seq_scaling_matrix_present_flag   */
        ps_seq->i4_seq_scaling_matrix_present_flag =
 (WORD32)ih264d_get_bit_h264(ps_bitstrm);

 if(ps_seq->i4_seq_scaling_matrix_present_flag)
 {
 for(i4_i = 0; i4_i < 8; i4_i++)
 {
                ps_seq->u1_seq_scaling_list_present_flag[i4_i] =
                                ih264d_get_bit_h264(ps_bitstrm);

 /* initialize u1_use_default_scaling_matrix_flag[i4_i] to zero */
 /* before calling scaling list                             */
                ps_seq->u1_use_default_scaling_matrix_flag[i4_i] = 0;

 if(ps_seq->u1_seq_scaling_list_present_flag[i4_i])
 {
 if(i4_i < 6)
 {
                        ih264d_scaling_list(
                                        ps_seq->i2_scalinglist4x4[i4_i],
 16,
 &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                        ps_bitstrm);
 }
 else
 {
                        ih264d_scaling_list(
                                        ps_seq->i2_scalinglist8x8[i4_i - 6],
 64,
 &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                        ps_bitstrm);
 }
 }
 }
 }
 }
 /*--------------------------------------------------------------------*/
 /* Decode MaxFrameNum                                                 */
 /*--------------------------------------------------------------------*/
    u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > MAX_BITS_IN_FRAME_NUM)
 {
 return ERROR_INV_SPS_PPS_T;
 }
    ps_seq->u1_bits_in_frm_num = u4_temp;
    COPYTHECONTEXT(""SPS: log2_max_frame_num_minus4"",
 (ps_seq->u1_bits_in_frm_num - 4));

    i2_max_frm_num = (1 << (ps_seq->u1_bits_in_frm_num));
    ps_seq->u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1;
 /*--------------------------------------------------------------------*/
 /* Decode picture order count and related values                      */
 /*--------------------------------------------------------------------*/
    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

 if(u4_temp > MAX_PIC_ORDER_CNT_TYPE)
 {
 return ERROR_INV_POC_TYPE_T;
 }
    ps_seq->u1_pic_order_cnt_type = u4_temp;
    COPYTHECONTEXT(""SPS: pic_order_cnt_type"",ps_seq->u1_pic_order_cnt_type);

    ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = 1;
 if(ps_seq->u1_pic_order_cnt_type == 0)
 {
        u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > MAX_BITS_IN_POC_LSB)
 {
 return ERROR_INV_SPS_PPS_T;
 }
        ps_seq->u1_log2_max_pic_order_cnt_lsb_minus = u4_temp;
        ps_seq->i4_max_pic_order_cntLsb = (1 << u4_temp);
        COPYTHECONTEXT(""SPS: log2_max_pic_order_cnt_lsb_minus4"",(u4_temp - 4));
 }
 else if(ps_seq->u1_pic_order_cnt_type == 1)
 {
        ps_seq->u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264(
                        ps_bitstrm);
        COPYTHECONTEXT(""SPS: delta_pic_order_always_zero_flag"",
                        ps_seq->u1_delta_pic_order_always_zero_flag);

        ps_seq->i4_ofst_for_non_ref_pic = ih264d_sev(pu4_bitstrm_ofst,
                                                     pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: offset_for_non_ref_pic"",
                        ps_seq->i4_ofst_for_non_ref_pic);

        ps_seq->i4_ofst_for_top_to_bottom_field = ih264d_sev(
                        pu4_bitstrm_ofst, pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: offset_for_top_to_bottom_field"",
                        ps_seq->i4_ofst_for_top_to_bottom_field);

        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > 255)
 return ERROR_INV_SPS_PPS_T;
        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp;
        COPYTHECONTEXT(""SPS: num_ref_frames_in_pic_order_cnt_cycle"",
                        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle);

 for(i = 0; i < ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle; i++)
 {
            ps_seq->i4_ofst_for_ref_frame[i] = ih264d_sev(
                            pu4_bitstrm_ofst, pu4_bitstrm_buf);
            COPYTHECONTEXT(""SPS: offset_for_ref_frame"",
                            ps_seq->i4_ofst_for_ref_frame[i]);
 }
 }

    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

 if((u4_temp > H264_MAX_REF_PICS))
 {
 return ERROR_NUM_REF;
 }

 /* Compare with older num_ref_frames is header is already once */
 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_num_ref_frames != u4_temp))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

    ps_seq->u1_num_ref_frames = u4_temp;
    COPYTHECONTEXT(""SPS: num_ref_frames"",ps_seq->u1_num_ref_frames);

    ps_seq->u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264(
                    ps_bitstrm);
    COPYTHECONTEXT(""SPS: gaps_in_frame_num_value_allowed_flag"",
                    ps_seq->u1_gaps_in_frame_num_value_allowed_flag);

 /*--------------------------------------------------------------------*/
 /* Decode FrameWidth and FrameHeight and related values               */
 /*--------------------------------------------------------------------*/
    ps_seq->u2_frm_wd_in_mbs = 1
 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
    COPYTHECONTEXT(""SPS: pic_width_in_mbs_minus1"",
                    ps_seq->u2_frm_wd_in_mbs - 1);
    u2_pic_wd = (ps_seq->u2_frm_wd_in_mbs << 4);

    pic_height_in_map_units_minus1 = ih264d_uev(pu4_bitstrm_ofst,
                                                pu4_bitstrm_buf);
    ps_seq->u2_frm_ht_in_mbs = 1 + pic_height_in_map_units_minus1;

    u2_pic_ht = (ps_seq->u2_frm_ht_in_mbs << 4);

 /*--------------------------------------------------------------------*/
 /* Get the value of MaxMbAddress and Number of bits needed for it     */
 /*--------------------------------------------------------------------*/
    ps_seq->u2_max_mb_addr = (ps_seq->u2_frm_wd_in_mbs
 * ps_seq->u2_frm_ht_in_mbs) - 1;

    ps_seq->u2_total_num_of_mbs = ps_seq->u2_max_mb_addr + 1;

    ps_seq->u1_level_idc = ih264d_correct_level_idc(
                    u1_level_idc, ps_seq->u2_total_num_of_mbs);

    u1_frm = ih264d_get_bit_h264(ps_bitstrm);
 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_frame_mbs_only_flag != u1_frm))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

    ps_seq->u1_frame_mbs_only_flag = u1_frm;


     COPYTHECONTEXT(""SPS: frame_mbs_only_flag"", u1_frm);
 
     if(!u1_frm)
//fix_flaw_line_below:
//        u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if((ps_dec->i4_header_decoded & 1)
//fix_flaw_line_below:
//                    && (ps_seq->u1_mb_aff_flag != u1_mb_aff_flag))
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//        ps_dec->u1_res_changed = 1;
//fix_flaw_line_below:
//        return IVD_RES_CHANGED;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if(!u1_frm)
     {
         u2_pic_ht <<= 1;
//flaw_line_below:
        ps_seq->u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);
//fix_flaw_line_below:
//        ps_seq->u1_mb_aff_flag = u1_mb_aff_flag;
         COPYTHECONTEXT(""SPS: mb_adaptive_frame_field_flag"",
                         ps_seq->u1_mb_aff_flag);
 
 }
 else
        ps_seq->u1_mb_aff_flag = 0;

    ps_seq->u1_direct_8x8_inference_flag = ih264d_get_bit_h264(ps_bitstrm);

    COPYTHECONTEXT(""SPS: direct_8x8_inference_flag"",
                    ps_seq->u1_direct_8x8_inference_flag);

 /* G050 */
    u1_frame_cropping_flag = ih264d_get_bit_h264(ps_bitstrm);
    COPYTHECONTEXT(""SPS: frame_cropping_flag"",u1_frame_cropping_flag);

 if(u1_frame_cropping_flag)
 {
        u1_frame_cropping_rect_left_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                      pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_left_offset"",
                        u1_frame_cropping_rect_left_ofst);
        u1_frame_cropping_rect_right_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                       pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_right_offset"",
                        u1_frame_cropping_rect_right_ofst);
        u1_frame_cropping_rect_top_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                     pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_top_offset"",
                        u1_frame_cropping_rect_top_ofst);
        u1_frame_cropping_rect_bottom_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                        pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_bottom_offset"",
                        u1_frame_cropping_rect_bottom_ofst);
 }
 /* G050 */

    ps_seq->u1_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm);
    COPYTHECONTEXT(""SPS: vui_parameters_present_flag"",
                    ps_seq->u1_vui_parameters_present_flag);

    u2_frm_wd_y = u2_pic_wd + (UWORD8)(PAD_LEN_Y_H << 1);
 if(1 == ps_dec->u4_share_disp_buf)
 {
 if(ps_dec->u4_app_disp_width > u2_frm_wd_y)
            u2_frm_wd_y = ps_dec->u4_app_disp_width;
 }

    u2_frm_ht_y = u2_pic_ht + (UWORD8)(PAD_LEN_Y_V << 2);
    u2_frm_wd_uv = u2_pic_wd + (UWORD8)(PAD_LEN_UV_H << 2);
    u2_frm_wd_uv = MAX(u2_frm_wd_uv, u2_frm_wd_y);

    u2_frm_ht_uv = (u2_pic_ht >> 1) + (UWORD8)(PAD_LEN_UV_V << 2);
    u2_frm_ht_uv = MAX(u2_frm_ht_uv, (u2_frm_ht_y >> 1));


 /* Calculate display picture width, height and start u4_ofst from YUV420 */
 /* pictute buffers as per cropping information parsed above             */
 {
        UWORD16 u2_rgt_ofst = 0;
        UWORD16 u2_lft_ofst = 0;
        UWORD16 u2_top_ofst = 0;
        UWORD16 u2_btm_ofst = 0;
        UWORD8 u1_frm_mbs_flag;
        UWORD8 u1_vert_mult_factor;

 if(u1_frame_cropping_flag)
 {
 /* Calculate right and left u4_ofst for cropped picture           */
            u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1;
            u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1;

 /* Know frame MBs only u4_flag                                      */
            u1_frm_mbs_flag = (1 == ps_seq->u1_frame_mbs_only_flag);

 /* Simplify the vertical u4_ofst calculation from field/frame     */
            u1_vert_mult_factor = (2 - u1_frm_mbs_flag);

 /* Calculate bottom and top u4_ofst for cropped  picture          */
            u2_btm_ofst = (u1_frame_cropping_rect_bottom_ofst
 << u1_vert_mult_factor);
            u2_top_ofst = (u1_frame_cropping_rect_top_ofst
 << u1_vert_mult_factor);
 }

 /* Calculate u4_ofst from start of YUV 420 picture buffer to start of*/
 /* cropped picture buffer                                           */
        u2_crop_offset_y = (u2_frm_wd_y * u2_top_ofst) + (u2_lft_ofst);
        u2_crop_offset_uv = (u2_frm_wd_uv * (u2_top_ofst >> 1))
 + (u2_lft_ofst >> 1) * YUV420SP_FACTOR;
 /* Calculate the display picture width and height based on crop      */
 /* information                                                       */
        i4_cropped_ht = u2_pic_ht - (u2_btm_ofst + u2_top_ofst);
        i4_cropped_wd = u2_pic_wd - (u2_rgt_ofst + u2_lft_ofst);

 if((i4_cropped_ht < MB_SIZE) || (i4_cropped_wd < MB_SIZE))
 {
 return ERROR_INV_SPS_PPS_T;
 }

 if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_wd != u2_pic_wd))
 {
            ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }
 if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_ht != u2_pic_ht))
 {
            ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

 /* Check for unsupported resolutions */
 if((u2_pic_wd > H264_MAX_FRAME_WIDTH) || (u2_pic_ht > H264_MAX_FRAME_HEIGHT)
 || (u2_pic_wd < H264_MIN_FRAME_WIDTH) || (u2_pic_ht < H264_MIN_FRAME_HEIGHT)
 || (u2_pic_wd * (UWORD32)u2_pic_ht > H264_MAX_FRAME_SIZE))
 {
 return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
 }

 /* If MBAff is enabled, decoder support is limited to streams with
         * width less than half of H264_MAX_FRAME_WIDTH.
         * In case of MBAff decoder processes two rows at a time
         */
 if((u2_pic_wd << ps_seq->u1_mb_aff_flag) > H264_MAX_FRAME_WIDTH)
 {
 return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
 }

 }

 /* Backup u4_num_reorder_frames if header is already decoded */
 if((ps_dec->i4_header_decoded & 1) &&
 (1 == ps_seq->u1_vui_parameters_present_flag) &&
 (1 == ps_seq->s_vui.u1_bitstream_restriction_flag))
 {
        u4_num_reorder_frames =  ps_seq->s_vui.u4_num_reorder_frames;
 }
 else
 {
        u4_num_reorder_frames = -1;
 }
 if(1 == ps_seq->u1_vui_parameters_present_flag)
 {
        ret = ih264d_parse_vui_parametres(&ps_seq->s_vui, ps_bitstrm);
 if(ret != OK)
 return ret;
 }

 /* Compare older u4_num_reorder_frames with the new one if header is already decoded */
 if((ps_dec->i4_header_decoded & 1) &&
 (-1 != (WORD32)u4_num_reorder_frames) &&
 (1 == ps_seq->u1_vui_parameters_present_flag) &&
 (1 == ps_seq->s_vui.u1_bitstream_restriction_flag) &&
 (ps_seq->s_vui.u4_num_reorder_frames != u4_num_reorder_frames))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

 /* In case bitstream read has exceeded the filled size, then
     return an error */
 if (ps_bitstrm->u4_ofst > ps_bitstrm->u4_max_ofst)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /*--------------------------------------------------------------------*/
 /* All initializations to ps_dec are beyond this point                */
 /*--------------------------------------------------------------------*/
    ps_dec->u2_disp_height = i4_cropped_ht;
    ps_dec->u2_disp_width = i4_cropped_wd;

    ps_dec->u2_pic_wd = u2_pic_wd;
    ps_dec->u2_pic_ht = u2_pic_ht;

 /* Determining the Width and Height of Frame from that of Picture */
    ps_dec->u2_frm_wd_y = u2_frm_wd_y;
    ps_dec->u2_frm_ht_y = u2_frm_ht_y;

    ps_dec->u2_frm_wd_uv = u2_frm_wd_uv;
    ps_dec->u2_frm_ht_uv = u2_frm_ht_uv;
    ps_dec->s_pad_mgr.u1_pad_len_y_v = (UWORD8)(PAD_LEN_Y_V << (1 - u1_frm));
    ps_dec->s_pad_mgr.u1_pad_len_cr_v = (UWORD8)(PAD_LEN_UV_V << (1 - u1_frm));

    ps_dec->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
    ps_dec->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs;

    ps_dec->u2_crop_offset_y = u2_crop_offset_y;
    ps_dec->u2_crop_offset_uv = u2_crop_offset_uv;

    ps_seq->u1_is_valid = TRUE;
    ps_dec->ps_sps[u1_seq_parameter_set_id] = *ps_seq;
    ps_dec->ps_cur_sps = &ps_dec->ps_sps[u1_seq_parameter_set_id];

 return OK;
}
",188127,"WORD32 ih264d_parse_sps(dec_struct_t *ps_dec, dec_bit_stream_t *ps_bitstrm)

 {
     UWORD8 i;
     dec_seq_params_t *ps_seq = NULL;
    UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id;
     UWORD16 i2_max_frm_num;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
    UWORD8 u1_frm, uc_constraint_set0_flag, uc_constraint_set1_flag;
    WORD32 i4_cropped_ht, i4_cropped_wd;
    UWORD32 u4_temp;
    WORD32 pic_height_in_map_units_minus1 = 0;
    UWORD32 u2_pic_wd = 0;
    UWORD32 u2_pic_ht = 0;
    UWORD32 u2_frm_wd_y = 0;
    UWORD32 u2_frm_ht_y = 0;
    UWORD32 u2_frm_wd_uv = 0;
    UWORD32 u2_frm_ht_uv = 0;
    UWORD32 u2_crop_offset_y = 0;
    UWORD32 u2_crop_offset_uv = 0;
    WORD32 ret;
    UWORD32 u4_num_reorder_frames;
 /* High profile related syntax element */
    WORD32 i4_i;
 /* G050 */
    UWORD8 u1_frame_cropping_flag, u1_frame_cropping_rect_left_ofst,
                    u1_frame_cropping_rect_right_ofst,
                    u1_frame_cropping_rect_top_ofst,
                    u1_frame_cropping_rect_bottom_ofst;
 /* G050 */
 /*--------------------------------------------------------------------*/
 /* Decode seq_parameter_set_id and profile and level values           */
 /*--------------------------------------------------------------------*/
    SWITCHONTRACE;
    u1_profile_idc = ih264d_get_bits_h264(ps_bitstrm, 8);
    COPYTHECONTEXT(""SPS: profile_idc"",u1_profile_idc);

 /* G050 */
    uc_constraint_set0_flag = ih264d_get_bit_h264(ps_bitstrm);
    uc_constraint_set1_flag = ih264d_get_bit_h264(ps_bitstrm);
    ih264d_get_bit_h264(ps_bitstrm);

 /*****************************************************/
 /* Read 5 bits for uc_constraint_set3_flag (1 bit)   */
 /* and reserved_zero_4bits (4 bits) - Sushant        */
 /*****************************************************/
    ih264d_get_bits_h264(ps_bitstrm, 5);
 /* G050 */

 /* Check whether particular profile is suported or not */
 /* Check whether particular profile is suported or not */
 if((u1_profile_idc != MAIN_PROFILE_IDC) &&

 (u1_profile_idc != BASE_PROFILE_IDC) &&

 (u1_profile_idc != HIGH_PROFILE_IDC)

 )
 {

 /* Apart from Baseline, main and high profile,
         * only extended profile is supported provided
         * uc_constraint_set0_flag or uc_constraint_set1_flag are set to 1
         */
 if((u1_profile_idc != EXTENDED_PROFILE_IDC) ||
 ((uc_constraint_set1_flag != 1) && (uc_constraint_set0_flag != 1)))
 {
 return (ERROR_FEATURE_UNAVAIL);
 }
 }

    u1_level_idc = ih264d_get_bits_h264(ps_bitstrm, 8);



    COPYTHECONTEXT(""SPS: u4_level_idc"",u1_level_idc);

    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp & MASK_ERR_SEQ_SET_ID)
 return ERROR_INV_SPS_PPS_T;
    u1_seq_parameter_set_id = u4_temp;
    COPYTHECONTEXT(""SPS: seq_parameter_set_id"",
                    u1_seq_parameter_set_id);

 /*--------------------------------------------------------------------*/
 /* Find an seq param entry in seqparam array of decStruct             */
 /*--------------------------------------------------------------------*/

    ps_seq = ps_dec->pv_scratch_sps_pps;
 if(ps_dec->i4_header_decoded & 1)
 {
 *ps_seq = *ps_dec->ps_cur_sps;
 }


 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_profile_idc != u1_profile_idc))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_level_idc != u1_level_idc))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

    ps_seq->u1_profile_idc = u1_profile_idc;
    ps_seq->u1_level_idc = u1_level_idc;
    ps_seq->u1_seq_parameter_set_id = u1_seq_parameter_set_id;

 /*******************************************************************/
 /* Initializations for high profile - Sushant                      */
 /*******************************************************************/
    ps_seq->i4_chroma_format_idc = 1;
    ps_seq->i4_bit_depth_luma_minus8 = 0;
    ps_seq->i4_bit_depth_chroma_minus8 = 0;
    ps_seq->i4_qpprime_y_zero_transform_bypass_flag = 0;
    ps_seq->i4_seq_scaling_matrix_present_flag = 0;
 if(u1_profile_idc == HIGH_PROFILE_IDC)
 {

 /* reading chroma_format_idc   */
        ps_seq->i4_chroma_format_idc = ih264d_uev(pu4_bitstrm_ofst,
                                                  pu4_bitstrm_buf);

 /* Monochrome is not supported */
 if(ps_seq->i4_chroma_format_idc != 1)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading bit_depth_luma_minus8   */
        ps_seq->i4_bit_depth_luma_minus8 = ih264d_uev(pu4_bitstrm_ofst,
                                                      pu4_bitstrm_buf);

 if(ps_seq->i4_bit_depth_luma_minus8 != 0)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading bit_depth_chroma_minus8   */
        ps_seq->i4_bit_depth_chroma_minus8 = ih264d_uev(pu4_bitstrm_ofst,
                                                        pu4_bitstrm_buf);

 if(ps_seq->i4_bit_depth_chroma_minus8 != 0)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading qpprime_y_zero_transform_bypass_flag   */
        ps_seq->i4_qpprime_y_zero_transform_bypass_flag =
 (WORD32)ih264d_get_bit_h264(ps_bitstrm);

 if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading seq_scaling_matrix_present_flag   */
        ps_seq->i4_seq_scaling_matrix_present_flag =
 (WORD32)ih264d_get_bit_h264(ps_bitstrm);

 if(ps_seq->i4_seq_scaling_matrix_present_flag)
 {
 for(i4_i = 0; i4_i < 8; i4_i++)
 {
                ps_seq->u1_seq_scaling_list_present_flag[i4_i] =
                                ih264d_get_bit_h264(ps_bitstrm);

 /* initialize u1_use_default_scaling_matrix_flag[i4_i] to zero */
 /* before calling scaling list                             */
                ps_seq->u1_use_default_scaling_matrix_flag[i4_i] = 0;

 if(ps_seq->u1_seq_scaling_list_present_flag[i4_i])
 {
 if(i4_i < 6)
 {
                        ih264d_scaling_list(
                                        ps_seq->i2_scalinglist4x4[i4_i],
 16,
 &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                        ps_bitstrm);
 }
 else
 {
                        ih264d_scaling_list(
                                        ps_seq->i2_scalinglist8x8[i4_i - 6],
 64,
 &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                        ps_bitstrm);
 }
 }
 }
 }
 }
 /*--------------------------------------------------------------------*/
 /* Decode MaxFrameNum                                                 */
 /*--------------------------------------------------------------------*/
    u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > MAX_BITS_IN_FRAME_NUM)
 {
 return ERROR_INV_SPS_PPS_T;
 }
    ps_seq->u1_bits_in_frm_num = u4_temp;
    COPYTHECONTEXT(""SPS: log2_max_frame_num_minus4"",
 (ps_seq->u1_bits_in_frm_num - 4));

    i2_max_frm_num = (1 << (ps_seq->u1_bits_in_frm_num));
    ps_seq->u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1;
 /*--------------------------------------------------------------------*/
 /* Decode picture order count and related values                      */
 /*--------------------------------------------------------------------*/
    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

 if(u4_temp > MAX_PIC_ORDER_CNT_TYPE)
 {
 return ERROR_INV_POC_TYPE_T;
 }
    ps_seq->u1_pic_order_cnt_type = u4_temp;
    COPYTHECONTEXT(""SPS: pic_order_cnt_type"",ps_seq->u1_pic_order_cnt_type);

    ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = 1;
 if(ps_seq->u1_pic_order_cnt_type == 0)
 {
        u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > MAX_BITS_IN_POC_LSB)
 {
 return ERROR_INV_SPS_PPS_T;
 }
        ps_seq->u1_log2_max_pic_order_cnt_lsb_minus = u4_temp;
        ps_seq->i4_max_pic_order_cntLsb = (1 << u4_temp);
        COPYTHECONTEXT(""SPS: log2_max_pic_order_cnt_lsb_minus4"",(u4_temp - 4));
 }
 else if(ps_seq->u1_pic_order_cnt_type == 1)
 {
        ps_seq->u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264(
                        ps_bitstrm);
        COPYTHECONTEXT(""SPS: delta_pic_order_always_zero_flag"",
                        ps_seq->u1_delta_pic_order_always_zero_flag);

        ps_seq->i4_ofst_for_non_ref_pic = ih264d_sev(pu4_bitstrm_ofst,
                                                     pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: offset_for_non_ref_pic"",
                        ps_seq->i4_ofst_for_non_ref_pic);

        ps_seq->i4_ofst_for_top_to_bottom_field = ih264d_sev(
                        pu4_bitstrm_ofst, pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: offset_for_top_to_bottom_field"",
                        ps_seq->i4_ofst_for_top_to_bottom_field);

        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > 255)
 return ERROR_INV_SPS_PPS_T;
        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp;
        COPYTHECONTEXT(""SPS: num_ref_frames_in_pic_order_cnt_cycle"",
                        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle);

 for(i = 0; i < ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle; i++)
 {
            ps_seq->i4_ofst_for_ref_frame[i] = ih264d_sev(
                            pu4_bitstrm_ofst, pu4_bitstrm_buf);
            COPYTHECONTEXT(""SPS: offset_for_ref_frame"",
                            ps_seq->i4_ofst_for_ref_frame[i]);
 }
 }

    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

 if((u4_temp > H264_MAX_REF_PICS))
 {
 return ERROR_NUM_REF;
 }

 /* Compare with older num_ref_frames is header is already once */
 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_num_ref_frames != u4_temp))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

    ps_seq->u1_num_ref_frames = u4_temp;
    COPYTHECONTEXT(""SPS: num_ref_frames"",ps_seq->u1_num_ref_frames);

    ps_seq->u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264(
                    ps_bitstrm);
    COPYTHECONTEXT(""SPS: gaps_in_frame_num_value_allowed_flag"",
                    ps_seq->u1_gaps_in_frame_num_value_allowed_flag);

 /*--------------------------------------------------------------------*/
 /* Decode FrameWidth and FrameHeight and related values               */
 /*--------------------------------------------------------------------*/
    ps_seq->u2_frm_wd_in_mbs = 1
 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
    COPYTHECONTEXT(""SPS: pic_width_in_mbs_minus1"",
                    ps_seq->u2_frm_wd_in_mbs - 1);
    u2_pic_wd = (ps_seq->u2_frm_wd_in_mbs << 4);

    pic_height_in_map_units_minus1 = ih264d_uev(pu4_bitstrm_ofst,
                                                pu4_bitstrm_buf);
    ps_seq->u2_frm_ht_in_mbs = 1 + pic_height_in_map_units_minus1;

    u2_pic_ht = (ps_seq->u2_frm_ht_in_mbs << 4);

 /*--------------------------------------------------------------------*/
 /* Get the value of MaxMbAddress and Number of bits needed for it     */
 /*--------------------------------------------------------------------*/
    ps_seq->u2_max_mb_addr = (ps_seq->u2_frm_wd_in_mbs
 * ps_seq->u2_frm_ht_in_mbs) - 1;

    ps_seq->u2_total_num_of_mbs = ps_seq->u2_max_mb_addr + 1;

    ps_seq->u1_level_idc = ih264d_correct_level_idc(
                    u1_level_idc, ps_seq->u2_total_num_of_mbs);

    u1_frm = ih264d_get_bit_h264(ps_bitstrm);
 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_frame_mbs_only_flag != u1_frm))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

    ps_seq->u1_frame_mbs_only_flag = u1_frm;


     COPYTHECONTEXT(""SPS: frame_mbs_only_flag"", u1_frm);
 
     if(!u1_frm)
     {
         u2_pic_ht <<= 1;
        ps_seq->u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT(""SPS: mb_adaptive_frame_field_flag"",
                         ps_seq->u1_mb_aff_flag);
 
 }
 else
        ps_seq->u1_mb_aff_flag = 0;

    ps_seq->u1_direct_8x8_inference_flag = ih264d_get_bit_h264(ps_bitstrm);

    COPYTHECONTEXT(""SPS: direct_8x8_inference_flag"",
                    ps_seq->u1_direct_8x8_inference_flag);

 /* G050 */
    u1_frame_cropping_flag = ih264d_get_bit_h264(ps_bitstrm);
    COPYTHECONTEXT(""SPS: frame_cropping_flag"",u1_frame_cropping_flag);

 if(u1_frame_cropping_flag)
 {
        u1_frame_cropping_rect_left_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                      pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_left_offset"",
                        u1_frame_cropping_rect_left_ofst);
        u1_frame_cropping_rect_right_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                       pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_right_offset"",
                        u1_frame_cropping_rect_right_ofst);
        u1_frame_cropping_rect_top_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                     pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_top_offset"",
                        u1_frame_cropping_rect_top_ofst);
        u1_frame_cropping_rect_bottom_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                        pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_bottom_offset"",
                        u1_frame_cropping_rect_bottom_ofst);
 }
 /* G050 */

    ps_seq->u1_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm);
    COPYTHECONTEXT(""SPS: vui_parameters_present_flag"",
                    ps_seq->u1_vui_parameters_present_flag);

    u2_frm_wd_y = u2_pic_wd + (UWORD8)(PAD_LEN_Y_H << 1);
 if(1 == ps_dec->u4_share_disp_buf)
 {
 if(ps_dec->u4_app_disp_width > u2_frm_wd_y)
            u2_frm_wd_y = ps_dec->u4_app_disp_width;
 }

    u2_frm_ht_y = u2_pic_ht + (UWORD8)(PAD_LEN_Y_V << 2);
    u2_frm_wd_uv = u2_pic_wd + (UWORD8)(PAD_LEN_UV_H << 2);
    u2_frm_wd_uv = MAX(u2_frm_wd_uv, u2_frm_wd_y);

    u2_frm_ht_uv = (u2_pic_ht >> 1) + (UWORD8)(PAD_LEN_UV_V << 2);
    u2_frm_ht_uv = MAX(u2_frm_ht_uv, (u2_frm_ht_y >> 1));


 /* Calculate display picture width, height and start u4_ofst from YUV420 */
 /* pictute buffers as per cropping information parsed above             */
 {
        UWORD16 u2_rgt_ofst = 0;
        UWORD16 u2_lft_ofst = 0;
        UWORD16 u2_top_ofst = 0;
        UWORD16 u2_btm_ofst = 0;
        UWORD8 u1_frm_mbs_flag;
        UWORD8 u1_vert_mult_factor;

 if(u1_frame_cropping_flag)
 {
 /* Calculate right and left u4_ofst for cropped picture           */
            u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1;
            u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1;

 /* Know frame MBs only u4_flag                                      */
            u1_frm_mbs_flag = (1 == ps_seq->u1_frame_mbs_only_flag);

 /* Simplify the vertical u4_ofst calculation from field/frame     */
            u1_vert_mult_factor = (2 - u1_frm_mbs_flag);

 /* Calculate bottom and top u4_ofst for cropped  picture          */
            u2_btm_ofst = (u1_frame_cropping_rect_bottom_ofst
 << u1_vert_mult_factor);
            u2_top_ofst = (u1_frame_cropping_rect_top_ofst
 << u1_vert_mult_factor);
 }

 /* Calculate u4_ofst from start of YUV 420 picture buffer to start of*/
 /* cropped picture buffer                                           */
        u2_crop_offset_y = (u2_frm_wd_y * u2_top_ofst) + (u2_lft_ofst);
        u2_crop_offset_uv = (u2_frm_wd_uv * (u2_top_ofst >> 1))
 + (u2_lft_ofst >> 1) * YUV420SP_FACTOR;
 /* Calculate the display picture width and height based on crop      */
 /* information                                                       */
        i4_cropped_ht = u2_pic_ht - (u2_btm_ofst + u2_top_ofst);
        i4_cropped_wd = u2_pic_wd - (u2_rgt_ofst + u2_lft_ofst);

 if((i4_cropped_ht < MB_SIZE) || (i4_cropped_wd < MB_SIZE))
 {
 return ERROR_INV_SPS_PPS_T;
 }

 if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_wd != u2_pic_wd))
 {
            ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }
 if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_ht != u2_pic_ht))
 {
            ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

 /* Check for unsupported resolutions */
 if((u2_pic_wd > H264_MAX_FRAME_WIDTH) || (u2_pic_ht > H264_MAX_FRAME_HEIGHT)
 || (u2_pic_wd < H264_MIN_FRAME_WIDTH) || (u2_pic_ht < H264_MIN_FRAME_HEIGHT)
 || (u2_pic_wd * (UWORD32)u2_pic_ht > H264_MAX_FRAME_SIZE))
 {
 return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
 }

 /* If MBAff is enabled, decoder support is limited to streams with
         * width less than half of H264_MAX_FRAME_WIDTH.
         * In case of MBAff decoder processes two rows at a time
         */
 if((u2_pic_wd << ps_seq->u1_mb_aff_flag) > H264_MAX_FRAME_WIDTH)
 {
 return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
 }

 }

 /* Backup u4_num_reorder_frames if header is already decoded */
 if((ps_dec->i4_header_decoded & 1) &&
 (1 == ps_seq->u1_vui_parameters_present_flag) &&
 (1 == ps_seq->s_vui.u1_bitstream_restriction_flag))
 {
        u4_num_reorder_frames =  ps_seq->s_vui.u4_num_reorder_frames;
 }
 else
 {
        u4_num_reorder_frames = -1;
 }
 if(1 == ps_seq->u1_vui_parameters_present_flag)
 {
        ret = ih264d_parse_vui_parametres(&ps_seq->s_vui, ps_bitstrm);
 if(ret != OK)
 return ret;
 }

 /* Compare older u4_num_reorder_frames with the new one if header is already decoded */
 if((ps_dec->i4_header_decoded & 1) &&
 (-1 != (WORD32)u4_num_reorder_frames) &&
 (1 == ps_seq->u1_vui_parameters_present_flag) &&
 (1 == ps_seq->s_vui.u1_bitstream_restriction_flag) &&
 (ps_seq->s_vui.u4_num_reorder_frames != u4_num_reorder_frames))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

 /* In case bitstream read has exceeded the filled size, then
     return an error */
 if (ps_bitstrm->u4_ofst > ps_bitstrm->u4_max_ofst)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /*--------------------------------------------------------------------*/
 /* All initializations to ps_dec are beyond this point                */
 /*--------------------------------------------------------------------*/
    ps_dec->u2_disp_height = i4_cropped_ht;
    ps_dec->u2_disp_width = i4_cropped_wd;

    ps_dec->u2_pic_wd = u2_pic_wd;
    ps_dec->u2_pic_ht = u2_pic_ht;

 /* Determining the Width and Height of Frame from that of Picture */
    ps_dec->u2_frm_wd_y = u2_frm_wd_y;
    ps_dec->u2_frm_ht_y = u2_frm_ht_y;

    ps_dec->u2_frm_wd_uv = u2_frm_wd_uv;
    ps_dec->u2_frm_ht_uv = u2_frm_ht_uv;
    ps_dec->s_pad_mgr.u1_pad_len_y_v = (UWORD8)(PAD_LEN_Y_V << (1 - u1_frm));
    ps_dec->s_pad_mgr.u1_pad_len_cr_v = (UWORD8)(PAD_LEN_UV_V << (1 - u1_frm));

    ps_dec->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
    ps_dec->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs;

    ps_dec->u2_crop_offset_y = u2_crop_offset_y;
    ps_dec->u2_crop_offset_uv = u2_crop_offset_uv;

    ps_seq->u1_is_valid = TRUE;
    ps_dec->ps_sps[u1_seq_parameter_set_id] = *ps_seq;
    ps_dec->ps_cur_sps = &ps_dec->ps_sps[u1_seq_parameter_set_id];

 return OK;
}
","WORD32 ih264d_parse_sps(dec_struct_t *ps_dec, dec_bit_stream_t *ps_bitstrm)

 {
     UWORD8 i;
     dec_seq_params_t *ps_seq = NULL;
    UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id, u1_mb_aff_flag = 0;
     UWORD16 i2_max_frm_num;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
    UWORD8 u1_frm, uc_constraint_set0_flag, uc_constraint_set1_flag;
    WORD32 i4_cropped_ht, i4_cropped_wd;
    UWORD32 u4_temp;
    WORD32 pic_height_in_map_units_minus1 = 0;
    UWORD32 u2_pic_wd = 0;
    UWORD32 u2_pic_ht = 0;
    UWORD32 u2_frm_wd_y = 0;
    UWORD32 u2_frm_ht_y = 0;
    UWORD32 u2_frm_wd_uv = 0;
    UWORD32 u2_frm_ht_uv = 0;
    UWORD32 u2_crop_offset_y = 0;
    UWORD32 u2_crop_offset_uv = 0;
    WORD32 ret;
    UWORD32 u4_num_reorder_frames;
 /* High profile related syntax element */
    WORD32 i4_i;
 /* G050 */
    UWORD8 u1_frame_cropping_flag, u1_frame_cropping_rect_left_ofst,
                    u1_frame_cropping_rect_right_ofst,
                    u1_frame_cropping_rect_top_ofst,
                    u1_frame_cropping_rect_bottom_ofst;
 /* G050 */
 /*--------------------------------------------------------------------*/
 /* Decode seq_parameter_set_id and profile and level values           */
 /*--------------------------------------------------------------------*/
    SWITCHONTRACE;
    u1_profile_idc = ih264d_get_bits_h264(ps_bitstrm, 8);
    COPYTHECONTEXT(""SPS: profile_idc"",u1_profile_idc);

 /* G050 */
    uc_constraint_set0_flag = ih264d_get_bit_h264(ps_bitstrm);
    uc_constraint_set1_flag = ih264d_get_bit_h264(ps_bitstrm);
    ih264d_get_bit_h264(ps_bitstrm);

 /*****************************************************/
 /* Read 5 bits for uc_constraint_set3_flag (1 bit)   */
 /* and reserved_zero_4bits (4 bits) - Sushant        */
 /*****************************************************/
    ih264d_get_bits_h264(ps_bitstrm, 5);
 /* G050 */

 /* Check whether particular profile is suported or not */
 /* Check whether particular profile is suported or not */
 if((u1_profile_idc != MAIN_PROFILE_IDC) &&

 (u1_profile_idc != BASE_PROFILE_IDC) &&

 (u1_profile_idc != HIGH_PROFILE_IDC)

 )
 {

 /* Apart from Baseline, main and high profile,
         * only extended profile is supported provided
         * uc_constraint_set0_flag or uc_constraint_set1_flag are set to 1
         */
 if((u1_profile_idc != EXTENDED_PROFILE_IDC) ||
 ((uc_constraint_set1_flag != 1) && (uc_constraint_set0_flag != 1)))
 {
 return (ERROR_FEATURE_UNAVAIL);
 }
 }

    u1_level_idc = ih264d_get_bits_h264(ps_bitstrm, 8);



    COPYTHECONTEXT(""SPS: u4_level_idc"",u1_level_idc);

    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp & MASK_ERR_SEQ_SET_ID)
 return ERROR_INV_SPS_PPS_T;
    u1_seq_parameter_set_id = u4_temp;
    COPYTHECONTEXT(""SPS: seq_parameter_set_id"",
                    u1_seq_parameter_set_id);

 /*--------------------------------------------------------------------*/
 /* Find an seq param entry in seqparam array of decStruct             */
 /*--------------------------------------------------------------------*/

    ps_seq = ps_dec->pv_scratch_sps_pps;
 if(ps_dec->i4_header_decoded & 1)
 {
 *ps_seq = *ps_dec->ps_cur_sps;
 }


 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_profile_idc != u1_profile_idc))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_level_idc != u1_level_idc))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

    ps_seq->u1_profile_idc = u1_profile_idc;
    ps_seq->u1_level_idc = u1_level_idc;
    ps_seq->u1_seq_parameter_set_id = u1_seq_parameter_set_id;

 /*******************************************************************/
 /* Initializations for high profile - Sushant                      */
 /*******************************************************************/
    ps_seq->i4_chroma_format_idc = 1;
    ps_seq->i4_bit_depth_luma_minus8 = 0;
    ps_seq->i4_bit_depth_chroma_minus8 = 0;
    ps_seq->i4_qpprime_y_zero_transform_bypass_flag = 0;
    ps_seq->i4_seq_scaling_matrix_present_flag = 0;
 if(u1_profile_idc == HIGH_PROFILE_IDC)
 {

 /* reading chroma_format_idc   */
        ps_seq->i4_chroma_format_idc = ih264d_uev(pu4_bitstrm_ofst,
                                                  pu4_bitstrm_buf);

 /* Monochrome is not supported */
 if(ps_seq->i4_chroma_format_idc != 1)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading bit_depth_luma_minus8   */
        ps_seq->i4_bit_depth_luma_minus8 = ih264d_uev(pu4_bitstrm_ofst,
                                                      pu4_bitstrm_buf);

 if(ps_seq->i4_bit_depth_luma_minus8 != 0)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading bit_depth_chroma_minus8   */
        ps_seq->i4_bit_depth_chroma_minus8 = ih264d_uev(pu4_bitstrm_ofst,
                                                        pu4_bitstrm_buf);

 if(ps_seq->i4_bit_depth_chroma_minus8 != 0)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading qpprime_y_zero_transform_bypass_flag   */
        ps_seq->i4_qpprime_y_zero_transform_bypass_flag =
 (WORD32)ih264d_get_bit_h264(ps_bitstrm);

 if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /* reading seq_scaling_matrix_present_flag   */
        ps_seq->i4_seq_scaling_matrix_present_flag =
 (WORD32)ih264d_get_bit_h264(ps_bitstrm);

 if(ps_seq->i4_seq_scaling_matrix_present_flag)
 {
 for(i4_i = 0; i4_i < 8; i4_i++)
 {
                ps_seq->u1_seq_scaling_list_present_flag[i4_i] =
                                ih264d_get_bit_h264(ps_bitstrm);

 /* initialize u1_use_default_scaling_matrix_flag[i4_i] to zero */
 /* before calling scaling list                             */
                ps_seq->u1_use_default_scaling_matrix_flag[i4_i] = 0;

 if(ps_seq->u1_seq_scaling_list_present_flag[i4_i])
 {
 if(i4_i < 6)
 {
                        ih264d_scaling_list(
                                        ps_seq->i2_scalinglist4x4[i4_i],
 16,
 &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                        ps_bitstrm);
 }
 else
 {
                        ih264d_scaling_list(
                                        ps_seq->i2_scalinglist8x8[i4_i - 6],
 64,
 &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],
                                        ps_bitstrm);
 }
 }
 }
 }
 }
 /*--------------------------------------------------------------------*/
 /* Decode MaxFrameNum                                                 */
 /*--------------------------------------------------------------------*/
    u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > MAX_BITS_IN_FRAME_NUM)
 {
 return ERROR_INV_SPS_PPS_T;
 }
    ps_seq->u1_bits_in_frm_num = u4_temp;
    COPYTHECONTEXT(""SPS: log2_max_frame_num_minus4"",
 (ps_seq->u1_bits_in_frm_num - 4));

    i2_max_frm_num = (1 << (ps_seq->u1_bits_in_frm_num));
    ps_seq->u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1;
 /*--------------------------------------------------------------------*/
 /* Decode picture order count and related values                      */
 /*--------------------------------------------------------------------*/
    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

 if(u4_temp > MAX_PIC_ORDER_CNT_TYPE)
 {
 return ERROR_INV_POC_TYPE_T;
 }
    ps_seq->u1_pic_order_cnt_type = u4_temp;
    COPYTHECONTEXT(""SPS: pic_order_cnt_type"",ps_seq->u1_pic_order_cnt_type);

    ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = 1;
 if(ps_seq->u1_pic_order_cnt_type == 0)
 {
        u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > MAX_BITS_IN_POC_LSB)
 {
 return ERROR_INV_SPS_PPS_T;
 }
        ps_seq->u1_log2_max_pic_order_cnt_lsb_minus = u4_temp;
        ps_seq->i4_max_pic_order_cntLsb = (1 << u4_temp);
        COPYTHECONTEXT(""SPS: log2_max_pic_order_cnt_lsb_minus4"",(u4_temp - 4));
 }
 else if(ps_seq->u1_pic_order_cnt_type == 1)
 {
        ps_seq->u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264(
                        ps_bitstrm);
        COPYTHECONTEXT(""SPS: delta_pic_order_always_zero_flag"",
                        ps_seq->u1_delta_pic_order_always_zero_flag);

        ps_seq->i4_ofst_for_non_ref_pic = ih264d_sev(pu4_bitstrm_ofst,
                                                     pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: offset_for_non_ref_pic"",
                        ps_seq->i4_ofst_for_non_ref_pic);

        ps_seq->i4_ofst_for_top_to_bottom_field = ih264d_sev(
                        pu4_bitstrm_ofst, pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: offset_for_top_to_bottom_field"",
                        ps_seq->i4_ofst_for_top_to_bottom_field);

        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > 255)
 return ERROR_INV_SPS_PPS_T;
        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp;
        COPYTHECONTEXT(""SPS: num_ref_frames_in_pic_order_cnt_cycle"",
                        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle);

 for(i = 0; i < ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle; i++)
 {
            ps_seq->i4_ofst_for_ref_frame[i] = ih264d_sev(
                            pu4_bitstrm_ofst, pu4_bitstrm_buf);
            COPYTHECONTEXT(""SPS: offset_for_ref_frame"",
                            ps_seq->i4_ofst_for_ref_frame[i]);
 }
 }

    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

 if((u4_temp > H264_MAX_REF_PICS))
 {
 return ERROR_NUM_REF;
 }

 /* Compare with older num_ref_frames is header is already once */
 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_num_ref_frames != u4_temp))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

    ps_seq->u1_num_ref_frames = u4_temp;
    COPYTHECONTEXT(""SPS: num_ref_frames"",ps_seq->u1_num_ref_frames);

    ps_seq->u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264(
                    ps_bitstrm);
    COPYTHECONTEXT(""SPS: gaps_in_frame_num_value_allowed_flag"",
                    ps_seq->u1_gaps_in_frame_num_value_allowed_flag);

 /*--------------------------------------------------------------------*/
 /* Decode FrameWidth and FrameHeight and related values               */
 /*--------------------------------------------------------------------*/
    ps_seq->u2_frm_wd_in_mbs = 1
 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
    COPYTHECONTEXT(""SPS: pic_width_in_mbs_minus1"",
                    ps_seq->u2_frm_wd_in_mbs - 1);
    u2_pic_wd = (ps_seq->u2_frm_wd_in_mbs << 4);

    pic_height_in_map_units_minus1 = ih264d_uev(pu4_bitstrm_ofst,
                                                pu4_bitstrm_buf);
    ps_seq->u2_frm_ht_in_mbs = 1 + pic_height_in_map_units_minus1;

    u2_pic_ht = (ps_seq->u2_frm_ht_in_mbs << 4);

 /*--------------------------------------------------------------------*/
 /* Get the value of MaxMbAddress and Number of bits needed for it     */
 /*--------------------------------------------------------------------*/
    ps_seq->u2_max_mb_addr = (ps_seq->u2_frm_wd_in_mbs
 * ps_seq->u2_frm_ht_in_mbs) - 1;

    ps_seq->u2_total_num_of_mbs = ps_seq->u2_max_mb_addr + 1;

    ps_seq->u1_level_idc = ih264d_correct_level_idc(
                    u1_level_idc, ps_seq->u2_total_num_of_mbs);

    u1_frm = ih264d_get_bit_h264(ps_bitstrm);
 if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_frame_mbs_only_flag != u1_frm))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

    ps_seq->u1_frame_mbs_only_flag = u1_frm;


     COPYTHECONTEXT(""SPS: frame_mbs_only_flag"", u1_frm);
 
     if(!u1_frm)
        u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);

    if((ps_dec->i4_header_decoded & 1)
                    && (ps_seq->u1_mb_aff_flag != u1_mb_aff_flag))
    {
        ps_dec->u1_res_changed = 1;
        return IVD_RES_CHANGED;
    }

    if(!u1_frm)
     {
         u2_pic_ht <<= 1;
        ps_seq->u1_mb_aff_flag = u1_mb_aff_flag;
         COPYTHECONTEXT(""SPS: mb_adaptive_frame_field_flag"",
                         ps_seq->u1_mb_aff_flag);
 
 }
 else
        ps_seq->u1_mb_aff_flag = 0;

    ps_seq->u1_direct_8x8_inference_flag = ih264d_get_bit_h264(ps_bitstrm);

    COPYTHECONTEXT(""SPS: direct_8x8_inference_flag"",
                    ps_seq->u1_direct_8x8_inference_flag);

 /* G050 */
    u1_frame_cropping_flag = ih264d_get_bit_h264(ps_bitstrm);
    COPYTHECONTEXT(""SPS: frame_cropping_flag"",u1_frame_cropping_flag);

 if(u1_frame_cropping_flag)
 {
        u1_frame_cropping_rect_left_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                      pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_left_offset"",
                        u1_frame_cropping_rect_left_ofst);
        u1_frame_cropping_rect_right_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                       pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_right_offset"",
                        u1_frame_cropping_rect_right_ofst);
        u1_frame_cropping_rect_top_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                     pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_top_offset"",
                        u1_frame_cropping_rect_top_ofst);
        u1_frame_cropping_rect_bottom_ofst = ih264d_uev(pu4_bitstrm_ofst,
                                                        pu4_bitstrm_buf);
        COPYTHECONTEXT(""SPS: frame_cropping_rect_bottom_offset"",
                        u1_frame_cropping_rect_bottom_ofst);
 }
 /* G050 */

    ps_seq->u1_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm);
    COPYTHECONTEXT(""SPS: vui_parameters_present_flag"",
                    ps_seq->u1_vui_parameters_present_flag);

    u2_frm_wd_y = u2_pic_wd + (UWORD8)(PAD_LEN_Y_H << 1);
 if(1 == ps_dec->u4_share_disp_buf)
 {
 if(ps_dec->u4_app_disp_width > u2_frm_wd_y)
            u2_frm_wd_y = ps_dec->u4_app_disp_width;
 }

    u2_frm_ht_y = u2_pic_ht + (UWORD8)(PAD_LEN_Y_V << 2);
    u2_frm_wd_uv = u2_pic_wd + (UWORD8)(PAD_LEN_UV_H << 2);
    u2_frm_wd_uv = MAX(u2_frm_wd_uv, u2_frm_wd_y);

    u2_frm_ht_uv = (u2_pic_ht >> 1) + (UWORD8)(PAD_LEN_UV_V << 2);
    u2_frm_ht_uv = MAX(u2_frm_ht_uv, (u2_frm_ht_y >> 1));


 /* Calculate display picture width, height and start u4_ofst from YUV420 */
 /* pictute buffers as per cropping information parsed above             */
 {
        UWORD16 u2_rgt_ofst = 0;
        UWORD16 u2_lft_ofst = 0;
        UWORD16 u2_top_ofst = 0;
        UWORD16 u2_btm_ofst = 0;
        UWORD8 u1_frm_mbs_flag;
        UWORD8 u1_vert_mult_factor;

 if(u1_frame_cropping_flag)
 {
 /* Calculate right and left u4_ofst for cropped picture           */
            u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1;
            u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1;

 /* Know frame MBs only u4_flag                                      */
            u1_frm_mbs_flag = (1 == ps_seq->u1_frame_mbs_only_flag);

 /* Simplify the vertical u4_ofst calculation from field/frame     */
            u1_vert_mult_factor = (2 - u1_frm_mbs_flag);

 /* Calculate bottom and top u4_ofst for cropped  picture          */
            u2_btm_ofst = (u1_frame_cropping_rect_bottom_ofst
 << u1_vert_mult_factor);
            u2_top_ofst = (u1_frame_cropping_rect_top_ofst
 << u1_vert_mult_factor);
 }

 /* Calculate u4_ofst from start of YUV 420 picture buffer to start of*/
 /* cropped picture buffer                                           */
        u2_crop_offset_y = (u2_frm_wd_y * u2_top_ofst) + (u2_lft_ofst);
        u2_crop_offset_uv = (u2_frm_wd_uv * (u2_top_ofst >> 1))
 + (u2_lft_ofst >> 1) * YUV420SP_FACTOR;
 /* Calculate the display picture width and height based on crop      */
 /* information                                                       */
        i4_cropped_ht = u2_pic_ht - (u2_btm_ofst + u2_top_ofst);
        i4_cropped_wd = u2_pic_wd - (u2_rgt_ofst + u2_lft_ofst);

 if((i4_cropped_ht < MB_SIZE) || (i4_cropped_wd < MB_SIZE))
 {
 return ERROR_INV_SPS_PPS_T;
 }

 if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_wd != u2_pic_wd))
 {
            ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }
 if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_ht != u2_pic_ht))
 {
            ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

 /* Check for unsupported resolutions */
 if((u2_pic_wd > H264_MAX_FRAME_WIDTH) || (u2_pic_ht > H264_MAX_FRAME_HEIGHT)
 || (u2_pic_wd < H264_MIN_FRAME_WIDTH) || (u2_pic_ht < H264_MIN_FRAME_HEIGHT)
 || (u2_pic_wd * (UWORD32)u2_pic_ht > H264_MAX_FRAME_SIZE))
 {
 return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
 }

 /* If MBAff is enabled, decoder support is limited to streams with
         * width less than half of H264_MAX_FRAME_WIDTH.
         * In case of MBAff decoder processes two rows at a time
         */
 if((u2_pic_wd << ps_seq->u1_mb_aff_flag) > H264_MAX_FRAME_WIDTH)
 {
 return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;
 }

 }

 /* Backup u4_num_reorder_frames if header is already decoded */
 if((ps_dec->i4_header_decoded & 1) &&
 (1 == ps_seq->u1_vui_parameters_present_flag) &&
 (1 == ps_seq->s_vui.u1_bitstream_restriction_flag))
 {
        u4_num_reorder_frames =  ps_seq->s_vui.u4_num_reorder_frames;
 }
 else
 {
        u4_num_reorder_frames = -1;
 }
 if(1 == ps_seq->u1_vui_parameters_present_flag)
 {
        ret = ih264d_parse_vui_parametres(&ps_seq->s_vui, ps_bitstrm);
 if(ret != OK)
 return ret;
 }

 /* Compare older u4_num_reorder_frames with the new one if header is already decoded */
 if((ps_dec->i4_header_decoded & 1) &&
 (-1 != (WORD32)u4_num_reorder_frames) &&
 (1 == ps_seq->u1_vui_parameters_present_flag) &&
 (1 == ps_seq->s_vui.u1_bitstream_restriction_flag) &&
 (ps_seq->s_vui.u4_num_reorder_frames != u4_num_reorder_frames))
 {
        ps_dec->u1_res_changed = 1;
 return IVD_RES_CHANGED;
 }

 /* In case bitstream read has exceeded the filled size, then
     return an error */
 if (ps_bitstrm->u4_ofst > ps_bitstrm->u4_max_ofst)
 {
 return ERROR_INV_SPS_PPS_T;
 }

 /*--------------------------------------------------------------------*/
 /* All initializations to ps_dec are beyond this point                */
 /*--------------------------------------------------------------------*/
    ps_dec->u2_disp_height = i4_cropped_ht;
    ps_dec->u2_disp_width = i4_cropped_wd;

    ps_dec->u2_pic_wd = u2_pic_wd;
    ps_dec->u2_pic_ht = u2_pic_ht;

 /* Determining the Width and Height of Frame from that of Picture */
    ps_dec->u2_frm_wd_y = u2_frm_wd_y;
    ps_dec->u2_frm_ht_y = u2_frm_ht_y;

    ps_dec->u2_frm_wd_uv = u2_frm_wd_uv;
    ps_dec->u2_frm_ht_uv = u2_frm_ht_uv;
    ps_dec->s_pad_mgr.u1_pad_len_y_v = (UWORD8)(PAD_LEN_Y_V << (1 - u1_frm));
    ps_dec->s_pad_mgr.u1_pad_len_cr_v = (UWORD8)(PAD_LEN_UV_V << (1 - u1_frm));

    ps_dec->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
    ps_dec->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs;

    ps_dec->u2_crop_offset_y = u2_crop_offset_y;
    ps_dec->u2_crop_offset_uv = u2_crop_offset_uv;

    ps_seq->u1_is_valid = TRUE;
    ps_dec->ps_sps[u1_seq_parameter_set_id] = *ps_seq;
    ps_dec->ps_cur_sps = &ps_dec->ps_sps[u1_seq_parameter_set_id];

 return OK;
}
","The function `ih264d_parse_sps` is designed to parse the Sequence Parameter Set (SPS) from a bitstream in H.264 video decoding. It retrieves various parameters such as profile ID, level ID, and sequence parameter set ID, while also validating the profile against supported types. The function initializes several attributes related to frame dimensions, cropping, and reference frames, ensuring that the parsed values adhere to specified constraints. Additionally, it handles potential changes in resolution and updates the decoder's state accordingly. Ultimately, it populates the decoder's structure with the parsed SPS data and returns a status code indicating success or error.","The provided code is responsible for parsing the Sequence Parameter Set from a video bitstream in H.264 decoding. It extracts essential parameters such as profile and level identifiers, checks their validity against supported profiles, and initializes various attributes related to frame dimensions and cropping. The code also manages reference frame counts and ensures that the parsed values conform to specific constraints. Additionally, it updates the decoder's state to reflect any changes in resolution or configuration, ultimately populating the decoder's structure with the necessary information for further processing of the video stream.","The vulnerability in the original code stemmed from the lack of proper handling for the macroblock adaptive frame field (MBAFF) flag, which could lead to incorrect processing of video streams when the flag changed. Specifically, the absence of a dedicated variable to track the MBAFF state meant that changes in this flag were not detected, potentially causing inconsistencies in the decoder's behavior. The fixed code introduced a new variable to explicitly store the MBAFF flag's state, ensuring that any changes trigger a re-initialization of relevant decoder context variables, thus maintaining the integrity of the decoding process and preventing errors related to unsupported configurations.","The vulnerability in the original code arose from the failure to properly track changes to the macroblock adaptive frame field flag, which is crucial for correctly interpreting video data. This oversight could lead to inconsistencies in the decoding process, particularly when the flag's state changed, resulting in potential errors or unsupported configurations. The fix implemented a mechanism to detect changes in this flag, ensuring that when a change occurs, the decoder context is re-initialized appropriately. This adjustment enhances the decoder's reliability and accuracy in processing video streams, thereby addressing the identified issue.","The vulnerability was fixed by introducing a dedicated variable to track the macroblock adaptive frame field flag, allowing the code to detect changes in its state. Specifically, a new variable was initialized to store the flag's value, and checks were added to compare this value against the previously stored state. If a change is detected, the decoder context is re-initialized, including updating the relevant variables such as the number of macroblocks and other associated parameters. This ensures that the decoder accurately reflects the current configuration, preventing inconsistencies and errors during video processing.","The vulnerability was addressed by implementing a mechanism to explicitly track changes to the macroblock adaptive frame field flag. A new variable was introduced to store the current state of this flag, allowing the code to detect any modifications. When a change is identified, the decoder context is re-initialized to ensure that all related parameters and configurations are updated accordingly. This adjustment enhances the decoder's ability to handle different video stream configurations accurately, thereby preventing potential errors and inconsistencies that could arise from untracked changes in the flag's state.","4,4","4, 4","4,4","4, 4"
125,125,188130,188130,,Remote,Not required,,CVE-2017-13200,https://www.cvedetails.com/cve/CVE-2017-13200/,CWE-200,Low,Partial,,,2018-01-12,5.0,"An information disclosure vulnerability in the Android media framework (av) related to id3 unsynchronization. Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-63100526.",2018-01-26,+Info ,6,https://android.googlesource.com/platform/frameworks/av/+/dd3ca4d6b81a9ae2ddf358b7b93d2f8c010921f5,dd3ca4d6b81a9ae2ddf358b7b93d2f8c010921f5,"Fix edge case when applying id3 unsynchronization

Bug: 63100526
Test: opened poc, other files
Change-Id: I0a51a2a11d0ea84ede0c075de650a7118f0e00c5
(cherry picked from commit 3e70296461c5f260988ab21854a6f43fdafea764)
",1,media/libstagefright/id3/ID3.cpp,"{""filename"": ""media/libstagefright/id3/ID3.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/dd3ca4d6b81a9ae2ddf358b7b93d2f8c010921f5/media/libstagefright/id3/ID3.cpp"", ""patch"": ""@@ -392,7 +392,12 @@\n\n                     --mSize;\n                     --dataSize;\n                 }\n-                mData[writeOffset++] = mData[readOffset++];\n+                if (i + 1 < dataSize) {\n+                    // Only move data if there's actually something to move.\n+                    // This handles the special case of the data being only [0xff, 0x00]\n+                    // which should be converted to just 0xff if unsynchronization is on.\n+                    mData[writeOffset++] = mData[readOffset++];\n+                }\n             }\n             // move the remaining data following this frame\n             if (readOffset <= oldSize) {\n""}","bool ID3::removeUnsynchronizationV2_4(bool iTunesHack) {
 size_t oldSize = mSize;

 size_t offset = 0;
 while (mSize >= 10 && offset <= mSize - 10) {
 if (!memcmp(&mData[offset], ""\0\0\0\0"", 4)) {
 break;
 }

 size_t dataSize;
 if (iTunesHack) {
            dataSize = U32_AT(&mData[offset + 4]);
 } else if (!ParseSyncsafeInteger(&mData[offset + 4], &dataSize)) {
 return false;
 }

 if (dataSize > mSize - 10 - offset) {
 return false;
 }

 uint16_t flags = U16_AT(&mData[offset + 8]);
 uint16_t prevFlags = flags;

 if (flags & 1) {

 if (mSize < 14 || mSize - 14 < offset || dataSize < 4) {
 return false;
 }
            memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);
            mSize -= 4;
            dataSize -= 4;

            flags &= ~1;
 }

 if ((flags & 2) && (dataSize >= 2)) {

 size_t readOffset = offset + 11;
 size_t writeOffset = offset + 11;
 for (size_t i = 0; i + 1 < dataSize; ++i) {
 if (mData[readOffset - 1] == 0xff
 && mData[readOffset] == 0x00) {
 ++readOffset;

                     --mSize;
                     --dataSize;
                 }
                if (i + 1 < dataSize) {
                    // Only move data if there's actually something to move.
                    // This handles the special case of the data being only [0xff, 0x00]
                    // which should be converted to just 0xff if unsynchronization is on.
                    mData[writeOffset++] = mData[readOffset++];
                }
             }
             if (readOffset <= oldSize) {
                memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);
 } else {
                ALOGE(""b/34618607 (%zu %zu %zu %zu)"", readOffset, writeOffset, oldSize, mSize);
                android_errorWriteLog(0x534e4554, ""34618607"");
 }

 }
        flags &= ~2;
 if (flags != prevFlags || iTunesHack) {
 WriteSyncsafeInteger(&mData[offset + 4], dataSize);
            mData[offset + 8] = flags >> 8;
            mData[offset + 9] = flags & 0xff;
 }

        offset += 10 + dataSize;
 }

    memset(&mData[mSize], 0, oldSize - mSize);

 return true;
}
","bool ID3::removeUnsynchronizationV2_4(bool iTunesHack) {
 size_t oldSize = mSize;

 size_t offset = 0;
 while (mSize >= 10 && offset <= mSize - 10) {
 if (!memcmp(&mData[offset], ""\0\0\0\0"", 4)) {
 break;
 }

 size_t dataSize;
 if (iTunesHack) {
            dataSize = U32_AT(&mData[offset + 4]);
 } else if (!ParseSyncsafeInteger(&mData[offset + 4], &dataSize)) {
 return false;
 }

 if (dataSize > mSize - 10 - offset) {
 return false;
 }

 uint16_t flags = U16_AT(&mData[offset + 8]);
 uint16_t prevFlags = flags;

 if (flags & 1) {

 if (mSize < 14 || mSize - 14 < offset || dataSize < 4) {
 return false;
 }
            memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);
            mSize -= 4;
            dataSize -= 4;

            flags &= ~1;
 }

 if ((flags & 2) && (dataSize >= 2)) {

 size_t readOffset = offset + 11;
 size_t writeOffset = offset + 11;
 for (size_t i = 0; i + 1 < dataSize; ++i) {
 if (mData[readOffset - 1] == 0xff
 && mData[readOffset] == 0x00) {
 ++readOffset;

                     --mSize;
                     --dataSize;
                 }
                mData[writeOffset++] = mData[readOffset++];
             }
             if (readOffset <= oldSize) {
                memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);
 } else {
                ALOGE(""b/34618607 (%zu %zu %zu %zu)"", readOffset, writeOffset, oldSize, mSize);
                android_errorWriteLog(0x534e4554, ""34618607"");
 }

 }
        flags &= ~2;
 if (flags != prevFlags || iTunesHack) {
 WriteSyncsafeInteger(&mData[offset + 4], dataSize);
            mData[offset + 8] = flags >> 8;
            mData[offset + 9] = flags & 0xff;
 }

        offset += 10 + dataSize;
 }

    memset(&mData[mSize], 0, oldSize - mSize);

 return true;
}
",C,"                if (i + 1 < dataSize) {
                    // Only move data if there's actually something to move.
                    // This handles the special case of the data being only [0xff, 0x00]
                    // which should be converted to just 0xff if unsynchronization is on.
                    mData[writeOffset++] = mData[readOffset++];
                }
","                mData[writeOffset++] = mData[readOffset++];
",,"@@ -392,7 +392,12 @@

                     --mSize;
                     --dataSize;
                 }
-                mData[writeOffset++] = mData[readOffset++];
+                if (i + 1 < dataSize) {
+                    // Only move data if there's actually something to move.
+                    // This handles the special case of the data being only [0xff, 0x00]
+                    // which should be converted to just 0xff if unsynchronization is on.
+                    mData[writeOffset++] = mData[readOffset++];
+                }
             }
             // move the remaining data following this frame
             if (readOffset <= oldSize) {
",Android,https://android.googlesource.com/platform/frameworks/av/+/dd3ca4d6b81a9ae2ddf358b7b93d2f8c010921f5/,https://android.googlesource.com/platform/frameworks/av/+/dd3ca4d6b81a9ae2ddf358b7b93d2f8c010921f5%5E/,1,"bool ID3::removeUnsynchronizationV2_4(bool iTunesHack) {
 size_t oldSize = mSize;

 size_t offset = 0;
 while (mSize >= 10 && offset <= mSize - 10) {
 if (!memcmp(&mData[offset], ""\0\0\0\0"", 4)) {
 break;
 }

 size_t dataSize;
 if (iTunesHack) {
            dataSize = U32_AT(&mData[offset + 4]);
 } else if (!ParseSyncsafeInteger(&mData[offset + 4], &dataSize)) {
 return false;
 }

 if (dataSize > mSize - 10 - offset) {
 return false;
 }

 uint16_t flags = U16_AT(&mData[offset + 8]);
 uint16_t prevFlags = flags;

 if (flags & 1) {
 // Strip data length indicator

 if (mSize < 14 || mSize - 14 < offset || dataSize < 4) {
 return false;
 }
            memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);
            mSize -= 4;
            dataSize -= 4;

            flags &= ~1;
 }

 if ((flags & 2) && (dataSize >= 2)) {
 // This file has ""unsynchronization"", so we have to replace occurrences
 // of 0xff 0x00 with just 0xff in order to get the real data.

 size_t readOffset = offset + 11;
 size_t writeOffset = offset + 11;
 for (size_t i = 0; i + 1 < dataSize; ++i) {
 if (mData[readOffset - 1] == 0xff
 && mData[readOffset] == 0x00) {
 ++readOffset;

                     --mSize;
                     --dataSize;
                 }
//flaw_line_below:
                mData[writeOffset++] = mData[readOffset++];
//fix_flaw_line_below:
//                if (i + 1 < dataSize) {
//fix_flaw_line_below:
//                    // Only move data if there's actually something to move.
//fix_flaw_line_below:
//                    // This handles the special case of the data being only [0xff, 0x00]
//fix_flaw_line_below:
//                    // which should be converted to just 0xff if unsynchronization is on.
//fix_flaw_line_below:
//                    mData[writeOffset++] = mData[readOffset++];
//fix_flaw_line_below:
//                }
             }
             // move the remaining data following this frame
             if (readOffset <= oldSize) {
                memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);
 } else {
                ALOGE(""b/34618607 (%zu %zu %zu %zu)"", readOffset, writeOffset, oldSize, mSize);
                android_errorWriteLog(0x534e4554, ""34618607"");
 }

 }
        flags &= ~2;
 if (flags != prevFlags || iTunesHack) {
 WriteSyncsafeInteger(&mData[offset + 4], dataSize);
            mData[offset + 8] = flags >> 8;
            mData[offset + 9] = flags & 0xff;
 }

        offset += 10 + dataSize;
 }

    memset(&mData[mSize], 0, oldSize - mSize);

 return true;
}
",188130,"bool ID3::removeUnsynchronizationV2_4(bool iTunesHack) {
 size_t oldSize = mSize;

 size_t offset = 0;
 while (mSize >= 10 && offset <= mSize - 10) {
 if (!memcmp(&mData[offset], ""\0\0\0\0"", 4)) {
 break;
 }

 size_t dataSize;
 if (iTunesHack) {
            dataSize = U32_AT(&mData[offset + 4]);
 } else if (!ParseSyncsafeInteger(&mData[offset + 4], &dataSize)) {
 return false;
 }

 if (dataSize > mSize - 10 - offset) {
 return false;
 }

 uint16_t flags = U16_AT(&mData[offset + 8]);
 uint16_t prevFlags = flags;

 if (flags & 1) {

 if (mSize < 14 || mSize - 14 < offset || dataSize < 4) {
 return false;
 }
            memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);
            mSize -= 4;
            dataSize -= 4;

            flags &= ~1;
 }

 if ((flags & 2) && (dataSize >= 2)) {

 size_t readOffset = offset + 11;
 size_t writeOffset = offset + 11;
 for (size_t i = 0; i + 1 < dataSize; ++i) {
 if (mData[readOffset - 1] == 0xff
 && mData[readOffset] == 0x00) {
 ++readOffset;

                     --mSize;
                     --dataSize;
                 }
                mData[writeOffset++] = mData[readOffset++];
             }
             if (readOffset <= oldSize) {
                memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);
 } else {
                ALOGE(""b/34618607 (%zu %zu %zu %zu)"", readOffset, writeOffset, oldSize, mSize);
                android_errorWriteLog(0x534e4554, ""34618607"");
 }

 }
        flags &= ~2;
 if (flags != prevFlags || iTunesHack) {
 WriteSyncsafeInteger(&mData[offset + 4], dataSize);
            mData[offset + 8] = flags >> 8;
            mData[offset + 9] = flags & 0xff;
 }

        offset += 10 + dataSize;
 }

    memset(&mData[mSize], 0, oldSize - mSize);

 return true;
}
","bool ID3::removeUnsynchronizationV2_4(bool iTunesHack) {
 size_t oldSize = mSize;

 size_t offset = 0;
 while (mSize >= 10 && offset <= mSize - 10) {
 if (!memcmp(&mData[offset], ""\0\0\0\0"", 4)) {
 break;
 }

 size_t dataSize;
 if (iTunesHack) {
            dataSize = U32_AT(&mData[offset + 4]);
 } else if (!ParseSyncsafeInteger(&mData[offset + 4], &dataSize)) {
 return false;
 }

 if (dataSize > mSize - 10 - offset) {
 return false;
 }

 uint16_t flags = U16_AT(&mData[offset + 8]);
 uint16_t prevFlags = flags;

 if (flags & 1) {

 if (mSize < 14 || mSize - 14 < offset || dataSize < 4) {
 return false;
 }
            memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);
            mSize -= 4;
            dataSize -= 4;

            flags &= ~1;
 }

 if ((flags & 2) && (dataSize >= 2)) {

 size_t readOffset = offset + 11;
 size_t writeOffset = offset + 11;
 for (size_t i = 0; i + 1 < dataSize; ++i) {
 if (mData[readOffset - 1] == 0xff
 && mData[readOffset] == 0x00) {
 ++readOffset;

                     --mSize;
                     --dataSize;
                 }
                if (i + 1 < dataSize) {
                    // Only move data if there's actually something to move.
                    // This handles the special case of the data being only [0xff, 0x00]
                    // which should be converted to just 0xff if unsynchronization is on.
                    mData[writeOffset++] = mData[readOffset++];
                }
             }
             if (readOffset <= oldSize) {
                memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);
 } else {
                ALOGE(""b/34618607 (%zu %zu %zu %zu)"", readOffset, writeOffset, oldSize, mSize);
                android_errorWriteLog(0x534e4554, ""34618607"");
 }

 }
        flags &= ~2;
 if (flags != prevFlags || iTunesHack) {
 WriteSyncsafeInteger(&mData[offset + 4], dataSize);
            mData[offset + 8] = flags >> 8;
            mData[offset + 9] = flags & 0xff;
 }

        offset += 10 + dataSize;
 }

    memset(&mData[mSize], 0, oldSize - mSize);

 return true;
}
","The `removeUnsynchronizationV2_4` function processes an ID3 tag by removing unsynchronization bytes, which are used to prevent misinterpretation of data streams. It iterates through the tag data, checking for specific flags and conditions to identify and remove unnecessary bytes, particularly those that may interfere with data interpretation. If the iTunes hack is enabled, it reads data sizes differently. The function adjusts the size of the data and updates flags accordingly, ensuring that the data remains intact while eliminating unsynchronization artifacts. Finally, it clears any remaining data beyond the new size, ensuring a clean output.","The code processes an audio metadata format by identifying and removing unnecessary synchronization bytes that can disrupt data interpretation. It iterates through the metadata, checking for specific conditions to determine which bytes can be safely eliminated. Depending on a specific flag, it adjusts the size of the data and modifies certain indicators to reflect these changes. The function ensures that the remaining data is correctly aligned and free of artifacts, while also clearing any excess data beyond the new size. Ultimately, it maintains the integrity of the metadata while enhancing its compatibility with various players.","The vulnerability in the original code stemmed from inadequate checks when processing unsynchronization flags, particularly when handling specific byte patterns that could lead to buffer overflows or data corruption. The fixed code introduces a condition to ensure that data movement only occurs if there is sufficient data to process, specifically checking `if (i + 1 < dataSize)` before moving bytes. This prevents attempts to access out-of-bounds memory when the data consists solely of the unsynchronization pattern. Additionally, the fix includes logging for error handling, enhancing the robustness of the function against edge cases.","The vulnerability in the original code arose from insufficient validation when processing unsynchronization bytes, which could lead to buffer overflows or unintended data manipulation, particularly in edge cases where specific byte patterns were present. The fix addressed this issue by implementing additional checks to ensure that data movement only occurred when there was enough data to process, thereby preventing out-of-bounds access. This enhancement not only mitigated the risk of corruption but also improved the overall stability of the function when handling various input scenarios, ensuring safer and more reliable processing of audio metadata.","The vulnerability was fixed by adding a condition to check that there is sufficient data to process before moving bytes, specifically by ensuring `if (i + 1 < dataSize)` is true during the data movement loop. This prevents attempts to access memory beyond the allocated size, which could lead to buffer overflows. Additionally, the code now includes a check for the `dataSize` variable to ensure it is valid before proceeding with operations that modify the data. These changes enhance the robustness of the function, ensuring it handles edge cases safely and effectively.","The vulnerability was fixed by implementing additional checks to ensure that there is enough data available before performing any operations that could lead to memory access issues. Specifically, the code now verifies that the data being processed meets certain conditions before proceeding with modifications, which prevents out-of-bounds access and potential buffer overflows. This enhancement ensures that the function only attempts to manipulate data when it is safe to do so, thereby improving the overall stability and reliability of the code when handling various input scenarios and edge cases.","4,4","5,5","4,4","4,4"
126,126,188137,188137,,Remote,Not required,Complete,CVE-2017-13187,https://www.cvedetails.com/cve/CVE-2017-13187/,CWE-200,Low,Partial,,,2018-01-12,8.5,"An information disclosure vulnerability in the Android media framework (libhevc). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-65034175.",2018-01-26,+Info ,12,https://android.googlesource.com/platform/external/libhevc/+/7c9be319a279654e55a6d757265f88c61a16a4d5,7c9be319a279654e55a6d757265f88c61a16a4d5,"Fix prev slice incomplete check

Bug: 64552185
Bug: 65034175

Move the decision to signal missing ctbs as skipped ctbs of
previous slice to the end of current slice hdr parsing to
ensure no error in slice hdr parsing.

Change-Id: Ia33b4be31dad6225b04e7b20b9000059c87941c4
(cherry picked from commit 74f35f191022c06863dacd33a3651a33be3ef08d)
(cherry picked from commit 9c24714e25d6ba713549a573df1d496479dce2b1)
",10,decoder/ihevcd_parse_slice_header.c,"{""filename"": ""decoder/ihevcd_parse_slice_header.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libhevc/+/7c9be319a279654e55a6d757265f88c61a16a4d5/decoder/ihevcd_parse_slice_header.c"", ""patch"": ""@@ -234,6 +234,7 @@\n\n     WORD8 i1_nal_unit_type = ps_nal->i1_nal_unit_type;\n     WORD32 num_poc_total_curr = 0;\n     WORD32 slice_address;\n+    WORD32 prev_slice_incomplete_flag = 0;\n \n     if(ps_codec->i4_slice_error == 1)\n         return ret;\n@@ -737,16 +738,7 @@\n\n             {\n                 if(ps_codec->i4_pic_present)\n                 {\n-                    slice_header_t *ps_slice_hdr_next;\n-                    ps_codec->i4_slice_error = 1;\n-                    ps_codec->s_parse.i4_cur_slice_idx--;\n-                    if(ps_codec->s_parse.i4_cur_slice_idx < 0)\n-                        ps_codec->s_parse.i4_cur_slice_idx = 0;\n-\n-                    ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\n-                    ps_slice_hdr_next->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;\n-                    ps_slice_hdr_next->i2_ctb_y = slice_address / ps_sps->i2_pic_wd_in_ctb;\n-                    return ret;\n+                    prev_slice_incomplete_flag = 1;\n                 }\n                 else\n                 {\n@@ -1016,7 +1008,8 @@\n\n         slice_header_t *ps_slice_hdr_prev = ps_codec->s_parse.ps_slice_hdr_base;\n         ihevcd_copy_slice_hdr(ps_codec, 0, (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)));\n \n-        ps_codec->i4_slice_error = 1;\n+        prev_slice_incomplete_flag = 1;\n+        ASSERT(ps_codec->s_parse.i4_cur_slice_idx == 1);\n \n         ps_slice_hdr_prev->i2_ctb_x = 0;\n         ps_slice_hdr_prev->i2_ctb_y = 0;\n@@ -1055,5 +1048,13 @@\n\n         }\n     }\n \n+    if(prev_slice_incomplete_flag)\n+    {\n+        ps_codec->i4_slice_error = 1;\n+        ps_codec->s_parse.i4_cur_slice_idx--;\n+        if(ps_codec->s_parse.i4_cur_slice_idx < 0)\n+            ps_codec->s_parse.i4_cur_slice_idx = 0;\n+    }\n+\n     return ret;\n }\n""}","IHEVCD_ERROR_T ihevcd_parse_slice_header(codec_t *ps_codec,
 nal_header_t *ps_nal)
{
    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
    WORD32 value;
    WORD32 i, j;
    WORD32 sps_id;

 pps_t *ps_pps;
 sps_t *ps_sps;
 slice_header_t *ps_slice_hdr;
    WORD32 disable_deblocking_filter_flag;
 bitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;
    WORD32 idr_pic_flag;
    WORD32 pps_id;
    WORD32 first_slice_in_pic_flag;
    WORD32 no_output_of_prior_pics_flag = 0;

     WORD8 i1_nal_unit_type = ps_nal->i1_nal_unit_type;
     WORD32 num_poc_total_curr = 0;
     WORD32 slice_address;
    WORD32 prev_slice_incomplete_flag = 0;
 
     if(ps_codec->i4_slice_error == 1)
         return ret;

    idr_pic_flag = (NAL_IDR_W_LP == i1_nal_unit_type) ||
 (NAL_IDR_N_LP == i1_nal_unit_type);


    BITS_PARSE(""first_slice_in_pic_flag"", first_slice_in_pic_flag, ps_bitstrm, 1);
 if((NAL_BLA_W_LP <= i1_nal_unit_type) &&
 (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))
 {
        BITS_PARSE(""no_output_of_prior_pics_flag"", no_output_of_prior_pics_flag, ps_bitstrm, 1);
 }
    UEV_PARSE(""pic_parameter_set_id"", pps_id, ps_bitstrm);
    pps_id = CLIP3(pps_id, 0, MAX_PPS_CNT - 2);

 /* Get the current PPS structure */
    ps_pps = ps_codec->s_parse.ps_pps_base + pps_id;
 if(0 == ps_pps->i1_pps_valid)
 {
 pps_t *ps_pps_ref = ps_codec->ps_pps_base;
 while(0 == ps_pps_ref->i1_pps_valid)
 {
            ps_pps_ref++;
 if((ps_pps_ref - ps_codec->ps_pps_base >= MAX_PPS_CNT - 1))
 return IHEVCD_INVALID_HEADER;
 }

        ihevcd_copy_pps(ps_codec, pps_id, ps_pps_ref->i1_pps_id);
 }

 /* Get SPS id for the current PPS */
    sps_id = ps_pps->i1_sps_id;

 /* Get the current SPS structure */
    ps_sps = ps_codec->s_parse.ps_sps_base + sps_id;

 /* When the current slice is the first in a pic,
     *  check whether the previous frame is complete
     *  If the previous frame is incomplete -
     *  treat the remaining CTBs as skip */
 if((0 != ps_codec->u4_pic_cnt || ps_codec->i4_pic_present) &&
                    first_slice_in_pic_flag)
 {
 if(ps_codec->i4_pic_present)
 {
 slice_header_t *ps_slice_hdr_next;
            ps_codec->i4_slice_error = 1;
            ps_codec->s_parse.i4_cur_slice_idx--;
 if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                ps_codec->s_parse.i4_cur_slice_idx = 0;

            ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
            ps_slice_hdr_next->i2_ctb_x = 0;
            ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;
 return ret;
 }
 else
 {
            ps_codec->i4_slice_error = 0;
 }
 }

 if(first_slice_in_pic_flag)
 {
        ps_codec->s_parse.i4_cur_slice_idx = 0;
 }
 else
 {
 /* If the current slice is not the first slice in the pic,
         * but the first one to be parsed, set the current slice indx to 1
         * Treat the first slice to be missing and copy the current slice header
         * to the first one */
 if(0 == ps_codec->i4_pic_present)
            ps_codec->s_parse.i4_cur_slice_idx = 1;
 }

    ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));


 if((ps_pps->i1_dependent_slice_enabled_flag) &&
 (!first_slice_in_pic_flag))
 {
        BITS_PARSE(""dependent_slice_flag"", value, ps_bitstrm, 1);

 /* If dependendent slice, copy slice header from previous slice */
 if(value && (ps_codec->s_parse.i4_cur_slice_idx > 0))
 {
            ihevcd_copy_slice_hdr(ps_codec,
 (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)),
 ((ps_codec->s_parse.i4_cur_slice_idx - 1) & (MAX_SLICE_HDR_CNT - 1)));
 }
        ps_slice_hdr->i1_dependent_slice_flag = value;
 }
 else
 {
        ps_slice_hdr->i1_dependent_slice_flag = 0;
 }
    ps_slice_hdr->i1_nal_unit_type = i1_nal_unit_type;
    ps_slice_hdr->i1_pps_id = pps_id;
    ps_slice_hdr->i1_first_slice_in_pic_flag = first_slice_in_pic_flag;

    ps_slice_hdr->i1_no_output_of_prior_pics_flag = 1;
 if((NAL_BLA_W_LP <= i1_nal_unit_type) &&
 (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))
 {
        ps_slice_hdr->i1_no_output_of_prior_pics_flag = no_output_of_prior_pics_flag;
 }
    ps_slice_hdr->i1_pps_id = pps_id;

 if(!ps_slice_hdr->i1_first_slice_in_pic_flag)
 {
        WORD32 num_bits;

 /* Use CLZ to compute Ceil( Log2( PicSizeInCtbsY ) ) */
        num_bits = 32 - CLZ(ps_sps->i4_pic_size_in_ctb - 1);
        BITS_PARSE(""slice_address"", value, ps_bitstrm, num_bits);

        slice_address = value;
 /* If slice address is greater than the number of CTBs in a picture,
         * ignore the slice */
 if(value >= ps_sps->i4_pic_size_in_ctb)
 return IHEVCD_IGNORE_SLICE;
 }
 else
 {
        slice_address = 0;
 }

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
        ps_slice_hdr->i1_pic_output_flag = 1;
        ps_slice_hdr->i4_pic_order_cnt_lsb = 0;
        ps_slice_hdr->i1_num_long_term_sps = 0;
        ps_slice_hdr->i1_num_long_term_pics = 0;

 for(i = 0; i < ps_pps->i1_num_extra_slice_header_bits; i++)
 {
            BITS_PARSE(""slice_reserved_undetermined_flag[ i ]"", value, ps_bitstrm, 1);
 }
        UEV_PARSE(""slice_type"", value, ps_bitstrm);
        ps_slice_hdr->i1_slice_type = value;

 /* If the picture is IRAP, slice type must be equal to ISLICE */
 if((ps_slice_hdr->i1_nal_unit_type >= NAL_BLA_W_LP) &&
 (ps_slice_hdr->i1_nal_unit_type <= NAL_RSV_RAP_VCL23))
            ps_slice_hdr->i1_slice_type = ISLICE;

 if((ps_slice_hdr->i1_slice_type < 0) ||
 (ps_slice_hdr->i1_slice_type > 2))
 return IHEVCD_IGNORE_SLICE;

 if(ps_pps->i1_output_flag_present_flag)
 {
            BITS_PARSE(""pic_output_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_pic_output_flag = value;
 }
        ps_slice_hdr->i1_colour_plane_id = 0;
 if(1 == ps_sps->i1_separate_colour_plane_flag)
 {
            BITS_PARSE(""colour_plane_id"", value, ps_bitstrm, 2);
            ps_slice_hdr->i1_colour_plane_id = value;
 }
        ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = 0;

 if(!idr_pic_flag)
 {

            WORD32 st_rps_idx;
            WORD32 num_neg_pics;
            WORD32 num_pos_pics;
            WORD8 *pi1_used;

            BITS_PARSE(""pic_order_cnt_lsb"", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);
            ps_slice_hdr->i4_pic_order_cnt_lsb = value;

            BITS_PARSE(""short_term_ref_pic_set_sps_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag = value;

 if(1 == ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag)
 {
                WORD32 numbits;

                ps_slice_hdr->i1_short_term_ref_pic_set_idx = 0;
 if(ps_sps->i1_num_short_term_ref_pic_sets > 1)
 {
                    numbits = 32 - CLZ(ps_sps->i1_num_short_term_ref_pic_sets - 1);
                    BITS_PARSE(""short_term_ref_pic_set_idx"", value, ps_bitstrm, numbits);
                    ps_slice_hdr->i1_short_term_ref_pic_set_idx = value;
 }

                st_rps_idx = ps_slice_hdr->i1_short_term_ref_pic_set_idx;
                num_neg_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_neg_pics;
                num_pos_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_pos_pics;
                pi1_used = ps_sps->as_stref_picset[st_rps_idx].ai1_used;
 }
 else
 {
                ihevcd_short_term_ref_pic_set(ps_bitstrm,
 &ps_sps->as_stref_picset[0],
                                              ps_sps->i1_num_short_term_ref_pic_sets,
                                              ps_sps->i1_num_short_term_ref_pic_sets,
 &ps_slice_hdr->s_stref_picset);

                st_rps_idx = ps_sps->i1_num_short_term_ref_pic_sets;
                num_neg_pics = ps_slice_hdr->s_stref_picset.i1_num_neg_pics;
                num_pos_pics = ps_slice_hdr->s_stref_picset.i1_num_pos_pics;
                pi1_used = ps_slice_hdr->s_stref_picset.ai1_used;
 }

 if(ps_sps->i1_long_term_ref_pics_present_flag)
 {
 if(ps_sps->i1_num_long_term_ref_pics_sps > 0)
 {
                    UEV_PARSE(""num_long_term_sps"", value, ps_bitstrm);
                    ps_slice_hdr->i1_num_long_term_sps = value;

                    ps_slice_hdr->i1_num_long_term_sps = CLIP3(ps_slice_hdr->i1_num_long_term_sps,
 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics);
 }
                UEV_PARSE(""num_long_term_pics"", value, ps_bitstrm);
                ps_slice_hdr->i1_num_long_term_pics = value;
                ps_slice_hdr->i1_num_long_term_pics = CLIP3(ps_slice_hdr->i1_num_long_term_pics,
 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics -
                                                            ps_slice_hdr->i1_num_long_term_sps);

 for(i = 0; i < (ps_slice_hdr->i1_num_long_term_sps +
                                ps_slice_hdr->i1_num_long_term_pics); i++)
 {
 if(i < ps_slice_hdr->i1_num_long_term_sps)
 {
 /* Use CLZ to compute Ceil( Log2( num_long_term_ref_pics_sps ) ) */
 if (ps_sps->i1_num_long_term_ref_pics_sps > 1)
 {
                            WORD32 num_bits = 32 - CLZ(ps_sps->i1_num_long_term_ref_pics_sps - 1);
                            BITS_PARSE(""lt_idx_sps[ i ]"", value, ps_bitstrm, num_bits);
 }
 else
 {
                            value = 0;
 }
                        ps_slice_hdr->ai4_poc_lsb_lt[i] = ps_sps->au2_lt_ref_pic_poc_lsb_sps[value];
                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = ps_sps->ai1_used_by_curr_pic_lt_sps_flag[value];

 }
 else
 {
                        BITS_PARSE(""poc_lsb_lt[ i ]"", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);
                        ps_slice_hdr->ai4_poc_lsb_lt[i] = value;

                        BITS_PARSE(""used_by_curr_pic_lt_flag[ i ]"", value, ps_bitstrm, 1);
                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = value;

 }
                    BITS_PARSE(""delta_poc_msb_present_flag[ i ]"", value, ps_bitstrm, 1);
                    ps_slice_hdr->ai1_delta_poc_msb_present_flag[i] = value;


                    ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = 0;
 if(ps_slice_hdr->ai1_delta_poc_msb_present_flag[i])
 {

                        UEV_PARSE(""delata_poc_msb_cycle_lt[ i ]"", value, ps_bitstrm);
                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = value;
 }

 if((i != 0) && (i != ps_slice_hdr->i1_num_long_term_sps))
 {
                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] += ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i - 1];
 }

 }
 }

 for(i = 0; i < num_neg_pics + num_pos_pics; i++)
 {
 if(pi1_used[i])
 {
                    num_poc_total_curr++;
 }
 }
 for(i = 0; i < ps_slice_hdr->i1_num_long_term_sps + ps_slice_hdr->i1_num_long_term_pics; i++)
 {
 if(ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i])
 {
                    num_poc_total_curr++;
 }
 }


 if(ps_sps->i1_sps_temporal_mvp_enable_flag)
 {
                BITS_PARSE(""enable_temporal_mvp_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = value;
 }

 }
        ps_slice_hdr->i1_slice_sao_luma_flag = 0;
        ps_slice_hdr->i1_slice_sao_chroma_flag = 0;
 if(ps_sps->i1_sample_adaptive_offset_enabled_flag)
 {
            BITS_PARSE(""slice_sao_luma_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_slice_sao_luma_flag = value;

            BITS_PARSE(""slice_sao_chroma_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_slice_sao_chroma_flag = value;

 }

        ps_slice_hdr->i1_max_num_merge_cand = 1;
        ps_slice_hdr->i1_cabac_init_flag = 0;

        ps_slice_hdr->i1_num_ref_idx_l0_active = 0;
        ps_slice_hdr->i1_num_ref_idx_l1_active = 0;
        ps_slice_hdr->i1_slice_cb_qp_offset = 0;
        ps_slice_hdr->i1_slice_cr_qp_offset = 0;
 if((PSLICE == ps_slice_hdr->i1_slice_type) ||
 (BSLICE == ps_slice_hdr->i1_slice_type))
 {
            BITS_PARSE(""num_ref_idx_active_override_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_num_ref_idx_active_override_flag = value;

 if(ps_slice_hdr->i1_num_ref_idx_active_override_flag)
 {
                UEV_PARSE(""num_ref_idx_l0_active_minus1"", value, ps_bitstrm);
                ps_slice_hdr->i1_num_ref_idx_l0_active = value + 1;

 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                    UEV_PARSE(""num_ref_idx_l1_active_minus1"", value, ps_bitstrm);
                    ps_slice_hdr->i1_num_ref_idx_l1_active = value + 1;
 }

 }
 else
 {
                ps_slice_hdr->i1_num_ref_idx_l0_active = ps_pps->i1_num_ref_idx_l0_default_active;

 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                    ps_slice_hdr->i1_num_ref_idx_l1_active = ps_pps->i1_num_ref_idx_l1_default_active;
 }
 }

            ps_slice_hdr->i1_num_ref_idx_l0_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l0_active, 0, MAX_DPB_SIZE - 1);
            ps_slice_hdr->i1_num_ref_idx_l1_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l1_active, 0, MAX_DPB_SIZE - 1);

 if(0 == num_poc_total_curr)
 return IHEVCD_IGNORE_SLICE;
 if((ps_pps->i1_lists_modification_present_flag) && (num_poc_total_curr > 1))
 {
                ihevcd_ref_pic_list_modification(ps_bitstrm,
                                                 ps_slice_hdr, num_poc_total_curr);
 }
 else
 {
                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l0 = 0;
                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l1 = 0;
 }

 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                BITS_PARSE(""mvd_l1_zero_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_mvd_l1_zero_flag = value;
 }

            ps_slice_hdr->i1_cabac_init_flag = 0;
 if(ps_pps->i1_cabac_init_present_flag)
 {
                BITS_PARSE(""cabac_init_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_cabac_init_flag = value;

 }
            ps_slice_hdr->i1_collocated_from_l0_flag = 1;
            ps_slice_hdr->i1_collocated_ref_idx = 0;
 if(ps_slice_hdr->i1_slice_temporal_mvp_enable_flag)
 {
 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                    BITS_PARSE(""collocated_from_l0_flag"", value, ps_bitstrm, 1);
                    ps_slice_hdr->i1_collocated_from_l0_flag = value;
 }

 if((ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l0_active > 1)) ||
 (!ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l1_active > 1)))
 {
                    UEV_PARSE(""collocated_ref_idx"", value, ps_bitstrm);
                    ps_slice_hdr->i1_collocated_ref_idx = value;
 }

 }
            ps_slice_hdr->i1_collocated_ref_idx = CLIP3(ps_slice_hdr->i1_collocated_ref_idx, 0, MAX_DPB_SIZE - 1);

 if((ps_pps->i1_weighted_pred_flag  && (PSLICE == ps_slice_hdr->i1_slice_type)) ||
 (ps_pps->i1_weighted_bipred_flag  && (BSLICE == ps_slice_hdr->i1_slice_type)))
 {
                ihevcd_parse_pred_wt_ofst(ps_bitstrm, ps_sps, ps_pps, ps_slice_hdr);
 }
            UEV_PARSE(""five_minus_max_num_merge_cand"", value, ps_bitstrm);
            ps_slice_hdr->i1_max_num_merge_cand = 5 - value;

 }
        ps_slice_hdr->i1_max_num_merge_cand = CLIP3(ps_slice_hdr->i1_max_num_merge_cand, 1, 5);
        SEV_PARSE(""slice_qp_delta"", value, ps_bitstrm);
        ps_slice_hdr->i1_slice_qp_delta = value;

 if(ps_pps->i1_pic_slice_level_chroma_qp_offsets_present_flag)
 {
            SEV_PARSE(""slice_cb_qp_offset"", value, ps_bitstrm);
            ps_slice_hdr->i1_slice_cb_qp_offset = value;

            SEV_PARSE(""slice_cr_qp_offset"", value, ps_bitstrm);
            ps_slice_hdr->i1_slice_cr_qp_offset = value;

 }
        ps_slice_hdr->i1_deblocking_filter_override_flag = 0;
        ps_slice_hdr->i1_slice_disable_deblocking_filter_flag  = ps_pps->i1_pic_disable_deblocking_filter_flag;
        ps_slice_hdr->i1_beta_offset_div2 = ps_pps->i1_beta_offset_div2;
        ps_slice_hdr->i1_tc_offset_div2 = ps_pps->i1_tc_offset_div2;

        disable_deblocking_filter_flag = ps_pps->i1_pic_disable_deblocking_filter_flag;

 if(ps_pps->i1_deblocking_filter_control_present_flag)
 {

 if(ps_pps->i1_deblocking_filter_override_enabled_flag)
 {
                BITS_PARSE(""deblocking_filter_override_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_deblocking_filter_override_flag = value;
 }

 if(ps_slice_hdr->i1_deblocking_filter_override_flag)
 {
                BITS_PARSE(""slice_disable_deblocking_filter_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_slice_disable_deblocking_filter_flag = value;
                disable_deblocking_filter_flag = ps_slice_hdr->i1_slice_disable_deblocking_filter_flag;

 if(!ps_slice_hdr->i1_slice_disable_deblocking_filter_flag)
 {
                    SEV_PARSE(""beta_offset_div2"", value, ps_bitstrm);
                    ps_slice_hdr->i1_beta_offset_div2 = value;

                    SEV_PARSE(""tc_offset_div2"", value, ps_bitstrm);
                    ps_slice_hdr->i1_tc_offset_div2 = value;

 }
 }
 }

        ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = ps_pps->i1_loop_filter_across_slices_enabled_flag;
 if(ps_pps->i1_loop_filter_across_slices_enabled_flag  &&
 (ps_slice_hdr->i1_slice_sao_luma_flag  ||  ps_slice_hdr->i1_slice_sao_chroma_flag  || !disable_deblocking_filter_flag))
 {
            BITS_PARSE(""slice_loop_filter_across_slices_enabled_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = value;
 }

 }

 /* Check sanity of slice */
 if((!first_slice_in_pic_flag) &&
 (ps_codec->i4_pic_present))
 {
 slice_header_t *ps_slice_hdr_base = ps_codec->ps_slice_hdr_base;


 /* According to the standard, the above conditions must be satisfied - But for error resilience,
         * only the following conditions are checked */
 if((ps_slice_hdr_base->i1_pps_id != ps_slice_hdr->i1_pps_id) ||
 (ps_slice_hdr_base->i4_pic_order_cnt_lsb != ps_slice_hdr->i4_pic_order_cnt_lsb))
 {
 return IHEVCD_IGNORE_SLICE;
 }

 }


 if(0 == ps_codec->i4_pic_present)
 {
        ps_slice_hdr->i4_abs_pic_order_cnt = ihevcd_calc_poc(ps_codec, ps_nal, ps_sps->i1_log2_max_pic_order_cnt_lsb, ps_slice_hdr->i4_pic_order_cnt_lsb);
 }
 else
 {
        ps_slice_hdr->i4_abs_pic_order_cnt = ps_codec->s_parse.i4_abs_pic_order_cnt;
 }


 if(!first_slice_in_pic_flag)
 {
 /* Check if the current slice belongs to the same pic (Pic being parsed) */
 if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)
 {

 /* If the Next CTB's index is less than the slice address,
             * the previous slice is incomplete.
             * Indicate slice error, and treat the remaining CTBs as skip */
 if(slice_address > ps_codec->s_parse.i4_next_ctb_indx)

             {
                 if(ps_codec->i4_pic_present)
                 {
                    prev_slice_incomplete_flag = 1;
                 }
                 else
                 {
 return IHEVCD_IGNORE_SLICE;
 }
 }
 /* If the slice address is less than the next CTB's index,
             * extra CTBs have been decoded in the previous slice.
             * Ignore the current slice. Treat it as incomplete */
 else if(slice_address < ps_codec->s_parse.i4_next_ctb_indx)
 {
 return IHEVCD_IGNORE_SLICE;
 }
 else
 {
                ps_codec->i4_slice_error = 0;
 }
 }

 /* The current slice does not belong to the pic that is being parsed */
 else
 {
 /* The previous pic is incomplete.
             * Treat the remaining CTBs as skip */
 if(ps_codec->i4_pic_present)
 {
 slice_header_t *ps_slice_hdr_next;
                ps_codec->i4_slice_error = 1;
                ps_codec->s_parse.i4_cur_slice_idx--;
 if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                    ps_codec->s_parse.i4_cur_slice_idx = 0;

                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
                ps_slice_hdr_next->i2_ctb_x = 0;
                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;
 return ret;
 }

 /* If the previous pic is complete,
             * return if the current slice is dependant
             * otherwise, update the parse context's POC */
 else
 {
 if(ps_slice_hdr->i1_dependent_slice_flag)
 return IHEVCD_IGNORE_SLICE;

                ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;
 }
 }
 }

 /* If the slice is the first slice in the pic, update the parse context's POC */
 else
 {
 /* If the first slice is repeated, ignore the second occurrence
         * If any other slice is repeated, the CTB addr will be greater than the slice addr,
         * and hence the second occurrence is ignored */
 if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)
 return IHEVCD_IGNORE_SLICE;

        ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;
 }

    ps_slice_hdr->i4_num_entry_point_offsets = 0;
 if((ps_pps->i1_tiles_enabled_flag) ||
 (ps_pps->i1_entropy_coding_sync_enabled_flag))
 {
        UEV_PARSE(""num_entry_point_offsets"", value, ps_bitstrm);
        ps_slice_hdr->i4_num_entry_point_offsets = value;

 {
            WORD32 max_num_entry_point_offsets;
 if((ps_pps->i1_tiles_enabled_flag) &&
 (ps_pps->i1_entropy_coding_sync_enabled_flag))
 {
                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * (ps_sps->i2_pic_ht_in_ctb - 1);
 }
 else if(ps_pps->i1_tiles_enabled_flag)
 {
                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * ps_pps->i1_num_tile_rows;
 }
 else
 {
                max_num_entry_point_offsets = (ps_sps->i2_pic_ht_in_ctb - 1);
 }

            ps_slice_hdr->i4_num_entry_point_offsets = CLIP3(ps_slice_hdr->i4_num_entry_point_offsets,
 0, max_num_entry_point_offsets);
 }

 if(ps_slice_hdr->i4_num_entry_point_offsets > 0)
 {
            UEV_PARSE(""offset_len_minus1"", value, ps_bitstrm);
            ps_slice_hdr->i1_offset_len = value + 1;

 for(i = 0; i < ps_slice_hdr->i4_num_entry_point_offsets; i++)
 {
                BITS_PARSE(""entry_point_offset"", value, ps_bitstrm, ps_slice_hdr->i1_offset_len);

 /* TODO: pu4_entry_point_offset needs to be initialized */
 }

 }
 }

 if(ps_pps->i1_slice_header_extension_present_flag)
 {
        UEV_PARSE(""slice_header_extension_length"", value, ps_bitstrm);
        ps_slice_hdr->i2_slice_header_extension_length = value;


 for(i = 0; i < ps_slice_hdr->i2_slice_header_extension_length; i++)
 {
            BITS_PARSE(""slice_header_extension_data_byte"", value, ps_bitstrm, 8);
 }

 }

    ihevcd_bits_flush_to_byte_boundary(ps_bitstrm);

 if((UWORD8 *)ps_bitstrm->pu4_buf > ps_bitstrm->pu1_buf_max)
 return IHEVCD_INVALID_PARAMETER;

 {
 dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;
        WORD32 r_idx;

 if((NAL_IDR_W_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_IDR_N_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_BLA_N_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_BLA_W_DLP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_BLA_W_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (0 == ps_codec->u4_pic_cnt))
 {
 for(i = 0; i < MAX_DPB_BUFS; i++)
 {
 if(ps_dpb_mgr->as_dpb_info[i].ps_pic_buf)
 {
 pic_buf_t *ps_pic_buf = ps_dpb_mgr->as_dpb_info[i].ps_pic_buf;
 mv_buf_t *ps_mv_buf;

 /* Long term index is set to MAX_DPB_BUFS to ensure it is not added as LT */
                    ihevc_dpb_mgr_del_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr, (buf_mgr_t *)ps_codec->pv_pic_buf_mgr, ps_pic_buf->i4_abs_poc);
 /* Find buffer id of the MV bank corresponding to the buffer being freed (Buffer with POC of u4_abs_poc) */
                    ps_mv_buf = (mv_buf_t *)ps_codec->ps_mv_buf;
 for(j = 0; j < ps_codec->i4_max_dpb_size; j++)
 {
 if(ps_mv_buf && ps_mv_buf->i4_abs_poc == ps_pic_buf->i4_abs_poc)
 {
                            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_mv_buf_mgr, j, BUF_MGR_REF);
 break;
 }
                        ps_mv_buf++;
 }

 }

 }

 /* Initialize the reference lists to NULL
             * This is done to take care of the cases where the first pic is not IDR
             * but the reference list is not created for the first pic because
             * pic count is zero leaving the reference list uninitialised  */
 for(r_idx = 0; r_idx < MAX_DPB_SIZE; r_idx++)
 {
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = NULL;
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = NULL;

                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = NULL;
                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = NULL;
 }

 }
 else
 {
            ret = ihevcd_ref_list(ps_codec, ps_pps, ps_sps, ps_slice_hdr);
 if ((WORD32)IHEVCD_SUCCESS != ret)
 {
 return ret;
 }

 }

 }

 /* Fill the remaining entries of the reference lists with the nearest POC
     * This is done to handle cases where there is a corruption in the reference index */
 if(ps_codec->i4_pic_present)
 {
 pic_buf_t *ps_pic_buf_ref;
 mv_buf_t *ps_mv_buf_ref;
        WORD32 r_idx;
 dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;
 buf_mgr_t *ps_mv_buf_mgr = (buf_mgr_t *)ps_codec->pv_mv_buf_mgr;

        ps_pic_buf_ref = ihevc_dpb_mgr_get_ref_by_nearest_poc(ps_dpb_mgr, ps_slice_hdr->i4_abs_pic_order_cnt);
 if(NULL == ps_pic_buf_ref)
 {
            ps_pic_buf_ref = ps_codec->as_process[0].ps_cur_pic;
            ps_mv_buf_ref = ps_codec->s_parse.ps_cur_mv_buf;
 }
 else
 {
            ps_mv_buf_ref = ihevcd_mv_mgr_get_poc(ps_mv_buf_mgr, ps_pic_buf_ref->i4_abs_poc);
 }

 for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx++)
 {
 if(NULL == ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf)
 {
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }
 }

 for(r_idx = ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx < MAX_DPB_SIZE; r_idx++)
 {
            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }

 for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx++)
 {
 if(NULL == ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf)
 {
                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }
 }

 for(r_idx = ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx < MAX_DPB_SIZE; r_idx++)
 {
            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }
 }

 /* Update slice address in the header */
 if(!ps_slice_hdr->i1_first_slice_in_pic_flag)
 {
        ps_slice_hdr->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;
        ps_slice_hdr->i2_ctb_y = slice_address / ps_sps->i2_pic_wd_in_ctb;

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
            ps_slice_hdr->i2_independent_ctb_x = ps_slice_hdr->i2_ctb_x;
            ps_slice_hdr->i2_independent_ctb_y = ps_slice_hdr->i2_ctb_y;
 }
 }
 else
 {
        ps_slice_hdr->i2_ctb_x = 0;
        ps_slice_hdr->i2_ctb_y = 0;

        ps_slice_hdr->i2_independent_ctb_x = 0;
        ps_slice_hdr->i2_independent_ctb_y = 0;
 }

 /* If the first slice in the pic is missing, copy the current slice header to
     * the first slice's header */
 if((!first_slice_in_pic_flag) &&
 (0 == ps_codec->i4_pic_present))
 {

         slice_header_t *ps_slice_hdr_prev = ps_codec->s_parse.ps_slice_hdr_base;
         ihevcd_copy_slice_hdr(ps_codec, 0, (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)));
 
        prev_slice_incomplete_flag = 1;
        ASSERT(ps_codec->s_parse.i4_cur_slice_idx == 1);
 
         ps_slice_hdr_prev->i2_ctb_x = 0;
         ps_slice_hdr_prev->i2_ctb_y = 0;

        ps_codec->s_parse.i4_ctb_x = 0;
        ps_codec->s_parse.i4_ctb_y = 0;

        ps_codec->s_parse.i4_cur_slice_idx = 0;

 if((ps_slice_hdr->i2_ctb_x == 0) &&
 (ps_slice_hdr->i2_ctb_y == 0))
 {
            ps_slice_hdr->i2_ctb_x++;
 }
 }

 {
 /* If skip B is enabled,
         * ignore pictures that are non-reference
         * TODO: (i1_nal_unit_type < NAL_BLA_W_LP) && (i1_nal_unit_type % 2 == 0) only says it is
         * sub-layer non-reference slice. May need to find a way to detect actual non-reference pictures*/

 if((i1_nal_unit_type < NAL_BLA_W_LP) &&
 (i1_nal_unit_type % 2 == 0))
 {
 if(IVD_SKIP_B == ps_codec->e_pic_skip_mode)
 return IHEVCD_IGNORE_SLICE;
 }

 /* If skip PB is enabled,
         * decode only I slices */
 if((IVD_SKIP_PB == ps_codec->e_pic_skip_mode) &&
 (ISLICE != ps_slice_hdr->i1_slice_type))
 {
 return IHEVCD_IGNORE_SLICE;

         }
     }
 
    if(prev_slice_incomplete_flag)
    {
        ps_codec->i4_slice_error = 1;
        ps_codec->s_parse.i4_cur_slice_idx--;
        if(ps_codec->s_parse.i4_cur_slice_idx < 0)
            ps_codec->s_parse.i4_cur_slice_idx = 0;
    }

     return ret;
 }
","IHEVCD_ERROR_T ihevcd_parse_slice_header(codec_t *ps_codec,
 nal_header_t *ps_nal)
{
    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
    WORD32 value;
    WORD32 i, j;
    WORD32 sps_id;

 pps_t *ps_pps;
 sps_t *ps_sps;
 slice_header_t *ps_slice_hdr;
    WORD32 disable_deblocking_filter_flag;
 bitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;
    WORD32 idr_pic_flag;
    WORD32 pps_id;
    WORD32 first_slice_in_pic_flag;
    WORD32 no_output_of_prior_pics_flag = 0;

     WORD8 i1_nal_unit_type = ps_nal->i1_nal_unit_type;
     WORD32 num_poc_total_curr = 0;
     WORD32 slice_address;
 
     if(ps_codec->i4_slice_error == 1)
         return ret;

    idr_pic_flag = (NAL_IDR_W_LP == i1_nal_unit_type) ||
 (NAL_IDR_N_LP == i1_nal_unit_type);


    BITS_PARSE(""first_slice_in_pic_flag"", first_slice_in_pic_flag, ps_bitstrm, 1);
 if((NAL_BLA_W_LP <= i1_nal_unit_type) &&
 (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))
 {
        BITS_PARSE(""no_output_of_prior_pics_flag"", no_output_of_prior_pics_flag, ps_bitstrm, 1);
 }
    UEV_PARSE(""pic_parameter_set_id"", pps_id, ps_bitstrm);
    pps_id = CLIP3(pps_id, 0, MAX_PPS_CNT - 2);

 /* Get the current PPS structure */
    ps_pps = ps_codec->s_parse.ps_pps_base + pps_id;
 if(0 == ps_pps->i1_pps_valid)
 {
 pps_t *ps_pps_ref = ps_codec->ps_pps_base;
 while(0 == ps_pps_ref->i1_pps_valid)
 {
            ps_pps_ref++;
 if((ps_pps_ref - ps_codec->ps_pps_base >= MAX_PPS_CNT - 1))
 return IHEVCD_INVALID_HEADER;
 }

        ihevcd_copy_pps(ps_codec, pps_id, ps_pps_ref->i1_pps_id);
 }

 /* Get SPS id for the current PPS */
    sps_id = ps_pps->i1_sps_id;

 /* Get the current SPS structure */
    ps_sps = ps_codec->s_parse.ps_sps_base + sps_id;

 /* When the current slice is the first in a pic,
     *  check whether the previous frame is complete
     *  If the previous frame is incomplete -
     *  treat the remaining CTBs as skip */
 if((0 != ps_codec->u4_pic_cnt || ps_codec->i4_pic_present) &&
                    first_slice_in_pic_flag)
 {
 if(ps_codec->i4_pic_present)
 {
 slice_header_t *ps_slice_hdr_next;
            ps_codec->i4_slice_error = 1;
            ps_codec->s_parse.i4_cur_slice_idx--;
 if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                ps_codec->s_parse.i4_cur_slice_idx = 0;

            ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
            ps_slice_hdr_next->i2_ctb_x = 0;
            ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;
 return ret;
 }
 else
 {
            ps_codec->i4_slice_error = 0;
 }
 }

 if(first_slice_in_pic_flag)
 {
        ps_codec->s_parse.i4_cur_slice_idx = 0;
 }
 else
 {
 /* If the current slice is not the first slice in the pic,
         * but the first one to be parsed, set the current slice indx to 1
         * Treat the first slice to be missing and copy the current slice header
         * to the first one */
 if(0 == ps_codec->i4_pic_present)
            ps_codec->s_parse.i4_cur_slice_idx = 1;
 }

    ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));


 if((ps_pps->i1_dependent_slice_enabled_flag) &&
 (!first_slice_in_pic_flag))
 {
        BITS_PARSE(""dependent_slice_flag"", value, ps_bitstrm, 1);

 /* If dependendent slice, copy slice header from previous slice */
 if(value && (ps_codec->s_parse.i4_cur_slice_idx > 0))
 {
            ihevcd_copy_slice_hdr(ps_codec,
 (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)),
 ((ps_codec->s_parse.i4_cur_slice_idx - 1) & (MAX_SLICE_HDR_CNT - 1)));
 }
        ps_slice_hdr->i1_dependent_slice_flag = value;
 }
 else
 {
        ps_slice_hdr->i1_dependent_slice_flag = 0;
 }
    ps_slice_hdr->i1_nal_unit_type = i1_nal_unit_type;
    ps_slice_hdr->i1_pps_id = pps_id;
    ps_slice_hdr->i1_first_slice_in_pic_flag = first_slice_in_pic_flag;

    ps_slice_hdr->i1_no_output_of_prior_pics_flag = 1;
 if((NAL_BLA_W_LP <= i1_nal_unit_type) &&
 (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))
 {
        ps_slice_hdr->i1_no_output_of_prior_pics_flag = no_output_of_prior_pics_flag;
 }
    ps_slice_hdr->i1_pps_id = pps_id;

 if(!ps_slice_hdr->i1_first_slice_in_pic_flag)
 {
        WORD32 num_bits;

 /* Use CLZ to compute Ceil( Log2( PicSizeInCtbsY ) ) */
        num_bits = 32 - CLZ(ps_sps->i4_pic_size_in_ctb - 1);
        BITS_PARSE(""slice_address"", value, ps_bitstrm, num_bits);

        slice_address = value;
 /* If slice address is greater than the number of CTBs in a picture,
         * ignore the slice */
 if(value >= ps_sps->i4_pic_size_in_ctb)
 return IHEVCD_IGNORE_SLICE;
 }
 else
 {
        slice_address = 0;
 }

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
        ps_slice_hdr->i1_pic_output_flag = 1;
        ps_slice_hdr->i4_pic_order_cnt_lsb = 0;
        ps_slice_hdr->i1_num_long_term_sps = 0;
        ps_slice_hdr->i1_num_long_term_pics = 0;

 for(i = 0; i < ps_pps->i1_num_extra_slice_header_bits; i++)
 {
            BITS_PARSE(""slice_reserved_undetermined_flag[ i ]"", value, ps_bitstrm, 1);
 }
        UEV_PARSE(""slice_type"", value, ps_bitstrm);
        ps_slice_hdr->i1_slice_type = value;

 /* If the picture is IRAP, slice type must be equal to ISLICE */
 if((ps_slice_hdr->i1_nal_unit_type >= NAL_BLA_W_LP) &&
 (ps_slice_hdr->i1_nal_unit_type <= NAL_RSV_RAP_VCL23))
            ps_slice_hdr->i1_slice_type = ISLICE;

 if((ps_slice_hdr->i1_slice_type < 0) ||
 (ps_slice_hdr->i1_slice_type > 2))
 return IHEVCD_IGNORE_SLICE;

 if(ps_pps->i1_output_flag_present_flag)
 {
            BITS_PARSE(""pic_output_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_pic_output_flag = value;
 }
        ps_slice_hdr->i1_colour_plane_id = 0;
 if(1 == ps_sps->i1_separate_colour_plane_flag)
 {
            BITS_PARSE(""colour_plane_id"", value, ps_bitstrm, 2);
            ps_slice_hdr->i1_colour_plane_id = value;
 }
        ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = 0;

 if(!idr_pic_flag)
 {

            WORD32 st_rps_idx;
            WORD32 num_neg_pics;
            WORD32 num_pos_pics;
            WORD8 *pi1_used;

            BITS_PARSE(""pic_order_cnt_lsb"", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);
            ps_slice_hdr->i4_pic_order_cnt_lsb = value;

            BITS_PARSE(""short_term_ref_pic_set_sps_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag = value;

 if(1 == ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag)
 {
                WORD32 numbits;

                ps_slice_hdr->i1_short_term_ref_pic_set_idx = 0;
 if(ps_sps->i1_num_short_term_ref_pic_sets > 1)
 {
                    numbits = 32 - CLZ(ps_sps->i1_num_short_term_ref_pic_sets - 1);
                    BITS_PARSE(""short_term_ref_pic_set_idx"", value, ps_bitstrm, numbits);
                    ps_slice_hdr->i1_short_term_ref_pic_set_idx = value;
 }

                st_rps_idx = ps_slice_hdr->i1_short_term_ref_pic_set_idx;
                num_neg_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_neg_pics;
                num_pos_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_pos_pics;
                pi1_used = ps_sps->as_stref_picset[st_rps_idx].ai1_used;
 }
 else
 {
                ihevcd_short_term_ref_pic_set(ps_bitstrm,
 &ps_sps->as_stref_picset[0],
                                              ps_sps->i1_num_short_term_ref_pic_sets,
                                              ps_sps->i1_num_short_term_ref_pic_sets,
 &ps_slice_hdr->s_stref_picset);

                st_rps_idx = ps_sps->i1_num_short_term_ref_pic_sets;
                num_neg_pics = ps_slice_hdr->s_stref_picset.i1_num_neg_pics;
                num_pos_pics = ps_slice_hdr->s_stref_picset.i1_num_pos_pics;
                pi1_used = ps_slice_hdr->s_stref_picset.ai1_used;
 }

 if(ps_sps->i1_long_term_ref_pics_present_flag)
 {
 if(ps_sps->i1_num_long_term_ref_pics_sps > 0)
 {
                    UEV_PARSE(""num_long_term_sps"", value, ps_bitstrm);
                    ps_slice_hdr->i1_num_long_term_sps = value;

                    ps_slice_hdr->i1_num_long_term_sps = CLIP3(ps_slice_hdr->i1_num_long_term_sps,
 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics);
 }
                UEV_PARSE(""num_long_term_pics"", value, ps_bitstrm);
                ps_slice_hdr->i1_num_long_term_pics = value;
                ps_slice_hdr->i1_num_long_term_pics = CLIP3(ps_slice_hdr->i1_num_long_term_pics,
 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics -
                                                            ps_slice_hdr->i1_num_long_term_sps);

 for(i = 0; i < (ps_slice_hdr->i1_num_long_term_sps +
                                ps_slice_hdr->i1_num_long_term_pics); i++)
 {
 if(i < ps_slice_hdr->i1_num_long_term_sps)
 {
 /* Use CLZ to compute Ceil( Log2( num_long_term_ref_pics_sps ) ) */
 if (ps_sps->i1_num_long_term_ref_pics_sps > 1)
 {
                            WORD32 num_bits = 32 - CLZ(ps_sps->i1_num_long_term_ref_pics_sps - 1);
                            BITS_PARSE(""lt_idx_sps[ i ]"", value, ps_bitstrm, num_bits);
 }
 else
 {
                            value = 0;
 }
                        ps_slice_hdr->ai4_poc_lsb_lt[i] = ps_sps->au2_lt_ref_pic_poc_lsb_sps[value];
                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = ps_sps->ai1_used_by_curr_pic_lt_sps_flag[value];

 }
 else
 {
                        BITS_PARSE(""poc_lsb_lt[ i ]"", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);
                        ps_slice_hdr->ai4_poc_lsb_lt[i] = value;

                        BITS_PARSE(""used_by_curr_pic_lt_flag[ i ]"", value, ps_bitstrm, 1);
                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = value;

 }
                    BITS_PARSE(""delta_poc_msb_present_flag[ i ]"", value, ps_bitstrm, 1);
                    ps_slice_hdr->ai1_delta_poc_msb_present_flag[i] = value;


                    ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = 0;
 if(ps_slice_hdr->ai1_delta_poc_msb_present_flag[i])
 {

                        UEV_PARSE(""delata_poc_msb_cycle_lt[ i ]"", value, ps_bitstrm);
                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = value;
 }

 if((i != 0) && (i != ps_slice_hdr->i1_num_long_term_sps))
 {
                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] += ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i - 1];
 }

 }
 }

 for(i = 0; i < num_neg_pics + num_pos_pics; i++)
 {
 if(pi1_used[i])
 {
                    num_poc_total_curr++;
 }
 }
 for(i = 0; i < ps_slice_hdr->i1_num_long_term_sps + ps_slice_hdr->i1_num_long_term_pics; i++)
 {
 if(ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i])
 {
                    num_poc_total_curr++;
 }
 }


 if(ps_sps->i1_sps_temporal_mvp_enable_flag)
 {
                BITS_PARSE(""enable_temporal_mvp_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = value;
 }

 }
        ps_slice_hdr->i1_slice_sao_luma_flag = 0;
        ps_slice_hdr->i1_slice_sao_chroma_flag = 0;
 if(ps_sps->i1_sample_adaptive_offset_enabled_flag)
 {
            BITS_PARSE(""slice_sao_luma_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_slice_sao_luma_flag = value;

            BITS_PARSE(""slice_sao_chroma_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_slice_sao_chroma_flag = value;

 }

        ps_slice_hdr->i1_max_num_merge_cand = 1;
        ps_slice_hdr->i1_cabac_init_flag = 0;

        ps_slice_hdr->i1_num_ref_idx_l0_active = 0;
        ps_slice_hdr->i1_num_ref_idx_l1_active = 0;
        ps_slice_hdr->i1_slice_cb_qp_offset = 0;
        ps_slice_hdr->i1_slice_cr_qp_offset = 0;
 if((PSLICE == ps_slice_hdr->i1_slice_type) ||
 (BSLICE == ps_slice_hdr->i1_slice_type))
 {
            BITS_PARSE(""num_ref_idx_active_override_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_num_ref_idx_active_override_flag = value;

 if(ps_slice_hdr->i1_num_ref_idx_active_override_flag)
 {
                UEV_PARSE(""num_ref_idx_l0_active_minus1"", value, ps_bitstrm);
                ps_slice_hdr->i1_num_ref_idx_l0_active = value + 1;

 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                    UEV_PARSE(""num_ref_idx_l1_active_minus1"", value, ps_bitstrm);
                    ps_slice_hdr->i1_num_ref_idx_l1_active = value + 1;
 }

 }
 else
 {
                ps_slice_hdr->i1_num_ref_idx_l0_active = ps_pps->i1_num_ref_idx_l0_default_active;

 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                    ps_slice_hdr->i1_num_ref_idx_l1_active = ps_pps->i1_num_ref_idx_l1_default_active;
 }
 }

            ps_slice_hdr->i1_num_ref_idx_l0_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l0_active, 0, MAX_DPB_SIZE - 1);
            ps_slice_hdr->i1_num_ref_idx_l1_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l1_active, 0, MAX_DPB_SIZE - 1);

 if(0 == num_poc_total_curr)
 return IHEVCD_IGNORE_SLICE;
 if((ps_pps->i1_lists_modification_present_flag) && (num_poc_total_curr > 1))
 {
                ihevcd_ref_pic_list_modification(ps_bitstrm,
                                                 ps_slice_hdr, num_poc_total_curr);
 }
 else
 {
                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l0 = 0;
                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l1 = 0;
 }

 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                BITS_PARSE(""mvd_l1_zero_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_mvd_l1_zero_flag = value;
 }

            ps_slice_hdr->i1_cabac_init_flag = 0;
 if(ps_pps->i1_cabac_init_present_flag)
 {
                BITS_PARSE(""cabac_init_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_cabac_init_flag = value;

 }
            ps_slice_hdr->i1_collocated_from_l0_flag = 1;
            ps_slice_hdr->i1_collocated_ref_idx = 0;
 if(ps_slice_hdr->i1_slice_temporal_mvp_enable_flag)
 {
 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                    BITS_PARSE(""collocated_from_l0_flag"", value, ps_bitstrm, 1);
                    ps_slice_hdr->i1_collocated_from_l0_flag = value;
 }

 if((ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l0_active > 1)) ||
 (!ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l1_active > 1)))
 {
                    UEV_PARSE(""collocated_ref_idx"", value, ps_bitstrm);
                    ps_slice_hdr->i1_collocated_ref_idx = value;
 }

 }
            ps_slice_hdr->i1_collocated_ref_idx = CLIP3(ps_slice_hdr->i1_collocated_ref_idx, 0, MAX_DPB_SIZE - 1);

 if((ps_pps->i1_weighted_pred_flag  && (PSLICE == ps_slice_hdr->i1_slice_type)) ||
 (ps_pps->i1_weighted_bipred_flag  && (BSLICE == ps_slice_hdr->i1_slice_type)))
 {
                ihevcd_parse_pred_wt_ofst(ps_bitstrm, ps_sps, ps_pps, ps_slice_hdr);
 }
            UEV_PARSE(""five_minus_max_num_merge_cand"", value, ps_bitstrm);
            ps_slice_hdr->i1_max_num_merge_cand = 5 - value;

 }
        ps_slice_hdr->i1_max_num_merge_cand = CLIP3(ps_slice_hdr->i1_max_num_merge_cand, 1, 5);
        SEV_PARSE(""slice_qp_delta"", value, ps_bitstrm);
        ps_slice_hdr->i1_slice_qp_delta = value;

 if(ps_pps->i1_pic_slice_level_chroma_qp_offsets_present_flag)
 {
            SEV_PARSE(""slice_cb_qp_offset"", value, ps_bitstrm);
            ps_slice_hdr->i1_slice_cb_qp_offset = value;

            SEV_PARSE(""slice_cr_qp_offset"", value, ps_bitstrm);
            ps_slice_hdr->i1_slice_cr_qp_offset = value;

 }
        ps_slice_hdr->i1_deblocking_filter_override_flag = 0;
        ps_slice_hdr->i1_slice_disable_deblocking_filter_flag  = ps_pps->i1_pic_disable_deblocking_filter_flag;
        ps_slice_hdr->i1_beta_offset_div2 = ps_pps->i1_beta_offset_div2;
        ps_slice_hdr->i1_tc_offset_div2 = ps_pps->i1_tc_offset_div2;

        disable_deblocking_filter_flag = ps_pps->i1_pic_disable_deblocking_filter_flag;

 if(ps_pps->i1_deblocking_filter_control_present_flag)
 {

 if(ps_pps->i1_deblocking_filter_override_enabled_flag)
 {
                BITS_PARSE(""deblocking_filter_override_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_deblocking_filter_override_flag = value;
 }

 if(ps_slice_hdr->i1_deblocking_filter_override_flag)
 {
                BITS_PARSE(""slice_disable_deblocking_filter_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_slice_disable_deblocking_filter_flag = value;
                disable_deblocking_filter_flag = ps_slice_hdr->i1_slice_disable_deblocking_filter_flag;

 if(!ps_slice_hdr->i1_slice_disable_deblocking_filter_flag)
 {
                    SEV_PARSE(""beta_offset_div2"", value, ps_bitstrm);
                    ps_slice_hdr->i1_beta_offset_div2 = value;

                    SEV_PARSE(""tc_offset_div2"", value, ps_bitstrm);
                    ps_slice_hdr->i1_tc_offset_div2 = value;

 }
 }
 }

        ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = ps_pps->i1_loop_filter_across_slices_enabled_flag;
 if(ps_pps->i1_loop_filter_across_slices_enabled_flag  &&
 (ps_slice_hdr->i1_slice_sao_luma_flag  ||  ps_slice_hdr->i1_slice_sao_chroma_flag  || !disable_deblocking_filter_flag))
 {
            BITS_PARSE(""slice_loop_filter_across_slices_enabled_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = value;
 }

 }

 /* Check sanity of slice */
 if((!first_slice_in_pic_flag) &&
 (ps_codec->i4_pic_present))
 {
 slice_header_t *ps_slice_hdr_base = ps_codec->ps_slice_hdr_base;


 /* According to the standard, the above conditions must be satisfied - But for error resilience,
         * only the following conditions are checked */
 if((ps_slice_hdr_base->i1_pps_id != ps_slice_hdr->i1_pps_id) ||
 (ps_slice_hdr_base->i4_pic_order_cnt_lsb != ps_slice_hdr->i4_pic_order_cnt_lsb))
 {
 return IHEVCD_IGNORE_SLICE;
 }

 }


 if(0 == ps_codec->i4_pic_present)
 {
        ps_slice_hdr->i4_abs_pic_order_cnt = ihevcd_calc_poc(ps_codec, ps_nal, ps_sps->i1_log2_max_pic_order_cnt_lsb, ps_slice_hdr->i4_pic_order_cnt_lsb);
 }
 else
 {
        ps_slice_hdr->i4_abs_pic_order_cnt = ps_codec->s_parse.i4_abs_pic_order_cnt;
 }


 if(!first_slice_in_pic_flag)
 {
 /* Check if the current slice belongs to the same pic (Pic being parsed) */
 if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)
 {

 /* If the Next CTB's index is less than the slice address,
             * the previous slice is incomplete.
             * Indicate slice error, and treat the remaining CTBs as skip */
 if(slice_address > ps_codec->s_parse.i4_next_ctb_indx)

             {
                 if(ps_codec->i4_pic_present)
                 {
                    slice_header_t *ps_slice_hdr_next;
                    ps_codec->i4_slice_error = 1;
                    ps_codec->s_parse.i4_cur_slice_idx--;
                    if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                        ps_codec->s_parse.i4_cur_slice_idx = 0;
                    ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
                    ps_slice_hdr_next->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;
                    ps_slice_hdr_next->i2_ctb_y = slice_address / ps_sps->i2_pic_wd_in_ctb;
                    return ret;
                 }
                 else
                 {
 return IHEVCD_IGNORE_SLICE;
 }
 }
 /* If the slice address is less than the next CTB's index,
             * extra CTBs have been decoded in the previous slice.
             * Ignore the current slice. Treat it as incomplete */
 else if(slice_address < ps_codec->s_parse.i4_next_ctb_indx)
 {
 return IHEVCD_IGNORE_SLICE;
 }
 else
 {
                ps_codec->i4_slice_error = 0;
 }
 }

 /* The current slice does not belong to the pic that is being parsed */
 else
 {
 /* The previous pic is incomplete.
             * Treat the remaining CTBs as skip */
 if(ps_codec->i4_pic_present)
 {
 slice_header_t *ps_slice_hdr_next;
                ps_codec->i4_slice_error = 1;
                ps_codec->s_parse.i4_cur_slice_idx--;
 if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                    ps_codec->s_parse.i4_cur_slice_idx = 0;

                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
                ps_slice_hdr_next->i2_ctb_x = 0;
                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;
 return ret;
 }

 /* If the previous pic is complete,
             * return if the current slice is dependant
             * otherwise, update the parse context's POC */
 else
 {
 if(ps_slice_hdr->i1_dependent_slice_flag)
 return IHEVCD_IGNORE_SLICE;

                ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;
 }
 }
 }

 /* If the slice is the first slice in the pic, update the parse context's POC */
 else
 {
 /* If the first slice is repeated, ignore the second occurrence
         * If any other slice is repeated, the CTB addr will be greater than the slice addr,
         * and hence the second occurrence is ignored */
 if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)
 return IHEVCD_IGNORE_SLICE;

        ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;
 }

    ps_slice_hdr->i4_num_entry_point_offsets = 0;
 if((ps_pps->i1_tiles_enabled_flag) ||
 (ps_pps->i1_entropy_coding_sync_enabled_flag))
 {
        UEV_PARSE(""num_entry_point_offsets"", value, ps_bitstrm);
        ps_slice_hdr->i4_num_entry_point_offsets = value;

 {
            WORD32 max_num_entry_point_offsets;
 if((ps_pps->i1_tiles_enabled_flag) &&
 (ps_pps->i1_entropy_coding_sync_enabled_flag))
 {
                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * (ps_sps->i2_pic_ht_in_ctb - 1);
 }
 else if(ps_pps->i1_tiles_enabled_flag)
 {
                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * ps_pps->i1_num_tile_rows;
 }
 else
 {
                max_num_entry_point_offsets = (ps_sps->i2_pic_ht_in_ctb - 1);
 }

            ps_slice_hdr->i4_num_entry_point_offsets = CLIP3(ps_slice_hdr->i4_num_entry_point_offsets,
 0, max_num_entry_point_offsets);
 }

 if(ps_slice_hdr->i4_num_entry_point_offsets > 0)
 {
            UEV_PARSE(""offset_len_minus1"", value, ps_bitstrm);
            ps_slice_hdr->i1_offset_len = value + 1;

 for(i = 0; i < ps_slice_hdr->i4_num_entry_point_offsets; i++)
 {
                BITS_PARSE(""entry_point_offset"", value, ps_bitstrm, ps_slice_hdr->i1_offset_len);

 /* TODO: pu4_entry_point_offset needs to be initialized */
 }

 }
 }

 if(ps_pps->i1_slice_header_extension_present_flag)
 {
        UEV_PARSE(""slice_header_extension_length"", value, ps_bitstrm);
        ps_slice_hdr->i2_slice_header_extension_length = value;


 for(i = 0; i < ps_slice_hdr->i2_slice_header_extension_length; i++)
 {
            BITS_PARSE(""slice_header_extension_data_byte"", value, ps_bitstrm, 8);
 }

 }

    ihevcd_bits_flush_to_byte_boundary(ps_bitstrm);

 if((UWORD8 *)ps_bitstrm->pu4_buf > ps_bitstrm->pu1_buf_max)
 return IHEVCD_INVALID_PARAMETER;

 {
 dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;
        WORD32 r_idx;

 if((NAL_IDR_W_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_IDR_N_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_BLA_N_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_BLA_W_DLP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_BLA_W_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (0 == ps_codec->u4_pic_cnt))
 {
 for(i = 0; i < MAX_DPB_BUFS; i++)
 {
 if(ps_dpb_mgr->as_dpb_info[i].ps_pic_buf)
 {
 pic_buf_t *ps_pic_buf = ps_dpb_mgr->as_dpb_info[i].ps_pic_buf;
 mv_buf_t *ps_mv_buf;

 /* Long term index is set to MAX_DPB_BUFS to ensure it is not added as LT */
                    ihevc_dpb_mgr_del_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr, (buf_mgr_t *)ps_codec->pv_pic_buf_mgr, ps_pic_buf->i4_abs_poc);
 /* Find buffer id of the MV bank corresponding to the buffer being freed (Buffer with POC of u4_abs_poc) */
                    ps_mv_buf = (mv_buf_t *)ps_codec->ps_mv_buf;
 for(j = 0; j < ps_codec->i4_max_dpb_size; j++)
 {
 if(ps_mv_buf && ps_mv_buf->i4_abs_poc == ps_pic_buf->i4_abs_poc)
 {
                            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_mv_buf_mgr, j, BUF_MGR_REF);
 break;
 }
                        ps_mv_buf++;
 }

 }

 }

 /* Initialize the reference lists to NULL
             * This is done to take care of the cases where the first pic is not IDR
             * but the reference list is not created for the first pic because
             * pic count is zero leaving the reference list uninitialised  */
 for(r_idx = 0; r_idx < MAX_DPB_SIZE; r_idx++)
 {
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = NULL;
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = NULL;

                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = NULL;
                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = NULL;
 }

 }
 else
 {
            ret = ihevcd_ref_list(ps_codec, ps_pps, ps_sps, ps_slice_hdr);
 if ((WORD32)IHEVCD_SUCCESS != ret)
 {
 return ret;
 }

 }

 }

 /* Fill the remaining entries of the reference lists with the nearest POC
     * This is done to handle cases where there is a corruption in the reference index */
 if(ps_codec->i4_pic_present)
 {
 pic_buf_t *ps_pic_buf_ref;
 mv_buf_t *ps_mv_buf_ref;
        WORD32 r_idx;
 dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;
 buf_mgr_t *ps_mv_buf_mgr = (buf_mgr_t *)ps_codec->pv_mv_buf_mgr;

        ps_pic_buf_ref = ihevc_dpb_mgr_get_ref_by_nearest_poc(ps_dpb_mgr, ps_slice_hdr->i4_abs_pic_order_cnt);
 if(NULL == ps_pic_buf_ref)
 {
            ps_pic_buf_ref = ps_codec->as_process[0].ps_cur_pic;
            ps_mv_buf_ref = ps_codec->s_parse.ps_cur_mv_buf;
 }
 else
 {
            ps_mv_buf_ref = ihevcd_mv_mgr_get_poc(ps_mv_buf_mgr, ps_pic_buf_ref->i4_abs_poc);
 }

 for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx++)
 {
 if(NULL == ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf)
 {
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }
 }

 for(r_idx = ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx < MAX_DPB_SIZE; r_idx++)
 {
            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }

 for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx++)
 {
 if(NULL == ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf)
 {
                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }
 }

 for(r_idx = ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx < MAX_DPB_SIZE; r_idx++)
 {
            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }
 }

 /* Update slice address in the header */
 if(!ps_slice_hdr->i1_first_slice_in_pic_flag)
 {
        ps_slice_hdr->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;
        ps_slice_hdr->i2_ctb_y = slice_address / ps_sps->i2_pic_wd_in_ctb;

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
            ps_slice_hdr->i2_independent_ctb_x = ps_slice_hdr->i2_ctb_x;
            ps_slice_hdr->i2_independent_ctb_y = ps_slice_hdr->i2_ctb_y;
 }
 }
 else
 {
        ps_slice_hdr->i2_ctb_x = 0;
        ps_slice_hdr->i2_ctb_y = 0;

        ps_slice_hdr->i2_independent_ctb_x = 0;
        ps_slice_hdr->i2_independent_ctb_y = 0;
 }

 /* If the first slice in the pic is missing, copy the current slice header to
     * the first slice's header */
 if((!first_slice_in_pic_flag) &&
 (0 == ps_codec->i4_pic_present))
 {

         slice_header_t *ps_slice_hdr_prev = ps_codec->s_parse.ps_slice_hdr_base;
         ihevcd_copy_slice_hdr(ps_codec, 0, (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)));
 
        ps_codec->i4_slice_error = 1;
 
         ps_slice_hdr_prev->i2_ctb_x = 0;
         ps_slice_hdr_prev->i2_ctb_y = 0;

        ps_codec->s_parse.i4_ctb_x = 0;
        ps_codec->s_parse.i4_ctb_y = 0;

        ps_codec->s_parse.i4_cur_slice_idx = 0;

 if((ps_slice_hdr->i2_ctb_x == 0) &&
 (ps_slice_hdr->i2_ctb_y == 0))
 {
            ps_slice_hdr->i2_ctb_x++;
 }
 }

 {
 /* If skip B is enabled,
         * ignore pictures that are non-reference
         * TODO: (i1_nal_unit_type < NAL_BLA_W_LP) && (i1_nal_unit_type % 2 == 0) only says it is
         * sub-layer non-reference slice. May need to find a way to detect actual non-reference pictures*/

 if((i1_nal_unit_type < NAL_BLA_W_LP) &&
 (i1_nal_unit_type % 2 == 0))
 {
 if(IVD_SKIP_B == ps_codec->e_pic_skip_mode)
 return IHEVCD_IGNORE_SLICE;
 }

 /* If skip PB is enabled,
         * decode only I slices */
 if((IVD_SKIP_PB == ps_codec->e_pic_skip_mode) &&
 (ISLICE != ps_slice_hdr->i1_slice_type))
 {
 return IHEVCD_IGNORE_SLICE;

         }
     }
 
     return ret;
 }
",C,"    WORD32 prev_slice_incomplete_flag = 0;
                    prev_slice_incomplete_flag = 1;
        prev_slice_incomplete_flag = 1;
        ASSERT(ps_codec->s_parse.i4_cur_slice_idx == 1);
    if(prev_slice_incomplete_flag)
    {
        ps_codec->i4_slice_error = 1;
        ps_codec->s_parse.i4_cur_slice_idx--;
        if(ps_codec->s_parse.i4_cur_slice_idx < 0)
            ps_codec->s_parse.i4_cur_slice_idx = 0;
    }

","                    slice_header_t *ps_slice_hdr_next;
                    ps_codec->i4_slice_error = 1;
                    ps_codec->s_parse.i4_cur_slice_idx--;
                    if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                        ps_codec->s_parse.i4_cur_slice_idx = 0;
                    ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
                    ps_slice_hdr_next->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;
                    ps_slice_hdr_next->i2_ctb_y = slice_address / ps_sps->i2_pic_wd_in_ctb;
                    return ret;
        ps_codec->i4_slice_error = 1;
",,"@@ -234,6 +234,7 @@

     WORD8 i1_nal_unit_type = ps_nal->i1_nal_unit_type;
     WORD32 num_poc_total_curr = 0;
     WORD32 slice_address;
+    WORD32 prev_slice_incomplete_flag = 0;
 
     if(ps_codec->i4_slice_error == 1)
         return ret;
@@ -737,16 +738,7 @@

             {
                 if(ps_codec->i4_pic_present)
                 {
-                    slice_header_t *ps_slice_hdr_next;
-                    ps_codec->i4_slice_error = 1;
-                    ps_codec->s_parse.i4_cur_slice_idx--;
-                    if(ps_codec->s_parse.i4_cur_slice_idx < 0)
-                        ps_codec->s_parse.i4_cur_slice_idx = 0;
-
-                    ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
-                    ps_slice_hdr_next->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;
-                    ps_slice_hdr_next->i2_ctb_y = slice_address / ps_sps->i2_pic_wd_in_ctb;
-                    return ret;
+                    prev_slice_incomplete_flag = 1;
                 }
                 else
                 {
@@ -1016,7 +1008,8 @@

         slice_header_t *ps_slice_hdr_prev = ps_codec->s_parse.ps_slice_hdr_base;
         ihevcd_copy_slice_hdr(ps_codec, 0, (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)));
 
-        ps_codec->i4_slice_error = 1;
+        prev_slice_incomplete_flag = 1;
+        ASSERT(ps_codec->s_parse.i4_cur_slice_idx == 1);
 
         ps_slice_hdr_prev->i2_ctb_x = 0;
         ps_slice_hdr_prev->i2_ctb_y = 0;
@@ -1055,5 +1048,13 @@

         }
     }
 
+    if(prev_slice_incomplete_flag)
+    {
+        ps_codec->i4_slice_error = 1;
+        ps_codec->s_parse.i4_cur_slice_idx--;
+        if(ps_codec->s_parse.i4_cur_slice_idx < 0)
+            ps_codec->s_parse.i4_cur_slice_idx = 0;
+    }
+
     return ret;
 }
",Android,https://android.googlesource.com/platform/external/libhevc/+/7c9be319a279654e55a6d757265f88c61a16a4d5/,https://android.googlesource.com/platform/external/libhevc/+/7c9be319a279654e55a6d757265f88c61a16a4d5%5E/,1,"IHEVCD_ERROR_T ihevcd_parse_slice_header(codec_t *ps_codec,
 nal_header_t *ps_nal)
{
    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
    WORD32 value;
    WORD32 i, j;
    WORD32 sps_id;

 pps_t *ps_pps;
 sps_t *ps_sps;
 slice_header_t *ps_slice_hdr;
    WORD32 disable_deblocking_filter_flag;
 bitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;
    WORD32 idr_pic_flag;
    WORD32 pps_id;
    WORD32 first_slice_in_pic_flag;
    WORD32 no_output_of_prior_pics_flag = 0;

     WORD8 i1_nal_unit_type = ps_nal->i1_nal_unit_type;
     WORD32 num_poc_total_curr = 0;
     WORD32 slice_address;
//fix_flaw_line_below:
//    WORD32 prev_slice_incomplete_flag = 0;
 
     if(ps_codec->i4_slice_error == 1)
         return ret;

    idr_pic_flag = (NAL_IDR_W_LP == i1_nal_unit_type) ||
 (NAL_IDR_N_LP == i1_nal_unit_type);


    BITS_PARSE(""first_slice_in_pic_flag"", first_slice_in_pic_flag, ps_bitstrm, 1);
 if((NAL_BLA_W_LP <= i1_nal_unit_type) &&
 (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))
 {
        BITS_PARSE(""no_output_of_prior_pics_flag"", no_output_of_prior_pics_flag, ps_bitstrm, 1);
 }
    UEV_PARSE(""pic_parameter_set_id"", pps_id, ps_bitstrm);
    pps_id = CLIP3(pps_id, 0, MAX_PPS_CNT - 2);

 /* Get the current PPS structure */
    ps_pps = ps_codec->s_parse.ps_pps_base + pps_id;
 if(0 == ps_pps->i1_pps_valid)
 {
 pps_t *ps_pps_ref = ps_codec->ps_pps_base;
 while(0 == ps_pps_ref->i1_pps_valid)
 {
            ps_pps_ref++;
 if((ps_pps_ref - ps_codec->ps_pps_base >= MAX_PPS_CNT - 1))
 return IHEVCD_INVALID_HEADER;
 }

        ihevcd_copy_pps(ps_codec, pps_id, ps_pps_ref->i1_pps_id);
 }

 /* Get SPS id for the current PPS */
    sps_id = ps_pps->i1_sps_id;

 /* Get the current SPS structure */
    ps_sps = ps_codec->s_parse.ps_sps_base + sps_id;

 /* When the current slice is the first in a pic,
     *  check whether the previous frame is complete
     *  If the previous frame is incomplete -
     *  treat the remaining CTBs as skip */
 if((0 != ps_codec->u4_pic_cnt || ps_codec->i4_pic_present) &&
                    first_slice_in_pic_flag)
 {
 if(ps_codec->i4_pic_present)
 {
 slice_header_t *ps_slice_hdr_next;
            ps_codec->i4_slice_error = 1;
            ps_codec->s_parse.i4_cur_slice_idx--;
 if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                ps_codec->s_parse.i4_cur_slice_idx = 0;

            ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
            ps_slice_hdr_next->i2_ctb_x = 0;
            ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;
 return ret;
 }
 else
 {
            ps_codec->i4_slice_error = 0;
 }
 }

 if(first_slice_in_pic_flag)
 {
        ps_codec->s_parse.i4_cur_slice_idx = 0;
 }
 else
 {
 /* If the current slice is not the first slice in the pic,
         * but the first one to be parsed, set the current slice indx to 1
         * Treat the first slice to be missing and copy the current slice header
         * to the first one */
 if(0 == ps_codec->i4_pic_present)
            ps_codec->s_parse.i4_cur_slice_idx = 1;
 }

    ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));


 if((ps_pps->i1_dependent_slice_enabled_flag) &&
 (!first_slice_in_pic_flag))
 {
        BITS_PARSE(""dependent_slice_flag"", value, ps_bitstrm, 1);

 /* If dependendent slice, copy slice header from previous slice */
 if(value && (ps_codec->s_parse.i4_cur_slice_idx > 0))
 {
            ihevcd_copy_slice_hdr(ps_codec,
 (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)),
 ((ps_codec->s_parse.i4_cur_slice_idx - 1) & (MAX_SLICE_HDR_CNT - 1)));
 }
        ps_slice_hdr->i1_dependent_slice_flag = value;
 }
 else
 {
        ps_slice_hdr->i1_dependent_slice_flag = 0;
 }
    ps_slice_hdr->i1_nal_unit_type = i1_nal_unit_type;
    ps_slice_hdr->i1_pps_id = pps_id;
    ps_slice_hdr->i1_first_slice_in_pic_flag = first_slice_in_pic_flag;

    ps_slice_hdr->i1_no_output_of_prior_pics_flag = 1;
 if((NAL_BLA_W_LP <= i1_nal_unit_type) &&
 (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))
 {
        ps_slice_hdr->i1_no_output_of_prior_pics_flag = no_output_of_prior_pics_flag;
 }
    ps_slice_hdr->i1_pps_id = pps_id;

 if(!ps_slice_hdr->i1_first_slice_in_pic_flag)
 {
        WORD32 num_bits;

 /* Use CLZ to compute Ceil( Log2( PicSizeInCtbsY ) ) */
        num_bits = 32 - CLZ(ps_sps->i4_pic_size_in_ctb - 1);
        BITS_PARSE(""slice_address"", value, ps_bitstrm, num_bits);

        slice_address = value;
 /* If slice address is greater than the number of CTBs in a picture,
         * ignore the slice */
 if(value >= ps_sps->i4_pic_size_in_ctb)
 return IHEVCD_IGNORE_SLICE;
 }
 else
 {
        slice_address = 0;
 }

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
        ps_slice_hdr->i1_pic_output_flag = 1;
        ps_slice_hdr->i4_pic_order_cnt_lsb = 0;
        ps_slice_hdr->i1_num_long_term_sps = 0;
        ps_slice_hdr->i1_num_long_term_pics = 0;

 for(i = 0; i < ps_pps->i1_num_extra_slice_header_bits; i++)
 {
            BITS_PARSE(""slice_reserved_undetermined_flag[ i ]"", value, ps_bitstrm, 1);
 //slice_reserved_undetermined_flag[ i ]
 }
        UEV_PARSE(""slice_type"", value, ps_bitstrm);
        ps_slice_hdr->i1_slice_type = value;

 /* If the picture is IRAP, slice type must be equal to ISLICE */
 if((ps_slice_hdr->i1_nal_unit_type >= NAL_BLA_W_LP) &&
 (ps_slice_hdr->i1_nal_unit_type <= NAL_RSV_RAP_VCL23))
            ps_slice_hdr->i1_slice_type = ISLICE;

 if((ps_slice_hdr->i1_slice_type < 0) ||
 (ps_slice_hdr->i1_slice_type > 2))
 return IHEVCD_IGNORE_SLICE;

 if(ps_pps->i1_output_flag_present_flag)
 {
            BITS_PARSE(""pic_output_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_pic_output_flag = value;
 }
        ps_slice_hdr->i1_colour_plane_id = 0;
 if(1 == ps_sps->i1_separate_colour_plane_flag)
 {
            BITS_PARSE(""colour_plane_id"", value, ps_bitstrm, 2);
            ps_slice_hdr->i1_colour_plane_id = value;
 }
        ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = 0;

 if(!idr_pic_flag)
 {

            WORD32 st_rps_idx;
            WORD32 num_neg_pics;
            WORD32 num_pos_pics;
            WORD8 *pi1_used;

            BITS_PARSE(""pic_order_cnt_lsb"", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);
 //value = ihevcd_extend_sign_bit(value, ps_sps->i1_log2_max_pic_order_cnt_lsb);
            ps_slice_hdr->i4_pic_order_cnt_lsb = value;

            BITS_PARSE(""short_term_ref_pic_set_sps_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag = value;

 if(1 == ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag)
 {
                WORD32 numbits;

                ps_slice_hdr->i1_short_term_ref_pic_set_idx = 0;
 if(ps_sps->i1_num_short_term_ref_pic_sets > 1)
 {
                    numbits = 32 - CLZ(ps_sps->i1_num_short_term_ref_pic_sets - 1);
                    BITS_PARSE(""short_term_ref_pic_set_idx"", value, ps_bitstrm, numbits);
                    ps_slice_hdr->i1_short_term_ref_pic_set_idx = value;
 }

                st_rps_idx = ps_slice_hdr->i1_short_term_ref_pic_set_idx;
                num_neg_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_neg_pics;
                num_pos_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_pos_pics;
                pi1_used = ps_sps->as_stref_picset[st_rps_idx].ai1_used;
 }
 else
 {
                ihevcd_short_term_ref_pic_set(ps_bitstrm,
 &ps_sps->as_stref_picset[0],
                                              ps_sps->i1_num_short_term_ref_pic_sets,
                                              ps_sps->i1_num_short_term_ref_pic_sets,
 &ps_slice_hdr->s_stref_picset);

                st_rps_idx = ps_sps->i1_num_short_term_ref_pic_sets;
                num_neg_pics = ps_slice_hdr->s_stref_picset.i1_num_neg_pics;
                num_pos_pics = ps_slice_hdr->s_stref_picset.i1_num_pos_pics;
                pi1_used = ps_slice_hdr->s_stref_picset.ai1_used;
 }

 if(ps_sps->i1_long_term_ref_pics_present_flag)
 {
 if(ps_sps->i1_num_long_term_ref_pics_sps > 0)
 {
                    UEV_PARSE(""num_long_term_sps"", value, ps_bitstrm);
                    ps_slice_hdr->i1_num_long_term_sps = value;

                    ps_slice_hdr->i1_num_long_term_sps = CLIP3(ps_slice_hdr->i1_num_long_term_sps,
 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics);
 }
                UEV_PARSE(""num_long_term_pics"", value, ps_bitstrm);
                ps_slice_hdr->i1_num_long_term_pics = value;
                ps_slice_hdr->i1_num_long_term_pics = CLIP3(ps_slice_hdr->i1_num_long_term_pics,
 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics -
                                                            ps_slice_hdr->i1_num_long_term_sps);

 for(i = 0; i < (ps_slice_hdr->i1_num_long_term_sps +
                                ps_slice_hdr->i1_num_long_term_pics); i++)
 {
 if(i < ps_slice_hdr->i1_num_long_term_sps)
 {
 /* Use CLZ to compute Ceil( Log2( num_long_term_ref_pics_sps ) ) */
 if (ps_sps->i1_num_long_term_ref_pics_sps > 1)
 {
                            WORD32 num_bits = 32 - CLZ(ps_sps->i1_num_long_term_ref_pics_sps - 1);
                            BITS_PARSE(""lt_idx_sps[ i ]"", value, ps_bitstrm, num_bits);
 }
 else
 {
                            value = 0;
 }
                        ps_slice_hdr->ai4_poc_lsb_lt[i] = ps_sps->au2_lt_ref_pic_poc_lsb_sps[value];
                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = ps_sps->ai1_used_by_curr_pic_lt_sps_flag[value];

 }
 else
 {
                        BITS_PARSE(""poc_lsb_lt[ i ]"", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);
                        ps_slice_hdr->ai4_poc_lsb_lt[i] = value;

                        BITS_PARSE(""used_by_curr_pic_lt_flag[ i ]"", value, ps_bitstrm, 1);
                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = value;

 }
                    BITS_PARSE(""delta_poc_msb_present_flag[ i ]"", value, ps_bitstrm, 1);
                    ps_slice_hdr->ai1_delta_poc_msb_present_flag[i] = value;


                    ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = 0;
 if(ps_slice_hdr->ai1_delta_poc_msb_present_flag[i])
 {

                        UEV_PARSE(""delata_poc_msb_cycle_lt[ i ]"", value, ps_bitstrm);
                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = value;
 }

 if((i != 0) && (i != ps_slice_hdr->i1_num_long_term_sps))
 {
                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] += ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i - 1];
 }

 }
 }

 for(i = 0; i < num_neg_pics + num_pos_pics; i++)
 {
 if(pi1_used[i])
 {
                    num_poc_total_curr++;
 }
 }
 for(i = 0; i < ps_slice_hdr->i1_num_long_term_sps + ps_slice_hdr->i1_num_long_term_pics; i++)
 {
 if(ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i])
 {
                    num_poc_total_curr++;
 }
 }


 if(ps_sps->i1_sps_temporal_mvp_enable_flag)
 {
                BITS_PARSE(""enable_temporal_mvp_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = value;
 }

 }
        ps_slice_hdr->i1_slice_sao_luma_flag = 0;
        ps_slice_hdr->i1_slice_sao_chroma_flag = 0;
 if(ps_sps->i1_sample_adaptive_offset_enabled_flag)
 {
            BITS_PARSE(""slice_sao_luma_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_slice_sao_luma_flag = value;

            BITS_PARSE(""slice_sao_chroma_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_slice_sao_chroma_flag = value;

 }

        ps_slice_hdr->i1_max_num_merge_cand = 1;
        ps_slice_hdr->i1_cabac_init_flag = 0;

        ps_slice_hdr->i1_num_ref_idx_l0_active = 0;
        ps_slice_hdr->i1_num_ref_idx_l1_active = 0;
        ps_slice_hdr->i1_slice_cb_qp_offset = 0;
        ps_slice_hdr->i1_slice_cr_qp_offset = 0;
 if((PSLICE == ps_slice_hdr->i1_slice_type) ||
 (BSLICE == ps_slice_hdr->i1_slice_type))
 {
            BITS_PARSE(""num_ref_idx_active_override_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_num_ref_idx_active_override_flag = value;

 if(ps_slice_hdr->i1_num_ref_idx_active_override_flag)
 {
                UEV_PARSE(""num_ref_idx_l0_active_minus1"", value, ps_bitstrm);
                ps_slice_hdr->i1_num_ref_idx_l0_active = value + 1;

 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                    UEV_PARSE(""num_ref_idx_l1_active_minus1"", value, ps_bitstrm);
                    ps_slice_hdr->i1_num_ref_idx_l1_active = value + 1;
 }

 }
 else
 {
                ps_slice_hdr->i1_num_ref_idx_l0_active = ps_pps->i1_num_ref_idx_l0_default_active;

 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                    ps_slice_hdr->i1_num_ref_idx_l1_active = ps_pps->i1_num_ref_idx_l1_default_active;
 }
 }

            ps_slice_hdr->i1_num_ref_idx_l0_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l0_active, 0, MAX_DPB_SIZE - 1);
            ps_slice_hdr->i1_num_ref_idx_l1_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l1_active, 0, MAX_DPB_SIZE - 1);

 if(0 == num_poc_total_curr)
 return IHEVCD_IGNORE_SLICE;
 if((ps_pps->i1_lists_modification_present_flag) && (num_poc_total_curr > 1))
 {
                ihevcd_ref_pic_list_modification(ps_bitstrm,
                                                 ps_slice_hdr, num_poc_total_curr);
 }
 else
 {
                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l0 = 0;
                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l1 = 0;
 }

 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                BITS_PARSE(""mvd_l1_zero_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_mvd_l1_zero_flag = value;
 }

            ps_slice_hdr->i1_cabac_init_flag = 0;
 if(ps_pps->i1_cabac_init_present_flag)
 {
                BITS_PARSE(""cabac_init_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_cabac_init_flag = value;

 }
            ps_slice_hdr->i1_collocated_from_l0_flag = 1;
            ps_slice_hdr->i1_collocated_ref_idx = 0;
 if(ps_slice_hdr->i1_slice_temporal_mvp_enable_flag)
 {
 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                    BITS_PARSE(""collocated_from_l0_flag"", value, ps_bitstrm, 1);
                    ps_slice_hdr->i1_collocated_from_l0_flag = value;
 }

 if((ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l0_active > 1)) ||
 (!ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l1_active > 1)))
 {
                    UEV_PARSE(""collocated_ref_idx"", value, ps_bitstrm);
                    ps_slice_hdr->i1_collocated_ref_idx = value;
 }

 }
            ps_slice_hdr->i1_collocated_ref_idx = CLIP3(ps_slice_hdr->i1_collocated_ref_idx, 0, MAX_DPB_SIZE - 1);

 if((ps_pps->i1_weighted_pred_flag  && (PSLICE == ps_slice_hdr->i1_slice_type)) ||
 (ps_pps->i1_weighted_bipred_flag  && (BSLICE == ps_slice_hdr->i1_slice_type)))
 {
                ihevcd_parse_pred_wt_ofst(ps_bitstrm, ps_sps, ps_pps, ps_slice_hdr);
 }
            UEV_PARSE(""five_minus_max_num_merge_cand"", value, ps_bitstrm);
            ps_slice_hdr->i1_max_num_merge_cand = 5 - value;

 }
        ps_slice_hdr->i1_max_num_merge_cand = CLIP3(ps_slice_hdr->i1_max_num_merge_cand, 1, 5);
        SEV_PARSE(""slice_qp_delta"", value, ps_bitstrm);
        ps_slice_hdr->i1_slice_qp_delta = value;

 if(ps_pps->i1_pic_slice_level_chroma_qp_offsets_present_flag)
 {
            SEV_PARSE(""slice_cb_qp_offset"", value, ps_bitstrm);
            ps_slice_hdr->i1_slice_cb_qp_offset = value;

            SEV_PARSE(""slice_cr_qp_offset"", value, ps_bitstrm);
            ps_slice_hdr->i1_slice_cr_qp_offset = value;

 }
        ps_slice_hdr->i1_deblocking_filter_override_flag = 0;
        ps_slice_hdr->i1_slice_disable_deblocking_filter_flag  = ps_pps->i1_pic_disable_deblocking_filter_flag;
        ps_slice_hdr->i1_beta_offset_div2 = ps_pps->i1_beta_offset_div2;
        ps_slice_hdr->i1_tc_offset_div2 = ps_pps->i1_tc_offset_div2;

        disable_deblocking_filter_flag = ps_pps->i1_pic_disable_deblocking_filter_flag;

 if(ps_pps->i1_deblocking_filter_control_present_flag)
 {

 if(ps_pps->i1_deblocking_filter_override_enabled_flag)
 {
                BITS_PARSE(""deblocking_filter_override_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_deblocking_filter_override_flag = value;
 }

 if(ps_slice_hdr->i1_deblocking_filter_override_flag)
 {
                BITS_PARSE(""slice_disable_deblocking_filter_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_slice_disable_deblocking_filter_flag = value;
                disable_deblocking_filter_flag = ps_slice_hdr->i1_slice_disable_deblocking_filter_flag;

 if(!ps_slice_hdr->i1_slice_disable_deblocking_filter_flag)
 {
                    SEV_PARSE(""beta_offset_div2"", value, ps_bitstrm);
                    ps_slice_hdr->i1_beta_offset_div2 = value;

                    SEV_PARSE(""tc_offset_div2"", value, ps_bitstrm);
                    ps_slice_hdr->i1_tc_offset_div2 = value;

 }
 }
 }

        ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = ps_pps->i1_loop_filter_across_slices_enabled_flag;
 if(ps_pps->i1_loop_filter_across_slices_enabled_flag  &&
 (ps_slice_hdr->i1_slice_sao_luma_flag  ||  ps_slice_hdr->i1_slice_sao_chroma_flag  || !disable_deblocking_filter_flag))
 {
            BITS_PARSE(""slice_loop_filter_across_slices_enabled_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = value;
 }

 }

 /* Check sanity of slice */
 if((!first_slice_in_pic_flag) &&
 (ps_codec->i4_pic_present))
 {
 slice_header_t *ps_slice_hdr_base = ps_codec->ps_slice_hdr_base;


 /* According to the standard, the above conditions must be satisfied - But for error resilience,
         * only the following conditions are checked */
 if((ps_slice_hdr_base->i1_pps_id != ps_slice_hdr->i1_pps_id) ||
 (ps_slice_hdr_base->i4_pic_order_cnt_lsb != ps_slice_hdr->i4_pic_order_cnt_lsb))
 {
 return IHEVCD_IGNORE_SLICE;
 }

 }


 if(0 == ps_codec->i4_pic_present)
 {
        ps_slice_hdr->i4_abs_pic_order_cnt = ihevcd_calc_poc(ps_codec, ps_nal, ps_sps->i1_log2_max_pic_order_cnt_lsb, ps_slice_hdr->i4_pic_order_cnt_lsb);
 }
 else
 {
        ps_slice_hdr->i4_abs_pic_order_cnt = ps_codec->s_parse.i4_abs_pic_order_cnt;
 }


 if(!first_slice_in_pic_flag)
 {
 /* Check if the current slice belongs to the same pic (Pic being parsed) */
 if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)
 {

 /* If the Next CTB's index is less than the slice address,
             * the previous slice is incomplete.
             * Indicate slice error, and treat the remaining CTBs as skip */
 if(slice_address > ps_codec->s_parse.i4_next_ctb_indx)

             {
                 if(ps_codec->i4_pic_present)
                 {
//flaw_line_below:
                    slice_header_t *ps_slice_hdr_next;
//flaw_line_below:
                    ps_codec->i4_slice_error = 1;
//flaw_line_below:
                    ps_codec->s_parse.i4_cur_slice_idx--;
//flaw_line_below:
                    if(ps_codec->s_parse.i4_cur_slice_idx < 0)
//flaw_line_below:
                        ps_codec->s_parse.i4_cur_slice_idx = 0;
//flaw_line_below:

//flaw_line_below:
                    ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
//flaw_line_below:
                    ps_slice_hdr_next->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;
//flaw_line_below:
                    ps_slice_hdr_next->i2_ctb_y = slice_address / ps_sps->i2_pic_wd_in_ctb;
//flaw_line_below:
                    return ret;
//fix_flaw_line_below:
//                    prev_slice_incomplete_flag = 1;
                 }
                 else
                 {
 return IHEVCD_IGNORE_SLICE;
 }
 }
 /* If the slice address is less than the next CTB's index,
             * extra CTBs have been decoded in the previous slice.
             * Ignore the current slice. Treat it as incomplete */
 else if(slice_address < ps_codec->s_parse.i4_next_ctb_indx)
 {
 return IHEVCD_IGNORE_SLICE;
 }
 else
 {
                ps_codec->i4_slice_error = 0;
 }
 }

 /* The current slice does not belong to the pic that is being parsed */
 else
 {
 /* The previous pic is incomplete.
             * Treat the remaining CTBs as skip */
 if(ps_codec->i4_pic_present)
 {
 slice_header_t *ps_slice_hdr_next;
                ps_codec->i4_slice_error = 1;
                ps_codec->s_parse.i4_cur_slice_idx--;
 if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                    ps_codec->s_parse.i4_cur_slice_idx = 0;

                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
                ps_slice_hdr_next->i2_ctb_x = 0;
                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;
 return ret;
 }

 /* If the previous pic is complete,
             * return if the current slice is dependant
             * otherwise, update the parse context's POC */
 else
 {
 if(ps_slice_hdr->i1_dependent_slice_flag)
 return IHEVCD_IGNORE_SLICE;

                ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;
 }
 }
 }

 /* If the slice is the first slice in the pic, update the parse context's POC */
 else
 {
 /* If the first slice is repeated, ignore the second occurrence
         * If any other slice is repeated, the CTB addr will be greater than the slice addr,
         * and hence the second occurrence is ignored */
 if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)
 return IHEVCD_IGNORE_SLICE;

        ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;
 }

 // printf(""POC: %d\n"", ps_slice_hdr->i4_abs_pic_order_cnt);
 // AEV_TRACE(""POC"", ps_slice_hdr->i4_abs_pic_order_cnt, 0);
    ps_slice_hdr->i4_num_entry_point_offsets = 0;
 if((ps_pps->i1_tiles_enabled_flag) ||
 (ps_pps->i1_entropy_coding_sync_enabled_flag))
 {
        UEV_PARSE(""num_entry_point_offsets"", value, ps_bitstrm);
        ps_slice_hdr->i4_num_entry_point_offsets = value;

 {
            WORD32 max_num_entry_point_offsets;
 if((ps_pps->i1_tiles_enabled_flag) &&
 (ps_pps->i1_entropy_coding_sync_enabled_flag))
 {
                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * (ps_sps->i2_pic_ht_in_ctb - 1);
 }
 else if(ps_pps->i1_tiles_enabled_flag)
 {
                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * ps_pps->i1_num_tile_rows;
 }
 else
 {
                max_num_entry_point_offsets = (ps_sps->i2_pic_ht_in_ctb - 1);
 }

            ps_slice_hdr->i4_num_entry_point_offsets = CLIP3(ps_slice_hdr->i4_num_entry_point_offsets,
 0, max_num_entry_point_offsets);
 }

 if(ps_slice_hdr->i4_num_entry_point_offsets > 0)
 {
            UEV_PARSE(""offset_len_minus1"", value, ps_bitstrm);
            ps_slice_hdr->i1_offset_len = value + 1;

 for(i = 0; i < ps_slice_hdr->i4_num_entry_point_offsets; i++)
 {
                BITS_PARSE(""entry_point_offset"", value, ps_bitstrm, ps_slice_hdr->i1_offset_len);

 /* TODO: pu4_entry_point_offset needs to be initialized */
 //ps_slice_hdr->pu4_entry_point_offset[i] = value;
 }

 }
 }

 if(ps_pps->i1_slice_header_extension_present_flag)
 {
        UEV_PARSE(""slice_header_extension_length"", value, ps_bitstrm);
        ps_slice_hdr->i2_slice_header_extension_length = value;


 for(i = 0; i < ps_slice_hdr->i2_slice_header_extension_length; i++)
 {
            BITS_PARSE(""slice_header_extension_data_byte"", value, ps_bitstrm, 8);
 }

 }

    ihevcd_bits_flush_to_byte_boundary(ps_bitstrm);

 if((UWORD8 *)ps_bitstrm->pu4_buf > ps_bitstrm->pu1_buf_max)
 return IHEVCD_INVALID_PARAMETER;

 {
 dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;
        WORD32 r_idx;

 if((NAL_IDR_W_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_IDR_N_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_BLA_N_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_BLA_W_DLP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_BLA_W_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (0 == ps_codec->u4_pic_cnt))
 {
 for(i = 0; i < MAX_DPB_BUFS; i++)
 {
 if(ps_dpb_mgr->as_dpb_info[i].ps_pic_buf)
 {
 pic_buf_t *ps_pic_buf = ps_dpb_mgr->as_dpb_info[i].ps_pic_buf;
 mv_buf_t *ps_mv_buf;

 /* Long term index is set to MAX_DPB_BUFS to ensure it is not added as LT */
                    ihevc_dpb_mgr_del_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr, (buf_mgr_t *)ps_codec->pv_pic_buf_mgr, ps_pic_buf->i4_abs_poc);
 /* Find buffer id of the MV bank corresponding to the buffer being freed (Buffer with POC of u4_abs_poc) */
                    ps_mv_buf = (mv_buf_t *)ps_codec->ps_mv_buf;
 for(j = 0; j < ps_codec->i4_max_dpb_size; j++)
 {
 if(ps_mv_buf && ps_mv_buf->i4_abs_poc == ps_pic_buf->i4_abs_poc)
 {
                            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_mv_buf_mgr, j, BUF_MGR_REF);
 break;
 }
                        ps_mv_buf++;
 }

 }

 }

 /* Initialize the reference lists to NULL
             * This is done to take care of the cases where the first pic is not IDR
             * but the reference list is not created for the first pic because
             * pic count is zero leaving the reference list uninitialised  */
 for(r_idx = 0; r_idx < MAX_DPB_SIZE; r_idx++)
 {
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = NULL;
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = NULL;

                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = NULL;
                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = NULL;
 }

 }
 else
 {
            ret = ihevcd_ref_list(ps_codec, ps_pps, ps_sps, ps_slice_hdr);
 if ((WORD32)IHEVCD_SUCCESS != ret)
 {
 return ret;
 }

 }

 }

 /* Fill the remaining entries of the reference lists with the nearest POC
     * This is done to handle cases where there is a corruption in the reference index */
 if(ps_codec->i4_pic_present)
 {
 pic_buf_t *ps_pic_buf_ref;
 mv_buf_t *ps_mv_buf_ref;
        WORD32 r_idx;
 dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;
 buf_mgr_t *ps_mv_buf_mgr = (buf_mgr_t *)ps_codec->pv_mv_buf_mgr;

        ps_pic_buf_ref = ihevc_dpb_mgr_get_ref_by_nearest_poc(ps_dpb_mgr, ps_slice_hdr->i4_abs_pic_order_cnt);
 if(NULL == ps_pic_buf_ref)
 {
            ps_pic_buf_ref = ps_codec->as_process[0].ps_cur_pic;
            ps_mv_buf_ref = ps_codec->s_parse.ps_cur_mv_buf;
 }
 else
 {
            ps_mv_buf_ref = ihevcd_mv_mgr_get_poc(ps_mv_buf_mgr, ps_pic_buf_ref->i4_abs_poc);
 }

 for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx++)
 {
 if(NULL == ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf)
 {
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }
 }

 for(r_idx = ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx < MAX_DPB_SIZE; r_idx++)
 {
            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }

 for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx++)
 {
 if(NULL == ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf)
 {
                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }
 }

 for(r_idx = ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx < MAX_DPB_SIZE; r_idx++)
 {
            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }
 }

 /* Update slice address in the header */
 if(!ps_slice_hdr->i1_first_slice_in_pic_flag)
 {
        ps_slice_hdr->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;
        ps_slice_hdr->i2_ctb_y = slice_address / ps_sps->i2_pic_wd_in_ctb;

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
            ps_slice_hdr->i2_independent_ctb_x = ps_slice_hdr->i2_ctb_x;
            ps_slice_hdr->i2_independent_ctb_y = ps_slice_hdr->i2_ctb_y;
 }
 }
 else
 {
        ps_slice_hdr->i2_ctb_x = 0;
        ps_slice_hdr->i2_ctb_y = 0;

        ps_slice_hdr->i2_independent_ctb_x = 0;
        ps_slice_hdr->i2_independent_ctb_y = 0;
 }

 /* If the first slice in the pic is missing, copy the current slice header to
     * the first slice's header */
 if((!first_slice_in_pic_flag) &&
 (0 == ps_codec->i4_pic_present))
 {

         slice_header_t *ps_slice_hdr_prev = ps_codec->s_parse.ps_slice_hdr_base;
         ihevcd_copy_slice_hdr(ps_codec, 0, (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)));
 
//flaw_line_below:
        ps_codec->i4_slice_error = 1;
//fix_flaw_line_below:
//        prev_slice_incomplete_flag = 1;
//fix_flaw_line_below:
//        ASSERT(ps_codec->s_parse.i4_cur_slice_idx == 1);
 
         ps_slice_hdr_prev->i2_ctb_x = 0;
         ps_slice_hdr_prev->i2_ctb_y = 0;

        ps_codec->s_parse.i4_ctb_x = 0;
        ps_codec->s_parse.i4_ctb_y = 0;

        ps_codec->s_parse.i4_cur_slice_idx = 0;

 if((ps_slice_hdr->i2_ctb_x == 0) &&
 (ps_slice_hdr->i2_ctb_y == 0))
 {
            ps_slice_hdr->i2_ctb_x++;
 }
 }

 {
 /* If skip B is enabled,
         * ignore pictures that are non-reference
         * TODO: (i1_nal_unit_type < NAL_BLA_W_LP) && (i1_nal_unit_type % 2 == 0) only says it is
         * sub-layer non-reference slice. May need to find a way to detect actual non-reference pictures*/

 if((i1_nal_unit_type < NAL_BLA_W_LP) &&
 (i1_nal_unit_type % 2 == 0))
 {
 if(IVD_SKIP_B == ps_codec->e_pic_skip_mode)
 return IHEVCD_IGNORE_SLICE;
 }

 /* If skip PB is enabled,
         * decode only I slices */
 if((IVD_SKIP_PB == ps_codec->e_pic_skip_mode) &&
 (ISLICE != ps_slice_hdr->i1_slice_type))
 {
 return IHEVCD_IGNORE_SLICE;

         }
     }
 
//fix_flaw_line_below:
//    if(prev_slice_incomplete_flag)
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//        ps_codec->i4_slice_error = 1;
//fix_flaw_line_below:
//        ps_codec->s_parse.i4_cur_slice_idx--;
//fix_flaw_line_below:
//        if(ps_codec->s_parse.i4_cur_slice_idx < 0)
//fix_flaw_line_below:
//            ps_codec->s_parse.i4_cur_slice_idx = 0;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     return ret;
 }
",188137,"IHEVCD_ERROR_T ihevcd_parse_slice_header(codec_t *ps_codec,
 nal_header_t *ps_nal)
{
    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
    WORD32 value;
    WORD32 i, j;
    WORD32 sps_id;

 pps_t *ps_pps;
 sps_t *ps_sps;
 slice_header_t *ps_slice_hdr;
    WORD32 disable_deblocking_filter_flag;
 bitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;
    WORD32 idr_pic_flag;
    WORD32 pps_id;
    WORD32 first_slice_in_pic_flag;
    WORD32 no_output_of_prior_pics_flag = 0;

     WORD8 i1_nal_unit_type = ps_nal->i1_nal_unit_type;
     WORD32 num_poc_total_curr = 0;
     WORD32 slice_address;
 
     if(ps_codec->i4_slice_error == 1)
         return ret;

    idr_pic_flag = (NAL_IDR_W_LP == i1_nal_unit_type) ||
 (NAL_IDR_N_LP == i1_nal_unit_type);


    BITS_PARSE(""first_slice_in_pic_flag"", first_slice_in_pic_flag, ps_bitstrm, 1);
 if((NAL_BLA_W_LP <= i1_nal_unit_type) &&
 (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))
 {
        BITS_PARSE(""no_output_of_prior_pics_flag"", no_output_of_prior_pics_flag, ps_bitstrm, 1);
 }
    UEV_PARSE(""pic_parameter_set_id"", pps_id, ps_bitstrm);
    pps_id = CLIP3(pps_id, 0, MAX_PPS_CNT - 2);

 /* Get the current PPS structure */
    ps_pps = ps_codec->s_parse.ps_pps_base + pps_id;
 if(0 == ps_pps->i1_pps_valid)
 {
 pps_t *ps_pps_ref = ps_codec->ps_pps_base;
 while(0 == ps_pps_ref->i1_pps_valid)
 {
            ps_pps_ref++;
 if((ps_pps_ref - ps_codec->ps_pps_base >= MAX_PPS_CNT - 1))
 return IHEVCD_INVALID_HEADER;
 }

        ihevcd_copy_pps(ps_codec, pps_id, ps_pps_ref->i1_pps_id);
 }

 /* Get SPS id for the current PPS */
    sps_id = ps_pps->i1_sps_id;

 /* Get the current SPS structure */
    ps_sps = ps_codec->s_parse.ps_sps_base + sps_id;

 /* When the current slice is the first in a pic,
     *  check whether the previous frame is complete
     *  If the previous frame is incomplete -
     *  treat the remaining CTBs as skip */
 if((0 != ps_codec->u4_pic_cnt || ps_codec->i4_pic_present) &&
                    first_slice_in_pic_flag)
 {
 if(ps_codec->i4_pic_present)
 {
 slice_header_t *ps_slice_hdr_next;
            ps_codec->i4_slice_error = 1;
            ps_codec->s_parse.i4_cur_slice_idx--;
 if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                ps_codec->s_parse.i4_cur_slice_idx = 0;

            ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
            ps_slice_hdr_next->i2_ctb_x = 0;
            ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;
 return ret;
 }
 else
 {
            ps_codec->i4_slice_error = 0;
 }
 }

 if(first_slice_in_pic_flag)
 {
        ps_codec->s_parse.i4_cur_slice_idx = 0;
 }
 else
 {
 /* If the current slice is not the first slice in the pic,
         * but the first one to be parsed, set the current slice indx to 1
         * Treat the first slice to be missing and copy the current slice header
         * to the first one */
 if(0 == ps_codec->i4_pic_present)
            ps_codec->s_parse.i4_cur_slice_idx = 1;
 }

    ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));


 if((ps_pps->i1_dependent_slice_enabled_flag) &&
 (!first_slice_in_pic_flag))
 {
        BITS_PARSE(""dependent_slice_flag"", value, ps_bitstrm, 1);

 /* If dependendent slice, copy slice header from previous slice */
 if(value && (ps_codec->s_parse.i4_cur_slice_idx > 0))
 {
            ihevcd_copy_slice_hdr(ps_codec,
 (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)),
 ((ps_codec->s_parse.i4_cur_slice_idx - 1) & (MAX_SLICE_HDR_CNT - 1)));
 }
        ps_slice_hdr->i1_dependent_slice_flag = value;
 }
 else
 {
        ps_slice_hdr->i1_dependent_slice_flag = 0;
 }
    ps_slice_hdr->i1_nal_unit_type = i1_nal_unit_type;
    ps_slice_hdr->i1_pps_id = pps_id;
    ps_slice_hdr->i1_first_slice_in_pic_flag = first_slice_in_pic_flag;

    ps_slice_hdr->i1_no_output_of_prior_pics_flag = 1;
 if((NAL_BLA_W_LP <= i1_nal_unit_type) &&
 (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))
 {
        ps_slice_hdr->i1_no_output_of_prior_pics_flag = no_output_of_prior_pics_flag;
 }
    ps_slice_hdr->i1_pps_id = pps_id;

 if(!ps_slice_hdr->i1_first_slice_in_pic_flag)
 {
        WORD32 num_bits;

 /* Use CLZ to compute Ceil( Log2( PicSizeInCtbsY ) ) */
        num_bits = 32 - CLZ(ps_sps->i4_pic_size_in_ctb - 1);
        BITS_PARSE(""slice_address"", value, ps_bitstrm, num_bits);

        slice_address = value;
 /* If slice address is greater than the number of CTBs in a picture,
         * ignore the slice */
 if(value >= ps_sps->i4_pic_size_in_ctb)
 return IHEVCD_IGNORE_SLICE;
 }
 else
 {
        slice_address = 0;
 }

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
        ps_slice_hdr->i1_pic_output_flag = 1;
        ps_slice_hdr->i4_pic_order_cnt_lsb = 0;
        ps_slice_hdr->i1_num_long_term_sps = 0;
        ps_slice_hdr->i1_num_long_term_pics = 0;

 for(i = 0; i < ps_pps->i1_num_extra_slice_header_bits; i++)
 {
            BITS_PARSE(""slice_reserved_undetermined_flag[ i ]"", value, ps_bitstrm, 1);
 }
        UEV_PARSE(""slice_type"", value, ps_bitstrm);
        ps_slice_hdr->i1_slice_type = value;

 /* If the picture is IRAP, slice type must be equal to ISLICE */
 if((ps_slice_hdr->i1_nal_unit_type >= NAL_BLA_W_LP) &&
 (ps_slice_hdr->i1_nal_unit_type <= NAL_RSV_RAP_VCL23))
            ps_slice_hdr->i1_slice_type = ISLICE;

 if((ps_slice_hdr->i1_slice_type < 0) ||
 (ps_slice_hdr->i1_slice_type > 2))
 return IHEVCD_IGNORE_SLICE;

 if(ps_pps->i1_output_flag_present_flag)
 {
            BITS_PARSE(""pic_output_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_pic_output_flag = value;
 }
        ps_slice_hdr->i1_colour_plane_id = 0;
 if(1 == ps_sps->i1_separate_colour_plane_flag)
 {
            BITS_PARSE(""colour_plane_id"", value, ps_bitstrm, 2);
            ps_slice_hdr->i1_colour_plane_id = value;
 }
        ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = 0;

 if(!idr_pic_flag)
 {

            WORD32 st_rps_idx;
            WORD32 num_neg_pics;
            WORD32 num_pos_pics;
            WORD8 *pi1_used;

            BITS_PARSE(""pic_order_cnt_lsb"", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);
            ps_slice_hdr->i4_pic_order_cnt_lsb = value;

            BITS_PARSE(""short_term_ref_pic_set_sps_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag = value;

 if(1 == ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag)
 {
                WORD32 numbits;

                ps_slice_hdr->i1_short_term_ref_pic_set_idx = 0;
 if(ps_sps->i1_num_short_term_ref_pic_sets > 1)
 {
                    numbits = 32 - CLZ(ps_sps->i1_num_short_term_ref_pic_sets - 1);
                    BITS_PARSE(""short_term_ref_pic_set_idx"", value, ps_bitstrm, numbits);
                    ps_slice_hdr->i1_short_term_ref_pic_set_idx = value;
 }

                st_rps_idx = ps_slice_hdr->i1_short_term_ref_pic_set_idx;
                num_neg_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_neg_pics;
                num_pos_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_pos_pics;
                pi1_used = ps_sps->as_stref_picset[st_rps_idx].ai1_used;
 }
 else
 {
                ihevcd_short_term_ref_pic_set(ps_bitstrm,
 &ps_sps->as_stref_picset[0],
                                              ps_sps->i1_num_short_term_ref_pic_sets,
                                              ps_sps->i1_num_short_term_ref_pic_sets,
 &ps_slice_hdr->s_stref_picset);

                st_rps_idx = ps_sps->i1_num_short_term_ref_pic_sets;
                num_neg_pics = ps_slice_hdr->s_stref_picset.i1_num_neg_pics;
                num_pos_pics = ps_slice_hdr->s_stref_picset.i1_num_pos_pics;
                pi1_used = ps_slice_hdr->s_stref_picset.ai1_used;
 }

 if(ps_sps->i1_long_term_ref_pics_present_flag)
 {
 if(ps_sps->i1_num_long_term_ref_pics_sps > 0)
 {
                    UEV_PARSE(""num_long_term_sps"", value, ps_bitstrm);
                    ps_slice_hdr->i1_num_long_term_sps = value;

                    ps_slice_hdr->i1_num_long_term_sps = CLIP3(ps_slice_hdr->i1_num_long_term_sps,
 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics);
 }
                UEV_PARSE(""num_long_term_pics"", value, ps_bitstrm);
                ps_slice_hdr->i1_num_long_term_pics = value;
                ps_slice_hdr->i1_num_long_term_pics = CLIP3(ps_slice_hdr->i1_num_long_term_pics,
 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics -
                                                            ps_slice_hdr->i1_num_long_term_sps);

 for(i = 0; i < (ps_slice_hdr->i1_num_long_term_sps +
                                ps_slice_hdr->i1_num_long_term_pics); i++)
 {
 if(i < ps_slice_hdr->i1_num_long_term_sps)
 {
 /* Use CLZ to compute Ceil( Log2( num_long_term_ref_pics_sps ) ) */
 if (ps_sps->i1_num_long_term_ref_pics_sps > 1)
 {
                            WORD32 num_bits = 32 - CLZ(ps_sps->i1_num_long_term_ref_pics_sps - 1);
                            BITS_PARSE(""lt_idx_sps[ i ]"", value, ps_bitstrm, num_bits);
 }
 else
 {
                            value = 0;
 }
                        ps_slice_hdr->ai4_poc_lsb_lt[i] = ps_sps->au2_lt_ref_pic_poc_lsb_sps[value];
                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = ps_sps->ai1_used_by_curr_pic_lt_sps_flag[value];

 }
 else
 {
                        BITS_PARSE(""poc_lsb_lt[ i ]"", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);
                        ps_slice_hdr->ai4_poc_lsb_lt[i] = value;

                        BITS_PARSE(""used_by_curr_pic_lt_flag[ i ]"", value, ps_bitstrm, 1);
                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = value;

 }
                    BITS_PARSE(""delta_poc_msb_present_flag[ i ]"", value, ps_bitstrm, 1);
                    ps_slice_hdr->ai1_delta_poc_msb_present_flag[i] = value;


                    ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = 0;
 if(ps_slice_hdr->ai1_delta_poc_msb_present_flag[i])
 {

                        UEV_PARSE(""delata_poc_msb_cycle_lt[ i ]"", value, ps_bitstrm);
                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = value;
 }

 if((i != 0) && (i != ps_slice_hdr->i1_num_long_term_sps))
 {
                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] += ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i - 1];
 }

 }
 }

 for(i = 0; i < num_neg_pics + num_pos_pics; i++)
 {
 if(pi1_used[i])
 {
                    num_poc_total_curr++;
 }
 }
 for(i = 0; i < ps_slice_hdr->i1_num_long_term_sps + ps_slice_hdr->i1_num_long_term_pics; i++)
 {
 if(ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i])
 {
                    num_poc_total_curr++;
 }
 }


 if(ps_sps->i1_sps_temporal_mvp_enable_flag)
 {
                BITS_PARSE(""enable_temporal_mvp_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = value;
 }

 }
        ps_slice_hdr->i1_slice_sao_luma_flag = 0;
        ps_slice_hdr->i1_slice_sao_chroma_flag = 0;
 if(ps_sps->i1_sample_adaptive_offset_enabled_flag)
 {
            BITS_PARSE(""slice_sao_luma_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_slice_sao_luma_flag = value;

            BITS_PARSE(""slice_sao_chroma_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_slice_sao_chroma_flag = value;

 }

        ps_slice_hdr->i1_max_num_merge_cand = 1;
        ps_slice_hdr->i1_cabac_init_flag = 0;

        ps_slice_hdr->i1_num_ref_idx_l0_active = 0;
        ps_slice_hdr->i1_num_ref_idx_l1_active = 0;
        ps_slice_hdr->i1_slice_cb_qp_offset = 0;
        ps_slice_hdr->i1_slice_cr_qp_offset = 0;
 if((PSLICE == ps_slice_hdr->i1_slice_type) ||
 (BSLICE == ps_slice_hdr->i1_slice_type))
 {
            BITS_PARSE(""num_ref_idx_active_override_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_num_ref_idx_active_override_flag = value;

 if(ps_slice_hdr->i1_num_ref_idx_active_override_flag)
 {
                UEV_PARSE(""num_ref_idx_l0_active_minus1"", value, ps_bitstrm);
                ps_slice_hdr->i1_num_ref_idx_l0_active = value + 1;

 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                    UEV_PARSE(""num_ref_idx_l1_active_minus1"", value, ps_bitstrm);
                    ps_slice_hdr->i1_num_ref_idx_l1_active = value + 1;
 }

 }
 else
 {
                ps_slice_hdr->i1_num_ref_idx_l0_active = ps_pps->i1_num_ref_idx_l0_default_active;

 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                    ps_slice_hdr->i1_num_ref_idx_l1_active = ps_pps->i1_num_ref_idx_l1_default_active;
 }
 }

            ps_slice_hdr->i1_num_ref_idx_l0_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l0_active, 0, MAX_DPB_SIZE - 1);
            ps_slice_hdr->i1_num_ref_idx_l1_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l1_active, 0, MAX_DPB_SIZE - 1);

 if(0 == num_poc_total_curr)
 return IHEVCD_IGNORE_SLICE;
 if((ps_pps->i1_lists_modification_present_flag) && (num_poc_total_curr > 1))
 {
                ihevcd_ref_pic_list_modification(ps_bitstrm,
                                                 ps_slice_hdr, num_poc_total_curr);
 }
 else
 {
                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l0 = 0;
                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l1 = 0;
 }

 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                BITS_PARSE(""mvd_l1_zero_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_mvd_l1_zero_flag = value;
 }

            ps_slice_hdr->i1_cabac_init_flag = 0;
 if(ps_pps->i1_cabac_init_present_flag)
 {
                BITS_PARSE(""cabac_init_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_cabac_init_flag = value;

 }
            ps_slice_hdr->i1_collocated_from_l0_flag = 1;
            ps_slice_hdr->i1_collocated_ref_idx = 0;
 if(ps_slice_hdr->i1_slice_temporal_mvp_enable_flag)
 {
 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                    BITS_PARSE(""collocated_from_l0_flag"", value, ps_bitstrm, 1);
                    ps_slice_hdr->i1_collocated_from_l0_flag = value;
 }

 if((ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l0_active > 1)) ||
 (!ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l1_active > 1)))
 {
                    UEV_PARSE(""collocated_ref_idx"", value, ps_bitstrm);
                    ps_slice_hdr->i1_collocated_ref_idx = value;
 }

 }
            ps_slice_hdr->i1_collocated_ref_idx = CLIP3(ps_slice_hdr->i1_collocated_ref_idx, 0, MAX_DPB_SIZE - 1);

 if((ps_pps->i1_weighted_pred_flag  && (PSLICE == ps_slice_hdr->i1_slice_type)) ||
 (ps_pps->i1_weighted_bipred_flag  && (BSLICE == ps_slice_hdr->i1_slice_type)))
 {
                ihevcd_parse_pred_wt_ofst(ps_bitstrm, ps_sps, ps_pps, ps_slice_hdr);
 }
            UEV_PARSE(""five_minus_max_num_merge_cand"", value, ps_bitstrm);
            ps_slice_hdr->i1_max_num_merge_cand = 5 - value;

 }
        ps_slice_hdr->i1_max_num_merge_cand = CLIP3(ps_slice_hdr->i1_max_num_merge_cand, 1, 5);
        SEV_PARSE(""slice_qp_delta"", value, ps_bitstrm);
        ps_slice_hdr->i1_slice_qp_delta = value;

 if(ps_pps->i1_pic_slice_level_chroma_qp_offsets_present_flag)
 {
            SEV_PARSE(""slice_cb_qp_offset"", value, ps_bitstrm);
            ps_slice_hdr->i1_slice_cb_qp_offset = value;

            SEV_PARSE(""slice_cr_qp_offset"", value, ps_bitstrm);
            ps_slice_hdr->i1_slice_cr_qp_offset = value;

 }
        ps_slice_hdr->i1_deblocking_filter_override_flag = 0;
        ps_slice_hdr->i1_slice_disable_deblocking_filter_flag  = ps_pps->i1_pic_disable_deblocking_filter_flag;
        ps_slice_hdr->i1_beta_offset_div2 = ps_pps->i1_beta_offset_div2;
        ps_slice_hdr->i1_tc_offset_div2 = ps_pps->i1_tc_offset_div2;

        disable_deblocking_filter_flag = ps_pps->i1_pic_disable_deblocking_filter_flag;

 if(ps_pps->i1_deblocking_filter_control_present_flag)
 {

 if(ps_pps->i1_deblocking_filter_override_enabled_flag)
 {
                BITS_PARSE(""deblocking_filter_override_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_deblocking_filter_override_flag = value;
 }

 if(ps_slice_hdr->i1_deblocking_filter_override_flag)
 {
                BITS_PARSE(""slice_disable_deblocking_filter_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_slice_disable_deblocking_filter_flag = value;
                disable_deblocking_filter_flag = ps_slice_hdr->i1_slice_disable_deblocking_filter_flag;

 if(!ps_slice_hdr->i1_slice_disable_deblocking_filter_flag)
 {
                    SEV_PARSE(""beta_offset_div2"", value, ps_bitstrm);
                    ps_slice_hdr->i1_beta_offset_div2 = value;

                    SEV_PARSE(""tc_offset_div2"", value, ps_bitstrm);
                    ps_slice_hdr->i1_tc_offset_div2 = value;

 }
 }
 }

        ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = ps_pps->i1_loop_filter_across_slices_enabled_flag;
 if(ps_pps->i1_loop_filter_across_slices_enabled_flag  &&
 (ps_slice_hdr->i1_slice_sao_luma_flag  ||  ps_slice_hdr->i1_slice_sao_chroma_flag  || !disable_deblocking_filter_flag))
 {
            BITS_PARSE(""slice_loop_filter_across_slices_enabled_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = value;
 }

 }

 /* Check sanity of slice */
 if((!first_slice_in_pic_flag) &&
 (ps_codec->i4_pic_present))
 {
 slice_header_t *ps_slice_hdr_base = ps_codec->ps_slice_hdr_base;


 /* According to the standard, the above conditions must be satisfied - But for error resilience,
         * only the following conditions are checked */
 if((ps_slice_hdr_base->i1_pps_id != ps_slice_hdr->i1_pps_id) ||
 (ps_slice_hdr_base->i4_pic_order_cnt_lsb != ps_slice_hdr->i4_pic_order_cnt_lsb))
 {
 return IHEVCD_IGNORE_SLICE;
 }

 }


 if(0 == ps_codec->i4_pic_present)
 {
        ps_slice_hdr->i4_abs_pic_order_cnt = ihevcd_calc_poc(ps_codec, ps_nal, ps_sps->i1_log2_max_pic_order_cnt_lsb, ps_slice_hdr->i4_pic_order_cnt_lsb);
 }
 else
 {
        ps_slice_hdr->i4_abs_pic_order_cnt = ps_codec->s_parse.i4_abs_pic_order_cnt;
 }


 if(!first_slice_in_pic_flag)
 {
 /* Check if the current slice belongs to the same pic (Pic being parsed) */
 if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)
 {

 /* If the Next CTB's index is less than the slice address,
             * the previous slice is incomplete.
             * Indicate slice error, and treat the remaining CTBs as skip */
 if(slice_address > ps_codec->s_parse.i4_next_ctb_indx)

             {
                 if(ps_codec->i4_pic_present)
                 {
                    slice_header_t *ps_slice_hdr_next;
                    ps_codec->i4_slice_error = 1;
                    ps_codec->s_parse.i4_cur_slice_idx--;
                    if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                        ps_codec->s_parse.i4_cur_slice_idx = 0;
                    ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
                    ps_slice_hdr_next->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;
                    ps_slice_hdr_next->i2_ctb_y = slice_address / ps_sps->i2_pic_wd_in_ctb;
                    return ret;
                 }
                 else
                 {
 return IHEVCD_IGNORE_SLICE;
 }
 }
 /* If the slice address is less than the next CTB's index,
             * extra CTBs have been decoded in the previous slice.
             * Ignore the current slice. Treat it as incomplete */
 else if(slice_address < ps_codec->s_parse.i4_next_ctb_indx)
 {
 return IHEVCD_IGNORE_SLICE;
 }
 else
 {
                ps_codec->i4_slice_error = 0;
 }
 }

 /* The current slice does not belong to the pic that is being parsed */
 else
 {
 /* The previous pic is incomplete.
             * Treat the remaining CTBs as skip */
 if(ps_codec->i4_pic_present)
 {
 slice_header_t *ps_slice_hdr_next;
                ps_codec->i4_slice_error = 1;
                ps_codec->s_parse.i4_cur_slice_idx--;
 if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                    ps_codec->s_parse.i4_cur_slice_idx = 0;

                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
                ps_slice_hdr_next->i2_ctb_x = 0;
                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;
 return ret;
 }

 /* If the previous pic is complete,
             * return if the current slice is dependant
             * otherwise, update the parse context's POC */
 else
 {
 if(ps_slice_hdr->i1_dependent_slice_flag)
 return IHEVCD_IGNORE_SLICE;

                ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;
 }
 }
 }

 /* If the slice is the first slice in the pic, update the parse context's POC */
 else
 {
 /* If the first slice is repeated, ignore the second occurrence
         * If any other slice is repeated, the CTB addr will be greater than the slice addr,
         * and hence the second occurrence is ignored */
 if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)
 return IHEVCD_IGNORE_SLICE;

        ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;
 }

    ps_slice_hdr->i4_num_entry_point_offsets = 0;
 if((ps_pps->i1_tiles_enabled_flag) ||
 (ps_pps->i1_entropy_coding_sync_enabled_flag))
 {
        UEV_PARSE(""num_entry_point_offsets"", value, ps_bitstrm);
        ps_slice_hdr->i4_num_entry_point_offsets = value;

 {
            WORD32 max_num_entry_point_offsets;
 if((ps_pps->i1_tiles_enabled_flag) &&
 (ps_pps->i1_entropy_coding_sync_enabled_flag))
 {
                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * (ps_sps->i2_pic_ht_in_ctb - 1);
 }
 else if(ps_pps->i1_tiles_enabled_flag)
 {
                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * ps_pps->i1_num_tile_rows;
 }
 else
 {
                max_num_entry_point_offsets = (ps_sps->i2_pic_ht_in_ctb - 1);
 }

            ps_slice_hdr->i4_num_entry_point_offsets = CLIP3(ps_slice_hdr->i4_num_entry_point_offsets,
 0, max_num_entry_point_offsets);
 }

 if(ps_slice_hdr->i4_num_entry_point_offsets > 0)
 {
            UEV_PARSE(""offset_len_minus1"", value, ps_bitstrm);
            ps_slice_hdr->i1_offset_len = value + 1;

 for(i = 0; i < ps_slice_hdr->i4_num_entry_point_offsets; i++)
 {
                BITS_PARSE(""entry_point_offset"", value, ps_bitstrm, ps_slice_hdr->i1_offset_len);

 /* TODO: pu4_entry_point_offset needs to be initialized */
 }

 }
 }

 if(ps_pps->i1_slice_header_extension_present_flag)
 {
        UEV_PARSE(""slice_header_extension_length"", value, ps_bitstrm);
        ps_slice_hdr->i2_slice_header_extension_length = value;


 for(i = 0; i < ps_slice_hdr->i2_slice_header_extension_length; i++)
 {
            BITS_PARSE(""slice_header_extension_data_byte"", value, ps_bitstrm, 8);
 }

 }

    ihevcd_bits_flush_to_byte_boundary(ps_bitstrm);

 if((UWORD8 *)ps_bitstrm->pu4_buf > ps_bitstrm->pu1_buf_max)
 return IHEVCD_INVALID_PARAMETER;

 {
 dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;
        WORD32 r_idx;

 if((NAL_IDR_W_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_IDR_N_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_BLA_N_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_BLA_W_DLP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_BLA_W_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (0 == ps_codec->u4_pic_cnt))
 {
 for(i = 0; i < MAX_DPB_BUFS; i++)
 {
 if(ps_dpb_mgr->as_dpb_info[i].ps_pic_buf)
 {
 pic_buf_t *ps_pic_buf = ps_dpb_mgr->as_dpb_info[i].ps_pic_buf;
 mv_buf_t *ps_mv_buf;

 /* Long term index is set to MAX_DPB_BUFS to ensure it is not added as LT */
                    ihevc_dpb_mgr_del_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr, (buf_mgr_t *)ps_codec->pv_pic_buf_mgr, ps_pic_buf->i4_abs_poc);
 /* Find buffer id of the MV bank corresponding to the buffer being freed (Buffer with POC of u4_abs_poc) */
                    ps_mv_buf = (mv_buf_t *)ps_codec->ps_mv_buf;
 for(j = 0; j < ps_codec->i4_max_dpb_size; j++)
 {
 if(ps_mv_buf && ps_mv_buf->i4_abs_poc == ps_pic_buf->i4_abs_poc)
 {
                            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_mv_buf_mgr, j, BUF_MGR_REF);
 break;
 }
                        ps_mv_buf++;
 }

 }

 }

 /* Initialize the reference lists to NULL
             * This is done to take care of the cases where the first pic is not IDR
             * but the reference list is not created for the first pic because
             * pic count is zero leaving the reference list uninitialised  */
 for(r_idx = 0; r_idx < MAX_DPB_SIZE; r_idx++)
 {
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = NULL;
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = NULL;

                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = NULL;
                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = NULL;
 }

 }
 else
 {
            ret = ihevcd_ref_list(ps_codec, ps_pps, ps_sps, ps_slice_hdr);
 if ((WORD32)IHEVCD_SUCCESS != ret)
 {
 return ret;
 }

 }

 }

 /* Fill the remaining entries of the reference lists with the nearest POC
     * This is done to handle cases where there is a corruption in the reference index */
 if(ps_codec->i4_pic_present)
 {
 pic_buf_t *ps_pic_buf_ref;
 mv_buf_t *ps_mv_buf_ref;
        WORD32 r_idx;
 dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;
 buf_mgr_t *ps_mv_buf_mgr = (buf_mgr_t *)ps_codec->pv_mv_buf_mgr;

        ps_pic_buf_ref = ihevc_dpb_mgr_get_ref_by_nearest_poc(ps_dpb_mgr, ps_slice_hdr->i4_abs_pic_order_cnt);
 if(NULL == ps_pic_buf_ref)
 {
            ps_pic_buf_ref = ps_codec->as_process[0].ps_cur_pic;
            ps_mv_buf_ref = ps_codec->s_parse.ps_cur_mv_buf;
 }
 else
 {
            ps_mv_buf_ref = ihevcd_mv_mgr_get_poc(ps_mv_buf_mgr, ps_pic_buf_ref->i4_abs_poc);
 }

 for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx++)
 {
 if(NULL == ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf)
 {
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }
 }

 for(r_idx = ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx < MAX_DPB_SIZE; r_idx++)
 {
            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }

 for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx++)
 {
 if(NULL == ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf)
 {
                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }
 }

 for(r_idx = ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx < MAX_DPB_SIZE; r_idx++)
 {
            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }
 }

 /* Update slice address in the header */
 if(!ps_slice_hdr->i1_first_slice_in_pic_flag)
 {
        ps_slice_hdr->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;
        ps_slice_hdr->i2_ctb_y = slice_address / ps_sps->i2_pic_wd_in_ctb;

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
            ps_slice_hdr->i2_independent_ctb_x = ps_slice_hdr->i2_ctb_x;
            ps_slice_hdr->i2_independent_ctb_y = ps_slice_hdr->i2_ctb_y;
 }
 }
 else
 {
        ps_slice_hdr->i2_ctb_x = 0;
        ps_slice_hdr->i2_ctb_y = 0;

        ps_slice_hdr->i2_independent_ctb_x = 0;
        ps_slice_hdr->i2_independent_ctb_y = 0;
 }

 /* If the first slice in the pic is missing, copy the current slice header to
     * the first slice's header */
 if((!first_slice_in_pic_flag) &&
 (0 == ps_codec->i4_pic_present))
 {

         slice_header_t *ps_slice_hdr_prev = ps_codec->s_parse.ps_slice_hdr_base;
         ihevcd_copy_slice_hdr(ps_codec, 0, (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)));
 
        ps_codec->i4_slice_error = 1;
 
         ps_slice_hdr_prev->i2_ctb_x = 0;
         ps_slice_hdr_prev->i2_ctb_y = 0;

        ps_codec->s_parse.i4_ctb_x = 0;
        ps_codec->s_parse.i4_ctb_y = 0;

        ps_codec->s_parse.i4_cur_slice_idx = 0;

 if((ps_slice_hdr->i2_ctb_x == 0) &&
 (ps_slice_hdr->i2_ctb_y == 0))
 {
            ps_slice_hdr->i2_ctb_x++;
 }
 }

 {
 /* If skip B is enabled,
         * ignore pictures that are non-reference
         * TODO: (i1_nal_unit_type < NAL_BLA_W_LP) && (i1_nal_unit_type % 2 == 0) only says it is
         * sub-layer non-reference slice. May need to find a way to detect actual non-reference pictures*/

 if((i1_nal_unit_type < NAL_BLA_W_LP) &&
 (i1_nal_unit_type % 2 == 0))
 {
 if(IVD_SKIP_B == ps_codec->e_pic_skip_mode)
 return IHEVCD_IGNORE_SLICE;
 }

 /* If skip PB is enabled,
         * decode only I slices */
 if((IVD_SKIP_PB == ps_codec->e_pic_skip_mode) &&
 (ISLICE != ps_slice_hdr->i1_slice_type))
 {
 return IHEVCD_IGNORE_SLICE;

         }
     }
 
     return ret;
 }
","IHEVCD_ERROR_T ihevcd_parse_slice_header(codec_t *ps_codec,
 nal_header_t *ps_nal)
{
    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
    WORD32 value;
    WORD32 i, j;
    WORD32 sps_id;

 pps_t *ps_pps;
 sps_t *ps_sps;
 slice_header_t *ps_slice_hdr;
    WORD32 disable_deblocking_filter_flag;
 bitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;
    WORD32 idr_pic_flag;
    WORD32 pps_id;
    WORD32 first_slice_in_pic_flag;
    WORD32 no_output_of_prior_pics_flag = 0;

     WORD8 i1_nal_unit_type = ps_nal->i1_nal_unit_type;
     WORD32 num_poc_total_curr = 0;
     WORD32 slice_address;
    WORD32 prev_slice_incomplete_flag = 0;
 
     if(ps_codec->i4_slice_error == 1)
         return ret;

    idr_pic_flag = (NAL_IDR_W_LP == i1_nal_unit_type) ||
 (NAL_IDR_N_LP == i1_nal_unit_type);


    BITS_PARSE(""first_slice_in_pic_flag"", first_slice_in_pic_flag, ps_bitstrm, 1);
 if((NAL_BLA_W_LP <= i1_nal_unit_type) &&
 (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))
 {
        BITS_PARSE(""no_output_of_prior_pics_flag"", no_output_of_prior_pics_flag, ps_bitstrm, 1);
 }
    UEV_PARSE(""pic_parameter_set_id"", pps_id, ps_bitstrm);
    pps_id = CLIP3(pps_id, 0, MAX_PPS_CNT - 2);

 /* Get the current PPS structure */
    ps_pps = ps_codec->s_parse.ps_pps_base + pps_id;
 if(0 == ps_pps->i1_pps_valid)
 {
 pps_t *ps_pps_ref = ps_codec->ps_pps_base;
 while(0 == ps_pps_ref->i1_pps_valid)
 {
            ps_pps_ref++;
 if((ps_pps_ref - ps_codec->ps_pps_base >= MAX_PPS_CNT - 1))
 return IHEVCD_INVALID_HEADER;
 }

        ihevcd_copy_pps(ps_codec, pps_id, ps_pps_ref->i1_pps_id);
 }

 /* Get SPS id for the current PPS */
    sps_id = ps_pps->i1_sps_id;

 /* Get the current SPS structure */
    ps_sps = ps_codec->s_parse.ps_sps_base + sps_id;

 /* When the current slice is the first in a pic,
     *  check whether the previous frame is complete
     *  If the previous frame is incomplete -
     *  treat the remaining CTBs as skip */
 if((0 != ps_codec->u4_pic_cnt || ps_codec->i4_pic_present) &&
                    first_slice_in_pic_flag)
 {
 if(ps_codec->i4_pic_present)
 {
 slice_header_t *ps_slice_hdr_next;
            ps_codec->i4_slice_error = 1;
            ps_codec->s_parse.i4_cur_slice_idx--;
 if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                ps_codec->s_parse.i4_cur_slice_idx = 0;

            ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
            ps_slice_hdr_next->i2_ctb_x = 0;
            ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;
 return ret;
 }
 else
 {
            ps_codec->i4_slice_error = 0;
 }
 }

 if(first_slice_in_pic_flag)
 {
        ps_codec->s_parse.i4_cur_slice_idx = 0;
 }
 else
 {
 /* If the current slice is not the first slice in the pic,
         * but the first one to be parsed, set the current slice indx to 1
         * Treat the first slice to be missing and copy the current slice header
         * to the first one */
 if(0 == ps_codec->i4_pic_present)
            ps_codec->s_parse.i4_cur_slice_idx = 1;
 }

    ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));


 if((ps_pps->i1_dependent_slice_enabled_flag) &&
 (!first_slice_in_pic_flag))
 {
        BITS_PARSE(""dependent_slice_flag"", value, ps_bitstrm, 1);

 /* If dependendent slice, copy slice header from previous slice */
 if(value && (ps_codec->s_parse.i4_cur_slice_idx > 0))
 {
            ihevcd_copy_slice_hdr(ps_codec,
 (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)),
 ((ps_codec->s_parse.i4_cur_slice_idx - 1) & (MAX_SLICE_HDR_CNT - 1)));
 }
        ps_slice_hdr->i1_dependent_slice_flag = value;
 }
 else
 {
        ps_slice_hdr->i1_dependent_slice_flag = 0;
 }
    ps_slice_hdr->i1_nal_unit_type = i1_nal_unit_type;
    ps_slice_hdr->i1_pps_id = pps_id;
    ps_slice_hdr->i1_first_slice_in_pic_flag = first_slice_in_pic_flag;

    ps_slice_hdr->i1_no_output_of_prior_pics_flag = 1;
 if((NAL_BLA_W_LP <= i1_nal_unit_type) &&
 (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))
 {
        ps_slice_hdr->i1_no_output_of_prior_pics_flag = no_output_of_prior_pics_flag;
 }
    ps_slice_hdr->i1_pps_id = pps_id;

 if(!ps_slice_hdr->i1_first_slice_in_pic_flag)
 {
        WORD32 num_bits;

 /* Use CLZ to compute Ceil( Log2( PicSizeInCtbsY ) ) */
        num_bits = 32 - CLZ(ps_sps->i4_pic_size_in_ctb - 1);
        BITS_PARSE(""slice_address"", value, ps_bitstrm, num_bits);

        slice_address = value;
 /* If slice address is greater than the number of CTBs in a picture,
         * ignore the slice */
 if(value >= ps_sps->i4_pic_size_in_ctb)
 return IHEVCD_IGNORE_SLICE;
 }
 else
 {
        slice_address = 0;
 }

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
        ps_slice_hdr->i1_pic_output_flag = 1;
        ps_slice_hdr->i4_pic_order_cnt_lsb = 0;
        ps_slice_hdr->i1_num_long_term_sps = 0;
        ps_slice_hdr->i1_num_long_term_pics = 0;

 for(i = 0; i < ps_pps->i1_num_extra_slice_header_bits; i++)
 {
            BITS_PARSE(""slice_reserved_undetermined_flag[ i ]"", value, ps_bitstrm, 1);
 }
        UEV_PARSE(""slice_type"", value, ps_bitstrm);
        ps_slice_hdr->i1_slice_type = value;

 /* If the picture is IRAP, slice type must be equal to ISLICE */
 if((ps_slice_hdr->i1_nal_unit_type >= NAL_BLA_W_LP) &&
 (ps_slice_hdr->i1_nal_unit_type <= NAL_RSV_RAP_VCL23))
            ps_slice_hdr->i1_slice_type = ISLICE;

 if((ps_slice_hdr->i1_slice_type < 0) ||
 (ps_slice_hdr->i1_slice_type > 2))
 return IHEVCD_IGNORE_SLICE;

 if(ps_pps->i1_output_flag_present_flag)
 {
            BITS_PARSE(""pic_output_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_pic_output_flag = value;
 }
        ps_slice_hdr->i1_colour_plane_id = 0;
 if(1 == ps_sps->i1_separate_colour_plane_flag)
 {
            BITS_PARSE(""colour_plane_id"", value, ps_bitstrm, 2);
            ps_slice_hdr->i1_colour_plane_id = value;
 }
        ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = 0;

 if(!idr_pic_flag)
 {

            WORD32 st_rps_idx;
            WORD32 num_neg_pics;
            WORD32 num_pos_pics;
            WORD8 *pi1_used;

            BITS_PARSE(""pic_order_cnt_lsb"", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);
            ps_slice_hdr->i4_pic_order_cnt_lsb = value;

            BITS_PARSE(""short_term_ref_pic_set_sps_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag = value;

 if(1 == ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag)
 {
                WORD32 numbits;

                ps_slice_hdr->i1_short_term_ref_pic_set_idx = 0;
 if(ps_sps->i1_num_short_term_ref_pic_sets > 1)
 {
                    numbits = 32 - CLZ(ps_sps->i1_num_short_term_ref_pic_sets - 1);
                    BITS_PARSE(""short_term_ref_pic_set_idx"", value, ps_bitstrm, numbits);
                    ps_slice_hdr->i1_short_term_ref_pic_set_idx = value;
 }

                st_rps_idx = ps_slice_hdr->i1_short_term_ref_pic_set_idx;
                num_neg_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_neg_pics;
                num_pos_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_pos_pics;
                pi1_used = ps_sps->as_stref_picset[st_rps_idx].ai1_used;
 }
 else
 {
                ihevcd_short_term_ref_pic_set(ps_bitstrm,
 &ps_sps->as_stref_picset[0],
                                              ps_sps->i1_num_short_term_ref_pic_sets,
                                              ps_sps->i1_num_short_term_ref_pic_sets,
 &ps_slice_hdr->s_stref_picset);

                st_rps_idx = ps_sps->i1_num_short_term_ref_pic_sets;
                num_neg_pics = ps_slice_hdr->s_stref_picset.i1_num_neg_pics;
                num_pos_pics = ps_slice_hdr->s_stref_picset.i1_num_pos_pics;
                pi1_used = ps_slice_hdr->s_stref_picset.ai1_used;
 }

 if(ps_sps->i1_long_term_ref_pics_present_flag)
 {
 if(ps_sps->i1_num_long_term_ref_pics_sps > 0)
 {
                    UEV_PARSE(""num_long_term_sps"", value, ps_bitstrm);
                    ps_slice_hdr->i1_num_long_term_sps = value;

                    ps_slice_hdr->i1_num_long_term_sps = CLIP3(ps_slice_hdr->i1_num_long_term_sps,
 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics);
 }
                UEV_PARSE(""num_long_term_pics"", value, ps_bitstrm);
                ps_slice_hdr->i1_num_long_term_pics = value;
                ps_slice_hdr->i1_num_long_term_pics = CLIP3(ps_slice_hdr->i1_num_long_term_pics,
 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics -
                                                            ps_slice_hdr->i1_num_long_term_sps);

 for(i = 0; i < (ps_slice_hdr->i1_num_long_term_sps +
                                ps_slice_hdr->i1_num_long_term_pics); i++)
 {
 if(i < ps_slice_hdr->i1_num_long_term_sps)
 {
 /* Use CLZ to compute Ceil( Log2( num_long_term_ref_pics_sps ) ) */
 if (ps_sps->i1_num_long_term_ref_pics_sps > 1)
 {
                            WORD32 num_bits = 32 - CLZ(ps_sps->i1_num_long_term_ref_pics_sps - 1);
                            BITS_PARSE(""lt_idx_sps[ i ]"", value, ps_bitstrm, num_bits);
 }
 else
 {
                            value = 0;
 }
                        ps_slice_hdr->ai4_poc_lsb_lt[i] = ps_sps->au2_lt_ref_pic_poc_lsb_sps[value];
                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = ps_sps->ai1_used_by_curr_pic_lt_sps_flag[value];

 }
 else
 {
                        BITS_PARSE(""poc_lsb_lt[ i ]"", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);
                        ps_slice_hdr->ai4_poc_lsb_lt[i] = value;

                        BITS_PARSE(""used_by_curr_pic_lt_flag[ i ]"", value, ps_bitstrm, 1);
                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = value;

 }
                    BITS_PARSE(""delta_poc_msb_present_flag[ i ]"", value, ps_bitstrm, 1);
                    ps_slice_hdr->ai1_delta_poc_msb_present_flag[i] = value;


                    ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = 0;
 if(ps_slice_hdr->ai1_delta_poc_msb_present_flag[i])
 {

                        UEV_PARSE(""delata_poc_msb_cycle_lt[ i ]"", value, ps_bitstrm);
                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = value;
 }

 if((i != 0) && (i != ps_slice_hdr->i1_num_long_term_sps))
 {
                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] += ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i - 1];
 }

 }
 }

 for(i = 0; i < num_neg_pics + num_pos_pics; i++)
 {
 if(pi1_used[i])
 {
                    num_poc_total_curr++;
 }
 }
 for(i = 0; i < ps_slice_hdr->i1_num_long_term_sps + ps_slice_hdr->i1_num_long_term_pics; i++)
 {
 if(ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i])
 {
                    num_poc_total_curr++;
 }
 }


 if(ps_sps->i1_sps_temporal_mvp_enable_flag)
 {
                BITS_PARSE(""enable_temporal_mvp_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = value;
 }

 }
        ps_slice_hdr->i1_slice_sao_luma_flag = 0;
        ps_slice_hdr->i1_slice_sao_chroma_flag = 0;
 if(ps_sps->i1_sample_adaptive_offset_enabled_flag)
 {
            BITS_PARSE(""slice_sao_luma_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_slice_sao_luma_flag = value;

            BITS_PARSE(""slice_sao_chroma_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_slice_sao_chroma_flag = value;

 }

        ps_slice_hdr->i1_max_num_merge_cand = 1;
        ps_slice_hdr->i1_cabac_init_flag = 0;

        ps_slice_hdr->i1_num_ref_idx_l0_active = 0;
        ps_slice_hdr->i1_num_ref_idx_l1_active = 0;
        ps_slice_hdr->i1_slice_cb_qp_offset = 0;
        ps_slice_hdr->i1_slice_cr_qp_offset = 0;
 if((PSLICE == ps_slice_hdr->i1_slice_type) ||
 (BSLICE == ps_slice_hdr->i1_slice_type))
 {
            BITS_PARSE(""num_ref_idx_active_override_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_num_ref_idx_active_override_flag = value;

 if(ps_slice_hdr->i1_num_ref_idx_active_override_flag)
 {
                UEV_PARSE(""num_ref_idx_l0_active_minus1"", value, ps_bitstrm);
                ps_slice_hdr->i1_num_ref_idx_l0_active = value + 1;

 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                    UEV_PARSE(""num_ref_idx_l1_active_minus1"", value, ps_bitstrm);
                    ps_slice_hdr->i1_num_ref_idx_l1_active = value + 1;
 }

 }
 else
 {
                ps_slice_hdr->i1_num_ref_idx_l0_active = ps_pps->i1_num_ref_idx_l0_default_active;

 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                    ps_slice_hdr->i1_num_ref_idx_l1_active = ps_pps->i1_num_ref_idx_l1_default_active;
 }
 }

            ps_slice_hdr->i1_num_ref_idx_l0_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l0_active, 0, MAX_DPB_SIZE - 1);
            ps_slice_hdr->i1_num_ref_idx_l1_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l1_active, 0, MAX_DPB_SIZE - 1);

 if(0 == num_poc_total_curr)
 return IHEVCD_IGNORE_SLICE;
 if((ps_pps->i1_lists_modification_present_flag) && (num_poc_total_curr > 1))
 {
                ihevcd_ref_pic_list_modification(ps_bitstrm,
                                                 ps_slice_hdr, num_poc_total_curr);
 }
 else
 {
                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l0 = 0;
                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l1 = 0;
 }

 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                BITS_PARSE(""mvd_l1_zero_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_mvd_l1_zero_flag = value;
 }

            ps_slice_hdr->i1_cabac_init_flag = 0;
 if(ps_pps->i1_cabac_init_present_flag)
 {
                BITS_PARSE(""cabac_init_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_cabac_init_flag = value;

 }
            ps_slice_hdr->i1_collocated_from_l0_flag = 1;
            ps_slice_hdr->i1_collocated_ref_idx = 0;
 if(ps_slice_hdr->i1_slice_temporal_mvp_enable_flag)
 {
 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                    BITS_PARSE(""collocated_from_l0_flag"", value, ps_bitstrm, 1);
                    ps_slice_hdr->i1_collocated_from_l0_flag = value;
 }

 if((ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l0_active > 1)) ||
 (!ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l1_active > 1)))
 {
                    UEV_PARSE(""collocated_ref_idx"", value, ps_bitstrm);
                    ps_slice_hdr->i1_collocated_ref_idx = value;
 }

 }
            ps_slice_hdr->i1_collocated_ref_idx = CLIP3(ps_slice_hdr->i1_collocated_ref_idx, 0, MAX_DPB_SIZE - 1);

 if((ps_pps->i1_weighted_pred_flag  && (PSLICE == ps_slice_hdr->i1_slice_type)) ||
 (ps_pps->i1_weighted_bipred_flag  && (BSLICE == ps_slice_hdr->i1_slice_type)))
 {
                ihevcd_parse_pred_wt_ofst(ps_bitstrm, ps_sps, ps_pps, ps_slice_hdr);
 }
            UEV_PARSE(""five_minus_max_num_merge_cand"", value, ps_bitstrm);
            ps_slice_hdr->i1_max_num_merge_cand = 5 - value;

 }
        ps_slice_hdr->i1_max_num_merge_cand = CLIP3(ps_slice_hdr->i1_max_num_merge_cand, 1, 5);
        SEV_PARSE(""slice_qp_delta"", value, ps_bitstrm);
        ps_slice_hdr->i1_slice_qp_delta = value;

 if(ps_pps->i1_pic_slice_level_chroma_qp_offsets_present_flag)
 {
            SEV_PARSE(""slice_cb_qp_offset"", value, ps_bitstrm);
            ps_slice_hdr->i1_slice_cb_qp_offset = value;

            SEV_PARSE(""slice_cr_qp_offset"", value, ps_bitstrm);
            ps_slice_hdr->i1_slice_cr_qp_offset = value;

 }
        ps_slice_hdr->i1_deblocking_filter_override_flag = 0;
        ps_slice_hdr->i1_slice_disable_deblocking_filter_flag  = ps_pps->i1_pic_disable_deblocking_filter_flag;
        ps_slice_hdr->i1_beta_offset_div2 = ps_pps->i1_beta_offset_div2;
        ps_slice_hdr->i1_tc_offset_div2 = ps_pps->i1_tc_offset_div2;

        disable_deblocking_filter_flag = ps_pps->i1_pic_disable_deblocking_filter_flag;

 if(ps_pps->i1_deblocking_filter_control_present_flag)
 {

 if(ps_pps->i1_deblocking_filter_override_enabled_flag)
 {
                BITS_PARSE(""deblocking_filter_override_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_deblocking_filter_override_flag = value;
 }

 if(ps_slice_hdr->i1_deblocking_filter_override_flag)
 {
                BITS_PARSE(""slice_disable_deblocking_filter_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_slice_disable_deblocking_filter_flag = value;
                disable_deblocking_filter_flag = ps_slice_hdr->i1_slice_disable_deblocking_filter_flag;

 if(!ps_slice_hdr->i1_slice_disable_deblocking_filter_flag)
 {
                    SEV_PARSE(""beta_offset_div2"", value, ps_bitstrm);
                    ps_slice_hdr->i1_beta_offset_div2 = value;

                    SEV_PARSE(""tc_offset_div2"", value, ps_bitstrm);
                    ps_slice_hdr->i1_tc_offset_div2 = value;

 }
 }
 }

        ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = ps_pps->i1_loop_filter_across_slices_enabled_flag;
 if(ps_pps->i1_loop_filter_across_slices_enabled_flag  &&
 (ps_slice_hdr->i1_slice_sao_luma_flag  ||  ps_slice_hdr->i1_slice_sao_chroma_flag  || !disable_deblocking_filter_flag))
 {
            BITS_PARSE(""slice_loop_filter_across_slices_enabled_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = value;
 }

 }

 /* Check sanity of slice */
 if((!first_slice_in_pic_flag) &&
 (ps_codec->i4_pic_present))
 {
 slice_header_t *ps_slice_hdr_base = ps_codec->ps_slice_hdr_base;


 /* According to the standard, the above conditions must be satisfied - But for error resilience,
         * only the following conditions are checked */
 if((ps_slice_hdr_base->i1_pps_id != ps_slice_hdr->i1_pps_id) ||
 (ps_slice_hdr_base->i4_pic_order_cnt_lsb != ps_slice_hdr->i4_pic_order_cnt_lsb))
 {
 return IHEVCD_IGNORE_SLICE;
 }

 }


 if(0 == ps_codec->i4_pic_present)
 {
        ps_slice_hdr->i4_abs_pic_order_cnt = ihevcd_calc_poc(ps_codec, ps_nal, ps_sps->i1_log2_max_pic_order_cnt_lsb, ps_slice_hdr->i4_pic_order_cnt_lsb);
 }
 else
 {
        ps_slice_hdr->i4_abs_pic_order_cnt = ps_codec->s_parse.i4_abs_pic_order_cnt;
 }


 if(!first_slice_in_pic_flag)
 {
 /* Check if the current slice belongs to the same pic (Pic being parsed) */
 if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)
 {

 /* If the Next CTB's index is less than the slice address,
             * the previous slice is incomplete.
             * Indicate slice error, and treat the remaining CTBs as skip */
 if(slice_address > ps_codec->s_parse.i4_next_ctb_indx)

             {
                 if(ps_codec->i4_pic_present)
                 {
                    prev_slice_incomplete_flag = 1;
                 }
                 else
                 {
 return IHEVCD_IGNORE_SLICE;
 }
 }
 /* If the slice address is less than the next CTB's index,
             * extra CTBs have been decoded in the previous slice.
             * Ignore the current slice. Treat it as incomplete */
 else if(slice_address < ps_codec->s_parse.i4_next_ctb_indx)
 {
 return IHEVCD_IGNORE_SLICE;
 }
 else
 {
                ps_codec->i4_slice_error = 0;
 }
 }

 /* The current slice does not belong to the pic that is being parsed */
 else
 {
 /* The previous pic is incomplete.
             * Treat the remaining CTBs as skip */
 if(ps_codec->i4_pic_present)
 {
 slice_header_t *ps_slice_hdr_next;
                ps_codec->i4_slice_error = 1;
                ps_codec->s_parse.i4_cur_slice_idx--;
 if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                    ps_codec->s_parse.i4_cur_slice_idx = 0;

                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
                ps_slice_hdr_next->i2_ctb_x = 0;
                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;
 return ret;
 }

 /* If the previous pic is complete,
             * return if the current slice is dependant
             * otherwise, update the parse context's POC */
 else
 {
 if(ps_slice_hdr->i1_dependent_slice_flag)
 return IHEVCD_IGNORE_SLICE;

                ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;
 }
 }
 }

 /* If the slice is the first slice in the pic, update the parse context's POC */
 else
 {
 /* If the first slice is repeated, ignore the second occurrence
         * If any other slice is repeated, the CTB addr will be greater than the slice addr,
         * and hence the second occurrence is ignored */
 if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)
 return IHEVCD_IGNORE_SLICE;

        ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;
 }

    ps_slice_hdr->i4_num_entry_point_offsets = 0;
 if((ps_pps->i1_tiles_enabled_flag) ||
 (ps_pps->i1_entropy_coding_sync_enabled_flag))
 {
        UEV_PARSE(""num_entry_point_offsets"", value, ps_bitstrm);
        ps_slice_hdr->i4_num_entry_point_offsets = value;

 {
            WORD32 max_num_entry_point_offsets;
 if((ps_pps->i1_tiles_enabled_flag) &&
 (ps_pps->i1_entropy_coding_sync_enabled_flag))
 {
                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * (ps_sps->i2_pic_ht_in_ctb - 1);
 }
 else if(ps_pps->i1_tiles_enabled_flag)
 {
                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * ps_pps->i1_num_tile_rows;
 }
 else
 {
                max_num_entry_point_offsets = (ps_sps->i2_pic_ht_in_ctb - 1);
 }

            ps_slice_hdr->i4_num_entry_point_offsets = CLIP3(ps_slice_hdr->i4_num_entry_point_offsets,
 0, max_num_entry_point_offsets);
 }

 if(ps_slice_hdr->i4_num_entry_point_offsets > 0)
 {
            UEV_PARSE(""offset_len_minus1"", value, ps_bitstrm);
            ps_slice_hdr->i1_offset_len = value + 1;

 for(i = 0; i < ps_slice_hdr->i4_num_entry_point_offsets; i++)
 {
                BITS_PARSE(""entry_point_offset"", value, ps_bitstrm, ps_slice_hdr->i1_offset_len);

 /* TODO: pu4_entry_point_offset needs to be initialized */
 }

 }
 }

 if(ps_pps->i1_slice_header_extension_present_flag)
 {
        UEV_PARSE(""slice_header_extension_length"", value, ps_bitstrm);
        ps_slice_hdr->i2_slice_header_extension_length = value;


 for(i = 0; i < ps_slice_hdr->i2_slice_header_extension_length; i++)
 {
            BITS_PARSE(""slice_header_extension_data_byte"", value, ps_bitstrm, 8);
 }

 }

    ihevcd_bits_flush_to_byte_boundary(ps_bitstrm);

 if((UWORD8 *)ps_bitstrm->pu4_buf > ps_bitstrm->pu1_buf_max)
 return IHEVCD_INVALID_PARAMETER;

 {
 dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;
        WORD32 r_idx;

 if((NAL_IDR_W_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_IDR_N_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_BLA_N_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_BLA_W_DLP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_BLA_W_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (0 == ps_codec->u4_pic_cnt))
 {
 for(i = 0; i < MAX_DPB_BUFS; i++)
 {
 if(ps_dpb_mgr->as_dpb_info[i].ps_pic_buf)
 {
 pic_buf_t *ps_pic_buf = ps_dpb_mgr->as_dpb_info[i].ps_pic_buf;
 mv_buf_t *ps_mv_buf;

 /* Long term index is set to MAX_DPB_BUFS to ensure it is not added as LT */
                    ihevc_dpb_mgr_del_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr, (buf_mgr_t *)ps_codec->pv_pic_buf_mgr, ps_pic_buf->i4_abs_poc);
 /* Find buffer id of the MV bank corresponding to the buffer being freed (Buffer with POC of u4_abs_poc) */
                    ps_mv_buf = (mv_buf_t *)ps_codec->ps_mv_buf;
 for(j = 0; j < ps_codec->i4_max_dpb_size; j++)
 {
 if(ps_mv_buf && ps_mv_buf->i4_abs_poc == ps_pic_buf->i4_abs_poc)
 {
                            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_mv_buf_mgr, j, BUF_MGR_REF);
 break;
 }
                        ps_mv_buf++;
 }

 }

 }

 /* Initialize the reference lists to NULL
             * This is done to take care of the cases where the first pic is not IDR
             * but the reference list is not created for the first pic because
             * pic count is zero leaving the reference list uninitialised  */
 for(r_idx = 0; r_idx < MAX_DPB_SIZE; r_idx++)
 {
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = NULL;
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = NULL;

                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = NULL;
                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = NULL;
 }

 }
 else
 {
            ret = ihevcd_ref_list(ps_codec, ps_pps, ps_sps, ps_slice_hdr);
 if ((WORD32)IHEVCD_SUCCESS != ret)
 {
 return ret;
 }

 }

 }

 /* Fill the remaining entries of the reference lists with the nearest POC
     * This is done to handle cases where there is a corruption in the reference index */
 if(ps_codec->i4_pic_present)
 {
 pic_buf_t *ps_pic_buf_ref;
 mv_buf_t *ps_mv_buf_ref;
        WORD32 r_idx;
 dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;
 buf_mgr_t *ps_mv_buf_mgr = (buf_mgr_t *)ps_codec->pv_mv_buf_mgr;

        ps_pic_buf_ref = ihevc_dpb_mgr_get_ref_by_nearest_poc(ps_dpb_mgr, ps_slice_hdr->i4_abs_pic_order_cnt);
 if(NULL == ps_pic_buf_ref)
 {
            ps_pic_buf_ref = ps_codec->as_process[0].ps_cur_pic;
            ps_mv_buf_ref = ps_codec->s_parse.ps_cur_mv_buf;
 }
 else
 {
            ps_mv_buf_ref = ihevcd_mv_mgr_get_poc(ps_mv_buf_mgr, ps_pic_buf_ref->i4_abs_poc);
 }

 for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx++)
 {
 if(NULL == ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf)
 {
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }
 }

 for(r_idx = ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx < MAX_DPB_SIZE; r_idx++)
 {
            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }

 for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx++)
 {
 if(NULL == ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf)
 {
                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }
 }

 for(r_idx = ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx < MAX_DPB_SIZE; r_idx++)
 {
            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }
 }

 /* Update slice address in the header */
 if(!ps_slice_hdr->i1_first_slice_in_pic_flag)
 {
        ps_slice_hdr->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;
        ps_slice_hdr->i2_ctb_y = slice_address / ps_sps->i2_pic_wd_in_ctb;

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
            ps_slice_hdr->i2_independent_ctb_x = ps_slice_hdr->i2_ctb_x;
            ps_slice_hdr->i2_independent_ctb_y = ps_slice_hdr->i2_ctb_y;
 }
 }
 else
 {
        ps_slice_hdr->i2_ctb_x = 0;
        ps_slice_hdr->i2_ctb_y = 0;

        ps_slice_hdr->i2_independent_ctb_x = 0;
        ps_slice_hdr->i2_independent_ctb_y = 0;
 }

 /* If the first slice in the pic is missing, copy the current slice header to
     * the first slice's header */
 if((!first_slice_in_pic_flag) &&
 (0 == ps_codec->i4_pic_present))
 {

         slice_header_t *ps_slice_hdr_prev = ps_codec->s_parse.ps_slice_hdr_base;
         ihevcd_copy_slice_hdr(ps_codec, 0, (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)));
 
        prev_slice_incomplete_flag = 1;
        ASSERT(ps_codec->s_parse.i4_cur_slice_idx == 1);
 
         ps_slice_hdr_prev->i2_ctb_x = 0;
         ps_slice_hdr_prev->i2_ctb_y = 0;

        ps_codec->s_parse.i4_ctb_x = 0;
        ps_codec->s_parse.i4_ctb_y = 0;

        ps_codec->s_parse.i4_cur_slice_idx = 0;

 if((ps_slice_hdr->i2_ctb_x == 0) &&
 (ps_slice_hdr->i2_ctb_y == 0))
 {
            ps_slice_hdr->i2_ctb_x++;
 }
 }

 {
 /* If skip B is enabled,
         * ignore pictures that are non-reference
         * TODO: (i1_nal_unit_type < NAL_BLA_W_LP) && (i1_nal_unit_type % 2 == 0) only says it is
         * sub-layer non-reference slice. May need to find a way to detect actual non-reference pictures*/

 if((i1_nal_unit_type < NAL_BLA_W_LP) &&
 (i1_nal_unit_type % 2 == 0))
 {
 if(IVD_SKIP_B == ps_codec->e_pic_skip_mode)
 return IHEVCD_IGNORE_SLICE;
 }

 /* If skip PB is enabled,
         * decode only I slices */
 if((IVD_SKIP_PB == ps_codec->e_pic_skip_mode) &&
 (ISLICE != ps_slice_hdr->i1_slice_type))
 {
 return IHEVCD_IGNORE_SLICE;

         }
     }
 
    if(prev_slice_incomplete_flag)
    {
        ps_codec->i4_slice_error = 1;
        ps_codec->s_parse.i4_cur_slice_idx--;
        if(ps_codec->s_parse.i4_cur_slice_idx < 0)
            ps_codec->s_parse.i4_cur_slice_idx = 0;
    }

     return ret;
 }
","The `ihevcd_parse_slice_header` function is responsible for parsing the slice header of a video stream in the HEVC (High Efficiency Video Coding) format. It begins by checking for slice errors and identifying the type of NAL (Network Abstraction Layer) unit. The function then extracts various parameters from the bitstream, such as the picture parameter set (PPS) and sequence parameter set (SPS) IDs, slice flags, and reference picture lists. It handles conditions for first slices, dependent slices, and manages reference picture lists based on the parsed data. The function also ensures that the slice adheres to the HEVC standards, updating the codec's state and returning appropriate error codes when necessary.","The code is designed to parse the slice header of a video stream encoded in the HEVC format. It begins by checking for any existing slice errors and identifying the type of slice being processed. The function extracts essential parameters from the bitstream, including identifiers for picture and sequence parameters, as well as various flags that dictate the slice's characteristics. It manages the state of reference pictures and handles conditions for both first and dependent slices, ensuring compliance with the HEVC standards while updating the codec's internal state and returning appropriate error codes when necessary.","The vulnerability in the original code stemmed from prematurely signaling that the previous slice was incomplete during the parsing of the current slice header, which could lead to incorrect handling of slice data and potential errors in decoding. Specifically, the logic that checked for incomplete slices was executed too early, potentially before all necessary validations were completed. In the fixed code, this check was moved to the end of the current slice header parsing process, ensuring that all relevant data was correctly processed before determining if the previous slice should be marked as incomplete, thus enhancing the robustness and correctness of the slice parsing logic.","The vulnerability in the original code arose from prematurely marking the previous slice as incomplete during the parsing of the current slice header, which could lead to incorrect handling of slice data and potential decoding errors. This early decision could disrupt the parsing process, resulting in missed validations and erroneous state updates. The fix involved relocating the check for incomplete slices to the end of the current slice header parsing, ensuring that all necessary data was processed before determining the status of the previous slice. This adjustment enhances the reliability of the parsing logic and prevents unintended errors.","The vulnerability was fixed by moving the check for the `prev_slice_incomplete_flag` to the end of the current slice header parsing process. In the original code, the decision to signal missing coding tree blocks (CTBs) as skipped was made too early, potentially before all necessary validations were completed. The revised code ensures that this check occurs after the parsing of the current slice header is fully completed, allowing for a more accurate assessment of the slice's status. This change prevents premature error signaling and ensures that the parsing logic operates correctly without unintended consequences.","The vulnerability was addressed by restructuring the code to delay the check for incomplete slices until after the entire current slice header had been parsed. This adjustment ensures that all relevant data and conditions are fully evaluated before determining whether to mark the previous slice as incomplete. By moving this decision to a later point in the process, the fix prevents premature error signaling, allowing for a more accurate and reliable assessment of the slice's status. This change enhances the overall robustness of the parsing logic and reduces the likelihood of decoding errors.","4,5","5, 5","3,4","5,4"
127,127,188140,188140,,Remote,Not required,Complete,CVE-2017-13185,https://www.cvedetails.com/cve/CVE-2017-13185/,CWE-200,Low,Partial,,,2018-01-12,8.5,"An information disclosure vulnerability in the Android media framework (libhevc). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-65123471.",2018-01-25,+Info ,2,https://android.googlesource.com/platform/external/libhevc/+/2b9fb0c2074d370a254b35e2489de2d94943578d,2b9fb0c2074d370a254b35e2489de2d94943578d,"Set error skip ctbs as multiple 8x8 pus

Bug: 65123471

This is required for incomplete ctbs at the frame
boundaries

Change-Id: I7e41a3ac2f6e35a929ba4ff3ca4cfcc859a7b867
",74,decoder/ihevcd_parse_slice.c,"{""filename"": ""decoder/ihevcd_parse_slice.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libhevc/+/2b9fb0c2074d370a254b35e2489de2d94943578d/decoder/ihevcd_parse_slice.c"", ""patch"": ""@@ -2177,6 +2177,98 @@\n\n  *******************************************************************************\n  *\n  * @brief\n+ *  Set ctb skip\n+ *\n+ * @par Description:\n+ *  During error, sets tu and pu params of a ctb as skip.\n+ *\n+ * @param[in] ps_codec\n+ *  Pointer to codec context\n+ *\n+ * @returns  None\n+ *\n+ * @remarks\n+ *\n+ *\n+ *******************************************************************************\n+ */\n+void ihevcd_set_ctb_skip(codec_t *ps_codec)\n+{\n+    tu_t *ps_tu;\n+    pu_t *ps_pu;\n+    sps_t *ps_sps = ps_codec->s_parse.ps_sps;\n+    WORD32 ctb_size = 1 << ps_sps->i1_log2_ctb_size;\n+    WORD32 ctb_skip_wd, ctb_skip_ht;\n+    WORD32 rows_remaining, cols_remaining;\n+    WORD32 tu_abs_x, tu_abs_y;\n+    WORD32 numbytes_row =  (ps_sps->i2_pic_width_in_luma_samples + 63) / 64;\n+    UWORD8 *pu1_pic_intra_flag;\n+    UWORD32 u4_mask;\n+    WORD32 pu_x,pu_y;\n+\n+    /* Set pu wd and ht based on whether the ctb is complete or not */\n+    rows_remaining = ps_sps->i2_pic_height_in_luma_samples\n+                    - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);\n+    ctb_skip_ht = MIN(ctb_size, rows_remaining);\n+\n+    cols_remaining = ps_sps->i2_pic_width_in_luma_samples\n+                    - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size);\n+    ctb_skip_wd = MIN(ctb_size, cols_remaining);\n+\n+    ps_codec->s_parse.s_cu.i4_pred_mode = PRED_MODE_SKIP;\n+    ps_codec->s_parse.s_cu.i4_part_mode = PART_2Nx2N;\n+\n+    for (pu_y = 0; pu_y < ctb_skip_ht ; pu_y += MIN_CU_SIZE)\n+    {\n+        for (pu_x = 0; pu_x < ctb_skip_wd ; pu_x += MIN_CU_SIZE)\n+        {\n+            ps_tu = ps_codec->s_parse.ps_tu;\n+            ps_tu->b1_cb_cbf = 0;\n+            ps_tu->b1_cr_cbf = 0;\n+            ps_tu->b1_y_cbf = 0;\n+            ps_tu->b4_pos_x = pu_x >> 2;\n+            ps_tu->b4_pos_y = pu_y >> 2;\n+            ps_tu->b1_transquant_bypass = 0;\n+            ps_tu->b3_size = 1;\n+            ps_tu->b7_qp = ps_codec->s_parse.u4_qp;\n+            ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;\n+            ps_tu->b6_luma_intra_mode   = INTRA_PRED_NONE;\n+            ps_tu->b1_first_tu_in_cu = 1;\n+\n+            ps_codec->s_parse.ps_tu++;\n+            ps_codec->s_parse.s_cu.i4_tu_cnt++;\n+            ps_codec->s_parse.i4_pic_tu_idx++;\n+\n+            tu_abs_x = (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size) + pu_x;\n+            tu_abs_y = (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size) + pu_y;\n+            pu1_pic_intra_flag = ps_codec->s_parse.pu1_pic_intra_flag;\n+            pu1_pic_intra_flag += (tu_abs_y >> 3) * numbytes_row;\n+            pu1_pic_intra_flag += (tu_abs_x >> 6);\n+            u4_mask = (LSB_ONES((MIN_CU_SIZE >> 3)) << (((tu_abs_x) / 8) % 8));\n+            u4_mask = ~u4_mask;\n+            *pu1_pic_intra_flag &= u4_mask;\n+\n+            ps_pu = ps_codec->s_parse.ps_pu;\n+            ps_pu->b2_part_idx = 0;\n+            ps_pu->b4_pos_x = pu_x >> 2;\n+            ps_pu->b4_pos_y = pu_y >> 2;\n+            ps_pu->b4_wd = 1;\n+            ps_pu->b4_ht = 1;\n+            ps_pu->b1_intra_flag = 0;\n+            ps_pu->b3_part_mode = ps_codec->s_parse.s_cu.i4_part_mode;\n+            ps_pu->b1_merge_flag = 1;\n+            ps_pu->b3_merge_idx = 0;\n+\n+            ps_codec->s_parse.ps_pu++;\n+            ps_codec->s_parse.i4_pic_pu_idx++;\n+        }\n+    }\n+}\n+\n+/**\n+ *******************************************************************************\n+ *\n+ * @brief\n  *  Parses Slice data syntax\n  *\n  * @par Description:\n@@ -2640,19 +2732,8 @@\n\n             if (ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n             {\n                 /* Reset tu and pu parameters, and signal current ctb as skip */\n-                WORD32 pu_skip_wd, pu_skip_ht;\n-                WORD32 rows_remaining, cols_remaining;\n                 WORD32 tu_coeff_data_reset_size;\n \n-                /* Set pu wd and ht based on whether the ctb is complete or not */\n-                rows_remaining = ps_sps->i2_pic_height_in_luma_samples\n-                                - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);\n-                pu_skip_ht = MIN(ctb_size, rows_remaining);\n-\n-                cols_remaining = ps_sps->i2_pic_width_in_luma_samples\n-                                - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size);\n-                pu_skip_wd = MIN(ctb_size, cols_remaining);\n-\n                 ps_codec->s_parse.ps_tu = ps_tu;\n                 ps_codec->s_parse.s_cu.i4_tu_cnt = i4_tu_cnt;\n                 ps_codec->s_parse.i4_pic_tu_idx = i4_pic_tu_idx;\n@@ -2660,41 +2741,11 @@\n\n                 ps_codec->s_parse.ps_pu = ps_pu;\n                 ps_codec->s_parse.i4_pic_pu_idx = i4_pic_pu_idx;\n \n-                ps_tu->b1_cb_cbf = 0;\n-                ps_tu->b1_cr_cbf = 0;\n-                ps_tu->b1_y_cbf = 0;\n-                ps_tu->b4_pos_x = 0;\n-                ps_tu->b4_pos_y = 0;\n-                ps_tu->b1_transquant_bypass = 0;\n-                ps_tu->b3_size = (ps_sps->i1_log2_ctb_size - 2);\n-                ps_tu->b7_qp = ps_codec->s_parse.u4_qp;\n-                ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;\n-                ps_tu->b6_luma_intra_mode   = INTRA_PRED_NONE;\n-                ps_tu->b1_first_tu_in_cu = 1;\n-\n                 tu_coeff_data_reset_size = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data - pu1_tu_coeff_data;\n                 memset(pu1_tu_coeff_data, 0, tu_coeff_data_reset_size);\n                 ps_codec->s_parse.pv_tu_coeff_data = (void *)pu1_tu_coeff_data;\n \n-                ps_codec->s_parse.ps_tu++;\n-                ps_codec->s_parse.s_cu.i4_tu_cnt++;\n-                ps_codec->s_parse.i4_pic_tu_idx++;\n-\n-                ps_codec->s_parse.s_cu.i4_pred_mode = PRED_MODE_SKIP;\n-                ps_codec->s_parse.s_cu.i4_part_mode = PART_2Nx2N;\n-\n-                ps_pu->b2_part_idx = 0;\n-                ps_pu->b4_pos_x = 0;\n-                ps_pu->b4_pos_y = 0;\n-                ps_pu->b4_wd = (pu_skip_wd >> 2) - 1;\n-                ps_pu->b4_ht = (pu_skip_ht >> 2) - 1;\n-                ps_pu->b1_intra_flag = 0;\n-                ps_pu->b3_part_mode = ps_codec->s_parse.s_cu.i4_part_mode;\n-                ps_pu->b1_merge_flag = 1;\n-                ps_pu->b3_merge_idx = 0;\n-\n-                ps_codec->s_parse.ps_pu++;\n-                ps_codec->s_parse.i4_pic_pu_idx++;\n+                ihevcd_set_ctb_skip(ps_codec);\n \n                 /* Set slice error to suppress further parsing and\n                  * signal end of slice.\n@@ -2706,52 +2757,7 @@\n\n         }\n         else\n         {\n-            tu_t *ps_tu = ps_codec->s_parse.ps_tu;\n-            pu_t *ps_pu = ps_codec->s_parse.ps_pu;\n-            WORD32 pu_skip_wd, pu_skip_ht;\n-            WORD32 rows_remaining, cols_remaining;\n-\n-            /* Set pu wd and ht based on whether the ctb is complete or not */\n-            rows_remaining = ps_sps->i2_pic_height_in_luma_samples\n-                            - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);\n-            pu_skip_ht = MIN(ctb_size, rows_remaining);\n-\n-            cols_remaining = ps_sps->i2_pic_width_in_luma_samples\n-                            - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size);\n-            pu_skip_wd = MIN(ctb_size, cols_remaining);\n-\n-            ps_tu->b1_cb_cbf = 0;\n-            ps_tu->b1_cr_cbf = 0;\n-            ps_tu->b1_y_cbf = 0;\n-            ps_tu->b4_pos_x = 0;\n-            ps_tu->b4_pos_y = 0;\n-            ps_tu->b1_transquant_bypass = 0;\n-            ps_tu->b3_size = (ps_sps->i1_log2_ctb_size - 2);\n-            ps_tu->b7_qp = ps_codec->s_parse.u4_qp;\n-            ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;\n-            ps_tu->b6_luma_intra_mode   = INTRA_PRED_NONE;\n-            ps_tu->b1_first_tu_in_cu = 1;\n-\n-            ps_codec->s_parse.ps_tu++;\n-            ps_codec->s_parse.s_cu.i4_tu_cnt++;\n-            ps_codec->s_parse.i4_pic_tu_idx++;\n-\n-            ps_codec->s_parse.s_cu.i4_pred_mode = PRED_MODE_SKIP;\n-            ps_codec->s_parse.s_cu.i4_part_mode = PART_2Nx2N;\n-\n-            ps_pu->b2_part_idx = 0;\n-            ps_pu->b4_pos_x = 0;\n-            ps_pu->b4_pos_y = 0;\n-            ps_pu->b4_wd = (pu_skip_wd >> 2) - 1;\n-            ps_pu->b4_ht = (pu_skip_ht >> 2) - 1;\n-            ps_pu->b1_intra_flag = 0;\n-            ps_pu->b3_part_mode = ps_codec->s_parse.s_cu.i4_part_mode;\n-            ps_pu->b1_merge_flag = 1;\n-            ps_pu->b3_merge_idx = 0;\n-\n-            ps_codec->s_parse.ps_pu++;\n-            ps_codec->s_parse.i4_pic_pu_idx++;\n-\n+            ihevcd_set_ctb_skip(ps_codec);\n         }\n \n         if(0 == ps_codec->i4_slice_error)\n""}","IHEVCD_ERROR_T ihevcd_parse_slice_data(codec_t *ps_codec)
{

    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
    WORD32 end_of_slice_flag = 0;
 sps_t *ps_sps;
 pps_t *ps_pps;
 slice_header_t *ps_slice_hdr;
    WORD32 end_of_pic;
 tile_t *ps_tile, *ps_tile_prev;
    WORD32 i;
    WORD32 ctb_addr;
    WORD32 tile_idx;
    WORD32 cabac_init_idc;
    WORD32 ctb_size;
    WORD32 num_ctb_in_row;
    WORD32 num_min4x4_in_ctb;
    WORD32 slice_qp;
    WORD32 slice_start_ctb_idx;
    WORD32 tile_start_ctb_idx;


    ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base;
    ps_pps = ps_codec->s_parse.ps_pps_base;
    ps_sps = ps_codec->s_parse.ps_sps_base;

 /* Get current slice header, pps and sps */
    ps_slice_hdr += (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));
    ps_pps  += ps_slice_hdr->i1_pps_id;
    ps_sps  += ps_pps->i1_sps_id;

 if(0 != ps_codec->s_parse.i4_cur_slice_idx)
 {
 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
            ps_codec->s_parse.i4_cur_independent_slice_idx++;
 if(MAX_SLICE_HDR_CNT == ps_codec->s_parse.i4_cur_independent_slice_idx)
                ps_codec->s_parse.i4_cur_independent_slice_idx = 0;
 }
 }


    ctb_size = 1 << ps_sps->i1_log2_ctb_size;
    num_min4x4_in_ctb = (ctb_size / 4) * (ctb_size / 4);
    num_ctb_in_row = ps_sps->i2_pic_wd_in_ctb;

 /* Update the parse context */
 if(0 == ps_codec->i4_slice_error)
 {
        ps_codec->s_parse.i4_ctb_x = ps_slice_hdr->i2_ctb_x;
        ps_codec->s_parse.i4_ctb_y = ps_slice_hdr->i2_ctb_y;
 }
    ps_codec->s_parse.ps_pps = ps_pps;
    ps_codec->s_parse.ps_sps = ps_sps;
    ps_codec->s_parse.ps_slice_hdr = ps_slice_hdr;

 /* Derive Tile positions for the current CTB */
 /* Change this to lookup if required */
    ihevcd_get_tile_pos(ps_pps, ps_sps, ps_codec->s_parse.i4_ctb_x,
                        ps_codec->s_parse.i4_ctb_y,
 &ps_codec->s_parse.i4_ctb_tile_x,
 &ps_codec->s_parse.i4_ctb_tile_y,
 &tile_idx);
    ps_codec->s_parse.ps_tile = ps_pps->ps_tile + tile_idx;
    ps_codec->s_parse.i4_cur_tile_idx = tile_idx;
    ps_tile = ps_codec->s_parse.ps_tile;
 if(tile_idx)
        ps_tile_prev = ps_tile - 1;
 else
        ps_tile_prev = ps_tile;

 /* If the present slice is dependent, then store the previous
     * independent slices' ctb x and y values for decoding process */
 if(0 == ps_codec->i4_slice_error)
 {
 if(1 == ps_slice_hdr->i1_dependent_slice_flag)
 {
 /*If slice is present at the start of a new tile*/
 if((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                ps_codec->s_parse.i4_ctb_slice_x = 0;
                ps_codec->s_parse.i4_ctb_slice_y = 0;
 }
 }

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
            ps_codec->s_parse.i4_ctb_slice_x = 0;
            ps_codec->s_parse.i4_ctb_slice_y = 0;
 }
 }

 /* Frame level initializations */
 if((0 == ps_codec->s_parse.i4_ctb_y) &&
 (0 == ps_codec->s_parse.i4_ctb_x))
 {
        ret = ihevcd_parse_pic_init(ps_codec);
        RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret);

        ps_codec->s_parse.pu4_pic_tu_idx[0] = 0;
        ps_codec->s_parse.pu4_pic_pu_idx[0] = 0;
        ps_codec->s_parse.i4_cur_independent_slice_idx = 0;
        ps_codec->s_parse.i4_ctb_tile_x = 0;
        ps_codec->s_parse.i4_ctb_tile_y = 0;
 }

 {
 /* Updating the poc list of current slice to ps_mv_buf */
 mv_buf_t *ps_mv_buf = ps_codec->s_parse.ps_cur_mv_buf;

 if(ps_slice_hdr->i1_num_ref_idx_l1_active != 0)
 {
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l1_active; i++)
 {
                ps_mv_buf->l1_collocated_poc[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_pic_buf)->i4_abs_poc;
                ps_mv_buf->u1_l1_collocated_poc_lt[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_pic_buf)->u1_used_as_ref;
 }
 }

 if(ps_slice_hdr->i1_num_ref_idx_l0_active != 0)
 {
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l0_active; i++)
 {
                ps_mv_buf->l0_collocated_poc[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_pic_buf)->i4_abs_poc;
                ps_mv_buf->u1_l0_collocated_poc_lt[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_pic_buf)->u1_used_as_ref;
 }
 }
 }

 /*Initialize the low delay flag at the beginning of every slice*/
 if((0 == ps_codec->s_parse.i4_ctb_slice_x) || (0 == ps_codec->s_parse.i4_ctb_slice_y))
 {
 /* Lowdelay flag */
        WORD32 cur_poc, ref_list_poc, flag = 1;
        cur_poc = ps_slice_hdr->i4_abs_pic_order_cnt;
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l0_active; i++)
 {
            ref_list_poc = ((mv_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_mv_buf)->i4_abs_poc;
 if(ref_list_poc > cur_poc)
 {
                flag = 0;
 break;
 }
 }
 if(flag && (ps_slice_hdr->i1_slice_type == BSLICE))
 {
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l1_active; i++)
 {
                ref_list_poc = ((mv_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_mv_buf)->i4_abs_poc;
 if(ref_list_poc > cur_poc)
 {
                    flag = 0;
 break;
 }
 }
 }
        ps_slice_hdr->i1_low_delay_flag = flag;
 }

 /* initialize the cabac init idc based on slice type */
 if(ps_slice_hdr->i1_slice_type == ISLICE)
 {
        cabac_init_idc = 0;
 }
 else if(ps_slice_hdr->i1_slice_type == PSLICE)
 {
        cabac_init_idc = ps_slice_hdr->i1_cabac_init_flag ? 2 : 1;
 }
 else
 {
        cabac_init_idc = ps_slice_hdr->i1_cabac_init_flag ? 1 : 2;
 }

    slice_qp = ps_slice_hdr->i1_slice_qp_delta + ps_pps->i1_pic_init_qp;
    slice_qp = CLIP3(slice_qp, 0, 51);

 /*Update QP value for every indepndent slice or for every dependent slice that begins at the start of a new tile*/
 if((0 == ps_slice_hdr->i1_dependent_slice_flag) ||
 ((1 == ps_slice_hdr->i1_dependent_slice_flag) && ((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))))
 {
        ps_codec->s_parse.u4_qp = slice_qp;
 }

 /*Cabac init at the beginning of a slice*/
 if((1 == ps_slice_hdr->i1_dependent_slice_flag) && (!((ps_codec->s_parse.i4_ctb_tile_x == 0) && (ps_codec->s_parse.i4_ctb_tile_y == 0))))
 {
 if((0 == ps_pps->i1_entropy_coding_sync_enabled_flag) || (ps_pps->i1_entropy_coding_sync_enabled_flag && (0 != ps_codec->s_parse.i4_ctb_x)))
 {
            ihevcd_cabac_reset(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm);
 }
 }
 else if((0 == ps_pps->i1_entropy_coding_sync_enabled_flag) || (ps_pps->i1_entropy_coding_sync_enabled_flag && (0 != ps_codec->s_parse.i4_ctb_x)))
 {
        ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                slice_qp,
                                cabac_init_idc,
 &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);
 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
            ps_codec->i4_slice_error = 1;
            end_of_slice_flag = 1;
            ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }
 }


 do
 {

 {
            WORD32 cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);
 if(1 == ps_codec->i4_num_cores && 0 == cur_ctb_idx % RESET_TU_BUF_NCTB)
 {
                ps_codec->s_parse.ps_tu = ps_codec->s_parse.ps_pic_tu;
                ps_codec->s_parse.i4_pic_tu_idx = 0;
 }
 }

        end_of_pic = 0;
 /* Section:7.3.7 Coding tree unit syntax */
 /* coding_tree_unit() inlined here */
 /* If number of cores is greater than 1, then add job to the queue */
 /* At the start of ctb row parsing in a tile, queue a job for processing the current tile row */
        ps_codec->s_parse.i4_ctb_num_pcm_blks = 0;


 /*At the beginning of each tile-which is not the beginning of a slice, cabac context must be initialized.
         * Hence, check for the tile beginning here */
 if(((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))
 && (!((ps_tile->u1_pos_x == 0) && (ps_tile->u1_pos_y == 0)))
 && (!((0 == ps_codec->s_parse.i4_ctb_slice_x) && (0 == ps_codec->s_parse.i4_ctb_slice_y))))
 {
            slice_qp = ps_slice_hdr->i1_slice_qp_delta + ps_pps->i1_pic_init_qp;
            slice_qp = CLIP3(slice_qp, 0, 51);
            ps_codec->s_parse.u4_qp = slice_qp;

            ihevcd_get_tile_pos(ps_pps, ps_sps, ps_codec->s_parse.i4_ctb_x,
                                ps_codec->s_parse.i4_ctb_y,
 &ps_codec->s_parse.i4_ctb_tile_x,
 &ps_codec->s_parse.i4_ctb_tile_y,
 &tile_idx);

            ps_codec->s_parse.ps_tile = ps_pps->ps_tile + tile_idx;
            ps_codec->s_parse.i4_cur_tile_idx = tile_idx;
            ps_tile_prev = ps_tile - 1;

            tile_start_ctb_idx = ps_tile->u1_pos_x
 + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);

            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x
 + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

 /*For slices that span across multiple tiles*/
 if(slice_start_ctb_idx < tile_start_ctb_idx)
 { /* 2 Cases
             * 1 - slice spans across frame-width- but does not start from 1st column
             * 2 - Slice spans across multiple tiles anywhere is a frame
             */
                ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y - ps_slice_hdr->i2_ctb_y;
 if(!(((ps_slice_hdr->i2_ctb_x + ps_tile_prev->u2_wd) % ps_sps->i2_pic_wd_in_ctb) == ps_tile->u1_pos_x)) //Case 2
 {
 if(ps_slice_hdr->i2_ctb_y <= ps_tile->u1_pos_y)
 {
 if(ps_slice_hdr->i2_ctb_x > ps_tile->u1_pos_x)
 {
                            ps_codec->s_parse.i4_ctb_slice_y -= 1;
 }
 }
 }
 /*ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y - ps_slice_hdr->i2_ctb_y;
                if (ps_slice_hdr->i2_ctb_y <= ps_tile->u1_pos_y)
                {
                    if (ps_slice_hdr->i2_ctb_x > ps_tile->u1_pos_x )
                    {
                        ps_codec->s_parse.i4_ctb_slice_y -= 1 ;
                    }
                }*/
 }

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
                ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                        slice_qp,
                                        cabac_init_idc,
 &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);
 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
                    ps_codec->i4_slice_error = 1;
                    end_of_slice_flag = 1;
                    ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }

 }
 }
 /* If number of cores is greater than 1, then add job to the queue */
 /* At the start of ctb row parsing in a tile, queue a job for processing the current tile row */

 if(0 == ps_codec->s_parse.i4_ctb_tile_x)
 {

 if(1 < ps_codec->i4_num_cores)
 {
 proc_job_t s_job;
                IHEVCD_ERROR_T ret;
                s_job.i4_cmd    = CMD_PROCESS;
                s_job.i2_ctb_cnt = (WORD16)ps_tile->u2_wd;
                s_job.i2_ctb_x = (WORD16)ps_codec->s_parse.i4_ctb_x;
                s_job.i2_ctb_y = (WORD16)ps_codec->s_parse.i4_ctb_y;
                s_job.i2_slice_idx = (WORD16)ps_codec->s_parse.i4_cur_slice_idx;
                s_job.i4_tu_coeff_data_ofst = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data -
 (UWORD8 *)ps_codec->s_parse.pv_pic_tu_coeff_data;
                ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq, &s_job, sizeof(proc_job_t), 1);

 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 return ret;
 }
 else
 {
 process_ctxt_t *ps_proc = &ps_codec->as_process[0];
                WORD32 tu_coeff_data_ofst = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data -
 (UWORD8 *)ps_codec->s_parse.pv_pic_tu_coeff_data;

 /* If the codec is running in single core mode,
                 * initialize zeroth process context
                 * TODO: Dual core mode might need a different implementation instead of jobq
                 */

                ps_proc->i4_ctb_cnt = ps_tile->u2_wd;
                ps_proc->i4_ctb_x   = ps_codec->s_parse.i4_ctb_x;
                ps_proc->i4_ctb_y   = ps_codec->s_parse.i4_ctb_y;
                ps_proc->i4_cur_slice_idx = ps_codec->s_parse.i4_cur_slice_idx;

                ihevcd_init_proc_ctxt(ps_proc, tu_coeff_data_ofst);
 }
 }


 /* Restore cabac context model from top right CTB if entropy sync is enabled */
 if(ps_pps->i1_entropy_coding_sync_enabled_flag)
 {
 /*TODO Handle single CTB and top-right belonging to a different slice */
 if(0 == ps_codec->s_parse.i4_ctb_x)
 {
                WORD32 default_ctxt = 0;

 if((0 == ps_codec->s_parse.i4_ctb_slice_y) && (!ps_slice_hdr->i1_dependent_slice_flag))
                    default_ctxt = 1;
 if(1 == ps_sps->i2_pic_wd_in_ctb)
                    default_ctxt = 1;

                ps_codec->s_parse.u4_qp = slice_qp;
 if(default_ctxt)
 {
                    ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                            slice_qp,
                                            cabac_init_idc,
 &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);

 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
                        ps_codec->i4_slice_error = 1;
                        end_of_slice_flag = 1;
                        ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }
 }
 else
 {
                    ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                            slice_qp,
                                            cabac_init_idc,
 (const UWORD8 *)&ps_codec->s_parse.s_cabac.au1_ctxt_models_sync);

 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
                        ps_codec->i4_slice_error = 1;
                        end_of_slice_flag = 1;
                        ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }
 }
 }
 }



 if(0 == ps_codec->i4_slice_error)
 {
 if(ps_slice_hdr->i1_slice_sao_luma_flag || ps_slice_hdr->i1_slice_sao_chroma_flag)
                ihevcd_parse_sao(ps_codec);
 }
 else
 {
 sao_t *ps_sao = ps_codec->s_parse.ps_pic_sao +
                            ps_codec->s_parse.i4_ctb_x +
                            ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb;

 /* Default values */
            ps_sao->b3_y_type_idx = 0;
            ps_sao->b3_cb_type_idx = 0;
            ps_sao->b3_cr_type_idx = 0;
 }


 {
            WORD32 ctb_indx;
            ctb_indx = ps_codec->s_parse.i4_ctb_x + ps_sps->i2_pic_wd_in_ctb * ps_codec->s_parse.i4_ctb_y;
            ps_codec->s_parse.s_bs_ctxt.pu1_pic_qp_const_in_ctb[ctb_indx >> 3] |= (1 << (ctb_indx & 7));
 {
                UWORD16 *pu1_slice_idx = ps_codec->s_parse.pu1_slice_idx;
                pu1_slice_idx[ctb_indx] = ps_codec->s_parse.i4_cur_independent_slice_idx;
 }
 }

 if(0 == ps_codec->i4_slice_error)
 {
 tu_t *ps_tu = ps_codec->s_parse.ps_tu;
            WORD32 i4_tu_cnt = ps_codec->s_parse.s_cu.i4_tu_cnt;
            WORD32 i4_pic_tu_idx = ps_codec->s_parse.i4_pic_tu_idx;

 pu_t *ps_pu = ps_codec->s_parse.ps_pu;
            WORD32 i4_pic_pu_idx = ps_codec->s_parse.i4_pic_pu_idx;

            UWORD8 *pu1_tu_coeff_data = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data;

            ret = ihevcd_parse_coding_quadtree(ps_codec,
 (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size),
 (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size),
                                               ps_sps->i1_log2_ctb_size,
 0);
 /* Check for error */

             if (ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
             {
                 /* Reset tu and pu parameters, and signal current ctb as skip */
                 WORD32 tu_coeff_data_reset_size;
 
                 ps_codec->s_parse.ps_tu = ps_tu;
                 ps_codec->s_parse.s_cu.i4_tu_cnt = i4_tu_cnt;
                 ps_codec->s_parse.i4_pic_tu_idx = i4_pic_tu_idx;


                 ps_codec->s_parse.ps_pu = ps_pu;
                 ps_codec->s_parse.i4_pic_pu_idx = i4_pic_pu_idx;
 
                 tu_coeff_data_reset_size = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data - pu1_tu_coeff_data;
                 memset(pu1_tu_coeff_data, 0, tu_coeff_data_reset_size);
                 ps_codec->s_parse.pv_tu_coeff_data = (void *)pu1_tu_coeff_data;
 
                ihevcd_set_ctb_skip(ps_codec);
 
                 /* Set slice error to suppress further parsing and
                  * signal end of slice.
                 */
                ps_codec->i4_slice_error = 1;
                end_of_slice_flag = 1;
                ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }

         }
         else
         {
            ihevcd_set_ctb_skip(ps_codec);
         }
 
         if(0 == ps_codec->i4_slice_error)
            end_of_slice_flag = ihevcd_cabac_decode_terminate(&ps_codec->s_parse.s_cabac, &ps_codec->s_parse.s_bitstrm);

        AEV_TRACE(""end_of_slice_flag"", end_of_slice_flag, ps_codec->s_parse.s_cabac.u4_range);


 /* In case of tiles or entropy sync, terminate cabac and copy cabac context backed up at the end of top-right CTB */
 if(ps_pps->i1_tiles_enabled_flag || ps_pps->i1_entropy_coding_sync_enabled_flag)
 {
            WORD32 end_of_tile = 0;
            WORD32 end_of_tile_row = 0;

 /* Take a back up of cabac context models if entropy sync is enabled */
 if(ps_pps->i1_entropy_coding_sync_enabled_flag || ps_pps->i1_tiles_enabled_flag)
 {
 if(1 == ps_codec->s_parse.i4_ctb_x)
 {
                    WORD32 size = sizeof(ps_codec->s_parse.s_cabac.au1_ctxt_models);
                    memcpy(&ps_codec->s_parse.s_cabac.au1_ctxt_models_sync, &ps_codec->s_parse.s_cabac.au1_ctxt_models, size);
 }
 }

 /* Since tiles and entropy sync are not enabled simultaneously, the following will not result in any problems */
 if((ps_codec->s_parse.i4_ctb_tile_x + 1) == (ps_tile->u2_wd))
 {
                end_of_tile_row = 1;
 if((ps_codec->s_parse.i4_ctb_tile_y + 1) == ps_tile->u2_ht)
                    end_of_tile = 1;
 }
 if((0 == end_of_slice_flag) &&
 ((ps_pps->i1_tiles_enabled_flag && end_of_tile) ||
 (ps_pps->i1_entropy_coding_sync_enabled_flag && end_of_tile_row)))
 {
                WORD32 end_of_sub_stream_one_bit;
                end_of_sub_stream_one_bit = ihevcd_cabac_decode_terminate(&ps_codec->s_parse.s_cabac, &ps_codec->s_parse.s_bitstrm);
                AEV_TRACE(""end_of_sub_stream_one_bit"", end_of_sub_stream_one_bit, ps_codec->s_parse.s_cabac.u4_range);

 /* TODO: Remove the check for offset when HM is updated to include a byte unconditionally even for aligned location */
 /* For Ittiam streams this check should not be there, for HM9.1 streams this should be there */
 if(ps_codec->s_parse.s_bitstrm.u4_bit_ofst % 8)
                    ihevcd_bits_flush_to_byte_boundary(&ps_codec->s_parse.s_bitstrm);

                UNUSED(end_of_sub_stream_one_bit);
 }
 }
 {
            WORD32 ctb_indx;

            ctb_addr = ps_codec->s_parse.i4_ctb_y * num_ctb_in_row + ps_codec->s_parse.i4_ctb_x;

            ctb_indx = ++ctb_addr;

 /* Store pu_idx for next CTB in frame level pu_idx array */

 if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))
 {
                ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.
 if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))
 {
 if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))
 {
                        ctb_indx = ctb_addr; //Next continuous ctb address
 }
 else //Not last tile's end , but a tile end
 {
 tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;
                        ctb_indx = ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.
 }
 }
 }

            ps_codec->s_parse.pu4_pic_pu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_pu_idx;
            ps_codec->s_parse.i4_next_pu_ctb_cnt = ctb_indx;

            ps_codec->s_parse.pu1_pu_map += num_min4x4_in_ctb;

 /* Store tu_idx for next CTB in frame level tu_idx array */
 if(1 == ps_codec->i4_num_cores)
 {
                ctb_indx = (0 == ctb_addr % RESET_TU_BUF_NCTB) ?
                                RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB;

 if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))
 {
                    ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.
 if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))
 {
 if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))
 {
                            ctb_indx = (0 == ctb_addr % RESET_TU_BUF_NCTB) ?
                                            RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB;
 }
 else //Not last tile's end , but a tile end
 {
 tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;
                            ctb_indx =  ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.
 }
 }
 }
                ps_codec->s_parse.i4_next_tu_ctb_cnt = ctb_indx;
                ps_codec->s_parse.pu4_pic_tu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_tu_idx;
 }
 else
 {
                ctb_indx = ctb_addr;
 if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))
 {
                    ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.
 if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))
 {
 if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))
 {
                            ctb_indx = ctb_addr;
 }
 else //Not last tile's end , but a tile end
 {
 tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;
                            ctb_indx =  ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.
 }
 }
 }
                ps_codec->s_parse.i4_next_tu_ctb_cnt = ctb_indx;
                ps_codec->s_parse.pu4_pic_tu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_tu_idx;
 }
            ps_codec->s_parse.pu1_tu_map += num_min4x4_in_ctb;
 }


 if(ps_codec->i4_num_cores <= MV_PRED_NUM_CORES_THRESHOLD)
 {
 /*************************************************/
 /****************   MV pred **********************/
 /*************************************************/
            WORD8 u1_top_ctb_avail = 1;
            WORD8 u1_left_ctb_avail = 1;
            WORD8 u1_top_lt_ctb_avail = 1;
            WORD8 u1_top_rt_ctb_avail = 1;
            WORD16 i2_wd_in_ctb;

            tile_start_ctb_idx = ps_tile->u1_pos_x
 + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);

            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x
 + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

 if((slice_start_ctb_idx < tile_start_ctb_idx))
 {
                i2_wd_in_ctb = ps_sps->i2_pic_wd_in_ctb;
 }
 else
 {
                i2_wd_in_ctb = ps_tile->u2_wd;
 }
 /* slice and tile boundaries */
 if((0 == ps_codec->s_parse.i4_ctb_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                u1_top_ctb_avail = 0;
                u1_top_lt_ctb_avail = 0;
                u1_top_rt_ctb_avail = 0;
 }

 if((0 == ps_codec->s_parse.i4_ctb_x) || (0 == ps_codec->s_parse.i4_ctb_tile_x))
 {
                u1_left_ctb_avail = 0;
                u1_top_lt_ctb_avail = 0;
 if((0 == ps_codec->s_parse.i4_ctb_slice_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                    u1_top_ctb_avail = 0;
 if((i2_wd_in_ctb - 1) != ps_codec->s_parse.i4_ctb_slice_x) //TODO: For tile, not implemented
 {
                        u1_top_rt_ctb_avail = 0;
 }
 }
 }
 /*For slices not beginning at start of a ctb row*/
 else if(ps_codec->s_parse.i4_ctb_x > 0)
 {
 if((0 == ps_codec->s_parse.i4_ctb_slice_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                    u1_top_ctb_avail = 0;
                    u1_top_lt_ctb_avail = 0;
 if(0 == ps_codec->s_parse.i4_ctb_slice_x)
 {
                        u1_left_ctb_avail = 0;
 }
 if((i2_wd_in_ctb - 1) != ps_codec->s_parse.i4_ctb_slice_x)
 {
                        u1_top_rt_ctb_avail = 0;
 }
 }
 else if((1 == ps_codec->s_parse.i4_ctb_slice_y) && (0 == ps_codec->s_parse.i4_ctb_slice_x))
 {
                    u1_top_lt_ctb_avail = 0;
 }
 }

 if(((ps_sps->i2_pic_wd_in_ctb - 1) == ps_codec->s_parse.i4_ctb_x) || ((ps_tile->u2_wd - 1) == ps_codec->s_parse.i4_ctb_tile_x))
 {
                u1_top_rt_ctb_avail = 0;
 }

 if(PSLICE == ps_slice_hdr->i1_slice_type
 || BSLICE == ps_slice_hdr->i1_slice_type)
 {
 mv_ctxt_t s_mv_ctxt;
 process_ctxt_t *ps_proc;
                UWORD32 *pu4_ctb_top_pu_idx;
                UWORD32 *pu4_ctb_left_pu_idx;
                UWORD32 *pu4_ctb_top_left_pu_idx;
                WORD32 i4_ctb_pu_cnt;
                WORD32 cur_ctb_idx;
                WORD32 next_ctb_idx;
                WORD32 cur_pu_idx;
                ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];
                cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);
                next_ctb_idx = ps_codec->s_parse.i4_next_pu_ctb_cnt;
                i4_ctb_pu_cnt = ps_codec->s_parse.pu4_pic_pu_idx[next_ctb_idx]
 - ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];

                cur_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];

                pu4_ctb_top_pu_idx = ps_proc->pu4_pic_pu_idx_top
 + (ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE);
                pu4_ctb_left_pu_idx = ps_proc->pu4_pic_pu_idx_left;
                pu4_ctb_top_left_pu_idx = &ps_proc->u4_ctb_top_left_pu_idx;

 /* Initializing s_mv_ctxt */
 {
                    s_mv_ctxt.ps_pps = ps_pps;
                    s_mv_ctxt.ps_sps = ps_sps;
                    s_mv_ctxt.ps_slice_hdr = ps_slice_hdr;
                    s_mv_ctxt.i4_ctb_x = ps_codec->s_parse.i4_ctb_x;
                    s_mv_ctxt.i4_ctb_y = ps_codec->s_parse.i4_ctb_y;
                    s_mv_ctxt.ps_pu = &ps_codec->s_parse.ps_pic_pu[cur_pu_idx];
                    s_mv_ctxt.ps_pic_pu = ps_codec->s_parse.ps_pic_pu;
                    s_mv_ctxt.ps_tile = ps_tile;
                    s_mv_ctxt.pu4_pic_pu_idx_map = ps_proc->pu4_pic_pu_idx_map;
                    s_mv_ctxt.pu4_pic_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx;
                    s_mv_ctxt.pu1_pic_pu_map = ps_codec->s_parse.pu1_pic_pu_map;
                    s_mv_ctxt.i4_ctb_pu_cnt = i4_ctb_pu_cnt;
                    s_mv_ctxt.i4_ctb_start_pu_idx = cur_pu_idx;
                    s_mv_ctxt.u1_top_ctb_avail = u1_top_ctb_avail;
                    s_mv_ctxt.u1_top_rt_ctb_avail = u1_top_rt_ctb_avail;
                    s_mv_ctxt.u1_top_lt_ctb_avail = u1_top_lt_ctb_avail;
                    s_mv_ctxt.u1_left_ctb_avail = u1_left_ctb_avail;
 }

                ihevcd_get_mv_ctb(&s_mv_ctxt, pu4_ctb_top_pu_idx,
                                  pu4_ctb_left_pu_idx, pu4_ctb_top_left_pu_idx);

 }
 else
 {
                WORD32 num_minpu_in_ctb = (ctb_size / MIN_PU_SIZE) * (ctb_size / MIN_PU_SIZE);
                UWORD8 *pu1_pic_pu_map_ctb = ps_codec->s_parse.pu1_pic_pu_map +
 (ps_codec->s_parse.i4_ctb_x + ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb) * num_minpu_in_ctb;
 process_ctxt_t *ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];
                WORD32 row, col;
                WORD32 pu_cnt;
                WORD32 num_pu_per_ctb;
                WORD32 cur_ctb_idx;
                WORD32 next_ctb_idx;
                WORD32 ctb_start_pu_idx;
                UWORD32 *pu4_nbr_pu_idx = ps_proc->pu4_pic_pu_idx_map;
                WORD32 nbr_pu_idx_strd = MAX_CTB_SIZE / MIN_PU_SIZE + 2;
 pu_t *ps_pu;

 for(row = 0; row < ctb_size / MIN_PU_SIZE; row++)
 {
 for(col = 0; col < ctb_size / MIN_PU_SIZE; col++)
 {
                        pu1_pic_pu_map_ctb[row * ctb_size / MIN_PU_SIZE + col] = 0;
 }
 }


 /* Neighbor PU idx update inside CTB */
 /* 1byte per 4x4. Indicates the PU idx that 4x4 block belongs to */

                cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);
                next_ctb_idx = ps_codec->s_parse.i4_next_pu_ctb_cnt;
                num_pu_per_ctb = ps_codec->s_parse.pu4_pic_pu_idx[next_ctb_idx]
 - ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];
                ctb_start_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];
                ps_pu = &ps_codec->s_parse.ps_pic_pu[ctb_start_pu_idx];

 for(pu_cnt = 0; pu_cnt < num_pu_per_ctb; pu_cnt++, ps_pu++)
 {
                    UWORD32 cur_pu_idx;
                    WORD32 pu_ht = (ps_pu->b4_ht + 1) << 2;
                    WORD32 pu_wd = (ps_pu->b4_wd + 1) << 2;

                    cur_pu_idx = ctb_start_pu_idx + pu_cnt;

 for(row = 0; row < pu_ht / MIN_PU_SIZE; row++)
 for(col = 0; col < pu_wd / MIN_PU_SIZE; col++)
                            pu4_nbr_pu_idx[(1 + ps_pu->b4_pos_x + col)
 + (1 + ps_pu->b4_pos_y + row)
 * nbr_pu_idx_strd] =
                                            cur_pu_idx;
 }

 /* Updating Top and Left pointers */
 {
                    WORD32 rows_remaining = ps_sps->i2_pic_height_in_luma_samples
 - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);
                    WORD32 ctb_size_left = MIN(ctb_size, rows_remaining);

 /* Top Left */
 /* saving top left before updating top ptr, as updating top ptr will overwrite the top left for the next ctb */
                    ps_proc->u4_ctb_top_left_pu_idx = ps_proc->pu4_pic_pu_idx_top[(ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE) + ctb_size / MIN_PU_SIZE - 1];
 for(i = 0; i < ctb_size / MIN_PU_SIZE; i++)
 {
 /* Left */
 /* Last column of au4_nbr_pu_idx */
                        ps_proc->pu4_pic_pu_idx_left[i] = pu4_nbr_pu_idx[(ctb_size / MIN_PU_SIZE)
 + (i + 1) * nbr_pu_idx_strd];
 /* Top */
 /* Last row of au4_nbr_pu_idx */
                        ps_proc->pu4_pic_pu_idx_top[(ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE) + i] =
                                        pu4_nbr_pu_idx[(ctb_size_left / MIN_PU_SIZE) * nbr_pu_idx_strd + i + 1];

 }
 }
 }

 /*************************************************/
 /******************  BS, QP  *********************/
 /*************************************************/
 /* Check if deblock is disabled for the current slice or if it is disabled for the current picture
             * because of disable deblock api
             */
 if(0 == ps_codec->i4_disable_deblk_pic)
 {
 if((0 == ps_slice_hdr->i1_slice_disable_deblocking_filter_flag) &&
 (0 == ps_codec->i4_slice_error))
 {
                    WORD32 i4_ctb_tu_cnt;
                    WORD32 cur_ctb_idx, next_ctb_idx;
                    WORD32 cur_pu_idx;
                    WORD32 cur_tu_idx;
 process_ctxt_t *ps_proc;

                    ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];
                    cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

                    cur_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];
                    next_ctb_idx = ps_codec->s_parse.i4_next_tu_ctb_cnt;
 if(1 == ps_codec->i4_num_cores)
 {
                        i4_ctb_tu_cnt = ps_codec->s_parse.pu4_pic_tu_idx[next_ctb_idx] -
                                        ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx % RESET_TU_BUF_NCTB];

                        cur_tu_idx = ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx % RESET_TU_BUF_NCTB];
 }
 else
 {
                        i4_ctb_tu_cnt = ps_codec->s_parse.pu4_pic_tu_idx[next_ctb_idx] -
                                        ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx];

                        cur_tu_idx = ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx];
 }

                    ps_codec->s_parse.s_bs_ctxt.ps_pps = ps_codec->s_parse.ps_pps;
                    ps_codec->s_parse.s_bs_ctxt.ps_sps = ps_codec->s_parse.ps_sps;
                    ps_codec->s_parse.s_bs_ctxt.ps_codec = ps_codec;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tu_cnt = i4_ctb_tu_cnt;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_x = ps_codec->s_parse.i4_ctb_x;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_y = ps_codec->s_parse.i4_ctb_y;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tile_x = ps_codec->s_parse.i4_ctb_tile_x;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tile_y = ps_codec->s_parse.i4_ctb_tile_y;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_slice_x = ps_codec->s_parse.i4_ctb_slice_x;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_slice_y = ps_codec->s_parse.i4_ctb_slice_y;
                    ps_codec->s_parse.s_bs_ctxt.ps_tu = &ps_codec->s_parse.ps_pic_tu[cur_tu_idx];
                    ps_codec->s_parse.s_bs_ctxt.ps_pu = &ps_codec->s_parse.ps_pic_pu[cur_pu_idx];
                    ps_codec->s_parse.s_bs_ctxt.pu4_pic_pu_idx_map = ps_proc->pu4_pic_pu_idx_map;
                    ps_codec->s_parse.s_bs_ctxt.i4_next_pu_ctb_cnt = ps_codec->s_parse.i4_next_pu_ctb_cnt;
                    ps_codec->s_parse.s_bs_ctxt.i4_next_tu_ctb_cnt = ps_codec->s_parse.i4_next_tu_ctb_cnt;
                    ps_codec->s_parse.s_bs_ctxt.pu1_slice_idx = ps_codec->s_parse.pu1_slice_idx;
                    ps_codec->s_parse.s_bs_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;
                    ps_codec->s_parse.s_bs_ctxt.ps_tile = ps_codec->s_parse.ps_tile;

 if(ISLICE == ps_slice_hdr->i1_slice_type)
 {
                        ihevcd_ctb_boundary_strength_islice(&ps_codec->s_parse.s_bs_ctxt);
 }
 else
 {
                        ihevcd_ctb_boundary_strength_pbslice(&ps_codec->s_parse.s_bs_ctxt);
 }
 }
 else
 {
                    WORD32 bs_strd = (ps_sps->i2_pic_wd_in_ctb + 1) * (ctb_size * ctb_size / 8 / 16);

                    UWORD32 *pu4_vert_bs = (UWORD32 *)((UWORD8 *)ps_codec->s_parse.s_bs_ctxt.pu4_pic_vert_bs +
                                    ps_codec->s_parse.i4_ctb_x * (ctb_size * ctb_size / 8 / 16) +
                                    ps_codec->s_parse.i4_ctb_y * bs_strd);
                    UWORD32 *pu4_horz_bs = (UWORD32 *)((UWORD8 *)ps_codec->s_parse.s_bs_ctxt.pu4_pic_horz_bs +
                                    ps_codec->s_parse.i4_ctb_x * (ctb_size * ctb_size / 8 / 16) +
                                    ps_codec->s_parse.i4_ctb_y * bs_strd);

                    memset(pu4_vert_bs, 0, (ctb_size / 8 + 1) * (ctb_size / 4) / 8 * 2);
                    memset(pu4_horz_bs, 0, (ctb_size / 8) * (ctb_size / 4) / 8 * 2);

 }
 }

 }


 /* Update the parse status map */
 {
 sps_t *ps_sps = ps_codec->s_parse.ps_sps;
            UWORD8 *pu1_buf;
            WORD32 idx;
            idx = (ps_codec->s_parse.i4_ctb_x);
            idx += ((ps_codec->s_parse.i4_ctb_y) * ps_sps->i2_pic_wd_in_ctb);
            pu1_buf = (ps_codec->pu1_parse_map + idx);
 *pu1_buf = 1;
 }

 /* Increment CTB x and y positions */
        ps_codec->s_parse.i4_ctb_tile_x++;
        ps_codec->s_parse.i4_ctb_x++;
        ps_codec->s_parse.i4_ctb_slice_x++;

 /*If tiles are enabled, handle the slice counters differently*/
 if(ps_pps->i1_tiles_enabled_flag)
 {
            tile_start_ctb_idx = ps_tile->u1_pos_x
 + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);

            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x
 + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

 if((slice_start_ctb_idx < tile_start_ctb_idx))
 {
 if(ps_codec->s_parse.i4_ctb_slice_x == (ps_tile->u1_pos_x + ps_tile->u2_wd))
 {
 /* Reached end of slice row within a tile /frame */
                    ps_codec->s_parse.i4_ctb_slice_y++;
                    ps_codec->s_parse.i4_ctb_slice_x = ps_tile->u1_pos_x; //todo:Check
 }
 }
 else if(ps_codec->s_parse.i4_ctb_slice_x == (ps_tile->u2_wd))
 {
                ps_codec->s_parse.i4_ctb_slice_y++;
                ps_codec->s_parse.i4_ctb_slice_x = 0;
 }
 }
 else
 {
 if(ps_codec->s_parse.i4_ctb_slice_x == ps_tile->u2_wd)
 {
 /* Reached end of slice row within a tile /frame */
                ps_codec->s_parse.i4_ctb_slice_y++;
                ps_codec->s_parse.i4_ctb_slice_x = 0;
 }
 }


 if(ps_codec->s_parse.i4_ctb_tile_x == (ps_tile->u2_wd))
 {
 /* Reached end of tile row */
            ps_codec->s_parse.i4_ctb_tile_x = 0;
            ps_codec->s_parse.i4_ctb_x = ps_tile->u1_pos_x;

            ps_codec->s_parse.i4_ctb_tile_y++;
            ps_codec->s_parse.i4_ctb_y++;

 if(ps_codec->s_parse.i4_ctb_tile_y == (ps_tile->u2_ht))
 {
 /* Reached End of Tile */
                ps_codec->s_parse.i4_ctb_tile_y = 0;
                ps_codec->s_parse.i4_ctb_tile_x = 0;
                ps_codec->s_parse.ps_tile++;

 if((ps_tile->u2_ht + ps_tile->u1_pos_y  ==  ps_sps->i2_pic_ht_in_ctb) && (ps_tile->u2_wd + ps_tile->u1_pos_x  ==  ps_sps->i2_pic_wd_in_ctb))
 {
 /* Reached end of frame */
                    end_of_pic = 1;
                    ps_codec->s_parse.i4_ctb_x = 0;
                    ps_codec->s_parse.i4_ctb_y = ps_sps->i2_pic_ht_in_ctb;
 }
 else
 {
 /* Initialize ctb_x and ctb_y to start of next tile */
                    ps_tile = ps_codec->s_parse.ps_tile;
                    ps_codec->s_parse.i4_ctb_x = ps_tile->u1_pos_x;
                    ps_codec->s_parse.i4_ctb_y = ps_tile->u1_pos_y;
                    ps_codec->s_parse.i4_ctb_tile_y = 0;
                    ps_codec->s_parse.i4_ctb_tile_x = 0;
                    ps_codec->s_parse.i4_ctb_slice_x = ps_tile->u1_pos_x;
                    ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y;

 }
 }

 }

        ps_codec->s_parse.i4_next_ctb_indx = ps_codec->s_parse.i4_ctb_x +
                        ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb;

 /* If the current slice is in error, check if the next slice's address
         * is reached and mark the end_of_slice flag */
 if(ps_codec->i4_slice_error)
 {
 slice_header_t *ps_slice_hdr_next = ps_slice_hdr + 1;
            WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x +
                            ps_slice_hdr_next->i2_ctb_y * ps_sps->i2_pic_wd_in_ctb;

 if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr)
                end_of_slice_flag = 1;
 }

 /* If the codec is running in single core mode
         * then call process function for current CTB
         */
 if((1 == ps_codec->i4_num_cores) && (ps_codec->s_parse.i4_ctb_tile_x == 0))
 {
 process_ctxt_t *ps_proc = &ps_codec->as_process[0];
            ps_proc->i4_ctb_cnt = ps_proc->ps_tile->u2_wd;
            ihevcd_process(ps_proc);
 }

 /* If the bytes for the current slice are exhausted
         * set end_of_slice flag to 1
         * This slice will be treated as incomplete */
 if((UWORD8 *)ps_codec->s_parse.s_bitstrm.pu1_buf_max + BITSTRM_OFF_THRS <
 ((UWORD8 *)ps_codec->s_parse.s_bitstrm.pu4_buf + (ps_codec->s_parse.s_bitstrm.u4_bit_ofst / 8)))
 {

 if(0 == ps_codec->i4_slice_error)
                end_of_slice_flag = 1;
 }


 if(end_of_pic)
 break;
 } while(!end_of_slice_flag);

 /* Reset slice error */
    ps_codec->i4_slice_error = 0;

 /* Increment the slice index for parsing next slice */
 if(0 == end_of_pic)
 {
 while(1)
 {

            WORD32 parse_slice_idx;
            parse_slice_idx = ps_codec->s_parse.i4_cur_slice_idx;
            parse_slice_idx++;

 {
 /* If the next slice header is not initialized, update cur_slice_idx and break */
 if((1 == ps_codec->i4_num_cores) || (0 != (parse_slice_idx & (MAX_SLICE_HDR_CNT - 1))))
 {
                    ps_codec->s_parse.i4_cur_slice_idx = parse_slice_idx;
 break;
 }

 /* If the next slice header is initialised, wait for the parsed slices to be processed */
 else
 {
                    WORD32 ctb_indx = 0;

 while(ctb_indx != ps_sps->i4_pic_size_in_ctb)
 {
                        WORD32 parse_status = *(ps_codec->pu1_parse_map + ctb_indx);
 volatile WORD32 proc_status = *(ps_codec->pu1_proc_map + ctb_indx) & 1;

 if(parse_status == proc_status)
                            ctb_indx++;
 }
                    ps_codec->s_parse.i4_cur_slice_idx = parse_slice_idx;
 break;
 }

 }
 }

 }
 else
 {
#if FRAME_ILF_PAD
 if(FRAME_ILF_PAD && 1 == ps_codec->i4_num_cores)
 {
 if(ps_slice_hdr->i4_abs_pic_order_cnt == 0)
 {
                DUMP_PRE_ILF(ps_codec->as_process[0].pu1_cur_pic_luma,
                             ps_codec->as_process[0].pu1_cur_pic_chroma,
                             ps_sps->i2_pic_width_in_luma_samples,
                             ps_sps->i2_pic_height_in_luma_samples,
                             ps_codec->i4_strd);

                DUMP_BS(ps_codec->as_process[0].s_bs_ctxt.pu4_pic_vert_bs,
                        ps_codec->as_process[0].s_bs_ctxt.pu4_pic_horz_bs,
                        ps_sps->i2_pic_wd_in_ctb * (ctb_size * ctb_size / 8 / 16) * ps_sps->i2_pic_ht_in_ctb,
 (ps_sps->i2_pic_wd_in_ctb + 1) * (ctb_size * ctb_size / 8 / 16) * ps_sps->i2_pic_ht_in_ctb);

                DUMP_QP(ps_codec->as_process[0].s_bs_ctxt.pu1_pic_qp,
 (ps_sps->i2_pic_height_in_luma_samples * ps_sps->i2_pic_width_in_luma_samples) / (MIN_CU_SIZE * MIN_CU_SIZE));

                DUMP_QP_CONST_IN_CTB(ps_codec->as_process[0].s_bs_ctxt.pu1_pic_qp_const_in_ctb,
 (ps_sps->i2_pic_height_in_luma_samples * ps_sps->i2_pic_width_in_luma_samples) / (MIN_CTB_SIZE * MIN_CTB_SIZE) / 8);

                DUMP_NO_LOOP_FILTER(ps_codec->as_process[0].pu1_pic_no_loop_filter_flag,
 (ps_sps->i2_pic_width_in_luma_samples / MIN_CU_SIZE) * (ps_sps->i2_pic_height_in_luma_samples / MIN_CU_SIZE) / 8);

                DUMP_OFFSETS(ps_slice_hdr->i1_beta_offset_div2,
                             ps_slice_hdr->i1_tc_offset_div2,
                             ps_pps->i1_pic_cb_qp_offset,
                             ps_pps->i1_pic_cr_qp_offset);
 }
            ps_codec->s_parse.s_deblk_ctxt.ps_pps = ps_codec->s_parse.ps_pps;
            ps_codec->s_parse.s_deblk_ctxt.ps_sps = ps_codec->s_parse.ps_sps;
            ps_codec->s_parse.s_deblk_ctxt.ps_codec = ps_codec;
            ps_codec->s_parse.s_deblk_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;
            ps_codec->s_parse.s_deblk_ctxt.is_chroma_yuv420sp_vu = (ps_codec->e_ref_chroma_fmt == IV_YUV_420SP_VU);

            ps_codec->s_parse.s_sao_ctxt.ps_pps = ps_codec->s_parse.ps_pps;
            ps_codec->s_parse.s_sao_ctxt.ps_sps = ps_codec->s_parse.ps_sps;
            ps_codec->s_parse.s_sao_ctxt.ps_codec = ps_codec;
            ps_codec->s_parse.s_sao_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;

            ihevcd_ilf_pad_frame(&ps_codec->s_parse.s_deblk_ctxt, &ps_codec->s_parse.s_sao_ctxt);

 }
#endif
        ps_codec->s_parse.i4_end_of_frame = 1;
 }
 return ret;
}
","IHEVCD_ERROR_T ihevcd_parse_slice_data(codec_t *ps_codec)
{

    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
    WORD32 end_of_slice_flag = 0;
 sps_t *ps_sps;
 pps_t *ps_pps;
 slice_header_t *ps_slice_hdr;
    WORD32 end_of_pic;
 tile_t *ps_tile, *ps_tile_prev;
    WORD32 i;
    WORD32 ctb_addr;
    WORD32 tile_idx;
    WORD32 cabac_init_idc;
    WORD32 ctb_size;
    WORD32 num_ctb_in_row;
    WORD32 num_min4x4_in_ctb;
    WORD32 slice_qp;
    WORD32 slice_start_ctb_idx;
    WORD32 tile_start_ctb_idx;


    ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base;
    ps_pps = ps_codec->s_parse.ps_pps_base;
    ps_sps = ps_codec->s_parse.ps_sps_base;

 /* Get current slice header, pps and sps */
    ps_slice_hdr += (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));
    ps_pps  += ps_slice_hdr->i1_pps_id;
    ps_sps  += ps_pps->i1_sps_id;

 if(0 != ps_codec->s_parse.i4_cur_slice_idx)
 {
 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
            ps_codec->s_parse.i4_cur_independent_slice_idx++;
 if(MAX_SLICE_HDR_CNT == ps_codec->s_parse.i4_cur_independent_slice_idx)
                ps_codec->s_parse.i4_cur_independent_slice_idx = 0;
 }
 }


    ctb_size = 1 << ps_sps->i1_log2_ctb_size;
    num_min4x4_in_ctb = (ctb_size / 4) * (ctb_size / 4);
    num_ctb_in_row = ps_sps->i2_pic_wd_in_ctb;

 /* Update the parse context */
 if(0 == ps_codec->i4_slice_error)
 {
        ps_codec->s_parse.i4_ctb_x = ps_slice_hdr->i2_ctb_x;
        ps_codec->s_parse.i4_ctb_y = ps_slice_hdr->i2_ctb_y;
 }
    ps_codec->s_parse.ps_pps = ps_pps;
    ps_codec->s_parse.ps_sps = ps_sps;
    ps_codec->s_parse.ps_slice_hdr = ps_slice_hdr;

 /* Derive Tile positions for the current CTB */
 /* Change this to lookup if required */
    ihevcd_get_tile_pos(ps_pps, ps_sps, ps_codec->s_parse.i4_ctb_x,
                        ps_codec->s_parse.i4_ctb_y,
 &ps_codec->s_parse.i4_ctb_tile_x,
 &ps_codec->s_parse.i4_ctb_tile_y,
 &tile_idx);
    ps_codec->s_parse.ps_tile = ps_pps->ps_tile + tile_idx;
    ps_codec->s_parse.i4_cur_tile_idx = tile_idx;
    ps_tile = ps_codec->s_parse.ps_tile;
 if(tile_idx)
        ps_tile_prev = ps_tile - 1;
 else
        ps_tile_prev = ps_tile;

 /* If the present slice is dependent, then store the previous
     * independent slices' ctb x and y values for decoding process */
 if(0 == ps_codec->i4_slice_error)
 {
 if(1 == ps_slice_hdr->i1_dependent_slice_flag)
 {
 /*If slice is present at the start of a new tile*/
 if((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                ps_codec->s_parse.i4_ctb_slice_x = 0;
                ps_codec->s_parse.i4_ctb_slice_y = 0;
 }
 }

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
            ps_codec->s_parse.i4_ctb_slice_x = 0;
            ps_codec->s_parse.i4_ctb_slice_y = 0;
 }
 }

 /* Frame level initializations */
 if((0 == ps_codec->s_parse.i4_ctb_y) &&
 (0 == ps_codec->s_parse.i4_ctb_x))
 {
        ret = ihevcd_parse_pic_init(ps_codec);
        RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret);

        ps_codec->s_parse.pu4_pic_tu_idx[0] = 0;
        ps_codec->s_parse.pu4_pic_pu_idx[0] = 0;
        ps_codec->s_parse.i4_cur_independent_slice_idx = 0;
        ps_codec->s_parse.i4_ctb_tile_x = 0;
        ps_codec->s_parse.i4_ctb_tile_y = 0;
 }

 {
 /* Updating the poc list of current slice to ps_mv_buf */
 mv_buf_t *ps_mv_buf = ps_codec->s_parse.ps_cur_mv_buf;

 if(ps_slice_hdr->i1_num_ref_idx_l1_active != 0)
 {
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l1_active; i++)
 {
                ps_mv_buf->l1_collocated_poc[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_pic_buf)->i4_abs_poc;
                ps_mv_buf->u1_l1_collocated_poc_lt[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_pic_buf)->u1_used_as_ref;
 }
 }

 if(ps_slice_hdr->i1_num_ref_idx_l0_active != 0)
 {
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l0_active; i++)
 {
                ps_mv_buf->l0_collocated_poc[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_pic_buf)->i4_abs_poc;
                ps_mv_buf->u1_l0_collocated_poc_lt[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_pic_buf)->u1_used_as_ref;
 }
 }
 }

 /*Initialize the low delay flag at the beginning of every slice*/
 if((0 == ps_codec->s_parse.i4_ctb_slice_x) || (0 == ps_codec->s_parse.i4_ctb_slice_y))
 {
 /* Lowdelay flag */
        WORD32 cur_poc, ref_list_poc, flag = 1;
        cur_poc = ps_slice_hdr->i4_abs_pic_order_cnt;
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l0_active; i++)
 {
            ref_list_poc = ((mv_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_mv_buf)->i4_abs_poc;
 if(ref_list_poc > cur_poc)
 {
                flag = 0;
 break;
 }
 }
 if(flag && (ps_slice_hdr->i1_slice_type == BSLICE))
 {
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l1_active; i++)
 {
                ref_list_poc = ((mv_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_mv_buf)->i4_abs_poc;
 if(ref_list_poc > cur_poc)
 {
                    flag = 0;
 break;
 }
 }
 }
        ps_slice_hdr->i1_low_delay_flag = flag;
 }

 /* initialize the cabac init idc based on slice type */
 if(ps_slice_hdr->i1_slice_type == ISLICE)
 {
        cabac_init_idc = 0;
 }
 else if(ps_slice_hdr->i1_slice_type == PSLICE)
 {
        cabac_init_idc = ps_slice_hdr->i1_cabac_init_flag ? 2 : 1;
 }
 else
 {
        cabac_init_idc = ps_slice_hdr->i1_cabac_init_flag ? 1 : 2;
 }

    slice_qp = ps_slice_hdr->i1_slice_qp_delta + ps_pps->i1_pic_init_qp;
    slice_qp = CLIP3(slice_qp, 0, 51);

 /*Update QP value for every indepndent slice or for every dependent slice that begins at the start of a new tile*/
 if((0 == ps_slice_hdr->i1_dependent_slice_flag) ||
 ((1 == ps_slice_hdr->i1_dependent_slice_flag) && ((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))))
 {
        ps_codec->s_parse.u4_qp = slice_qp;
 }

 /*Cabac init at the beginning of a slice*/
 if((1 == ps_slice_hdr->i1_dependent_slice_flag) && (!((ps_codec->s_parse.i4_ctb_tile_x == 0) && (ps_codec->s_parse.i4_ctb_tile_y == 0))))
 {
 if((0 == ps_pps->i1_entropy_coding_sync_enabled_flag) || (ps_pps->i1_entropy_coding_sync_enabled_flag && (0 != ps_codec->s_parse.i4_ctb_x)))
 {
            ihevcd_cabac_reset(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm);
 }
 }
 else if((0 == ps_pps->i1_entropy_coding_sync_enabled_flag) || (ps_pps->i1_entropy_coding_sync_enabled_flag && (0 != ps_codec->s_parse.i4_ctb_x)))
 {
        ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                slice_qp,
                                cabac_init_idc,
 &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);
 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
            ps_codec->i4_slice_error = 1;
            end_of_slice_flag = 1;
            ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }
 }


 do
 {

 {
            WORD32 cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);
 if(1 == ps_codec->i4_num_cores && 0 == cur_ctb_idx % RESET_TU_BUF_NCTB)
 {
                ps_codec->s_parse.ps_tu = ps_codec->s_parse.ps_pic_tu;
                ps_codec->s_parse.i4_pic_tu_idx = 0;
 }
 }

        end_of_pic = 0;
 /* Section:7.3.7 Coding tree unit syntax */
 /* coding_tree_unit() inlined here */
 /* If number of cores is greater than 1, then add job to the queue */
 /* At the start of ctb row parsing in a tile, queue a job for processing the current tile row */
        ps_codec->s_parse.i4_ctb_num_pcm_blks = 0;


 /*At the beginning of each tile-which is not the beginning of a slice, cabac context must be initialized.
         * Hence, check for the tile beginning here */
 if(((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))
 && (!((ps_tile->u1_pos_x == 0) && (ps_tile->u1_pos_y == 0)))
 && (!((0 == ps_codec->s_parse.i4_ctb_slice_x) && (0 == ps_codec->s_parse.i4_ctb_slice_y))))
 {
            slice_qp = ps_slice_hdr->i1_slice_qp_delta + ps_pps->i1_pic_init_qp;
            slice_qp = CLIP3(slice_qp, 0, 51);
            ps_codec->s_parse.u4_qp = slice_qp;

            ihevcd_get_tile_pos(ps_pps, ps_sps, ps_codec->s_parse.i4_ctb_x,
                                ps_codec->s_parse.i4_ctb_y,
 &ps_codec->s_parse.i4_ctb_tile_x,
 &ps_codec->s_parse.i4_ctb_tile_y,
 &tile_idx);

            ps_codec->s_parse.ps_tile = ps_pps->ps_tile + tile_idx;
            ps_codec->s_parse.i4_cur_tile_idx = tile_idx;
            ps_tile_prev = ps_tile - 1;

            tile_start_ctb_idx = ps_tile->u1_pos_x
 + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);

            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x
 + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

 /*For slices that span across multiple tiles*/
 if(slice_start_ctb_idx < tile_start_ctb_idx)
 { /* 2 Cases
             * 1 - slice spans across frame-width- but does not start from 1st column
             * 2 - Slice spans across multiple tiles anywhere is a frame
             */
                ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y - ps_slice_hdr->i2_ctb_y;
 if(!(((ps_slice_hdr->i2_ctb_x + ps_tile_prev->u2_wd) % ps_sps->i2_pic_wd_in_ctb) == ps_tile->u1_pos_x)) //Case 2
 {
 if(ps_slice_hdr->i2_ctb_y <= ps_tile->u1_pos_y)
 {
 if(ps_slice_hdr->i2_ctb_x > ps_tile->u1_pos_x)
 {
                            ps_codec->s_parse.i4_ctb_slice_y -= 1;
 }
 }
 }
 /*ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y - ps_slice_hdr->i2_ctb_y;
                if (ps_slice_hdr->i2_ctb_y <= ps_tile->u1_pos_y)
                {
                    if (ps_slice_hdr->i2_ctb_x > ps_tile->u1_pos_x )
                    {
                        ps_codec->s_parse.i4_ctb_slice_y -= 1 ;
                    }
                }*/
 }

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
                ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                        slice_qp,
                                        cabac_init_idc,
 &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);
 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
                    ps_codec->i4_slice_error = 1;
                    end_of_slice_flag = 1;
                    ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }

 }
 }
 /* If number of cores is greater than 1, then add job to the queue */
 /* At the start of ctb row parsing in a tile, queue a job for processing the current tile row */

 if(0 == ps_codec->s_parse.i4_ctb_tile_x)
 {

 if(1 < ps_codec->i4_num_cores)
 {
 proc_job_t s_job;
                IHEVCD_ERROR_T ret;
                s_job.i4_cmd    = CMD_PROCESS;
                s_job.i2_ctb_cnt = (WORD16)ps_tile->u2_wd;
                s_job.i2_ctb_x = (WORD16)ps_codec->s_parse.i4_ctb_x;
                s_job.i2_ctb_y = (WORD16)ps_codec->s_parse.i4_ctb_y;
                s_job.i2_slice_idx = (WORD16)ps_codec->s_parse.i4_cur_slice_idx;
                s_job.i4_tu_coeff_data_ofst = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data -
 (UWORD8 *)ps_codec->s_parse.pv_pic_tu_coeff_data;
                ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq, &s_job, sizeof(proc_job_t), 1);

 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 return ret;
 }
 else
 {
 process_ctxt_t *ps_proc = &ps_codec->as_process[0];
                WORD32 tu_coeff_data_ofst = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data -
 (UWORD8 *)ps_codec->s_parse.pv_pic_tu_coeff_data;

 /* If the codec is running in single core mode,
                 * initialize zeroth process context
                 * TODO: Dual core mode might need a different implementation instead of jobq
                 */

                ps_proc->i4_ctb_cnt = ps_tile->u2_wd;
                ps_proc->i4_ctb_x   = ps_codec->s_parse.i4_ctb_x;
                ps_proc->i4_ctb_y   = ps_codec->s_parse.i4_ctb_y;
                ps_proc->i4_cur_slice_idx = ps_codec->s_parse.i4_cur_slice_idx;

                ihevcd_init_proc_ctxt(ps_proc, tu_coeff_data_ofst);
 }
 }


 /* Restore cabac context model from top right CTB if entropy sync is enabled */
 if(ps_pps->i1_entropy_coding_sync_enabled_flag)
 {
 /*TODO Handle single CTB and top-right belonging to a different slice */
 if(0 == ps_codec->s_parse.i4_ctb_x)
 {
                WORD32 default_ctxt = 0;

 if((0 == ps_codec->s_parse.i4_ctb_slice_y) && (!ps_slice_hdr->i1_dependent_slice_flag))
                    default_ctxt = 1;
 if(1 == ps_sps->i2_pic_wd_in_ctb)
                    default_ctxt = 1;

                ps_codec->s_parse.u4_qp = slice_qp;
 if(default_ctxt)
 {
                    ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                            slice_qp,
                                            cabac_init_idc,
 &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);

 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
                        ps_codec->i4_slice_error = 1;
                        end_of_slice_flag = 1;
                        ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }
 }
 else
 {
                    ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                            slice_qp,
                                            cabac_init_idc,
 (const UWORD8 *)&ps_codec->s_parse.s_cabac.au1_ctxt_models_sync);

 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
                        ps_codec->i4_slice_error = 1;
                        end_of_slice_flag = 1;
                        ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }
 }
 }
 }



 if(0 == ps_codec->i4_slice_error)
 {
 if(ps_slice_hdr->i1_slice_sao_luma_flag || ps_slice_hdr->i1_slice_sao_chroma_flag)
                ihevcd_parse_sao(ps_codec);
 }
 else
 {
 sao_t *ps_sao = ps_codec->s_parse.ps_pic_sao +
                            ps_codec->s_parse.i4_ctb_x +
                            ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb;

 /* Default values */
            ps_sao->b3_y_type_idx = 0;
            ps_sao->b3_cb_type_idx = 0;
            ps_sao->b3_cr_type_idx = 0;
 }


 {
            WORD32 ctb_indx;
            ctb_indx = ps_codec->s_parse.i4_ctb_x + ps_sps->i2_pic_wd_in_ctb * ps_codec->s_parse.i4_ctb_y;
            ps_codec->s_parse.s_bs_ctxt.pu1_pic_qp_const_in_ctb[ctb_indx >> 3] |= (1 << (ctb_indx & 7));
 {
                UWORD16 *pu1_slice_idx = ps_codec->s_parse.pu1_slice_idx;
                pu1_slice_idx[ctb_indx] = ps_codec->s_parse.i4_cur_independent_slice_idx;
 }
 }

 if(0 == ps_codec->i4_slice_error)
 {
 tu_t *ps_tu = ps_codec->s_parse.ps_tu;
            WORD32 i4_tu_cnt = ps_codec->s_parse.s_cu.i4_tu_cnt;
            WORD32 i4_pic_tu_idx = ps_codec->s_parse.i4_pic_tu_idx;

 pu_t *ps_pu = ps_codec->s_parse.ps_pu;
            WORD32 i4_pic_pu_idx = ps_codec->s_parse.i4_pic_pu_idx;

            UWORD8 *pu1_tu_coeff_data = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data;

            ret = ihevcd_parse_coding_quadtree(ps_codec,
 (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size),
 (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size),
                                               ps_sps->i1_log2_ctb_size,
 0);
 /* Check for error */

             if (ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
             {
                 /* Reset tu and pu parameters, and signal current ctb as skip */
                WORD32 pu_skip_wd, pu_skip_ht;
                WORD32 rows_remaining, cols_remaining;
                 WORD32 tu_coeff_data_reset_size;
 
                /* Set pu wd and ht based on whether the ctb is complete or not */
                rows_remaining = ps_sps->i2_pic_height_in_luma_samples
                                - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);
                pu_skip_ht = MIN(ctb_size, rows_remaining);
                cols_remaining = ps_sps->i2_pic_width_in_luma_samples
                                - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size);
                pu_skip_wd = MIN(ctb_size, cols_remaining);
                 ps_codec->s_parse.ps_tu = ps_tu;
                 ps_codec->s_parse.s_cu.i4_tu_cnt = i4_tu_cnt;
                 ps_codec->s_parse.i4_pic_tu_idx = i4_pic_tu_idx;


                 ps_codec->s_parse.ps_pu = ps_pu;
                 ps_codec->s_parse.i4_pic_pu_idx = i4_pic_pu_idx;
 
                ps_tu->b1_cb_cbf = 0;
                ps_tu->b1_cr_cbf = 0;
                ps_tu->b1_y_cbf = 0;
                ps_tu->b4_pos_x = 0;
                ps_tu->b4_pos_y = 0;
                ps_tu->b1_transquant_bypass = 0;
                ps_tu->b3_size = (ps_sps->i1_log2_ctb_size - 2);
                ps_tu->b7_qp = ps_codec->s_parse.u4_qp;
                ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;
                ps_tu->b6_luma_intra_mode   = INTRA_PRED_NONE;
                ps_tu->b1_first_tu_in_cu = 1;
                 tu_coeff_data_reset_size = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data - pu1_tu_coeff_data;
                 memset(pu1_tu_coeff_data, 0, tu_coeff_data_reset_size);
                 ps_codec->s_parse.pv_tu_coeff_data = (void *)pu1_tu_coeff_data;
 
                ps_codec->s_parse.ps_tu++;
                ps_codec->s_parse.s_cu.i4_tu_cnt++;
                ps_codec->s_parse.i4_pic_tu_idx++;
                ps_codec->s_parse.s_cu.i4_pred_mode = PRED_MODE_SKIP;
                ps_codec->s_parse.s_cu.i4_part_mode = PART_2Nx2N;
                ps_pu->b2_part_idx = 0;
                ps_pu->b4_pos_x = 0;
                ps_pu->b4_pos_y = 0;
                ps_pu->b4_wd = (pu_skip_wd >> 2) - 1;
                ps_pu->b4_ht = (pu_skip_ht >> 2) - 1;
                ps_pu->b1_intra_flag = 0;
                ps_pu->b3_part_mode = ps_codec->s_parse.s_cu.i4_part_mode;
                ps_pu->b1_merge_flag = 1;
                ps_pu->b3_merge_idx = 0;
                ps_codec->s_parse.ps_pu++;
                ps_codec->s_parse.i4_pic_pu_idx++;
 
                 /* Set slice error to suppress further parsing and
                  * signal end of slice.
                 */
                ps_codec->i4_slice_error = 1;
                end_of_slice_flag = 1;
                ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }

         }
         else
         {
            tu_t *ps_tu = ps_codec->s_parse.ps_tu;
            pu_t *ps_pu = ps_codec->s_parse.ps_pu;
            WORD32 pu_skip_wd, pu_skip_ht;
            WORD32 rows_remaining, cols_remaining;
            /* Set pu wd and ht based on whether the ctb is complete or not */
            rows_remaining = ps_sps->i2_pic_height_in_luma_samples
                            - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);
            pu_skip_ht = MIN(ctb_size, rows_remaining);
            cols_remaining = ps_sps->i2_pic_width_in_luma_samples
                            - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size);
            pu_skip_wd = MIN(ctb_size, cols_remaining);
            ps_tu->b1_cb_cbf = 0;
            ps_tu->b1_cr_cbf = 0;
            ps_tu->b1_y_cbf = 0;
            ps_tu->b4_pos_x = 0;
            ps_tu->b4_pos_y = 0;
            ps_tu->b1_transquant_bypass = 0;
            ps_tu->b3_size = (ps_sps->i1_log2_ctb_size - 2);
            ps_tu->b7_qp = ps_codec->s_parse.u4_qp;
            ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;
            ps_tu->b6_luma_intra_mode   = INTRA_PRED_NONE;
            ps_tu->b1_first_tu_in_cu = 1;
            ps_codec->s_parse.ps_tu++;
            ps_codec->s_parse.s_cu.i4_tu_cnt++;
            ps_codec->s_parse.i4_pic_tu_idx++;
            ps_codec->s_parse.s_cu.i4_pred_mode = PRED_MODE_SKIP;
            ps_codec->s_parse.s_cu.i4_part_mode = PART_2Nx2N;
            ps_pu->b2_part_idx = 0;
            ps_pu->b4_pos_x = 0;
            ps_pu->b4_pos_y = 0;
            ps_pu->b4_wd = (pu_skip_wd >> 2) - 1;
            ps_pu->b4_ht = (pu_skip_ht >> 2) - 1;
            ps_pu->b1_intra_flag = 0;
            ps_pu->b3_part_mode = ps_codec->s_parse.s_cu.i4_part_mode;
            ps_pu->b1_merge_flag = 1;
            ps_pu->b3_merge_idx = 0;
            ps_codec->s_parse.ps_pu++;
            ps_codec->s_parse.i4_pic_pu_idx++;
         }
 
         if(0 == ps_codec->i4_slice_error)
            end_of_slice_flag = ihevcd_cabac_decode_terminate(&ps_codec->s_parse.s_cabac, &ps_codec->s_parse.s_bitstrm);

        AEV_TRACE(""end_of_slice_flag"", end_of_slice_flag, ps_codec->s_parse.s_cabac.u4_range);


 /* In case of tiles or entropy sync, terminate cabac and copy cabac context backed up at the end of top-right CTB */
 if(ps_pps->i1_tiles_enabled_flag || ps_pps->i1_entropy_coding_sync_enabled_flag)
 {
            WORD32 end_of_tile = 0;
            WORD32 end_of_tile_row = 0;

 /* Take a back up of cabac context models if entropy sync is enabled */
 if(ps_pps->i1_entropy_coding_sync_enabled_flag || ps_pps->i1_tiles_enabled_flag)
 {
 if(1 == ps_codec->s_parse.i4_ctb_x)
 {
                    WORD32 size = sizeof(ps_codec->s_parse.s_cabac.au1_ctxt_models);
                    memcpy(&ps_codec->s_parse.s_cabac.au1_ctxt_models_sync, &ps_codec->s_parse.s_cabac.au1_ctxt_models, size);
 }
 }

 /* Since tiles and entropy sync are not enabled simultaneously, the following will not result in any problems */
 if((ps_codec->s_parse.i4_ctb_tile_x + 1) == (ps_tile->u2_wd))
 {
                end_of_tile_row = 1;
 if((ps_codec->s_parse.i4_ctb_tile_y + 1) == ps_tile->u2_ht)
                    end_of_tile = 1;
 }
 if((0 == end_of_slice_flag) &&
 ((ps_pps->i1_tiles_enabled_flag && end_of_tile) ||
 (ps_pps->i1_entropy_coding_sync_enabled_flag && end_of_tile_row)))
 {
                WORD32 end_of_sub_stream_one_bit;
                end_of_sub_stream_one_bit = ihevcd_cabac_decode_terminate(&ps_codec->s_parse.s_cabac, &ps_codec->s_parse.s_bitstrm);
                AEV_TRACE(""end_of_sub_stream_one_bit"", end_of_sub_stream_one_bit, ps_codec->s_parse.s_cabac.u4_range);

 /* TODO: Remove the check for offset when HM is updated to include a byte unconditionally even for aligned location */
 /* For Ittiam streams this check should not be there, for HM9.1 streams this should be there */
 if(ps_codec->s_parse.s_bitstrm.u4_bit_ofst % 8)
                    ihevcd_bits_flush_to_byte_boundary(&ps_codec->s_parse.s_bitstrm);

                UNUSED(end_of_sub_stream_one_bit);
 }
 }
 {
            WORD32 ctb_indx;

            ctb_addr = ps_codec->s_parse.i4_ctb_y * num_ctb_in_row + ps_codec->s_parse.i4_ctb_x;

            ctb_indx = ++ctb_addr;

 /* Store pu_idx for next CTB in frame level pu_idx array */

 if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))
 {
                ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.
 if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))
 {
 if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))
 {
                        ctb_indx = ctb_addr; //Next continuous ctb address
 }
 else //Not last tile's end , but a tile end
 {
 tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;
                        ctb_indx = ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.
 }
 }
 }

            ps_codec->s_parse.pu4_pic_pu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_pu_idx;
            ps_codec->s_parse.i4_next_pu_ctb_cnt = ctb_indx;

            ps_codec->s_parse.pu1_pu_map += num_min4x4_in_ctb;

 /* Store tu_idx for next CTB in frame level tu_idx array */
 if(1 == ps_codec->i4_num_cores)
 {
                ctb_indx = (0 == ctb_addr % RESET_TU_BUF_NCTB) ?
                                RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB;

 if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))
 {
                    ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.
 if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))
 {
 if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))
 {
                            ctb_indx = (0 == ctb_addr % RESET_TU_BUF_NCTB) ?
                                            RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB;
 }
 else //Not last tile's end , but a tile end
 {
 tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;
                            ctb_indx =  ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.
 }
 }
 }
                ps_codec->s_parse.i4_next_tu_ctb_cnt = ctb_indx;
                ps_codec->s_parse.pu4_pic_tu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_tu_idx;
 }
 else
 {
                ctb_indx = ctb_addr;
 if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))
 {
                    ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.
 if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))
 {
 if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))
 {
                            ctb_indx = ctb_addr;
 }
 else //Not last tile's end , but a tile end
 {
 tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;
                            ctb_indx =  ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.
 }
 }
 }
                ps_codec->s_parse.i4_next_tu_ctb_cnt = ctb_indx;
                ps_codec->s_parse.pu4_pic_tu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_tu_idx;
 }
            ps_codec->s_parse.pu1_tu_map += num_min4x4_in_ctb;
 }


 if(ps_codec->i4_num_cores <= MV_PRED_NUM_CORES_THRESHOLD)
 {
 /*************************************************/
 /****************   MV pred **********************/
 /*************************************************/
            WORD8 u1_top_ctb_avail = 1;
            WORD8 u1_left_ctb_avail = 1;
            WORD8 u1_top_lt_ctb_avail = 1;
            WORD8 u1_top_rt_ctb_avail = 1;
            WORD16 i2_wd_in_ctb;

            tile_start_ctb_idx = ps_tile->u1_pos_x
 + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);

            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x
 + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

 if((slice_start_ctb_idx < tile_start_ctb_idx))
 {
                i2_wd_in_ctb = ps_sps->i2_pic_wd_in_ctb;
 }
 else
 {
                i2_wd_in_ctb = ps_tile->u2_wd;
 }
 /* slice and tile boundaries */
 if((0 == ps_codec->s_parse.i4_ctb_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                u1_top_ctb_avail = 0;
                u1_top_lt_ctb_avail = 0;
                u1_top_rt_ctb_avail = 0;
 }

 if((0 == ps_codec->s_parse.i4_ctb_x) || (0 == ps_codec->s_parse.i4_ctb_tile_x))
 {
                u1_left_ctb_avail = 0;
                u1_top_lt_ctb_avail = 0;
 if((0 == ps_codec->s_parse.i4_ctb_slice_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                    u1_top_ctb_avail = 0;
 if((i2_wd_in_ctb - 1) != ps_codec->s_parse.i4_ctb_slice_x) //TODO: For tile, not implemented
 {
                        u1_top_rt_ctb_avail = 0;
 }
 }
 }
 /*For slices not beginning at start of a ctb row*/
 else if(ps_codec->s_parse.i4_ctb_x > 0)
 {
 if((0 == ps_codec->s_parse.i4_ctb_slice_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                    u1_top_ctb_avail = 0;
                    u1_top_lt_ctb_avail = 0;
 if(0 == ps_codec->s_parse.i4_ctb_slice_x)
 {
                        u1_left_ctb_avail = 0;
 }
 if((i2_wd_in_ctb - 1) != ps_codec->s_parse.i4_ctb_slice_x)
 {
                        u1_top_rt_ctb_avail = 0;
 }
 }
 else if((1 == ps_codec->s_parse.i4_ctb_slice_y) && (0 == ps_codec->s_parse.i4_ctb_slice_x))
 {
                    u1_top_lt_ctb_avail = 0;
 }
 }

 if(((ps_sps->i2_pic_wd_in_ctb - 1) == ps_codec->s_parse.i4_ctb_x) || ((ps_tile->u2_wd - 1) == ps_codec->s_parse.i4_ctb_tile_x))
 {
                u1_top_rt_ctb_avail = 0;
 }

 if(PSLICE == ps_slice_hdr->i1_slice_type
 || BSLICE == ps_slice_hdr->i1_slice_type)
 {
 mv_ctxt_t s_mv_ctxt;
 process_ctxt_t *ps_proc;
                UWORD32 *pu4_ctb_top_pu_idx;
                UWORD32 *pu4_ctb_left_pu_idx;
                UWORD32 *pu4_ctb_top_left_pu_idx;
                WORD32 i4_ctb_pu_cnt;
                WORD32 cur_ctb_idx;
                WORD32 next_ctb_idx;
                WORD32 cur_pu_idx;
                ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];
                cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);
                next_ctb_idx = ps_codec->s_parse.i4_next_pu_ctb_cnt;
                i4_ctb_pu_cnt = ps_codec->s_parse.pu4_pic_pu_idx[next_ctb_idx]
 - ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];

                cur_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];

                pu4_ctb_top_pu_idx = ps_proc->pu4_pic_pu_idx_top
 + (ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE);
                pu4_ctb_left_pu_idx = ps_proc->pu4_pic_pu_idx_left;
                pu4_ctb_top_left_pu_idx = &ps_proc->u4_ctb_top_left_pu_idx;

 /* Initializing s_mv_ctxt */
 {
                    s_mv_ctxt.ps_pps = ps_pps;
                    s_mv_ctxt.ps_sps = ps_sps;
                    s_mv_ctxt.ps_slice_hdr = ps_slice_hdr;
                    s_mv_ctxt.i4_ctb_x = ps_codec->s_parse.i4_ctb_x;
                    s_mv_ctxt.i4_ctb_y = ps_codec->s_parse.i4_ctb_y;
                    s_mv_ctxt.ps_pu = &ps_codec->s_parse.ps_pic_pu[cur_pu_idx];
                    s_mv_ctxt.ps_pic_pu = ps_codec->s_parse.ps_pic_pu;
                    s_mv_ctxt.ps_tile = ps_tile;
                    s_mv_ctxt.pu4_pic_pu_idx_map = ps_proc->pu4_pic_pu_idx_map;
                    s_mv_ctxt.pu4_pic_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx;
                    s_mv_ctxt.pu1_pic_pu_map = ps_codec->s_parse.pu1_pic_pu_map;
                    s_mv_ctxt.i4_ctb_pu_cnt = i4_ctb_pu_cnt;
                    s_mv_ctxt.i4_ctb_start_pu_idx = cur_pu_idx;
                    s_mv_ctxt.u1_top_ctb_avail = u1_top_ctb_avail;
                    s_mv_ctxt.u1_top_rt_ctb_avail = u1_top_rt_ctb_avail;
                    s_mv_ctxt.u1_top_lt_ctb_avail = u1_top_lt_ctb_avail;
                    s_mv_ctxt.u1_left_ctb_avail = u1_left_ctb_avail;
 }

                ihevcd_get_mv_ctb(&s_mv_ctxt, pu4_ctb_top_pu_idx,
                                  pu4_ctb_left_pu_idx, pu4_ctb_top_left_pu_idx);

 }
 else
 {
                WORD32 num_minpu_in_ctb = (ctb_size / MIN_PU_SIZE) * (ctb_size / MIN_PU_SIZE);
                UWORD8 *pu1_pic_pu_map_ctb = ps_codec->s_parse.pu1_pic_pu_map +
 (ps_codec->s_parse.i4_ctb_x + ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb) * num_minpu_in_ctb;
 process_ctxt_t *ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];
                WORD32 row, col;
                WORD32 pu_cnt;
                WORD32 num_pu_per_ctb;
                WORD32 cur_ctb_idx;
                WORD32 next_ctb_idx;
                WORD32 ctb_start_pu_idx;
                UWORD32 *pu4_nbr_pu_idx = ps_proc->pu4_pic_pu_idx_map;
                WORD32 nbr_pu_idx_strd = MAX_CTB_SIZE / MIN_PU_SIZE + 2;
 pu_t *ps_pu;

 for(row = 0; row < ctb_size / MIN_PU_SIZE; row++)
 {
 for(col = 0; col < ctb_size / MIN_PU_SIZE; col++)
 {
                        pu1_pic_pu_map_ctb[row * ctb_size / MIN_PU_SIZE + col] = 0;
 }
 }


 /* Neighbor PU idx update inside CTB */
 /* 1byte per 4x4. Indicates the PU idx that 4x4 block belongs to */

                cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);
                next_ctb_idx = ps_codec->s_parse.i4_next_pu_ctb_cnt;
                num_pu_per_ctb = ps_codec->s_parse.pu4_pic_pu_idx[next_ctb_idx]
 - ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];
                ctb_start_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];
                ps_pu = &ps_codec->s_parse.ps_pic_pu[ctb_start_pu_idx];

 for(pu_cnt = 0; pu_cnt < num_pu_per_ctb; pu_cnt++, ps_pu++)
 {
                    UWORD32 cur_pu_idx;
                    WORD32 pu_ht = (ps_pu->b4_ht + 1) << 2;
                    WORD32 pu_wd = (ps_pu->b4_wd + 1) << 2;

                    cur_pu_idx = ctb_start_pu_idx + pu_cnt;

 for(row = 0; row < pu_ht / MIN_PU_SIZE; row++)
 for(col = 0; col < pu_wd / MIN_PU_SIZE; col++)
                            pu4_nbr_pu_idx[(1 + ps_pu->b4_pos_x + col)
 + (1 + ps_pu->b4_pos_y + row)
 * nbr_pu_idx_strd] =
                                            cur_pu_idx;
 }

 /* Updating Top and Left pointers */
 {
                    WORD32 rows_remaining = ps_sps->i2_pic_height_in_luma_samples
 - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);
                    WORD32 ctb_size_left = MIN(ctb_size, rows_remaining);

 /* Top Left */
 /* saving top left before updating top ptr, as updating top ptr will overwrite the top left for the next ctb */
                    ps_proc->u4_ctb_top_left_pu_idx = ps_proc->pu4_pic_pu_idx_top[(ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE) + ctb_size / MIN_PU_SIZE - 1];
 for(i = 0; i < ctb_size / MIN_PU_SIZE; i++)
 {
 /* Left */
 /* Last column of au4_nbr_pu_idx */
                        ps_proc->pu4_pic_pu_idx_left[i] = pu4_nbr_pu_idx[(ctb_size / MIN_PU_SIZE)
 + (i + 1) * nbr_pu_idx_strd];
 /* Top */
 /* Last row of au4_nbr_pu_idx */
                        ps_proc->pu4_pic_pu_idx_top[(ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE) + i] =
                                        pu4_nbr_pu_idx[(ctb_size_left / MIN_PU_SIZE) * nbr_pu_idx_strd + i + 1];

 }
 }
 }

 /*************************************************/
 /******************  BS, QP  *********************/
 /*************************************************/
 /* Check if deblock is disabled for the current slice or if it is disabled for the current picture
             * because of disable deblock api
             */
 if(0 == ps_codec->i4_disable_deblk_pic)
 {
 if((0 == ps_slice_hdr->i1_slice_disable_deblocking_filter_flag) &&
 (0 == ps_codec->i4_slice_error))
 {
                    WORD32 i4_ctb_tu_cnt;
                    WORD32 cur_ctb_idx, next_ctb_idx;
                    WORD32 cur_pu_idx;
                    WORD32 cur_tu_idx;
 process_ctxt_t *ps_proc;

                    ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];
                    cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

                    cur_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];
                    next_ctb_idx = ps_codec->s_parse.i4_next_tu_ctb_cnt;
 if(1 == ps_codec->i4_num_cores)
 {
                        i4_ctb_tu_cnt = ps_codec->s_parse.pu4_pic_tu_idx[next_ctb_idx] -
                                        ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx % RESET_TU_BUF_NCTB];

                        cur_tu_idx = ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx % RESET_TU_BUF_NCTB];
 }
 else
 {
                        i4_ctb_tu_cnt = ps_codec->s_parse.pu4_pic_tu_idx[next_ctb_idx] -
                                        ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx];

                        cur_tu_idx = ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx];
 }

                    ps_codec->s_parse.s_bs_ctxt.ps_pps = ps_codec->s_parse.ps_pps;
                    ps_codec->s_parse.s_bs_ctxt.ps_sps = ps_codec->s_parse.ps_sps;
                    ps_codec->s_parse.s_bs_ctxt.ps_codec = ps_codec;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tu_cnt = i4_ctb_tu_cnt;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_x = ps_codec->s_parse.i4_ctb_x;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_y = ps_codec->s_parse.i4_ctb_y;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tile_x = ps_codec->s_parse.i4_ctb_tile_x;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tile_y = ps_codec->s_parse.i4_ctb_tile_y;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_slice_x = ps_codec->s_parse.i4_ctb_slice_x;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_slice_y = ps_codec->s_parse.i4_ctb_slice_y;
                    ps_codec->s_parse.s_bs_ctxt.ps_tu = &ps_codec->s_parse.ps_pic_tu[cur_tu_idx];
                    ps_codec->s_parse.s_bs_ctxt.ps_pu = &ps_codec->s_parse.ps_pic_pu[cur_pu_idx];
                    ps_codec->s_parse.s_bs_ctxt.pu4_pic_pu_idx_map = ps_proc->pu4_pic_pu_idx_map;
                    ps_codec->s_parse.s_bs_ctxt.i4_next_pu_ctb_cnt = ps_codec->s_parse.i4_next_pu_ctb_cnt;
                    ps_codec->s_parse.s_bs_ctxt.i4_next_tu_ctb_cnt = ps_codec->s_parse.i4_next_tu_ctb_cnt;
                    ps_codec->s_parse.s_bs_ctxt.pu1_slice_idx = ps_codec->s_parse.pu1_slice_idx;
                    ps_codec->s_parse.s_bs_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;
                    ps_codec->s_parse.s_bs_ctxt.ps_tile = ps_codec->s_parse.ps_tile;

 if(ISLICE == ps_slice_hdr->i1_slice_type)
 {
                        ihevcd_ctb_boundary_strength_islice(&ps_codec->s_parse.s_bs_ctxt);
 }
 else
 {
                        ihevcd_ctb_boundary_strength_pbslice(&ps_codec->s_parse.s_bs_ctxt);
 }
 }
 else
 {
                    WORD32 bs_strd = (ps_sps->i2_pic_wd_in_ctb + 1) * (ctb_size * ctb_size / 8 / 16);

                    UWORD32 *pu4_vert_bs = (UWORD32 *)((UWORD8 *)ps_codec->s_parse.s_bs_ctxt.pu4_pic_vert_bs +
                                    ps_codec->s_parse.i4_ctb_x * (ctb_size * ctb_size / 8 / 16) +
                                    ps_codec->s_parse.i4_ctb_y * bs_strd);
                    UWORD32 *pu4_horz_bs = (UWORD32 *)((UWORD8 *)ps_codec->s_parse.s_bs_ctxt.pu4_pic_horz_bs +
                                    ps_codec->s_parse.i4_ctb_x * (ctb_size * ctb_size / 8 / 16) +
                                    ps_codec->s_parse.i4_ctb_y * bs_strd);

                    memset(pu4_vert_bs, 0, (ctb_size / 8 + 1) * (ctb_size / 4) / 8 * 2);
                    memset(pu4_horz_bs, 0, (ctb_size / 8) * (ctb_size / 4) / 8 * 2);

 }
 }

 }


 /* Update the parse status map */
 {
 sps_t *ps_sps = ps_codec->s_parse.ps_sps;
            UWORD8 *pu1_buf;
            WORD32 idx;
            idx = (ps_codec->s_parse.i4_ctb_x);
            idx += ((ps_codec->s_parse.i4_ctb_y) * ps_sps->i2_pic_wd_in_ctb);
            pu1_buf = (ps_codec->pu1_parse_map + idx);
 *pu1_buf = 1;
 }

 /* Increment CTB x and y positions */
        ps_codec->s_parse.i4_ctb_tile_x++;
        ps_codec->s_parse.i4_ctb_x++;
        ps_codec->s_parse.i4_ctb_slice_x++;

 /*If tiles are enabled, handle the slice counters differently*/
 if(ps_pps->i1_tiles_enabled_flag)
 {
            tile_start_ctb_idx = ps_tile->u1_pos_x
 + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);

            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x
 + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

 if((slice_start_ctb_idx < tile_start_ctb_idx))
 {
 if(ps_codec->s_parse.i4_ctb_slice_x == (ps_tile->u1_pos_x + ps_tile->u2_wd))
 {
 /* Reached end of slice row within a tile /frame */
                    ps_codec->s_parse.i4_ctb_slice_y++;
                    ps_codec->s_parse.i4_ctb_slice_x = ps_tile->u1_pos_x; //todo:Check
 }
 }
 else if(ps_codec->s_parse.i4_ctb_slice_x == (ps_tile->u2_wd))
 {
                ps_codec->s_parse.i4_ctb_slice_y++;
                ps_codec->s_parse.i4_ctb_slice_x = 0;
 }
 }
 else
 {
 if(ps_codec->s_parse.i4_ctb_slice_x == ps_tile->u2_wd)
 {
 /* Reached end of slice row within a tile /frame */
                ps_codec->s_parse.i4_ctb_slice_y++;
                ps_codec->s_parse.i4_ctb_slice_x = 0;
 }
 }


 if(ps_codec->s_parse.i4_ctb_tile_x == (ps_tile->u2_wd))
 {
 /* Reached end of tile row */
            ps_codec->s_parse.i4_ctb_tile_x = 0;
            ps_codec->s_parse.i4_ctb_x = ps_tile->u1_pos_x;

            ps_codec->s_parse.i4_ctb_tile_y++;
            ps_codec->s_parse.i4_ctb_y++;

 if(ps_codec->s_parse.i4_ctb_tile_y == (ps_tile->u2_ht))
 {
 /* Reached End of Tile */
                ps_codec->s_parse.i4_ctb_tile_y = 0;
                ps_codec->s_parse.i4_ctb_tile_x = 0;
                ps_codec->s_parse.ps_tile++;

 if((ps_tile->u2_ht + ps_tile->u1_pos_y  ==  ps_sps->i2_pic_ht_in_ctb) && (ps_tile->u2_wd + ps_tile->u1_pos_x  ==  ps_sps->i2_pic_wd_in_ctb))
 {
 /* Reached end of frame */
                    end_of_pic = 1;
                    ps_codec->s_parse.i4_ctb_x = 0;
                    ps_codec->s_parse.i4_ctb_y = ps_sps->i2_pic_ht_in_ctb;
 }
 else
 {
 /* Initialize ctb_x and ctb_y to start of next tile */
                    ps_tile = ps_codec->s_parse.ps_tile;
                    ps_codec->s_parse.i4_ctb_x = ps_tile->u1_pos_x;
                    ps_codec->s_parse.i4_ctb_y = ps_tile->u1_pos_y;
                    ps_codec->s_parse.i4_ctb_tile_y = 0;
                    ps_codec->s_parse.i4_ctb_tile_x = 0;
                    ps_codec->s_parse.i4_ctb_slice_x = ps_tile->u1_pos_x;
                    ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y;

 }
 }

 }

        ps_codec->s_parse.i4_next_ctb_indx = ps_codec->s_parse.i4_ctb_x +
                        ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb;

 /* If the current slice is in error, check if the next slice's address
         * is reached and mark the end_of_slice flag */
 if(ps_codec->i4_slice_error)
 {
 slice_header_t *ps_slice_hdr_next = ps_slice_hdr + 1;
            WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x +
                            ps_slice_hdr_next->i2_ctb_y * ps_sps->i2_pic_wd_in_ctb;

 if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr)
                end_of_slice_flag = 1;
 }

 /* If the codec is running in single core mode
         * then call process function for current CTB
         */
 if((1 == ps_codec->i4_num_cores) && (ps_codec->s_parse.i4_ctb_tile_x == 0))
 {
 process_ctxt_t *ps_proc = &ps_codec->as_process[0];
            ps_proc->i4_ctb_cnt = ps_proc->ps_tile->u2_wd;
            ihevcd_process(ps_proc);
 }

 /* If the bytes for the current slice are exhausted
         * set end_of_slice flag to 1
         * This slice will be treated as incomplete */
 if((UWORD8 *)ps_codec->s_parse.s_bitstrm.pu1_buf_max + BITSTRM_OFF_THRS <
 ((UWORD8 *)ps_codec->s_parse.s_bitstrm.pu4_buf + (ps_codec->s_parse.s_bitstrm.u4_bit_ofst / 8)))
 {

 if(0 == ps_codec->i4_slice_error)
                end_of_slice_flag = 1;
 }


 if(end_of_pic)
 break;
 } while(!end_of_slice_flag);

 /* Reset slice error */
    ps_codec->i4_slice_error = 0;

 /* Increment the slice index for parsing next slice */
 if(0 == end_of_pic)
 {
 while(1)
 {

            WORD32 parse_slice_idx;
            parse_slice_idx = ps_codec->s_parse.i4_cur_slice_idx;
            parse_slice_idx++;

 {
 /* If the next slice header is not initialized, update cur_slice_idx and break */
 if((1 == ps_codec->i4_num_cores) || (0 != (parse_slice_idx & (MAX_SLICE_HDR_CNT - 1))))
 {
                    ps_codec->s_parse.i4_cur_slice_idx = parse_slice_idx;
 break;
 }

 /* If the next slice header is initialised, wait for the parsed slices to be processed */
 else
 {
                    WORD32 ctb_indx = 0;

 while(ctb_indx != ps_sps->i4_pic_size_in_ctb)
 {
                        WORD32 parse_status = *(ps_codec->pu1_parse_map + ctb_indx);
 volatile WORD32 proc_status = *(ps_codec->pu1_proc_map + ctb_indx) & 1;

 if(parse_status == proc_status)
                            ctb_indx++;
 }
                    ps_codec->s_parse.i4_cur_slice_idx = parse_slice_idx;
 break;
 }

 }
 }

 }
 else
 {
#if FRAME_ILF_PAD
 if(FRAME_ILF_PAD && 1 == ps_codec->i4_num_cores)
 {
 if(ps_slice_hdr->i4_abs_pic_order_cnt == 0)
 {
                DUMP_PRE_ILF(ps_codec->as_process[0].pu1_cur_pic_luma,
                             ps_codec->as_process[0].pu1_cur_pic_chroma,
                             ps_sps->i2_pic_width_in_luma_samples,
                             ps_sps->i2_pic_height_in_luma_samples,
                             ps_codec->i4_strd);

                DUMP_BS(ps_codec->as_process[0].s_bs_ctxt.pu4_pic_vert_bs,
                        ps_codec->as_process[0].s_bs_ctxt.pu4_pic_horz_bs,
                        ps_sps->i2_pic_wd_in_ctb * (ctb_size * ctb_size / 8 / 16) * ps_sps->i2_pic_ht_in_ctb,
 (ps_sps->i2_pic_wd_in_ctb + 1) * (ctb_size * ctb_size / 8 / 16) * ps_sps->i2_pic_ht_in_ctb);

                DUMP_QP(ps_codec->as_process[0].s_bs_ctxt.pu1_pic_qp,
 (ps_sps->i2_pic_height_in_luma_samples * ps_sps->i2_pic_width_in_luma_samples) / (MIN_CU_SIZE * MIN_CU_SIZE));

                DUMP_QP_CONST_IN_CTB(ps_codec->as_process[0].s_bs_ctxt.pu1_pic_qp_const_in_ctb,
 (ps_sps->i2_pic_height_in_luma_samples * ps_sps->i2_pic_width_in_luma_samples) / (MIN_CTB_SIZE * MIN_CTB_SIZE) / 8);

                DUMP_NO_LOOP_FILTER(ps_codec->as_process[0].pu1_pic_no_loop_filter_flag,
 (ps_sps->i2_pic_width_in_luma_samples / MIN_CU_SIZE) * (ps_sps->i2_pic_height_in_luma_samples / MIN_CU_SIZE) / 8);

                DUMP_OFFSETS(ps_slice_hdr->i1_beta_offset_div2,
                             ps_slice_hdr->i1_tc_offset_div2,
                             ps_pps->i1_pic_cb_qp_offset,
                             ps_pps->i1_pic_cr_qp_offset);
 }
            ps_codec->s_parse.s_deblk_ctxt.ps_pps = ps_codec->s_parse.ps_pps;
            ps_codec->s_parse.s_deblk_ctxt.ps_sps = ps_codec->s_parse.ps_sps;
            ps_codec->s_parse.s_deblk_ctxt.ps_codec = ps_codec;
            ps_codec->s_parse.s_deblk_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;
            ps_codec->s_parse.s_deblk_ctxt.is_chroma_yuv420sp_vu = (ps_codec->e_ref_chroma_fmt == IV_YUV_420SP_VU);

            ps_codec->s_parse.s_sao_ctxt.ps_pps = ps_codec->s_parse.ps_pps;
            ps_codec->s_parse.s_sao_ctxt.ps_sps = ps_codec->s_parse.ps_sps;
            ps_codec->s_parse.s_sao_ctxt.ps_codec = ps_codec;
            ps_codec->s_parse.s_sao_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;

            ihevcd_ilf_pad_frame(&ps_codec->s_parse.s_deblk_ctxt, &ps_codec->s_parse.s_sao_ctxt);

 }
#endif
        ps_codec->s_parse.i4_end_of_frame = 1;
 }
 return ret;
}
",C,"                ihevcd_set_ctb_skip(ps_codec);
            ihevcd_set_ctb_skip(ps_codec);
","                WORD32 pu_skip_wd, pu_skip_ht;
                WORD32 rows_remaining, cols_remaining;
                /* Set pu wd and ht based on whether the ctb is complete or not */
                rows_remaining = ps_sps->i2_pic_height_in_luma_samples
                                - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);
                pu_skip_ht = MIN(ctb_size, rows_remaining);
                cols_remaining = ps_sps->i2_pic_width_in_luma_samples
                                - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size);
                pu_skip_wd = MIN(ctb_size, cols_remaining);
                ps_tu->b1_cb_cbf = 0;
                ps_tu->b1_cr_cbf = 0;
                ps_tu->b1_y_cbf = 0;
                ps_tu->b4_pos_x = 0;
                ps_tu->b4_pos_y = 0;
                ps_tu->b1_transquant_bypass = 0;
                ps_tu->b3_size = (ps_sps->i1_log2_ctb_size - 2);
                ps_tu->b7_qp = ps_codec->s_parse.u4_qp;
                ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;
                ps_tu->b6_luma_intra_mode   = INTRA_PRED_NONE;
                ps_tu->b1_first_tu_in_cu = 1;
                ps_codec->s_parse.ps_tu++;
                ps_codec->s_parse.s_cu.i4_tu_cnt++;
                ps_codec->s_parse.i4_pic_tu_idx++;
                ps_codec->s_parse.s_cu.i4_pred_mode = PRED_MODE_SKIP;
                ps_codec->s_parse.s_cu.i4_part_mode = PART_2Nx2N;
                ps_pu->b2_part_idx = 0;
                ps_pu->b4_pos_x = 0;
                ps_pu->b4_pos_y = 0;
                ps_pu->b4_wd = (pu_skip_wd >> 2) - 1;
                ps_pu->b4_ht = (pu_skip_ht >> 2) - 1;
                ps_pu->b1_intra_flag = 0;
                ps_pu->b3_part_mode = ps_codec->s_parse.s_cu.i4_part_mode;
                ps_pu->b1_merge_flag = 1;
                ps_pu->b3_merge_idx = 0;
                ps_codec->s_parse.ps_pu++;
                ps_codec->s_parse.i4_pic_pu_idx++;
            tu_t *ps_tu = ps_codec->s_parse.ps_tu;
            pu_t *ps_pu = ps_codec->s_parse.ps_pu;
            WORD32 pu_skip_wd, pu_skip_ht;
            WORD32 rows_remaining, cols_remaining;
            /* Set pu wd and ht based on whether the ctb is complete or not */
            rows_remaining = ps_sps->i2_pic_height_in_luma_samples
                            - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);
            pu_skip_ht = MIN(ctb_size, rows_remaining);
            cols_remaining = ps_sps->i2_pic_width_in_luma_samples
                            - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size);
            pu_skip_wd = MIN(ctb_size, cols_remaining);
            ps_tu->b1_cb_cbf = 0;
            ps_tu->b1_cr_cbf = 0;
            ps_tu->b1_y_cbf = 0;
            ps_tu->b4_pos_x = 0;
            ps_tu->b4_pos_y = 0;
            ps_tu->b1_transquant_bypass = 0;
            ps_tu->b3_size = (ps_sps->i1_log2_ctb_size - 2);
            ps_tu->b7_qp = ps_codec->s_parse.u4_qp;
            ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;
            ps_tu->b6_luma_intra_mode   = INTRA_PRED_NONE;
            ps_tu->b1_first_tu_in_cu = 1;
            ps_codec->s_parse.ps_tu++;
            ps_codec->s_parse.s_cu.i4_tu_cnt++;
            ps_codec->s_parse.i4_pic_tu_idx++;
            ps_codec->s_parse.s_cu.i4_pred_mode = PRED_MODE_SKIP;
            ps_codec->s_parse.s_cu.i4_part_mode = PART_2Nx2N;
            ps_pu->b2_part_idx = 0;
            ps_pu->b4_pos_x = 0;
            ps_pu->b4_pos_y = 0;
            ps_pu->b4_wd = (pu_skip_wd >> 2) - 1;
            ps_pu->b4_ht = (pu_skip_ht >> 2) - 1;
            ps_pu->b1_intra_flag = 0;
            ps_pu->b3_part_mode = ps_codec->s_parse.s_cu.i4_part_mode;
            ps_pu->b1_merge_flag = 1;
            ps_pu->b3_merge_idx = 0;
            ps_codec->s_parse.ps_pu++;
            ps_codec->s_parse.i4_pic_pu_idx++;
",,"@@ -2177,6 +2177,98 @@

  *******************************************************************************
  *
  * @brief
+ *  Set ctb skip
+ *
+ * @par Description:
+ *  During error, sets tu and pu params of a ctb as skip.
+ *
+ * @param[in] ps_codec
+ *  Pointer to codec context
+ *
+ * @returns  None
+ *
+ * @remarks
+ *
+ *
+ *******************************************************************************
+ */
+void ihevcd_set_ctb_skip(codec_t *ps_codec)
+{
+    tu_t *ps_tu;
+    pu_t *ps_pu;
+    sps_t *ps_sps = ps_codec->s_parse.ps_sps;
+    WORD32 ctb_size = 1 << ps_sps->i1_log2_ctb_size;
+    WORD32 ctb_skip_wd, ctb_skip_ht;
+    WORD32 rows_remaining, cols_remaining;
+    WORD32 tu_abs_x, tu_abs_y;
+    WORD32 numbytes_row =  (ps_sps->i2_pic_width_in_luma_samples + 63) / 64;
+    UWORD8 *pu1_pic_intra_flag;
+    UWORD32 u4_mask;
+    WORD32 pu_x,pu_y;
+
+    /* Set pu wd and ht based on whether the ctb is complete or not */
+    rows_remaining = ps_sps->i2_pic_height_in_luma_samples
+                    - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);
+    ctb_skip_ht = MIN(ctb_size, rows_remaining);
+
+    cols_remaining = ps_sps->i2_pic_width_in_luma_samples
+                    - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size);
+    ctb_skip_wd = MIN(ctb_size, cols_remaining);
+
+    ps_codec->s_parse.s_cu.i4_pred_mode = PRED_MODE_SKIP;
+    ps_codec->s_parse.s_cu.i4_part_mode = PART_2Nx2N;
+
+    for (pu_y = 0; pu_y < ctb_skip_ht ; pu_y += MIN_CU_SIZE)
+    {
+        for (pu_x = 0; pu_x < ctb_skip_wd ; pu_x += MIN_CU_SIZE)
+        {
+            ps_tu = ps_codec->s_parse.ps_tu;
+            ps_tu->b1_cb_cbf = 0;
+            ps_tu->b1_cr_cbf = 0;
+            ps_tu->b1_y_cbf = 0;
+            ps_tu->b4_pos_x = pu_x >> 2;
+            ps_tu->b4_pos_y = pu_y >> 2;
+            ps_tu->b1_transquant_bypass = 0;
+            ps_tu->b3_size = 1;
+            ps_tu->b7_qp = ps_codec->s_parse.u4_qp;
+            ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;
+            ps_tu->b6_luma_intra_mode   = INTRA_PRED_NONE;
+            ps_tu->b1_first_tu_in_cu = 1;
+
+            ps_codec->s_parse.ps_tu++;
+            ps_codec->s_parse.s_cu.i4_tu_cnt++;
+            ps_codec->s_parse.i4_pic_tu_idx++;
+
+            tu_abs_x = (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size) + pu_x;
+            tu_abs_y = (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size) + pu_y;
+            pu1_pic_intra_flag = ps_codec->s_parse.pu1_pic_intra_flag;
+            pu1_pic_intra_flag += (tu_abs_y >> 3) * numbytes_row;
+            pu1_pic_intra_flag += (tu_abs_x >> 6);
+            u4_mask = (LSB_ONES((MIN_CU_SIZE >> 3)) << (((tu_abs_x) / 8) % 8));
+            u4_mask = ~u4_mask;
+            *pu1_pic_intra_flag &= u4_mask;
+
+            ps_pu = ps_codec->s_parse.ps_pu;
+            ps_pu->b2_part_idx = 0;
+            ps_pu->b4_pos_x = pu_x >> 2;
+            ps_pu->b4_pos_y = pu_y >> 2;
+            ps_pu->b4_wd = 1;
+            ps_pu->b4_ht = 1;
+            ps_pu->b1_intra_flag = 0;
+            ps_pu->b3_part_mode = ps_codec->s_parse.s_cu.i4_part_mode;
+            ps_pu->b1_merge_flag = 1;
+            ps_pu->b3_merge_idx = 0;
+
+            ps_codec->s_parse.ps_pu++;
+            ps_codec->s_parse.i4_pic_pu_idx++;
+        }
+    }
+}
+
+/**
+ *******************************************************************************
+ *
+ * @brief
  *  Parses Slice data syntax
  *
  * @par Description:
@@ -2640,19 +2732,8 @@

             if (ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
             {
                 /* Reset tu and pu parameters, and signal current ctb as skip */
-                WORD32 pu_skip_wd, pu_skip_ht;
-                WORD32 rows_remaining, cols_remaining;
                 WORD32 tu_coeff_data_reset_size;
 
-                /* Set pu wd and ht based on whether the ctb is complete or not */
-                rows_remaining = ps_sps->i2_pic_height_in_luma_samples
-                                - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);
-                pu_skip_ht = MIN(ctb_size, rows_remaining);
-
-                cols_remaining = ps_sps->i2_pic_width_in_luma_samples
-                                - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size);
-                pu_skip_wd = MIN(ctb_size, cols_remaining);
-
                 ps_codec->s_parse.ps_tu = ps_tu;
                 ps_codec->s_parse.s_cu.i4_tu_cnt = i4_tu_cnt;
                 ps_codec->s_parse.i4_pic_tu_idx = i4_pic_tu_idx;
@@ -2660,41 +2741,11 @@

                 ps_codec->s_parse.ps_pu = ps_pu;
                 ps_codec->s_parse.i4_pic_pu_idx = i4_pic_pu_idx;
 
-                ps_tu->b1_cb_cbf = 0;
-                ps_tu->b1_cr_cbf = 0;
-                ps_tu->b1_y_cbf = 0;
-                ps_tu->b4_pos_x = 0;
-                ps_tu->b4_pos_y = 0;
-                ps_tu->b1_transquant_bypass = 0;
-                ps_tu->b3_size = (ps_sps->i1_log2_ctb_size - 2);
-                ps_tu->b7_qp = ps_codec->s_parse.u4_qp;
-                ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;
-                ps_tu->b6_luma_intra_mode   = INTRA_PRED_NONE;
-                ps_tu->b1_first_tu_in_cu = 1;
-
                 tu_coeff_data_reset_size = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data - pu1_tu_coeff_data;
                 memset(pu1_tu_coeff_data, 0, tu_coeff_data_reset_size);
                 ps_codec->s_parse.pv_tu_coeff_data = (void *)pu1_tu_coeff_data;
 
-                ps_codec->s_parse.ps_tu++;
-                ps_codec->s_parse.s_cu.i4_tu_cnt++;
-                ps_codec->s_parse.i4_pic_tu_idx++;
-
-                ps_codec->s_parse.s_cu.i4_pred_mode = PRED_MODE_SKIP;
-                ps_codec->s_parse.s_cu.i4_part_mode = PART_2Nx2N;
-
-                ps_pu->b2_part_idx = 0;
-                ps_pu->b4_pos_x = 0;
-                ps_pu->b4_pos_y = 0;
-                ps_pu->b4_wd = (pu_skip_wd >> 2) - 1;
-                ps_pu->b4_ht = (pu_skip_ht >> 2) - 1;
-                ps_pu->b1_intra_flag = 0;
-                ps_pu->b3_part_mode = ps_codec->s_parse.s_cu.i4_part_mode;
-                ps_pu->b1_merge_flag = 1;
-                ps_pu->b3_merge_idx = 0;
-
-                ps_codec->s_parse.ps_pu++;
-                ps_codec->s_parse.i4_pic_pu_idx++;
+                ihevcd_set_ctb_skip(ps_codec);
 
                 /* Set slice error to suppress further parsing and
                  * signal end of slice.
@@ -2706,52 +2757,7 @@

         }
         else
         {
-            tu_t *ps_tu = ps_codec->s_parse.ps_tu;
-            pu_t *ps_pu = ps_codec->s_parse.ps_pu;
-            WORD32 pu_skip_wd, pu_skip_ht;
-            WORD32 rows_remaining, cols_remaining;
-
-            /* Set pu wd and ht based on whether the ctb is complete or not */
-            rows_remaining = ps_sps->i2_pic_height_in_luma_samples
-                            - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);
-            pu_skip_ht = MIN(ctb_size, rows_remaining);
-
-            cols_remaining = ps_sps->i2_pic_width_in_luma_samples
-                            - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size);
-            pu_skip_wd = MIN(ctb_size, cols_remaining);
-
-            ps_tu->b1_cb_cbf = 0;
-            ps_tu->b1_cr_cbf = 0;
-            ps_tu->b1_y_cbf = 0;
-            ps_tu->b4_pos_x = 0;
-            ps_tu->b4_pos_y = 0;
-            ps_tu->b1_transquant_bypass = 0;
-            ps_tu->b3_size = (ps_sps->i1_log2_ctb_size - 2);
-            ps_tu->b7_qp = ps_codec->s_parse.u4_qp;
-            ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;
-            ps_tu->b6_luma_intra_mode   = INTRA_PRED_NONE;
-            ps_tu->b1_first_tu_in_cu = 1;
-
-            ps_codec->s_parse.ps_tu++;
-            ps_codec->s_parse.s_cu.i4_tu_cnt++;
-            ps_codec->s_parse.i4_pic_tu_idx++;
-
-            ps_codec->s_parse.s_cu.i4_pred_mode = PRED_MODE_SKIP;
-            ps_codec->s_parse.s_cu.i4_part_mode = PART_2Nx2N;
-
-            ps_pu->b2_part_idx = 0;
-            ps_pu->b4_pos_x = 0;
-            ps_pu->b4_pos_y = 0;
-            ps_pu->b4_wd = (pu_skip_wd >> 2) - 1;
-            ps_pu->b4_ht = (pu_skip_ht >> 2) - 1;
-            ps_pu->b1_intra_flag = 0;
-            ps_pu->b3_part_mode = ps_codec->s_parse.s_cu.i4_part_mode;
-            ps_pu->b1_merge_flag = 1;
-            ps_pu->b3_merge_idx = 0;
-
-            ps_codec->s_parse.ps_pu++;
-            ps_codec->s_parse.i4_pic_pu_idx++;
-
+            ihevcd_set_ctb_skip(ps_codec);
         }
 
         if(0 == ps_codec->i4_slice_error)
",Android,https://android.googlesource.com/platform/external/libhevc/+/2b9fb0c2074d370a254b35e2489de2d94943578d/,https://android.googlesource.com/platform/external/libhevc/+/2b9fb0c2074d370a254b35e2489de2d94943578d%5E/,1,"IHEVCD_ERROR_T ihevcd_parse_slice_data(codec_t *ps_codec)
{

    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
    WORD32 end_of_slice_flag = 0;
 sps_t *ps_sps;
 pps_t *ps_pps;
 slice_header_t *ps_slice_hdr;
    WORD32 end_of_pic;
 tile_t *ps_tile, *ps_tile_prev;
    WORD32 i;
    WORD32 ctb_addr;
    WORD32 tile_idx;
    WORD32 cabac_init_idc;
    WORD32 ctb_size;
    WORD32 num_ctb_in_row;
    WORD32 num_min4x4_in_ctb;
    WORD32 slice_qp;
    WORD32 slice_start_ctb_idx;
    WORD32 tile_start_ctb_idx;


    ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base;
    ps_pps = ps_codec->s_parse.ps_pps_base;
    ps_sps = ps_codec->s_parse.ps_sps_base;

 /* Get current slice header, pps and sps */
    ps_slice_hdr += (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));
    ps_pps  += ps_slice_hdr->i1_pps_id;
    ps_sps  += ps_pps->i1_sps_id;

 if(0 != ps_codec->s_parse.i4_cur_slice_idx)
 {
 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
            ps_codec->s_parse.i4_cur_independent_slice_idx++;
 if(MAX_SLICE_HDR_CNT == ps_codec->s_parse.i4_cur_independent_slice_idx)
                ps_codec->s_parse.i4_cur_independent_slice_idx = 0;
 }
 }


    ctb_size = 1 << ps_sps->i1_log2_ctb_size;
    num_min4x4_in_ctb = (ctb_size / 4) * (ctb_size / 4);
    num_ctb_in_row = ps_sps->i2_pic_wd_in_ctb;

 /* Update the parse context */
 if(0 == ps_codec->i4_slice_error)
 {
        ps_codec->s_parse.i4_ctb_x = ps_slice_hdr->i2_ctb_x;
        ps_codec->s_parse.i4_ctb_y = ps_slice_hdr->i2_ctb_y;
 }
    ps_codec->s_parse.ps_pps = ps_pps;
    ps_codec->s_parse.ps_sps = ps_sps;
    ps_codec->s_parse.ps_slice_hdr = ps_slice_hdr;

 /* Derive Tile positions for the current CTB */
 /* Change this to lookup if required */
    ihevcd_get_tile_pos(ps_pps, ps_sps, ps_codec->s_parse.i4_ctb_x,
                        ps_codec->s_parse.i4_ctb_y,
 &ps_codec->s_parse.i4_ctb_tile_x,
 &ps_codec->s_parse.i4_ctb_tile_y,
 &tile_idx);
    ps_codec->s_parse.ps_tile = ps_pps->ps_tile + tile_idx;
    ps_codec->s_parse.i4_cur_tile_idx = tile_idx;
    ps_tile = ps_codec->s_parse.ps_tile;
 if(tile_idx)
        ps_tile_prev = ps_tile - 1;
 else
        ps_tile_prev = ps_tile;

 /* If the present slice is dependent, then store the previous
     * independent slices' ctb x and y values for decoding process */
 if(0 == ps_codec->i4_slice_error)
 {
 if(1 == ps_slice_hdr->i1_dependent_slice_flag)
 {
 /*If slice is present at the start of a new tile*/
 if((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                ps_codec->s_parse.i4_ctb_slice_x = 0;
                ps_codec->s_parse.i4_ctb_slice_y = 0;
 }
 }

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
            ps_codec->s_parse.i4_ctb_slice_x = 0;
            ps_codec->s_parse.i4_ctb_slice_y = 0;
 }
 }

 /* Frame level initializations */
 if((0 == ps_codec->s_parse.i4_ctb_y) &&
 (0 == ps_codec->s_parse.i4_ctb_x))
 {
        ret = ihevcd_parse_pic_init(ps_codec);
        RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret);

        ps_codec->s_parse.pu4_pic_tu_idx[0] = 0;
        ps_codec->s_parse.pu4_pic_pu_idx[0] = 0;
        ps_codec->s_parse.i4_cur_independent_slice_idx = 0;
        ps_codec->s_parse.i4_ctb_tile_x = 0;
        ps_codec->s_parse.i4_ctb_tile_y = 0;
 }

 {
 /* Updating the poc list of current slice to ps_mv_buf */
 mv_buf_t *ps_mv_buf = ps_codec->s_parse.ps_cur_mv_buf;

 if(ps_slice_hdr->i1_num_ref_idx_l1_active != 0)
 {
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l1_active; i++)
 {
                ps_mv_buf->l1_collocated_poc[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_pic_buf)->i4_abs_poc;
                ps_mv_buf->u1_l1_collocated_poc_lt[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_pic_buf)->u1_used_as_ref;
 }
 }

 if(ps_slice_hdr->i1_num_ref_idx_l0_active != 0)
 {
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l0_active; i++)
 {
                ps_mv_buf->l0_collocated_poc[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_pic_buf)->i4_abs_poc;
                ps_mv_buf->u1_l0_collocated_poc_lt[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_pic_buf)->u1_used_as_ref;
 }
 }
 }

 /*Initialize the low delay flag at the beginning of every slice*/
 if((0 == ps_codec->s_parse.i4_ctb_slice_x) || (0 == ps_codec->s_parse.i4_ctb_slice_y))
 {
 /* Lowdelay flag */
        WORD32 cur_poc, ref_list_poc, flag = 1;
        cur_poc = ps_slice_hdr->i4_abs_pic_order_cnt;
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l0_active; i++)
 {
            ref_list_poc = ((mv_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_mv_buf)->i4_abs_poc;
 if(ref_list_poc > cur_poc)
 {
                flag = 0;
 break;
 }
 }
 if(flag && (ps_slice_hdr->i1_slice_type == BSLICE))
 {
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l1_active; i++)
 {
                ref_list_poc = ((mv_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_mv_buf)->i4_abs_poc;
 if(ref_list_poc > cur_poc)
 {
                    flag = 0;
 break;
 }
 }
 }
        ps_slice_hdr->i1_low_delay_flag = flag;
 }

 /* initialize the cabac init idc based on slice type */
 if(ps_slice_hdr->i1_slice_type == ISLICE)
 {
        cabac_init_idc = 0;
 }
 else if(ps_slice_hdr->i1_slice_type == PSLICE)
 {
        cabac_init_idc = ps_slice_hdr->i1_cabac_init_flag ? 2 : 1;
 }
 else
 {
        cabac_init_idc = ps_slice_hdr->i1_cabac_init_flag ? 1 : 2;
 }

    slice_qp = ps_slice_hdr->i1_slice_qp_delta + ps_pps->i1_pic_init_qp;
    slice_qp = CLIP3(slice_qp, 0, 51);

 /*Update QP value for every indepndent slice or for every dependent slice that begins at the start of a new tile*/
 if((0 == ps_slice_hdr->i1_dependent_slice_flag) ||
 ((1 == ps_slice_hdr->i1_dependent_slice_flag) && ((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))))
 {
        ps_codec->s_parse.u4_qp = slice_qp;
 }

 /*Cabac init at the beginning of a slice*/
 //If the slice is a dependent slice, not present at the start of a tile
 if((1 == ps_slice_hdr->i1_dependent_slice_flag) && (!((ps_codec->s_parse.i4_ctb_tile_x == 0) && (ps_codec->s_parse.i4_ctb_tile_y == 0))))
 {
 if((0 == ps_pps->i1_entropy_coding_sync_enabled_flag) || (ps_pps->i1_entropy_coding_sync_enabled_flag && (0 != ps_codec->s_parse.i4_ctb_x)))
 {
            ihevcd_cabac_reset(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm);
 }
 }
 else if((0 == ps_pps->i1_entropy_coding_sync_enabled_flag) || (ps_pps->i1_entropy_coding_sync_enabled_flag && (0 != ps_codec->s_parse.i4_ctb_x)))
 {
        ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                slice_qp,
                                cabac_init_idc,
 &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);
 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
            ps_codec->i4_slice_error = 1;
            end_of_slice_flag = 1;
            ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }
 }


 do
 {

 {
            WORD32 cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);
 if(1 == ps_codec->i4_num_cores && 0 == cur_ctb_idx % RESET_TU_BUF_NCTB)
 {
                ps_codec->s_parse.ps_tu = ps_codec->s_parse.ps_pic_tu;
                ps_codec->s_parse.i4_pic_tu_idx = 0;
 }
 }

        end_of_pic = 0;
 /* Section:7.3.7 Coding tree unit syntax */
 /* coding_tree_unit() inlined here */
 /* If number of cores is greater than 1, then add job to the queue */
 //TODO: Dual core implementation might need a different algo for better load balancing
 /* At the start of ctb row parsing in a tile, queue a job for processing the current tile row */
        ps_codec->s_parse.i4_ctb_num_pcm_blks = 0;


 /*At the beginning of each tile-which is not the beginning of a slice, cabac context must be initialized.
         * Hence, check for the tile beginning here */
 if(((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))
 && (!((ps_tile->u1_pos_x == 0) && (ps_tile->u1_pos_y == 0)))
 && (!((0 == ps_codec->s_parse.i4_ctb_slice_x) && (0 == ps_codec->s_parse.i4_ctb_slice_y))))
 {
            slice_qp = ps_slice_hdr->i1_slice_qp_delta + ps_pps->i1_pic_init_qp;
            slice_qp = CLIP3(slice_qp, 0, 51);
            ps_codec->s_parse.u4_qp = slice_qp;

            ihevcd_get_tile_pos(ps_pps, ps_sps, ps_codec->s_parse.i4_ctb_x,
                                ps_codec->s_parse.i4_ctb_y,
 &ps_codec->s_parse.i4_ctb_tile_x,
 &ps_codec->s_parse.i4_ctb_tile_y,
 &tile_idx);

            ps_codec->s_parse.ps_tile = ps_pps->ps_tile + tile_idx;
            ps_codec->s_parse.i4_cur_tile_idx = tile_idx;
            ps_tile_prev = ps_tile - 1;

            tile_start_ctb_idx = ps_tile->u1_pos_x
 + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);

            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x
 + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

 /*For slices that span across multiple tiles*/
 if(slice_start_ctb_idx < tile_start_ctb_idx)
 { /* 2 Cases
             * 1 - slice spans across frame-width- but does not start from 1st column
             * 2 - Slice spans across multiple tiles anywhere is a frame
             */
                ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y - ps_slice_hdr->i2_ctb_y;
 if(!(((ps_slice_hdr->i2_ctb_x + ps_tile_prev->u2_wd) % ps_sps->i2_pic_wd_in_ctb) == ps_tile->u1_pos_x)) //Case 2
 {
 if(ps_slice_hdr->i2_ctb_y <= ps_tile->u1_pos_y)
 {
 //Check if ctb x is before or after
 if(ps_slice_hdr->i2_ctb_x > ps_tile->u1_pos_x)
 {
                            ps_codec->s_parse.i4_ctb_slice_y -= 1;
 }
 }
 }
 /*ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y - ps_slice_hdr->i2_ctb_y;
                if (ps_slice_hdr->i2_ctb_y <= ps_tile->u1_pos_y)
                {
                    //Check if ctb x is before or after
                    if (ps_slice_hdr->i2_ctb_x > ps_tile->u1_pos_x )
                    {
                        ps_codec->s_parse.i4_ctb_slice_y -= 1 ;
                    }
                }*/
 }

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
                ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                        slice_qp,
                                        cabac_init_idc,
 &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);
 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
                    ps_codec->i4_slice_error = 1;
                    end_of_slice_flag = 1;
                    ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }

 }
 }
 /* If number of cores is greater than 1, then add job to the queue */
 //TODO: Dual core implementation might need a different algo for better load balancing
 /* At the start of ctb row parsing in a tile, queue a job for processing the current tile row */

 if(0 == ps_codec->s_parse.i4_ctb_tile_x)
 {

 if(1 < ps_codec->i4_num_cores)
 {
 proc_job_t s_job;
                IHEVCD_ERROR_T ret;
                s_job.i4_cmd    = CMD_PROCESS;
                s_job.i2_ctb_cnt = (WORD16)ps_tile->u2_wd;
                s_job.i2_ctb_x = (WORD16)ps_codec->s_parse.i4_ctb_x;
                s_job.i2_ctb_y = (WORD16)ps_codec->s_parse.i4_ctb_y;
                s_job.i2_slice_idx = (WORD16)ps_codec->s_parse.i4_cur_slice_idx;
                s_job.i4_tu_coeff_data_ofst = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data -
 (UWORD8 *)ps_codec->s_parse.pv_pic_tu_coeff_data;
                ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq, &s_job, sizeof(proc_job_t), 1);

 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 return ret;
 }
 else
 {
 process_ctxt_t *ps_proc = &ps_codec->as_process[0];
                WORD32 tu_coeff_data_ofst = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data -
 (UWORD8 *)ps_codec->s_parse.pv_pic_tu_coeff_data;

 /* If the codec is running in single core mode,
                 * initialize zeroth process context
                 * TODO: Dual core mode might need a different implementation instead of jobq
                 */

                ps_proc->i4_ctb_cnt = ps_tile->u2_wd;
                ps_proc->i4_ctb_x   = ps_codec->s_parse.i4_ctb_x;
                ps_proc->i4_ctb_y   = ps_codec->s_parse.i4_ctb_y;
                ps_proc->i4_cur_slice_idx = ps_codec->s_parse.i4_cur_slice_idx;

                ihevcd_init_proc_ctxt(ps_proc, tu_coeff_data_ofst);
 }
 }


 /* Restore cabac context model from top right CTB if entropy sync is enabled */
 if(ps_pps->i1_entropy_coding_sync_enabled_flag)
 {
 /*TODO Handle single CTB and top-right belonging to a different slice */
 if(0 == ps_codec->s_parse.i4_ctb_x)
 {
 //WORD32 size = sizeof(ps_codec->s_parse.s_cabac.au1_ctxt_models);
                WORD32 default_ctxt = 0;

 if((0 == ps_codec->s_parse.i4_ctb_slice_y) && (!ps_slice_hdr->i1_dependent_slice_flag))
                    default_ctxt = 1;
 if(1 == ps_sps->i2_pic_wd_in_ctb)
                    default_ctxt = 1;

                ps_codec->s_parse.u4_qp = slice_qp;
 if(default_ctxt)
 {
 //memcpy(&ps_codec->s_parse.s_cabac.au1_ctxt_models, &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0], size);
                    ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                            slice_qp,
                                            cabac_init_idc,
 &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);

 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
                        ps_codec->i4_slice_error = 1;
                        end_of_slice_flag = 1;
                        ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }
 }
 else
 {
 //memcpy(&ps_codec->s_parse.s_cabac.au1_ctxt_models, &ps_codec->s_parse.s_cabac.au1_ctxt_models_sync, size);
                    ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                            slice_qp,
                                            cabac_init_idc,
 (const UWORD8 *)&ps_codec->s_parse.s_cabac.au1_ctxt_models_sync);

 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
                        ps_codec->i4_slice_error = 1;
                        end_of_slice_flag = 1;
                        ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }
 }
 }
 }



 if(0 == ps_codec->i4_slice_error)
 {
 if(ps_slice_hdr->i1_slice_sao_luma_flag || ps_slice_hdr->i1_slice_sao_chroma_flag)
                ihevcd_parse_sao(ps_codec);
 }
 else
 {
 sao_t *ps_sao = ps_codec->s_parse.ps_pic_sao +
                            ps_codec->s_parse.i4_ctb_x +
                            ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb;

 /* Default values */
            ps_sao->b3_y_type_idx = 0;
            ps_sao->b3_cb_type_idx = 0;
            ps_sao->b3_cr_type_idx = 0;
 }

 //AEV_TRACE(""CTB x"", ps_codec->s_parse.i4_ctb_x, 0);
 //AEV_TRACE(""CTB y"", ps_codec->s_parse.i4_ctb_y, 0);

 {
            WORD32 ctb_indx;
            ctb_indx = ps_codec->s_parse.i4_ctb_x + ps_sps->i2_pic_wd_in_ctb * ps_codec->s_parse.i4_ctb_y;
            ps_codec->s_parse.s_bs_ctxt.pu1_pic_qp_const_in_ctb[ctb_indx >> 3] |= (1 << (ctb_indx & 7));
 {
                UWORD16 *pu1_slice_idx = ps_codec->s_parse.pu1_slice_idx;
                pu1_slice_idx[ctb_indx] = ps_codec->s_parse.i4_cur_independent_slice_idx;
 }
 }

 if(0 == ps_codec->i4_slice_error)
 {
 tu_t *ps_tu = ps_codec->s_parse.ps_tu;
            WORD32 i4_tu_cnt = ps_codec->s_parse.s_cu.i4_tu_cnt;
            WORD32 i4_pic_tu_idx = ps_codec->s_parse.i4_pic_tu_idx;

 pu_t *ps_pu = ps_codec->s_parse.ps_pu;
            WORD32 i4_pic_pu_idx = ps_codec->s_parse.i4_pic_pu_idx;

            UWORD8 *pu1_tu_coeff_data = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data;

            ret = ihevcd_parse_coding_quadtree(ps_codec,
 (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size),
 (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size),
                                               ps_sps->i1_log2_ctb_size,
 0);
 /* Check for error */

             if (ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
             {
                 /* Reset tu and pu parameters, and signal current ctb as skip */
//flaw_line_below:
                WORD32 pu_skip_wd, pu_skip_ht;
//flaw_line_below:
                WORD32 rows_remaining, cols_remaining;
                 WORD32 tu_coeff_data_reset_size;
 
//flaw_line_below:
                /* Set pu wd and ht based on whether the ctb is complete or not */
//flaw_line_below:
                rows_remaining = ps_sps->i2_pic_height_in_luma_samples
//flaw_line_below:
                                - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);
//flaw_line_below:
                pu_skip_ht = MIN(ctb_size, rows_remaining);
//flaw_line_below:

//flaw_line_below:
                cols_remaining = ps_sps->i2_pic_width_in_luma_samples
//flaw_line_below:
                                - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size);
//flaw_line_below:
                pu_skip_wd = MIN(ctb_size, cols_remaining);
//flaw_line_below:

                 ps_codec->s_parse.ps_tu = ps_tu;
                 ps_codec->s_parse.s_cu.i4_tu_cnt = i4_tu_cnt;
                 ps_codec->s_parse.i4_pic_tu_idx = i4_pic_tu_idx;


                 ps_codec->s_parse.ps_pu = ps_pu;
                 ps_codec->s_parse.i4_pic_pu_idx = i4_pic_pu_idx;
 
//flaw_line_below:
                ps_tu->b1_cb_cbf = 0;
//flaw_line_below:
                ps_tu->b1_cr_cbf = 0;
//flaw_line_below:
                ps_tu->b1_y_cbf = 0;
//flaw_line_below:
                ps_tu->b4_pos_x = 0;
//flaw_line_below:
                ps_tu->b4_pos_y = 0;
//flaw_line_below:
                ps_tu->b1_transquant_bypass = 0;
//flaw_line_below:
                ps_tu->b3_size = (ps_sps->i1_log2_ctb_size - 2);
//flaw_line_below:
                ps_tu->b7_qp = ps_codec->s_parse.u4_qp;
//flaw_line_below:
                ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;
//flaw_line_below:
                ps_tu->b6_luma_intra_mode   = INTRA_PRED_NONE;
//flaw_line_below:
                ps_tu->b1_first_tu_in_cu = 1;
//flaw_line_below:

                 tu_coeff_data_reset_size = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data - pu1_tu_coeff_data;
                 memset(pu1_tu_coeff_data, 0, tu_coeff_data_reset_size);
                 ps_codec->s_parse.pv_tu_coeff_data = (void *)pu1_tu_coeff_data;
 
//flaw_line_below:
                ps_codec->s_parse.ps_tu++;
//flaw_line_below:
                ps_codec->s_parse.s_cu.i4_tu_cnt++;
//flaw_line_below:
                ps_codec->s_parse.i4_pic_tu_idx++;
//flaw_line_below:

//flaw_line_below:
                ps_codec->s_parse.s_cu.i4_pred_mode = PRED_MODE_SKIP;
//flaw_line_below:
                ps_codec->s_parse.s_cu.i4_part_mode = PART_2Nx2N;
//flaw_line_below:

//flaw_line_below:
                ps_pu->b2_part_idx = 0;
//flaw_line_below:
                ps_pu->b4_pos_x = 0;
//flaw_line_below:
                ps_pu->b4_pos_y = 0;
//flaw_line_below:
                ps_pu->b4_wd = (pu_skip_wd >> 2) - 1;
//flaw_line_below:
                ps_pu->b4_ht = (pu_skip_ht >> 2) - 1;
//flaw_line_below:
                ps_pu->b1_intra_flag = 0;
//flaw_line_below:
                ps_pu->b3_part_mode = ps_codec->s_parse.s_cu.i4_part_mode;
//flaw_line_below:
                ps_pu->b1_merge_flag = 1;
//flaw_line_below:
                ps_pu->b3_merge_idx = 0;
//flaw_line_below:

//flaw_line_below:
                ps_codec->s_parse.ps_pu++;
//flaw_line_below:
                ps_codec->s_parse.i4_pic_pu_idx++;
//fix_flaw_line_below:
//                ihevcd_set_ctb_skip(ps_codec);
 
                 /* Set slice error to suppress further parsing and
                  * signal end of slice.
                 */
                ps_codec->i4_slice_error = 1;
                end_of_slice_flag = 1;
                ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }

         }
         else
         {
//flaw_line_below:
            tu_t *ps_tu = ps_codec->s_parse.ps_tu;
//flaw_line_below:
            pu_t *ps_pu = ps_codec->s_parse.ps_pu;
//flaw_line_below:
            WORD32 pu_skip_wd, pu_skip_ht;
//flaw_line_below:
            WORD32 rows_remaining, cols_remaining;
//flaw_line_below:

//flaw_line_below:
            /* Set pu wd and ht based on whether the ctb is complete or not */
//flaw_line_below:
            rows_remaining = ps_sps->i2_pic_height_in_luma_samples
//flaw_line_below:
                            - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);
//flaw_line_below:
            pu_skip_ht = MIN(ctb_size, rows_remaining);
//flaw_line_below:

//flaw_line_below:
            cols_remaining = ps_sps->i2_pic_width_in_luma_samples
//flaw_line_below:
                            - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size);
//flaw_line_below:
            pu_skip_wd = MIN(ctb_size, cols_remaining);
//flaw_line_below:

//flaw_line_below:
            ps_tu->b1_cb_cbf = 0;
//flaw_line_below:
            ps_tu->b1_cr_cbf = 0;
//flaw_line_below:
            ps_tu->b1_y_cbf = 0;
//flaw_line_below:
            ps_tu->b4_pos_x = 0;
//flaw_line_below:
            ps_tu->b4_pos_y = 0;
//flaw_line_below:
            ps_tu->b1_transquant_bypass = 0;
//flaw_line_below:
            ps_tu->b3_size = (ps_sps->i1_log2_ctb_size - 2);
//flaw_line_below:
            ps_tu->b7_qp = ps_codec->s_parse.u4_qp;
//flaw_line_below:
            ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;
//flaw_line_below:
            ps_tu->b6_luma_intra_mode   = INTRA_PRED_NONE;
//flaw_line_below:
            ps_tu->b1_first_tu_in_cu = 1;
//flaw_line_below:

//flaw_line_below:
            ps_codec->s_parse.ps_tu++;
//flaw_line_below:
            ps_codec->s_parse.s_cu.i4_tu_cnt++;
//flaw_line_below:
            ps_codec->s_parse.i4_pic_tu_idx++;
//flaw_line_below:

//flaw_line_below:
            ps_codec->s_parse.s_cu.i4_pred_mode = PRED_MODE_SKIP;
//flaw_line_below:
            ps_codec->s_parse.s_cu.i4_part_mode = PART_2Nx2N;
//flaw_line_below:

//flaw_line_below:
            ps_pu->b2_part_idx = 0;
//flaw_line_below:
            ps_pu->b4_pos_x = 0;
//flaw_line_below:
            ps_pu->b4_pos_y = 0;
//flaw_line_below:
            ps_pu->b4_wd = (pu_skip_wd >> 2) - 1;
//flaw_line_below:
            ps_pu->b4_ht = (pu_skip_ht >> 2) - 1;
//flaw_line_below:
            ps_pu->b1_intra_flag = 0;
//flaw_line_below:
            ps_pu->b3_part_mode = ps_codec->s_parse.s_cu.i4_part_mode;
//flaw_line_below:
            ps_pu->b1_merge_flag = 1;
//flaw_line_below:
            ps_pu->b3_merge_idx = 0;
//flaw_line_below:

//flaw_line_below:
            ps_codec->s_parse.ps_pu++;
//flaw_line_below:
            ps_codec->s_parse.i4_pic_pu_idx++;
//flaw_line_below:

//fix_flaw_line_below:
//            ihevcd_set_ctb_skip(ps_codec);
         }
 
         if(0 == ps_codec->i4_slice_error)
            end_of_slice_flag = ihevcd_cabac_decode_terminate(&ps_codec->s_parse.s_cabac, &ps_codec->s_parse.s_bitstrm);

        AEV_TRACE(""end_of_slice_flag"", end_of_slice_flag, ps_codec->s_parse.s_cabac.u4_range);


 /* In case of tiles or entropy sync, terminate cabac and copy cabac context backed up at the end of top-right CTB */
 if(ps_pps->i1_tiles_enabled_flag || ps_pps->i1_entropy_coding_sync_enabled_flag)
 {
            WORD32 end_of_tile = 0;
            WORD32 end_of_tile_row = 0;

 /* Take a back up of cabac context models if entropy sync is enabled */
 if(ps_pps->i1_entropy_coding_sync_enabled_flag || ps_pps->i1_tiles_enabled_flag)
 {
 if(1 == ps_codec->s_parse.i4_ctb_x)
 {
                    WORD32 size = sizeof(ps_codec->s_parse.s_cabac.au1_ctxt_models);
                    memcpy(&ps_codec->s_parse.s_cabac.au1_ctxt_models_sync, &ps_codec->s_parse.s_cabac.au1_ctxt_models, size);
 }
 }

 /* Since tiles and entropy sync are not enabled simultaneously, the following will not result in any problems */
 if((ps_codec->s_parse.i4_ctb_tile_x + 1) == (ps_tile->u2_wd))
 {
                end_of_tile_row = 1;
 if((ps_codec->s_parse.i4_ctb_tile_y + 1) == ps_tile->u2_ht)
                    end_of_tile = 1;
 }
 if((0 == end_of_slice_flag) &&
 ((ps_pps->i1_tiles_enabled_flag && end_of_tile) ||
 (ps_pps->i1_entropy_coding_sync_enabled_flag && end_of_tile_row)))
 {
                WORD32 end_of_sub_stream_one_bit;
                end_of_sub_stream_one_bit = ihevcd_cabac_decode_terminate(&ps_codec->s_parse.s_cabac, &ps_codec->s_parse.s_bitstrm);
                AEV_TRACE(""end_of_sub_stream_one_bit"", end_of_sub_stream_one_bit, ps_codec->s_parse.s_cabac.u4_range);

 /* TODO: Remove the check for offset when HM is updated to include a byte unconditionally even for aligned location */
 /* For Ittiam streams this check should not be there, for HM9.1 streams this should be there */
 if(ps_codec->s_parse.s_bitstrm.u4_bit_ofst % 8)
                    ihevcd_bits_flush_to_byte_boundary(&ps_codec->s_parse.s_bitstrm);

                UNUSED(end_of_sub_stream_one_bit);
 }
 }
 {
            WORD32 ctb_indx;

            ctb_addr = ps_codec->s_parse.i4_ctb_y * num_ctb_in_row + ps_codec->s_parse.i4_ctb_x;

            ctb_indx = ++ctb_addr;

 /* Store pu_idx for next CTB in frame level pu_idx array */

 //In case of multiple tiles, if end-of-tile row is reached
 if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))
 {
                ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.
 if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))
 {
 //If the current ctb is the last tile's last ctb
 if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))
 {
                        ctb_indx = ctb_addr; //Next continuous ctb address
 }
 else //Not last tile's end , but a tile end
 {
 tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;
                        ctb_indx = ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.
 }
 }
 }

            ps_codec->s_parse.pu4_pic_pu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_pu_idx;
            ps_codec->s_parse.i4_next_pu_ctb_cnt = ctb_indx;

            ps_codec->s_parse.pu1_pu_map += num_min4x4_in_ctb;

 /* Store tu_idx for next CTB in frame level tu_idx array */
 if(1 == ps_codec->i4_num_cores)
 {
                ctb_indx = (0 == ctb_addr % RESET_TU_BUF_NCTB) ?
                                RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB;

 //In case of multiple tiles, if end-of-tile row is reached
 if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))
 {
                    ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.
 if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))
 {
 //If the current ctb is the last tile's last ctb
 if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))
 {
                            ctb_indx = (0 == ctb_addr % RESET_TU_BUF_NCTB) ?
                                            RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB;
 }
 else //Not last tile's end , but a tile end
 {
 tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;
                            ctb_indx =  ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.
 }
 }
 }
                ps_codec->s_parse.i4_next_tu_ctb_cnt = ctb_indx;
                ps_codec->s_parse.pu4_pic_tu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_tu_idx;
 }
 else
 {
                ctb_indx = ctb_addr;
 if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))
 {
                    ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.
 if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))
 {
 //If the current ctb is the last tile's last ctb
 if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))
 {
                            ctb_indx = ctb_addr;
 }
 else //Not last tile's end , but a tile end
 {
 tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;
                            ctb_indx =  ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.
 }
 }
 }
                ps_codec->s_parse.i4_next_tu_ctb_cnt = ctb_indx;
                ps_codec->s_parse.pu4_pic_tu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_tu_idx;
 }
            ps_codec->s_parse.pu1_tu_map += num_min4x4_in_ctb;
 }


 if(ps_codec->i4_num_cores <= MV_PRED_NUM_CORES_THRESHOLD)
 {
 /*************************************************/
 /****************   MV pred **********************/
 /*************************************************/
            WORD8 u1_top_ctb_avail = 1;
            WORD8 u1_left_ctb_avail = 1;
            WORD8 u1_top_lt_ctb_avail = 1;
            WORD8 u1_top_rt_ctb_avail = 1;
            WORD16 i2_wd_in_ctb;

            tile_start_ctb_idx = ps_tile->u1_pos_x
 + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);

            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x
 + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

 if((slice_start_ctb_idx < tile_start_ctb_idx))
 {
 //Slices span across multiple tiles.
                i2_wd_in_ctb = ps_sps->i2_pic_wd_in_ctb;
 }
 else
 {
                i2_wd_in_ctb = ps_tile->u2_wd;
 }
 /* slice and tile boundaries */
 if((0 == ps_codec->s_parse.i4_ctb_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                u1_top_ctb_avail = 0;
                u1_top_lt_ctb_avail = 0;
                u1_top_rt_ctb_avail = 0;
 }

 if((0 == ps_codec->s_parse.i4_ctb_x) || (0 == ps_codec->s_parse.i4_ctb_tile_x))
 {
                u1_left_ctb_avail = 0;
                u1_top_lt_ctb_avail = 0;
 if((0 == ps_codec->s_parse.i4_ctb_slice_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                    u1_top_ctb_avail = 0;
 if((i2_wd_in_ctb - 1) != ps_codec->s_parse.i4_ctb_slice_x) //TODO: For tile, not implemented
 {
                        u1_top_rt_ctb_avail = 0;
 }
 }
 }
 /*For slices not beginning at start of a ctb row*/
 else if(ps_codec->s_parse.i4_ctb_x > 0)
 {
 if((0 == ps_codec->s_parse.i4_ctb_slice_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                    u1_top_ctb_avail = 0;
                    u1_top_lt_ctb_avail = 0;
 if(0 == ps_codec->s_parse.i4_ctb_slice_x)
 {
                        u1_left_ctb_avail = 0;
 }
 if((i2_wd_in_ctb - 1) != ps_codec->s_parse.i4_ctb_slice_x)
 {
                        u1_top_rt_ctb_avail = 0;
 }
 }
 else if((1 == ps_codec->s_parse.i4_ctb_slice_y) && (0 == ps_codec->s_parse.i4_ctb_slice_x))
 {
                    u1_top_lt_ctb_avail = 0;
 }
 }

 if(((ps_sps->i2_pic_wd_in_ctb - 1) == ps_codec->s_parse.i4_ctb_x) || ((ps_tile->u2_wd - 1) == ps_codec->s_parse.i4_ctb_tile_x))
 {
                u1_top_rt_ctb_avail = 0;
 }

 if(PSLICE == ps_slice_hdr->i1_slice_type
 || BSLICE == ps_slice_hdr->i1_slice_type)
 {
 mv_ctxt_t s_mv_ctxt;
 process_ctxt_t *ps_proc;
                UWORD32 *pu4_ctb_top_pu_idx;
                UWORD32 *pu4_ctb_left_pu_idx;
                UWORD32 *pu4_ctb_top_left_pu_idx;
                WORD32 i4_ctb_pu_cnt;
                WORD32 cur_ctb_idx;
                WORD32 next_ctb_idx;
                WORD32 cur_pu_idx;
                ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];
                cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);
                next_ctb_idx = ps_codec->s_parse.i4_next_pu_ctb_cnt;
                i4_ctb_pu_cnt = ps_codec->s_parse.pu4_pic_pu_idx[next_ctb_idx]
 - ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];

                cur_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];

                pu4_ctb_top_pu_idx = ps_proc->pu4_pic_pu_idx_top
 + (ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE);
                pu4_ctb_left_pu_idx = ps_proc->pu4_pic_pu_idx_left;
                pu4_ctb_top_left_pu_idx = &ps_proc->u4_ctb_top_left_pu_idx;

 /* Initializing s_mv_ctxt */
 {
                    s_mv_ctxt.ps_pps = ps_pps;
                    s_mv_ctxt.ps_sps = ps_sps;
                    s_mv_ctxt.ps_slice_hdr = ps_slice_hdr;
                    s_mv_ctxt.i4_ctb_x = ps_codec->s_parse.i4_ctb_x;
                    s_mv_ctxt.i4_ctb_y = ps_codec->s_parse.i4_ctb_y;
                    s_mv_ctxt.ps_pu = &ps_codec->s_parse.ps_pic_pu[cur_pu_idx];
                    s_mv_ctxt.ps_pic_pu = ps_codec->s_parse.ps_pic_pu;
                    s_mv_ctxt.ps_tile = ps_tile;
                    s_mv_ctxt.pu4_pic_pu_idx_map = ps_proc->pu4_pic_pu_idx_map;
                    s_mv_ctxt.pu4_pic_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx;
                    s_mv_ctxt.pu1_pic_pu_map = ps_codec->s_parse.pu1_pic_pu_map;
                    s_mv_ctxt.i4_ctb_pu_cnt = i4_ctb_pu_cnt;
                    s_mv_ctxt.i4_ctb_start_pu_idx = cur_pu_idx;
                    s_mv_ctxt.u1_top_ctb_avail = u1_top_ctb_avail;
                    s_mv_ctxt.u1_top_rt_ctb_avail = u1_top_rt_ctb_avail;
                    s_mv_ctxt.u1_top_lt_ctb_avail = u1_top_lt_ctb_avail;
                    s_mv_ctxt.u1_left_ctb_avail = u1_left_ctb_avail;
 }

                ihevcd_get_mv_ctb(&s_mv_ctxt, pu4_ctb_top_pu_idx,
                                  pu4_ctb_left_pu_idx, pu4_ctb_top_left_pu_idx);

 }
 else
 {
                WORD32 num_minpu_in_ctb = (ctb_size / MIN_PU_SIZE) * (ctb_size / MIN_PU_SIZE);
                UWORD8 *pu1_pic_pu_map_ctb = ps_codec->s_parse.pu1_pic_pu_map +
 (ps_codec->s_parse.i4_ctb_x + ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb) * num_minpu_in_ctb;
 process_ctxt_t *ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];
                WORD32 row, col;
                WORD32 pu_cnt;
                WORD32 num_pu_per_ctb;
                WORD32 cur_ctb_idx;
                WORD32 next_ctb_idx;
                WORD32 ctb_start_pu_idx;
                UWORD32 *pu4_nbr_pu_idx = ps_proc->pu4_pic_pu_idx_map;
                WORD32 nbr_pu_idx_strd = MAX_CTB_SIZE / MIN_PU_SIZE + 2;
 pu_t *ps_pu;

 for(row = 0; row < ctb_size / MIN_PU_SIZE; row++)
 {
 for(col = 0; col < ctb_size / MIN_PU_SIZE; col++)
 {
                        pu1_pic_pu_map_ctb[row * ctb_size / MIN_PU_SIZE + col] = 0;
 }
 }


 /* Neighbor PU idx update inside CTB */
 /* 1byte per 4x4. Indicates the PU idx that 4x4 block belongs to */

                cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);
                next_ctb_idx = ps_codec->s_parse.i4_next_pu_ctb_cnt;
                num_pu_per_ctb = ps_codec->s_parse.pu4_pic_pu_idx[next_ctb_idx]
 - ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];
                ctb_start_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];
                ps_pu = &ps_codec->s_parse.ps_pic_pu[ctb_start_pu_idx];

 for(pu_cnt = 0; pu_cnt < num_pu_per_ctb; pu_cnt++, ps_pu++)
 {
                    UWORD32 cur_pu_idx;
                    WORD32 pu_ht = (ps_pu->b4_ht + 1) << 2;
                    WORD32 pu_wd = (ps_pu->b4_wd + 1) << 2;

                    cur_pu_idx = ctb_start_pu_idx + pu_cnt;

 for(row = 0; row < pu_ht / MIN_PU_SIZE; row++)
 for(col = 0; col < pu_wd / MIN_PU_SIZE; col++)
                            pu4_nbr_pu_idx[(1 + ps_pu->b4_pos_x + col)
 + (1 + ps_pu->b4_pos_y + row)
 * nbr_pu_idx_strd] =
                                            cur_pu_idx;
 }

 /* Updating Top and Left pointers */
 {
                    WORD32 rows_remaining = ps_sps->i2_pic_height_in_luma_samples
 - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);
                    WORD32 ctb_size_left = MIN(ctb_size, rows_remaining);

 /* Top Left */
 /* saving top left before updating top ptr, as updating top ptr will overwrite the top left for the next ctb */
                    ps_proc->u4_ctb_top_left_pu_idx = ps_proc->pu4_pic_pu_idx_top[(ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE) + ctb_size / MIN_PU_SIZE - 1];
 for(i = 0; i < ctb_size / MIN_PU_SIZE; i++)
 {
 /* Left */
 /* Last column of au4_nbr_pu_idx */
                        ps_proc->pu4_pic_pu_idx_left[i] = pu4_nbr_pu_idx[(ctb_size / MIN_PU_SIZE)
 + (i + 1) * nbr_pu_idx_strd];
 /* Top */
 /* Last row of au4_nbr_pu_idx */
                        ps_proc->pu4_pic_pu_idx_top[(ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE) + i] =
                                        pu4_nbr_pu_idx[(ctb_size_left / MIN_PU_SIZE) * nbr_pu_idx_strd + i + 1];

 }
 }
 }

 /*************************************************/
 /******************  BS, QP  *********************/
 /*************************************************/
 /* Check if deblock is disabled for the current slice or if it is disabled for the current picture
             * because of disable deblock api
             */
 if(0 == ps_codec->i4_disable_deblk_pic)
 {
 if((0 == ps_slice_hdr->i1_slice_disable_deblocking_filter_flag) &&
 (0 == ps_codec->i4_slice_error))
 {
                    WORD32 i4_ctb_tu_cnt;
                    WORD32 cur_ctb_idx, next_ctb_idx;
                    WORD32 cur_pu_idx;
                    WORD32 cur_tu_idx;
 process_ctxt_t *ps_proc;

                    ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];
                    cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

                    cur_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];
                    next_ctb_idx = ps_codec->s_parse.i4_next_tu_ctb_cnt;
 if(1 == ps_codec->i4_num_cores)
 {
                        i4_ctb_tu_cnt = ps_codec->s_parse.pu4_pic_tu_idx[next_ctb_idx] -
                                        ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx % RESET_TU_BUF_NCTB];

                        cur_tu_idx = ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx % RESET_TU_BUF_NCTB];
 }
 else
 {
                        i4_ctb_tu_cnt = ps_codec->s_parse.pu4_pic_tu_idx[next_ctb_idx] -
                                        ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx];

                        cur_tu_idx = ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx];
 }

                    ps_codec->s_parse.s_bs_ctxt.ps_pps = ps_codec->s_parse.ps_pps;
                    ps_codec->s_parse.s_bs_ctxt.ps_sps = ps_codec->s_parse.ps_sps;
                    ps_codec->s_parse.s_bs_ctxt.ps_codec = ps_codec;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tu_cnt = i4_ctb_tu_cnt;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_x = ps_codec->s_parse.i4_ctb_x;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_y = ps_codec->s_parse.i4_ctb_y;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tile_x = ps_codec->s_parse.i4_ctb_tile_x;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tile_y = ps_codec->s_parse.i4_ctb_tile_y;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_slice_x = ps_codec->s_parse.i4_ctb_slice_x;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_slice_y = ps_codec->s_parse.i4_ctb_slice_y;
                    ps_codec->s_parse.s_bs_ctxt.ps_tu = &ps_codec->s_parse.ps_pic_tu[cur_tu_idx];
                    ps_codec->s_parse.s_bs_ctxt.ps_pu = &ps_codec->s_parse.ps_pic_pu[cur_pu_idx];
                    ps_codec->s_parse.s_bs_ctxt.pu4_pic_pu_idx_map = ps_proc->pu4_pic_pu_idx_map;
                    ps_codec->s_parse.s_bs_ctxt.i4_next_pu_ctb_cnt = ps_codec->s_parse.i4_next_pu_ctb_cnt;
                    ps_codec->s_parse.s_bs_ctxt.i4_next_tu_ctb_cnt = ps_codec->s_parse.i4_next_tu_ctb_cnt;
                    ps_codec->s_parse.s_bs_ctxt.pu1_slice_idx = ps_codec->s_parse.pu1_slice_idx;
                    ps_codec->s_parse.s_bs_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;
                    ps_codec->s_parse.s_bs_ctxt.ps_tile = ps_codec->s_parse.ps_tile;

 if(ISLICE == ps_slice_hdr->i1_slice_type)
 {
                        ihevcd_ctb_boundary_strength_islice(&ps_codec->s_parse.s_bs_ctxt);
 }
 else
 {
                        ihevcd_ctb_boundary_strength_pbslice(&ps_codec->s_parse.s_bs_ctxt);
 }
 }
 else
 {
                    WORD32 bs_strd = (ps_sps->i2_pic_wd_in_ctb + 1) * (ctb_size * ctb_size / 8 / 16);

                    UWORD32 *pu4_vert_bs = (UWORD32 *)((UWORD8 *)ps_codec->s_parse.s_bs_ctxt.pu4_pic_vert_bs +
                                    ps_codec->s_parse.i4_ctb_x * (ctb_size * ctb_size / 8 / 16) +
                                    ps_codec->s_parse.i4_ctb_y * bs_strd);
                    UWORD32 *pu4_horz_bs = (UWORD32 *)((UWORD8 *)ps_codec->s_parse.s_bs_ctxt.pu4_pic_horz_bs +
                                    ps_codec->s_parse.i4_ctb_x * (ctb_size * ctb_size / 8 / 16) +
                                    ps_codec->s_parse.i4_ctb_y * bs_strd);

                    memset(pu4_vert_bs, 0, (ctb_size / 8 + 1) * (ctb_size / 4) / 8 * 2);
                    memset(pu4_horz_bs, 0, (ctb_size / 8) * (ctb_size / 4) / 8 * 2);

 }
 }

 }


 /* Update the parse status map */
 {
 sps_t *ps_sps = ps_codec->s_parse.ps_sps;
            UWORD8 *pu1_buf;
            WORD32 idx;
            idx = (ps_codec->s_parse.i4_ctb_x);
            idx += ((ps_codec->s_parse.i4_ctb_y) * ps_sps->i2_pic_wd_in_ctb);
            pu1_buf = (ps_codec->pu1_parse_map + idx);
 *pu1_buf = 1;
 }

 /* Increment CTB x and y positions */
        ps_codec->s_parse.i4_ctb_tile_x++;
        ps_codec->s_parse.i4_ctb_x++;
        ps_codec->s_parse.i4_ctb_slice_x++;

 /*If tiles are enabled, handle the slice counters differently*/
 if(ps_pps->i1_tiles_enabled_flag)
 {
 //Indicates multiple tiles in a slice case
            tile_start_ctb_idx = ps_tile->u1_pos_x
 + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);

            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x
 + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

 if((slice_start_ctb_idx < tile_start_ctb_idx))
 {
 if(ps_codec->s_parse.i4_ctb_slice_x == (ps_tile->u1_pos_x + ps_tile->u2_wd))
 {
 /* Reached end of slice row within a tile /frame */
                    ps_codec->s_parse.i4_ctb_slice_y++;
                    ps_codec->s_parse.i4_ctb_slice_x = ps_tile->u1_pos_x; //todo:Check
 }
 }
 //Indicates multiple slices in a tile case - hence, reset slice_x
 else if(ps_codec->s_parse.i4_ctb_slice_x == (ps_tile->u2_wd))
 {
                ps_codec->s_parse.i4_ctb_slice_y++;
                ps_codec->s_parse.i4_ctb_slice_x = 0;
 }
 }
 else
 {
 if(ps_codec->s_parse.i4_ctb_slice_x == ps_tile->u2_wd)
 {
 /* Reached end of slice row within a tile /frame */
                ps_codec->s_parse.i4_ctb_slice_y++;
                ps_codec->s_parse.i4_ctb_slice_x = 0;
 }
 }


 if(ps_codec->s_parse.i4_ctb_tile_x == (ps_tile->u2_wd))
 {
 /* Reached end of tile row */
            ps_codec->s_parse.i4_ctb_tile_x = 0;
            ps_codec->s_parse.i4_ctb_x = ps_tile->u1_pos_x;

            ps_codec->s_parse.i4_ctb_tile_y++;
            ps_codec->s_parse.i4_ctb_y++;

 if(ps_codec->s_parse.i4_ctb_tile_y == (ps_tile->u2_ht))
 {
 /* Reached End of Tile */
                ps_codec->s_parse.i4_ctb_tile_y = 0;
                ps_codec->s_parse.i4_ctb_tile_x = 0;
                ps_codec->s_parse.ps_tile++;

 if((ps_tile->u2_ht + ps_tile->u1_pos_y  ==  ps_sps->i2_pic_ht_in_ctb) && (ps_tile->u2_wd + ps_tile->u1_pos_x  ==  ps_sps->i2_pic_wd_in_ctb))
 {
 /* Reached end of frame */
                    end_of_pic = 1;
                    ps_codec->s_parse.i4_ctb_x = 0;
                    ps_codec->s_parse.i4_ctb_y = ps_sps->i2_pic_ht_in_ctb;
 }
 else
 {
 /* Initialize ctb_x and ctb_y to start of next tile */
                    ps_tile = ps_codec->s_parse.ps_tile;
                    ps_codec->s_parse.i4_ctb_x = ps_tile->u1_pos_x;
                    ps_codec->s_parse.i4_ctb_y = ps_tile->u1_pos_y;
                    ps_codec->s_parse.i4_ctb_tile_y = 0;
                    ps_codec->s_parse.i4_ctb_tile_x = 0;
                    ps_codec->s_parse.i4_ctb_slice_x = ps_tile->u1_pos_x;
                    ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y;

 }
 }

 }

        ps_codec->s_parse.i4_next_ctb_indx = ps_codec->s_parse.i4_ctb_x +
                        ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb;

 /* If the current slice is in error, check if the next slice's address
         * is reached and mark the end_of_slice flag */
 if(ps_codec->i4_slice_error)
 {
 slice_header_t *ps_slice_hdr_next = ps_slice_hdr + 1;
            WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x +
                            ps_slice_hdr_next->i2_ctb_y * ps_sps->i2_pic_wd_in_ctb;

 if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr)
                end_of_slice_flag = 1;
 }

 /* If the codec is running in single core mode
         * then call process function for current CTB
         */
 if((1 == ps_codec->i4_num_cores) && (ps_codec->s_parse.i4_ctb_tile_x == 0))
 {
 process_ctxt_t *ps_proc = &ps_codec->as_process[0];
//          ps_proc->i4_ctb_cnt = ihevcd_nctb_cnt(ps_codec, ps_sps);
            ps_proc->i4_ctb_cnt = ps_proc->ps_tile->u2_wd;
            ihevcd_process(ps_proc);
 }

 /* If the bytes for the current slice are exhausted
         * set end_of_slice flag to 1
         * This slice will be treated as incomplete */
 if((UWORD8 *)ps_codec->s_parse.s_bitstrm.pu1_buf_max + BITSTRM_OFF_THRS <
 ((UWORD8 *)ps_codec->s_parse.s_bitstrm.pu4_buf + (ps_codec->s_parse.s_bitstrm.u4_bit_ofst / 8)))
 {
 // end_of_slice_flag = ps_codec->i4_slice_error ? 0 : 1;

 if(0 == ps_codec->i4_slice_error)
                end_of_slice_flag = 1;
 }


 if(end_of_pic)
 break;
 } while(!end_of_slice_flag);

 /* Reset slice error */
    ps_codec->i4_slice_error = 0;

 /* Increment the slice index for parsing next slice */
 if(0 == end_of_pic)
 {
 while(1)
 {

            WORD32 parse_slice_idx;
            parse_slice_idx = ps_codec->s_parse.i4_cur_slice_idx;
            parse_slice_idx++;

 {
 /* If the next slice header is not initialized, update cur_slice_idx and break */
 if((1 == ps_codec->i4_num_cores) || (0 != (parse_slice_idx & (MAX_SLICE_HDR_CNT - 1))))
 {
                    ps_codec->s_parse.i4_cur_slice_idx = parse_slice_idx;
 break;
 }

 /* If the next slice header is initialised, wait for the parsed slices to be processed */
 else
 {
                    WORD32 ctb_indx = 0;

 while(ctb_indx != ps_sps->i4_pic_size_in_ctb)
 {
                        WORD32 parse_status = *(ps_codec->pu1_parse_map + ctb_indx);
 volatile WORD32 proc_status = *(ps_codec->pu1_proc_map + ctb_indx) & 1;

 if(parse_status == proc_status)
                            ctb_indx++;
 }
                    ps_codec->s_parse.i4_cur_slice_idx = parse_slice_idx;
 break;
 }

 }
 }

 }
 else
 {
#if FRAME_ILF_PAD
 if(FRAME_ILF_PAD && 1 == ps_codec->i4_num_cores)
 {
 if(ps_slice_hdr->i4_abs_pic_order_cnt == 0)
 {
                DUMP_PRE_ILF(ps_codec->as_process[0].pu1_cur_pic_luma,
                             ps_codec->as_process[0].pu1_cur_pic_chroma,
                             ps_sps->i2_pic_width_in_luma_samples,
                             ps_sps->i2_pic_height_in_luma_samples,
                             ps_codec->i4_strd);

                DUMP_BS(ps_codec->as_process[0].s_bs_ctxt.pu4_pic_vert_bs,
                        ps_codec->as_process[0].s_bs_ctxt.pu4_pic_horz_bs,
                        ps_sps->i2_pic_wd_in_ctb * (ctb_size * ctb_size / 8 / 16) * ps_sps->i2_pic_ht_in_ctb,
 (ps_sps->i2_pic_wd_in_ctb + 1) * (ctb_size * ctb_size / 8 / 16) * ps_sps->i2_pic_ht_in_ctb);

                DUMP_QP(ps_codec->as_process[0].s_bs_ctxt.pu1_pic_qp,
 (ps_sps->i2_pic_height_in_luma_samples * ps_sps->i2_pic_width_in_luma_samples) / (MIN_CU_SIZE * MIN_CU_SIZE));

                DUMP_QP_CONST_IN_CTB(ps_codec->as_process[0].s_bs_ctxt.pu1_pic_qp_const_in_ctb,
 (ps_sps->i2_pic_height_in_luma_samples * ps_sps->i2_pic_width_in_luma_samples) / (MIN_CTB_SIZE * MIN_CTB_SIZE) / 8);

                DUMP_NO_LOOP_FILTER(ps_codec->as_process[0].pu1_pic_no_loop_filter_flag,
 (ps_sps->i2_pic_width_in_luma_samples / MIN_CU_SIZE) * (ps_sps->i2_pic_height_in_luma_samples / MIN_CU_SIZE) / 8);

                DUMP_OFFSETS(ps_slice_hdr->i1_beta_offset_div2,
                             ps_slice_hdr->i1_tc_offset_div2,
                             ps_pps->i1_pic_cb_qp_offset,
                             ps_pps->i1_pic_cr_qp_offset);
 }
            ps_codec->s_parse.s_deblk_ctxt.ps_pps = ps_codec->s_parse.ps_pps;
            ps_codec->s_parse.s_deblk_ctxt.ps_sps = ps_codec->s_parse.ps_sps;
            ps_codec->s_parse.s_deblk_ctxt.ps_codec = ps_codec;
            ps_codec->s_parse.s_deblk_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;
            ps_codec->s_parse.s_deblk_ctxt.is_chroma_yuv420sp_vu = (ps_codec->e_ref_chroma_fmt == IV_YUV_420SP_VU);

            ps_codec->s_parse.s_sao_ctxt.ps_pps = ps_codec->s_parse.ps_pps;
            ps_codec->s_parse.s_sao_ctxt.ps_sps = ps_codec->s_parse.ps_sps;
            ps_codec->s_parse.s_sao_ctxt.ps_codec = ps_codec;
            ps_codec->s_parse.s_sao_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;

            ihevcd_ilf_pad_frame(&ps_codec->s_parse.s_deblk_ctxt, &ps_codec->s_parse.s_sao_ctxt);

 }
#endif
        ps_codec->s_parse.i4_end_of_frame = 1;
 }
 return ret;
}
",188140,"IHEVCD_ERROR_T ihevcd_parse_slice_data(codec_t *ps_codec)
{

    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
    WORD32 end_of_slice_flag = 0;
 sps_t *ps_sps;
 pps_t *ps_pps;
 slice_header_t *ps_slice_hdr;
    WORD32 end_of_pic;
 tile_t *ps_tile, *ps_tile_prev;
    WORD32 i;
    WORD32 ctb_addr;
    WORD32 tile_idx;
    WORD32 cabac_init_idc;
    WORD32 ctb_size;
    WORD32 num_ctb_in_row;
    WORD32 num_min4x4_in_ctb;
    WORD32 slice_qp;
    WORD32 slice_start_ctb_idx;
    WORD32 tile_start_ctb_idx;


    ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base;
    ps_pps = ps_codec->s_parse.ps_pps_base;
    ps_sps = ps_codec->s_parse.ps_sps_base;

 /* Get current slice header, pps and sps */
    ps_slice_hdr += (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));
    ps_pps  += ps_slice_hdr->i1_pps_id;
    ps_sps  += ps_pps->i1_sps_id;

 if(0 != ps_codec->s_parse.i4_cur_slice_idx)
 {
 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
            ps_codec->s_parse.i4_cur_independent_slice_idx++;
 if(MAX_SLICE_HDR_CNT == ps_codec->s_parse.i4_cur_independent_slice_idx)
                ps_codec->s_parse.i4_cur_independent_slice_idx = 0;
 }
 }


    ctb_size = 1 << ps_sps->i1_log2_ctb_size;
    num_min4x4_in_ctb = (ctb_size / 4) * (ctb_size / 4);
    num_ctb_in_row = ps_sps->i2_pic_wd_in_ctb;

 /* Update the parse context */
 if(0 == ps_codec->i4_slice_error)
 {
        ps_codec->s_parse.i4_ctb_x = ps_slice_hdr->i2_ctb_x;
        ps_codec->s_parse.i4_ctb_y = ps_slice_hdr->i2_ctb_y;
 }
    ps_codec->s_parse.ps_pps = ps_pps;
    ps_codec->s_parse.ps_sps = ps_sps;
    ps_codec->s_parse.ps_slice_hdr = ps_slice_hdr;

 /* Derive Tile positions for the current CTB */
 /* Change this to lookup if required */
    ihevcd_get_tile_pos(ps_pps, ps_sps, ps_codec->s_parse.i4_ctb_x,
                        ps_codec->s_parse.i4_ctb_y,
 &ps_codec->s_parse.i4_ctb_tile_x,
 &ps_codec->s_parse.i4_ctb_tile_y,
 &tile_idx);
    ps_codec->s_parse.ps_tile = ps_pps->ps_tile + tile_idx;
    ps_codec->s_parse.i4_cur_tile_idx = tile_idx;
    ps_tile = ps_codec->s_parse.ps_tile;
 if(tile_idx)
        ps_tile_prev = ps_tile - 1;
 else
        ps_tile_prev = ps_tile;

 /* If the present slice is dependent, then store the previous
     * independent slices' ctb x and y values for decoding process */
 if(0 == ps_codec->i4_slice_error)
 {
 if(1 == ps_slice_hdr->i1_dependent_slice_flag)
 {
 /*If slice is present at the start of a new tile*/
 if((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                ps_codec->s_parse.i4_ctb_slice_x = 0;
                ps_codec->s_parse.i4_ctb_slice_y = 0;
 }
 }

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
            ps_codec->s_parse.i4_ctb_slice_x = 0;
            ps_codec->s_parse.i4_ctb_slice_y = 0;
 }
 }

 /* Frame level initializations */
 if((0 == ps_codec->s_parse.i4_ctb_y) &&
 (0 == ps_codec->s_parse.i4_ctb_x))
 {
        ret = ihevcd_parse_pic_init(ps_codec);
        RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret);

        ps_codec->s_parse.pu4_pic_tu_idx[0] = 0;
        ps_codec->s_parse.pu4_pic_pu_idx[0] = 0;
        ps_codec->s_parse.i4_cur_independent_slice_idx = 0;
        ps_codec->s_parse.i4_ctb_tile_x = 0;
        ps_codec->s_parse.i4_ctb_tile_y = 0;
 }

 {
 /* Updating the poc list of current slice to ps_mv_buf */
 mv_buf_t *ps_mv_buf = ps_codec->s_parse.ps_cur_mv_buf;

 if(ps_slice_hdr->i1_num_ref_idx_l1_active != 0)
 {
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l1_active; i++)
 {
                ps_mv_buf->l1_collocated_poc[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_pic_buf)->i4_abs_poc;
                ps_mv_buf->u1_l1_collocated_poc_lt[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_pic_buf)->u1_used_as_ref;
 }
 }

 if(ps_slice_hdr->i1_num_ref_idx_l0_active != 0)
 {
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l0_active; i++)
 {
                ps_mv_buf->l0_collocated_poc[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_pic_buf)->i4_abs_poc;
                ps_mv_buf->u1_l0_collocated_poc_lt[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_pic_buf)->u1_used_as_ref;
 }
 }
 }

 /*Initialize the low delay flag at the beginning of every slice*/
 if((0 == ps_codec->s_parse.i4_ctb_slice_x) || (0 == ps_codec->s_parse.i4_ctb_slice_y))
 {
 /* Lowdelay flag */
        WORD32 cur_poc, ref_list_poc, flag = 1;
        cur_poc = ps_slice_hdr->i4_abs_pic_order_cnt;
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l0_active; i++)
 {
            ref_list_poc = ((mv_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_mv_buf)->i4_abs_poc;
 if(ref_list_poc > cur_poc)
 {
                flag = 0;
 break;
 }
 }
 if(flag && (ps_slice_hdr->i1_slice_type == BSLICE))
 {
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l1_active; i++)
 {
                ref_list_poc = ((mv_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_mv_buf)->i4_abs_poc;
 if(ref_list_poc > cur_poc)
 {
                    flag = 0;
 break;
 }
 }
 }
        ps_slice_hdr->i1_low_delay_flag = flag;
 }

 /* initialize the cabac init idc based on slice type */
 if(ps_slice_hdr->i1_slice_type == ISLICE)
 {
        cabac_init_idc = 0;
 }
 else if(ps_slice_hdr->i1_slice_type == PSLICE)
 {
        cabac_init_idc = ps_slice_hdr->i1_cabac_init_flag ? 2 : 1;
 }
 else
 {
        cabac_init_idc = ps_slice_hdr->i1_cabac_init_flag ? 1 : 2;
 }

    slice_qp = ps_slice_hdr->i1_slice_qp_delta + ps_pps->i1_pic_init_qp;
    slice_qp = CLIP3(slice_qp, 0, 51);

 /*Update QP value for every indepndent slice or for every dependent slice that begins at the start of a new tile*/
 if((0 == ps_slice_hdr->i1_dependent_slice_flag) ||
 ((1 == ps_slice_hdr->i1_dependent_slice_flag) && ((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))))
 {
        ps_codec->s_parse.u4_qp = slice_qp;
 }

 /*Cabac init at the beginning of a slice*/
 if((1 == ps_slice_hdr->i1_dependent_slice_flag) && (!((ps_codec->s_parse.i4_ctb_tile_x == 0) && (ps_codec->s_parse.i4_ctb_tile_y == 0))))
 {
 if((0 == ps_pps->i1_entropy_coding_sync_enabled_flag) || (ps_pps->i1_entropy_coding_sync_enabled_flag && (0 != ps_codec->s_parse.i4_ctb_x)))
 {
            ihevcd_cabac_reset(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm);
 }
 }
 else if((0 == ps_pps->i1_entropy_coding_sync_enabled_flag) || (ps_pps->i1_entropy_coding_sync_enabled_flag && (0 != ps_codec->s_parse.i4_ctb_x)))
 {
        ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                slice_qp,
                                cabac_init_idc,
 &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);
 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
            ps_codec->i4_slice_error = 1;
            end_of_slice_flag = 1;
            ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }
 }


 do
 {

 {
            WORD32 cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);
 if(1 == ps_codec->i4_num_cores && 0 == cur_ctb_idx % RESET_TU_BUF_NCTB)
 {
                ps_codec->s_parse.ps_tu = ps_codec->s_parse.ps_pic_tu;
                ps_codec->s_parse.i4_pic_tu_idx = 0;
 }
 }

        end_of_pic = 0;
 /* Section:7.3.7 Coding tree unit syntax */
 /* coding_tree_unit() inlined here */
 /* If number of cores is greater than 1, then add job to the queue */
 /* At the start of ctb row parsing in a tile, queue a job for processing the current tile row */
        ps_codec->s_parse.i4_ctb_num_pcm_blks = 0;


 /*At the beginning of each tile-which is not the beginning of a slice, cabac context must be initialized.
         * Hence, check for the tile beginning here */
 if(((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))
 && (!((ps_tile->u1_pos_x == 0) && (ps_tile->u1_pos_y == 0)))
 && (!((0 == ps_codec->s_parse.i4_ctb_slice_x) && (0 == ps_codec->s_parse.i4_ctb_slice_y))))
 {
            slice_qp = ps_slice_hdr->i1_slice_qp_delta + ps_pps->i1_pic_init_qp;
            slice_qp = CLIP3(slice_qp, 0, 51);
            ps_codec->s_parse.u4_qp = slice_qp;

            ihevcd_get_tile_pos(ps_pps, ps_sps, ps_codec->s_parse.i4_ctb_x,
                                ps_codec->s_parse.i4_ctb_y,
 &ps_codec->s_parse.i4_ctb_tile_x,
 &ps_codec->s_parse.i4_ctb_tile_y,
 &tile_idx);

            ps_codec->s_parse.ps_tile = ps_pps->ps_tile + tile_idx;
            ps_codec->s_parse.i4_cur_tile_idx = tile_idx;
            ps_tile_prev = ps_tile - 1;

            tile_start_ctb_idx = ps_tile->u1_pos_x
 + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);

            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x
 + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

 /*For slices that span across multiple tiles*/
 if(slice_start_ctb_idx < tile_start_ctb_idx)
 { /* 2 Cases
             * 1 - slice spans across frame-width- but does not start from 1st column
             * 2 - Slice spans across multiple tiles anywhere is a frame
             */
                ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y - ps_slice_hdr->i2_ctb_y;
 if(!(((ps_slice_hdr->i2_ctb_x + ps_tile_prev->u2_wd) % ps_sps->i2_pic_wd_in_ctb) == ps_tile->u1_pos_x)) //Case 2
 {
 if(ps_slice_hdr->i2_ctb_y <= ps_tile->u1_pos_y)
 {
 if(ps_slice_hdr->i2_ctb_x > ps_tile->u1_pos_x)
 {
                            ps_codec->s_parse.i4_ctb_slice_y -= 1;
 }
 }
 }
 /*ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y - ps_slice_hdr->i2_ctb_y;
                if (ps_slice_hdr->i2_ctb_y <= ps_tile->u1_pos_y)
                {
                    if (ps_slice_hdr->i2_ctb_x > ps_tile->u1_pos_x )
                    {
                        ps_codec->s_parse.i4_ctb_slice_y -= 1 ;
                    }
                }*/
 }

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
                ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                        slice_qp,
                                        cabac_init_idc,
 &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);
 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
                    ps_codec->i4_slice_error = 1;
                    end_of_slice_flag = 1;
                    ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }

 }
 }
 /* If number of cores is greater than 1, then add job to the queue */
 /* At the start of ctb row parsing in a tile, queue a job for processing the current tile row */

 if(0 == ps_codec->s_parse.i4_ctb_tile_x)
 {

 if(1 < ps_codec->i4_num_cores)
 {
 proc_job_t s_job;
                IHEVCD_ERROR_T ret;
                s_job.i4_cmd    = CMD_PROCESS;
                s_job.i2_ctb_cnt = (WORD16)ps_tile->u2_wd;
                s_job.i2_ctb_x = (WORD16)ps_codec->s_parse.i4_ctb_x;
                s_job.i2_ctb_y = (WORD16)ps_codec->s_parse.i4_ctb_y;
                s_job.i2_slice_idx = (WORD16)ps_codec->s_parse.i4_cur_slice_idx;
                s_job.i4_tu_coeff_data_ofst = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data -
 (UWORD8 *)ps_codec->s_parse.pv_pic_tu_coeff_data;
                ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq, &s_job, sizeof(proc_job_t), 1);

 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 return ret;
 }
 else
 {
 process_ctxt_t *ps_proc = &ps_codec->as_process[0];
                WORD32 tu_coeff_data_ofst = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data -
 (UWORD8 *)ps_codec->s_parse.pv_pic_tu_coeff_data;

 /* If the codec is running in single core mode,
                 * initialize zeroth process context
                 * TODO: Dual core mode might need a different implementation instead of jobq
                 */

                ps_proc->i4_ctb_cnt = ps_tile->u2_wd;
                ps_proc->i4_ctb_x   = ps_codec->s_parse.i4_ctb_x;
                ps_proc->i4_ctb_y   = ps_codec->s_parse.i4_ctb_y;
                ps_proc->i4_cur_slice_idx = ps_codec->s_parse.i4_cur_slice_idx;

                ihevcd_init_proc_ctxt(ps_proc, tu_coeff_data_ofst);
 }
 }


 /* Restore cabac context model from top right CTB if entropy sync is enabled */
 if(ps_pps->i1_entropy_coding_sync_enabled_flag)
 {
 /*TODO Handle single CTB and top-right belonging to a different slice */
 if(0 == ps_codec->s_parse.i4_ctb_x)
 {
                WORD32 default_ctxt = 0;

 if((0 == ps_codec->s_parse.i4_ctb_slice_y) && (!ps_slice_hdr->i1_dependent_slice_flag))
                    default_ctxt = 1;
 if(1 == ps_sps->i2_pic_wd_in_ctb)
                    default_ctxt = 1;

                ps_codec->s_parse.u4_qp = slice_qp;
 if(default_ctxt)
 {
                    ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                            slice_qp,
                                            cabac_init_idc,
 &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);

 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
                        ps_codec->i4_slice_error = 1;
                        end_of_slice_flag = 1;
                        ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }
 }
 else
 {
                    ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                            slice_qp,
                                            cabac_init_idc,
 (const UWORD8 *)&ps_codec->s_parse.s_cabac.au1_ctxt_models_sync);

 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
                        ps_codec->i4_slice_error = 1;
                        end_of_slice_flag = 1;
                        ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }
 }
 }
 }



 if(0 == ps_codec->i4_slice_error)
 {
 if(ps_slice_hdr->i1_slice_sao_luma_flag || ps_slice_hdr->i1_slice_sao_chroma_flag)
                ihevcd_parse_sao(ps_codec);
 }
 else
 {
 sao_t *ps_sao = ps_codec->s_parse.ps_pic_sao +
                            ps_codec->s_parse.i4_ctb_x +
                            ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb;

 /* Default values */
            ps_sao->b3_y_type_idx = 0;
            ps_sao->b3_cb_type_idx = 0;
            ps_sao->b3_cr_type_idx = 0;
 }


 {
            WORD32 ctb_indx;
            ctb_indx = ps_codec->s_parse.i4_ctb_x + ps_sps->i2_pic_wd_in_ctb * ps_codec->s_parse.i4_ctb_y;
            ps_codec->s_parse.s_bs_ctxt.pu1_pic_qp_const_in_ctb[ctb_indx >> 3] |= (1 << (ctb_indx & 7));
 {
                UWORD16 *pu1_slice_idx = ps_codec->s_parse.pu1_slice_idx;
                pu1_slice_idx[ctb_indx] = ps_codec->s_parse.i4_cur_independent_slice_idx;
 }
 }

 if(0 == ps_codec->i4_slice_error)
 {
 tu_t *ps_tu = ps_codec->s_parse.ps_tu;
            WORD32 i4_tu_cnt = ps_codec->s_parse.s_cu.i4_tu_cnt;
            WORD32 i4_pic_tu_idx = ps_codec->s_parse.i4_pic_tu_idx;

 pu_t *ps_pu = ps_codec->s_parse.ps_pu;
            WORD32 i4_pic_pu_idx = ps_codec->s_parse.i4_pic_pu_idx;

            UWORD8 *pu1_tu_coeff_data = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data;

            ret = ihevcd_parse_coding_quadtree(ps_codec,
 (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size),
 (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size),
                                               ps_sps->i1_log2_ctb_size,
 0);
 /* Check for error */

             if (ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
             {
                 /* Reset tu and pu parameters, and signal current ctb as skip */
                WORD32 pu_skip_wd, pu_skip_ht;
                WORD32 rows_remaining, cols_remaining;
                 WORD32 tu_coeff_data_reset_size;
 
                /* Set pu wd and ht based on whether the ctb is complete or not */
                rows_remaining = ps_sps->i2_pic_height_in_luma_samples
                                - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);
                pu_skip_ht = MIN(ctb_size, rows_remaining);
                cols_remaining = ps_sps->i2_pic_width_in_luma_samples
                                - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size);
                pu_skip_wd = MIN(ctb_size, cols_remaining);
                 ps_codec->s_parse.ps_tu = ps_tu;
                 ps_codec->s_parse.s_cu.i4_tu_cnt = i4_tu_cnt;
                 ps_codec->s_parse.i4_pic_tu_idx = i4_pic_tu_idx;


                 ps_codec->s_parse.ps_pu = ps_pu;
                 ps_codec->s_parse.i4_pic_pu_idx = i4_pic_pu_idx;
 
                ps_tu->b1_cb_cbf = 0;
                ps_tu->b1_cr_cbf = 0;
                ps_tu->b1_y_cbf = 0;
                ps_tu->b4_pos_x = 0;
                ps_tu->b4_pos_y = 0;
                ps_tu->b1_transquant_bypass = 0;
                ps_tu->b3_size = (ps_sps->i1_log2_ctb_size - 2);
                ps_tu->b7_qp = ps_codec->s_parse.u4_qp;
                ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;
                ps_tu->b6_luma_intra_mode   = INTRA_PRED_NONE;
                ps_tu->b1_first_tu_in_cu = 1;
                 tu_coeff_data_reset_size = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data - pu1_tu_coeff_data;
                 memset(pu1_tu_coeff_data, 0, tu_coeff_data_reset_size);
                 ps_codec->s_parse.pv_tu_coeff_data = (void *)pu1_tu_coeff_data;
 
                ps_codec->s_parse.ps_tu++;
                ps_codec->s_parse.s_cu.i4_tu_cnt++;
                ps_codec->s_parse.i4_pic_tu_idx++;
                ps_codec->s_parse.s_cu.i4_pred_mode = PRED_MODE_SKIP;
                ps_codec->s_parse.s_cu.i4_part_mode = PART_2Nx2N;
                ps_pu->b2_part_idx = 0;
                ps_pu->b4_pos_x = 0;
                ps_pu->b4_pos_y = 0;
                ps_pu->b4_wd = (pu_skip_wd >> 2) - 1;
                ps_pu->b4_ht = (pu_skip_ht >> 2) - 1;
                ps_pu->b1_intra_flag = 0;
                ps_pu->b3_part_mode = ps_codec->s_parse.s_cu.i4_part_mode;
                ps_pu->b1_merge_flag = 1;
                ps_pu->b3_merge_idx = 0;
                ps_codec->s_parse.ps_pu++;
                ps_codec->s_parse.i4_pic_pu_idx++;
 
                 /* Set slice error to suppress further parsing and
                  * signal end of slice.
                 */
                ps_codec->i4_slice_error = 1;
                end_of_slice_flag = 1;
                ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }

         }
         else
         {
            tu_t *ps_tu = ps_codec->s_parse.ps_tu;
            pu_t *ps_pu = ps_codec->s_parse.ps_pu;
            WORD32 pu_skip_wd, pu_skip_ht;
            WORD32 rows_remaining, cols_remaining;
            /* Set pu wd and ht based on whether the ctb is complete or not */
            rows_remaining = ps_sps->i2_pic_height_in_luma_samples
                            - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);
            pu_skip_ht = MIN(ctb_size, rows_remaining);
            cols_remaining = ps_sps->i2_pic_width_in_luma_samples
                            - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size);
            pu_skip_wd = MIN(ctb_size, cols_remaining);
            ps_tu->b1_cb_cbf = 0;
            ps_tu->b1_cr_cbf = 0;
            ps_tu->b1_y_cbf = 0;
            ps_tu->b4_pos_x = 0;
            ps_tu->b4_pos_y = 0;
            ps_tu->b1_transquant_bypass = 0;
            ps_tu->b3_size = (ps_sps->i1_log2_ctb_size - 2);
            ps_tu->b7_qp = ps_codec->s_parse.u4_qp;
            ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;
            ps_tu->b6_luma_intra_mode   = INTRA_PRED_NONE;
            ps_tu->b1_first_tu_in_cu = 1;
            ps_codec->s_parse.ps_tu++;
            ps_codec->s_parse.s_cu.i4_tu_cnt++;
            ps_codec->s_parse.i4_pic_tu_idx++;
            ps_codec->s_parse.s_cu.i4_pred_mode = PRED_MODE_SKIP;
            ps_codec->s_parse.s_cu.i4_part_mode = PART_2Nx2N;
            ps_pu->b2_part_idx = 0;
            ps_pu->b4_pos_x = 0;
            ps_pu->b4_pos_y = 0;
            ps_pu->b4_wd = (pu_skip_wd >> 2) - 1;
            ps_pu->b4_ht = (pu_skip_ht >> 2) - 1;
            ps_pu->b1_intra_flag = 0;
            ps_pu->b3_part_mode = ps_codec->s_parse.s_cu.i4_part_mode;
            ps_pu->b1_merge_flag = 1;
            ps_pu->b3_merge_idx = 0;
            ps_codec->s_parse.ps_pu++;
            ps_codec->s_parse.i4_pic_pu_idx++;
         }
 
         if(0 == ps_codec->i4_slice_error)
            end_of_slice_flag = ihevcd_cabac_decode_terminate(&ps_codec->s_parse.s_cabac, &ps_codec->s_parse.s_bitstrm);

        AEV_TRACE(""end_of_slice_flag"", end_of_slice_flag, ps_codec->s_parse.s_cabac.u4_range);


 /* In case of tiles or entropy sync, terminate cabac and copy cabac context backed up at the end of top-right CTB */
 if(ps_pps->i1_tiles_enabled_flag || ps_pps->i1_entropy_coding_sync_enabled_flag)
 {
            WORD32 end_of_tile = 0;
            WORD32 end_of_tile_row = 0;

 /* Take a back up of cabac context models if entropy sync is enabled */
 if(ps_pps->i1_entropy_coding_sync_enabled_flag || ps_pps->i1_tiles_enabled_flag)
 {
 if(1 == ps_codec->s_parse.i4_ctb_x)
 {
                    WORD32 size = sizeof(ps_codec->s_parse.s_cabac.au1_ctxt_models);
                    memcpy(&ps_codec->s_parse.s_cabac.au1_ctxt_models_sync, &ps_codec->s_parse.s_cabac.au1_ctxt_models, size);
 }
 }

 /* Since tiles and entropy sync are not enabled simultaneously, the following will not result in any problems */
 if((ps_codec->s_parse.i4_ctb_tile_x + 1) == (ps_tile->u2_wd))
 {
                end_of_tile_row = 1;
 if((ps_codec->s_parse.i4_ctb_tile_y + 1) == ps_tile->u2_ht)
                    end_of_tile = 1;
 }
 if((0 == end_of_slice_flag) &&
 ((ps_pps->i1_tiles_enabled_flag && end_of_tile) ||
 (ps_pps->i1_entropy_coding_sync_enabled_flag && end_of_tile_row)))
 {
                WORD32 end_of_sub_stream_one_bit;
                end_of_sub_stream_one_bit = ihevcd_cabac_decode_terminate(&ps_codec->s_parse.s_cabac, &ps_codec->s_parse.s_bitstrm);
                AEV_TRACE(""end_of_sub_stream_one_bit"", end_of_sub_stream_one_bit, ps_codec->s_parse.s_cabac.u4_range);

 /* TODO: Remove the check for offset when HM is updated to include a byte unconditionally even for aligned location */
 /* For Ittiam streams this check should not be there, for HM9.1 streams this should be there */
 if(ps_codec->s_parse.s_bitstrm.u4_bit_ofst % 8)
                    ihevcd_bits_flush_to_byte_boundary(&ps_codec->s_parse.s_bitstrm);

                UNUSED(end_of_sub_stream_one_bit);
 }
 }
 {
            WORD32 ctb_indx;

            ctb_addr = ps_codec->s_parse.i4_ctb_y * num_ctb_in_row + ps_codec->s_parse.i4_ctb_x;

            ctb_indx = ++ctb_addr;

 /* Store pu_idx for next CTB in frame level pu_idx array */

 if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))
 {
                ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.
 if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))
 {
 if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))
 {
                        ctb_indx = ctb_addr; //Next continuous ctb address
 }
 else //Not last tile's end , but a tile end
 {
 tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;
                        ctb_indx = ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.
 }
 }
 }

            ps_codec->s_parse.pu4_pic_pu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_pu_idx;
            ps_codec->s_parse.i4_next_pu_ctb_cnt = ctb_indx;

            ps_codec->s_parse.pu1_pu_map += num_min4x4_in_ctb;

 /* Store tu_idx for next CTB in frame level tu_idx array */
 if(1 == ps_codec->i4_num_cores)
 {
                ctb_indx = (0 == ctb_addr % RESET_TU_BUF_NCTB) ?
                                RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB;

 if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))
 {
                    ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.
 if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))
 {
 if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))
 {
                            ctb_indx = (0 == ctb_addr % RESET_TU_BUF_NCTB) ?
                                            RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB;
 }
 else //Not last tile's end , but a tile end
 {
 tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;
                            ctb_indx =  ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.
 }
 }
 }
                ps_codec->s_parse.i4_next_tu_ctb_cnt = ctb_indx;
                ps_codec->s_parse.pu4_pic_tu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_tu_idx;
 }
 else
 {
                ctb_indx = ctb_addr;
 if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))
 {
                    ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.
 if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))
 {
 if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))
 {
                            ctb_indx = ctb_addr;
 }
 else //Not last tile's end , but a tile end
 {
 tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;
                            ctb_indx =  ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.
 }
 }
 }
                ps_codec->s_parse.i4_next_tu_ctb_cnt = ctb_indx;
                ps_codec->s_parse.pu4_pic_tu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_tu_idx;
 }
            ps_codec->s_parse.pu1_tu_map += num_min4x4_in_ctb;
 }


 if(ps_codec->i4_num_cores <= MV_PRED_NUM_CORES_THRESHOLD)
 {
 /*************************************************/
 /****************   MV pred **********************/
 /*************************************************/
            WORD8 u1_top_ctb_avail = 1;
            WORD8 u1_left_ctb_avail = 1;
            WORD8 u1_top_lt_ctb_avail = 1;
            WORD8 u1_top_rt_ctb_avail = 1;
            WORD16 i2_wd_in_ctb;

            tile_start_ctb_idx = ps_tile->u1_pos_x
 + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);

            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x
 + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

 if((slice_start_ctb_idx < tile_start_ctb_idx))
 {
                i2_wd_in_ctb = ps_sps->i2_pic_wd_in_ctb;
 }
 else
 {
                i2_wd_in_ctb = ps_tile->u2_wd;
 }
 /* slice and tile boundaries */
 if((0 == ps_codec->s_parse.i4_ctb_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                u1_top_ctb_avail = 0;
                u1_top_lt_ctb_avail = 0;
                u1_top_rt_ctb_avail = 0;
 }

 if((0 == ps_codec->s_parse.i4_ctb_x) || (0 == ps_codec->s_parse.i4_ctb_tile_x))
 {
                u1_left_ctb_avail = 0;
                u1_top_lt_ctb_avail = 0;
 if((0 == ps_codec->s_parse.i4_ctb_slice_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                    u1_top_ctb_avail = 0;
 if((i2_wd_in_ctb - 1) != ps_codec->s_parse.i4_ctb_slice_x) //TODO: For tile, not implemented
 {
                        u1_top_rt_ctb_avail = 0;
 }
 }
 }
 /*For slices not beginning at start of a ctb row*/
 else if(ps_codec->s_parse.i4_ctb_x > 0)
 {
 if((0 == ps_codec->s_parse.i4_ctb_slice_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                    u1_top_ctb_avail = 0;
                    u1_top_lt_ctb_avail = 0;
 if(0 == ps_codec->s_parse.i4_ctb_slice_x)
 {
                        u1_left_ctb_avail = 0;
 }
 if((i2_wd_in_ctb - 1) != ps_codec->s_parse.i4_ctb_slice_x)
 {
                        u1_top_rt_ctb_avail = 0;
 }
 }
 else if((1 == ps_codec->s_parse.i4_ctb_slice_y) && (0 == ps_codec->s_parse.i4_ctb_slice_x))
 {
                    u1_top_lt_ctb_avail = 0;
 }
 }

 if(((ps_sps->i2_pic_wd_in_ctb - 1) == ps_codec->s_parse.i4_ctb_x) || ((ps_tile->u2_wd - 1) == ps_codec->s_parse.i4_ctb_tile_x))
 {
                u1_top_rt_ctb_avail = 0;
 }

 if(PSLICE == ps_slice_hdr->i1_slice_type
 || BSLICE == ps_slice_hdr->i1_slice_type)
 {
 mv_ctxt_t s_mv_ctxt;
 process_ctxt_t *ps_proc;
                UWORD32 *pu4_ctb_top_pu_idx;
                UWORD32 *pu4_ctb_left_pu_idx;
                UWORD32 *pu4_ctb_top_left_pu_idx;
                WORD32 i4_ctb_pu_cnt;
                WORD32 cur_ctb_idx;
                WORD32 next_ctb_idx;
                WORD32 cur_pu_idx;
                ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];
                cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);
                next_ctb_idx = ps_codec->s_parse.i4_next_pu_ctb_cnt;
                i4_ctb_pu_cnt = ps_codec->s_parse.pu4_pic_pu_idx[next_ctb_idx]
 - ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];

                cur_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];

                pu4_ctb_top_pu_idx = ps_proc->pu4_pic_pu_idx_top
 + (ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE);
                pu4_ctb_left_pu_idx = ps_proc->pu4_pic_pu_idx_left;
                pu4_ctb_top_left_pu_idx = &ps_proc->u4_ctb_top_left_pu_idx;

 /* Initializing s_mv_ctxt */
 {
                    s_mv_ctxt.ps_pps = ps_pps;
                    s_mv_ctxt.ps_sps = ps_sps;
                    s_mv_ctxt.ps_slice_hdr = ps_slice_hdr;
                    s_mv_ctxt.i4_ctb_x = ps_codec->s_parse.i4_ctb_x;
                    s_mv_ctxt.i4_ctb_y = ps_codec->s_parse.i4_ctb_y;
                    s_mv_ctxt.ps_pu = &ps_codec->s_parse.ps_pic_pu[cur_pu_idx];
                    s_mv_ctxt.ps_pic_pu = ps_codec->s_parse.ps_pic_pu;
                    s_mv_ctxt.ps_tile = ps_tile;
                    s_mv_ctxt.pu4_pic_pu_idx_map = ps_proc->pu4_pic_pu_idx_map;
                    s_mv_ctxt.pu4_pic_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx;
                    s_mv_ctxt.pu1_pic_pu_map = ps_codec->s_parse.pu1_pic_pu_map;
                    s_mv_ctxt.i4_ctb_pu_cnt = i4_ctb_pu_cnt;
                    s_mv_ctxt.i4_ctb_start_pu_idx = cur_pu_idx;
                    s_mv_ctxt.u1_top_ctb_avail = u1_top_ctb_avail;
                    s_mv_ctxt.u1_top_rt_ctb_avail = u1_top_rt_ctb_avail;
                    s_mv_ctxt.u1_top_lt_ctb_avail = u1_top_lt_ctb_avail;
                    s_mv_ctxt.u1_left_ctb_avail = u1_left_ctb_avail;
 }

                ihevcd_get_mv_ctb(&s_mv_ctxt, pu4_ctb_top_pu_idx,
                                  pu4_ctb_left_pu_idx, pu4_ctb_top_left_pu_idx);

 }
 else
 {
                WORD32 num_minpu_in_ctb = (ctb_size / MIN_PU_SIZE) * (ctb_size / MIN_PU_SIZE);
                UWORD8 *pu1_pic_pu_map_ctb = ps_codec->s_parse.pu1_pic_pu_map +
 (ps_codec->s_parse.i4_ctb_x + ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb) * num_minpu_in_ctb;
 process_ctxt_t *ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];
                WORD32 row, col;
                WORD32 pu_cnt;
                WORD32 num_pu_per_ctb;
                WORD32 cur_ctb_idx;
                WORD32 next_ctb_idx;
                WORD32 ctb_start_pu_idx;
                UWORD32 *pu4_nbr_pu_idx = ps_proc->pu4_pic_pu_idx_map;
                WORD32 nbr_pu_idx_strd = MAX_CTB_SIZE / MIN_PU_SIZE + 2;
 pu_t *ps_pu;

 for(row = 0; row < ctb_size / MIN_PU_SIZE; row++)
 {
 for(col = 0; col < ctb_size / MIN_PU_SIZE; col++)
 {
                        pu1_pic_pu_map_ctb[row * ctb_size / MIN_PU_SIZE + col] = 0;
 }
 }


 /* Neighbor PU idx update inside CTB */
 /* 1byte per 4x4. Indicates the PU idx that 4x4 block belongs to */

                cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);
                next_ctb_idx = ps_codec->s_parse.i4_next_pu_ctb_cnt;
                num_pu_per_ctb = ps_codec->s_parse.pu4_pic_pu_idx[next_ctb_idx]
 - ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];
                ctb_start_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];
                ps_pu = &ps_codec->s_parse.ps_pic_pu[ctb_start_pu_idx];

 for(pu_cnt = 0; pu_cnt < num_pu_per_ctb; pu_cnt++, ps_pu++)
 {
                    UWORD32 cur_pu_idx;
                    WORD32 pu_ht = (ps_pu->b4_ht + 1) << 2;
                    WORD32 pu_wd = (ps_pu->b4_wd + 1) << 2;

                    cur_pu_idx = ctb_start_pu_idx + pu_cnt;

 for(row = 0; row < pu_ht / MIN_PU_SIZE; row++)
 for(col = 0; col < pu_wd / MIN_PU_SIZE; col++)
                            pu4_nbr_pu_idx[(1 + ps_pu->b4_pos_x + col)
 + (1 + ps_pu->b4_pos_y + row)
 * nbr_pu_idx_strd] =
                                            cur_pu_idx;
 }

 /* Updating Top and Left pointers */
 {
                    WORD32 rows_remaining = ps_sps->i2_pic_height_in_luma_samples
 - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);
                    WORD32 ctb_size_left = MIN(ctb_size, rows_remaining);

 /* Top Left */
 /* saving top left before updating top ptr, as updating top ptr will overwrite the top left for the next ctb */
                    ps_proc->u4_ctb_top_left_pu_idx = ps_proc->pu4_pic_pu_idx_top[(ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE) + ctb_size / MIN_PU_SIZE - 1];
 for(i = 0; i < ctb_size / MIN_PU_SIZE; i++)
 {
 /* Left */
 /* Last column of au4_nbr_pu_idx */
                        ps_proc->pu4_pic_pu_idx_left[i] = pu4_nbr_pu_idx[(ctb_size / MIN_PU_SIZE)
 + (i + 1) * nbr_pu_idx_strd];
 /* Top */
 /* Last row of au4_nbr_pu_idx */
                        ps_proc->pu4_pic_pu_idx_top[(ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE) + i] =
                                        pu4_nbr_pu_idx[(ctb_size_left / MIN_PU_SIZE) * nbr_pu_idx_strd + i + 1];

 }
 }
 }

 /*************************************************/
 /******************  BS, QP  *********************/
 /*************************************************/
 /* Check if deblock is disabled for the current slice or if it is disabled for the current picture
             * because of disable deblock api
             */
 if(0 == ps_codec->i4_disable_deblk_pic)
 {
 if((0 == ps_slice_hdr->i1_slice_disable_deblocking_filter_flag) &&
 (0 == ps_codec->i4_slice_error))
 {
                    WORD32 i4_ctb_tu_cnt;
                    WORD32 cur_ctb_idx, next_ctb_idx;
                    WORD32 cur_pu_idx;
                    WORD32 cur_tu_idx;
 process_ctxt_t *ps_proc;

                    ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];
                    cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

                    cur_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];
                    next_ctb_idx = ps_codec->s_parse.i4_next_tu_ctb_cnt;
 if(1 == ps_codec->i4_num_cores)
 {
                        i4_ctb_tu_cnt = ps_codec->s_parse.pu4_pic_tu_idx[next_ctb_idx] -
                                        ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx % RESET_TU_BUF_NCTB];

                        cur_tu_idx = ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx % RESET_TU_BUF_NCTB];
 }
 else
 {
                        i4_ctb_tu_cnt = ps_codec->s_parse.pu4_pic_tu_idx[next_ctb_idx] -
                                        ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx];

                        cur_tu_idx = ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx];
 }

                    ps_codec->s_parse.s_bs_ctxt.ps_pps = ps_codec->s_parse.ps_pps;
                    ps_codec->s_parse.s_bs_ctxt.ps_sps = ps_codec->s_parse.ps_sps;
                    ps_codec->s_parse.s_bs_ctxt.ps_codec = ps_codec;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tu_cnt = i4_ctb_tu_cnt;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_x = ps_codec->s_parse.i4_ctb_x;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_y = ps_codec->s_parse.i4_ctb_y;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tile_x = ps_codec->s_parse.i4_ctb_tile_x;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tile_y = ps_codec->s_parse.i4_ctb_tile_y;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_slice_x = ps_codec->s_parse.i4_ctb_slice_x;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_slice_y = ps_codec->s_parse.i4_ctb_slice_y;
                    ps_codec->s_parse.s_bs_ctxt.ps_tu = &ps_codec->s_parse.ps_pic_tu[cur_tu_idx];
                    ps_codec->s_parse.s_bs_ctxt.ps_pu = &ps_codec->s_parse.ps_pic_pu[cur_pu_idx];
                    ps_codec->s_parse.s_bs_ctxt.pu4_pic_pu_idx_map = ps_proc->pu4_pic_pu_idx_map;
                    ps_codec->s_parse.s_bs_ctxt.i4_next_pu_ctb_cnt = ps_codec->s_parse.i4_next_pu_ctb_cnt;
                    ps_codec->s_parse.s_bs_ctxt.i4_next_tu_ctb_cnt = ps_codec->s_parse.i4_next_tu_ctb_cnt;
                    ps_codec->s_parse.s_bs_ctxt.pu1_slice_idx = ps_codec->s_parse.pu1_slice_idx;
                    ps_codec->s_parse.s_bs_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;
                    ps_codec->s_parse.s_bs_ctxt.ps_tile = ps_codec->s_parse.ps_tile;

 if(ISLICE == ps_slice_hdr->i1_slice_type)
 {
                        ihevcd_ctb_boundary_strength_islice(&ps_codec->s_parse.s_bs_ctxt);
 }
 else
 {
                        ihevcd_ctb_boundary_strength_pbslice(&ps_codec->s_parse.s_bs_ctxt);
 }
 }
 else
 {
                    WORD32 bs_strd = (ps_sps->i2_pic_wd_in_ctb + 1) * (ctb_size * ctb_size / 8 / 16);

                    UWORD32 *pu4_vert_bs = (UWORD32 *)((UWORD8 *)ps_codec->s_parse.s_bs_ctxt.pu4_pic_vert_bs +
                                    ps_codec->s_parse.i4_ctb_x * (ctb_size * ctb_size / 8 / 16) +
                                    ps_codec->s_parse.i4_ctb_y * bs_strd);
                    UWORD32 *pu4_horz_bs = (UWORD32 *)((UWORD8 *)ps_codec->s_parse.s_bs_ctxt.pu4_pic_horz_bs +
                                    ps_codec->s_parse.i4_ctb_x * (ctb_size * ctb_size / 8 / 16) +
                                    ps_codec->s_parse.i4_ctb_y * bs_strd);

                    memset(pu4_vert_bs, 0, (ctb_size / 8 + 1) * (ctb_size / 4) / 8 * 2);
                    memset(pu4_horz_bs, 0, (ctb_size / 8) * (ctb_size / 4) / 8 * 2);

 }
 }

 }


 /* Update the parse status map */
 {
 sps_t *ps_sps = ps_codec->s_parse.ps_sps;
            UWORD8 *pu1_buf;
            WORD32 idx;
            idx = (ps_codec->s_parse.i4_ctb_x);
            idx += ((ps_codec->s_parse.i4_ctb_y) * ps_sps->i2_pic_wd_in_ctb);
            pu1_buf = (ps_codec->pu1_parse_map + idx);
 *pu1_buf = 1;
 }

 /* Increment CTB x and y positions */
        ps_codec->s_parse.i4_ctb_tile_x++;
        ps_codec->s_parse.i4_ctb_x++;
        ps_codec->s_parse.i4_ctb_slice_x++;

 /*If tiles are enabled, handle the slice counters differently*/
 if(ps_pps->i1_tiles_enabled_flag)
 {
            tile_start_ctb_idx = ps_tile->u1_pos_x
 + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);

            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x
 + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

 if((slice_start_ctb_idx < tile_start_ctb_idx))
 {
 if(ps_codec->s_parse.i4_ctb_slice_x == (ps_tile->u1_pos_x + ps_tile->u2_wd))
 {
 /* Reached end of slice row within a tile /frame */
                    ps_codec->s_parse.i4_ctb_slice_y++;
                    ps_codec->s_parse.i4_ctb_slice_x = ps_tile->u1_pos_x; //todo:Check
 }
 }
 else if(ps_codec->s_parse.i4_ctb_slice_x == (ps_tile->u2_wd))
 {
                ps_codec->s_parse.i4_ctb_slice_y++;
                ps_codec->s_parse.i4_ctb_slice_x = 0;
 }
 }
 else
 {
 if(ps_codec->s_parse.i4_ctb_slice_x == ps_tile->u2_wd)
 {
 /* Reached end of slice row within a tile /frame */
                ps_codec->s_parse.i4_ctb_slice_y++;
                ps_codec->s_parse.i4_ctb_slice_x = 0;
 }
 }


 if(ps_codec->s_parse.i4_ctb_tile_x == (ps_tile->u2_wd))
 {
 /* Reached end of tile row */
            ps_codec->s_parse.i4_ctb_tile_x = 0;
            ps_codec->s_parse.i4_ctb_x = ps_tile->u1_pos_x;

            ps_codec->s_parse.i4_ctb_tile_y++;
            ps_codec->s_parse.i4_ctb_y++;

 if(ps_codec->s_parse.i4_ctb_tile_y == (ps_tile->u2_ht))
 {
 /* Reached End of Tile */
                ps_codec->s_parse.i4_ctb_tile_y = 0;
                ps_codec->s_parse.i4_ctb_tile_x = 0;
                ps_codec->s_parse.ps_tile++;

 if((ps_tile->u2_ht + ps_tile->u1_pos_y  ==  ps_sps->i2_pic_ht_in_ctb) && (ps_tile->u2_wd + ps_tile->u1_pos_x  ==  ps_sps->i2_pic_wd_in_ctb))
 {
 /* Reached end of frame */
                    end_of_pic = 1;
                    ps_codec->s_parse.i4_ctb_x = 0;
                    ps_codec->s_parse.i4_ctb_y = ps_sps->i2_pic_ht_in_ctb;
 }
 else
 {
 /* Initialize ctb_x and ctb_y to start of next tile */
                    ps_tile = ps_codec->s_parse.ps_tile;
                    ps_codec->s_parse.i4_ctb_x = ps_tile->u1_pos_x;
                    ps_codec->s_parse.i4_ctb_y = ps_tile->u1_pos_y;
                    ps_codec->s_parse.i4_ctb_tile_y = 0;
                    ps_codec->s_parse.i4_ctb_tile_x = 0;
                    ps_codec->s_parse.i4_ctb_slice_x = ps_tile->u1_pos_x;
                    ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y;

 }
 }

 }

        ps_codec->s_parse.i4_next_ctb_indx = ps_codec->s_parse.i4_ctb_x +
                        ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb;

 /* If the current slice is in error, check if the next slice's address
         * is reached and mark the end_of_slice flag */
 if(ps_codec->i4_slice_error)
 {
 slice_header_t *ps_slice_hdr_next = ps_slice_hdr + 1;
            WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x +
                            ps_slice_hdr_next->i2_ctb_y * ps_sps->i2_pic_wd_in_ctb;

 if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr)
                end_of_slice_flag = 1;
 }

 /* If the codec is running in single core mode
         * then call process function for current CTB
         */
 if((1 == ps_codec->i4_num_cores) && (ps_codec->s_parse.i4_ctb_tile_x == 0))
 {
 process_ctxt_t *ps_proc = &ps_codec->as_process[0];
            ps_proc->i4_ctb_cnt = ps_proc->ps_tile->u2_wd;
            ihevcd_process(ps_proc);
 }

 /* If the bytes for the current slice are exhausted
         * set end_of_slice flag to 1
         * This slice will be treated as incomplete */
 if((UWORD8 *)ps_codec->s_parse.s_bitstrm.pu1_buf_max + BITSTRM_OFF_THRS <
 ((UWORD8 *)ps_codec->s_parse.s_bitstrm.pu4_buf + (ps_codec->s_parse.s_bitstrm.u4_bit_ofst / 8)))
 {

 if(0 == ps_codec->i4_slice_error)
                end_of_slice_flag = 1;
 }


 if(end_of_pic)
 break;
 } while(!end_of_slice_flag);

 /* Reset slice error */
    ps_codec->i4_slice_error = 0;

 /* Increment the slice index for parsing next slice */
 if(0 == end_of_pic)
 {
 while(1)
 {

            WORD32 parse_slice_idx;
            parse_slice_idx = ps_codec->s_parse.i4_cur_slice_idx;
            parse_slice_idx++;

 {
 /* If the next slice header is not initialized, update cur_slice_idx and break */
 if((1 == ps_codec->i4_num_cores) || (0 != (parse_slice_idx & (MAX_SLICE_HDR_CNT - 1))))
 {
                    ps_codec->s_parse.i4_cur_slice_idx = parse_slice_idx;
 break;
 }

 /* If the next slice header is initialised, wait for the parsed slices to be processed */
 else
 {
                    WORD32 ctb_indx = 0;

 while(ctb_indx != ps_sps->i4_pic_size_in_ctb)
 {
                        WORD32 parse_status = *(ps_codec->pu1_parse_map + ctb_indx);
 volatile WORD32 proc_status = *(ps_codec->pu1_proc_map + ctb_indx) & 1;

 if(parse_status == proc_status)
                            ctb_indx++;
 }
                    ps_codec->s_parse.i4_cur_slice_idx = parse_slice_idx;
 break;
 }

 }
 }

 }
 else
 {
#if FRAME_ILF_PAD
 if(FRAME_ILF_PAD && 1 == ps_codec->i4_num_cores)
 {
 if(ps_slice_hdr->i4_abs_pic_order_cnt == 0)
 {
                DUMP_PRE_ILF(ps_codec->as_process[0].pu1_cur_pic_luma,
                             ps_codec->as_process[0].pu1_cur_pic_chroma,
                             ps_sps->i2_pic_width_in_luma_samples,
                             ps_sps->i2_pic_height_in_luma_samples,
                             ps_codec->i4_strd);

                DUMP_BS(ps_codec->as_process[0].s_bs_ctxt.pu4_pic_vert_bs,
                        ps_codec->as_process[0].s_bs_ctxt.pu4_pic_horz_bs,
                        ps_sps->i2_pic_wd_in_ctb * (ctb_size * ctb_size / 8 / 16) * ps_sps->i2_pic_ht_in_ctb,
 (ps_sps->i2_pic_wd_in_ctb + 1) * (ctb_size * ctb_size / 8 / 16) * ps_sps->i2_pic_ht_in_ctb);

                DUMP_QP(ps_codec->as_process[0].s_bs_ctxt.pu1_pic_qp,
 (ps_sps->i2_pic_height_in_luma_samples * ps_sps->i2_pic_width_in_luma_samples) / (MIN_CU_SIZE * MIN_CU_SIZE));

                DUMP_QP_CONST_IN_CTB(ps_codec->as_process[0].s_bs_ctxt.pu1_pic_qp_const_in_ctb,
 (ps_sps->i2_pic_height_in_luma_samples * ps_sps->i2_pic_width_in_luma_samples) / (MIN_CTB_SIZE * MIN_CTB_SIZE) / 8);

                DUMP_NO_LOOP_FILTER(ps_codec->as_process[0].pu1_pic_no_loop_filter_flag,
 (ps_sps->i2_pic_width_in_luma_samples / MIN_CU_SIZE) * (ps_sps->i2_pic_height_in_luma_samples / MIN_CU_SIZE) / 8);

                DUMP_OFFSETS(ps_slice_hdr->i1_beta_offset_div2,
                             ps_slice_hdr->i1_tc_offset_div2,
                             ps_pps->i1_pic_cb_qp_offset,
                             ps_pps->i1_pic_cr_qp_offset);
 }
            ps_codec->s_parse.s_deblk_ctxt.ps_pps = ps_codec->s_parse.ps_pps;
            ps_codec->s_parse.s_deblk_ctxt.ps_sps = ps_codec->s_parse.ps_sps;
            ps_codec->s_parse.s_deblk_ctxt.ps_codec = ps_codec;
            ps_codec->s_parse.s_deblk_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;
            ps_codec->s_parse.s_deblk_ctxt.is_chroma_yuv420sp_vu = (ps_codec->e_ref_chroma_fmt == IV_YUV_420SP_VU);

            ps_codec->s_parse.s_sao_ctxt.ps_pps = ps_codec->s_parse.ps_pps;
            ps_codec->s_parse.s_sao_ctxt.ps_sps = ps_codec->s_parse.ps_sps;
            ps_codec->s_parse.s_sao_ctxt.ps_codec = ps_codec;
            ps_codec->s_parse.s_sao_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;

            ihevcd_ilf_pad_frame(&ps_codec->s_parse.s_deblk_ctxt, &ps_codec->s_parse.s_sao_ctxt);

 }
#endif
        ps_codec->s_parse.i4_end_of_frame = 1;
 }
 return ret;
}
","IHEVCD_ERROR_T ihevcd_parse_slice_data(codec_t *ps_codec)
{

    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
    WORD32 end_of_slice_flag = 0;
 sps_t *ps_sps;
 pps_t *ps_pps;
 slice_header_t *ps_slice_hdr;
    WORD32 end_of_pic;
 tile_t *ps_tile, *ps_tile_prev;
    WORD32 i;
    WORD32 ctb_addr;
    WORD32 tile_idx;
    WORD32 cabac_init_idc;
    WORD32 ctb_size;
    WORD32 num_ctb_in_row;
    WORD32 num_min4x4_in_ctb;
    WORD32 slice_qp;
    WORD32 slice_start_ctb_idx;
    WORD32 tile_start_ctb_idx;


    ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base;
    ps_pps = ps_codec->s_parse.ps_pps_base;
    ps_sps = ps_codec->s_parse.ps_sps_base;

 /* Get current slice header, pps and sps */
    ps_slice_hdr += (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));
    ps_pps  += ps_slice_hdr->i1_pps_id;
    ps_sps  += ps_pps->i1_sps_id;

 if(0 != ps_codec->s_parse.i4_cur_slice_idx)
 {
 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
            ps_codec->s_parse.i4_cur_independent_slice_idx++;
 if(MAX_SLICE_HDR_CNT == ps_codec->s_parse.i4_cur_independent_slice_idx)
                ps_codec->s_parse.i4_cur_independent_slice_idx = 0;
 }
 }


    ctb_size = 1 << ps_sps->i1_log2_ctb_size;
    num_min4x4_in_ctb = (ctb_size / 4) * (ctb_size / 4);
    num_ctb_in_row = ps_sps->i2_pic_wd_in_ctb;

 /* Update the parse context */
 if(0 == ps_codec->i4_slice_error)
 {
        ps_codec->s_parse.i4_ctb_x = ps_slice_hdr->i2_ctb_x;
        ps_codec->s_parse.i4_ctb_y = ps_slice_hdr->i2_ctb_y;
 }
    ps_codec->s_parse.ps_pps = ps_pps;
    ps_codec->s_parse.ps_sps = ps_sps;
    ps_codec->s_parse.ps_slice_hdr = ps_slice_hdr;

 /* Derive Tile positions for the current CTB */
 /* Change this to lookup if required */
    ihevcd_get_tile_pos(ps_pps, ps_sps, ps_codec->s_parse.i4_ctb_x,
                        ps_codec->s_parse.i4_ctb_y,
 &ps_codec->s_parse.i4_ctb_tile_x,
 &ps_codec->s_parse.i4_ctb_tile_y,
 &tile_idx);
    ps_codec->s_parse.ps_tile = ps_pps->ps_tile + tile_idx;
    ps_codec->s_parse.i4_cur_tile_idx = tile_idx;
    ps_tile = ps_codec->s_parse.ps_tile;
 if(tile_idx)
        ps_tile_prev = ps_tile - 1;
 else
        ps_tile_prev = ps_tile;

 /* If the present slice is dependent, then store the previous
     * independent slices' ctb x and y values for decoding process */
 if(0 == ps_codec->i4_slice_error)
 {
 if(1 == ps_slice_hdr->i1_dependent_slice_flag)
 {
 /*If slice is present at the start of a new tile*/
 if((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                ps_codec->s_parse.i4_ctb_slice_x = 0;
                ps_codec->s_parse.i4_ctb_slice_y = 0;
 }
 }

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
            ps_codec->s_parse.i4_ctb_slice_x = 0;
            ps_codec->s_parse.i4_ctb_slice_y = 0;
 }
 }

 /* Frame level initializations */
 if((0 == ps_codec->s_parse.i4_ctb_y) &&
 (0 == ps_codec->s_parse.i4_ctb_x))
 {
        ret = ihevcd_parse_pic_init(ps_codec);
        RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret);

        ps_codec->s_parse.pu4_pic_tu_idx[0] = 0;
        ps_codec->s_parse.pu4_pic_pu_idx[0] = 0;
        ps_codec->s_parse.i4_cur_independent_slice_idx = 0;
        ps_codec->s_parse.i4_ctb_tile_x = 0;
        ps_codec->s_parse.i4_ctb_tile_y = 0;
 }

 {
 /* Updating the poc list of current slice to ps_mv_buf */
 mv_buf_t *ps_mv_buf = ps_codec->s_parse.ps_cur_mv_buf;

 if(ps_slice_hdr->i1_num_ref_idx_l1_active != 0)
 {
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l1_active; i++)
 {
                ps_mv_buf->l1_collocated_poc[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_pic_buf)->i4_abs_poc;
                ps_mv_buf->u1_l1_collocated_poc_lt[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_pic_buf)->u1_used_as_ref;
 }
 }

 if(ps_slice_hdr->i1_num_ref_idx_l0_active != 0)
 {
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l0_active; i++)
 {
                ps_mv_buf->l0_collocated_poc[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_pic_buf)->i4_abs_poc;
                ps_mv_buf->u1_l0_collocated_poc_lt[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_pic_buf)->u1_used_as_ref;
 }
 }
 }

 /*Initialize the low delay flag at the beginning of every slice*/
 if((0 == ps_codec->s_parse.i4_ctb_slice_x) || (0 == ps_codec->s_parse.i4_ctb_slice_y))
 {
 /* Lowdelay flag */
        WORD32 cur_poc, ref_list_poc, flag = 1;
        cur_poc = ps_slice_hdr->i4_abs_pic_order_cnt;
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l0_active; i++)
 {
            ref_list_poc = ((mv_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_mv_buf)->i4_abs_poc;
 if(ref_list_poc > cur_poc)
 {
                flag = 0;
 break;
 }
 }
 if(flag && (ps_slice_hdr->i1_slice_type == BSLICE))
 {
 for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l1_active; i++)
 {
                ref_list_poc = ((mv_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_mv_buf)->i4_abs_poc;
 if(ref_list_poc > cur_poc)
 {
                    flag = 0;
 break;
 }
 }
 }
        ps_slice_hdr->i1_low_delay_flag = flag;
 }

 /* initialize the cabac init idc based on slice type */
 if(ps_slice_hdr->i1_slice_type == ISLICE)
 {
        cabac_init_idc = 0;
 }
 else if(ps_slice_hdr->i1_slice_type == PSLICE)
 {
        cabac_init_idc = ps_slice_hdr->i1_cabac_init_flag ? 2 : 1;
 }
 else
 {
        cabac_init_idc = ps_slice_hdr->i1_cabac_init_flag ? 1 : 2;
 }

    slice_qp = ps_slice_hdr->i1_slice_qp_delta + ps_pps->i1_pic_init_qp;
    slice_qp = CLIP3(slice_qp, 0, 51);

 /*Update QP value for every indepndent slice or for every dependent slice that begins at the start of a new tile*/
 if((0 == ps_slice_hdr->i1_dependent_slice_flag) ||
 ((1 == ps_slice_hdr->i1_dependent_slice_flag) && ((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))))
 {
        ps_codec->s_parse.u4_qp = slice_qp;
 }

 /*Cabac init at the beginning of a slice*/
 if((1 == ps_slice_hdr->i1_dependent_slice_flag) && (!((ps_codec->s_parse.i4_ctb_tile_x == 0) && (ps_codec->s_parse.i4_ctb_tile_y == 0))))
 {
 if((0 == ps_pps->i1_entropy_coding_sync_enabled_flag) || (ps_pps->i1_entropy_coding_sync_enabled_flag && (0 != ps_codec->s_parse.i4_ctb_x)))
 {
            ihevcd_cabac_reset(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm);
 }
 }
 else if((0 == ps_pps->i1_entropy_coding_sync_enabled_flag) || (ps_pps->i1_entropy_coding_sync_enabled_flag && (0 != ps_codec->s_parse.i4_ctb_x)))
 {
        ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                slice_qp,
                                cabac_init_idc,
 &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);
 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
            ps_codec->i4_slice_error = 1;
            end_of_slice_flag = 1;
            ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }
 }


 do
 {

 {
            WORD32 cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);
 if(1 == ps_codec->i4_num_cores && 0 == cur_ctb_idx % RESET_TU_BUF_NCTB)
 {
                ps_codec->s_parse.ps_tu = ps_codec->s_parse.ps_pic_tu;
                ps_codec->s_parse.i4_pic_tu_idx = 0;
 }
 }

        end_of_pic = 0;
 /* Section:7.3.7 Coding tree unit syntax */
 /* coding_tree_unit() inlined here */
 /* If number of cores is greater than 1, then add job to the queue */
 /* At the start of ctb row parsing in a tile, queue a job for processing the current tile row */
        ps_codec->s_parse.i4_ctb_num_pcm_blks = 0;


 /*At the beginning of each tile-which is not the beginning of a slice, cabac context must be initialized.
         * Hence, check for the tile beginning here */
 if(((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))
 && (!((ps_tile->u1_pos_x == 0) && (ps_tile->u1_pos_y == 0)))
 && (!((0 == ps_codec->s_parse.i4_ctb_slice_x) && (0 == ps_codec->s_parse.i4_ctb_slice_y))))
 {
            slice_qp = ps_slice_hdr->i1_slice_qp_delta + ps_pps->i1_pic_init_qp;
            slice_qp = CLIP3(slice_qp, 0, 51);
            ps_codec->s_parse.u4_qp = slice_qp;

            ihevcd_get_tile_pos(ps_pps, ps_sps, ps_codec->s_parse.i4_ctb_x,
                                ps_codec->s_parse.i4_ctb_y,
 &ps_codec->s_parse.i4_ctb_tile_x,
 &ps_codec->s_parse.i4_ctb_tile_y,
 &tile_idx);

            ps_codec->s_parse.ps_tile = ps_pps->ps_tile + tile_idx;
            ps_codec->s_parse.i4_cur_tile_idx = tile_idx;
            ps_tile_prev = ps_tile - 1;

            tile_start_ctb_idx = ps_tile->u1_pos_x
 + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);

            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x
 + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

 /*For slices that span across multiple tiles*/
 if(slice_start_ctb_idx < tile_start_ctb_idx)
 { /* 2 Cases
             * 1 - slice spans across frame-width- but does not start from 1st column
             * 2 - Slice spans across multiple tiles anywhere is a frame
             */
                ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y - ps_slice_hdr->i2_ctb_y;
 if(!(((ps_slice_hdr->i2_ctb_x + ps_tile_prev->u2_wd) % ps_sps->i2_pic_wd_in_ctb) == ps_tile->u1_pos_x)) //Case 2
 {
 if(ps_slice_hdr->i2_ctb_y <= ps_tile->u1_pos_y)
 {
 if(ps_slice_hdr->i2_ctb_x > ps_tile->u1_pos_x)
 {
                            ps_codec->s_parse.i4_ctb_slice_y -= 1;
 }
 }
 }
 /*ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y - ps_slice_hdr->i2_ctb_y;
                if (ps_slice_hdr->i2_ctb_y <= ps_tile->u1_pos_y)
                {
                    if (ps_slice_hdr->i2_ctb_x > ps_tile->u1_pos_x )
                    {
                        ps_codec->s_parse.i4_ctb_slice_y -= 1 ;
                    }
                }*/
 }

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
                ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                        slice_qp,
                                        cabac_init_idc,
 &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);
 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
                    ps_codec->i4_slice_error = 1;
                    end_of_slice_flag = 1;
                    ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }

 }
 }
 /* If number of cores is greater than 1, then add job to the queue */
 /* At the start of ctb row parsing in a tile, queue a job for processing the current tile row */

 if(0 == ps_codec->s_parse.i4_ctb_tile_x)
 {

 if(1 < ps_codec->i4_num_cores)
 {
 proc_job_t s_job;
                IHEVCD_ERROR_T ret;
                s_job.i4_cmd    = CMD_PROCESS;
                s_job.i2_ctb_cnt = (WORD16)ps_tile->u2_wd;
                s_job.i2_ctb_x = (WORD16)ps_codec->s_parse.i4_ctb_x;
                s_job.i2_ctb_y = (WORD16)ps_codec->s_parse.i4_ctb_y;
                s_job.i2_slice_idx = (WORD16)ps_codec->s_parse.i4_cur_slice_idx;
                s_job.i4_tu_coeff_data_ofst = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data -
 (UWORD8 *)ps_codec->s_parse.pv_pic_tu_coeff_data;
                ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq, &s_job, sizeof(proc_job_t), 1);

 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 return ret;
 }
 else
 {
 process_ctxt_t *ps_proc = &ps_codec->as_process[0];
                WORD32 tu_coeff_data_ofst = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data -
 (UWORD8 *)ps_codec->s_parse.pv_pic_tu_coeff_data;

 /* If the codec is running in single core mode,
                 * initialize zeroth process context
                 * TODO: Dual core mode might need a different implementation instead of jobq
                 */

                ps_proc->i4_ctb_cnt = ps_tile->u2_wd;
                ps_proc->i4_ctb_x   = ps_codec->s_parse.i4_ctb_x;
                ps_proc->i4_ctb_y   = ps_codec->s_parse.i4_ctb_y;
                ps_proc->i4_cur_slice_idx = ps_codec->s_parse.i4_cur_slice_idx;

                ihevcd_init_proc_ctxt(ps_proc, tu_coeff_data_ofst);
 }
 }


 /* Restore cabac context model from top right CTB if entropy sync is enabled */
 if(ps_pps->i1_entropy_coding_sync_enabled_flag)
 {
 /*TODO Handle single CTB and top-right belonging to a different slice */
 if(0 == ps_codec->s_parse.i4_ctb_x)
 {
                WORD32 default_ctxt = 0;

 if((0 == ps_codec->s_parse.i4_ctb_slice_y) && (!ps_slice_hdr->i1_dependent_slice_flag))
                    default_ctxt = 1;
 if(1 == ps_sps->i2_pic_wd_in_ctb)
                    default_ctxt = 1;

                ps_codec->s_parse.u4_qp = slice_qp;
 if(default_ctxt)
 {
                    ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                            slice_qp,
                                            cabac_init_idc,
 &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);

 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
                        ps_codec->i4_slice_error = 1;
                        end_of_slice_flag = 1;
                        ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }
 }
 else
 {
                    ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,
 &ps_codec->s_parse.s_bitstrm,
                                            slice_qp,
                                            cabac_init_idc,
 (const UWORD8 *)&ps_codec->s_parse.s_cabac.au1_ctxt_models_sync);

 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 {
                        ps_codec->i4_slice_error = 1;
                        end_of_slice_flag = 1;
                        ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }
 }
 }
 }



 if(0 == ps_codec->i4_slice_error)
 {
 if(ps_slice_hdr->i1_slice_sao_luma_flag || ps_slice_hdr->i1_slice_sao_chroma_flag)
                ihevcd_parse_sao(ps_codec);
 }
 else
 {
 sao_t *ps_sao = ps_codec->s_parse.ps_pic_sao +
                            ps_codec->s_parse.i4_ctb_x +
                            ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb;

 /* Default values */
            ps_sao->b3_y_type_idx = 0;
            ps_sao->b3_cb_type_idx = 0;
            ps_sao->b3_cr_type_idx = 0;
 }


 {
            WORD32 ctb_indx;
            ctb_indx = ps_codec->s_parse.i4_ctb_x + ps_sps->i2_pic_wd_in_ctb * ps_codec->s_parse.i4_ctb_y;
            ps_codec->s_parse.s_bs_ctxt.pu1_pic_qp_const_in_ctb[ctb_indx >> 3] |= (1 << (ctb_indx & 7));
 {
                UWORD16 *pu1_slice_idx = ps_codec->s_parse.pu1_slice_idx;
                pu1_slice_idx[ctb_indx] = ps_codec->s_parse.i4_cur_independent_slice_idx;
 }
 }

 if(0 == ps_codec->i4_slice_error)
 {
 tu_t *ps_tu = ps_codec->s_parse.ps_tu;
            WORD32 i4_tu_cnt = ps_codec->s_parse.s_cu.i4_tu_cnt;
            WORD32 i4_pic_tu_idx = ps_codec->s_parse.i4_pic_tu_idx;

 pu_t *ps_pu = ps_codec->s_parse.ps_pu;
            WORD32 i4_pic_pu_idx = ps_codec->s_parse.i4_pic_pu_idx;

            UWORD8 *pu1_tu_coeff_data = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data;

            ret = ihevcd_parse_coding_quadtree(ps_codec,
 (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size),
 (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size),
                                               ps_sps->i1_log2_ctb_size,
 0);
 /* Check for error */

             if (ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
             {
                 /* Reset tu and pu parameters, and signal current ctb as skip */
                 WORD32 tu_coeff_data_reset_size;
 
                 ps_codec->s_parse.ps_tu = ps_tu;
                 ps_codec->s_parse.s_cu.i4_tu_cnt = i4_tu_cnt;
                 ps_codec->s_parse.i4_pic_tu_idx = i4_pic_tu_idx;


                 ps_codec->s_parse.ps_pu = ps_pu;
                 ps_codec->s_parse.i4_pic_pu_idx = i4_pic_pu_idx;
 
                 tu_coeff_data_reset_size = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data - pu1_tu_coeff_data;
                 memset(pu1_tu_coeff_data, 0, tu_coeff_data_reset_size);
                 ps_codec->s_parse.pv_tu_coeff_data = (void *)pu1_tu_coeff_data;
 
                ihevcd_set_ctb_skip(ps_codec);
 
                 /* Set slice error to suppress further parsing and
                  * signal end of slice.
                 */
                ps_codec->i4_slice_error = 1;
                end_of_slice_flag = 1;
                ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
 }

         }
         else
         {
            ihevcd_set_ctb_skip(ps_codec);
         }
 
         if(0 == ps_codec->i4_slice_error)
            end_of_slice_flag = ihevcd_cabac_decode_terminate(&ps_codec->s_parse.s_cabac, &ps_codec->s_parse.s_bitstrm);

        AEV_TRACE(""end_of_slice_flag"", end_of_slice_flag, ps_codec->s_parse.s_cabac.u4_range);


 /* In case of tiles or entropy sync, terminate cabac and copy cabac context backed up at the end of top-right CTB */
 if(ps_pps->i1_tiles_enabled_flag || ps_pps->i1_entropy_coding_sync_enabled_flag)
 {
            WORD32 end_of_tile = 0;
            WORD32 end_of_tile_row = 0;

 /* Take a back up of cabac context models if entropy sync is enabled */
 if(ps_pps->i1_entropy_coding_sync_enabled_flag || ps_pps->i1_tiles_enabled_flag)
 {
 if(1 == ps_codec->s_parse.i4_ctb_x)
 {
                    WORD32 size = sizeof(ps_codec->s_parse.s_cabac.au1_ctxt_models);
                    memcpy(&ps_codec->s_parse.s_cabac.au1_ctxt_models_sync, &ps_codec->s_parse.s_cabac.au1_ctxt_models, size);
 }
 }

 /* Since tiles and entropy sync are not enabled simultaneously, the following will not result in any problems */
 if((ps_codec->s_parse.i4_ctb_tile_x + 1) == (ps_tile->u2_wd))
 {
                end_of_tile_row = 1;
 if((ps_codec->s_parse.i4_ctb_tile_y + 1) == ps_tile->u2_ht)
                    end_of_tile = 1;
 }
 if((0 == end_of_slice_flag) &&
 ((ps_pps->i1_tiles_enabled_flag && end_of_tile) ||
 (ps_pps->i1_entropy_coding_sync_enabled_flag && end_of_tile_row)))
 {
                WORD32 end_of_sub_stream_one_bit;
                end_of_sub_stream_one_bit = ihevcd_cabac_decode_terminate(&ps_codec->s_parse.s_cabac, &ps_codec->s_parse.s_bitstrm);
                AEV_TRACE(""end_of_sub_stream_one_bit"", end_of_sub_stream_one_bit, ps_codec->s_parse.s_cabac.u4_range);

 /* TODO: Remove the check for offset when HM is updated to include a byte unconditionally even for aligned location */
 /* For Ittiam streams this check should not be there, for HM9.1 streams this should be there */
 if(ps_codec->s_parse.s_bitstrm.u4_bit_ofst % 8)
                    ihevcd_bits_flush_to_byte_boundary(&ps_codec->s_parse.s_bitstrm);

                UNUSED(end_of_sub_stream_one_bit);
 }
 }
 {
            WORD32 ctb_indx;

            ctb_addr = ps_codec->s_parse.i4_ctb_y * num_ctb_in_row + ps_codec->s_parse.i4_ctb_x;

            ctb_indx = ++ctb_addr;

 /* Store pu_idx for next CTB in frame level pu_idx array */

 if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))
 {
                ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.
 if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))
 {
 if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))
 {
                        ctb_indx = ctb_addr; //Next continuous ctb address
 }
 else //Not last tile's end , but a tile end
 {
 tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;
                        ctb_indx = ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.
 }
 }
 }

            ps_codec->s_parse.pu4_pic_pu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_pu_idx;
            ps_codec->s_parse.i4_next_pu_ctb_cnt = ctb_indx;

            ps_codec->s_parse.pu1_pu_map += num_min4x4_in_ctb;

 /* Store tu_idx for next CTB in frame level tu_idx array */
 if(1 == ps_codec->i4_num_cores)
 {
                ctb_indx = (0 == ctb_addr % RESET_TU_BUF_NCTB) ?
                                RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB;

 if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))
 {
                    ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.
 if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))
 {
 if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))
 {
                            ctb_indx = (0 == ctb_addr % RESET_TU_BUF_NCTB) ?
                                            RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB;
 }
 else //Not last tile's end , but a tile end
 {
 tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;
                            ctb_indx =  ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.
 }
 }
 }
                ps_codec->s_parse.i4_next_tu_ctb_cnt = ctb_indx;
                ps_codec->s_parse.pu4_pic_tu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_tu_idx;
 }
 else
 {
                ctb_indx = ctb_addr;
 if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))
 {
                    ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.
 if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))
 {
 if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))
 {
                            ctb_indx = ctb_addr;
 }
 else //Not last tile's end , but a tile end
 {
 tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;
                            ctb_indx =  ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.
 }
 }
 }
                ps_codec->s_parse.i4_next_tu_ctb_cnt = ctb_indx;
                ps_codec->s_parse.pu4_pic_tu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_tu_idx;
 }
            ps_codec->s_parse.pu1_tu_map += num_min4x4_in_ctb;
 }


 if(ps_codec->i4_num_cores <= MV_PRED_NUM_CORES_THRESHOLD)
 {
 /*************************************************/
 /****************   MV pred **********************/
 /*************************************************/
            WORD8 u1_top_ctb_avail = 1;
            WORD8 u1_left_ctb_avail = 1;
            WORD8 u1_top_lt_ctb_avail = 1;
            WORD8 u1_top_rt_ctb_avail = 1;
            WORD16 i2_wd_in_ctb;

            tile_start_ctb_idx = ps_tile->u1_pos_x
 + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);

            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x
 + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

 if((slice_start_ctb_idx < tile_start_ctb_idx))
 {
                i2_wd_in_ctb = ps_sps->i2_pic_wd_in_ctb;
 }
 else
 {
                i2_wd_in_ctb = ps_tile->u2_wd;
 }
 /* slice and tile boundaries */
 if((0 == ps_codec->s_parse.i4_ctb_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                u1_top_ctb_avail = 0;
                u1_top_lt_ctb_avail = 0;
                u1_top_rt_ctb_avail = 0;
 }

 if((0 == ps_codec->s_parse.i4_ctb_x) || (0 == ps_codec->s_parse.i4_ctb_tile_x))
 {
                u1_left_ctb_avail = 0;
                u1_top_lt_ctb_avail = 0;
 if((0 == ps_codec->s_parse.i4_ctb_slice_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                    u1_top_ctb_avail = 0;
 if((i2_wd_in_ctb - 1) != ps_codec->s_parse.i4_ctb_slice_x) //TODO: For tile, not implemented
 {
                        u1_top_rt_ctb_avail = 0;
 }
 }
 }
 /*For slices not beginning at start of a ctb row*/
 else if(ps_codec->s_parse.i4_ctb_x > 0)
 {
 if((0 == ps_codec->s_parse.i4_ctb_slice_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))
 {
                    u1_top_ctb_avail = 0;
                    u1_top_lt_ctb_avail = 0;
 if(0 == ps_codec->s_parse.i4_ctb_slice_x)
 {
                        u1_left_ctb_avail = 0;
 }
 if((i2_wd_in_ctb - 1) != ps_codec->s_parse.i4_ctb_slice_x)
 {
                        u1_top_rt_ctb_avail = 0;
 }
 }
 else if((1 == ps_codec->s_parse.i4_ctb_slice_y) && (0 == ps_codec->s_parse.i4_ctb_slice_x))
 {
                    u1_top_lt_ctb_avail = 0;
 }
 }

 if(((ps_sps->i2_pic_wd_in_ctb - 1) == ps_codec->s_parse.i4_ctb_x) || ((ps_tile->u2_wd - 1) == ps_codec->s_parse.i4_ctb_tile_x))
 {
                u1_top_rt_ctb_avail = 0;
 }

 if(PSLICE == ps_slice_hdr->i1_slice_type
 || BSLICE == ps_slice_hdr->i1_slice_type)
 {
 mv_ctxt_t s_mv_ctxt;
 process_ctxt_t *ps_proc;
                UWORD32 *pu4_ctb_top_pu_idx;
                UWORD32 *pu4_ctb_left_pu_idx;
                UWORD32 *pu4_ctb_top_left_pu_idx;
                WORD32 i4_ctb_pu_cnt;
                WORD32 cur_ctb_idx;
                WORD32 next_ctb_idx;
                WORD32 cur_pu_idx;
                ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];
                cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);
                next_ctb_idx = ps_codec->s_parse.i4_next_pu_ctb_cnt;
                i4_ctb_pu_cnt = ps_codec->s_parse.pu4_pic_pu_idx[next_ctb_idx]
 - ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];

                cur_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];

                pu4_ctb_top_pu_idx = ps_proc->pu4_pic_pu_idx_top
 + (ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE);
                pu4_ctb_left_pu_idx = ps_proc->pu4_pic_pu_idx_left;
                pu4_ctb_top_left_pu_idx = &ps_proc->u4_ctb_top_left_pu_idx;

 /* Initializing s_mv_ctxt */
 {
                    s_mv_ctxt.ps_pps = ps_pps;
                    s_mv_ctxt.ps_sps = ps_sps;
                    s_mv_ctxt.ps_slice_hdr = ps_slice_hdr;
                    s_mv_ctxt.i4_ctb_x = ps_codec->s_parse.i4_ctb_x;
                    s_mv_ctxt.i4_ctb_y = ps_codec->s_parse.i4_ctb_y;
                    s_mv_ctxt.ps_pu = &ps_codec->s_parse.ps_pic_pu[cur_pu_idx];
                    s_mv_ctxt.ps_pic_pu = ps_codec->s_parse.ps_pic_pu;
                    s_mv_ctxt.ps_tile = ps_tile;
                    s_mv_ctxt.pu4_pic_pu_idx_map = ps_proc->pu4_pic_pu_idx_map;
                    s_mv_ctxt.pu4_pic_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx;
                    s_mv_ctxt.pu1_pic_pu_map = ps_codec->s_parse.pu1_pic_pu_map;
                    s_mv_ctxt.i4_ctb_pu_cnt = i4_ctb_pu_cnt;
                    s_mv_ctxt.i4_ctb_start_pu_idx = cur_pu_idx;
                    s_mv_ctxt.u1_top_ctb_avail = u1_top_ctb_avail;
                    s_mv_ctxt.u1_top_rt_ctb_avail = u1_top_rt_ctb_avail;
                    s_mv_ctxt.u1_top_lt_ctb_avail = u1_top_lt_ctb_avail;
                    s_mv_ctxt.u1_left_ctb_avail = u1_left_ctb_avail;
 }

                ihevcd_get_mv_ctb(&s_mv_ctxt, pu4_ctb_top_pu_idx,
                                  pu4_ctb_left_pu_idx, pu4_ctb_top_left_pu_idx);

 }
 else
 {
                WORD32 num_minpu_in_ctb = (ctb_size / MIN_PU_SIZE) * (ctb_size / MIN_PU_SIZE);
                UWORD8 *pu1_pic_pu_map_ctb = ps_codec->s_parse.pu1_pic_pu_map +
 (ps_codec->s_parse.i4_ctb_x + ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb) * num_minpu_in_ctb;
 process_ctxt_t *ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];
                WORD32 row, col;
                WORD32 pu_cnt;
                WORD32 num_pu_per_ctb;
                WORD32 cur_ctb_idx;
                WORD32 next_ctb_idx;
                WORD32 ctb_start_pu_idx;
                UWORD32 *pu4_nbr_pu_idx = ps_proc->pu4_pic_pu_idx_map;
                WORD32 nbr_pu_idx_strd = MAX_CTB_SIZE / MIN_PU_SIZE + 2;
 pu_t *ps_pu;

 for(row = 0; row < ctb_size / MIN_PU_SIZE; row++)
 {
 for(col = 0; col < ctb_size / MIN_PU_SIZE; col++)
 {
                        pu1_pic_pu_map_ctb[row * ctb_size / MIN_PU_SIZE + col] = 0;
 }
 }


 /* Neighbor PU idx update inside CTB */
 /* 1byte per 4x4. Indicates the PU idx that 4x4 block belongs to */

                cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);
                next_ctb_idx = ps_codec->s_parse.i4_next_pu_ctb_cnt;
                num_pu_per_ctb = ps_codec->s_parse.pu4_pic_pu_idx[next_ctb_idx]
 - ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];
                ctb_start_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];
                ps_pu = &ps_codec->s_parse.ps_pic_pu[ctb_start_pu_idx];

 for(pu_cnt = 0; pu_cnt < num_pu_per_ctb; pu_cnt++, ps_pu++)
 {
                    UWORD32 cur_pu_idx;
                    WORD32 pu_ht = (ps_pu->b4_ht + 1) << 2;
                    WORD32 pu_wd = (ps_pu->b4_wd + 1) << 2;

                    cur_pu_idx = ctb_start_pu_idx + pu_cnt;

 for(row = 0; row < pu_ht / MIN_PU_SIZE; row++)
 for(col = 0; col < pu_wd / MIN_PU_SIZE; col++)
                            pu4_nbr_pu_idx[(1 + ps_pu->b4_pos_x + col)
 + (1 + ps_pu->b4_pos_y + row)
 * nbr_pu_idx_strd] =
                                            cur_pu_idx;
 }

 /* Updating Top and Left pointers */
 {
                    WORD32 rows_remaining = ps_sps->i2_pic_height_in_luma_samples
 - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);
                    WORD32 ctb_size_left = MIN(ctb_size, rows_remaining);

 /* Top Left */
 /* saving top left before updating top ptr, as updating top ptr will overwrite the top left for the next ctb */
                    ps_proc->u4_ctb_top_left_pu_idx = ps_proc->pu4_pic_pu_idx_top[(ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE) + ctb_size / MIN_PU_SIZE - 1];
 for(i = 0; i < ctb_size / MIN_PU_SIZE; i++)
 {
 /* Left */
 /* Last column of au4_nbr_pu_idx */
                        ps_proc->pu4_pic_pu_idx_left[i] = pu4_nbr_pu_idx[(ctb_size / MIN_PU_SIZE)
 + (i + 1) * nbr_pu_idx_strd];
 /* Top */
 /* Last row of au4_nbr_pu_idx */
                        ps_proc->pu4_pic_pu_idx_top[(ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE) + i] =
                                        pu4_nbr_pu_idx[(ctb_size_left / MIN_PU_SIZE) * nbr_pu_idx_strd + i + 1];

 }
 }
 }

 /*************************************************/
 /******************  BS, QP  *********************/
 /*************************************************/
 /* Check if deblock is disabled for the current slice or if it is disabled for the current picture
             * because of disable deblock api
             */
 if(0 == ps_codec->i4_disable_deblk_pic)
 {
 if((0 == ps_slice_hdr->i1_slice_disable_deblocking_filter_flag) &&
 (0 == ps_codec->i4_slice_error))
 {
                    WORD32 i4_ctb_tu_cnt;
                    WORD32 cur_ctb_idx, next_ctb_idx;
                    WORD32 cur_pu_idx;
                    WORD32 cur_tu_idx;
 process_ctxt_t *ps_proc;

                    ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];
                    cur_ctb_idx = ps_codec->s_parse.i4_ctb_x
 + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

                    cur_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];
                    next_ctb_idx = ps_codec->s_parse.i4_next_tu_ctb_cnt;
 if(1 == ps_codec->i4_num_cores)
 {
                        i4_ctb_tu_cnt = ps_codec->s_parse.pu4_pic_tu_idx[next_ctb_idx] -
                                        ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx % RESET_TU_BUF_NCTB];

                        cur_tu_idx = ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx % RESET_TU_BUF_NCTB];
 }
 else
 {
                        i4_ctb_tu_cnt = ps_codec->s_parse.pu4_pic_tu_idx[next_ctb_idx] -
                                        ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx];

                        cur_tu_idx = ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx];
 }

                    ps_codec->s_parse.s_bs_ctxt.ps_pps = ps_codec->s_parse.ps_pps;
                    ps_codec->s_parse.s_bs_ctxt.ps_sps = ps_codec->s_parse.ps_sps;
                    ps_codec->s_parse.s_bs_ctxt.ps_codec = ps_codec;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tu_cnt = i4_ctb_tu_cnt;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_x = ps_codec->s_parse.i4_ctb_x;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_y = ps_codec->s_parse.i4_ctb_y;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tile_x = ps_codec->s_parse.i4_ctb_tile_x;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tile_y = ps_codec->s_parse.i4_ctb_tile_y;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_slice_x = ps_codec->s_parse.i4_ctb_slice_x;
                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_slice_y = ps_codec->s_parse.i4_ctb_slice_y;
                    ps_codec->s_parse.s_bs_ctxt.ps_tu = &ps_codec->s_parse.ps_pic_tu[cur_tu_idx];
                    ps_codec->s_parse.s_bs_ctxt.ps_pu = &ps_codec->s_parse.ps_pic_pu[cur_pu_idx];
                    ps_codec->s_parse.s_bs_ctxt.pu4_pic_pu_idx_map = ps_proc->pu4_pic_pu_idx_map;
                    ps_codec->s_parse.s_bs_ctxt.i4_next_pu_ctb_cnt = ps_codec->s_parse.i4_next_pu_ctb_cnt;
                    ps_codec->s_parse.s_bs_ctxt.i4_next_tu_ctb_cnt = ps_codec->s_parse.i4_next_tu_ctb_cnt;
                    ps_codec->s_parse.s_bs_ctxt.pu1_slice_idx = ps_codec->s_parse.pu1_slice_idx;
                    ps_codec->s_parse.s_bs_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;
                    ps_codec->s_parse.s_bs_ctxt.ps_tile = ps_codec->s_parse.ps_tile;

 if(ISLICE == ps_slice_hdr->i1_slice_type)
 {
                        ihevcd_ctb_boundary_strength_islice(&ps_codec->s_parse.s_bs_ctxt);
 }
 else
 {
                        ihevcd_ctb_boundary_strength_pbslice(&ps_codec->s_parse.s_bs_ctxt);
 }
 }
 else
 {
                    WORD32 bs_strd = (ps_sps->i2_pic_wd_in_ctb + 1) * (ctb_size * ctb_size / 8 / 16);

                    UWORD32 *pu4_vert_bs = (UWORD32 *)((UWORD8 *)ps_codec->s_parse.s_bs_ctxt.pu4_pic_vert_bs +
                                    ps_codec->s_parse.i4_ctb_x * (ctb_size * ctb_size / 8 / 16) +
                                    ps_codec->s_parse.i4_ctb_y * bs_strd);
                    UWORD32 *pu4_horz_bs = (UWORD32 *)((UWORD8 *)ps_codec->s_parse.s_bs_ctxt.pu4_pic_horz_bs +
                                    ps_codec->s_parse.i4_ctb_x * (ctb_size * ctb_size / 8 / 16) +
                                    ps_codec->s_parse.i4_ctb_y * bs_strd);

                    memset(pu4_vert_bs, 0, (ctb_size / 8 + 1) * (ctb_size / 4) / 8 * 2);
                    memset(pu4_horz_bs, 0, (ctb_size / 8) * (ctb_size / 4) / 8 * 2);

 }
 }

 }


 /* Update the parse status map */
 {
 sps_t *ps_sps = ps_codec->s_parse.ps_sps;
            UWORD8 *pu1_buf;
            WORD32 idx;
            idx = (ps_codec->s_parse.i4_ctb_x);
            idx += ((ps_codec->s_parse.i4_ctb_y) * ps_sps->i2_pic_wd_in_ctb);
            pu1_buf = (ps_codec->pu1_parse_map + idx);
 *pu1_buf = 1;
 }

 /* Increment CTB x and y positions */
        ps_codec->s_parse.i4_ctb_tile_x++;
        ps_codec->s_parse.i4_ctb_x++;
        ps_codec->s_parse.i4_ctb_slice_x++;

 /*If tiles are enabled, handle the slice counters differently*/
 if(ps_pps->i1_tiles_enabled_flag)
 {
            tile_start_ctb_idx = ps_tile->u1_pos_x
 + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);

            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x
 + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);

 if((slice_start_ctb_idx < tile_start_ctb_idx))
 {
 if(ps_codec->s_parse.i4_ctb_slice_x == (ps_tile->u1_pos_x + ps_tile->u2_wd))
 {
 /* Reached end of slice row within a tile /frame */
                    ps_codec->s_parse.i4_ctb_slice_y++;
                    ps_codec->s_parse.i4_ctb_slice_x = ps_tile->u1_pos_x; //todo:Check
 }
 }
 else if(ps_codec->s_parse.i4_ctb_slice_x == (ps_tile->u2_wd))
 {
                ps_codec->s_parse.i4_ctb_slice_y++;
                ps_codec->s_parse.i4_ctb_slice_x = 0;
 }
 }
 else
 {
 if(ps_codec->s_parse.i4_ctb_slice_x == ps_tile->u2_wd)
 {
 /* Reached end of slice row within a tile /frame */
                ps_codec->s_parse.i4_ctb_slice_y++;
                ps_codec->s_parse.i4_ctb_slice_x = 0;
 }
 }


 if(ps_codec->s_parse.i4_ctb_tile_x == (ps_tile->u2_wd))
 {
 /* Reached end of tile row */
            ps_codec->s_parse.i4_ctb_tile_x = 0;
            ps_codec->s_parse.i4_ctb_x = ps_tile->u1_pos_x;

            ps_codec->s_parse.i4_ctb_tile_y++;
            ps_codec->s_parse.i4_ctb_y++;

 if(ps_codec->s_parse.i4_ctb_tile_y == (ps_tile->u2_ht))
 {
 /* Reached End of Tile */
                ps_codec->s_parse.i4_ctb_tile_y = 0;
                ps_codec->s_parse.i4_ctb_tile_x = 0;
                ps_codec->s_parse.ps_tile++;

 if((ps_tile->u2_ht + ps_tile->u1_pos_y  ==  ps_sps->i2_pic_ht_in_ctb) && (ps_tile->u2_wd + ps_tile->u1_pos_x  ==  ps_sps->i2_pic_wd_in_ctb))
 {
 /* Reached end of frame */
                    end_of_pic = 1;
                    ps_codec->s_parse.i4_ctb_x = 0;
                    ps_codec->s_parse.i4_ctb_y = ps_sps->i2_pic_ht_in_ctb;
 }
 else
 {
 /* Initialize ctb_x and ctb_y to start of next tile */
                    ps_tile = ps_codec->s_parse.ps_tile;
                    ps_codec->s_parse.i4_ctb_x = ps_tile->u1_pos_x;
                    ps_codec->s_parse.i4_ctb_y = ps_tile->u1_pos_y;
                    ps_codec->s_parse.i4_ctb_tile_y = 0;
                    ps_codec->s_parse.i4_ctb_tile_x = 0;
                    ps_codec->s_parse.i4_ctb_slice_x = ps_tile->u1_pos_x;
                    ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y;

 }
 }

 }

        ps_codec->s_parse.i4_next_ctb_indx = ps_codec->s_parse.i4_ctb_x +
                        ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb;

 /* If the current slice is in error, check if the next slice's address
         * is reached and mark the end_of_slice flag */
 if(ps_codec->i4_slice_error)
 {
 slice_header_t *ps_slice_hdr_next = ps_slice_hdr + 1;
            WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x +
                            ps_slice_hdr_next->i2_ctb_y * ps_sps->i2_pic_wd_in_ctb;

 if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr)
                end_of_slice_flag = 1;
 }

 /* If the codec is running in single core mode
         * then call process function for current CTB
         */
 if((1 == ps_codec->i4_num_cores) && (ps_codec->s_parse.i4_ctb_tile_x == 0))
 {
 process_ctxt_t *ps_proc = &ps_codec->as_process[0];
            ps_proc->i4_ctb_cnt = ps_proc->ps_tile->u2_wd;
            ihevcd_process(ps_proc);
 }

 /* If the bytes for the current slice are exhausted
         * set end_of_slice flag to 1
         * This slice will be treated as incomplete */
 if((UWORD8 *)ps_codec->s_parse.s_bitstrm.pu1_buf_max + BITSTRM_OFF_THRS <
 ((UWORD8 *)ps_codec->s_parse.s_bitstrm.pu4_buf + (ps_codec->s_parse.s_bitstrm.u4_bit_ofst / 8)))
 {

 if(0 == ps_codec->i4_slice_error)
                end_of_slice_flag = 1;
 }


 if(end_of_pic)
 break;
 } while(!end_of_slice_flag);

 /* Reset slice error */
    ps_codec->i4_slice_error = 0;

 /* Increment the slice index for parsing next slice */
 if(0 == end_of_pic)
 {
 while(1)
 {

            WORD32 parse_slice_idx;
            parse_slice_idx = ps_codec->s_parse.i4_cur_slice_idx;
            parse_slice_idx++;

 {
 /* If the next slice header is not initialized, update cur_slice_idx and break */
 if((1 == ps_codec->i4_num_cores) || (0 != (parse_slice_idx & (MAX_SLICE_HDR_CNT - 1))))
 {
                    ps_codec->s_parse.i4_cur_slice_idx = parse_slice_idx;
 break;
 }

 /* If the next slice header is initialised, wait for the parsed slices to be processed */
 else
 {
                    WORD32 ctb_indx = 0;

 while(ctb_indx != ps_sps->i4_pic_size_in_ctb)
 {
                        WORD32 parse_status = *(ps_codec->pu1_parse_map + ctb_indx);
 volatile WORD32 proc_status = *(ps_codec->pu1_proc_map + ctb_indx) & 1;

 if(parse_status == proc_status)
                            ctb_indx++;
 }
                    ps_codec->s_parse.i4_cur_slice_idx = parse_slice_idx;
 break;
 }

 }
 }

 }
 else
 {
#if FRAME_ILF_PAD
 if(FRAME_ILF_PAD && 1 == ps_codec->i4_num_cores)
 {
 if(ps_slice_hdr->i4_abs_pic_order_cnt == 0)
 {
                DUMP_PRE_ILF(ps_codec->as_process[0].pu1_cur_pic_luma,
                             ps_codec->as_process[0].pu1_cur_pic_chroma,
                             ps_sps->i2_pic_width_in_luma_samples,
                             ps_sps->i2_pic_height_in_luma_samples,
                             ps_codec->i4_strd);

                DUMP_BS(ps_codec->as_process[0].s_bs_ctxt.pu4_pic_vert_bs,
                        ps_codec->as_process[0].s_bs_ctxt.pu4_pic_horz_bs,
                        ps_sps->i2_pic_wd_in_ctb * (ctb_size * ctb_size / 8 / 16) * ps_sps->i2_pic_ht_in_ctb,
 (ps_sps->i2_pic_wd_in_ctb + 1) * (ctb_size * ctb_size / 8 / 16) * ps_sps->i2_pic_ht_in_ctb);

                DUMP_QP(ps_codec->as_process[0].s_bs_ctxt.pu1_pic_qp,
 (ps_sps->i2_pic_height_in_luma_samples * ps_sps->i2_pic_width_in_luma_samples) / (MIN_CU_SIZE * MIN_CU_SIZE));

                DUMP_QP_CONST_IN_CTB(ps_codec->as_process[0].s_bs_ctxt.pu1_pic_qp_const_in_ctb,
 (ps_sps->i2_pic_height_in_luma_samples * ps_sps->i2_pic_width_in_luma_samples) / (MIN_CTB_SIZE * MIN_CTB_SIZE) / 8);

                DUMP_NO_LOOP_FILTER(ps_codec->as_process[0].pu1_pic_no_loop_filter_flag,
 (ps_sps->i2_pic_width_in_luma_samples / MIN_CU_SIZE) * (ps_sps->i2_pic_height_in_luma_samples / MIN_CU_SIZE) / 8);

                DUMP_OFFSETS(ps_slice_hdr->i1_beta_offset_div2,
                             ps_slice_hdr->i1_tc_offset_div2,
                             ps_pps->i1_pic_cb_qp_offset,
                             ps_pps->i1_pic_cr_qp_offset);
 }
            ps_codec->s_parse.s_deblk_ctxt.ps_pps = ps_codec->s_parse.ps_pps;
            ps_codec->s_parse.s_deblk_ctxt.ps_sps = ps_codec->s_parse.ps_sps;
            ps_codec->s_parse.s_deblk_ctxt.ps_codec = ps_codec;
            ps_codec->s_parse.s_deblk_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;
            ps_codec->s_parse.s_deblk_ctxt.is_chroma_yuv420sp_vu = (ps_codec->e_ref_chroma_fmt == IV_YUV_420SP_VU);

            ps_codec->s_parse.s_sao_ctxt.ps_pps = ps_codec->s_parse.ps_pps;
            ps_codec->s_parse.s_sao_ctxt.ps_sps = ps_codec->s_parse.ps_sps;
            ps_codec->s_parse.s_sao_ctxt.ps_codec = ps_codec;
            ps_codec->s_parse.s_sao_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;

            ihevcd_ilf_pad_frame(&ps_codec->s_parse.s_deblk_ctxt, &ps_codec->s_parse.s_sao_ctxt);

 }
#endif
        ps_codec->s_parse.i4_end_of_frame = 1;
 }
 return ret;
}
","The `ihevcd_parse_slice_data` function is responsible for parsing slice data in a video codec, specifically for the HEVC (High Efficiency Video Coding) standard. It initializes various parameters related to slice headers, picture parameters, and coding tree blocks (CTBs). The function processes each slice by updating the parsing context, managing tile positions, and handling dependencies between slices. It also initializes CABAC (Context-based Adaptive Binary Arithmetic Coding) for entropy coding, updates motion vector buffers, and manages boundary strength calculations. The function iterates through the slices, handling errors and signaling the end of slices or pictures as necessary, ultimately returning a status code indicating success or failure.","The provided code is designed to parse slice data in a video codec, specifically for the HEVC standard. It initializes and updates various parameters related to slice headers and picture properties, while managing the positions of coding tree blocks. The code processes each slice by handling dependencies, initializing entropy coding, and updating motion vector buffers. It iterates through slices, checking for errors and signaling the end of slices or pictures as needed. The function ultimately returns a status code that indicates whether the parsing operation was successful or encountered issues.","The vulnerability in the original code stemmed from improper handling of incomplete coding tree blocks (CTBs) at frame boundaries, which could lead to incorrect parsing and potential memory access violations. Specifically, the code did not adequately manage the state of processing when encountering incomplete CTBs, risking undefined behavior. The fix introduced a mechanism to set error skip CTBs as multiple 8x8 processing units (PUs), ensuring that the parsing logic correctly identifies and handles these incomplete blocks. This adjustment allows the codec to gracefully skip over problematic areas, maintaining stability and preventing crashes during decoding.","The vulnerability in the original code was related to the handling of incomplete coding tree blocks at frame boundaries, which could lead to incorrect parsing and potential crashes during video decoding. This issue arose when the code failed to properly manage the state of processing for these incomplete blocks, risking undefined behavior. The fix implemented a mechanism to designate error skip blocks as multiple smaller processing units, ensuring that the codec could effectively skip over problematic areas. This adjustment improved the robustness of the parsing process, allowing it to handle incomplete data gracefully without causing instability.","The vulnerability was fixed by introducing a mechanism to set error skip coding tree blocks as multiple 8x8 processing units. This was achieved through the function `ihevcd_set_ctb_skip`, which was called when the parsing encountered incomplete coding tree blocks. By updating the state of the codec to recognize these incomplete blocks, the code ensured that the parsing process could gracefully skip over them without causing crashes or undefined behavior. This adjustment was crucial for maintaining stability during the decoding process, particularly at frame boundaries where such incomplete blocks are likely to occur.","The vulnerability was addressed by implementing a mechanism that designates incomplete coding tree blocks as multiple smaller processing units. This change allows the codec to recognize and appropriately handle these incomplete blocks during the parsing process. By updating the internal state to skip over problematic areas, the code ensures that the parsing can continue without encountering crashes or undefined behavior. This fix enhances the robustness of the decoding process, particularly at frame boundaries, where incomplete data is more likely to occur, thereby improving overall stability and reliability.","4,5","4, 4","5,4","3,4"
128,128,188166,188166,,Remote,Not required,,CVE-2016-6720,https://www.cvedetails.com/cve/CVE-2016-6720/,CWE-200,Medium,Partial,,,2016-12-13,4.3,"An information disclosure vulnerability in libstagefright in Mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-11-01, and 7.0 before 2016-11-01 could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Android ID: A-29422020.",2016-12-14,+Info ,0,https://android.googlesource.com/platform/frameworks/av/+/640b04121d7cd2cac90e2f7c82b97fce05f074a5,640b04121d7cd2cac90e2f7c82b97fce05f074a5,"IOMX: do not clear buffer if it's allocated by component

The component might depends on their buffers to be initialized
in certain ways to work. Don't clear unless we're allocating it.

bug: 31586647
Change-Id: Ia0a125797e414998ef0cd8ce03672f5b1e0bbf7a
(cherry picked from commit ea76573aa276f51950007217a97903c4fe64f685)
",1,media/libstagefright/omx/OMXNodeInstance.cpp,"{""filename"": ""media/libstagefright/omx/OMXNodeInstance.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/640b04121d7cd2cac90e2f7c82b97fce05f074a5/media/libstagefright/omx/OMXNodeInstance.cpp"", ""patch"": ""@@ -1310,7 +1310,6 @@\n\n     }\n \n     CHECK_EQ(header->pAppPrivate, buffer_meta);\n-    memset(header->pBuffer, 0, header->nAllocLen);\n \n     *buffer = makeBufferID(header);\n \n""}","status_t OMXNodeInstance::allocateBufferWithBackup(
        OMX_U32 portIndex, const sp<IMemory> &params,
        OMX::buffer_id *buffer, OMX_U32 allottedSize) {
 if (params == NULL || buffer == NULL) {
        ALOGE(""b/25884056"");
 return BAD_VALUE;
 }

 Mutex::Autolock autoLock(mLock);
 if (allottedSize > params->size() || portIndex >= NELEM(mNumPortBuffers)) {
 return BAD_VALUE;
 }

 bool copy = mMetadataType[portIndex] == kMetadataBufferTypeInvalid;

 BufferMeta *buffer_meta = new BufferMeta(
            params, portIndex,
 (portIndex == kPortIndexInput) && copy /* copyToOmx */,
 (portIndex == kPortIndexOutput) && copy /* copyFromOmx */,
            NULL /* data */);

    OMX_BUFFERHEADERTYPE *header;

    OMX_ERRORTYPE err = OMX_AllocateBuffer(
            mHandle, &header, portIndex, buffer_meta, allottedSize);
 if (err != OMX_ErrorNone) {
        CLOG_ERROR(allocateBufferWithBackup, err,
                SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));
 delete buffer_meta;
        buffer_meta = NULL;

 *buffer = 0;

 return StatusFromOMXError(err);

     }
 
     CHECK_EQ(header->pAppPrivate, buffer_meta);
 
     *buffer = makeBufferID(header);
 
    addActiveBuffer(portIndex, *buffer);

    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
 if (bufferSource != NULL && portIndex == kPortIndexInput) {
        bufferSource->addCodecBuffer(header);
 }

    CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, ""%zu@%p :> %u@%p"",
            params->size(), params->pointer(), allottedSize, header->pBuffer));

 return OK;
}
","status_t OMXNodeInstance::allocateBufferWithBackup(
        OMX_U32 portIndex, const sp<IMemory> &params,
        OMX::buffer_id *buffer, OMX_U32 allottedSize) {
 if (params == NULL || buffer == NULL) {
        ALOGE(""b/25884056"");
 return BAD_VALUE;
 }

 Mutex::Autolock autoLock(mLock);
 if (allottedSize > params->size() || portIndex >= NELEM(mNumPortBuffers)) {
 return BAD_VALUE;
 }

 bool copy = mMetadataType[portIndex] == kMetadataBufferTypeInvalid;

 BufferMeta *buffer_meta = new BufferMeta(
            params, portIndex,
 (portIndex == kPortIndexInput) && copy /* copyToOmx */,
 (portIndex == kPortIndexOutput) && copy /* copyFromOmx */,
            NULL /* data */);

    OMX_BUFFERHEADERTYPE *header;

    OMX_ERRORTYPE err = OMX_AllocateBuffer(
            mHandle, &header, portIndex, buffer_meta, allottedSize);
 if (err != OMX_ErrorNone) {
        CLOG_ERROR(allocateBufferWithBackup, err,
                SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));
 delete buffer_meta;
        buffer_meta = NULL;

 *buffer = 0;

 return StatusFromOMXError(err);

     }
 
     CHECK_EQ(header->pAppPrivate, buffer_meta);
    memset(header->pBuffer, 0, header->nAllocLen);
 
     *buffer = makeBufferID(header);
 
    addActiveBuffer(portIndex, *buffer);

    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
 if (bufferSource != NULL && portIndex == kPortIndexInput) {
        bufferSource->addCodecBuffer(header);
 }

    CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, ""%zu@%p :> %u@%p"",
            params->size(), params->pointer(), allottedSize, header->pBuffer));

 return OK;
}
",C,,"    memset(header->pBuffer, 0, header->nAllocLen);
",,"@@ -1310,7 +1310,6 @@

     }
 
     CHECK_EQ(header->pAppPrivate, buffer_meta);
-    memset(header->pBuffer, 0, header->nAllocLen);
 
     *buffer = makeBufferID(header);
 
",Android,https://android.googlesource.com/platform/frameworks/av/+/640b04121d7cd2cac90e2f7c82b97fce05f074a5/,https://android.googlesource.com/platform/frameworks/av/+/640b04121d7cd2cac90e2f7c82b97fce05f074a5%5E/,1,"status_t OMXNodeInstance::allocateBufferWithBackup(
        OMX_U32 portIndex, const sp<IMemory> &params,
        OMX::buffer_id *buffer, OMX_U32 allottedSize) {
 if (params == NULL || buffer == NULL) {
        ALOGE(""b/25884056"");
 return BAD_VALUE;
 }

 Mutex::Autolock autoLock(mLock);
 if (allottedSize > params->size() || portIndex >= NELEM(mNumPortBuffers)) {
 return BAD_VALUE;
 }

 // metadata buffers are not connected cross process; only copy if not meta
 bool copy = mMetadataType[portIndex] == kMetadataBufferTypeInvalid;

 BufferMeta *buffer_meta = new BufferMeta(
            params, portIndex,
 (portIndex == kPortIndexInput) && copy /* copyToOmx */,
 (portIndex == kPortIndexOutput) && copy /* copyFromOmx */,
            NULL /* data */);

    OMX_BUFFERHEADERTYPE *header;

    OMX_ERRORTYPE err = OMX_AllocateBuffer(
            mHandle, &header, portIndex, buffer_meta, allottedSize);
 if (err != OMX_ErrorNone) {
        CLOG_ERROR(allocateBufferWithBackup, err,
                SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));
 delete buffer_meta;
        buffer_meta = NULL;

 *buffer = 0;

 return StatusFromOMXError(err);

     }
 
     CHECK_EQ(header->pAppPrivate, buffer_meta);
//flaw_line_below:
    memset(header->pBuffer, 0, header->nAllocLen);
 
     *buffer = makeBufferID(header);
 
    addActiveBuffer(portIndex, *buffer);

    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
 if (bufferSource != NULL && portIndex == kPortIndexInput) {
        bufferSource->addCodecBuffer(header);
 }

    CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, ""%zu@%p :> %u@%p"",
            params->size(), params->pointer(), allottedSize, header->pBuffer));

 return OK;
}
",188166,"status_t OMXNodeInstance::allocateBufferWithBackup(
        OMX_U32 portIndex, const sp<IMemory> &params,
        OMX::buffer_id *buffer, OMX_U32 allottedSize) {
 if (params == NULL || buffer == NULL) {
        ALOGE(""b/25884056"");
 return BAD_VALUE;
 }

 Mutex::Autolock autoLock(mLock);
 if (allottedSize > params->size() || portIndex >= NELEM(mNumPortBuffers)) {
 return BAD_VALUE;
 }

 bool copy = mMetadataType[portIndex] == kMetadataBufferTypeInvalid;

 BufferMeta *buffer_meta = new BufferMeta(
            params, portIndex,
 (portIndex == kPortIndexInput) && copy /* copyToOmx */,
 (portIndex == kPortIndexOutput) && copy /* copyFromOmx */,
            NULL /* data */);

    OMX_BUFFERHEADERTYPE *header;

    OMX_ERRORTYPE err = OMX_AllocateBuffer(
            mHandle, &header, portIndex, buffer_meta, allottedSize);
 if (err != OMX_ErrorNone) {
        CLOG_ERROR(allocateBufferWithBackup, err,
                SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));
 delete buffer_meta;
        buffer_meta = NULL;

 *buffer = 0;

 return StatusFromOMXError(err);

     }
 
     CHECK_EQ(header->pAppPrivate, buffer_meta);
    memset(header->pBuffer, 0, header->nAllocLen);
 
     *buffer = makeBufferID(header);
 
    addActiveBuffer(portIndex, *buffer);

    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
 if (bufferSource != NULL && portIndex == kPortIndexInput) {
        bufferSource->addCodecBuffer(header);
 }

    CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, ""%zu@%p :> %u@%p"",
            params->size(), params->pointer(), allottedSize, header->pBuffer));

 return OK;
}
","status_t OMXNodeInstance::allocateBufferWithBackup(
        OMX_U32 portIndex, const sp<IMemory> &params,
        OMX::buffer_id *buffer, OMX_U32 allottedSize) {
 if (params == NULL || buffer == NULL) {
        ALOGE(""b/25884056"");
 return BAD_VALUE;
 }

 Mutex::Autolock autoLock(mLock);
 if (allottedSize > params->size() || portIndex >= NELEM(mNumPortBuffers)) {
 return BAD_VALUE;
 }

 bool copy = mMetadataType[portIndex] == kMetadataBufferTypeInvalid;

 BufferMeta *buffer_meta = new BufferMeta(
            params, portIndex,
 (portIndex == kPortIndexInput) && copy /* copyToOmx */,
 (portIndex == kPortIndexOutput) && copy /* copyFromOmx */,
            NULL /* data */);

    OMX_BUFFERHEADERTYPE *header;

    OMX_ERRORTYPE err = OMX_AllocateBuffer(
            mHandle, &header, portIndex, buffer_meta, allottedSize);
 if (err != OMX_ErrorNone) {
        CLOG_ERROR(allocateBufferWithBackup, err,
                SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));
 delete buffer_meta;
        buffer_meta = NULL;

 *buffer = 0;

 return StatusFromOMXError(err);

     }
 
     CHECK_EQ(header->pAppPrivate, buffer_meta);
 
     *buffer = makeBufferID(header);
 
    addActiveBuffer(portIndex, *buffer);

    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
 if (bufferSource != NULL && portIndex == kPortIndexInput) {
        bufferSource->addCodecBuffer(header);
 }

    CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, ""%zu@%p :> %u@%p"",
            params->size(), params->pointer(), allottedSize, header->pBuffer));

 return OK;
}
","The `allocateBufferWithBackup` function in the `OMXNodeInstance` class is responsible for allocating a buffer for a specified port index while ensuring that the buffer meets certain conditions. It first checks for null parameters and validates the allotted size against the provided memory size and port index. If the conditions are met, it creates a `BufferMeta` object, attempts to allocate an OMX buffer, and handles any errors that may arise during allocation. Upon successful allocation, it initializes the buffer, assigns it a unique identifier, and potentially adds it to a graphic buffer source if the port is an input. Finally, it logs the buffer details and returns a status indicating success or failure.","The provided code defines a function that allocates a buffer for a specific port while ensuring that the allocation parameters are valid. It checks for null inputs and verifies that the requested size does not exceed the available memory. If the conditions are satisfied, it creates a metadata object for the buffer and attempts to allocate the buffer. If successful, it initializes the buffer, assigns it a unique identifier, and may add it to a graphic buffer source if the port is designated for input. The function concludes by logging the buffer details and returning a status indicating the outcome of the operation.","The vulnerability in the original code stemmed from unconditionally clearing the allocated buffer, which could disrupt components that rely on specific initialization states of their buffers. This behavior could lead to unexpected results or failures in the component's operation. The fix involved modifying the code to avoid clearing the buffer unless it was newly allocated, ensuring that existing buffers retain their intended state. This change was implemented by checking the allocation conditions and only initializing the buffer when necessary, thus preserving the integrity of buffers that components depend on for proper functionality.","The vulnerability in the original code arose from the practice of clearing buffers upon allocation, which could interfere with components that expect their buffers to maintain specific initialization states. This could lead to improper functioning or failures in those components, as they might rely on the existing data within the buffers. The fix addressed this issue by ensuring that buffers are only cleared when they are newly allocated, thereby preserving the intended state of buffers that are already in use. This change allows components to operate correctly without unintended modifications to their buffers.","The vulnerability was fixed by modifying the buffer initialization logic in the allocation function. Specifically, the code was updated to avoid clearing the buffer unless it was newly allocated. This was achieved by checking the conditions under which the buffer is allocated and only invoking the clearing operation when necessary. The change ensures that the buffer is not cleared if it has been allocated by a component, thus preserving its state. This adjustment prevents unintended data loss and maintains the integrity of the buffers, allowing components to function correctly without disruption.","The vulnerability was fixed by altering the buffer management logic to prevent unnecessary clearing of buffers that are already allocated by components. The updated code introduces a condition that checks whether the buffer is newly allocated before performing any clearing operations. This ensures that existing buffers retain their intended state and data, which is crucial for the proper functioning of components that depend on specific initialization. By implementing this change, the code safeguards against unintended modifications, thereby enhancing the reliability and stability of the system.","5,4","4, 4","4, 4","4, 3"
129,129,188633,188633,,Remote,Not required,,CVE-2017-0402,https://www.cvedetails.com/cve/CVE-2017-0402/,CWE-200,Medium,Partial,,,2017-01-12,4.3,"An information disclosure vulnerability in lvm/wrapper/Bundle/EffectBundle.cpp in libeffects in Audioserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1. Android ID: A-32436341.",2017-01-17,+Info ,16,https://android.googlesource.com/platform/hardware/qcom/audio/+/d72ea85c78a1a68bf99fd5804ad9784b4102fe57,d72ea85c78a1a68bf99fd5804ad9784b4102fe57,"Fix security vulnerability: Equalizer command might allow negative indexes

Bug: 32247948
Bug: 32438598
Bug: 32436341

Test: use POC on bug or cts security test

Change-Id: I56a92582687599b5b313dea1abcb8bcb19c7fc0e
(cherry picked from commit 3f37d4ef89f4f0eef9e201c5a91b7b2c77ed1071)
(cherry picked from commit ceb7b2d7a4c4cb8d03f166c61f5c7551c6c760aa)
",4,post_proc/equalizer.c,"{""filename"": ""post_proc/equalizer.c"", ""raw_url"": ""https://android.googlesource.com/platform/hardware/qcom/audio/+/d72ea85c78a1a68bf99fd5804ad9784b4102fe57/post_proc/equalizer.c"", ""patch"": ""@@ -265,8 +265,12 @@\n\n     case EQ_PARAM_BAND_LEVEL:\n \tALOGV(\""%s: EQ_PARAM_BAND_LEVEL\"", __func__);\n         param2 = *param_tmp;\n-        if (param2 >= NUM_EQ_BANDS) {\n+        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {\n             p->status = -EINVAL;\n+            if (param2 < 0) {\n+                android_errorWriteLog(0x534e4554, \""32438598\"");\n+                ALOGW(\""\\tERROR EQ_PARAM_BAND_LEVEL band %d\"", param2);\n+            }\n             break;\n         }\n         *(int16_t *)value = (int16_t)equalizer_get_band_level(eq_ctxt, param2);\n@@ -275,8 +279,12 @@\n\n     case EQ_PARAM_CENTER_FREQ:\n \tALOGV(\""%s: EQ_PARAM_CENTER_FREQ\"", __func__);\n         param2 = *param_tmp;\n-        if (param2 >= NUM_EQ_BANDS) {\n-           p->status = -EINVAL;\n+        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {\n+            p->status = -EINVAL;\n+            if (param2 < 0) {\n+                android_errorWriteLog(0x534e4554, \""32436341\"");\n+                ALOGW(\""\\tERROR EQ_PARAM_CENTER_FREQ band %d\"", param2);\n+            }\n             break;\n         }\n         *(int32_t *)value = equalizer_get_center_frequency(eq_ctxt, param2);\n@@ -285,8 +293,12 @@\n\n     case EQ_PARAM_BAND_FREQ_RANGE:\n \tALOGV(\""%s: EQ_PARAM_BAND_FREQ_RANGE\"", __func__);\n         param2 = *param_tmp;\n-        if (param2 >= NUM_EQ_BANDS) {\n+        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {\n             p->status = -EINVAL;\n+            if (param2 < 0) {\n+                android_errorWriteLog(0x534e4554, \""32247948\"");\n+                ALOGW(\""\\tERROR EQ_PARAM_BAND_FREQ_RANGE band %d\"", param2);\n+            }\n            break;\n         }\n        equalizer_get_band_freq_range(eq_ctxt, param2, (uint32_t *)value,\n""}","int equalizer_get_parameter(effect_context_t *context, effect_param_t *p,
 uint32_t *size)
{
 equalizer_context_t *eq_ctxt = (equalizer_context_t *)context;
 int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);
 int32_t *param_tmp = (int32_t *)p->data;
 int32_t param = *param_tmp++;
 int32_t param2;
 char *name;
 void *value = p->data + voffset;
 int i;

    ALOGV(""%s"", __func__);

    p->status = 0;

 switch (param) {
 case EQ_PARAM_NUM_BANDS:
 case EQ_PARAM_CUR_PRESET:
 case EQ_PARAM_GET_NUM_OF_PRESETS:
 case EQ_PARAM_BAND_LEVEL:
 case EQ_PARAM_GET_BAND:
 if (p->vsize < sizeof(int16_t))
           p->status = -EINVAL;
        p->vsize = sizeof(int16_t);
 break;

 case EQ_PARAM_LEVEL_RANGE:
 if (p->vsize < 2 * sizeof(int16_t))
            p->status = -EINVAL;
        p->vsize = 2 * sizeof(int16_t);
 break;
 case EQ_PARAM_BAND_FREQ_RANGE:
 if (p->vsize < 2 * sizeof(int32_t))
            p->status = -EINVAL;
        p->vsize = 2 * sizeof(int32_t);
 break;

 case EQ_PARAM_CENTER_FREQ:
 if (p->vsize < sizeof(int32_t))
            p->status = -EINVAL;
        p->vsize = sizeof(int32_t);
 break;

 case EQ_PARAM_GET_PRESET_NAME:
 break;

 case EQ_PARAM_PROPERTIES:
 if (p->vsize < (2 + NUM_EQ_BANDS) * sizeof(uint16_t))
            p->status = -EINVAL;
        p->vsize = (2 + NUM_EQ_BANDS) * sizeof(uint16_t);
 break;

 default:
        p->status = -EINVAL;
 }

 *size = sizeof(effect_param_t) + voffset + p->vsize;

 if (p->status != 0)
 return 0;

 switch (param) {
 case EQ_PARAM_NUM_BANDS:
	ALOGV(""%s: EQ_PARAM_NUM_BANDS"", __func__);
 *(uint16_t *)value = (uint16_t)NUM_EQ_BANDS;
 break;

 case EQ_PARAM_LEVEL_RANGE:
	ALOGV(""%s: EQ_PARAM_LEVEL_RANGE"", __func__);
 *(int16_t *)value = -1500;
 *((int16_t *)value + 1) = 1500;
 break;


     case EQ_PARAM_BAND_LEVEL:
 	ALOGV(""%s: EQ_PARAM_BAND_LEVEL"", __func__);
         param2 = *param_tmp;
        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {
             p->status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32438598"");
                ALOGW(""\tERROR EQ_PARAM_BAND_LEVEL band %d"", param2);
            }
             break;
         }
         *(int16_t *)value = (int16_t)equalizer_get_band_level(eq_ctxt, param2);
 break;


     case EQ_PARAM_CENTER_FREQ:
 	ALOGV(""%s: EQ_PARAM_CENTER_FREQ"", __func__);
         param2 = *param_tmp;
        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {
            p->status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32436341"");
                ALOGW(""\tERROR EQ_PARAM_CENTER_FREQ band %d"", param2);
            }
             break;
         }
         *(int32_t *)value = equalizer_get_center_frequency(eq_ctxt, param2);
 break;


     case EQ_PARAM_BAND_FREQ_RANGE:
 	ALOGV(""%s: EQ_PARAM_BAND_FREQ_RANGE"", __func__);
         param2 = *param_tmp;
        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {
             p->status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32247948"");
                ALOGW(""\tERROR EQ_PARAM_BAND_FREQ_RANGE band %d"", param2);
            }
            break;
         }
        equalizer_get_band_freq_range(eq_ctxt, param2, (uint32_t *)value,
 ((uint32_t *)value + 1));
 break;

 case EQ_PARAM_GET_BAND:
	ALOGV(""%s: EQ_PARAM_GET_BAND"", __func__);
        param2 = *param_tmp;
 *(uint16_t *)value = (uint16_t)equalizer_get_band(eq_ctxt, param2);
 break;

 case EQ_PARAM_CUR_PRESET:
	ALOGV(""%s: EQ_PARAM_CUR_PRESET"", __func__);
 *(uint16_t *)value = (uint16_t)equalizer_get_preset(eq_ctxt);
 break;

 case EQ_PARAM_GET_NUM_OF_PRESETS:
	ALOGV(""%s: EQ_PARAM_GET_NUM_OF_PRESETS"", __func__);
 *(uint16_t *)value = (uint16_t)equalizer_get_num_presets(eq_ctxt);
 break;

 case EQ_PARAM_GET_PRESET_NAME:
	ALOGV(""%s: EQ_PARAM_GET_PRESET_NAME"", __func__);
        param2 = *param_tmp;
	ALOGV(""param2: %d"", param2);
 if (param2 >= equalizer_get_num_presets(eq_ctxt)) {
            p->status = -EINVAL;
 break;
 }
        name = (char *)value;
        strlcpy(name, equalizer_get_preset_name(eq_ctxt, param2), p->vsize - 1);
        name[p->vsize - 1] = 0;
        p->vsize = strlen(name) + 1;
 break;

 case EQ_PARAM_PROPERTIES: {
	ALOGV(""%s: EQ_PARAM_PROPERTIES"", __func__);
 int16_t *prop = (int16_t *)value;
        prop[0] = (int16_t)equalizer_get_preset(eq_ctxt);
        prop[1] = (int16_t)NUM_EQ_BANDS;
 for (i = 0; i < NUM_EQ_BANDS; i++) {
            prop[2 + i] = (int16_t)equalizer_get_band_level(eq_ctxt, i);
 }
 } break;

 default:
        p->status = -EINVAL;
 break;
 }

 return 0;
}
","int equalizer_get_parameter(effect_context_t *context, effect_param_t *p,
 uint32_t *size)
{
 equalizer_context_t *eq_ctxt = (equalizer_context_t *)context;
 int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);
 int32_t *param_tmp = (int32_t *)p->data;
 int32_t param = *param_tmp++;
 int32_t param2;
 char *name;
 void *value = p->data + voffset;
 int i;

    ALOGV(""%s"", __func__);

    p->status = 0;

 switch (param) {
 case EQ_PARAM_NUM_BANDS:
 case EQ_PARAM_CUR_PRESET:
 case EQ_PARAM_GET_NUM_OF_PRESETS:
 case EQ_PARAM_BAND_LEVEL:
 case EQ_PARAM_GET_BAND:
 if (p->vsize < sizeof(int16_t))
           p->status = -EINVAL;
        p->vsize = sizeof(int16_t);
 break;

 case EQ_PARAM_LEVEL_RANGE:
 if (p->vsize < 2 * sizeof(int16_t))
            p->status = -EINVAL;
        p->vsize = 2 * sizeof(int16_t);
 break;
 case EQ_PARAM_BAND_FREQ_RANGE:
 if (p->vsize < 2 * sizeof(int32_t))
            p->status = -EINVAL;
        p->vsize = 2 * sizeof(int32_t);
 break;

 case EQ_PARAM_CENTER_FREQ:
 if (p->vsize < sizeof(int32_t))
            p->status = -EINVAL;
        p->vsize = sizeof(int32_t);
 break;

 case EQ_PARAM_GET_PRESET_NAME:
 break;

 case EQ_PARAM_PROPERTIES:
 if (p->vsize < (2 + NUM_EQ_BANDS) * sizeof(uint16_t))
            p->status = -EINVAL;
        p->vsize = (2 + NUM_EQ_BANDS) * sizeof(uint16_t);
 break;

 default:
        p->status = -EINVAL;
 }

 *size = sizeof(effect_param_t) + voffset + p->vsize;

 if (p->status != 0)
 return 0;

 switch (param) {
 case EQ_PARAM_NUM_BANDS:
	ALOGV(""%s: EQ_PARAM_NUM_BANDS"", __func__);
 *(uint16_t *)value = (uint16_t)NUM_EQ_BANDS;
 break;

 case EQ_PARAM_LEVEL_RANGE:
	ALOGV(""%s: EQ_PARAM_LEVEL_RANGE"", __func__);
 *(int16_t *)value = -1500;
 *((int16_t *)value + 1) = 1500;
 break;


     case EQ_PARAM_BAND_LEVEL:
 	ALOGV(""%s: EQ_PARAM_BAND_LEVEL"", __func__);
         param2 = *param_tmp;
        if (param2 >= NUM_EQ_BANDS) {
             p->status = -EINVAL;
             break;
         }
         *(int16_t *)value = (int16_t)equalizer_get_band_level(eq_ctxt, param2);
 break;


     case EQ_PARAM_CENTER_FREQ:
 	ALOGV(""%s: EQ_PARAM_CENTER_FREQ"", __func__);
         param2 = *param_tmp;
        if (param2 >= NUM_EQ_BANDS) {
           p->status = -EINVAL;
             break;
         }
         *(int32_t *)value = equalizer_get_center_frequency(eq_ctxt, param2);
 break;


     case EQ_PARAM_BAND_FREQ_RANGE:
 	ALOGV(""%s: EQ_PARAM_BAND_FREQ_RANGE"", __func__);
         param2 = *param_tmp;
        if (param2 >= NUM_EQ_BANDS) {
             p->status = -EINVAL;
            break;
         }
        equalizer_get_band_freq_range(eq_ctxt, param2, (uint32_t *)value,
 ((uint32_t *)value + 1));
 break;

 case EQ_PARAM_GET_BAND:
	ALOGV(""%s: EQ_PARAM_GET_BAND"", __func__);
        param2 = *param_tmp;
 *(uint16_t *)value = (uint16_t)equalizer_get_band(eq_ctxt, param2);
 break;

 case EQ_PARAM_CUR_PRESET:
	ALOGV(""%s: EQ_PARAM_CUR_PRESET"", __func__);
 *(uint16_t *)value = (uint16_t)equalizer_get_preset(eq_ctxt);
 break;

 case EQ_PARAM_GET_NUM_OF_PRESETS:
	ALOGV(""%s: EQ_PARAM_GET_NUM_OF_PRESETS"", __func__);
 *(uint16_t *)value = (uint16_t)equalizer_get_num_presets(eq_ctxt);
 break;

 case EQ_PARAM_GET_PRESET_NAME:
	ALOGV(""%s: EQ_PARAM_GET_PRESET_NAME"", __func__);
        param2 = *param_tmp;
	ALOGV(""param2: %d"", param2);
 if (param2 >= equalizer_get_num_presets(eq_ctxt)) {
            p->status = -EINVAL;
 break;
 }
        name = (char *)value;
        strlcpy(name, equalizer_get_preset_name(eq_ctxt, param2), p->vsize - 1);
        name[p->vsize - 1] = 0;
        p->vsize = strlen(name) + 1;
 break;

 case EQ_PARAM_PROPERTIES: {
	ALOGV(""%s: EQ_PARAM_PROPERTIES"", __func__);
 int16_t *prop = (int16_t *)value;
        prop[0] = (int16_t)equalizer_get_preset(eq_ctxt);
        prop[1] = (int16_t)NUM_EQ_BANDS;
 for (i = 0; i < NUM_EQ_BANDS; i++) {
            prop[2 + i] = (int16_t)equalizer_get_band_level(eq_ctxt, i);
 }
 } break;

 default:
        p->status = -EINVAL;
 break;
 }

 return 0;
}
",C,"        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32438598"");
                ALOGW(""\tERROR EQ_PARAM_BAND_LEVEL band %d"", param2);
            }
        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {
            p->status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32436341"");
                ALOGW(""\tERROR EQ_PARAM_CENTER_FREQ band %d"", param2);
            }
        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32247948"");
                ALOGW(""\tERROR EQ_PARAM_BAND_FREQ_RANGE band %d"", param2);
            }
","        if (param2 >= NUM_EQ_BANDS) {
        if (param2 >= NUM_EQ_BANDS) {
           p->status = -EINVAL;
        if (param2 >= NUM_EQ_BANDS) {
",,"@@ -265,8 +265,12 @@

     case EQ_PARAM_BAND_LEVEL:
 	ALOGV(""%s: EQ_PARAM_BAND_LEVEL"", __func__);
         param2 = *param_tmp;
-        if (param2 >= NUM_EQ_BANDS) {
+        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {
             p->status = -EINVAL;
+            if (param2 < 0) {
+                android_errorWriteLog(0x534e4554, ""32438598"");
+                ALOGW(""\tERROR EQ_PARAM_BAND_LEVEL band %d"", param2);
+            }
             break;
         }
         *(int16_t *)value = (int16_t)equalizer_get_band_level(eq_ctxt, param2);
@@ -275,8 +279,12 @@

     case EQ_PARAM_CENTER_FREQ:
 	ALOGV(""%s: EQ_PARAM_CENTER_FREQ"", __func__);
         param2 = *param_tmp;
-        if (param2 >= NUM_EQ_BANDS) {
-           p->status = -EINVAL;
+        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {
+            p->status = -EINVAL;
+            if (param2 < 0) {
+                android_errorWriteLog(0x534e4554, ""32436341"");
+                ALOGW(""\tERROR EQ_PARAM_CENTER_FREQ band %d"", param2);
+            }
             break;
         }
         *(int32_t *)value = equalizer_get_center_frequency(eq_ctxt, param2);
@@ -285,8 +293,12 @@

     case EQ_PARAM_BAND_FREQ_RANGE:
 	ALOGV(""%s: EQ_PARAM_BAND_FREQ_RANGE"", __func__);
         param2 = *param_tmp;
-        if (param2 >= NUM_EQ_BANDS) {
+        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {
             p->status = -EINVAL;
+            if (param2 < 0) {
+                android_errorWriteLog(0x534e4554, ""32247948"");
+                ALOGW(""\tERROR EQ_PARAM_BAND_FREQ_RANGE band %d"", param2);
+            }
            break;
         }
        equalizer_get_band_freq_range(eq_ctxt, param2, (uint32_t *)value,
",Android,https://android.googlesource.com/platform/hardware/qcom/audio/+/d72ea85c78a1a68bf99fd5804ad9784b4102fe57/,https://android.googlesource.com/platform/hardware/qcom/audio/+/d72ea85c78a1a68bf99fd5804ad9784b4102fe57%5E/,1,"int equalizer_get_parameter(effect_context_t *context, effect_param_t *p,
 uint32_t *size)
{
 equalizer_context_t *eq_ctxt = (equalizer_context_t *)context;
 int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);
 int32_t *param_tmp = (int32_t *)p->data;
 int32_t param = *param_tmp++;
 int32_t param2;
 char *name;
 void *value = p->data + voffset;
 int i;

    ALOGV(""%s"", __func__);

    p->status = 0;

 switch (param) {
 case EQ_PARAM_NUM_BANDS:
 case EQ_PARAM_CUR_PRESET:
 case EQ_PARAM_GET_NUM_OF_PRESETS:
 case EQ_PARAM_BAND_LEVEL:
 case EQ_PARAM_GET_BAND:
 if (p->vsize < sizeof(int16_t))
           p->status = -EINVAL;
        p->vsize = sizeof(int16_t);
 break;

 case EQ_PARAM_LEVEL_RANGE:
 if (p->vsize < 2 * sizeof(int16_t))
            p->status = -EINVAL;
        p->vsize = 2 * sizeof(int16_t);
 break;
 case EQ_PARAM_BAND_FREQ_RANGE:
 if (p->vsize < 2 * sizeof(int32_t))
            p->status = -EINVAL;
        p->vsize = 2 * sizeof(int32_t);
 break;

 case EQ_PARAM_CENTER_FREQ:
 if (p->vsize < sizeof(int32_t))
            p->status = -EINVAL;
        p->vsize = sizeof(int32_t);
 break;

 case EQ_PARAM_GET_PRESET_NAME:
 break;

 case EQ_PARAM_PROPERTIES:
 if (p->vsize < (2 + NUM_EQ_BANDS) * sizeof(uint16_t))
            p->status = -EINVAL;
        p->vsize = (2 + NUM_EQ_BANDS) * sizeof(uint16_t);
 break;

 default:
        p->status = -EINVAL;
 }

 *size = sizeof(effect_param_t) + voffset + p->vsize;

 if (p->status != 0)
 return 0;

 switch (param) {
 case EQ_PARAM_NUM_BANDS:
	ALOGV(""%s: EQ_PARAM_NUM_BANDS"", __func__);
 *(uint16_t *)value = (uint16_t)NUM_EQ_BANDS;
 break;

 case EQ_PARAM_LEVEL_RANGE:
	ALOGV(""%s: EQ_PARAM_LEVEL_RANGE"", __func__);
 *(int16_t *)value = -1500;
 *((int16_t *)value + 1) = 1500;
 break;


     case EQ_PARAM_BAND_LEVEL:
 	ALOGV(""%s: EQ_PARAM_BAND_LEVEL"", __func__);
         param2 = *param_tmp;
//flaw_line_below:
        if (param2 >= NUM_EQ_BANDS) {
//fix_flaw_line_below:
//        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {
             p->status = -EINVAL;
//fix_flaw_line_below:
//            if (param2 < 0) {
//fix_flaw_line_below:
//                android_errorWriteLog(0x534e4554, ""32438598"");
//fix_flaw_line_below:
//                ALOGW(""\tERROR EQ_PARAM_BAND_LEVEL band %d"", param2);
//fix_flaw_line_below:
//            }
             break;
         }
         *(int16_t *)value = (int16_t)equalizer_get_band_level(eq_ctxt, param2);
 break;


     case EQ_PARAM_CENTER_FREQ:
 	ALOGV(""%s: EQ_PARAM_CENTER_FREQ"", __func__);
         param2 = *param_tmp;
//flaw_line_below:
        if (param2 >= NUM_EQ_BANDS) {
//flaw_line_below:
           p->status = -EINVAL;
//fix_flaw_line_below:
//        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {
//fix_flaw_line_below:
//            p->status = -EINVAL;
//fix_flaw_line_below:
//            if (param2 < 0) {
//fix_flaw_line_below:
//                android_errorWriteLog(0x534e4554, ""32436341"");
//fix_flaw_line_below:
//                ALOGW(""\tERROR EQ_PARAM_CENTER_FREQ band %d"", param2);
//fix_flaw_line_below:
//            }
             break;
         }
         *(int32_t *)value = equalizer_get_center_frequency(eq_ctxt, param2);
 break;


     case EQ_PARAM_BAND_FREQ_RANGE:
 	ALOGV(""%s: EQ_PARAM_BAND_FREQ_RANGE"", __func__);
         param2 = *param_tmp;
//flaw_line_below:
        if (param2 >= NUM_EQ_BANDS) {
//fix_flaw_line_below:
//        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {
             p->status = -EINVAL;
//fix_flaw_line_below:
//            if (param2 < 0) {
//fix_flaw_line_below:
//                android_errorWriteLog(0x534e4554, ""32247948"");
//fix_flaw_line_below:
//                ALOGW(""\tERROR EQ_PARAM_BAND_FREQ_RANGE band %d"", param2);
//fix_flaw_line_below:
//            }
            break;
         }
        equalizer_get_band_freq_range(eq_ctxt, param2, (uint32_t *)value,
 ((uint32_t *)value + 1));
 break;

 case EQ_PARAM_GET_BAND:
	ALOGV(""%s: EQ_PARAM_GET_BAND"", __func__);
        param2 = *param_tmp;
 *(uint16_t *)value = (uint16_t)equalizer_get_band(eq_ctxt, param2);
 break;

 case EQ_PARAM_CUR_PRESET:
	ALOGV(""%s: EQ_PARAM_CUR_PRESET"", __func__);
 *(uint16_t *)value = (uint16_t)equalizer_get_preset(eq_ctxt);
 break;

 case EQ_PARAM_GET_NUM_OF_PRESETS:
	ALOGV(""%s: EQ_PARAM_GET_NUM_OF_PRESETS"", __func__);
 *(uint16_t *)value = (uint16_t)equalizer_get_num_presets(eq_ctxt);
 break;

 case EQ_PARAM_GET_PRESET_NAME:
	ALOGV(""%s: EQ_PARAM_GET_PRESET_NAME"", __func__);
        param2 = *param_tmp;
	ALOGV(""param2: %d"", param2);
 if (param2 >= equalizer_get_num_presets(eq_ctxt)) {
            p->status = -EINVAL;
 break;
 }
        name = (char *)value;
        strlcpy(name, equalizer_get_preset_name(eq_ctxt, param2), p->vsize - 1);
        name[p->vsize - 1] = 0;
        p->vsize = strlen(name) + 1;
 break;

 case EQ_PARAM_PROPERTIES: {
	ALOGV(""%s: EQ_PARAM_PROPERTIES"", __func__);
 int16_t *prop = (int16_t *)value;
        prop[0] = (int16_t)equalizer_get_preset(eq_ctxt);
        prop[1] = (int16_t)NUM_EQ_BANDS;
 for (i = 0; i < NUM_EQ_BANDS; i++) {
            prop[2 + i] = (int16_t)equalizer_get_band_level(eq_ctxt, i);
 }
 } break;

 default:
        p->status = -EINVAL;
 break;
 }

 return 0;
}
",188633,"int equalizer_get_parameter(effect_context_t *context, effect_param_t *p,
 uint32_t *size)
{
 equalizer_context_t *eq_ctxt = (equalizer_context_t *)context;
 int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);
 int32_t *param_tmp = (int32_t *)p->data;
 int32_t param = *param_tmp++;
 int32_t param2;
 char *name;
 void *value = p->data + voffset;
 int i;

    ALOGV(""%s"", __func__);

    p->status = 0;

 switch (param) {
 case EQ_PARAM_NUM_BANDS:
 case EQ_PARAM_CUR_PRESET:
 case EQ_PARAM_GET_NUM_OF_PRESETS:
 case EQ_PARAM_BAND_LEVEL:
 case EQ_PARAM_GET_BAND:
 if (p->vsize < sizeof(int16_t))
           p->status = -EINVAL;
        p->vsize = sizeof(int16_t);
 break;

 case EQ_PARAM_LEVEL_RANGE:
 if (p->vsize < 2 * sizeof(int16_t))
            p->status = -EINVAL;
        p->vsize = 2 * sizeof(int16_t);
 break;
 case EQ_PARAM_BAND_FREQ_RANGE:
 if (p->vsize < 2 * sizeof(int32_t))
            p->status = -EINVAL;
        p->vsize = 2 * sizeof(int32_t);
 break;

 case EQ_PARAM_CENTER_FREQ:
 if (p->vsize < sizeof(int32_t))
            p->status = -EINVAL;
        p->vsize = sizeof(int32_t);
 break;

 case EQ_PARAM_GET_PRESET_NAME:
 break;

 case EQ_PARAM_PROPERTIES:
 if (p->vsize < (2 + NUM_EQ_BANDS) * sizeof(uint16_t))
            p->status = -EINVAL;
        p->vsize = (2 + NUM_EQ_BANDS) * sizeof(uint16_t);
 break;

 default:
        p->status = -EINVAL;
 }

 *size = sizeof(effect_param_t) + voffset + p->vsize;

 if (p->status != 0)
 return 0;

 switch (param) {
 case EQ_PARAM_NUM_BANDS:
	ALOGV(""%s: EQ_PARAM_NUM_BANDS"", __func__);
 *(uint16_t *)value = (uint16_t)NUM_EQ_BANDS;
 break;

 case EQ_PARAM_LEVEL_RANGE:
	ALOGV(""%s: EQ_PARAM_LEVEL_RANGE"", __func__);
 *(int16_t *)value = -1500;
 *((int16_t *)value + 1) = 1500;
 break;


     case EQ_PARAM_BAND_LEVEL:
 	ALOGV(""%s: EQ_PARAM_BAND_LEVEL"", __func__);
         param2 = *param_tmp;
        if (param2 >= NUM_EQ_BANDS) {
             p->status = -EINVAL;
             break;
         }
         *(int16_t *)value = (int16_t)equalizer_get_band_level(eq_ctxt, param2);
 break;


     case EQ_PARAM_CENTER_FREQ:
 	ALOGV(""%s: EQ_PARAM_CENTER_FREQ"", __func__);
         param2 = *param_tmp;
        if (param2 >= NUM_EQ_BANDS) {
           p->status = -EINVAL;
             break;
         }
         *(int32_t *)value = equalizer_get_center_frequency(eq_ctxt, param2);
 break;


     case EQ_PARAM_BAND_FREQ_RANGE:
 	ALOGV(""%s: EQ_PARAM_BAND_FREQ_RANGE"", __func__);
         param2 = *param_tmp;
        if (param2 >= NUM_EQ_BANDS) {
             p->status = -EINVAL;
            break;
         }
        equalizer_get_band_freq_range(eq_ctxt, param2, (uint32_t *)value,
 ((uint32_t *)value + 1));
 break;

 case EQ_PARAM_GET_BAND:
	ALOGV(""%s: EQ_PARAM_GET_BAND"", __func__);
        param2 = *param_tmp;
 *(uint16_t *)value = (uint16_t)equalizer_get_band(eq_ctxt, param2);
 break;

 case EQ_PARAM_CUR_PRESET:
	ALOGV(""%s: EQ_PARAM_CUR_PRESET"", __func__);
 *(uint16_t *)value = (uint16_t)equalizer_get_preset(eq_ctxt);
 break;

 case EQ_PARAM_GET_NUM_OF_PRESETS:
	ALOGV(""%s: EQ_PARAM_GET_NUM_OF_PRESETS"", __func__);
 *(uint16_t *)value = (uint16_t)equalizer_get_num_presets(eq_ctxt);
 break;

 case EQ_PARAM_GET_PRESET_NAME:
	ALOGV(""%s: EQ_PARAM_GET_PRESET_NAME"", __func__);
        param2 = *param_tmp;
	ALOGV(""param2: %d"", param2);
 if (param2 >= equalizer_get_num_presets(eq_ctxt)) {
            p->status = -EINVAL;
 break;
 }
        name = (char *)value;
        strlcpy(name, equalizer_get_preset_name(eq_ctxt, param2), p->vsize - 1);
        name[p->vsize - 1] = 0;
        p->vsize = strlen(name) + 1;
 break;

 case EQ_PARAM_PROPERTIES: {
	ALOGV(""%s: EQ_PARAM_PROPERTIES"", __func__);
 int16_t *prop = (int16_t *)value;
        prop[0] = (int16_t)equalizer_get_preset(eq_ctxt);
        prop[1] = (int16_t)NUM_EQ_BANDS;
 for (i = 0; i < NUM_EQ_BANDS; i++) {
            prop[2 + i] = (int16_t)equalizer_get_band_level(eq_ctxt, i);
 }
 } break;

 default:
        p->status = -EINVAL;
 break;
 }

 return 0;
}
","int equalizer_get_parameter(effect_context_t *context, effect_param_t *p,
 uint32_t *size)
{
 equalizer_context_t *eq_ctxt = (equalizer_context_t *)context;
 int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);
 int32_t *param_tmp = (int32_t *)p->data;
 int32_t param = *param_tmp++;
 int32_t param2;
 char *name;
 void *value = p->data + voffset;
 int i;

    ALOGV(""%s"", __func__);

    p->status = 0;

 switch (param) {
 case EQ_PARAM_NUM_BANDS:
 case EQ_PARAM_CUR_PRESET:
 case EQ_PARAM_GET_NUM_OF_PRESETS:
 case EQ_PARAM_BAND_LEVEL:
 case EQ_PARAM_GET_BAND:
 if (p->vsize < sizeof(int16_t))
           p->status = -EINVAL;
        p->vsize = sizeof(int16_t);
 break;

 case EQ_PARAM_LEVEL_RANGE:
 if (p->vsize < 2 * sizeof(int16_t))
            p->status = -EINVAL;
        p->vsize = 2 * sizeof(int16_t);
 break;
 case EQ_PARAM_BAND_FREQ_RANGE:
 if (p->vsize < 2 * sizeof(int32_t))
            p->status = -EINVAL;
        p->vsize = 2 * sizeof(int32_t);
 break;

 case EQ_PARAM_CENTER_FREQ:
 if (p->vsize < sizeof(int32_t))
            p->status = -EINVAL;
        p->vsize = sizeof(int32_t);
 break;

 case EQ_PARAM_GET_PRESET_NAME:
 break;

 case EQ_PARAM_PROPERTIES:
 if (p->vsize < (2 + NUM_EQ_BANDS) * sizeof(uint16_t))
            p->status = -EINVAL;
        p->vsize = (2 + NUM_EQ_BANDS) * sizeof(uint16_t);
 break;

 default:
        p->status = -EINVAL;
 }

 *size = sizeof(effect_param_t) + voffset + p->vsize;

 if (p->status != 0)
 return 0;

 switch (param) {
 case EQ_PARAM_NUM_BANDS:
	ALOGV(""%s: EQ_PARAM_NUM_BANDS"", __func__);
 *(uint16_t *)value = (uint16_t)NUM_EQ_BANDS;
 break;

 case EQ_PARAM_LEVEL_RANGE:
	ALOGV(""%s: EQ_PARAM_LEVEL_RANGE"", __func__);
 *(int16_t *)value = -1500;
 *((int16_t *)value + 1) = 1500;
 break;


     case EQ_PARAM_BAND_LEVEL:
 	ALOGV(""%s: EQ_PARAM_BAND_LEVEL"", __func__);
         param2 = *param_tmp;
        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {
             p->status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32438598"");
                ALOGW(""\tERROR EQ_PARAM_BAND_LEVEL band %d"", param2);
            }
             break;
         }
         *(int16_t *)value = (int16_t)equalizer_get_band_level(eq_ctxt, param2);
 break;


     case EQ_PARAM_CENTER_FREQ:
 	ALOGV(""%s: EQ_PARAM_CENTER_FREQ"", __func__);
         param2 = *param_tmp;
        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {
            p->status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32436341"");
                ALOGW(""\tERROR EQ_PARAM_CENTER_FREQ band %d"", param2);
            }
             break;
         }
         *(int32_t *)value = equalizer_get_center_frequency(eq_ctxt, param2);
 break;


     case EQ_PARAM_BAND_FREQ_RANGE:
 	ALOGV(""%s: EQ_PARAM_BAND_FREQ_RANGE"", __func__);
         param2 = *param_tmp;
        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {
             p->status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32247948"");
                ALOGW(""\tERROR EQ_PARAM_BAND_FREQ_RANGE band %d"", param2);
            }
            break;
         }
        equalizer_get_band_freq_range(eq_ctxt, param2, (uint32_t *)value,
 ((uint32_t *)value + 1));
 break;

 case EQ_PARAM_GET_BAND:
	ALOGV(""%s: EQ_PARAM_GET_BAND"", __func__);
        param2 = *param_tmp;
 *(uint16_t *)value = (uint16_t)equalizer_get_band(eq_ctxt, param2);
 break;

 case EQ_PARAM_CUR_PRESET:
	ALOGV(""%s: EQ_PARAM_CUR_PRESET"", __func__);
 *(uint16_t *)value = (uint16_t)equalizer_get_preset(eq_ctxt);
 break;

 case EQ_PARAM_GET_NUM_OF_PRESETS:
	ALOGV(""%s: EQ_PARAM_GET_NUM_OF_PRESETS"", __func__);
 *(uint16_t *)value = (uint16_t)equalizer_get_num_presets(eq_ctxt);
 break;

 case EQ_PARAM_GET_PRESET_NAME:
	ALOGV(""%s: EQ_PARAM_GET_PRESET_NAME"", __func__);
        param2 = *param_tmp;
	ALOGV(""param2: %d"", param2);
 if (param2 >= equalizer_get_num_presets(eq_ctxt)) {
            p->status = -EINVAL;
 break;
 }
        name = (char *)value;
        strlcpy(name, equalizer_get_preset_name(eq_ctxt, param2), p->vsize - 1);
        name[p->vsize - 1] = 0;
        p->vsize = strlen(name) + 1;
 break;

 case EQ_PARAM_PROPERTIES: {
	ALOGV(""%s: EQ_PARAM_PROPERTIES"", __func__);
 int16_t *prop = (int16_t *)value;
        prop[0] = (int16_t)equalizer_get_preset(eq_ctxt);
        prop[1] = (int16_t)NUM_EQ_BANDS;
 for (i = 0; i < NUM_EQ_BANDS; i++) {
            prop[2 + i] = (int16_t)equalizer_get_band_level(eq_ctxt, i);
 }
 } break;

 default:
        p->status = -EINVAL;
 break;
 }

 return 0;
}
","The `equalizer_get_parameter` function retrieves various parameters related to an equalizer effect, using an `effect_context_t` and an `effect_param_t` structure to manage input and output data. It first calculates the required size for the output based on the parameter type and checks for validity. Depending on the requested parameter (e.g., number of bands, current preset, band levels, frequency ranges), it populates the output value accordingly, utilizing helper functions to fetch specific equalizer settings. The function also logs its operations and updates the status of the parameter request, returning zero upon completion.","The provided code defines a function that retrieves various parameters related to an audio equalizer effect. It processes input data to determine the requested parameter type and checks if the output buffer is adequately sized. Based on the parameter type, it populates the output with relevant information, such as the number of frequency bands, current preset, band levels, and frequency ranges. The function also handles error checking for invalid requests and logs its operations, ultimately returning a status indicating the success or failure of the parameter retrieval process.","The vulnerability in the original code stemmed from the lack of validation for negative indexes when accessing equalizer parameters, which could lead to out-of-bounds memory access and potential security issues. Specifically, the code did not check if the index value, retrieved from the input data, was less than zero before using it to access band levels or frequencies. The fix introduced checks to ensure that the index is non-negative and within valid bounds for all relevant cases, logging errors for negative values and preventing further processing if the index is invalid, thereby enhancing the security and stability of the function.","The vulnerability in the original code allowed for the possibility of negative index values when accessing equalizer parameters, which could lead to out-of-bounds memory access and potential exploitation. This lack of validation could result in unintended behavior or security breaches. The fix implemented checks to ensure that any index used to access parameters is non-negative and within the valid range. By adding these validations, the code now prevents processing of invalid indexes, thereby enhancing security and stability while also logging errors for any negative values encountered, which aids in debugging and monitoring.","The vulnerability was fixed by adding validation checks for the index values retrieved from the input data before they are used to access equalizer parameters. Specifically, the code now checks if the index, stored in the variable `param2`, is less than zero or exceeds the maximum number of bands, `NUM_EQ_BANDS`. If either condition is met, the status is set to an error value, and an error log is generated using `android_errorWriteLog`. This ensures that invalid indexes are not processed, preventing potential out-of-bounds memory access and enhancing the overall security of the function.","The vulnerability was addressed by implementing validation checks to ensure that index values used for accessing equalizer parameters are both non-negative and within the valid range. The code now verifies that the index does not fall below zero or exceed the maximum allowable limit before proceeding with any operations. If an invalid index is detected, the function sets an error status and logs an appropriate error message. This proactive approach prevents out-of-bounds memory access, thereby enhancing the security and stability of the code while ensuring that only valid requests are processed.","4,5","5,5","4,4","4, 5"
