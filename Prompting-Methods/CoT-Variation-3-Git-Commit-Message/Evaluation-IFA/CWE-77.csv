,Unnamed: 0.3,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,G1_Clarity_C3_C5,G2_Relevance_C3_C5,G3_Completeness_C3_C5,G4_Actionability_C3_C5,T1_Top_10_CWE_IDs,T2_Correctly_Found_CWE,T3_IFA
0,0,0,182309,182309,,Remote,Not required,Partial,CVE-2018-14354,https://www.cvedetails.com/cve/CVE-2018-14354/,CWE-77,Low,Partial,Partial,,2018-07-17,7.5,"An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with a manual subscription or unsubscription.",2019-10-02,Exec Code ,3,https://github.com/neomutt/neomutt/commit/95e80bf9ff10f68cb6443f760b85df4117cb15eb,95e80bf9ff10f68cb6443f760b85df4117cb15eb,Quote path in imap_subscribe,1,imap/imap.c,"{""sha"": ""f1706885620c7afd61bdc5bd03593557980bd0ab"", ""filename"": ""imap/imap.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/95e80bf9ff10f68cb6443f760b85df4117cb15eb/imap/imap.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/95e80bf9ff10f68cb6443f760b85df4117cb15eb/imap/imap.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/imap/imap.c?ref=95e80bf9ff10f68cb6443f760b85df4117cb15eb"", ""patch"": ""@@ -1709,6 +1709,7 @@ int imap_subscribe(char *path, bool subscribe)\n   char errstr[STRING];\n   struct Buffer err, token;\n   struct ImapMbox mx;\n+  size_t len = 0;\n \n   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n   {\n@@ -1729,7 +1730,8 @@ int imap_subscribe(char *path, bool subscribe)\n     mutt_buffer_init(&err);\n     err.data = errstr;\n     err.dsize = sizeof(errstr);\n-    snprintf(mbox, sizeof(mbox), \""%smailboxes \\\""%s\\\""\"", subscribe ? \""\"" : \""un\"", path);\n+\tlen = snprintf(mbox, sizeof(mbox), \""%smailboxes \"", subscribe ? \""\"" : \""un\"");\n+\timap_quote_string(mbox + len, sizeof(mbox) - len, path, true);\n     if (mutt_parse_rc_line(mbox, &token, &err))\n       mutt_debug(1, \""Error adding subscribed mailbox: %s\\n\"", errstr);\n     FREE(&token.data);""}","int imap_subscribe(char *path, bool subscribe)
{
  struct ImapData *idata = NULL;
  char buf[LONG_STRING];
  char mbox[LONG_STRING];
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
  size_t len = 0;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
    mutt_error(_(""Bad mailbox name""));
    return -1;
  }
  idata = imap_conn_find(&(mx.account), 0);
  if (!idata)
    goto fail;

  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));
  if (!*buf)
    mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf));

  if (ImapCheckSubscribed)
  {
    mutt_buffer_init(&token);
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);
  }

  if (subscribe)
    mutt_message(_(""Subscribing to %s...""), buf);
  else
    mutt_message(_(""Unsubscribing from %s...""), buf);
  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);

  snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox);

  if (imap_exec(idata, buf, 0) < 0)
    goto fail;

  imap_unmunge_mbox_name(idata, mx.mbox);
  if (subscribe)
    mutt_message(_(""Subscribed to %s""), mx.mbox);
  else
    mutt_message(_(""Unsubscribed from %s""), mx.mbox);
  FREE(&mx.mbox);
  return 0;

fail:
  FREE(&mx.mbox);
  return -1;
}
","int imap_subscribe(char *path, bool subscribe)
{
  struct ImapData *idata = NULL;
  char buf[LONG_STRING];
  char mbox[LONG_STRING];
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
    mutt_error(_(""Bad mailbox name""));
    return -1;
  }
  idata = imap_conn_find(&(mx.account), 0);
  if (!idata)
    goto fail;

  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));
  if (!*buf)
    mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf));

  if (ImapCheckSubscribed)
  {
    mutt_buffer_init(&token);
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
    snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);
  }

  if (subscribe)
    mutt_message(_(""Subscribing to %s...""), buf);
  else
    mutt_message(_(""Unsubscribing from %s...""), buf);
  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);

  snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox);

  if (imap_exec(idata, buf, 0) < 0)
    goto fail;

  imap_unmunge_mbox_name(idata, mx.mbox);
  if (subscribe)
    mutt_message(_(""Subscribed to %s""), mx.mbox);
  else
    mutt_message(_(""Unsubscribed from %s""), mx.mbox);
  FREE(&mx.mbox);
  return 0;

fail:
  FREE(&mx.mbox);
  return -1;
}
",C,"  size_t len = 0;
	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
","    snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
",,"@@ -1709,6 +1709,7 @@ int imap_subscribe(char *path, bool subscribe)
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
+  size_t len = 0;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
@@ -1729,7 +1730,8 @@ int imap_subscribe(char *path, bool subscribe)
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
-    snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
+	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
+	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);",neomutt,95e80bf9ff10f68cb6443f760b85df4117cb15eb,51c4efb8ccae3dab550fe8909fc76fb2462f0a89,1,"int imap_subscribe(char *path, bool subscribe)
{
  struct ImapData *idata = NULL;
  char buf[LONG_STRING];
  char mbox[LONG_STRING];
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
//fix_flaw_line_below:
//  size_t len = 0;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
    mutt_error(_(""Bad mailbox name""));
    return -1;
  }
  idata = imap_conn_find(&(mx.account), 0);
  if (!idata)
    goto fail;

  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));
  if (!*buf)
    mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf));

  if (ImapCheckSubscribed)
  {
    mutt_buffer_init(&token);
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
//flaw_line_below:
    snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
//fix_flaw_line_below:
//	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
//fix_flaw_line_below:
//	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);
  }

  if (subscribe)
    mutt_message(_(""Subscribing to %s...""), buf);
  else
    mutt_message(_(""Unsubscribing from %s...""), buf);
  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);

  snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox);

  if (imap_exec(idata, buf, 0) < 0)
    goto fail;

  imap_unmunge_mbox_name(idata, mx.mbox);
  if (subscribe)
    mutt_message(_(""Subscribed to %s""), mx.mbox);
  else
    mutt_message(_(""Unsubscribed from %s""), mx.mbox);
  FREE(&mx.mbox);
  return 0;

fail:
  FREE(&mx.mbox);
  return -1;
}
",182309,"int imap_subscribe(char *path, bool subscribe)
{
  struct ImapData *idata = NULL;
  char buf[LONG_STRING];
  char mbox[LONG_STRING];
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
    mutt_error(_(""Bad mailbox name""));
    return -1;
  }
  idata = imap_conn_find(&(mx.account), 0);
  if (!idata)
    goto fail;

  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));
  if (!*buf)
    mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf));

  if (ImapCheckSubscribed)
  {
    mutt_buffer_init(&token);
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
    snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);
  }

  if (subscribe)
    mutt_message(_(""Subscribing to %s...""), buf);
  else
    mutt_message(_(""Unsubscribing from %s...""), buf);
  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);

  snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox);

  if (imap_exec(idata, buf, 0) < 0)
    goto fail;

  imap_unmunge_mbox_name(idata, mx.mbox);
  if (subscribe)
    mutt_message(_(""Subscribed to %s""), mx.mbox);
  else
    mutt_message(_(""Unsubscribed from %s""), mx.mbox);
  FREE(&mx.mbox);
  return 0;

fail:
  FREE(&mx.mbox);
  return -1;
}
","int imap_subscribe(char *path, bool subscribe)
{
  struct ImapData *idata = NULL;
  char buf[LONG_STRING];
  char mbox[LONG_STRING];
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
  size_t len = 0;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
    mutt_error(_(""Bad mailbox name""));
    return -1;
  }
  idata = imap_conn_find(&(mx.account), 0);
  if (!idata)
    goto fail;

  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));
  if (!*buf)
    mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf));

  if (ImapCheckSubscribed)
  {
    mutt_buffer_init(&token);
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);
  }

  if (subscribe)
    mutt_message(_(""Subscribing to %s...""), buf);
  else
    mutt_message(_(""Unsubscribing from %s...""), buf);
  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);

  snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox);

  if (imap_exec(idata, buf, 0) < 0)
    goto fail;

  imap_unmunge_mbox_name(idata, mx.mbox);
  if (subscribe)
    mutt_message(_(""Subscribed to %s""), mx.mbox);
  else
    mutt_message(_(""Unsubscribed from %s""), mx.mbox);
  FREE(&mx.mbox);
  return 0;

fail:
  FREE(&mx.mbox);
  return -1;
}
","The `imap_subscribe` function manages the subscription status of an IMAP mailbox, allowing users to either subscribe to or unsubscribe from a specified mailbox path. It first validates the mailbox path and retrieves the associated IMAP connection data. If the mailbox is valid, it constructs a command string for subscribing or unsubscribing based on the `subscribe` boolean parameter. The function then executes the command using the IMAP protocol and provides user feedback through messages indicating the action taken. If any errors occur during the process, appropriate error handling is performed, and the function returns -1; otherwise, it returns 0 upon success.","The code defines a function that manages the subscription status of a mailbox in an email client using the IMAP protocol. It begins by validating the provided mailbox path and retrieving the necessary connection data. If the mailbox is valid, it constructs a command to either subscribe to or unsubscribe from the mailbox based on a specified parameter. The function then executes this command and provides feedback to the user about the action taken. In case of any errors during the process, it handles them appropriately and returns a failure status; otherwise, it indicates success.","The vulnerability in the original code stemmed from the lack of proper handling of user input for the mailbox path, which could lead to command injection or malformed commands when constructing the subscription request. Specifically, the code directly concatenated the user-provided path into the command string without sanitization. The fix introduced a new function to quote the mailbox path safely, ensuring that any special characters in the user input are properly escaped before being included in the command. This change mitigates the risk of injection attacks and ensures that the command is constructed correctly, enhancing overall security.","The vulnerability in the original code arose from inadequate sanitization of user input for the mailbox path, which could allow for command injection or the creation of malformed commands. This oversight meant that malicious input could manipulate the command sent to the server, potentially leading to unauthorized actions. The fix addressed this issue by implementing a quoting mechanism for the mailbox path, ensuring that any special characters in the user input are properly escaped before being included in the command. This enhancement effectively mitigates the risk of injection attacks and ensures the integrity of the command construction process.","The vulnerability was fixed by introducing a quoting mechanism for the mailbox path within the `imap_subscribe` function. Specifically, the code now uses the `imap_quote_string` function to safely escape any special characters in the user-provided path before appending it to the command string. This change occurs after constructing the initial part of the command in the `mbox` variable, ensuring that the path is properly formatted. By sanitizing the input in this manner, the risk of command injection is significantly reduced, thereby enhancing the security of the subscription process.","The vulnerability was addressed by implementing a mechanism to properly escape and quote the user-provided mailbox path before it is included in the command string. This enhancement ensures that any special characters in the input are handled correctly, preventing potential command injection or malformed commands. By sanitizing the input in this way, the code now constructs the command more securely, thereby mitigating the risk of unauthorized actions or errors during execution. This fix significantly improves the overall security of the subscription process by ensuring that user input does not compromise the integrity of the commands sent to the server.","5,4","5,5","4,4","5,5","CWE-78, CWE-77, CWE-116, CWE-74, CWE-79, CWE-89, CWE-157, CWE-150, CWE-20, CWE-75",N,-1
1,1,1,182848,182848,,Local,Not required,,CVE-2019-11884,https://www.cvedetails.com/cve/CVE-2019-11884/,CWE-77,Low,Partial,,,2019-05-10,2.1,"The do_hidp_sock_ioctl function in net/bluetooth/hidp/sock.c in the Linux kernel before 5.0.15 allows a local user to obtain potentially sensitive information from kernel stack memory via a HIDPCONNADD command, because a name field may not end with a '0' character.",2019-05-31,+Info ,1,https://github.com/torvalds/linux/commit/a1616a5ac99ede5d605047a9012481ce7ff18b16,a1616a5ac99ede5d605047a9012481ce7ff18b16,"Bluetooth: hidp: fix buffer overflow

Struct ca is copied from userspace. It is not checked whether the ""name""
field is NULL terminated, which allows local users to obtain potentially
sensitive information from kernel stack memory, via a HIDPCONNADD command.

This vulnerability is similar to CVE-2011-1079.

Signed-off-by: Young Xiao <YangX92@hotmail.com>
Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
Cc: stable@vger.kernel.org",0,net/bluetooth/hidp/sock.c,"{""sha"": ""2151913892ce8705d093a96fa65c3888e8a6dbb1"", ""filename"": ""net/bluetooth/hidp/sock.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/a1616a5ac99ede5d605047a9012481ce7ff18b16/net/bluetooth/hidp/sock.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a1616a5ac99ede5d605047a9012481ce7ff18b16/net/bluetooth/hidp/sock.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/bluetooth/hidp/sock.c?ref=a1616a5ac99ede5d605047a9012481ce7ff18b16"", ""patch"": ""@@ -75,6 +75,7 @@ static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user\n \t\t\tsockfd_put(csock);\n \t\t\treturn err;\n \t\t}\n+\t\tca.name[sizeof(ca.name)-1] = 0;\n \n \t\terr = hidp_connection_add(&ca, csock, isock);\n \t\tif (!err && copy_to_user(argp, &ca, sizeof(ca)))""}","static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)
{
	struct hidp_connadd_req ca;
	struct hidp_conndel_req cd;
	struct hidp_connlist_req cl;
	struct hidp_conninfo ci;
	struct socket *csock;
	struct socket *isock;
	int err;

	BT_DBG(""cmd %x arg %p"", cmd, argp);

	switch (cmd) {
	case HIDPCONNADD:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&ca, argp, sizeof(ca)))
			return -EFAULT;

		csock = sockfd_lookup(ca.ctrl_sock, &err);
		if (!csock)
			return err;

		isock = sockfd_lookup(ca.intr_sock, &err);
		if (!isock) {
 			sockfd_put(csock);
 			return err;
 		}
		ca.name[sizeof(ca.name)-1] = 0;
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))
			err = -EFAULT;

		sockfd_put(csock);
		sockfd_put(isock);

		return err;

	case HIDPCONNDEL:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&cd, argp, sizeof(cd)))
			return -EFAULT;

		return hidp_connection_del(&cd);

	case HIDPGETCONNLIST:
		if (copy_from_user(&cl, argp, sizeof(cl)))
			return -EFAULT;

		if (cl.cnum <= 0)
			return -EINVAL;

		err = hidp_get_connlist(&cl);
		if (!err && copy_to_user(argp, &cl, sizeof(cl)))
			return -EFAULT;

		return err;

	case HIDPGETCONNINFO:
		if (copy_from_user(&ci, argp, sizeof(ci)))
			return -EFAULT;

		err = hidp_get_conninfo(&ci);
		if (!err && copy_to_user(argp, &ci, sizeof(ci)))
			return -EFAULT;

		return err;
	}

	return -EINVAL;
}
","static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)
{
	struct hidp_connadd_req ca;
	struct hidp_conndel_req cd;
	struct hidp_connlist_req cl;
	struct hidp_conninfo ci;
	struct socket *csock;
	struct socket *isock;
	int err;

	BT_DBG(""cmd %x arg %p"", cmd, argp);

	switch (cmd) {
	case HIDPCONNADD:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&ca, argp, sizeof(ca)))
			return -EFAULT;

		csock = sockfd_lookup(ca.ctrl_sock, &err);
		if (!csock)
			return err;

		isock = sockfd_lookup(ca.intr_sock, &err);
		if (!isock) {
 			sockfd_put(csock);
 			return err;
 		}
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))
			err = -EFAULT;

		sockfd_put(csock);
		sockfd_put(isock);

		return err;

	case HIDPCONNDEL:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&cd, argp, sizeof(cd)))
			return -EFAULT;

		return hidp_connection_del(&cd);

	case HIDPGETCONNLIST:
		if (copy_from_user(&cl, argp, sizeof(cl)))
			return -EFAULT;

		if (cl.cnum <= 0)
			return -EINVAL;

		err = hidp_get_connlist(&cl);
		if (!err && copy_to_user(argp, &cl, sizeof(cl)))
			return -EFAULT;

		return err;

	case HIDPGETCONNINFO:
		if (copy_from_user(&ci, argp, sizeof(ci)))
			return -EFAULT;

		err = hidp_get_conninfo(&ci);
		if (!err && copy_to_user(argp, &ci, sizeof(ci)))
			return -EFAULT;

		return err;
	}

	return -EINVAL;
}
",C,"		ca.name[sizeof(ca.name)-1] = 0;
",,,"@@ -75,6 +75,7 @@ static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user
 			sockfd_put(csock);
 			return err;
 		}
+		ca.name[sizeof(ca.name)-1] = 0;
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))",linux,a1616a5ac99ede5d605047a9012481ce7ff18b16,73623340546cceff421c95b53abd8140d1f2b2a2,1,"static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)
{
	struct hidp_connadd_req ca;
	struct hidp_conndel_req cd;
	struct hidp_connlist_req cl;
	struct hidp_conninfo ci;
	struct socket *csock;
	struct socket *isock;
	int err;

	BT_DBG(""cmd %x arg %p"", cmd, argp);

	switch (cmd) {
	case HIDPCONNADD:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&ca, argp, sizeof(ca)))
			return -EFAULT;

		csock = sockfd_lookup(ca.ctrl_sock, &err);
		if (!csock)
			return err;

		isock = sockfd_lookup(ca.intr_sock, &err);
		if (!isock) {
 			sockfd_put(csock);
 			return err;
 		}
//fix_flaw_line_below:
//		ca.name[sizeof(ca.name)-1] = 0;
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))
			err = -EFAULT;

		sockfd_put(csock);
		sockfd_put(isock);

		return err;

	case HIDPCONNDEL:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&cd, argp, sizeof(cd)))
			return -EFAULT;

		return hidp_connection_del(&cd);

	case HIDPGETCONNLIST:
		if (copy_from_user(&cl, argp, sizeof(cl)))
			return -EFAULT;

		if (cl.cnum <= 0)
			return -EINVAL;

		err = hidp_get_connlist(&cl);
		if (!err && copy_to_user(argp, &cl, sizeof(cl)))
			return -EFAULT;

		return err;

	case HIDPGETCONNINFO:
		if (copy_from_user(&ci, argp, sizeof(ci)))
			return -EFAULT;

		err = hidp_get_conninfo(&ci);
		if (!err && copy_to_user(argp, &ci, sizeof(ci)))
			return -EFAULT;

		return err;
	}

	return -EINVAL;
}
",182848,"static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)
{
	struct hidp_connadd_req ca;
	struct hidp_conndel_req cd;
	struct hidp_connlist_req cl;
	struct hidp_conninfo ci;
	struct socket *csock;
	struct socket *isock;
	int err;

	BT_DBG(""cmd %x arg %p"", cmd, argp);

	switch (cmd) {
	case HIDPCONNADD:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&ca, argp, sizeof(ca)))
			return -EFAULT;

		csock = sockfd_lookup(ca.ctrl_sock, &err);
		if (!csock)
			return err;

		isock = sockfd_lookup(ca.intr_sock, &err);
		if (!isock) {
 			sockfd_put(csock);
 			return err;
 		}
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))
			err = -EFAULT;

		sockfd_put(csock);
		sockfd_put(isock);

		return err;

	case HIDPCONNDEL:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&cd, argp, sizeof(cd)))
			return -EFAULT;

		return hidp_connection_del(&cd);

	case HIDPGETCONNLIST:
		if (copy_from_user(&cl, argp, sizeof(cl)))
			return -EFAULT;

		if (cl.cnum <= 0)
			return -EINVAL;

		err = hidp_get_connlist(&cl);
		if (!err && copy_to_user(argp, &cl, sizeof(cl)))
			return -EFAULT;

		return err;

	case HIDPGETCONNINFO:
		if (copy_from_user(&ci, argp, sizeof(ci)))
			return -EFAULT;

		err = hidp_get_conninfo(&ci);
		if (!err && copy_to_user(argp, &ci, sizeof(ci)))
			return -EFAULT;

		return err;
	}

	return -EINVAL;
}
","static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)
{
	struct hidp_connadd_req ca;
	struct hidp_conndel_req cd;
	struct hidp_connlist_req cl;
	struct hidp_conninfo ci;
	struct socket *csock;
	struct socket *isock;
	int err;

	BT_DBG(""cmd %x arg %p"", cmd, argp);

	switch (cmd) {
	case HIDPCONNADD:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&ca, argp, sizeof(ca)))
			return -EFAULT;

		csock = sockfd_lookup(ca.ctrl_sock, &err);
		if (!csock)
			return err;

		isock = sockfd_lookup(ca.intr_sock, &err);
		if (!isock) {
 			sockfd_put(csock);
 			return err;
 		}
		ca.name[sizeof(ca.name)-1] = 0;
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))
			err = -EFAULT;

		sockfd_put(csock);
		sockfd_put(isock);

		return err;

	case HIDPCONNDEL:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&cd, argp, sizeof(cd)))
			return -EFAULT;

		return hidp_connection_del(&cd);

	case HIDPGETCONNLIST:
		if (copy_from_user(&cl, argp, sizeof(cl)))
			return -EFAULT;

		if (cl.cnum <= 0)
			return -EINVAL;

		err = hidp_get_connlist(&cl);
		if (!err && copy_to_user(argp, &cl, sizeof(cl)))
			return -EFAULT;

		return err;

	case HIDPGETCONNINFO:
		if (copy_from_user(&ci, argp, sizeof(ci)))
			return -EFAULT;

		err = hidp_get_conninfo(&ci);
		if (!err && copy_to_user(argp, &ci, sizeof(ci)))
			return -EFAULT;

		return err;
	}

	return -EINVAL;
}
","The `do_hidp_sock_ioctl` function handles various IOCTL commands related to Bluetooth HID (Human Interface Device) connections. It processes commands such as adding a connection (`HIDPCONNADD`), deleting a connection (`HIDPCONNDEL`), retrieving a list of connections (`HIDPGETCONNLIST`), and fetching connection information (`HIDPGETCONNINFO`). The function checks for administrative privileges, copies data between user and kernel space, and manages socket references. It returns appropriate error codes for permission issues, memory access violations, or invalid parameters, ensuring robust interaction with HIDP socket operations while maintaining system security and stability.","The provided code implements a function that manages various operations related to Bluetooth HID connections through IOCTL commands. It allows for adding and deleting connections, as well as retrieving lists and details of existing connections. The function ensures that only users with the appropriate administrative privileges can perform certain actions. It handles data transfer between user space and kernel space, checking for errors during these operations. Additionally, it maintains socket references to ensure proper resource management and returns relevant error codes for issues such as permission denial, memory access failures, or invalid input parameters.","The vulnerability in the original code stemmed from the lack of a null termination check for the ""name"" field in the structure copied from user space, which could lead to a buffer overflow. This oversight allowed local users to potentially access sensitive information from the kernel stack memory when executing the HIDPCONNADD command. The fix introduced a line that explicitly sets the last character of the ""name"" field to zero, ensuring it is properly null-terminated. This change mitigates the risk of buffer overflow by preventing the exposure of uninitialized or sensitive data from the kernel memory.","The vulnerability in the original code arose from the failure to ensure that a specific field copied from user space was null-terminated, which could lead to a buffer overflow. This oversight allowed local users to potentially access sensitive information from kernel memory when executing a specific command. The fix addressed this issue by explicitly setting the last character of the field to zero, ensuring it is properly null-terminated. This modification effectively prevents the overflow, safeguarding against unauthorized access to sensitive data and enhancing the overall security of the system.","The vulnerability was fixed by adding a line of code that explicitly sets the last character of the ""name"" field in the structure to zero, ensuring it is null-terminated. This change was implemented right after the user-supplied data was copied into the structure, preventing any potential overflow when the ""name"" field is processed. By ensuring that the ""name"" field is properly terminated, the fix mitigates the risk of exposing sensitive information from the kernel stack memory, thereby enhancing the security of the HIDPCONNADD command and preventing unauthorized access to kernel data.","The vulnerability was addressed by implementing a safeguard that ensures a specific field copied from user space is properly null-terminated. This was achieved by explicitly setting the last character of the field to zero after the data was transferred. This modification prevents any potential buffer overflow that could allow unauthorized access to sensitive information stored in kernel memory. By ensuring the field is correctly terminated, the fix enhances the security of the command processing, effectively mitigating the risk of exposing sensitive data and protecting the integrity of the system.","4,4","3, 3","4,4","4,4","CWE-119, CWE-120, CWE-170, CWE-788, CWE-121, CWE-20, CWE-125, CWE-787, CWE-126, CWE-131",N,-1
2,2,2,187046,187046,,Local,Not required,,CVE-2019-5804,https://www.cvedetails.com/cve/CVE-2019-5804/,CWE-77,Low,,Partial,,2019-05-23,2.1,Incorrect command line processing in Chrome in Google Chrome prior to 73.0.3683.75 allowed a local attacker to perform domain spoofing via a crafted domain name.,2019-06-28,,4,https://github.com/chromium/chromium/commit/08965161257ab9aeef9a3548c1cd1a44525dc562,08965161257ab9aeef9a3548c1cd1a44525dc562,"Ignore switches following ""--"" when parsing a command line.

BUG=933004
R=wfh@chromium.org

Change-Id: I911be4cbfc38a4d41dec85d85f7fe0f50ddca392
Reviewed-on: https://chromium-review.googlesource.com/c/1481210
Auto-Submit: Greg Thompson <grt@chromium.org>
Commit-Queue: Julian Pastarmov <pastarmovj@chromium.org>
Reviewed-by: Julian Pastarmov <pastarmovj@chromium.org>
Cr-Commit-Position: refs/heads/master@{#634604}",2,chrome/install_static/install_util.cc,"{""sha"": ""7c7b6c5343bb05ebea63212a0c00fdfbd675efc7"", ""filename"": ""chrome/install_static/install_util.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/install_static/install_util.cc?ref=08965161257ab9aeef9a3548c1cd1a44525dc562"", ""patch"": ""@@ -847,13 +847,15 @@ std::vector<std::wstring> TokenizeCommandLineToArray(\n \n std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,\n                                            const std::wstring& switch_name) {\n+  static constexpr wchar_t kSwitchTerminator[] = L\""--\"";\n   assert(!command_line.empty());\n   assert(!switch_name.empty());\n \n   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);\n   std::wstring switch_with_equal = L\""--\"" + switch_name + L\""=\"";\n-  for (size_t i = 1; i < as_array.size(); ++i) {\n-    const std::wstring& arg = as_array[i];\n+  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);\n+  for (auto scan = as_array.cbegin(); scan != end; ++scan) {\n+    const std::wstring& arg = *scan;\n     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)\n       return arg.substr(switch_with_equal.size());\n   }""}<_**next**_>{""sha"": ""27a55e3bd94ca5a377ca300fe5240874f4efdcf5"", ""filename"": ""chrome/install_static/install_util.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/install_static/install_util.h?ref=08965161257ab9aeef9a3548c1cd1a44525dc562"", ""patch"": ""@@ -275,9 +275,10 @@ std::vector<std::wstring> TokenizeString16(const std::wstring& str,\n std::vector<std::wstring> TokenizeCommandLineToArray(\n     const std::wstring& command_line);\n \n-// We assume that the command line |command_line| contains multiple switches\n-// with the format --<switch name>=<switch value>. This function returns the\n-// value of the |switch_name| passed in.\n+// Returns the value of a switch of the form \""--<switch name>=<switch value>\"" in\n+// |command_line|. An empty switch in |command_line| (\""--\"") denotes the end of\n+// switches and the beginning of args. Anything of the form --<switch\n+// name>=<switch value> following \""--\"" is ignored.\n std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,\n                                            const std::wstring& switch_name);\n ""}<_**next**_>{""sha"": ""a05794655ddd653123941c14ce20076e5c07c79d"", ""filename"": ""chrome/install_static/install_util_unittest.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/08965161257ab9aeef9a3548c1cd1a44525dc562/chrome/install_static/install_util_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/install_static/install_util_unittest.cc?ref=08965161257ab9aeef9a3548c1cd1a44525dc562"", ""patch"": ""@@ -96,6 +96,10 @@ TEST(InstallStaticTest, GetSwitchValueFromCommandLineTest) {\n   // Bad command line without closing quotes. Should not crash.\n   value = GetSwitchValueFromCommandLine(L\""\\\""blah --type=\\t\\t\\t\"", L\""type\"");\n   EXPECT_TRUE(value.empty());\n+\n+  // Anything following \""--\"" should be considered args and therfore ignored.\n+  value = GetSwitchValueFromCommandLine(L\""blah -- --type=bleh\"", L\""type\"");\n+  EXPECT_TRUE(value.empty());\n }\n \n TEST(InstallStaticTest, SpacesAndQuotesInCommandLineArguments) {""}"," std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
  static constexpr wchar_t kSwitchTerminator[] = L""--"";
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
    const std::wstring& arg = *scan;
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }

  return std::wstring();
}
"," std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
  for (size_t i = 1; i < as_array.size(); ++i) {
    const std::wstring& arg = as_array[i];
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }

  return std::wstring();
}
",C,"  static constexpr wchar_t kSwitchTerminator[] = L""--"";
  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
    const std::wstring& arg = *scan;
","  for (size_t i = 1; i < as_array.size(); ++i) {
    const std::wstring& arg = as_array[i];
",,"@@ -847,13 +847,15 @@ std::vector<std::wstring> TokenizeCommandLineToArray(
 
 std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
+  static constexpr wchar_t kSwitchTerminator[] = L""--"";
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
-  for (size_t i = 1; i < as_array.size(); ++i) {
-    const std::wstring& arg = as_array[i];
+  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
+  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
+    const std::wstring& arg = *scan;
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }",Chrome,08965161257ab9aeef9a3548c1cd1a44525dc562,fba5eff0d4a6451e2d4a925c4f47973fbf10bb91,1," std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
//fix_flaw_line_below:
//  static constexpr wchar_t kSwitchTerminator[] = L""--"";
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
//flaw_line_below:
  for (size_t i = 1; i < as_array.size(); ++i) {
//flaw_line_below:
    const std::wstring& arg = as_array[i];
//fix_flaw_line_below:
//  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
//fix_flaw_line_below:
//  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
//fix_flaw_line_below:
//    const std::wstring& arg = *scan;
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }

  return std::wstring();
}
",187046," std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
  for (size_t i = 1; i < as_array.size(); ++i) {
    const std::wstring& arg = as_array[i];
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }

  return std::wstring();
}
"," std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
  static constexpr wchar_t kSwitchTerminator[] = L""--"";
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
    const std::wstring& arg = *scan;
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }

  return std::wstring();
}
","The provided code defines a function `GetSwitchValueFromCommandLine` that extracts the value associated with a specified command-line switch from a given command line string. It first checks that neither the command line nor the switch name is empty. The function then tokenizes the command line into an array of arguments and constructs a string representing the switch in the format `--switch_name=`. It iterates through the tokenized arguments, comparing each one to the constructed switch string. If a match is found, it returns the value following the equal sign; otherwise, it returns an empty string.","The code defines a function that retrieves the value associated with a specific command-line option from a provided command line string. It begins by ensuring that both the command line and the option name are not empty. The function then splits the command line into individual arguments and constructs a string that represents the desired option format. It iterates through the list of arguments, checking for a match with the constructed option string. If a match is found, it extracts and returns the value that follows the equal sign; if no match is found, it returns an empty string.","The vulnerability in the original code arises from the lack of handling for command-line switches that appear after a terminator, specifically `--`, which indicates the end of valid options. This oversight could lead to unintended behavior or security issues if such switches are processed. The fixed code addresses this vulnerability by introducing a static constant for the switch terminator and using `std::find` to locate it in the tokenized argument array. The iteration now only scans arguments before the terminator, ensuring that any switches following `--` are ignored, thus enhancing the robustness of the command-line parsing.","The vulnerability in the original code stems from its failure to account for command-line switches that appear after a specific terminator, which indicates the end of valid options. This oversight could lead to the processing of unintended or potentially harmful switches, compromising the application's security and functionality. The fixed code addresses this issue by implementing a mechanism to identify the terminator and limit the parsing to only those switches that precede it. This ensures that any switches following the terminator are ignored, thereby enhancing the integrity and security of the command-line parsing process.","The vulnerability was fixed by introducing a static constant for the switch terminator and using `std::find` to locate it within the tokenized argument array. In the updated code, the iteration over the arguments is limited to those before the terminator, as indicated by the `end` iterator. This change ensures that the parsing process only considers valid switches, effectively ignoring any switches that appear after the `--` terminator. By restricting the scanning to the valid range, the code prevents unintended processing of potentially harmful or irrelevant command-line options.","The vulnerability was fixed by implementing a mechanism to identify a specific terminator that indicates the end of valid command-line options. The updated code now searches for this terminator and restricts the parsing process to only those options that appear before it. By doing so, any switches that follow the terminator are effectively ignored, preventing the processing of unintended or potentially harmful options. This change enhances the security and reliability of the command-line parsing by ensuring that only appropriate and expected switches are considered during the execution of the program.","5,4","5,5","4,3","4,4","CWE-749, CWE-74, CWE-78, CWE-20, CWE-114, CWE-88, CWE-77, CWE-732, CWE-94, CWE-73",N,-1
