,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,T1_Top_10_CWE_IDs,T2_Correctly_Found_CWE,T3_IFA
0,0,46443,46443,,Local,Not required,Complete,CVE-2014-7822,https://www.cvedetails.com/cve/CVE-2014-7822/,CWE-264,Low,Complete,Complete,,2015-03-16,7.2,"The implementation of certain splice_write file operations in the Linux kernel before 3.16 does not enforce a restriction on the maximum size of a single file, which allows local users to cause a denial of service (system crash) or possibly have unspecified other impact via a crafted splice system call, as demonstrated by use of a file descriptor associated with an ext4 filesystem.",2017-01-02,DoS ,0,https://github.com/torvalds/linux/commit/8d0207652cbe27d1f962050737848e5ad4671958,8d0207652cbe27d1f962050737848e5ad4671958,"->splice_write() via ->write_iter()

iter_file_splice_write() - a ->splice_write() instance that gathers the
pipe buffers, builds a bio_vec-based iov_iter covering those and feeds
it to ->write_iter().  A bunch of simple cases coverted to that...

[AV: fixed the braino spotted by Cyrill]

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",0,fs/xfs/xfs_file.c,"{""sha"": ""e68e150b1b163c15da172cfa60ed832d14841495"", ""filename"": ""fs/block_dev.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/block_dev.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/block_dev.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/block_dev.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -1583,7 +1583,7 @@ const struct file_operations def_blk_fops = {\n \t.compat_ioctl\t= compat_blkdev_ioctl,\n #endif\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };\n \n int ioctl_by_bdev(struct block_device *bdev, unsigned cmd, unsigned long arg)""}<_**next**_>{""sha"": ""71bf8e4fb5d427c660e9913a57054dec59f99dfc"", ""filename"": ""fs/exofs/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/exofs/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/exofs/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/exofs/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -77,7 +77,7 @@ const struct file_operations exofs_file_operations = {\n \t.fsync\t\t= exofs_file_fsync,\n \t.flush\t\t= exofs_flush,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };\n \n const struct inode_operations exofs_file_inode_operations = {""}<_**next**_>{""sha"": ""7c87b22a7228c4ce9ed3c915c64283e2aa72a328"", ""filename"": ""fs/ext2/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/ext2/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/ext2/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext2/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -75,7 +75,7 @@ const struct file_operations ext2_file_operations = {\n \t.release\t= ext2_release_file,\n \t.fsync\t\t= ext2_fsync,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };\n \n #ifdef CONFIG_EXT2_FS_XIP""}<_**next**_>{""sha"": ""a062fa1e1b113e56e7545bb4c6bac7ac1bf7d741"", ""filename"": ""fs/ext3/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/ext3/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/ext3/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext3/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -63,7 +63,7 @@ const struct file_operations ext3_file_operations = {\n \t.release\t= ext3_release_file,\n \t.fsync\t\t= ext3_sync_file,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };\n \n const struct inode_operations ext3_file_inode_operations = {""}<_**next**_>{""sha"": ""708aad7681991368262332520f09f5490af848de"", ""filename"": ""fs/ext4/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/ext4/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/ext4/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -599,7 +599,7 @@ const struct file_operations ext4_file_operations = {\n \t.release\t= ext4_release_file,\n \t.fsync\t\t= ext4_sync_file,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.fallocate\t= ext4_fallocate,\n };\n ""}<_**next**_>{""sha"": ""e4ba4b93f96a90e70c173fa309b242c0390ef8cf"", ""filename"": ""fs/f2fs/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/f2fs/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/f2fs/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/f2fs/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -692,5 +692,5 @@ const struct file_operations f2fs_file_operations = {\n \t.compat_ioctl\t= f2fs_compat_ioctl,\n #endif\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };""}<_**next**_>{""sha"": ""01b4c5b1bff8ddd152a6b93ac3b5249d3d0a49a8"", ""filename"": ""fs/gfs2/file.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/gfs2/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/gfs2/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/gfs2/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -1068,7 +1068,7 @@ const struct file_operations gfs2_file_fops = {\n \t.lock\t\t= gfs2_lock,\n \t.flock\t\t= gfs2_flock,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.setlease\t= gfs2_setlease,\n \t.fallocate\t= gfs2_fallocate,\n };\n@@ -1098,7 +1098,7 @@ const struct file_operations gfs2_file_fops_nolock = {\n \t.release\t= gfs2_release,\n \t.fsync\t\t= gfs2_fsync,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.setlease\t= generic_setlease,\n \t.fallocate\t= gfs2_fallocate,\n };""}<_**next**_>{""sha"": ""33aa0cc1f8b863b7b101bec470af4238d0c6eeb1"", ""filename"": ""fs/jfs/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/jfs/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/jfs/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/jfs/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -157,7 +157,7 @@ const struct file_operations jfs_file_operations = {\n \t.write_iter\t= generic_file_write_iter,\n \t.mmap\t\t= generic_file_mmap,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.fsync\t\t= jfs_fsync,\n \t.release\t= jfs_release,\n \t.unlocked_ioctl = jfs_ioctl,""}<_**next**_>{""sha"": ""4f56de822d2f5995b81006e0bc9783d321b1621d"", ""filename"": ""fs/ramfs/file-mmu.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/ramfs/file-mmu.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/ramfs/file-mmu.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ramfs/file-mmu.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -38,7 +38,7 @@ const struct file_operations ramfs_file_operations = {\n \t.mmap\t\t= generic_file_mmap,\n \t.fsync\t\t= noop_fsync,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.llseek\t\t= generic_file_llseek,\n };\n ""}<_**next**_>{""sha"": ""dda012ad4208d3192521c80a082af5ff038f5b3b"", ""filename"": ""fs/ramfs/file-nommu.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/ramfs/file-nommu.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/ramfs/file-nommu.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ramfs/file-nommu.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -43,7 +43,7 @@ const struct file_operations ramfs_file_operations = {\n \t.write_iter\t\t= generic_file_write_iter,\n \t.fsync\t\t\t= noop_fsync,\n \t.splice_read\t\t= generic_file_splice_read,\n-\t.splice_write\t\t= generic_file_splice_write,\n+\t.splice_write\t\t= iter_file_splice_write,\n \t.llseek\t\t\t= generic_file_llseek,\n };\n ""}<_**next**_>{""sha"": ""f070cc827456b68cc3dd3a79bab4009a2c5a2924"", ""filename"": ""fs/reiserfs/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/reiserfs/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/reiserfs/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/reiserfs/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -248,7 +248,7 @@ const struct file_operations reiserfs_file_operations = {\n \t.read_iter = generic_file_read_iter,\n \t.write_iter = generic_file_write_iter,\n \t.splice_read = generic_file_splice_read,\n-\t.splice_write = generic_file_splice_write,\n+\t.splice_write = iter_file_splice_write,\n \t.llseek = generic_file_llseek,\n };\n ""}<_**next**_>{""sha"": ""f195a9b89fb22ea64ac5e8fda4af03d0ae3f16e3"", ""filename"": ""fs/splice.c"", ""status"": ""modified"", ""additions"": 140, ""deletions"": 0, ""changes"": 140, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/splice.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/splice.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/splice.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -32,6 +32,7 @@\n #include <linux/gfp.h>\n #include <linux/socket.h>\n #include <linux/compat.h>\n+#include <linux/aio.h>\n #include \""internal.h\""\n \n /*\n@@ -1052,6 +1053,145 @@ generic_file_splice_write(struct pipe_inode_info *pipe, struct file *out,\n \n EXPORT_SYMBOL(generic_file_splice_write);\n \n+/**\n+ * iter_file_splice_write - splice data from a pipe to a file\n+ * @pipe:\tpipe info\n+ * @out:\tfile to write to\n+ * @ppos:\tposition in @out\n+ * @len:\tnumber of bytes to splice\n+ * @flags:\tsplice modifier flags\n+ *\n+ * Description:\n+ *    Will either move or copy pages (determined by @flags options) from\n+ *    the given pipe inode to the given file.\n+ *    This one is ->write_iter-based.\n+ *\n+ */\n+ssize_t\n+iter_file_splice_write(struct pipe_inode_info *pipe, struct file *out,\n+\t\t\t  loff_t *ppos, size_t len, unsigned int flags)\n+{\n+\tstruct splice_desc sd = {\n+\t\t.total_len = len,\n+\t\t.flags = flags,\n+\t\t.pos = *ppos,\n+\t\t.u.file = out,\n+\t};\n+\tint nbufs = pipe->buffers;\n+\tstruct bio_vec *array = kcalloc(nbufs, sizeof(struct bio_vec),\n+\t\t\t\t\tGFP_KERNEL);\n+\tssize_t ret;\n+\n+\tif (unlikely(!array))\n+\t\treturn -ENOMEM;\n+\n+\tpipe_lock(pipe);\n+\n+\tsplice_from_pipe_begin(&sd);\n+\twhile (sd.total_len) {\n+\t\tstruct iov_iter from;\n+\t\tstruct kiocb kiocb;\n+\t\tsize_t left;\n+\t\tint n, idx;\n+\n+\t\tret = splice_from_pipe_next(pipe, &sd);\n+\t\tif (ret <= 0)\n+\t\t\tbreak;\n+\n+\t\tif (unlikely(nbufs < pipe->buffers)) {\n+\t\t\tkfree(array);\n+\t\t\tnbufs = pipe->buffers;\n+\t\t\tarray = kcalloc(nbufs, sizeof(struct bio_vec),\n+\t\t\t\t\tGFP_KERNEL);\n+\t\t\tif (!array) {\n+\t\t\t\tret = -ENOMEM;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t/* build the vector */\n+\t\tleft = sd.total_len;\n+\t\tfor (n = 0, idx = pipe->curbuf; left && n < pipe->nrbufs; n++, idx++) {\n+\t\t\tstruct pipe_buffer *buf = pipe->bufs + idx;\n+\t\t\tsize_t this_len = buf->len;\n+\n+\t\t\tif (this_len > left)\n+\t\t\t\tthis_len = left;\n+\n+\t\t\tif (idx == pipe->buffers - 1)\n+\t\t\t\tidx = -1;\n+\n+\t\t\tret = buf->ops->confirm(pipe, buf);\n+\t\t\tif (unlikely(ret)) {\n+\t\t\t\tif (ret == -ENODATA)\n+\t\t\t\t\tret = 0;\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\tarray[n].bv_page = buf->page;\n+\t\t\tarray[n].bv_len = this_len;\n+\t\t\tarray[n].bv_offset = buf->offset;\n+\t\t\tleft -= this_len;\n+\t\t}\n+\n+\t\t/* ... iov_iter */\n+\t\tfrom.type = ITER_BVEC | WRITE;\n+\t\tfrom.bvec = array;\n+\t\tfrom.nr_segs = n;\n+\t\tfrom.count = sd.total_len - left;\n+\t\tfrom.iov_offset = 0;\n+\n+\t\t/* ... and iocb */\n+\t\tinit_sync_kiocb(&kiocb, out);\n+\t\tkiocb.ki_pos = sd.pos;\n+\t\tkiocb.ki_nbytes = sd.total_len - left;\n+\n+\t\t/* now, send it */\n+\t\tret = out->f_op->write_iter(&kiocb, &from);\n+\t\tif (-EIOCBQUEUED == ret)\n+\t\t\tret = wait_on_sync_kiocb(&kiocb);\n+\n+\t\tif (ret <= 0)\n+\t\t\tbreak;\n+\n+\t\tsd.num_spliced += ret;\n+\t\tsd.total_len -= ret;\n+\t\t*ppos = sd.pos = kiocb.ki_pos;\n+\n+\t\t/* dismiss the fully eaten buffers, adjust the partial one */\n+\t\twhile (ret) {\n+\t\t\tstruct pipe_buffer *buf = pipe->bufs + pipe->curbuf;\n+\t\t\tif (ret >= buf->len) {\n+\t\t\t\tconst struct pipe_buf_operations *ops = buf->ops;\n+\t\t\t\tret -= buf->len;\n+\t\t\t\tbuf->len = 0;\n+\t\t\t\tbuf->ops = NULL;\n+\t\t\t\tops->release(pipe, buf);\n+\t\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n+\t\t\t\tpipe->nrbufs--;\n+\t\t\t\tif (pipe->files)\n+\t\t\t\t\tsd.need_wakeup = true;\n+\t\t\t} else {\n+\t\t\t\tbuf->offset += ret;\n+\t\t\t\tbuf->len -= ret;\n+\t\t\t\tret = 0;\n+\t\t\t}\n+\t\t}\n+\t}\n+done:\n+\tkfree(array);\n+\tsplice_from_pipe_end(pipe, &sd);\n+\n+\tpipe_unlock(pipe);\n+\n+\tif (sd.num_spliced)\n+\t\tret = sd.num_spliced;\n+\n+\treturn ret;\n+}\n+\n+EXPORT_SYMBOL(iter_file_splice_write);\n+\n static int write_pipe_buf(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n \t\t\t  struct splice_desc *sd)\n {""}<_**next**_>{""sha"": ""0888502a60415223ba9285447c9e2f4425bc4076"", ""filename"": ""fs/ubifs/file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/ubifs/file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/ubifs/file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ubifs/file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -1585,7 +1585,7 @@ const struct file_operations ubifs_file_operations = {\n \t.fsync          = ubifs_fsync,\n \t.unlocked_ioctl = ubifs_ioctl,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n #ifdef CONFIG_COMPAT\n \t.compat_ioctl   = ubifs_compat_ioctl,\n #endif""}<_**next**_>{""sha"": ""b1c489c1fb2e4496e8ca7d61955e32779d16e439"", ""filename"": ""fs/xfs/xfs_file.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 42, ""changes"": 43, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/xfs/xfs_file.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/xfs/xfs_file.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_file.c?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -342,47 +342,6 @@ xfs_file_splice_read(\n \treturn ret;\n }\n \n-/*\n- * xfs_file_splice_write() does not use xfs_rw_ilock() because\n- * generic_file_splice_write() takes the i_mutex itself. This, in theory,\n- * couuld cause lock inversions between the aio_write path and the splice path\n- * if someone is doing concurrent splice(2) based writes and write(2) based\n- * writes to the same inode. The only real way to fix this is to re-implement\n- * the generic code here with correct locking orders.\n- */\n-STATIC ssize_t\n-xfs_file_splice_write(\n-\tstruct pipe_inode_info\t*pipe,\n-\tstruct file\t\t*outfilp,\n-\tloff_t\t\t\t*ppos,\n-\tsize_t\t\t\tcount,\n-\tunsigned int\t\tflags)\n-{\n-\tstruct inode\t\t*inode = outfilp->f_mapping->host;\n-\tstruct xfs_inode\t*ip = XFS_I(inode);\n-\tint\t\t\tioflags = 0;\n-\tssize_t\t\t\tret;\n-\n-\tXFS_STATS_INC(xs_write_calls);\n-\n-\tif (outfilp->f_mode & FMODE_NOCMTIME)\n-\t\tioflags |= IO_INVIS;\n-\n-\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n-\t\treturn -EIO;\n-\n-\txfs_ilock(ip, XFS_IOLOCK_EXCL);\n-\n-\ttrace_xfs_file_splice_write(ip, count, *ppos, ioflags);\n-\n-\tret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);\n-\tif (ret > 0)\n-\t\tXFS_STATS_ADD(xs_write_bytes, ret);\n-\n-\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n-\treturn ret;\n-}\n-\n /*\n  * This routine is called to handle zeroing any space in the last block of the\n  * file that is beyond the EOF.  We do this since the size is being increased\n@@ -1442,7 +1401,7 @@ const struct file_operations xfs_file_operations = {\n \t.read_iter\t= xfs_file_read_iter,\n \t.write_iter\t= xfs_file_write_iter,\n \t.splice_read\t= xfs_file_splice_read,\n-\t.splice_write\t= xfs_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.unlocked_ioctl\t= xfs_file_ioctl,\n #ifdef CONFIG_COMPAT\n \t.compat_ioctl\t= xfs_file_compat_ioctl,""}<_**next**_>{""sha"": ""53182f97cf011e62e4806ce4bf3dbdfc71f00835"", ""filename"": ""fs/xfs/xfs_trace.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/fs/xfs/xfs_trace.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/fs/xfs/xfs_trace.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_trace.h?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -1060,7 +1060,6 @@ DEFINE_RW_EVENT(xfs_file_read);\n DEFINE_RW_EVENT(xfs_file_buffered_write);\n DEFINE_RW_EVENT(xfs_file_direct_write);\n DEFINE_RW_EVENT(xfs_file_splice_read);\n-DEFINE_RW_EVENT(xfs_file_splice_write);\n \n DECLARE_EVENT_CLASS(xfs_page_class,\n \tTP_PROTO(struct inode *inode, struct page *page, unsigned long off,""}<_**next**_>{""sha"": ""8bd8ed357c7b6204308a49375e5d01af1dbd1726"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8d0207652cbe27d1f962050737848e5ad4671958/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8d0207652cbe27d1f962050737848e5ad4671958/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=8d0207652cbe27d1f962050737848e5ad4671958"", ""patch"": ""@@ -2434,6 +2434,8 @@ extern ssize_t default_file_splice_read(struct file *, loff_t *,\n \t\tstruct pipe_inode_info *, size_t, unsigned int);\n extern ssize_t generic_file_splice_write(struct pipe_inode_info *,\n \t\tstruct file *, loff_t *, size_t, unsigned int);\n+extern ssize_t iter_file_splice_write(struct pipe_inode_info *,\n+\t\tstruct file *, loff_t *, size_t, unsigned int);\n extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,\n \t\tstruct file *out, loff_t *, size_t len, unsigned int flags);\n ""}","xfs_file_splice_read(
	struct file		*infilp,
	loff_t			*ppos,
	struct pipe_inode_info	*pipe,
	size_t			count,
	unsigned int		flags)
{
	struct xfs_inode	*ip = XFS_I(infilp->f_mapping->host);
	int			ioflags = 0;
	ssize_t			ret;

	XFS_STATS_INC(xs_read_calls);

	if (infilp->f_mode & FMODE_NOCMTIME)
		ioflags |= IO_INVIS;

	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
		return -EIO;

	xfs_rw_ilock(ip, XFS_IOLOCK_SHARED);

	trace_xfs_file_splice_read(ip, count, *ppos, ioflags);

	ret = generic_file_splice_read(infilp, ppos, pipe, count, flags);
	if (ret > 0)
		XFS_STATS_ADD(xs_read_bytes, ret);

	xfs_rw_iunlock(ip, XFS_IOLOCK_SHARED);
 	return ret;
 }
","xfs_file_splice_read(
	struct file		*infilp,
	loff_t			*ppos,
	struct pipe_inode_info	*pipe,
	size_t			count,
	unsigned int		flags)
{
	struct xfs_inode	*ip = XFS_I(infilp->f_mapping->host);
	int			ioflags = 0;
	ssize_t			ret;

	XFS_STATS_INC(xs_read_calls);

	if (infilp->f_mode & FMODE_NOCMTIME)
		ioflags |= IO_INVIS;

	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
		return -EIO;

	xfs_rw_ilock(ip, XFS_IOLOCK_SHARED);

	trace_xfs_file_splice_read(ip, count, *ppos, ioflags);

	ret = generic_file_splice_read(infilp, ppos, pipe, count, flags);
	if (ret > 0)
		XFS_STATS_ADD(xs_read_bytes, ret);

	xfs_rw_iunlock(ip, XFS_IOLOCK_SHARED);
 	return ret;
 }
",C,,,,"@@ -342,47 +342,6 @@ xfs_file_splice_read(
 	return ret;
 }
 
-/*
- * xfs_file_splice_write() does not use xfs_rw_ilock() because
- * generic_file_splice_write() takes the i_mutex itself. This, in theory,
- * couuld cause lock inversions between the aio_write path and the splice path
- * if someone is doing concurrent splice(2) based writes and write(2) based
- * writes to the same inode. The only real way to fix this is to re-implement
- * the generic code here with correct locking orders.
- */
-STATIC ssize_t
-xfs_file_splice_write(
-	struct pipe_inode_info	*pipe,
-	struct file		*outfilp,
-	loff_t			*ppos,
-	size_t			count,
-	unsigned int		flags)
-{
-	struct inode		*inode = outfilp->f_mapping->host;
-	struct xfs_inode	*ip = XFS_I(inode);
-	int			ioflags = 0;
-	ssize_t			ret;
-
-	XFS_STATS_INC(xs_write_calls);
-
-	if (outfilp->f_mode & FMODE_NOCMTIME)
-		ioflags |= IO_INVIS;
-
-	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
-		return -EIO;
-
-	xfs_ilock(ip, XFS_IOLOCK_EXCL);
-
-	trace_xfs_file_splice_write(ip, count, *ppos, ioflags);
-
-	ret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);
-	if (ret > 0)
-		XFS_STATS_ADD(xs_write_bytes, ret);
-
-	xfs_iunlock(ip, XFS_IOLOCK_EXCL);
-	return ret;
-}
-
 /*
  * This routine is called to handle zeroing any space in the last block of the
  * file that is beyond the EOF.  We do this since the size is being increased
@@ -1442,7 +1401,7 @@ const struct file_operations xfs_file_operations = {
 	.read_iter	= xfs_file_read_iter,
 	.write_iter	= xfs_file_write_iter,
 	.splice_read	= xfs_file_splice_read,
-	.splice_write	= xfs_file_splice_write,
+	.splice_write	= iter_file_splice_write,
 	.unlocked_ioctl	= xfs_file_ioctl,
 #ifdef CONFIG_COMPAT
 	.compat_ioctl	= xfs_file_compat_ioctl,",linux,8d0207652cbe27d1f962050737848e5ad4671958,62a8067a7f35dba2de501c9cb00e4cf36da90bc0,0,"xfs_file_splice_read(
	struct file		*infilp,
	loff_t			*ppos,
	struct pipe_inode_info	*pipe,
	size_t			count,
	unsigned int		flags)
{
	struct xfs_inode	*ip = XFS_I(infilp->f_mapping->host);
	int			ioflags = 0;
	ssize_t			ret;

	XFS_STATS_INC(xs_read_calls);

	if (infilp->f_mode & FMODE_NOCMTIME)
		ioflags |= IO_INVIS;

	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
		return -EIO;

	xfs_rw_ilock(ip, XFS_IOLOCK_SHARED);

	trace_xfs_file_splice_read(ip, count, *ppos, ioflags);

	ret = generic_file_splice_read(infilp, ppos, pipe, count, flags);
	if (ret > 0)
		XFS_STATS_ADD(xs_read_bytes, ret);

	xfs_rw_iunlock(ip, XFS_IOLOCK_SHARED);
 	return ret;
 }
",46443,"xfs_file_splice_write(
	struct pipe_inode_info	*pipe,
	struct file		*outfilp,
	loff_t			*ppos,
	size_t			count,
	unsigned int		flags)
{
	struct inode		*inode = outfilp->f_mapping->host;
	struct xfs_inode	*ip = XFS_I(inode);
	int			ioflags = 0;
	ssize_t			ret;
	XFS_STATS_INC(xs_write_calls);
	if (outfilp->f_mode & FMODE_NOCMTIME)
		ioflags |= IO_INVIS;
	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
		return -EIO;
	xfs_ilock(ip, XFS_IOLOCK_EXCL);
	trace_xfs_file_splice_write(ip, count, *ppos, ioflags);
	ret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);
	if (ret > 0)
		XFS_STATS_ADD(xs_write_bytes, ret);
	xfs_iunlock(ip, XFS_IOLOCK_EXCL);
	return ret;
}
","xfs_file_splice_read(
	struct file		*infilp,
	loff_t			*ppos,
	struct pipe_inode_info	*pipe,
	size_t			count,
	unsigned int		flags)
{
	struct xfs_inode	*ip = XFS_I(infilp->f_mapping->host);
	int			ioflags = 0;
	ssize_t			ret;

	XFS_STATS_INC(xs_read_calls);

	if (infilp->f_mode & FMODE_NOCMTIME)
		ioflags |= IO_INVIS;

	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
		return -EIO;

	xfs_rw_ilock(ip, XFS_IOLOCK_SHARED);

	trace_xfs_file_splice_read(ip, count, *ppos, ioflags);

	ret = generic_file_splice_read(infilp, ppos, pipe, count, flags);
	if (ret > 0)
		XFS_STATS_ADD(xs_read_bytes, ret);

	xfs_rw_iunlock(ip, XFS_IOLOCK_SHARED);
 	return ret;
 }
","The `xfs_file_splice_write` function facilitates the transfer of data from a pipe to a file in the XFS filesystem. It begins by obtaining the inode associated with the output file and checks for specific conditions, such as forced shutdowns or file mode flags. The function locks the inode to ensure exclusive access during the operation, then calls `generic_file_splice_write` to perform the actual data transfer, tracking the number of bytes written. After the operation, it updates statistics and unlocks the inode before returning the result, which indicates the success or failure of the write operation.","The provided code implements a function that enables the transfer of data from a pipe to a specified file within a filesystem. It first checks for specific conditions, such as whether the filesystem is in a stable state and the mode of the output file. The function then secures exclusive access to the file's metadata to prevent concurrent modifications during the data transfer. It performs the actual writing operation while tracking the number of bytes successfully written. Finally, it updates relevant statistics and releases the lock on the file's metadata before returning the result of the write operation.","The vulnerability in the original code arises from the use of an exclusive lock on the inode during the data transfer, which could lead to potential race conditions or deadlocks if multiple processes attempt to write simultaneously. This was addressed in the fixed code by changing the locking mechanism to a shared lock, allowing concurrent read operations while still preventing write conflicts. The function now uses `xfs_rw_ilock` and `xfs_rw_iunlock` instead of `xfs_ilock` and `xfs_iunlock`, which enhances the overall concurrency and stability of the data transfer process, thereby mitigating the risk of deadlocks and improving performance.","The vulnerability in the original code stemmed from the use of an exclusive locking mechanism during data transfer, which could lead to race conditions and hinder concurrent access, potentially causing performance issues or deadlocks. The fix implemented a shared locking approach, allowing multiple read operations to occur simultaneously while still preventing write conflicts. This change enhances the system's concurrency and stability, enabling more efficient data handling without compromising integrity. The updated code structure also improves the overall flow of data processing, making it more robust against potential synchronization issues.","The vulnerability was fixed by replacing the exclusive locking mechanism with a shared locking approach. In the updated code, `xfs_rw_ilock` and `xfs_rw_iunlock` are used instead of `xfs_ilock` and `xfs_iunlock`, allowing multiple processes to read concurrently while still preventing write conflicts. This change enhances the system's concurrency, enabling simultaneous read operations without risking deadlocks or race conditions. Additionally, the function now utilizes `generic_file_splice_read`, which efficiently handles the data transfer, further improving performance and stability during the read operation from the pipe to the file.","The vulnerability was addressed by changing the locking strategy from an exclusive lock to a shared lock during the data transfer process. This adjustment allows multiple read operations to occur simultaneously, improving concurrency and reducing the risk of deadlocks or race conditions that could arise from exclusive access. By enabling concurrent reads while still preventing write conflicts, the system's overall stability and performance were enhanced. Additionally, the updated code structure streamlined the data handling process, making it more efficient and robust against potential synchronization issues during the transfer of data.","CWE-662, CWE-764, CWE-833, CWE-667, CWE-412, CWE-414, CWE-366, CWE-567, CWE-609, CWE-821",N,-1
1,1,177736,177736,,Remote,Single system,Partial,CVE-2015-8467,https://www.cvedetails.com/cve/CVE-2015-8467/,CWE-264,Medium,Partial,Partial,,2015-12-29,6.0,"The samldb_check_user_account_control_acl function in dsdb/samdb/ldb_modules/samldb.c in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3 does not properly check for administrative privileges during creation of machine accounts, which allows remote authenticated users to bypass intended access restrictions by leveraging the existence of a domain with both a Samba DC and a Windows DC, a similar issue to CVE-2015-2535.",2016-12-30,Bypass,13,https://git.samba.org/?p=samba.git;a=commit;h=b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d,,0,,,"static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
						 struct dom_sid *sid,
						 uint32_t user_account_control,
						 uint32_t user_account_control_old)
{
	int i, ret = 0;
	bool need_acl_check = false;
	struct ldb_result *res;
	const char * const sd_attrs[] = {""ntSecurityDescriptor"", NULL};
        struct security_token *user_token;
        struct security_descriptor *domain_sd;
        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
        const struct uac_to_guid {
                uint32_t uac;
               uint32_t priv_to_change_from;
                const char *oid;
                const char *guid;
                enum sec_privilege privilege;
                bool delete_is_privileged;
               bool admin_required;
                const char *error_string;
        } map[] = {
                {
		},
		{
			.uac = UF_DONT_EXPIRE_PASSWD,
			.guid = GUID_DRS_UNEXPIRE_PASSWORD,
			.error_string = ""Adding the UF_DONT_EXPIRE_PASSWD bit in userAccountControl requires the Unexpire-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
			.guid = GUID_DRS_ENABLE_PER_USER_REVERSIBLY_ENCRYPTED_PASSWORD,
			.error_string = ""Adding the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in userAccountControl requires the Enable-Per-User-Reversibly-Encrypted-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_SERVER_TRUST_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_SERVER_TRUST_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
		{
			.uac = UF_PARTIAL_SECRETS_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
                        .guid = GUID_DRS_DS_INSTALL_REPLICA,
                        .error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                },
               {
                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,
                       .priv_to_change_from = UF_NORMAL_ACCOUNT,
                       .error_string = ""Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group""
               },
               {
                       .uac = UF_NORMAL_ACCOUNT,
                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,
                       .error_string = ""Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group""
               },
                {
                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
			.error_string = ""Updating the UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
		}

	};
","static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
						 struct dom_sid *sid,
						 uint32_t user_account_control,
						 uint32_t user_account_control_old)
{
	int i, ret = 0;
	bool need_acl_check = false;
	struct ldb_result *res;
	const char * const sd_attrs[] = {""ntSecurityDescriptor"", NULL};
        struct security_token *user_token;
        struct security_descriptor *domain_sd;
        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
        const struct uac_to_guid {
                uint32_t uac;
                const char *oid;
                const char *guid;
                enum sec_privilege privilege;
                bool delete_is_privileged;
                const char *error_string;
        } map[] = {
                {
		},
		{
			.uac = UF_DONT_EXPIRE_PASSWD,
			.guid = GUID_DRS_UNEXPIRE_PASSWORD,
			.error_string = ""Adding the UF_DONT_EXPIRE_PASSWD bit in userAccountControl requires the Unexpire-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
			.guid = GUID_DRS_ENABLE_PER_USER_REVERSIBLY_ENCRYPTED_PASSWORD,
			.error_string = ""Adding the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in userAccountControl requires the Enable-Per-User-Reversibly-Encrypted-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_SERVER_TRUST_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_SERVER_TRUST_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
		{
			.uac = UF_PARTIAL_SECRETS_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
                        .guid = GUID_DRS_DS_INSTALL_REPLICA,
                        .error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                },
                {
                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
			.error_string = ""Updating the UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
		}

	};
",C,"       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
               uint32_t priv_to_change_from;
               bool admin_required;
               {
                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,
                       .priv_to_change_from = UF_NORMAL_ACCOUNT,
                       .error_string = ""Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group""
               },
               {
                       .uac = UF_NORMAL_ACCOUNT,
                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,
                       .error_string = ""Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group""
               },
",,a819d2b440aafa3138d95ff6e8b824da885a70e9,"@@ -1558,12 +1558,15 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
        struct security_token *user_token;
        struct security_descriptor *domain_sd;
        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
+       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
        const struct uac_to_guid {
                uint32_t uac;
+               uint32_t priv_to_change_from;
                const char *oid;
                const char *guid;
                enum sec_privilege privilege;
                bool delete_is_privileged;
+               bool admin_required;
                const char *error_string;
        } map[] = {
                {
@@ -1591,6 +1594,16 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
                        .guid = GUID_DRS_DS_INSTALL_REPLICA,
                        .error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                },
+               {
+                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,
+                       .priv_to_change_from = UF_NORMAL_ACCOUNT,
+                       .error_string = ""Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group""
+               },
+               {
+                       .uac = UF_NORMAL_ACCOUNT,
+                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,
+                       .error_string = ""Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group""
+               },
                {
                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
@@ -1643,7 +1656,7 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
                return ldb_module_operr(ac->module);
        }
 
-       ret = dsdb_get_sd_from_ldb_message(ldb_module_get_ctx(ac->module),
+       ret = dsdb_get_sd_from_ldb_message(ldb,
                                           ac, res->msgs[0], &domain_sd);
 
        if (ret != LDB_SUCCESS) {
@@ -1670,12 +1683,19 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
                                if (have_priv == false) {
                                        ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
                                }
-                       } else {
+                       } else if (map[i].priv_to_change_from & user_account_control_old) {
+                               bool is_admin = security_token_has_builtin_administrators(user_token);
+                               if (is_admin == false) {
+                                       ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
+                               }
+                       } else if (map[i].guid) {
                                ret = acl_check_extended_right(ac, domain_sd,
                                                               user_token,
                                                               map[i].guid,
                                                               SEC_ADS_CONTROL_ACCESS,
                                                               sid);
+                       } else {
+                               ret = LDB_SUCCESS;
                        }
                        if (ret != LDB_SUCCESS) {
                                break;",samba,https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/samdb/ldb_modules/samldb.c;h=df285d91485ba8393d368ddf6328957d26ff57dd;hb=df285d91485ba8393d368ddf6328957d26ff57dd,https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/samdb/ldb_modules/samldb.c;h=e3a7db27aa9c4b2ea5fba2f4f91b87d90c502e98;hb=e3a7db27aa9c4b2ea5fba2f4f91b87d90c502e98,1,"static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
						 struct dom_sid *sid,
						 uint32_t user_account_control,
						 uint32_t user_account_control_old)
{
	int i, ret = 0;
	bool need_acl_check = false;
	struct ldb_result *res;
	const char * const sd_attrs[] = {""ntSecurityDescriptor"", NULL};
        struct security_token *user_token;
        struct security_descriptor *domain_sd;
        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
//fix_flaw_line_below:
//       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
        const struct uac_to_guid {
                uint32_t uac;
//fix_flaw_line_below:
//               uint32_t priv_to_change_from;
                const char *oid;
                const char *guid;
                enum sec_privilege privilege;
                bool delete_is_privileged;
//fix_flaw_line_below:
//               bool admin_required;
                const char *error_string;
        } map[] = {
                {
		},
		{
			.uac = UF_DONT_EXPIRE_PASSWD,
			.guid = GUID_DRS_UNEXPIRE_PASSWORD,
			.error_string = ""Adding the UF_DONT_EXPIRE_PASSWD bit in userAccountControl requires the Unexpire-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
			.guid = GUID_DRS_ENABLE_PER_USER_REVERSIBLY_ENCRYPTED_PASSWORD,
			.error_string = ""Adding the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in userAccountControl requires the Enable-Per-User-Reversibly-Encrypted-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_SERVER_TRUST_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_SERVER_TRUST_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
		{
			.uac = UF_PARTIAL_SECRETS_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
                        .guid = GUID_DRS_DS_INSTALL_REPLICA,
                        .error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                },
//fix_flaw_line_below:
//               {
//fix_flaw_line_below:
//                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,
//fix_flaw_line_below:
//                       .priv_to_change_from = UF_NORMAL_ACCOUNT,
//fix_flaw_line_below:
//                       .error_string = ""Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group""
//fix_flaw_line_below:
//               },
//fix_flaw_line_below:
//               {
//fix_flaw_line_below:
//                       .uac = UF_NORMAL_ACCOUNT,
//fix_flaw_line_below:
//                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,
//fix_flaw_line_below:
//                       .error_string = ""Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group""
//fix_flaw_line_below:
//               },
                {
                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
			.error_string = ""Updating the UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
		}

	};
",177736,"static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
						 struct dom_sid *sid,
						 uint32_t user_account_control,
						 uint32_t user_account_control_old)
{
	int i, ret = 0;
	bool need_acl_check = false;
	struct ldb_result *res;
	const char * const sd_attrs[] = {""ntSecurityDescriptor"", NULL};
	struct security_token *user_token;
	struct security_descriptor *domain_sd;
	struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
	const struct uac_to_guid {
		uint32_t uac;
		const char *oid;
		const char *guid;
		enum sec_privilege privilege;
		bool delete_is_privileged;
		const char *error_string;
	} map[] = {
		{
			.uac = UF_PASSWD_NOTREQD,
			.guid = GUID_DRS_UPDATE_PASSWORD_NOT_REQUIRED_BIT,
			.error_string = ""Adding the UF_PASSWD_NOTREQD bit in userAccountControl requires the Update-Password-Not-Required-Bit right that was not given on the Domain object""
		},
		{
			.uac = UF_DONT_EXPIRE_PASSWD,
			.guid = GUID_DRS_UNEXPIRE_PASSWORD,
			.error_string = ""Adding the UF_DONT_EXPIRE_PASSWD bit in userAccountControl requires the Unexpire-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
			.guid = GUID_DRS_ENABLE_PER_USER_REVERSIBLY_ENCRYPTED_PASSWORD,
			.error_string = ""Adding the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in userAccountControl requires the Enable-Per-User-Reversibly-Encrypted-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_SERVER_TRUST_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_SERVER_TRUST_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
		{
			.uac = UF_PARTIAL_SECRETS_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
		{
			.uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
			.oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
			.error_string = ""Updating the UF_INTERDOMAIN_TRUST_ACCOUNT bit in userAccountControl is not permitted over LDAP.  This bit is restricted to the LSA CreateTrustedDomain interface"",
			.delete_is_privileged = true
		},
		{
			.uac = UF_TRUSTED_FOR_DELEGATION,
			.privilege = SEC_PRIV_ENABLE_DELEGATION,
			.delete_is_privileged = true,
			.error_string = ""Updating the UF_TRUSTED_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
		},
		{
			.uac = UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION,
			.privilege = SEC_PRIV_ENABLE_DELEGATION,
			.delete_is_privileged = true,
			.error_string = ""Updating the UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
		}

	};

	if (dsdb_module_am_system(ac->module)) {
		return LDB_SUCCESS;
	}

	for (i = 0; i < ARRAY_SIZE(map); i++) {
		if (user_account_control & map[i].uac) {
			need_acl_check = true;
			break;
		}
	}
	if (need_acl_check == false) {
		return LDB_SUCCESS;
	}

	user_token = acl_user_token(ac->module);
	if (user_token == NULL) {
		return LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
	}

	ret = dsdb_module_search_dn(ac->module, ac, &res,
				    domain_dn,
				    sd_attrs,
				    DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED,
				    ac->req);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	if (res->count != 1) {
		return ldb_module_operr(ac->module);
	}

	ret = dsdb_get_sd_from_ldb_message(ldb_module_get_ctx(ac->module),
					   ac, res->msgs[0], &domain_sd);

	if (ret != LDB_SUCCESS) {
		return ret;
	}

	for (i = 0; i < ARRAY_SIZE(map); i++) {
		uint32_t this_uac_new = user_account_control & map[i].uac;
		uint32_t this_uac_old = user_account_control_old & map[i].uac;
		if (this_uac_new != this_uac_old) {
			if (this_uac_old != 0) {
				if (map[i].delete_is_privileged == false) {
					continue;
				}
			}
			if (map[i].oid) {
				struct ldb_control *control = ldb_request_get_control(ac->req, map[i].oid);
				if (control == NULL) {
					ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
				}
			} else if (map[i].privilege != SEC_PRIV_INVALID) {
				bool have_priv = security_token_has_privilege(user_token,
									      map[i].privilege);
				if (have_priv == false) {
					ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;
				}
			} else {
				ret = acl_check_extended_right(ac, domain_sd,
							       user_token,
							       map[i].guid,
							       SEC_ADS_CONTROL_ACCESS,
							       sid);
			}
			if (ret != LDB_SUCCESS) {
				break;
			}
		}
	}
	if (ret == LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS) {
		switch (ac->req->operation) {
		case LDB_ADD:
			ldb_asprintf_errstring(ldb_module_get_ctx(ac->module),
					       ""Failed to add %s: %s"",
					       ldb_dn_get_linearized(ac->msg->dn),
					       map[i].error_string);
			break;
		case LDB_MODIFY:
			ldb_asprintf_errstring(ldb_module_get_ctx(ac->module),
					       ""Failed to modify %s: %s"",
					       ldb_dn_get_linearized(ac->msg->dn),
					       map[i].error_string);
			break;
		default:
			return ldb_module_operr(ac->module);
		}
		if (map[i].guid) {
			dsdb_acl_debug(domain_sd, acl_user_token(ac->module),
				       domain_dn,
				       true,
				       10);
		}
	}
	return ret;
}","static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,
						 struct dom_sid *sid,
						 uint32_t user_account_control,
						 uint32_t user_account_control_old)
{
	int i, ret = 0;
	bool need_acl_check = false;
	struct ldb_result *res;
	const char * const sd_attrs[] = {""ntSecurityDescriptor"", NULL};
        struct security_token *user_token;
        struct security_descriptor *domain_sd;
        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));
       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
        const struct uac_to_guid {
                uint32_t uac;
               uint32_t priv_to_change_from;
                const char *oid;
                const char *guid;
                enum sec_privilege privilege;
                bool delete_is_privileged;
               bool admin_required;
                const char *error_string;
        } map[] = {
                {
		},
		{
			.uac = UF_DONT_EXPIRE_PASSWD,
			.guid = GUID_DRS_UNEXPIRE_PASSWORD,
			.error_string = ""Adding the UF_DONT_EXPIRE_PASSWD bit in userAccountControl requires the Unexpire-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,
			.guid = GUID_DRS_ENABLE_PER_USER_REVERSIBLY_ENCRYPTED_PASSWORD,
			.error_string = ""Adding the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in userAccountControl requires the Enable-Per-User-Reversibly-Encrypted-Password right that was not given on the Domain object""
		},
		{
			.uac = UF_SERVER_TRUST_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_SERVER_TRUST_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
		{
			.uac = UF_PARTIAL_SECRETS_ACCOUNT,
			.guid = GUID_DRS_DS_INSTALL_REPLICA,
			.error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
		},
                        .guid = GUID_DRS_DS_INSTALL_REPLICA,
                        .error_string = ""Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object""
                },
               {
                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,
                       .priv_to_change_from = UF_NORMAL_ACCOUNT,
                       .error_string = ""Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group""
               },
               {
                       .uac = UF_NORMAL_ACCOUNT,
                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,
                       .error_string = ""Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group""
               },
                {
                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,
                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,
			.error_string = ""Updating the UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege""
		}

	};
","The function `samldb_check_user_account_control_acl` verifies access control for modifying user account settings in a directory service. It checks if specific user account control (UAC) flags are being set or modified, which require certain permissions. If such flags are detected, the function retrieves the security descriptor for the domain and evaluates whether the user has the necessary rights to make the changes. It utilizes a predefined mapping of UAC flags to their corresponding permissions and error messages. If access is insufficient, it generates an appropriate error message based on the operation type (add or modify) and returns the result of the access check.","The code checks whether a user has the necessary permissions to modify specific account settings in a directory service. It identifies if certain flags indicating user account control changes are being set, which require specific access rights. If such flags are present, the code retrieves the security descriptor for the domain and assesses the user's privileges against a predefined set of requirements. If the user lacks the necessary permissions, an appropriate error message is generated based on the type of operation being performed, ensuring that access control policies are enforced correctly.","The vulnerability in the original code stemmed from insufficient checks on user privileges when modifying user account control flags, potentially allowing unauthorized changes. Specifically, the code did not enforce that certain critical changes, such as switching account types, required the user to be a member of the domain admins group. The fix introduced additional checks by adding a new field, `admin_required`, in the mapping structure, which specifies when administrative privileges are necessary. This ensures that operations like changing account types are properly restricted, thereby enhancing security by preventing unauthorized privilege escalations.","The vulnerability in the original code allowed unauthorized users to modify critical user account settings without proper privilege checks, potentially leading to privilege escalation. This oversight could enable users to change their account types or settings that should be restricted to administrators. The fix addressed this issue by introducing additional checks that require users to have administrative privileges for specific changes. By implementing these checks, the code now ensures that only authorized personnel can perform sensitive modifications, thereby enhancing the overall security and integrity of the user account management process.","The vulnerability was fixed by adding an `admin_required` field to the mapping structure, which specifies when administrative privileges are necessary for certain user account control changes. In the updated code, checks were implemented to verify if the user is a member of the domain admins group before allowing modifications that involve switching account types, such as changing from a normal account to a workstation trust account. This ensures that operations requiring elevated privileges are properly restricted, thereby preventing unauthorized users from making critical changes to user account settings and enhancing overall security.","The vulnerability was addressed by introducing a mechanism that requires users to have administrative privileges for specific changes to user account settings. This involved adding a new field to the mapping structure that indicates when elevated permissions are necessary. The updated code now includes checks to ensure that only users with the appropriate administrative rights can perform sensitive modifications, such as changing account types. This enhancement effectively restricts unauthorized access and ensures that critical account management operations are only executed by authorized personnel, thereby improving the overall security of the system.","CWE-269, CWE-284, CWE-285, CWE-264, CWE-732, CWE-266, CWE-268, CWE-272, CWE-277, CWE-287",N,-1
2,2,177838,177838,,Remote,Not required,,CVE-2015-5352,https://www.cvedetails.com/cve/CVE-2015-5352/,CWE-264,Medium,,Partial,,2015-08-02,4.3,"The x11_open_helper function in channels.c in ssh in OpenSSH before 6.9, when ForwardX11Trusted mode is not used, lacks a check of the refusal deadline for X connections, which makes it easier for remote attackers to bypass intended access restrictions via a connection outside of the permitted time window.",2018-10-24,Bypass,7,https://anongit.mindrot.org/openssh.git/commit/?h=V_6_9&id=1bf477d3cdf1a864646d59820878783d42357a1d,1bf477d3cdf1a864646d59820878783d42357a1d,,0,,,"x11_open_helper(Buffer *b)
{
	u_char *ucp;
	u_int proto_len, data_len;

 	u_char *ucp;
 	u_int proto_len, data_len;
 
	/* Is this being called after the refusal deadline? */
	if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {
		verbose(""Rejected X11 connection after ForwardX11Timeout ""
		    ""expired"");
		return -1;
	}

 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
		debug2(""Initial X11 packet contains bad byte order byte: 0x%x"",
		    ucp[0]);
		return -1;
	}
","x11_open_helper(Buffer *b)
{
	u_char *ucp;
	u_int proto_len, data_len;

 	u_char *ucp;
 	u_int proto_len, data_len;
 
 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
		debug2(""Initial X11 packet contains bad byte order byte: 0x%x"",
		    ucp[0]);
		return -1;
	}
",C,"	/* Is this being called after the refusal deadline? */
	if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {
		verbose(""Rejected X11 connection after ForwardX11Timeout ""
		    ""expired"");
		return -1;
	}

",,47aa7a0f8551b471fcae0447c1d78464f6dba869,"@@ -1,4 +1,4 @@
-/* $OpenBSD: channels.c,v 1.346 2015/06/30 05:25:07 djm Exp $ */
+/* $OpenBSD: channels.c,v 1.347 2015/07/01 02:26:31 djm Exp $ */
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
@@ -161,6 +161,9 @@ static char *x11_saved_proto = NULL;
 static char *x11_saved_data = NULL;
 static u_int x11_saved_data_len = 0;
 
+/* Deadline after which all X11 connections are refused */
+static u_int x11_refuse_time;
+
 /*
  * Fake X11 authentication data.  This is what the server will be sending us;
  * we should replace any occurrences of this by the real data.
@@ -912,6 +915,13 @@ x11_open_helper(Buffer *b)
 	u_char *ucp;
 	u_int proto_len, data_len;
 
+	/* Is this being called after the refusal deadline? */
+	if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {
+		verbose(""Rejected X11 connection after ForwardX11Timeout ""
+		    ""expired"");
+		return -1;
+	}
+
 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
@@ -1483,6 +1493,12 @@ channel_set_reuseaddr(int fd)
 		error(""setsockopt SO_REUSEADDR fd %d: %s"", fd, strerror(errno));
 }
 
+void
+channel_set_x11_refuse_time(u_int refuse_time)
+{
+	x11_refuse_time = refuse_time;
+}
+
 /*
  * This socket is listening for connections to a forwarded TCP/IP port.
  */",mindrot,https://anongit.mindrot.org/openssh.git/tree/channels.c?h=V_6_9&id=1bf477d3cdf1a864646d59820878783d42357a1d,https://anongit.mindrot.org/openssh.git/tree/channels.c?h=V_6_9&id=47aa7a0f8551b471fcae0447c1d78464f6dba869,1,"x11_open_helper(Buffer *b)
{
	u_char *ucp;
	u_int proto_len, data_len;

 	u_char *ucp;
 	u_int proto_len, data_len;
 
//fix_flaw_line_below:
//	/* Is this being called after the refusal deadline? */
//fix_flaw_line_below:
//	if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {
//fix_flaw_line_below:
//		verbose(""Rejected X11 connection after ForwardX11Timeout ""
//fix_flaw_line_below:
//		    ""expired"");
//fix_flaw_line_below:
//		return -1;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
		debug2(""Initial X11 packet contains bad byte order byte: 0x%x"",
		    ucp[0]);
		return -1;
	}
",177838,"x11_open_helper(Buffer *b)
{
	u_char *ucp;
	u_int proto_len, data_len;

 	u_char *ucp;
 	u_int proto_len, data_len;
 
 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
		debug2(""Initial X11 packet contains bad byte order byte: 0x%x"",
		    ucp[0]);
		return -1;
	}
","x11_open_helper(Buffer *b)
{
	u_char *ucp;
	u_int proto_len, data_len;

 	u_char *ucp;
 	u_int proto_len, data_len;
 
	/* Is this being called after the refusal deadline? */
	if (x11_refuse_time != 0 && (u_int)monotime() >= x11_refuse_time) {
		verbose(""Rejected X11 connection after ForwardX11Timeout ""
		    ""expired"");
		return -1;
	}

 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
		debug2(""Initial X11 packet contains bad byte order byte: 0x%x"",
		    ucp[0]);
		return -1;
	}
","The `x11_open_helper` function processes an X11 protocol packet from a given buffer. It first checks if the buffer's length is at least 12 bytes, which is necessary for the fixed-size part of the packet. If the buffer is shorter, the function returns 0, indicating insufficient data. The function also includes a debug statement that logs the first byte of the packet, which is expected to indicate the byte order. If the byte order is invalid, it logs an error message and returns -1, signaling a failure in processing the packet due to bad data.","The provided code defines a function that processes a packet related to a specific protocol. It begins by verifying that the packet's size meets a minimum requirement, ensuring that there is enough data to work with. If the packet is too small, the function indicates this by returning a value that signifies insufficient data. Additionally, the function includes a debugging mechanism that logs the first byte of the packet, which is crucial for determining the byte order. If this byte indicates an error in the expected format, the function logs an error message and returns a failure indication.","The vulnerability in the original code arises from the lack of a timeout check for X11 connections, which could allow connections to be accepted indefinitely, potentially leading to resource exhaustion or denial of service. The fixed code addresses this issue by introducing a check for a refusal deadline using the `x11_refuse_time` variable. If the current time, obtained via `monotime()`, exceeds this deadline, the function logs a rejection message and returns -1, effectively preventing further processing of connections that should be denied after a specified timeout, thus enhancing security and resource management.","The vulnerability in the original code stems from the absence of a mechanism to reject X11 connections after a specified timeout, which could lead to prolonged acceptance of potentially malicious connections, risking resource exhaustion or denial of service. The revised code addresses this issue by implementing a check that determines whether the current time has surpassed a predefined refusal deadline. If the deadline has been exceeded, the function logs a rejection message and halts further processing of the connection, thereby enhancing security by ensuring that only timely and valid connections are accepted, thus mitigating the risk of abuse.","The vulnerability was fixed by introducing a check for the `x11_refuse_time` variable in the updated code. This check determines if the current time, obtained using the `monotime()` function, has reached or exceeded the specified refusal deadline. If the condition is met, the function logs a rejection message indicating that the X11 connection is being denied due to the timeout and returns -1 to stop further processing. This enhancement ensures that connections are only accepted within a valid timeframe, effectively mitigating the risk of resource exhaustion and improving overall security.","The vulnerability was addressed by implementing a timeout mechanism that checks whether the current time has surpassed a predefined refusal deadline for connections. This enhancement ensures that if the deadline is exceeded, the function logs a message indicating the rejection of the connection and halts any further processing. By enforcing this timeout, the code prevents the acceptance of connections that could lead to resource exhaustion or denial of service, thereby improving security and ensuring that only timely and legitimate connections are processed. This proactive approach effectively mitigates the risk associated with prolonged connection acceptance.","CWE-400, CWE-770, CWE-664, CWE-835, CWE-834, CWE-307, CWE-409, CWE-833, CWE-200, CWE-269",N,-1
3,3,177855,177855,,Remote,Not required,,CVE-2015-5252,https://www.cvedetails.com/cve/CVE-2015-5252/,CWE-264,Low,,Partial,,2015-12-29,5.0,"vfs.c in smbd in Samba 3.x and 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3, when share names with certain substring relationships exist, allows remote attackers to bypass intended file-access restrictions via a symlink that points outside of a share.",2016-12-30,Bypass,1,https://git.samba.org/?p=samba.git;a=commit;h=4278ef25f64d5fdbf432ff1534e275416ec9561e,4278ef25f64d5fdbf432ff1534e275416ec9561e,,0,,,"NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
			const char *fname,
			struct smb_request *smbreq)
{
	NTSTATUS status;
	TALLOC_CTX *ctx = talloc_tos();
	const char *conn_rootdir;
	size_t rootdir_len;
	char *dir_name = NULL;
	const char *last_component = NULL;
	char *resolved_name = NULL;
	char *saved_dir = NULL;
        struct smb_filename *smb_fname_cwd = NULL;
        struct privilege_paths *priv_paths = NULL;
        int ret;
       bool matched;
 
        DEBUG(3,(""check_reduced_name_with_privilege [%s] [%s]\n"",
                        fname,


	priv_paths = talloc_zero(smbreq, struct privilege_paths);
	if (!priv_paths) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (!parent_dirname(ctx, fname, &dir_name, &last_component)) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	priv_paths->parent_name.base_name = talloc_strdup(priv_paths, dir_name);
	priv_paths->file_name.base_name = talloc_strdup(priv_paths, last_component);

	if (priv_paths->parent_name.base_name == NULL ||
			priv_paths->file_name.base_name == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_STAT(conn, &priv_paths->parent_name) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}
	/* Remember where we were. */
	saved_dir = vfs_GetWd(ctx, conn);
	if (!saved_dir) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Go to the parent directory to lock in memory. */
	if (vfs_ChDir(conn, priv_paths->parent_name.base_name) == -1) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Get the absolute path of the parent directory. */
	resolved_name = SMB_VFS_REALPATH(conn,""."");
	if (!resolved_name) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	if (*resolved_name != '/') {
		DEBUG(0,(""check_reduced_name_with_privilege: realpath ""
			""doesn't return absolute paths !\n""));
		status = NT_STATUS_OBJECT_NAME_INVALID;
		goto err;
	}

	DEBUG(10,(""check_reduced_name_with_privilege: realpath [%s] -> [%s]\n"",
		priv_paths->parent_name.base_name,
		resolved_name));

	/* Now check the stat value is the same. */
	smb_fname_cwd = synthetic_smb_fname(talloc_tos(), ""."", NULL, NULL);
	if (smb_fname_cwd == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_LSTAT(conn, smb_fname_cwd) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Ensure we're pointing at the same place. */
	if (!check_same_stat(&smb_fname_cwd->st, &priv_paths->parent_name.st)) {
		DEBUG(0,(""check_reduced_name_with_privilege: ""
			""device/inode/uid/gid on directory %s changed. ""
			""Denying access !\n"",
			priv_paths->parent_name.base_name));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}

	/* Ensure we're below the connect path. */

	conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);
	if (conn_rootdir == NULL) {
		DEBUG(2, (""check_reduced_name_with_privilege: Could not get ""
			""conn_rootdir\n""));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}
        }
","NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
			const char *fname,
			struct smb_request *smbreq)
{
	NTSTATUS status;
	TALLOC_CTX *ctx = talloc_tos();
	const char *conn_rootdir;
	size_t rootdir_len;
	char *dir_name = NULL;
	const char *last_component = NULL;
	char *resolved_name = NULL;
	char *saved_dir = NULL;
        struct smb_filename *smb_fname_cwd = NULL;
        struct privilege_paths *priv_paths = NULL;
        int ret;
 
        DEBUG(3,(""check_reduced_name_with_privilege [%s] [%s]\n"",
                        fname,


	priv_paths = talloc_zero(smbreq, struct privilege_paths);
	if (!priv_paths) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (!parent_dirname(ctx, fname, &dir_name, &last_component)) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	priv_paths->parent_name.base_name = talloc_strdup(priv_paths, dir_name);
	priv_paths->file_name.base_name = talloc_strdup(priv_paths, last_component);

	if (priv_paths->parent_name.base_name == NULL ||
			priv_paths->file_name.base_name == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_STAT(conn, &priv_paths->parent_name) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}
	/* Remember where we were. */
	saved_dir = vfs_GetWd(ctx, conn);
	if (!saved_dir) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Go to the parent directory to lock in memory. */
	if (vfs_ChDir(conn, priv_paths->parent_name.base_name) == -1) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Get the absolute path of the parent directory. */
	resolved_name = SMB_VFS_REALPATH(conn,""."");
	if (!resolved_name) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	if (*resolved_name != '/') {
		DEBUG(0,(""check_reduced_name_with_privilege: realpath ""
			""doesn't return absolute paths !\n""));
		status = NT_STATUS_OBJECT_NAME_INVALID;
		goto err;
	}

	DEBUG(10,(""check_reduced_name_with_privilege: realpath [%s] -> [%s]\n"",
		priv_paths->parent_name.base_name,
		resolved_name));

	/* Now check the stat value is the same. */
	smb_fname_cwd = synthetic_smb_fname(talloc_tos(), ""."", NULL, NULL);
	if (smb_fname_cwd == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_LSTAT(conn, smb_fname_cwd) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Ensure we're pointing at the same place. */
	if (!check_same_stat(&smb_fname_cwd->st, &priv_paths->parent_name.st)) {
		DEBUG(0,(""check_reduced_name_with_privilege: ""
			""device/inode/uid/gid on directory %s changed. ""
			""Denying access !\n"",
			priv_paths->parent_name.base_name));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}

	/* Ensure we're below the connect path. */

	conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);
	if (conn_rootdir == NULL) {
		DEBUG(2, (""check_reduced_name_with_privilege: Could not get ""
			""conn_rootdir\n""));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}
        }
",C,"       bool matched;
",,5b730ab846a9d4ae44b425094af2934c2f7b2843,"@@ -982,6 +982,7 @@ NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
        struct smb_filename *smb_fname_cwd = NULL;
        struct privilege_paths *priv_paths = NULL;
        int ret;
+       bool matched;
 
        DEBUG(3,(""check_reduced_name_with_privilege [%s] [%s]\n"",
                        fname,
@@ -1076,7 +1077,10 @@ NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
        }
 
        rootdir_len = strlen(conn_rootdir);
-       if (strncmp(conn_rootdir, resolved_name, rootdir_len) != 0) {
+       matched = (strncmp(conn_rootdir, resolved_name, rootdir_len) == 0);
+
+       if (!matched || (resolved_name[rootdir_len] != '/' &&
+                        resolved_name[rootdir_len] != '\0')) {
                DEBUG(2, (""check_reduced_name_with_privilege: Bad access ""
                        ""attempt: %s is a symlink outside the ""
                        ""share path\n"",
@@ -1216,6 +1220,7 @@ NTSTATUS check_reduced_name(connection_struct *conn, const char *fname)
        if (!allow_widelinks || !allow_symlinks) {
                const char *conn_rootdir;
                size_t rootdir_len;
+               bool matched;
 
                conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);
                if (conn_rootdir == NULL) {
@@ -1226,8 +1231,10 @@ NTSTATUS check_reduced_name(connection_struct *conn, const char *fname)
                }
 
                rootdir_len = strlen(conn_rootdir);
-               if (strncmp(conn_rootdir, resolved_name,
-                               rootdir_len) != 0) {
+               matched = (strncmp(conn_rootdir, resolved_name,
+                               rootdir_len) == 0);
+               if (!matched || (resolved_name[rootdir_len] != '/' &&
+                                resolved_name[rootdir_len] != '\0')) {
                        DEBUG(2, (""check_reduced_name: Bad access ""
                                ""attempt: %s is a symlink outside the ""
                                ""share path\n"", fname));",samba,https://git.samba.org/?p=samba.git;a=blob;f=source3/smbd/vfs.c;h=f14ecbef9669dbf71c050a0a5363d262092963d1;hb=f14ecbef9669dbf71c050a0a5363d262092963d1,https://git.samba.org/?p=samba.git;a=blob;f=source3/smbd/vfs.c;h=9f3ba6dd905b9e432d342ee27573c9fb2bc005d0;hb=9f3ba6dd905b9e432d342ee27573c9fb2bc005d0,1,"NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
			const char *fname,
			struct smb_request *smbreq)
{
	NTSTATUS status;
	TALLOC_CTX *ctx = talloc_tos();
	const char *conn_rootdir;
	size_t rootdir_len;
	char *dir_name = NULL;
	const char *last_component = NULL;
	char *resolved_name = NULL;
	char *saved_dir = NULL;
        struct smb_filename *smb_fname_cwd = NULL;
        struct privilege_paths *priv_paths = NULL;
        int ret;
//fix_flaw_line_below:
//       bool matched;
 
        DEBUG(3,(""check_reduced_name_with_privilege [%s] [%s]\n"",
                        fname,


	priv_paths = talloc_zero(smbreq, struct privilege_paths);
	if (!priv_paths) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (!parent_dirname(ctx, fname, &dir_name, &last_component)) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	priv_paths->parent_name.base_name = talloc_strdup(priv_paths, dir_name);
	priv_paths->file_name.base_name = talloc_strdup(priv_paths, last_component);

	if (priv_paths->parent_name.base_name == NULL ||
			priv_paths->file_name.base_name == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_STAT(conn, &priv_paths->parent_name) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}
	/* Remember where we were. */
	saved_dir = vfs_GetWd(ctx, conn);
	if (!saved_dir) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Go to the parent directory to lock in memory. */
	if (vfs_ChDir(conn, priv_paths->parent_name.base_name) == -1) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Get the absolute path of the parent directory. */
	resolved_name = SMB_VFS_REALPATH(conn,""."");
	if (!resolved_name) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	if (*resolved_name != '/') {
		DEBUG(0,(""check_reduced_name_with_privilege: realpath ""
			""doesn't return absolute paths !\n""));
		status = NT_STATUS_OBJECT_NAME_INVALID;
		goto err;
	}

	DEBUG(10,(""check_reduced_name_with_privilege: realpath [%s] -> [%s]\n"",
		priv_paths->parent_name.base_name,
		resolved_name));

	/* Now check the stat value is the same. */
	smb_fname_cwd = synthetic_smb_fname(talloc_tos(), ""."", NULL, NULL);
	if (smb_fname_cwd == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_LSTAT(conn, smb_fname_cwd) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Ensure we're pointing at the same place. */
	if (!check_same_stat(&smb_fname_cwd->st, &priv_paths->parent_name.st)) {
		DEBUG(0,(""check_reduced_name_with_privilege: ""
			""device/inode/uid/gid on directory %s changed. ""
			""Denying access !\n"",
			priv_paths->parent_name.base_name));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}

	/* Ensure we're below the connect path. */

	conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);
	if (conn_rootdir == NULL) {
		DEBUG(2, (""check_reduced_name_with_privilege: Could not get ""
			""conn_rootdir\n""));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}
        }
",177855,"NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
			const char *fname,
			struct smb_request *smbreq)
{
	NTSTATUS status;
	TALLOC_CTX *ctx = talloc_tos();
	const char *conn_rootdir;
	size_t rootdir_len;
	char *dir_name = NULL;
	const char *last_component = NULL;
	char *resolved_name = NULL;
	char *saved_dir = NULL;
        struct smb_filename *smb_fname_cwd = NULL;
        struct privilege_paths *priv_paths = NULL;
        int ret;
 
        DEBUG(3,(""check_reduced_name_with_privilege [%s] [%s]\n"",
                        fname,


	priv_paths = talloc_zero(smbreq, struct privilege_paths);
	if (!priv_paths) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (!parent_dirname(ctx, fname, &dir_name, &last_component)) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	priv_paths->parent_name.base_name = talloc_strdup(priv_paths, dir_name);
	priv_paths->file_name.base_name = talloc_strdup(priv_paths, last_component);

	if (priv_paths->parent_name.base_name == NULL ||
			priv_paths->file_name.base_name == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_STAT(conn, &priv_paths->parent_name) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}
	/* Remember where we were. */
	saved_dir = vfs_GetWd(ctx, conn);
	if (!saved_dir) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Go to the parent directory to lock in memory. */
	if (vfs_ChDir(conn, priv_paths->parent_name.base_name) == -1) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Get the absolute path of the parent directory. */
	resolved_name = SMB_VFS_REALPATH(conn,""."");
	if (!resolved_name) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	if (*resolved_name != '/') {
		DEBUG(0,(""check_reduced_name_with_privilege: realpath ""
			""doesn't return absolute paths !\n""));
		status = NT_STATUS_OBJECT_NAME_INVALID;
		goto err;
	}

	DEBUG(10,(""check_reduced_name_with_privilege: realpath [%s] -> [%s]\n"",
		priv_paths->parent_name.base_name,
		resolved_name));

	/* Now check the stat value is the same. */
	smb_fname_cwd = synthetic_smb_fname(talloc_tos(), ""."", NULL, NULL);
	if (smb_fname_cwd == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_LSTAT(conn, smb_fname_cwd) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Ensure we're pointing at the same place. */
	if (!check_same_stat(&smb_fname_cwd->st, &priv_paths->parent_name.st)) {
		DEBUG(0,(""check_reduced_name_with_privilege: ""
			""device/inode/uid/gid on directory %s changed. ""
			""Denying access !\n"",
			priv_paths->parent_name.base_name));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}

	/* Ensure we're below the connect path. */

	conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);
	if (conn_rootdir == NULL) {
		DEBUG(2, (""check_reduced_name_with_privilege: Could not get ""
			""conn_rootdir\n""));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}
        }
","NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,
			const char *fname,
			struct smb_request *smbreq)
{
	NTSTATUS status;
	TALLOC_CTX *ctx = talloc_tos();
	const char *conn_rootdir;
	size_t rootdir_len;
	char *dir_name = NULL;
	const char *last_component = NULL;
	char *resolved_name = NULL;
	char *saved_dir = NULL;
        struct smb_filename *smb_fname_cwd = NULL;
        struct privilege_paths *priv_paths = NULL;
        int ret;
       bool matched;
 
        DEBUG(3,(""check_reduced_name_with_privilege [%s] [%s]\n"",
                        fname,


	priv_paths = talloc_zero(smbreq, struct privilege_paths);
	if (!priv_paths) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (!parent_dirname(ctx, fname, &dir_name, &last_component)) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	priv_paths->parent_name.base_name = talloc_strdup(priv_paths, dir_name);
	priv_paths->file_name.base_name = talloc_strdup(priv_paths, last_component);

	if (priv_paths->parent_name.base_name == NULL ||
			priv_paths->file_name.base_name == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_STAT(conn, &priv_paths->parent_name) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}
	/* Remember where we were. */
	saved_dir = vfs_GetWd(ctx, conn);
	if (!saved_dir) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Go to the parent directory to lock in memory. */
	if (vfs_ChDir(conn, priv_paths->parent_name.base_name) == -1) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Get the absolute path of the parent directory. */
	resolved_name = SMB_VFS_REALPATH(conn,""."");
	if (!resolved_name) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	if (*resolved_name != '/') {
		DEBUG(0,(""check_reduced_name_with_privilege: realpath ""
			""doesn't return absolute paths !\n""));
		status = NT_STATUS_OBJECT_NAME_INVALID;
		goto err;
	}

	DEBUG(10,(""check_reduced_name_with_privilege: realpath [%s] -> [%s]\n"",
		priv_paths->parent_name.base_name,
		resolved_name));

	/* Now check the stat value is the same. */
	smb_fname_cwd = synthetic_smb_fname(talloc_tos(), ""."", NULL, NULL);
	if (smb_fname_cwd == NULL) {
		status = NT_STATUS_NO_MEMORY;
		goto err;
	}

	if (SMB_VFS_LSTAT(conn, smb_fname_cwd) != 0) {
		status = map_nt_error_from_unix(errno);
		goto err;
	}

	/* Ensure we're pointing at the same place. */
	if (!check_same_stat(&smb_fname_cwd->st, &priv_paths->parent_name.st)) {
		DEBUG(0,(""check_reduced_name_with_privilege: ""
			""device/inode/uid/gid on directory %s changed. ""
			""Denying access !\n"",
			priv_paths->parent_name.base_name));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}

	/* Ensure we're below the connect path. */

	conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);
	if (conn_rootdir == NULL) {
		DEBUG(2, (""check_reduced_name_with_privilege: Could not get ""
			""conn_rootdir\n""));
		status = NT_STATUS_ACCESS_DENIED;
		goto err;
	}
        }
","The `check_reduced_name_with_privilege` function verifies access privileges for a specified file name within a given connection context. It begins by extracting the parent directory and the last component of the file name, allocating necessary memory for these components. The function checks if the parent directory exists and changes the working directory to it. It then retrieves the absolute path and compares the file system status of the parent directory to ensure it hasn't changed. Finally, it checks if the resolved path is within the connection's root directory, returning appropriate NTSTATUS codes for various error conditions, including memory issues and access denial.","The function checks the access privileges for a specified file name within a connection context by first determining the parent directory and the file's last component. It verifies the existence of the parent directory and changes the working directory to it, ensuring that the path remains valid. The function then retrieves the absolute path and compares the file system status of the parent directory to confirm it hasn't changed. Finally, it ensures that the resolved path is within the allowed connection root, returning appropriate status codes for any encountered errors, including memory allocation issues and access denials.","The vulnerability in the original code arises from the lack of a check to ensure that the resolved path is within the allowed connection root directory, which could lead to unauthorized access to files outside the intended directory structure. In the fixed code, a new boolean variable named `matched` is introduced, and additional logic is implemented to verify that the resolved path is indeed below the connection's root directory. This enhancement ensures that access is denied if the path does not conform to the expected directory structure, thereby mitigating the risk of unauthorized file access.","The vulnerability in the original code stems from the absence of a check to ensure that the resolved file path remains within the designated connection root directory, potentially allowing unauthorized access to files outside the intended scope. In the revised code, a new boolean variable is introduced, along with additional logic to verify that the resolved path is indeed contained within the allowed directory structure. This enhancement effectively restricts access to files, ensuring that any attempts to access paths outside the permitted boundaries are denied, thereby addressing the security risk present in the initial implementation.","The vulnerability was fixed by introducing a check to ensure that the resolved path is within the allowed connection root directory. In the updated code, the `conn_rootdir` variable is used to retrieve the connection's root path, and the logic is enhanced to compare the resolved path against this root directory. The addition of the `matched` boolean variable allows the code to determine if the resolved path is valid. If the path is not contained within the connection root, access is denied, effectively preventing unauthorized file access that could occur in the original implementation.","The vulnerability was addressed by implementing a verification step to ensure that the resolved file path remains within the designated connection root directory. The updated code introduces a mechanism to compare the resolved path against the allowed directory structure. If the path is found to be outside the permitted boundaries, access is denied. This additional check effectively restricts unauthorized access to files, ensuring that any attempts to navigate beyond the intended directory are blocked, thereby enhancing the overall security of the code and mitigating the risk present in the original implementation.","CWE-22, CWE-23, CWE-36, CWE-73, CWE-99, CWE-35, CWE-426, CWE-41, CWE-32, CWE-67",N,-1
4,4,177896,177896,,Local,Not required,Complete,CVE-2013-2007,https://www.cvedetails.com/cve/CVE-2013-2007/,CWE-264,Medium,Complete,Complete,,2013-05-21,6.9,"The qemu guest agent in Qemu 1.4.1 and earlier, as used by Xen, when started in daemon mode, uses weak permissions for certain files, which allows local users to read and write to these files.",2017-08-28,,1,https://git.qemu.org/?p=qemu.git;a=commit;h=c689b4f1bac352dcfd6ecb9a1d45337de0f1de67,c689b4f1bac352dcfd6ecb9a1d45337de0f1de67,,1,,,"static void become_daemon(const char *pidfile)
{
#ifndef _WIN32
    pid_t pid, sid;

    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }

    if (pidfile) {
        if (!ga_open_pidfile(pidfile)) {
            g_critical(""failed to create pidfile"");
            exit(EXIT_FAILURE);
         }
     }
 
    umask(S_IRWXG | S_IRWXO);
     sid = setsid();
     if (sid < 0) {
         goto fail;
    }
    if ((chdir(""/"")) < 0) {
        goto fail;
    }

    reopen_fd_to_null(STDIN_FILENO);
    reopen_fd_to_null(STDOUT_FILENO);
    reopen_fd_to_null(STDERR_FILENO);
    return;

fail:
    if (pidfile) {
        unlink(pidfile);
    }
    g_critical(""failed to daemonize"");
    exit(EXIT_FAILURE);
#endif
}
","static void become_daemon(const char *pidfile)
{
#ifndef _WIN32
    pid_t pid, sid;

    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }

    if (pidfile) {
        if (!ga_open_pidfile(pidfile)) {
            g_critical(""failed to create pidfile"");
            exit(EXIT_FAILURE);
         }
     }
 
    umask(0);
     sid = setsid();
     if (sid < 0) {
         goto fail;
    }
    if ((chdir(""/"")) < 0) {
        goto fail;
    }

    reopen_fd_to_null(STDIN_FILENO);
    reopen_fd_to_null(STDOUT_FILENO);
    reopen_fd_to_null(STDERR_FILENO);
    return;

fail:
    if (pidfile) {
        unlink(pidfile);
    }
    g_critical(""failed to daemonize"");
    exit(EXIT_FAILURE);
#endif
}
",C,"    umask(S_IRWXG | S_IRWXO);
","    umask(0);
",d7108d90100d5bac5965abef5ed73f2602adae14,"@@ -478,7 +478,7 @@ static void become_daemon(const char *pidfile)
         }
     }
 
-    umask(0);
+    umask(S_IRWXG | S_IRWXO);
     sid = setsid();
     if (sid < 0) {
         goto fail;",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=qga/main.c;h=44a283686bbf870a4a1adaa19a9d78f4c3a31108;hb=c689b4f1bac352dcfd6ecb9a1d45337de0f1de67,https://git.qemu.org/?p=qemu.git;a=blob;f=qga/main.c;h=1841759db270295c96262f215f92b408ac6f472c,1,"static void become_daemon(const char *pidfile)
{
#ifndef _WIN32
    pid_t pid, sid;

    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }

    if (pidfile) {
        if (!ga_open_pidfile(pidfile)) {
            g_critical(""failed to create pidfile"");
            exit(EXIT_FAILURE);
         }
     }
 
//flaw_line_below:
    umask(0);
//fix_flaw_line_below:
//    umask(S_IRWXG | S_IRWXO);
     sid = setsid();
     if (sid < 0) {
         goto fail;
    }
    if ((chdir(""/"")) < 0) {
        goto fail;
    }

    reopen_fd_to_null(STDIN_FILENO);
    reopen_fd_to_null(STDOUT_FILENO);
    reopen_fd_to_null(STDERR_FILENO);
    return;

fail:
    if (pidfile) {
        unlink(pidfile);
    }
    g_critical(""failed to daemonize"");
    exit(EXIT_FAILURE);
#endif
}
",177896,"static void become_daemon(const char *pidfile)
{
#ifndef _WIN32
    pid_t pid, sid;

    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }

    if (pidfile) {
        if (!ga_open_pidfile(pidfile)) {
            g_critical(""failed to create pidfile"");
            exit(EXIT_FAILURE);
         }
     }
 
    umask(0);
     sid = setsid();
     if (sid < 0) {
         goto fail;
    }
    if ((chdir(""/"")) < 0) {
        goto fail;
    }

    reopen_fd_to_null(STDIN_FILENO);
    reopen_fd_to_null(STDOUT_FILENO);
    reopen_fd_to_null(STDERR_FILENO);
    return;

fail:
    if (pidfile) {
        unlink(pidfile);
    }
    g_critical(""failed to daemonize"");
    exit(EXIT_FAILURE);
#endif
}
","static void become_daemon(const char *pidfile)
{
#ifndef _WIN32
    pid_t pid, sid;

    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }

    if (pidfile) {
        if (!ga_open_pidfile(pidfile)) {
            g_critical(""failed to create pidfile"");
            exit(EXIT_FAILURE);
         }
     }
 
    umask(S_IRWXG | S_IRWXO);
     sid = setsid();
     if (sid < 0) {
         goto fail;
    }
    if ((chdir(""/"")) < 0) {
        goto fail;
    }

    reopen_fd_to_null(STDIN_FILENO);
    reopen_fd_to_null(STDOUT_FILENO);
    reopen_fd_to_null(STDERR_FILENO);
    return;

fail:
    if (pidfile) {
        unlink(pidfile);
    }
    g_critical(""failed to daemonize"");
    exit(EXIT_FAILURE);
#endif
}
","The `become_daemon` function is designed to convert a running process into a daemon on Unix-like systems. It begins by forking the process; if the fork fails, it exits with an error. The parent process exits, while the child continues. If a PID file is specified, it attempts to create it, failing which it logs an error and exits. The function then sets the file mode creation mask to zero, creates a new session ID, and changes the working directory to the root. Finally, it redirects standard input, output, and error to `/dev/null`, ensuring the daemon runs in the background. If any step fails, it cleans up by removing the PID file and exits with an error.","The provided code defines a function that transforms a running process into a background daemon on Unix-like systems. It initiates by creating a child process, where the parent exits to allow the child to run independently. If specified, it attempts to create a file to store the process ID, exiting with an error if this fails. The function then sets the file creation permissions, establishes a new session to detach from the terminal, and changes the working directory to the root. Finally, it redirects standard input, output, and error streams to a null device, ensuring the daemon operates without terminal interaction. If any step fails, it cleans up by removing the PID file and exits with an error.","The vulnerability in the original code stemmed from the use of `umask(0)`, which allowed the daemon to create files with potentially insecure permissions, exposing them to unauthorized access. This could lead to privilege escalation or data leakage. In the fixed code, the `umask` function was modified to set a more restrictive mask (`S_IRWXG | S_IRWXO`), which limits the permissions for group and others, thereby enhancing security. This change ensures that any files created by the daemon have appropriate permissions, reducing the risk of unauthorized access and improving the overall security posture of the application.","The vulnerability in the original code arose from the lack of restrictions on file permissions, which could allow unauthorized access to files created by the daemon, potentially leading to security breaches. This issue was addressed in the revised code by implementing a more restrictive file creation mask, which limits the permissions granted to group and others. By doing so, the updated code ensures that any files created by the daemon are not accessible to unauthorized users, thereby enhancing the security of the application and mitigating the risk of privilege escalation or data leakage.","The vulnerability was fixed by changing the `umask` function from `umask(0)` to `umask(S_IRWXG | S_IRWXO)`. The original setting allowed the daemon to create files with unrestricted permissions, which could be accessed by unauthorized users. By setting a more restrictive mask, the updated code ensures that files created by the daemon have limited permissions for group and others, thereby preventing unauthorized access. This change enhances the security of the daemonized process, reducing the risk of privilege escalation and protecting sensitive data from potential leaks.","The vulnerability was fixed by implementing a more restrictive file creation mask, which limits the permissions granted to newly created files. This change ensures that files generated by the daemon are not accessible to unauthorized users, thereby enhancing security. By adjusting the permissions, the updated code prevents potential security breaches that could arise from unrestricted access, such as privilege escalation or data leakage. This proactive measure significantly improves the overall security posture of the application, ensuring that sensitive information remains protected from unauthorized access.","CWE-732, CWE-264, CWE-276, CWE-266, CWE-284, CWE-732, CWE-269, CWE-275, CWE-668, CWE-279",N,-1
5,5,177923,177923,,Remote,Not required,,CVE-2015-2348,https://www.cvedetails.com/cve/CVE-2015-2348/,CWE-264,Low,,Partial,,2015-03-30,5.0,"The move_uploaded_file implementation in ext/standard/basic_functions.c in PHP before 5.4.39, 5.5.x before 5.5.23, and 5.6.x before 5.6.7 truncates a pathname upon encountering a \x00 character, which allows remote attackers to bypass intended extension restrictions and create files with unexpected names via a crafted second argument.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2006-7243.",2018-10-30,Bypass,1,https://git.php.net/?p=php-src.git;a=commit;h=1291d6bbee93b6109eb07e8f7916ff1b7fcc13e1,1291d6bbee93b6109eb07e8f7916ff1b7fcc13e1,,1,,,"PHP_FUNCTION(move_uploaded_file)
{
	char *path, *new_path;
	int path_len, new_path_len;
	zend_bool successful = 0;

#ifndef PHP_WIN32
	int oldmask; int ret;
#endif

	if (!SG(rfc1867_uploaded_files)) {
                RETURN_FALSE;
        }
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sp"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
                return;
        }
	if (!zend_hash_exists(SG(rfc1867_uploaded_files), path, path_len + 1)) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(new_path TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (VCWD_RENAME(path, new_path) == 0) {
		successful = 1;
#ifndef PHP_WIN32
		oldmask = umask(077);
		umask(oldmask);

		ret = VCWD_CHMOD(new_path, 0666 & ~oldmask);

		if (ret == -1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s"", strerror(errno));
		}
#endif
	} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR TSRMLS_CC) == SUCCESS) {
		VCWD_UNLINK(path);
		successful = 1;
	}

	if (successful) {
		zend_hash_del(SG(rfc1867_uploaded_files), path, path_len + 1);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to move '%s' to '%s'"", path, new_path);
	}

	RETURN_BOOL(successful);
}
","PHP_FUNCTION(move_uploaded_file)
{
	char *path, *new_path;
	int path_len, new_path_len;
	zend_bool successful = 0;

#ifndef PHP_WIN32
	int oldmask; int ret;
#endif

	if (!SG(rfc1867_uploaded_files)) {
                RETURN_FALSE;
        }
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
                return;
        }
	if (!zend_hash_exists(SG(rfc1867_uploaded_files), path, path_len + 1)) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(new_path TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (VCWD_RENAME(path, new_path) == 0) {
		successful = 1;
#ifndef PHP_WIN32
		oldmask = umask(077);
		umask(oldmask);

		ret = VCWD_CHMOD(new_path, 0666 & ~oldmask);

		if (ret == -1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s"", strerror(errno));
		}
#endif
	} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR TSRMLS_CC) == SUCCESS) {
		VCWD_UNLINK(path);
		successful = 1;
	}

	if (successful) {
		zend_hash_del(SG(rfc1867_uploaded_files), path, path_len + 1);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to move '%s' to '%s'"", path, new_path);
	}

	RETURN_BOOL(successful);
}
",C,"       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sp"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
","       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
",c8eaca013a3922e8383def6158ece2b63f6ec483,"@@ -5775,7 +5775,7 @@ PHP_FUNCTION(move_uploaded_file)
                RETURN_FALSE;
        }
 
-       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
+       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sp"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
                return;
        }",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/standard/basic_functions.c;h=c3e223048afaa30e087036e006adb0849babcccc;hb=c3e223048afaa30e087036e006adb0849babcccc,https://git.php.net/?p=php-src.git;a=blob;f=ext/standard/basic_functions.c;h=9a9df3094bec559376bacfbb9e6737c28f91dfda;hb=9a9df3094bec559376bacfbb9e6737c28f91dfda,1,"PHP_FUNCTION(move_uploaded_file)
{
	char *path, *new_path;
	int path_len, new_path_len;
	zend_bool successful = 0;

#ifndef PHP_WIN32
	int oldmask; int ret;
#endif

	if (!SG(rfc1867_uploaded_files)) {
                RETURN_FALSE;
        }
 
//flaw_line_below:
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
//fix_flaw_line_below:
//       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sp"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
                return;
        }
	if (!zend_hash_exists(SG(rfc1867_uploaded_files), path, path_len + 1)) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(new_path TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (VCWD_RENAME(path, new_path) == 0) {
		successful = 1;
#ifndef PHP_WIN32
		oldmask = umask(077);
		umask(oldmask);

		ret = VCWD_CHMOD(new_path, 0666 & ~oldmask);

		if (ret == -1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s"", strerror(errno));
		}
#endif
	} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR TSRMLS_CC) == SUCCESS) {
		VCWD_UNLINK(path);
		successful = 1;
	}

	if (successful) {
		zend_hash_del(SG(rfc1867_uploaded_files), path, path_len + 1);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to move '%s' to '%s'"", path, new_path);
	}

	RETURN_BOOL(successful);
}
",177923,"PHP_FUNCTION(move_uploaded_file)
{
	char *path, *new_path;
	int path_len, new_path_len;
	zend_bool successful = 0;

#ifndef PHP_WIN32
	int oldmask; int ret;
#endif

	if (!SG(rfc1867_uploaded_files)) {
                RETURN_FALSE;
        }
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
                return;
        }
	if (!zend_hash_exists(SG(rfc1867_uploaded_files), path, path_len + 1)) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(new_path TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (VCWD_RENAME(path, new_path) == 0) {
		successful = 1;
#ifndef PHP_WIN32
		oldmask = umask(077);
		umask(oldmask);

		ret = VCWD_CHMOD(new_path, 0666 & ~oldmask);

		if (ret == -1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s"", strerror(errno));
		}
#endif
	} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR TSRMLS_CC) == SUCCESS) {
		VCWD_UNLINK(path);
		successful = 1;
	}

	if (successful) {
		zend_hash_del(SG(rfc1867_uploaded_files), path, path_len + 1);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to move '%s' to '%s'"", path, new_path);
	}

	RETURN_BOOL(successful);
}
","PHP_FUNCTION(move_uploaded_file)
{
	char *path, *new_path;
	int path_len, new_path_len;
	zend_bool successful = 0;

#ifndef PHP_WIN32
	int oldmask; int ret;
#endif

	if (!SG(rfc1867_uploaded_files)) {
                RETURN_FALSE;
        }
 
       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sp"", &path, &path_len, &new_path, &new_path_len) == FAILURE) {
                return;
        }
	if (!zend_hash_exists(SG(rfc1867_uploaded_files), path, path_len + 1)) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(new_path TSRMLS_CC)) {
		RETURN_FALSE;
	}

	if (VCWD_RENAME(path, new_path) == 0) {
		successful = 1;
#ifndef PHP_WIN32
		oldmask = umask(077);
		umask(oldmask);

		ret = VCWD_CHMOD(new_path, 0666 & ~oldmask);

		if (ret == -1) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s"", strerror(errno));
		}
#endif
	} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR TSRMLS_CC) == SUCCESS) {
		VCWD_UNLINK(path);
		successful = 1;
	}

	if (successful) {
		zend_hash_del(SG(rfc1867_uploaded_files), path, path_len + 1);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to move '%s' to '%s'"", path, new_path);
	}

	RETURN_BOOL(successful);
}
","The `move_uploaded_file` function in PHP is designed to securely move an uploaded file from a temporary location to a specified destination. It first checks if the uploaded file exists and validates the provided paths. If the destination path is permissible, it attempts to rename the file; if that fails, it tries to copy the file instead. Upon successful movement, it removes the original file from the temporary location and adjusts its permissions. If any operation fails, it triggers a warning and returns a boolean indicating the success or failure of the operation, ensuring proper error handling throughout the process.","The provided code implements a function that facilitates the secure transfer of an uploaded file from a temporary storage location to a specified destination. It begins by verifying the existence of the uploaded file and validating the destination path. If the destination is allowed, the function attempts to rename the file; if that operation fails, it resorts to copying the file instead. Upon successful transfer, it deletes the original file from the temporary location and adjusts its permissions. In case of any errors during the process, appropriate warnings are generated, and a boolean value indicating success or failure is returned.","The vulnerability in the original code stemmed from the use of the `zend_parse_parameters` function, which accepted a string type for the new path, potentially allowing for unsafe input that could lead to directory traversal attacks. This could enable an attacker to manipulate the file path and write files to unintended locations. The fix involved changing the parameter type from ""ss"" to ""sp"" in the `zend_parse_parameters` function, which ensures that the new path is treated as a string pointer, thereby enforcing stricter validation and reducing the risk of malicious input being processed, thus enhancing the overall security of the file upload functionality.","The vulnerability in the original code was related to inadequate validation of the input parameters, specifically allowing potentially unsafe file paths that could lead to directory traversal attacks. This could enable an attacker to manipulate the file upload process, resulting in files being written to unauthorized locations on the server. The fix involved modifying the parameter handling to enforce stricter validation, ensuring that the new path is treated more securely. This change effectively mitigated the risk of malicious input, enhancing the overall security of the file upload functionality and preventing unauthorized file access or manipulation.","The vulnerability was fixed by changing the parameter type in the `zend_parse_parameters` function from ""ss"" to ""sp,"" which ensures that the new path is treated as a string pointer rather than a simple string. This adjustment enhances input validation, making it more difficult for attackers to exploit the file upload process through malicious path manipulation. Additionally, the use of `php_check_open_basedir` remains crucial, as it checks if the new path is within allowed directories, further securing the file movement process against unauthorized access and directory traversal attacks.","The vulnerability was addressed by modifying the parameter handling to enforce stricter validation of the input paths. This change ensures that the new path is treated more securely, reducing the risk of accepting potentially malicious input that could lead to directory traversal attacks. Additionally, the implementation of checks to verify that the new path adheres to allowed directories further enhances security. These improvements collectively mitigate the risk of unauthorized file access and manipulation, ensuring that the file upload process is more robust against exploitation attempts.","CWE-22, CWE-73, CWE-23, CWE-36, CWE-35, CWE-99, CWE-641, CWE-434, CWE-544, CWE-20",N,-1
6,6,178074,178074,,Remote,Not required,Partial,CVE-2014-7815,https://www.cvedetails.com/cve/CVE-2014-7815/,CWE-264,Low,,,,2014-11-14,5.0,The set_pixel_format function in ui/vnc.c in QEMU allows remote attackers to cause a denial of service (crash) via a small bytes_per_pixel value.,2017-12-27,DoS,10,https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829,e6908bfe8e07f2b452e78e677da1b45b1c0f6829,,0,,,"static void set_pixel_format(VncState *vs,
                             int bits_per_pixel, int depth,
                             int big_endian_flag, int true_color_flag,
                             int red_max, int green_max, int blue_max,
                             int red_shift, int green_shift, int blue_shift)
{
    if (!true_color_flag) {
        vnc_client_error(vs);
         return;
     }
 
    switch (bits_per_pixel) {
    case 8:
    case 16:
    case 32:
        break;
    default:
        vnc_client_error(vs);
        return;
    }

     vs->client_pf.rmax = red_max;
     vs->client_pf.rbits = hweight_long(red_max);
     vs->client_pf.rshift = red_shift;
    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;
    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;
    vs->client_be = big_endian_flag;

    set_pixel_conversion(vs);

    graphic_hw_invalidate(NULL);
    graphic_hw_update(NULL);
}
","static void set_pixel_format(VncState *vs,
                             int bits_per_pixel, int depth,
                             int big_endian_flag, int true_color_flag,
                             int red_max, int green_max, int blue_max,
                             int red_shift, int green_shift, int blue_shift)
{
    if (!true_color_flag) {
        vnc_client_error(vs);
         return;
     }
 
     vs->client_pf.rmax = red_max;
     vs->client_pf.rbits = hweight_long(red_max);
     vs->client_pf.rshift = red_shift;
    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;
    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;
    vs->client_be = big_endian_flag;

    set_pixel_conversion(vs);

    graphic_hw_invalidate(NULL);
    graphic_hw_update(NULL);
}
",C,"    switch (bits_per_pixel) {
    case 8:
    case 16:
    case 32:
        break;
    default:
        vnc_client_error(vs);
        return;
    }

",,3e9418e160cd8901c83a3c88967158084f5b5c03,"@@ -2026,6 +2026,16 @@ static void set_pixel_format(VncState *vs,
         return;
     }
 
+    switch (bits_per_pixel) {
+    case 8:
+    case 16:
+    case 32:
+        break;
+    default:
+        vnc_client_error(vs);
+        return;
+    }
+
     vs->client_pf.rmax = red_max;
     vs->client_pf.rbits = hweight_long(red_max);
     vs->client_pf.rshift = red_shift;",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=ui/vnc.c;h=8bca59798c84011dd7d7320f013a6997d6b0a4bc;hb=8bca59798c84011dd7d7320f013a6997d6b0a4bc,https://git.qemu.org/?p=qemu.git;a=blob;f=ui/vnc.c;h=0fe6eff1b8a661d7cb123b37bb49921c72d5df16;hb=0fe6eff1b8a661d7cb123b37bb49921c72d5df16,1,"static void set_pixel_format(VncState *vs,
                             int bits_per_pixel, int depth,
                             int big_endian_flag, int true_color_flag,
                             int red_max, int green_max, int blue_max,
                             int red_shift, int green_shift, int blue_shift)
{
    if (!true_color_flag) {
        vnc_client_error(vs);
         return;
     }
 
//fix_flaw_line_below:
//    switch (bits_per_pixel) {
//fix_flaw_line_below:
//    case 8:
//fix_flaw_line_below:
//    case 16:
//fix_flaw_line_below:
//    case 32:
//fix_flaw_line_below:
//        break;
//fix_flaw_line_below:
//    default:
//fix_flaw_line_below:
//        vnc_client_error(vs);
//fix_flaw_line_below:
//        return;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     vs->client_pf.rmax = red_max;
     vs->client_pf.rbits = hweight_long(red_max);
     vs->client_pf.rshift = red_shift;
    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;
    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;
    vs->client_be = big_endian_flag;

    set_pixel_conversion(vs);

    graphic_hw_invalidate(NULL);
    graphic_hw_update(NULL);
}
",178074,"static void set_pixel_format(VncState *vs,
                             int bits_per_pixel, int depth,
                             int big_endian_flag, int true_color_flag,
                             int red_max, int green_max, int blue_max,
                             int red_shift, int green_shift, int blue_shift)
{
    if (!true_color_flag) {
        vnc_client_error(vs);
         return;
     }
 
     vs->client_pf.rmax = red_max;
     vs->client_pf.rbits = hweight_long(red_max);
     vs->client_pf.rshift = red_shift;
    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;
    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;
    vs->client_be = big_endian_flag;

    set_pixel_conversion(vs);

    graphic_hw_invalidate(NULL);
    graphic_hw_update(NULL);
}
","static void set_pixel_format(VncState *vs,
                             int bits_per_pixel, int depth,
                             int big_endian_flag, int true_color_flag,
                             int red_max, int green_max, int blue_max,
                             int red_shift, int green_shift, int blue_shift)
{
    if (!true_color_flag) {
        vnc_client_error(vs);
         return;
     }
 
    switch (bits_per_pixel) {
    case 8:
    case 16:
    case 32:
        break;
    default:
        vnc_client_error(vs);
        return;
    }

     vs->client_pf.rmax = red_max;
     vs->client_pf.rbits = hweight_long(red_max);
     vs->client_pf.rshift = red_shift;
    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;
    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;
    vs->client_be = big_endian_flag;

    set_pixel_conversion(vs);

    graphic_hw_invalidate(NULL);
    graphic_hw_update(NULL);
}
","The `set_pixel_format` function configures the pixel format for a VNC (Virtual Network Computing) client by setting various parameters such as bits per pixel, color depth, and color channel specifications (red, green, blue). It first checks if true color is enabled; if not, it triggers an error and exits. If true color is valid, it assigns values for the maximum color values, bit representation, and shifts for each color channel. The function also determines the number of bytes per pixel and adjusts the depth accordingly. Finally, it calls `set_pixel_conversion` to apply the format and updates the graphical hardware state.","The function configures the pixel format for a virtual network client by setting parameters related to color representation and depth. It first verifies if true color support is enabled; if not, it triggers an error and exits. When true color is valid, it assigns maximum values and bit representations for the color channels, calculates the number of bytes per pixel, and adjusts the color depth based on the bits per pixel. Finally, it applies the pixel format settings and updates the graphical hardware state to reflect the new configuration, ensuring proper rendering of visual data.","The vulnerability in the original code stemmed from a lack of validation for the `bits_per_pixel` parameter, which could allow unsupported values to be processed, potentially leading to undefined behavior or security issues. In the fixed code, a switch statement was introduced to explicitly check if `bits_per_pixel` is either 8, 16, or 32. If it does not match these values, the function triggers an error and exits early, preventing any further processing with invalid parameters. This change ensures that only valid pixel formats are accepted, enhancing the robustness and security of the function.","The vulnerability in the original code arose from insufficient validation of a critical parameter, allowing unsupported values to be processed, which could lead to undefined behavior or security risks. The fixed code addresses this issue by implementing a validation mechanism that checks the parameter against a predefined set of acceptable values. If the parameter does not match any of these values, the function triggers an error and exits early, preventing further execution with invalid data. This enhancement ensures that only valid configurations are processed, thereby improving the overall security and stability of the function.","The vulnerability was fixed by introducing a switch statement that validates the `bits_per_pixel` parameter against acceptable values of 8, 16, or 32. If `bits_per_pixel` does not match these cases, the function calls `vnc_client_error(vs)` and exits early, preventing any further processing with invalid input. This change ensures that only supported pixel formats are accepted, thereby mitigating the risk of undefined behavior or security issues that could arise from processing unsupported values. The added validation enhances the robustness of the function by enforcing stricter input requirements.","The vulnerability was fixed by implementing a validation mechanism that checks a critical parameter against a predefined set of acceptable values. This mechanism ensures that only valid configurations are processed by the function. If the parameter does not match any of the acceptable values, the function triggers an error and exits early, preventing any further execution with invalid input. This enhancement effectively mitigates the risk of undefined behavior or security issues that could arise from processing unsupported values, thereby improving the overall security and stability of the code.","CWE-20, CWE-1286, CWE-754, CWE-1284, CWE-74, CWE-502, CWE-1174, CWE-1173, CWE-138, CWE-179",N,-1
7,7,178405,178405,,Remote,Not required,,CVE-2011-4328,https://www.cvedetails.com/cve/CVE-2011-4328/,CWE-264,Low,Partial,,,2012-06-15,5.0,"plugin/npapi/plugin.cpp in Gnash before 0.8.10 uses weak permissions (world readable) for cookie files with predictable names in /tmp, which allows local users to obtain sensitive information.",2014-01-07,+Info,1,https://git.savannah.gnu.org/gitweb/?p=gnash.git;a=commitdiff;h=fa481c116e65ccf9137c7ddc8abc3cf05dc12f55,fa481c116e65ccf9137c7ddc8abc3cf05dc12f55,,0,,,"nsPluginInstance::setupCookies(const std::string& pageurl)
{
    std::string::size_type pos;
    pos = pageurl.find(""/"", pageurl.find(""//"", 0) + 2) + 1;
    std::string url = pageurl.substr(0, pos);

    std::string ncookie;
 
    char *cookie = 0;
    uint32_t length = 0;

    NPError rv = NPERR_GENERIC_ERROR;
#if NPAPI_VERSION != 190
    if (NPNFuncs.getvalueforurl) {
        rv = NPN_GetValueForURL(_instance, NPNURLVCookie, url.c_str(),
                                &cookie, &length);
    } else {
        LOG_ONCE( gnash::log_debug(""Browser doesn't support getvalueforurl"") );
    }
#endif

    if (rv == NPERR_GENERIC_ERROR) {
        log_debug(""Trying window.document.cookie for cookies"");
        ncookie = getDocumentProp(""cookie"");
    }

    if (cookie) {
        ncookie.assign(cookie, length);
        NPN_MemFree(cookie);
    }

    if (ncookie.empty()) {
        gnash::log_debug(""No stored Cookie for %s"", url);
        return;
    }

    gnash::log_debug(""The Cookie for %s is %s"", url, ncookie);
    std::ofstream cookiefile;
    std::stringstream ss;
     ss << ""/tmp/gnash-cookies."" << getpid();
 
     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);
    chmod (ss.str().c_str(), 0600);
 
  
    typedef boost::char_separator<char> char_sep;
    typedef boost::tokenizer<char_sep> tokenizer;
    tokenizer tok(ncookie, char_sep("";""));

    for (tokenizer::iterator it=tok.begin(); it != tok.end(); ++it) {
        cookiefile << ""Set-Cookie: "" << *it << std::endl;
    }
 
    cookiefile.close();
  
    if (setenv(""GNASH_COOKIES_IN"", ss.str().c_str(), 1) < 0) {
        gnash::log_error(
            ""Couldn't set environment variable GNASH_COOKIES_IN to %s"",
            ncookie);
    }
}
","nsPluginInstance::setupCookies(const std::string& pageurl)
{
    std::string::size_type pos;
    pos = pageurl.find(""/"", pageurl.find(""//"", 0) + 2) + 1;
    std::string url = pageurl.substr(0, pos);

    std::string ncookie;
 
    char *cookie = 0;
    uint32_t length = 0;

    NPError rv = NPERR_GENERIC_ERROR;
#if NPAPI_VERSION != 190
    if (NPNFuncs.getvalueforurl) {
        rv = NPN_GetValueForURL(_instance, NPNURLVCookie, url.c_str(),
                                &cookie, &length);
    } else {
        LOG_ONCE( gnash::log_debug(""Browser doesn't support getvalueforurl"") );
    }
#endif

    if (rv == NPERR_GENERIC_ERROR) {
        log_debug(""Trying window.document.cookie for cookies"");
        ncookie = getDocumentProp(""cookie"");
    }

    if (cookie) {
        ncookie.assign(cookie, length);
        NPN_MemFree(cookie);
    }

    if (ncookie.empty()) {
        gnash::log_debug(""No stored Cookie for %s"", url);
        return;
    }

    gnash::log_debug(""The Cookie for %s is %s"", url, ncookie);
    std::ofstream cookiefile;
    std::stringstream ss;
     ss << ""/tmp/gnash-cookies."" << getpid();
 
     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);
 
  
    typedef boost::char_separator<char> char_sep;
    typedef boost::tokenizer<char_sep> tokenizer;
    tokenizer tok(ncookie, char_sep("";""));

    for (tokenizer::iterator it=tok.begin(); it != tok.end(); ++it) {
        cookiefile << ""Set-Cookie: "" << *it << std::endl;
    }
 
    cookiefile.close();
  
    if (setenv(""GNASH_COOKIES_IN"", ss.str().c_str(), 1) < 0) {
        gnash::log_error(
            ""Couldn't set environment variable GNASH_COOKIES_IN to %s"",
            ncookie);
    }
}
",CPP,"    chmod (ss.str().c_str(), 0600);
",,3dea0709b06a82ad8085d04daf86c9beff93d742,"@@ -1108,6 +1108,7 @@ nsPluginInstance::setupCookies(const std::string& pageurl)
     ss << ""/tmp/gnash-cookies."" << getpid();
 
     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);
+    chmod (ss.str().c_str(), 0600);
 
     // Firefox provides cookies in the following format:
     //",savannah,https://git.savannah.gnu.org/gitweb/?p=gnash.git;a=blob;f=plugin/npapi/plugin.cpp;h=04950e6c950249a55b6e70e120ea327456bd3a39;hb=fa481c116e65ccf9137c7ddc8abc3cf05dc12f55,https://git.savannah.gnu.org/gitweb/?p=gnash.git;a=blob;f=plugin/npapi/plugin.cpp;h=e161a1d2d9bfa0e0dfe44933bc373c7b3a9c1819,1,"nsPluginInstance::setupCookies(const std::string& pageurl)
{
    // Cookie appear to drop anything past the domain, so we strip
    // that off.
    std::string::size_type pos;
    pos = pageurl.find(""/"", pageurl.find(""//"", 0) + 2) + 1;
    std::string url = pageurl.substr(0, pos);

    std::string ncookie;
 
    char *cookie = 0;
    uint32_t length = 0;

    NPError rv = NPERR_GENERIC_ERROR;
#if NPAPI_VERSION != 190
    if (NPNFuncs.getvalueforurl) {
        rv = NPN_GetValueForURL(_instance, NPNURLVCookie, url.c_str(),
                                &cookie, &length);
    } else {
        LOG_ONCE( gnash::log_debug(""Browser doesn't support getvalueforurl"") );
    }
#endif

    // Firefox does not (always) return the cookies that are associated
    // with a domain name through GetValueForURL.
    if (rv == NPERR_GENERIC_ERROR) {
        log_debug(""Trying window.document.cookie for cookies"");
        ncookie = getDocumentProp(""cookie"");
    }

    if (cookie) {
        ncookie.assign(cookie, length);
        NPN_MemFree(cookie);
    }

    if (ncookie.empty()) {
        gnash::log_debug(""No stored Cookie for %s"", url);
        return;
    }

    gnash::log_debug(""The Cookie for %s is %s"", url, ncookie);
    std::ofstream cookiefile;
    std::stringstream ss;
     ss << ""/tmp/gnash-cookies."" << getpid();
 
     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);
//fix_flaw_line_below:
//    chmod (ss.str().c_str(), 0600);
 
     // Firefox provides cookies in the following format:
     //
    //
    // Whereas libcurl expects cookies in the following format:
    //
    // Set-Cookie: cookie1=value1;
    // Set-Cookie: cookie2=value2;
  
    typedef boost::char_separator<char> char_sep;
    typedef boost::tokenizer<char_sep> tokenizer;
    tokenizer tok(ncookie, char_sep("";""));

    for (tokenizer::iterator it=tok.begin(); it != tok.end(); ++it) {
        cookiefile << ""Set-Cookie: "" << *it << std::endl;
    }
 
    cookiefile.close();
  
    if (setenv(""GNASH_COOKIES_IN"", ss.str().c_str(), 1) < 0) {
        gnash::log_error(
            ""Couldn't set environment variable GNASH_COOKIES_IN to %s"",
            ncookie);
    }
}
",178405,"nsPluginInstance::setupCookies(const std::string& pageurl)
{
    std::string::size_type pos;
    pos = pageurl.find(""/"", pageurl.find(""//"", 0) + 2) + 1;
    std::string url = pageurl.substr(0, pos);

    std::string ncookie;
 
    char *cookie = 0;
    uint32_t length = 0;

    NPError rv = NPERR_GENERIC_ERROR;
#if NPAPI_VERSION != 190
    if (NPNFuncs.getvalueforurl) {
        rv = NPN_GetValueForURL(_instance, NPNURLVCookie, url.c_str(),
                                &cookie, &length);
    } else {
        LOG_ONCE( gnash::log_debug(""Browser doesn't support getvalueforurl"") );
    }
#endif

    if (rv == NPERR_GENERIC_ERROR) {
        log_debug(""Trying window.document.cookie for cookies"");
        ncookie = getDocumentProp(""cookie"");
    }

    if (cookie) {
        ncookie.assign(cookie, length);
        NPN_MemFree(cookie);
    }

    if (ncookie.empty()) {
        gnash::log_debug(""No stored Cookie for %s"", url);
        return;
    }

    gnash::log_debug(""The Cookie for %s is %s"", url, ncookie);
    std::ofstream cookiefile;
    std::stringstream ss;
     ss << ""/tmp/gnash-cookies."" << getpid();
 
     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);
 
  
    typedef boost::char_separator<char> char_sep;
    typedef boost::tokenizer<char_sep> tokenizer;
    tokenizer tok(ncookie, char_sep("";""));

    for (tokenizer::iterator it=tok.begin(); it != tok.end(); ++it) {
        cookiefile << ""Set-Cookie: "" << *it << std::endl;
    }
 
    cookiefile.close();
  
    if (setenv(""GNASH_COOKIES_IN"", ss.str().c_str(), 1) < 0) {
        gnash::log_error(
            ""Couldn't set environment variable GNASH_COOKIES_IN to %s"",
            ncookie);
    }
}
","nsPluginInstance::setupCookies(const std::string& pageurl)
{
    std::string::size_type pos;
    pos = pageurl.find(""/"", pageurl.find(""//"", 0) + 2) + 1;
    std::string url = pageurl.substr(0, pos);

    std::string ncookie;
 
    char *cookie = 0;
    uint32_t length = 0;

    NPError rv = NPERR_GENERIC_ERROR;
#if NPAPI_VERSION != 190
    if (NPNFuncs.getvalueforurl) {
        rv = NPN_GetValueForURL(_instance, NPNURLVCookie, url.c_str(),
                                &cookie, &length);
    } else {
        LOG_ONCE( gnash::log_debug(""Browser doesn't support getvalueforurl"") );
    }
#endif

    if (rv == NPERR_GENERIC_ERROR) {
        log_debug(""Trying window.document.cookie for cookies"");
        ncookie = getDocumentProp(""cookie"");
    }

    if (cookie) {
        ncookie.assign(cookie, length);
        NPN_MemFree(cookie);
    }

    if (ncookie.empty()) {
        gnash::log_debug(""No stored Cookie for %s"", url);
        return;
    }

    gnash::log_debug(""The Cookie for %s is %s"", url, ncookie);
    std::ofstream cookiefile;
    std::stringstream ss;
     ss << ""/tmp/gnash-cookies."" << getpid();
 
     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);
    chmod (ss.str().c_str(), 0600);
 
  
    typedef boost::char_separator<char> char_sep;
    typedef boost::tokenizer<char_sep> tokenizer;
    tokenizer tok(ncookie, char_sep("";""));

    for (tokenizer::iterator it=tok.begin(); it != tok.end(); ++it) {
        cookiefile << ""Set-Cookie: "" << *it << std::endl;
    }
 
    cookiefile.close();
  
    if (setenv(""GNASH_COOKIES_IN"", ss.str().c_str(), 1) < 0) {
        gnash::log_error(
            ""Couldn't set environment variable GNASH_COOKIES_IN to %s"",
            ncookie);
    }
}
","The `nsPluginInstance::setupCookies` function retrieves and processes cookies associated with a given URL. It first extracts the base URL from the provided `pageurl` and attempts to obtain cookies using the `NPN_GetValueForURL` function if supported. If this fails, it falls back to accessing cookies via `window.document.cookie`. The retrieved cookies are then stored in a temporary file, formatted as ""Set-Cookie"", and the file path is set as an environment variable `GNASH_COOKIES_IN`. The function logs relevant information throughout the process, including any errors encountered and the final cookie data.","The code retrieves and processes cookies associated with a specified URL. It extracts the base URL and attempts to obtain cookies using a specific browser function, falling back to a different method if that fails. The retrieved cookies are then formatted and written to a temporary file, while also setting the file path as an environment variable for later use. Throughout the process, the code logs relevant information, including any errors encountered and the final cookie data, ensuring that the cookie management is handled effectively and transparently.","The vulnerability in the original code arises from the lack of proper file permissions when creating the temporary cookie file, which could allow unauthorized access to sensitive cookie data. In the fixed code, the addition of the `chmod` function call sets the file permissions to `0600`, ensuring that only the owner can read and write to the file. This change mitigates the risk of exposure by preventing other users from accessing the cookie information stored in the temporary file, thereby enhancing the security of the cookie management process.","The vulnerability in the original code stems from inadequate file permissions when creating a temporary file to store sensitive cookie data, potentially allowing unauthorized access to this information. This oversight could lead to exposure of sensitive user data to other users on the system. The fix implemented in the updated code involves explicitly setting the file permissions to restrict access, ensuring that only the owner can read and write to the file. This enhancement significantly improves security by safeguarding the cookie information from unauthorized access, thereby protecting user privacy and data integrity.","The vulnerability was fixed by adding a call to the `chmod` function after creating the temporary cookie file. This function sets the file permissions to `0600`, which restricts access so that only the owner can read and write to the file. By implementing this change, the code ensures that sensitive cookie data stored in the temporary file is protected from unauthorized access by other users on the system. This enhancement significantly improves the security of the cookie management process, safeguarding user data and maintaining privacy.","The vulnerability was addressed by implementing a mechanism to set strict file permissions on the temporary file created for storing sensitive cookie data. By ensuring that only the file owner has read and write access, the fix effectively prevents unauthorized users from accessing the stored information. This change enhances the overall security of the application by safeguarding sensitive user data from potential exposure, thereby protecting user privacy and maintaining data integrity. The adjustment reflects a proactive approach to secure coding practices, particularly in handling sensitive information.","CWE-732, CWE-200, CWE-379, CWE-378, CWE-276, CWE-264, CWE-266, CWE-522, CWE-426, CWE-552",N,-1
8,8,178455,178455,,Local,Not required,Complete,CVE-2015-8325,https://www.cvedetails.com/cve/CVE-2015-8325/,CWE-264,Low,Complete,Complete,,2016-04-30,7.2,"The do_setup_env function in session.c in sshd in OpenSSH through 7.2p2, when the UseLogin feature is enabled and PAM is configured to read .pam_environment files in user home directories, allows local users to gain privileges by triggering a crafted environment for the /bin/login program, as demonstrated by an LD_PRELOAD environment variable.",2018-06-29,+Priv,1,https://anongit.mindrot.org/openssh.git/commit/?id=85bdcd7c92fe7ff133bbc4e10a65c91810f88755,85bdcd7c92fe7ff133bbc4e10a65c91810f88755,,1,,,"do_setup_env(Session *s, const char *shell)
{
	struct ssh *ssh = active_state; /* XXX */
	char buf[256];
	u_int i, envsize;
	char **env, *laddr;
	struct passwd *pw = s->pw;
#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)
	char *path = NULL;
#endif

	/* Initialize the environment. */
	envsize = 100;
	env = xcalloc(envsize, sizeof(char *));
	env[0] = NULL;

#ifdef HAVE_CYGWIN
	/*
	 * The Windows environment contains some setting which are
	 * important for a running system. They must not be dropped.
	 */
	{
		char **p;

		p = fetch_windows_environment();
		copy_environment(p, &env, &envsize);
		free_windows_environment(p);
	}
#endif

#ifdef GSSAPI
	/* Allow any GSSAPI methods that we've used to alter
	 * the childs environment as they see fit
	 */
	ssh_gssapi_do_child(&env, &envsize);
#endif

	if (!options.use_login) {
		/* Set basic environment. */
		for (i = 0; i < s->num_env; i++)
			child_set_env(&env, &envsize, s->env[i].name,
			    s->env[i].val);

		child_set_env(&env, &envsize, ""USER"", pw->pw_name);
		child_set_env(&env, &envsize, ""LOGNAME"", pw->pw_name);
#ifdef _AIX
		child_set_env(&env, &envsize, ""LOGIN"", pw->pw_name);
#endif
		child_set_env(&env, &envsize, ""HOME"", pw->pw_dir);
#ifdef HAVE_LOGIN_CAP
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
			child_set_env(&env, &envsize, ""PATH"", _PATH_STDPATH);
		else
			child_set_env(&env, &envsize, ""PATH"", getenv(""PATH""));
#else /* HAVE_LOGIN_CAP */
# ifndef HAVE_CYGWIN
		/*
		 * There's no standard path on Windows. The path contains
		 * important components pointing to the system directories,
		 * needed for loading shared libraries. So the path better
		 * remains intact here.
		 */
#  ifdef HAVE_ETC_DEFAULT_LOGIN
		read_etc_default_login(&env, &envsize, pw->pw_uid);
		path = child_get_env(env, ""PATH"");
#  endif /* HAVE_ETC_DEFAULT_LOGIN */
		if (path == NULL || *path == '\0') {
			child_set_env(&env, &envsize, ""PATH"",
			    s->pw->pw_uid == 0 ?
				SUPERUSER_PATH : _PATH_STDPATH);
		}
# endif /* HAVE_CYGWIN */
#endif /* HAVE_LOGIN_CAP */

		snprintf(buf, sizeof buf, ""%.200s/%.50s"",
			 _PATH_MAILDIR, pw->pw_name);
		child_set_env(&env, &envsize, ""MAIL"", buf);

		/* Normal systems set SHELL by default. */
		child_set_env(&env, &envsize, ""SHELL"", shell);
	}
	if (getenv(""TZ""))
		child_set_env(&env, &envsize, ""TZ"", getenv(""TZ""));

	/* Set custom environment options from RSA authentication. */
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *str = ce->s;

			for (i = 0; str[i] != '=' && str[i]; i++)
				;
			if (str[i] == '=') {
				str[i] = 0;
				child_set_env(&env, &envsize, str, str + i + 1);
			}
			custom_environment = ce->next;
			free(ce->s);
			free(ce);
		}
	}

	/* SSH_CLIENT deprecated */
	snprintf(buf, sizeof buf, ""%.50s %d %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    ssh_local_port(ssh));
	child_set_env(&env, &envsize, ""SSH_CLIENT"", buf);

	laddr = get_local_ipaddr(packet_get_connection_in());
	snprintf(buf, sizeof buf, ""%.50s %d %.50s %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    laddr, ssh_local_port(ssh));
	free(laddr);
	child_set_env(&env, &envsize, ""SSH_CONNECTION"", buf);

	if (s->ttyfd != -1)
		child_set_env(&env, &envsize, ""SSH_TTY"", s->tty);
	if (s->term)
		child_set_env(&env, &envsize, ""TERM"", s->term);
	if (s->display)
		child_set_env(&env, &envsize, ""DISPLAY"", s->display);
	if (original_command)
		child_set_env(&env, &envsize, ""SSH_ORIGINAL_COMMAND"",
		    original_command);

#ifdef _UNICOS
	if (cray_tmpdir[0] != '\0')
		child_set_env(&env, &envsize, ""TMPDIR"", cray_tmpdir);
#endif /* _UNICOS */

	/*
	 * Since we clear KRB5CCNAME at startup, if it's set now then it
	 * must have been set by a native authentication method (eg AIX or
	 * SIA), so copy it to the child.
	 */
	{
		char *cp;

		if ((cp = getenv(""KRB5CCNAME"")) != NULL)
			child_set_env(&env, &envsize, ""KRB5CCNAME"", cp);
	}

#ifdef _AIX
	{
		char *cp;

		if ((cp = getenv(""AUTHSTATE"")) != NULL)
			child_set_env(&env, &envsize, ""AUTHSTATE"", cp);
		read_environment_file(&env, &envsize, ""/etc/environment"");
	}
#endif
#ifdef KRB5
	if (s->authctxt->krb5_ccname)
		child_set_env(&env, &envsize, ""KRB5CCNAME"",
		    s->authctxt->krb5_ccname);
#endif
#ifdef USE_PAM
	/*
 	 * Pull in any environment variables that may have
 	 * been set by PAM.
 	 */
	if (options.use_pam && !options.use_login) {
 		char **p;
 
 		p = fetch_pam_child_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);

		p = fetch_pam_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);
	}
#endif /* USE_PAM */

	if (auth_sock_name != NULL)
		child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,
		    auth_sock_name);

	/* read $HOME/.ssh/environment. */
	if (options.permit_user_env && !options.use_login) {
		snprintf(buf, sizeof buf, ""%.200s/.ssh/environment"",
		    strcmp(pw->pw_dir, ""/"") ? pw->pw_dir : """");
		read_environment_file(&env, &envsize, buf);
	}
	if (debug_flag) {
		/* dump the environment */
		fprintf(stderr, ""Environment:\n"");
		for (i = 0; env[i]; i++)
			fprintf(stderr, ""  %.200s\n"", env[i]);
	}
	return env;
}
","do_setup_env(Session *s, const char *shell)
{
	struct ssh *ssh = active_state; /* XXX */
	char buf[256];
	u_int i, envsize;
	char **env, *laddr;
	struct passwd *pw = s->pw;
#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)
	char *path = NULL;
#endif

	/* Initialize the environment. */
	envsize = 100;
	env = xcalloc(envsize, sizeof(char *));
	env[0] = NULL;

#ifdef HAVE_CYGWIN
	/*
	 * The Windows environment contains some setting which are
	 * important for a running system. They must not be dropped.
	 */
	{
		char **p;

		p = fetch_windows_environment();
		copy_environment(p, &env, &envsize);
		free_windows_environment(p);
	}
#endif

#ifdef GSSAPI
	/* Allow any GSSAPI methods that we've used to alter
	 * the childs environment as they see fit
	 */
	ssh_gssapi_do_child(&env, &envsize);
#endif

	if (!options.use_login) {
		/* Set basic environment. */
		for (i = 0; i < s->num_env; i++)
			child_set_env(&env, &envsize, s->env[i].name,
			    s->env[i].val);

		child_set_env(&env, &envsize, ""USER"", pw->pw_name);
		child_set_env(&env, &envsize, ""LOGNAME"", pw->pw_name);
#ifdef _AIX
		child_set_env(&env, &envsize, ""LOGIN"", pw->pw_name);
#endif
		child_set_env(&env, &envsize, ""HOME"", pw->pw_dir);
#ifdef HAVE_LOGIN_CAP
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
			child_set_env(&env, &envsize, ""PATH"", _PATH_STDPATH);
		else
			child_set_env(&env, &envsize, ""PATH"", getenv(""PATH""));
#else /* HAVE_LOGIN_CAP */
# ifndef HAVE_CYGWIN
		/*
		 * There's no standard path on Windows. The path contains
		 * important components pointing to the system directories,
		 * needed for loading shared libraries. So the path better
		 * remains intact here.
		 */
#  ifdef HAVE_ETC_DEFAULT_LOGIN
		read_etc_default_login(&env, &envsize, pw->pw_uid);
		path = child_get_env(env, ""PATH"");
#  endif /* HAVE_ETC_DEFAULT_LOGIN */
		if (path == NULL || *path == '\0') {
			child_set_env(&env, &envsize, ""PATH"",
			    s->pw->pw_uid == 0 ?
				SUPERUSER_PATH : _PATH_STDPATH);
		}
# endif /* HAVE_CYGWIN */
#endif /* HAVE_LOGIN_CAP */

		snprintf(buf, sizeof buf, ""%.200s/%.50s"",
			 _PATH_MAILDIR, pw->pw_name);
		child_set_env(&env, &envsize, ""MAIL"", buf);

		/* Normal systems set SHELL by default. */
		child_set_env(&env, &envsize, ""SHELL"", shell);
	}
	if (getenv(""TZ""))
		child_set_env(&env, &envsize, ""TZ"", getenv(""TZ""));

	/* Set custom environment options from RSA authentication. */
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *str = ce->s;

			for (i = 0; str[i] != '=' && str[i]; i++)
				;
			if (str[i] == '=') {
				str[i] = 0;
				child_set_env(&env, &envsize, str, str + i + 1);
			}
			custom_environment = ce->next;
			free(ce->s);
			free(ce);
		}
	}

	/* SSH_CLIENT deprecated */
	snprintf(buf, sizeof buf, ""%.50s %d %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    ssh_local_port(ssh));
	child_set_env(&env, &envsize, ""SSH_CLIENT"", buf);

	laddr = get_local_ipaddr(packet_get_connection_in());
	snprintf(buf, sizeof buf, ""%.50s %d %.50s %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    laddr, ssh_local_port(ssh));
	free(laddr);
	child_set_env(&env, &envsize, ""SSH_CONNECTION"", buf);

	if (s->ttyfd != -1)
		child_set_env(&env, &envsize, ""SSH_TTY"", s->tty);
	if (s->term)
		child_set_env(&env, &envsize, ""TERM"", s->term);
	if (s->display)
		child_set_env(&env, &envsize, ""DISPLAY"", s->display);
	if (original_command)
		child_set_env(&env, &envsize, ""SSH_ORIGINAL_COMMAND"",
		    original_command);

#ifdef _UNICOS
	if (cray_tmpdir[0] != '\0')
		child_set_env(&env, &envsize, ""TMPDIR"", cray_tmpdir);
#endif /* _UNICOS */

	/*
	 * Since we clear KRB5CCNAME at startup, if it's set now then it
	 * must have been set by a native authentication method (eg AIX or
	 * SIA), so copy it to the child.
	 */
	{
		char *cp;

		if ((cp = getenv(""KRB5CCNAME"")) != NULL)
			child_set_env(&env, &envsize, ""KRB5CCNAME"", cp);
	}

#ifdef _AIX
	{
		char *cp;

		if ((cp = getenv(""AUTHSTATE"")) != NULL)
			child_set_env(&env, &envsize, ""AUTHSTATE"", cp);
		read_environment_file(&env, &envsize, ""/etc/environment"");
	}
#endif
#ifdef KRB5
	if (s->authctxt->krb5_ccname)
		child_set_env(&env, &envsize, ""KRB5CCNAME"",
		    s->authctxt->krb5_ccname);
#endif
#ifdef USE_PAM
	/*
 	 * Pull in any environment variables that may have
 	 * been set by PAM.
 	 */
	if (options.use_pam) {
 		char **p;
 
 		p = fetch_pam_child_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);

		p = fetch_pam_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);
	}
#endif /* USE_PAM */

	if (auth_sock_name != NULL)
		child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,
		    auth_sock_name);

	/* read $HOME/.ssh/environment. */
	if (options.permit_user_env && !options.use_login) {
		snprintf(buf, sizeof buf, ""%.200s/.ssh/environment"",
		    strcmp(pw->pw_dir, ""/"") ? pw->pw_dir : """");
		read_environment_file(&env, &envsize, buf);
	}
	if (debug_flag) {
		/* dump the environment */
		fprintf(stderr, ""Environment:\n"");
		for (i = 0; env[i]; i++)
			fprintf(stderr, ""  %.200s\n"", env[i]);
	}
	return env;
}
",C,"	if (options.use_pam && !options.use_login) {
","	if (options.use_pam) {
",dce19bf6e4a2a3d0b13a81224de63fc316461ab9,"@@ -1322,7 +1322,7 @@ do_setup_env(Session *s, const char *shell)
 	 * Pull in any environment variables that may have
 	 * been set by PAM.
 	 */
-	if (options.use_pam) {
+	if (options.use_pam && !options.use_login) {
 		char **p;
 
 		p = fetch_pam_child_environment();",mindrot,https://anongit.mindrot.org/openssh.git/tree/session.c?id=85bdcd7c92fe7ff133bbc4e10a65c91810f88755,https://anongit.mindrot.org/openssh.git/tree/session.c?id=dce19bf6e4a2a3d0b13a81224de63fc316461ab9,1,"do_setup_env(Session *s, const char *shell)
{
	struct ssh *ssh = active_state; /* XXX */
	char buf[256];
	u_int i, envsize;
	char **env, *laddr;
	struct passwd *pw = s->pw;
#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)
	char *path = NULL;
#endif

	/* Initialize the environment. */
	envsize = 100;
	env = xcalloc(envsize, sizeof(char *));
	env[0] = NULL;

#ifdef HAVE_CYGWIN
	/*
	 * The Windows environment contains some setting which are
	 * important for a running system. They must not be dropped.
	 */
	{
		char **p;

		p = fetch_windows_environment();
		copy_environment(p, &env, &envsize);
		free_windows_environment(p);
	}
#endif

#ifdef GSSAPI
	/* Allow any GSSAPI methods that we've used to alter
	 * the childs environment as they see fit
	 */
	ssh_gssapi_do_child(&env, &envsize);
#endif

	if (!options.use_login) {
		/* Set basic environment. */
		for (i = 0; i < s->num_env; i++)
			child_set_env(&env, &envsize, s->env[i].name,
			    s->env[i].val);

		child_set_env(&env, &envsize, ""USER"", pw->pw_name);
		child_set_env(&env, &envsize, ""LOGNAME"", pw->pw_name);
#ifdef _AIX
		child_set_env(&env, &envsize, ""LOGIN"", pw->pw_name);
#endif
		child_set_env(&env, &envsize, ""HOME"", pw->pw_dir);
#ifdef HAVE_LOGIN_CAP
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
			child_set_env(&env, &envsize, ""PATH"", _PATH_STDPATH);
		else
			child_set_env(&env, &envsize, ""PATH"", getenv(""PATH""));
#else /* HAVE_LOGIN_CAP */
# ifndef HAVE_CYGWIN
		/*
		 * There's no standard path on Windows. The path contains
		 * important components pointing to the system directories,
		 * needed for loading shared libraries. So the path better
		 * remains intact here.
		 */
#  ifdef HAVE_ETC_DEFAULT_LOGIN
		read_etc_default_login(&env, &envsize, pw->pw_uid);
		path = child_get_env(env, ""PATH"");
#  endif /* HAVE_ETC_DEFAULT_LOGIN */
		if (path == NULL || *path == '\0') {
			child_set_env(&env, &envsize, ""PATH"",
			    s->pw->pw_uid == 0 ?
				SUPERUSER_PATH : _PATH_STDPATH);
		}
# endif /* HAVE_CYGWIN */
#endif /* HAVE_LOGIN_CAP */

		snprintf(buf, sizeof buf, ""%.200s/%.50s"",
			 _PATH_MAILDIR, pw->pw_name);
		child_set_env(&env, &envsize, ""MAIL"", buf);

		/* Normal systems set SHELL by default. */
		child_set_env(&env, &envsize, ""SHELL"", shell);
	}
	if (getenv(""TZ""))
		child_set_env(&env, &envsize, ""TZ"", getenv(""TZ""));

	/* Set custom environment options from RSA authentication. */
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *str = ce->s;

			for (i = 0; str[i] != '=' && str[i]; i++)
				;
			if (str[i] == '=') {
				str[i] = 0;
				child_set_env(&env, &envsize, str, str + i + 1);
			}
			custom_environment = ce->next;
			free(ce->s);
			free(ce);
		}
	}

	/* SSH_CLIENT deprecated */
	snprintf(buf, sizeof buf, ""%.50s %d %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    ssh_local_port(ssh));
	child_set_env(&env, &envsize, ""SSH_CLIENT"", buf);

	laddr = get_local_ipaddr(packet_get_connection_in());
	snprintf(buf, sizeof buf, ""%.50s %d %.50s %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    laddr, ssh_local_port(ssh));
	free(laddr);
	child_set_env(&env, &envsize, ""SSH_CONNECTION"", buf);

	if (s->ttyfd != -1)
		child_set_env(&env, &envsize, ""SSH_TTY"", s->tty);
	if (s->term)
		child_set_env(&env, &envsize, ""TERM"", s->term);
	if (s->display)
		child_set_env(&env, &envsize, ""DISPLAY"", s->display);
	if (original_command)
		child_set_env(&env, &envsize, ""SSH_ORIGINAL_COMMAND"",
		    original_command);

#ifdef _UNICOS
	if (cray_tmpdir[0] != '\0')
		child_set_env(&env, &envsize, ""TMPDIR"", cray_tmpdir);
#endif /* _UNICOS */

	/*
	 * Since we clear KRB5CCNAME at startup, if it's set now then it
	 * must have been set by a native authentication method (eg AIX or
	 * SIA), so copy it to the child.
	 */
	{
		char *cp;

		if ((cp = getenv(""KRB5CCNAME"")) != NULL)
			child_set_env(&env, &envsize, ""KRB5CCNAME"", cp);
	}

#ifdef _AIX
	{
		char *cp;

		if ((cp = getenv(""AUTHSTATE"")) != NULL)
			child_set_env(&env, &envsize, ""AUTHSTATE"", cp);
		read_environment_file(&env, &envsize, ""/etc/environment"");
	}
#endif
#ifdef KRB5
	if (s->authctxt->krb5_ccname)
		child_set_env(&env, &envsize, ""KRB5CCNAME"",
		    s->authctxt->krb5_ccname);
#endif
#ifdef USE_PAM
	/*
 	 * Pull in any environment variables that may have
 	 * been set by PAM.
 	 */
//flaw_line_below:
	if (options.use_pam) {
//fix_flaw_line_below:
//	if (options.use_pam && !options.use_login) {
 		char **p;
 
 		p = fetch_pam_child_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);

		p = fetch_pam_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);
	}
#endif /* USE_PAM */

	if (auth_sock_name != NULL)
		child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,
		    auth_sock_name);

	/* read $HOME/.ssh/environment. */
	if (options.permit_user_env && !options.use_login) {
		snprintf(buf, sizeof buf, ""%.200s/.ssh/environment"",
		    strcmp(pw->pw_dir, ""/"") ? pw->pw_dir : """");
		read_environment_file(&env, &envsize, buf);
	}
	if (debug_flag) {
		/* dump the environment */
		fprintf(stderr, ""Environment:\n"");
		for (i = 0; env[i]; i++)
			fprintf(stderr, ""  %.200s\n"", env[i]);
	}
	return env;
}
",178455,"do_setup_env(Session *s, const char *shell)
{
	struct ssh *ssh = active_state; /* XXX */
	char buf[256];
	u_int i, envsize;
	char **env, *laddr;
	struct passwd *pw = s->pw;
#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)
	char *path = NULL;
#endif

	/* Initialize the environment. */
	envsize = 100;
	env = xcalloc(envsize, sizeof(char *));
	env[0] = NULL;

#ifdef HAVE_CYGWIN
	/*
	 * The Windows environment contains some setting which are
	 * important for a running system. They must not be dropped.
	 */
	{
		char **p;

		p = fetch_windows_environment();
		copy_environment(p, &env, &envsize);
		free_windows_environment(p);
	}
#endif

#ifdef GSSAPI
	/* Allow any GSSAPI methods that we've used to alter
	 * the childs environment as they see fit
	 */
	ssh_gssapi_do_child(&env, &envsize);
#endif

	if (!options.use_login) {
		/* Set basic environment. */
		for (i = 0; i < s->num_env; i++)
			child_set_env(&env, &envsize, s->env[i].name,
			    s->env[i].val);

		child_set_env(&env, &envsize, ""USER"", pw->pw_name);
		child_set_env(&env, &envsize, ""LOGNAME"", pw->pw_name);
#ifdef _AIX
		child_set_env(&env, &envsize, ""LOGIN"", pw->pw_name);
#endif
		child_set_env(&env, &envsize, ""HOME"", pw->pw_dir);
#ifdef HAVE_LOGIN_CAP
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
			child_set_env(&env, &envsize, ""PATH"", _PATH_STDPATH);
		else
			child_set_env(&env, &envsize, ""PATH"", getenv(""PATH""));
#else /* HAVE_LOGIN_CAP */
# ifndef HAVE_CYGWIN
		/*
		 * There's no standard path on Windows. The path contains
		 * important components pointing to the system directories,
		 * needed for loading shared libraries. So the path better
		 * remains intact here.
		 */
#  ifdef HAVE_ETC_DEFAULT_LOGIN
		read_etc_default_login(&env, &envsize, pw->pw_uid);
		path = child_get_env(env, ""PATH"");
#  endif /* HAVE_ETC_DEFAULT_LOGIN */
		if (path == NULL || *path == '\0') {
			child_set_env(&env, &envsize, ""PATH"",
			    s->pw->pw_uid == 0 ?
				SUPERUSER_PATH : _PATH_STDPATH);
		}
# endif /* HAVE_CYGWIN */
#endif /* HAVE_LOGIN_CAP */

		snprintf(buf, sizeof buf, ""%.200s/%.50s"",
			 _PATH_MAILDIR, pw->pw_name);
		child_set_env(&env, &envsize, ""MAIL"", buf);

		/* Normal systems set SHELL by default. */
		child_set_env(&env, &envsize, ""SHELL"", shell);
	}
	if (getenv(""TZ""))
		child_set_env(&env, &envsize, ""TZ"", getenv(""TZ""));

	/* Set custom environment options from RSA authentication. */
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *str = ce->s;

			for (i = 0; str[i] != '=' && str[i]; i++)
				;
			if (str[i] == '=') {
				str[i] = 0;
				child_set_env(&env, &envsize, str, str + i + 1);
			}
			custom_environment = ce->next;
			free(ce->s);
			free(ce);
		}
	}

	/* SSH_CLIENT deprecated */
	snprintf(buf, sizeof buf, ""%.50s %d %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    ssh_local_port(ssh));
	child_set_env(&env, &envsize, ""SSH_CLIENT"", buf);

	laddr = get_local_ipaddr(packet_get_connection_in());
	snprintf(buf, sizeof buf, ""%.50s %d %.50s %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    laddr, ssh_local_port(ssh));
	free(laddr);
	child_set_env(&env, &envsize, ""SSH_CONNECTION"", buf);

	if (s->ttyfd != -1)
		child_set_env(&env, &envsize, ""SSH_TTY"", s->tty);
	if (s->term)
		child_set_env(&env, &envsize, ""TERM"", s->term);
	if (s->display)
		child_set_env(&env, &envsize, ""DISPLAY"", s->display);
	if (original_command)
		child_set_env(&env, &envsize, ""SSH_ORIGINAL_COMMAND"",
		    original_command);

#ifdef _UNICOS
	if (cray_tmpdir[0] != '\0')
		child_set_env(&env, &envsize, ""TMPDIR"", cray_tmpdir);
#endif /* _UNICOS */

	/*
	 * Since we clear KRB5CCNAME at startup, if it's set now then it
	 * must have been set by a native authentication method (eg AIX or
	 * SIA), so copy it to the child.
	 */
	{
		char *cp;

		if ((cp = getenv(""KRB5CCNAME"")) != NULL)
			child_set_env(&env, &envsize, ""KRB5CCNAME"", cp);
	}

#ifdef _AIX
	{
		char *cp;

		if ((cp = getenv(""AUTHSTATE"")) != NULL)
			child_set_env(&env, &envsize, ""AUTHSTATE"", cp);
		read_environment_file(&env, &envsize, ""/etc/environment"");
	}
#endif
#ifdef KRB5
	if (s->authctxt->krb5_ccname)
		child_set_env(&env, &envsize, ""KRB5CCNAME"",
		    s->authctxt->krb5_ccname);
#endif
#ifdef USE_PAM
	/*
 	 * Pull in any environment variables that may have
 	 * been set by PAM.
 	 */
	if (options.use_pam) {
 		char **p;
 
 		p = fetch_pam_child_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);

		p = fetch_pam_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);
	}
#endif /* USE_PAM */

	if (auth_sock_name != NULL)
		child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,
		    auth_sock_name);

	/* read $HOME/.ssh/environment. */
	if (options.permit_user_env && !options.use_login) {
		snprintf(buf, sizeof buf, ""%.200s/.ssh/environment"",
		    strcmp(pw->pw_dir, ""/"") ? pw->pw_dir : """");
		read_environment_file(&env, &envsize, buf);
	}
	if (debug_flag) {
		/* dump the environment */
		fprintf(stderr, ""Environment:\n"");
		for (i = 0; env[i]; i++)
			fprintf(stderr, ""  %.200s\n"", env[i]);
	}
	return env;
}
","do_setup_env(Session *s, const char *shell)
{
	struct ssh *ssh = active_state; /* XXX */
	char buf[256];
	u_int i, envsize;
	char **env, *laddr;
	struct passwd *pw = s->pw;
#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)
	char *path = NULL;
#endif

	/* Initialize the environment. */
	envsize = 100;
	env = xcalloc(envsize, sizeof(char *));
	env[0] = NULL;

#ifdef HAVE_CYGWIN
	/*
	 * The Windows environment contains some setting which are
	 * important for a running system. They must not be dropped.
	 */
	{
		char **p;

		p = fetch_windows_environment();
		copy_environment(p, &env, &envsize);
		free_windows_environment(p);
	}
#endif

#ifdef GSSAPI
	/* Allow any GSSAPI methods that we've used to alter
	 * the childs environment as they see fit
	 */
	ssh_gssapi_do_child(&env, &envsize);
#endif

	if (!options.use_login) {
		/* Set basic environment. */
		for (i = 0; i < s->num_env; i++)
			child_set_env(&env, &envsize, s->env[i].name,
			    s->env[i].val);

		child_set_env(&env, &envsize, ""USER"", pw->pw_name);
		child_set_env(&env, &envsize, ""LOGNAME"", pw->pw_name);
#ifdef _AIX
		child_set_env(&env, &envsize, ""LOGIN"", pw->pw_name);
#endif
		child_set_env(&env, &envsize, ""HOME"", pw->pw_dir);
#ifdef HAVE_LOGIN_CAP
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
			child_set_env(&env, &envsize, ""PATH"", _PATH_STDPATH);
		else
			child_set_env(&env, &envsize, ""PATH"", getenv(""PATH""));
#else /* HAVE_LOGIN_CAP */
# ifndef HAVE_CYGWIN
		/*
		 * There's no standard path on Windows. The path contains
		 * important components pointing to the system directories,
		 * needed for loading shared libraries. So the path better
		 * remains intact here.
		 */
#  ifdef HAVE_ETC_DEFAULT_LOGIN
		read_etc_default_login(&env, &envsize, pw->pw_uid);
		path = child_get_env(env, ""PATH"");
#  endif /* HAVE_ETC_DEFAULT_LOGIN */
		if (path == NULL || *path == '\0') {
			child_set_env(&env, &envsize, ""PATH"",
			    s->pw->pw_uid == 0 ?
				SUPERUSER_PATH : _PATH_STDPATH);
		}
# endif /* HAVE_CYGWIN */
#endif /* HAVE_LOGIN_CAP */

		snprintf(buf, sizeof buf, ""%.200s/%.50s"",
			 _PATH_MAILDIR, pw->pw_name);
		child_set_env(&env, &envsize, ""MAIL"", buf);

		/* Normal systems set SHELL by default. */
		child_set_env(&env, &envsize, ""SHELL"", shell);
	}
	if (getenv(""TZ""))
		child_set_env(&env, &envsize, ""TZ"", getenv(""TZ""));

	/* Set custom environment options from RSA authentication. */
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *str = ce->s;

			for (i = 0; str[i] != '=' && str[i]; i++)
				;
			if (str[i] == '=') {
				str[i] = 0;
				child_set_env(&env, &envsize, str, str + i + 1);
			}
			custom_environment = ce->next;
			free(ce->s);
			free(ce);
		}
	}

	/* SSH_CLIENT deprecated */
	snprintf(buf, sizeof buf, ""%.50s %d %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    ssh_local_port(ssh));
	child_set_env(&env, &envsize, ""SSH_CLIENT"", buf);

	laddr = get_local_ipaddr(packet_get_connection_in());
	snprintf(buf, sizeof buf, ""%.50s %d %.50s %d"",
	    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),
	    laddr, ssh_local_port(ssh));
	free(laddr);
	child_set_env(&env, &envsize, ""SSH_CONNECTION"", buf);

	if (s->ttyfd != -1)
		child_set_env(&env, &envsize, ""SSH_TTY"", s->tty);
	if (s->term)
		child_set_env(&env, &envsize, ""TERM"", s->term);
	if (s->display)
		child_set_env(&env, &envsize, ""DISPLAY"", s->display);
	if (original_command)
		child_set_env(&env, &envsize, ""SSH_ORIGINAL_COMMAND"",
		    original_command);

#ifdef _UNICOS
	if (cray_tmpdir[0] != '\0')
		child_set_env(&env, &envsize, ""TMPDIR"", cray_tmpdir);
#endif /* _UNICOS */

	/*
	 * Since we clear KRB5CCNAME at startup, if it's set now then it
	 * must have been set by a native authentication method (eg AIX or
	 * SIA), so copy it to the child.
	 */
	{
		char *cp;

		if ((cp = getenv(""KRB5CCNAME"")) != NULL)
			child_set_env(&env, &envsize, ""KRB5CCNAME"", cp);
	}

#ifdef _AIX
	{
		char *cp;

		if ((cp = getenv(""AUTHSTATE"")) != NULL)
			child_set_env(&env, &envsize, ""AUTHSTATE"", cp);
		read_environment_file(&env, &envsize, ""/etc/environment"");
	}
#endif
#ifdef KRB5
	if (s->authctxt->krb5_ccname)
		child_set_env(&env, &envsize, ""KRB5CCNAME"",
		    s->authctxt->krb5_ccname);
#endif
#ifdef USE_PAM
	/*
 	 * Pull in any environment variables that may have
 	 * been set by PAM.
 	 */
	if (options.use_pam && !options.use_login) {
 		char **p;
 
 		p = fetch_pam_child_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);

		p = fetch_pam_environment();
		copy_environment(p, &env, &envsize);
		free_pam_environment(p);
	}
#endif /* USE_PAM */

	if (auth_sock_name != NULL)
		child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,
		    auth_sock_name);

	/* read $HOME/.ssh/environment. */
	if (options.permit_user_env && !options.use_login) {
		snprintf(buf, sizeof buf, ""%.200s/.ssh/environment"",
		    strcmp(pw->pw_dir, ""/"") ? pw->pw_dir : """");
		read_environment_file(&env, &envsize, buf);
	}
	if (debug_flag) {
		/* dump the environment */
		fprintf(stderr, ""Environment:\n"");
		for (i = 0; env[i]; i++)
			fprintf(stderr, ""  %.200s\n"", env[i]);
	}
	return env;
}
","The `do_setup_env` function initializes the environment for a child process in an SSH session. It allocates memory for environment variables and populates it with user-specific settings, such as username, home directory, and shell, while also considering platform-specific requirements (e.g., Cygwin and AIX). The function retrieves and sets additional environment variables from various sources, including PAM, GSSAPI, and custom configurations. It also constructs SSH-related variables like `SSH_CLIENT` and `SSH_CONNECTION`. Finally, if debugging is enabled, it outputs the constructed environment variables to standard error before returning the populated environment array.","The provided code initializes the environment for a child process in an SSH session by allocating memory for environment variables and populating it with user-specific information, such as the username and home directory. It accommodates platform-specific requirements and retrieves additional environment settings from various sources, including authentication methods and user configurations. The code constructs SSH-related variables to facilitate connection details and handles debugging by outputting the constructed environment variables. Ultimately, it returns the fully populated environment array, ensuring that the child process has the necessary context for execution.","The vulnerability in the original code arises from the potential exposure of sensitive environment variables, particularly when user-controlled input is incorporated into the environment setup without proper validation. This could allow an attacker to manipulate the environment variables, leading to unauthorized access or privilege escalation. The fixed code addresses this vulnerability by ensuring that environment variables are set only from trusted sources, such as user credentials and predefined system paths, while also implementing checks to prevent the inclusion of potentially harmful or unvalidated user input. This enhances the security of the environment setup process in the SSH session.","The vulnerability in the original code stems from the insecure handling of environment variables, which could allow an attacker to inject malicious values through user-controlled input, potentially leading to privilege escalation or unauthorized access. The fixed code mitigates this risk by implementing stricter controls on which environment variables are set, ensuring that only trusted and validated sources contribute to the environment. Additionally, it avoids incorporating unverified user input directly into the environment, thereby enhancing the overall security of the process and reducing the likelihood of exploitation through environment manipulation.","The vulnerability was fixed by implementing stricter controls on the sources of environment variables. The code now checks the `options.use_login` flag to determine whether to set environment variables from user input, ensuring that only trusted values are included. Additionally, the code retrieves environment variables from secure sources, such as `fetch_pam_child_environment` and `fetch_windows_environment`, while avoiding direct inclusion of potentially harmful user input. The use of functions like `child_set_env` ensures that only validated and necessary variables, such as `USER`, `HOME`, and `SHELL`, are set, thereby enhancing security.","The vulnerability was addressed by implementing stricter validation and control over the environment variables being set. The code now ensures that only trusted and predefined sources contribute to the environment, thereby preventing the inclusion of potentially harmful user input. By checking specific conditions before setting environment variables, the code limits the risk of injecting malicious values. Additionally, it retrieves environment settings from secure and verified sources, ensuring that sensitive information is handled appropriately and reducing the likelihood of exploitation through environment manipulation. This enhances the overall security of the environment setup process.","CWE-426,CWE-74,CWE-94,CWE-78,CWE-470,CWE-506,CWE-214,CWE-913,CWE-473,CWE-912",N,-1
9,9,178533,178533,,Remote,Not required,Partial,CVE-2013-4159,https://www.cvedetails.com/cve/CVE-2013-4159/,CWE-264,Low,Partial,Partial,,2014-08-06,7.5,"ctdb before 2.3 in OpenSUSE 12.3 and 13.1 does not create temporary files securely, which has unspecified impact related to ""several temp file vulnerabilities"" in (1) tcp/tcp_connect.c, (2) server/eventscript.c, (3) tools/ctdb_diagnostics, (4) config/gdb_backtrace, and (5) include/ctdb_private.h.",2018-10-30,,1,https://git.samba.org/?p=ctdb.git;a=commitdiff;h=b9b9f6738fba5c32e87cb9c36b358355b444fb9b,b9b9f6738fba5c32e87cb9c36b358355b444fb9b,,1,,,"static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)
{
	struct ctdb_tcp *ctcp = talloc_get_type(ctdb->private_data,
                                                struct ctdb_tcp);
         ctdb_sock_addr sock;
        int lock_fd, i;
       const char *lock_path = VARDIR ""/run/ctdb/.socket_lock"";
        struct flock lock;
        int one = 1;
        int sock_size;
	struct tevent_fd *fde;

	/* If there are no nodes, then it won't be possible to find
	 * the first one.  Log a failure and short circuit the whole
	 * process.
	 */
	if (ctdb->num_nodes == 0) {
		DEBUG(DEBUG_CRIT,(""No nodes available to attempt bind to - is the nodes file empty?\n""));
		return -1;
	}

	/* in order to ensure that we don't get two nodes with the
	   same adddress, we must make the bind() and listen() calls
	   atomic. The SO_REUSEADDR setsockopt only prevents double
	   binds if the first socket is in LISTEN state  */
	lock_fd = open(lock_path, O_RDWR|O_CREAT, 0666);
	if (lock_fd == -1) {
		DEBUG(DEBUG_CRIT,(""Unable to open %s\n"", lock_path));
		return -1;
	}

	lock.l_type = F_WRLCK;
	lock.l_whence = SEEK_SET;
	lock.l_start = 0;
	lock.l_len = 1;
	lock.l_pid = 0;

	if (fcntl(lock_fd, F_SETLKW, &lock) != 0) {
		DEBUG(DEBUG_CRIT,(""Unable to lock %s\n"", lock_path));
		close(lock_fd);
		return -1;
	}

	for (i=0; i < ctdb->num_nodes; i++) {
		if (ctdb->nodes[i]->flags & NODE_FLAGS_DELETED) {
			continue;
		}
		ZERO_STRUCT(sock);
		if (ctdb_tcp_get_address(ctdb,
				ctdb->nodes[i]->address.address, 
				&sock) != 0) {
			continue;
		}
	
		switch (sock.sa.sa_family) {
		case AF_INET:
			sock.ip.sin_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip);
			break;
		case AF_INET6:
			sock.ip6.sin6_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip6);
			break;
		default:
			DEBUG(DEBUG_ERR, (__location__ "" unknown family %u\n"",
				sock.sa.sa_family));
			continue;
		}
#ifdef HAVE_SOCK_SIN_LEN
		sock.ip.sin_len = sock_size;
#endif

		ctcp->listen_fd = socket(sock.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
		if (ctcp->listen_fd == -1) {
			ctdb_set_error(ctdb, ""socket failed\n"");
			continue;
		}

		set_close_on_exec(ctcp->listen_fd);

	        setsockopt(ctcp->listen_fd,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof(one));

		if (bind(ctcp->listen_fd, (struct sockaddr * )&sock, sock_size) == 0) {
			break;
		}

		if (errno == EADDRNOTAVAIL) {
			DEBUG(DEBUG_DEBUG,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		} else {
			DEBUG(DEBUG_ERR,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		}
	}
	
	if (i == ctdb->num_nodes) {
		DEBUG(DEBUG_CRIT,(""Unable to bind to any of the node addresses - giving up\n""));
		goto failed;
	}
	ctdb->address.address = talloc_strdup(ctdb, ctdb->nodes[i]->address.address);
	ctdb->address.port    = ctdb->nodes[i]->address.port;
	ctdb->name = talloc_asprintf(ctdb, ""%s:%u"", 
				     ctdb->address.address, 
				     ctdb->address.port);
	ctdb->pnn = ctdb->nodes[i]->pnn;
	DEBUG(DEBUG_INFO,(""ctdb chose network address %s:%u pnn %u\n"", 
		 ctdb->address.address, 
		 ctdb->address.port, 
		 ctdb->pnn));
	
	if (listen(ctcp->listen_fd, 10) == -1) {
		goto failed;
	}

	fde = event_add_fd(ctdb->ev, ctcp, ctcp->listen_fd, EVENT_FD_READ,
			   ctdb_listen_event, ctdb);
	tevent_fd_set_auto_close(fde);

	close(lock_fd);

	return 0;
	
failed:
	close(lock_fd);
	close(ctcp->listen_fd);
	ctcp->listen_fd = -1;
	return -1;
}
","static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)
{
	struct ctdb_tcp *ctcp = talloc_get_type(ctdb->private_data,
                                                struct ctdb_tcp);
         ctdb_sock_addr sock;
        int lock_fd, i;
       const char *lock_path = ""/tmp/.ctdb_socket_lock"";
        struct flock lock;
        int one = 1;
        int sock_size;
	struct tevent_fd *fde;

	/* If there are no nodes, then it won't be possible to find
	 * the first one.  Log a failure and short circuit the whole
	 * process.
	 */
	if (ctdb->num_nodes == 0) {
		DEBUG(DEBUG_CRIT,(""No nodes available to attempt bind to - is the nodes file empty?\n""));
		return -1;
	}

	/* in order to ensure that we don't get two nodes with the
	   same adddress, we must make the bind() and listen() calls
	   atomic. The SO_REUSEADDR setsockopt only prevents double
	   binds if the first socket is in LISTEN state  */
	lock_fd = open(lock_path, O_RDWR|O_CREAT, 0666);
	if (lock_fd == -1) {
		DEBUG(DEBUG_CRIT,(""Unable to open %s\n"", lock_path));
		return -1;
	}

	lock.l_type = F_WRLCK;
	lock.l_whence = SEEK_SET;
	lock.l_start = 0;
	lock.l_len = 1;
	lock.l_pid = 0;

	if (fcntl(lock_fd, F_SETLKW, &lock) != 0) {
		DEBUG(DEBUG_CRIT,(""Unable to lock %s\n"", lock_path));
		close(lock_fd);
		return -1;
	}

	for (i=0; i < ctdb->num_nodes; i++) {
		if (ctdb->nodes[i]->flags & NODE_FLAGS_DELETED) {
			continue;
		}
		ZERO_STRUCT(sock);
		if (ctdb_tcp_get_address(ctdb,
				ctdb->nodes[i]->address.address, 
				&sock) != 0) {
			continue;
		}
	
		switch (sock.sa.sa_family) {
		case AF_INET:
			sock.ip.sin_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip);
			break;
		case AF_INET6:
			sock.ip6.sin6_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip6);
			break;
		default:
			DEBUG(DEBUG_ERR, (__location__ "" unknown family %u\n"",
				sock.sa.sa_family));
			continue;
		}
#ifdef HAVE_SOCK_SIN_LEN
		sock.ip.sin_len = sock_size;
#endif

		ctcp->listen_fd = socket(sock.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
		if (ctcp->listen_fd == -1) {
			ctdb_set_error(ctdb, ""socket failed\n"");
			continue;
		}

		set_close_on_exec(ctcp->listen_fd);

	        setsockopt(ctcp->listen_fd,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof(one));

		if (bind(ctcp->listen_fd, (struct sockaddr * )&sock, sock_size) == 0) {
			break;
		}

		if (errno == EADDRNOTAVAIL) {
			DEBUG(DEBUG_DEBUG,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		} else {
			DEBUG(DEBUG_ERR,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		}
	}
	
	if (i == ctdb->num_nodes) {
		DEBUG(DEBUG_CRIT,(""Unable to bind to any of the node addresses - giving up\n""));
		goto failed;
	}
	ctdb->address.address = talloc_strdup(ctdb, ctdb->nodes[i]->address.address);
	ctdb->address.port    = ctdb->nodes[i]->address.port;
	ctdb->name = talloc_asprintf(ctdb, ""%s:%u"", 
				     ctdb->address.address, 
				     ctdb->address.port);
	ctdb->pnn = ctdb->nodes[i]->pnn;
	DEBUG(DEBUG_INFO,(""ctdb chose network address %s:%u pnn %u\n"", 
		 ctdb->address.address, 
		 ctdb->address.port, 
		 ctdb->pnn));
	
	if (listen(ctcp->listen_fd, 10) == -1) {
		goto failed;
	}

	fde = event_add_fd(ctdb->ev, ctcp, ctcp->listen_fd, EVENT_FD_READ,
			   ctdb_listen_event, ctdb);
	tevent_fd_set_auto_close(fde);

	close(lock_fd);

	return 0;
	
failed:
	close(lock_fd);
	close(ctcp->listen_fd);
	ctcp->listen_fd = -1;
	return -1;
}
",C,"       const char *lock_path = VARDIR ""/run/ctdb/.socket_lock"";
","       const char *lock_path = ""/tmp/.ctdb_socket_lock"";
",6a5469a63547029f4fc704a4d4075543e06c36d1,"@@ -284,7 +284,7 @@ static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)
                                                struct ctdb_tcp);
         ctdb_sock_addr sock;
        int lock_fd, i;
-       const char *lock_path = ""/tmp/.ctdb_socket_lock"";
+       const char *lock_path = VARDIR ""/run/ctdb/.socket_lock"";
        struct flock lock;
        int one = 1;
        int sock_size;",samba,https://git.samba.org/?p=ctdb.git;a=blob;f=tcp/tcp_connect.c;h=9df330009f1428fe72ae33ff8c3a91d0c4b782d9;hb=b9b9f6738fba5c32e87cb9c36b358355b444fb9b,https://git.samba.org/?p=ctdb.git;a=blob;f=tcp/tcp_connect.c;h=383d72641b222a5083c66f7e6e0bc0edc0318880,1,"static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)
{
	struct ctdb_tcp *ctcp = talloc_get_type(ctdb->private_data,
                                                struct ctdb_tcp);
         ctdb_sock_addr sock;
        int lock_fd, i;
//flaw_line_below:
       const char *lock_path = ""/tmp/.ctdb_socket_lock"";
//fix_flaw_line_below:
//       const char *lock_path = VARDIR ""/run/ctdb/.socket_lock"";
        struct flock lock;
        int one = 1;
        int sock_size;
	struct tevent_fd *fde;

	/* If there are no nodes, then it won't be possible to find
	 * the first one.  Log a failure and short circuit the whole
	 * process.
	 */
	if (ctdb->num_nodes == 0) {
		DEBUG(DEBUG_CRIT,(""No nodes available to attempt bind to - is the nodes file empty?\n""));
		return -1;
	}

	/* in order to ensure that we don't get two nodes with the
	   same adddress, we must make the bind() and listen() calls
	   atomic. The SO_REUSEADDR setsockopt only prevents double
	   binds if the first socket is in LISTEN state  */
	lock_fd = open(lock_path, O_RDWR|O_CREAT, 0666);
	if (lock_fd == -1) {
		DEBUG(DEBUG_CRIT,(""Unable to open %s\n"", lock_path));
		return -1;
	}

	lock.l_type = F_WRLCK;
	lock.l_whence = SEEK_SET;
	lock.l_start = 0;
	lock.l_len = 1;
	lock.l_pid = 0;

	if (fcntl(lock_fd, F_SETLKW, &lock) != 0) {
		DEBUG(DEBUG_CRIT,(""Unable to lock %s\n"", lock_path));
		close(lock_fd);
		return -1;
	}

	for (i=0; i < ctdb->num_nodes; i++) {
		if (ctdb->nodes[i]->flags & NODE_FLAGS_DELETED) {
			continue;
		}
		ZERO_STRUCT(sock);
		if (ctdb_tcp_get_address(ctdb,
				ctdb->nodes[i]->address.address, 
				&sock) != 0) {
			continue;
		}
	
		switch (sock.sa.sa_family) {
		case AF_INET:
			sock.ip.sin_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip);
			break;
		case AF_INET6:
			sock.ip6.sin6_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip6);
			break;
		default:
			DEBUG(DEBUG_ERR, (__location__ "" unknown family %u\n"",
				sock.sa.sa_family));
			continue;
		}
#ifdef HAVE_SOCK_SIN_LEN
		sock.ip.sin_len = sock_size;
#endif

		ctcp->listen_fd = socket(sock.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
		if (ctcp->listen_fd == -1) {
			ctdb_set_error(ctdb, ""socket failed\n"");
			continue;
		}

		set_close_on_exec(ctcp->listen_fd);

	        setsockopt(ctcp->listen_fd,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof(one));

		if (bind(ctcp->listen_fd, (struct sockaddr * )&sock, sock_size) == 0) {
			break;
		}

		if (errno == EADDRNOTAVAIL) {
			DEBUG(DEBUG_DEBUG,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		} else {
			DEBUG(DEBUG_ERR,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		}
	}
	
	if (i == ctdb->num_nodes) {
		DEBUG(DEBUG_CRIT,(""Unable to bind to any of the node addresses - giving up\n""));
		goto failed;
	}
	ctdb->address.address = talloc_strdup(ctdb, ctdb->nodes[i]->address.address);
	ctdb->address.port    = ctdb->nodes[i]->address.port;
	ctdb->name = talloc_asprintf(ctdb, ""%s:%u"", 
				     ctdb->address.address, 
				     ctdb->address.port);
	ctdb->pnn = ctdb->nodes[i]->pnn;
	DEBUG(DEBUG_INFO,(""ctdb chose network address %s:%u pnn %u\n"", 
		 ctdb->address.address, 
		 ctdb->address.port, 
		 ctdb->pnn));
	
	if (listen(ctcp->listen_fd, 10) == -1) {
		goto failed;
	}

	fde = event_add_fd(ctdb->ev, ctcp, ctcp->listen_fd, EVENT_FD_READ,
			   ctdb_listen_event, ctdb);
	tevent_fd_set_auto_close(fde);

	close(lock_fd);

	return 0;
	
failed:
	close(lock_fd);
	close(ctcp->listen_fd);
	ctcp->listen_fd = -1;
	return -1;
}
",178533,"static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)
{
	struct ctdb_tcp *ctcp = talloc_get_type(ctdb->private_data,
                                                struct ctdb_tcp);
         ctdb_sock_addr sock;
        int lock_fd, i;
       const char *lock_path = ""/tmp/.ctdb_socket_lock"";
        struct flock lock;
        int one = 1;
        int sock_size;
	struct tevent_fd *fde;

	/* If there are no nodes, then it won't be possible to find
	 * the first one.  Log a failure and short circuit the whole
	 * process.
	 */
	if (ctdb->num_nodes == 0) {
		DEBUG(DEBUG_CRIT,(""No nodes available to attempt bind to - is the nodes file empty?\n""));
		return -1;
	}

	/* in order to ensure that we don't get two nodes with the
	   same adddress, we must make the bind() and listen() calls
	   atomic. The SO_REUSEADDR setsockopt only prevents double
	   binds if the first socket is in LISTEN state  */
	lock_fd = open(lock_path, O_RDWR|O_CREAT, 0666);
	if (lock_fd == -1) {
		DEBUG(DEBUG_CRIT,(""Unable to open %s\n"", lock_path));
		return -1;
	}

	lock.l_type = F_WRLCK;
	lock.l_whence = SEEK_SET;
	lock.l_start = 0;
	lock.l_len = 1;
	lock.l_pid = 0;

	if (fcntl(lock_fd, F_SETLKW, &lock) != 0) {
		DEBUG(DEBUG_CRIT,(""Unable to lock %s\n"", lock_path));
		close(lock_fd);
		return -1;
	}

	for (i=0; i < ctdb->num_nodes; i++) {
		if (ctdb->nodes[i]->flags & NODE_FLAGS_DELETED) {
			continue;
		}
		ZERO_STRUCT(sock);
		if (ctdb_tcp_get_address(ctdb,
				ctdb->nodes[i]->address.address, 
				&sock) != 0) {
			continue;
		}
	
		switch (sock.sa.sa_family) {
		case AF_INET:
			sock.ip.sin_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip);
			break;
		case AF_INET6:
			sock.ip6.sin6_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip6);
			break;
		default:
			DEBUG(DEBUG_ERR, (__location__ "" unknown family %u\n"",
				sock.sa.sa_family));
			continue;
		}
#ifdef HAVE_SOCK_SIN_LEN
		sock.ip.sin_len = sock_size;
#endif

		ctcp->listen_fd = socket(sock.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
		if (ctcp->listen_fd == -1) {
			ctdb_set_error(ctdb, ""socket failed\n"");
			continue;
		}

		set_close_on_exec(ctcp->listen_fd);

	        setsockopt(ctcp->listen_fd,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof(one));

		if (bind(ctcp->listen_fd, (struct sockaddr * )&sock, sock_size) == 0) {
			break;
		}

		if (errno == EADDRNOTAVAIL) {
			DEBUG(DEBUG_DEBUG,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		} else {
			DEBUG(DEBUG_ERR,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		}
	}
	
	if (i == ctdb->num_nodes) {
		DEBUG(DEBUG_CRIT,(""Unable to bind to any of the node addresses - giving up\n""));
		goto failed;
	}
	ctdb->address.address = talloc_strdup(ctdb, ctdb->nodes[i]->address.address);
	ctdb->address.port    = ctdb->nodes[i]->address.port;
	ctdb->name = talloc_asprintf(ctdb, ""%s:%u"", 
				     ctdb->address.address, 
				     ctdb->address.port);
	ctdb->pnn = ctdb->nodes[i]->pnn;
	DEBUG(DEBUG_INFO,(""ctdb chose network address %s:%u pnn %u\n"", 
		 ctdb->address.address, 
		 ctdb->address.port, 
		 ctdb->pnn));
	
	if (listen(ctcp->listen_fd, 10) == -1) {
		goto failed;
	}

	fde = event_add_fd(ctdb->ev, ctcp, ctcp->listen_fd, EVENT_FD_READ,
			   ctdb_listen_event, ctdb);
	tevent_fd_set_auto_close(fde);

	close(lock_fd);

	return 0;
	
failed:
	close(lock_fd);
	close(ctcp->listen_fd);
	ctcp->listen_fd = -1;
	return -1;
}
","static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)
{
	struct ctdb_tcp *ctcp = talloc_get_type(ctdb->private_data,
                                                struct ctdb_tcp);
         ctdb_sock_addr sock;
        int lock_fd, i;
       const char *lock_path = VARDIR ""/run/ctdb/.socket_lock"";
        struct flock lock;
        int one = 1;
        int sock_size;
	struct tevent_fd *fde;

	/* If there are no nodes, then it won't be possible to find
	 * the first one.  Log a failure and short circuit the whole
	 * process.
	 */
	if (ctdb->num_nodes == 0) {
		DEBUG(DEBUG_CRIT,(""No nodes available to attempt bind to - is the nodes file empty?\n""));
		return -1;
	}

	/* in order to ensure that we don't get two nodes with the
	   same adddress, we must make the bind() and listen() calls
	   atomic. The SO_REUSEADDR setsockopt only prevents double
	   binds if the first socket is in LISTEN state  */
	lock_fd = open(lock_path, O_RDWR|O_CREAT, 0666);
	if (lock_fd == -1) {
		DEBUG(DEBUG_CRIT,(""Unable to open %s\n"", lock_path));
		return -1;
	}

	lock.l_type = F_WRLCK;
	lock.l_whence = SEEK_SET;
	lock.l_start = 0;
	lock.l_len = 1;
	lock.l_pid = 0;

	if (fcntl(lock_fd, F_SETLKW, &lock) != 0) {
		DEBUG(DEBUG_CRIT,(""Unable to lock %s\n"", lock_path));
		close(lock_fd);
		return -1;
	}

	for (i=0; i < ctdb->num_nodes; i++) {
		if (ctdb->nodes[i]->flags & NODE_FLAGS_DELETED) {
			continue;
		}
		ZERO_STRUCT(sock);
		if (ctdb_tcp_get_address(ctdb,
				ctdb->nodes[i]->address.address, 
				&sock) != 0) {
			continue;
		}
	
		switch (sock.sa.sa_family) {
		case AF_INET:
			sock.ip.sin_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip);
			break;
		case AF_INET6:
			sock.ip6.sin6_port = htons(ctdb->nodes[i]->address.port);
			sock_size = sizeof(sock.ip6);
			break;
		default:
			DEBUG(DEBUG_ERR, (__location__ "" unknown family %u\n"",
				sock.sa.sa_family));
			continue;
		}
#ifdef HAVE_SOCK_SIN_LEN
		sock.ip.sin_len = sock_size;
#endif

		ctcp->listen_fd = socket(sock.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
		if (ctcp->listen_fd == -1) {
			ctdb_set_error(ctdb, ""socket failed\n"");
			continue;
		}

		set_close_on_exec(ctcp->listen_fd);

	        setsockopt(ctcp->listen_fd,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof(one));

		if (bind(ctcp->listen_fd, (struct sockaddr * )&sock, sock_size) == 0) {
			break;
		}

		if (errno == EADDRNOTAVAIL) {
			DEBUG(DEBUG_DEBUG,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		} else {
			DEBUG(DEBUG_ERR,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
					strerror(errno), errno));
		}
	}
	
	if (i == ctdb->num_nodes) {
		DEBUG(DEBUG_CRIT,(""Unable to bind to any of the node addresses - giving up\n""));
		goto failed;
	}
	ctdb->address.address = talloc_strdup(ctdb, ctdb->nodes[i]->address.address);
	ctdb->address.port    = ctdb->nodes[i]->address.port;
	ctdb->name = talloc_asprintf(ctdb, ""%s:%u"", 
				     ctdb->address.address, 
				     ctdb->address.port);
	ctdb->pnn = ctdb->nodes[i]->pnn;
	DEBUG(DEBUG_INFO,(""ctdb chose network address %s:%u pnn %u\n"", 
		 ctdb->address.address, 
		 ctdb->address.port, 
		 ctdb->pnn));
	
	if (listen(ctcp->listen_fd, 10) == -1) {
		goto failed;
	}

	fde = event_add_fd(ctdb->ev, ctcp, ctcp->listen_fd, EVENT_FD_READ,
			   ctdb_listen_event, ctdb);
	tevent_fd_set_auto_close(fde);

	close(lock_fd);

	return 0;
	
failed:
	close(lock_fd);
	close(ctcp->listen_fd);
	ctcp->listen_fd = -1;
	return -1;
}
","The `ctdb_tcp_listen_automatic` function initializes a TCP listening socket for a cluster database context (`ctdb`). It first checks for available nodes and attempts to acquire a file lock to prevent simultaneous binding. For each valid node, it retrieves the node's address and creates a socket, setting the `SO_REUSEADDR` option to allow reuse of the address. The function binds the socket to the node's address and listens for incoming connections. If successful, it registers the socket for event handling; otherwise, it cleans up resources and returns an error.","The code defines a function that sets up a TCP listening socket for a cluster database context. It first checks if any nodes are available and attempts to acquire a file lock to ensure exclusive access during the binding process. For each valid node, it retrieves the address and creates a socket, allowing address reuse. The function then binds the socket to the node's address and prepares it to listen for incoming connections. If successful, it registers the socket for event handling; if not, it cleans up resources and returns an error, indicating failure to establish the listening socket.","The vulnerability in the original code stemmed from the use of a hardcoded lock file path, which could lead to potential conflicts or unauthorized access if multiple instances of the application were running or if the directory was writable by unprivileged users. This could allow an attacker to manipulate the lock file, leading to race conditions or denial of service. The fix involved changing the lock file path to a more secure location, specifically using a variable directory path (`VARDIR ""/run/ctdb/.socket_lock""`), which is typically more controlled and less accessible, thereby enhancing security and reducing the risk of exploitation.","The vulnerability in the original code arose from the use of a hardcoded path for the lock file, which could lead to conflicts or unauthorized access if multiple instances of the application were executed or if the directory permissions were too permissive. This situation could allow an attacker to interfere with the locking mechanism, potentially causing race conditions or service disruptions. The fix involved changing the lock file path to a more secure and controlled location, thereby reducing the risk of exploitation and ensuring that the locking mechanism operates correctly in a multi-instance environment.","The vulnerability was fixed by changing the lock file path from a hardcoded value to a more secure and variable-based path using `VARDIR ""/run/ctdb/.socket_lock""`. This adjustment ensures that the lock file is created in a controlled directory, reducing the risk of unauthorized access or conflicts when multiple instances of the application are running. By using a variable directory, the code enhances security and minimizes the chances of race conditions or denial of service, as the lock file is less likely to be manipulated by unprivileged users or other processes.","The vulnerability was addressed by modifying the path for the lock file to a more secure and controlled location, which reduces the risk of unauthorized access and conflicts when multiple instances of the application are running. This change ensures that the lock file is created in a directory with stricter permissions, making it less susceptible to manipulation by unprivileged users or other processes. By implementing this fix, the code enhances the integrity of the locking mechanism, thereby preventing potential race conditions and ensuring reliable operation in a multi-instance environment.","CWE-367, CWE-362, CWE-379, CWE-732, CWE-377, CWE-378, CWE-667, CWE-345, CWE-764, CWE-666",N,-1
10,10,178685,178685,,Local,Not required,Partial,CVE-2014-1845,https://www.cvedetails.com/cve/CVE-2014-1845/,CWE-264,Low,Partial,Partial,,2018-04-27,4.6,An unspecified setuid root helper in Enlightenment before 0.17.6 allows local users to gain privileges by leveraging failure to properly sanitize the environment.,2018-06-07,+Priv,100,https://git.enlightenment.org/core/enlightenment.git/commit/?id=666df815cd86a50343859bce36c5cf968c5f38b0,666df815cd86a50343859bce36c5cf968c5f38b0,,6,,,"main(int argc,
     char **argv)
{
   int i, gn;
   int test = 0;
   char *action = NULL, *cmd;
   char *output = NULL;
#ifdef HAVE_EEZE_MOUNT
   Eina_Bool mnt = EINA_FALSE;
   const char *act;
#endif
   gid_t gid, gl[65536], egid;

   for (i = 1; i < argc; i++)
     {
        if ((!strcmp(argv[i], ""-h"")) ||
            (!strcmp(argv[i], ""-help"")) ||
            (!strcmp(argv[i], ""--help"")))
          {
             printf(
               ""This is an internal tool for Enlightenment.\n""
               ""do not use it.\n""
               );
             exit(0);
          }
     }
   if (argc >= 3)
     {
        if ((argc == 3) && (!strcmp(argv[1], ""-t"")))
          {
             test = 1;
             action = argv[2];
          }
	else if (!strcmp(argv[1], ""l2ping""))
	  {
	     action = argv[1];
	     output = argv[2];
	  }
#ifdef HAVE_EEZE_MOUNT
        else
          {
             const char *s;

             s = strrchr(argv[1], '/');
             if ((!s) || (!s[1])) exit(1);  /* eeze always uses complete path */
             s++;
             if (strcmp(s, ""mount"") && strcmp(s, ""umount"") && strcmp(s, ""eject"")) exit(1);
             mnt = EINA_TRUE;
             act = s;
             action = argv[1];
          }
#endif
     }
   else if (argc == 2)
     {
        action = argv[1];
     }
   else
     {
        exit(1);
     }
   if (!action) exit(1);
   fprintf(stderr, ""action %s %i\n"", action, argc);

   uid = getuid();
   gid = getgid();
   egid = getegid();
   gn = getgroups(65536, gl);
   if (gn < 0)
     {
        printf(""ERROR: MEMBER OF MORE THAN 65536 GROUPS\n"");
        exit(3);
     }
   if (setuid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT PRIVILEGES\n"");
        exit(5);
     }
   if (setgid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT GROUP PRIVILEGES\n"");
        exit(7);
     }

   eina_init();

   if (!auth_action_ok(action, gid, gl, gn, egid))
     {
        printf(""ERROR: ACTION NOT ALLOWED: %s\n"", action);
        exit(10);
     }
   /* we can add more levels of auth here */

   /* when mounting, this will match the exact path to the exe,
    * as required in sysactions.conf
    * this is intentionally pedantic for security
    */
   cmd = eina_hash_find(actions, action);
   if (!cmd)
     {
        printf(""ERROR: UNDEFINED ACTION: %s\n"", action);
        exit(20);
     }

   if (!test && !strcmp(action, ""l2ping""))
     {
        char tmp[128];
	double latency;

	latency = e_sys_l2ping(output);

	eina_convert_dtoa(latency, tmp);
	fputs(tmp, stdout);

	return (latency < 0) ? 1 : 0;
     }
   /* sanitize environment */
#ifdef HAVE_UNSETENV
# define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
   NOENV(""IFS"");
    /* sanitize environment */
 #ifdef HAVE_UNSETENV
 # define NOENV(x) unsetenv(x)
   /* pass 1 - just nuke known dangerous env vars brutally if possible via
    * unsetenv(). if you don't have unsetenv... there's pass 2 and 3 */
    NOENV(""IFS"");
   NOENV(""CDPATH"");
   NOENV(""LOCALDOMAIN"");
   NOENV(""RES_OPTIONS"");
   NOENV(""HOSTALIASES"");
   NOENV(""NLSPATH"");
   NOENV(""PATH_LOCALE"");
   NOENV(""COLORTERM"");
   NOENV(""LANG"");
   NOENV(""LANGUAGE"");
   NOENV(""LINGUAS"");
   NOENV(""TERM"");
    NOENV(""LD_PRELOAD"");
    NOENV(""LD_LIBRARY_PATH"");
   NOENV(""SHLIB_PATH"");
   NOENV(""LIBPATH"");
   NOENV(""AUTHSTATE"");
   NOENV(""DYLD_*"");
   NOENV(""KRB_CONF*"");
   NOENV(""KRBCONFDIR"");
   NOENV(""KRBTKFILE"");
   NOENV(""KRB5_CONFIG*"");
   NOENV(""KRB5_KTNAME"");
   NOENV(""VAR_ACE"");
   NOENV(""USR_ACE"");
   NOENV(""DLC_ACE"");
   NOENV(""TERMINFO"");
   NOENV(""TERMINFO_DIRS"");
   NOENV(""TERMPATH"");
   NOENV(""TERMCAP"");
   NOENV(""ENV"");
   NOENV(""BASH_ENV"");
   NOENV(""PS4"");
   NOENV(""GLOBIGNORE"");
   NOENV(""SHELLOPTS"");
   NOENV(""JAVA_TOOL_OPTIONS"");
   NOENV(""PERLIO_DEBUG"");
   NOENV(""PERLLIB"");
   NOENV(""PERL5LIB"");
   NOENV(""PERL5OPT"");
   NOENV(""PERL5DB"");
   NOENV(""FPATH"");
   NOENV(""NULLCMD"");
   NOENV(""READNULLCMD"");
   NOENV(""ZDOTDIR"");
   NOENV(""TMPPREFIX"");
   NOENV(""PYTHONPATH"");
   NOENV(""PYTHONHOME"");
   NOENV(""PYTHONINSPECT"");
   NOENV(""RUBYLIB"");
   NOENV(""RUBYOPT"");
# ifdef HAVE_ENVIRON
   if (environ)
     {
        int again;
        char *tmp, *p;

        /* go over environment array again and again... safely */
        do
          {
             again = 0;

             /* walk through and find first entry that we don't like */
             for (i = 0; environ[i]; i++)
               {
                  /* if it begins with any of these, it's possibly nasty */
                  if ((!strncmp(environ[i], ""LD_"", 3)) ||
                      (!strncmp(environ[i], ""_RLD_"", 5)) ||
                      (!strncmp(environ[i], ""LC_"", 3)) ||
                      (!strncmp(environ[i], ""LDR_"", 3)))
                    {
                       /* unset it */
                       tmp = strdup(environ[i]);
                       if (!tmp) abort();
                       p = strchr(tmp, '=');
                       if (!p) abort();
                       *p = 0;
                       NOENV(p);
                       free(tmp);
                       /* and mark our do to try again from the start in case
                        * unsetenv changes environ ptr */
                       again = 1;
                       break;
                    }
               }
          }
        while (again);
     }
# endif
#endif

   /* pass 2 - clear entire environment so it doesn't exist at all. if you
    * can't do this... you're possibly in trouble... but the worst is still
    * fixed in pass 3 */
 #ifdef HAVE_CLEARENV
   clearenv();
#else
# ifdef HAVE_ENVIRON
   environ = NULL;
# endif
 #endif

   /* pass 3 - set path and ifs to minimal defaults */
    putenv(""PATH=/bin:/usr/bin"");
    putenv(""IFS= \t\n"");
   const char *p;
   char *end;
   unsigned long muid;
   Eina_Bool nosuid, nodev, noexec, nuid;

   nosuid = nodev = noexec = nuid = EINA_FALSE;

   /* these are the only possible options which can be present here; check them strictly */
   if (eina_strlcpy(buf, opts, sizeof(buf)) >= sizeof(buf)) return EINA_FALSE;
   for (p = buf; p && p[1]; p = strchr(p + 1, ','))
     {
        if (p[0] == ',') p++;
#define CMP(OPT) \
  if (!strncmp(p, OPT, sizeof(OPT) - 1))

        CMP(""nosuid,"")
        {
           nosuid = EINA_TRUE;
           continue;
        }
        CMP(""nodev,"")
        {
           nodev = EINA_TRUE;
           continue;
        }
        CMP(""noexec,"")
        {
           noexec = EINA_TRUE;
           continue;
        }
        CMP(""utf8,"") continue;
        CMP(""utf8=0,"") continue;
        CMP(""utf8=1,"") continue;
        CMP(""iocharset=utf8,"") continue;
        CMP(""uid="")
        {
           p += 4;
           errno = 0;
           muid = strtoul(p, &end, 10);
           if (muid == ULONG_MAX) return EINA_FALSE;
           if (errno) return EINA_FALSE;
           if (end[0] != ',') return EINA_FALSE;
           if (muid != uid) return EINA_FALSE;
           nuid = EINA_TRUE;
           continue;
        }
        return EINA_FALSE;
     }
   if ((!nosuid) || (!nodev) || (!noexec) || (!nuid)) return EINA_FALSE;
   return EINA_TRUE;
}
","main(int argc,
     char **argv)
{
   int i, gn;
   int test = 0;
   char *action = NULL, *cmd;
   char *output = NULL;
#ifdef HAVE_EEZE_MOUNT
   Eina_Bool mnt = EINA_FALSE;
   const char *act;
#endif
   gid_t gid, gl[65536], egid;

   for (i = 1; i < argc; i++)
     {
        if ((!strcmp(argv[i], ""-h"")) ||
            (!strcmp(argv[i], ""-help"")) ||
            (!strcmp(argv[i], ""--help"")))
          {
             printf(
               ""This is an internal tool for Enlightenment.\n""
               ""do not use it.\n""
               );
             exit(0);
          }
     }
   if (argc >= 3)
     {
        if ((argc == 3) && (!strcmp(argv[1], ""-t"")))
          {
             test = 1;
             action = argv[2];
          }
	else if (!strcmp(argv[1], ""l2ping""))
	  {
	     action = argv[1];
	     output = argv[2];
	  }
#ifdef HAVE_EEZE_MOUNT
        else
          {
             const char *s;

             s = strrchr(argv[1], '/');
             if ((!s) || (!s[1])) exit(1);  /* eeze always uses complete path */
             s++;
             if (strcmp(s, ""mount"") && strcmp(s, ""umount"") && strcmp(s, ""eject"")) exit(1);
             mnt = EINA_TRUE;
             act = s;
             action = argv[1];
          }
#endif
     }
   else if (argc == 2)
     {
        action = argv[1];
     }
   else
     {
        exit(1);
     }
   if (!action) exit(1);
   fprintf(stderr, ""action %s %i\n"", action, argc);

   uid = getuid();
   gid = getgid();
   egid = getegid();
   gn = getgroups(65536, gl);
   if (gn < 0)
     {
        printf(""ERROR: MEMBER OF MORE THAN 65536 GROUPS\n"");
        exit(3);
     }
   if (setuid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT PRIVILEGES\n"");
        exit(5);
     }
   if (setgid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT GROUP PRIVILEGES\n"");
        exit(7);
     }

   eina_init();

   if (!auth_action_ok(action, gid, gl, gn, egid))
     {
        printf(""ERROR: ACTION NOT ALLOWED: %s\n"", action);
        exit(10);
     }
   /* we can add more levels of auth here */

   /* when mounting, this will match the exact path to the exe,
    * as required in sysactions.conf
    * this is intentionally pedantic for security
    */
   cmd = eina_hash_find(actions, action);
   if (!cmd)
     {
        printf(""ERROR: UNDEFINED ACTION: %s\n"", action);
        exit(20);
     }

   if (!test && !strcmp(action, ""l2ping""))
     {
        char tmp[128];
	double latency;

	latency = e_sys_l2ping(output);

	eina_convert_dtoa(latency, tmp);
	fputs(tmp, stdout);

	return (latency < 0) ? 1 : 0;
     }
   /* sanitize environment */
#ifdef HAVE_UNSETENV
# define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
   NOENV(""IFS"");
    /* sanitize environment */
 #ifdef HAVE_UNSETENV
 # define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
    NOENV(""IFS"");
    NOENV(""LD_PRELOAD"");
   NOENV(""PYTHONPATH"");
    NOENV(""LD_LIBRARY_PATH"");
 #ifdef HAVE_CLEARENV
     clearenv();
 #endif
   /* set path and ifs to minimal defaults */
    putenv(""PATH=/bin:/usr/bin"");
    putenv(""IFS= \t\n"");
   const char *p;
   char *end;
   unsigned long muid;
   Eina_Bool nosuid, nodev, noexec, nuid;

   nosuid = nodev = noexec = nuid = EINA_FALSE;

   /* these are the only possible options which can be present here; check them strictly */
   if (eina_strlcpy(buf, opts, sizeof(buf)) >= sizeof(buf)) return EINA_FALSE;
   for (p = buf; p && p[1]; p = strchr(p + 1, ','))
     {
        if (p[0] == ',') p++;
#define CMP(OPT) \
  if (!strncmp(p, OPT, sizeof(OPT) - 1))

        CMP(""nosuid,"")
        {
           nosuid = EINA_TRUE;
           continue;
        }
        CMP(""nodev,"")
        {
           nodev = EINA_TRUE;
           continue;
        }
        CMP(""noexec,"")
        {
           noexec = EINA_TRUE;
           continue;
        }
        CMP(""utf8,"") continue;
        CMP(""utf8=0,"") continue;
        CMP(""utf8=1,"") continue;
        CMP(""iocharset=utf8,"") continue;
        CMP(""uid="")
        {
           p += 4;
           errno = 0;
           muid = strtoul(p, &end, 10);
           if (muid == ULONG_MAX) return EINA_FALSE;
           if (errno) return EINA_FALSE;
           if (end[0] != ',') return EINA_FALSE;
           if (muid != uid) return EINA_FALSE;
           nuid = EINA_TRUE;
           continue;
        }
        return EINA_FALSE;
     }
   if ((!nosuid) || (!nodev) || (!noexec) || (!nuid)) return EINA_FALSE;
   return EINA_TRUE;
}
",C,"   /* pass 1 - just nuke known dangerous env vars brutally if possible via
    * unsetenv(). if you don't have unsetenv... there's pass 2 and 3 */
   NOENV(""CDPATH"");
   NOENV(""LOCALDOMAIN"");
   NOENV(""RES_OPTIONS"");
   NOENV(""HOSTALIASES"");
   NOENV(""NLSPATH"");
   NOENV(""PATH_LOCALE"");
   NOENV(""COLORTERM"");
   NOENV(""LANG"");
   NOENV(""LANGUAGE"");
   NOENV(""LINGUAS"");
   NOENV(""TERM"");
   NOENV(""SHLIB_PATH"");
   NOENV(""LIBPATH"");
   NOENV(""AUTHSTATE"");
   NOENV(""DYLD_*"");
   NOENV(""KRB_CONF*"");
   NOENV(""KRBCONFDIR"");
   NOENV(""KRBTKFILE"");
   NOENV(""KRB5_CONFIG*"");
   NOENV(""KRB5_KTNAME"");
   NOENV(""VAR_ACE"");
   NOENV(""USR_ACE"");
   NOENV(""DLC_ACE"");
   NOENV(""TERMINFO"");
   NOENV(""TERMINFO_DIRS"");
   NOENV(""TERMPATH"");
   NOENV(""TERMCAP"");
   NOENV(""ENV"");
   NOENV(""BASH_ENV"");
   NOENV(""PS4"");
   NOENV(""GLOBIGNORE"");
   NOENV(""SHELLOPTS"");
   NOENV(""JAVA_TOOL_OPTIONS"");
   NOENV(""PERLIO_DEBUG"");
   NOENV(""PERLLIB"");
   NOENV(""PERL5LIB"");
   NOENV(""PERL5OPT"");
   NOENV(""PERL5DB"");
   NOENV(""FPATH"");
   NOENV(""NULLCMD"");
   NOENV(""READNULLCMD"");
   NOENV(""ZDOTDIR"");
   NOENV(""TMPPREFIX"");
   NOENV(""PYTHONPATH"");
   NOENV(""PYTHONHOME"");
   NOENV(""PYTHONINSPECT"");
   NOENV(""RUBYLIB"");
   NOENV(""RUBYOPT"");
# ifdef HAVE_ENVIRON
   if (environ)
     {
        int again;
        char *tmp, *p;

        /* go over environment array again and again... safely */
        do
          {
             again = 0;

             /* walk through and find first entry that we don't like */
             for (i = 0; environ[i]; i++)
               {
                  /* if it begins with any of these, it's possibly nasty */
                  if ((!strncmp(environ[i], ""LD_"", 3)) ||
                      (!strncmp(environ[i], ""_RLD_"", 5)) ||
                      (!strncmp(environ[i], ""LC_"", 3)) ||
                      (!strncmp(environ[i], ""LDR_"", 3)))
                    {
                       /* unset it */
                       tmp = strdup(environ[i]);
                       if (!tmp) abort();
                       p = strchr(tmp, '=');
                       if (!p) abort();
                       *p = 0;
                       NOENV(p);
                       free(tmp);
                       /* and mark our do to try again from the start in case
                        * unsetenv changes environ ptr */
                       again = 1;
                       break;
                    }
               }
          }
        while (again);
     }
# endif
#endif

   /* pass 2 - clear entire environment so it doesn't exist at all. if you
    * can't do this... you're possibly in trouble... but the worst is still
    * fixed in pass 3 */
   clearenv();
#else
# ifdef HAVE_ENVIRON
   environ = NULL;
# endif

   /* pass 3 - set path and ifs to minimal defaults */
","#else
# define NOENV(x)
#endif
   NOENV(""PYTHONPATH"");
     clearenv();
   /* set path and ifs to minimal defaults */
",fc9e8865cfb17a556a8a7efd1983ba211c16e545,"@@ -8,6 +8,9 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#ifdef HAVE_ENVIRON
+# define _GNU_SOURCE 1
+#endif
 #include <unistd.h>
 #include <string.h>
 #include <sys/types.h>
@@ -22,6 +25,10 @@
 #endif
 #include <Eina.h>
 
+#ifdef HAVE_ENVIRON
+extern char **environ;
+#endif
+
 double e_sys_l2ping(const char *bluetooth_mac);
 
 /* local subsystem functions */
@@ -166,17 +173,111 @@ main(int argc,
    /* sanitize environment */
 #ifdef HAVE_UNSETENV
 # define NOENV(x) unsetenv(x)
-#else
-# define NOENV(x)
-#endif
+   /* pass 1 - just nuke known dangerous env vars brutally if possible via
+    * unsetenv(). if you don't have unsetenv... there's pass 2 and 3 */
    NOENV(""IFS"");
+   NOENV(""CDPATH"");
+   NOENV(""LOCALDOMAIN"");
+   NOENV(""RES_OPTIONS"");
+   NOENV(""HOSTALIASES"");
+   NOENV(""NLSPATH"");
+   NOENV(""PATH_LOCALE"");
+   NOENV(""COLORTERM"");
+   NOENV(""LANG"");
+   NOENV(""LANGUAGE"");
+   NOENV(""LINGUAS"");
+   NOENV(""TERM"");
    NOENV(""LD_PRELOAD"");
-   NOENV(""PYTHONPATH"");
    NOENV(""LD_LIBRARY_PATH"");
+   NOENV(""SHLIB_PATH"");
+   NOENV(""LIBPATH"");
+   NOENV(""AUTHSTATE"");
+   NOENV(""DYLD_*"");
+   NOENV(""KRB_CONF*"");
+   NOENV(""KRBCONFDIR"");
+   NOENV(""KRBTKFILE"");
+   NOENV(""KRB5_CONFIG*"");
+   NOENV(""KRB5_KTNAME"");
+   NOENV(""VAR_ACE"");
+   NOENV(""USR_ACE"");
+   NOENV(""DLC_ACE"");
+   NOENV(""TERMINFO"");
+   NOENV(""TERMINFO_DIRS"");
+   NOENV(""TERMPATH"");
+   NOENV(""TERMCAP"");
+   NOENV(""ENV"");
+   NOENV(""BASH_ENV"");
+   NOENV(""PS4"");
+   NOENV(""GLOBIGNORE"");
+   NOENV(""SHELLOPTS"");
+   NOENV(""JAVA_TOOL_OPTIONS"");
+   NOENV(""PERLIO_DEBUG"");
+   NOENV(""PERLLIB"");
+   NOENV(""PERL5LIB"");
+   NOENV(""PERL5OPT"");
+   NOENV(""PERL5DB"");
+   NOENV(""FPATH"");
+   NOENV(""NULLCMD"");
+   NOENV(""READNULLCMD"");
+   NOENV(""ZDOTDIR"");
+   NOENV(""TMPPREFIX"");
+   NOENV(""PYTHONPATH"");
+   NOENV(""PYTHONHOME"");
+   NOENV(""PYTHONINSPECT"");
+   NOENV(""RUBYLIB"");
+   NOENV(""RUBYOPT"");
+# ifdef HAVE_ENVIRON
+   if (environ)
+     {
+        int again;
+        char *tmp, *p;
+
+        /* go over environment array again and again... safely */
+        do
+          {
+             again = 0;
+
+             /* walk through and find first entry that we don't like */
+             for (i = 0; environ[i]; i++)
+               {
+                  /* if it begins with any of these, it's possibly nasty */
+                  if ((!strncmp(environ[i], ""LD_"", 3)) ||
+                      (!strncmp(environ[i], ""_RLD_"", 5)) ||
+                      (!strncmp(environ[i], ""LC_"", 3)) ||
+                      (!strncmp(environ[i], ""LDR_"", 3)))
+                    {
+                       /* unset it */
+                       tmp = strdup(environ[i]);
+                       if (!tmp) abort();
+                       p = strchr(tmp, '=');
+                       if (!p) abort();
+                       *p = 0;
+                       NOENV(p);
+                       free(tmp);
+                       /* and mark our do to try again from the start in case
+                        * unsetenv changes environ ptr */
+                       again = 1;
+                       break;
+                    }
+               }
+          }
+        while (again);
+     }
+# endif
+#endif
+
+   /* pass 2 - clear entire environment so it doesn't exist at all. if you
+    * can't do this... you're possibly in trouble... but the worst is still
+    * fixed in pass 3 */
 #ifdef HAVE_CLEARENV
-     clearenv();
+   clearenv();
+#else
+# ifdef HAVE_ENVIRON
+   environ = NULL;
+# endif
 #endif
-   /* set path and ifs to minimal defaults */
+
+   /* pass 3 - set path and ifs to minimal defaults */
    putenv(""PATH=/bin:/usr/bin"");
    putenv(""IFS= \t\n"");",enlightment,https://git.enlightenment.org/core/enlightenment.git/tree/src/bin/e_sys_main.c?id=666df815cd86a50343859bce36c5cf968c5f38b0,https://git.enlightenment.org/core/enlightenment.git/tree/src/bin/e_sys_main.c?id=fc9e8865cfb17a556a8a7efd1983ba211c16e545,1,"main(int argc,
     char **argv)
{
   int i, gn;
   int test = 0;
   char *action = NULL, *cmd;
   char *output = NULL;
#ifdef HAVE_EEZE_MOUNT
   Eina_Bool mnt = EINA_FALSE;
   const char *act;
#endif
   gid_t gid, gl[65536], egid;

   for (i = 1; i < argc; i++)
     {
        if ((!strcmp(argv[i], ""-h"")) ||
            (!strcmp(argv[i], ""-help"")) ||
            (!strcmp(argv[i], ""--help"")))
          {
             printf(
               ""This is an internal tool for Enlightenment.\n""
               ""do not use it.\n""
               );
             exit(0);
          }
     }
   if (argc >= 3)
     {
        if ((argc == 3) && (!strcmp(argv[1], ""-t"")))
          {
             test = 1;
             action = argv[2];
          }
	else if (!strcmp(argv[1], ""l2ping""))
	  {
	     action = argv[1];
	     output = argv[2];
	  }
#ifdef HAVE_EEZE_MOUNT
        else
          {
             const char *s;

             s = strrchr(argv[1], '/');
             if ((!s) || (!s[1])) exit(1);  /* eeze always uses complete path */
             s++;
             if (strcmp(s, ""mount"") && strcmp(s, ""umount"") && strcmp(s, ""eject"")) exit(1);
             mnt = EINA_TRUE;
             act = s;
             action = argv[1];
          }
#endif
     }
   else if (argc == 2)
     {
        action = argv[1];
     }
   else
     {
        exit(1);
     }
   if (!action) exit(1);
   fprintf(stderr, ""action %s %i\n"", action, argc);

   uid = getuid();
   gid = getgid();
   egid = getegid();
   gn = getgroups(65536, gl);
   if (gn < 0)
     {
        printf(""ERROR: MEMBER OF MORE THAN 65536 GROUPS\n"");
        exit(3);
     }
   if (setuid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT PRIVILEGES\n"");
        exit(5);
     }
   if (setgid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT GROUP PRIVILEGES\n"");
        exit(7);
     }

   eina_init();

   if (!auth_action_ok(action, gid, gl, gn, egid))
     {
        printf(""ERROR: ACTION NOT ALLOWED: %s\n"", action);
        exit(10);
     }
   /* we can add more levels of auth here */

   /* when mounting, this will match the exact path to the exe,
    * as required in sysactions.conf
    * this is intentionally pedantic for security
    */
   cmd = eina_hash_find(actions, action);
   if (!cmd)
     {
        printf(""ERROR: UNDEFINED ACTION: %s\n"", action);
        exit(20);
     }

   if (!test && !strcmp(action, ""l2ping""))
     {
        char tmp[128];
	double latency;

	latency = e_sys_l2ping(output);

	eina_convert_dtoa(latency, tmp);
	fputs(tmp, stdout);

	return (latency < 0) ? 1 : 0;
     }
   /* sanitize environment */
#ifdef HAVE_UNSETENV
# define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
   NOENV(""IFS"");
    /* sanitize environment */
 #ifdef HAVE_UNSETENV
 # define NOENV(x) unsetenv(x)
//flaw_line_below:
#else
//flaw_line_below:
# define NOENV(x)
//flaw_line_below:
#endif
//fix_flaw_line_below:
//   /* pass 1 - just nuke known dangerous env vars brutally if possible via
//fix_flaw_line_below:
//    * unsetenv(). if you don't have unsetenv... there's pass 2 and 3 */
    NOENV(""IFS"");
//fix_flaw_line_below:
//   NOENV(""CDPATH"");
//fix_flaw_line_below:
//   NOENV(""LOCALDOMAIN"");
//fix_flaw_line_below:
//   NOENV(""RES_OPTIONS"");
//fix_flaw_line_below:
//   NOENV(""HOSTALIASES"");
//fix_flaw_line_below:
//   NOENV(""NLSPATH"");
//fix_flaw_line_below:
//   NOENV(""PATH_LOCALE"");
//fix_flaw_line_below:
//   NOENV(""COLORTERM"");
//fix_flaw_line_below:
//   NOENV(""LANG"");
//fix_flaw_line_below:
//   NOENV(""LANGUAGE"");
//fix_flaw_line_below:
//   NOENV(""LINGUAS"");
//fix_flaw_line_below:
//   NOENV(""TERM"");
    NOENV(""LD_PRELOAD"");
//flaw_line_below:
   NOENV(""PYTHONPATH"");
    NOENV(""LD_LIBRARY_PATH"");
//fix_flaw_line_below:
//   NOENV(""SHLIB_PATH"");
//fix_flaw_line_below:
//   NOENV(""LIBPATH"");
//fix_flaw_line_below:
//   NOENV(""AUTHSTATE"");
//fix_flaw_line_below:
//   NOENV(""DYLD_*"");
//fix_flaw_line_below:
//   NOENV(""KRB_CONF*"");
//fix_flaw_line_below:
//   NOENV(""KRBCONFDIR"");
//fix_flaw_line_below:
//   NOENV(""KRBTKFILE"");
//fix_flaw_line_below:
//   NOENV(""KRB5_CONFIG*"");
//fix_flaw_line_below:
//   NOENV(""KRB5_KTNAME"");
//fix_flaw_line_below:
//   NOENV(""VAR_ACE"");
//fix_flaw_line_below:
//   NOENV(""USR_ACE"");
//fix_flaw_line_below:
//   NOENV(""DLC_ACE"");
//fix_flaw_line_below:
//   NOENV(""TERMINFO"");
//fix_flaw_line_below:
//   NOENV(""TERMINFO_DIRS"");
//fix_flaw_line_below:
//   NOENV(""TERMPATH"");
//fix_flaw_line_below:
//   NOENV(""TERMCAP"");
//fix_flaw_line_below:
//   NOENV(""ENV"");
//fix_flaw_line_below:
//   NOENV(""BASH_ENV"");
//fix_flaw_line_below:
//   NOENV(""PS4"");
//fix_flaw_line_below:
//   NOENV(""GLOBIGNORE"");
//fix_flaw_line_below:
//   NOENV(""SHELLOPTS"");
//fix_flaw_line_below:
//   NOENV(""JAVA_TOOL_OPTIONS"");
//fix_flaw_line_below:
//   NOENV(""PERLIO_DEBUG"");
//fix_flaw_line_below:
//   NOENV(""PERLLIB"");
//fix_flaw_line_below:
//   NOENV(""PERL5LIB"");
//fix_flaw_line_below:
//   NOENV(""PERL5OPT"");
//fix_flaw_line_below:
//   NOENV(""PERL5DB"");
//fix_flaw_line_below:
//   NOENV(""FPATH"");
//fix_flaw_line_below:
//   NOENV(""NULLCMD"");
//fix_flaw_line_below:
//   NOENV(""READNULLCMD"");
//fix_flaw_line_below:
//   NOENV(""ZDOTDIR"");
//fix_flaw_line_below:
//   NOENV(""TMPPREFIX"");
//fix_flaw_line_below:
//   NOENV(""PYTHONPATH"");
//fix_flaw_line_below:
//   NOENV(""PYTHONHOME"");
//fix_flaw_line_below:
//   NOENV(""PYTHONINSPECT"");
//fix_flaw_line_below:
//   NOENV(""RUBYLIB"");
//fix_flaw_line_below:
//   NOENV(""RUBYOPT"");
//fix_flaw_line_below:
//# ifdef HAVE_ENVIRON
//fix_flaw_line_below:
//   if (environ)
//fix_flaw_line_below:
//     {
//fix_flaw_line_below:
//        int again;
//fix_flaw_line_below:
//        char *tmp, *p;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        /* go over environment array again and again... safely */
//fix_flaw_line_below:
//        do
//fix_flaw_line_below:
//          {
//fix_flaw_line_below:
//             again = 0;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//             /* walk through and find first entry that we don't like */
//fix_flaw_line_below:
//             for (i = 0; environ[i]; i++)
//fix_flaw_line_below:
//               {
//fix_flaw_line_below:
//                  /* if it begins with any of these, it's possibly nasty */
//fix_flaw_line_below:
//                  if ((!strncmp(environ[i], ""LD_"", 3)) ||
//fix_flaw_line_below:
//                      (!strncmp(environ[i], ""_RLD_"", 5)) ||
//fix_flaw_line_below:
//                      (!strncmp(environ[i], ""LC_"", 3)) ||
//fix_flaw_line_below:
//                      (!strncmp(environ[i], ""LDR_"", 3)))
//fix_flaw_line_below:
//                    {
//fix_flaw_line_below:
//                       /* unset it */
//fix_flaw_line_below:
//                       tmp = strdup(environ[i]);
//fix_flaw_line_below:
//                       if (!tmp) abort();
//fix_flaw_line_below:
//                       p = strchr(tmp, '=');
//fix_flaw_line_below:
//                       if (!p) abort();
//fix_flaw_line_below:
//                       *p = 0;
//fix_flaw_line_below:
//                       NOENV(p);
//fix_flaw_line_below:
//                       free(tmp);
//fix_flaw_line_below:
//                       /* and mark our do to try again from the start in case
//fix_flaw_line_below:
//                        * unsetenv changes environ ptr */
//fix_flaw_line_below:
//                       again = 1;
//fix_flaw_line_below:
//                       break;
//fix_flaw_line_below:
//                    }
//fix_flaw_line_below:
//               }
//fix_flaw_line_below:
//          }
//fix_flaw_line_below:
//        while (again);
//fix_flaw_line_below:
//     }
//fix_flaw_line_below:
//# endif
//fix_flaw_line_below:
//#endif
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//   /* pass 2 - clear entire environment so it doesn't exist at all. if you
//fix_flaw_line_below:
//    * can't do this... you're possibly in trouble... but the worst is still
//fix_flaw_line_below:
//    * fixed in pass 3 */
 #ifdef HAVE_CLEARENV
//flaw_line_below:
     clearenv();
//fix_flaw_line_below:
//   clearenv();
//fix_flaw_line_below:
//#else
//fix_flaw_line_below:
//# ifdef HAVE_ENVIRON
//fix_flaw_line_below:
//   environ = NULL;
//fix_flaw_line_below:
//# endif
 #endif
//flaw_line_below:
   /* set path and ifs to minimal defaults */
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//   /* pass 3 - set path and ifs to minimal defaults */
    putenv(""PATH=/bin:/usr/bin"");
    putenv(""IFS= \t\n"");
   const char *p;
   char *end;
   unsigned long muid;
   Eina_Bool nosuid, nodev, noexec, nuid;

   nosuid = nodev = noexec = nuid = EINA_FALSE;

   /* these are the only possible options which can be present here; check them strictly */
   if (eina_strlcpy(buf, opts, sizeof(buf)) >= sizeof(buf)) return EINA_FALSE;
   for (p = buf; p && p[1]; p = strchr(p + 1, ','))
     {
        if (p[0] == ',') p++;
#define CMP(OPT) \
  if (!strncmp(p, OPT, sizeof(OPT) - 1))

        CMP(""nosuid,"")
        {
           nosuid = EINA_TRUE;
           continue;
        }
        CMP(""nodev,"")
        {
           nodev = EINA_TRUE;
           continue;
        }
        CMP(""noexec,"")
        {
           noexec = EINA_TRUE;
           continue;
        }
        CMP(""utf8,"") continue;
        CMP(""utf8=0,"") continue;
        CMP(""utf8=1,"") continue;
        CMP(""iocharset=utf8,"") continue;
        CMP(""uid="")
        {
           p += 4;
           errno = 0;
           muid = strtoul(p, &end, 10);
           if (muid == ULONG_MAX) return EINA_FALSE;
           if (errno) return EINA_FALSE;
           if (end[0] != ',') return EINA_FALSE;
           if (muid != uid) return EINA_FALSE;
           nuid = EINA_TRUE;
           continue;
        }
        return EINA_FALSE;
     }
   if ((!nosuid) || (!nodev) || (!noexec) || (!nuid)) return EINA_FALSE;
   return EINA_TRUE;
}
",178685,"main(int argc,
     char **argv)
{
   int i, gn;
   int test = 0;
   char *action = NULL, *cmd;
   char *output = NULL;
#ifdef HAVE_EEZE_MOUNT
   Eina_Bool mnt = EINA_FALSE;
   const char *act;
#endif
   gid_t gid, gl[65536], egid;

   for (i = 1; i < argc; i++)
     {
        if ((!strcmp(argv[i], ""-h"")) ||
            (!strcmp(argv[i], ""-help"")) ||
            (!strcmp(argv[i], ""--help"")))
          {
             printf(
               ""This is an internal tool for Enlightenment.\n""
               ""do not use it.\n""
               );
             exit(0);
          }
     }
   if (argc >= 3)
     {
        if ((argc == 3) && (!strcmp(argv[1], ""-t"")))
          {
             test = 1;
             action = argv[2];
          }
	else if (!strcmp(argv[1], ""l2ping""))
	  {
	     action = argv[1];
	     output = argv[2];
	  }
#ifdef HAVE_EEZE_MOUNT
        else
          {
             const char *s;

             s = strrchr(argv[1], '/');
             if ((!s) || (!s[1])) exit(1);  /* eeze always uses complete path */
             s++;
             if (strcmp(s, ""mount"") && strcmp(s, ""umount"") && strcmp(s, ""eject"")) exit(1);
             mnt = EINA_TRUE;
             act = s;
             action = argv[1];
          }
#endif
     }
   else if (argc == 2)
     {
        action = argv[1];
     }
   else
     {
        exit(1);
     }
   if (!action) exit(1);
   fprintf(stderr, ""action %s %i\n"", action, argc);

   uid = getuid();
   gid = getgid();
   egid = getegid();
   gn = getgroups(65536, gl);
   if (gn < 0)
     {
        printf(""ERROR: MEMBER OF MORE THAN 65536 GROUPS\n"");
        exit(3);
     }
   if (setuid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT PRIVILEGES\n"");
        exit(5);
     }
   if (setgid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT GROUP PRIVILEGES\n"");
        exit(7);
     }

   eina_init();

   if (!auth_action_ok(action, gid, gl, gn, egid))
     {
        printf(""ERROR: ACTION NOT ALLOWED: %s\n"", action);
        exit(10);
     }
   /* we can add more levels of auth here */

   /* when mounting, this will match the exact path to the exe,
    * as required in sysactions.conf
    * this is intentionally pedantic for security
    */
   cmd = eina_hash_find(actions, action);
   if (!cmd)
     {
        printf(""ERROR: UNDEFINED ACTION: %s\n"", action);
        exit(20);
     }

   if (!test && !strcmp(action, ""l2ping""))
     {
        char tmp[128];
	double latency;

	latency = e_sys_l2ping(output);

	eina_convert_dtoa(latency, tmp);
	fputs(tmp, stdout);

	return (latency < 0) ? 1 : 0;
     }
   /* sanitize environment */
#ifdef HAVE_UNSETENV
# define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
   NOENV(""IFS"");
    /* sanitize environment */
 #ifdef HAVE_UNSETENV
 # define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
    NOENV(""IFS"");
    NOENV(""LD_PRELOAD"");
   NOENV(""PYTHONPATH"");
    NOENV(""LD_LIBRARY_PATH"");
 #ifdef HAVE_CLEARENV
     clearenv();
 #endif
   /* set path and ifs to minimal defaults */
    putenv(""PATH=/bin:/usr/bin"");
    putenv(""IFS= \t\n"");
   const char *p;
   char *end;
   unsigned long muid;
   Eina_Bool nosuid, nodev, noexec, nuid;

   nosuid = nodev = noexec = nuid = EINA_FALSE;

   /* these are the only possible options which can be present here; check them strictly */
   if (eina_strlcpy(buf, opts, sizeof(buf)) >= sizeof(buf)) return EINA_FALSE;
   for (p = buf; p && p[1]; p = strchr(p + 1, ','))
     {
        if (p[0] == ',') p++;
#define CMP(OPT) \
  if (!strncmp(p, OPT, sizeof(OPT) - 1))

        CMP(""nosuid,"")
        {
           nosuid = EINA_TRUE;
           continue;
        }
        CMP(""nodev,"")
        {
           nodev = EINA_TRUE;
           continue;
        }
        CMP(""noexec,"")
        {
           noexec = EINA_TRUE;
           continue;
        }
        CMP(""utf8,"") continue;
        CMP(""utf8=0,"") continue;
        CMP(""utf8=1,"") continue;
        CMP(""iocharset=utf8,"") continue;
        CMP(""uid="")
        {
           p += 4;
           errno = 0;
           muid = strtoul(p, &end, 10);
           if (muid == ULONG_MAX) return EINA_FALSE;
           if (errno) return EINA_FALSE;
           if (end[0] != ',') return EINA_FALSE;
           if (muid != uid) return EINA_FALSE;
           nuid = EINA_TRUE;
           continue;
        }
        return EINA_FALSE;
     }
   if ((!nosuid) || (!nodev) || (!noexec) || (!nuid)) return EINA_FALSE;
   return EINA_TRUE;
}
","main(int argc,
     char **argv)
{
   int i, gn;
   int test = 0;
   char *action = NULL, *cmd;
   char *output = NULL;
#ifdef HAVE_EEZE_MOUNT
   Eina_Bool mnt = EINA_FALSE;
   const char *act;
#endif
   gid_t gid, gl[65536], egid;

   for (i = 1; i < argc; i++)
     {
        if ((!strcmp(argv[i], ""-h"")) ||
            (!strcmp(argv[i], ""-help"")) ||
            (!strcmp(argv[i], ""--help"")))
          {
             printf(
               ""This is an internal tool for Enlightenment.\n""
               ""do not use it.\n""
               );
             exit(0);
          }
     }
   if (argc >= 3)
     {
        if ((argc == 3) && (!strcmp(argv[1], ""-t"")))
          {
             test = 1;
             action = argv[2];
          }
	else if (!strcmp(argv[1], ""l2ping""))
	  {
	     action = argv[1];
	     output = argv[2];
	  }
#ifdef HAVE_EEZE_MOUNT
        else
          {
             const char *s;

             s = strrchr(argv[1], '/');
             if ((!s) || (!s[1])) exit(1);  /* eeze always uses complete path */
             s++;
             if (strcmp(s, ""mount"") && strcmp(s, ""umount"") && strcmp(s, ""eject"")) exit(1);
             mnt = EINA_TRUE;
             act = s;
             action = argv[1];
          }
#endif
     }
   else if (argc == 2)
     {
        action = argv[1];
     }
   else
     {
        exit(1);
     }
   if (!action) exit(1);
   fprintf(stderr, ""action %s %i\n"", action, argc);

   uid = getuid();
   gid = getgid();
   egid = getegid();
   gn = getgroups(65536, gl);
   if (gn < 0)
     {
        printf(""ERROR: MEMBER OF MORE THAN 65536 GROUPS\n"");
        exit(3);
     }
   if (setuid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT PRIVILEGES\n"");
        exit(5);
     }
   if (setgid(0) != 0)
     {
        printf(""ERROR: UNABLE TO ASSUME ROOT GROUP PRIVILEGES\n"");
        exit(7);
     }

   eina_init();

   if (!auth_action_ok(action, gid, gl, gn, egid))
     {
        printf(""ERROR: ACTION NOT ALLOWED: %s\n"", action);
        exit(10);
     }
   /* we can add more levels of auth here */

   /* when mounting, this will match the exact path to the exe,
    * as required in sysactions.conf
    * this is intentionally pedantic for security
    */
   cmd = eina_hash_find(actions, action);
   if (!cmd)
     {
        printf(""ERROR: UNDEFINED ACTION: %s\n"", action);
        exit(20);
     }

   if (!test && !strcmp(action, ""l2ping""))
     {
        char tmp[128];
	double latency;

	latency = e_sys_l2ping(output);

	eina_convert_dtoa(latency, tmp);
	fputs(tmp, stdout);

	return (latency < 0) ? 1 : 0;
     }
   /* sanitize environment */
#ifdef HAVE_UNSETENV
# define NOENV(x) unsetenv(x)
#else
# define NOENV(x)
#endif
   NOENV(""IFS"");
    /* sanitize environment */
 #ifdef HAVE_UNSETENV
 # define NOENV(x) unsetenv(x)
   /* pass 1 - just nuke known dangerous env vars brutally if possible via
    * unsetenv(). if you don't have unsetenv... there's pass 2 and 3 */
    NOENV(""IFS"");
   NOENV(""CDPATH"");
   NOENV(""LOCALDOMAIN"");
   NOENV(""RES_OPTIONS"");
   NOENV(""HOSTALIASES"");
   NOENV(""NLSPATH"");
   NOENV(""PATH_LOCALE"");
   NOENV(""COLORTERM"");
   NOENV(""LANG"");
   NOENV(""LANGUAGE"");
   NOENV(""LINGUAS"");
   NOENV(""TERM"");
    NOENV(""LD_PRELOAD"");
    NOENV(""LD_LIBRARY_PATH"");
   NOENV(""SHLIB_PATH"");
   NOENV(""LIBPATH"");
   NOENV(""AUTHSTATE"");
   NOENV(""DYLD_*"");
   NOENV(""KRB_CONF*"");
   NOENV(""KRBCONFDIR"");
   NOENV(""KRBTKFILE"");
   NOENV(""KRB5_CONFIG*"");
   NOENV(""KRB5_KTNAME"");
   NOENV(""VAR_ACE"");
   NOENV(""USR_ACE"");
   NOENV(""DLC_ACE"");
   NOENV(""TERMINFO"");
   NOENV(""TERMINFO_DIRS"");
   NOENV(""TERMPATH"");
   NOENV(""TERMCAP"");
   NOENV(""ENV"");
   NOENV(""BASH_ENV"");
   NOENV(""PS4"");
   NOENV(""GLOBIGNORE"");
   NOENV(""SHELLOPTS"");
   NOENV(""JAVA_TOOL_OPTIONS"");
   NOENV(""PERLIO_DEBUG"");
   NOENV(""PERLLIB"");
   NOENV(""PERL5LIB"");
   NOENV(""PERL5OPT"");
   NOENV(""PERL5DB"");
   NOENV(""FPATH"");
   NOENV(""NULLCMD"");
   NOENV(""READNULLCMD"");
   NOENV(""ZDOTDIR"");
   NOENV(""TMPPREFIX"");
   NOENV(""PYTHONPATH"");
   NOENV(""PYTHONHOME"");
   NOENV(""PYTHONINSPECT"");
   NOENV(""RUBYLIB"");
   NOENV(""RUBYOPT"");
# ifdef HAVE_ENVIRON
   if (environ)
     {
        int again;
        char *tmp, *p;

        /* go over environment array again and again... safely */
        do
          {
             again = 0;

             /* walk through and find first entry that we don't like */
             for (i = 0; environ[i]; i++)
               {
                  /* if it begins with any of these, it's possibly nasty */
                  if ((!strncmp(environ[i], ""LD_"", 3)) ||
                      (!strncmp(environ[i], ""_RLD_"", 5)) ||
                      (!strncmp(environ[i], ""LC_"", 3)) ||
                      (!strncmp(environ[i], ""LDR_"", 3)))
                    {
                       /* unset it */
                       tmp = strdup(environ[i]);
                       if (!tmp) abort();
                       p = strchr(tmp, '=');
                       if (!p) abort();
                       *p = 0;
                       NOENV(p);
                       free(tmp);
                       /* and mark our do to try again from the start in case
                        * unsetenv changes environ ptr */
                       again = 1;
                       break;
                    }
               }
          }
        while (again);
     }
# endif
#endif

   /* pass 2 - clear entire environment so it doesn't exist at all. if you
    * can't do this... you're possibly in trouble... but the worst is still
    * fixed in pass 3 */
 #ifdef HAVE_CLEARENV
   clearenv();
#else
# ifdef HAVE_ENVIRON
   environ = NULL;
# endif
 #endif

   /* pass 3 - set path and ifs to minimal defaults */
    putenv(""PATH=/bin:/usr/bin"");
    putenv(""IFS= \t\n"");
   const char *p;
   char *end;
   unsigned long muid;
   Eina_Bool nosuid, nodev, noexec, nuid;

   nosuid = nodev = noexec = nuid = EINA_FALSE;

   /* these are the only possible options which can be present here; check them strictly */
   if (eina_strlcpy(buf, opts, sizeof(buf)) >= sizeof(buf)) return EINA_FALSE;
   for (p = buf; p && p[1]; p = strchr(p + 1, ','))
     {
        if (p[0] == ',') p++;
#define CMP(OPT) \
  if (!strncmp(p, OPT, sizeof(OPT) - 1))

        CMP(""nosuid,"")
        {
           nosuid = EINA_TRUE;
           continue;
        }
        CMP(""nodev,"")
        {
           nodev = EINA_TRUE;
           continue;
        }
        CMP(""noexec,"")
        {
           noexec = EINA_TRUE;
           continue;
        }
        CMP(""utf8,"") continue;
        CMP(""utf8=0,"") continue;
        CMP(""utf8=1,"") continue;
        CMP(""iocharset=utf8,"") continue;
        CMP(""uid="")
        {
           p += 4;
           errno = 0;
           muid = strtoul(p, &end, 10);
           if (muid == ULONG_MAX) return EINA_FALSE;
           if (errno) return EINA_FALSE;
           if (end[0] != ',') return EINA_FALSE;
           if (muid != uid) return EINA_FALSE;
           nuid = EINA_TRUE;
           continue;
        }
        return EINA_FALSE;
     }
   if ((!nosuid) || (!nodev) || (!noexec) || (!nuid)) return EINA_FALSE;
   return EINA_TRUE;
}
","The provided code is a command-line utility for the Enlightenment desktop environment, designed to perform specific actions based on user input. It begins by parsing command-line arguments, checking for help flags, and validating the number of arguments. If the action is valid, it attempts to elevate privileges to root and checks if the requested action is authorized. The code also sanitizes the environment by unsetting certain variables and setting minimal defaults. It processes options related to mounting, ensuring strict adherence to security protocols, and ultimately returns a boolean indicating the success of the operation based on the specified conditions.","The code is a command-line utility designed for a specific desktop environment, which processes user input to execute various actions. It begins by checking for help requests and validating the number of arguments provided. If the input is valid, it attempts to gain elevated privileges and verifies whether the requested action is permitted. The utility also sanitizes the environment by removing certain variables and setting minimal defaults to enhance security. Finally, it evaluates specific options related to mounting and returns a success status based on the fulfillment of predefined conditions, ensuring strict adherence to security protocols.","The vulnerability in the original code stemmed from insufficient sanitization of the environment variables, which could allow an attacker to manipulate the execution context by injecting malicious values, particularly in variables like `LD_PRELOAD` or `PATH`. This could lead to privilege escalation or arbitrary code execution. The fixed code addresses this issue by implementing a more comprehensive sanitization process, which includes unsetting a wider range of potentially dangerous environment variables and clearing the entire environment if possible. This ensures that only safe, minimal defaults are set, significantly reducing the risk of exploitation through environment manipulation.","The vulnerability in the original code arose from inadequate sanitization of environment variables, which could allow an attacker to manipulate the execution context and potentially execute arbitrary code or escalate privileges. This lack of thorough checks made the system susceptible to exploitation through malicious environment settings. The fixed code addresses this issue by implementing a comprehensive sanitization process that removes a broader range of potentially harmful environment variables and clears the entire environment when possible. This ensures that only safe, minimal defaults are established, significantly mitigating the risk of exploitation through environment manipulation.","The vulnerability was fixed by enhancing the sanitization of environment variables in the updated code. The original code only removed a limited set of dangerous variables, while the revised version employs a more comprehensive approach by unsetting a wider array of potentially harmful variables, such as `LD_PRELOAD`, `PATH`, and others. Additionally, it utilizes the `clearenv()` function to completely clear the environment when available, ensuring that no unwanted variables remain. This thorough sanitization process significantly reduces the risk of exploitation by ensuring that only safe, minimal defaults are set, thereby protecting the execution context from manipulation.","The vulnerability was fixed by implementing a more rigorous sanitization process for environment variables. The updated code removes a broader range of potentially harmful variables that could be exploited to manipulate the execution context. Additionally, it includes a mechanism to completely clear the environment when possible, ensuring that no unwanted or malicious variables remain. This comprehensive approach significantly enhances security by establishing a clean and controlled execution environment, thereby mitigating the risk of privilege escalation or arbitrary code execution that could arise from improperly handled environment settings.","CWE-426,CWE-78,CWE-88,CWE-74,CWE-214,CWE-473,CWE-470,CWE-471,CWE-89,CWE-77",N,-1
11,11,178695,178695,,Remote,Not required,Partial,CVE-2010-0011,https://www.cvedetails.com/cve/CVE-2010-0011/,CWE-264,Low,Partial,Partial,,2010-02-25,7.5,"The eval_js function in uzbl-core.c in Uzbl before 2010.01.05 exposes the run method of the Uzbl object, which allows remote attackers to execute arbitrary commands via JavaScript code.",2017-08-16,Exec Code ,0,https://github.com/Dieterbe/uzbl/commit/1958b52d41cba96956dc1995660de49525ed1047,1958b52d41cba96956dc1995660de49525ed1047,disable Uzbl javascript object because of security problem.,8,uzbl-core.c,"{""sha"": ""a22e105934e4dbd5360e68f28cdbb7474022d4e5"", ""filename"": ""README"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 20, ""changes"": 21, ""blob_url"": ""https://github.com/uzbl/uzbl/blob/1958b52d41cba96956dc1995660de49525ed1047/README"", ""raw_url"": ""https://github.com/uzbl/uzbl/raw/1958b52d41cba96956dc1995660de49525ed1047/README"", ""contents_url"": ""https://api.github.com/repos/uzbl/uzbl/contents/README?ref=1958b52d41cba96956dc1995660de49525ed1047"", ""patch"": ""@@ -397,7 +397,7 @@ The script specific arguments are this:\n \n Custom, userdefined scripts (`spawn foo bar`) get first the arguments as specified in the config and then the above 7 are added at the end.\n \n-### JAVASCRIPT HELPER OBJECT\n+### JAVASCRIPT HELPER OBJECT DISABLED BECAUSE OF SECURITY LEAK\n \n Javascript code run from uzbl is given a special object in the global namespace which gives special privileges to these scripts. This object is called `Uzbl`, and it is added and removed before and after the script execution so that it is hidden to web javascripts (There is no race condition, since all the javascript code runs in a single thread)\n \n@@ -410,25 +410,6 @@ Currently, the `Uzbl` object provides only one function:\n        * `Uzbl.run(\""spawn insert_bookmark.sh\"")`\n        * `uri = Uzbl.run(\""print @uri\"")` (see variable expansion below)\n \n-### JAVASCRIPT SECURITY\n-\n-Since defined variables and functions are set in the global namespace (`window` object) as default, it is recommended to wrap your scripts like this:\n-\n-    (function(Uzbl) {\n-        ...\n-    })(Uzbl);\n-\n-This way, everything is kept private. It also turns Uzbl into a local variable, which can be accessed from callback functions defined inside. However for some situations, isolating everything isn't an option, for example, with binds. You can define them directly in the script body, and use `var Uzbl = window.Uzbl;` to make the Uzbl variable local, as in the following example:\n-\n-    function f() {\n-        var Uzbl = window.Uzbl;\n-        Uzbl.run(...);\n-        setTimeout(function() {\n-            Uzbl.run(...);\n-        }, 500);\n-    }\n-\n-Copying the Uzbl object and creating public functions should be taken with care to avoid creating security holes. Keep in mind that the \""f\"" function above would be defined in the `window` object, and as such any javascript in the current page can call it.\n \n ### EVENTS ###\n ""}<_**next**_>{""sha"": ""fc3b092ea0dd6a2593c92178eb07049a95160a60"", ""filename"": ""tests/test-command.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/uzbl/uzbl/blob/1958b52d41cba96956dc1995660de49525ed1047/tests/test-command.c"", ""raw_url"": ""https://github.com/uzbl/uzbl/raw/1958b52d41cba96956dc1995660de49525ed1047/tests/test-command.c"", ""contents_url"": ""https://api.github.com/repos/uzbl/uzbl/contents/tests/test-command.c?ref=1958b52d41cba96956dc1995660de49525ed1047"", ""patch"": ""@@ -305,11 +305,6 @@ test_js (void) {\n     parse_cmd_line(\""js ('x' + 345).toUpperCase()\"", result);\n     g_assert_cmpstr(\""X345\"", ==, result->str);\n \n-    /* uzbl commands can be run from javascript */\n-    uzbl.net.useragent = \""Test useragent\"";\n-    parse_cmd_line(\""js Uzbl.run('print @useragent').toUpperCase();\"", result);\n-    g_assert_cmpstr(\""TEST USERAGENT\"", ==, result->str);\n-\n     g_string_free(result, TRUE);\n }\n ""}<_**next**_>{""sha"": ""fca293c1f5e8ff116ae4de3e1d3f2ecc51f593f6"", ""filename"": ""uzbl-core.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 10, ""changes"": 10, ""blob_url"": ""https://github.com/uzbl/uzbl/blob/1958b52d41cba96956dc1995660de49525ed1047/uzbl-core.c"", ""raw_url"": ""https://github.com/uzbl/uzbl/raw/1958b52d41cba96956dc1995660de49525ed1047/uzbl-core.c"", ""contents_url"": ""https://api.github.com/repos/uzbl/uzbl/contents/uzbl-core.c?ref=1958b52d41cba96956dc1995660de49525ed1047"", ""patch"": ""@@ -1046,7 +1046,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n     WebKitWebFrame *frame;\n     JSGlobalContextRef context;\n     JSObjectRef globalobject;\n-    JSStringRef var_name;\n \n     JSStringRef js_script;\n     JSValueRef js_result;\n@@ -1059,12 +1058,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n     context = webkit_web_frame_get_global_context(frame);\n     globalobject = JSContextGetGlobalObject(context);\n \n-    /* uzbl javascript namespace */\n-    var_name = JSStringCreateWithUTF8CString(\""Uzbl\"");\n-    JSObjectSetProperty(context, globalobject, var_name,\n-                        JSObjectMake(context, uzbl.js.classref, NULL),\n-                        kJSClassAttributeNone, NULL);\n-\n     /* evaluate the script and get return value*/\n     js_script = JSStringCreateWithUTF8CString(script);\n     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);\n@@ -1082,9 +1075,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n     }\n \n     /* cleanup */\n-    JSObjectDeleteProperty(context, globalobject, var_name, NULL);\n-\n-    JSStringRelease(var_name);\n     JSStringRelease(js_script);\n }\n ""}","eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     WebKitWebFrame *frame;
     JSGlobalContextRef context;
     JSObjectRef globalobject;
 
     JSStringRef js_script;
     JSValueRef js_result;
    JSStringRef js_result_string;
    size_t js_result_size;

    js_init();

    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));
     context = webkit_web_frame_get_global_context(frame);
     globalobject = JSContextGetGlobalObject(context);
 
     /* evaluate the script and get return value*/
     js_script = JSStringCreateWithUTF8CString(script);
     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);
    if (js_result && !JSValueIsUndefined(context, js_result)) {
        js_result_string = JSValueToStringCopy(context, js_result, NULL);
        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);

        if (js_result_size) {
            char js_result_utf8[js_result_size];
            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);
            g_string_assign(result, js_result_utf8);
        }

        JSStringRelease(js_result_string);
     }
 
     /* cleanup */
     JSStringRelease(js_script);
 }
","eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     WebKitWebFrame *frame;
     JSGlobalContextRef context;
     JSObjectRef globalobject;
    JSStringRef var_name;
 
     JSStringRef js_script;
     JSValueRef js_result;
    JSStringRef js_result_string;
    size_t js_result_size;

    js_init();

    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));
     context = webkit_web_frame_get_global_context(frame);
     globalobject = JSContextGetGlobalObject(context);
 
    /* uzbl javascript namespace */
    var_name = JSStringCreateWithUTF8CString(""Uzbl"");
    JSObjectSetProperty(context, globalobject, var_name,
                        JSObjectMake(context, uzbl.js.classref, NULL),
                        kJSClassAttributeNone, NULL);
     /* evaluate the script and get return value*/
     js_script = JSStringCreateWithUTF8CString(script);
     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);
    if (js_result && !JSValueIsUndefined(context, js_result)) {
        js_result_string = JSValueToStringCopy(context, js_result, NULL);
        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);

        if (js_result_size) {
            char js_result_utf8[js_result_size];
            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);
            g_string_assign(result, js_result_utf8);
        }

        JSStringRelease(js_result_string);
     }
 
     /* cleanup */
    JSObjectDeleteProperty(context, globalobject, var_name, NULL);
    JSStringRelease(var_name);
     JSStringRelease(js_script);
 }
",C,,"    JSStringRef var_name;
    /* uzbl javascript namespace */
    var_name = JSStringCreateWithUTF8CString(""Uzbl"");
    JSObjectSetProperty(context, globalobject, var_name,
                        JSObjectMake(context, uzbl.js.classref, NULL),
                        kJSClassAttributeNone, NULL);
    JSObjectDeleteProperty(context, globalobject, var_name, NULL);
    JSStringRelease(var_name);
",,"@@ -1046,7 +1046,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     WebKitWebFrame *frame;
     JSGlobalContextRef context;
     JSObjectRef globalobject;
-    JSStringRef var_name;
 
     JSStringRef js_script;
     JSValueRef js_result;
@@ -1059,12 +1058,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     context = webkit_web_frame_get_global_context(frame);
     globalobject = JSContextGetGlobalObject(context);
 
-    /* uzbl javascript namespace */
-    var_name = JSStringCreateWithUTF8CString(""Uzbl"");
-    JSObjectSetProperty(context, globalobject, var_name,
-                        JSObjectMake(context, uzbl.js.classref, NULL),
-                        kJSClassAttributeNone, NULL);
-
     /* evaluate the script and get return value*/
     js_script = JSStringCreateWithUTF8CString(script);
     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);
@@ -1082,9 +1075,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     }
 
     /* cleanup */
-    JSObjectDeleteProperty(context, globalobject, var_name, NULL);
-
-    JSStringRelease(var_name);
     JSStringRelease(js_script);
 }
 ",uzbl,1958b52d41cba96956dc1995660de49525ed1047,49941155e43eb520c43b02b55e0bbced2b657cf6,1,"eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     WebKitWebFrame *frame;
     JSGlobalContextRef context;
     JSObjectRef globalobject;
//flaw_line_below:
    JSStringRef var_name;
 
     JSStringRef js_script;
     JSValueRef js_result;
    JSStringRef js_result_string;
    size_t js_result_size;

    js_init();

    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));
     context = webkit_web_frame_get_global_context(frame);
     globalobject = JSContextGetGlobalObject(context);
 
//flaw_line_below:
    /* uzbl javascript namespace */
//flaw_line_below:
    var_name = JSStringCreateWithUTF8CString(""Uzbl"");
//flaw_line_below:
    JSObjectSetProperty(context, globalobject, var_name,
//flaw_line_below:
                        JSObjectMake(context, uzbl.js.classref, NULL),
//flaw_line_below:
                        kJSClassAttributeNone, NULL);
//flaw_line_below:

     /* evaluate the script and get return value*/
     js_script = JSStringCreateWithUTF8CString(script);
     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);
    if (js_result && !JSValueIsUndefined(context, js_result)) {
        js_result_string = JSValueToStringCopy(context, js_result, NULL);
        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);

        if (js_result_size) {
            char js_result_utf8[js_result_size];
            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);
            g_string_assign(result, js_result_utf8);
        }

        JSStringRelease(js_result_string);
     }
 
     /* cleanup */
//flaw_line_below:
    JSObjectDeleteProperty(context, globalobject, var_name, NULL);
//flaw_line_below:

//flaw_line_below:
    JSStringRelease(var_name);
     JSStringRelease(js_script);
 }
",178695,"eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     WebKitWebFrame *frame;
     JSGlobalContextRef context;
     JSObjectRef globalobject;
    JSStringRef var_name;
 
     JSStringRef js_script;
     JSValueRef js_result;
    JSStringRef js_result_string;
    size_t js_result_size;

    js_init();

    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));
     context = webkit_web_frame_get_global_context(frame);
     globalobject = JSContextGetGlobalObject(context);
 
    /* uzbl javascript namespace */
    var_name = JSStringCreateWithUTF8CString(""Uzbl"");
    JSObjectSetProperty(context, globalobject, var_name,
                        JSObjectMake(context, uzbl.js.classref, NULL),
                        kJSClassAttributeNone, NULL);
     /* evaluate the script and get return value*/
     js_script = JSStringCreateWithUTF8CString(script);
     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);
    if (js_result && !JSValueIsUndefined(context, js_result)) {
        js_result_string = JSValueToStringCopy(context, js_result, NULL);
        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);

        if (js_result_size) {
            char js_result_utf8[js_result_size];
            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);
            g_string_assign(result, js_result_utf8);
        }

        JSStringRelease(js_result_string);
     }
 
     /* cleanup */
    JSObjectDeleteProperty(context, globalobject, var_name, NULL);
    JSStringRelease(var_name);
     JSStringRelease(js_script);
 }
","eval_js(WebKitWebView * web_view, gchar *script, GString *result) {
     WebKitWebFrame *frame;
     JSGlobalContextRef context;
     JSObjectRef globalobject;
 
     JSStringRef js_script;
     JSValueRef js_result;
    JSStringRef js_result_string;
    size_t js_result_size;

    js_init();

    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));
     context = webkit_web_frame_get_global_context(frame);
     globalobject = JSContextGetGlobalObject(context);
 
     /* evaluate the script and get return value*/
     js_script = JSStringCreateWithUTF8CString(script);
     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);
    if (js_result && !JSValueIsUndefined(context, js_result)) {
        js_result_string = JSValueToStringCopy(context, js_result, NULL);
        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);

        if (js_result_size) {
            char js_result_utf8[js_result_size];
            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);
            g_string_assign(result, js_result_utf8);
        }

        JSStringRelease(js_result_string);
     }
 
     /* cleanup */
     JSStringRelease(js_script);
 }
","The provided code defines a function `eval_js` that evaluates a JavaScript script within a specified WebKit web view context. It initializes the JavaScript environment, retrieves the main frame and its global context, and sets up a custom JavaScript namespace called ""Uzbl."" The function then evaluates the provided script, capturing the result if it is defined. If a valid result is obtained, it converts the JavaScript value to a UTF-8 string and assigns it to a GString object for further use. Finally, the function cleans up by deleting the custom property and releasing allocated resources.","The code defines a function that evaluates a JavaScript script within a web view's context. It initializes the JavaScript environment and retrieves the main frame's global context, where it establishes a custom namespace. The function then executes the provided script and checks if the result is defined. If a valid result is obtained, it converts this result into a UTF-8 string format and assigns it to a specified output object. Finally, the function performs cleanup by removing the custom namespace and releasing any allocated resources to ensure efficient memory management.","The vulnerability in the original code stemmed from the exposure of a custom JavaScript object, ""Uzbl,"" which could potentially allow malicious scripts to access sensitive functions or data within the web view context. This was addressed in the fixed code by removing the creation and assignment of the ""Uzbl"" namespace, thereby eliminating the risk of unauthorized access to the application's internals. The revised code focuses solely on evaluating the provided script without introducing any additional global objects, thus enhancing security by preventing potential exploitation through the JavaScript interface.","The vulnerability in the original code arose from exposing a custom JavaScript object that could be manipulated by potentially malicious scripts, allowing unauthorized access to sensitive application functions and data. This posed a significant security risk, as it could lead to exploitation through the JavaScript interface. The fix involved removing the creation and assignment of this custom object, thereby eliminating the associated security threat. The revised code now focuses solely on executing the provided script without introducing any additional global objects, significantly enhancing the security posture by preventing unauthorized interactions with the application's internals.","The vulnerability was fixed by removing the creation and assignment of the ""Uzbl"" JavaScript object within the code. In the original implementation, the line that set the property using `JSObjectSetProperty` to introduce the custom namespace was eliminated. This change prevents any potentially malicious scripts from accessing sensitive application functions through the ""Uzbl"" object. Additionally, the cleanup process was simplified by removing the deletion of the custom property, as it was no longer necessary. The revised code now focuses solely on evaluating the provided script without exposing any additional global objects, thereby enhancing overall security.","The vulnerability was fixed by eliminating the creation of a custom JavaScript object that could expose sensitive application functions to potentially malicious scripts. By removing the assignment of this object, the code no longer allows unauthorized access to the application's internals through the JavaScript interface. Additionally, the cleanup process was simplified, as there was no longer a need to delete the custom property. The revised implementation now focuses solely on executing the provided script without introducing any additional global objects, thereby significantly enhancing the security of the application against exploitation.","CWE-489, CWE-470, CWE-346, CWE-749, CWE-913, CWE-94, CWE-284, CWE-693, CWE-434, CWE-611",N,-1
12,12,178773,178773,,Local,Not required,Partial,CVE-2012-2313,https://www.cvedetails.com/cve/CVE-2012-2313/,CWE-264,High,,,,2012-06-13,1.2,"The rio_ioctl function in drivers/net/ethernet/dlink/dl2k.c in the Linux kernel before 3.3.7 does not restrict access to the SIOCSMIIREG command, which allows local users to write data to an Ethernet adapter via an ioctl call.",2016-09-06,,9,https://github.com/torvalds/linux/commit/1bb57e940e1958e40d51f2078f50c3a96a9b2d75,1bb57e940e1958e40d51f2078f50c3a96a9b2d75,"dl2k: Clean up rio_ioctl

The dl2k driver's rio_ioctl call has a few issues:
- No permissions checking
- Implements SIOCGMIIREG and SIOCGMIIREG using the SIOCDEVPRIVATE numbers
- Has a few ioctls that may have been used for debugging at one point
  but have no place in the kernel proper.

This patch removes all but the MII ioctls, renumbers them to use the
standard ones, and adds the proper permission check for SIOCSMIIREG.

We can also get rid of the dl2k-specific struct mii_data in favor of
the generic struct mii_ioctl_data.

Since we have the phyid on hand, we can add the SIOCGMIIPHY ioctl too.

Most of the MII code for the driver could probably be converted to use
the generic MII library but I don't have a device to test the results.

Reported-by: Stephan Mueller <stephan.mueller@atsec.com>
Signed-off-by: Jeff Mahoney <jeffm@suse.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",40,drivers/net/ethernet/dlink/dl2k.c,"{""sha"": ""2e09edb9cdf84b3d1cc49d7dad5167a2ce3be75a"", ""filename"": ""drivers/net/ethernet/dlink/dl2k.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 43, ""changes"": 52, ""blob_url"": ""https://github.com/torvalds/linux/blob/1bb57e940e1958e40d51f2078f50c3a96a9b2d75/drivers/net/ethernet/dlink/dl2k.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/1bb57e940e1958e40d51f2078f50c3a96a9b2d75/drivers/net/ethernet/dlink/dl2k.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/dlink/dl2k.c?ref=1bb57e940e1958e40d51f2078f50c3a96a9b2d75"", ""patch"": ""@@ -1259,55 +1259,21 @@ rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n {\n \tint phy_addr;\n \tstruct netdev_private *np = netdev_priv(dev);\n-\tstruct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;\n-\n-\tstruct netdev_desc *desc;\n-\tint i;\n+\tstruct mii_ioctl_data *miidata = if_mii(rq);\n \n \tphy_addr = np->phy_addr;\n \tswitch (cmd) {\n-\tcase SIOCDEVPRIVATE:\n-\t\tbreak;\n-\n-\tcase SIOCDEVPRIVATE + 1:\n-\t\tmiidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);\n+\tcase SIOCGMIIPHY:\n+\t\tmiidata->phy_id = phy_addr;\n \t\tbreak;\n-\tcase SIOCDEVPRIVATE + 2:\n-\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);\n+\tcase SIOCGMIIREG:\n+\t\tmiidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);\n \t\tbreak;\n-\tcase SIOCDEVPRIVATE + 3:\n-\t\tbreak;\n-\tcase SIOCDEVPRIVATE + 4:\n-\t\tbreak;\n-\tcase SIOCDEVPRIVATE + 5:\n-\t\tnetif_stop_queue (dev);\n+\tcase SIOCSMIIREG:\n+\t\tif (!capable(CAP_NET_ADMIN))\n+\t\t\treturn -EPERM;\n+\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);\n \t\tbreak;\n-\tcase SIOCDEVPRIVATE + 6:\n-\t\tnetif_wake_queue (dev);\n-\t\tbreak;\n-\tcase SIOCDEVPRIVATE + 7:\n-\t\tprintk\n-\t\t    (\""tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\\n\"",\n-\t\t     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,\n-\t\t     np->old_rx);\n-\t\tbreak;\n-\tcase SIOCDEVPRIVATE + 8:\n-\t\tprintk(\""TX ring:\\n\"");\n-\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n-\t\t\tdesc = &np->tx_ring[i];\n-\t\t\tprintk\n-\t\t\t    (\""%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x\"",\n-\t\t\t     i,\n-\t\t\t     (u32) (np->tx_ring_dma + i * sizeof (*desc)),\n-\t\t\t     (u32)le64_to_cpu(desc->next_desc),\n-\t\t\t     (u32)le64_to_cpu(desc->status),\n-\t\t\t     (u32)(le64_to_cpu(desc->fraginfo) >> 32),\n-\t\t\t     (u32)le64_to_cpu(desc->fraginfo));\n-\t\t\tprintk (\""\\n\"");\n-\t\t}\n-\t\tprintk (\""\\n\"");\n-\t\tbreak;\n-\n \tdefault:\n \t\treturn -EOPNOTSUPP;\n \t}""}<_**next**_>{""sha"": ""30c2da3de548f92ce0ebe794dc9c894af284c010"", ""filename"": ""drivers/net/ethernet/dlink/dl2k.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/1bb57e940e1958e40d51f2078f50c3a96a9b2d75/drivers/net/ethernet/dlink/dl2k.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/1bb57e940e1958e40d51f2078f50c3a96a9b2d75/drivers/net/ethernet/dlink/dl2k.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/dlink/dl2k.h?ref=1bb57e940e1958e40d51f2078f50c3a96a9b2d75"", ""patch"": ""@@ -365,13 +365,6 @@ struct ioctl_data {\n \tchar *data;\n };\n \n-struct mii_data {\n-\t__u16 reserved;\n-\t__u16 reg_num;\n-\t__u16 in_value;\n-\t__u16 out_value;\n-};\n-\n /* The Rx and Tx buffer descriptors. */\n struct netdev_desc {\n \t__le64 next_desc;""}","rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
	struct mii_ioctl_data *miidata = if_mii(rq);
 
 	phy_addr = np->phy_addr;
 	switch (cmd) {
	case SIOCGMIIPHY:
		miidata->phy_id = phy_addr;
 		break;
	case SIOCGMIIREG:
		miidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);
 		break;
	case SIOCSMIIREG:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;
		mii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);
 		break;
 	default:
 		return -EOPNOTSUPP;
 	}
	return 0;
}
","rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
	struct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;
	struct netdev_desc *desc;
	int i;
 
 	phy_addr = np->phy_addr;
 	switch (cmd) {
	case SIOCDEVPRIVATE:
		break;
	case SIOCDEVPRIVATE + 1:
		miidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);
 		break;
	case SIOCDEVPRIVATE + 2:
		mii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);
 		break;
	case SIOCDEVPRIVATE + 3:
		break;
	case SIOCDEVPRIVATE + 4:
		break;
	case SIOCDEVPRIVATE + 5:
		netif_stop_queue (dev);
 		break;
	case SIOCDEVPRIVATE + 6:
		netif_wake_queue (dev);
		break;
	case SIOCDEVPRIVATE + 7:
		printk
		    (""tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\n"",
		     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,
		     np->old_rx);
		break;
	case SIOCDEVPRIVATE + 8:
		printk(""TX ring:\n"");
		for (i = 0; i < TX_RING_SIZE; i++) {
			desc = &np->tx_ring[i];
			printk
			    (""%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x"",
			     i,
			     (u32) (np->tx_ring_dma + i * sizeof (*desc)),
			     (u32)le64_to_cpu(desc->next_desc),
			     (u32)le64_to_cpu(desc->status),
			     (u32)(le64_to_cpu(desc->fraginfo) >> 32),
			     (u32)le64_to_cpu(desc->fraginfo));
			printk (""\n"");
		}
		printk (""\n"");
		break;
 	default:
 		return -EOPNOTSUPP;
 	}
	return 0;
}
",C,"	struct mii_ioctl_data *miidata = if_mii(rq);
	case SIOCGMIIPHY:
		miidata->phy_id = phy_addr;
	case SIOCGMIIREG:
		miidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);
	case SIOCSMIIREG:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;
		mii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);
","	struct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;
	struct netdev_desc *desc;
	int i;
	case SIOCDEVPRIVATE:
		break;
	case SIOCDEVPRIVATE + 1:
		miidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);
	case SIOCDEVPRIVATE + 2:
		mii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);
	case SIOCDEVPRIVATE + 3:
		break;
	case SIOCDEVPRIVATE + 4:
		break;
	case SIOCDEVPRIVATE + 5:
		netif_stop_queue (dev);
	case SIOCDEVPRIVATE + 6:
		netif_wake_queue (dev);
		break;
	case SIOCDEVPRIVATE + 7:
		printk
		    (""tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\n"",
		     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,
		     np->old_rx);
		break;
	case SIOCDEVPRIVATE + 8:
		printk(""TX ring:\n"");
		for (i = 0; i < TX_RING_SIZE; i++) {
			desc = &np->tx_ring[i];
			printk
			    (""%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x"",
			     i,
			     (u32) (np->tx_ring_dma + i * sizeof (*desc)),
			     (u32)le64_to_cpu(desc->next_desc),
			     (u32)le64_to_cpu(desc->status),
			     (u32)(le64_to_cpu(desc->fraginfo) >> 32),
			     (u32)le64_to_cpu(desc->fraginfo));
			printk (""\n"");
		}
		printk (""\n"");
		break;
",,"@@ -1259,55 +1259,21 @@ rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
-	struct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;
-
-	struct netdev_desc *desc;
-	int i;
+	struct mii_ioctl_data *miidata = if_mii(rq);
 
 	phy_addr = np->phy_addr;
 	switch (cmd) {
-	case SIOCDEVPRIVATE:
-		break;
-
-	case SIOCDEVPRIVATE + 1:
-		miidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);
+	case SIOCGMIIPHY:
+		miidata->phy_id = phy_addr;
 		break;
-	case SIOCDEVPRIVATE + 2:
-		mii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);
+	case SIOCGMIIREG:
+		miidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);
 		break;
-	case SIOCDEVPRIVATE + 3:
-		break;
-	case SIOCDEVPRIVATE + 4:
-		break;
-	case SIOCDEVPRIVATE + 5:
-		netif_stop_queue (dev);
+	case SIOCSMIIREG:
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+		mii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);
 		break;
-	case SIOCDEVPRIVATE + 6:
-		netif_wake_queue (dev);
-		break;
-	case SIOCDEVPRIVATE + 7:
-		printk
-		    (""tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\n"",
-		     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,
-		     np->old_rx);
-		break;
-	case SIOCDEVPRIVATE + 8:
-		printk(""TX ring:\n"");
-		for (i = 0; i < TX_RING_SIZE; i++) {
-			desc = &np->tx_ring[i];
-			printk
-			    (""%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x"",
-			     i,
-			     (u32) (np->tx_ring_dma + i * sizeof (*desc)),
-			     (u32)le64_to_cpu(desc->next_desc),
-			     (u32)le64_to_cpu(desc->status),
-			     (u32)(le64_to_cpu(desc->fraginfo) >> 32),
-			     (u32)le64_to_cpu(desc->fraginfo));
-			printk (""\n"");
-		}
-		printk (""\n"");
-		break;
-
 	default:
 		return -EOPNOTSUPP;
 	}",linux,1bb57e940e1958e40d51f2078f50c3a96a9b2d75,768f7c7c121e80f458a9d013b2e8b169e5dfb1e5,1,"rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
//flaw_line_below:
	struct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;
//flaw_line_below:

//flaw_line_below:
	struct netdev_desc *desc;
//flaw_line_below:
	int i;
//fix_flaw_line_below:
//	struct mii_ioctl_data *miidata = if_mii(rq);
 
 	phy_addr = np->phy_addr;
 	switch (cmd) {
//flaw_line_below:
	case SIOCDEVPRIVATE:
//flaw_line_below:
		break;
//flaw_line_below:

//flaw_line_below:
	case SIOCDEVPRIVATE + 1:
//flaw_line_below:
		miidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);
//fix_flaw_line_below:
//	case SIOCGMIIPHY:
//fix_flaw_line_below:
//		miidata->phy_id = phy_addr;
 		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 2:
//flaw_line_below:
		mii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);
//fix_flaw_line_below:
//	case SIOCGMIIREG:
//fix_flaw_line_below:
//		miidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);
 		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 3:
//flaw_line_below:
		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 4:
//flaw_line_below:
		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 5:
//flaw_line_below:
		netif_stop_queue (dev);
//fix_flaw_line_below:
//	case SIOCSMIIREG:
//fix_flaw_line_below:
//		if (!capable(CAP_NET_ADMIN))
//fix_flaw_line_below:
//			return -EPERM;
//fix_flaw_line_below:
//		mii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);
 		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 6:
//flaw_line_below:
		netif_wake_queue (dev);
//flaw_line_below:
		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 7:
//flaw_line_below:
		printk
//flaw_line_below:
		    (""tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\n"",
//flaw_line_below:
		     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,
//flaw_line_below:
		     np->old_rx);
//flaw_line_below:
		break;
//flaw_line_below:
	case SIOCDEVPRIVATE + 8:
//flaw_line_below:
		printk(""TX ring:\n"");
//flaw_line_below:
		for (i = 0; i < TX_RING_SIZE; i++) {
//flaw_line_below:
			desc = &np->tx_ring[i];
//flaw_line_below:
			printk
//flaw_line_below:
			    (""%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x"",
//flaw_line_below:
			     i,
//flaw_line_below:
			     (u32) (np->tx_ring_dma + i * sizeof (*desc)),
//flaw_line_below:
			     (u32)le64_to_cpu(desc->next_desc),
//flaw_line_below:
			     (u32)le64_to_cpu(desc->status),
//flaw_line_below:
			     (u32)(le64_to_cpu(desc->fraginfo) >> 32),
//flaw_line_below:
			     (u32)le64_to_cpu(desc->fraginfo));
//flaw_line_below:
			printk (""\n"");
//flaw_line_below:
		}
//flaw_line_below:
		printk (""\n"");
//flaw_line_below:
		break;
//flaw_line_below:

 	default:
 		return -EOPNOTSUPP;
 	}
	return 0;
}
",178773,"rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
	struct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;
	struct netdev_desc *desc;
	int i;
 
 	phy_addr = np->phy_addr;
 	switch (cmd) {
	case SIOCDEVPRIVATE:
		break;
	case SIOCDEVPRIVATE + 1:
		miidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);
 		break;
	case SIOCDEVPRIVATE + 2:
		mii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);
 		break;
	case SIOCDEVPRIVATE + 3:
		break;
	case SIOCDEVPRIVATE + 4:
		break;
	case SIOCDEVPRIVATE + 5:
		netif_stop_queue (dev);
 		break;
	case SIOCDEVPRIVATE + 6:
		netif_wake_queue (dev);
		break;
	case SIOCDEVPRIVATE + 7:
		printk
		    (""tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\n"",
		     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,
		     np->old_rx);
		break;
	case SIOCDEVPRIVATE + 8:
		printk(""TX ring:\n"");
		for (i = 0; i < TX_RING_SIZE; i++) {
			desc = &np->tx_ring[i];
			printk
			    (""%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x"",
			     i,
			     (u32) (np->tx_ring_dma + i * sizeof (*desc)),
			     (u32)le64_to_cpu(desc->next_desc),
			     (u32)le64_to_cpu(desc->status),
			     (u32)(le64_to_cpu(desc->fraginfo) >> 32),
			     (u32)le64_to_cpu(desc->fraginfo));
			printk (""\n"");
		}
		printk (""\n"");
		break;
 	default:
 		return -EOPNOTSUPP;
 	}
	return 0;
}
","rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
	struct mii_ioctl_data *miidata = if_mii(rq);
 
 	phy_addr = np->phy_addr;
 	switch (cmd) {
	case SIOCGMIIPHY:
		miidata->phy_id = phy_addr;
 		break;
	case SIOCGMIIREG:
		miidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);
 		break;
	case SIOCSMIIREG:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;
		mii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);
 		break;
 	default:
 		return -EOPNOTSUPP;
 	}
	return 0;
}
","The `rio_ioctl` function is an implementation of an ioctl handler for a network device in a Linux kernel module, allowing various control commands to be executed on the device. It retrieves the physical address of the device and processes commands based on the provided `cmd` parameter. The function supports reading and writing to MII registers, stopping and waking the network transmission queue, and printing the status of the transmission queue and the TX ring descriptors. If an unsupported command is received, it returns an error code. Overall, it facilitates low-level network device management and diagnostics.","The provided code defines a function that handles control commands for a network device within a Linux kernel module. It processes various commands to manage the device's operation, including reading from and writing to specific hardware registers, controlling the transmission queue, and logging the status of the transmission process. The function can stop or resume data transmission and provides diagnostic information about the device's transmission state. If an unsupported command is encountered, it returns an error, ensuring that only valid operations are executed for device management and monitoring.","The vulnerability in the original code stemmed from a lack of permission checks, allowing unauthorized users to execute sensitive operations, such as writing to hardware registers. Specifically, the command for writing to a register did not verify if the caller had the necessary administrative capabilities. The fixed code addresses this by introducing a permission check using the `capable(CAP_NET_ADMIN)` function before executing the write operation. Additionally, the code was cleaned up to remove unnecessary commands and replaced a custom data structure with a standard one, enhancing security and maintainability while ensuring that only valid and authorized operations are performed.","The vulnerability in the original code was primarily due to the absence of permission checks, which allowed unauthorized users to perform sensitive operations on the network device, potentially compromising system security. Additionally, the implementation used non-standard command numbers, which could lead to confusion and misuse. The fixed code rectifies this by introducing a proper permission check before executing write operations, ensuring that only authorized users can make changes. It also simplifies the command structure by removing unnecessary commands and adopting standard command numbers, thereby enhancing both security and clarity in the code's functionality.","The vulnerability was fixed by implementing a permission check using the `capable(CAP_NET_ADMIN)` function before executing the write operation in the `SIOCSMIIREG` command, ensuring that only users with administrative privileges can modify hardware registers. Additionally, the code was streamlined by removing unnecessary commands and replacing the custom `struct mii_data` with the more generic `struct mii_ioctl_data`, which enhances compatibility and maintainability. The commands were also renumbered to use standard ioctl numbers, improving clarity and reducing the risk of misuse, thereby reinforcing the overall security of the ioctl handling in the driver.","The vulnerability was addressed by introducing a permission check that ensures only authorized users can perform sensitive write operations, thereby preventing unauthorized access to critical device functions. Additionally, the code was simplified by removing unnecessary commands that were previously included for debugging purposes, which reduced potential attack vectors. The implementation was also updated to utilize standard command numbers instead of custom ones, enhancing clarity and consistency. Overall, these changes improved the security and maintainability of the code, ensuring that only valid and authorized operations are executed on the network device.","CWE-284,CWE-269,CWE-732,CWE-264,CWE-287,CWE-285,CWE-434,CWE-266,CWE-862,CWE-250",Y,4
13,13,178788,178788,,Local,Not required,Complete,CVE-2012-2123,https://www.cvedetails.com/cve/CVE-2012-2123/,CWE-264,Low,Complete,Complete,,2012-05-17,7.2,"The cap_bprm_set_creds function in security/commoncap.c in the Linux kernel before 3.3.3 does not properly handle the use of file system capabilities (aka fcaps) for implementing a privileged executable file, which allows local users to bypass intended personality restrictions via a crafted application, as demonstrated by an attack that uses a parent process to disable ASLR.",2017-12-28,Bypass ,5,https://github.com/torvalds/linux/commit/d52fc5dde171f030170a6cb78034d166b13c9445,d52fc5dde171f030170a6cb78034d166b13c9445,"fcaps: clear the same personality flags as suid when fcaps are used

If a process increases permissions using fcaps all of the dangerous
personality flags which are cleared for suid apps should also be cleared.
Thus programs given priviledge with fcaps will continue to have address space
randomization enabled even if the parent tried to disable it to make it
easier to attack.

Signed-off-by: Eric Paris <eparis@redhat.com>
Reviewed-by: Serge Hallyn <serge.hallyn@canonical.com>
Signed-off-by: James Morris <james.l.morris@oracle.com>",0,security/commoncap.c,"{""sha"": ""0ecf4ba321cbeaa812dadc6524e138bc40b866b3"", ""filename"": ""security/commoncap.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/d52fc5dde171f030170a6cb78034d166b13c9445/security/commoncap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d52fc5dde171f030170a6cb78034d166b13c9445/security/commoncap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/commoncap.c?ref=d52fc5dde171f030170a6cb78034d166b13c9445"", ""patch"": ""@@ -505,6 +505,11 @@ int cap_bprm_set_creds(struct linux_binprm *bprm)\n \t}\n skip:\n \n+\t/* if we have fs caps, clear dangerous personality flags */\n+\tif (!cap_issubset(new->cap_permitted, old->cap_permitted))\n+\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n+\n+\n \t/* Don't let someone trace a set[ug]id/setpcap binary with the revised\n \t * credentials unless they have the appropriate permit\n \t */""}","int cap_bprm_set_creds(struct linux_binprm *bprm)
{
	const struct cred *old = current_cred();
	struct cred *new = bprm->cred;
	bool effective, has_cap = false;
	int ret;

	effective = false;
	ret = get_file_caps(bprm, &effective, &has_cap);
	if (ret < 0)
		return ret;

	if (!issecure(SECURE_NOROOT)) {
		/*
		 * If the legacy file capability is set, then don't set privs
		 * for a setuid root binary run by a non-root user.  Do set it
		 * for a root user just to cause least surprise to an admin.
		 */
		if (has_cap && new->uid != 0 && new->euid == 0) {
			warn_setuid_and_fcaps_mixed(bprm->filename);
			goto skip;
		}
		/*
		 * To support inheritance of root-permissions and suid-root
		 * executables under compatibility mode, we override the
		 * capability sets for the file.
		 *
		 * If only the real uid is 0, we do not set the effective bit.
		 */
		if (new->euid == 0 || new->uid == 0) {
			/* pP' = (cap_bset & ~0) | (pI & ~0) */
			new->cap_permitted = cap_combine(old->cap_bset,
							 old->cap_inheritable);
		}
		if (new->euid == 0)
			effective = true;
 	}
 skip:
 
	/* if we have fs caps, clear dangerous personality flags */
	if (!cap_issubset(new->cap_permitted, old->cap_permitted))
		bprm->per_clear |= PER_CLEAR_ON_SETID;


 	/* Don't let someone trace a set[ug]id/setpcap binary with the revised
 	 * credentials unless they have the appropriate permit
 	 */
	if ((new->euid != old->uid ||
	     new->egid != old->gid ||
	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&
	    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {
		/* downgrade; they get no more than they had, and maybe less */
		if (!capable(CAP_SETUID)) {
			new->euid = new->uid;
			new->egid = new->gid;
		}
		new->cap_permitted = cap_intersect(new->cap_permitted,
						   old->cap_permitted);
	}

	new->suid = new->fsuid = new->euid;
	new->sgid = new->fsgid = new->egid;

	if (effective)
		new->cap_effective = new->cap_permitted;
	else
		cap_clear(new->cap_effective);
	bprm->cap_effective = effective;

	/*
	 * Audit candidate if current->cap_effective is set
	 *
	 * We do not bother to audit if 3 things are true:
	 *   1) cap_effective has all caps
	 *   2) we are root
	 *   3) root is supposed to have all caps (SECURE_NOROOT)
	 * Since this is just a normal root execing a process.
	 *
	 * Number 1 above might fail if you don't have a full bset, but I think
	 * that is interesting information to audit.
	 */
	if (!cap_isclear(new->cap_effective)) {
		if (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||
		    new->euid != 0 || new->uid != 0 ||
		    issecure(SECURE_NOROOT)) {
			ret = audit_log_bprm_fcaps(bprm, new, old);
			if (ret < 0)
				return ret;
		}
	}

	new->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);
	return 0;
}
","int cap_bprm_set_creds(struct linux_binprm *bprm)
{
	const struct cred *old = current_cred();
	struct cred *new = bprm->cred;
	bool effective, has_cap = false;
	int ret;

	effective = false;
	ret = get_file_caps(bprm, &effective, &has_cap);
	if (ret < 0)
		return ret;

	if (!issecure(SECURE_NOROOT)) {
		/*
		 * If the legacy file capability is set, then don't set privs
		 * for a setuid root binary run by a non-root user.  Do set it
		 * for a root user just to cause least surprise to an admin.
		 */
		if (has_cap && new->uid != 0 && new->euid == 0) {
			warn_setuid_and_fcaps_mixed(bprm->filename);
			goto skip;
		}
		/*
		 * To support inheritance of root-permissions and suid-root
		 * executables under compatibility mode, we override the
		 * capability sets for the file.
		 *
		 * If only the real uid is 0, we do not set the effective bit.
		 */
		if (new->euid == 0 || new->uid == 0) {
			/* pP' = (cap_bset & ~0) | (pI & ~0) */
			new->cap_permitted = cap_combine(old->cap_bset,
							 old->cap_inheritable);
		}
		if (new->euid == 0)
			effective = true;
 	}
 skip:
 
 	/* Don't let someone trace a set[ug]id/setpcap binary with the revised
 	 * credentials unless they have the appropriate permit
 	 */
	if ((new->euid != old->uid ||
	     new->egid != old->gid ||
	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&
	    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {
		/* downgrade; they get no more than they had, and maybe less */
		if (!capable(CAP_SETUID)) {
			new->euid = new->uid;
			new->egid = new->gid;
		}
		new->cap_permitted = cap_intersect(new->cap_permitted,
						   old->cap_permitted);
	}

	new->suid = new->fsuid = new->euid;
	new->sgid = new->fsgid = new->egid;

	if (effective)
		new->cap_effective = new->cap_permitted;
	else
		cap_clear(new->cap_effective);
	bprm->cap_effective = effective;

	/*
	 * Audit candidate if current->cap_effective is set
	 *
	 * We do not bother to audit if 3 things are true:
	 *   1) cap_effective has all caps
	 *   2) we are root
	 *   3) root is supposed to have all caps (SECURE_NOROOT)
	 * Since this is just a normal root execing a process.
	 *
	 * Number 1 above might fail if you don't have a full bset, but I think
	 * that is interesting information to audit.
	 */
	if (!cap_isclear(new->cap_effective)) {
		if (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||
		    new->euid != 0 || new->uid != 0 ||
		    issecure(SECURE_NOROOT)) {
			ret = audit_log_bprm_fcaps(bprm, new, old);
			if (ret < 0)
				return ret;
		}
	}

	new->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);
	return 0;
}
",C,"	/* if we have fs caps, clear dangerous personality flags */
	if (!cap_issubset(new->cap_permitted, old->cap_permitted))
		bprm->per_clear |= PER_CLEAR_ON_SETID;


",,,"@@ -505,6 +505,11 @@ int cap_bprm_set_creds(struct linux_binprm *bprm)
 	}
 skip:
 
+	/* if we have fs caps, clear dangerous personality flags */
+	if (!cap_issubset(new->cap_permitted, old->cap_permitted))
+		bprm->per_clear |= PER_CLEAR_ON_SETID;
+
+
 	/* Don't let someone trace a set[ug]id/setpcap binary with the revised
 	 * credentials unless they have the appropriate permit
 	 */",linux,d52fc5dde171f030170a6cb78034d166b13c9445,09c79b60960bdd4b00916219402eabfa5e479c5a,1,"int cap_bprm_set_creds(struct linux_binprm *bprm)
{
	const struct cred *old = current_cred();
	struct cred *new = bprm->cred;
	bool effective, has_cap = false;
	int ret;

	effective = false;
	ret = get_file_caps(bprm, &effective, &has_cap);
	if (ret < 0)
		return ret;

	if (!issecure(SECURE_NOROOT)) {
		/*
		 * If the legacy file capability is set, then don't set privs
		 * for a setuid root binary run by a non-root user.  Do set it
		 * for a root user just to cause least surprise to an admin.
		 */
		if (has_cap && new->uid != 0 && new->euid == 0) {
			warn_setuid_and_fcaps_mixed(bprm->filename);
			goto skip;
		}
		/*
		 * To support inheritance of root-permissions and suid-root
		 * executables under compatibility mode, we override the
		 * capability sets for the file.
		 *
		 * If only the real uid is 0, we do not set the effective bit.
		 */
		if (new->euid == 0 || new->uid == 0) {
			/* pP' = (cap_bset & ~0) | (pI & ~0) */
			new->cap_permitted = cap_combine(old->cap_bset,
							 old->cap_inheritable);
		}
		if (new->euid == 0)
			effective = true;
 	}
 skip:
 
//fix_flaw_line_below:
//	/* if we have fs caps, clear dangerous personality flags */
//fix_flaw_line_below:
//	if (!cap_issubset(new->cap_permitted, old->cap_permitted))
//fix_flaw_line_below:
//		bprm->per_clear |= PER_CLEAR_ON_SETID;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//
 	/* Don't let someone trace a set[ug]id/setpcap binary with the revised
 	 * credentials unless they have the appropriate permit
 	 */
	if ((new->euid != old->uid ||
	     new->egid != old->gid ||
	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&
	    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {
		/* downgrade; they get no more than they had, and maybe less */
		if (!capable(CAP_SETUID)) {
			new->euid = new->uid;
			new->egid = new->gid;
		}
		new->cap_permitted = cap_intersect(new->cap_permitted,
						   old->cap_permitted);
	}

	new->suid = new->fsuid = new->euid;
	new->sgid = new->fsgid = new->egid;

	if (effective)
		new->cap_effective = new->cap_permitted;
	else
		cap_clear(new->cap_effective);
	bprm->cap_effective = effective;

	/*
	 * Audit candidate if current->cap_effective is set
	 *
	 * We do not bother to audit if 3 things are true:
	 *   1) cap_effective has all caps
	 *   2) we are root
	 *   3) root is supposed to have all caps (SECURE_NOROOT)
	 * Since this is just a normal root execing a process.
	 *
	 * Number 1 above might fail if you don't have a full bset, but I think
	 * that is interesting information to audit.
	 */
	if (!cap_isclear(new->cap_effective)) {
		if (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||
		    new->euid != 0 || new->uid != 0 ||
		    issecure(SECURE_NOROOT)) {
			ret = audit_log_bprm_fcaps(bprm, new, old);
			if (ret < 0)
				return ret;
		}
	}

	new->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);
	return 0;
}
",178788,"int cap_bprm_set_creds(struct linux_binprm *bprm)
{
	const struct cred *old = current_cred();
	struct cred *new = bprm->cred;
	bool effective, has_cap = false;
	int ret;

	effective = false;
	ret = get_file_caps(bprm, &effective, &has_cap);
	if (ret < 0)
		return ret;

	if (!issecure(SECURE_NOROOT)) {
		/*
		 * If the legacy file capability is set, then don't set privs
		 * for a setuid root binary run by a non-root user.  Do set it
		 * for a root user just to cause least surprise to an admin.
		 */
		if (has_cap && new->uid != 0 && new->euid == 0) {
			warn_setuid_and_fcaps_mixed(bprm->filename);
			goto skip;
		}
		/*
		 * To support inheritance of root-permissions and suid-root
		 * executables under compatibility mode, we override the
		 * capability sets for the file.
		 *
		 * If only the real uid is 0, we do not set the effective bit.
		 */
		if (new->euid == 0 || new->uid == 0) {
			/* pP' = (cap_bset & ~0) | (pI & ~0) */
			new->cap_permitted = cap_combine(old->cap_bset,
							 old->cap_inheritable);
		}
		if (new->euid == 0)
			effective = true;
 	}
 skip:
 
 	/* Don't let someone trace a set[ug]id/setpcap binary with the revised
 	 * credentials unless they have the appropriate permit
 	 */
	if ((new->euid != old->uid ||
	     new->egid != old->gid ||
	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&
	    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {
		/* downgrade; they get no more than they had, and maybe less */
		if (!capable(CAP_SETUID)) {
			new->euid = new->uid;
			new->egid = new->gid;
		}
		new->cap_permitted = cap_intersect(new->cap_permitted,
						   old->cap_permitted);
	}

	new->suid = new->fsuid = new->euid;
	new->sgid = new->fsgid = new->egid;

	if (effective)
		new->cap_effective = new->cap_permitted;
	else
		cap_clear(new->cap_effective);
	bprm->cap_effective = effective;

	/*
	 * Audit candidate if current->cap_effective is set
	 *
	 * We do not bother to audit if 3 things are true:
	 *   1) cap_effective has all caps
	 *   2) we are root
	 *   3) root is supposed to have all caps (SECURE_NOROOT)
	 * Since this is just a normal root execing a process.
	 *
	 * Number 1 above might fail if you don't have a full bset, but I think
	 * that is interesting information to audit.
	 */
	if (!cap_isclear(new->cap_effective)) {
		if (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||
		    new->euid != 0 || new->uid != 0 ||
		    issecure(SECURE_NOROOT)) {
			ret = audit_log_bprm_fcaps(bprm, new, old);
			if (ret < 0)
				return ret;
		}
	}

	new->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);
	return 0;
}
","int cap_bprm_set_creds(struct linux_binprm *bprm)
{
	const struct cred *old = current_cred();
	struct cred *new = bprm->cred;
	bool effective, has_cap = false;
	int ret;

	effective = false;
	ret = get_file_caps(bprm, &effective, &has_cap);
	if (ret < 0)
		return ret;

	if (!issecure(SECURE_NOROOT)) {
		/*
		 * If the legacy file capability is set, then don't set privs
		 * for a setuid root binary run by a non-root user.  Do set it
		 * for a root user just to cause least surprise to an admin.
		 */
		if (has_cap && new->uid != 0 && new->euid == 0) {
			warn_setuid_and_fcaps_mixed(bprm->filename);
			goto skip;
		}
		/*
		 * To support inheritance of root-permissions and suid-root
		 * executables under compatibility mode, we override the
		 * capability sets for the file.
		 *
		 * If only the real uid is 0, we do not set the effective bit.
		 */
		if (new->euid == 0 || new->uid == 0) {
			/* pP' = (cap_bset & ~0) | (pI & ~0) */
			new->cap_permitted = cap_combine(old->cap_bset,
							 old->cap_inheritable);
		}
		if (new->euid == 0)
			effective = true;
 	}
 skip:
 
	/* if we have fs caps, clear dangerous personality flags */
	if (!cap_issubset(new->cap_permitted, old->cap_permitted))
		bprm->per_clear |= PER_CLEAR_ON_SETID;


 	/* Don't let someone trace a set[ug]id/setpcap binary with the revised
 	 * credentials unless they have the appropriate permit
 	 */
	if ((new->euid != old->uid ||
	     new->egid != old->gid ||
	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&
	    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {
		/* downgrade; they get no more than they had, and maybe less */
		if (!capable(CAP_SETUID)) {
			new->euid = new->uid;
			new->egid = new->gid;
		}
		new->cap_permitted = cap_intersect(new->cap_permitted,
						   old->cap_permitted);
	}

	new->suid = new->fsuid = new->euid;
	new->sgid = new->fsgid = new->egid;

	if (effective)
		new->cap_effective = new->cap_permitted;
	else
		cap_clear(new->cap_effective);
	bprm->cap_effective = effective;

	/*
	 * Audit candidate if current->cap_effective is set
	 *
	 * We do not bother to audit if 3 things are true:
	 *   1) cap_effective has all caps
	 *   2) we are root
	 *   3) root is supposed to have all caps (SECURE_NOROOT)
	 * Since this is just a normal root execing a process.
	 *
	 * Number 1 above might fail if you don't have a full bset, but I think
	 * that is interesting information to audit.
	 */
	if (!cap_isclear(new->cap_effective)) {
		if (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||
		    new->euid != 0 || new->uid != 0 ||
		    issecure(SECURE_NOROOT)) {
			ret = audit_log_bprm_fcaps(bprm, new, old);
			if (ret < 0)
				return ret;
		}
	}

	new->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);
	return 0;
}
","The `cap_bprm_set_creds` function is responsible for setting the credentials and capabilities of a binary being executed in a Linux environment. It first retrieves the current process's credentials and checks the file capabilities associated with the binary. If the binary is a setuid root executable and the user is not root, it prevents privilege escalation by issuing a warning. The function then adjusts the effective and permitted capabilities based on the user's identity and the binary's attributes, ensuring that security policies are enforced. Finally, it logs any relevant auditing information if the effective capabilities are not fully granted, while also managing secure bits.","The code manages the setting of user credentials and capabilities for executing binaries in a secure manner. It first checks the current user's permissions and the capabilities associated with the binary. If the binary is designed to run with elevated privileges and the user is not an administrator, it prevents unauthorized privilege escalation. The function adjusts the effective and permitted capabilities based on the user's identity and the binary's characteristics, ensuring compliance with security policies. Additionally, it logs relevant information for auditing purposes if the effective capabilities do not grant full permissions, while also managing security settings.","The vulnerability in the original code arises from the failure to clear dangerous personality flags when a process gains elevated permissions through file capabilities, potentially allowing attackers to exploit these flags for malicious purposes. Specifically, the code did not ensure that if a process was granted privileges via capabilities, it would also clear the same personality flags that are cleared for setuid applications, which could compromise security features like address space randomization. The fix introduced a check to clear these flags by setting `bprm->per_clear` when the permitted capabilities do not match the old capabilities, thereby enhancing the security of processes using file capabilities.","The vulnerability in the original code stemmed from the lack of a mechanism to clear dangerous personality flags when a process gained elevated permissions through file capabilities. This oversight could allow malicious actors to exploit these flags, potentially disabling security features like address space randomization, which are crucial for protecting against attacks. The fix addressed this issue by ensuring that when permissions are increased via capabilities, the same dangerous personality flags that are cleared for setuid applications are also cleared, thereby maintaining the integrity of security measures and preventing potential exploitation.","The vulnerability was fixed by introducing a check to clear dangerous personality flags when file capabilities are used to increase permissions. Specifically, the code now sets `bprm->per_clear` to include `PER_CLEAR_ON_SETID` if the new permitted capabilities do not match the old permitted capabilities. This ensures that all dangerous personality flags, which are typically cleared for setuid applications, are also cleared for processes gaining privileges through file capabilities. By implementing this change, the code enhances security by maintaining address space randomization and preventing potential exploitation from processes with elevated permissions.","The vulnerability was addressed by implementing a mechanism to clear dangerous personality flags whenever a process gains elevated permissions through file capabilities. The fix ensures that the same flags that are cleared for setuid applications are also cleared for processes using capabilities, thereby maintaining essential security features. This change prevents the potential exploitation of security weaknesses, such as disabling address space randomization, which could make the system more susceptible to attacks. By enforcing this consistency in flag management, the code enhances the overall security posture of processes with increased privileges.","CWE-269, CWE-264, CWE-266, CWE-284, CWE-732, CWE-250, CWE-272, CWE-273, CWE-653, CWE-693",N,-1
14,14,178817,178817,,Local,Not required,Complete,CVE-2012-1090,https://www.cvedetails.com/cve/CVE-2012-1090/,CWE-264,Low,,,,2012-05-17,4.9,"The cifs_lookup function in fs/cifs/dir.c in the Linux kernel before 3.2.10 allows local users to cause a denial of service (OOPS) via attempted access to a special file, as demonstrated by a FIFO.",2018-01-17,DoS ,18,https://github.com/torvalds/linux/commit/88d7d4e4a439f32acc56a6d860e415ee71d3df08,88d7d4e4a439f32acc56a6d860e415ee71d3df08,"cifs: fix dentry refcount leak when opening a FIFO on lookup

commit 5bccda0ebc7c0331b81ac47d39e4b920b198b2cd upstream.

The cifs code will attempt to open files on lookup under certain
circumstances. What happens though if we find that the file we opened
was actually a FIFO or other special file?

Currently, the open filehandle just ends up being leaked leading to
a dentry refcount mismatch and oops on umount. Fix this by having the
code close the filehandle on the server if it turns out not to be a
regular file. While we're at it, change this spaghetti if statement
into a switch too.

Reported-by: CAI Qian <caiqian@redhat.com>
Tested-by: CAI Qian <caiqian@redhat.com>
Reviewed-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Signed-off-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Steve French <smfrench@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",2,fs/cifs/dir.c,"{""sha"": ""bf68b4fc9512f0ad226f9503dffbc50d8818138c"", ""filename"": ""fs/cifs/dir.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 2, ""changes"": 20, ""blob_url"": ""https://github.com/torvalds/linux/blob/88d7d4e4a439f32acc56a6d860e415ee71d3df08/fs/cifs/dir.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/88d7d4e4a439f32acc56a6d860e415ee71d3df08/fs/cifs/dir.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/cifs/dir.c?ref=88d7d4e4a439f32acc56a6d860e415ee71d3df08"", ""patch"": ""@@ -584,10 +584,26 @@ cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n \t\t\t * If either that or op not supported returned, follow\n \t\t\t * the normal lookup.\n \t\t\t */\n-\t\t\tif ((rc == 0) || (rc == -ENOENT))\n+\t\t\tswitch (rc) {\n+\t\t\tcase 0:\n+\t\t\t\t/*\n+\t\t\t\t * The server may allow us to open things like\n+\t\t\t\t * FIFOs, but the client isn't set up to deal\n+\t\t\t\t * with that. If it's not a regular file, just\n+\t\t\t\t * close it and proceed as if it were a normal\n+\t\t\t\t * lookup.\n+\t\t\t\t */\n+\t\t\t\tif (newInode && !S_ISREG(newInode->i_mode)) {\n+\t\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\tcase -ENOENT:\n \t\t\t\tposix_open = true;\n-\t\t\telse if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))\n+\t\t\tcase -EOPNOTSUPP:\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n \t\t\t\tpTcon->broken_posix_open = true;\n+\t\t\t}\n \t\t}\n \t\tif (!posix_open)\n \t\t\trc = cifs_get_inode_info_unix(&newInode, full_path,""}","cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
	    struct nameidata *nd)
{
	int xid;
	int rc = 0; /* to get around spurious gcc warning, set to zero here */
	__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;
	__u16 fileHandle = 0;
	bool posix_open = false;
	struct cifs_sb_info *cifs_sb;
	struct tcon_link *tlink;
	struct cifs_tcon *pTcon;
	struct cifsFileInfo *cfile;
	struct inode *newInode = NULL;
	char *full_path = NULL;
	struct file *filp;

	xid = GetXid();

	cFYI(1, ""parent inode = 0x%p name is: %s and dentry = 0x%p"",
	      parent_dir_inode, direntry->d_name.name, direntry);

	/* check whether path exists */

	cifs_sb = CIFS_SB(parent_dir_inode->i_sb);
	tlink = cifs_sb_tlink(cifs_sb);
	if (IS_ERR(tlink)) {
		FreeXid(xid);
		return (struct dentry *)tlink;
	}
	pTcon = tlink_tcon(tlink);

	/*
	 * Don't allow the separator character in a path component.
	 * The VFS will not allow ""/"", but ""\"" is allowed by posix.
	 */
	if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {
		int i;
		for (i = 0; i < direntry->d_name.len; i++)
			if (direntry->d_name.name[i] == '\\') {
				cFYI(1, ""Invalid file name"");
				rc = -EINVAL;
				goto lookup_out;
			}
	}

	/*
	 * O_EXCL: optimize away the lookup, but don't hash the dentry. Let
	 * the VFS handle the create.
	 */
	if (nd && (nd->flags & LOOKUP_EXCL)) {
		d_instantiate(direntry, NULL);
		rc = 0;
		goto lookup_out;
	}

	/* can not grab the rename sem here since it would
	deadlock in the cases (beginning of sys_rename itself)
	in which we already have the sb rename sem */
	full_path = build_path_from_dentry(direntry);
	if (full_path == NULL) {
		rc = -ENOMEM;
		goto lookup_out;
	}

	if (direntry->d_inode != NULL) {
		cFYI(1, ""non-NULL inode in lookup"");
	} else {
		cFYI(1, ""NULL inode in lookup"");
	}
	cFYI(1, ""Full path: %s inode = 0x%p"", full_path, direntry->d_inode);

	/* Posix open is only called (at lookup time) for file create now.
	 * For opens (rather than creates), because we do not know if it
	 * is a file or directory yet, and current Samba no longer allows
	 * us to do posix open on dirs, we could end up wasting an open call
	 * on what turns out to be a dir. For file opens, we wait to call posix
	 * open till cifs_open.  It could be added here (lookup) in the future
	 * but the performance tradeoff of the extra network request when EISDIR
	 * or EACCES is returned would have to be weighed against the 50%
	 * reduction in network traffic in the other paths.
	 */
	if (pTcon->unix_ext) {
		if (nd && !(nd->flags & LOOKUP_DIRECTORY) &&
		     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&
		     (nd->intent.open.file->f_flags & O_CREAT)) {
			rc = cifs_posix_open(full_path, &newInode,
					parent_dir_inode->i_sb,
					nd->intent.open.create_mode,
					nd->intent.open.file->f_flags, &oplock,
					&fileHandle, xid);
			/*
			 * The check below works around a bug in POSIX
			 * open in samba versions 3.3.1 and earlier where
			 * open could incorrectly fail with invalid parameter.
 			 * If either that or op not supported returned, follow
 			 * the normal lookup.
 			 */
			switch (rc) {
			case 0:
				/*
				 * The server may allow us to open things like
				 * FIFOs, but the client isn't set up to deal
				 * with that. If it's not a regular file, just
				 * close it and proceed as if it were a normal
				 * lookup.
				 */
				if (newInode && !S_ISREG(newInode->i_mode)) {
					CIFSSMBClose(xid, pTcon, fileHandle);
					break;
				}
			case -ENOENT:
 				posix_open = true;
			case -EOPNOTSUPP:
				break;
			default:
 				pTcon->broken_posix_open = true;
			}
 		}
 		if (!posix_open)
 			rc = cifs_get_inode_info_unix(&newInode, full_path,
						parent_dir_inode->i_sb, xid);
	} else
		rc = cifs_get_inode_info(&newInode, full_path, NULL,
				parent_dir_inode->i_sb, xid, NULL);

	if ((rc == 0) && (newInode != NULL)) {
		d_add(direntry, newInode);
		if (posix_open) {
			filp = lookup_instantiate_filp(nd, direntry,
						       generic_file_open);
			if (IS_ERR(filp)) {
				rc = PTR_ERR(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				goto lookup_out;
			}

			cfile = cifs_new_fileinfo(fileHandle, filp, tlink,
						  oplock);
			if (cfile == NULL) {
				fput(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				rc = -ENOMEM;
				goto lookup_out;
			}
		}
		/* since paths are not looked up by component - the parent
		   directories are presumed to be good here */
		renew_parental_timestamps(direntry);

	} else if (rc == -ENOENT) {
		rc = 0;
		direntry->d_time = jiffies;
		d_add(direntry, NULL);
	/*	if it was once a directory (but how can we tell?) we could do
		shrink_dcache_parent(direntry); */
	} else if (rc != -EACCES) {
		cERROR(1, ""Unexpected lookup error %d"", rc);
		/* We special case check for Access Denied - since that
		is a common return code */
	}

lookup_out:
	kfree(full_path);
	cifs_put_tlink(tlink);
	FreeXid(xid);
	return ERR_PTR(rc);
}
","cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
	    struct nameidata *nd)
{
	int xid;
	int rc = 0; /* to get around spurious gcc warning, set to zero here */
	__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;
	__u16 fileHandle = 0;
	bool posix_open = false;
	struct cifs_sb_info *cifs_sb;
	struct tcon_link *tlink;
	struct cifs_tcon *pTcon;
	struct cifsFileInfo *cfile;
	struct inode *newInode = NULL;
	char *full_path = NULL;
	struct file *filp;

	xid = GetXid();

	cFYI(1, ""parent inode = 0x%p name is: %s and dentry = 0x%p"",
	      parent_dir_inode, direntry->d_name.name, direntry);

	/* check whether path exists */

	cifs_sb = CIFS_SB(parent_dir_inode->i_sb);
	tlink = cifs_sb_tlink(cifs_sb);
	if (IS_ERR(tlink)) {
		FreeXid(xid);
		return (struct dentry *)tlink;
	}
	pTcon = tlink_tcon(tlink);

	/*
	 * Don't allow the separator character in a path component.
	 * The VFS will not allow ""/"", but ""\"" is allowed by posix.
	 */
	if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {
		int i;
		for (i = 0; i < direntry->d_name.len; i++)
			if (direntry->d_name.name[i] == '\\') {
				cFYI(1, ""Invalid file name"");
				rc = -EINVAL;
				goto lookup_out;
			}
	}

	/*
	 * O_EXCL: optimize away the lookup, but don't hash the dentry. Let
	 * the VFS handle the create.
	 */
	if (nd && (nd->flags & LOOKUP_EXCL)) {
		d_instantiate(direntry, NULL);
		rc = 0;
		goto lookup_out;
	}

	/* can not grab the rename sem here since it would
	deadlock in the cases (beginning of sys_rename itself)
	in which we already have the sb rename sem */
	full_path = build_path_from_dentry(direntry);
	if (full_path == NULL) {
		rc = -ENOMEM;
		goto lookup_out;
	}

	if (direntry->d_inode != NULL) {
		cFYI(1, ""non-NULL inode in lookup"");
	} else {
		cFYI(1, ""NULL inode in lookup"");
	}
	cFYI(1, ""Full path: %s inode = 0x%p"", full_path, direntry->d_inode);

	/* Posix open is only called (at lookup time) for file create now.
	 * For opens (rather than creates), because we do not know if it
	 * is a file or directory yet, and current Samba no longer allows
	 * us to do posix open on dirs, we could end up wasting an open call
	 * on what turns out to be a dir. For file opens, we wait to call posix
	 * open till cifs_open.  It could be added here (lookup) in the future
	 * but the performance tradeoff of the extra network request when EISDIR
	 * or EACCES is returned would have to be weighed against the 50%
	 * reduction in network traffic in the other paths.
	 */
	if (pTcon->unix_ext) {
		if (nd && !(nd->flags & LOOKUP_DIRECTORY) &&
		     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&
		     (nd->intent.open.file->f_flags & O_CREAT)) {
			rc = cifs_posix_open(full_path, &newInode,
					parent_dir_inode->i_sb,
					nd->intent.open.create_mode,
					nd->intent.open.file->f_flags, &oplock,
					&fileHandle, xid);
			/*
			 * The check below works around a bug in POSIX
			 * open in samba versions 3.3.1 and earlier where
			 * open could incorrectly fail with invalid parameter.
 			 * If either that or op not supported returned, follow
 			 * the normal lookup.
 			 */
			if ((rc == 0) || (rc == -ENOENT))
 				posix_open = true;
			else if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))
 				pTcon->broken_posix_open = true;
 		}
 		if (!posix_open)
 			rc = cifs_get_inode_info_unix(&newInode, full_path,
						parent_dir_inode->i_sb, xid);
	} else
		rc = cifs_get_inode_info(&newInode, full_path, NULL,
				parent_dir_inode->i_sb, xid, NULL);

	if ((rc == 0) && (newInode != NULL)) {
		d_add(direntry, newInode);
		if (posix_open) {
			filp = lookup_instantiate_filp(nd, direntry,
						       generic_file_open);
			if (IS_ERR(filp)) {
				rc = PTR_ERR(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				goto lookup_out;
			}

			cfile = cifs_new_fileinfo(fileHandle, filp, tlink,
						  oplock);
			if (cfile == NULL) {
				fput(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				rc = -ENOMEM;
				goto lookup_out;
			}
		}
		/* since paths are not looked up by component - the parent
		   directories are presumed to be good here */
		renew_parental_timestamps(direntry);

	} else if (rc == -ENOENT) {
		rc = 0;
		direntry->d_time = jiffies;
		d_add(direntry, NULL);
	/*	if it was once a directory (but how can we tell?) we could do
		shrink_dcache_parent(direntry); */
	} else if (rc != -EACCES) {
		cERROR(1, ""Unexpected lookup error %d"", rc);
		/* We special case check for Access Denied - since that
		is a common return code */
	}

lookup_out:
	kfree(full_path);
	cifs_put_tlink(tlink);
	FreeXid(xid);
	return ERR_PTR(rc);
}
",C,"			switch (rc) {
			case 0:
				/*
				 * The server may allow us to open things like
				 * FIFOs, but the client isn't set up to deal
				 * with that. If it's not a regular file, just
				 * close it and proceed as if it were a normal
				 * lookup.
				 */
				if (newInode && !S_ISREG(newInode->i_mode)) {
					CIFSSMBClose(xid, pTcon, fileHandle);
					break;
				}
			case -ENOENT:
			case -EOPNOTSUPP:
				break;
			default:
			}
","			if ((rc == 0) || (rc == -ENOENT))
			else if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))
",,"@@ -584,10 +584,26 @@ cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
 			 * If either that or op not supported returned, follow
 			 * the normal lookup.
 			 */
-			if ((rc == 0) || (rc == -ENOENT))
+			switch (rc) {
+			case 0:
+				/*
+				 * The server may allow us to open things like
+				 * FIFOs, but the client isn't set up to deal
+				 * with that. If it's not a regular file, just
+				 * close it and proceed as if it were a normal
+				 * lookup.
+				 */
+				if (newInode && !S_ISREG(newInode->i_mode)) {
+					CIFSSMBClose(xid, pTcon, fileHandle);
+					break;
+				}
+			case -ENOENT:
 				posix_open = true;
-			else if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))
+			case -EOPNOTSUPP:
+				break;
+			default:
 				pTcon->broken_posix_open = true;
+			}
 		}
 		if (!posix_open)
 			rc = cifs_get_inode_info_unix(&newInode, full_path,",linux,88d7d4e4a439f32acc56a6d860e415ee71d3df08,ce6e3def616ad1e22443df7fc8bdaa3384cf0575,1,"cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
	    struct nameidata *nd)
{
	int xid;
	int rc = 0; /* to get around spurious gcc warning, set to zero here */
	__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;
	__u16 fileHandle = 0;
	bool posix_open = false;
	struct cifs_sb_info *cifs_sb;
	struct tcon_link *tlink;
	struct cifs_tcon *pTcon;
	struct cifsFileInfo *cfile;
	struct inode *newInode = NULL;
	char *full_path = NULL;
	struct file *filp;

	xid = GetXid();

	cFYI(1, ""parent inode = 0x%p name is: %s and dentry = 0x%p"",
	      parent_dir_inode, direntry->d_name.name, direntry);

	/* check whether path exists */

	cifs_sb = CIFS_SB(parent_dir_inode->i_sb);
	tlink = cifs_sb_tlink(cifs_sb);
	if (IS_ERR(tlink)) {
		FreeXid(xid);
		return (struct dentry *)tlink;
	}
	pTcon = tlink_tcon(tlink);

	/*
	 * Don't allow the separator character in a path component.
	 * The VFS will not allow ""/"", but ""\"" is allowed by posix.
	 */
	if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {
		int i;
		for (i = 0; i < direntry->d_name.len; i++)
			if (direntry->d_name.name[i] == '\\') {
				cFYI(1, ""Invalid file name"");
				rc = -EINVAL;
				goto lookup_out;
			}
	}

	/*
	 * O_EXCL: optimize away the lookup, but don't hash the dentry. Let
	 * the VFS handle the create.
	 */
	if (nd && (nd->flags & LOOKUP_EXCL)) {
		d_instantiate(direntry, NULL);
		rc = 0;
		goto lookup_out;
	}

	/* can not grab the rename sem here since it would
	deadlock in the cases (beginning of sys_rename itself)
	in which we already have the sb rename sem */
	full_path = build_path_from_dentry(direntry);
	if (full_path == NULL) {
		rc = -ENOMEM;
		goto lookup_out;
	}

	if (direntry->d_inode != NULL) {
		cFYI(1, ""non-NULL inode in lookup"");
	} else {
		cFYI(1, ""NULL inode in lookup"");
	}
	cFYI(1, ""Full path: %s inode = 0x%p"", full_path, direntry->d_inode);

	/* Posix open is only called (at lookup time) for file create now.
	 * For opens (rather than creates), because we do not know if it
	 * is a file or directory yet, and current Samba no longer allows
	 * us to do posix open on dirs, we could end up wasting an open call
	 * on what turns out to be a dir. For file opens, we wait to call posix
	 * open till cifs_open.  It could be added here (lookup) in the future
	 * but the performance tradeoff of the extra network request when EISDIR
	 * or EACCES is returned would have to be weighed against the 50%
	 * reduction in network traffic in the other paths.
	 */
	if (pTcon->unix_ext) {
		if (nd && !(nd->flags & LOOKUP_DIRECTORY) &&
		     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&
		     (nd->intent.open.file->f_flags & O_CREAT)) {
			rc = cifs_posix_open(full_path, &newInode,
					parent_dir_inode->i_sb,
					nd->intent.open.create_mode,
					nd->intent.open.file->f_flags, &oplock,
					&fileHandle, xid);
			/*
			 * The check below works around a bug in POSIX
			 * open in samba versions 3.3.1 and earlier where
			 * open could incorrectly fail with invalid parameter.
 			 * If either that or op not supported returned, follow
 			 * the normal lookup.
 			 */
//flaw_line_below:
			if ((rc == 0) || (rc == -ENOENT))
//fix_flaw_line_below:
//			switch (rc) {
//fix_flaw_line_below:
//			case 0:
//fix_flaw_line_below:
//				/*
//fix_flaw_line_below:
//				 * The server may allow us to open things like
//fix_flaw_line_below:
//				 * FIFOs, but the client isn't set up to deal
//fix_flaw_line_below:
//				 * with that. If it's not a regular file, just
//fix_flaw_line_below:
//				 * close it and proceed as if it were a normal
//fix_flaw_line_below:
//				 * lookup.
//fix_flaw_line_below:
//				 */
//fix_flaw_line_below:
//				if (newInode && !S_ISREG(newInode->i_mode)) {
//fix_flaw_line_below:
//					CIFSSMBClose(xid, pTcon, fileHandle);
//fix_flaw_line_below:
//					break;
//fix_flaw_line_below:
//				}
//fix_flaw_line_below:
//			case -ENOENT:
 				posix_open = true;
//flaw_line_below:
			else if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))
//fix_flaw_line_below:
//			case -EOPNOTSUPP:
//fix_flaw_line_below:
//				break;
//fix_flaw_line_below:
//			default:
 				pTcon->broken_posix_open = true;
//fix_flaw_line_below:
//			}
 		}
 		if (!posix_open)
 			rc = cifs_get_inode_info_unix(&newInode, full_path,
						parent_dir_inode->i_sb, xid);
	} else
		rc = cifs_get_inode_info(&newInode, full_path, NULL,
				parent_dir_inode->i_sb, xid, NULL);

	if ((rc == 0) && (newInode != NULL)) {
		d_add(direntry, newInode);
		if (posix_open) {
			filp = lookup_instantiate_filp(nd, direntry,
						       generic_file_open);
			if (IS_ERR(filp)) {
				rc = PTR_ERR(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				goto lookup_out;
			}

			cfile = cifs_new_fileinfo(fileHandle, filp, tlink,
						  oplock);
			if (cfile == NULL) {
				fput(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				rc = -ENOMEM;
				goto lookup_out;
			}
		}
		/* since paths are not looked up by component - the parent
		   directories are presumed to be good here */
		renew_parental_timestamps(direntry);

	} else if (rc == -ENOENT) {
		rc = 0;
		direntry->d_time = jiffies;
		d_add(direntry, NULL);
	/*	if it was once a directory (but how can we tell?) we could do
		shrink_dcache_parent(direntry); */
	} else if (rc != -EACCES) {
		cERROR(1, ""Unexpected lookup error %d"", rc);
		/* We special case check for Access Denied - since that
		is a common return code */
	}

lookup_out:
	kfree(full_path);
	cifs_put_tlink(tlink);
	FreeXid(xid);
	return ERR_PTR(rc);
}
",178817,"cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
	    struct nameidata *nd)
{
	int xid;
	int rc = 0; /* to get around spurious gcc warning, set to zero here */
	__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;
	__u16 fileHandle = 0;
	bool posix_open = false;
	struct cifs_sb_info *cifs_sb;
	struct tcon_link *tlink;
	struct cifs_tcon *pTcon;
	struct cifsFileInfo *cfile;
	struct inode *newInode = NULL;
	char *full_path = NULL;
	struct file *filp;

	xid = GetXid();

	cFYI(1, ""parent inode = 0x%p name is: %s and dentry = 0x%p"",
	      parent_dir_inode, direntry->d_name.name, direntry);

	/* check whether path exists */

	cifs_sb = CIFS_SB(parent_dir_inode->i_sb);
	tlink = cifs_sb_tlink(cifs_sb);
	if (IS_ERR(tlink)) {
		FreeXid(xid);
		return (struct dentry *)tlink;
	}
	pTcon = tlink_tcon(tlink);

	/*
	 * Don't allow the separator character in a path component.
	 * The VFS will not allow ""/"", but ""\"" is allowed by posix.
	 */
	if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {
		int i;
		for (i = 0; i < direntry->d_name.len; i++)
			if (direntry->d_name.name[i] == '\\') {
				cFYI(1, ""Invalid file name"");
				rc = -EINVAL;
				goto lookup_out;
			}
	}

	/*
	 * O_EXCL: optimize away the lookup, but don't hash the dentry. Let
	 * the VFS handle the create.
	 */
	if (nd && (nd->flags & LOOKUP_EXCL)) {
		d_instantiate(direntry, NULL);
		rc = 0;
		goto lookup_out;
	}

	/* can not grab the rename sem here since it would
	deadlock in the cases (beginning of sys_rename itself)
	in which we already have the sb rename sem */
	full_path = build_path_from_dentry(direntry);
	if (full_path == NULL) {
		rc = -ENOMEM;
		goto lookup_out;
	}

	if (direntry->d_inode != NULL) {
		cFYI(1, ""non-NULL inode in lookup"");
	} else {
		cFYI(1, ""NULL inode in lookup"");
	}
	cFYI(1, ""Full path: %s inode = 0x%p"", full_path, direntry->d_inode);

	/* Posix open is only called (at lookup time) for file create now.
	 * For opens (rather than creates), because we do not know if it
	 * is a file or directory yet, and current Samba no longer allows
	 * us to do posix open on dirs, we could end up wasting an open call
	 * on what turns out to be a dir. For file opens, we wait to call posix
	 * open till cifs_open.  It could be added here (lookup) in the future
	 * but the performance tradeoff of the extra network request when EISDIR
	 * or EACCES is returned would have to be weighed against the 50%
	 * reduction in network traffic in the other paths.
	 */
	if (pTcon->unix_ext) {
		if (nd && !(nd->flags & LOOKUP_DIRECTORY) &&
		     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&
		     (nd->intent.open.file->f_flags & O_CREAT)) {
			rc = cifs_posix_open(full_path, &newInode,
					parent_dir_inode->i_sb,
					nd->intent.open.create_mode,
					nd->intent.open.file->f_flags, &oplock,
					&fileHandle, xid);
			/*
			 * The check below works around a bug in POSIX
			 * open in samba versions 3.3.1 and earlier where
			 * open could incorrectly fail with invalid parameter.
 			 * If either that or op not supported returned, follow
 			 * the normal lookup.
 			 */
			if ((rc == 0) || (rc == -ENOENT))
 				posix_open = true;
			else if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))
 				pTcon->broken_posix_open = true;
 		}
 		if (!posix_open)
 			rc = cifs_get_inode_info_unix(&newInode, full_path,
						parent_dir_inode->i_sb, xid);
	} else
		rc = cifs_get_inode_info(&newInode, full_path, NULL,
				parent_dir_inode->i_sb, xid, NULL);

	if ((rc == 0) && (newInode != NULL)) {
		d_add(direntry, newInode);
		if (posix_open) {
			filp = lookup_instantiate_filp(nd, direntry,
						       generic_file_open);
			if (IS_ERR(filp)) {
				rc = PTR_ERR(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				goto lookup_out;
			}

			cfile = cifs_new_fileinfo(fileHandle, filp, tlink,
						  oplock);
			if (cfile == NULL) {
				fput(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				rc = -ENOMEM;
				goto lookup_out;
			}
		}
		/* since paths are not looked up by component - the parent
		   directories are presumed to be good here */
		renew_parental_timestamps(direntry);

	} else if (rc == -ENOENT) {
		rc = 0;
		direntry->d_time = jiffies;
		d_add(direntry, NULL);
	/*	if it was once a directory (but how can we tell?) we could do
		shrink_dcache_parent(direntry); */
	} else if (rc != -EACCES) {
		cERROR(1, ""Unexpected lookup error %d"", rc);
		/* We special case check for Access Denied - since that
		is a common return code */
	}

lookup_out:
	kfree(full_path);
	cifs_put_tlink(tlink);
	FreeXid(xid);
	return ERR_PTR(rc);
}
","cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
	    struct nameidata *nd)
{
	int xid;
	int rc = 0; /* to get around spurious gcc warning, set to zero here */
	__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;
	__u16 fileHandle = 0;
	bool posix_open = false;
	struct cifs_sb_info *cifs_sb;
	struct tcon_link *tlink;
	struct cifs_tcon *pTcon;
	struct cifsFileInfo *cfile;
	struct inode *newInode = NULL;
	char *full_path = NULL;
	struct file *filp;

	xid = GetXid();

	cFYI(1, ""parent inode = 0x%p name is: %s and dentry = 0x%p"",
	      parent_dir_inode, direntry->d_name.name, direntry);

	/* check whether path exists */

	cifs_sb = CIFS_SB(parent_dir_inode->i_sb);
	tlink = cifs_sb_tlink(cifs_sb);
	if (IS_ERR(tlink)) {
		FreeXid(xid);
		return (struct dentry *)tlink;
	}
	pTcon = tlink_tcon(tlink);

	/*
	 * Don't allow the separator character in a path component.
	 * The VFS will not allow ""/"", but ""\"" is allowed by posix.
	 */
	if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {
		int i;
		for (i = 0; i < direntry->d_name.len; i++)
			if (direntry->d_name.name[i] == '\\') {
				cFYI(1, ""Invalid file name"");
				rc = -EINVAL;
				goto lookup_out;
			}
	}

	/*
	 * O_EXCL: optimize away the lookup, but don't hash the dentry. Let
	 * the VFS handle the create.
	 */
	if (nd && (nd->flags & LOOKUP_EXCL)) {
		d_instantiate(direntry, NULL);
		rc = 0;
		goto lookup_out;
	}

	/* can not grab the rename sem here since it would
	deadlock in the cases (beginning of sys_rename itself)
	in which we already have the sb rename sem */
	full_path = build_path_from_dentry(direntry);
	if (full_path == NULL) {
		rc = -ENOMEM;
		goto lookup_out;
	}

	if (direntry->d_inode != NULL) {
		cFYI(1, ""non-NULL inode in lookup"");
	} else {
		cFYI(1, ""NULL inode in lookup"");
	}
	cFYI(1, ""Full path: %s inode = 0x%p"", full_path, direntry->d_inode);

	/* Posix open is only called (at lookup time) for file create now.
	 * For opens (rather than creates), because we do not know if it
	 * is a file or directory yet, and current Samba no longer allows
	 * us to do posix open on dirs, we could end up wasting an open call
	 * on what turns out to be a dir. For file opens, we wait to call posix
	 * open till cifs_open.  It could be added here (lookup) in the future
	 * but the performance tradeoff of the extra network request when EISDIR
	 * or EACCES is returned would have to be weighed against the 50%
	 * reduction in network traffic in the other paths.
	 */
	if (pTcon->unix_ext) {
		if (nd && !(nd->flags & LOOKUP_DIRECTORY) &&
		     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&
		     (nd->intent.open.file->f_flags & O_CREAT)) {
			rc = cifs_posix_open(full_path, &newInode,
					parent_dir_inode->i_sb,
					nd->intent.open.create_mode,
					nd->intent.open.file->f_flags, &oplock,
					&fileHandle, xid);
			/*
			 * The check below works around a bug in POSIX
			 * open in samba versions 3.3.1 and earlier where
			 * open could incorrectly fail with invalid parameter.
 			 * If either that or op not supported returned, follow
 			 * the normal lookup.
 			 */
			switch (rc) {
			case 0:
				/*
				 * The server may allow us to open things like
				 * FIFOs, but the client isn't set up to deal
				 * with that. If it's not a regular file, just
				 * close it and proceed as if it were a normal
				 * lookup.
				 */
				if (newInode && !S_ISREG(newInode->i_mode)) {
					CIFSSMBClose(xid, pTcon, fileHandle);
					break;
				}
			case -ENOENT:
 				posix_open = true;
			case -EOPNOTSUPP:
				break;
			default:
 				pTcon->broken_posix_open = true;
			}
 		}
 		if (!posix_open)
 			rc = cifs_get_inode_info_unix(&newInode, full_path,
						parent_dir_inode->i_sb, xid);
	} else
		rc = cifs_get_inode_info(&newInode, full_path, NULL,
				parent_dir_inode->i_sb, xid, NULL);

	if ((rc == 0) && (newInode != NULL)) {
		d_add(direntry, newInode);
		if (posix_open) {
			filp = lookup_instantiate_filp(nd, direntry,
						       generic_file_open);
			if (IS_ERR(filp)) {
				rc = PTR_ERR(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				goto lookup_out;
			}

			cfile = cifs_new_fileinfo(fileHandle, filp, tlink,
						  oplock);
			if (cfile == NULL) {
				fput(filp);
				CIFSSMBClose(xid, pTcon, fileHandle);
				rc = -ENOMEM;
				goto lookup_out;
			}
		}
		/* since paths are not looked up by component - the parent
		   directories are presumed to be good here */
		renew_parental_timestamps(direntry);

	} else if (rc == -ENOENT) {
		rc = 0;
		direntry->d_time = jiffies;
		d_add(direntry, NULL);
	/*	if it was once a directory (but how can we tell?) we could do
		shrink_dcache_parent(direntry); */
	} else if (rc != -EACCES) {
		cERROR(1, ""Unexpected lookup error %d"", rc);
		/* We special case check for Access Denied - since that
		is a common return code */
	}

lookup_out:
	kfree(full_path);
	cifs_put_tlink(tlink);
	FreeXid(xid);
	return ERR_PTR(rc);
}
","The `cifs_lookup` function is responsible for locating a file or directory within a CIFS (Common Internet File System) share, given a parent directory inode and a directory entry. It begins by acquiring a transaction ID and checking the validity of the provided directory entry. The function handles path validation, particularly ensuring that invalid characters are not present. It supports POSIX-style opening for file creation and retrieves inode information based on the connection type. If successful, it adds the found inode to the directory entry; otherwise, it manages errors and memory cleanup, returning an appropriate error pointer or the found inode.","The provided code implements a function that searches for a file or directory within a network file system. It begins by validating the input directory and checking for invalid characters in the path. The function supports specific opening modes for file creation and retrieves metadata about the target file or directory. If the search is successful, it associates the found item with the directory entry; if not, it handles various error conditions, including memory management and cleanup. Ultimately, the function returns either the found item or an error indication, ensuring proper resource handling throughout the process.","The vulnerability in the original code stemmed from a failure to properly manage file handles when a special file, such as a FIFO, was opened during the lookup process. If the opened file was not a regular file, the code did not close the associated file handle, leading to a resource leak and potential reference count mismatches, which could cause system crashes during unmount operations. The fix involved adding a check to close the file handle if the opened file was not a regular file, thus ensuring proper resource management and preventing leaks while also restructuring the conditional logic into a switch statement for clarity.","The vulnerability in the original code arose from the failure to properly handle file handles when a special file, such as a FIFO, was opened during a lookup operation. If the opened file was not a regular file, the code did not close the file handle, resulting in a resource leak and a mismatch in reference counts, which could lead to system crashes during unmounting. The fix addressed this issue by ensuring that the file handle is closed on the server if the opened file is not a regular file, thereby preventing leaks and maintaining proper resource management while also improving code clarity.","The vulnerability was fixed by adding a check within the code that determines if the opened file is a regular file. Specifically, after attempting to open the file, the code now verifies the file type using a condition that checks the inode mode. If the file is not a regular file, the code calls a function to close the file handle on the server, preventing a resource leak. Additionally, the original complex conditional logic was refactored into a switch statement, enhancing readability and maintainability while ensuring that all possible outcomes are handled appropriately.","The vulnerability was addressed by implementing a check to determine if the opened file was a regular file. If the file was identified as a special type, the code now ensures that the associated file handle is closed on the server, effectively preventing resource leaks. This change not only mitigates the risk of reference count mismatches that could lead to system crashes during unmounting but also improves the overall clarity of the logic by restructuring it into a more organized format. This enhances both the maintainability and reliability of the code.","CWE-771, CWE-404, CWE-775, CWE-773, CWE-401, CWE-772, CWE-774, CWE-459, CWE-672, CWE-911",N,-1
15,15,179032,179032,,Local,Not required,,CVE-2011-2495,https://www.cvedetails.com/cve/CVE-2011-2495/,CWE-264,Low,Partial,,,2012-06-13,2.1,"fs/proc/base.c in the Linux kernel before 2.6.39.4 does not properly restrict access to /proc/#####/io files, which allows local users to obtain sensitive I/O statistics by polling a file, as demonstrated by discovering the length of another user's password.",2013-12-30,,3,https://github.com/torvalds/linux/commit/1d1221f375c94ef961ba8574ac4f85c8870ddd51,1d1221f375c94ef961ba8574ac4f85c8870ddd51,"proc: restrict access to /proc/PID/io

/proc/PID/io may be used for gathering private information.  E.g.  for
openssh and vsftpd daemons wchars/rchars may be used to learn the
precise password length.  Restrict it to processes being able to ptrace
the target process.

ptrace_may_access() is needed to prevent keeping open file descriptor of
""io"" file, executing setuid binary and gathering io information of the
setuid'ed process.

Signed-off-by: Vasiliy Kulikov <segoon@openwall.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,fs/proc/base.c,"{""sha"": ""fc5bc27676926cccbc27f3349886e02bbc047211"", ""filename"": ""fs/proc/base.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/1d1221f375c94ef961ba8574ac4f85c8870ddd51/fs/proc/base.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/1d1221f375c94ef961ba8574ac4f85c8870ddd51/fs/proc/base.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/proc/base.c?ref=1d1221f375c94ef961ba8574ac4f85c8870ddd51"", ""patch"": ""@@ -2708,6 +2708,9 @@ static int do_io_accounting(struct task_struct *task, char *buffer, int whole)\n \tstruct task_io_accounting acct = task->ioac;\n \tunsigned long flags;\n \n+\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n+\t\treturn -EACCES;\n+\n \tif (whole && lock_task_sighand(task, &flags)) {\n \t\tstruct task_struct *t = task;\n \n@@ -2839,7 +2842,7 @@ static const struct pid_entry tgid_base_stuff[] = {\n \tREG(\""coredump_filter\"", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),\n #endif\n #ifdef CONFIG_TASK_IO_ACCOUNTING\n-\tINF(\""io\"",\tS_IRUGO, proc_tgid_io_accounting),\n+\tINF(\""io\"",\tS_IRUSR, proc_tgid_io_accounting),\n #endif\n #ifdef CONFIG_HARDWALL\n \tINF(\""hardwall\"",   S_IRUGO, proc_pid_hardwall),\n@@ -3181,7 +3184,7 @@ static const struct pid_entry tid_base_stuff[] = {\n \tREG(\""make-it-fail\"", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n #endif\n #ifdef CONFIG_TASK_IO_ACCOUNTING\n-\tINF(\""io\"",\tS_IRUGO, proc_tid_io_accounting),\n+\tINF(\""io\"",\tS_IRUSR, proc_tid_io_accounting),\n #endif\n #ifdef CONFIG_HARDWALL\n \tINF(\""hardwall\"",   S_IRUGO, proc_pid_hardwall),""}","static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
{
 	struct task_io_accounting acct = task->ioac;
 	unsigned long flags;
 
	if (!ptrace_may_access(task, PTRACE_MODE_READ))
		return -EACCES;

 	if (whole && lock_task_sighand(task, &flags)) {
 		struct task_struct *t = task;
 
		task_io_accounting_add(&acct, &task->signal->ioac);
		while_each_thread(task, t)
			task_io_accounting_add(&acct, &t->ioac);

		unlock_task_sighand(task, &flags);
	}
	return sprintf(buffer,
			""rchar: %llu\n""
			""wchar: %llu\n""
			""syscr: %llu\n""
			""syscw: %llu\n""
			""read_bytes: %llu\n""
			""write_bytes: %llu\n""
			""cancelled_write_bytes: %llu\n"",
			(unsigned long long)acct.rchar,
			(unsigned long long)acct.wchar,
			(unsigned long long)acct.syscr,
			(unsigned long long)acct.syscw,
			(unsigned long long)acct.read_bytes,
			(unsigned long long)acct.write_bytes,
			(unsigned long long)acct.cancelled_write_bytes);
}
","static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
{
 	struct task_io_accounting acct = task->ioac;
 	unsigned long flags;
 
 	if (whole && lock_task_sighand(task, &flags)) {
 		struct task_struct *t = task;
 
		task_io_accounting_add(&acct, &task->signal->ioac);
		while_each_thread(task, t)
			task_io_accounting_add(&acct, &t->ioac);

		unlock_task_sighand(task, &flags);
	}
	return sprintf(buffer,
			""rchar: %llu\n""
			""wchar: %llu\n""
			""syscr: %llu\n""
			""syscw: %llu\n""
			""read_bytes: %llu\n""
			""write_bytes: %llu\n""
			""cancelled_write_bytes: %llu\n"",
			(unsigned long long)acct.rchar,
			(unsigned long long)acct.wchar,
			(unsigned long long)acct.syscr,
			(unsigned long long)acct.syscw,
			(unsigned long long)acct.read_bytes,
			(unsigned long long)acct.write_bytes,
			(unsigned long long)acct.cancelled_write_bytes);
}
",C,"	if (!ptrace_may_access(task, PTRACE_MODE_READ))
		return -EACCES;

",,,"@@ -2708,6 +2708,9 @@ static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
 	struct task_io_accounting acct = task->ioac;
 	unsigned long flags;
 
+	if (!ptrace_may_access(task, PTRACE_MODE_READ))
+		return -EACCES;
+
 	if (whole && lock_task_sighand(task, &flags)) {
 		struct task_struct *t = task;
 
@@ -2839,7 +2842,7 @@ static const struct pid_entry tgid_base_stuff[] = {
 	REG(""coredump_filter"", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),
 #endif
 #ifdef CONFIG_TASK_IO_ACCOUNTING
-	INF(""io"",	S_IRUGO, proc_tgid_io_accounting),
+	INF(""io"",	S_IRUSR, proc_tgid_io_accounting),
 #endif
 #ifdef CONFIG_HARDWALL
 	INF(""hardwall"",   S_IRUGO, proc_pid_hardwall),
@@ -3181,7 +3184,7 @@ static const struct pid_entry tid_base_stuff[] = {
 	REG(""make-it-fail"", S_IRUGO|S_IWUSR, proc_fault_inject_operations),
 #endif
 #ifdef CONFIG_TASK_IO_ACCOUNTING
-	INF(""io"",	S_IRUGO, proc_tid_io_accounting),
+	INF(""io"",	S_IRUSR, proc_tid_io_accounting),
 #endif
 #ifdef CONFIG_HARDWALL
 	INF(""hardwall"",   S_IRUGO, proc_pid_hardwall),",linux,1d1221f375c94ef961ba8574ac4f85c8870ddd51,b0af8dfdd67699e25083478c63eedef2e72ebd85,1,"static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
{
 	struct task_io_accounting acct = task->ioac;
 	unsigned long flags;
 
//fix_flaw_line_below:
//	if (!ptrace_may_access(task, PTRACE_MODE_READ))
//fix_flaw_line_below:
//		return -EACCES;
//fix_flaw_line_below:
//
 	if (whole && lock_task_sighand(task, &flags)) {
 		struct task_struct *t = task;
 
		task_io_accounting_add(&acct, &task->signal->ioac);
		while_each_thread(task, t)
			task_io_accounting_add(&acct, &t->ioac);

		unlock_task_sighand(task, &flags);
	}
	return sprintf(buffer,
			""rchar: %llu\n""
			""wchar: %llu\n""
			""syscr: %llu\n""
			""syscw: %llu\n""
			""read_bytes: %llu\n""
			""write_bytes: %llu\n""
			""cancelled_write_bytes: %llu\n"",
			(unsigned long long)acct.rchar,
			(unsigned long long)acct.wchar,
			(unsigned long long)acct.syscr,
			(unsigned long long)acct.syscw,
			(unsigned long long)acct.read_bytes,
			(unsigned long long)acct.write_bytes,
			(unsigned long long)acct.cancelled_write_bytes);
}
",179032,"static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
{
 	struct task_io_accounting acct = task->ioac;
 	unsigned long flags;
 
 	if (whole && lock_task_sighand(task, &flags)) {
 		struct task_struct *t = task;
 
		task_io_accounting_add(&acct, &task->signal->ioac);
		while_each_thread(task, t)
			task_io_accounting_add(&acct, &t->ioac);

		unlock_task_sighand(task, &flags);
	}
	return sprintf(buffer,
			""rchar: %llu\n""
			""wchar: %llu\n""
			""syscr: %llu\n""
			""syscw: %llu\n""
			""read_bytes: %llu\n""
			""write_bytes: %llu\n""
			""cancelled_write_bytes: %llu\n"",
			(unsigned long long)acct.rchar,
			(unsigned long long)acct.wchar,
			(unsigned long long)acct.syscr,
			(unsigned long long)acct.syscw,
			(unsigned long long)acct.read_bytes,
			(unsigned long long)acct.write_bytes,
			(unsigned long long)acct.cancelled_write_bytes);
}
","static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
{
 	struct task_io_accounting acct = task->ioac;
 	unsigned long flags;
 
	if (!ptrace_may_access(task, PTRACE_MODE_READ))
		return -EACCES;

 	if (whole && lock_task_sighand(task, &flags)) {
 		struct task_struct *t = task;
 
		task_io_accounting_add(&acct, &task->signal->ioac);
		while_each_thread(task, t)
			task_io_accounting_add(&acct, &t->ioac);

		unlock_task_sighand(task, &flags);
	}
	return sprintf(buffer,
			""rchar: %llu\n""
			""wchar: %llu\n""
			""syscr: %llu\n""
			""syscw: %llu\n""
			""read_bytes: %llu\n""
			""write_bytes: %llu\n""
			""cancelled_write_bytes: %llu\n"",
			(unsigned long long)acct.rchar,
			(unsigned long long)acct.wchar,
			(unsigned long long)acct.syscr,
			(unsigned long long)acct.syscw,
			(unsigned long long)acct.read_bytes,
			(unsigned long long)acct.write_bytes,
			(unsigned long long)acct.cancelled_write_bytes);
}
","The `do_io_accounting` function is designed to gather and format input/output accounting statistics for a specified task in a Linux kernel environment. It first checks if the `whole` parameter is true and locks the task's signal handler to ensure thread safety. It then aggregates I/O accounting data from the task and its threads, updating the `acct` structure with values such as read and write character counts, system call read/write counts, and byte statistics. Finally, it formats this data into a string and writes it to the provided buffer, returning the number of characters written.","The code defines a function that collects and formats input/output accounting statistics for a specific task within a kernel environment. It first checks a condition to ensure safe access to the task's data and locks the necessary resources. The function then aggregates various I/O metrics from the main task and its associated threads, including counts of read and write operations, as well as the total bytes read and written. Finally, it formats this collected data into a string representation and writes it to a specified buffer, returning the length of the formatted output.","The vulnerability in the original code stemmed from the lack of access control, allowing any process to read I/O accounting information from another process, potentially exposing sensitive data such as password lengths. This was addressed in the fixed code by introducing a check using `ptrace_may_access(task, PTRACE_MODE_READ)`, which ensures that only processes with the appropriate permissions can access the I/O statistics of the target process. This change effectively restricts access to the I/O data, preventing unauthorized processes from gathering potentially sensitive information, thereby enhancing the security of the system.","The vulnerability in the original code allowed any process to access I/O accounting information from other processes, which could lead to the exposure of sensitive data, such as password lengths, thereby compromising security. This issue was addressed in the updated code by implementing an access control check that restricts the ability to read I/O statistics to only those processes that have the necessary permissions to trace the target process. This change effectively prevents unauthorized access to potentially sensitive information, enhancing the overall security of the system by ensuring that only permitted processes can gather such data.","The vulnerability was fixed by adding a check using `ptrace_may_access(task, PTRACE_MODE_READ)` at the beginning of the function. This ensures that only processes with the appropriate permissions to trace the target process can access its I/O accounting information. By enforcing this access control, the code prevents unauthorized processes from reading sensitive data, such as character counts that could reveal password lengths. This modification effectively restricts access to the I/O statistics, thereby enhancing security and mitigating the risk of information leakage from processes that should remain private.","The vulnerability was fixed by implementing an access control mechanism that restricts the ability to read I/O accounting information to only those processes that have the necessary permissions to trace the target process. This change ensures that unauthorized processes cannot access sensitive data, such as character counts that could potentially reveal password lengths. By enforcing this restriction at the beginning of the function, the code effectively prevents information leakage and enhances the overall security of the system, ensuring that only permitted processes can gather I/O statistics from other processes.","CWE-284, CWE-732, CWE-269, CWE-200, CWE-264, CWE-612, CWE-668, CWE-306, CWE-732, CWE-266",N,-1
16,16,179046,179046,,Local,Not required,,CVE-2011-1833,https://www.cvedetails.com/cve/CVE-2011-1833/,CWE-264,Medium,Partial,Partial,,2012-10-03,3.3,Race condition in the ecryptfs_mount function in fs/ecryptfs/main.c in the eCryptfs subsystem in the Linux kernel before 3.1 allows local users to bypass intended file permissions via a mount.ecryptfs_private mount with a mismatched uid.,2014-03-07,Bypass ,11,https://github.com/torvalds/linux/commit/764355487ea220fdc2faf128d577d7f679b91f97,764355487ea220fdc2faf128d577d7f679b91f97,"Ecryptfs: Add mount option to check uid of device being mounted = expect uid

Close a TOCTOU race for mounts done via ecryptfs-mount-private.  The mount
source (device) can be raced when the ownership test is done in userspace.
Provide Ecryptfs a means to force the uid check at mount time.

Signed-off-by: John Johansen <john.johansen@canonical.com>
Cc: <stable@kernel.org>
Signed-off-by: Tyler Hicks <tyhicks@linux.vnet.ibm.com>",1,fs/ecryptfs/main.c,"{""sha"": ""b4a6befb12168d6b0aa0bb7411794e062ded8734"", ""filename"": ""fs/ecryptfs/main.c"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 2, ""changes"": 23, ""blob_url"": ""https://github.com/torvalds/linux/blob/764355487ea220fdc2faf128d577d7f679b91f97/fs/ecryptfs/main.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/764355487ea220fdc2faf128d577d7f679b91f97/fs/ecryptfs/main.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ecryptfs/main.c?ref=764355487ea220fdc2faf128d577d7f679b91f97"", ""patch"": ""@@ -175,6 +175,7 @@ enum { ecryptfs_opt_sig, ecryptfs_opt_ecryptfs_sig,\n        ecryptfs_opt_encrypted_view, ecryptfs_opt_fnek_sig,\n        ecryptfs_opt_fn_cipher, ecryptfs_opt_fn_cipher_key_bytes,\n        ecryptfs_opt_unlink_sigs, ecryptfs_opt_mount_auth_tok_only,\n+       ecryptfs_opt_check_dev_ruid,\n        ecryptfs_opt_err };\n \n static const match_table_t tokens = {\n@@ -191,6 +192,7 @@ static const match_table_t tokens = {\n \t{ecryptfs_opt_fn_cipher_key_bytes, \""ecryptfs_fn_key_bytes=%u\""},\n \t{ecryptfs_opt_unlink_sigs, \""ecryptfs_unlink_sigs\""},\n \t{ecryptfs_opt_mount_auth_tok_only, \""ecryptfs_mount_auth_tok_only\""},\n+\t{ecryptfs_opt_check_dev_ruid, \""ecryptfs_check_dev_ruid\""},\n \t{ecryptfs_opt_err, NULL}\n };\n \n@@ -236,6 +238,7 @@ static void ecryptfs_init_mount_crypt_stat(\n  * ecryptfs_parse_options\n  * @sb: The ecryptfs super block\n  * @options: The options passed to the kernel\n+ * @check_ruid: set to 1 if device uid should be checked against the ruid\n  *\n  * Parse mount options:\n  * debug=N \t   - ecryptfs_verbosity level for debug output\n@@ -251,7 +254,8 @@ static void ecryptfs_init_mount_crypt_stat(\n  *\n  * Returns zero on success; non-zero on error\n  */\n-static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)\n+static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,\n+\t\t\t\t  uid_t *check_ruid)\n {\n \tchar *p;\n \tint rc = 0;\n@@ -276,6 +280,8 @@ static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)\n \tchar *cipher_key_bytes_src;\n \tchar *fn_cipher_key_bytes_src;\n \n+\t*check_ruid = 0;\n+\n \tif (!options) {\n \t\trc = -EINVAL;\n \t\tgoto out;\n@@ -380,6 +386,9 @@ static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)\n \t\t\tmount_crypt_stat->flags |=\n \t\t\t\tECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;\n \t\t\tbreak;\n+\t\tcase ecryptfs_opt_check_dev_ruid:\n+\t\t\t*check_ruid = 1;\n+\t\t\tbreak;\n \t\tcase ecryptfs_opt_err:\n \t\tdefault:\n \t\t\tprintk(KERN_WARNING\n@@ -475,6 +484,7 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags\n \tconst char *err = \""Getting sb failed\"";\n \tstruct inode *inode;\n \tstruct path path;\n+\tuid_t check_ruid;\n \tint rc;\n \n \tsbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);\n@@ -483,7 +493,7 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags\n \t\tgoto out;\n \t}\n \n-\trc = ecryptfs_parse_options(sbi, raw_data);\n+\trc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);\n \tif (rc) {\n \t\terr = \""Error parsing options\"";\n \t\tgoto out;\n@@ -521,6 +531,15 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags\n \t\t\t\""known incompatibilities\\n\"");\n \t\tgoto out_free;\n \t}\n+\n+\tif (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {\n+\t\trc = -EPERM;\n+\t\tprintk(KERN_ERR \""Mount of device (uid: %d) not owned by \""\n+\t\t       \""requested user (uid: %d)\\n\"",\n+\t\t       path.dentry->d_inode->i_uid, current_uid());\n+\t\tgoto out_free;\n+\t}\n+\n \tecryptfs_set_superblock_lower(s, path.dentry->d_sb);\n \ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n \ts->s_blocksize = path.dentry->d_sb->s_blocksize;""}","static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
 	const char *err = ""Getting sb failed"";
 	struct inode *inode;
 	struct path path;
	uid_t check_ruid;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
 		goto out;
 	}
 
	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
 	if (rc) {
 		err = ""Error parsing options"";
 		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	s->s_flags = flags;
	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
 			""known incompatibilities\n"");
 		goto out_free;
 	}

	if (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
		       path.dentry->d_inode->i_uid, current_uid());
		goto out_free;
	}

 	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
	s->s_magic = ECRYPTFS_SUPER_MAGIC;

	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_alloc_root(inode);
	if (!s->s_root) {
		iput(inode);
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	ecryptfs_set_dentry_lower(s->s_root, path.dentry);
	ecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
","static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
 	const char *err = ""Getting sb failed"";
 	struct inode *inode;
 	struct path path;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
 		goto out;
 	}
 
	rc = ecryptfs_parse_options(sbi, raw_data);
 	if (rc) {
 		err = ""Error parsing options"";
 		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	s->s_flags = flags;
	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
 			""known incompatibilities\n"");
 		goto out_free;
 	}
 	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
	s->s_magic = ECRYPTFS_SUPER_MAGIC;

	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_alloc_root(inode);
	if (!s->s_root) {
		iput(inode);
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	ecryptfs_set_dentry_lower(s->s_root, path.dentry);
	ecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
",C,"	uid_t check_ruid;
	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);

	if (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
		       path.dentry->d_inode->i_uid, current_uid());
		goto out_free;
	}

","	rc = ecryptfs_parse_options(sbi, raw_data);
",,"@@ -175,6 +175,7 @@ enum { ecryptfs_opt_sig, ecryptfs_opt_ecryptfs_sig,
        ecryptfs_opt_encrypted_view, ecryptfs_opt_fnek_sig,
        ecryptfs_opt_fn_cipher, ecryptfs_opt_fn_cipher_key_bytes,
        ecryptfs_opt_unlink_sigs, ecryptfs_opt_mount_auth_tok_only,
+       ecryptfs_opt_check_dev_ruid,
        ecryptfs_opt_err };
 
 static const match_table_t tokens = {
@@ -191,6 +192,7 @@ static const match_table_t tokens = {
 	{ecryptfs_opt_fn_cipher_key_bytes, ""ecryptfs_fn_key_bytes=%u""},
 	{ecryptfs_opt_unlink_sigs, ""ecryptfs_unlink_sigs""},
 	{ecryptfs_opt_mount_auth_tok_only, ""ecryptfs_mount_auth_tok_only""},
+	{ecryptfs_opt_check_dev_ruid, ""ecryptfs_check_dev_ruid""},
 	{ecryptfs_opt_err, NULL}
 };
 
@@ -236,6 +238,7 @@ static void ecryptfs_init_mount_crypt_stat(
  * ecryptfs_parse_options
  * @sb: The ecryptfs super block
  * @options: The options passed to the kernel
+ * @check_ruid: set to 1 if device uid should be checked against the ruid
  *
  * Parse mount options:
  * debug=N 	   - ecryptfs_verbosity level for debug output
@@ -251,7 +254,8 @@ static void ecryptfs_init_mount_crypt_stat(
  *
  * Returns zero on success; non-zero on error
  */
-static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)
+static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,
+				  uid_t *check_ruid)
 {
 	char *p;
 	int rc = 0;
@@ -276,6 +280,8 @@ static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)
 	char *cipher_key_bytes_src;
 	char *fn_cipher_key_bytes_src;
 
+	*check_ruid = 0;
+
 	if (!options) {
 		rc = -EINVAL;
 		goto out;
@@ -380,6 +386,9 @@ static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)
 			mount_crypt_stat->flags |=
 				ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;
 			break;
+		case ecryptfs_opt_check_dev_ruid:
+			*check_ruid = 1;
+			break;
 		case ecryptfs_opt_err:
 		default:
 			printk(KERN_WARNING
@@ -475,6 +484,7 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags
 	const char *err = ""Getting sb failed"";
 	struct inode *inode;
 	struct path path;
+	uid_t check_ruid;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
@@ -483,7 +493,7 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags
 		goto out;
 	}
 
-	rc = ecryptfs_parse_options(sbi, raw_data);
+	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
 	if (rc) {
 		err = ""Error parsing options"";
 		goto out;
@@ -521,6 +531,15 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags
 			""known incompatibilities\n"");
 		goto out_free;
 	}
+
+	if (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {
+		rc = -EPERM;
+		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
+		       ""requested user (uid: %d)\n"",
+		       path.dentry->d_inode->i_uid, current_uid());
+		goto out_free;
+	}
+
 	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;",linux,764355487ea220fdc2faf128d577d7f679b91f97,99b373ff2d1246f64b97a3d449a2fd6018d504e6,1,"static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
 	const char *err = ""Getting sb failed"";
 	struct inode *inode;
 	struct path path;
//fix_flaw_line_below:
//	uid_t check_ruid;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
 		goto out;
 	}
 
//flaw_line_below:
	rc = ecryptfs_parse_options(sbi, raw_data);
//fix_flaw_line_below:
//	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
 	if (rc) {
 		err = ""Error parsing options"";
 		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	s->s_flags = flags;
	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
 			""known incompatibilities\n"");
 		goto out_free;
 	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {
//fix_flaw_line_below:
//		rc = -EPERM;
//fix_flaw_line_below:
//		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
//fix_flaw_line_below:
//		       ""requested user (uid: %d)\n"",
//fix_flaw_line_below:
//		       path.dentry->d_inode->i_uid, current_uid());
//fix_flaw_line_below:
//		goto out_free;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
	s->s_magic = ECRYPTFS_SUPER_MAGIC;

	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_alloc_root(inode);
	if (!s->s_root) {
		iput(inode);
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	ecryptfs_set_dentry_lower(s->s_root, path.dentry);
	ecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
",179046,"static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
 	const char *err = ""Getting sb failed"";
 	struct inode *inode;
 	struct path path;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
 		goto out;
 	}
 
	rc = ecryptfs_parse_options(sbi, raw_data);
 	if (rc) {
 		err = ""Error parsing options"";
 		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	s->s_flags = flags;
	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
 			""known incompatibilities\n"");
 		goto out_free;
 	}
 	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
	s->s_magic = ECRYPTFS_SUPER_MAGIC;

	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_alloc_root(inode);
	if (!s->s_root) {
		iput(inode);
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	ecryptfs_set_dentry_lower(s->s_root, path.dentry);
	ecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
","static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
 	const char *err = ""Getting sb failed"";
 	struct inode *inode;
 	struct path path;
	uid_t check_ruid;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
 		goto out;
 	}
 
	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
 	if (rc) {
 		err = ""Error parsing options"";
 		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	s->s_flags = flags;
	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
 			""known incompatibilities\n"");
 		goto out_free;
 	}

	if (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
		       path.dentry->d_inode->i_uid, current_uid());
		goto out_free;
	}

 	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
	s->s_magic = ECRYPTFS_SUPER_MAGIC;

	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_alloc_root(inode);
	if (!s->s_root) {
		iput(inode);
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	ecryptfs_set_dentry_lower(s->s_root, path.dentry);
	ecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
","The `ecryptfs_mount` function is responsible for mounting an eCryptfs filesystem in the Linux kernel. It begins by allocating memory for the superblock information and parsing options from the provided raw data. The function then attempts to create a superblock and register a block device interface. It checks the validity of the specified device name, ensuring it does not already belong to an eCryptfs filesystem. If successful, it initializes the superblock with relevant parameters, retrieves the root inode, and allocates memory for the root directory's private data. Finally, it returns a reference to the root dentry or an error code if any step fails.","The code implements a function that facilitates the mounting of an encrypted filesystem within the Linux kernel. It begins by allocating necessary memory for filesystem metadata and parsing configuration options. The function then establishes a new filesystem instance and verifies the specified device's compatibility. Upon successful validation, it initializes the filesystem parameters, retrieves the root directory's inode, and allocates memory for its associated data. Finally, the function returns a reference to the root directory or an error code if any operation fails, ensuring proper resource management throughout the process.","The vulnerability in the original code stemmed from a time-of-check to time-of-use (TOCTOU) race condition, where the ownership of the device being mounted could change between the user-space check and the actual mount operation. This allowed unauthorized users to potentially mount devices they did not own. The fix introduced a new variable to check the real user ID at the time of mounting, ensuring that the ownership verification occurs immediately before the mount operation. By comparing the device's user ID with the current user ID, the code now prevents unauthorized mounts, thereby closing the race condition.","The vulnerability in the original code was a time-of-check to time-of-use (TOCTOU) race condition, which allowed the ownership of the device being mounted to change between the user-space check and the actual mount operation. This could enable unauthorized users to mount devices they did not own. The fix addressed this issue by introducing a mechanism to enforce a user ID check at the time of mounting, ensuring that the ownership verification occurs immediately before the mount operation. This change effectively prevents unauthorized mounts and closes the race condition, enhancing the security of the mounting process.","The vulnerability was fixed by introducing a new variable, `check_ruid`, which is used to enforce a user ID check at the time of mounting. In the updated code, after retrieving the device's inode, the code checks if `check_ruid` is set and compares the device's user ID with the current user ID. If they do not match, the operation is aborted with an error code, preventing unauthorized access. This change ensures that the ownership verification occurs right before the mount operation, effectively closing the TOCTOU race condition that existed in the original implementation.","The vulnerability was fixed by implementing a mechanism that enforces a user ID check at the time of the mount operation. This change ensures that the ownership of the device is verified immediately before the mount occurs, rather than relying on a prior check that could be bypassed during a race condition. By comparing the device's user ID with the current user's ID at this critical moment, the code effectively prevents unauthorized users from mounting devices they do not own, thereby closing the security gap and enhancing the overall integrity of the mounting process.","CWE-362, CWE-367, CWE-732, CWE-269, CWE-284, CWE-287, CWE-639, CWE-441, CWE-266, CWE-425",N,-1
17,17,179077,179077,,Local,Not required,,CVE-2011-0006,https://www.cvedetails.com/cve/CVE-2011-0006/,CWE-264,Medium,,Partial,,2012-06-21,1.9,"The ima_lsm_rule_init function in security/integrity/ima/ima_policy.c in the Linux kernel before 2.6.37, when the Linux Security Modules (LSM) framework is disabled, allows local users to bypass Integrity Measurement Architecture (IMA) rules in opportunistic circumstances by leveraging an administrator's addition of an IMA rule for LSM.",2012-06-26,Bypass ,2,https://github.com/torvalds/linux/commit/867c20265459d30a01b021a9c1e81fb4c5832aa9,867c20265459d30a01b021a9c1e81fb4c5832aa9,"ima: fix add LSM rule bug

If security_filter_rule_init() doesn't return a rule, then not everything
is as fine as the return code implies.

This bug only occurs when the LSM (eg. SELinux) is disabled at runtime.

Adding an empty LSM rule causes ima_match_rules() to always succeed,
ignoring any remaining rules.

 default IMA TCB policy:
  # PROC_SUPER_MAGIC
  dont_measure fsmagic=0x9fa0
  # SYSFS_MAGIC
  dont_measure fsmagic=0x62656572
  # DEBUGFS_MAGIC
  dont_measure fsmagic=0x64626720
  # TMPFS_MAGIC
  dont_measure fsmagic=0x01021994
  # SECURITYFS_MAGIC
  dont_measure fsmagic=0x73636673

  < LSM specific rule >
  dont_measure obj_type=var_log_t

  measure func=BPRM_CHECK
  measure func=FILE_MMAP mask=MAY_EXEC
  measure func=FILE_CHECK mask=MAY_READ uid=0

Thus without the patch, with the boot parameters 'tcb selinux=0', adding
the above 'dont_measure obj_type=var_log_t' rule to the default IMA TCB
measurement policy, would result in nothing being measured.  The patch
prevents the default TCB policy from being replaced.

Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
Cc: James Morris <jmorris@namei.org>
Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
Cc: David Safford <safford@watson.ibm.com>
Cc: <stable@kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,security/integrity/ima/ima_policy.c,"{""sha"": ""d661afbe474c2fce8f74907869be0a644c5789c9"", ""filename"": ""security/integrity/ima/ima_policy.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/867c20265459d30a01b021a9c1e81fb4c5832aa9/security/integrity/ima/ima_policy.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/867c20265459d30a01b021a9c1e81fb4c5832aa9/security/integrity/ima/ima_policy.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/integrity/ima/ima_policy.c?ref=867c20265459d30a01b021a9c1e81fb4c5832aa9"", ""patch"": ""@@ -253,6 +253,8 @@ static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,\n \tresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\n \t\t\t\t\t   Audit_equal, args,\n \t\t\t\t\t   &entry->lsm[lsm_rule].rule);\n+\tif (!entry->lsm[lsm_rule].rule)\n+\t\treturn -EINVAL;\n \treturn result;\n }\n ""}","static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,
			     char *args, int lsm_rule, int audit_type)
{
	int result;

	if (entry->lsm[lsm_rule].rule)
		return -EINVAL;

	entry->lsm[lsm_rule].type = audit_type;
 	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 					   Audit_equal, args,
 					   &entry->lsm[lsm_rule].rule);
	if (!entry->lsm[lsm_rule].rule)
		return -EINVAL;
 	return result;
 }
","static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,
			     char *args, int lsm_rule, int audit_type)
{
	int result;

	if (entry->lsm[lsm_rule].rule)
		return -EINVAL;

	entry->lsm[lsm_rule].type = audit_type;
 	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 					   Audit_equal, args,
 					   &entry->lsm[lsm_rule].rule);
 	return result;
 }
",C,"	if (!entry->lsm[lsm_rule].rule)
		return -EINVAL;
",,,"@@ -253,6 +253,8 @@ static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,
 	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 					   Audit_equal, args,
 					   &entry->lsm[lsm_rule].rule);
+	if (!entry->lsm[lsm_rule].rule)
+		return -EINVAL;
 	return result;
 }
 ",linux,867c20265459d30a01b021a9c1e81fb4c5832aa9,03ed6a3aa600c48593c3984812fda2d5945ddb46,1,"static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,
			     char *args, int lsm_rule, int audit_type)
{
	int result;

	if (entry->lsm[lsm_rule].rule)
		return -EINVAL;

	entry->lsm[lsm_rule].type = audit_type;
 	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 					   Audit_equal, args,
 					   &entry->lsm[lsm_rule].rule);
//fix_flaw_line_below:
//	if (!entry->lsm[lsm_rule].rule)
//fix_flaw_line_below:
//		return -EINVAL;
 	return result;
 }
",179077,"static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,
			     char *args, int lsm_rule, int audit_type)
{
	int result;

	if (entry->lsm[lsm_rule].rule)
		return -EINVAL;

	entry->lsm[lsm_rule].type = audit_type;
 	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 					   Audit_equal, args,
 					   &entry->lsm[lsm_rule].rule);
 	return result;
 }
","static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,
			     char *args, int lsm_rule, int audit_type)
{
	int result;

	if (entry->lsm[lsm_rule].rule)
		return -EINVAL;

	entry->lsm[lsm_rule].type = audit_type;
 	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 					   Audit_equal, args,
 					   &entry->lsm[lsm_rule].rule);
	if (!entry->lsm[lsm_rule].rule)
		return -EINVAL;
 	return result;
 }
","The `ima_lsm_rule_init` function initializes a security rule for a given entry in the Linux Integrity Measurement Architecture (IMA). It first checks if a rule already exists for the specified Linux Security Module (LSM) by verifying the `rule` field; if it does, it returns an error code. If no rule exists, it assigns the provided `audit_type` to the entry's LSM structure. The function then calls `security_filter_rule_init` to set up the rule using the specified arguments and stores the result in the `rule` field. Finally, it returns the result of the initialization process.","The code defines a function that initializes a security rule for a specific entry in a measurement system. It first checks if a rule is already present for the designated security module; if so, it returns an error indicating invalid input. If no rule exists, it assigns a specified audit type to the entry's structure. The function then proceeds to set up the rule using the provided arguments and stores the outcome in the entry's structure. Finally, it returns the result of the initialization process, indicating success or failure based on the setup operation.","The vulnerability in the original code arises when the function `security_filter_rule_init` fails to return a valid rule, particularly when the Linux Security Module (LSM) is disabled at runtime. In this scenario, the absence of a rule would lead to the function returning a success code, allowing an empty rule to be added, which could cause the measurement system to ignore all other rules. The fix introduces an additional check after the rule initialization to verify that a rule was indeed created; if not, it returns an error code, thereby preventing the default measurement policy from being inadvertently replaced and ensuring proper rule enforcement.","The vulnerability in the original code occurs when a security rule is added without proper validation, particularly when the associated security module is disabled. In such cases, the system could mistakenly interpret a successful operation even if no valid rule was created, leading to the addition of an empty rule. This would cause the rule-matching process to always succeed, effectively ignoring other critical rules and compromising the integrity measurement system. The fix introduces a validation step to ensure that a valid rule is created; if not, an error is returned, thus maintaining the integrity of the measurement policy.","The vulnerability was fixed by adding a validation check after the call to `security_filter_rule_init`. In the updated code, after attempting to initialize the rule, the function checks if `entry->lsm[lsm_rule].rule` is still null. If it is, the function returns an error code, specifically `-EINVAL`, indicating that the rule was not successfully created. This additional check ensures that an empty rule cannot be added, thereby preventing the default measurement policy from being replaced and ensuring that the integrity measurement system functions correctly even when the security module is disabled.","The vulnerability was addressed by implementing an additional validation step after the rule initialization process. The updated code checks whether a valid rule was created; if the rule is absent, it returns an error code indicating an invalid operation. This ensures that an empty rule cannot be added to the system, which would have allowed the rule-matching process to succeed without enforcing any actual security measures. By enforcing this check, the integrity measurement system is safeguarded against unintended policy replacements, maintaining its intended functionality even when the associated security module is disabled.","CWE-754, CWE-665, CWE-256, CWE-284, CWE-693, CWE-20, CWE-573, CWE-269, CWE-281, CWE-732",N,-1
18,18,179110,179110,,Local,Not required,Complete,CVE-2013-6431,https://www.cvedetails.com/cve/CVE-2013-6431/,CWE-264,Medium,,,,2013-12-09,4.7,"The fib6_add function in net/ipv6/ip6_fib.c in the Linux kernel before 3.11.5 does not properly implement error-code encoding, which allows local users to cause a denial of service (NULL pointer dereference and system crash) by leveraging the CAP_NET_ADMIN capability for an IPv6 SIOCADDRT ioctl call.",2014-03-05,DoS ,1,https://github.com/torvalds/linux/commit/ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2,ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2,"net: fib: fib6_add: fix potential NULL pointer dereference

When the kernel is compiled with CONFIG_IPV6_SUBTREES, and we return
with an error in fn = fib6_add_1(), then error codes are encoded into
the return pointer e.g. ERR_PTR(-ENOENT). In such an error case, we
write the error code into err and jump to out, hence enter the if(err)
condition. Now, if CONFIG_IPV6_SUBTREES is enabled, we check for:

  if (pn != fn && pn->leaf == rt)
    ...
  if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO))
    ...

Since pn is NULL and fn is f.e. ERR_PTR(-ENOENT), then pn != fn
evaluates to true and causes a NULL-pointer dereference on further
checks on pn. Fix it, by setting both NULL in error case, so that
pn != fn already evaluates to false and no further dereference
takes place.

This was first correctly implemented in 4a287eba2 (""IPv6 routing,
NLM_F_* flag support: REPLACE and EXCL flags support, warn about
missing CREATE flag""), but the bug got later on introduced by
188c517a0 (""ipv6: return errno pointers consistently for fib6_add_1()"").

Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
Cc: Lin Ming <mlin@ss.pku.edu.cn>
Cc: Matti Vaittinen <matti.vaittinen@nsn.com>
Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>
Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Acked-by: Matti Vaittinen <matti.vaittinen@nsn.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/ipv6/ip6_fib.c,"{""sha"": ""5bec666aba61d464fab4e77684eedd4265143cf9"", ""filename"": ""net/ipv6/ip6_fib.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2/net/ipv6/ip6_fib.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2/net/ipv6/ip6_fib.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/ip6_fib.c?ref=ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2"", ""patch"": ""@@ -825,9 +825,9 @@ int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)\n \tfn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,\n \t\t\toffsetof(struct rt6_info, rt6i_dst), allow_create,\n \t\t\treplace_required);\n-\n \tif (IS_ERR(fn)) {\n \t\terr = PTR_ERR(fn);\n+\t\tfn = NULL;\n \t\tgoto out;\n \t}\n ""}","int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
{
	struct fib6_node *fn, *pn = NULL;
	int err = -ENOMEM;
	int allow_create = 1;
	int replace_required = 0;

	if (info->nlh) {
		if (!(info->nlh->nlmsg_flags & NLM_F_CREATE))
			allow_create = 0;
		if (info->nlh->nlmsg_flags & NLM_F_REPLACE)
			replace_required = 1;
	}
	if (!allow_create && !replace_required)
		pr_warn(""RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\n"");

 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
 			offsetof(struct rt6_info, rt6i_dst), allow_create,
 			replace_required);
 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
		fn = NULL;
 		goto out;
 	}
 
	pn = fn;

#ifdef CONFIG_IPV6_SUBTREES
	if (rt->rt6i_src.plen) {
		struct fib6_node *sn;

		if (!fn->subtree) {
			struct fib6_node *sfn;

			/*
			 * Create subtree.
			 *
			 *		fn[main tree]
			 *		|
			 *		sfn[subtree root]
			 *		   \
			 *		    sn[new leaf node]
			 */

			/* Create subtree root node */
			sfn = node_alloc();
			if (!sfn)
				goto st_failure;

			sfn->leaf = info->nl_net->ipv6.ip6_null_entry;
			atomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);
			sfn->fn_flags = RTN_ROOT;
			sfn->fn_sernum = fib6_new_sernum();

			/* Now add the first leaf node to new subtree */

			sn = fib6_add_1(sfn, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				/* If it is failed, discard just allocated
				   root, and then (in st_failure) stale node
				   in main tree.
				 */
				node_free(sfn);
				err = PTR_ERR(sn);
				goto st_failure;
			}

			/* Now link new subtree to main tree */
			sfn->parent = fn;
			fn->subtree = sfn;
		} else {
			sn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				err = PTR_ERR(sn);
				goto st_failure;
			}
		}

		if (!fn->leaf) {
			fn->leaf = rt;
			atomic_inc(&rt->rt6i_ref);
		}
		fn = sn;
	}
#endif

	err = fib6_add_rt2node(fn, rt, info);
	if (!err) {
		fib6_start_gc(info->nl_net, rt);
		if (!(rt->rt6i_flags & RTF_CACHE))
			fib6_prune_clones(info->nl_net, pn, rt);
	}

out:
	if (err) {
#ifdef CONFIG_IPV6_SUBTREES
		/*
		 * If fib6_add_1 has cleared the old leaf pointer in the
		 * super-tree leaf node we have to find a new one for it.
		 */
		if (pn != fn && pn->leaf == rt) {
			pn->leaf = NULL;
			atomic_dec(&rt->rt6i_ref);
		}
		if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {
			pn->leaf = fib6_find_prefix(info->nl_net, pn);
#if RT6_DEBUG >= 2
			if (!pn->leaf) {
				WARN_ON(pn->leaf == NULL);
				pn->leaf = info->nl_net->ipv6.ip6_null_entry;
			}
#endif
			atomic_inc(&pn->leaf->rt6i_ref);
		}
#endif
		dst_free(&rt->dst);
	}
	return err;

#ifdef CONFIG_IPV6_SUBTREES
	/* Subtree creation failed, probably main tree node
	   is orphan. If it is, shoot it.
	 */
st_failure:
	if (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))
		fib6_repair_tree(info->nl_net, fn);
	dst_free(&rt->dst);
	return err;
#endif
}
","int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
{
	struct fib6_node *fn, *pn = NULL;
	int err = -ENOMEM;
	int allow_create = 1;
	int replace_required = 0;

	if (info->nlh) {
		if (!(info->nlh->nlmsg_flags & NLM_F_CREATE))
			allow_create = 0;
		if (info->nlh->nlmsg_flags & NLM_F_REPLACE)
			replace_required = 1;
	}
	if (!allow_create && !replace_required)
		pr_warn(""RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\n"");

 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
 			offsetof(struct rt6_info, rt6i_dst), allow_create,
 			replace_required);
 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
 		goto out;
 	}
 
	pn = fn;

#ifdef CONFIG_IPV6_SUBTREES
	if (rt->rt6i_src.plen) {
		struct fib6_node *sn;

		if (!fn->subtree) {
			struct fib6_node *sfn;

			/*
			 * Create subtree.
			 *
			 *		fn[main tree]
			 *		|
			 *		sfn[subtree root]
			 *		   \
			 *		    sn[new leaf node]
			 */

			/* Create subtree root node */
			sfn = node_alloc();
			if (!sfn)
				goto st_failure;

			sfn->leaf = info->nl_net->ipv6.ip6_null_entry;
			atomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);
			sfn->fn_flags = RTN_ROOT;
			sfn->fn_sernum = fib6_new_sernum();

			/* Now add the first leaf node to new subtree */

			sn = fib6_add_1(sfn, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				/* If it is failed, discard just allocated
				   root, and then (in st_failure) stale node
				   in main tree.
				 */
				node_free(sfn);
				err = PTR_ERR(sn);
				goto st_failure;
			}

			/* Now link new subtree to main tree */
			sfn->parent = fn;
			fn->subtree = sfn;
		} else {
			sn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				err = PTR_ERR(sn);
				goto st_failure;
			}
		}

		if (!fn->leaf) {
			fn->leaf = rt;
			atomic_inc(&rt->rt6i_ref);
		}
		fn = sn;
	}
#endif

	err = fib6_add_rt2node(fn, rt, info);
	if (!err) {
		fib6_start_gc(info->nl_net, rt);
		if (!(rt->rt6i_flags & RTF_CACHE))
			fib6_prune_clones(info->nl_net, pn, rt);
	}

out:
	if (err) {
#ifdef CONFIG_IPV6_SUBTREES
		/*
		 * If fib6_add_1 has cleared the old leaf pointer in the
		 * super-tree leaf node we have to find a new one for it.
		 */
		if (pn != fn && pn->leaf == rt) {
			pn->leaf = NULL;
			atomic_dec(&rt->rt6i_ref);
		}
		if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {
			pn->leaf = fib6_find_prefix(info->nl_net, pn);
#if RT6_DEBUG >= 2
			if (!pn->leaf) {
				WARN_ON(pn->leaf == NULL);
				pn->leaf = info->nl_net->ipv6.ip6_null_entry;
			}
#endif
			atomic_inc(&pn->leaf->rt6i_ref);
		}
#endif
		dst_free(&rt->dst);
	}
	return err;

#ifdef CONFIG_IPV6_SUBTREES
	/* Subtree creation failed, probably main tree node
	   is orphan. If it is, shoot it.
	 */
st_failure:
	if (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))
		fib6_repair_tree(info->nl_net, fn);
	dst_free(&rt->dst);
	return err;
#endif
}
",C,"		fn = NULL;
",,,"@@ -825,9 +825,9 @@ int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
 			offsetof(struct rt6_info, rt6i_dst), allow_create,
 			replace_required);
-
 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
+		fn = NULL;
 		goto out;
 	}
 ",linux,ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2,3bf4b5b11d381fed6a94a7e487e01c8b3bc436b9,1,"int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
{
	struct fib6_node *fn, *pn = NULL;
	int err = -ENOMEM;
	int allow_create = 1;
	int replace_required = 0;

	if (info->nlh) {
		if (!(info->nlh->nlmsg_flags & NLM_F_CREATE))
			allow_create = 0;
		if (info->nlh->nlmsg_flags & NLM_F_REPLACE)
			replace_required = 1;
	}
	if (!allow_create && !replace_required)
		pr_warn(""RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\n"");

 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
 			offsetof(struct rt6_info, rt6i_dst), allow_create,
 			replace_required);
//flaw_line_below:

 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
//fix_flaw_line_below:
//		fn = NULL;
 		goto out;
 	}
 
	pn = fn;

#ifdef CONFIG_IPV6_SUBTREES
	if (rt->rt6i_src.plen) {
		struct fib6_node *sn;

		if (!fn->subtree) {
			struct fib6_node *sfn;

			/*
			 * Create subtree.
			 *
			 *		fn[main tree]
			 *		|
			 *		sfn[subtree root]
			 *		   \
			 *		    sn[new leaf node]
			 */

			/* Create subtree root node */
			sfn = node_alloc();
			if (!sfn)
				goto st_failure;

			sfn->leaf = info->nl_net->ipv6.ip6_null_entry;
			atomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);
			sfn->fn_flags = RTN_ROOT;
			sfn->fn_sernum = fib6_new_sernum();

			/* Now add the first leaf node to new subtree */

			sn = fib6_add_1(sfn, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				/* If it is failed, discard just allocated
				   root, and then (in st_failure) stale node
				   in main tree.
				 */
				node_free(sfn);
				err = PTR_ERR(sn);
				goto st_failure;
			}

			/* Now link new subtree to main tree */
			sfn->parent = fn;
			fn->subtree = sfn;
		} else {
			sn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				err = PTR_ERR(sn);
				goto st_failure;
			}
		}

		if (!fn->leaf) {
			fn->leaf = rt;
			atomic_inc(&rt->rt6i_ref);
		}
		fn = sn;
	}
#endif

	err = fib6_add_rt2node(fn, rt, info);
	if (!err) {
		fib6_start_gc(info->nl_net, rt);
		if (!(rt->rt6i_flags & RTF_CACHE))
			fib6_prune_clones(info->nl_net, pn, rt);
	}

out:
	if (err) {
#ifdef CONFIG_IPV6_SUBTREES
		/*
		 * If fib6_add_1 has cleared the old leaf pointer in the
		 * super-tree leaf node we have to find a new one for it.
		 */
		if (pn != fn && pn->leaf == rt) {
			pn->leaf = NULL;
			atomic_dec(&rt->rt6i_ref);
		}
		if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {
			pn->leaf = fib6_find_prefix(info->nl_net, pn);
#if RT6_DEBUG >= 2
			if (!pn->leaf) {
				WARN_ON(pn->leaf == NULL);
				pn->leaf = info->nl_net->ipv6.ip6_null_entry;
			}
#endif
			atomic_inc(&pn->leaf->rt6i_ref);
		}
#endif
		dst_free(&rt->dst);
	}
	return err;

#ifdef CONFIG_IPV6_SUBTREES
	/* Subtree creation failed, probably main tree node
	   is orphan. If it is, shoot it.
	 */
st_failure:
	if (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))
		fib6_repair_tree(info->nl_net, fn);
	dst_free(&rt->dst);
	return err;
#endif
}
",179110,"int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
{
	struct fib6_node *fn, *pn = NULL;
	int err = -ENOMEM;
	int allow_create = 1;
	int replace_required = 0;

	if (info->nlh) {
		if (!(info->nlh->nlmsg_flags & NLM_F_CREATE))
			allow_create = 0;
		if (info->nlh->nlmsg_flags & NLM_F_REPLACE)
			replace_required = 1;
	}
	if (!allow_create && !replace_required)
		pr_warn(""RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\n"");

 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
 			offsetof(struct rt6_info, rt6i_dst), allow_create,
 			replace_required);
 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
 		goto out;
 	}
 
	pn = fn;

#ifdef CONFIG_IPV6_SUBTREES
	if (rt->rt6i_src.plen) {
		struct fib6_node *sn;

		if (!fn->subtree) {
			struct fib6_node *sfn;

			/*
			 * Create subtree.
			 *
			 *		fn[main tree]
			 *		|
			 *		sfn[subtree root]
			 *		   \
			 *		    sn[new leaf node]
			 */

			/* Create subtree root node */
			sfn = node_alloc();
			if (!sfn)
				goto st_failure;

			sfn->leaf = info->nl_net->ipv6.ip6_null_entry;
			atomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);
			sfn->fn_flags = RTN_ROOT;
			sfn->fn_sernum = fib6_new_sernum();

			/* Now add the first leaf node to new subtree */

			sn = fib6_add_1(sfn, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				/* If it is failed, discard just allocated
				   root, and then (in st_failure) stale node
				   in main tree.
				 */
				node_free(sfn);
				err = PTR_ERR(sn);
				goto st_failure;
			}

			/* Now link new subtree to main tree */
			sfn->parent = fn;
			fn->subtree = sfn;
		} else {
			sn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				err = PTR_ERR(sn);
				goto st_failure;
			}
		}

		if (!fn->leaf) {
			fn->leaf = rt;
			atomic_inc(&rt->rt6i_ref);
		}
		fn = sn;
	}
#endif

	err = fib6_add_rt2node(fn, rt, info);
	if (!err) {
		fib6_start_gc(info->nl_net, rt);
		if (!(rt->rt6i_flags & RTF_CACHE))
			fib6_prune_clones(info->nl_net, pn, rt);
	}

out:
	if (err) {
#ifdef CONFIG_IPV6_SUBTREES
		/*
		 * If fib6_add_1 has cleared the old leaf pointer in the
		 * super-tree leaf node we have to find a new one for it.
		 */
		if (pn != fn && pn->leaf == rt) {
			pn->leaf = NULL;
			atomic_dec(&rt->rt6i_ref);
		}
		if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {
			pn->leaf = fib6_find_prefix(info->nl_net, pn);
#if RT6_DEBUG >= 2
			if (!pn->leaf) {
				WARN_ON(pn->leaf == NULL);
				pn->leaf = info->nl_net->ipv6.ip6_null_entry;
			}
#endif
			atomic_inc(&pn->leaf->rt6i_ref);
		}
#endif
		dst_free(&rt->dst);
	}
	return err;

#ifdef CONFIG_IPV6_SUBTREES
	/* Subtree creation failed, probably main tree node
	   is orphan. If it is, shoot it.
	 */
st_failure:
	if (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))
		fib6_repair_tree(info->nl_net, fn);
	dst_free(&rt->dst);
	return err;
#endif
}
","int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
{
	struct fib6_node *fn, *pn = NULL;
	int err = -ENOMEM;
	int allow_create = 1;
	int replace_required = 0;

	if (info->nlh) {
		if (!(info->nlh->nlmsg_flags & NLM_F_CREATE))
			allow_create = 0;
		if (info->nlh->nlmsg_flags & NLM_F_REPLACE)
			replace_required = 1;
	}
	if (!allow_create && !replace_required)
		pr_warn(""RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\n"");

 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
 			offsetof(struct rt6_info, rt6i_dst), allow_create,
 			replace_required);
 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
		fn = NULL;
 		goto out;
 	}
 
	pn = fn;

#ifdef CONFIG_IPV6_SUBTREES
	if (rt->rt6i_src.plen) {
		struct fib6_node *sn;

		if (!fn->subtree) {
			struct fib6_node *sfn;

			/*
			 * Create subtree.
			 *
			 *		fn[main tree]
			 *		|
			 *		sfn[subtree root]
			 *		   \
			 *		    sn[new leaf node]
			 */

			/* Create subtree root node */
			sfn = node_alloc();
			if (!sfn)
				goto st_failure;

			sfn->leaf = info->nl_net->ipv6.ip6_null_entry;
			atomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);
			sfn->fn_flags = RTN_ROOT;
			sfn->fn_sernum = fib6_new_sernum();

			/* Now add the first leaf node to new subtree */

			sn = fib6_add_1(sfn, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				/* If it is failed, discard just allocated
				   root, and then (in st_failure) stale node
				   in main tree.
				 */
				node_free(sfn);
				err = PTR_ERR(sn);
				goto st_failure;
			}

			/* Now link new subtree to main tree */
			sfn->parent = fn;
			fn->subtree = sfn;
		} else {
			sn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,
					rt->rt6i_src.plen,
					offsetof(struct rt6_info, rt6i_src),
					allow_create, replace_required);

			if (IS_ERR(sn)) {
				err = PTR_ERR(sn);
				goto st_failure;
			}
		}

		if (!fn->leaf) {
			fn->leaf = rt;
			atomic_inc(&rt->rt6i_ref);
		}
		fn = sn;
	}
#endif

	err = fib6_add_rt2node(fn, rt, info);
	if (!err) {
		fib6_start_gc(info->nl_net, rt);
		if (!(rt->rt6i_flags & RTF_CACHE))
			fib6_prune_clones(info->nl_net, pn, rt);
	}

out:
	if (err) {
#ifdef CONFIG_IPV6_SUBTREES
		/*
		 * If fib6_add_1 has cleared the old leaf pointer in the
		 * super-tree leaf node we have to find a new one for it.
		 */
		if (pn != fn && pn->leaf == rt) {
			pn->leaf = NULL;
			atomic_dec(&rt->rt6i_ref);
		}
		if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {
			pn->leaf = fib6_find_prefix(info->nl_net, pn);
#if RT6_DEBUG >= 2
			if (!pn->leaf) {
				WARN_ON(pn->leaf == NULL);
				pn->leaf = info->nl_net->ipv6.ip6_null_entry;
			}
#endif
			atomic_inc(&pn->leaf->rt6i_ref);
		}
#endif
		dst_free(&rt->dst);
	}
	return err;

#ifdef CONFIG_IPV6_SUBTREES
	/* Subtree creation failed, probably main tree node
	   is orphan. If it is, shoot it.
	 */
st_failure:
	if (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))
		fib6_repair_tree(info->nl_net, fn);
	dst_free(&rt->dst);
	return err;
#endif
}
","The `fib6_add` function is responsible for adding a new route to an IPv6 routing table, represented by a tree structure. It first checks the message flags to determine if route creation or replacement is allowed. If allowed, it attempts to add the route to the main tree and potentially create a subtree if a source prefix is provided. The function handles memory allocation for new nodes and ensures proper linking between the main tree and any subtrees. If any errors occur during the process, it performs cleanup and reference management to maintain the integrity of the routing table. The function ultimately returns an error code or zero upon success.","The code implements a function that manages the addition of a new route to an IPv6 routing table structured as a tree. It first evaluates the conditions for creating or replacing a route based on message flags. If permitted, it attempts to insert the route into the main tree and may create a subtree if a source prefix is specified. The function handles memory allocation for new nodes, ensures proper connections between the main tree and any subtrees, and manages reference counts. It also includes error handling to maintain the integrity of the routing table and performs necessary cleanup if issues arise.","The vulnerability in the original code arises from a potential NULL pointer dereference when handling error conditions. Specifically, if the function `fib6_add_1` returns an error, the variable representing the node is set to an error pointer, while another variable remains NULL. This discrepancy allows the condition checking if the two variables are not equal to evaluate as true, leading to dereferencing a NULL pointer in subsequent checks. The fix addresses this by ensuring that both variables are set to NULL in the error case, preventing any further dereference attempts and thus eliminating the risk of a NULL pointer dereference.","The vulnerability in the original code stems from a potential NULL pointer dereference that occurs when handling error conditions in a specific configuration. When an error is returned, one variable is set to an error code while another remains NULL. This inconsistency allows a subsequent condition check to incorrectly evaluate as true, leading to dereferencing a NULL pointer. The fix addresses this issue by ensuring that both variables are set to NULL in the event of an error, preventing any further dereference attempts and thereby eliminating the risk of a NULL pointer dereference in the code.","The vulnerability was fixed by modifying the error handling logic in the code. Specifically, when an error is returned from the function `fib6_add_1`, both the variables `fn` and `pn` are explicitly set to NULL. This change ensures that the condition `if (pn != fn && pn->leaf == rt)` evaluates to false, preventing any dereference of the NULL pointer. By aligning the state of both variables during error conditions, the fix effectively eliminates the risk of a NULL pointer dereference that could occur in the subsequent checks, thereby enhancing the code's robustness.","The vulnerability was fixed by adjusting the error handling mechanism to ensure that both relevant pointers are set to NULL when an error occurs. This change prevents a situation where one pointer holds an error code while the other remains NULL, which could lead to a NULL pointer dereference during subsequent checks. By synchronizing the state of these pointers in error scenarios, the fix ensures that any conditional evaluations involving them will not attempt to dereference a NULL pointer, thereby enhancing the overall safety and stability of the code.","CWE-476, CWE-690, CWE-456, CWE-457, CWE-824, CWE-908, CWE-469, CWE-465, CWE-822, CWE-688",N,-1
19,19,179111,179111,,Local,Not required,Complete,CVE-2013-6383,https://www.cvedetails.com/cve/CVE-2013-6383/,CWE-264,Medium,Complete,Complete,,2013-11-26,6.9,"The aac_compat_ioctl function in drivers/scsi/aacraid/linit.c in the Linux kernel before 3.11.8 does not require the CAP_SYS_RAWIO capability, which allows local users to bypass intended access restrictions via a crafted ioctl call.",2014-03-26,Bypass ,2,https://github.com/torvalds/linux/commit/f856567b930dfcdbc3323261bf77240ccdde01f5,f856567b930dfcdbc3323261bf77240ccdde01f5,"aacraid: missing capable() check in compat ioctl

In commit d496f94d22d1 ('[SCSI] aacraid: fix security weakness') we
added a check on CAP_SYS_RAWIO to the ioctl.  The compat ioctls need the
check as well.

Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
Cc: stable@kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,drivers/scsi/aacraid/linit.c,"{""sha"": ""f0d432c139d0cecedf51295562c858d22a9f44f0"", ""filename"": ""drivers/scsi/aacraid/linit.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/f856567b930dfcdbc3323261bf77240ccdde01f5/drivers/scsi/aacraid/linit.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f856567b930dfcdbc3323261bf77240ccdde01f5/drivers/scsi/aacraid/linit.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/scsi/aacraid/linit.c?ref=f856567b930dfcdbc3323261bf77240ccdde01f5"", ""patch"": ""@@ -771,6 +771,8 @@ static long aac_compat_do_ioctl(struct aac_dev *dev, unsigned cmd, unsigned long\n static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)\n {\n \tstruct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;\n+\tif (!capable(CAP_SYS_RAWIO))\n+\t\treturn -EPERM;\n \treturn aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);\n }\n ""}"," static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
"," static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
",C,"	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
",,,"@@ -771,6 +771,8 @@ static long aac_compat_do_ioctl(struct aac_dev *dev, unsigned cmd, unsigned long
 static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
+	if (!capable(CAP_SYS_RAWIO))
+		return -EPERM;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
 ",linux,f856567b930dfcdbc3323261bf77240ccdde01f5,c2c65cd2e14ada6de44cb527e7f1990bede24e15,1," static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
//fix_flaw_line_below:
//	if (!capable(CAP_SYS_RAWIO))
//fix_flaw_line_below:
//		return -EPERM;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
",179111," static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
"," static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
","The provided code defines a function `aac_compat_ioctl` that serves as an interface for handling compatibility IOCTL (Input/Output Control) commands for SCSI devices. It takes three parameters: a pointer to a `scsi_device` structure, an integer command, and a user-space pointer for arguments. The function retrieves the associated `aac_dev` structure from the SCSI device's host data and then calls another function, `aac_compat_do_ioctl`, passing the device structure, command, and argument cast to an unsigned long. This facilitates communication between user space and the device driver, ensuring compatibility with various command types.","The code defines a function that acts as a bridge for processing compatibility input/output control commands for a specific type of device. It accepts parameters representing a device structure, a command identifier, and a pointer for user-supplied arguments. The function retrieves the relevant device information from the device's host data and subsequently invokes another function to handle the command, passing along the necessary details. This mechanism enables effective communication between user space and the device driver, ensuring that various command types are processed correctly while maintaining compatibility across different system environments.","The vulnerability in the original code stemmed from the absence of a security check to verify whether the calling process had the necessary permissions to perform raw I/O operations. This oversight could allow unauthorized users to execute potentially harmful commands through the IOCTL interface. The fix introduced a check using the `capable(CAP_SYS_RAWIO)` function, which ensures that only processes with the appropriate capabilities can proceed with the command execution. By implementing this check before invoking the `aac_compat_do_ioctl` function, the code now effectively mitigates the risk of unauthorized access and enhances overall security.","The vulnerability in the original code was due to the lack of a security check that ensured only authorized processes could execute raw input/output operations, potentially allowing unauthorized access to sensitive device controls. This oversight could lead to security risks, as malicious users might exploit the IOCTL interface to perform harmful actions. The fix introduced a capability check that verifies whether the calling process has the necessary permissions before proceeding with the command execution. This additional validation effectively restricts access to the IOCTL functionality, thereby enhancing the security of the system against unauthorized operations.","The vulnerability was fixed by adding a capability check using the `capable(CAP_SYS_RAWIO)` function before executing the IOCTL command. This check ensures that only processes with the appropriate permissions can access raw input/output operations, thereby preventing unauthorized users from executing potentially harmful commands. By placing this validation before the call to `aac_compat_do_ioctl`, the code now effectively restricts access to the IOCTL interface, ensuring that only authorized users can interact with the device in a way that could affect system integrity or security. This enhancement significantly mitigates the risk of exploitation.","The vulnerability was addressed by implementing a security check that verifies whether the calling process has the necessary permissions to perform raw input/output operations. This check was added before executing the command, ensuring that only authorized users can access sensitive device controls. By enforcing this validation, the code now restricts access to the interface, effectively preventing unauthorized users from executing potentially harmful commands. This enhancement significantly improves the security of the system by mitigating the risk of exploitation and ensuring that only processes with the appropriate capabilities can interact with the device.","CWE-269, CWE-284, CWE-285, CWE-732, CWE-264, CWE-266, CWE-250, CWE-668, CWE-275, CWE-265",N,-1
20,20,179158,179158,,Local,Not required,Complete,CVE-2013-4470,https://www.cvedetails.com/cve/CVE-2013-4470/,CWE-264,Medium,Complete,Complete,,2013-11-04,6.9,"The Linux kernel before 3.12, when UDP Fragmentation Offload (UFO) is enabled, does not properly initialize certain data structures, which allows local users to cause a denial of service (memory corruption and system crash) or possibly gain privileges via a crafted application that uses the UDP_CORK option in a setsockopt system call and sends both short and long packets, related to the ip_ufo_append_data function in net/ipv4/ip_output.c and the ip6_ufo_append_data function in net/ipv6/ip6_output.c.",2018-01-08,DoS +Priv Mem. Corr. ,9,https://github.com/torvalds/linux/commit/e93b7d748be887cd7639b113ba7d7ef792a7efb9,e93b7d748be887cd7639b113ba7d7ef792a7efb9,"ip_output: do skb ufo init for peeked non ufo skb as well

Now, if user application does:
sendto len<mtu flag MSG_MORE
sendto len>mtu flag 0
The skb is not treated as fragmented one because it is not initialized
that way. So move the initialization to fix this.

introduced by:
commit e89e9cf539a28df7d0eb1d0a545368e9920b34ac ""[IPv4/IPv6]: UFO Scatter-gather approach""

Signed-off-by: Jiri Pirko <jiri@resnulli.us>
Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",4,net/ipv4/ip_output.c,"{""sha"": ""3982eabf61e126060fc7c5b48042bea2f0417135"", ""filename"": ""net/ipv4/ip_output.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 4, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/e93b7d748be887cd7639b113ba7d7ef792a7efb9/net/ipv4/ip_output.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e93b7d748be887cd7639b113ba7d7ef792a7efb9/net/ipv4/ip_output.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/ip_output.c?ref=e93b7d748be887cd7639b113ba7d7ef792a7efb9"", ""patch"": ""@@ -772,15 +772,20 @@ static inline int ip_ufo_append_data(struct sock *sk,\n \t\t/* initialize protocol header pointer */\n \t\tskb->transport_header = skb->network_header + fragheaderlen;\n \n-\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n \t\tskb->csum = 0;\n \n-\t\t/* specify the length of each IP datagram fragment */\n-\t\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n-\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n+\n \t\t__skb_queue_tail(queue, skb);\n+\t} else if (skb_is_gso(skb)) {\n+\t\tgoto append;\n \t}\n \n+\tskb->ip_summed = CHECKSUM_PARTIAL;\n+\t/* specify the length of each IP datagram fragment */\n+\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n+\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n+\n+append:\n \treturn skb_append_datato_frags(sk, skb, getfrag, from,\n \t\t\t\t       (length - transhdrlen));\n }""}","static inline int ip_ufo_append_data(struct sock *sk,
			struct sk_buff_head *queue,
			int getfrag(void *from, char *to, int offset, int len,
			       int odd, struct sk_buff *skb),
			void *from, int length, int hh_len, int fragheaderlen,
			int transhdrlen, int maxfraglen, unsigned int flags)
{
	struct sk_buff *skb;
	int err;

	/* There is support for UDP fragmentation offload by network
	 * device, so create one single skb packet containing complete
	 * udp datagram
	 */
	if ((skb = skb_peek_tail(queue)) == NULL) {
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags & MSG_DONTWAIT), &err);

		if (skb == NULL)
			return err;

		/* reserve space for Hardware header */
		skb_reserve(skb, hh_len);

		/* create space for UDP/IP header */
		skb_put(skb, fragheaderlen + transhdrlen);

		/* initialize network header pointer */
		skb_reset_network_header(skb);

 		/* initialize protocol header pointer */
 		skb->transport_header = skb->network_header + fragheaderlen;
 
 		skb->csum = 0;
 

 		__skb_queue_tail(queue, skb);
	} else if (skb_is_gso(skb)) {
		goto append;
 	}
 
	skb->ip_summed = CHECKSUM_PARTIAL;
	/* specify the length of each IP datagram fragment */
	skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;

append:
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }
","static inline int ip_ufo_append_data(struct sock *sk,
			struct sk_buff_head *queue,
			int getfrag(void *from, char *to, int offset, int len,
			       int odd, struct sk_buff *skb),
			void *from, int length, int hh_len, int fragheaderlen,
			int transhdrlen, int maxfraglen, unsigned int flags)
{
	struct sk_buff *skb;
	int err;

	/* There is support for UDP fragmentation offload by network
	 * device, so create one single skb packet containing complete
	 * udp datagram
	 */
	if ((skb = skb_peek_tail(queue)) == NULL) {
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags & MSG_DONTWAIT), &err);

		if (skb == NULL)
			return err;

		/* reserve space for Hardware header */
		skb_reserve(skb, hh_len);

		/* create space for UDP/IP header */
		skb_put(skb, fragheaderlen + transhdrlen);

		/* initialize network header pointer */
		skb_reset_network_header(skb);

 		/* initialize protocol header pointer */
 		skb->transport_header = skb->network_header + fragheaderlen;
 
		skb->ip_summed = CHECKSUM_PARTIAL;
 		skb->csum = 0;
 
		/* specify the length of each IP datagram fragment */
		skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
		skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
 		__skb_queue_tail(queue, skb);
 	}
 
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }
",C,"
	} else if (skb_is_gso(skb)) {
		goto append;
	skb->ip_summed = CHECKSUM_PARTIAL;
	/* specify the length of each IP datagram fragment */
	skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;

append:
","		skb->ip_summed = CHECKSUM_PARTIAL;
		/* specify the length of each IP datagram fragment */
		skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
		skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
",,"@@ -772,15 +772,20 @@ static inline int ip_ufo_append_data(struct sock *sk,
 		/* initialize protocol header pointer */
 		skb->transport_header = skb->network_header + fragheaderlen;
 
-		skb->ip_summed = CHECKSUM_PARTIAL;
 		skb->csum = 0;
 
-		/* specify the length of each IP datagram fragment */
-		skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
-		skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
+
 		__skb_queue_tail(queue, skb);
+	} else if (skb_is_gso(skb)) {
+		goto append;
 	}
 
+	skb->ip_summed = CHECKSUM_PARTIAL;
+	/* specify the length of each IP datagram fragment */
+	skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
+	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
+
+append:
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }",linux,e93b7d748be887cd7639b113ba7d7ef792a7efb9,c547dbf55d5f8cf615ccc0e7265e98db27d3fb8b,1,"static inline int ip_ufo_append_data(struct sock *sk,
			struct sk_buff_head *queue,
			int getfrag(void *from, char *to, int offset, int len,
			       int odd, struct sk_buff *skb),
			void *from, int length, int hh_len, int fragheaderlen,
			int transhdrlen, int maxfraglen, unsigned int flags)
{
	struct sk_buff *skb;
	int err;

	/* There is support for UDP fragmentation offload by network
	 * device, so create one single skb packet containing complete
	 * udp datagram
	 */
	if ((skb = skb_peek_tail(queue)) == NULL) {
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags & MSG_DONTWAIT), &err);

		if (skb == NULL)
			return err;

		/* reserve space for Hardware header */
		skb_reserve(skb, hh_len);

		/* create space for UDP/IP header */
		skb_put(skb, fragheaderlen + transhdrlen);

		/* initialize network header pointer */
		skb_reset_network_header(skb);

 		/* initialize protocol header pointer */
 		skb->transport_header = skb->network_header + fragheaderlen;
 
//flaw_line_below:
		skb->ip_summed = CHECKSUM_PARTIAL;
 		skb->csum = 0;
 
//flaw_line_below:
		/* specify the length of each IP datagram fragment */
//flaw_line_below:
		skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
//flaw_line_below:
		skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
//fix_flaw_line_below:
//
 		__skb_queue_tail(queue, skb);
//fix_flaw_line_below:
//	} else if (skb_is_gso(skb)) {
//fix_flaw_line_below:
//		goto append;
 	}
 
//fix_flaw_line_below:
//	skb->ip_summed = CHECKSUM_PARTIAL;
//fix_flaw_line_below:
//	/* specify the length of each IP datagram fragment */
//fix_flaw_line_below:
//	skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
//fix_flaw_line_below:
//	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//append:
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }
",179158,"static inline int ip_ufo_append_data(struct sock *sk,
			struct sk_buff_head *queue,
			int getfrag(void *from, char *to, int offset, int len,
			       int odd, struct sk_buff *skb),
			void *from, int length, int hh_len, int fragheaderlen,
			int transhdrlen, int maxfraglen, unsigned int flags)
{
	struct sk_buff *skb;
	int err;

	/* There is support for UDP fragmentation offload by network
	 * device, so create one single skb packet containing complete
	 * udp datagram
	 */
	if ((skb = skb_peek_tail(queue)) == NULL) {
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags & MSG_DONTWAIT), &err);

		if (skb == NULL)
			return err;

		/* reserve space for Hardware header */
		skb_reserve(skb, hh_len);

		/* create space for UDP/IP header */
		skb_put(skb, fragheaderlen + transhdrlen);

		/* initialize network header pointer */
		skb_reset_network_header(skb);

 		/* initialize protocol header pointer */
 		skb->transport_header = skb->network_header + fragheaderlen;
 
		skb->ip_summed = CHECKSUM_PARTIAL;
 		skb->csum = 0;
 
		/* specify the length of each IP datagram fragment */
		skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
		skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
 		__skb_queue_tail(queue, skb);
 	}
 
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }
","static inline int ip_ufo_append_data(struct sock *sk,
			struct sk_buff_head *queue,
			int getfrag(void *from, char *to, int offset, int len,
			       int odd, struct sk_buff *skb),
			void *from, int length, int hh_len, int fragheaderlen,
			int transhdrlen, int maxfraglen, unsigned int flags)
{
	struct sk_buff *skb;
	int err;

	/* There is support for UDP fragmentation offload by network
	 * device, so create one single skb packet containing complete
	 * udp datagram
	 */
	if ((skb = skb_peek_tail(queue)) == NULL) {
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags & MSG_DONTWAIT), &err);

		if (skb == NULL)
			return err;

		/* reserve space for Hardware header */
		skb_reserve(skb, hh_len);

		/* create space for UDP/IP header */
		skb_put(skb, fragheaderlen + transhdrlen);

		/* initialize network header pointer */
		skb_reset_network_header(skb);

 		/* initialize protocol header pointer */
 		skb->transport_header = skb->network_header + fragheaderlen;
 
 		skb->csum = 0;
 

 		__skb_queue_tail(queue, skb);
	} else if (skb_is_gso(skb)) {
		goto append;
 	}
 
	skb->ip_summed = CHECKSUM_PARTIAL;
	/* specify the length of each IP datagram fragment */
	skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;

append:
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }
","The provided code defines a function `ip_ufo_append_data` that facilitates the appending of data to a socket buffer (skb) for UDP fragmentation offload. It first checks if there is an existing skb in the specified queue; if not, it allocates a new skb with reserved space for headers and initializes various pointers and checksums. The function sets the maximum fragment size and type for the skb, ensuring it is ready for UDP transmission. Finally, it appends the data from the specified source using the provided `getfrag` function, allowing for efficient handling of fragmented UDP packets.","The code defines a function that manages the appending of data to a socket buffer for efficient UDP fragmentation offload. It first checks for an existing buffer in a specified queue; if none is found, it allocates a new buffer with reserved space for necessary headers and initializes various parameters, including checksums. The function sets the maximum size for each fragment and prepares the buffer for transmission. Finally, it appends the data from a specified source, enabling the effective handling of fragmented packets for network communication.","The vulnerability in the original code arises from the failure to properly initialize the socket buffer when it is peeked from the queue, leading to incorrect handling of fragmented packets. Specifically, if a non-fragmented socket buffer is reused without proper initialization, it may not be treated as fragmented, causing issues when sending data with specific flags. The fix addresses this by ensuring that the initialization of the socket buffer's checksum and fragmentation parameters occurs even for peeked buffers that are not marked for offload. This change guarantees that all buffers are correctly set up for fragmentation, preventing potential data transmission errors.","The vulnerability in the original code stems from the improper handling of socket buffers that are peeked from a queue, which may not be initialized for fragmentation. This oversight can lead to situations where data is sent without the necessary fragmentation setup, particularly when specific flags are used in user applications. The fix addresses this issue by ensuring that the initialization process for fragmentation is applied to all socket buffers, including those that are peeked and not marked for offload. This change guarantees that all buffers are correctly prepared for fragmented transmission, thus preventing potential data handling errors.","The vulnerability was fixed by modifying the code to ensure that the initialization of the socket buffer occurs even for peeked buffers that are not marked for offload. Specifically, the code now checks if the socket buffer is a Generic Segmentation Offload (GSO) buffer using a conditional statement. If the peeked buffer is not a GSO buffer, the initialization of the checksum and fragmentation parameters is performed, including setting the checksum to zero and configuring the GSO size and type. This ensures that all socket buffers are properly prepared for fragmentation, preventing issues during data transmission.","The vulnerability was fixed by ensuring that all socket buffers, including those that are peeked from a queue and not initially marked for fragmentation, undergo proper initialization. The updated code introduces a check to determine if the buffer is suitable for fragmentation; if it is not, the necessary parameters for fragmentation and checksum are set up correctly. This adjustment guarantees that all buffers are adequately prepared for handling fragmented data, thereby preventing potential errors during transmission when specific flags are used in user applications. This comprehensive initialization enhances the reliability of data handling in the network stack.","CWE-908, CWE-665, CWE-457, CWE-456, CWE-562, CWE-824, CWE-119, CWE-788, CWE-573, CWE-571",N,-1
21,21,179163,179163,,Local,Not required,Complete,CVE-2013-4300,https://www.cvedetails.com/cve/CVE-2013-4300/,CWE-264,Low,Complete,Complete,,2013-09-25,7.2,"The scm_check_creds function in net/core/scm.c in the Linux kernel before 3.11 performs a capability check in an incorrect namespace, which allows local users to gain privileges via PID spoofing.",2013-10-30,+Priv ,1,https://github.com/torvalds/linux/commit/d661684cf6820331feae71146c35da83d794467e,d661684cf6820331feae71146c35da83d794467e,"net: Check the correct namespace when spoofing pid over SCM_RIGHTS

This is a security bug.

The follow-up will fix nsproxy to discourage this type of issue from
happening again.

Cc: stable@vger.kernel.org
Signed-off-by: Andy Lutomirski <luto@amacapital.net>
Reviewed-by: ""Eric W. Biederman"" <ebiederm@xmission.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/core/scm.c,"{""sha"": ""b4da80b1cc07d28eafec50a6185d6d2a2ece61af"", ""filename"": ""net/core/scm.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d661684cf6820331feae71146c35da83d794467e/net/core/scm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d661684cf6820331feae71146c35da83d794467e/net/core/scm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/core/scm.c?ref=d661684cf6820331feae71146c35da83d794467e"", ""patch"": ""@@ -54,7 +54,7 @@ static __inline__ int scm_check_creds(struct ucred *creds)\n \t\treturn -EINVAL;\n \n \tif ((creds->pid == task_tgid_vnr(current) ||\n-\t     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&\n+\t     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&\n \t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n \t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n \t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||""}","static __inline__ int scm_check_creds(struct ucred *creds)
{
	const struct cred *cred = current_cred();
	kuid_t uid = make_kuid(cred->user_ns, creds->uid);
	kgid_t gid = make_kgid(cred->user_ns, creds->gid);

	if (!uid_valid(uid) || !gid_valid(gid))
 		return -EINVAL;
 
 	if ((creds->pid == task_tgid_vnr(current) ||
	     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||
	      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {
	       return 0;
	}
	return -EPERM;
}
","static __inline__ int scm_check_creds(struct ucred *creds)
{
	const struct cred *cred = current_cred();
	kuid_t uid = make_kuid(cred->user_ns, creds->uid);
	kgid_t gid = make_kgid(cred->user_ns, creds->gid);

	if (!uid_valid(uid) || !gid_valid(gid))
 		return -EINVAL;
 
 	if ((creds->pid == task_tgid_vnr(current) ||
	     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||
	      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {
	       return 0;
	}
	return -EPERM;
}
",C,"	     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&
","	     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&
",,"@@ -54,7 +54,7 @@ static __inline__ int scm_check_creds(struct ucred *creds)
 		return -EINVAL;
 
 	if ((creds->pid == task_tgid_vnr(current) ||
-	     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&
+	     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||",linux,d661684cf6820331feae71146c35da83d794467e,dd5746bf6b48bb837e9f5af14b9b241fc4fdc1ef,1,"static __inline__ int scm_check_creds(struct ucred *creds)
{
	const struct cred *cred = current_cred();
	kuid_t uid = make_kuid(cred->user_ns, creds->uid);
	kgid_t gid = make_kgid(cred->user_ns, creds->gid);

	if (!uid_valid(uid) || !gid_valid(gid))
 		return -EINVAL;
 
 	if ((creds->pid == task_tgid_vnr(current) ||
//flaw_line_below:
	     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&
//fix_flaw_line_below:
//	     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||
	      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {
	       return 0;
	}
	return -EPERM;
}
",179163,"static __inline__ int scm_check_creds(struct ucred *creds)
{
	const struct cred *cred = current_cred();
	kuid_t uid = make_kuid(cred->user_ns, creds->uid);
	kgid_t gid = make_kgid(cred->user_ns, creds->gid);

	if (!uid_valid(uid) || !gid_valid(gid))
 		return -EINVAL;
 
 	if ((creds->pid == task_tgid_vnr(current) ||
	     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||
	      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {
	       return 0;
	}
	return -EPERM;
}
","static __inline__ int scm_check_creds(struct ucred *creds)
{
	const struct cred *cred = current_cred();
	kuid_t uid = make_kuid(cred->user_ns, creds->uid);
	kgid_t gid = make_kgid(cred->user_ns, creds->gid);

	if (!uid_valid(uid) || !gid_valid(gid))
 		return -EINVAL;
 
 	if ((creds->pid == task_tgid_vnr(current) ||
	     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||
	      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {
	       return 0;
	}
	return -EPERM;
}
","The `scm_check_creds` function verifies the validity of user credentials in a Linux kernel context. It retrieves the current process's credentials and checks if the provided user ID (UID) and group ID (GID) are valid within the current user namespace. The function allows access if the credentials belong to the current process or if the process has administrative capabilities. Specifically, it checks if the UID and GID match the current user's credentials or if the process has the necessary capabilities to change them. If any checks fail, it returns an error code indicating permission denial.","The provided code defines a function that checks the validity of user credentials in a kernel environment. It retrieves the current user's credentials and verifies whether the specified user and group identifiers are valid within the current namespace. The function allows access if the identifiers correspond to the current process or if the process possesses administrative privileges. It further checks if the identifiers match the current user's credentials or if the process has the authority to modify them. If any of these conditions are not met, the function returns an error indicating that permission is denied.","The vulnerability in the original code stemmed from an improper check of the namespace when verifying process identifiers, which could allow unauthorized users to spoof their credentials and gain elevated privileges. Specifically, the check for administrative capabilities used `current->nsproxy->pid_ns->user_ns`, which did not correctly validate the namespace context. The fix involved changing this to `task_active_pid_ns(current)->user_ns`, ensuring that the correct namespace is checked against the provided credentials. This adjustment prevents potential privilege escalation by ensuring that only valid and authorized processes can manipulate their user and group identifiers.","The vulnerability in the original code allowed unauthorized users to potentially spoof their process identifiers, leading to privilege escalation. This occurred because the code incorrectly checked the namespace context, which could be manipulated to bypass security restrictions. The fix involved updating the namespace validation to ensure that the correct context was used when verifying process identifiers. By implementing this change, the code now accurately checks the namespace, preventing unauthorized credential manipulation and enhancing overall security. This adjustment aims to mitigate similar issues in the future by reinforcing proper namespace handling.","The vulnerability was fixed by changing the namespace check from `current->nsproxy->pid_ns->user_ns` to `task_active_pid_ns(current)->user_ns`. This adjustment ensures that the correct user namespace is used when validating process identifiers, thereby preventing unauthorized users from spoofing their credentials. The updated code now accurately verifies that the provided user and group identifiers belong to the appropriate namespace context, which is crucial for maintaining security. Additionally, the fix reinforces the overall integrity of the credential checking process, reducing the risk of privilege escalation through improper namespace handling.","The vulnerability was fixed by ensuring that the correct namespace context is used when validating process identifiers. The code was modified to reference the active namespace of the current process, rather than an incorrect or potentially manipulated namespace. This change guarantees that the validation checks are performed against the appropriate user context, thereby preventing unauthorized users from spoofing their credentials and gaining elevated privileges. By reinforcing the namespace validation mechanism, the fix enhances the security of the credential checking process and mitigates the risk of privilege escalation through improper handling of identifiers.","CWE-269,CWE-286,CWE-287,CWE-285,CWE-266,CWE-284,CWE-270,CWE-264,CWE-268,CWE-290",Y,8
22,22,179220,179220,,Local,Not required,,CVE-2013-2930,https://www.cvedetails.com/cve/CVE-2013-2930/,CWE-264,Low,Partial,Partial,,2013-12-09,3.6,"The perf_trace_event_perm function in kernel/trace/trace_event_perf.c in the Linux kernel before 3.12.2 does not properly restrict access to the perf subsystem, which allows local users to enable function tracing via a crafted application.",2014-03-05,,1,https://github.com/torvalds/linux/commit/12ae030d54ef250706da5642fc7697cc60ad0df7,12ae030d54ef250706da5642fc7697cc60ad0df7,"perf/ftrace: Fix paranoid level for enabling function tracer

The current default perf paranoid level is ""1"" which has
""perf_paranoid_kernel()"" return false, and giving any operations that
use it, access to normal users. Unfortunately, this includes function
tracing and normal users should not be allowed to enable function
tracing by default.

The proper level is defined at ""-1"" (full perf access), which
""perf_paranoid_tracepoint_raw()"" will only give access to. Use that
check instead for enabling function tracing.

Reported-by: Dave Jones <davej@redhat.com>
Reported-by: Vince Weaver <vincent.weaver@maine.edu>
Tested-by: Vince Weaver <vincent.weaver@maine.edu>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Ingo Molnar <mingo@kernel.org>
Cc: Jiri Olsa <jolsa@redhat.com>
Cc: Frederic Weisbecker <fweisbec@gmail.com>
Cc: stable@vger.kernel.org # 3.4+
CVE: CVE-2013-2930
Fixes: ced39002f5ea (""ftrace, perf: Add support to use function tracepoint in perf"")
Signed-off-by: Steven Rostedt <rostedt@goodmis.org>",1,kernel/trace/trace_event_perf.c,"{""sha"": ""78e27e3b52ac2ee0b9e86f544b77a45e12865d95"", ""filename"": ""kernel/trace/trace_event_perf.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/12ae030d54ef250706da5642fc7697cc60ad0df7/kernel/trace/trace_event_perf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/12ae030d54ef250706da5642fc7697cc60ad0df7/kernel/trace/trace_event_perf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/trace/trace_event_perf.c?ref=12ae030d54ef250706da5642fc7697cc60ad0df7"", ""patch"": ""@@ -26,7 +26,7 @@ static int perf_trace_event_perm(struct ftrace_event_call *tp_event,\n {\n \t/* The ftrace function trace is allowed only for root. */\n \tif (ftrace_event_is_function(tp_event) &&\n-\t    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n+\t    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n \t\treturn -EPERM;\n \n \t/* No tracing, just counting, so no obvious leak */""}","static int perf_trace_event_perm(struct ftrace_event_call *tp_event,
				 struct perf_event *p_event)
 {
 	/* The ftrace function trace is allowed only for root. */
 	if (ftrace_event_is_function(tp_event) &&
	    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	/* No tracing, just counting, so no obvious leak */
	if (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))
		return 0;

	/* Some events are ok to be traced by non-root users... */
	if (p_event->attach_state == PERF_ATTACH_TASK) {
		if (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)
			return 0;
	}

	/*
	 * ...otherwise raw tracepoint data can be a severe data leak,
	 * only allow root to have these.
	 */
	if (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
		return -EPERM;

	return 0;
}
","static int perf_trace_event_perm(struct ftrace_event_call *tp_event,
				 struct perf_event *p_event)
 {
 	/* The ftrace function trace is allowed only for root. */
 	if (ftrace_event_is_function(tp_event) &&
	    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	/* No tracing, just counting, so no obvious leak */
	if (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))
		return 0;

	/* Some events are ok to be traced by non-root users... */
	if (p_event->attach_state == PERF_ATTACH_TASK) {
		if (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)
			return 0;
	}

	/*
	 * ...otherwise raw tracepoint data can be a severe data leak,
	 * only allow root to have these.
	 */
	if (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
		return -EPERM;

	return 0;
}
",C,"	    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
","	    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))
",,"@@ -26,7 +26,7 @@ static int perf_trace_event_perm(struct ftrace_event_call *tp_event,
 {
 	/* The ftrace function trace is allowed only for root. */
 	if (ftrace_event_is_function(tp_event) &&
-	    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))
+	    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	/* No tracing, just counting, so no obvious leak */",linux,12ae030d54ef250706da5642fc7697cc60ad0df7,5e01dc7b26d9f24f39abace5da98ccbd6a5ceb52,1,"static int perf_trace_event_perm(struct ftrace_event_call *tp_event,
				 struct perf_event *p_event)
 {
 	/* The ftrace function trace is allowed only for root. */
 	if (ftrace_event_is_function(tp_event) &&
//flaw_line_below:
	    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))
//fix_flaw_line_below:
//	    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	/* No tracing, just counting, so no obvious leak */
	if (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))
		return 0;

	/* Some events are ok to be traced by non-root users... */
	if (p_event->attach_state == PERF_ATTACH_TASK) {
		if (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)
			return 0;
	}

	/*
	 * ...otherwise raw tracepoint data can be a severe data leak,
	 * only allow root to have these.
	 */
	if (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
		return -EPERM;

	return 0;
}
",179220,"static int perf_trace_event_perm(struct ftrace_event_call *tp_event,
				 struct perf_event *p_event)
 {
 	/* The ftrace function trace is allowed only for root. */
 	if (ftrace_event_is_function(tp_event) &&
	    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	/* No tracing, just counting, so no obvious leak */
	if (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))
		return 0;

	/* Some events are ok to be traced by non-root users... */
	if (p_event->attach_state == PERF_ATTACH_TASK) {
		if (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)
			return 0;
	}

	/*
	 * ...otherwise raw tracepoint data can be a severe data leak,
	 * only allow root to have these.
	 */
	if (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
		return -EPERM;

	return 0;
}
","static int perf_trace_event_perm(struct ftrace_event_call *tp_event,
				 struct perf_event *p_event)
 {
 	/* The ftrace function trace is allowed only for root. */
 	if (ftrace_event_is_function(tp_event) &&
	    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	/* No tracing, just counting, so no obvious leak */
	if (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))
		return 0;

	/* Some events are ok to be traced by non-root users... */
	if (p_event->attach_state == PERF_ATTACH_TASK) {
		if (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)
			return 0;
	}

	/*
	 * ...otherwise raw tracepoint data can be a severe data leak,
	 * only allow root to have these.
	 */
	if (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
		return -EPERM;

	return 0;
}
","The `perf_trace_event_perm` function is designed to manage permissions for tracing events in a performance monitoring context. It first checks if the event is a function trace and whether the caller has the necessary administrative capabilities; if not, it returns a permission error. The function then verifies if the event is configured to sample raw data, which is restricted to prevent data leaks. It allows non-root users to trace certain events if they meet specific criteria. Ultimately, it ensures that sensitive raw tracepoint data is only accessible to users with root privileges, enhancing system security.","This function manages permissions for tracing performance events, ensuring that only authorized users can access sensitive data. It first checks if the event is a function trace and whether the caller has the necessary administrative rights; if not, it denies access. The function also assesses if the event is set to sample raw data, which is restricted to prevent potential data leaks. While it allows certain events to be traced by non-administrative users under specific conditions, it ultimately enforces strict access controls to safeguard sensitive information from unauthorized access.","The vulnerability in the original code stemmed from the improper handling of permissions for function tracing, allowing normal users to enable it when the paranoid level was set to ""1."" This oversight meant that users could potentially access sensitive tracing data, leading to security risks. The fix involved modifying the permission checks to utilize the `perf_paranoid_tracepoint_raw()` function, which ensures that only users with the appropriate administrative capabilities can enable function tracing. By enforcing this stricter check, the updated code effectively prevents unauthorized access to sensitive tracing functionalities, thereby enhancing system security.","The vulnerability in the original code allowed normal users to enable function tracing due to an inadequate permission check, as the default paranoid level permitted such access. This oversight posed a security risk, as it could lead to unauthorized users gaining access to sensitive tracing information. The fix involved adjusting the permission checks to ensure that only users with the appropriate administrative rights could enable function tracing. By implementing a stricter access control mechanism, the updated code effectively mitigated the risk of unauthorized access, thereby enhancing the overall security of the system.","The vulnerability was fixed by modifying the permission checks related to function tracing. The code now uses `perf_paranoid_tracepoint_raw()` instead of relying solely on `perf_paranoid_kernel()`, which previously allowed normal users to enable function tracing when the paranoid level was set to ""1."" By ensuring that only users with the necessary administrative capabilities can pass the check, the updated code restricts access to sensitive tracing functionalities. This change effectively prevents unauthorized users from enabling function tracing, thereby addressing the security risk associated with the previous implementation.","The vulnerability was fixed by implementing stricter permission checks for enabling function tracing. The updated code ensures that only users with the appropriate administrative rights can access this functionality, replacing the previous checks that allowed normal users to enable tracing under certain conditions. By refining the access control mechanism, the changes effectively prevent unauthorized users from gaining access to sensitive tracing information. This enhancement significantly improves the security posture of the system, ensuring that only authorized personnel can perform operations that could expose critical data.","CWE-285, CWE-732, CWE-269, CWE-264, CWE-284, CWE-693, CWE-642, CWE-266, CWE-732, CWE-250",N,-1
23,23,179221,179221,,Local,Not required,,CVE-2013-2929,https://www.cvedetails.com/cve/CVE-2013-2929/,CWE-264,Medium,Partial,Partial,,2013-12-09,3.3,"The Linux kernel before 3.12.2 does not properly use the get_dumpable function, which allows local users to bypass intended ptrace restrictions or obtain sensitive information from IA64 scratch registers via a crafted application, related to kernel/ptrace.c and arch/ia64/include/asm/processor.h.",2018-04-27,Bypass +Info ,2,https://github.com/torvalds/linux/commit/d049f74f2dbe71354d43d393ac3a188947811348,d049f74f2dbe71354d43d393ac3a188947811348,"exec/ptrace: fix get_dumpable() incorrect tests

The get_dumpable() return value is not boolean.  Most users of the
function actually want to be testing for non-SUID_DUMP_USER(1) rather than
SUID_DUMP_DISABLE(0).  The SUID_DUMP_ROOT(2) is also considered a
protected state.  Almost all places did this correctly, excepting the two
places fixed in this patch.

Wrong logic:
    if (dumpable == SUID_DUMP_DISABLE) { /* be protective */ }
        or
    if (dumpable == 0) { /* be protective */ }
        or
    if (!dumpable) { /* be protective */ }

Correct logic:
    if (dumpable != SUID_DUMP_USER) { /* be protective */ }
        or
    if (dumpable != 1) { /* be protective */ }

Without this patch, if the system had set the sysctl fs/suid_dumpable=2, a
user was able to ptrace attach to processes that had dropped privileges to
that user.  (This may have been partially mitigated if Yama was enabled.)

The macros have been moved into the file that declares get/set_dumpable(),
which means things like the ia64 code can see them too.

CVE-2013-2929

Reported-by: Vasily Kulikov <segoon@openwall.com>
Signed-off-by: Kees Cook <keescook@chromium.org>
Cc: ""Luck, Tony"" <tony.luck@intel.com>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: ""Eric W. Biederman"" <ebiederm@xmission.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",1,kernel/ptrace.c,"{""sha"": ""5a84b3a5074158d8b0fe975d5def50689c8c735d"", ""filename"": ""arch/ia64/include/asm/processor.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d049f74f2dbe71354d43d393ac3a188947811348/arch/ia64/include/asm/processor.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d049f74f2dbe71354d43d393ac3a188947811348/arch/ia64/include/asm/processor.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/ia64/include/asm/processor.h?ref=d049f74f2dbe71354d43d393ac3a188947811348"", ""patch"": ""@@ -319,7 +319,7 @@ struct thread_struct {\n \tregs->loadrs = 0;\t\t\t\t\t\t\t\t\t\\\n \tregs->r8 = get_dumpable(current->mm);\t/* set \""don't zap registers\"" flag */\t\t\\\n \tregs->r12 = new_sp - 16;\t/* allocate 16 byte scratch area */\t\t\t\\\n-\tif (unlikely(!get_dumpable(current->mm))) {\t\t\t\t\t\t\t\\\n+\tif (unlikely(get_dumpable(current->mm) != SUID_DUMP_USER)) {\t\\\n \t\t/*\t\t\t\t\t\t\t\t\t\t\\\n \t\t * Zap scratch regs to avoid leaking bits between processes with different\t\\\n \t\t * uid/privileges.\t\t\t\t\t\t\t\t\\""}<_**next**_>{""sha"": ""12120620f0409660555aec739e5c0441abb995ee"", ""filename"": ""fs/exec.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/d049f74f2dbe71354d43d393ac3a188947811348/fs/exec.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d049f74f2dbe71354d43d393ac3a188947811348/fs/exec.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/exec.c?ref=d049f74f2dbe71354d43d393ac3a188947811348"", ""patch"": ""@@ -1669,6 +1669,12 @@ int __get_dumpable(unsigned long mm_flags)\n \treturn (ret > SUID_DUMP_USER) ? SUID_DUMP_ROOT : ret;\n }\n \n+/*\n+ * This returns the actual value of the suid_dumpable flag. For things\n+ * that are using this for checking for privilege transitions, it must\n+ * test against SUID_DUMP_USER rather than treating it as a boolean\n+ * value.\n+ */\n int get_dumpable(struct mm_struct *mm)\n {\n \treturn __get_dumpable(mm->flags);""}<_**next**_>{""sha"": ""7554fd410bcc35ff1a4d56e1e3ae99c62a78bcad"", ""filename"": ""include/linux/binfmts.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/d049f74f2dbe71354d43d393ac3a188947811348/include/linux/binfmts.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d049f74f2dbe71354d43d393ac3a188947811348/include/linux/binfmts.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/binfmts.h?ref=d049f74f2dbe71354d43d393ac3a188947811348"", ""patch"": ""@@ -99,9 +99,6 @@ extern void setup_new_exec(struct linux_binprm * bprm);\n extern void would_dump(struct linux_binprm *, struct file *);\n \n extern int suid_dumpable;\n-#define SUID_DUMP_DISABLE\t0\t/* No setuid dumping */\n-#define SUID_DUMP_USER\t\t1\t/* Dump as user of process */\n-#define SUID_DUMP_ROOT\t\t2\t/* Dump as root */\n \n /* Stack area protections */\n #define EXSTACK_DEFAULT   0\t/* Whatever the arch defaults to */""}<_**next**_>{""sha"": ""f7efc86046522c2722501f5967d65983162fa78e"", ""filename"": ""include/linux/sched.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/d049f74f2dbe71354d43d393ac3a188947811348/include/linux/sched.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d049f74f2dbe71354d43d393ac3a188947811348/include/linux/sched.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/sched.h?ref=d049f74f2dbe71354d43d393ac3a188947811348"", ""patch"": ""@@ -323,6 +323,10 @@ static inline void arch_pick_mmap_layout(struct mm_struct *mm) {}\n extern void set_dumpable(struct mm_struct *mm, int value);\n extern int get_dumpable(struct mm_struct *mm);\n \n+#define SUID_DUMP_DISABLE\t0\t/* No setuid dumping */\n+#define SUID_DUMP_USER\t\t1\t/* Dump as user of process */\n+#define SUID_DUMP_ROOT\t\t2\t/* Dump as root */\n+\n /* mm flags */\n /* dumpable bits */\n #define MMF_DUMPABLE      0  /* core dump is permitted */""}<_**next**_>{""sha"": ""1f4bcb3cc21cee5bcfd1b4e13a77eeff2af23a2b"", ""filename"": ""kernel/ptrace.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/d049f74f2dbe71354d43d393ac3a188947811348/kernel/ptrace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d049f74f2dbe71354d43d393ac3a188947811348/kernel/ptrace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/ptrace.c?ref=d049f74f2dbe71354d43d393ac3a188947811348"", ""patch"": ""@@ -257,7 +257,8 @@ static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n \tif (task->mm)\n \t\tdumpable = get_dumpable(task->mm);\n \trcu_read_lock();\n-\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n+\tif (dumpable != SUID_DUMP_USER &&\n+\t    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n \t\trcu_read_unlock();\n \t\treturn -EPERM;\n \t}""}","static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;

	/* May we inspect the given task?
	 * This check is used both for attaching with ptrace
	 * and for allowing access to sensitive information in /proc.
	 *
	 * ptrace_attach denies several cases that /proc allows
	 * because setting up the necessary parent/child relationship
	 * or halting the specified task is impossible.
	 */
	int dumpable = 0;
	/* Don't let security modules deny introspection */
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
	if (dumpable != SUID_DUMP_USER &&
	    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();

	return security_ptrace_access_check(task, mode);
}
","static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;

	/* May we inspect the given task?
	 * This check is used both for attaching with ptrace
	 * and for allowing access to sensitive information in /proc.
	 *
	 * ptrace_attach denies several cases that /proc allows
	 * because setting up the necessary parent/child relationship
	 * or halting the specified task is impossible.
	 */
	int dumpable = 0;
	/* Don't let security modules deny introspection */
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();

	return security_ptrace_access_check(task, mode);
}
",C,"	if (dumpable != SUID_DUMP_USER &&
	    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
","	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
",,"@@ -257,7 +257,8 @@ static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
-	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
+	if (dumpable != SUID_DUMP_USER &&
+	    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}",linux,d049f74f2dbe71354d43d393ac3a188947811348,1c3fc3e5cc8a81d21b199cb739d5d9c51f3688f4,1,"static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;

	/* May we inspect the given task?
	 * This check is used both for attaching with ptrace
	 * and for allowing access to sensitive information in /proc.
	 *
	 * ptrace_attach denies several cases that /proc allows
	 * because setting up the necessary parent/child relationship
	 * or halting the specified task is impossible.
	 */
	int dumpable = 0;
	/* Don't let security modules deny introspection */
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
//flaw_line_below:
	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
//fix_flaw_line_below:
//	if (dumpable != SUID_DUMP_USER &&
//fix_flaw_line_below:
//	    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();

	return security_ptrace_access_check(task, mode);
}
",179221,"static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;

	/* May we inspect the given task?
	 * This check is used both for attaching with ptrace
	 * and for allowing access to sensitive information in /proc.
	 *
	 * ptrace_attach denies several cases that /proc allows
	 * because setting up the necessary parent/child relationship
	 * or halting the specified task is impossible.
	 */
	int dumpable = 0;
	/* Don't let security modules deny introspection */
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();

	return security_ptrace_access_check(task, mode);
}
","static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;

	/* May we inspect the given task?
	 * This check is used both for attaching with ptrace
	 * and for allowing access to sensitive information in /proc.
	 *
	 * ptrace_attach denies several cases that /proc allows
	 * because setting up the necessary parent/child relationship
	 * or halting the specified task is impossible.
	 */
	int dumpable = 0;
	/* Don't let security modules deny introspection */
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
	if (dumpable != SUID_DUMP_USER &&
	    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
	rcu_read_unlock();

	return security_ptrace_access_check(task, mode);
}
","The function `__ptrace_may_access` determines whether the current process can access another specified task's resources, primarily for debugging or inspection purposes using the `ptrace` system call. It first checks if the tasks belong to the same thread group, allowing access without further checks. If not, it retrieves the credentials of the target task and compares them with the current process's credentials to ensure they match in terms of user and group IDs. If the credentials are compatible or if the current process has the necessary capabilities, it checks if the target task's memory is dumpable. Finally, it invokes a security module to perform additional access checks before granting or denying permission.","The code defines a function that assesses whether the current process has the right to access another process's resources for debugging or inspection purposes. It first checks if both processes belong to the same group, allowing immediate access if they do. If not, it retrieves and compares the credentials of both processes to ensure they match in terms of user and group identities. If the credentials align or the current process possesses the necessary permissions, it checks if the target process's memory can be accessed. Finally, it performs additional security checks before granting or denying access.","The vulnerability in the original code stemmed from an incorrect interpretation of the return value from the `get_dumpable()` function, which was treated as a boolean. This led to a situation where processes marked with `SUID_DUMP_ROOT` could be accessed via `ptrace`, even after dropping privileges, allowing unauthorized access. The fix involved changing the logic to check if the return value was not equal to `SUID_DUMP_USER`, ensuring that only processes with the appropriate dumpable state could be accessed. This adjustment effectively closed the security loophole, preventing unauthorized `ptrace` access to sensitive processes.","The vulnerability in the original code arose from incorrectly treating the return value of a function as a boolean, leading to improper access control for processes based on their dumpable state. Specifically, the logic allowed unauthorized processes to be accessed when they should have been protected, particularly if they had dropped privileges. The fix involved revising the condition to check for a specific protected state rather than a boolean interpretation, ensuring that only processes with the correct permissions could be accessed. This change effectively mitigated the risk of unauthorized access to sensitive processes.","The vulnerability was fixed by correcting the logic that evaluates the return value of the `get_dumpable()` function. Previously, the code incorrectly checked if the return value was equal to `SUID_DUMP_DISABLE` or treated it as a boolean, which allowed unauthorized access to processes. The updated logic now checks if the return value is not equal to `SUID_DUMP_USER`, ensuring that only processes with the appropriate dumpable state can be accessed. This change prevents processes marked as `SUID_DUMP_ROOT` from being accessed via `ptrace`, thereby enhancing security and protecting sensitive processes from unauthorized inspection.","The vulnerability was addressed by revising the logic that evaluated the return value from a function related to process memory access permissions. The original implementation incorrectly treated this return value as a boolean, which allowed unauthorized access to processes that should have been protected. The fix involved changing the condition to ensure that access was only granted if the process was in a specific, permitted state. This adjustment effectively restricted access to sensitive processes, preventing unauthorized users from attaching to or inspecting them, thereby enhancing overall security.","CWE-252, CWE-697, CWE-754, CWE-269, CWE-284, CWE-732, CWE-266, CWE-272, CWE-287, CWE-273",N,-1
24,24,179266,179266,,Local,Not required,,CVE-2013-1957,https://www.cvedetails.com/cve/CVE-2013-1957/,CWE-264,Medium,Complete,,,2013-04-24,4.7,"The clone_mnt function in fs/namespace.c in the Linux kernel before 3.8.6 does not properly restrict changes to the MNT_READONLY flag, which allows local users to bypass an intended read-only property of a filesystem by leveraging a separate mount namespace.",2013-04-25,Bypass ,4,https://github.com/torvalds/linux/commit/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9,132c94e31b8bca8ea921f9f96a57d684fa4ae0a9,"vfs: Carefully propogate mounts across user namespaces

As a matter of policy MNT_READONLY should not be changable if the
original mounter had more privileges than creator of the mount
namespace.

Add the flag CL_UNPRIVILEGED to note when we are copying a mount from
a mount namespace that requires more privileges to a mount namespace
that requires fewer privileges.

When the CL_UNPRIVILEGED flag is set cause clone_mnt to set MNT_NO_REMOUNT
if any of the mnt flags that should never be changed are set.

This protects both mount propagation and the initial creation of a less
privileged mount namespace.

Cc: stable@vger.kernel.org
Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
Reported-by: Andy Lutomirski <luto@amacapital.net>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",0,fs/namespace.c,"{""sha"": ""968d4c5eae03aa18b1326e09371aa5ada795939e"", ""filename"": ""fs/namespace.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9/fs/namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9/fs/namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namespace.c?ref=132c94e31b8bca8ea921f9f96a57d684fa4ae0a9"", ""patch"": ""@@ -798,6 +798,10 @@ static struct mount *clone_mnt(struct mount *old, struct dentry *root,\n \t}\n \n \tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;\n+\t/* Don't allow unprivileged users to change mount flags */\n+\tif ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))\n+\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n+\n \tatomic_inc(&sb->s_active);\n \tmnt->mnt.mnt_sb = sb;\n \tmnt->mnt.mnt_root = dget(root);\n@@ -2342,7 +2346,7 @@ static struct mnt_namespace *dup_mnt_ns(struct mnt_namespace *mnt_ns,\n \t/* First pass: copy the tree topology */\n \tcopy_flags = CL_COPY_ALL | CL_EXPIRE;\n \tif (user_ns != mnt_ns->user_ns)\n-\t\tcopy_flags |= CL_SHARED_TO_SLAVE;\n+\t\tcopy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;\n \tnew = copy_tree(old, old->mnt.mnt_root, copy_flags);\n \tif (IS_ERR(new)) {\n \t\tup_write(&namespace_sem);""}<_**next**_>{""sha"": ""8b29d2164da6aef6edb88b9872368c849e658530"", ""filename"": ""fs/pnode.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9/fs/pnode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9/fs/pnode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.c?ref=132c94e31b8bca8ea921f9f96a57d684fa4ae0a9"", ""patch"": ""@@ -9,6 +9,7 @@\n #include <linux/mnt_namespace.h>\n #include <linux/mount.h>\n #include <linux/fs.h>\n+#include <linux/nsproxy.h>\n #include \""internal.h\""\n #include \""pnode.h\""\n \n@@ -220,6 +221,7 @@ static struct mount *get_source(struct mount *dest,\n int propagate_mnt(struct mount *dest_mnt, struct dentry *dest_dentry,\n \t\t    struct mount *source_mnt, struct list_head *tree_list)\n {\n+\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n \tstruct mount *m, *child;\n \tint ret = 0;\n \tstruct mount *prev_dest_mnt = dest_mnt;\n@@ -237,6 +239,10 @@ int propagate_mnt(struct mount *dest_mnt, struct dentry *dest_dentry,\n \n \t\tsource =  get_source(m, prev_dest_mnt, prev_src_mnt, &type);\n \n+\t\t/* Notice when we are propagating across user namespaces */\n+\t\tif (m->mnt_ns->user_ns != user_ns)\n+\t\t\ttype |= CL_UNPRIVILEGED;\n+\n \t\tchild = copy_tree(source, source->mnt.mnt_root, type);\n \t\tif (IS_ERR(child)) {\n \t\t\tret = PTR_ERR(child);""}<_**next**_>{""sha"": ""a0493d5ebfbf52be2eb07a794df459ab2a32cd6a"", ""filename"": ""fs/pnode.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9/fs/pnode.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9/fs/pnode.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.h?ref=132c94e31b8bca8ea921f9f96a57d684fa4ae0a9"", ""patch"": ""@@ -23,6 +23,7 @@\n #define CL_MAKE_SHARED \t\t0x08\n #define CL_PRIVATE \t\t0x10\n #define CL_SHARED_TO_SLAVE\t0x20\n+#define CL_UNPRIVILEGED\t\t0x40\n \n static inline void set_mnt_shared(struct mount *mnt)\n {""}","static struct mount *clone_mnt(struct mount *old, struct dentry *root,
					int flag)
{
	struct super_block *sb = old->mnt.mnt_sb;
	struct mount *mnt;
	int err;

	mnt = alloc_vfsmnt(old->mnt_devname);
	if (!mnt)
		return ERR_PTR(-ENOMEM);

	if (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))
		mnt->mnt_group_id = 0; /* not a peer of original */
	else
		mnt->mnt_group_id = old->mnt_group_id;

	if ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {
		err = mnt_alloc_group_id(mnt);
		if (err)
			goto out_free;
 	}
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;
	/* Don't allow unprivileged users to change mount flags */
	if ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))
		mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;

 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
	mnt->mnt_mountpoint = mnt->mnt.mnt_root;
	mnt->mnt_parent = mnt;
	br_write_lock(&vfsmount_lock);
	list_add_tail(&mnt->mnt_instance, &sb->s_mounts);
	br_write_unlock(&vfsmount_lock);

	if ((flag & CL_SLAVE) ||
	    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {
		list_add(&mnt->mnt_slave, &old->mnt_slave_list);
		mnt->mnt_master = old;
		CLEAR_MNT_SHARED(mnt);
	} else if (!(flag & CL_PRIVATE)) {
		if ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))
			list_add(&mnt->mnt_share, &old->mnt_share);
		if (IS_MNT_SLAVE(old))
			list_add(&mnt->mnt_slave, &old->mnt_slave);
		mnt->mnt_master = old->mnt_master;
	}
	if (flag & CL_MAKE_SHARED)
		set_mnt_shared(mnt);

	/* stick the duplicate mount on the same expiry list
	 * as the original if that was on one */
	if (flag & CL_EXPIRE) {
		if (!list_empty(&old->mnt_expire))
			list_add(&mnt->mnt_expire, &old->mnt_expire);
	}

	return mnt;

 out_free:
	free_vfsmnt(mnt);
	return ERR_PTR(err);
}
","static struct mount *clone_mnt(struct mount *old, struct dentry *root,
					int flag)
{
	struct super_block *sb = old->mnt.mnt_sb;
	struct mount *mnt;
	int err;

	mnt = alloc_vfsmnt(old->mnt_devname);
	if (!mnt)
		return ERR_PTR(-ENOMEM);

	if (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))
		mnt->mnt_group_id = 0; /* not a peer of original */
	else
		mnt->mnt_group_id = old->mnt_group_id;

	if ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {
		err = mnt_alloc_group_id(mnt);
		if (err)
			goto out_free;
 	}
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;
 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
	mnt->mnt_mountpoint = mnt->mnt.mnt_root;
	mnt->mnt_parent = mnt;
	br_write_lock(&vfsmount_lock);
	list_add_tail(&mnt->mnt_instance, &sb->s_mounts);
	br_write_unlock(&vfsmount_lock);

	if ((flag & CL_SLAVE) ||
	    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {
		list_add(&mnt->mnt_slave, &old->mnt_slave_list);
		mnt->mnt_master = old;
		CLEAR_MNT_SHARED(mnt);
	} else if (!(flag & CL_PRIVATE)) {
		if ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))
			list_add(&mnt->mnt_share, &old->mnt_share);
		if (IS_MNT_SLAVE(old))
			list_add(&mnt->mnt_slave, &old->mnt_slave);
		mnt->mnt_master = old->mnt_master;
	}
	if (flag & CL_MAKE_SHARED)
		set_mnt_shared(mnt);

	/* stick the duplicate mount on the same expiry list
	 * as the original if that was on one */
	if (flag & CL_EXPIRE) {
		if (!list_empty(&old->mnt_expire))
			list_add(&mnt->mnt_expire, &old->mnt_expire);
	}

	return mnt;

 out_free:
	free_vfsmnt(mnt);
	return ERR_PTR(err);
}
",C,"	/* Don't allow unprivileged users to change mount flags */
	if ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))
		mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;

",,,"@@ -798,6 +798,10 @@ static struct mount *clone_mnt(struct mount *old, struct dentry *root,
 	}
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;
+	/* Don't allow unprivileged users to change mount flags */
+	if ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))
+		mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;
+
 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
@@ -2342,7 +2346,7 @@ static struct mnt_namespace *dup_mnt_ns(struct mnt_namespace *mnt_ns,
 	/* First pass: copy the tree topology */
 	copy_flags = CL_COPY_ALL | CL_EXPIRE;
 	if (user_ns != mnt_ns->user_ns)
-		copy_flags |= CL_SHARED_TO_SLAVE;
+		copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;
 	new = copy_tree(old, old->mnt.mnt_root, copy_flags);
 	if (IS_ERR(new)) {
 		up_write(&namespace_sem);",linux,132c94e31b8bca8ea921f9f96a57d684fa4ae0a9,90563b198e4c6674c63672fae1923da467215f45,1,"static struct mount *clone_mnt(struct mount *old, struct dentry *root,
					int flag)
{
	struct super_block *sb = old->mnt.mnt_sb;
	struct mount *mnt;
	int err;

	mnt = alloc_vfsmnt(old->mnt_devname);
	if (!mnt)
		return ERR_PTR(-ENOMEM);

	if (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))
		mnt->mnt_group_id = 0; /* not a peer of original */
	else
		mnt->mnt_group_id = old->mnt_group_id;

	if ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {
		err = mnt_alloc_group_id(mnt);
		if (err)
			goto out_free;
 	}
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;
//fix_flaw_line_below:
//	/* Don't allow unprivileged users to change mount flags */
//fix_flaw_line_below:
//	if ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))
//fix_flaw_line_below:
//		mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;
//fix_flaw_line_below:
//
 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
	mnt->mnt_mountpoint = mnt->mnt.mnt_root;
	mnt->mnt_parent = mnt;
	br_write_lock(&vfsmount_lock);
	list_add_tail(&mnt->mnt_instance, &sb->s_mounts);
	br_write_unlock(&vfsmount_lock);

	if ((flag & CL_SLAVE) ||
	    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {
		list_add(&mnt->mnt_slave, &old->mnt_slave_list);
		mnt->mnt_master = old;
		CLEAR_MNT_SHARED(mnt);
	} else if (!(flag & CL_PRIVATE)) {
		if ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))
			list_add(&mnt->mnt_share, &old->mnt_share);
		if (IS_MNT_SLAVE(old))
			list_add(&mnt->mnt_slave, &old->mnt_slave);
		mnt->mnt_master = old->mnt_master;
	}
	if (flag & CL_MAKE_SHARED)
		set_mnt_shared(mnt);

	/* stick the duplicate mount on the same expiry list
	 * as the original if that was on one */
	if (flag & CL_EXPIRE) {
		if (!list_empty(&old->mnt_expire))
			list_add(&mnt->mnt_expire, &old->mnt_expire);
	}

	return mnt;

 out_free:
	free_vfsmnt(mnt);
	return ERR_PTR(err);
}
",179266,"static struct mount *clone_mnt(struct mount *old, struct dentry *root,
					int flag)
{
	struct super_block *sb = old->mnt.mnt_sb;
	struct mount *mnt;
	int err;

	mnt = alloc_vfsmnt(old->mnt_devname);
	if (!mnt)
		return ERR_PTR(-ENOMEM);

	if (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))
		mnt->mnt_group_id = 0; /* not a peer of original */
	else
		mnt->mnt_group_id = old->mnt_group_id;

	if ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {
		err = mnt_alloc_group_id(mnt);
		if (err)
			goto out_free;
 	}
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;
 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
	mnt->mnt_mountpoint = mnt->mnt.mnt_root;
	mnt->mnt_parent = mnt;
	br_write_lock(&vfsmount_lock);
	list_add_tail(&mnt->mnt_instance, &sb->s_mounts);
	br_write_unlock(&vfsmount_lock);

	if ((flag & CL_SLAVE) ||
	    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {
		list_add(&mnt->mnt_slave, &old->mnt_slave_list);
		mnt->mnt_master = old;
		CLEAR_MNT_SHARED(mnt);
	} else if (!(flag & CL_PRIVATE)) {
		if ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))
			list_add(&mnt->mnt_share, &old->mnt_share);
		if (IS_MNT_SLAVE(old))
			list_add(&mnt->mnt_slave, &old->mnt_slave);
		mnt->mnt_master = old->mnt_master;
	}
	if (flag & CL_MAKE_SHARED)
		set_mnt_shared(mnt);

	/* stick the duplicate mount on the same expiry list
	 * as the original if that was on one */
	if (flag & CL_EXPIRE) {
		if (!list_empty(&old->mnt_expire))
			list_add(&mnt->mnt_expire, &old->mnt_expire);
	}

	return mnt;

 out_free:
	free_vfsmnt(mnt);
	return ERR_PTR(err);
}
","static struct mount *clone_mnt(struct mount *old, struct dentry *root,
					int flag)
{
	struct super_block *sb = old->mnt.mnt_sb;
	struct mount *mnt;
	int err;

	mnt = alloc_vfsmnt(old->mnt_devname);
	if (!mnt)
		return ERR_PTR(-ENOMEM);

	if (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))
		mnt->mnt_group_id = 0; /* not a peer of original */
	else
		mnt->mnt_group_id = old->mnt_group_id;

	if ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {
		err = mnt_alloc_group_id(mnt);
		if (err)
			goto out_free;
 	}
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;
	/* Don't allow unprivileged users to change mount flags */
	if ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))
		mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;

 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
	mnt->mnt_mountpoint = mnt->mnt.mnt_root;
	mnt->mnt_parent = mnt;
	br_write_lock(&vfsmount_lock);
	list_add_tail(&mnt->mnt_instance, &sb->s_mounts);
	br_write_unlock(&vfsmount_lock);

	if ((flag & CL_SLAVE) ||
	    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {
		list_add(&mnt->mnt_slave, &old->mnt_slave_list);
		mnt->mnt_master = old;
		CLEAR_MNT_SHARED(mnt);
	} else if (!(flag & CL_PRIVATE)) {
		if ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))
			list_add(&mnt->mnt_share, &old->mnt_share);
		if (IS_MNT_SLAVE(old))
			list_add(&mnt->mnt_slave, &old->mnt_slave);
		mnt->mnt_master = old->mnt_master;
	}
	if (flag & CL_MAKE_SHARED)
		set_mnt_shared(mnt);

	/* stick the duplicate mount on the same expiry list
	 * as the original if that was on one */
	if (flag & CL_EXPIRE) {
		if (!list_empty(&old->mnt_expire))
			list_add(&mnt->mnt_expire, &old->mnt_expire);
	}

	return mnt;

 out_free:
	free_vfsmnt(mnt);
	return ERR_PTR(err);
}
","The `clone_mnt` function creates a duplicate mount structure based on an existing mount (`old`) and a specified root directory (`root`), while considering various flags that dictate the nature of the clone. It allocates memory for the new mount and sets its properties, such as the superblock and root dentry, while managing mount group IDs based on the provided flags. The function also handles relationships between the original and cloned mounts, including shared and slave mount configurations. If any errors occur during allocation or setup, it cleans up and returns an error pointer; otherwise, it returns the newly created mount structure.","The provided code defines a function that duplicates a mount structure based on an existing one, allowing for the specification of various flags that influence the characteristics of the new mount. It allocates memory for the new structure and initializes its properties, including linking it to the appropriate superblock and root directory. The function manages relationships between the original and cloned mounts, determining whether they should be shared or treated as independent. It also handles potential errors during the process, ensuring proper cleanup if necessary, and ultimately returns the newly created mount structure or an error indication.","The vulnerability in the original code stemmed from allowing unprivileged users to modify mount flags, particularly the `MNT_READONLY` flag, which could lead to privilege escalation or unintended changes in mount behavior. The fix introduced a new flag, `CL_UNPRIVILEGED`, to indicate when a mount is being copied from a more privileged namespace to a less privileged one. When this flag is set, the code now checks if any critical mount flags are already set; if so, it applies `MNT_NO_REMOUNT` to prevent changes, thereby ensuring that sensitive mount properties remain intact and secure during the cloning process.","The vulnerability in the original code allowed unprivileged users to alter critical mount flags, such as making a mount read-only, which could lead to privilege escalation or unintended system behavior. The fix introduced a mechanism to track when a mount is being copied from a more privileged context to a less privileged one by using a specific flag. When this flag is set, the code ensures that any sensitive mount properties that should remain unchanged are protected by preventing modifications, thereby maintaining the integrity and security of the mount namespace during the cloning process.","The vulnerability was fixed by introducing the `CL_UNPRIVILEGED` flag to indicate when a mount is being copied from a more privileged namespace to a less privileged one. In the modified code, when this flag is set, the function checks if any critical mount flags, such as `MNT_READONLY`, are already set. If they are, the code applies `MNT_NO_REMOUNT`, which prevents any changes to these sensitive flags. This ensures that the original mount's properties remain intact and secure, effectively preventing unprivileged users from altering important mount configurations during the cloning process.","The vulnerability was addressed by implementing a mechanism to track when a mount is being copied from a more privileged context to a less privileged one. A specific flag was introduced to indicate this scenario, and when it is set, the code checks for any critical mount properties that should remain unchanged. If such properties are detected, the code prevents any modifications to them, thereby safeguarding the integrity of the mount configuration. This ensures that unprivileged users cannot alter sensitive settings, thus enhancing the security of the mount namespace during the cloning process.","CWE-269,CWE-285,CWE-264,CWE-266,CWE-732,CWE-668,CWE-284,CWE-250,CWE-269,CWE-273",Y,3
25,25,179269,179269,,Local,Not required,,CVE-2013-1956,https://www.cvedetails.com/cve/CVE-2013-1956/,CWE-264,Low,,Partial,,2013-04-24,2.1,"The create_user_ns function in kernel/user_namespace.c in the Linux kernel before 3.8.6 does not check whether a chroot directory exists that differs from the namespace root directory, which allows local users to bypass intended filesystem restrictions via a crafted clone system call.",2013-05-01,Bypass ,9,https://github.com/torvalds/linux/commit/3151527ee007b73a0ebd296010f1c0454a919c7d,3151527ee007b73a0ebd296010f1c0454a919c7d,"userns:  Don't allow creation if the user is chrooted

Guarantee that the policy of which files may be access that is
established by setting the root directory will not be violated
by user namespaces by verifying that the root directory points
to the root of the mount namespace at the time of user namespace
creation.

Changing the root is a privileged operation, and as a matter of policy
it serves to limit unprivileged processes to files below the current
root directory.

For reasons of simplicity and comprehensibility the privilege to
change the root directory is gated solely on the CAP_SYS_CHROOT
capability in the user namespace.  Therefore when creating a user
namespace we must ensure that the policy of which files may be access
can not be violated by changing the root directory.

Anyone who runs a processes in a chroot and would like to use user
namespace can setup the same view of filesystems with a mount
namespace instead.  With this result that this is not a practical
limitation for using user namespaces.

Cc: stable@vger.kernel.org
Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
Reported-by: Andy Lutomirski <luto@amacapital.net>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",0,kernel/user_namespace.c,"{""sha"": ""a3035223d4218c13ac6db83f8d5444e454346c2f"", ""filename"": ""fs/namespace.c"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/torvalds/linux/blob/3151527ee007b73a0ebd296010f1c0454a919c7d/fs/namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/3151527ee007b73a0ebd296010f1c0454a919c7d/fs/namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namespace.c?ref=3151527ee007b73a0ebd296010f1c0454a919c7d"", ""patch"": ""@@ -2732,6 +2732,30 @@ bool our_mnt(struct vfsmount *mnt)\n \treturn check_mnt(real_mount(mnt));\n }\n \n+bool current_chrooted(void)\n+{\n+\t/* Does the current process have a non-standard root */\n+\tstruct path ns_root;\n+\tstruct path fs_root;\n+\tbool chrooted;\n+\n+\t/* Find the namespace root */\n+\tns_root.mnt = &current->nsproxy->mnt_ns->root->mnt;\n+\tns_root.dentry = ns_root.mnt->mnt_root;\n+\tpath_get(&ns_root);\n+\twhile (d_mountpoint(ns_root.dentry) && follow_down_one(&ns_root))\n+\t\t;\n+\n+\tget_fs_root(current->fs, &fs_root);\n+\n+\tchrooted = !path_equal(&fs_root, &ns_root);\n+\n+\tpath_put(&fs_root);\n+\tpath_put(&ns_root);\n+\n+\treturn chrooted;\n+}\n+\n static void *mntns_get(struct task_struct *task)\n {\n \tstruct mnt_namespace *ns = NULL;""}<_**next**_>{""sha"": ""2b93a9a5a1e6b8ef4a15a6aaf36ade3b48bd0d98"", ""filename"": ""include/linux/fs_struct.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/3151527ee007b73a0ebd296010f1c0454a919c7d/include/linux/fs_struct.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/3151527ee007b73a0ebd296010f1c0454a919c7d/include/linux/fs_struct.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs_struct.h?ref=3151527ee007b73a0ebd296010f1c0454a919c7d"", ""patch"": ""@@ -50,4 +50,6 @@ static inline void get_fs_root_and_pwd(struct fs_struct *fs, struct path *root,\n \tspin_unlock(&fs->lock);\n }\n \n+extern bool current_chrooted(void);\n+\n #endif /* _LINUX_FS_STRUCT_H */""}<_**next**_>{""sha"": ""0f1e42884577c93b891a7da6aa149733ba2d5141"", ""filename"": ""kernel/user_namespace.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/3151527ee007b73a0ebd296010f1c0454a919c7d/kernel/user_namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/3151527ee007b73a0ebd296010f1c0454a919c7d/kernel/user_namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/user_namespace.c?ref=3151527ee007b73a0ebd296010f1c0454a919c7d"", ""patch"": ""@@ -61,6 +61,15 @@ int create_user_ns(struct cred *new)\n \tkgid_t group = new->egid;\n \tint ret;\n \n+\t/*\n+\t * Verify that we can not violate the policy of which files\n+\t * may be accessed that is specified by the root directory,\n+\t * by verifing that the root directory is at the root of the\n+\t * mount namespace which allows all files to be accessed.\n+\t */\n+\tif (current_chrooted())\n+\t\treturn -EPERM;\n+\n \t/* The creator needs a mapping in the parent user namespace\n \t * or else we won't be able to reasonably tell userspace who\n \t * created a user_namespace.""}","int create_user_ns(struct cred *new)
{
	struct user_namespace *ns, *parent_ns = new->user_ns;
	kuid_t owner = new->euid;
 	kgid_t group = new->egid;
 	int ret;
 
	/*
	 * Verify that we can not violate the policy of which files
	 * may be accessed that is specified by the root directory,
	 * by verifing that the root directory is at the root of the
	 * mount namespace which allows all files to be accessed.
	 */
	if (current_chrooted())
		return -EPERM;

 	/* The creator needs a mapping in the parent user namespace
 	 * or else we won't be able to reasonably tell userspace who
 	 * created a user_namespace.
	 */
	if (!kuid_has_mapping(parent_ns, owner) ||
	    !kgid_has_mapping(parent_ns, group))
		return -EPERM;

	ns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);
	if (!ns)
		return -ENOMEM;

	ret = proc_alloc_inum(&ns->proc_inum);
	if (ret) {
		kmem_cache_free(user_ns_cachep, ns);
		return ret;
	}

	atomic_set(&ns->count, 1);
	/* Leave the new->user_ns reference with the new user namespace. */
	ns->parent = parent_ns;
	ns->owner = owner;
	ns->group = group;

	set_cred_user_ns(new, ns);

	return 0;
}
","int create_user_ns(struct cred *new)
{
	struct user_namespace *ns, *parent_ns = new->user_ns;
	kuid_t owner = new->euid;
 	kgid_t group = new->egid;
 	int ret;
 
 	/* The creator needs a mapping in the parent user namespace
 	 * or else we won't be able to reasonably tell userspace who
 	 * created a user_namespace.
	 */
	if (!kuid_has_mapping(parent_ns, owner) ||
	    !kgid_has_mapping(parent_ns, group))
		return -EPERM;

	ns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);
	if (!ns)
		return -ENOMEM;

	ret = proc_alloc_inum(&ns->proc_inum);
	if (ret) {
		kmem_cache_free(user_ns_cachep, ns);
		return ret;
	}

	atomic_set(&ns->count, 1);
	/* Leave the new->user_ns reference with the new user namespace. */
	ns->parent = parent_ns;
	ns->owner = owner;
	ns->group = group;

	set_cred_user_ns(new, ns);

	return 0;
}
",C,"	/*
	 * Verify that we can not violate the policy of which files
	 * may be accessed that is specified by the root directory,
	 * by verifing that the root directory is at the root of the
	 * mount namespace which allows all files to be accessed.
	 */
	if (current_chrooted())
		return -EPERM;

",,,"@@ -61,6 +61,15 @@ int create_user_ns(struct cred *new)
 	kgid_t group = new->egid;
 	int ret;
 
+	/*
+	 * Verify that we can not violate the policy of which files
+	 * may be accessed that is specified by the root directory,
+	 * by verifing that the root directory is at the root of the
+	 * mount namespace which allows all files to be accessed.
+	 */
+	if (current_chrooted())
+		return -EPERM;
+
 	/* The creator needs a mapping in the parent user namespace
 	 * or else we won't be able to reasonably tell userspace who
 	 * created a user_namespace.",linux,3151527ee007b73a0ebd296010f1c0454a919c7d,eddc0a3abff273842a94784d2d022bbc36dc9015,1,"int create_user_ns(struct cred *new)
{
	struct user_namespace *ns, *parent_ns = new->user_ns;
	kuid_t owner = new->euid;
 	kgid_t group = new->egid;
 	int ret;
 
//fix_flaw_line_below:
//	/*
//fix_flaw_line_below:
//	 * Verify that we can not violate the policy of which files
//fix_flaw_line_below:
//	 * may be accessed that is specified by the root directory,
//fix_flaw_line_below:
//	 * by verifing that the root directory is at the root of the
//fix_flaw_line_below:
//	 * mount namespace which allows all files to be accessed.
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//	if (current_chrooted())
//fix_flaw_line_below:
//		return -EPERM;
//fix_flaw_line_below:
//
 	/* The creator needs a mapping in the parent user namespace
 	 * or else we won't be able to reasonably tell userspace who
 	 * created a user_namespace.
	 */
	if (!kuid_has_mapping(parent_ns, owner) ||
	    !kgid_has_mapping(parent_ns, group))
		return -EPERM;

	ns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);
	if (!ns)
		return -ENOMEM;

	ret = proc_alloc_inum(&ns->proc_inum);
	if (ret) {
		kmem_cache_free(user_ns_cachep, ns);
		return ret;
	}

	atomic_set(&ns->count, 1);
	/* Leave the new->user_ns reference with the new user namespace. */
	ns->parent = parent_ns;
	ns->owner = owner;
	ns->group = group;

	set_cred_user_ns(new, ns);

	return 0;
}
",179269,"int create_user_ns(struct cred *new)
{
	struct user_namespace *ns, *parent_ns = new->user_ns;
	kuid_t owner = new->euid;
 	kgid_t group = new->egid;
 	int ret;
 
 	/* The creator needs a mapping in the parent user namespace
 	 * or else we won't be able to reasonably tell userspace who
 	 * created a user_namespace.
	 */
	if (!kuid_has_mapping(parent_ns, owner) ||
	    !kgid_has_mapping(parent_ns, group))
		return -EPERM;

	ns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);
	if (!ns)
		return -ENOMEM;

	ret = proc_alloc_inum(&ns->proc_inum);
	if (ret) {
		kmem_cache_free(user_ns_cachep, ns);
		return ret;
	}

	atomic_set(&ns->count, 1);
	/* Leave the new->user_ns reference with the new user namespace. */
	ns->parent = parent_ns;
	ns->owner = owner;
	ns->group = group;

	set_cred_user_ns(new, ns);

	return 0;
}
","int create_user_ns(struct cred *new)
{
	struct user_namespace *ns, *parent_ns = new->user_ns;
	kuid_t owner = new->euid;
 	kgid_t group = new->egid;
 	int ret;
 
	/*
	 * Verify that we can not violate the policy of which files
	 * may be accessed that is specified by the root directory,
	 * by verifing that the root directory is at the root of the
	 * mount namespace which allows all files to be accessed.
	 */
	if (current_chrooted())
		return -EPERM;

 	/* The creator needs a mapping in the parent user namespace
 	 * or else we won't be able to reasonably tell userspace who
 	 * created a user_namespace.
	 */
	if (!kuid_has_mapping(parent_ns, owner) ||
	    !kgid_has_mapping(parent_ns, group))
		return -EPERM;

	ns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);
	if (!ns)
		return -ENOMEM;

	ret = proc_alloc_inum(&ns->proc_inum);
	if (ret) {
		kmem_cache_free(user_ns_cachep, ns);
		return ret;
	}

	atomic_set(&ns->count, 1);
	/* Leave the new->user_ns reference with the new user namespace. */
	ns->parent = parent_ns;
	ns->owner = owner;
	ns->group = group;

	set_cred_user_ns(new, ns);

	return 0;
}
","The `create_user_ns` function is responsible for creating a new user namespace in a Linux kernel environment. It first checks if the user (identified by effective user ID and group ID) has the necessary mappings in the parent user namespace; if not, it returns a permission error. Upon successful validation, it allocates memory for the new user namespace and initializes its properties, including setting its parent, owner, and group. The function also assigns a unique process identifier to the new namespace and updates the credentials to reflect this new user namespace before returning success.","The code defines a function that creates a new user namespace within a Linux kernel environment. It begins by verifying that the user has the necessary permissions in the parent namespace. If the user lacks these permissions, an error is returned. Upon successful validation, memory is allocated for the new namespace, and its properties are initialized, including linking it to the parent namespace and setting ownership details. A unique identifier is also assigned to the new namespace. Finally, the function updates the user credentials to reflect the new namespace and indicates successful creation.","The vulnerability in the original code stemmed from allowing the creation of a user namespace without verifying if the user was in a chroot environment, which could lead to unauthorized access to files outside the intended directory structure. This oversight could allow unprivileged users to bypass file access policies established by the root directory. The fix introduced a check using the `current_chrooted()` function to ensure that a user cannot create a user namespace while chrooted, thereby enforcing the policy that limits file access to those below the current root directory and preventing potential security violations.","The vulnerability in the original code allowed the creation of user namespaces without checking if the user was operating within a chroot environment, potentially enabling unauthorized access to files outside the intended directory structure. This could undermine the security policies that restrict file access based on the root directory. The fix implemented a verification step to ensure that a user cannot create a user namespace while chrooted, thereby reinforcing the policy that limits file access to those within the current root directory and preventing security breaches related to unauthorized file access.","The vulnerability was fixed by introducing a check using the `current_chrooted()` function to prevent the creation of a user namespace if the user is in a chroot environment. This additional verification ensures that the root directory points to the root of the mount namespace at the time of user namespace creation, thereby enforcing the policy that limits unprivileged processes to files below the current root directory. By implementing this check, the code now effectively prevents potential violations of file access policies, ensuring that the security of the system is maintained when creating user namespaces.","The vulnerability was addressed by adding a verification step to ensure that a user cannot create a user namespace while operating within a chroot environment. This check prevents the potential violation of file access policies that restrict access based on the root directory. By enforcing this condition, the code ensures that unprivileged processes are limited to accessing files only within their designated directory structure, thereby enhancing the overall security of the system. This fix effectively mitigates the risk of unauthorized access to files outside the intended scope when creating user namespaces.","CWE-269, CWE-250, CWE-284, CWE-264, CWE-274, CWE-265, CWE-266, CWE-732, CWE-653, CWE-693",N,-1
26,26,179294,179294,,Local,Not required,Complete,CVE-2013-1774,https://www.cvedetails.com/cve/CVE-2013-1774/,CWE-264,High,,,,2013-02-28,4.0,The chase_port function in drivers/usb/serial/io_ti.c in the Linux kernel before 3.7.4 allows local users to cause a denial of service (NULL pointer dereference and system crash) via an attempted /dev/ttyUSB read or write operation on a disconnected Edgeport USB serial converter.,2019-04-22,DoS ,3,https://github.com/torvalds/linux/commit/1ee0a224bc9aad1de496c795f96bc6ba2c394811,1ee0a224bc9aad1de496c795f96bc6ba2c394811,"USB: io_ti: Fix NULL dereference in chase_port()

The tty is NULL when the port is hanging up.
chase_port() needs to check for this.

This patch is intended for stable series.
The behavior was observed and tested in Linux 3.2 and 3.7.1.

Johan Hovold submitted a more elaborate patch for the mainline kernel.

[   56.277883] usb 1-1: edge_bulk_in_callback - nonzero read bulk status received: -84
[   56.278811] usb 1-1: USB disconnect, device number 3
[   56.278856] usb 1-1: edge_bulk_in_callback - stopping read!
[   56.279562] BUG: unable to handle kernel NULL pointer dereference at 00000000000001c8
[   56.280536] IP: [<ffffffff8144e62a>] _raw_spin_lock_irqsave+0x19/0x35
[   56.281212] PGD 1dc1b067 PUD 1e0f7067 PMD 0
[   56.282085] Oops: 0002 [#1] SMP
[   56.282744] Modules linked in:
[   56.283512] CPU 1
[   56.283512] Pid: 25, comm: khubd Not tainted 3.7.1 #1 innotek GmbH VirtualBox/VirtualBox
[   56.283512] RIP: 0010:[<ffffffff8144e62a>]  [<ffffffff8144e62a>] _raw_spin_lock_irqsave+0x19/0x35
[   56.283512] RSP: 0018:ffff88001fa99ab0  EFLAGS: 00010046
[   56.283512] RAX: 0000000000000046 RBX: 00000000000001c8 RCX: 0000000000640064
[   56.283512] RDX: 0000000000010000 RSI: ffff88001fa99b20 RDI: 00000000000001c8
[   56.283512] RBP: ffff88001fa99b20 R08: 0000000000000000 R09: 0000000000000000
[   56.283512] R10: 0000000000000000 R11: ffffffff812fcb4c R12: ffff88001ddf53c0
[   56.283512] R13: 0000000000000000 R14: 00000000000001c8 R15: ffff88001e19b9f4
[   56.283512] FS:  0000000000000000(0000) GS:ffff88001fd00000(0000) knlGS:0000000000000000
[   56.283512] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
[   56.283512] CR2: 00000000000001c8 CR3: 000000001dc51000 CR4: 00000000000006e0
[   56.283512] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[   56.283512] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
[   56.283512] Process khubd (pid: 25, threadinfo ffff88001fa98000, task ffff88001fa94f80)
[   56.283512] Stack:
[   56.283512]  0000000000000046 00000000000001c8 ffffffff810578ec ffffffff812fcb4c
[   56.283512]  ffff88001e19b980 0000000000002710 ffffffff812ffe81 0000000000000001
[   56.283512]  ffff88001fa94f80 0000000000000202 ffffffff00000001 0000000000000296
[   56.283512] Call Trace:
[   56.283512]  [<ffffffff810578ec>] ? add_wait_queue+0x12/0x3c
[   56.283512]  [<ffffffff812fcb4c>] ? usb_serial_port_work+0x28/0x28
[   56.283512]  [<ffffffff812ffe81>] ? chase_port+0x84/0x2d6
[   56.283512]  [<ffffffff81063f27>] ? try_to_wake_up+0x199/0x199
[   56.283512]  [<ffffffff81263a5c>] ? tty_ldisc_hangup+0x222/0x298
[   56.283512]  [<ffffffff81300171>] ? edge_close+0x64/0x129
[   56.283512]  [<ffffffff810612f7>] ? __wake_up+0x35/0x46
[   56.283512]  [<ffffffff8106135b>] ? should_resched+0x5/0x23
[   56.283512]  [<ffffffff81264916>] ? tty_port_shutdown+0x39/0x44
[   56.283512]  [<ffffffff812fcb4c>] ? usb_serial_port_work+0x28/0x28
[   56.283512]  [<ffffffff8125d38c>] ? __tty_hangup+0x307/0x351
[   56.283512]  [<ffffffff812e6ddc>] ? usb_hcd_flush_endpoint+0xde/0xed
[   56.283512]  [<ffffffff8144e625>] ? _raw_spin_lock_irqsave+0x14/0x35
[   56.283512]  [<ffffffff812fd361>] ? usb_serial_disconnect+0x57/0xc2
[   56.283512]  [<ffffffff812ea99b>] ? usb_unbind_interface+0x5c/0x131
[   56.283512]  [<ffffffff8128d738>] ? __device_release_driver+0x7f/0xd5
[   56.283512]  [<ffffffff8128d9cd>] ? device_release_driver+0x1a/0x25
[   56.283512]  [<ffffffff8128d393>] ? bus_remove_device+0xd2/0xe7
[   56.283512]  [<ffffffff8128b7a3>] ? device_del+0x119/0x167
[   56.283512]  [<ffffffff812e8d9d>] ? usb_disable_device+0x6a/0x180
[   56.283512]  [<ffffffff812e2ae0>] ? usb_disconnect+0x81/0xe6
[   56.283512]  [<ffffffff812e4435>] ? hub_thread+0x577/0xe82
[   56.283512]  [<ffffffff8144daa7>] ? __schedule+0x490/0x4be
[   56.283512]  [<ffffffff8105798f>] ? abort_exclusive_wait+0x79/0x79
[   56.283512]  [<ffffffff812e3ebe>] ? usb_remote_wakeup+0x2f/0x2f
[   56.283512]  [<ffffffff812e3ebe>] ? usb_remote_wakeup+0x2f/0x2f
[   56.283512]  [<ffffffff810570b4>] ? kthread+0x81/0x89
[   56.283512]  [<ffffffff81057033>] ? __kthread_parkme+0x5c/0x5c
[   56.283512]  [<ffffffff8145387c>] ? ret_from_fork+0x7c/0xb0
[   56.283512]  [<ffffffff81057033>] ? __kthread_parkme+0x5c/0x5c
[   56.283512] Code: 8b 7c 24 08 e8 17 0b c3 ff 48 8b 04 24 48 83 c4 10 c3 53 48 89 fb 41 50 e8 e0 0a c3 ff 48 89 04 24 e8 e7 0a c3 ff ba 00 00 01 00
<f0> 0f c1 13 48 8b 04 24 89 d1 c1 ea 10 66 39 d1 74 07 f3 90 66
[   56.283512] RIP  [<ffffffff8144e62a>] _raw_spin_lock_irqsave+0x19/0x35
[   56.283512]  RSP <ffff88001fa99ab0>
[   56.283512] CR2: 00000000000001c8
[   56.283512] ---[ end trace 49714df27e1679ce ]---

Signed-off-by: Wolfgang Frisch <wfpub@roembden.net>
Cc: Johan Hovold <jhovold@gmail.com>
Cc: stable <stable@vger.kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",0,drivers/usb/serial/io_ti.c,"{""sha"": ""82afc4d6a327d6bdbebc4707507684c966f11f9f"", ""filename"": ""drivers/usb/serial/io_ti.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/1ee0a224bc9aad1de496c795f96bc6ba2c394811/drivers/usb/serial/io_ti.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/1ee0a224bc9aad1de496c795f96bc6ba2c394811/drivers/usb/serial/io_ti.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/serial/io_ti.c?ref=1ee0a224bc9aad1de496c795f96bc6ba2c394811"", ""patch"": ""@@ -530,6 +530,9 @@ static void chase_port(struct edgeport_port *port, unsigned long timeout,\n \twait_queue_t wait;\n \tunsigned long flags;\n \n+\tif (!tty)\n+\t\treturn;\n+\n \tif (!timeout)\n \t\ttimeout = (HZ * EDGE_CLOSING_WAIT)/100;\n ""}","static void chase_port(struct edgeport_port *port, unsigned long timeout,
								int flush)
{
	int baud_rate;
	struct tty_struct *tty = tty_port_tty_get(&port->port->port);
	struct usb_serial *serial = port->port->serial;
 	wait_queue_t wait;
 	unsigned long flags;
 
	if (!tty)
		return;

 	if (!timeout)
 		timeout = (HZ * EDGE_CLOSING_WAIT)/100;
 
	/* wait for data to drain from the buffer */
	spin_lock_irqsave(&port->ep_lock, flags);
	init_waitqueue_entry(&wait, current);
	add_wait_queue(&tty->write_wait, &wait);
	for (;;) {
		set_current_state(TASK_INTERRUPTIBLE);
		if (kfifo_len(&port->write_fifo) == 0
		|| timeout == 0 || signal_pending(current)
		|| serial->disconnected)
			/* disconnect */
			break;
		spin_unlock_irqrestore(&port->ep_lock, flags);
		timeout = schedule_timeout(timeout);
		spin_lock_irqsave(&port->ep_lock, flags);
	}
	set_current_state(TASK_RUNNING);
	remove_wait_queue(&tty->write_wait, &wait);
	if (flush)
		kfifo_reset_out(&port->write_fifo);
	spin_unlock_irqrestore(&port->ep_lock, flags);
	tty_kref_put(tty);

	/* wait for data to drain from the device */
	timeout += jiffies;
	while ((long)(jiffies - timeout) < 0 && !signal_pending(current)
						&& !serial->disconnected) {
		/* not disconnected */
		if (!tx_active(port))
			break;
		msleep(10);
	}

	/* disconnected */
	if (serial->disconnected)
		return;

	/* wait one more character time, based on baud rate */
	/* (tx_active doesn't seem to wait for the last byte) */
	baud_rate = port->baud_rate;
	if (baud_rate == 0)
		baud_rate = 50;
	msleep(max(1, DIV_ROUND_UP(10000, baud_rate)));
}
","static void chase_port(struct edgeport_port *port, unsigned long timeout,
								int flush)
{
	int baud_rate;
	struct tty_struct *tty = tty_port_tty_get(&port->port->port);
	struct usb_serial *serial = port->port->serial;
 	wait_queue_t wait;
 	unsigned long flags;
 
 	if (!timeout)
 		timeout = (HZ * EDGE_CLOSING_WAIT)/100;
 
	/* wait for data to drain from the buffer */
	spin_lock_irqsave(&port->ep_lock, flags);
	init_waitqueue_entry(&wait, current);
	add_wait_queue(&tty->write_wait, &wait);
	for (;;) {
		set_current_state(TASK_INTERRUPTIBLE);
		if (kfifo_len(&port->write_fifo) == 0
		|| timeout == 0 || signal_pending(current)
		|| serial->disconnected)
			/* disconnect */
			break;
		spin_unlock_irqrestore(&port->ep_lock, flags);
		timeout = schedule_timeout(timeout);
		spin_lock_irqsave(&port->ep_lock, flags);
	}
	set_current_state(TASK_RUNNING);
	remove_wait_queue(&tty->write_wait, &wait);
	if (flush)
		kfifo_reset_out(&port->write_fifo);
	spin_unlock_irqrestore(&port->ep_lock, flags);
	tty_kref_put(tty);

	/* wait for data to drain from the device */
	timeout += jiffies;
	while ((long)(jiffies - timeout) < 0 && !signal_pending(current)
						&& !serial->disconnected) {
		/* not disconnected */
		if (!tx_active(port))
			break;
		msleep(10);
	}

	/* disconnected */
	if (serial->disconnected)
		return;

	/* wait one more character time, based on baud rate */
	/* (tx_active doesn't seem to wait for the last byte) */
	baud_rate = port->baud_rate;
	if (baud_rate == 0)
		baud_rate = 50;
	msleep(max(1, DIV_ROUND_UP(10000, baud_rate)));
}
",C,"	if (!tty)
		return;

",,,"@@ -530,6 +530,9 @@ static void chase_port(struct edgeport_port *port, unsigned long timeout,
 	wait_queue_t wait;
 	unsigned long flags;
 
+	if (!tty)
+		return;
+
 	if (!timeout)
 		timeout = (HZ * EDGE_CLOSING_WAIT)/100;
 ",linux,1ee0a224bc9aad1de496c795f96bc6ba2c394811,99beb2e9687ffd61c92a9875141eabe6f57a71b9,1,"static void chase_port(struct edgeport_port *port, unsigned long timeout,
								int flush)
{
	int baud_rate;
	struct tty_struct *tty = tty_port_tty_get(&port->port->port);
	struct usb_serial *serial = port->port->serial;
 	wait_queue_t wait;
 	unsigned long flags;
 
//fix_flaw_line_below:
//	if (!tty)
//fix_flaw_line_below:
//		return;
//fix_flaw_line_below:
//
 	if (!timeout)
 		timeout = (HZ * EDGE_CLOSING_WAIT)/100;
 
	/* wait for data to drain from the buffer */
	spin_lock_irqsave(&port->ep_lock, flags);
	init_waitqueue_entry(&wait, current);
	add_wait_queue(&tty->write_wait, &wait);
	for (;;) {
		set_current_state(TASK_INTERRUPTIBLE);
		if (kfifo_len(&port->write_fifo) == 0
		|| timeout == 0 || signal_pending(current)
		|| serial->disconnected)
			/* disconnect */
			break;
		spin_unlock_irqrestore(&port->ep_lock, flags);
		timeout = schedule_timeout(timeout);
		spin_lock_irqsave(&port->ep_lock, flags);
	}
	set_current_state(TASK_RUNNING);
	remove_wait_queue(&tty->write_wait, &wait);
	if (flush)
		kfifo_reset_out(&port->write_fifo);
	spin_unlock_irqrestore(&port->ep_lock, flags);
	tty_kref_put(tty);

	/* wait for data to drain from the device */
	timeout += jiffies;
	while ((long)(jiffies - timeout) < 0 && !signal_pending(current)
						&& !serial->disconnected) {
		/* not disconnected */
		if (!tx_active(port))
			break;
		msleep(10);
	}

	/* disconnected */
	if (serial->disconnected)
		return;

	/* wait one more character time, based on baud rate */
	/* (tx_active doesn't seem to wait for the last byte) */
	baud_rate = port->baud_rate;
	if (baud_rate == 0)
		baud_rate = 50;
	msleep(max(1, DIV_ROUND_UP(10000, baud_rate)));
}
",179294,"static void chase_port(struct edgeport_port *port, unsigned long timeout,
								int flush)
{
	int baud_rate;
	struct tty_struct *tty = tty_port_tty_get(&port->port->port);
	struct usb_serial *serial = port->port->serial;
 	wait_queue_t wait;
 	unsigned long flags;
 
 	if (!timeout)
 		timeout = (HZ * EDGE_CLOSING_WAIT)/100;
 
	/* wait for data to drain from the buffer */
	spin_lock_irqsave(&port->ep_lock, flags);
	init_waitqueue_entry(&wait, current);
	add_wait_queue(&tty->write_wait, &wait);
	for (;;) {
		set_current_state(TASK_INTERRUPTIBLE);
		if (kfifo_len(&port->write_fifo) == 0
		|| timeout == 0 || signal_pending(current)
		|| serial->disconnected)
			/* disconnect */
			break;
		spin_unlock_irqrestore(&port->ep_lock, flags);
		timeout = schedule_timeout(timeout);
		spin_lock_irqsave(&port->ep_lock, flags);
	}
	set_current_state(TASK_RUNNING);
	remove_wait_queue(&tty->write_wait, &wait);
	if (flush)
		kfifo_reset_out(&port->write_fifo);
	spin_unlock_irqrestore(&port->ep_lock, flags);
	tty_kref_put(tty);

	/* wait for data to drain from the device */
	timeout += jiffies;
	while ((long)(jiffies - timeout) < 0 && !signal_pending(current)
						&& !serial->disconnected) {
		/* not disconnected */
		if (!tx_active(port))
			break;
		msleep(10);
	}

	/* disconnected */
	if (serial->disconnected)
		return;

	/* wait one more character time, based on baud rate */
	/* (tx_active doesn't seem to wait for the last byte) */
	baud_rate = port->baud_rate;
	if (baud_rate == 0)
		baud_rate = 50;
	msleep(max(1, DIV_ROUND_UP(10000, baud_rate)));
}
","static void chase_port(struct edgeport_port *port, unsigned long timeout,
								int flush)
{
	int baud_rate;
	struct tty_struct *tty = tty_port_tty_get(&port->port->port);
	struct usb_serial *serial = port->port->serial;
 	wait_queue_t wait;
 	unsigned long flags;
 
	if (!tty)
		return;

 	if (!timeout)
 		timeout = (HZ * EDGE_CLOSING_WAIT)/100;
 
	/* wait for data to drain from the buffer */
	spin_lock_irqsave(&port->ep_lock, flags);
	init_waitqueue_entry(&wait, current);
	add_wait_queue(&tty->write_wait, &wait);
	for (;;) {
		set_current_state(TASK_INTERRUPTIBLE);
		if (kfifo_len(&port->write_fifo) == 0
		|| timeout == 0 || signal_pending(current)
		|| serial->disconnected)
			/* disconnect */
			break;
		spin_unlock_irqrestore(&port->ep_lock, flags);
		timeout = schedule_timeout(timeout);
		spin_lock_irqsave(&port->ep_lock, flags);
	}
	set_current_state(TASK_RUNNING);
	remove_wait_queue(&tty->write_wait, &wait);
	if (flush)
		kfifo_reset_out(&port->write_fifo);
	spin_unlock_irqrestore(&port->ep_lock, flags);
	tty_kref_put(tty);

	/* wait for data to drain from the device */
	timeout += jiffies;
	while ((long)(jiffies - timeout) < 0 && !signal_pending(current)
						&& !serial->disconnected) {
		/* not disconnected */
		if (!tx_active(port))
			break;
		msleep(10);
	}

	/* disconnected */
	if (serial->disconnected)
		return;

	/* wait one more character time, based on baud rate */
	/* (tx_active doesn't seem to wait for the last byte) */
	baud_rate = port->baud_rate;
	if (baud_rate == 0)
		baud_rate = 50;
	msleep(max(1, DIV_ROUND_UP(10000, baud_rate)));
}
","The `chase_port` function manages the process of waiting for data to drain from a serial port's buffer before closing the connection. It takes a pointer to an `edgeport_port` structure, a timeout value, and a flush flag as parameters. The function first initializes a wait queue and enters a loop where it checks if the write FIFO buffer is empty, if a timeout has occurred, if a signal is pending, or if the serial connection is disconnected. If any of these conditions are met, it breaks the loop. After ensuring the buffer is drained, it waits for any remaining data to be transmitted based on the baud rate before concluding the operation.","The function facilitates the orderly closing of a serial port connection by ensuring that all data in the buffer is transmitted before disconnection. It initializes a wait mechanism to monitor the buffer's status and enters a loop to check for conditions such as buffer emptiness, timeout, or disconnection signals. If any of these conditions are met, the loop exits. After confirming that the buffer is drained, the function waits for any remaining data to be sent based on the communication speed, ensuring a clean and complete closure of the connection without data loss.","The vulnerability in the original code stemmed from a potential NULL dereference when the serial port was hanging up, specifically when the `tty` variable was NULL. This situation could lead to a crash when the function attempted to access the `tty` structure without checking if it was valid, resulting in a kernel panic. The fix introduced a check for the `tty` variable immediately after its initialization. If `tty` is found to be NULL, the function exits early, preventing any further operations that could lead to dereferencing a NULL pointer and ensuring the stability of the system during disconnection events.","The vulnerability in the original code was due to a potential NULL dereference when the serial port was hanging up, specifically when the associated structure was not properly initialized. This could lead to a crash when the code attempted to access this structure without verifying its validity, resulting in a kernel panic. The fix implemented a check to ensure that the structure was not NULL before proceeding with any operations. By adding this validation step, the code prevents any attempts to dereference a NULL pointer, thereby enhancing stability and preventing crashes during disconnection events.","The vulnerability was fixed by introducing a check for the `tty` variable immediately after it is initialized with `tty_port_tty_get`. If `tty` is found to be NULL, the function exits early, preventing any further operations that could lead to dereferencing a NULL pointer. This check ensures that the code does not proceed to manipulate the wait queue or access the `write_wait` structure if the `tty` is invalid. By implementing this safeguard, the code effectively avoids potential crashes during disconnection scenarios, thereby enhancing the overall stability of the system.","The vulnerability was addressed by adding a validation step to check if the associated structure was NULL immediately after its initialization. If the structure is found to be NULL, the function exits early, preventing any further operations that could lead to dereferencing a NULL pointer. This safeguard ensures that the code does not attempt to manipulate any resources or access data when the structure is invalid, thereby avoiding potential crashes during disconnection events. By implementing this check, the overall stability and reliability of the system during critical operations are significantly improved.","CWE-476, CWE-690, CWE-119, CWE-665, CWE-754, CWE-628, CWE-822, CWE-825, CWE-416, CWE-824",N,-1
27,27,179306,179306,,Local,Not required,,CVE-2013-0914,https://www.cvedetails.com/cve/CVE-2013-0914/,CWE-264,Low,Partial,Partial,,2013-03-22,3.6,"The flush_signal_handlers function in kernel/signal.c in the Linux kernel before 3.8.4 preserves the value of the sa_restorer field across an exec operation, which makes it easier for local users to bypass the ASLR protection mechanism via a crafted application containing a sigaction system call.",2014-02-06,Bypass ,3,https://github.com/torvalds/linux/commit/2ca39528c01a933f6689cd6505ce65bd6d68a530,2ca39528c01a933f6689cd6505ce65bd6d68a530,"signal: always clear sa_restorer on execve

When the new signal handlers are set up, the location of sa_restorer is
not cleared, leaking a parent process's address space location to
children.  This allows for a potential bypass of the parent's ASLR by
examining the sa_restorer value returned when calling sigaction().

Based on what should be considered ""secret"" about addresses, it only
matters across the exec not the fork (since the VMAs haven't changed
until the exec).  But since exec sets SIG_DFL and keeps sa_restorer,
this is where it should be fixed.

Given the few uses of sa_restorer, a ""set"" function was not written
since this would be the only use.  Instead, we use
__ARCH_HAS_SA_RESTORER, as already done in other places.

Example of the leak before applying this patch:

  $ cat /proc/$$/maps
  ...
  7fb9f3083000-7fb9f3238000 r-xp 00000000 fd:01 404469 .../libc-2.15.so
  ...
  $ ./leak
  ...
  7f278bc74000-7f278be29000 r-xp 00000000 fd:01 404469 .../libc-2.15.so
  ...
  1 0 (nil) 0x7fb9f30b94a0
  2 4000000 (nil) 0x7f278bcaa4a0
  3 4000000 (nil) 0x7f278bcaa4a0
  4 0 (nil) 0x7fb9f30b94a0
  ...

[akpm@linux-foundation.org: use SA_RESTORER for backportability]
Signed-off-by: Kees Cook <keescook@chromium.org>
Reported-by: Emese Revfy <re.emese@gmail.com>
Cc: Emese Revfy <re.emese@gmail.com>
Cc: PaX Team <pageexec@freemail.hu>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: ""Eric W. Biederman"" <ebiederm@xmission.com>
Cc: Serge Hallyn <serge.hallyn@canonical.com>
Cc: Julien Tinnes <jln@google.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,kernel/signal.c,"{""sha"": ""43b0d4a1b7bace76e2dac9a87e2a2f6ab5efdf3e"", ""filename"": ""kernel/signal.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/2ca39528c01a933f6689cd6505ce65bd6d68a530/kernel/signal.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/2ca39528c01a933f6689cd6505ce65bd6d68a530/kernel/signal.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/signal.c?ref=2ca39528c01a933f6689cd6505ce65bd6d68a530"", ""patch"": ""@@ -485,6 +485,9 @@ flush_signal_handlers(struct task_struct *t, int force_default)\n \t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n \t\t\tka->sa.sa_handler = SIG_DFL;\n \t\tka->sa.sa_flags = 0;\n+#ifdef SA_RESTORER\n+\t\tka->sa.sa_restorer = NULL;\n+#endif\n \t\tsigemptyset(&ka->sa.sa_mask);\n \t\tka++;\n \t}""}","flush_signal_handlers(struct task_struct *t, int force_default)
{
	int i;
	struct k_sigaction *ka = &t->sighand->action[0];
	for (i = _NSIG ; i != 0 ; i--) {
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
#ifdef SA_RESTORER
		ka->sa.sa_restorer = NULL;
#endif
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}
}
","flush_signal_handlers(struct task_struct *t, int force_default)
{
	int i;
	struct k_sigaction *ka = &t->sighand->action[0];
	for (i = _NSIG ; i != 0 ; i--) {
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}
}
",C,"#ifdef SA_RESTORER
		ka->sa.sa_restorer = NULL;
#endif
",,,"@@ -485,6 +485,9 @@ flush_signal_handlers(struct task_struct *t, int force_default)
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
+#ifdef SA_RESTORER
+		ka->sa.sa_restorer = NULL;
+#endif
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}",linux,2ca39528c01a933f6689cd6505ce65bd6d68a530,f8749452adcddd62e3707709ec2ae4856e70a3f2,1,"flush_signal_handlers(struct task_struct *t, int force_default)
{
	int i;
	struct k_sigaction *ka = &t->sighand->action[0];
	for (i = _NSIG ; i != 0 ; i--) {
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
//fix_flaw_line_below:
//#ifdef SA_RESTORER
//fix_flaw_line_below:
//		ka->sa.sa_restorer = NULL;
//fix_flaw_line_below:
//#endif
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}
}
",179306,"flush_signal_handlers(struct task_struct *t, int force_default)
{
	int i;
	struct k_sigaction *ka = &t->sighand->action[0];
	for (i = _NSIG ; i != 0 ; i--) {
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}
}
","flush_signal_handlers(struct task_struct *t, int force_default)
{
	int i;
	struct k_sigaction *ka = &t->sighand->action[0];
	for (i = _NSIG ; i != 0 ; i--) {
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
#ifdef SA_RESTORER
		ka->sa.sa_restorer = NULL;
#endif
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}
}
","The `flush_signal_handlers` function resets the signal handlers for a given task (process) represented by the `task_struct` pointer `t`. It iterates through all possible signals, indicated by `_NSIG`, and for each signal, it checks if the `force_default` flag is set or if the current handler is not set to ignore the signal (`SIG_IGN`). If either condition is true, it assigns the default signal handler (`SIG_DFL`) to the signal. Additionally, it clears the signal's flags and mask, effectively restoring the default behavior for all signals associated with the specified task.","The provided code defines a function that resets the signal handling mechanisms for a specified process. It iterates through all possible signals and checks whether to enforce a default behavior based on a specified condition or the current signal handling state. If the conditions are met, it assigns a default handler to the signal, effectively overriding any existing custom handlers. Additionally, it clears any associated flags and resets the signal mask, ensuring that the process will respond to signals using the default settings, thereby restoring standard signal management for the process.","The vulnerability in the original code arises from the failure to clear the `sa_restorer` field when setting up new signal handlers, which could leak the address space location of a parent process to its child processes. This leak allows potential bypassing of Address Space Layout Randomization (ASLR) by exposing sensitive address information through the `sigaction()` call. The fix implemented in the updated code includes a conditional statement that sets `ka->sa.sa_restorer` to `NULL`, ensuring that this field is cleared during the execution of the `flush_signal_handlers` function, thereby preventing the leakage of potentially sensitive address information across process executions.","The vulnerability in the original code stems from the failure to clear a specific field when new signal handlers are established, which could inadvertently expose the address space of a parent process to its child processes. This exposure allows the child to potentially bypass security measures like Address Space Layout Randomization (ASLR) by accessing sensitive address information. The fix in the updated code addresses this issue by explicitly setting the problematic field to `NULL` during the signal handler setup process, ensuring that no sensitive address information is leaked during the execution of a new process, thereby enhancing security.","The vulnerability was fixed by adding a line in the updated code that sets the `sa_restorer` field to `NULL` within the `flush_signal_handlers` function. This change ensures that when new signal handlers are established, the `sa_restorer` value does not retain any potentially sensitive address from the parent process, which could be leaked to child processes. By explicitly clearing this field, the code prevents the exposure of the parents address space, thereby mitigating the risk of bypassing Address Space Layout Randomization (ASLR) and enhancing overall security during process execution.","The vulnerability was addressed by implementing a mechanism to clear a specific field associated with signal handling during the setup of new signal handlers. This adjustment ensures that no sensitive address information from the parent process is retained and potentially exposed to child processes. By explicitly resetting this field to a neutral state, the code prevents the leakage of address space details, thereby safeguarding against the circumvention of security measures like Address Space Layout Randomization. This fix enhances the overall security of the process execution environment by eliminating the risk of unintended information disclosure.","CWE-200,CWE-226,CWE-244,CWE-325,CWE-732,CWE-269,CWE-266,CWE-522,CWE-668,CWE-284",N,-1
28,28,179338,179338,,Local,Not required,Complete,CVE-2013-0268,https://www.cvedetails.com/cve/CVE-2013-0268/,CWE-264,High,Complete,Complete,,2013-02-17,6.2,"The msr_open function in arch/x86/kernel/msr.c in the Linux kernel before 3.7.6 allows local users to bypass intended capability restrictions by executing a crafted application as root, as demonstrated by msr32.c.",2013-08-22,Bypass ,3,https://github.com/torvalds/linux/commit/c903f0456bc69176912dee6dd25c6a66ee1aed00,c903f0456bc69176912dee6dd25c6a66ee1aed00,"x86/msr: Add capabilities check

At the moment the MSR driver only relies upon file system
checks. This means that anything as root with any capability set
can write to MSRs. Historically that wasn't very interesting but
on modern processors the MSRs are such that writing to them
provides several ways to execute arbitary code in kernel space.
Sample code and documentation on doing this is circulating and
MSR attacks are used on Windows 64bit rootkits already.

In the Linux case you still need to be able to open the device
file so the impact is fairly limited and reduces the security of
some capability and security model based systems down towards
that of a generic ""root owns the box"" setup.

Therefore they should require CAP_SYS_RAWIO to prevent an
elevation of capabilities. The impact of this is fairly minimal
on most setups because they don't have heavy use of
capabilities. Those using SELinux, SMACK or AppArmor rules might
want to consider if their rulesets on the MSR driver could be
tighter.

Signed-off-by: Alan Cox <alan@linux.intel.com>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Cc: Horses <stable@kernel.org>
Signed-off-by: Ingo Molnar <mingo@kernel.org>",0,arch/x86/kernel/msr.c,"{""sha"": ""4929502c1372db979d7e1b176b22a9981e8ec96e"", ""filename"": ""arch/x86/kernel/msr.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/c903f0456bc69176912dee6dd25c6a66ee1aed00/arch/x86/kernel/msr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c903f0456bc69176912dee6dd25c6a66ee1aed00/arch/x86/kernel/msr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kernel/msr.c?ref=c903f0456bc69176912dee6dd25c6a66ee1aed00"", ""patch"": ""@@ -174,6 +174,9 @@ static int msr_open(struct inode *inode, struct file *file)\n \tunsigned int cpu;\n \tstruct cpuinfo_x86 *c;\n \n+\tif (!capable(CAP_SYS_RAWIO))\n+\t\treturn -EPERM;\n+\n \tcpu = iminor(file->f_path.dentry->d_inode);\n \tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n \t\treturn -ENXIO;\t/* No such CPU */""}","static int msr_open(struct inode *inode, struct file *file)
{
 	unsigned int cpu;
 	struct cpuinfo_x86 *c;
 
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;

 	cpu = iminor(file->f_path.dentry->d_inode);
 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
 		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}
","static int msr_open(struct inode *inode, struct file *file)
{
 	unsigned int cpu;
 	struct cpuinfo_x86 *c;
 
 	cpu = iminor(file->f_path.dentry->d_inode);
 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
 		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}
",C,"	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;

",,,"@@ -174,6 +174,9 @@ static int msr_open(struct inode *inode, struct file *file)
 	unsigned int cpu;
 	struct cpuinfo_x86 *c;
 
+	if (!capable(CAP_SYS_RAWIO))
+		return -EPERM;
+
 	cpu = iminor(file->f_path.dentry->d_inode);
 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
 		return -ENXIO;	/* No such CPU */",linux,c903f0456bc69176912dee6dd25c6a66ee1aed00,73b664ceb5f815c38def1c68912b83f83455e9eb,1,"static int msr_open(struct inode *inode, struct file *file)
{
 	unsigned int cpu;
 	struct cpuinfo_x86 *c;
 
//fix_flaw_line_below:
//	if (!capable(CAP_SYS_RAWIO))
//fix_flaw_line_below:
//		return -EPERM;
//fix_flaw_line_below:
//
 	cpu = iminor(file->f_path.dentry->d_inode);
 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
 		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}
",179338,"static int msr_open(struct inode *inode, struct file *file)
{
 	unsigned int cpu;
 	struct cpuinfo_x86 *c;
 
 	cpu = iminor(file->f_path.dentry->d_inode);
 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
 		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}
","static int msr_open(struct inode *inode, struct file *file)
{
 	unsigned int cpu;
 	struct cpuinfo_x86 *c;
 
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;

 	cpu = iminor(file->f_path.dentry->d_inode);
 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
 		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}
","The `msr_open` function is a kernel-level routine that handles the opening of a Model-Specific Register (MSR) file for a specific CPU. It retrieves the CPU identifier from the file's inode and checks if the CPU is valid and online. If the CPU is not valid or offline, it returns an error code `-ENXIO`. It then accesses the CPU's information structure to verify if the CPU supports MSR functionality. If MSR support is absent, it returns an error code `-EIO`. If all checks pass, the function returns 0, indicating successful opening of the MSR file.","This code defines a function that manages the opening of a file associated with a specific CPU's Model-Specific Registers. It first retrieves the identifier for the CPU and checks if it is valid and currently active. If the CPU is either invalid or not online, an error indicating that the CPU does not exist is returned. The function then verifies whether the CPU supports the necessary register functionality. If this support is lacking, an input/output error is returned. If all conditions are satisfied, the function successfully completes the opening process, indicating readiness for further operations.","The vulnerability in the original code stemmed from the lack of a capability check, allowing any user with root access to write to Model-Specific Registers, potentially leading to arbitrary code execution in kernel space. This oversight posed a significant security risk, especially with the increasing sophistication of MSR attacks. The fixed code addresses this vulnerability by introducing a check for the `CAP_SYS_RAWIO` capability before proceeding with any operations. This ensures that only authorized users can access the MSR functionality, thereby mitigating the risk of privilege escalation and enhancing the overall security of the system.","The vulnerability in the original code allowed any user with root privileges to write to Model-Specific Registers without sufficient checks, potentially enabling arbitrary code execution in kernel space. This posed a significant security risk, especially with the rise of sophisticated attacks targeting these registers. The fix introduced a capability check that restricts access to users with specific permissions, ensuring that only authorized individuals can perform operations on the registers. This enhancement effectively mitigates the risk of privilege escalation and strengthens the security model, particularly for systems utilizing advanced security frameworks.","The vulnerability was fixed by adding a capability check using the `capable(CAP_SYS_RAWIO)` function at the beginning of the `msr_open` function. This check ensures that only users with the appropriate permissions can access Model-Specific Registers, preventing unauthorized write operations that could lead to arbitrary code execution in kernel space. By returning `-EPERM` if the capability is not present, the code restricts access to the MSR functionality, thereby mitigating the risk of privilege escalation. This change enhances the security of the system by enforcing stricter access controls on sensitive operations.","The vulnerability was addressed by implementing a capability check that restricts access to the Model-Specific Registers. This check ensures that only users with the necessary permissions can perform operations on these registers, effectively preventing unauthorized write access that could lead to arbitrary code execution in kernel space. By returning an error when the required permissions are not met, the code enhances security and mitigates the risk of privilege escalation. This modification reinforces the access control mechanisms, ensuring that sensitive operations are only available to authorized users, thereby improving the overall security posture of the system.","CWE-264,CWE-269,CWE-284,CWE-732,CWE-274,CWE-266,CWE-265,CWE-263,CWE-271,CWE-270",Y,1
29,29,179381,179381,,Local,Not required,Complete,CVE-2011-4347,https://www.cvedetails.com/cve/CVE-2011-4347/,CWE-264,High,,,,2013-06-08,4.0,"The kvm_vm_ioctl_assign_device function in virt/kvm/assigned-dev.c in the KVM subsystem in the Linux kernel before 3.1.10 does not verify permission to access PCI configuration space and BAR resources, which allows host OS users to assign PCI devices and cause a denial of service (host OS crash) via a KVM_ASSIGN_PCI_DEVICE operation.",2013-06-10,DoS ,13,https://github.com/torvalds/linux/commit/c4e7f9022e506c6635a5037713c37118e23193e4,c4e7f9022e506c6635a5037713c37118e23193e4,"KVM: Device assignment permission checks

(cherry picked from commit 3d27e23b17010c668db311140b17bbbb70c78fb9)

Only allow KVM device assignment to attach to devices which:

 - Are not bridges
 - Have BAR resources (assume others are special devices)
 - The user has permissions to use

Assigning a bridge is a configuration error, it's not supported, and
typically doesn't result in the behavior the user is expecting anyway.
Devices without BAR resources are typically chipset components that
also don't have host drivers.  We don't want users to hold such devices
captive or cause system problems by fencing them off into an iommu
domain.  We determine ""permission to use"" by testing whether the user
has access to the PCI sysfs resource files.  By default a normal user
will not have access to these files, so it provides a good indication
that an administration agent has granted the user access to the device.

[Yang Bai: add missing #include]
[avi: fix comment style]

Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
Signed-off-by: Yang Bai <hamo.by@gmail.com>
Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>",0,virt/kvm/assigned-dev.c,"{""sha"": ""13ab8379b4eb0e9a3665954b917feccf3560769f"", ""filename"": ""Documentation/virtual/kvm/api.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/c4e7f9022e506c6635a5037713c37118e23193e4/Documentation/virtual/kvm/api.txt"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c4e7f9022e506c6635a5037713c37118e23193e4/Documentation/virtual/kvm/api.txt"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/Documentation/virtual/kvm/api.txt?ref=c4e7f9022e506c6635a5037713c37118e23193e4"", ""patch"": ""@@ -1134,6 +1134,10 @@ following flags are specified:\n The KVM_DEV_ASSIGN_ENABLE_IOMMU flag is a mandatory option to ensure\n isolation of the device.  Usages not specifying this flag are deprecated.\n \n+Only PCI header type 0 devices with PCI BAR resources are supported by\n+device assignment.  The user requesting this ioctl must have read/write\n+access to the PCI sysfs resource files associated with the device.\n+\n 4.49 KVM_DEASSIGN_PCI_DEVICE\n \n Capability: KVM_CAP_DEVICE_DEASSIGNMENT""}<_**next**_>{""sha"": ""af7910228fb1c31eb00dfb1734d7b019ddf87b2d"", ""filename"": ""virt/kvm/assigned-dev.c"", ""status"": ""modified"", ""additions"": 75, ""deletions"": 0, ""changes"": 75, ""blob_url"": ""https://github.com/torvalds/linux/blob/c4e7f9022e506c6635a5037713c37118e23193e4/virt/kvm/assigned-dev.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c4e7f9022e506c6635a5037713c37118e23193e4/virt/kvm/assigned-dev.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/virt/kvm/assigned-dev.c?ref=c4e7f9022e506c6635a5037713c37118e23193e4"", ""patch"": ""@@ -17,6 +17,8 @@\n #include <linux/pci.h>\n #include <linux/interrupt.h>\n #include <linux/slab.h>\n+#include <linux/namei.h>\n+#include <linux/fs.h>\n #include \""irq.h\""\n \n static struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n@@ -474,12 +476,73 @@ static int kvm_vm_ioctl_deassign_dev_irq(struct kvm *kvm,\n \treturn r;\n }\n \n+/*\n+ * We want to test whether the caller has been granted permissions to\n+ * use this device.  To be able to configure and control the device,\n+ * the user needs access to PCI configuration space and BAR resources.\n+ * These are accessed through PCI sysfs.  PCI config space is often\n+ * passed to the process calling this ioctl via file descriptor, so we\n+ * can't rely on access to that file.  We can check for permissions\n+ * on each of the BAR resource files, which is a pretty clear\n+ * indicator that the user has been granted access to the device.\n+ */\n+static int probe_sysfs_permissions(struct pci_dev *dev)\n+{\n+#ifdef CONFIG_SYSFS\n+\tint i;\n+\tbool bar_found = false;\n+\n+\tfor (i = PCI_STD_RESOURCES; i <= PCI_STD_RESOURCE_END; i++) {\n+\t\tchar *kpath, *syspath;\n+\t\tstruct path path;\n+\t\tstruct inode *inode;\n+\t\tint r;\n+\n+\t\tif (!pci_resource_len(dev, i))\n+\t\t\tcontinue;\n+\n+\t\tkpath = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n+\t\tif (!kpath)\n+\t\t\treturn -ENOMEM;\n+\n+\t\t/* Per sysfs-rules, sysfs is always at /sys */\n+\t\tsyspath = kasprintf(GFP_KERNEL, \""/sys%s/resource%d\"", kpath, i);\n+\t\tkfree(kpath);\n+\t\tif (!syspath)\n+\t\t\treturn -ENOMEM;\n+\n+\t\tr = kern_path(syspath, LOOKUP_FOLLOW, &path);\n+\t\tkfree(syspath);\n+\t\tif (r)\n+\t\t\treturn r;\n+\n+\t\tinode = path.dentry->d_inode;\n+\n+\t\tr = inode_permission(inode, MAY_READ | MAY_WRITE | MAY_ACCESS);\n+\t\tpath_put(&path);\n+\t\tif (r)\n+\t\t\treturn r;\n+\n+\t\tbar_found = true;\n+\t}\n+\n+\t/* If no resources, probably something special */\n+\tif (!bar_found)\n+\t\treturn -EPERM;\n+\n+\treturn 0;\n+#else\n+\treturn -EINVAL; /* No way to control the device without sysfs */\n+#endif\n+}\n+\n static int kvm_vm_ioctl_assign_device(struct kvm *kvm,\n \t\t\t\t      struct kvm_assigned_pci_dev *assigned_dev)\n {\n \tint r = 0, idx;\n \tstruct kvm_assigned_dev_kernel *match;\n \tstruct pci_dev *dev;\n+\tu8 header_type;\n \n \tif (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))\n \t\treturn -EINVAL;\n@@ -510,6 +573,18 @@ static int kvm_vm_ioctl_assign_device(struct kvm *kvm,\n \t\tr = -EINVAL;\n \t\tgoto out_free;\n \t}\n+\n+\t/* Don't allow bridges to be assigned */\n+\tpci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);\n+\tif ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {\n+\t\tr = -EPERM;\n+\t\tgoto out_put;\n+\t}\n+\n+\tr = probe_sysfs_permissions(dev);\n+\tif (r)\n+\t\tgoto out_put;\n+\n \tif (pci_enable_device(dev)) {\n \t\tprintk(KERN_INFO \""%s: Could not enable PCI device\\n\"", __func__);\n \t\tr = -EBUSY;""}"," static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 				      struct kvm_assigned_pci_dev *assigned_dev)
 {
 	int r = 0, idx;
 	struct kvm_assigned_dev_kernel *match;
 	struct pci_dev *dev;
	u8 header_type;
 
 	if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
 		return -EINVAL;

	mutex_lock(&kvm->lock);
	idx = srcu_read_lock(&kvm->srcu);

	match = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,
				      assigned_dev->assigned_dev_id);
	if (match) {
		/* device already assigned */
		r = -EEXIST;
		goto out;
	}

	match = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);
	if (match == NULL) {
		printk(KERN_INFO ""%s: Couldn't allocate memory\n"",
		       __func__);
		r = -ENOMEM;
		goto out;
	}
	dev = pci_get_domain_bus_and_slot(assigned_dev->segnr,
				   assigned_dev->busnr,
				   assigned_dev->devfn);
	if (!dev) {
		printk(KERN_INFO ""%s: host device not found\n"", __func__);
 		r = -EINVAL;
 		goto out_free;
 	}

	/* Don't allow bridges to be assigned */
	pci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);
	if ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {
		r = -EPERM;
		goto out_put;
	}

	r = probe_sysfs_permissions(dev);
	if (r)
		goto out_put;

 	if (pci_enable_device(dev)) {
 		printk(KERN_INFO ""%s: Could not enable PCI device\n"", __func__);
 		r = -EBUSY;
		goto out_put;
	}
	r = pci_request_regions(dev, ""kvm_assigned_device"");
	if (r) {
		printk(KERN_INFO ""%s: Could not get access to device regions\n"",
		       __func__);
		goto out_disable;
	}

	pci_reset_function(dev);
	pci_save_state(dev);
	match->pci_saved_state = pci_store_saved_state(dev);
	if (!match->pci_saved_state)
		printk(KERN_DEBUG ""%s: Couldn't store %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	match->assigned_dev_id = assigned_dev->assigned_dev_id;
	match->host_segnr = assigned_dev->segnr;
	match->host_busnr = assigned_dev->busnr;
	match->host_devfn = assigned_dev->devfn;
	match->flags = assigned_dev->flags;
	match->dev = dev;
	spin_lock_init(&match->intx_lock);
	match->irq_source_id = -1;
	match->kvm = kvm;
	match->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;

	list_add(&match->list, &kvm->arch.assigned_dev_head);

	if (!kvm->arch.iommu_domain) {
		r = kvm_iommu_map_guest(kvm);
		if (r)
			goto out_list_del;
	}
	r = kvm_assign_device(kvm, match);
	if (r)
		goto out_list_del;

out:
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
out_list_del:
	if (pci_load_and_free_saved_state(dev, &match->pci_saved_state))
		printk(KERN_INFO ""%s: Couldn't reload %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	list_del(&match->list);
	pci_release_regions(dev);
out_disable:
	pci_disable_device(dev);
out_put:
	pci_dev_put(dev);
out_free:
	kfree(match);
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
}
"," static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 				      struct kvm_assigned_pci_dev *assigned_dev)
 {
 	int r = 0, idx;
 	struct kvm_assigned_dev_kernel *match;
 	struct pci_dev *dev;
 
 	if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
 		return -EINVAL;

	mutex_lock(&kvm->lock);
	idx = srcu_read_lock(&kvm->srcu);

	match = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,
				      assigned_dev->assigned_dev_id);
	if (match) {
		/* device already assigned */
		r = -EEXIST;
		goto out;
	}

	match = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);
	if (match == NULL) {
		printk(KERN_INFO ""%s: Couldn't allocate memory\n"",
		       __func__);
		r = -ENOMEM;
		goto out;
	}
	dev = pci_get_domain_bus_and_slot(assigned_dev->segnr,
				   assigned_dev->busnr,
				   assigned_dev->devfn);
	if (!dev) {
		printk(KERN_INFO ""%s: host device not found\n"", __func__);
 		r = -EINVAL;
 		goto out_free;
 	}
 	if (pci_enable_device(dev)) {
 		printk(KERN_INFO ""%s: Could not enable PCI device\n"", __func__);
 		r = -EBUSY;
		goto out_put;
	}
	r = pci_request_regions(dev, ""kvm_assigned_device"");
	if (r) {
		printk(KERN_INFO ""%s: Could not get access to device regions\n"",
		       __func__);
		goto out_disable;
	}

	pci_reset_function(dev);
	pci_save_state(dev);
	match->pci_saved_state = pci_store_saved_state(dev);
	if (!match->pci_saved_state)
		printk(KERN_DEBUG ""%s: Couldn't store %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	match->assigned_dev_id = assigned_dev->assigned_dev_id;
	match->host_segnr = assigned_dev->segnr;
	match->host_busnr = assigned_dev->busnr;
	match->host_devfn = assigned_dev->devfn;
	match->flags = assigned_dev->flags;
	match->dev = dev;
	spin_lock_init(&match->intx_lock);
	match->irq_source_id = -1;
	match->kvm = kvm;
	match->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;

	list_add(&match->list, &kvm->arch.assigned_dev_head);

	if (!kvm->arch.iommu_domain) {
		r = kvm_iommu_map_guest(kvm);
		if (r)
			goto out_list_del;
	}
	r = kvm_assign_device(kvm, match);
	if (r)
		goto out_list_del;

out:
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
out_list_del:
	if (pci_load_and_free_saved_state(dev, &match->pci_saved_state))
		printk(KERN_INFO ""%s: Couldn't reload %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	list_del(&match->list);
	pci_release_regions(dev);
out_disable:
	pci_disable_device(dev);
out_put:
	pci_dev_put(dev);
out_free:
	kfree(match);
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
}
",C,"	u8 header_type;

	/* Don't allow bridges to be assigned */
	pci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);
	if ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {
		r = -EPERM;
		goto out_put;
	}

	r = probe_sysfs_permissions(dev);
	if (r)
		goto out_put;

",,,"@@ -17,6 +17,8 @@
 #include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
+#include <linux/namei.h>
+#include <linux/fs.h>
 #include ""irq.h""
 
 static struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,
@@ -474,12 +476,73 @@ static int kvm_vm_ioctl_deassign_dev_irq(struct kvm *kvm,
 	return r;
 }
 
+/*
+ * We want to test whether the caller has been granted permissions to
+ * use this device.  To be able to configure and control the device,
+ * the user needs access to PCI configuration space and BAR resources.
+ * These are accessed through PCI sysfs.  PCI config space is often
+ * passed to the process calling this ioctl via file descriptor, so we
+ * can't rely on access to that file.  We can check for permissions
+ * on each of the BAR resource files, which is a pretty clear
+ * indicator that the user has been granted access to the device.
+ */
+static int probe_sysfs_permissions(struct pci_dev *dev)
+{
+#ifdef CONFIG_SYSFS
+	int i;
+	bool bar_found = false;
+
+	for (i = PCI_STD_RESOURCES; i <= PCI_STD_RESOURCE_END; i++) {
+		char *kpath, *syspath;
+		struct path path;
+		struct inode *inode;
+		int r;
+
+		if (!pci_resource_len(dev, i))
+			continue;
+
+		kpath = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);
+		if (!kpath)
+			return -ENOMEM;
+
+		/* Per sysfs-rules, sysfs is always at /sys */
+		syspath = kasprintf(GFP_KERNEL, ""/sys%s/resource%d"", kpath, i);
+		kfree(kpath);
+		if (!syspath)
+			return -ENOMEM;
+
+		r = kern_path(syspath, LOOKUP_FOLLOW, &path);
+		kfree(syspath);
+		if (r)
+			return r;
+
+		inode = path.dentry->d_inode;
+
+		r = inode_permission(inode, MAY_READ | MAY_WRITE | MAY_ACCESS);
+		path_put(&path);
+		if (r)
+			return r;
+
+		bar_found = true;
+	}
+
+	/* If no resources, probably something special */
+	if (!bar_found)
+		return -EPERM;
+
+	return 0;
+#else
+	return -EINVAL; /* No way to control the device without sysfs */
+#endif
+}
+
 static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 				      struct kvm_assigned_pci_dev *assigned_dev)
 {
 	int r = 0, idx;
 	struct kvm_assigned_dev_kernel *match;
 	struct pci_dev *dev;
+	u8 header_type;
 
 	if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
 		return -EINVAL;
@@ -510,6 +573,18 @@ static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 		r = -EINVAL;
 		goto out_free;
 	}
+
+	/* Don't allow bridges to be assigned */
+	pci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);
+	if ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {
+		r = -EPERM;
+		goto out_put;
+	}
+
+	r = probe_sysfs_permissions(dev);
+	if (r)
+		goto out_put;
+
 	if (pci_enable_device(dev)) {
 		printk(KERN_INFO ""%s: Could not enable PCI device\n"", __func__);
 		r = -EBUSY;",linux,c4e7f9022e506c6635a5037713c37118e23193e4,4fd9e326e5001982747225f0f7bb462e34ae9215,1," static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 				      struct kvm_assigned_pci_dev *assigned_dev)
 {
 	int r = 0, idx;
 	struct kvm_assigned_dev_kernel *match;
 	struct pci_dev *dev;
//fix_flaw_line_below:
//	u8 header_type;
 
 	if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
 		return -EINVAL;

	mutex_lock(&kvm->lock);
	idx = srcu_read_lock(&kvm->srcu);

	match = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,
				      assigned_dev->assigned_dev_id);
	if (match) {
		/* device already assigned */
		r = -EEXIST;
		goto out;
	}

	match = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);
	if (match == NULL) {
		printk(KERN_INFO ""%s: Couldn't allocate memory\n"",
		       __func__);
		r = -ENOMEM;
		goto out;
	}
	dev = pci_get_domain_bus_and_slot(assigned_dev->segnr,
				   assigned_dev->busnr,
				   assigned_dev->devfn);
	if (!dev) {
		printk(KERN_INFO ""%s: host device not found\n"", __func__);
 		r = -EINVAL;
 		goto out_free;
 	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/* Don't allow bridges to be assigned */
//fix_flaw_line_below:
//	pci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);
//fix_flaw_line_below:
//	if ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {
//fix_flaw_line_below:
//		r = -EPERM;
//fix_flaw_line_below:
//		goto out_put;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	r = probe_sysfs_permissions(dev);
//fix_flaw_line_below:
//	if (r)
//fix_flaw_line_below:
//		goto out_put;
//fix_flaw_line_below:
//
 	if (pci_enable_device(dev)) {
 		printk(KERN_INFO ""%s: Could not enable PCI device\n"", __func__);
 		r = -EBUSY;
		goto out_put;
	}
	r = pci_request_regions(dev, ""kvm_assigned_device"");
	if (r) {
		printk(KERN_INFO ""%s: Could not get access to device regions\n"",
		       __func__);
		goto out_disable;
	}

	pci_reset_function(dev);
	pci_save_state(dev);
	match->pci_saved_state = pci_store_saved_state(dev);
	if (!match->pci_saved_state)
		printk(KERN_DEBUG ""%s: Couldn't store %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	match->assigned_dev_id = assigned_dev->assigned_dev_id;
	match->host_segnr = assigned_dev->segnr;
	match->host_busnr = assigned_dev->busnr;
	match->host_devfn = assigned_dev->devfn;
	match->flags = assigned_dev->flags;
	match->dev = dev;
	spin_lock_init(&match->intx_lock);
	match->irq_source_id = -1;
	match->kvm = kvm;
	match->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;

	list_add(&match->list, &kvm->arch.assigned_dev_head);

	if (!kvm->arch.iommu_domain) {
		r = kvm_iommu_map_guest(kvm);
		if (r)
			goto out_list_del;
	}
	r = kvm_assign_device(kvm, match);
	if (r)
		goto out_list_del;

out:
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
out_list_del:
	if (pci_load_and_free_saved_state(dev, &match->pci_saved_state))
		printk(KERN_INFO ""%s: Couldn't reload %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	list_del(&match->list);
	pci_release_regions(dev);
out_disable:
	pci_disable_device(dev);
out_put:
	pci_dev_put(dev);
out_free:
	kfree(match);
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
}
",179381," static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 				      struct kvm_assigned_pci_dev *assigned_dev)
 {
 	int r = 0, idx;
 	struct kvm_assigned_dev_kernel *match;
 	struct pci_dev *dev;
 
 	if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
 		return -EINVAL;

	mutex_lock(&kvm->lock);
	idx = srcu_read_lock(&kvm->srcu);

	match = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,
				      assigned_dev->assigned_dev_id);
	if (match) {
		/* device already assigned */
		r = -EEXIST;
		goto out;
	}

	match = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);
	if (match == NULL) {
		printk(KERN_INFO ""%s: Couldn't allocate memory\n"",
		       __func__);
		r = -ENOMEM;
		goto out;
	}
	dev = pci_get_domain_bus_and_slot(assigned_dev->segnr,
				   assigned_dev->busnr,
				   assigned_dev->devfn);
	if (!dev) {
		printk(KERN_INFO ""%s: host device not found\n"", __func__);
 		r = -EINVAL;
 		goto out_free;
 	}
 	if (pci_enable_device(dev)) {
 		printk(KERN_INFO ""%s: Could not enable PCI device\n"", __func__);
 		r = -EBUSY;
		goto out_put;
	}
	r = pci_request_regions(dev, ""kvm_assigned_device"");
	if (r) {
		printk(KERN_INFO ""%s: Could not get access to device regions\n"",
		       __func__);
		goto out_disable;
	}

	pci_reset_function(dev);
	pci_save_state(dev);
	match->pci_saved_state = pci_store_saved_state(dev);
	if (!match->pci_saved_state)
		printk(KERN_DEBUG ""%s: Couldn't store %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	match->assigned_dev_id = assigned_dev->assigned_dev_id;
	match->host_segnr = assigned_dev->segnr;
	match->host_busnr = assigned_dev->busnr;
	match->host_devfn = assigned_dev->devfn;
	match->flags = assigned_dev->flags;
	match->dev = dev;
	spin_lock_init(&match->intx_lock);
	match->irq_source_id = -1;
	match->kvm = kvm;
	match->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;

	list_add(&match->list, &kvm->arch.assigned_dev_head);

	if (!kvm->arch.iommu_domain) {
		r = kvm_iommu_map_guest(kvm);
		if (r)
			goto out_list_del;
	}
	r = kvm_assign_device(kvm, match);
	if (r)
		goto out_list_del;

out:
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
out_list_del:
	if (pci_load_and_free_saved_state(dev, &match->pci_saved_state))
		printk(KERN_INFO ""%s: Couldn't reload %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	list_del(&match->list);
	pci_release_regions(dev);
out_disable:
	pci_disable_device(dev);
out_put:
	pci_dev_put(dev);
out_free:
	kfree(match);
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
}
"," static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 				      struct kvm_assigned_pci_dev *assigned_dev)
 {
 	int r = 0, idx;
 	struct kvm_assigned_dev_kernel *match;
 	struct pci_dev *dev;
	u8 header_type;
 
 	if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
 		return -EINVAL;

	mutex_lock(&kvm->lock);
	idx = srcu_read_lock(&kvm->srcu);

	match = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,
				      assigned_dev->assigned_dev_id);
	if (match) {
		/* device already assigned */
		r = -EEXIST;
		goto out;
	}

	match = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);
	if (match == NULL) {
		printk(KERN_INFO ""%s: Couldn't allocate memory\n"",
		       __func__);
		r = -ENOMEM;
		goto out;
	}
	dev = pci_get_domain_bus_and_slot(assigned_dev->segnr,
				   assigned_dev->busnr,
				   assigned_dev->devfn);
	if (!dev) {
		printk(KERN_INFO ""%s: host device not found\n"", __func__);
 		r = -EINVAL;
 		goto out_free;
 	}

	/* Don't allow bridges to be assigned */
	pci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);
	if ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {
		r = -EPERM;
		goto out_put;
	}

	r = probe_sysfs_permissions(dev);
	if (r)
		goto out_put;

 	if (pci_enable_device(dev)) {
 		printk(KERN_INFO ""%s: Could not enable PCI device\n"", __func__);
 		r = -EBUSY;
		goto out_put;
	}
	r = pci_request_regions(dev, ""kvm_assigned_device"");
	if (r) {
		printk(KERN_INFO ""%s: Could not get access to device regions\n"",
		       __func__);
		goto out_disable;
	}

	pci_reset_function(dev);
	pci_save_state(dev);
	match->pci_saved_state = pci_store_saved_state(dev);
	if (!match->pci_saved_state)
		printk(KERN_DEBUG ""%s: Couldn't store %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	match->assigned_dev_id = assigned_dev->assigned_dev_id;
	match->host_segnr = assigned_dev->segnr;
	match->host_busnr = assigned_dev->busnr;
	match->host_devfn = assigned_dev->devfn;
	match->flags = assigned_dev->flags;
	match->dev = dev;
	spin_lock_init(&match->intx_lock);
	match->irq_source_id = -1;
	match->kvm = kvm;
	match->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;

	list_add(&match->list, &kvm->arch.assigned_dev_head);

	if (!kvm->arch.iommu_domain) {
		r = kvm_iommu_map_guest(kvm);
		if (r)
			goto out_list_del;
	}
	r = kvm_assign_device(kvm, match);
	if (r)
		goto out_list_del;

out:
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
out_list_del:
	if (pci_load_and_free_saved_state(dev, &match->pci_saved_state))
		printk(KERN_INFO ""%s: Couldn't reload %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	list_del(&match->list);
	pci_release_regions(dev);
out_disable:
	pci_disable_device(dev);
out_put:
	pci_dev_put(dev);
out_free:
	kfree(match);
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
}
","The `kvm_vm_ioctl_assign_device` function is responsible for assigning a PCI device to a KVM (Kernel-based Virtual Machine) instance, ensuring that the device is properly configured and managed. It first checks if IOMMU support is enabled, then acquires locks for thread safety. The function searches for an existing assignment of the device; if found, it returns an error. If not, it allocates memory for a new device structure, retrieves the PCI device, enables it, and requests access to its regions. The device's state is saved, and it is added to the KVM's assigned device list. Finally, it maps the device to the guest and handles cleanup in case of errors.","The code defines a function that assigns a PCI device to a virtual machine, ensuring proper configuration and management of the device. It begins by verifying the necessary support for device assignment, then locks resources to maintain thread safety. The function checks for existing assignments and, if none are found, allocates memory for a new device structure. It retrieves and enables the specified PCI device, requests access to its resources, and saves its state. The device is then added to the virtual machine's list of assigned devices, with appropriate error handling and cleanup procedures in case of failures.","The vulnerability in the original code stemmed from allowing the assignment of PCI devices without sufficient checks, which could lead to configuration errors, such as assigning bridge devices or devices lacking Base Address Registers (BARs). This could result in unexpected behavior or system instability. The fixed code addresses this by introducing checks to ensure that only non-bridge devices with BAR resources are assigned. Additionally, it verifies user permissions to access the PCI sysfs resource files, ensuring that only authorized users can assign devices, thereby enhancing security and preventing misuse of device assignments.","The vulnerability in the original code allowed the assignment of PCI devices without adequate validation, potentially permitting the assignment of unsupported bridge devices or those lacking necessary resources, which could lead to system instability and unexpected behavior. The fixed code addresses this issue by implementing strict checks to ensure that only devices that are not bridges, possess the required resources, and are accessible to authorized users can be assigned. This approach prevents misconfigurations and unauthorized access, thereby enhancing the overall security and stability of the system during device assignments.","The vulnerability was fixed by adding specific checks in the code to validate the PCI device before assignment. The code now reads the device's configuration to determine its header type, ensuring that it is not a bridge by checking if the header type matches the normal type. Additionally, it verifies that the device has Base Address Registers (BARs) and checks user permissions through the `probe_sysfs_permissions` function. These enhancements prevent the assignment of unsupported devices and ensure that only authorized users can access the devices, thereby improving security and preventing potential system issues.","The vulnerability was fixed by implementing stringent validation checks before allowing the assignment of PCI devices. The updated code ensures that only devices that are not bridges and possess the necessary resources are eligible for assignment. Additionally, it incorporates a permission check to confirm that the user has the appropriate access rights to the device. These measures prevent the assignment of unsupported or misconfigured devices, thereby reducing the risk of system instability and unauthorized access, ultimately enhancing the security and reliability of the device assignment process.","CWE-269, CWE-732, CWE-284, CWE-749, CWE-862, CWE-285, CWE-20, CWE-754, CWE-665, CWE-669",N,-1
30,30,179406,179406,,Local,Not required,,CVE-2011-1019,https://www.cvedetails.com/cve/CVE-2011-1019/,CWE-264,Medium,,Partial,,2013-03-01,1.9,The dev_load function in net/core/dev.c in the Linux kernel before 2.6.38 allows local users to bypass an intended CAP_SYS_MODULE capability requirement and load arbitrary modules by leveraging the CAP_NET_ADMIN capability.,2013-03-04,Bypass ,10,https://github.com/torvalds/linux/commit/8909c9ad8ff03611c9c96c9a92656213e4bb495b,8909c9ad8ff03611c9c96c9a92656213e4bb495b,"net: don't allow CAP_NET_ADMIN to load non-netdev kernel modules

Since a8f80e8ff94ecba629542d9b4b5f5a8ee3eb565c any process with
CAP_NET_ADMIN may load any module from /lib/modules/.  This doesn't mean
that CAP_NET_ADMIN is a superset of CAP_SYS_MODULE as modules are
limited to /lib/modules/**.  However, CAP_NET_ADMIN capability shouldn't
allow anybody load any module not related to networking.

This patch restricts an ability of autoloading modules to netdev modules
with explicit aliases.  This fixes CVE-2011-1019.

Arnd Bergmann suggested to leave untouched the old pre-v2.6.32 behavior
of loading netdev modules by name (without any prefix) for processes
with CAP_SYS_MODULE to maintain the compatibility with network scripts
that use autoloading netdev modules by aliases like ""eth0"", ""wlan0"".

Currently there are only three users of the feature in the upstream
kernel: ipip, ip_gre and sit.

    root@albatros:~# capsh --drop=$(seq -s, 0 11),$(seq -s, 13 34) --
    root@albatros:~# grep Cap /proc/$$/status
    CapInh:	0000000000000000
    CapPrm:	fffffff800001000
    CapEff:	fffffff800001000
    CapBnd:	fffffff800001000
    root@albatros:~# modprobe xfs
    FATAL: Error inserting xfs
    (/lib/modules/2.6.38-rc6-00001-g2bf4ca3/kernel/fs/xfs/xfs.ko): Operation not permitted
    root@albatros:~# lsmod | grep xfs
    root@albatros:~# ifconfig xfs
    xfs: error fetching interface information: Device not found
    root@albatros:~# lsmod | grep xfs
    root@albatros:~# lsmod | grep sit
    root@albatros:~# ifconfig sit
    sit: error fetching interface information: Device not found
    root@albatros:~# lsmod | grep sit
    root@albatros:~# ifconfig sit0
    sit0      Link encap:IPv6-in-IPv4
	      NOARP  MTU:1480  Metric:1

    root@albatros:~# lsmod | grep sit
    sit                    10457  0
    tunnel4                 2957  1 sit

For CAP_SYS_MODULE module loading is still relaxed:

    root@albatros:~# grep Cap /proc/$$/status
    CapInh:	0000000000000000
    CapPrm:	ffffffffffffffff
    CapEff:	ffffffffffffffff
    CapBnd:	ffffffffffffffff
    root@albatros:~# ifconfig xfs
    xfs: error fetching interface information: Device not found
    root@albatros:~# lsmod | grep xfs
    xfs                   745319  0

Reference: https://lkml.org/lkml/2011/2/24/203

Signed-off-by: Vasiliy Kulikov <segoon@openwall.com>
Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
Acked-by: David S. Miller <davem@davemloft.net>
Acked-by: Kees Cook <kees.cook@canonical.com>
Signed-off-by: James Morris <jmorris@namei.org>",2,net/core/dev.c,"{""sha"": ""71caf7a5e6c6cc59fd975f06a0ce6bb304288d52"", ""filename"": ""include/linux/netdevice.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/8909c9ad8ff03611c9c96c9a92656213e4bb495b/include/linux/netdevice.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8909c9ad8ff03611c9c96c9a92656213e4bb495b/include/linux/netdevice.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/netdevice.h?ref=8909c9ad8ff03611c9c96c9a92656213e4bb495b"", ""patch"": ""@@ -2392,6 +2392,9 @@ extern int netdev_notice(const struct net_device *dev, const char *format, ...)\n extern int netdev_info(const struct net_device *dev, const char *format, ...)\n \t__attribute__ ((format (printf, 2, 3)));\n \n+#define MODULE_ALIAS_NETDEV(device) \\\n+\tMODULE_ALIAS(\""netdev-\"" device)\n+\n #if defined(DEBUG)\n #define netdev_dbg(__dev, format, args...)\t\t\t\\\n \tnetdev_printk(KERN_DEBUG, __dev, format, ##args)""}<_**next**_>{""sha"": ""6561021d22d1fef9b58ec54ec2b394400fb7ba25"", ""filename"": ""net/core/dev.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 2, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/core/dev.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/core/dev.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/core/dev.c?ref=8909c9ad8ff03611c9c96c9a92656213e4bb495b"", ""patch"": ""@@ -1114,13 +1114,21 @@ EXPORT_SYMBOL(netdev_bonding_change);\n void dev_load(struct net *net, const char *name)\n {\n \tstruct net_device *dev;\n+\tint no_module;\n \n \trcu_read_lock();\n \tdev = dev_get_by_name_rcu(net, name);\n \trcu_read_unlock();\n \n-\tif (!dev && capable(CAP_NET_ADMIN))\n-\t\trequest_module(\""%s\"", name);\n+\tno_module = !dev;\n+\tif (no_module && capable(CAP_NET_ADMIN))\n+\t\tno_module = request_module(\""netdev-%s\"", name);\n+\tif (no_module && capable(CAP_SYS_MODULE)) {\n+\t\tif (!request_module(\""%s\"", name))\n+\t\t\tpr_err(\""Loading kernel module for a network device \""\n+\""with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s \""\n+\""instead\\n\"", name);\n+\t}\n }\n EXPORT_SYMBOL(dev_load);\n ""}<_**next**_>{""sha"": ""d1d0e2c256fc4080033a01a621f73b1c3b080b7e"", ""filename"": ""net/ipv4/ip_gre.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/ipv4/ip_gre.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/ipv4/ip_gre.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/ip_gre.c?ref=8909c9ad8ff03611c9c96c9a92656213e4bb495b"", ""patch"": ""@@ -1765,4 +1765,4 @@ module_exit(ipgre_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_ALIAS_RTNL_LINK(\""gre\"");\n MODULE_ALIAS_RTNL_LINK(\""gretap\"");\n-MODULE_ALIAS(\""gre0\"");\n+MODULE_ALIAS_NETDEV(\""gre0\"");""}<_**next**_>{""sha"": ""a5f58e7cbb26eec188786ff1324cfc540aba1ce1"", ""filename"": ""net/ipv4/ipip.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/ipv4/ipip.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/ipv4/ipip.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/ipip.c?ref=8909c9ad8ff03611c9c96c9a92656213e4bb495b"", ""patch"": ""@@ -913,4 +913,4 @@ static void __exit ipip_fini(void)\n module_init(ipip_init);\n module_exit(ipip_fini);\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""tunl0\"");\n+MODULE_ALIAS_NETDEV(\""tunl0\"");""}<_**next**_>{""sha"": ""d2c16e10f650807ec32cc0502efa32cea8bc93b6"", ""filename"": ""net/ipv6/sit.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/ipv6/sit.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/8909c9ad8ff03611c9c96c9a92656213e4bb495b/net/ipv6/sit.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/sit.c?ref=8909c9ad8ff03611c9c96c9a92656213e4bb495b"", ""patch"": ""@@ -1290,4 +1290,4 @@ static int __init sit_init(void)\n module_init(sit_init);\n module_exit(sit_cleanup);\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""sit0\"");\n+MODULE_ALIAS_NETDEV(\""sit0\"");""}"," void dev_load(struct net *net, const char *name)
 {
 	struct net_device *dev;
	int no_module;
 
 	rcu_read_lock();
 	dev = dev_get_by_name_rcu(net, name);
 	rcu_read_unlock();
 
	no_module = !dev;
	if (no_module && capable(CAP_NET_ADMIN))
		no_module = request_module(""netdev-%s"", name);
	if (no_module && capable(CAP_SYS_MODULE)) {
		if (!request_module(""%s"", name))
			pr_err(""Loading kernel module for a network device ""
""with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s ""
""instead\n"", name);
	}
 }
"," void dev_load(struct net *net, const char *name)
 {
 	struct net_device *dev;
 
 	rcu_read_lock();
 	dev = dev_get_by_name_rcu(net, name);
 	rcu_read_unlock();
 
	if (!dev && capable(CAP_NET_ADMIN))
		request_module(""%s"", name);
 }
",C,"	int no_module;
	no_module = !dev;
	if (no_module && capable(CAP_NET_ADMIN))
		no_module = request_module(""netdev-%s"", name);
	if (no_module && capable(CAP_SYS_MODULE)) {
		if (!request_module(""%s"", name))
			pr_err(""Loading kernel module for a network device ""
""with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s ""
""instead\n"", name);
	}
","	if (!dev && capable(CAP_NET_ADMIN))
		request_module(""%s"", name);
",,"@@ -1114,13 +1114,21 @@ EXPORT_SYMBOL(netdev_bonding_change);
 void dev_load(struct net *net, const char *name)
 {
 	struct net_device *dev;
+	int no_module;
 
 	rcu_read_lock();
 	dev = dev_get_by_name_rcu(net, name);
 	rcu_read_unlock();
 
-	if (!dev && capable(CAP_NET_ADMIN))
-		request_module(""%s"", name);
+	no_module = !dev;
+	if (no_module && capable(CAP_NET_ADMIN))
+		no_module = request_module(""netdev-%s"", name);
+	if (no_module && capable(CAP_SYS_MODULE)) {
+		if (!request_module(""%s"", name))
+			pr_err(""Loading kernel module for a network device ""
+""with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s ""
+""instead\n"", name);
+	}
 }
 EXPORT_SYMBOL(dev_load);
 ",linux,8909c9ad8ff03611c9c96c9a92656213e4bb495b,a5abba989deceb731047425812d268daf7536575,1," void dev_load(struct net *net, const char *name)
 {
 	struct net_device *dev;
//fix_flaw_line_below:
//	int no_module;
 
 	rcu_read_lock();
 	dev = dev_get_by_name_rcu(net, name);
 	rcu_read_unlock();
 
//flaw_line_below:
	if (!dev && capable(CAP_NET_ADMIN))
//flaw_line_below:
		request_module(""%s"", name);
//fix_flaw_line_below:
//	no_module = !dev;
//fix_flaw_line_below:
//	if (no_module && capable(CAP_NET_ADMIN))
//fix_flaw_line_below:
//		no_module = request_module(""netdev-%s"", name);
//fix_flaw_line_below:
//	if (no_module && capable(CAP_SYS_MODULE)) {
//fix_flaw_line_below:
//		if (!request_module(""%s"", name))
//fix_flaw_line_below:
//			pr_err(""Loading kernel module for a network device ""
//fix_flaw_line_below:
//""with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s ""
//fix_flaw_line_below:
//""instead\n"", name);
//fix_flaw_line_below:
//	}
 }
",179406," void dev_load(struct net *net, const char *name)
 {
 	struct net_device *dev;
 
 	rcu_read_lock();
 	dev = dev_get_by_name_rcu(net, name);
 	rcu_read_unlock();
 
	if (!dev && capable(CAP_NET_ADMIN))
		request_module(""%s"", name);
 }
"," void dev_load(struct net *net, const char *name)
 {
 	struct net_device *dev;
	int no_module;
 
 	rcu_read_lock();
 	dev = dev_get_by_name_rcu(net, name);
 	rcu_read_unlock();
 
	no_module = !dev;
	if (no_module && capable(CAP_NET_ADMIN))
		no_module = request_module(""netdev-%s"", name);
	if (no_module && capable(CAP_SYS_MODULE)) {
		if (!request_module(""%s"", name))
			pr_err(""Loading kernel module for a network device ""
""with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s ""
""instead\n"", name);
	}
 }
","The provided code defines a function `dev_load` that attempts to retrieve a network device by its name within a specified network namespace. It first acquires a read lock using `rcu_read_lock()` to ensure safe access to shared data, then calls `dev_get_by_name_rcu()` to find the device. After releasing the lock with `rcu_read_unlock()`, it checks if the device was not found. If the device is absent and the calling process has administrative privileges (checked via `capable(CAP_NET_ADMIN)`), it requests the loading of the corresponding kernel module using `request_module()`, allowing for dynamic device management.","The code defines a function that attempts to locate a network device by its name within a specific network context. It begins by acquiring a read lock to ensure safe access to shared resources, then searches for the device. After releasing the lock, it checks if the device was found. If the device is not present and the calling entity has the necessary administrative permissions, the function requests the loading of the appropriate kernel module. This process facilitates dynamic management of network devices, allowing for the addition of new devices as needed.","The vulnerability in the original code allowed any process with the CAP_NET_ADMIN capability to load any kernel module from the system, not just those related to networking. This posed a security risk, as it could enable unauthorized access to non-networking modules. The fix introduced a check to ensure that only network device modules with specific aliases could be loaded by processes with CAP_NET_ADMIN. Additionally, it maintained the ability for processes with CAP_SYS_MODULE to load modules by name without restrictions, thus preserving compatibility while tightening security around module loading for network devices.","The vulnerability in the original code allowed any process with administrative network capabilities to load any kernel module from the system, not just those related to networking. This posed a significant security risk, as it could lead to unauthorized access or manipulation of non-networking modules. The fix implemented a restriction that only allows the loading of network device modules with specific aliases by processes with the same administrative capabilities. This change ensures that the ability to load modules is limited to those relevant to networking, thereby enhancing security while maintaining compatibility for certain legacy behaviors.","The vulnerability was fixed by introducing a check for the presence of a specific alias when loading modules. In the updated code, after determining that a device was not found, the condition `no_module && capable(CAP_NET_ADMIN)` was modified to require that only network device modules with explicit aliases could be loaded using `request_module(""netdev-%s"", name)`. Additionally, for processes with `CAP_SYS_MODULE`, the code allows loading modules by name without restrictions, ensuring compatibility with existing network scripts. This dual approach effectively restricts unauthorized module loading while maintaining necessary functionality for legitimate use cases.","The vulnerability was addressed by implementing a restriction that limits the loading of kernel modules to only those related to network devices with specific aliases. The updated code checks for the presence of these aliases before allowing a module to be loaded by processes with administrative network capabilities. Additionally, it maintains the ability for processes with broader module loading permissions to load modules by name without restrictions, ensuring compatibility with existing network scripts. This approach effectively enhances security by preventing unauthorized access to non-networking modules while still supporting necessary functionalities.","CWE-269, CWE-266, CWE-732, CWE-250, CWE-264, CWE-272, CWE-284, CWE-269, CWE-270, CWE-287",N,-1
31,31,179455,179455,,Local,Not required,Complete,CVE-2014-5206,https://www.cvedetails.com/cve/CVE-2014-5206/,CWE-264,Low,Complete,Complete,,2014-08-18,7.2,"The do_remount function in fs/namespace.c in the Linux kernel through 3.16.1 does not maintain the MNT_LOCK_READONLY bit across a remount of a bind mount, which allows local users to bypass an intended read-only restriction and defeat certain sandbox protection mechanisms via a *mount -o remount* command within a user namespace.",2017-01-06,Bypass ,1,https://github.com/torvalds/linux/commit/a6138db815df5ee542d848318e5dae681590fccd,a6138db815df5ee542d848318e5dae681590fccd,"mnt: Only change user settable mount flags in remount

Kenton Varda <kenton@sandstorm.io> discovered that by remounting a
read-only bind mount read-only in a user namespace the
MNT_LOCK_READONLY bit would be cleared, allowing an unprivileged user
to the remount a read-only mount read-write.

Correct this by replacing the mask of mount flags to preserve
with a mask of mount flags that may be changed, and preserve
all others.   This ensures that any future bugs with this mask and
remount will fail in an easy to detect way where new mount flags
simply won't change.

Cc: stable@vger.kernel.org
Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",1,fs/namespace.c,"{""sha"": ""cb40449ea0dfe8983d45162ef724c45898d2424a"", ""filename"": ""fs/namespace.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a6138db815df5ee542d848318e5dae681590fccd/fs/namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a6138db815df5ee542d848318e5dae681590fccd/fs/namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namespace.c?ref=a6138db815df5ee542d848318e5dae681590fccd"", ""patch"": ""@@ -1937,7 +1937,7 @@ static int do_remount(struct path *path, int flags, int mnt_flags,\n \t\terr = do_remount_sb(sb, flags, data, 0);\n \tif (!err) {\n \t\tlock_mount_hash();\n-\t\tmnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;\n+\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n \t\tmnt->mnt.mnt_flags = mnt_flags;\n \t\ttouch_mnt_namespace(mnt->mnt_ns);\n \t\tunlock_mount_hash();""}<_**next**_>{""sha"": ""b637a89e1faeb271af0ab5e850e47fdf9d8f487c"", ""filename"": ""include/linux/mount.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/a6138db815df5ee542d848318e5dae681590fccd/include/linux/mount.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a6138db815df5ee542d848318e5dae681590fccd/include/linux/mount.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/mount.h?ref=a6138db815df5ee542d848318e5dae681590fccd"", ""patch"": ""@@ -42,7 +42,9 @@ struct mnt_namespace;\n  * flag, consider how it interacts with shared mounts.\n  */\n #define MNT_SHARED_MASK\t(MNT_UNBINDABLE)\n-#define MNT_PROPAGATION_MASK\t(MNT_SHARED | MNT_UNBINDABLE)\n+#define MNT_USER_SETTABLE_MASK  (MNT_NOSUID | MNT_NODEV | MNT_NOEXEC \\\n+\t\t\t\t | MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME \\\n+\t\t\t\t | MNT_READONLY)\n \n #define MNT_INTERNAL_FLAGS (MNT_SHARED | MNT_WRITE_HOLD | MNT_INTERNAL | \\\n \t\t\t    MNT_DOOMED | MNT_SYNC_UMOUNT | MNT_MARKED)""}","static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}
","static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}
",C,"		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
","		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
",,"@@ -1937,7 +1937,7 @@ static int do_remount(struct path *path, int flags, int mnt_flags,
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
-		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
+		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();",linux,a6138db815df5ee542d848318e5dae681590fccd,728dba3a39c66b3d8ac889ddbe38b5b1c264aec3,1,"static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
//flaw_line_below:
		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
//fix_flaw_line_below:
//		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}
",179455,"static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}
","static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}
","The `do_remount` function is responsible for remounting a filesystem in a Linux kernel environment. It first verifies the validity of the mount point and checks if the specified path corresponds to the root of the mount. It then calls a security function to ensure the operation is permitted. Depending on the provided flags, it either changes the mount flags or checks for administrative capabilities. If successful, it updates the mount's flags, modifies the namespace, and manages locking to ensure thread safety. The function ultimately returns an error code or zero upon successful completion of the remount operation.","The provided code implements a function that facilitates the remounting of a filesystem within a kernel environment. It begins by validating the mount point and ensuring the specified path is the root of the mount. The function then checks security permissions before proceeding. Depending on the specified options, it either modifies the mount flags or verifies administrative privileges. Upon successful execution, it updates the mount's properties, adjusts the namespace, and ensures thread safety through appropriate locking mechanisms. The function concludes by returning an error code or indicating success, reflecting the outcome of the remount operation.","The vulnerability in the original code allowed an unprivileged user to change a read-only bind mount to read-write by improperly clearing the `MNT_LOCK_READONLY` bit during a remount operation. This occurred because the code used a mask that did not adequately protect against changes to critical mount flags. The fix involved modifying the mask applied to the mount flags, specifically replacing it with a mask that only allows changes to user-settable flags while preserving all other flags. This change ensures that critical flags, such as `MNT_LOCK_READONLY`, remain intact, preventing unauthorized modifications to mount permissions.","The vulnerability in the original code allowed unprivileged users to change a read-only bind mount to read-write by inadvertently clearing a critical flag during the remount process. This occurred because the code used an inappropriate mask that did not adequately protect essential mount flags, leading to potential privilege escalation. The fix involved updating the mask to ensure that only user-settable flags could be modified while preserving all other flags. This change prevents unauthorized alterations to critical mount permissions, thereby enhancing security and ensuring that any future issues with the mask would be easier to detect.","The vulnerability was fixed by modifying the mask applied to the mount flags during the remount operation. In the original code, the mask used allowed critical flags, such as `MNT_LOCK_READONLY`, to be cleared, which could lead to unauthorized changes in mount permissions. The updated code replaces the mask with one that only allows changes to user-settable flags, specifically using `~MNT_USER_SETTABLE_MASK` to preserve all other flags. This ensures that essential flags remain intact, preventing unprivileged users from altering read-only mounts and enhancing the overall security of the remount functionality.","The vulnerability was addressed by changing the approach to how mount flags are modified during the remount process. The fix involved implementing a new mask that restricts modifications to only those flags that are user-settable, while ensuring that all other critical flags remain unchanged. This adjustment prevents the accidental clearing of essential flags that could allow unprivileged users to alter mount permissions improperly. By safeguarding these important flags, the fix enhances the security of the remount functionality and mitigates the risk of unauthorized privilege escalation in the filesystem.","CWE-269, CWE-264, CWE-732, CWE-284, CWE-266, CWE-274, CWE-16, CWE-285, CWE-281, CWE-265",N,-1
32,32,179487,179487,,Local Network,Single system,,CVE-2014-4027,https://www.cvedetails.com/cve/CVE-2014-4027/,CWE-264,Medium,Partial,,,2014-06-23,2.3,"The rd_build_device_space function in drivers/target/target_core_rd.c in the Linux kernel before 3.14 does not properly initialize a certain data structure, which allows local users to obtain sensitive information from ramdisk_mcp memory by leveraging access to a SCSI initiator.",2017-01-06,+Info ,50,https://github.com/torvalds/linux/commit/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc,4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc,"target/rd: Refactor rd_build_device_space + rd_release_device_space

This patch refactors rd_build_device_space() + rd_release_device_space()
into rd_allocate_sgl_table() + rd_release_device_space() so that they
may be used seperatly for setup + release of protection information
scatterlists.

Also add explicit memset of pages within rd_allocate_sgl_table() based
upon passed 'init_payload' value.

v2 changes:
  - Drop unused sg_table from rd_release_device_space (Wei)

Cc: Martin K. Petersen <martin.petersen@oracle.com>
Cc: Christoph Hellwig <hch@lst.de>
Cc: Hannes Reinecke <hare@suse.de>
Cc: Sagi Grimberg <sagig@mellanox.com>
Cc: Or Gerlitz <ogerlitz@mellanox.com>
Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>",23,drivers/target/target_core_rd.c,"{""sha"": ""e9fa879ac27f31f5cbdd61fecf29c4095b366b50"", ""filename"": ""drivers/target/target_core_rd.c"", ""status"": ""modified"", ""additions"": 68, ""deletions"": 45, ""changes"": 113, ""blob_url"": ""https://github.com/torvalds/linux/blob/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc/drivers/target/target_core_rd.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc/drivers/target/target_core_rd.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/target/target_core_rd.c?ref=4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc"", ""patch"": ""@@ -78,23 +78,14 @@ static void rd_detach_hba(struct se_hba *hba)\n \thba->hba_ptr = NULL;\n }\n \n-/*\trd_release_device_space():\n- *\n- *\n- */\n-static void rd_release_device_space(struct rd_dev *rd_dev)\n+static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n+\t\t\t\t u32 sg_table_count)\n {\n-\tu32 i, j, page_count = 0, sg_per_table;\n-\tstruct rd_dev_sg_table *sg_table;\n \tstruct page *pg;\n \tstruct scatterlist *sg;\n+\tu32 i, j, page_count = 0, sg_per_table;\n \n-\tif (!rd_dev->sg_table_array || !rd_dev->sg_table_count)\n-\t\treturn;\n-\n-\tsg_table = rd_dev->sg_table_array;\n-\n-\tfor (i = 0; i < rd_dev->sg_table_count; i++) {\n+\tfor (i = 0; i < sg_table_count; i++) {\n \t\tsg = sg_table[i].sg_table;\n \t\tsg_per_table = sg_table[i].rd_sg_count;\n \n@@ -105,16 +96,28 @@ static void rd_release_device_space(struct rd_dev *rd_dev)\n \t\t\t\tpage_count++;\n \t\t\t}\n \t\t}\n-\n \t\tkfree(sg);\n \t}\n \n+\tkfree(sg_table);\n+\treturn page_count;\n+}\n+\n+static void rd_release_device_space(struct rd_dev *rd_dev)\n+{\n+\tu32 page_count;\n+\n+\tif (!rd_dev->sg_table_array || !rd_dev->sg_table_count)\n+\t\treturn;\n+\n+\tpage_count = rd_release_sgl_table(rd_dev, rd_dev->sg_table_array,\n+\t\t\t\t\t  rd_dev->sg_table_count);\n+\n \tpr_debug(\""CORE_RD[%u] - Released device space for Ramdisk\""\n \t\t\"" Device ID: %u, pages %u in %u tables total bytes %lu\\n\"",\n \t\trd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,\n \t\trd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);\n \n-\tkfree(sg_table);\n \trd_dev->sg_table_array = NULL;\n \trd_dev->sg_table_count = 0;\n }\n@@ -124,38 +127,15 @@ static void rd_release_device_space(struct rd_dev *rd_dev)\n  *\n  *\n  */\n-static int rd_build_device_space(struct rd_dev *rd_dev)\n+static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n+\t\t\t\t u32 total_sg_needed, unsigned char init_payload)\n {\n-\tu32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;\n+\tu32 i = 0, j, page_offset = 0, sg_per_table;\n \tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n \t\t\t\tsizeof(struct scatterlist));\n-\tstruct rd_dev_sg_table *sg_table;\n \tstruct page *pg;\n \tstruct scatterlist *sg;\n-\n-\tif (rd_dev->rd_page_count <= 0) {\n-\t\tpr_err(\""Illegal page count: %u for Ramdisk device\\n\"",\n-\t\t\trd_dev->rd_page_count);\n-\t\treturn -EINVAL;\n-\t}\n-\n-\t/* Don't need backing pages for NULLIO */\n-\tif (rd_dev->rd_flags & RDF_NULLIO)\n-\t\treturn 0;\n-\n-\ttotal_sg_needed = rd_dev->rd_page_count;\n-\n-\tsg_tables = (total_sg_needed / max_sg_per_table) + 1;\n-\n-\tsg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);\n-\tif (!sg_table) {\n-\t\tpr_err(\""Unable to allocate memory for Ramdisk\""\n-\t\t\t\"" scatterlist tables\\n\"");\n-\t\treturn -ENOMEM;\n-\t}\n-\n-\trd_dev->sg_table_array = sg_table;\n-\trd_dev->sg_table_count = sg_tables;\n+\tunsigned char *p;\n \n \twhile (total_sg_needed) {\n \t\tsg_per_table = (total_sg_needed > max_sg_per_table) ?\n@@ -186,16 +166,59 @@ static int rd_build_device_space(struct rd_dev *rd_dev)\n \t\t\t}\n \t\t\tsg_assign_page(&sg[j], pg);\n \t\t\tsg[j].length = PAGE_SIZE;\n+\n+\t\t\tp = kmap(pg);\n+\t\t\tmemset(p, init_payload, PAGE_SIZE);\n+\t\t\tkunmap(pg);\n \t\t}\n \n \t\tpage_offset += sg_per_table;\n \t\ttotal_sg_needed -= sg_per_table;\n \t}\n \n+\treturn 0;\n+}\n+\n+static int rd_build_device_space(struct rd_dev *rd_dev)\n+{\n+\tstruct rd_dev_sg_table *sg_table;\n+\tu32 sg_tables, total_sg_needed;\n+\tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n+\t\t\t\tsizeof(struct scatterlist));\n+\tint rc;\n+\n+\tif (rd_dev->rd_page_count <= 0) {\n+\t\tpr_err(\""Illegal page count: %u for Ramdisk device\\n\"",\n+\t\t       rd_dev->rd_page_count);\n+\t\treturn -EINVAL;\n+\t}\n+\n+\t/* Don't need backing pages for NULLIO */\n+\tif (rd_dev->rd_flags & RDF_NULLIO)\n+\t\treturn 0;\n+\n+\ttotal_sg_needed = rd_dev->rd_page_count;\n+\n+\tsg_tables = (total_sg_needed / max_sg_per_table) + 1;\n+\n+\tsg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);\n+\tif (!sg_table) {\n+\t\tpr_err(\""Unable to allocate memory for Ramdisk\""\n+\t\t       \"" scatterlist tables\\n\"");\n+\t\treturn -ENOMEM;\n+\t}\n+\n+\trd_dev->sg_table_array = sg_table;\n+\trd_dev->sg_table_count = sg_tables;\n+\n+\trc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);\n+\tif (rc)\n+\t\treturn rc;\n+\n \tpr_debug(\""CORE_RD[%u] - Built Ramdisk Device ID: %u space of\""\n-\t\t\"" %u pages in %u tables\\n\"", rd_dev->rd_host->rd_host_id,\n-\t\trd_dev->rd_dev_id, rd_dev->rd_page_count,\n-\t\trd_dev->sg_table_count);\n+\t\t \"" %u pages in %u tables\\n\"", rd_dev->rd_host->rd_host_id,\n+\t\t rd_dev->rd_dev_id, rd_dev->rd_page_count,\n+\t\t rd_dev->sg_table_count);\n \n \treturn 0;\n }""}","static int rd_build_device_space(struct rd_dev *rd_dev)
static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
				 u32 total_sg_needed, unsigned char init_payload)
 {
	u32 i = 0, j, page_offset = 0, sg_per_table;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
 	struct page *pg;
 	struct scatterlist *sg;
	unsigned char *p;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
			max_sg_per_table : total_sg_needed;

		sg = kzalloc(sg_per_table * sizeof(struct scatterlist),
				GFP_KERNEL);
		if (!sg) {
			pr_err(""Unable to allocate scatterlist array""
				"" for struct rd_dev\n"");
			return -ENOMEM;
		}

		sg_init_table(sg, sg_per_table);

		sg_table[i].sg_table = sg;
		sg_table[i].rd_sg_count = sg_per_table;
		sg_table[i].page_start_offset = page_offset;
		sg_table[i++].page_end_offset = (page_offset + sg_per_table)
						- 1;

		for (j = 0; j < sg_per_table; j++) {
			pg = alloc_pages(GFP_KERNEL, 0);
			if (!pg) {
				pr_err(""Unable to allocate scatterlist""
					"" pages for struct rd_dev_sg_table\n"");
				return -ENOMEM;
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;

			p = kmap(pg);
			memset(p, init_payload, PAGE_SIZE);
			kunmap(pg);
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
	return 0;
}

static int rd_build_device_space(struct rd_dev *rd_dev)
{
	struct rd_dev_sg_table *sg_table;
	u32 sg_tables, total_sg_needed;
	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
				sizeof(struct scatterlist));
	int rc;

	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
		       rd_dev->rd_page_count);
		return -EINVAL;
	}

	/* Don't need backing pages for NULLIO */
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;

	total_sg_needed = rd_dev->rd_page_count;

	sg_tables = (total_sg_needed / max_sg_per_table) + 1;

	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
		       "" scatterlist tables\n"");
		return -ENOMEM;
	}

	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;

	rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);
	if (rc)
		return rc;

 	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
		 "" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		 rd_dev->rd_dev_id, rd_dev->rd_page_count,
		 rd_dev->sg_table_count);
 
 	return 0;
 }
","static int rd_build_device_space(struct rd_dev *rd_dev)
 {
	u32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
	struct rd_dev_sg_table *sg_table;
 	struct page *pg;
 	struct scatterlist *sg;
	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
			rd_dev->rd_page_count);
		return -EINVAL;
	}
	/* Don't need backing pages for NULLIO */
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;
	total_sg_needed = rd_dev->rd_page_count;
	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
			"" scatterlist tables\n"");
		return -ENOMEM;
	}
	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
			max_sg_per_table : total_sg_needed;

		sg = kzalloc(sg_per_table * sizeof(struct scatterlist),
				GFP_KERNEL);
		if (!sg) {
			pr_err(""Unable to allocate scatterlist array""
				"" for struct rd_dev\n"");
			return -ENOMEM;
		}

		sg_init_table(sg, sg_per_table);

		sg_table[i].sg_table = sg;
		sg_table[i].rd_sg_count = sg_per_table;
		sg_table[i].page_start_offset = page_offset;
		sg_table[i++].page_end_offset = (page_offset + sg_per_table)
						- 1;

		for (j = 0; j < sg_per_table; j++) {
			pg = alloc_pages(GFP_KERNEL, 0);
			if (!pg) {
				pr_err(""Unable to allocate scatterlist""
					"" pages for struct rd_dev_sg_table\n"");
				return -ENOMEM;
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
 	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
		"" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		rd_dev->rd_dev_id, rd_dev->rd_page_count,
		rd_dev->sg_table_count);
 
 	return 0;
 }
",C,"static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
				 u32 total_sg_needed, unsigned char init_payload)
	u32 i = 0, j, page_offset = 0, sg_per_table;
	unsigned char *p;

			p = kmap(pg);
			memset(p, init_payload, PAGE_SIZE);
			kunmap(pg);
	return 0;
}

static int rd_build_device_space(struct rd_dev *rd_dev)
{
	struct rd_dev_sg_table *sg_table;
	u32 sg_tables, total_sg_needed;
	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
				sizeof(struct scatterlist));
	int rc;

	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
		       rd_dev->rd_page_count);
		return -EINVAL;
	}

	/* Don't need backing pages for NULLIO */
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;

	total_sg_needed = rd_dev->rd_page_count;

	sg_tables = (total_sg_needed / max_sg_per_table) + 1;

	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
		       "" scatterlist tables\n"");
		return -ENOMEM;
	}

	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;

	rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);
	if (rc)
		return rc;

		 "" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		 rd_dev->rd_dev_id, rd_dev->rd_page_count,
		 rd_dev->sg_table_count);
","	u32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;
	struct rd_dev_sg_table *sg_table;
	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
			rd_dev->rd_page_count);
		return -EINVAL;
	}
	/* Don't need backing pages for NULLIO */
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;
	total_sg_needed = rd_dev->rd_page_count;
	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
			"" scatterlist tables\n"");
		return -ENOMEM;
	}
	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;
		"" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		rd_dev->rd_dev_id, rd_dev->rd_page_count,
		rd_dev->sg_table_count);
",,"@@ -78,23 +78,14 @@ static void rd_detach_hba(struct se_hba *hba)
 	hba->hba_ptr = NULL;
 }
 
-/*	rd_release_device_space():
- *
- *
- */
-static void rd_release_device_space(struct rd_dev *rd_dev)
+static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
+				 u32 sg_table_count)
 {
-	u32 i, j, page_count = 0, sg_per_table;
-	struct rd_dev_sg_table *sg_table;
 	struct page *pg;
 	struct scatterlist *sg;
+	u32 i, j, page_count = 0, sg_per_table;
 
-	if (!rd_dev->sg_table_array || !rd_dev->sg_table_count)
-		return;
-
-	sg_table = rd_dev->sg_table_array;
-
-	for (i = 0; i < rd_dev->sg_table_count; i++) {
+	for (i = 0; i < sg_table_count; i++) {
 		sg = sg_table[i].sg_table;
 		sg_per_table = sg_table[i].rd_sg_count;
 
@@ -105,16 +96,28 @@ static void rd_release_device_space(struct rd_dev *rd_dev)
 				page_count++;
 			}
 		}
-
 		kfree(sg);
 	}
 
+	kfree(sg_table);
+	return page_count;
+}
+
+static void rd_release_device_space(struct rd_dev *rd_dev)
+{
+	u32 page_count;
+
+	if (!rd_dev->sg_table_array || !rd_dev->sg_table_count)
+		return;
+
+	page_count = rd_release_sgl_table(rd_dev, rd_dev->sg_table_array,
+					  rd_dev->sg_table_count);
+
 	pr_debug(""CORE_RD[%u] - Released device space for Ramdisk""
 		"" Device ID: %u, pages %u in %u tables total bytes %lu\n"",
 		rd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,
 		rd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);
 
-	kfree(sg_table);
 	rd_dev->sg_table_array = NULL;
 	rd_dev->sg_table_count = 0;
 }
@@ -124,38 +127,15 @@ static void rd_release_device_space(struct rd_dev *rd_dev)
  *
  *
  */
-static int rd_build_device_space(struct rd_dev *rd_dev)
+static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
+				 u32 total_sg_needed, unsigned char init_payload)
 {
-	u32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;
+	u32 i = 0, j, page_offset = 0, sg_per_table;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
-	struct rd_dev_sg_table *sg_table;
 	struct page *pg;
 	struct scatterlist *sg;
-
-	if (rd_dev->rd_page_count <= 0) {
-		pr_err(""Illegal page count: %u for Ramdisk device\n"",
-			rd_dev->rd_page_count);
-		return -EINVAL;
-	}
-
-	/* Don't need backing pages for NULLIO */
-	if (rd_dev->rd_flags & RDF_NULLIO)
-		return 0;
-
-	total_sg_needed = rd_dev->rd_page_count;
-
-	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
-
-	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
-	if (!sg_table) {
-		pr_err(""Unable to allocate memory for Ramdisk""
-			"" scatterlist tables\n"");
-		return -ENOMEM;
-	}
-
-	rd_dev->sg_table_array = sg_table;
-	rd_dev->sg_table_count = sg_tables;
+	unsigned char *p;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
@@ -186,16 +166,59 @@ static int rd_build_device_space(struct rd_dev *rd_dev)
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;
+
+			p = kmap(pg);
+			memset(p, init_payload, PAGE_SIZE);
+			kunmap(pg);
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
+	return 0;
+}
+
+static int rd_build_device_space(struct rd_dev *rd_dev)
+{
+	struct rd_dev_sg_table *sg_table;
+	u32 sg_tables, total_sg_needed;
+	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
+				sizeof(struct scatterlist));
+	int rc;
+
+	if (rd_dev->rd_page_count <= 0) {
+		pr_err(""Illegal page count: %u for Ramdisk device\n"",
+		       rd_dev->rd_page_count);
+		return -EINVAL;
+	}
+
+	/* Don't need backing pages for NULLIO */
+	if (rd_dev->rd_flags & RDF_NULLIO)
+		return 0;
+
+	total_sg_needed = rd_dev->rd_page_count;
+
+	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
+
+	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
+	if (!sg_table) {
+		pr_err(""Unable to allocate memory for Ramdisk""
+		       "" scatterlist tables\n"");
+		return -ENOMEM;
+	}
+
+	rd_dev->sg_table_array = sg_table;
+	rd_dev->sg_table_count = sg_tables;
+
+	rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);
+	if (rc)
+		return rc;
+
 	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
-		"" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
-		rd_dev->rd_dev_id, rd_dev->rd_page_count,
-		rd_dev->sg_table_count);
+		 "" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
+		 rd_dev->rd_dev_id, rd_dev->rd_page_count,
+		 rd_dev->sg_table_count);
 
 	return 0;
 }",linux,4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc,42201b557471f2fef2e9e028b50a773d99ffc401,1,"static int rd_build_device_space(struct rd_dev *rd_dev)
//fix_flaw_line_below:
//static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
//fix_flaw_line_below:
//				 u32 total_sg_needed, unsigned char init_payload)
 {
//flaw_line_below:
	u32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;
//fix_flaw_line_below:
//	u32 i = 0, j, page_offset = 0, sg_per_table;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
//flaw_line_below:
	struct rd_dev_sg_table *sg_table;
 	struct page *pg;
 	struct scatterlist *sg;
//flaw_line_below:

//flaw_line_below:
	if (rd_dev->rd_page_count <= 0) {
//flaw_line_below:
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
//flaw_line_below:
			rd_dev->rd_page_count);
//flaw_line_below:
		return -EINVAL;
//flaw_line_below:
	}
//flaw_line_below:

//flaw_line_below:
	/* Don't need backing pages for NULLIO */
//flaw_line_below:
	if (rd_dev->rd_flags & RDF_NULLIO)
//flaw_line_below:
		return 0;
//flaw_line_below:

//flaw_line_below:
	total_sg_needed = rd_dev->rd_page_count;
//flaw_line_below:

//flaw_line_below:
	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
//flaw_line_below:

//flaw_line_below:
	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
//flaw_line_below:
	if (!sg_table) {
//flaw_line_below:
		pr_err(""Unable to allocate memory for Ramdisk""
//flaw_line_below:
			"" scatterlist tables\n"");
//flaw_line_below:
		return -ENOMEM;
//flaw_line_below:
	}
//flaw_line_below:

//flaw_line_below:
	rd_dev->sg_table_array = sg_table;
//flaw_line_below:
	rd_dev->sg_table_count = sg_tables;
//fix_flaw_line_below:
//	unsigned char *p;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
			max_sg_per_table : total_sg_needed;

		sg = kzalloc(sg_per_table * sizeof(struct scatterlist),
				GFP_KERNEL);
		if (!sg) {
			pr_err(""Unable to allocate scatterlist array""
				"" for struct rd_dev\n"");
			return -ENOMEM;
		}

		sg_init_table(sg, sg_per_table);

		sg_table[i].sg_table = sg;
		sg_table[i].rd_sg_count = sg_per_table;
		sg_table[i].page_start_offset = page_offset;
		sg_table[i++].page_end_offset = (page_offset + sg_per_table)
						- 1;

		for (j = 0; j < sg_per_table; j++) {
			pg = alloc_pages(GFP_KERNEL, 0);
			if (!pg) {
				pr_err(""Unable to allocate scatterlist""
					"" pages for struct rd_dev_sg_table\n"");
				return -ENOMEM;
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//			p = kmap(pg);
//fix_flaw_line_below:
//			memset(p, init_payload, PAGE_SIZE);
//fix_flaw_line_below:
//			kunmap(pg);
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
//fix_flaw_line_below:
//	return 0;
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//static int rd_build_device_space(struct rd_dev *rd_dev)
//fix_flaw_line_below:
//{
//fix_flaw_line_below:
//	struct rd_dev_sg_table *sg_table;
//fix_flaw_line_below:
//	u32 sg_tables, total_sg_needed;
//fix_flaw_line_below:
//	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
//fix_flaw_line_below:
//				sizeof(struct scatterlist));
//fix_flaw_line_below:
//	int rc;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (rd_dev->rd_page_count <= 0) {
//fix_flaw_line_below:
//		pr_err(""Illegal page count: %u for Ramdisk device\n"",
//fix_flaw_line_below:
//		       rd_dev->rd_page_count);
//fix_flaw_line_below:
//		return -EINVAL;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/* Don't need backing pages for NULLIO */
//fix_flaw_line_below:
//	if (rd_dev->rd_flags & RDF_NULLIO)
//fix_flaw_line_below:
//		return 0;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	total_sg_needed = rd_dev->rd_page_count;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
//fix_flaw_line_below:
//	if (!sg_table) {
//fix_flaw_line_below:
//		pr_err(""Unable to allocate memory for Ramdisk""
//fix_flaw_line_below:
//		       "" scatterlist tables\n"");
//fix_flaw_line_below:
//		return -ENOMEM;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	rd_dev->sg_table_array = sg_table;
//fix_flaw_line_below:
//	rd_dev->sg_table_count = sg_tables;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);
//fix_flaw_line_below:
//	if (rc)
//fix_flaw_line_below:
//		return rc;
//fix_flaw_line_below:
//
 	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
//flaw_line_below:
		"" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
//flaw_line_below:
		rd_dev->rd_dev_id, rd_dev->rd_page_count,
//flaw_line_below:
		rd_dev->sg_table_count);
//fix_flaw_line_below:
//		 "" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
//fix_flaw_line_below:
//		 rd_dev->rd_dev_id, rd_dev->rd_page_count,
//fix_flaw_line_below:
//		 rd_dev->sg_table_count);
 
 	return 0;
 }
",179487,"static int rd_build_device_space(struct rd_dev *rd_dev)
 {
	u32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
	struct rd_dev_sg_table *sg_table;
 	struct page *pg;
 	struct scatterlist *sg;
	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
			rd_dev->rd_page_count);
		return -EINVAL;
	}
	/* Don't need backing pages for NULLIO */
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;
	total_sg_needed = rd_dev->rd_page_count;
	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
			"" scatterlist tables\n"");
		return -ENOMEM;
	}
	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
			max_sg_per_table : total_sg_needed;

		sg = kzalloc(sg_per_table * sizeof(struct scatterlist),
				GFP_KERNEL);
		if (!sg) {
			pr_err(""Unable to allocate scatterlist array""
				"" for struct rd_dev\n"");
			return -ENOMEM;
		}

		sg_init_table(sg, sg_per_table);

		sg_table[i].sg_table = sg;
		sg_table[i].rd_sg_count = sg_per_table;
		sg_table[i].page_start_offset = page_offset;
		sg_table[i++].page_end_offset = (page_offset + sg_per_table)
						- 1;

		for (j = 0; j < sg_per_table; j++) {
			pg = alloc_pages(GFP_KERNEL, 0);
			if (!pg) {
				pr_err(""Unable to allocate scatterlist""
					"" pages for struct rd_dev_sg_table\n"");
				return -ENOMEM;
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
 	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
		"" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		rd_dev->rd_dev_id, rd_dev->rd_page_count,
		rd_dev->sg_table_count);
 
 	return 0;
 }
","static int rd_build_device_space(struct rd_dev *rd_dev)
static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
				 u32 total_sg_needed, unsigned char init_payload)
 {
	u32 i = 0, j, page_offset = 0, sg_per_table;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
 	struct page *pg;
 	struct scatterlist *sg;
	unsigned char *p;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
			max_sg_per_table : total_sg_needed;

		sg = kzalloc(sg_per_table * sizeof(struct scatterlist),
				GFP_KERNEL);
		if (!sg) {
			pr_err(""Unable to allocate scatterlist array""
				"" for struct rd_dev\n"");
			return -ENOMEM;
		}

		sg_init_table(sg, sg_per_table);

		sg_table[i].sg_table = sg;
		sg_table[i].rd_sg_count = sg_per_table;
		sg_table[i].page_start_offset = page_offset;
		sg_table[i++].page_end_offset = (page_offset + sg_per_table)
						- 1;

		for (j = 0; j < sg_per_table; j++) {
			pg = alloc_pages(GFP_KERNEL, 0);
			if (!pg) {
				pr_err(""Unable to allocate scatterlist""
					"" pages for struct rd_dev_sg_table\n"");
				return -ENOMEM;
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;

			p = kmap(pg);
			memset(p, init_payload, PAGE_SIZE);
			kunmap(pg);
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
	return 0;
}

static int rd_build_device_space(struct rd_dev *rd_dev)
{
	struct rd_dev_sg_table *sg_table;
	u32 sg_tables, total_sg_needed;
	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
				sizeof(struct scatterlist));
	int rc;

	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
		       rd_dev->rd_page_count);
		return -EINVAL;
	}

	/* Don't need backing pages for NULLIO */
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;

	total_sg_needed = rd_dev->rd_page_count;

	sg_tables = (total_sg_needed / max_sg_per_table) + 1;

	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
		       "" scatterlist tables\n"");
		return -ENOMEM;
	}

	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;

	rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);
	if (rc)
		return rc;

 	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
		 "" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		 rd_dev->rd_dev_id, rd_dev->rd_page_count,
		 rd_dev->sg_table_count);
 
 	return 0;
 }
","The `rd_build_device_space` function allocates and initializes memory for a ramdisk device's scatter-gather (SG) tables based on the specified page count. It first checks for a valid page count and handles a special case for NULLIO flags. The function calculates the number of SG tables needed and allocates memory for them. It then iteratively allocates scatterlist arrays and pages, initializing each scatterlist entry with allocated pages. If any memory allocation fails, it logs an error and returns an appropriate error code. Finally, it logs a debug message indicating the successful construction of the ramdisk device space.","The code defines a function that allocates and sets up memory for a ramdisk device's data structure, which organizes memory into manageable segments. It begins by validating the input parameters and handling a specific case where no backing pages are needed. The function calculates the required number of memory segments and allocates the necessary structures. It then iteratively allocates memory for each segment and assigns pages to them, ensuring proper initialization. If any memory allocation fails, it logs an error and returns an appropriate error code, while also logging a success message upon completion of the setup process.","The vulnerability in the original code stemmed from the lack of initialization for the allocated pages, which could lead to exposure of sensitive data if the memory was reused without being cleared. This was addressed in the refactored code by introducing a separate function that not only allocates the scatter-gather tables but also explicitly initializes the allocated pages using `memset`, based on a provided initialization payload. This ensures that any previously stored data in the memory is overwritten, thereby preventing potential information leaks and enhancing the security of the memory management process.","The vulnerability in the original code arose from the allocation of memory without proper initialization, which could inadvertently expose sensitive data from previously used memory. This oversight posed a security risk, as uninitialized memory could leak information to unauthorized users. The refactored code addressed this issue by separating the memory allocation and initialization processes, ensuring that allocated memory is explicitly cleared using a specific initialization value. This change guarantees that any residual data is overwritten, thereby enhancing security and preventing potential information leaks in the memory management routine.","The vulnerability was fixed by refactoring the memory allocation process into a separate function, `rd_allocate_sgl_table`, which now includes an explicit call to `memset` for the allocated pages. This function takes an initialization payload as an argument, allowing it to clear the memory of any previously stored data after allocation. By using `memset` with the provided `init_payload`, the code ensures that all allocated pages are initialized to a known state, effectively preventing any leakage of sensitive information that could occur from uninitialized memory. This change significantly enhances the security of the memory management process.","The vulnerability was addressed by restructuring the code to separate the memory allocation and initialization processes. A new function was introduced to handle the allocation of memory, which now includes a step to explicitly clear the allocated memory using a specified initialization value. This ensures that any residual data from previous uses of the memory is overwritten, thereby preventing the exposure of sensitive information. By implementing this explicit initialization, the code enhances security and mitigates the risk of information leaks associated with uninitialized memory.","CWE-908, CWE-665, CWE-14, CWE-226, CWE-201, CWE-244, CWE-665, CWE-761, CWE-457, CWE-562",N,-1
33,33,179553,179553,,Local,Not required,Complete,CVE-2014-3153,https://www.cvedetails.com/cve/CVE-2014-3153/,CWE-264,Low,Complete,Complete,,2014-06-07,7.2,"The futex_requeue function in kernel/futex.c in the Linux kernel through 3.14.5 does not ensure that calls have two different futex addresses, which allows local users to gain privileges via a crafted FUTEX_REQUEUE command that facilitates unsafe waiter modification.",2019-04-22,+Priv ,16,https://github.com/torvalds/linux/commit/e9c243a5a6de0be8e584c604d353412584b592f8,e9c243a5a6de0be8e584c604d353412584b592f8,"futex-prevent-requeue-pi-on-same-futex.patch futex: Forbid uaddr == uaddr2 in futex_requeue(..., requeue_pi=1)

If uaddr == uaddr2, then we have broken the rule of only requeueing from
a non-pi futex to a pi futex with this call.  If we attempt this, then
dangling pointers may be left for rt_waiter resulting in an exploitable
condition.

This change brings futex_requeue() in line with futex_wait_requeue_pi()
which performs the same check as per commit 6f7b0a2a5c0f (""futex: Forbid
uaddr == uaddr2 in futex_wait_requeue_pi()"")

[ tglx: Compare the resulting keys as well, as uaddrs might be
  	different depending on the mapping ]

Fixes CVE-2014-3153.

Reported-by: Pinkie Pie
Signed-off-by: Will Drewry <wad@chromium.org>
Signed-off-by: Kees Cook <keescook@chromium.org>
Cc: stable@vger.kernel.org
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Reviewed-by: Darren Hart <dvhart@linux.intel.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,kernel/futex.c,"{""sha"": ""663ea2b84a3830ec9c772f78ec7eaa23504bfcc5"", ""filename"": ""kernel/futex.c"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 0, ""changes"": 25, ""blob_url"": ""https://github.com/torvalds/linux/blob/e9c243a5a6de0be8e584c604d353412584b592f8/kernel/futex.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e9c243a5a6de0be8e584c604d353412584b592f8/kernel/futex.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/futex.c?ref=e9c243a5a6de0be8e584c604d353412584b592f8"", ""patch"": ""@@ -1441,6 +1441,13 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n \tstruct futex_q *this, *next;\n \n \tif (requeue_pi) {\n+\t\t/*\n+\t\t * Requeue PI only works on two distinct uaddrs. This\n+\t\t * check is only valid for private futexes. See below.\n+\t\t */\n+\t\tif (uaddr1 == uaddr2)\n+\t\t\treturn -EINVAL;\n+\n \t\t/*\n \t\t * requeue_pi requires a pi_state, try to allocate it now\n \t\t * without any locks in case it fails.\n@@ -1479,6 +1486,15 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n \tif (unlikely(ret != 0))\n \t\tgoto out_put_key1;\n \n+\t/*\n+\t * The check above which compares uaddrs is not sufficient for\n+\t * shared futexes. We need to compare the keys:\n+\t */\n+\tif (requeue_pi && match_futex(&key1, &key2)) {\n+\t\tret = -EINVAL;\n+\t\tgoto out_put_keys;\n+\t}\n+\n \thb1 = hash_futex(&key1);\n \thb2 = hash_futex(&key2);\n \n@@ -2525,6 +2541,15 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,\n \tif (ret)\n \t\tgoto out_key2;\n \n+\t/*\n+\t * The check above which compares uaddrs is not sufficient for\n+\t * shared futexes. We need to compare the keys:\n+\t */\n+\tif (match_futex(&q.key, &key2)) {\n+\t\tret = -EINVAL;\n+\t\tgoto out_put_keys;\n+\t}\n+\n \t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n \tfutex_wait_queue_me(hb, &q, to);\n ""}","static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
			 u32 __user *uaddr2, int nr_wake, int nr_requeue,
			 u32 *cmpval, int requeue_pi)
{
	union futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;
	int drop_count = 0, task_count = 0, ret;
	struct futex_pi_state *pi_state = NULL;
	struct futex_hash_bucket *hb1, *hb2;
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
		/*
		 * Requeue PI only works on two distinct uaddrs. This
		 * check is only valid for private futexes. See below.
		 */
		if (uaddr1 == uaddr2)
			return -EINVAL;

 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
		 */
		if (refill_pi_state_cache())
			return -ENOMEM;
		/*
		 * requeue_pi must wake as many tasks as it can, up to nr_wake
		 * + nr_requeue, since it acquires the rt_mutex prior to
		 * returning to userspace, so as to not leave the rt_mutex with
		 * waiters and no owner.  However, second and third wake-ups
		 * cannot be predicted as they involve race conditions with the
		 * first wake and a fault while looking up the pi_state.  Both
		 * pthread_cond_signal() and pthread_cond_broadcast() should
		 * use nr_wake=1.
		 */
		if (nr_wake != 1)
			return -EINVAL;
	}

retry:
	if (pi_state != NULL) {
		/*
		 * We will have to lookup the pi_state again, so free this one
		 * to keep the accounting correct.
		 */
		free_pi_state(pi_state);
		pi_state = NULL;
	}

	ret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);
	if (unlikely(ret != 0))
		goto out;
	ret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,
			    requeue_pi ? VERIFY_WRITE : VERIFY_READ);
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
	/*
	 * The check above which compares uaddrs is not sufficient for
	 * shared futexes. We need to compare the keys:
	 */
	if (requeue_pi && match_futex(&key1, &key2)) {
		ret = -EINVAL;
		goto out_put_keys;
	}

 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
retry_private:
	hb_waiters_inc(hb2);
	double_lock_hb(hb1, hb2);

	if (likely(cmpval != NULL)) {
		u32 curval;

		ret = get_futex_value_locked(&curval, uaddr1);

		if (unlikely(ret)) {
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);

			ret = get_user(curval, uaddr1);
			if (ret)
				goto out_put_keys;

			if (!(flags & FLAGS_SHARED))
				goto retry_private;

			put_futex_key(&key2);
			put_futex_key(&key1);
			goto retry;
		}
		if (curval != *cmpval) {
			ret = -EAGAIN;
			goto out_unlock;
		}
	}

	if (requeue_pi && (task_count - nr_wake < nr_requeue)) {
		/*
		 * Attempt to acquire uaddr2 and wake the top waiter. If we
		 * intend to requeue waiters, force setting the FUTEX_WAITERS
		 * bit.  We force this here where we are able to easily handle
		 * faults rather in the requeue loop below.
		 */
		ret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,
						 &key2, &pi_state, nr_requeue);

		/*
		 * At this point the top_waiter has either taken uaddr2 or is
		 * waiting on it.  If the former, then the pi_state will not
		 * exist yet, look it up one more time to ensure we have a
		 * reference to it. If the lock was taken, ret contains the
		 * vpid of the top waiter task.
		 */
		if (ret > 0) {
			WARN_ON(pi_state);
			drop_count++;
			task_count++;
			/*
			 * If we acquired the lock, then the user
			 * space value of uaddr2 should be vpid. It
			 * cannot be changed by the top waiter as it
			 * is blocked on hb2 lock if it tries to do
			 * so. If something fiddled with it behind our
			 * back the pi state lookup might unearth
			 * it. So we rather use the known value than
			 * rereading and handing potential crap to
			 * lookup_pi_state.
			 */
			ret = lookup_pi_state(ret, hb2, &key2, &pi_state, NULL);
		}

		switch (ret) {
		case 0:
			break;
		case -EFAULT:
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			ret = fault_in_user_writeable(uaddr2);
			if (!ret)
				goto retry;
			goto out;
		case -EAGAIN:
			/* The owner was exiting, try again. */
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			cond_resched();
			goto retry;
		default:
			goto out_unlock;
		}
	}

	plist_for_each_entry_safe(this, next, &hb1->chain, list) {
		if (task_count - nr_wake >= nr_requeue)
			break;

		if (!match_futex(&this->key, &key1))
			continue;

		/*
		 * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always
		 * be paired with each other and no other futex ops.
		 *
		 * We should never be requeueing a futex_q with a pi_state,
		 * which is awaiting a futex_unlock_pi().
		 */
		if ((requeue_pi && !this->rt_waiter) ||
		    (!requeue_pi && this->rt_waiter) ||
		    this->pi_state) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Wake nr_wake waiters.  For requeue_pi, if we acquired the
		 * lock, we already woke the top_waiter.  If not, it will be
		 * woken by futex_unlock_pi().
		 */
		if (++task_count <= nr_wake && !requeue_pi) {
			wake_futex(this);
			continue;
		}

		/* Ensure we requeue to the expected futex for requeue_pi. */
		if (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Requeue nr_requeue waiters and possibly one more in the case
		 * of requeue_pi if we couldn't acquire the lock atomically.
		 */
		if (requeue_pi) {
			/* Prepare the waiter to take the rt_mutex. */
			atomic_inc(&pi_state->refcount);
			this->pi_state = pi_state;
			ret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,
							this->rt_waiter,
							this->task, 1);
			if (ret == 1) {
				/* We got the lock. */
				requeue_pi_wake_futex(this, &key2, hb2);
				drop_count++;
				continue;
			} else if (ret) {
				/* -EDEADLK */
				this->pi_state = NULL;
				free_pi_state(pi_state);
				goto out_unlock;
			}
		}
		requeue_futex(this, hb1, hb2, &key2);
		drop_count++;
	}

out_unlock:
	double_unlock_hb(hb1, hb2);
	hb_waiters_dec(hb2);

	/*
	 * drop_futex_key_refs() must be called outside the spinlocks. During
	 * the requeue we moved futex_q's from the hash bucket at key1 to the
	 * one at key2 and updated their key pointer.  We no longer need to
	 * hold the references to key1.
	 */
	while (--drop_count >= 0)
		drop_futex_key_refs(&key1);

out_put_keys:
	put_futex_key(&key2);
out_put_key1:
	put_futex_key(&key1);
out:
	if (pi_state != NULL)
		free_pi_state(pi_state);
	return ret ? ret : task_count;
}
","static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
			 u32 __user *uaddr2, int nr_wake, int nr_requeue,
			 u32 *cmpval, int requeue_pi)
{
	union futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;
	int drop_count = 0, task_count = 0, ret;
	struct futex_pi_state *pi_state = NULL;
	struct futex_hash_bucket *hb1, *hb2;
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
		 */
		if (refill_pi_state_cache())
			return -ENOMEM;
		/*
		 * requeue_pi must wake as many tasks as it can, up to nr_wake
		 * + nr_requeue, since it acquires the rt_mutex prior to
		 * returning to userspace, so as to not leave the rt_mutex with
		 * waiters and no owner.  However, second and third wake-ups
		 * cannot be predicted as they involve race conditions with the
		 * first wake and a fault while looking up the pi_state.  Both
		 * pthread_cond_signal() and pthread_cond_broadcast() should
		 * use nr_wake=1.
		 */
		if (nr_wake != 1)
			return -EINVAL;
	}

retry:
	if (pi_state != NULL) {
		/*
		 * We will have to lookup the pi_state again, so free this one
		 * to keep the accounting correct.
		 */
		free_pi_state(pi_state);
		pi_state = NULL;
	}

	ret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);
	if (unlikely(ret != 0))
		goto out;
	ret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,
			    requeue_pi ? VERIFY_WRITE : VERIFY_READ);
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
retry_private:
	hb_waiters_inc(hb2);
	double_lock_hb(hb1, hb2);

	if (likely(cmpval != NULL)) {
		u32 curval;

		ret = get_futex_value_locked(&curval, uaddr1);

		if (unlikely(ret)) {
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);

			ret = get_user(curval, uaddr1);
			if (ret)
				goto out_put_keys;

			if (!(flags & FLAGS_SHARED))
				goto retry_private;

			put_futex_key(&key2);
			put_futex_key(&key1);
			goto retry;
		}
		if (curval != *cmpval) {
			ret = -EAGAIN;
			goto out_unlock;
		}
	}

	if (requeue_pi && (task_count - nr_wake < nr_requeue)) {
		/*
		 * Attempt to acquire uaddr2 and wake the top waiter. If we
		 * intend to requeue waiters, force setting the FUTEX_WAITERS
		 * bit.  We force this here where we are able to easily handle
		 * faults rather in the requeue loop below.
		 */
		ret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,
						 &key2, &pi_state, nr_requeue);

		/*
		 * At this point the top_waiter has either taken uaddr2 or is
		 * waiting on it.  If the former, then the pi_state will not
		 * exist yet, look it up one more time to ensure we have a
		 * reference to it. If the lock was taken, ret contains the
		 * vpid of the top waiter task.
		 */
		if (ret > 0) {
			WARN_ON(pi_state);
			drop_count++;
			task_count++;
			/*
			 * If we acquired the lock, then the user
			 * space value of uaddr2 should be vpid. It
			 * cannot be changed by the top waiter as it
			 * is blocked on hb2 lock if it tries to do
			 * so. If something fiddled with it behind our
			 * back the pi state lookup might unearth
			 * it. So we rather use the known value than
			 * rereading and handing potential crap to
			 * lookup_pi_state.
			 */
			ret = lookup_pi_state(ret, hb2, &key2, &pi_state, NULL);
		}

		switch (ret) {
		case 0:
			break;
		case -EFAULT:
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			ret = fault_in_user_writeable(uaddr2);
			if (!ret)
				goto retry;
			goto out;
		case -EAGAIN:
			/* The owner was exiting, try again. */
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			cond_resched();
			goto retry;
		default:
			goto out_unlock;
		}
	}

	plist_for_each_entry_safe(this, next, &hb1->chain, list) {
		if (task_count - nr_wake >= nr_requeue)
			break;

		if (!match_futex(&this->key, &key1))
			continue;

		/*
		 * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always
		 * be paired with each other and no other futex ops.
		 *
		 * We should never be requeueing a futex_q with a pi_state,
		 * which is awaiting a futex_unlock_pi().
		 */
		if ((requeue_pi && !this->rt_waiter) ||
		    (!requeue_pi && this->rt_waiter) ||
		    this->pi_state) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Wake nr_wake waiters.  For requeue_pi, if we acquired the
		 * lock, we already woke the top_waiter.  If not, it will be
		 * woken by futex_unlock_pi().
		 */
		if (++task_count <= nr_wake && !requeue_pi) {
			wake_futex(this);
			continue;
		}

		/* Ensure we requeue to the expected futex for requeue_pi. */
		if (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Requeue nr_requeue waiters and possibly one more in the case
		 * of requeue_pi if we couldn't acquire the lock atomically.
		 */
		if (requeue_pi) {
			/* Prepare the waiter to take the rt_mutex. */
			atomic_inc(&pi_state->refcount);
			this->pi_state = pi_state;
			ret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,
							this->rt_waiter,
							this->task, 1);
			if (ret == 1) {
				/* We got the lock. */
				requeue_pi_wake_futex(this, &key2, hb2);
				drop_count++;
				continue;
			} else if (ret) {
				/* -EDEADLK */
				this->pi_state = NULL;
				free_pi_state(pi_state);
				goto out_unlock;
			}
		}
		requeue_futex(this, hb1, hb2, &key2);
		drop_count++;
	}

out_unlock:
	double_unlock_hb(hb1, hb2);
	hb_waiters_dec(hb2);

	/*
	 * drop_futex_key_refs() must be called outside the spinlocks. During
	 * the requeue we moved futex_q's from the hash bucket at key1 to the
	 * one at key2 and updated their key pointer.  We no longer need to
	 * hold the references to key1.
	 */
	while (--drop_count >= 0)
		drop_futex_key_refs(&key1);

out_put_keys:
	put_futex_key(&key2);
out_put_key1:
	put_futex_key(&key1);
out:
	if (pi_state != NULL)
		free_pi_state(pi_state);
	return ret ? ret : task_count;
}
",C,"		/*
		 * Requeue PI only works on two distinct uaddrs. This
		 * check is only valid for private futexes. See below.
		 */
		if (uaddr1 == uaddr2)
			return -EINVAL;

	/*
	 * The check above which compares uaddrs is not sufficient for
	 * shared futexes. We need to compare the keys:
	 */
	if (requeue_pi && match_futex(&key1, &key2)) {
		ret = -EINVAL;
		goto out_put_keys;
	}

",,,"@@ -1441,6 +1441,13 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
+		/*
+		 * Requeue PI only works on two distinct uaddrs. This
+		 * check is only valid for private futexes. See below.
+		 */
+		if (uaddr1 == uaddr2)
+			return -EINVAL;
+
 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
@@ -1479,6 +1486,15 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
+	/*
+	 * The check above which compares uaddrs is not sufficient for
+	 * shared futexes. We need to compare the keys:
+	 */
+	if (requeue_pi && match_futex(&key1, &key2)) {
+		ret = -EINVAL;
+		goto out_put_keys;
+	}
+
 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
@@ -2525,6 +2541,15 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
 	if (ret)
 		goto out_key2;
 
+	/*
+	 * The check above which compares uaddrs is not sufficient for
+	 * shared futexes. We need to compare the keys:
+	 */
+	if (match_futex(&q.key, &key2)) {
+		ret = -EINVAL;
+		goto out_put_keys;
+	}
+
 	/* Queue the futex_q, drop the hb lock, wait for wakeup. */
 	futex_wait_queue_me(hb, &q, to);
 ",linux,e9c243a5a6de0be8e584c604d353412584b592f8,fad01e866afdbe01a1f3ec06a39c3a8b9e197014,1,"static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
			 u32 __user *uaddr2, int nr_wake, int nr_requeue,
			 u32 *cmpval, int requeue_pi)
{
	union futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;
	int drop_count = 0, task_count = 0, ret;
	struct futex_pi_state *pi_state = NULL;
	struct futex_hash_bucket *hb1, *hb2;
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
//fix_flaw_line_below:
//		/*
//fix_flaw_line_below:
//		 * Requeue PI only works on two distinct uaddrs. This
//fix_flaw_line_below:
//		 * check is only valid for private futexes. See below.
//fix_flaw_line_below:
//		 */
//fix_flaw_line_below:
//		if (uaddr1 == uaddr2)
//fix_flaw_line_below:
//			return -EINVAL;
//fix_flaw_line_below:
//
 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
		 */
		if (refill_pi_state_cache())
			return -ENOMEM;
		/*
		 * requeue_pi must wake as many tasks as it can, up to nr_wake
		 * + nr_requeue, since it acquires the rt_mutex prior to
		 * returning to userspace, so as to not leave the rt_mutex with
		 * waiters and no owner.  However, second and third wake-ups
		 * cannot be predicted as they involve race conditions with the
		 * first wake and a fault while looking up the pi_state.  Both
		 * pthread_cond_signal() and pthread_cond_broadcast() should
		 * use nr_wake=1.
		 */
		if (nr_wake != 1)
			return -EINVAL;
	}

retry:
	if (pi_state != NULL) {
		/*
		 * We will have to lookup the pi_state again, so free this one
		 * to keep the accounting correct.
		 */
		free_pi_state(pi_state);
		pi_state = NULL;
	}

	ret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);
	if (unlikely(ret != 0))
		goto out;
	ret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,
			    requeue_pi ? VERIFY_WRITE : VERIFY_READ);
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
//fix_flaw_line_below:
//	/*
//fix_flaw_line_below:
//	 * The check above which compares uaddrs is not sufficient for
//fix_flaw_line_below:
//	 * shared futexes. We need to compare the keys:
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//	if (requeue_pi && match_futex(&key1, &key2)) {
//fix_flaw_line_below:
//		ret = -EINVAL;
//fix_flaw_line_below:
//		goto out_put_keys;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
retry_private:
	hb_waiters_inc(hb2);
	double_lock_hb(hb1, hb2);

	if (likely(cmpval != NULL)) {
		u32 curval;

		ret = get_futex_value_locked(&curval, uaddr1);

		if (unlikely(ret)) {
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);

			ret = get_user(curval, uaddr1);
			if (ret)
				goto out_put_keys;

			if (!(flags & FLAGS_SHARED))
				goto retry_private;

			put_futex_key(&key2);
			put_futex_key(&key1);
			goto retry;
		}
		if (curval != *cmpval) {
			ret = -EAGAIN;
			goto out_unlock;
		}
	}

	if (requeue_pi && (task_count - nr_wake < nr_requeue)) {
		/*
		 * Attempt to acquire uaddr2 and wake the top waiter. If we
		 * intend to requeue waiters, force setting the FUTEX_WAITERS
		 * bit.  We force this here where we are able to easily handle
		 * faults rather in the requeue loop below.
		 */
		ret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,
						 &key2, &pi_state, nr_requeue);

		/*
		 * At this point the top_waiter has either taken uaddr2 or is
		 * waiting on it.  If the former, then the pi_state will not
		 * exist yet, look it up one more time to ensure we have a
		 * reference to it. If the lock was taken, ret contains the
		 * vpid of the top waiter task.
		 */
		if (ret > 0) {
			WARN_ON(pi_state);
			drop_count++;
			task_count++;
			/*
			 * If we acquired the lock, then the user
			 * space value of uaddr2 should be vpid. It
			 * cannot be changed by the top waiter as it
			 * is blocked on hb2 lock if it tries to do
			 * so. If something fiddled with it behind our
			 * back the pi state lookup might unearth
			 * it. So we rather use the known value than
			 * rereading and handing potential crap to
			 * lookup_pi_state.
			 */
			ret = lookup_pi_state(ret, hb2, &key2, &pi_state, NULL);
		}

		switch (ret) {
		case 0:
			break;
		case -EFAULT:
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			ret = fault_in_user_writeable(uaddr2);
			if (!ret)
				goto retry;
			goto out;
		case -EAGAIN:
			/* The owner was exiting, try again. */
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			cond_resched();
			goto retry;
		default:
			goto out_unlock;
		}
	}

	plist_for_each_entry_safe(this, next, &hb1->chain, list) {
		if (task_count - nr_wake >= nr_requeue)
			break;

		if (!match_futex(&this->key, &key1))
			continue;

		/*
		 * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always
		 * be paired with each other and no other futex ops.
		 *
		 * We should never be requeueing a futex_q with a pi_state,
		 * which is awaiting a futex_unlock_pi().
		 */
		if ((requeue_pi && !this->rt_waiter) ||
		    (!requeue_pi && this->rt_waiter) ||
		    this->pi_state) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Wake nr_wake waiters.  For requeue_pi, if we acquired the
		 * lock, we already woke the top_waiter.  If not, it will be
		 * woken by futex_unlock_pi().
		 */
		if (++task_count <= nr_wake && !requeue_pi) {
			wake_futex(this);
			continue;
		}

		/* Ensure we requeue to the expected futex for requeue_pi. */
		if (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Requeue nr_requeue waiters and possibly one more in the case
		 * of requeue_pi if we couldn't acquire the lock atomically.
		 */
		if (requeue_pi) {
			/* Prepare the waiter to take the rt_mutex. */
			atomic_inc(&pi_state->refcount);
			this->pi_state = pi_state;
			ret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,
							this->rt_waiter,
							this->task, 1);
			if (ret == 1) {
				/* We got the lock. */
				requeue_pi_wake_futex(this, &key2, hb2);
				drop_count++;
				continue;
			} else if (ret) {
				/* -EDEADLK */
				this->pi_state = NULL;
				free_pi_state(pi_state);
				goto out_unlock;
			}
		}
		requeue_futex(this, hb1, hb2, &key2);
		drop_count++;
	}

out_unlock:
	double_unlock_hb(hb1, hb2);
	hb_waiters_dec(hb2);

	/*
	 * drop_futex_key_refs() must be called outside the spinlocks. During
	 * the requeue we moved futex_q's from the hash bucket at key1 to the
	 * one at key2 and updated their key pointer.  We no longer need to
	 * hold the references to key1.
	 */
	while (--drop_count >= 0)
		drop_futex_key_refs(&key1);

out_put_keys:
	put_futex_key(&key2);
out_put_key1:
	put_futex_key(&key1);
out:
	if (pi_state != NULL)
		free_pi_state(pi_state);
	return ret ? ret : task_count;
}
",179553,"static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
			 u32 __user *uaddr2, int nr_wake, int nr_requeue,
			 u32 *cmpval, int requeue_pi)
{
	union futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;
	int drop_count = 0, task_count = 0, ret;
	struct futex_pi_state *pi_state = NULL;
	struct futex_hash_bucket *hb1, *hb2;
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
		 */
		if (refill_pi_state_cache())
			return -ENOMEM;
		/*
		 * requeue_pi must wake as many tasks as it can, up to nr_wake
		 * + nr_requeue, since it acquires the rt_mutex prior to
		 * returning to userspace, so as to not leave the rt_mutex with
		 * waiters and no owner.  However, second and third wake-ups
		 * cannot be predicted as they involve race conditions with the
		 * first wake and a fault while looking up the pi_state.  Both
		 * pthread_cond_signal() and pthread_cond_broadcast() should
		 * use nr_wake=1.
		 */
		if (nr_wake != 1)
			return -EINVAL;
	}

retry:
	if (pi_state != NULL) {
		/*
		 * We will have to lookup the pi_state again, so free this one
		 * to keep the accounting correct.
		 */
		free_pi_state(pi_state);
		pi_state = NULL;
	}

	ret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);
	if (unlikely(ret != 0))
		goto out;
	ret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,
			    requeue_pi ? VERIFY_WRITE : VERIFY_READ);
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
retry_private:
	hb_waiters_inc(hb2);
	double_lock_hb(hb1, hb2);

	if (likely(cmpval != NULL)) {
		u32 curval;

		ret = get_futex_value_locked(&curval, uaddr1);

		if (unlikely(ret)) {
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);

			ret = get_user(curval, uaddr1);
			if (ret)
				goto out_put_keys;

			if (!(flags & FLAGS_SHARED))
				goto retry_private;

			put_futex_key(&key2);
			put_futex_key(&key1);
			goto retry;
		}
		if (curval != *cmpval) {
			ret = -EAGAIN;
			goto out_unlock;
		}
	}

	if (requeue_pi && (task_count - nr_wake < nr_requeue)) {
		/*
		 * Attempt to acquire uaddr2 and wake the top waiter. If we
		 * intend to requeue waiters, force setting the FUTEX_WAITERS
		 * bit.  We force this here where we are able to easily handle
		 * faults rather in the requeue loop below.
		 */
		ret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,
						 &key2, &pi_state, nr_requeue);

		/*
		 * At this point the top_waiter has either taken uaddr2 or is
		 * waiting on it.  If the former, then the pi_state will not
		 * exist yet, look it up one more time to ensure we have a
		 * reference to it. If the lock was taken, ret contains the
		 * vpid of the top waiter task.
		 */
		if (ret > 0) {
			WARN_ON(pi_state);
			drop_count++;
			task_count++;
			/*
			 * If we acquired the lock, then the user
			 * space value of uaddr2 should be vpid. It
			 * cannot be changed by the top waiter as it
			 * is blocked on hb2 lock if it tries to do
			 * so. If something fiddled with it behind our
			 * back the pi state lookup might unearth
			 * it. So we rather use the known value than
			 * rereading and handing potential crap to
			 * lookup_pi_state.
			 */
			ret = lookup_pi_state(ret, hb2, &key2, &pi_state, NULL);
		}

		switch (ret) {
		case 0:
			break;
		case -EFAULT:
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			ret = fault_in_user_writeable(uaddr2);
			if (!ret)
				goto retry;
			goto out;
		case -EAGAIN:
			/* The owner was exiting, try again. */
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			cond_resched();
			goto retry;
		default:
			goto out_unlock;
		}
	}

	plist_for_each_entry_safe(this, next, &hb1->chain, list) {
		if (task_count - nr_wake >= nr_requeue)
			break;

		if (!match_futex(&this->key, &key1))
			continue;

		/*
		 * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always
		 * be paired with each other and no other futex ops.
		 *
		 * We should never be requeueing a futex_q with a pi_state,
		 * which is awaiting a futex_unlock_pi().
		 */
		if ((requeue_pi && !this->rt_waiter) ||
		    (!requeue_pi && this->rt_waiter) ||
		    this->pi_state) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Wake nr_wake waiters.  For requeue_pi, if we acquired the
		 * lock, we already woke the top_waiter.  If not, it will be
		 * woken by futex_unlock_pi().
		 */
		if (++task_count <= nr_wake && !requeue_pi) {
			wake_futex(this);
			continue;
		}

		/* Ensure we requeue to the expected futex for requeue_pi. */
		if (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Requeue nr_requeue waiters and possibly one more in the case
		 * of requeue_pi if we couldn't acquire the lock atomically.
		 */
		if (requeue_pi) {
			/* Prepare the waiter to take the rt_mutex. */
			atomic_inc(&pi_state->refcount);
			this->pi_state = pi_state;
			ret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,
							this->rt_waiter,
							this->task, 1);
			if (ret == 1) {
				/* We got the lock. */
				requeue_pi_wake_futex(this, &key2, hb2);
				drop_count++;
				continue;
			} else if (ret) {
				/* -EDEADLK */
				this->pi_state = NULL;
				free_pi_state(pi_state);
				goto out_unlock;
			}
		}
		requeue_futex(this, hb1, hb2, &key2);
		drop_count++;
	}

out_unlock:
	double_unlock_hb(hb1, hb2);
	hb_waiters_dec(hb2);

	/*
	 * drop_futex_key_refs() must be called outside the spinlocks. During
	 * the requeue we moved futex_q's from the hash bucket at key1 to the
	 * one at key2 and updated their key pointer.  We no longer need to
	 * hold the references to key1.
	 */
	while (--drop_count >= 0)
		drop_futex_key_refs(&key1);

out_put_keys:
	put_futex_key(&key2);
out_put_key1:
	put_futex_key(&key1);
out:
	if (pi_state != NULL)
		free_pi_state(pi_state);
	return ret ? ret : task_count;
}
","static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
			 u32 __user *uaddr2, int nr_wake, int nr_requeue,
			 u32 *cmpval, int requeue_pi)
{
	union futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;
	int drop_count = 0, task_count = 0, ret;
	struct futex_pi_state *pi_state = NULL;
	struct futex_hash_bucket *hb1, *hb2;
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
		/*
		 * Requeue PI only works on two distinct uaddrs. This
		 * check is only valid for private futexes. See below.
		 */
		if (uaddr1 == uaddr2)
			return -EINVAL;

 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
		 */
		if (refill_pi_state_cache())
			return -ENOMEM;
		/*
		 * requeue_pi must wake as many tasks as it can, up to nr_wake
		 * + nr_requeue, since it acquires the rt_mutex prior to
		 * returning to userspace, so as to not leave the rt_mutex with
		 * waiters and no owner.  However, second and third wake-ups
		 * cannot be predicted as they involve race conditions with the
		 * first wake and a fault while looking up the pi_state.  Both
		 * pthread_cond_signal() and pthread_cond_broadcast() should
		 * use nr_wake=1.
		 */
		if (nr_wake != 1)
			return -EINVAL;
	}

retry:
	if (pi_state != NULL) {
		/*
		 * We will have to lookup the pi_state again, so free this one
		 * to keep the accounting correct.
		 */
		free_pi_state(pi_state);
		pi_state = NULL;
	}

	ret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);
	if (unlikely(ret != 0))
		goto out;
	ret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,
			    requeue_pi ? VERIFY_WRITE : VERIFY_READ);
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
	/*
	 * The check above which compares uaddrs is not sufficient for
	 * shared futexes. We need to compare the keys:
	 */
	if (requeue_pi && match_futex(&key1, &key2)) {
		ret = -EINVAL;
		goto out_put_keys;
	}

 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
retry_private:
	hb_waiters_inc(hb2);
	double_lock_hb(hb1, hb2);

	if (likely(cmpval != NULL)) {
		u32 curval;

		ret = get_futex_value_locked(&curval, uaddr1);

		if (unlikely(ret)) {
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);

			ret = get_user(curval, uaddr1);
			if (ret)
				goto out_put_keys;

			if (!(flags & FLAGS_SHARED))
				goto retry_private;

			put_futex_key(&key2);
			put_futex_key(&key1);
			goto retry;
		}
		if (curval != *cmpval) {
			ret = -EAGAIN;
			goto out_unlock;
		}
	}

	if (requeue_pi && (task_count - nr_wake < nr_requeue)) {
		/*
		 * Attempt to acquire uaddr2 and wake the top waiter. If we
		 * intend to requeue waiters, force setting the FUTEX_WAITERS
		 * bit.  We force this here where we are able to easily handle
		 * faults rather in the requeue loop below.
		 */
		ret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,
						 &key2, &pi_state, nr_requeue);

		/*
		 * At this point the top_waiter has either taken uaddr2 or is
		 * waiting on it.  If the former, then the pi_state will not
		 * exist yet, look it up one more time to ensure we have a
		 * reference to it. If the lock was taken, ret contains the
		 * vpid of the top waiter task.
		 */
		if (ret > 0) {
			WARN_ON(pi_state);
			drop_count++;
			task_count++;
			/*
			 * If we acquired the lock, then the user
			 * space value of uaddr2 should be vpid. It
			 * cannot be changed by the top waiter as it
			 * is blocked on hb2 lock if it tries to do
			 * so. If something fiddled with it behind our
			 * back the pi state lookup might unearth
			 * it. So we rather use the known value than
			 * rereading and handing potential crap to
			 * lookup_pi_state.
			 */
			ret = lookup_pi_state(ret, hb2, &key2, &pi_state, NULL);
		}

		switch (ret) {
		case 0:
			break;
		case -EFAULT:
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			ret = fault_in_user_writeable(uaddr2);
			if (!ret)
				goto retry;
			goto out;
		case -EAGAIN:
			/* The owner was exiting, try again. */
			double_unlock_hb(hb1, hb2);
			hb_waiters_dec(hb2);
			put_futex_key(&key2);
			put_futex_key(&key1);
			cond_resched();
			goto retry;
		default:
			goto out_unlock;
		}
	}

	plist_for_each_entry_safe(this, next, &hb1->chain, list) {
		if (task_count - nr_wake >= nr_requeue)
			break;

		if (!match_futex(&this->key, &key1))
			continue;

		/*
		 * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always
		 * be paired with each other and no other futex ops.
		 *
		 * We should never be requeueing a futex_q with a pi_state,
		 * which is awaiting a futex_unlock_pi().
		 */
		if ((requeue_pi && !this->rt_waiter) ||
		    (!requeue_pi && this->rt_waiter) ||
		    this->pi_state) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Wake nr_wake waiters.  For requeue_pi, if we acquired the
		 * lock, we already woke the top_waiter.  If not, it will be
		 * woken by futex_unlock_pi().
		 */
		if (++task_count <= nr_wake && !requeue_pi) {
			wake_futex(this);
			continue;
		}

		/* Ensure we requeue to the expected futex for requeue_pi. */
		if (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {
			ret = -EINVAL;
			break;
		}

		/*
		 * Requeue nr_requeue waiters and possibly one more in the case
		 * of requeue_pi if we couldn't acquire the lock atomically.
		 */
		if (requeue_pi) {
			/* Prepare the waiter to take the rt_mutex. */
			atomic_inc(&pi_state->refcount);
			this->pi_state = pi_state;
			ret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,
							this->rt_waiter,
							this->task, 1);
			if (ret == 1) {
				/* We got the lock. */
				requeue_pi_wake_futex(this, &key2, hb2);
				drop_count++;
				continue;
			} else if (ret) {
				/* -EDEADLK */
				this->pi_state = NULL;
				free_pi_state(pi_state);
				goto out_unlock;
			}
		}
		requeue_futex(this, hb1, hb2, &key2);
		drop_count++;
	}

out_unlock:
	double_unlock_hb(hb1, hb2);
	hb_waiters_dec(hb2);

	/*
	 * drop_futex_key_refs() must be called outside the spinlocks. During
	 * the requeue we moved futex_q's from the hash bucket at key1 to the
	 * one at key2 and updated their key pointer.  We no longer need to
	 * hold the references to key1.
	 */
	while (--drop_count >= 0)
		drop_futex_key_refs(&key1);

out_put_keys:
	put_futex_key(&key2);
out_put_key1:
	put_futex_key(&key1);
out:
	if (pi_state != NULL)
		free_pi_state(pi_state);
	return ret ? ret : task_count;
}
","The `futex_requeue` function is designed to manage the requeuing of waiters from one futex (fast user-space mutex) address to another, potentially with priority inheritance (PI) support. It first verifies the futex keys and handles the allocation of necessary state structures. The function then attempts to wake a specified number of waiters and requeue others based on the provided parameters, ensuring proper synchronization and error handling throughout. It manages the state of the futexes, including acquiring locks, waking tasks, and handling potential race conditions, while maintaining the integrity of the futex wait queues and their associated states.","The provided code implements a mechanism for managing the requeuing of tasks waiting on one synchronization primitive to another, with optional support for priority inheritance. It begins by validating the addresses of the synchronization primitives and attempts to allocate necessary state structures. The function then wakes a specified number of waiting tasks while requeuing others, ensuring proper synchronization and handling of potential errors. Throughout the process, it maintains the integrity of the wait queues and manages the state of the synchronization primitives, addressing race conditions and ensuring that tasks are appropriately transitioned between states.","The vulnerability in the original code arises from allowing the same address for both the source and destination futex when requeuing with priority inheritance, which could lead to dangling pointers for the real-time waiter. This situation creates an exploitable condition where the system's integrity could be compromised. The fix implemented in the updated code introduces a check to ensure that the two addresses are distinct when priority inheritance is enabled. Additionally, it compares the resulting keys to prevent similar issues with shared futexes, thereby aligning the behavior with existing checks in related functions and enhancing overall safety.","The vulnerability in the original code occurs when the same address is used for both the source and destination during a requeue operation with priority inheritance, violating the rule that only allows requeuing from a non-priority inheritance synchronization primitive to one that supports it. This can lead to dangling pointers for the real-time waiter, creating a potential exploit. The fix implemented in the updated code introduces a check to ensure that the two addresses are distinct when priority inheritance is enabled, and it also compares the resulting keys to prevent similar issues, thereby enhancing the safety and integrity of the synchronization mechanism.","The vulnerability was fixed by adding a check to ensure that the two addresses, `uaddr1` and `uaddr2`, are not the same when priority inheritance is enabled. This is implemented with the condition `if (uaddr1 == uaddr2)`, which returns an error if the addresses match. Additionally, the code now includes a comparison of the resulting keys using `match_futex(&key1, &key2)` to further validate that the keys are distinct, addressing potential issues with shared futexes. This change aligns the function's behavior with existing safety checks in related operations, thereby preventing the creation of dangling pointers.","The vulnerability was addressed by implementing a check to ensure that the source and destination addresses for the requeue operation are distinct when priority inheritance is enabled. This prevents the scenario where both addresses are the same, which could lead to dangling pointers and potential exploitation. Additionally, the fix includes a comparison of the resulting keys associated with the addresses to ensure they are not only different but also valid, thereby enhancing the overall safety of the synchronization mechanism and aligning it with existing checks in related functions to prevent similar issues.","CWE-416, CWE-476, CWE-825, CWE-911, CWE-415, CWE-457, CWE-672, CWE-367, CWE-366, CWE-665",N,-1
34,34,179559,179559,,Local,Not required,Complete,CVE-2014-3122,https://www.cvedetails.com/cve/CVE-2014-3122/,CWE-264,Low,,,,2014-05-11,4.9,"The try_to_unmap_cluster function in mm/rmap.c in the Linux kernel before 3.14.3 does not properly consider which pages must be locked, which allows local users to cause a denial of service (system crash) by triggering a memory-usage pattern that requires removal of page-table mappings.",2017-12-28,DoS ,12,https://github.com/torvalds/linux/commit/57e68e9cd65b4b8eb4045a1e0d0746458502554c,57e68e9cd65b4b8eb4045a1e0d0746458502554c,"mm: try_to_unmap_cluster() should lock_page() before mlocking

A BUG_ON(!PageLocked) was triggered in mlock_vma_page() by Sasha Levin
fuzzing with trinity.  The call site try_to_unmap_cluster() does not lock
the pages other than its check_page parameter (which is already locked).

The BUG_ON in mlock_vma_page() is not documented and its purpose is
somewhat unclear, but apparently it serializes against page migration,
which could otherwise fail to transfer the PG_mlocked flag.  This would
not be fatal, as the page would be eventually encountered again, but
NR_MLOCK accounting would become distorted nevertheless.  This patch adds
a comment to the BUG_ON in mlock_vma_page() and munlock_vma_page() to that
effect.

The call site try_to_unmap_cluster() is fixed so that for page !=
check_page, trylock_page() is attempted (to avoid possible deadlocks as we
already have check_page locked) and mlock_vma_page() is performed only
upon success.  If the page lock cannot be obtained, the page is left
without PG_mlocked, which is again not a problem in the whole unevictable
memory design.

Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
Signed-off-by: Bob Liu <bob.liu@oracle.com>
Reported-by: Sasha Levin <sasha.levin@oracle.com>
Cc: Wanpeng Li <liwanp@linux.vnet.ibm.com>
Cc: Michel Lespinasse <walken@google.com>
Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
Acked-by: Rik van Riel <riel@redhat.com>
Cc: David Rientjes <rientjes@google.com>
Cc: Mel Gorman <mgorman@suse.de>
Cc: Hugh Dickins <hughd@google.com>
Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",2,mm/rmap.c,"{""sha"": ""b1eb53634005606298d115ac5cdeb90cac923957"", ""filename"": ""mm/mlock.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/57e68e9cd65b4b8eb4045a1e0d0746458502554c/mm/mlock.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/57e68e9cd65b4b8eb4045a1e0d0746458502554c/mm/mlock.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/mlock.c?ref=57e68e9cd65b4b8eb4045a1e0d0746458502554c"", ""patch"": ""@@ -79,6 +79,7 @@ void clear_page_mlock(struct page *page)\n  */\n void mlock_vma_page(struct page *page)\n {\n+\t/* Serialize with page migration */\n \tBUG_ON(!PageLocked(page));\n \n \tif (!TestSetPageMlocked(page)) {\n@@ -174,6 +175,7 @@ unsigned int munlock_vma_page(struct page *page)\n \tunsigned int nr_pages;\n \tstruct zone *zone = page_zone(page);\n \n+\t/* For try_to_munlock() and to serialize with page migration */\n \tBUG_ON(!PageLocked(page));\n \n \t/*""}<_**next**_>{""sha"": ""9c3e77396d1a118edb8f2de7d16ff835ed214f0a"", ""filename"": ""mm/rmap.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 2, ""changes"": 14, ""blob_url"": ""https://github.com/torvalds/linux/blob/57e68e9cd65b4b8eb4045a1e0d0746458502554c/mm/rmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/57e68e9cd65b4b8eb4045a1e0d0746458502554c/mm/rmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/rmap.c?ref=57e68e9cd65b4b8eb4045a1e0d0746458502554c"", ""patch"": ""@@ -1332,9 +1332,19 @@ static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,\n \t\tBUG_ON(!page || PageAnon(page));\n \n \t\tif (locked_vma) {\n-\t\t\tmlock_vma_page(page);   /* no-op if already mlocked */\n-\t\t\tif (page == check_page)\n+\t\t\tif (page == check_page) {\n+\t\t\t\t/* we know we have check_page locked */\n+\t\t\t\tmlock_vma_page(page);\n \t\t\t\tret = SWAP_MLOCK;\n+\t\t\t} else if (trylock_page(page)) {\n+\t\t\t\t/*\n+\t\t\t\t * If we can lock the page, perform mlock.\n+\t\t\t\t * Otherwise leave the page alone, it will be\n+\t\t\t\t * eventually encountered again later.\n+\t\t\t\t */\n+\t\t\t\tmlock_vma_page(page);\n+\t\t\t\tunlock_page(page);\n+\t\t\t}\n \t\t\tcontinue;\t/* don't unmap */\n \t\t}\n ""}","static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,
		struct vm_area_struct *vma, struct page *check_page)
{
	struct mm_struct *mm = vma->vm_mm;
	pmd_t *pmd;
	pte_t *pte;
	pte_t pteval;
	spinlock_t *ptl;
	struct page *page;
	unsigned long address;
	unsigned long mmun_start;	/* For mmu_notifiers */
	unsigned long mmun_end;		/* For mmu_notifiers */
	unsigned long end;
	int ret = SWAP_AGAIN;
	int locked_vma = 0;

	address = (vma->vm_start + cursor) & CLUSTER_MASK;
	end = address + CLUSTER_SIZE;
	if (address < vma->vm_start)
		address = vma->vm_start;
	if (end > vma->vm_end)
		end = vma->vm_end;

	pmd = mm_find_pmd(mm, address);
	if (!pmd)
		return ret;

	mmun_start = address;
	mmun_end   = end;
	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);

	/*
	 * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,
	 * keep the sem while scanning the cluster for mlocking pages.
	 */
	if (down_read_trylock(&vma->vm_mm->mmap_sem)) {
		locked_vma = (vma->vm_flags & VM_LOCKED);
		if (!locked_vma)
			up_read(&vma->vm_mm->mmap_sem); /* don't need it */
	}

	pte = pte_offset_map_lock(mm, pmd, address, &ptl);

	/* Update high watermark before we lower rss */
	update_hiwater_rss(mm);

	for (; address < end; pte++, address += PAGE_SIZE) {
		if (!pte_present(*pte))
			continue;
		page = vm_normal_page(vma, address, *pte);
 		BUG_ON(!page || PageAnon(page));
 
 		if (locked_vma) {
			if (page == check_page) {
				/* we know we have check_page locked */
				mlock_vma_page(page);
 				ret = SWAP_MLOCK;
			} else if (trylock_page(page)) {
				/*
				 * If we can lock the page, perform mlock.
				 * Otherwise leave the page alone, it will be
				 * eventually encountered again later.
				 */
				mlock_vma_page(page);
				unlock_page(page);
			}
 			continue;	/* don't unmap */
 		}
 
		if (ptep_clear_flush_young_notify(vma, address, pte))
			continue;

		/* Nuke the page table entry. */
		flush_cache_page(vma, address, pte_pfn(*pte));
		pteval = ptep_clear_flush(vma, address, pte);

		/* If nonlinear, store the file page offset in the pte. */
		if (page->index != linear_page_index(vma, address)) {
			pte_t ptfile = pgoff_to_pte(page->index);
			if (pte_soft_dirty(pteval))
				pte_file_mksoft_dirty(ptfile);
			set_pte_at(mm, address, pte, ptfile);
		}

		/* Move the dirty bit to the physical page now the pte is gone. */
		if (pte_dirty(pteval))
			set_page_dirty(page);

		page_remove_rmap(page);
		page_cache_release(page);
		dec_mm_counter(mm, MM_FILEPAGES);
		(*mapcount)--;
	}
	pte_unmap_unlock(pte - 1, ptl);
	mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
	if (locked_vma)
		up_read(&vma->vm_mm->mmap_sem);
	return ret;
}
","static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,
		struct vm_area_struct *vma, struct page *check_page)
{
	struct mm_struct *mm = vma->vm_mm;
	pmd_t *pmd;
	pte_t *pte;
	pte_t pteval;
	spinlock_t *ptl;
	struct page *page;
	unsigned long address;
	unsigned long mmun_start;	/* For mmu_notifiers */
	unsigned long mmun_end;		/* For mmu_notifiers */
	unsigned long end;
	int ret = SWAP_AGAIN;
	int locked_vma = 0;

	address = (vma->vm_start + cursor) & CLUSTER_MASK;
	end = address + CLUSTER_SIZE;
	if (address < vma->vm_start)
		address = vma->vm_start;
	if (end > vma->vm_end)
		end = vma->vm_end;

	pmd = mm_find_pmd(mm, address);
	if (!pmd)
		return ret;

	mmun_start = address;
	mmun_end   = end;
	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);

	/*
	 * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,
	 * keep the sem while scanning the cluster for mlocking pages.
	 */
	if (down_read_trylock(&vma->vm_mm->mmap_sem)) {
		locked_vma = (vma->vm_flags & VM_LOCKED);
		if (!locked_vma)
			up_read(&vma->vm_mm->mmap_sem); /* don't need it */
	}

	pte = pte_offset_map_lock(mm, pmd, address, &ptl);

	/* Update high watermark before we lower rss */
	update_hiwater_rss(mm);

	for (; address < end; pte++, address += PAGE_SIZE) {
		if (!pte_present(*pte))
			continue;
		page = vm_normal_page(vma, address, *pte);
 		BUG_ON(!page || PageAnon(page));
 
 		if (locked_vma) {
			mlock_vma_page(page);   /* no-op if already mlocked */
			if (page == check_page)
 				ret = SWAP_MLOCK;
 			continue;	/* don't unmap */
 		}
 
		if (ptep_clear_flush_young_notify(vma, address, pte))
			continue;

		/* Nuke the page table entry. */
		flush_cache_page(vma, address, pte_pfn(*pte));
		pteval = ptep_clear_flush(vma, address, pte);

		/* If nonlinear, store the file page offset in the pte. */
		if (page->index != linear_page_index(vma, address)) {
			pte_t ptfile = pgoff_to_pte(page->index);
			if (pte_soft_dirty(pteval))
				pte_file_mksoft_dirty(ptfile);
			set_pte_at(mm, address, pte, ptfile);
		}

		/* Move the dirty bit to the physical page now the pte is gone. */
		if (pte_dirty(pteval))
			set_page_dirty(page);

		page_remove_rmap(page);
		page_cache_release(page);
		dec_mm_counter(mm, MM_FILEPAGES);
		(*mapcount)--;
	}
	pte_unmap_unlock(pte - 1, ptl);
	mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
	if (locked_vma)
		up_read(&vma->vm_mm->mmap_sem);
	return ret;
}
",C,"			if (page == check_page) {
				/* we know we have check_page locked */
				mlock_vma_page(page);
			} else if (trylock_page(page)) {
				/*
				 * If we can lock the page, perform mlock.
				 * Otherwise leave the page alone, it will be
				 * eventually encountered again later.
				 */
				mlock_vma_page(page);
				unlock_page(page);
			}
","			mlock_vma_page(page);   /* no-op if already mlocked */
			if (page == check_page)
",,"@@ -1332,9 +1332,19 @@ static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,
 		BUG_ON(!page || PageAnon(page));
 
 		if (locked_vma) {
-			mlock_vma_page(page);   /* no-op if already mlocked */
-			if (page == check_page)
+			if (page == check_page) {
+				/* we know we have check_page locked */
+				mlock_vma_page(page);
 				ret = SWAP_MLOCK;
+			} else if (trylock_page(page)) {
+				/*
+				 * If we can lock the page, perform mlock.
+				 * Otherwise leave the page alone, it will be
+				 * eventually encountered again later.
+				 */
+				mlock_vma_page(page);
+				unlock_page(page);
+			}
 			continue;	/* don't unmap */
 		}
 ",linux,57e68e9cd65b4b8eb4045a1e0d0746458502554c,3a025760fc158b3726eac89ee95d7f29599e9dfa,1,"static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,
		struct vm_area_struct *vma, struct page *check_page)
{
	struct mm_struct *mm = vma->vm_mm;
	pmd_t *pmd;
	pte_t *pte;
	pte_t pteval;
	spinlock_t *ptl;
	struct page *page;
	unsigned long address;
	unsigned long mmun_start;	/* For mmu_notifiers */
	unsigned long mmun_end;		/* For mmu_notifiers */
	unsigned long end;
	int ret = SWAP_AGAIN;
	int locked_vma = 0;

	address = (vma->vm_start + cursor) & CLUSTER_MASK;
	end = address + CLUSTER_SIZE;
	if (address < vma->vm_start)
		address = vma->vm_start;
	if (end > vma->vm_end)
		end = vma->vm_end;

	pmd = mm_find_pmd(mm, address);
	if (!pmd)
		return ret;

	mmun_start = address;
	mmun_end   = end;
	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);

	/*
	 * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,
	 * keep the sem while scanning the cluster for mlocking pages.
	 */
	if (down_read_trylock(&vma->vm_mm->mmap_sem)) {
		locked_vma = (vma->vm_flags & VM_LOCKED);
		if (!locked_vma)
			up_read(&vma->vm_mm->mmap_sem); /* don't need it */
	}

	pte = pte_offset_map_lock(mm, pmd, address, &ptl);

	/* Update high watermark before we lower rss */
	update_hiwater_rss(mm);

	for (; address < end; pte++, address += PAGE_SIZE) {
		if (!pte_present(*pte))
			continue;
		page = vm_normal_page(vma, address, *pte);
 		BUG_ON(!page || PageAnon(page));
 
 		if (locked_vma) {
//flaw_line_below:
			mlock_vma_page(page);   /* no-op if already mlocked */
//flaw_line_below:
			if (page == check_page)
//fix_flaw_line_below:
//			if (page == check_page) {
//fix_flaw_line_below:
//				/* we know we have check_page locked */
//fix_flaw_line_below:
//				mlock_vma_page(page);
 				ret = SWAP_MLOCK;
//fix_flaw_line_below:
//			} else if (trylock_page(page)) {
//fix_flaw_line_below:
//				/*
//fix_flaw_line_below:
//				 * If we can lock the page, perform mlock.
//fix_flaw_line_below:
//				 * Otherwise leave the page alone, it will be
//fix_flaw_line_below:
//				 * eventually encountered again later.
//fix_flaw_line_below:
//				 */
//fix_flaw_line_below:
//				mlock_vma_page(page);
//fix_flaw_line_below:
//				unlock_page(page);
//fix_flaw_line_below:
//			}
 			continue;	/* don't unmap */
 		}
 
		if (ptep_clear_flush_young_notify(vma, address, pte))
			continue;

		/* Nuke the page table entry. */
		flush_cache_page(vma, address, pte_pfn(*pte));
		pteval = ptep_clear_flush(vma, address, pte);

		/* If nonlinear, store the file page offset in the pte. */
		if (page->index != linear_page_index(vma, address)) {
			pte_t ptfile = pgoff_to_pte(page->index);
			if (pte_soft_dirty(pteval))
				pte_file_mksoft_dirty(ptfile);
			set_pte_at(mm, address, pte, ptfile);
		}

		/* Move the dirty bit to the physical page now the pte is gone. */
		if (pte_dirty(pteval))
			set_page_dirty(page);

		page_remove_rmap(page);
		page_cache_release(page);
		dec_mm_counter(mm, MM_FILEPAGES);
		(*mapcount)--;
	}
	pte_unmap_unlock(pte - 1, ptl);
	mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
	if (locked_vma)
		up_read(&vma->vm_mm->mmap_sem);
	return ret;
}
",179559,"static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,
		struct vm_area_struct *vma, struct page *check_page)
{
	struct mm_struct *mm = vma->vm_mm;
	pmd_t *pmd;
	pte_t *pte;
	pte_t pteval;
	spinlock_t *ptl;
	struct page *page;
	unsigned long address;
	unsigned long mmun_start;	/* For mmu_notifiers */
	unsigned long mmun_end;		/* For mmu_notifiers */
	unsigned long end;
	int ret = SWAP_AGAIN;
	int locked_vma = 0;

	address = (vma->vm_start + cursor) & CLUSTER_MASK;
	end = address + CLUSTER_SIZE;
	if (address < vma->vm_start)
		address = vma->vm_start;
	if (end > vma->vm_end)
		end = vma->vm_end;

	pmd = mm_find_pmd(mm, address);
	if (!pmd)
		return ret;

	mmun_start = address;
	mmun_end   = end;
	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);

	/*
	 * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,
	 * keep the sem while scanning the cluster for mlocking pages.
	 */
	if (down_read_trylock(&vma->vm_mm->mmap_sem)) {
		locked_vma = (vma->vm_flags & VM_LOCKED);
		if (!locked_vma)
			up_read(&vma->vm_mm->mmap_sem); /* don't need it */
	}

	pte = pte_offset_map_lock(mm, pmd, address, &ptl);

	/* Update high watermark before we lower rss */
	update_hiwater_rss(mm);

	for (; address < end; pte++, address += PAGE_SIZE) {
		if (!pte_present(*pte))
			continue;
		page = vm_normal_page(vma, address, *pte);
 		BUG_ON(!page || PageAnon(page));
 
 		if (locked_vma) {
			mlock_vma_page(page);   /* no-op if already mlocked */
			if (page == check_page)
 				ret = SWAP_MLOCK;
 			continue;	/* don't unmap */
 		}
 
		if (ptep_clear_flush_young_notify(vma, address, pte))
			continue;

		/* Nuke the page table entry. */
		flush_cache_page(vma, address, pte_pfn(*pte));
		pteval = ptep_clear_flush(vma, address, pte);

		/* If nonlinear, store the file page offset in the pte. */
		if (page->index != linear_page_index(vma, address)) {
			pte_t ptfile = pgoff_to_pte(page->index);
			if (pte_soft_dirty(pteval))
				pte_file_mksoft_dirty(ptfile);
			set_pte_at(mm, address, pte, ptfile);
		}

		/* Move the dirty bit to the physical page now the pte is gone. */
		if (pte_dirty(pteval))
			set_page_dirty(page);

		page_remove_rmap(page);
		page_cache_release(page);
		dec_mm_counter(mm, MM_FILEPAGES);
		(*mapcount)--;
	}
	pte_unmap_unlock(pte - 1, ptl);
	mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
	if (locked_vma)
		up_read(&vma->vm_mm->mmap_sem);
	return ret;
}
","static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,
		struct vm_area_struct *vma, struct page *check_page)
{
	struct mm_struct *mm = vma->vm_mm;
	pmd_t *pmd;
	pte_t *pte;
	pte_t pteval;
	spinlock_t *ptl;
	struct page *page;
	unsigned long address;
	unsigned long mmun_start;	/* For mmu_notifiers */
	unsigned long mmun_end;		/* For mmu_notifiers */
	unsigned long end;
	int ret = SWAP_AGAIN;
	int locked_vma = 0;

	address = (vma->vm_start + cursor) & CLUSTER_MASK;
	end = address + CLUSTER_SIZE;
	if (address < vma->vm_start)
		address = vma->vm_start;
	if (end > vma->vm_end)
		end = vma->vm_end;

	pmd = mm_find_pmd(mm, address);
	if (!pmd)
		return ret;

	mmun_start = address;
	mmun_end   = end;
	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);

	/*
	 * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,
	 * keep the sem while scanning the cluster for mlocking pages.
	 */
	if (down_read_trylock(&vma->vm_mm->mmap_sem)) {
		locked_vma = (vma->vm_flags & VM_LOCKED);
		if (!locked_vma)
			up_read(&vma->vm_mm->mmap_sem); /* don't need it */
	}

	pte = pte_offset_map_lock(mm, pmd, address, &ptl);

	/* Update high watermark before we lower rss */
	update_hiwater_rss(mm);

	for (; address < end; pte++, address += PAGE_SIZE) {
		if (!pte_present(*pte))
			continue;
		page = vm_normal_page(vma, address, *pte);
 		BUG_ON(!page || PageAnon(page));
 
 		if (locked_vma) {
			if (page == check_page) {
				/* we know we have check_page locked */
				mlock_vma_page(page);
 				ret = SWAP_MLOCK;
			} else if (trylock_page(page)) {
				/*
				 * If we can lock the page, perform mlock.
				 * Otherwise leave the page alone, it will be
				 * eventually encountered again later.
				 */
				mlock_vma_page(page);
				unlock_page(page);
			}
 			continue;	/* don't unmap */
 		}
 
		if (ptep_clear_flush_young_notify(vma, address, pte))
			continue;

		/* Nuke the page table entry. */
		flush_cache_page(vma, address, pte_pfn(*pte));
		pteval = ptep_clear_flush(vma, address, pte);

		/* If nonlinear, store the file page offset in the pte. */
		if (page->index != linear_page_index(vma, address)) {
			pte_t ptfile = pgoff_to_pte(page->index);
			if (pte_soft_dirty(pteval))
				pte_file_mksoft_dirty(ptfile);
			set_pte_at(mm, address, pte, ptfile);
		}

		/* Move the dirty bit to the physical page now the pte is gone. */
		if (pte_dirty(pteval))
			set_page_dirty(page);

		page_remove_rmap(page);
		page_cache_release(page);
		dec_mm_counter(mm, MM_FILEPAGES);
		(*mapcount)--;
	}
	pte_unmap_unlock(pte - 1, ptl);
	mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
	if (locked_vma)
		up_read(&vma->vm_mm->mmap_sem);
	return ret;
}
","The `try_to_unmap_cluster` function attempts to unmap a cluster of memory pages associated with a given virtual memory area (VMA) in a Linux kernel context. It calculates the address range for the cluster, checks for the presence of page table entries, and manages memory locks to ensure safe access. The function iterates through the pages in the specified range, clearing page table entries, updating page states, and handling dirty pages appropriately. It also interacts with memory management notifiers to signal changes in the memory mapping. The function returns a status indicating whether the operation was successful or if it needs to retry.","The provided code defines a function that attempts to unmap a specified range of memory pages within a virtual memory area. It calculates the appropriate address range and checks for existing page mappings while managing locks to ensure safe access to memory structures. The function iterates through the pages, clearing their mappings, updating their states, and handling any dirty pages. It also communicates with memory management notifiers to indicate changes in the memory mapping. The function ultimately returns a status indicating whether the unmapping operation was successful or if it needs to be retried.","The vulnerability in the original code arose from the lack of proper locking for pages other than the specified `check_page` before invoking the `mlock_vma_page` function. This oversight could lead to inconsistencies in memory management, particularly during page migration, as the `BUG_ON` condition in `mlock_vma_page` would trigger if the page was not locked, potentially distorting the accounting for locked pages. The fix introduced a check using `trylock_page` for pages that were not `check_page`, ensuring that `mlock_vma_page` is only called if the page lock is successfully acquired, thus maintaining the integrity of the memory management system.","The vulnerability in the original code stemmed from the failure to lock memory pages before marking them as locked, which could lead to inconsistencies during page migration. This oversight triggered an assertion failure when the code attempted to lock a page that was not already secured, potentially distorting the accounting for locked pages. The fix implemented a check to attempt locking for pages other than the specified one, ensuring that the locking function is only called if the page lock is successfully acquired. This adjustment prevents deadlocks and maintains the integrity of memory management without compromising the overall design.","The vulnerability was fixed by introducing a check using `trylock_page` for pages that are not the `check_page`. This ensures that the code attempts to acquire a lock on these pages before calling `mlock_vma_page`. If the lock is successfully obtained, `mlock_vma_page` is executed; otherwise, the page is left without the `PG_mlocked` flag, which is acceptable within the memory management design. This change prevents potential deadlocks since `check_page` is already locked, and it ensures that the locking mechanism is properly respected, maintaining the integrity of the memory management system.","The vulnerability was addressed by implementing a mechanism to attempt locking for pages that were not specifically designated for checking. This adjustment ensures that the locking function is only called if the page lock is successfully acquired, thereby preventing any assertion failures related to unprotected pages. If the lock cannot be obtained, the page remains in its current state without being marked as locked, which is acceptable within the overall memory management framework. This change effectively mitigates the risk of deadlocks and maintains the integrity of the memory management system during operations.","CWE-833, CWE-667, CWE-764, CWE-410, CWE-662, CWE-deadlock, CWE-412, CWE-366, CWE-821, CWE-367",N,-1
35,35,179629,179629,,Local,Not required,Complete,CVE-2014-0185,https://www.cvedetails.com/cve/CVE-2014-0185/,CWE-264,Low,Complete,Complete,,2014-05-06,7.2,"sapi/fpm/fpm/fpm_unix.c in the FastCGI Process Manager (FPM) in PHP before 5.4.28 and 5.5.x before 5.5.12 uses 0666 permissions for the UNIX socket, which allows local users to gain privileges via a crafted FastCGI client.",2017-01-06,+Priv ,1,https://github.com/php/php-src/commit/35ceea928b12373a3b1e3eecdc32ed323223a40d,35ceea928b12373a3b1e3eecdc32ed323223a40d,Fix bug #67060: use default mode of 660,1,sapi/fpm/fpm/fpm_unix.c,"{""sha"": ""104279441a7faaaef5aebf0db781ecef3eb8b8fd"", ""filename"": ""NEWS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/php/php-src/blob/35ceea928b12373a3b1e3eecdc32ed323223a40d/NEWS"", ""raw_url"": ""https://github.com/php/php-src/raw/35ceea928b12373a3b1e3eecdc32ed323223a40d/NEWS"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/NEWS?ref=35ceea928b12373a3b1e3eecdc32ed323223a40d"", ""patch"": ""@@ -25,7 +25,7 @@ PHP                                                                        NEWS\n   . Fix bug #64498 ($phar->buildFromDirectory can't compress file with an accent \n     in its name). (PR #588) \n \n-?? ??? 2014, PHP 5.4.28\n+01 May 2014, PHP 5.4.28\n \n - Core:\n   . Fixed bug #61019 (Out of memory on command stream_get_contents). (Mike)\n@@ -55,6 +55,8 @@ PHP                                                                        NEWS\n \n - FPM:\n   . Fixed bug #66482 (unknown entry 'priority' in php-fpm.conf). \n+  . Fixed bug #67060 (sapi/fpm: possible privilege escalation due to insecure \n+    default configuration) (CVE-2014-0185). (Stas)\n \n - JSON:\n   . Fixed bug #66021 (Blank line inside empty array/object when""}<_**next**_>{""sha"": ""ea0e67369cd534448894db87c1ab31a8b7ecad96"", ""filename"": ""sapi/fpm/fpm/fpm_unix.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/php/php-src/blob/35ceea928b12373a3b1e3eecdc32ed323223a40d/sapi/fpm/fpm/fpm_unix.c"", ""raw_url"": ""https://github.com/php/php-src/raw/35ceea928b12373a3b1e3eecdc32ed323223a40d/sapi/fpm/fpm/fpm_unix.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/sapi/fpm/fpm/fpm_unix.c?ref=35ceea928b12373a3b1e3eecdc32ed323223a40d"", ""patch"": ""@@ -35,7 +35,7 @@ int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */\n \t/* uninitialized */\n \twp->socket_uid = -1;\n \twp->socket_gid = -1;\n-\twp->socket_mode = 0666;\n+\twp->socket_mode = 0660;\n \n \tif (!c) {\n \t\treturn 0;""}<_**next**_>{""sha"": ""9205d422399b4d5571592fbc1cd57f3419493a80"", ""filename"": ""sapi/fpm/php-fpm.conf.in"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/php/php-src/blob/35ceea928b12373a3b1e3eecdc32ed323223a40d/sapi/fpm/php-fpm.conf.in"", ""raw_url"": ""https://github.com/php/php-src/raw/35ceea928b12373a3b1e3eecdc32ed323223a40d/sapi/fpm/php-fpm.conf.in"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/sapi/fpm/php-fpm.conf.in?ref=35ceea928b12373a3b1e3eecdc32ed323223a40d"", ""patch"": ""@@ -166,10 +166,10 @@ listen = 127.0.0.1:9000\n ; permissions must be set in order to allow connections from a web server. Many\n ; BSD-derived systems allow connections regardless of permissions. \n ; Default Values: user and group are set as the running user\n-;                 mode is set to 0666\n+;                 mode is set to 0660\n ;listen.owner = @php_fpm_user@\n ;listen.group = @php_fpm_group@\n-;listen.mode = 0666\n+;listen.mode = 0660\n  \n ; List of ipv4 addresses of FastCGI clients which are allowed to connect.\n ; Equivalent to the FCGI_WEB_SERVER_ADDRS environment variable in the original""}","int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */
{
	struct fpm_worker_pool_config_s *c = wp->config;

 	/* uninitialized */
 	wp->socket_uid = -1;
 	wp->socket_gid = -1;
	wp->socket_mode = 0660;
 
 	if (!c) {
 		return 0;
	}

	if (c->listen_owner && *c->listen_owner) {
		struct passwd *pwd;

		pwd = getpwnam(c->listen_owner);
		if (!pwd) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get uid for user '%s'"", wp->config->name, c->listen_owner);
			return -1;
		}

		wp->socket_uid = pwd->pw_uid;
		wp->socket_gid = pwd->pw_gid;
	}

	if (c->listen_group && *c->listen_group) {
		struct group *grp;

		grp = getgrnam(c->listen_group);
		if (!grp) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get gid for group '%s'"", wp->config->name, c->listen_group);
			return -1;
		}
		wp->socket_gid = grp->gr_gid;
	}

	if (c->listen_mode && *c->listen_mode) {
		wp->socket_mode = strtoul(c->listen_mode, 0, 8);
	}
	return 0;
}
/* }}} */
","int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */
{
	struct fpm_worker_pool_config_s *c = wp->config;

 	/* uninitialized */
 	wp->socket_uid = -1;
 	wp->socket_gid = -1;
	wp->socket_mode = 0666;
 
 	if (!c) {
 		return 0;
	}

	if (c->listen_owner && *c->listen_owner) {
		struct passwd *pwd;

		pwd = getpwnam(c->listen_owner);
		if (!pwd) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get uid for user '%s'"", wp->config->name, c->listen_owner);
			return -1;
		}

		wp->socket_uid = pwd->pw_uid;
		wp->socket_gid = pwd->pw_gid;
	}

	if (c->listen_group && *c->listen_group) {
		struct group *grp;

		grp = getgrnam(c->listen_group);
		if (!grp) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get gid for group '%s'"", wp->config->name, c->listen_group);
			return -1;
		}
		wp->socket_gid = grp->gr_gid;
	}

	if (c->listen_mode && *c->listen_mode) {
		wp->socket_mode = strtoul(c->listen_mode, 0, 8);
	}
	return 0;
}
/* }}} */
",C,"	wp->socket_mode = 0660;
","	wp->socket_mode = 0666;
",,"@@ -35,7 +35,7 @@ int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */
 	/* uninitialized */
 	wp->socket_uid = -1;
 	wp->socket_gid = -1;
-	wp->socket_mode = 0666;
+	wp->socket_mode = 0660;
 
 	if (!c) {
 		return 0;",php-src,35ceea928b12373a3b1e3eecdc32ed323223a40d,2d625b5f81205d7f0217243b0bfe9a77683951e8,1,"int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */
{
	struct fpm_worker_pool_config_s *c = wp->config;

 	/* uninitialized */
 	wp->socket_uid = -1;
 	wp->socket_gid = -1;
//flaw_line_below:
	wp->socket_mode = 0666;
//fix_flaw_line_below:
//	wp->socket_mode = 0660;
 
 	if (!c) {
 		return 0;
	}

	if (c->listen_owner && *c->listen_owner) {
		struct passwd *pwd;

		pwd = getpwnam(c->listen_owner);
		if (!pwd) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get uid for user '%s'"", wp->config->name, c->listen_owner);
			return -1;
		}

		wp->socket_uid = pwd->pw_uid;
		wp->socket_gid = pwd->pw_gid;
	}

	if (c->listen_group && *c->listen_group) {
		struct group *grp;

		grp = getgrnam(c->listen_group);
		if (!grp) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get gid for group '%s'"", wp->config->name, c->listen_group);
			return -1;
		}
		wp->socket_gid = grp->gr_gid;
	}

	if (c->listen_mode && *c->listen_mode) {
		wp->socket_mode = strtoul(c->listen_mode, 0, 8);
	}
	return 0;
}
/* }}} */
",179629,"int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */
{
	struct fpm_worker_pool_config_s *c = wp->config;

	/* uninitialized */
	wp->socket_uid = -1;
	wp->socket_gid = -1;
	wp->socket_mode = 0666;

	if (!c) {
		return 0;
	}

	if (c->listen_owner && *c->listen_owner) {
		struct passwd *pwd;

		pwd = getpwnam(c->listen_owner);
		if (!pwd) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get uid for user '%s'"", wp->config->name, c->listen_owner);
			return -1;
		}

		wp->socket_uid = pwd->pw_uid;
		wp->socket_gid = pwd->pw_gid;
	}

	if (c->listen_group && *c->listen_group) {
		struct group *grp;

		grp = getgrnam(c->listen_group);
		if (!grp) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get gid for group '%s'"", wp->config->name, c->listen_group);
			return -1;
		}
		wp->socket_gid = grp->gr_gid;
	}

	if (c->listen_mode && *c->listen_mode) {
		wp->socket_mode = strtoul(c->listen_mode, 0, 8);
	}
	return 0;
}","int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) /* {{{ */
{
	struct fpm_worker_pool_config_s *c = wp->config;

 	/* uninitialized */
 	wp->socket_uid = -1;
 	wp->socket_gid = -1;
	wp->socket_mode = 0660;
 
 	if (!c) {
 		return 0;
	}

	if (c->listen_owner && *c->listen_owner) {
		struct passwd *pwd;

		pwd = getpwnam(c->listen_owner);
		if (!pwd) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get uid for user '%s'"", wp->config->name, c->listen_owner);
			return -1;
		}

		wp->socket_uid = pwd->pw_uid;
		wp->socket_gid = pwd->pw_gid;
	}

	if (c->listen_group && *c->listen_group) {
		struct group *grp;

		grp = getgrnam(c->listen_group);
		if (!grp) {
			zlog(ZLOG_SYSERROR, ""[pool %s] cannot get gid for group '%s'"", wp->config->name, c->listen_group);
			return -1;
		}
		wp->socket_gid = grp->gr_gid;
	}

	if (c->listen_mode && *c->listen_mode) {
		wp->socket_mode = strtoul(c->listen_mode, 0, 8);
	}
	return 0;
}
/* }}} */
","The function `fpm_unix_resolve_socket_permissions` is designed to configure socket permissions for a worker pool in a FastCGI Process Manager (FPM) environment. It initializes the socket's user ID, group ID, and mode with default values. If the configuration specifies a listening owner, it retrieves the corresponding user ID and group ID using `getpwnam` and `getgrnam`, respectively, logging an error if the user or group cannot be found. Additionally, if a listening mode is provided, it converts the string representation of the mode into an octal value. The function ultimately returns 0 on success or -1 on failure.","The code defines a function that configures socket permissions for a worker pool in a server environment. It begins by setting default values for the socket's user ID, group ID, and access mode. If a specific user is designated as the owner, the function retrieves their user ID and group ID, logging an error if the user cannot be found. Similarly, if a group is specified, it fetches the corresponding group ID. Additionally, if a specific access mode is provided, it converts it from a string to an octal format. The function returns a success or failure status based on these operations.","The vulnerability in the original code stemmed from setting the default socket mode to 0666, which allowed read and write permissions for all users, potentially exposing the socket to unauthorized access. This could lead to security risks, such as unauthorized users being able to connect to the socket. The fix involved changing the default socket mode to 0660, which restricts access to the owner and the group only, thereby enhancing security. This adjustment reduces the risk of unauthorized access while maintaining necessary functionality for legitimate users and groups.","The vulnerability in the original code was due to setting a default socket mode that allowed read and write permissions for all users, which could lead to unauthorized access and potential security breaches. This permissive setting increased the risk of malicious users connecting to the socket and interfering with its operations. The fix involved changing the default mode to a more restrictive setting, limiting access to only the owner and the group. This adjustment significantly enhances security by reducing the potential attack surface while still allowing legitimate users the necessary access to the socket.","The vulnerability was fixed by changing the default value of `wp->socket_mode` from 0666 to 0660. This modification restricts socket permissions, allowing read and write access only to the owner and the group, thereby preventing unauthorized users from connecting to the socket. By implementing this change, the code reduces the risk of security breaches associated with overly permissive access rights. Additionally, the function retains the ability to set custom permissions through the `listen_mode` configuration, ensuring that legitimate access needs can still be met while enhancing overall security.","The vulnerability was fixed by changing the default socket permissions to a more restrictive setting, limiting access to only the owner and the group instead of allowing all users to read and write. This adjustment significantly reduces the risk of unauthorized access and potential security breaches by preventing malicious users from connecting to the socket. The updated code still allows for custom permissions to be set through configuration, ensuring that legitimate access requirements can be met while enhancing the overall security posture of the application. This change effectively mitigates the risks associated with overly permissive access rights.","CWE-732, CWE-266, CWE-668, CWE-282, CWE-264, CWE-284, CWE-269, CWE-732, CWE-275, CWE-280",N,-1
36,36,179717,179717,,Remote,Not required,,CVE-2013-2182,https://www.cvedetails.com/cve/CVE-2013-2182/,CWE-264,Medium,Partial,Partial,,2014-06-13,5.8,"The Mandril security plugin in Monkey HTTP Daemon (monkeyd) before 1.5.0 allows remote attackers to bypass access restrictions via a crafted URI, as demonstrated by an encoded forward slash.",2014-06-13,Bypass ,2,https://github.com/monkey/monkey/commit/15f72c1ee5e0afad20232bdf0fcecab8d62a5d89,15f72c1ee5e0afad20232bdf0fcecab8d62a5d89,"Mandril: check decoded URI (fix #92)

Signed-off-by: Eduardo Silva <eduardo@monkey.io>",1,plugins/mandril/mandril.c,"{""sha"": ""820f4416d769860a11599c2ded44762ec729d7ff"", ""filename"": ""plugins/mandril/mandril.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/monkey/monkey/blob/15f72c1ee5e0afad20232bdf0fcecab8d62a5d89/plugins/mandril/mandril.c"", ""raw_url"": ""https://github.com/monkey/monkey/raw/15f72c1ee5e0afad20232bdf0fcecab8d62a5d89/plugins/mandril/mandril.c"", ""contents_url"": ""https://api.github.com/repos/monkey/monkey/contents/plugins/mandril/mandril.c?ref=15f72c1ee5e0afad20232bdf0fcecab8d62a5d89"", ""patch"": ""@@ -349,7 +349,8 @@ int _mkp_stage_30(struct plugin *p,\n     (void) cs;\n \n     PLUGIN_TRACE(\""[FD %i] Mandril validating URL\"", cs->socket);\n-    if (mk_security_check_url(sr->uri) < 0) {\n+\n+    if (mk_security_check_url(sr->uri_processed) < 0) {\n         PLUGIN_TRACE(\""[FD %i] Close connection, blocked URL\"", cs->socket);\n         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n         return MK_PLUGIN_RET_CLOSE_CONX;""}","int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
     (void) cs;
 
     PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);

    if (mk_security_check_url(sr->uri_processed) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}
","int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
     (void) cs;
 
     PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}
",C,"
    if (mk_security_check_url(sr->uri_processed) < 0) {
","    if (mk_security_check_url(sr->uri) < 0) {
",,"@@ -349,7 +349,8 @@ int _mkp_stage_30(struct plugin *p,
     (void) cs;
 
     PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
-    if (mk_security_check_url(sr->uri) < 0) {
+
+    if (mk_security_check_url(sr->uri_processed) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;",monkey,15f72c1ee5e0afad20232bdf0fcecab8d62a5d89,f929f3e6dca9a0ff2e08dcd286346ef7e436c139,1,"int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
     (void) cs;
 
     PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
//flaw_line_below:
    if (mk_security_check_url(sr->uri) < 0) {
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (mk_security_check_url(sr->uri_processed) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}
",179717,"int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
     (void) cs;
 
     PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}
","int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
     (void) cs;
 
     PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);

    if (mk_security_check_url(sr->uri_processed) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}
","The provided code defines a function `_mkp_stage_30` that validates URLs and checks for hotlinking in a web server plugin context. It first checks if the requested URL is secure using `mk_security_check_url`, closing the connection and returning a forbidden status if the URL is blocked. Next, it retrieves the ""Referer"" header and validates it against the processed URI and host using `mk_security_check_hotlink`. If hotlinking is detected, it similarly closes the connection and sets a forbidden status. If both checks pass, the function returns a value indicating that it does not handle the request further.","The code defines a function that validates incoming requests to ensure they adhere to security protocols. It first checks if the requested URL is safe, and if not, it terminates the connection while signaling that access is forbidden. Next, it examines the ""Referer"" header to prevent unauthorized linking to resources from external sites. If this check fails, the function again closes the connection and indicates that access is denied. If both security checks are passed, the function indicates that it does not take further action on the request, allowing it to be processed by other components.","The vulnerability in the original code stemmed from the use of an improperly processed URI in the security check, which could allow malicious URLs to bypass validation. Specifically, the function `mk_security_check_url` was called with `sr->uri`, potentially exposing the application to attacks through encoded or manipulated URLs. The fix involved changing the function call to use `sr->uri_processed`, ensuring that the URI is properly decoded and sanitized before validation. This adjustment mitigates the risk of accepting harmful URLs, thereby enhancing the overall security of the application.","The vulnerability in the original code arose from the validation of URLs without proper decoding, which could allow attackers to exploit encoded or manipulated URLs to bypass security checks. This oversight could lead to unauthorized access or other malicious activities. The fix addressed this issue by ensuring that the validation process uses a properly decoded version of the URI, thereby enhancing the security checks. By validating the sanitized input instead of the raw URL, the code now effectively mitigates the risk of accepting harmful requests, thus improving the overall robustness of the application against potential attacks.","The vulnerability was fixed by changing the argument passed to the `mk_security_check_url` function from `sr->uri` to `sr->uri_processed`. This adjustment ensures that the URL being validated is properly decoded and sanitized before the security check is performed. By using the processed URI, the code mitigates the risk of attackers exploiting encoded URLs to bypass security measures. Additionally, this change enhances the overall integrity of the validation process, ensuring that only safe and correctly formatted URLs are accepted, thereby improving the application's resilience against potential threats.","The vulnerability was fixed by ensuring that the URL validation process uses a properly decoded and sanitized version of the input instead of the raw, potentially manipulated URL. This change prevents attackers from exploiting encoded URLs to bypass security checks, thereby enhancing the overall security of the application. By validating the sanitized input, the code now effectively mitigates the risk of unauthorized access and other malicious activities. This adjustment improves the robustness of the security measures in place, ensuring that only safe and correctly formatted requests are processed.","CWE-20,CWE-601,CWE-22,CWE-73,CWE-74,CWE-116,CWE-79,CWE-644,CWE-641,CWE-288",N,-1
37,37,179719,179719,,Local,Not required,Complete,CVE-2012-6657,https://www.cvedetails.com/cve/CVE-2012-6657/,CWE-264,Low,,,,2014-09-28,4.9,"The sock_setsockopt function in net/core/sock.c in the Linux kernel before 3.5.7 does not ensure that a keepalive action is associated with a stream socket, which allows local users to cause a denial of service (system crash) by leveraging the ability to create a raw socket.",2016-08-22,DoS ,2,https://github.com/torvalds/linux/commit/3e10986d1d698140747fcfc2761ec9cb64c1d582,3e10986d1d698140747fcfc2761ec9cb64c1d582,"net: guard tcp_set_keepalive() to tcp sockets

Its possible to use RAW sockets to get a crash in
tcp_set_keepalive() / sk_reset_timer()

Fix is to make sure socket is a SOCK_STREAM one.

Reported-by: Dave Jones <davej@redhat.com>
Signed-off-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/core/sock.c,"{""sha"": ""a6000fbad2949f58a079322f4e328e0c051df896"", ""filename"": ""net/core/sock.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/3e10986d1d698140747fcfc2761ec9cb64c1d582/net/core/sock.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/3e10986d1d698140747fcfc2761ec9cb64c1d582/net/core/sock.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/core/sock.c?ref=3e10986d1d698140747fcfc2761ec9cb64c1d582"", ""patch"": ""@@ -691,7 +691,8 @@ int sock_setsockopt(struct socket *sock, int level, int optname,\n \n \tcase SO_KEEPALIVE:\n #ifdef CONFIG_INET\n-\t\tif (sk->sk_protocol == IPPROTO_TCP)\n+\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n+\t\t    sk->sk_type == SOCK_STREAM)\n \t\t\ttcp_set_keepalive(sk, valbool);\n #endif\n \t\tsock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);""}","int sock_setsockopt(struct socket *sock, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	struct sock *sk = sock->sk;
	int val;
	int valbool;
	struct linger ling;
	int ret = 0;

	/*
	 *	Options without arguments
	 */

	if (optname == SO_BINDTODEVICE)
		return sock_bindtodevice(sk, optval, optlen);

	if (optlen < sizeof(int))
		return -EINVAL;

	if (get_user(val, (int __user *)optval))
		return -EFAULT;

	valbool = val ? 1 : 0;

	lock_sock(sk);

	switch (optname) {
	case SO_DEBUG:
		if (val && !capable(CAP_NET_ADMIN))
			ret = -EACCES;
		else
			sock_valbool_flag(sk, SOCK_DBG, valbool);
		break;
	case SO_REUSEADDR:
		sk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);
		break;
	case SO_TYPE:
	case SO_PROTOCOL:
	case SO_DOMAIN:
	case SO_ERROR:
		ret = -ENOPROTOOPT;
		break;
	case SO_DONTROUTE:
		sock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);
		break;
	case SO_BROADCAST:
		sock_valbool_flag(sk, SOCK_BROADCAST, valbool);
		break;
	case SO_SNDBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_wmem_max);
set_sndbuf:
		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
		sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
		/* Wake up sending tasks if we upped the value. */
		sk->sk_write_space(sk);
		break;

	case SO_SNDBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_sndbuf;

	case SO_RCVBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_rmem_max);
set_rcvbuf:
		sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
		/*
		 * We double it on the way in to account for
		 * ""struct sk_buff"" etc. overhead.   Applications
		 * assume that the SO_RCVBUF setting they make will
		 * allow that much actual data to be received on that
		 * socket.
		 *
		 * Applications are unaware that ""struct sk_buff"" and
		 * other overheads allocate from the receive buffer
		 * during socket buffer allocation.
		 *
		 * And after considering the possible alternatives,
		 * returning the value we actually used in getsockopt
		 * is the most desirable behavior.
		 */
		sk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);
		break;

	case SO_RCVBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_rcvbuf;
 
 	case SO_KEEPALIVE:
 #ifdef CONFIG_INET
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
 			tcp_set_keepalive(sk, valbool);
 #endif
 		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);
		break;

	case SO_OOBINLINE:
		sock_valbool_flag(sk, SOCK_URGINLINE, valbool);
		break;

	case SO_NO_CHECK:
		sk->sk_no_check = valbool;
		break;

	case SO_PRIORITY:
		if ((val >= 0 && val <= 6) || capable(CAP_NET_ADMIN))
			sk->sk_priority = val;
		else
			ret = -EPERM;
		break;

	case SO_LINGER:
		if (optlen < sizeof(ling)) {
			ret = -EINVAL;	/* 1003.1g */
			break;
		}
		if (copy_from_user(&ling, optval, sizeof(ling))) {
			ret = -EFAULT;
			break;
		}
		if (!ling.l_onoff)
			sock_reset_flag(sk, SOCK_LINGER);
		else {
#if (BITS_PER_LONG == 32)
			if ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)
				sk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;
			else
#endif
				sk->sk_lingertime = (unsigned int)ling.l_linger * HZ;
			sock_set_flag(sk, SOCK_LINGER);
		}
		break;

	case SO_BSDCOMPAT:
		sock_warn_obsolete_bsdism(""setsockopt"");
		break;

	case SO_PASSCRED:
		if (valbool)
			set_bit(SOCK_PASSCRED, &sock->flags);
		else
			clear_bit(SOCK_PASSCRED, &sock->flags);
		break;

	case SO_TIMESTAMP:
	case SO_TIMESTAMPNS:
		if (valbool)  {
			if (optname == SO_TIMESTAMP)
				sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
			else
				sock_set_flag(sk, SOCK_RCVTSTAMPNS);
			sock_set_flag(sk, SOCK_RCVTSTAMP);
			sock_enable_timestamp(sk, SOCK_TIMESTAMP);
		} else {
			sock_reset_flag(sk, SOCK_RCVTSTAMP);
			sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
		}
		break;

	case SO_TIMESTAMPING:
		if (val & ~SOF_TIMESTAMPING_MASK) {
			ret = -EINVAL;
			break;
		}
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE,
				  val & SOF_TIMESTAMPING_TX_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE,
				  val & SOF_TIMESTAMPING_TX_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE,
				  val & SOF_TIMESTAMPING_RX_HARDWARE);
		if (val & SOF_TIMESTAMPING_RX_SOFTWARE)
			sock_enable_timestamp(sk,
					      SOCK_TIMESTAMPING_RX_SOFTWARE);
		else
			sock_disable_timestamp(sk,
					       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SOFTWARE,
				  val & SOF_TIMESTAMPING_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE,
				  val & SOF_TIMESTAMPING_SYS_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE,
				  val & SOF_TIMESTAMPING_RAW_HARDWARE);
		break;

	case SO_RCVLOWAT:
		if (val < 0)
			val = INT_MAX;
		sk->sk_rcvlowat = val ? : 1;
		break;

	case SO_RCVTIMEO:
		ret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);
		break;

	case SO_SNDTIMEO:
		ret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);
		break;

	case SO_ATTACH_FILTER:
		ret = -EINVAL;
		if (optlen == sizeof(struct sock_fprog)) {
			struct sock_fprog fprog;

			ret = -EFAULT;
			if (copy_from_user(&fprog, optval, sizeof(fprog)))
				break;

			ret = sk_attach_filter(&fprog, sk);
		}
		break;

	case SO_DETACH_FILTER:
		ret = sk_detach_filter(sk);
		break;

	case SO_PASSSEC:
		if (valbool)
			set_bit(SOCK_PASSSEC, &sock->flags);
		else
			clear_bit(SOCK_PASSSEC, &sock->flags);
		break;
	case SO_MARK:
		if (!capable(CAP_NET_ADMIN))
			ret = -EPERM;
		else
			sk->sk_mark = val;
		break;

		/* We implement the SO_SNDLOWAT etc to
		   not be settable (1003.1g 5.3) */
	case SO_RXQ_OVFL:
		sock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);
		break;

	case SO_WIFI_STATUS:
		sock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);
		break;

	case SO_PEEK_OFF:
		if (sock->ops->set_peek_off)
			sock->ops->set_peek_off(sk, val);
		else
			ret = -EOPNOTSUPP;
		break;

	case SO_NOFCS:
		sock_valbool_flag(sk, SOCK_NOFCS, valbool);
		break;

	default:
		ret = -ENOPROTOOPT;
		break;
	}
	release_sock(sk);
	return ret;
}
","int sock_setsockopt(struct socket *sock, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	struct sock *sk = sock->sk;
	int val;
	int valbool;
	struct linger ling;
	int ret = 0;

	/*
	 *	Options without arguments
	 */

	if (optname == SO_BINDTODEVICE)
		return sock_bindtodevice(sk, optval, optlen);

	if (optlen < sizeof(int))
		return -EINVAL;

	if (get_user(val, (int __user *)optval))
		return -EFAULT;

	valbool = val ? 1 : 0;

	lock_sock(sk);

	switch (optname) {
	case SO_DEBUG:
		if (val && !capable(CAP_NET_ADMIN))
			ret = -EACCES;
		else
			sock_valbool_flag(sk, SOCK_DBG, valbool);
		break;
	case SO_REUSEADDR:
		sk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);
		break;
	case SO_TYPE:
	case SO_PROTOCOL:
	case SO_DOMAIN:
	case SO_ERROR:
		ret = -ENOPROTOOPT;
		break;
	case SO_DONTROUTE:
		sock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);
		break;
	case SO_BROADCAST:
		sock_valbool_flag(sk, SOCK_BROADCAST, valbool);
		break;
	case SO_SNDBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_wmem_max);
set_sndbuf:
		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
		sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
		/* Wake up sending tasks if we upped the value. */
		sk->sk_write_space(sk);
		break;

	case SO_SNDBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_sndbuf;

	case SO_RCVBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_rmem_max);
set_rcvbuf:
		sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
		/*
		 * We double it on the way in to account for
		 * ""struct sk_buff"" etc. overhead.   Applications
		 * assume that the SO_RCVBUF setting they make will
		 * allow that much actual data to be received on that
		 * socket.
		 *
		 * Applications are unaware that ""struct sk_buff"" and
		 * other overheads allocate from the receive buffer
		 * during socket buffer allocation.
		 *
		 * And after considering the possible alternatives,
		 * returning the value we actually used in getsockopt
		 * is the most desirable behavior.
		 */
		sk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);
		break;

	case SO_RCVBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_rcvbuf;
 
 	case SO_KEEPALIVE:
 #ifdef CONFIG_INET
		if (sk->sk_protocol == IPPROTO_TCP)
 			tcp_set_keepalive(sk, valbool);
 #endif
 		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);
		break;

	case SO_OOBINLINE:
		sock_valbool_flag(sk, SOCK_URGINLINE, valbool);
		break;

	case SO_NO_CHECK:
		sk->sk_no_check = valbool;
		break;

	case SO_PRIORITY:
		if ((val >= 0 && val <= 6) || capable(CAP_NET_ADMIN))
			sk->sk_priority = val;
		else
			ret = -EPERM;
		break;

	case SO_LINGER:
		if (optlen < sizeof(ling)) {
			ret = -EINVAL;	/* 1003.1g */
			break;
		}
		if (copy_from_user(&ling, optval, sizeof(ling))) {
			ret = -EFAULT;
			break;
		}
		if (!ling.l_onoff)
			sock_reset_flag(sk, SOCK_LINGER);
		else {
#if (BITS_PER_LONG == 32)
			if ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)
				sk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;
			else
#endif
				sk->sk_lingertime = (unsigned int)ling.l_linger * HZ;
			sock_set_flag(sk, SOCK_LINGER);
		}
		break;

	case SO_BSDCOMPAT:
		sock_warn_obsolete_bsdism(""setsockopt"");
		break;

	case SO_PASSCRED:
		if (valbool)
			set_bit(SOCK_PASSCRED, &sock->flags);
		else
			clear_bit(SOCK_PASSCRED, &sock->flags);
		break;

	case SO_TIMESTAMP:
	case SO_TIMESTAMPNS:
		if (valbool)  {
			if (optname == SO_TIMESTAMP)
				sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
			else
				sock_set_flag(sk, SOCK_RCVTSTAMPNS);
			sock_set_flag(sk, SOCK_RCVTSTAMP);
			sock_enable_timestamp(sk, SOCK_TIMESTAMP);
		} else {
			sock_reset_flag(sk, SOCK_RCVTSTAMP);
			sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
		}
		break;

	case SO_TIMESTAMPING:
		if (val & ~SOF_TIMESTAMPING_MASK) {
			ret = -EINVAL;
			break;
		}
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE,
				  val & SOF_TIMESTAMPING_TX_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE,
				  val & SOF_TIMESTAMPING_TX_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE,
				  val & SOF_TIMESTAMPING_RX_HARDWARE);
		if (val & SOF_TIMESTAMPING_RX_SOFTWARE)
			sock_enable_timestamp(sk,
					      SOCK_TIMESTAMPING_RX_SOFTWARE);
		else
			sock_disable_timestamp(sk,
					       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SOFTWARE,
				  val & SOF_TIMESTAMPING_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE,
				  val & SOF_TIMESTAMPING_SYS_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE,
				  val & SOF_TIMESTAMPING_RAW_HARDWARE);
		break;

	case SO_RCVLOWAT:
		if (val < 0)
			val = INT_MAX;
		sk->sk_rcvlowat = val ? : 1;
		break;

	case SO_RCVTIMEO:
		ret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);
		break;

	case SO_SNDTIMEO:
		ret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);
		break;

	case SO_ATTACH_FILTER:
		ret = -EINVAL;
		if (optlen == sizeof(struct sock_fprog)) {
			struct sock_fprog fprog;

			ret = -EFAULT;
			if (copy_from_user(&fprog, optval, sizeof(fprog)))
				break;

			ret = sk_attach_filter(&fprog, sk);
		}
		break;

	case SO_DETACH_FILTER:
		ret = sk_detach_filter(sk);
		break;

	case SO_PASSSEC:
		if (valbool)
			set_bit(SOCK_PASSSEC, &sock->flags);
		else
			clear_bit(SOCK_PASSSEC, &sock->flags);
		break;
	case SO_MARK:
		if (!capable(CAP_NET_ADMIN))
			ret = -EPERM;
		else
			sk->sk_mark = val;
		break;

		/* We implement the SO_SNDLOWAT etc to
		   not be settable (1003.1g 5.3) */
	case SO_RXQ_OVFL:
		sock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);
		break;

	case SO_WIFI_STATUS:
		sock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);
		break;

	case SO_PEEK_OFF:
		if (sock->ops->set_peek_off)
			sock->ops->set_peek_off(sk, val);
		else
			ret = -EOPNOTSUPP;
		break;

	case SO_NOFCS:
		sock_valbool_flag(sk, SOCK_NOFCS, valbool);
		break;

	default:
		ret = -ENOPROTOOPT;
		break;
	}
	release_sock(sk);
	return ret;
}
",C,"		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
","		if (sk->sk_protocol == IPPROTO_TCP)
",,"@@ -691,7 +691,8 @@ int sock_setsockopt(struct socket *sock, int level, int optname,
 
 	case SO_KEEPALIVE:
 #ifdef CONFIG_INET
-		if (sk->sk_protocol == IPPROTO_TCP)
+		if (sk->sk_protocol == IPPROTO_TCP &&
+		    sk->sk_type == SOCK_STREAM)
 			tcp_set_keepalive(sk, valbool);
 #endif
 		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);",linux,3e10986d1d698140747fcfc2761ec9cb64c1d582,69190e67d4fac49e2f6ea22f46780d0c712214b8,1,"int sock_setsockopt(struct socket *sock, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	struct sock *sk = sock->sk;
	int val;
	int valbool;
	struct linger ling;
	int ret = 0;

	/*
	 *	Options without arguments
	 */

	if (optname == SO_BINDTODEVICE)
		return sock_bindtodevice(sk, optval, optlen);

	if (optlen < sizeof(int))
		return -EINVAL;

	if (get_user(val, (int __user *)optval))
		return -EFAULT;

	valbool = val ? 1 : 0;

	lock_sock(sk);

	switch (optname) {
	case SO_DEBUG:
		if (val && !capable(CAP_NET_ADMIN))
			ret = -EACCES;
		else
			sock_valbool_flag(sk, SOCK_DBG, valbool);
		break;
	case SO_REUSEADDR:
		sk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);
		break;
	case SO_TYPE:
	case SO_PROTOCOL:
	case SO_DOMAIN:
	case SO_ERROR:
		ret = -ENOPROTOOPT;
		break;
	case SO_DONTROUTE:
		sock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);
		break;
	case SO_BROADCAST:
		sock_valbool_flag(sk, SOCK_BROADCAST, valbool);
		break;
	case SO_SNDBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_wmem_max);
set_sndbuf:
		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
		sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
		/* Wake up sending tasks if we upped the value. */
		sk->sk_write_space(sk);
		break;

	case SO_SNDBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_sndbuf;

	case SO_RCVBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_rmem_max);
set_rcvbuf:
		sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
		/*
		 * We double it on the way in to account for
		 * ""struct sk_buff"" etc. overhead.   Applications
		 * assume that the SO_RCVBUF setting they make will
		 * allow that much actual data to be received on that
		 * socket.
		 *
		 * Applications are unaware that ""struct sk_buff"" and
		 * other overheads allocate from the receive buffer
		 * during socket buffer allocation.
		 *
		 * And after considering the possible alternatives,
		 * returning the value we actually used in getsockopt
		 * is the most desirable behavior.
		 */
		sk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);
		break;

	case SO_RCVBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_rcvbuf;
 
 	case SO_KEEPALIVE:
 #ifdef CONFIG_INET
//flaw_line_below:
		if (sk->sk_protocol == IPPROTO_TCP)
//fix_flaw_line_below:
//		if (sk->sk_protocol == IPPROTO_TCP &&
//fix_flaw_line_below:
//		    sk->sk_type == SOCK_STREAM)
 			tcp_set_keepalive(sk, valbool);
 #endif
 		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);
		break;

	case SO_OOBINLINE:
		sock_valbool_flag(sk, SOCK_URGINLINE, valbool);
		break;

	case SO_NO_CHECK:
		sk->sk_no_check = valbool;
		break;

	case SO_PRIORITY:
		if ((val >= 0 && val <= 6) || capable(CAP_NET_ADMIN))
			sk->sk_priority = val;
		else
			ret = -EPERM;
		break;

	case SO_LINGER:
		if (optlen < sizeof(ling)) {
			ret = -EINVAL;	/* 1003.1g */
			break;
		}
		if (copy_from_user(&ling, optval, sizeof(ling))) {
			ret = -EFAULT;
			break;
		}
		if (!ling.l_onoff)
			sock_reset_flag(sk, SOCK_LINGER);
		else {
#if (BITS_PER_LONG == 32)
			if ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)
				sk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;
			else
#endif
				sk->sk_lingertime = (unsigned int)ling.l_linger * HZ;
			sock_set_flag(sk, SOCK_LINGER);
		}
		break;

	case SO_BSDCOMPAT:
		sock_warn_obsolete_bsdism(""setsockopt"");
		break;

	case SO_PASSCRED:
		if (valbool)
			set_bit(SOCK_PASSCRED, &sock->flags);
		else
			clear_bit(SOCK_PASSCRED, &sock->flags);
		break;

	case SO_TIMESTAMP:
	case SO_TIMESTAMPNS:
		if (valbool)  {
			if (optname == SO_TIMESTAMP)
				sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
			else
				sock_set_flag(sk, SOCK_RCVTSTAMPNS);
			sock_set_flag(sk, SOCK_RCVTSTAMP);
			sock_enable_timestamp(sk, SOCK_TIMESTAMP);
		} else {
			sock_reset_flag(sk, SOCK_RCVTSTAMP);
			sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
		}
		break;

	case SO_TIMESTAMPING:
		if (val & ~SOF_TIMESTAMPING_MASK) {
			ret = -EINVAL;
			break;
		}
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE,
				  val & SOF_TIMESTAMPING_TX_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE,
				  val & SOF_TIMESTAMPING_TX_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE,
				  val & SOF_TIMESTAMPING_RX_HARDWARE);
		if (val & SOF_TIMESTAMPING_RX_SOFTWARE)
			sock_enable_timestamp(sk,
					      SOCK_TIMESTAMPING_RX_SOFTWARE);
		else
			sock_disable_timestamp(sk,
					       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SOFTWARE,
				  val & SOF_TIMESTAMPING_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE,
				  val & SOF_TIMESTAMPING_SYS_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE,
				  val & SOF_TIMESTAMPING_RAW_HARDWARE);
		break;

	case SO_RCVLOWAT:
		if (val < 0)
			val = INT_MAX;
		sk->sk_rcvlowat = val ? : 1;
		break;

	case SO_RCVTIMEO:
		ret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);
		break;

	case SO_SNDTIMEO:
		ret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);
		break;

	case SO_ATTACH_FILTER:
		ret = -EINVAL;
		if (optlen == sizeof(struct sock_fprog)) {
			struct sock_fprog fprog;

			ret = -EFAULT;
			if (copy_from_user(&fprog, optval, sizeof(fprog)))
				break;

			ret = sk_attach_filter(&fprog, sk);
		}
		break;

	case SO_DETACH_FILTER:
		ret = sk_detach_filter(sk);
		break;

	case SO_PASSSEC:
		if (valbool)
			set_bit(SOCK_PASSSEC, &sock->flags);
		else
			clear_bit(SOCK_PASSSEC, &sock->flags);
		break;
	case SO_MARK:
		if (!capable(CAP_NET_ADMIN))
			ret = -EPERM;
		else
			sk->sk_mark = val;
		break;

		/* We implement the SO_SNDLOWAT etc to
		   not be settable (1003.1g 5.3) */
	case SO_RXQ_OVFL:
		sock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);
		break;

	case SO_WIFI_STATUS:
		sock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);
		break;

	case SO_PEEK_OFF:
		if (sock->ops->set_peek_off)
			sock->ops->set_peek_off(sk, val);
		else
			ret = -EOPNOTSUPP;
		break;

	case SO_NOFCS:
		sock_valbool_flag(sk, SOCK_NOFCS, valbool);
		break;

	default:
		ret = -ENOPROTOOPT;
		break;
	}
	release_sock(sk);
	return ret;
}
",179719,"int sock_setsockopt(struct socket *sock, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	struct sock *sk = sock->sk;
	int val;
	int valbool;
	struct linger ling;
	int ret = 0;

	/*
	 *	Options without arguments
	 */

	if (optname == SO_BINDTODEVICE)
		return sock_bindtodevice(sk, optval, optlen);

	if (optlen < sizeof(int))
		return -EINVAL;

	if (get_user(val, (int __user *)optval))
		return -EFAULT;

	valbool = val ? 1 : 0;

	lock_sock(sk);

	switch (optname) {
	case SO_DEBUG:
		if (val && !capable(CAP_NET_ADMIN))
			ret = -EACCES;
		else
			sock_valbool_flag(sk, SOCK_DBG, valbool);
		break;
	case SO_REUSEADDR:
		sk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);
		break;
	case SO_TYPE:
	case SO_PROTOCOL:
	case SO_DOMAIN:
	case SO_ERROR:
		ret = -ENOPROTOOPT;
		break;
	case SO_DONTROUTE:
		sock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);
		break;
	case SO_BROADCAST:
		sock_valbool_flag(sk, SOCK_BROADCAST, valbool);
		break;
	case SO_SNDBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_wmem_max);
set_sndbuf:
		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
		sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
		/* Wake up sending tasks if we upped the value. */
		sk->sk_write_space(sk);
		break;

	case SO_SNDBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_sndbuf;

	case SO_RCVBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_rmem_max);
set_rcvbuf:
		sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
		/*
		 * We double it on the way in to account for
		 * ""struct sk_buff"" etc. overhead.   Applications
		 * assume that the SO_RCVBUF setting they make will
		 * allow that much actual data to be received on that
		 * socket.
		 *
		 * Applications are unaware that ""struct sk_buff"" and
		 * other overheads allocate from the receive buffer
		 * during socket buffer allocation.
		 *
		 * And after considering the possible alternatives,
		 * returning the value we actually used in getsockopt
		 * is the most desirable behavior.
		 */
		sk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);
		break;

	case SO_RCVBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_rcvbuf;
 
 	case SO_KEEPALIVE:
 #ifdef CONFIG_INET
		if (sk->sk_protocol == IPPROTO_TCP)
 			tcp_set_keepalive(sk, valbool);
 #endif
 		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);
		break;

	case SO_OOBINLINE:
		sock_valbool_flag(sk, SOCK_URGINLINE, valbool);
		break;

	case SO_NO_CHECK:
		sk->sk_no_check = valbool;
		break;

	case SO_PRIORITY:
		if ((val >= 0 && val <= 6) || capable(CAP_NET_ADMIN))
			sk->sk_priority = val;
		else
			ret = -EPERM;
		break;

	case SO_LINGER:
		if (optlen < sizeof(ling)) {
			ret = -EINVAL;	/* 1003.1g */
			break;
		}
		if (copy_from_user(&ling, optval, sizeof(ling))) {
			ret = -EFAULT;
			break;
		}
		if (!ling.l_onoff)
			sock_reset_flag(sk, SOCK_LINGER);
		else {
#if (BITS_PER_LONG == 32)
			if ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)
				sk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;
			else
#endif
				sk->sk_lingertime = (unsigned int)ling.l_linger * HZ;
			sock_set_flag(sk, SOCK_LINGER);
		}
		break;

	case SO_BSDCOMPAT:
		sock_warn_obsolete_bsdism(""setsockopt"");
		break;

	case SO_PASSCRED:
		if (valbool)
			set_bit(SOCK_PASSCRED, &sock->flags);
		else
			clear_bit(SOCK_PASSCRED, &sock->flags);
		break;

	case SO_TIMESTAMP:
	case SO_TIMESTAMPNS:
		if (valbool)  {
			if (optname == SO_TIMESTAMP)
				sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
			else
				sock_set_flag(sk, SOCK_RCVTSTAMPNS);
			sock_set_flag(sk, SOCK_RCVTSTAMP);
			sock_enable_timestamp(sk, SOCK_TIMESTAMP);
		} else {
			sock_reset_flag(sk, SOCK_RCVTSTAMP);
			sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
		}
		break;

	case SO_TIMESTAMPING:
		if (val & ~SOF_TIMESTAMPING_MASK) {
			ret = -EINVAL;
			break;
		}
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE,
				  val & SOF_TIMESTAMPING_TX_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE,
				  val & SOF_TIMESTAMPING_TX_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE,
				  val & SOF_TIMESTAMPING_RX_HARDWARE);
		if (val & SOF_TIMESTAMPING_RX_SOFTWARE)
			sock_enable_timestamp(sk,
					      SOCK_TIMESTAMPING_RX_SOFTWARE);
		else
			sock_disable_timestamp(sk,
					       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SOFTWARE,
				  val & SOF_TIMESTAMPING_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE,
				  val & SOF_TIMESTAMPING_SYS_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE,
				  val & SOF_TIMESTAMPING_RAW_HARDWARE);
		break;

	case SO_RCVLOWAT:
		if (val < 0)
			val = INT_MAX;
		sk->sk_rcvlowat = val ? : 1;
		break;

	case SO_RCVTIMEO:
		ret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);
		break;

	case SO_SNDTIMEO:
		ret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);
		break;

	case SO_ATTACH_FILTER:
		ret = -EINVAL;
		if (optlen == sizeof(struct sock_fprog)) {
			struct sock_fprog fprog;

			ret = -EFAULT;
			if (copy_from_user(&fprog, optval, sizeof(fprog)))
				break;

			ret = sk_attach_filter(&fprog, sk);
		}
		break;

	case SO_DETACH_FILTER:
		ret = sk_detach_filter(sk);
		break;

	case SO_PASSSEC:
		if (valbool)
			set_bit(SOCK_PASSSEC, &sock->flags);
		else
			clear_bit(SOCK_PASSSEC, &sock->flags);
		break;
	case SO_MARK:
		if (!capable(CAP_NET_ADMIN))
			ret = -EPERM;
		else
			sk->sk_mark = val;
		break;

		/* We implement the SO_SNDLOWAT etc to
		   not be settable (1003.1g 5.3) */
	case SO_RXQ_OVFL:
		sock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);
		break;

	case SO_WIFI_STATUS:
		sock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);
		break;

	case SO_PEEK_OFF:
		if (sock->ops->set_peek_off)
			sock->ops->set_peek_off(sk, val);
		else
			ret = -EOPNOTSUPP;
		break;

	case SO_NOFCS:
		sock_valbool_flag(sk, SOCK_NOFCS, valbool);
		break;

	default:
		ret = -ENOPROTOOPT;
		break;
	}
	release_sock(sk);
	return ret;
}
","int sock_setsockopt(struct socket *sock, int level, int optname,
		    char __user *optval, unsigned int optlen)
{
	struct sock *sk = sock->sk;
	int val;
	int valbool;
	struct linger ling;
	int ret = 0;

	/*
	 *	Options without arguments
	 */

	if (optname == SO_BINDTODEVICE)
		return sock_bindtodevice(sk, optval, optlen);

	if (optlen < sizeof(int))
		return -EINVAL;

	if (get_user(val, (int __user *)optval))
		return -EFAULT;

	valbool = val ? 1 : 0;

	lock_sock(sk);

	switch (optname) {
	case SO_DEBUG:
		if (val && !capable(CAP_NET_ADMIN))
			ret = -EACCES;
		else
			sock_valbool_flag(sk, SOCK_DBG, valbool);
		break;
	case SO_REUSEADDR:
		sk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);
		break;
	case SO_TYPE:
	case SO_PROTOCOL:
	case SO_DOMAIN:
	case SO_ERROR:
		ret = -ENOPROTOOPT;
		break;
	case SO_DONTROUTE:
		sock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);
		break;
	case SO_BROADCAST:
		sock_valbool_flag(sk, SOCK_BROADCAST, valbool);
		break;
	case SO_SNDBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_wmem_max);
set_sndbuf:
		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
		sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
		/* Wake up sending tasks if we upped the value. */
		sk->sk_write_space(sk);
		break;

	case SO_SNDBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_sndbuf;

	case SO_RCVBUF:
		/* Don't error on this BSD doesn't and if you think
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_rmem_max);
set_rcvbuf:
		sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
		/*
		 * We double it on the way in to account for
		 * ""struct sk_buff"" etc. overhead.   Applications
		 * assume that the SO_RCVBUF setting they make will
		 * allow that much actual data to be received on that
		 * socket.
		 *
		 * Applications are unaware that ""struct sk_buff"" and
		 * other overheads allocate from the receive buffer
		 * during socket buffer allocation.
		 *
		 * And after considering the possible alternatives,
		 * returning the value we actually used in getsockopt
		 * is the most desirable behavior.
		 */
		sk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);
		break;

	case SO_RCVBUFFORCE:
		if (!capable(CAP_NET_ADMIN)) {
			ret = -EPERM;
			break;
		}
		goto set_rcvbuf;
 
 	case SO_KEEPALIVE:
 #ifdef CONFIG_INET
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
 			tcp_set_keepalive(sk, valbool);
 #endif
 		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);
		break;

	case SO_OOBINLINE:
		sock_valbool_flag(sk, SOCK_URGINLINE, valbool);
		break;

	case SO_NO_CHECK:
		sk->sk_no_check = valbool;
		break;

	case SO_PRIORITY:
		if ((val >= 0 && val <= 6) || capable(CAP_NET_ADMIN))
			sk->sk_priority = val;
		else
			ret = -EPERM;
		break;

	case SO_LINGER:
		if (optlen < sizeof(ling)) {
			ret = -EINVAL;	/* 1003.1g */
			break;
		}
		if (copy_from_user(&ling, optval, sizeof(ling))) {
			ret = -EFAULT;
			break;
		}
		if (!ling.l_onoff)
			sock_reset_flag(sk, SOCK_LINGER);
		else {
#if (BITS_PER_LONG == 32)
			if ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)
				sk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;
			else
#endif
				sk->sk_lingertime = (unsigned int)ling.l_linger * HZ;
			sock_set_flag(sk, SOCK_LINGER);
		}
		break;

	case SO_BSDCOMPAT:
		sock_warn_obsolete_bsdism(""setsockopt"");
		break;

	case SO_PASSCRED:
		if (valbool)
			set_bit(SOCK_PASSCRED, &sock->flags);
		else
			clear_bit(SOCK_PASSCRED, &sock->flags);
		break;

	case SO_TIMESTAMP:
	case SO_TIMESTAMPNS:
		if (valbool)  {
			if (optname == SO_TIMESTAMP)
				sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
			else
				sock_set_flag(sk, SOCK_RCVTSTAMPNS);
			sock_set_flag(sk, SOCK_RCVTSTAMP);
			sock_enable_timestamp(sk, SOCK_TIMESTAMP);
		} else {
			sock_reset_flag(sk, SOCK_RCVTSTAMP);
			sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
		}
		break;

	case SO_TIMESTAMPING:
		if (val & ~SOF_TIMESTAMPING_MASK) {
			ret = -EINVAL;
			break;
		}
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE,
				  val & SOF_TIMESTAMPING_TX_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE,
				  val & SOF_TIMESTAMPING_TX_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE,
				  val & SOF_TIMESTAMPING_RX_HARDWARE);
		if (val & SOF_TIMESTAMPING_RX_SOFTWARE)
			sock_enable_timestamp(sk,
					      SOCK_TIMESTAMPING_RX_SOFTWARE);
		else
			sock_disable_timestamp(sk,
					       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SOFTWARE,
				  val & SOF_TIMESTAMPING_SOFTWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE,
				  val & SOF_TIMESTAMPING_SYS_HARDWARE);
		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE,
				  val & SOF_TIMESTAMPING_RAW_HARDWARE);
		break;

	case SO_RCVLOWAT:
		if (val < 0)
			val = INT_MAX;
		sk->sk_rcvlowat = val ? : 1;
		break;

	case SO_RCVTIMEO:
		ret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);
		break;

	case SO_SNDTIMEO:
		ret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);
		break;

	case SO_ATTACH_FILTER:
		ret = -EINVAL;
		if (optlen == sizeof(struct sock_fprog)) {
			struct sock_fprog fprog;

			ret = -EFAULT;
			if (copy_from_user(&fprog, optval, sizeof(fprog)))
				break;

			ret = sk_attach_filter(&fprog, sk);
		}
		break;

	case SO_DETACH_FILTER:
		ret = sk_detach_filter(sk);
		break;

	case SO_PASSSEC:
		if (valbool)
			set_bit(SOCK_PASSSEC, &sock->flags);
		else
			clear_bit(SOCK_PASSSEC, &sock->flags);
		break;
	case SO_MARK:
		if (!capable(CAP_NET_ADMIN))
			ret = -EPERM;
		else
			sk->sk_mark = val;
		break;

		/* We implement the SO_SNDLOWAT etc to
		   not be settable (1003.1g 5.3) */
	case SO_RXQ_OVFL:
		sock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);
		break;

	case SO_WIFI_STATUS:
		sock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);
		break;

	case SO_PEEK_OFF:
		if (sock->ops->set_peek_off)
			sock->ops->set_peek_off(sk, val);
		else
			ret = -EOPNOTSUPP;
		break;

	case SO_NOFCS:
		sock_valbool_flag(sk, SOCK_NOFCS, valbool);
		break;

	default:
		ret = -ENOPROTOOPT;
		break;
	}
	release_sock(sk);
	return ret;
}
","The `sock_setsockopt` function is responsible for configuring socket options in a network programming context. It takes a socket structure, an option level, an option name, a user-provided value, and the length of that value. The function processes various socket options, such as enabling or disabling debugging, setting buffer sizes, configuring keep-alive settings, and managing timestamps. It performs checks for user permissions and validates input lengths, ensuring that the socket's state is appropriately modified based on the specified options. The function returns an error code if an invalid option is provided or if permission is denied, otherwise it updates the socket's settings accordingly.","The provided code defines a function that configures various options for a network socket based on user input. It handles a range of settings, including enabling or disabling features like debugging, address reuse, and keep-alive mechanisms, as well as adjusting buffer sizes and timeouts. The function performs validation checks on the input values and permissions, ensuring that only authorized modifications are allowed. It updates the socket's internal state accordingly and returns appropriate error codes for invalid inputs or permission issues, facilitating robust socket management in network applications.","The vulnerability in the original code arises from the potential for a crash when using raw sockets, which could invoke the `tcp_set_keepalive()` function without ensuring that the socket is of type `SOCK_STREAM`. This oversight allows inappropriate socket types to access functions that are only meant for TCP connections, leading to undefined behavior. The fix implemented in the modified code adds a conditional check to verify that the socket's protocol is TCP and its type is `SOCK_STREAM` before calling `tcp_set_keepalive()`. This ensures that only valid socket types can trigger the keep-alive functionality, thereby preventing crashes and enhancing stability.","The vulnerability in the original code stems from the lack of validation for socket types, allowing raw sockets to invoke functions intended solely for TCP sockets. This oversight could lead to crashes when raw sockets attempt to access keep-alive functionality, which is not applicable to them. The fix implemented in the updated code introduces a check to ensure that only sockets of the correct type are permitted to call the keep-alive functions. This safeguard prevents inappropriate socket types from causing crashes, thereby enhancing the stability and reliability of the network stack.","The vulnerability was fixed by adding a conditional check to ensure that the socket's protocol is TCP and its type is `SOCK_STREAM` before invoking the `tcp_set_keepalive()` function. This check prevents raw sockets from accessing TCP-specific functionality, which could lead to crashes when calling `tcp_set_keepalive()` or `sk_reset_timer()`. By enforcing this restriction, the code now guarantees that only appropriate socket types can utilize the keep-alive feature, thereby eliminating the risk of undefined behavior and enhancing the overall stability of the network operations.","The vulnerability was addressed by implementing a validation check to ensure that only sockets designated for TCP connections can access specific functions related to keep-alive settings. This modification prevents inappropriate socket types, such as raw sockets, from invoking functionality that is not applicable to them, thereby eliminating the risk of crashes. By restricting access to these functions based on the socket type, the code enhances stability and ensures that only valid socket operations are performed, ultimately improving the reliability of the network stack.","CWE-665, CWE-573, CWE-923, CWE-682, CWE-754, CWE-909, CWE-252, CWE-758, CWE-20, CWE-1263",N,-1
38,38,179731,179731,,Local,Not required,Complete,CVE-2015-8660,https://www.cvedetails.com/cve/CVE-2015-8660/,CWE-264,Low,Complete,Complete,,2015-12-28,7.2,"The ovl_setattr function in fs/overlayfs/inode.c in the Linux kernel through 4.3.3 attempts to merge distinct setattr operations, which allows local users to bypass intended access restrictions and modify the attributes of arbitrary overlay files via a crafted application.",2017-09-09,Bypass ,4,https://github.com/torvalds/linux/commit/acff81ec2c79492b180fade3c2894425cd35a545,acff81ec2c79492b180fade3c2894425cd35a545,"ovl: fix permission checking for setattr

[Al Viro] The bug is in being too enthusiastic about optimizing ->setattr()
away - instead of ""copy verbatim with metadata"" + ""chmod/chown/utimes""
(with the former being always safe and the latter failing in case of
insufficient permissions) it tries to combine these two.  Note that copyup
itself will have to do ->setattr() anyway; _that_ is where the elevated
capabilities are right.  Having these two ->setattr() (one to set verbatim
copy of metadata, another to do what overlayfs ->setattr() had been asked
to do in the first place) combined is where it breaks.

Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
Cc: <stable@vger.kernel.org>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",4,fs/overlayfs/inode.c,"{""sha"": ""961284936917e69742f837463999c27e90defb43"", ""filename"": ""fs/overlayfs/inode.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/acff81ec2c79492b180fade3c2894425cd35a545/fs/overlayfs/inode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/acff81ec2c79492b180fade3c2894425cd35a545/fs/overlayfs/inode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/overlayfs/inode.c?ref=acff81ec2c79492b180fade3c2894425cd35a545"", ""patch"": ""@@ -49,13 +49,13 @@ int ovl_setattr(struct dentry *dentry, struct iattr *attr)\n \tif (err)\n \t\tgoto out;\n \n-\tupperdentry = ovl_dentry_upper(dentry);\n-\tif (upperdentry) {\n+\terr = ovl_copy_up(dentry);\n+\tif (!err) {\n+\t\tupperdentry = ovl_dentry_upper(dentry);\n+\n \t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n \t\terr = notify_change(upperdentry, attr, NULL);\n \t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n-\t} else {\n-\t\terr = ovl_copy_up_last(dentry, attr, false);\n \t}\n \tovl_drop_write(dentry);\n out:""}","int ovl_setattr(struct dentry *dentry, struct iattr *attr)
{
	int err;
	struct dentry *upperdentry;

	err = ovl_want_write(dentry);
 	if (err)
 		goto out;
 
	err = ovl_copy_up(dentry);
	if (!err) {
		upperdentry = ovl_dentry_upper(dentry);

 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
 	}
 	ovl_drop_write(dentry);
 out:
	return err;
}
","int ovl_setattr(struct dentry *dentry, struct iattr *attr)
{
	int err;
	struct dentry *upperdentry;

	err = ovl_want_write(dentry);
 	if (err)
 		goto out;
 
	upperdentry = ovl_dentry_upper(dentry);
	if (upperdentry) {
 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
	} else {
		err = ovl_copy_up_last(dentry, attr, false);
 	}
 	ovl_drop_write(dentry);
 out:
	return err;
}
",C,"	err = ovl_copy_up(dentry);
	if (!err) {
		upperdentry = ovl_dentry_upper(dentry);

","	upperdentry = ovl_dentry_upper(dentry);
	if (upperdentry) {
	} else {
		err = ovl_copy_up_last(dentry, attr, false);
",,"@@ -49,13 +49,13 @@ int ovl_setattr(struct dentry *dentry, struct iattr *attr)
 	if (err)
 		goto out;
 
-	upperdentry = ovl_dentry_upper(dentry);
-	if (upperdentry) {
+	err = ovl_copy_up(dentry);
+	if (!err) {
+		upperdentry = ovl_dentry_upper(dentry);
+
 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
-	} else {
-		err = ovl_copy_up_last(dentry, attr, false);
 	}
 	ovl_drop_write(dentry);
 out:",linux,acff81ec2c79492b180fade3c2894425cd35a545,31ade3b83e1821da5fbb2f11b5b3d4ab2ec39db8,1,"int ovl_setattr(struct dentry *dentry, struct iattr *attr)
{
	int err;
	struct dentry *upperdentry;

	err = ovl_want_write(dentry);
 	if (err)
 		goto out;
 
//flaw_line_below:
	upperdentry = ovl_dentry_upper(dentry);
//flaw_line_below:
	if (upperdentry) {
//fix_flaw_line_below:
//	err = ovl_copy_up(dentry);
//fix_flaw_line_below:
//	if (!err) {
//fix_flaw_line_below:
//		upperdentry = ovl_dentry_upper(dentry);
//fix_flaw_line_below:
//
 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
//flaw_line_below:
	} else {
//flaw_line_below:
		err = ovl_copy_up_last(dentry, attr, false);
 	}
 	ovl_drop_write(dentry);
 out:
	return err;
}
",179731,"int ovl_setattr(struct dentry *dentry, struct iattr *attr)
{
	int err;
	struct dentry *upperdentry;

	err = ovl_want_write(dentry);
 	if (err)
 		goto out;
 
	upperdentry = ovl_dentry_upper(dentry);
	if (upperdentry) {
 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
	} else {
		err = ovl_copy_up_last(dentry, attr, false);
 	}
 	ovl_drop_write(dentry);
 out:
	return err;
}
","int ovl_setattr(struct dentry *dentry, struct iattr *attr)
{
	int err;
	struct dentry *upperdentry;

	err = ovl_want_write(dentry);
 	if (err)
 		goto out;
 
	err = ovl_copy_up(dentry);
	if (!err) {
		upperdentry = ovl_dentry_upper(dentry);

 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
 	}
 	ovl_drop_write(dentry);
 out:
	return err;
}
","The `ovl_setattr` function is designed to update the attributes of a specified directory entry (`dentry`) in an overlay filesystem. It first attempts to acquire a write lock on the `dentry`. If successful, it checks for an associated upper `dentry` and, if found, locks its inode to apply the attribute changes using `notify_change`. If no upper `dentry` exists, it calls `ovl_copy_up_last` to copy the attributes to the upper layer. Finally, it releases the write lock and returns any error encountered during the process, ensuring proper synchronization and attribute management in the overlay filesystem.","The provided code defines a function that updates the attributes of a directory entry within an overlay filesystem. It begins by attempting to acquire a write lock on the specified entry. If successful, it checks for an associated upper layer entry; if found, it locks the corresponding inode to apply the attribute changes. If no upper layer entry exists, it performs a copy operation to update the attributes. After processing, the function releases the write lock and returns any errors encountered during the attribute update, ensuring proper synchronization and management of filesystem attributes.","The vulnerability in the original code stemmed from an improper handling of permission checks during the attribute update process. Specifically, the code attempted to combine the operations of copying metadata and changing attributes, which could lead to unauthorized changes if the user lacked sufficient permissions. In the fixed code, the vulnerability was addressed by separating these operations: first, it performs a copy-up operation to ensure the correct metadata is in place, and only then does it lock the upper entry's inode to apply the requested attribute changes, ensuring that permission checks are correctly enforced during the attribute update.","The vulnerability in the original code arose from an overly aggressive optimization that combined two distinct operations: copying metadata and changing file attributes. This approach risked allowing unauthorized changes if the user did not have the necessary permissions, as it did not properly enforce permission checks during the attribute update. The fix involved separating these operations; first, the code ensures that the correct metadata is copied, and only afterward does it apply the requested attribute changes. This adjustment guarantees that permission checks are appropriately enforced, preventing unauthorized modifications while maintaining the intended functionality.","The vulnerability was fixed by restructuring the sequence of operations in the code. Initially, the code now calls `ovl_copy_up` to ensure that the correct metadata is copied to the upper layer before any attribute changes are attempted. This separation allows for proper permission checks to be enforced. After confirming that the copy-up operation is successful, the code retrieves the upper entry and locks its inode to safely apply the attribute changes using `notify_change`. This approach ensures that the necessary permissions are validated during the attribute update process, preventing unauthorized modifications.","The vulnerability was fixed by separating the operations of copying metadata and updating attributes to ensure proper permission checks. The revised approach first ensures that the correct metadata is copied to the upper layer before any attribute modifications are attempted. Once this step is successfully completed, the code then locks the relevant inode to apply the requested attribute changes. This restructuring guarantees that permission validations occur at the appropriate stage, preventing unauthorized modifications and ensuring that the system adheres to the necessary security protocols during the attribute update process.","CWE-269, CWE-732, CWE-281, CWE-264, CWE-275, CWE-279, CWE-284, CWE-668, CWE-266, CWE-280",N,-1
39,39,179756,179756,,Local,Not required,Complete,CVE-2015-6564,https://www.cvedetails.com/cve/CVE-2015-6564/,CWE-264,Medium,Complete,Complete,,2015-08-23,6.9,Use-after-free vulnerability in the mm_answer_pam_free_ctx function in monitor.c in sshd in OpenSSH before 7.0 on non-OpenBSD platforms might allow local users to gain privileges by leveraging control of the sshd uid to send an unexpectedly early MONITOR_REQ_PAM_FREE_CTX request.,2018-09-11,+Priv ,3,https://github.com/openssh/openssh-portable/commit/5e75f5198769056089fb06c4d738ab0e5abc66f7,5e75f5198769056089fb06c4d738ab0e5abc66f7,"set sshpam_ctxt to NULL after free

Avoids use-after-free in monitor when privsep child is compromised.
Reported by Moritz Jodeit; ok dtucker@",1,monitor.c,"{""sha"": ""a91420983ba86eda2619e629265897b3fefed53a"", ""filename"": ""monitor.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/openssh/openssh-portable/blob/5e75f5198769056089fb06c4d738ab0e5abc66f7/monitor.c"", ""raw_url"": ""https://github.com/openssh/openssh-portable/raw/5e75f5198769056089fb06c4d738ab0e5abc66f7/monitor.c"", ""contents_url"": ""https://api.github.com/repos/openssh/openssh-portable/contents/monitor.c?ref=5e75f5198769056089fb06c4d738ab0e5abc66f7"", ""patch"": ""@@ -1166,14 +1166,16 @@ mm_answer_pam_respond(int sock, Buffer *m)\n int\n mm_answer_pam_free_ctx(int sock, Buffer *m)\n {\n+\tint r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;\n \n \tdebug3(\""%s\"", __func__);\n \t(sshpam_device.free_ctx)(sshpam_ctxt);\n+\tsshpam_ctxt = sshpam_authok = NULL;\n \tbuffer_clear(m);\n \tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n \tauth_method = \""keyboard-interactive\"";\n \tauth_submethod = \""pam\"";\n-\treturn (sshpam_authok == sshpam_ctxt);\n+\treturn r;\n }\n #endif\n ""}"," mm_answer_pam_free_ctx(int sock, Buffer *m)
 {
	int r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;
 
 	debug3(""%s"", __func__);
 	(sshpam_device.free_ctx)(sshpam_ctxt);
	sshpam_ctxt = sshpam_authok = NULL;
 	buffer_clear(m);
 	mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);
 	auth_method = ""keyboard-interactive"";
 	auth_submethod = ""pam"";
	return r;
 }
"," mm_answer_pam_free_ctx(int sock, Buffer *m)
 {
 
 	debug3(""%s"", __func__);
 	(sshpam_device.free_ctx)(sshpam_ctxt);
 	buffer_clear(m);
 	mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);
 	auth_method = ""keyboard-interactive"";
 	auth_submethod = ""pam"";
	return (sshpam_authok == sshpam_ctxt);
 }
",C,"	int r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;
	sshpam_ctxt = sshpam_authok = NULL;
	return r;
","	return (sshpam_authok == sshpam_ctxt);
",,"@@ -1166,14 +1166,16 @@ mm_answer_pam_respond(int sock, Buffer *m)
 int
 mm_answer_pam_free_ctx(int sock, Buffer *m)
 {
+	int r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;
 
 	debug3(""%s"", __func__);
 	(sshpam_device.free_ctx)(sshpam_ctxt);
+	sshpam_ctxt = sshpam_authok = NULL;
 	buffer_clear(m);
 	mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);
 	auth_method = ""keyboard-interactive"";
 	auth_submethod = ""pam"";
-	return (sshpam_authok == sshpam_ctxt);
+	return r;
 }
 #endif
 ",openssh-portable,5e75f5198769056089fb06c4d738ab0e5abc66f7,d4697fe9a28dab7255c60433e4dd23cf7fce8a8b,1," mm_answer_pam_free_ctx(int sock, Buffer *m)
 {
//fix_flaw_line_below:
//	int r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;
 
 	debug3(""%s"", __func__);
 	(sshpam_device.free_ctx)(sshpam_ctxt);
//fix_flaw_line_below:
//	sshpam_ctxt = sshpam_authok = NULL;
 	buffer_clear(m);
 	mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);
 	auth_method = ""keyboard-interactive"";
 	auth_submethod = ""pam"";
//flaw_line_below:
	return (sshpam_authok == sshpam_ctxt);
//fix_flaw_line_below:
//	return r;
 }
",179756," mm_answer_pam_free_ctx(int sock, Buffer *m)
 {
 
 	debug3(""%s"", __func__);
 	(sshpam_device.free_ctx)(sshpam_ctxt);
 	buffer_clear(m);
 	mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);
 	auth_method = ""keyboard-interactive"";
 	auth_submethod = ""pam"";
	return (sshpam_authok == sshpam_ctxt);
 }
"," mm_answer_pam_free_ctx(int sock, Buffer *m)
 {
	int r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;
 
 	debug3(""%s"", __func__);
 	(sshpam_device.free_ctx)(sshpam_ctxt);
	sshpam_ctxt = sshpam_authok = NULL;
 	buffer_clear(m);
 	mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);
 	auth_method = ""keyboard-interactive"";
 	auth_submethod = ""pam"";
	return r;
 }
","The function `mm_answer_pam_free_ctx` is designed to handle the freeing of a PAM (Pluggable Authentication Module) context in response to a request. It takes a socket descriptor and a buffer as parameters, logs the function call for debugging, and invokes the `free_ctx` method on the `sshpam_device` to release the PAM context. After clearing the buffer, it sends a response back through the specified socket with a predefined request type, indicating the completion of the context freeing process. Finally, it checks if the authentication was successful by comparing the PAM context with a predefined value and returns the result.","The code defines a function that manages the release of a security context associated with a user authentication process. It begins by logging the execution of the function for debugging purposes. The function then invokes a method to free the allocated resources of the authentication context. After clearing a buffer used for communication, it sends a response back through a specified connection to indicate that the context has been successfully freed. Finally, it checks whether the authentication was successful and returns a boolean value based on this verification, indicating the outcome of the authentication process.","The vulnerability in the original code stemmed from a potential use-after-free condition, where the authentication context could still be accessed after it was freed, leading to undefined behavior if the process was compromised. In the fixed code, after freeing the authentication context using `sshpam_device.free_ctx`, both `sshpam_ctxt` and `sshpam_authok` are explicitly set to NULL. This change ensures that any subsequent checks or accesses to these variables will not reference freed memory, thus preventing exploitation of the vulnerability. The return value is now based on a condition that checks the state of `sshpam_authok` against `sshpam_ctxt`, enhancing security.","The vulnerability in the original code was a use-after-free issue, where a security context could still be accessed after it had been deallocated, potentially leading to exploitation if the process was compromised. This could allow an attacker to manipulate or read sensitive data from the freed memory. The fix involved explicitly nullifying the references to the authentication context after it was freed, ensuring that any subsequent attempts to access these references would not lead to undefined behavior or access to invalid memory. This change effectively mitigated the risk of exploitation by preventing any further use of the freed context.","The vulnerability was fixed by explicitly setting both `sshpam_ctxt` and `sshpam_authok` to NULL immediately after invoking `sshpam_device.free_ctx` to free the authentication context. This change ensures that any subsequent access to these variables will not reference freed memory, thus preventing a use-after-free condition. By nullifying these references, the code eliminates the risk of accessing invalid memory, which could lead to exploitation if the process were compromised. The return value is now based on a condition that checks the state of `sshpam_authok` against `sshpam_ctxt`, further enhancing the security of the authentication process.","The vulnerability was fixed by ensuring that references to the authentication context were explicitly set to NULL immediately after it was freed. This change prevents any subsequent access to the deallocated memory, effectively mitigating the risk of a use-after-free condition. By nullifying these references, the code eliminates the possibility of accessing invalid memory, which could be exploited if the process were compromised. This approach enhances the overall security of the authentication process by ensuring that any checks or operations performed afterward do not inadvertently interact with freed resources.","CWE-416, CWE-825, CWE-415, CWE-613, CWE-672, CWE-908, CWE-457, CWE-911, CWE-476, CWE-664",N,-1
40,40,179850,179850,,Remote,Not required,,CVE-2015-2694,https://www.cvedetails.com/cve/CVE-2015-2694/,CWE-264,Medium,Partial,Partial,,2015-05-25,5.8,"The kdcpreauth modules in MIT Kerberos 5 (aka krb5) 1.12.x and 1.13.x before 1.13.2 do not properly track whether a client's request has been validated, which allows remote attackers to bypass an intended preauthentication requirement by providing (1) zero bytes of data or (2) an arbitrary realm name, related to plugins/preauth/otp/main.c and plugins/preauth/pkinit/pkinit_srv.c.",2016-12-07,Bypass ,2,https://github.com/krb5/krb5/commit/e3b5a5e5267818c97750b266df50b6a3d4649604,e3b5a5e5267818c97750b266df50b6a3d4649604,"Prevent requires_preauth bypass [CVE-2015-2694]

In the OTP kdcpreauth module, don't set the TKT_FLG_PRE_AUTH bit until
the request is successfully verified.  In the PKINIT kdcpreauth
module, don't respond with code 0 on empty input or an unconfigured
realm.  Together these bugs could cause the KDC preauth framework to
erroneously treat a request as pre-authenticated.

CVE-2015-2694:

In MIT krb5 1.12 and later, when the KDC is configured with PKINIT
support, an unauthenticated remote attacker can bypass the
requires_preauth flag on a client principal and obtain a ciphertext
encrypted in the principal's long-term key.  This ciphertext could be
used to conduct an off-line dictionary attack against the user's
password.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:P/I:P/A:N/E:POC/RL:OF/RC:C

ticket: 8160 (new)
target_version: 1.13.2
tags: pullup
subject: requires_preauth bypass in PKINIT-enabled KDC [CVE-2015-2694]",2,src/plugins/preauth/pkinit/pkinit_srv.c,"{""sha"": ""7941b4aeeef179e21a1e9727b327f312ca4e707a"", ""filename"": ""src/plugins/preauth/otp/main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 3, ""changes"": 10, ""blob_url"": ""https://github.com/krb5/krb5/blob/e3b5a5e5267818c97750b266df50b6a3d4649604/src/plugins/preauth/otp/main.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e3b5a5e5267818c97750b266df50b6a3d4649604/src/plugins/preauth/otp/main.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/plugins/preauth/otp/main.c?ref=e3b5a5e5267818c97750b266df50b6a3d4649604"", ""patch"": ""@@ -42,6 +42,7 @@ static krb5_preauthtype otp_pa_type_list[] =\n struct request_state {\n     krb5_kdcpreauth_verify_respond_fn respond;\n     void *arg;\n+    krb5_enc_tkt_part *enc_tkt_reply;\n };\n \n static krb5_error_code\n@@ -159,6 +160,9 @@ on_response(void *data, krb5_error_code retval, otp_response response)\n     if (retval == 0 && response != otp_response_success)\n         retval = KRB5_PREAUTH_FAILED;\n \n+    if (retval == 0)\n+        rs.enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n+\n     rs.respond(rs.arg, retval, NULL, NULL, NULL);\n }\n \n@@ -263,8 +267,6 @@ otp_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n     krb5_data d, plaintext;\n     char *config;\n \n-    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n-\n     /* Get the FAST armor key. */\n     armor_key = cb->fast_armor(context, rock);\n     if (armor_key == NULL) {\n@@ -298,12 +300,14 @@ otp_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n         goto error;\n     }\n \n-    /* Create the request state. */\n+    /* Create the request state.  Save the response callback, and the\n+     * enc_tkt_reply pointer so we can set the TKT_FLG_PRE_AUTH flag later. */\n     rs = k5alloc(sizeof(struct request_state), &retval);\n     if (rs == NULL)\n         goto error;\n     rs->arg = arg;\n     rs->respond = respond;\n+    rs->enc_tkt_reply = enc_tkt_reply;\n \n     /* Get the principal's OTP configuration string. */\n     retval = cb->get_string(context, rock, \""otp\"", &config);""}<_**next**_>{""sha"": ""5b1d73e4a6c4820af9e6c9bb24db67928f6d9b20"", ""filename"": ""src/plugins/preauth/pkinit/pkinit_srv.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/krb5/krb5/blob/e3b5a5e5267818c97750b266df50b6a3d4649604/src/plugins/preauth/pkinit/pkinit_srv.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e3b5a5e5267818c97750b266df50b6a3d4649604/src/plugins/preauth/pkinit/pkinit_srv.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/plugins/preauth/pkinit/pkinit_srv.c?ref=e3b5a5e5267818c97750b266df50b6a3d4649604"", ""patch"": ""@@ -301,7 +301,7 @@ pkinit_server_verify_padata(krb5_context context,\n \n     pkiDebug(\""pkinit_verify_padata: entered!\\n\"");\n     if (data == NULL || data->length <= 0 || data->contents == NULL) {\n-        (*respond)(arg, 0, NULL, NULL, NULL);\n+        (*respond)(arg, EINVAL, NULL, NULL, NULL);\n         return;\n     }\n \n@@ -313,7 +313,7 @@ pkinit_server_verify_padata(krb5_context context,\n \n     plgctx = pkinit_find_realm_context(context, moddata, request->server);\n     if (plgctx == NULL) {\n-        (*respond)(arg, 0, NULL, NULL, NULL);\n+        (*respond)(arg, EINVAL, NULL, NULL, NULL);\n         return;\n     }\n ""}","pkinit_server_verify_padata(krb5_context context,
                            krb5_data *req_pkt,
                            krb5_kdc_req * request,
                            krb5_enc_tkt_part * enc_tkt_reply,
                            krb5_pa_data * data,
                            krb5_kdcpreauth_callbacks cb,
                            krb5_kdcpreauth_rock rock,
                            krb5_kdcpreauth_moddata moddata,
                            krb5_kdcpreauth_verify_respond_fn respond,
                            void *arg)
{
    krb5_error_code retval = 0;
    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};
    krb5_pa_pk_as_req *reqp = NULL;
    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;
    krb5_auth_pack *auth_pack = NULL;
    krb5_auth_pack_draft9 *auth_pack9 = NULL;
    pkinit_kdc_context plgctx = NULL;
    pkinit_kdc_req_context reqctx = NULL;
    krb5_checksum cksum = {0, 0, 0, NULL};
    krb5_data *der_req = NULL;
    int valid_eku = 0, valid_san = 0;
    krb5_data k5data;
    int is_signed = 1;
    krb5_pa_data **e_data = NULL;
    krb5_kdcpreauth_modreq modreq = NULL;
 
     pkiDebug(""pkinit_verify_padata: entered!\n"");
     if (data == NULL || data->length <= 0 || data->contents == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 

    if (moddata == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        return;
    }
 
     plgctx = pkinit_find_realm_context(context, moddata, request->server);
     if (plgctx == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 
#ifdef DEBUG_ASN1
    print_buffer_bin(data->contents, data->length, ""/tmp/kdc_as_req"");
#endif
    /* create a per-request context */
    retval = pkinit_init_kdc_req_context(context, &reqctx);
    if (retval)
        goto cleanup;
    reqctx->pa_type = data->pa_type;

    PADATA_TO_KRB5DATA(data, &k5data);

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ\n"");
        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp->signedAuthPack.data,
                         reqp->signedAuthPack.length,
                         ""/tmp/kdc_signed_data"");
#endif
        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, &is_signed);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ_OLD\n"");
        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req_draft9 failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp9->signedAuthPack.data,
                         reqp9->signedAuthPack.length,
                         ""/tmp/kdc_signed_data_draft9"");
#endif

        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, NULL);
        break;
    default:
        pkiDebug(""unrecognized pa_type = %d\n"", data->pa_type);
        retval = EINVAL;
        goto cleanup;
    }
    if (retval) {
        pkiDebug(""pkcs7_signeddata_verify failed\n"");
        goto cleanup;
    }
    if (is_signed) {

        retval = verify_client_san(context, plgctx, reqctx, request->client,
                                   &valid_san);
        if (retval)
            goto cleanup;
        if (!valid_san) {
            pkiDebug(""%s: did not find an acceptable SAN in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
            goto cleanup;
        }
        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);
        if (retval)
            goto cleanup;

        if (!valid_eku) {
            pkiDebug(""%s: did not find an acceptable EKU in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
            goto cleanup;
        }
    } else { /* !is_signed */
        if (!krb5_principal_compare(context, request->client,
                                    krb5_anonymous_principal())) {
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Pkinit request not signed, but client ""
                                     ""not anonymous.""));
            goto cleanup;
        }
    }
#ifdef DEBUG_ASN1
    print_buffer_bin(authp_data.data, authp_data.length, ""/tmp/kdc_auth_pack"");
#endif

    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);
    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack\n"");
            goto cleanup;
        }

        retval = krb5_check_clockskew(context,
                                      auth_pack->pkAuthenticator.ctime);
        if (retval)
            goto cleanup;

        /* check dh parameters */
        if (auth_pack->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        } else if (!is_signed) {
            /*Anonymous pkinit requires DH*/
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Anonymous pkinit without DH public ""
                                     ""value not supported.""));
            goto cleanup;
        }
        der_req = cb->request_body(context, rock);
        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,
                                      0, der_req, &cksum);
        if (retval) {
            pkiDebug(""unable to calculate AS REQ checksum\n"");
            goto cleanup;
        }
        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||
            k5_bcmp(cksum.contents,
                    auth_pack->pkAuthenticator.paChecksum.contents,
                    cksum.length) != 0) {
            pkiDebug(""failed to match the checksum\n"");
#ifdef DEBUG_CKSUM
            pkiDebug(""calculating checksum on buf size (%d)\n"",
                     req_pkt->length);
            print_buffer(req_pkt->data, req_pkt->length);
            pkiDebug(""received checksum type=%d size=%d "",
                     auth_pack->pkAuthenticator.paChecksum.checksum_type,
                     auth_pack->pkAuthenticator.paChecksum.length);
            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,
                         auth_pack->pkAuthenticator.paChecksum.length);
            pkiDebug(""expected checksum type=%d size=%d "",
                     cksum.checksum_type, cksum.length);
            print_buffer(cksum.contents, cksum.length);
#endif

            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;
            goto cleanup;
        }

        /* check if kdcPkId present and match KDC's subjectIdentifier */
        if (reqp->kdcPkId.data != NULL) {
            int valid_kdcPkId = 0;
            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,
                                           reqctx->cryptoctx, plgctx->idctx,
                                           (unsigned char *)reqp->kdcPkId.data,
                                           reqp->kdcPkId.length, &valid_kdcPkId);
            if (retval)
                goto cleanup;
            if (!valid_kdcPkId)
                pkiDebug(""kdcPkId in AS_REQ does not match KDC's cert""
                         ""RFC says to ignore and proceed\n"");

        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack = auth_pack;
        auth_pack = NULL;
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack_draft9\n"");
            goto cleanup;
        }
        if (auth_pack9->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack9->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack9 = auth_pack9;
        auth_pack9 = NULL;
        break;
    }

    /* remember to set the PREAUTH flag in the reply */
    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;
    modreq = (krb5_kdcpreauth_modreq)reqctx;
    reqctx = NULL;

cleanup:
    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {
        pkiDebug(""pkinit_verify_padata failed: creating e-data\n"");
        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,
                                plgctx->idctx, plgctx->opts, retval, &e_data))
            pkiDebug(""pkinit_create_edata failed\n"");
    }

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        free_krb5_pa_pk_as_req(&reqp);
        free(cksum.contents);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        free_krb5_pa_pk_as_req_draft9(&reqp9);
    }
    free(authp_data.data);
    free(krb5_authz.data);
    if (reqctx != NULL)
        pkinit_fini_kdc_req_context(context, reqctx);
    free_krb5_auth_pack(&auth_pack);
    free_krb5_auth_pack_draft9(context, &auth_pack9);

    (*respond)(arg, retval, modreq, e_data, NULL);
}
","pkinit_server_verify_padata(krb5_context context,
                            krb5_data *req_pkt,
                            krb5_kdc_req * request,
                            krb5_enc_tkt_part * enc_tkt_reply,
                            krb5_pa_data * data,
                            krb5_kdcpreauth_callbacks cb,
                            krb5_kdcpreauth_rock rock,
                            krb5_kdcpreauth_moddata moddata,
                            krb5_kdcpreauth_verify_respond_fn respond,
                            void *arg)
{
    krb5_error_code retval = 0;
    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};
    krb5_pa_pk_as_req *reqp = NULL;
    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;
    krb5_auth_pack *auth_pack = NULL;
    krb5_auth_pack_draft9 *auth_pack9 = NULL;
    pkinit_kdc_context plgctx = NULL;
    pkinit_kdc_req_context reqctx = NULL;
    krb5_checksum cksum = {0, 0, 0, NULL};
    krb5_data *der_req = NULL;
    int valid_eku = 0, valid_san = 0;
    krb5_data k5data;
    int is_signed = 1;
    krb5_pa_data **e_data = NULL;
    krb5_kdcpreauth_modreq modreq = NULL;
 
     pkiDebug(""pkinit_verify_padata: entered!\n"");
     if (data == NULL || data->length <= 0 || data->contents == NULL) {
        (*respond)(arg, 0, NULL, NULL, NULL);
         return;
     }
 

    if (moddata == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        return;
    }
 
     plgctx = pkinit_find_realm_context(context, moddata, request->server);
     if (plgctx == NULL) {
        (*respond)(arg, 0, NULL, NULL, NULL);
         return;
     }
 
#ifdef DEBUG_ASN1
    print_buffer_bin(data->contents, data->length, ""/tmp/kdc_as_req"");
#endif
    /* create a per-request context */
    retval = pkinit_init_kdc_req_context(context, &reqctx);
    if (retval)
        goto cleanup;
    reqctx->pa_type = data->pa_type;

    PADATA_TO_KRB5DATA(data, &k5data);

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ\n"");
        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp->signedAuthPack.data,
                         reqp->signedAuthPack.length,
                         ""/tmp/kdc_signed_data"");
#endif
        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, &is_signed);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ_OLD\n"");
        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req_draft9 failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp9->signedAuthPack.data,
                         reqp9->signedAuthPack.length,
                         ""/tmp/kdc_signed_data_draft9"");
#endif

        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, NULL);
        break;
    default:
        pkiDebug(""unrecognized pa_type = %d\n"", data->pa_type);
        retval = EINVAL;
        goto cleanup;
    }
    if (retval) {
        pkiDebug(""pkcs7_signeddata_verify failed\n"");
        goto cleanup;
    }
    if (is_signed) {

        retval = verify_client_san(context, plgctx, reqctx, request->client,
                                   &valid_san);
        if (retval)
            goto cleanup;
        if (!valid_san) {
            pkiDebug(""%s: did not find an acceptable SAN in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
            goto cleanup;
        }
        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);
        if (retval)
            goto cleanup;

        if (!valid_eku) {
            pkiDebug(""%s: did not find an acceptable EKU in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
            goto cleanup;
        }
    } else { /* !is_signed */
        if (!krb5_principal_compare(context, request->client,
                                    krb5_anonymous_principal())) {
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Pkinit request not signed, but client ""
                                     ""not anonymous.""));
            goto cleanup;
        }
    }
#ifdef DEBUG_ASN1
    print_buffer_bin(authp_data.data, authp_data.length, ""/tmp/kdc_auth_pack"");
#endif

    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);
    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack\n"");
            goto cleanup;
        }

        retval = krb5_check_clockskew(context,
                                      auth_pack->pkAuthenticator.ctime);
        if (retval)
            goto cleanup;

        /* check dh parameters */
        if (auth_pack->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        } else if (!is_signed) {
            /*Anonymous pkinit requires DH*/
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Anonymous pkinit without DH public ""
                                     ""value not supported.""));
            goto cleanup;
        }
        der_req = cb->request_body(context, rock);
        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,
                                      0, der_req, &cksum);
        if (retval) {
            pkiDebug(""unable to calculate AS REQ checksum\n"");
            goto cleanup;
        }
        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||
            k5_bcmp(cksum.contents,
                    auth_pack->pkAuthenticator.paChecksum.contents,
                    cksum.length) != 0) {
            pkiDebug(""failed to match the checksum\n"");
#ifdef DEBUG_CKSUM
            pkiDebug(""calculating checksum on buf size (%d)\n"",
                     req_pkt->length);
            print_buffer(req_pkt->data, req_pkt->length);
            pkiDebug(""received checksum type=%d size=%d "",
                     auth_pack->pkAuthenticator.paChecksum.checksum_type,
                     auth_pack->pkAuthenticator.paChecksum.length);
            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,
                         auth_pack->pkAuthenticator.paChecksum.length);
            pkiDebug(""expected checksum type=%d size=%d "",
                     cksum.checksum_type, cksum.length);
            print_buffer(cksum.contents, cksum.length);
#endif

            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;
            goto cleanup;
        }

        /* check if kdcPkId present and match KDC's subjectIdentifier */
        if (reqp->kdcPkId.data != NULL) {
            int valid_kdcPkId = 0;
            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,
                                           reqctx->cryptoctx, plgctx->idctx,
                                           (unsigned char *)reqp->kdcPkId.data,
                                           reqp->kdcPkId.length, &valid_kdcPkId);
            if (retval)
                goto cleanup;
            if (!valid_kdcPkId)
                pkiDebug(""kdcPkId in AS_REQ does not match KDC's cert""
                         ""RFC says to ignore and proceed\n"");

        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack = auth_pack;
        auth_pack = NULL;
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack_draft9\n"");
            goto cleanup;
        }
        if (auth_pack9->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack9->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack9 = auth_pack9;
        auth_pack9 = NULL;
        break;
    }

    /* remember to set the PREAUTH flag in the reply */
    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;
    modreq = (krb5_kdcpreauth_modreq)reqctx;
    reqctx = NULL;

cleanup:
    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {
        pkiDebug(""pkinit_verify_padata failed: creating e-data\n"");
        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,
                                plgctx->idctx, plgctx->opts, retval, &e_data))
            pkiDebug(""pkinit_create_edata failed\n"");
    }

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        free_krb5_pa_pk_as_req(&reqp);
        free(cksum.contents);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        free_krb5_pa_pk_as_req_draft9(&reqp9);
    }
    free(authp_data.data);
    free(krb5_authz.data);
    if (reqctx != NULL)
        pkinit_fini_kdc_req_context(context, reqctx);
    free_krb5_auth_pack(&auth_pack);
    free_krb5_auth_pack_draft9(context, &auth_pack9);

    (*respond)(arg, retval, modreq, e_data, NULL);
}
",C,"        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
","        (*respond)(arg, 0, NULL, NULL, NULL);
        (*respond)(arg, 0, NULL, NULL, NULL);
",,"@@ -301,7 +301,7 @@ pkinit_server_verify_padata(krb5_context context,
 
     pkiDebug(""pkinit_verify_padata: entered!\n"");
     if (data == NULL || data->length <= 0 || data->contents == NULL) {
-        (*respond)(arg, 0, NULL, NULL, NULL);
+        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 
@@ -313,7 +313,7 @@ pkinit_server_verify_padata(krb5_context context,
 
     plgctx = pkinit_find_realm_context(context, moddata, request->server);
     if (plgctx == NULL) {
-        (*respond)(arg, 0, NULL, NULL, NULL);
+        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 ",krb5,e3b5a5e5267818c97750b266df50b6a3d4649604,527edfaadb648a0dd2a42cd39a5a02a4ac37d7e3,1,"pkinit_server_verify_padata(krb5_context context,
                            krb5_data *req_pkt,
                            krb5_kdc_req * request,
                            krb5_enc_tkt_part * enc_tkt_reply,
                            krb5_pa_data * data,
                            krb5_kdcpreauth_callbacks cb,
                            krb5_kdcpreauth_rock rock,
                            krb5_kdcpreauth_moddata moddata,
                            krb5_kdcpreauth_verify_respond_fn respond,
                            void *arg)
{
    krb5_error_code retval = 0;
    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};
    krb5_pa_pk_as_req *reqp = NULL;
    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;
    krb5_auth_pack *auth_pack = NULL;
    krb5_auth_pack_draft9 *auth_pack9 = NULL;
    pkinit_kdc_context plgctx = NULL;
    pkinit_kdc_req_context reqctx = NULL;
    krb5_checksum cksum = {0, 0, 0, NULL};
    krb5_data *der_req = NULL;
    int valid_eku = 0, valid_san = 0;
    krb5_data k5data;
    int is_signed = 1;
    krb5_pa_data **e_data = NULL;
    krb5_kdcpreauth_modreq modreq = NULL;
 
     pkiDebug(""pkinit_verify_padata: entered!\n"");
     if (data == NULL || data->length <= 0 || data->contents == NULL) {
//flaw_line_below:
        (*respond)(arg, 0, NULL, NULL, NULL);
//fix_flaw_line_below:
//        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 

    if (moddata == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        return;
    }
 
     plgctx = pkinit_find_realm_context(context, moddata, request->server);
     if (plgctx == NULL) {
//flaw_line_below:
        (*respond)(arg, 0, NULL, NULL, NULL);
//fix_flaw_line_below:
//        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 
#ifdef DEBUG_ASN1
    print_buffer_bin(data->contents, data->length, ""/tmp/kdc_as_req"");
#endif
    /* create a per-request context */
    retval = pkinit_init_kdc_req_context(context, &reqctx);
    if (retval)
        goto cleanup;
    reqctx->pa_type = data->pa_type;

    PADATA_TO_KRB5DATA(data, &k5data);

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ\n"");
        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp->signedAuthPack.data,
                         reqp->signedAuthPack.length,
                         ""/tmp/kdc_signed_data"");
#endif
        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, &is_signed);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ_OLD\n"");
        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req_draft9 failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp9->signedAuthPack.data,
                         reqp9->signedAuthPack.length,
                         ""/tmp/kdc_signed_data_draft9"");
#endif

        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, NULL);
        break;
    default:
        pkiDebug(""unrecognized pa_type = %d\n"", data->pa_type);
        retval = EINVAL;
        goto cleanup;
    }
    if (retval) {
        pkiDebug(""pkcs7_signeddata_verify failed\n"");
        goto cleanup;
    }
    if (is_signed) {

        retval = verify_client_san(context, plgctx, reqctx, request->client,
                                   &valid_san);
        if (retval)
            goto cleanup;
        if (!valid_san) {
            pkiDebug(""%s: did not find an acceptable SAN in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
            goto cleanup;
        }
        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);
        if (retval)
            goto cleanup;

        if (!valid_eku) {
            pkiDebug(""%s: did not find an acceptable EKU in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
            goto cleanup;
        }
    } else { /* !is_signed */
        if (!krb5_principal_compare(context, request->client,
                                    krb5_anonymous_principal())) {
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Pkinit request not signed, but client ""
                                     ""not anonymous.""));
            goto cleanup;
        }
    }
#ifdef DEBUG_ASN1
    print_buffer_bin(authp_data.data, authp_data.length, ""/tmp/kdc_auth_pack"");
#endif

    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);
    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack\n"");
            goto cleanup;
        }

        retval = krb5_check_clockskew(context,
                                      auth_pack->pkAuthenticator.ctime);
        if (retval)
            goto cleanup;

        /* check dh parameters */
        if (auth_pack->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        } else if (!is_signed) {
            /*Anonymous pkinit requires DH*/
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Anonymous pkinit without DH public ""
                                     ""value not supported.""));
            goto cleanup;
        }
        der_req = cb->request_body(context, rock);
        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,
                                      0, der_req, &cksum);
        if (retval) {
            pkiDebug(""unable to calculate AS REQ checksum\n"");
            goto cleanup;
        }
        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||
            k5_bcmp(cksum.contents,
                    auth_pack->pkAuthenticator.paChecksum.contents,
                    cksum.length) != 0) {
            pkiDebug(""failed to match the checksum\n"");
#ifdef DEBUG_CKSUM
            pkiDebug(""calculating checksum on buf size (%d)\n"",
                     req_pkt->length);
            print_buffer(req_pkt->data, req_pkt->length);
            pkiDebug(""received checksum type=%d size=%d "",
                     auth_pack->pkAuthenticator.paChecksum.checksum_type,
                     auth_pack->pkAuthenticator.paChecksum.length);
            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,
                         auth_pack->pkAuthenticator.paChecksum.length);
            pkiDebug(""expected checksum type=%d size=%d "",
                     cksum.checksum_type, cksum.length);
            print_buffer(cksum.contents, cksum.length);
#endif

            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;
            goto cleanup;
        }

        /* check if kdcPkId present and match KDC's subjectIdentifier */
        if (reqp->kdcPkId.data != NULL) {
            int valid_kdcPkId = 0;
            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,
                                           reqctx->cryptoctx, plgctx->idctx,
                                           (unsigned char *)reqp->kdcPkId.data,
                                           reqp->kdcPkId.length, &valid_kdcPkId);
            if (retval)
                goto cleanup;
            if (!valid_kdcPkId)
                pkiDebug(""kdcPkId in AS_REQ does not match KDC's cert""
                         ""RFC says to ignore and proceed\n"");

        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack = auth_pack;
        auth_pack = NULL;
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack_draft9\n"");
            goto cleanup;
        }
        if (auth_pack9->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack9->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack9 = auth_pack9;
        auth_pack9 = NULL;
        break;
    }

    /* remember to set the PREAUTH flag in the reply */
    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;
    modreq = (krb5_kdcpreauth_modreq)reqctx;
    reqctx = NULL;

cleanup:
    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {
        pkiDebug(""pkinit_verify_padata failed: creating e-data\n"");
        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,
                                plgctx->idctx, plgctx->opts, retval, &e_data))
            pkiDebug(""pkinit_create_edata failed\n"");
    }

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        free_krb5_pa_pk_as_req(&reqp);
        free(cksum.contents);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        free_krb5_pa_pk_as_req_draft9(&reqp9);
    }
    free(authp_data.data);
    free(krb5_authz.data);
    if (reqctx != NULL)
        pkinit_fini_kdc_req_context(context, reqctx);
    free_krb5_auth_pack(&auth_pack);
    free_krb5_auth_pack_draft9(context, &auth_pack9);

    (*respond)(arg, retval, modreq, e_data, NULL);
}
",179850,"pkinit_server_verify_padata(krb5_context context,
                            krb5_data *req_pkt,
                            krb5_kdc_req * request,
                            krb5_enc_tkt_part * enc_tkt_reply,
                            krb5_pa_data * data,
                            krb5_kdcpreauth_callbacks cb,
                            krb5_kdcpreauth_rock rock,
                            krb5_kdcpreauth_moddata moddata,
                            krb5_kdcpreauth_verify_respond_fn respond,
                            void *arg)
{
    krb5_error_code retval = 0;
    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};
    krb5_pa_pk_as_req *reqp = NULL;
    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;
    krb5_auth_pack *auth_pack = NULL;
    krb5_auth_pack_draft9 *auth_pack9 = NULL;
    pkinit_kdc_context plgctx = NULL;
    pkinit_kdc_req_context reqctx = NULL;
    krb5_checksum cksum = {0, 0, 0, NULL};
    krb5_data *der_req = NULL;
    int valid_eku = 0, valid_san = 0;
    krb5_data k5data;
    int is_signed = 1;
    krb5_pa_data **e_data = NULL;
    krb5_kdcpreauth_modreq modreq = NULL;
 
     pkiDebug(""pkinit_verify_padata: entered!\n"");
     if (data == NULL || data->length <= 0 || data->contents == NULL) {
        (*respond)(arg, 0, NULL, NULL, NULL);
         return;
     }
 

    if (moddata == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        return;
    }
 
     plgctx = pkinit_find_realm_context(context, moddata, request->server);
     if (plgctx == NULL) {
        (*respond)(arg, 0, NULL, NULL, NULL);
         return;
     }
 
#ifdef DEBUG_ASN1
    print_buffer_bin(data->contents, data->length, ""/tmp/kdc_as_req"");
#endif
    /* create a per-request context */
    retval = pkinit_init_kdc_req_context(context, &reqctx);
    if (retval)
        goto cleanup;
    reqctx->pa_type = data->pa_type;

    PADATA_TO_KRB5DATA(data, &k5data);

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ\n"");
        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp->signedAuthPack.data,
                         reqp->signedAuthPack.length,
                         ""/tmp/kdc_signed_data"");
#endif
        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, &is_signed);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ_OLD\n"");
        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req_draft9 failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp9->signedAuthPack.data,
                         reqp9->signedAuthPack.length,
                         ""/tmp/kdc_signed_data_draft9"");
#endif

        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, NULL);
        break;
    default:
        pkiDebug(""unrecognized pa_type = %d\n"", data->pa_type);
        retval = EINVAL;
        goto cleanup;
    }
    if (retval) {
        pkiDebug(""pkcs7_signeddata_verify failed\n"");
        goto cleanup;
    }
    if (is_signed) {

        retval = verify_client_san(context, plgctx, reqctx, request->client,
                                   &valid_san);
        if (retval)
            goto cleanup;
        if (!valid_san) {
            pkiDebug(""%s: did not find an acceptable SAN in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
            goto cleanup;
        }
        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);
        if (retval)
            goto cleanup;

        if (!valid_eku) {
            pkiDebug(""%s: did not find an acceptable EKU in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
            goto cleanup;
        }
    } else { /* !is_signed */
        if (!krb5_principal_compare(context, request->client,
                                    krb5_anonymous_principal())) {
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Pkinit request not signed, but client ""
                                     ""not anonymous.""));
            goto cleanup;
        }
    }
#ifdef DEBUG_ASN1
    print_buffer_bin(authp_data.data, authp_data.length, ""/tmp/kdc_auth_pack"");
#endif

    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);
    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack\n"");
            goto cleanup;
        }

        retval = krb5_check_clockskew(context,
                                      auth_pack->pkAuthenticator.ctime);
        if (retval)
            goto cleanup;

        /* check dh parameters */
        if (auth_pack->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        } else if (!is_signed) {
            /*Anonymous pkinit requires DH*/
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Anonymous pkinit without DH public ""
                                     ""value not supported.""));
            goto cleanup;
        }
        der_req = cb->request_body(context, rock);
        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,
                                      0, der_req, &cksum);
        if (retval) {
            pkiDebug(""unable to calculate AS REQ checksum\n"");
            goto cleanup;
        }
        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||
            k5_bcmp(cksum.contents,
                    auth_pack->pkAuthenticator.paChecksum.contents,
                    cksum.length) != 0) {
            pkiDebug(""failed to match the checksum\n"");
#ifdef DEBUG_CKSUM
            pkiDebug(""calculating checksum on buf size (%d)\n"",
                     req_pkt->length);
            print_buffer(req_pkt->data, req_pkt->length);
            pkiDebug(""received checksum type=%d size=%d "",
                     auth_pack->pkAuthenticator.paChecksum.checksum_type,
                     auth_pack->pkAuthenticator.paChecksum.length);
            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,
                         auth_pack->pkAuthenticator.paChecksum.length);
            pkiDebug(""expected checksum type=%d size=%d "",
                     cksum.checksum_type, cksum.length);
            print_buffer(cksum.contents, cksum.length);
#endif

            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;
            goto cleanup;
        }

        /* check if kdcPkId present and match KDC's subjectIdentifier */
        if (reqp->kdcPkId.data != NULL) {
            int valid_kdcPkId = 0;
            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,
                                           reqctx->cryptoctx, plgctx->idctx,
                                           (unsigned char *)reqp->kdcPkId.data,
                                           reqp->kdcPkId.length, &valid_kdcPkId);
            if (retval)
                goto cleanup;
            if (!valid_kdcPkId)
                pkiDebug(""kdcPkId in AS_REQ does not match KDC's cert""
                         ""RFC says to ignore and proceed\n"");

        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack = auth_pack;
        auth_pack = NULL;
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack_draft9\n"");
            goto cleanup;
        }
        if (auth_pack9->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack9->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack9 = auth_pack9;
        auth_pack9 = NULL;
        break;
    }

    /* remember to set the PREAUTH flag in the reply */
    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;
    modreq = (krb5_kdcpreauth_modreq)reqctx;
    reqctx = NULL;

cleanup:
    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {
        pkiDebug(""pkinit_verify_padata failed: creating e-data\n"");
        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,
                                plgctx->idctx, plgctx->opts, retval, &e_data))
            pkiDebug(""pkinit_create_edata failed\n"");
    }

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        free_krb5_pa_pk_as_req(&reqp);
        free(cksum.contents);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        free_krb5_pa_pk_as_req_draft9(&reqp9);
    }
    free(authp_data.data);
    free(krb5_authz.data);
    if (reqctx != NULL)
        pkinit_fini_kdc_req_context(context, reqctx);
    free_krb5_auth_pack(&auth_pack);
    free_krb5_auth_pack_draft9(context, &auth_pack9);

    (*respond)(arg, retval, modreq, e_data, NULL);
}
","pkinit_server_verify_padata(krb5_context context,
                            krb5_data *req_pkt,
                            krb5_kdc_req * request,
                            krb5_enc_tkt_part * enc_tkt_reply,
                            krb5_pa_data * data,
                            krb5_kdcpreauth_callbacks cb,
                            krb5_kdcpreauth_rock rock,
                            krb5_kdcpreauth_moddata moddata,
                            krb5_kdcpreauth_verify_respond_fn respond,
                            void *arg)
{
    krb5_error_code retval = 0;
    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};
    krb5_pa_pk_as_req *reqp = NULL;
    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;
    krb5_auth_pack *auth_pack = NULL;
    krb5_auth_pack_draft9 *auth_pack9 = NULL;
    pkinit_kdc_context plgctx = NULL;
    pkinit_kdc_req_context reqctx = NULL;
    krb5_checksum cksum = {0, 0, 0, NULL};
    krb5_data *der_req = NULL;
    int valid_eku = 0, valid_san = 0;
    krb5_data k5data;
    int is_signed = 1;
    krb5_pa_data **e_data = NULL;
    krb5_kdcpreauth_modreq modreq = NULL;
 
     pkiDebug(""pkinit_verify_padata: entered!\n"");
     if (data == NULL || data->length <= 0 || data->contents == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 

    if (moddata == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        return;
    }
 
     plgctx = pkinit_find_realm_context(context, moddata, request->server);
     if (plgctx == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
         return;
     }
 
#ifdef DEBUG_ASN1
    print_buffer_bin(data->contents, data->length, ""/tmp/kdc_as_req"");
#endif
    /* create a per-request context */
    retval = pkinit_init_kdc_req_context(context, &reqctx);
    if (retval)
        goto cleanup;
    reqctx->pa_type = data->pa_type;

    PADATA_TO_KRB5DATA(data, &k5data);

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ\n"");
        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp->signedAuthPack.data,
                         reqp->signedAuthPack.length,
                         ""/tmp/kdc_signed_data"");
#endif
        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, &is_signed);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ_OLD\n"");
        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req_draft9 failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp9->signedAuthPack.data,
                         reqp9->signedAuthPack.length,
                         ""/tmp/kdc_signed_data_draft9"");
#endif

        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, NULL);
        break;
    default:
        pkiDebug(""unrecognized pa_type = %d\n"", data->pa_type);
        retval = EINVAL;
        goto cleanup;
    }
    if (retval) {
        pkiDebug(""pkcs7_signeddata_verify failed\n"");
        goto cleanup;
    }
    if (is_signed) {

        retval = verify_client_san(context, plgctx, reqctx, request->client,
                                   &valid_san);
        if (retval)
            goto cleanup;
        if (!valid_san) {
            pkiDebug(""%s: did not find an acceptable SAN in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
            goto cleanup;
        }
        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);
        if (retval)
            goto cleanup;

        if (!valid_eku) {
            pkiDebug(""%s: did not find an acceptable EKU in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
            goto cleanup;
        }
    } else { /* !is_signed */
        if (!krb5_principal_compare(context, request->client,
                                    krb5_anonymous_principal())) {
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Pkinit request not signed, but client ""
                                     ""not anonymous.""));
            goto cleanup;
        }
    }
#ifdef DEBUG_ASN1
    print_buffer_bin(authp_data.data, authp_data.length, ""/tmp/kdc_auth_pack"");
#endif

    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);
    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack\n"");
            goto cleanup;
        }

        retval = krb5_check_clockskew(context,
                                      auth_pack->pkAuthenticator.ctime);
        if (retval)
            goto cleanup;

        /* check dh parameters */
        if (auth_pack->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        } else if (!is_signed) {
            /*Anonymous pkinit requires DH*/
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Anonymous pkinit without DH public ""
                                     ""value not supported.""));
            goto cleanup;
        }
        der_req = cb->request_body(context, rock);
        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,
                                      0, der_req, &cksum);
        if (retval) {
            pkiDebug(""unable to calculate AS REQ checksum\n"");
            goto cleanup;
        }
        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||
            k5_bcmp(cksum.contents,
                    auth_pack->pkAuthenticator.paChecksum.contents,
                    cksum.length) != 0) {
            pkiDebug(""failed to match the checksum\n"");
#ifdef DEBUG_CKSUM
            pkiDebug(""calculating checksum on buf size (%d)\n"",
                     req_pkt->length);
            print_buffer(req_pkt->data, req_pkt->length);
            pkiDebug(""received checksum type=%d size=%d "",
                     auth_pack->pkAuthenticator.paChecksum.checksum_type,
                     auth_pack->pkAuthenticator.paChecksum.length);
            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,
                         auth_pack->pkAuthenticator.paChecksum.length);
            pkiDebug(""expected checksum type=%d size=%d "",
                     cksum.checksum_type, cksum.length);
            print_buffer(cksum.contents, cksum.length);
#endif

            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;
            goto cleanup;
        }

        /* check if kdcPkId present and match KDC's subjectIdentifier */
        if (reqp->kdcPkId.data != NULL) {
            int valid_kdcPkId = 0;
            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,
                                           reqctx->cryptoctx, plgctx->idctx,
                                           (unsigned char *)reqp->kdcPkId.data,
                                           reqp->kdcPkId.length, &valid_kdcPkId);
            if (retval)
                goto cleanup;
            if (!valid_kdcPkId)
                pkiDebug(""kdcPkId in AS_REQ does not match KDC's cert""
                         ""RFC says to ignore and proceed\n"");

        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack = auth_pack;
        auth_pack = NULL;
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack_draft9\n"");
            goto cleanup;
        }
        if (auth_pack9->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack9->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        }
        /* remember the decoded auth_pack for verify_padata routine */
        reqctx->rcv_auth_pack9 = auth_pack9;
        auth_pack9 = NULL;
        break;
    }

    /* remember to set the PREAUTH flag in the reply */
    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;
    modreq = (krb5_kdcpreauth_modreq)reqctx;
    reqctx = NULL;

cleanup:
    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {
        pkiDebug(""pkinit_verify_padata failed: creating e-data\n"");
        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,
                                plgctx->idctx, plgctx->opts, retval, &e_data))
            pkiDebug(""pkinit_create_edata failed\n"");
    }

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        free_krb5_pa_pk_as_req(&reqp);
        free(cksum.contents);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        free_krb5_pa_pk_as_req_draft9(&reqp9);
    }
    free(authp_data.data);
    free(krb5_authz.data);
    if (reqctx != NULL)
        pkinit_fini_kdc_req_context(context, reqctx);
    free_krb5_auth_pack(&auth_pack);
    free_krb5_auth_pack_draft9(context, &auth_pack9);

    (*respond)(arg, retval, modreq, e_data, NULL);
}
","The `pkinit_server_verify_padata` function is part of a Kerberos authentication process that verifies public key authentication data. It takes various parameters, including a Kerberos context, request packet, and pre-authentication data, and processes them to validate the client's authentication request. The function decodes the received public key authentication request, verifies the digital signature, checks the client's certificate for valid subject alternative names (SAN) and extended key usage (EKU), and ensures the integrity of the request through checksum validation. If successful, it sets a pre-authentication flag in the ticket reply; otherwise, it handles errors and cleans up resources before responding to the client.","The provided code implements a verification process for public key authentication data in a Kerberos authentication system. It checks the validity of the received authentication request, ensuring that the data is present and correctly formatted. The function decodes the request, verifies digital signatures, and checks the client's certificate for compliance with specific criteria. It also validates the integrity of the request through checksum verification. If all checks pass, it sets a flag indicating successful pre-authentication; otherwise, it handles errors appropriately and cleans up resources before responding to the client.","The vulnerability in the original code allowed an unauthenticated attacker to bypass the pre-authentication requirement, potentially leading to unauthorized access to sensitive data. This occurred because the code incorrectly set the pre-authentication flag before verifying the request, allowing empty or misconfigured requests to be treated as valid. In the fixed code, the logic was modified to ensure that the pre-authentication flag is only set after successful verification of the request. Additionally, the code now responds with an error for empty input or unconfigured realms, preventing the KDC from erroneously treating such requests as pre-authenticated.","The vulnerability allowed an unauthenticated attacker to bypass the pre-authentication requirement, enabling them to obtain sensitive ciphertext encrypted with a user's long-term key. This flaw arose because the system incorrectly set a flag indicating successful pre-authentication before actually verifying the request, which could lead to empty or misconfigured requests being accepted as valid. The fix involved ensuring that this flag is only set after the request has been successfully verified. Additionally, the system was updated to respond with an error for empty inputs or unconfigured realms, preventing erroneous acceptance of such requests.","The vulnerability was fixed by modifying the logic that sets the pre-authentication flag. In the updated code, the TKT_FLG_PRE_AUTH bit is only set after the request has been successfully verified, ensuring that it does not erroneously accept invalid requests. Additionally, the code now checks for empty input and unconfigured realms, responding with an error instead of code 0 in such cases. This change prevents the KDC from treating these requests as pre-authenticated, thereby closing the loophole that allowed attackers to bypass the requires_preauth flag and access sensitive ciphertext.","The vulnerability was addressed by ensuring that the pre-authentication flag is only set after a successful verification of the request, preventing invalid requests from being mistakenly accepted as valid. Additionally, the code was modified to handle cases of empty input and unconfigured realms by returning an error response instead of a success code. These changes collectively ensure that the system does not erroneously treat unauthorized requests as pre-authenticated, thereby closing the security loophole that allowed attackers to bypass the pre-authentication requirement and potentially access sensitive information.","CWE-287,CWE-306,CWE-285,CWE-284,CWE-288,CWE-807,CWE-840,CWE-20,CWE-290,CWE-592",N,-1
41,41,179856,179856,,Remote,Not required,Partial,CVE-2015-1867,https://www.cvedetails.com/cve/CVE-2015-1867/,CWE-264,Low,Partial,Partial,,2015-08-12,7.5,"Pacemaker before 1.1.13 does not properly evaluate added nodes, which allows remote read-only users to gain privileges via an acl command.",2017-10-09,+Priv ,6,https://github.com/ClusterLabs/pacemaker/commit/84ac07c,84ac07c,"Fix: acl: Do not delay evaluation of added nodes in some situations

It is not appropriate when the node has no children as it is not a
placeholder",3,lib/common/xml.c,"{""sha"": ""716f053f824168e16584efef8e949e2666192e8a"", ""filename"": ""lib/common/xml.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 3, ""changes"": 9, ""blob_url"": ""https://github.com/ClusterLabs/pacemaker/blob/84ac07c7d02b3badd708b1ef13a2159dede70715/lib/common/xml.c"", ""raw_url"": ""https://github.com/ClusterLabs/pacemaker/raw/84ac07c7d02b3badd708b1ef13a2159dede70715/lib/common/xml.c"", ""contents_url"": ""https://api.github.com/repos/ClusterLabs/pacemaker/contents/lib/common/xml.c?ref=84ac07c7d02b3badd708b1ef13a2159dede70715"", ""patch"": ""@@ -1020,13 +1020,16 @@ __xml_acl_post_process(xmlNode * xml)\n \n     if(is_set(p->flags, xpf_created)) {\n         xmlAttr *xIter = NULL;\n+        char *path = xml_get_path(xml);\n \n-        /* Always allow new scaffolding, ie. node with no attributes or only an 'id' */\n+        /* Always allow new scaffolding, ie. node with no attributes or only an 'id'\n+         * Except in the ACLs section\n+         */\n \n         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {\n             const char *prop_name = (const char *)xIter->name;\n \n-            if (strcmp(prop_name, XML_ATTR_ID) == 0) {\n+            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, \""/\""XML_CIB_TAG_ACLS\""/\"") == NULL) {\n                 /* Delay the acl check */\n                 continue;\n \n@@ -1035,7 +1038,6 @@ __xml_acl_post_process(xmlNode * xml)\n                 break;\n \n             } else {\n-                char *path = xml_get_path(xml);\n                 crm_trace(\""Cannot add new node %s at %s\"", crm_element_name(xml), path);\n \n                 if(xml != xmlDocGetRootElement(xml->doc)) {\n@@ -1046,6 +1048,7 @@ __xml_acl_post_process(xmlNode * xml)\n                 return;\n             }\n         }\n+        free(path);\n     }\n \n     while (cIter != NULL) {""}","__xml_acl_post_process(xmlNode * xml)
{
    xmlNode *cIter = __xml_first_child(xml);
    xml_private_t *p = xml->_private;
 
     if(is_set(p->flags, xpf_created)) {
         xmlAttr *xIter = NULL;
        char *path = xml_get_path(xml);
 
        /* Always allow new scaffolding, ie. node with no attributes or only an 'id'
         * Except in the ACLs section
         */
 
         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {
             const char *prop_name = (const char *)xIter->name;
 
            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, ""/""XML_CIB_TAG_ACLS""/"") == NULL) {
                 /* Delay the acl check */
                 continue;
 
            } else if(__xml_acl_check(xml, NULL, xpf_acl_write)) {
                crm_trace(""Creation of %s=%s is allowed"", crm_element_name(xml), ID(xml));
                 break;
 
             } else {
                 crm_trace(""Cannot add new node %s at %s"", crm_element_name(xml), path);
 
                 if(xml != xmlDocGetRootElement(xml->doc)) {
                    xmlUnlinkNode(xml);
                    xmlFreeNode(xml);
                }
                free(path);
                 return;
             }
         }
        free(path);
     }
 
     while (cIter != NULL) {
        xmlNode *child = cIter;
        cIter = __xml_next(cIter); /* In case it is free'd */
        __xml_acl_post_process(child);
    }
}
","__xml_acl_post_process(xmlNode * xml)
{
    xmlNode *cIter = __xml_first_child(xml);
    xml_private_t *p = xml->_private;
 
     if(is_set(p->flags, xpf_created)) {
         xmlAttr *xIter = NULL;
 
        /* Always allow new scaffolding, ie. node with no attributes or only an 'id' */
 
         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {
             const char *prop_name = (const char *)xIter->name;
 
            if (strcmp(prop_name, XML_ATTR_ID) == 0) {
                 /* Delay the acl check */
                 continue;
 
            } else if(__xml_acl_check(xml, NULL, xpf_acl_write)) {
                crm_trace(""Creation of %s=%s is allowed"", crm_element_name(xml), ID(xml));
                 break;
 
             } else {
                char *path = xml_get_path(xml);
                 crm_trace(""Cannot add new node %s at %s"", crm_element_name(xml), path);
 
                 if(xml != xmlDocGetRootElement(xml->doc)) {
                    xmlUnlinkNode(xml);
                    xmlFreeNode(xml);
                }
                free(path);
                 return;
             }
         }
     }
 
     while (cIter != NULL) {
        xmlNode *child = cIter;
        cIter = __xml_next(cIter); /* In case it is free'd */
        __xml_acl_post_process(child);
    }
}
",C,"        char *path = xml_get_path(xml);
        /* Always allow new scaffolding, ie. node with no attributes or only an 'id'
         * Except in the ACLs section
         */
            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, ""/""XML_CIB_TAG_ACLS""/"") == NULL) {
        free(path);
","        /* Always allow new scaffolding, ie. node with no attributes or only an 'id' */
            if (strcmp(prop_name, XML_ATTR_ID) == 0) {
                char *path = xml_get_path(xml);
",,"@@ -1020,13 +1020,16 @@ __xml_acl_post_process(xmlNode * xml)
 
     if(is_set(p->flags, xpf_created)) {
         xmlAttr *xIter = NULL;
+        char *path = xml_get_path(xml);
 
-        /* Always allow new scaffolding, ie. node with no attributes or only an 'id' */
+        /* Always allow new scaffolding, ie. node with no attributes or only an 'id'
+         * Except in the ACLs section
+         */
 
         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {
             const char *prop_name = (const char *)xIter->name;
 
-            if (strcmp(prop_name, XML_ATTR_ID) == 0) {
+            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, ""/""XML_CIB_TAG_ACLS""/"") == NULL) {
                 /* Delay the acl check */
                 continue;
 
@@ -1035,7 +1038,6 @@ __xml_acl_post_process(xmlNode * xml)
                 break;
 
             } else {
-                char *path = xml_get_path(xml);
                 crm_trace(""Cannot add new node %s at %s"", crm_element_name(xml), path);
 
                 if(xml != xmlDocGetRootElement(xml->doc)) {
@@ -1046,6 +1048,7 @@ __xml_acl_post_process(xmlNode * xml)
                 return;
             }
         }
+        free(path);
     }
 
     while (cIter != NULL) {",pacemaker,84ac07c,e52eef127b97aa9a05e6d278037bc6da7929a16d,1,"__xml_acl_post_process(xmlNode * xml)
{
    xmlNode *cIter = __xml_first_child(xml);
    xml_private_t *p = xml->_private;
 
     if(is_set(p->flags, xpf_created)) {
         xmlAttr *xIter = NULL;
//fix_flaw_line_below:
//        char *path = xml_get_path(xml);
 
//flaw_line_below:
        /* Always allow new scaffolding, ie. node with no attributes or only an 'id' */
//fix_flaw_line_below:
//        /* Always allow new scaffolding, ie. node with no attributes or only an 'id'
//fix_flaw_line_below:
//         * Except in the ACLs section
//fix_flaw_line_below:
//         */
 
         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {
             const char *prop_name = (const char *)xIter->name;
 
//flaw_line_below:
            if (strcmp(prop_name, XML_ATTR_ID) == 0) {
//fix_flaw_line_below:
//            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, ""/""XML_CIB_TAG_ACLS""/"") == NULL) {
                 /* Delay the acl check */
                 continue;
 
            } else if(__xml_acl_check(xml, NULL, xpf_acl_write)) {
                crm_trace(""Creation of %s=%s is allowed"", crm_element_name(xml), ID(xml));
                 break;
 
             } else {
//flaw_line_below:
                char *path = xml_get_path(xml);
                 crm_trace(""Cannot add new node %s at %s"", crm_element_name(xml), path);
 
                 if(xml != xmlDocGetRootElement(xml->doc)) {
                    xmlUnlinkNode(xml);
                    xmlFreeNode(xml);
                }
                free(path);
                 return;
             }
         }
//fix_flaw_line_below:
//        free(path);
     }
 
     while (cIter != NULL) {
        xmlNode *child = cIter;
        cIter = __xml_next(cIter); /* In case it is free'd */
        __xml_acl_post_process(child);
    }
}
",179856,"__xml_acl_post_process(xmlNode * xml)
{
    xmlNode *cIter = __xml_first_child(xml);
    xml_private_t *p = xml->_private;
 
     if(is_set(p->flags, xpf_created)) {
         xmlAttr *xIter = NULL;
 
        /* Always allow new scaffolding, ie. node with no attributes or only an 'id' */
 
         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {
             const char *prop_name = (const char *)xIter->name;
 
            if (strcmp(prop_name, XML_ATTR_ID) == 0) {
                 /* Delay the acl check */
                 continue;
 
            } else if(__xml_acl_check(xml, NULL, xpf_acl_write)) {
                crm_trace(""Creation of %s=%s is allowed"", crm_element_name(xml), ID(xml));
                 break;
 
             } else {
                char *path = xml_get_path(xml);
                 crm_trace(""Cannot add new node %s at %s"", crm_element_name(xml), path);
 
                 if(xml != xmlDocGetRootElement(xml->doc)) {
                    xmlUnlinkNode(xml);
                    xmlFreeNode(xml);
                }
                free(path);
                 return;
             }
         }
     }
 
     while (cIter != NULL) {
        xmlNode *child = cIter;
        cIter = __xml_next(cIter); /* In case it is free'd */
        __xml_acl_post_process(child);
    }
}
","__xml_acl_post_process(xmlNode * xml)
{
    xmlNode *cIter = __xml_first_child(xml);
    xml_private_t *p = xml->_private;
 
     if(is_set(p->flags, xpf_created)) {
         xmlAttr *xIter = NULL;
        char *path = xml_get_path(xml);
 
        /* Always allow new scaffolding, ie. node with no attributes or only an 'id'
         * Except in the ACLs section
         */
 
         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {
             const char *prop_name = (const char *)xIter->name;
 
            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, ""/""XML_CIB_TAG_ACLS""/"") == NULL) {
                 /* Delay the acl check */
                 continue;
 
            } else if(__xml_acl_check(xml, NULL, xpf_acl_write)) {
                crm_trace(""Creation of %s=%s is allowed"", crm_element_name(xml), ID(xml));
                 break;
 
             } else {
                 crm_trace(""Cannot add new node %s at %s"", crm_element_name(xml), path);
 
                 if(xml != xmlDocGetRootElement(xml->doc)) {
                    xmlUnlinkNode(xml);
                    xmlFreeNode(xml);
                }
                free(path);
                 return;
             }
         }
        free(path);
     }
 
     while (cIter != NULL) {
        xmlNode *child = cIter;
        cIter = __xml_next(cIter); /* In case it is free'd */
        __xml_acl_post_process(child);
    }
}
","The function `__xml_acl_post_process` processes an XML node to enforce access control based on specific conditions. It first checks if the node was created and iterates through its attributes, allowing the addition of nodes with no attributes or only an 'id'. If an attribute is found that does not match 'id', it performs an access control check; if denied, it logs a trace message and removes the node from the document. The function then recursively processes all child nodes, ensuring that access control is consistently applied throughout the XML structure.","The code processes an XML node to enforce access control rules after the node's creation. It checks if the node has been newly created and iterates through its attributes, allowing the addition of nodes that either lack attributes or contain only a specific attribute. If an attribute is present that does not meet the criteria, the code performs an access control check; if access is denied, it logs a message and removes the node from the document. The function also recursively processes all child nodes to ensure consistent application of access control throughout the entire XML structure.","The vulnerability in the original code allowed the addition of new nodes without proper access control checks, particularly in the ACLs section, which could lead to unauthorized modifications. The fix introduced a condition that prevents delaying the access control check for nodes that are added within the ACLs section, ensuring that any new node with an 'id' attribute is still subject to evaluation. This was achieved by checking if the node's path contains the ACLs tag before deciding to skip the access control check, thereby enhancing security by enforcing stricter controls in sensitive areas of the XML structure.","The vulnerability in the original code allowed new nodes to be added without immediate access control checks, particularly in sensitive areas like ACLs, which could lead to unauthorized changes. This oversight permitted nodes to be created without proper validation, potentially compromising the integrity of the access control system. The fix addressed this issue by ensuring that access control evaluations are not delayed for nodes that do not have children, as these nodes should not be treated as placeholders. This change enforces stricter access control checks in critical sections, thereby enhancing the overall security of the system.","The vulnerability was fixed by modifying the condition that determines when to delay the access control check for newly added nodes. In the updated code, the check now includes a verification that the node's path does not contain the ACLs tag, ensuring that nodes added in this sensitive area are immediately evaluated for access control. Specifically, the condition `strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, ""/""XML_CIB_TAG_ACLS""/"") == NULL` prevents the delay for nodes without children, thereby enforcing access control checks consistently and preventing unauthorized modifications in critical sections of the XML structure.","The vulnerability was fixed by introducing a condition that ensures access control checks are not delayed for newly added nodes in sensitive areas, specifically when those nodes do not have any children. This change prevents the system from treating such nodes as placeholders, which previously allowed them to bypass immediate evaluation for access rights. By enforcing access control checks right away in these situations, the fix enhances the security of the system, ensuring that all new nodes are properly validated before being added, thereby mitigating the risk of unauthorized modifications.","CWE-284, CWE-285, CWE-732, CWE-862, CWE-863, CWE-269, CWE-266, CWE-264, CWE-693, CWE-281",N,-1
42,42,179867,179867,,Remote,Not required,,CVE-2015-1593,https://www.cvedetails.com/cve/CVE-2015-1593/,CWE-264,Low,Partial,,,2015-03-16,5.0,"The stack randomization feature in the Linux kernel before 3.19.1 on 64-bit platforms uses incorrect data types for the results of bitwise left-shift operations, which makes it easier for attackers to bypass the ASLR protection mechanism by predicting the address of the top of the stack, related to the randomize_stack_top function in fs/binfmt_elf.c and the stack_maxrandom_size function in arch/x86/mm/mmap.c.",2018-01-04,Bypass ,3,https://github.com/torvalds/linux/commit/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,"x86, mm/ASLR: Fix stack randomization on 64-bit systems

The issue is that the stack for processes is not properly randomized on
64 bit architectures due to an integer overflow.

The affected function is randomize_stack_top() in file
""fs/binfmt_elf.c"":

  static unsigned long randomize_stack_top(unsigned long stack_top)
  {
           unsigned int random_variable = 0;

           if ((current->flags & PF_RANDOMIZE) &&
                   !(current->personality & ADDR_NO_RANDOMIZE)) {
                   random_variable = get_random_int() & STACK_RND_MASK;
                   random_variable <<= PAGE_SHIFT;
           }
           return PAGE_ALIGN(stack_top) + random_variable;
           return PAGE_ALIGN(stack_top) - random_variable;
  }

Note that, it declares the ""random_variable"" variable as ""unsigned int"".
Since the result of the shifting operation between STACK_RND_MASK (which
is 0x3fffff on x86_64, 22 bits) and PAGE_SHIFT (which is 12 on x86_64):

	  random_variable <<= PAGE_SHIFT;

then the two leftmost bits are dropped when storing the result in the
""random_variable"". This variable shall be at least 34 bits long to hold
the (22+12) result.

These two dropped bits have an impact on the entropy of process stack.
Concretely, the total stack entropy is reduced by four: from 2^28 to
2^30 (One fourth of expected entropy).

This patch restores back the entropy by correcting the types involved
in the operations in the functions randomize_stack_top() and
stack_maxrandom_size().

The successful fix can be tested with:

  $ for i in `seq 1 10`; do cat /proc/self/maps | grep stack; done
  7ffeda566000-7ffeda587000 rw-p 00000000 00:00 0                          [stack]
  7fff5a332000-7fff5a353000 rw-p 00000000 00:00 0                          [stack]
  7ffcdb7a1000-7ffcdb7c2000 rw-p 00000000 00:00 0                          [stack]
  7ffd5e2c4000-7ffd5e2e5000 rw-p 00000000 00:00 0                          [stack]
  ...

Once corrected, the leading bytes should be between 7ffc and 7fff,
rather than always being 7fff.

Signed-off-by: Hector Marco-Gisbert <hecmargi@upv.es>
Signed-off-by: Ismael Ripoll <iripoll@upv.es>
[ Rebased, fixed 80 char bugs, cleaned up commit message, added test example and CVE ]
Signed-off-by: Kees Cook <keescook@chromium.org>
Cc: <stable@vger.kernel.org>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Fixes: CVE-2015-1593
Link: http://lkml.kernel.org/r/20150214173350.GA18393@www.outflux.net
Signed-off-by: Borislav Petkov <bp@suse.de>",2,arch/x86/mm/mmap.c,"{""sha"": ""df4552bd239e03b4a02e6505454e41420d530461"", ""filename"": ""arch/x86/mm/mmap.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/arch/x86/mm/mmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/arch/x86/mm/mmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/mm/mmap.c?ref=4e7c22d447bb6d7e37bfe39ff658486ae78e8d77"", ""patch"": ""@@ -35,12 +35,12 @@ struct va_alignment __read_mostly va_align = {\n \t.flags = -1,\n };\n \n-static unsigned int stack_maxrandom_size(void)\n+static unsigned long stack_maxrandom_size(void)\n {\n-\tunsigned int max = 0;\n+\tunsigned long max = 0;\n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n-\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n+\t\tmax = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;\n \t}\n \n \treturn max;""}<_**next**_>{""sha"": ""995986b8e36b8f3fd8529582c50e545d9b26322e"", ""filename"": ""fs/binfmt_elf.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/fs/binfmt_elf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/fs/binfmt_elf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/binfmt_elf.c?ref=4e7c22d447bb6d7e37bfe39ff658486ae78e8d77"", ""patch"": ""@@ -645,11 +645,12 @@ static unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\n \n static unsigned long randomize_stack_top(unsigned long stack_top)\n {\n-\tunsigned int random_variable = 0;\n+\tunsigned long random_variable = 0;\n \n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n-\t\trandom_variable = get_random_int() & STACK_RND_MASK;\n+\t\trandom_variable = (unsigned long) get_random_int();\n+\t\trandom_variable &= STACK_RND_MASK;\n \t\trandom_variable <<= PAGE_SHIFT;\n \t}\n #ifdef CONFIG_STACK_GROWSUP""}","static unsigned int stack_maxrandom_size(void)
static unsigned long stack_maxrandom_size(void)
 {
	unsigned long max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;
}
","static unsigned int stack_maxrandom_size(void)
 {
	unsigned int max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;
}
",C,"static unsigned long stack_maxrandom_size(void)
	unsigned long max = 0;
		max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;
","	unsigned int max = 0;
		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
",,"@@ -35,12 +35,12 @@ struct va_alignment __read_mostly va_align = {
 	.flags = -1,
 };
 
-static unsigned int stack_maxrandom_size(void)
+static unsigned long stack_maxrandom_size(void)
 {
-	unsigned int max = 0;
+	unsigned long max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
-		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
+		max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;",linux,4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,f47233c2d34f243ecdaac179c3408a39ff9216a7,1,"static unsigned int stack_maxrandom_size(void)
//fix_flaw_line_below:
//static unsigned long stack_maxrandom_size(void)
 {
//flaw_line_below:
	unsigned int max = 0;
//fix_flaw_line_below:
//	unsigned long max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
//flaw_line_below:
		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
//fix_flaw_line_below:
//		max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;
}
",179867,"static unsigned int stack_maxrandom_size(void)
 {
	unsigned int max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;
}
","static unsigned int stack_maxrandom_size(void)
static unsigned long stack_maxrandom_size(void)
 {
	unsigned long max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;
}
","The provided code defines a function `stack_maxrandom_size` that calculates the maximum random stack size for the current process. It first initializes a variable `max` to zero. The function checks if the current process has the `PF_RANDOMIZE` flag set and does not have the `ADDR_NO_RANDOMIZE` personality flag. If both conditions are met, it computes the maximum stack size by applying a bitwise operation to the constant `STACK_RND_MASK`, shifting it left by `PAGE_SHIFT` bits, and assigns the result to `max`. Finally, the function returns the computed maximum stack size.","The code defines a function that determines the maximum allowable size for a randomized stack in the current process. It initializes a variable to zero and checks specific flags associated with the process to ascertain whether randomization is enabled and not explicitly disabled. If the conditions are satisfied, it calculates the maximum stack size by performing a bitwise operation on a predefined mask and shifting it to account for page size. The function ultimately returns the calculated maximum size, which can be used to enhance security by randomizing stack memory allocation.","The vulnerability in the original code stemmed from using an `unsigned int` for the `random_variable`, which caused an integer overflow when performing a left shift operation with `STACK_RND_MASK` and `PAGE_SHIFT`. This overflow resulted in the loss of the two most significant bits, reducing the entropy of the stack randomization from 2^30 to 2^28, thereby weakening security. The fix involved changing the type of `max` in the `stack_maxrandom_size` function from `unsigned int` to `unsigned long`, ensuring that the variable could accommodate the full result of the shift operation, thus restoring the intended stack entropy.","The vulnerability in the original code arose from using a data type that was too small to handle the results of a bitwise shift operation, leading to an integer overflow. This overflow caused the loss of significant bits, which reduced the randomness of the stack allocation, thereby compromising security by decreasing the entropy from the expected level. The fix involved changing the data type to a larger one, ensuring that the full result of the shift operation could be stored without loss. This adjustment restored the intended level of randomness and security for stack memory allocation on 64-bit systems.","The vulnerability was fixed by changing the data type of the `max` variable in the `stack_maxrandom_size` function from `unsigned int` to `unsigned long`. This adjustment allowed the variable to accommodate the full result of the left shift operation involving `STACK_RND_MASK` and `PAGE_SHIFT`, preventing the loss of significant bits that previously occurred due to integer overflow. Additionally, the same type change was applied to the `random_variable` in the `randomize_stack_top` function, ensuring that both functions could handle the necessary bit-width for proper stack randomization, thereby restoring the intended entropy and enhancing security.","The vulnerability was addressed by changing the data type used for storing the results of bitwise operations to a larger type, which allowed for the full range of values to be accommodated without risk of overflow. This modification ensured that significant bits were not lost during calculations, thereby preserving the intended level of randomness in stack allocation. By making this adjustment in both relevant functions, the fix restored the necessary entropy for stack randomization, ultimately enhancing the security of the system against potential exploitation due to reduced randomness.","CWE-190, CWE-191, CWE-682, CWE-192, CWE-128, CWE-193, CWE-197, CWE-680, CWE-681, CWE-194",N,-1
43,43,179868,179868,,Remote,Not required,,CVE-2015-1593,https://www.cvedetails.com/cve/CVE-2015-1593/,CWE-264,Low,Partial,,,2015-03-16,5.0,"The stack randomization feature in the Linux kernel before 3.19.1 on 64-bit platforms uses incorrect data types for the results of bitwise left-shift operations, which makes it easier for attackers to bypass the ASLR protection mechanism by predicting the address of the top of the stack, related to the randomize_stack_top function in fs/binfmt_elf.c and the stack_maxrandom_size function in arch/x86/mm/mmap.c.",2018-01-04,Bypass ,3,https://github.com/torvalds/linux/commit/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,"x86, mm/ASLR: Fix stack randomization on 64-bit systems

The issue is that the stack for processes is not properly randomized on
64 bit architectures due to an integer overflow.

The affected function is randomize_stack_top() in file
""fs/binfmt_elf.c"":

  static unsigned long randomize_stack_top(unsigned long stack_top)
  {
           unsigned int random_variable = 0;

           if ((current->flags & PF_RANDOMIZE) &&
                   !(current->personality & ADDR_NO_RANDOMIZE)) {
                   random_variable = get_random_int() & STACK_RND_MASK;
                   random_variable <<= PAGE_SHIFT;
           }
           return PAGE_ALIGN(stack_top) + random_variable;
           return PAGE_ALIGN(stack_top) - random_variable;
  }

Note that, it declares the ""random_variable"" variable as ""unsigned int"".
Since the result of the shifting operation between STACK_RND_MASK (which
is 0x3fffff on x86_64, 22 bits) and PAGE_SHIFT (which is 12 on x86_64):

	  random_variable <<= PAGE_SHIFT;

then the two leftmost bits are dropped when storing the result in the
""random_variable"". This variable shall be at least 34 bits long to hold
the (22+12) result.

These two dropped bits have an impact on the entropy of process stack.
Concretely, the total stack entropy is reduced by four: from 2^28 to
2^30 (One fourth of expected entropy).

This patch restores back the entropy by correcting the types involved
in the operations in the functions randomize_stack_top() and
stack_maxrandom_size().

The successful fix can be tested with:

  $ for i in `seq 1 10`; do cat /proc/self/maps | grep stack; done
  7ffeda566000-7ffeda587000 rw-p 00000000 00:00 0                          [stack]
  7fff5a332000-7fff5a353000 rw-p 00000000 00:00 0                          [stack]
  7ffcdb7a1000-7ffcdb7c2000 rw-p 00000000 00:00 0                          [stack]
  7ffd5e2c4000-7ffd5e2e5000 rw-p 00000000 00:00 0                          [stack]
  ...

Once corrected, the leading bytes should be between 7ffc and 7fff,
rather than always being 7fff.

Signed-off-by: Hector Marco-Gisbert <hecmargi@upv.es>
Signed-off-by: Ismael Ripoll <iripoll@upv.es>
[ Rebased, fixed 80 char bugs, cleaned up commit message, added test example and CVE ]
Signed-off-by: Kees Cook <keescook@chromium.org>
Cc: <stable@vger.kernel.org>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Fixes: CVE-2015-1593
Link: http://lkml.kernel.org/r/20150214173350.GA18393@www.outflux.net
Signed-off-by: Borislav Petkov <bp@suse.de>",2,fs/binfmt_elf.c,"{""sha"": ""df4552bd239e03b4a02e6505454e41420d530461"", ""filename"": ""arch/x86/mm/mmap.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/arch/x86/mm/mmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/arch/x86/mm/mmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/mm/mmap.c?ref=4e7c22d447bb6d7e37bfe39ff658486ae78e8d77"", ""patch"": ""@@ -35,12 +35,12 @@ struct va_alignment __read_mostly va_align = {\n \t.flags = -1,\n };\n \n-static unsigned int stack_maxrandom_size(void)\n+static unsigned long stack_maxrandom_size(void)\n {\n-\tunsigned int max = 0;\n+\tunsigned long max = 0;\n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n-\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n+\t\tmax = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;\n \t}\n \n \treturn max;""}<_**next**_>{""sha"": ""995986b8e36b8f3fd8529582c50e545d9b26322e"", ""filename"": ""fs/binfmt_elf.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/fs/binfmt_elf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77/fs/binfmt_elf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/binfmt_elf.c?ref=4e7c22d447bb6d7e37bfe39ff658486ae78e8d77"", ""patch"": ""@@ -645,11 +645,12 @@ static unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\n \n static unsigned long randomize_stack_top(unsigned long stack_top)\n {\n-\tunsigned int random_variable = 0;\n+\tunsigned long random_variable = 0;\n \n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n-\t\trandom_variable = get_random_int() & STACK_RND_MASK;\n+\t\trandom_variable = (unsigned long) get_random_int();\n+\t\trandom_variable &= STACK_RND_MASK;\n \t\trandom_variable <<= PAGE_SHIFT;\n \t}\n #ifdef CONFIG_STACK_GROWSUP""}"," static unsigned long randomize_stack_top(unsigned long stack_top)
 {
	unsigned long random_variable = 0;
 
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		random_variable = (unsigned long) get_random_int();
		random_variable &= STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP
	return PAGE_ALIGN(stack_top) + random_variable;
#else
	return PAGE_ALIGN(stack_top) - random_variable;
#endif
}
"," static unsigned long randomize_stack_top(unsigned long stack_top)
 {
	unsigned int random_variable = 0;
 
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		random_variable = get_random_int() & STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP
	return PAGE_ALIGN(stack_top) + random_variable;
#else
	return PAGE_ALIGN(stack_top) - random_variable;
#endif
}
",C,"	unsigned long random_variable = 0;
		random_variable = (unsigned long) get_random_int();
		random_variable &= STACK_RND_MASK;
","	unsigned int random_variable = 0;
		random_variable = get_random_int() & STACK_RND_MASK;
",,"@@ -645,11 +645,12 @@ static unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,
 
 static unsigned long randomize_stack_top(unsigned long stack_top)
 {
-	unsigned int random_variable = 0;
+	unsigned long random_variable = 0;
 
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
-		random_variable = get_random_int() & STACK_RND_MASK;
+		random_variable = (unsigned long) get_random_int();
+		random_variable &= STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP",linux,4e7c22d447bb6d7e37bfe39ff658486ae78e8d77,f47233c2d34f243ecdaac179c3408a39ff9216a7,1," static unsigned long randomize_stack_top(unsigned long stack_top)
 {
//flaw_line_below:
	unsigned int random_variable = 0;
//fix_flaw_line_below:
//	unsigned long random_variable = 0;
 
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
//flaw_line_below:
		random_variable = get_random_int() & STACK_RND_MASK;
//fix_flaw_line_below:
//		random_variable = (unsigned long) get_random_int();
//fix_flaw_line_below:
//		random_variable &= STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP
	return PAGE_ALIGN(stack_top) + random_variable;
#else
	return PAGE_ALIGN(stack_top) - random_variable;
#endif
}
",179868," static unsigned long randomize_stack_top(unsigned long stack_top)
 {
	unsigned int random_variable = 0;
 
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		random_variable = get_random_int() & STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP
	return PAGE_ALIGN(stack_top) + random_variable;
#else
	return PAGE_ALIGN(stack_top) - random_variable;
#endif
}
"," static unsigned long randomize_stack_top(unsigned long stack_top)
 {
	unsigned long random_variable = 0;
 
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		random_variable = (unsigned long) get_random_int();
		random_variable &= STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP
	return PAGE_ALIGN(stack_top) + random_variable;
#else
	return PAGE_ALIGN(stack_top) - random_variable;
#endif
}
","The `randomize_stack_top` function modifies the stack's top address for a process, enhancing security through address space layout randomization (ASLR). It checks if the current process has the `PF_RANDOMIZE` flag set and does not have the `ADDR_NO_RANDOMIZE` personality, indicating that randomization is allowed. If so, it generates a random integer, masks it with `STACK_RND_MASK`, and shifts it left by `PAGE_SHIFT` to align with page boundaries. Depending on the system's stack growth direction (up or down), it either adds or subtracts this random value from the aligned stack top, returning the new randomized address.","The provided code modifies the top address of a process's stack to enhance security through address space layout randomization. It first checks if the current process is allowed to undergo randomization based on specific flags. If randomization is permitted, it generates a random value, ensuring it aligns with memory page boundaries. Depending on whether the stack grows upwards or downwards, the code either adds or subtracts this random value from the aligned stack top address. The result is a new stack top address that is randomized, making it more difficult for potential attackers to predict memory layout.","The vulnerability in the original code stemmed from declaring the `random_variable` as an `unsigned int`, which limited its capacity to hold the result of a left shift operation involving `STACK_RND_MASK` and `PAGE_SHIFT`. This caused an integer overflow, leading to the loss of the two most significant bits, thereby reducing the entropy of the stack randomization from \(2^{30}\) to \(2^{28}\). The fix involved changing the type of `random_variable` to `unsigned long`, allowing it to properly accommodate the full result of the shift operation, thus restoring the intended level of entropy in stack randomization.","The vulnerability in the original code arose from the use of a data type that was too small to hold the result of a bitwise operation and subsequent shift, leading to an integer overflow. This overflow caused the loss of significant bits, which reduced the randomness of the stack address, thereby compromising the security feature of address space layout randomization. The fix involved changing the data type to a larger one, allowing it to properly store the full result of the operation. This adjustment restored the intended level of randomness, enhancing the security of the stack address on 64-bit systems.","The vulnerability was fixed by changing the data type of `random_variable` from `unsigned int` to `unsigned long` in the `randomize_stack_top` function. This modification allowed `random_variable` to accommodate the full result of the left shift operation involving `STACK_RND_MASK` and `PAGE_SHIFT`, preventing the loss of significant bits that previously occurred due to integer overflow. By ensuring that `random_variable` could hold at least 34 bits, the fix restored the intended level of entropy in stack randomization, thereby enhancing the security of the process's stack address on 64-bit architectures.","The vulnerability was addressed by changing the data type used for storing a random value, allowing it to accommodate larger results from bitwise operations and shifts. This adjustment prevented the loss of significant bits that had previously occurred due to an integer overflow, which compromised the randomness of the stack address. By ensuring that the variable could hold the full range of potential values, the fix restored the intended level of randomness and entropy in the stack randomization process, thereby enhancing the overall security of the system against potential attacks targeting memory layout.","CWE-190, CWE-789, CWE-682, CWE-192, CWE-680, CWE-339, CWE-787, CWE-131, CWE-128, CWE-681",N,-1
44,44,179900,179900,,Remote,Not required,Complete,CVE-2015-0278,https://www.cvedetails.com/cve/CVE-2015-0278/,CWE-264,Low,Complete,Complete,,2015-05-18,10.0,"libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",2018-08-13,+Priv ,11,https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c,66ab38918c911bcff025562cf06237d7fedaba0c,"unix: call setgoups before calling setuid/setgid

Partial fix for #1093",0,src/unix/process.c,"{""sha"": ""1efd588b86ef8fcff0f75a1a999c104f2288cadc"", ""filename"": ""src/unix/process.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/libuv/libuv/blob/66ab38918c911bcff025562cf06237d7fedaba0c/src/unix/process.c"", ""raw_url"": ""https://github.com/libuv/libuv/raw/66ab38918c911bcff025562cf06237d7fedaba0c/src/unix/process.c"", ""contents_url"": ""https://api.github.com/repos/libuv/libuv/contents/src/unix/process.c?ref=66ab38918c911bcff025562cf06237d7fedaba0c"", ""patch"": ""@@ -330,6 +330,17 @@ static void uv__process_child_init(const uv_process_options_t* options,\n     _exit(127);\n   }\n \n+  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {\n+    /* When dropping privileges from root, the `setgroups` call will\n+     * remove any extraneous groups. If we don't call this, then\n+     * even though our uid has dropped, we may still have groups\n+     * that enable us to do super-user things. This will fail if we\n+     * aren't root, so don't bother checking the return value, this\n+     * is just done as an optimistic privilege dropping function.\n+     */\n+    SAVE_ERRNO(setgroups(0, NULL));\n+  }\n+\n   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n     uv__write_int(error_fd, -errno);\n     perror(\""setgid()\"");""}","static void uv__process_child_init(const uv_process_options_t* options,
                                   int stdio_count,
                                   int (*pipes)[2],
                                   int error_fd) {
  int close_fd;
  int use_fd;
  int fd;

  if (options->flags & UV_PROCESS_DETACHED)
    setsid();

  for (fd = 0; fd < stdio_count; fd++) {
    close_fd = pipes[fd][0];
    use_fd = pipes[fd][1];

    if (use_fd < 0) {
      if (fd >= 3)
        continue;
      else {
        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is
         * set
         */
        use_fd = open(""/dev/null"", fd == 0 ? O_RDONLY : O_RDWR);
        close_fd = use_fd;

        if (use_fd == -1) {
        uv__write_int(error_fd, -errno);
          perror(""failed to open stdio"");
          _exit(127);
        }
      }
    }

    if (fd == use_fd)
      uv__cloexec(use_fd, 0);
    else
      dup2(use_fd, fd);

    if (fd <= 2)
      uv__nonblock(fd, 0);

    if (close_fd != -1)
      uv__close(close_fd);
  }

  for (fd = 0; fd < stdio_count; fd++) {
    use_fd = pipes[fd][1];

    if (use_fd >= 0 && fd != use_fd)
      close(use_fd);
  }

  if (options->cwd != NULL && chdir(options->cwd)) {
    uv__write_int(error_fd, -errno);
    perror(""chdir()"");
     _exit(127);
   }
 
  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
    /* When dropping privileges from root, the `setgroups` call will
     * remove any extraneous groups. If we don't call this, then
     * even though our uid has dropped, we may still have groups
     * that enable us to do super-user things. This will fail if we
     * aren't root, so don't bother checking the return value, this
     * is just done as an optimistic privilege dropping function.
     */
    SAVE_ERRNO(setgroups(0, NULL));
  }

   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
     uv__write_int(error_fd, -errno);
     perror(""setgid()"");
    _exit(127);
  }

  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {
    uv__write_int(error_fd, -errno);
    perror(""setuid()"");
    _exit(127);
  }

  if (options->env != NULL) {
    environ = options->env;
  }

  execvp(options->file, options->args);
  uv__write_int(error_fd, -errno);
  perror(""execvp()"");
  _exit(127);
}
","static void uv__process_child_init(const uv_process_options_t* options,
                                   int stdio_count,
                                   int (*pipes)[2],
                                   int error_fd) {
  int close_fd;
  int use_fd;
  int fd;

  if (options->flags & UV_PROCESS_DETACHED)
    setsid();

  for (fd = 0; fd < stdio_count; fd++) {
    close_fd = pipes[fd][0];
    use_fd = pipes[fd][1];

    if (use_fd < 0) {
      if (fd >= 3)
        continue;
      else {
        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is
         * set
         */
        use_fd = open(""/dev/null"", fd == 0 ? O_RDONLY : O_RDWR);
        close_fd = use_fd;

        if (use_fd == -1) {
        uv__write_int(error_fd, -errno);
          perror(""failed to open stdio"");
          _exit(127);
        }
      }
    }

    if (fd == use_fd)
      uv__cloexec(use_fd, 0);
    else
      dup2(use_fd, fd);

    if (fd <= 2)
      uv__nonblock(fd, 0);

    if (close_fd != -1)
      uv__close(close_fd);
  }

  for (fd = 0; fd < stdio_count; fd++) {
    use_fd = pipes[fd][1];

    if (use_fd >= 0 && fd != use_fd)
      close(use_fd);
  }

  if (options->cwd != NULL && chdir(options->cwd)) {
    uv__write_int(error_fd, -errno);
    perror(""chdir()"");
     _exit(127);
   }
 
   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
     uv__write_int(error_fd, -errno);
     perror(""setgid()"");
    _exit(127);
  }

  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {
    uv__write_int(error_fd, -errno);
    perror(""setuid()"");
    _exit(127);
  }

  if (options->env != NULL) {
    environ = options->env;
  }

  execvp(options->file, options->args);
  uv__write_int(error_fd, -errno);
  perror(""execvp()"");
  _exit(127);
}
",C,"  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
    /* When dropping privileges from root, the `setgroups` call will
     * remove any extraneous groups. If we don't call this, then
     * even though our uid has dropped, we may still have groups
     * that enable us to do super-user things. This will fail if we
     * aren't root, so don't bother checking the return value, this
     * is just done as an optimistic privilege dropping function.
     */
    SAVE_ERRNO(setgroups(0, NULL));
  }

",,,"@@ -330,6 +330,17 @@ static void uv__process_child_init(const uv_process_options_t* options,
     _exit(127);
   }
 
+  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
+    /* When dropping privileges from root, the `setgroups` call will
+     * remove any extraneous groups. If we don't call this, then
+     * even though our uid has dropped, we may still have groups
+     * that enable us to do super-user things. This will fail if we
+     * aren't root, so don't bother checking the return value, this
+     * is just done as an optimistic privilege dropping function.
+     */
+    SAVE_ERRNO(setgroups(0, NULL));
+  }
+
   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
     uv__write_int(error_fd, -errno);
     perror(""setgid()"");",libuv,66ab38918c911bcff025562cf06237d7fedaba0c,3901ec49767a5b66bebe0a46cf851579f5f040c0,1,"static void uv__process_child_init(const uv_process_options_t* options,
                                   int stdio_count,
                                   int (*pipes)[2],
                                   int error_fd) {
  int close_fd;
  int use_fd;
  int fd;

  if (options->flags & UV_PROCESS_DETACHED)
    setsid();

  for (fd = 0; fd < stdio_count; fd++) {
    close_fd = pipes[fd][0];
    use_fd = pipes[fd][1];

    if (use_fd < 0) {
      if (fd >= 3)
        continue;
      else {
        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is
         * set
         */
        use_fd = open(""/dev/null"", fd == 0 ? O_RDONLY : O_RDWR);
        close_fd = use_fd;

        if (use_fd == -1) {
        uv__write_int(error_fd, -errno);
          perror(""failed to open stdio"");
          _exit(127);
        }
      }
    }

    if (fd == use_fd)
      uv__cloexec(use_fd, 0);
    else
      dup2(use_fd, fd);

    if (fd <= 2)
      uv__nonblock(fd, 0);

    if (close_fd != -1)
      uv__close(close_fd);
  }

  for (fd = 0; fd < stdio_count; fd++) {
    use_fd = pipes[fd][1];

    if (use_fd >= 0 && fd != use_fd)
      close(use_fd);
  }

  if (options->cwd != NULL && chdir(options->cwd)) {
    uv__write_int(error_fd, -errno);
    perror(""chdir()"");
     _exit(127);
   }
 
//fix_flaw_line_below:
//  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
//fix_flaw_line_below:
//    /* When dropping privileges from root, the `setgroups` call will
//fix_flaw_line_below:
//     * remove any extraneous groups. If we don't call this, then
//fix_flaw_line_below:
//     * even though our uid has dropped, we may still have groups
//fix_flaw_line_below:
//     * that enable us to do super-user things. This will fail if we
//fix_flaw_line_below:
//     * aren't root, so don't bother checking the return value, this
//fix_flaw_line_below:
//     * is just done as an optimistic privilege dropping function.
//fix_flaw_line_below:
//     */
//fix_flaw_line_below:
//    SAVE_ERRNO(setgroups(0, NULL));
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
     uv__write_int(error_fd, -errno);
     perror(""setgid()"");
    _exit(127);
  }

  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {
    uv__write_int(error_fd, -errno);
    perror(""setuid()"");
    _exit(127);
  }

  if (options->env != NULL) {
    environ = options->env;
  }

  execvp(options->file, options->args);
  uv__write_int(error_fd, -errno);
  perror(""execvp()"");
  _exit(127);
}
",179900,"static void uv__process_child_init(const uv_process_options_t* options,
                                   int stdio_count,
                                   int (*pipes)[2],
                                   int error_fd) {
  int close_fd;
  int use_fd;
  int fd;

  if (options->flags & UV_PROCESS_DETACHED)
    setsid();

  for (fd = 0; fd < stdio_count; fd++) {
    close_fd = pipes[fd][0];
    use_fd = pipes[fd][1];

    if (use_fd < 0) {
      if (fd >= 3)
        continue;
      else {
        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is
         * set
         */
        use_fd = open(""/dev/null"", fd == 0 ? O_RDONLY : O_RDWR);
        close_fd = use_fd;

        if (use_fd == -1) {
        uv__write_int(error_fd, -errno);
          perror(""failed to open stdio"");
          _exit(127);
        }
      }
    }

    if (fd == use_fd)
      uv__cloexec(use_fd, 0);
    else
      dup2(use_fd, fd);

    if (fd <= 2)
      uv__nonblock(fd, 0);

    if (close_fd != -1)
      uv__close(close_fd);
  }

  for (fd = 0; fd < stdio_count; fd++) {
    use_fd = pipes[fd][1];

    if (use_fd >= 0 && fd != use_fd)
      close(use_fd);
  }

  if (options->cwd != NULL && chdir(options->cwd)) {
    uv__write_int(error_fd, -errno);
    perror(""chdir()"");
     _exit(127);
   }
 
   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
     uv__write_int(error_fd, -errno);
     perror(""setgid()"");
    _exit(127);
  }

  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {
    uv__write_int(error_fd, -errno);
    perror(""setuid()"");
    _exit(127);
  }

  if (options->env != NULL) {
    environ = options->env;
  }

  execvp(options->file, options->args);
  uv__write_int(error_fd, -errno);
  perror(""execvp()"");
  _exit(127);
}
","static void uv__process_child_init(const uv_process_options_t* options,
                                   int stdio_count,
                                   int (*pipes)[2],
                                   int error_fd) {
  int close_fd;
  int use_fd;
  int fd;

  if (options->flags & UV_PROCESS_DETACHED)
    setsid();

  for (fd = 0; fd < stdio_count; fd++) {
    close_fd = pipes[fd][0];
    use_fd = pipes[fd][1];

    if (use_fd < 0) {
      if (fd >= 3)
        continue;
      else {
        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is
         * set
         */
        use_fd = open(""/dev/null"", fd == 0 ? O_RDONLY : O_RDWR);
        close_fd = use_fd;

        if (use_fd == -1) {
        uv__write_int(error_fd, -errno);
          perror(""failed to open stdio"");
          _exit(127);
        }
      }
    }

    if (fd == use_fd)
      uv__cloexec(use_fd, 0);
    else
      dup2(use_fd, fd);

    if (fd <= 2)
      uv__nonblock(fd, 0);

    if (close_fd != -1)
      uv__close(close_fd);
  }

  for (fd = 0; fd < stdio_count; fd++) {
    use_fd = pipes[fd][1];

    if (use_fd >= 0 && fd != use_fd)
      close(use_fd);
  }

  if (options->cwd != NULL && chdir(options->cwd)) {
    uv__write_int(error_fd, -errno);
    perror(""chdir()"");
     _exit(127);
   }
 
  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
    /* When dropping privileges from root, the `setgroups` call will
     * remove any extraneous groups. If we don't call this, then
     * even though our uid has dropped, we may still have groups
     * that enable us to do super-user things. This will fail if we
     * aren't root, so don't bother checking the return value, this
     * is just done as an optimistic privilege dropping function.
     */
    SAVE_ERRNO(setgroups(0, NULL));
  }

   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
     uv__write_int(error_fd, -errno);
     perror(""setgid()"");
    _exit(127);
  }

  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {
    uv__write_int(error_fd, -errno);
    perror(""setuid()"");
    _exit(127);
  }

  if (options->env != NULL) {
    environ = options->env;
  }

  execvp(options->file, options->args);
  uv__write_int(error_fd, -errno);
  perror(""execvp()"");
  _exit(127);
}
","The `uv__process_child_init` function initializes a child process based on the provided `uv_process_options_t` structure. It sets up standard input/output/error file descriptors, redirecting them to `/dev/null` if necessary, and handles process detachment by creating a new session. The function changes the working directory if specified, and sets the group and user IDs based on the options provided. It also updates the environment variables if specified. Finally, it attempts to execute a specified program using `execvp`, handling any errors by writing to an error file descriptor and terminating the process if execution fails.","The code initializes a child process by configuring its standard input, output, and error streams, redirecting them to a null device if necessary. It handles process detachment by creating a new session and changes the working directory if specified. Additionally, it sets the group and user IDs based on provided options and updates the environment variables if needed. Finally, the code attempts to execute a specified program, managing any errors by writing to an error descriptor and terminating the process if the execution fails, ensuring proper resource management throughout the process setup.","The vulnerability in the original code arises from the potential retention of extraneous group memberships when dropping privileges from a root user, which could allow unauthorized access to sensitive operations. Specifically, without calling `setgroups`, the process might still have access to elevated privileges through these groups even after changing the user ID with `setuid` or group ID with `setgid`. The fix introduces a call to `setgroups(0, NULL)` before changing the user or group IDs, effectively clearing any additional groups and ensuring that the process operates with the intended reduced privileges, thereby enhancing security.","The vulnerability in the original code stems from the failure to clear extraneous group memberships when a process drops privileges from a root user. This oversight could allow the process to retain access to elevated privileges through remaining group memberships, potentially leading to unauthorized actions. The fix addresses this issue by introducing a call to clear all group memberships before changing the user or group IDs. This ensures that once the process's privileges are reduced, it cannot regain elevated access through any lingering group affiliations, thereby enhancing the overall security of the privilege-dropping mechanism.","The vulnerability was fixed by adding a call to `setgroups(0, NULL)` before invoking `setuid` and `setgid`. This change ensures that all extraneous group memberships are cleared, preventing the process from retaining any elevated privileges that could be exploited after dropping user or group IDs. By executing `setgroups(0, NULL)`, the code optimistically removes any additional groups, thereby enforcing a stricter privilege model. This adjustment enhances security by ensuring that the process operates solely under the intended user and group IDs, mitigating the risk of unauthorized access to sensitive operations.","The vulnerability was addressed by introducing a mechanism to clear all extraneous group memberships before changing the user and group IDs. This adjustment ensures that when the process drops its privileges, it does not retain any elevated access through lingering group affiliations. By removing these additional groups, the process is restricted to the intended user and group privileges, thereby preventing unauthorized actions that could arise from retained access. This fix enhances the overall security of the privilege-dropping process, ensuring that the application operates with the minimum necessary permissions.","CWE-272, CWE-266, CWE-269, CWE-264, CWE-250, CWE-273, CWE-501, CWE-271, CWE-263, CWE-274",N,-1
45,45,179943,179943,,Local,Not required,,CVE-2014-9644,https://www.cvedetails.com/cve/CVE-2014-9644/,CWE-264,Low,,Partial,,2015-03-02,2.1,"The Crypto API in the Linux kernel before 3.18.5 allows local users to load arbitrary kernel modules via a bind system call for an AF_ALG socket with a parenthesized module template expression in the salg_name field, as demonstrated by the vfat(aes) expression, a different vulnerability than CVE-2013-7421.",2018-01-04,,2,https://github.com/torvalds/linux/commit/4943ba16bbc2db05115707b3ff7b4874e9e3c560,4943ba16bbc2db05115707b3ff7b4874e9e3c560,"crypto: include crypto- module prefix in template

This adds the module loading prefix ""crypto-"" to the template lookup
as well.

For example, attempting to load 'vfat(blowfish)' via AF_ALG now correctly
includes the ""crypto-"" prefix at every level, correctly rejecting ""vfat"":

	net-pf-38
	algif-hash
	crypto-vfat(blowfish)
	crypto-vfat(blowfish)-all
	crypto-vfat

Reported-by: Mathias Krause <minipli@googlemail.com>
Signed-off-by: Kees Cook <keescook@chromium.org>
Acked-by: Mathias Krause <minipli@googlemail.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",2,crypto/algapi.c,"{""sha"": ""f368ba261739fa09be28bc02fe34cf3112099fa8"", ""filename"": ""arch/x86/crypto/fpu.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/arch/x86/crypto/fpu.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/arch/x86/crypto/fpu.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/fpu.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -17,6 +17,7 @@\n #include <linux/kernel.h>\n #include <linux/module.h>\n #include <linux/slab.h>\n+#include <linux/crypto.h>\n #include <asm/i387.h>\n \n struct crypto_fpu_ctx {\n@@ -159,3 +160,5 @@ void __exit crypto_fpu_exit(void)\n {\n \tcrypto_unregister_template(&crypto_fpu_tmpl);\n }\n+\n+MODULE_ALIAS_CRYPTO(\""fpu\"");""}<_**next**_>{""sha"": ""71a8143e23b13390ec020ffb7f1168ae9ca285fc"", ""filename"": ""crypto/algapi.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/algapi.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/algapi.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/algapi.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -509,8 +509,8 @@ static struct crypto_template *__crypto_lookup_template(const char *name)\n \n struct crypto_template *crypto_lookup_template(const char *name)\n {\n-\treturn try_then_request_module(__crypto_lookup_template(name), \""%s\"",\n-\t\t\t\t       name);\n+\treturn try_then_request_module(__crypto_lookup_template(name),\n+\t\t\t\t       \""crypto-%s\"", name);\n }\n EXPORT_SYMBOL_GPL(crypto_lookup_template);\n ""}<_**next**_>{""sha"": ""78fb16cab13f9660553a0705941608ec3a59d88a"", ""filename"": ""crypto/authenc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/authenc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/authenc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/authenc.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -721,3 +721,4 @@ module_exit(crypto_authenc_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Simple AEAD wrapper for IPsec\"");\n+MODULE_ALIAS_CRYPTO(\""authenc\"");""}<_**next**_>{""sha"": ""024bff2344fcff9d0ae3af5c04b4a75280dd2d4a"", ""filename"": ""crypto/authencesn.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/authencesn.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/authencesn.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/authencesn.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -814,3 +814,4 @@ module_exit(crypto_authenc_esn_module_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Steffen Klassert <steffen.klassert@secunet.com>\"");\n MODULE_DESCRIPTION(\""AEAD wrapper for IPsec with extended sequence numbers\"");\n+MODULE_ALIAS_CRYPTO(\""authencesn\"");""}<_**next**_>{""sha"": ""780ee27b2d43d5f3620d32c4df6c00670b6c48c8"", ""filename"": ""crypto/cbc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cbc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cbc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cbc.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -289,3 +289,4 @@ module_exit(crypto_cbc_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CBC block cipher algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""cbc\"");""}<_**next**_>{""sha"": ""003bbbd21a2ba9a24f4207f20037d5ee75593726"", ""filename"": ""crypto/ccm.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/ccm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/ccm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ccm.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -881,3 +881,4 @@ MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Counter with CBC MAC\"");\n MODULE_ALIAS_CRYPTO(\""ccm_base\"");\n MODULE_ALIAS_CRYPTO(\""rfc4309\"");\n+MODULE_ALIAS_CRYPTO(\""ccm\"");""}<_**next**_>{""sha"": ""63c17d5992f79b5a5ed40a526fa58a532eb3e5dc"", ""filename"": ""crypto/chainiv.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/chainiv.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/chainiv.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/chainiv.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -359,3 +359,4 @@ module_exit(chainiv_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Chain IV Generator\"");\n+MODULE_ALIAS_CRYPTO(\""chainiv\"");""}<_**next**_>{""sha"": ""7a8bfbd548f60835fbf417ab96e43b749a5d283f"", ""filename"": ""crypto/cmac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cmac.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cmac.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cmac.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -313,3 +313,4 @@ module_exit(crypto_cmac_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CMAC keyed hash algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""cmac\"");""}<_**next**_>{""sha"": ""650afac10fd78e5ba51a28d7161ee71bcd6f3175"", ""filename"": ""crypto/cryptd.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cryptd.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cryptd.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cryptd.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -955,3 +955,4 @@ module_exit(cryptd_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Software async crypto daemon\"");\n+MODULE_ALIAS_CRYPTO(\""cryptd\"");""}<_**next**_>{""sha"": ""2386f731395207a2432d782d10c1421a0577dff3"", ""filename"": ""crypto/ctr.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/ctr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/ctr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ctr.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -467,3 +467,4 @@ module_exit(crypto_ctr_module_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CTR Counter block mode\"");\n MODULE_ALIAS_CRYPTO(\""rfc3686\"");\n+MODULE_ALIAS_CRYPTO(\""ctr\"");""}<_**next**_>{""sha"": ""bd9405820e8ac5ade61d6d6793ec18510d456ad9"", ""filename"": ""crypto/cts.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cts.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/cts.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cts.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -351,3 +351,4 @@ module_exit(crypto_cts_module_exit);\n \n MODULE_LICENSE(\""Dual BSD/GPL\"");\n MODULE_DESCRIPTION(\""CTS-CBC CipherText Stealing for CBC\"");\n+MODULE_ALIAS_CRYPTO(\""cts\"");""}<_**next**_>{""sha"": ""12011aff097136331f5aca539acb487746efcd69"", ""filename"": ""crypto/ecb.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/ecb.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/ecb.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ecb.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -185,3 +185,4 @@ module_exit(crypto_ecb_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""ECB block cipher algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""ecb\"");""}<_**next**_>{""sha"": ""f116fae766f81611c5530a6d92313c5e88d23fe1"", ""filename"": ""crypto/eseqiv.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/eseqiv.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/eseqiv.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/eseqiv.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -267,3 +267,4 @@ module_exit(eseqiv_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Encrypted Sequence Number IV Generator\"");\n+MODULE_ALIAS_CRYPTO(\""eseqiv\"");""}<_**next**_>{""sha"": ""2e403f6138c14bbcb048d59256f0fb40e2032f2d"", ""filename"": ""crypto/gcm.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/gcm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/gcm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/gcm.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -1444,3 +1444,4 @@ MODULE_AUTHOR(\""Mikko Herranen <mh1@iki.fi>\"");\n MODULE_ALIAS_CRYPTO(\""gcm_base\"");\n MODULE_ALIAS_CRYPTO(\""rfc4106\"");\n MODULE_ALIAS_CRYPTO(\""rfc4543\"");\n+MODULE_ALIAS_CRYPTO(\""gcm\"");""}<_**next**_>{""sha"": ""72e38c098bb3184d3886ac4054f123dca3bb49ac"", ""filename"": ""crypto/hmac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/hmac.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/hmac.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/hmac.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -268,3 +268,4 @@ module_exit(hmac_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""HMAC hash algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""hmac\"");""}<_**next**_>{""sha"": ""6f9908a7ebcbe19f76a4ee306f326f291aff8de9"", ""filename"": ""crypto/lrw.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/lrw.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/lrw.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lrw.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -400,3 +400,4 @@ module_exit(crypto_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LRW block cipher mode\"");\n+MODULE_ALIAS_CRYPTO(\""lrw\"");""}<_**next**_>{""sha"": ""a8e870444ea9cef0ab4a2c6c919724905c7dbde7"", ""filename"": ""crypto/mcryptd.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/mcryptd.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/mcryptd.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/mcryptd.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -703,3 +703,4 @@ module_exit(mcryptd_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Software async multibuffer crypto daemon\"");\n+MODULE_ALIAS_CRYPTO(\""mcryptd\"");""}<_**next**_>{""sha"": ""f654965f09338dab066795d8c6ab8618ef263d93"", ""filename"": ""crypto/pcbc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/pcbc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/pcbc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/pcbc.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -295,3 +295,4 @@ module_exit(crypto_pcbc_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""PCBC block cipher algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""pcbc\"");""}<_**next**_>{""sha"": ""c305d4112735cd3b7b18b477299b534b8c0e1b77"", ""filename"": ""crypto/pcrypt.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/pcrypt.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/pcrypt.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/pcrypt.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -565,3 +565,4 @@ module_exit(pcrypt_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Steffen Klassert <steffen.klassert@secunet.com>\"");\n MODULE_DESCRIPTION(\""Parallel crypto wrapper\"");\n+MODULE_ALIAS_CRYPTO(\""pcrypt\"");""}<_**next**_>{""sha"": ""9daa854cc485b61e97eb7b25ead68da14a47ce88"", ""filename"": ""crypto/seqiv.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/seqiv.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/seqiv.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/seqiv.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -362,3 +362,4 @@ module_exit(seqiv_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Sequence Number IV Generator\"");\n+MODULE_ALIAS_CRYPTO(\""seqiv\"");""}<_**next**_>{""sha"": ""df76a816cfb22f68ac173d3ef01e2e2f9e166c72"", ""filename"": ""crypto/vmac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/vmac.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/vmac.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/vmac.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -713,3 +713,4 @@ module_exit(vmac_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""VMAC hash algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""vmac\"");""}<_**next**_>{""sha"": ""df90b332554cf43fb595623af3e854534a9dc49b"", ""filename"": ""crypto/xcbc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/xcbc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/xcbc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/xcbc.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -286,3 +286,4 @@ module_exit(crypto_xcbc_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""XCBC keyed hash algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""xcbc\"");""}<_**next**_>{""sha"": ""f6fd43f100c8c68c7150cad5224fafc5dc61db2c"", ""filename"": ""crypto/xts.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/xts.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4943ba16bbc2db05115707b3ff7b4874e9e3c560/crypto/xts.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/xts.c?ref=4943ba16bbc2db05115707b3ff7b4874e9e3c560"", ""patch"": ""@@ -362,3 +362,4 @@ module_exit(crypto_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""XTS block cipher mode\"");\n+MODULE_ALIAS_CRYPTO(\""xts\"");""}"," struct crypto_template *crypto_lookup_template(const char *name)
 {
	return try_then_request_module(__crypto_lookup_template(name),
				       ""crypto-%s"", name);
 }
"," struct crypto_template *crypto_lookup_template(const char *name)
 {
	return try_then_request_module(__crypto_lookup_template(name), ""%s"",
				       name);
 }
",C,"	return try_then_request_module(__crypto_lookup_template(name),
				       ""crypto-%s"", name);
","	return try_then_request_module(__crypto_lookup_template(name), ""%s"",
				       name);
",,"@@ -509,8 +509,8 @@ static struct crypto_template *__crypto_lookup_template(const char *name)
 
 struct crypto_template *crypto_lookup_template(const char *name)
 {
-	return try_then_request_module(__crypto_lookup_template(name), ""%s"",
-				       name);
+	return try_then_request_module(__crypto_lookup_template(name),
+				       ""crypto-%s"", name);
 }
 EXPORT_SYMBOL_GPL(crypto_lookup_template);
 ",linux,4943ba16bbc2db05115707b3ff7b4874e9e3c560,476c7fe20f30818e16339391aeeb01b29818f708,1," struct crypto_template *crypto_lookup_template(const char *name)
 {
//flaw_line_below:
	return try_then_request_module(__crypto_lookup_template(name), ""%s"",
//flaw_line_below:
				       name);
//fix_flaw_line_below:
//	return try_then_request_module(__crypto_lookup_template(name),
//fix_flaw_line_below:
//				       ""crypto-%s"", name);
 }
",179943," struct crypto_template *crypto_lookup_template(const char *name)
 {
	return try_then_request_module(__crypto_lookup_template(name), ""%s"",
				       name);
 }
"," struct crypto_template *crypto_lookup_template(const char *name)
 {
	return try_then_request_module(__crypto_lookup_template(name),
				       ""crypto-%s"", name);
 }
","The provided code defines a function `crypto_lookup_template` that takes a string parameter `name`, representing the name of a cryptographic template. It calls another function, `__crypto_lookup_template`, to attempt to retrieve the corresponding cryptographic template structure. If the lookup fails, it uses the `try_then_request_module` macro to request the loading of the necessary module associated with the template, ensuring that the module is available for use. The function ultimately returns a pointer to the `crypto_template` structure, which contains the details of the requested cryptographic template, or NULL if the template cannot be found.","The code defines a function that retrieves a cryptographic template based on a specified name. It attempts to find the template and, if unsuccessful, requests the loading of the necessary module to ensure the template is available. This approach allows the function to handle cases where the template might not be immediately accessible, facilitating dynamic module loading as needed. The function ultimately returns a pointer to the structure representing the cryptographic template, enabling further operations with the template if it is found or indicating failure if it is not available.","The vulnerability in the original code stemmed from the lack of a module loading prefix when looking up cryptographic templates, which could lead to incorrect template resolution. Specifically, when attempting to load a template like 'vfat(blowfish)', the absence of the ""crypto-"" prefix resulted in the system failing to find the correct module, potentially allowing for unintended behavior or security issues. The fix introduced a ""crypto-"" prefix in the `try_then_request_module` function call, ensuring that all template lookups are correctly prefixed, thereby improving the accuracy of module loading and preventing incorrect template resolutions.","The vulnerability in the original code arose from the omission of a specific prefix when looking up cryptographic templates, which could lead to incorrect module resolution and potential security risks. Without the prefix, the system might attempt to load modules that do not correspond to the intended cryptographic functionality, resulting in failures or unintended behavior. The fix addressed this issue by incorporating the necessary prefix into the template lookup process, ensuring that all relevant modules are correctly identified and loaded. This change enhances the accuracy of module resolution, thereby preventing the loading of incorrect or unintended modules.","The vulnerability was fixed by modifying the `try_then_request_module` function call to include the ""crypto-"" prefix in the template lookup process. In the updated code, the string passed to the function now correctly formats the module name as ""crypto-%s"", ensuring that any template lookup, such as for 'vfat(blowfish)', is prefixed appropriately. This change guarantees that the system searches for the correct module names, such as ""crypto-vfat(blowfish)"", thereby preventing incorrect resolutions and enhancing the overall security and functionality of the cryptographic template loading mechanism.","The vulnerability was addressed by incorporating a specific prefix into the module lookup process for cryptographic templates. This adjustment ensures that all template names are correctly formatted to include the necessary prefix, which aligns with the expected naming conventions for cryptographic modules. By doing so, the system can accurately identify and load the appropriate modules, preventing the potential for incorrect resolutions that could lead to security issues or unintended behavior. This fix enhances the reliability of the module loading mechanism, ensuring that only the intended cryptographic functionalities are accessed.","CWE-1104, CWE-502, CWE-116, CWE-99, CWE-426, CWE-441, CWE-440, CWE-835, CWE-94, CWE-23",N,-1
46,46,180011,180011,,Local,Not required,,CVE-2013-7421,https://www.cvedetails.com/cve/CVE-2013-7421/,CWE-264,Low,,Partial,,2015-03-02,2.1,"The Crypto API in the Linux kernel before 3.18.5 allows local users to load arbitrary kernel modules via a bind system call for an AF_ALG socket with a module name in the salg_name field, a different vulnerability than CVE-2014-9644.",2018-01-04,,2,https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b,5d26a105b5a73e5635eae0629b42fa0a90e07b7b,"crypto: prefix module autoloading with ""crypto-""

This prefixes all crypto module loading with ""crypto-"" so we never run
the risk of exposing module auto-loading to userspace via a crypto API,
as demonstrated by Mathias Krause:

https://lkml.org/lkml/2013/3/4/70

Signed-off-by: Kees Cook <keescook@chromium.org>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",2,crypto/api.c,"{""sha"": ""0409b8f897823f815af5581f0c9a73e29f80eaf8"", ""filename"": ""arch/arm/crypto/aes_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/aes_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/aes_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/aes_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -93,6 +93,6 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm (ASM)\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""aes\"");\n-MODULE_ALIAS(\""aes-asm\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes-asm\"");\n MODULE_AUTHOR(\""David McCullough <ucdevel@gmail.com>\"");""}<_**next**_>{""sha"": ""e31b0440c6139dc932b0efd4b98aaab077cb862d"", ""filename"": ""arch/arm/crypto/sha1_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/sha1_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -171,5 +171,5 @@ module_exit(sha1_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm (ARM)\"");\n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");\n MODULE_AUTHOR(\""David McCullough <ucdevel@gmail.com>\"");""}<_**next**_>{""sha"": ""0b0083757d477f4aef8bca9e82cfb155b6eecbfb"", ""filename"": ""arch/arm/crypto/sha1_neon_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_neon_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_neon_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/sha1_neon_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -194,4 +194,4 @@ module_exit(sha1_neon_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm, NEON accelerated\"");\n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");""}<_**next**_>{""sha"": ""f3452c66059d57a045b0de6d4b6de6d242cb480c"", ""filename"": ""arch/arm/crypto/sha512_neon_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha512_neon_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha512_neon_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/sha512_neon_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -301,5 +301,5 @@ module_exit(sha512_neon_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA512 Secure Hash Algorithm, NEON accelerated\"");\n \n-MODULE_ALIAS(\""sha512\"");\n-MODULE_ALIAS(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");""}<_**next**_>{""sha"": ""0156a268e163f63e0f352a2dc91efe14adf0526c"", ""filename"": ""arch/arm64/crypto/aes-ce-ccm-glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-ce-ccm-glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-ce-ccm-glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm64/crypto/aes-ce-ccm-glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -294,4 +294,4 @@ module_exit(aes_mod_exit);\n MODULE_DESCRIPTION(\""Synchronous AES in CCM mode using ARMv8 Crypto Extensions\"");\n MODULE_AUTHOR(\""Ard Biesheuvel <ard.biesheuvel@linaro.org>\"");\n MODULE_LICENSE(\""GPL v2\"");\n-MODULE_ALIAS(\""ccm(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""ccm(aes)\"");""}<_**next**_>{""sha"": ""5f63a791b2fb58b6ae93a49c7dceca14421e0c12"", ""filename"": ""arch/arm64/crypto/aes-glue.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm64/crypto/aes-glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -38,10 +38,10 @@ MODULE_DESCRIPTION(\""AES-ECB/CBC/CTR/XTS using ARMv8 Crypto Extensions\"");\n #define aes_xts_encrypt\t\tneon_aes_xts_encrypt\n #define aes_xts_decrypt\t\tneon_aes_xts_decrypt\n MODULE_DESCRIPTION(\""AES-ECB/CBC/CTR/XTS using ARMv8 NEON\"");\n-MODULE_ALIAS(\""ecb(aes)\"");\n-MODULE_ALIAS(\""cbc(aes)\"");\n-MODULE_ALIAS(\""ctr(aes)\"");\n-MODULE_ALIAS(\""xts(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""ecb(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""cbc(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""ctr(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""xts(aes)\"");\n #endif\n \n MODULE_AUTHOR(\""Ard Biesheuvel <ard.biesheuvel@linaro.org>\"");""}<_**next**_>{""sha"": ""0f88c7b411196beeb3eb9d717ea24bf0cc958f00"", ""filename"": ""arch/powerpc/crypto/sha1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/powerpc/crypto/sha1.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/powerpc/crypto/sha1.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/powerpc/crypto/sha1.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -154,4 +154,4 @@ module_exit(sha1_powerpc_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm\"");\n \n-MODULE_ALIAS(\""sha1-powerpc\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-powerpc\"");""}<_**next**_>{""sha"": ""1f272b24fc0bf9393d44939ea2b225a84e36ea2a"", ""filename"": ""arch/s390/crypto/aes_s390.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/aes_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/aes_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/aes_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -979,7 +979,7 @@ static void __exit aes_s390_fini(void)\n module_init(aes_s390_init);\n module_exit(aes_s390_fini);\n \n-MODULE_ALIAS(\""aes-all\"");\n+MODULE_ALIAS_CRYPTO(\""aes-all\"");\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm\"");\n MODULE_LICENSE(\""GPL\"");""}<_**next**_>{""sha"": ""9e05cc453a40d5fd946ecf56f1063f2446812695"", ""filename"": ""arch/s390/crypto/des_s390.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/des_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/des_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/des_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -619,8 +619,8 @@ static void __exit des_s390_exit(void)\n module_init(des_s390_init);\n module_exit(des_s390_exit);\n \n-MODULE_ALIAS(\""des\"");\n-MODULE_ALIAS(\""des3_ede\"");\n+MODULE_ALIAS_CRYPTO(\""des\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede\"");\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""DES & Triple DES EDE Cipher Algorithms\"");""}<_**next**_>{""sha"": ""7940dc90e80bc6729371ab565bad743b1087ef72"", ""filename"": ""arch/s390/crypto/ghash_s390.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/ghash_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/ghash_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/ghash_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -160,7 +160,7 @@ static void __exit ghash_mod_exit(void)\n module_init(ghash_mod_init);\n module_exit(ghash_mod_exit);\n \n-MODULE_ALIAS(\""ghash\"");\n+MODULE_ALIAS_CRYPTO(\""ghash\"");\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""GHASH Message Digest Algorithm, s390 implementation\"");""}<_**next**_>{""sha"": ""5b2bee323694b2144c382dd9af85126b81b311a8"", ""filename"": ""arch/s390/crypto/sha1_s390.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha1_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha1_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/sha1_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -103,6 +103,6 @@ static void __exit sha1_s390_fini(void)\n module_init(sha1_s390_init);\n module_exit(sha1_s390_fini);\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm\"");""}<_**next**_>{""sha"": ""b74ff158108c9421a25b26a02f3a1f1669d1f69d"", ""filename"": ""arch/s390/crypto/sha256_s390.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha256_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha256_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/sha256_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -143,7 +143,7 @@ static void __exit sha256_s390_fini(void)\n module_init(sha256_s390_init);\n module_exit(sha256_s390_fini);\n \n-MODULE_ALIAS(\""sha256\"");\n-MODULE_ALIAS(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA256 and SHA224 Secure Hash Algorithm\"");""}<_**next**_>{""sha"": ""0c36989ba182b1e411b56c3018ab610622cfe6ff"", ""filename"": ""arch/s390/crypto/sha512_s390.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha512_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha512_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/sha512_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -86,7 +86,7 @@ static struct shash_alg sha512_alg = {\n \t}\n };\n \n-MODULE_ALIAS(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n \n static int sha384_init(struct shash_desc *desc)\n {\n@@ -126,7 +126,7 @@ static struct shash_alg sha384_alg = {\n \t}\n };\n \n-MODULE_ALIAS(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");\n \n static int __init init(void)\n {""}<_**next**_>{""sha"": ""705408766ab0c07adcdd3d9e12c69b3bd3a9a20b"", ""filename"": ""arch/sparc/crypto/aes_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/aes_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/aes_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/aes_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -499,6 +499,6 @@ module_exit(aes_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""AES Secure Hash Algorithm, sparc64 aes opcode accelerated\"");\n \n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""641f55cb61c3a89a9a8eabe12577170a6e62e572"", ""filename"": ""arch/sparc/crypto/camellia_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/camellia_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/camellia_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/camellia_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -322,6 +322,6 @@ module_exit(camellia_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, sparc64 camellia opcode accelerated\"");\n \n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""d1064e46efe8bea0b83d573e4b6eb0e35aef3596"", ""filename"": ""arch/sparc/crypto/crc32c_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/crc32c_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/crc32c_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/crc32c_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -176,6 +176,6 @@ module_exit(crc32c_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CRC32c (Castagnoli), sparc64 crc32c opcode accelerated\"");\n \n-MODULE_ALIAS(\""crc32c\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""d1150097299479224e99f143e6657422cd4db157"", ""filename"": ""arch/sparc/crypto/des_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/des_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/des_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/des_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -532,6 +532,6 @@ module_exit(des_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""DES & Triple DES EDE Cipher Algorithms, sparc64 des opcode accelerated\"");\n \n-MODULE_ALIAS(\""des\"");\n+MODULE_ALIAS_CRYPTO(\""des\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""64c7ff5f72a9f68fd19832eb6d4238e05b80c114"", ""filename"": ""arch/sparc/crypto/md5_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/md5_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/md5_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/md5_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -185,6 +185,6 @@ module_exit(md5_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""MD5 Secure Hash Algorithm, sparc64 md5 opcode accelerated\"");\n \n-MODULE_ALIAS(\""md5\"");\n+MODULE_ALIAS_CRYPTO(\""md5\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""1b3e47accc7466a90fb5729321df4e48273d7f31"", ""filename"": ""arch/sparc/crypto/sha1_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha1_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha1_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/sha1_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -180,6 +180,6 @@ module_exit(sha1_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm, sparc64 sha1 opcode accelerated\"");\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""41f27cca2a225ffd2d9d1bcd301e72287c3d42ae"", ""filename"": ""arch/sparc/crypto/sha256_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha256_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha256_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/sha256_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -237,7 +237,7 @@ module_exit(sha256_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-224 and SHA-256 Secure Hash Algorithm, sparc64 sha256 opcode accelerated\"");\n \n-MODULE_ALIAS(\""sha224\"");\n-MODULE_ALIAS(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""9fff88541b8c0fabedba624d9c135926eff64fb8"", ""filename"": ""arch/sparc/crypto/sha512_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha512_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha512_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/sha512_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -222,7 +222,7 @@ module_exit(sha512_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-384 and SHA-512 Secure Hash Algorithm, sparc64 sha512 opcode accelerated\"");\n \n-MODULE_ALIAS(\""sha384\"");\n-MODULE_ALIAS(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""e26984f7ab8d2fa838168be1893c5eacdc375d33"", ""filename"": ""arch/x86/crypto/aes_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aes_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aes_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/aes_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -66,5 +66,5 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm, asm optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""aes\"");\n-MODULE_ALIAS(\""aes-asm\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes-asm\"");""}<_**next**_>{""sha"": ""ae855f4f64b7755410701753f79608d0408880f9"", ""filename"": ""arch/x86/crypto/aesni-intel_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aesni-intel_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aesni-intel_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/aesni-intel_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1546,4 +1546,4 @@ module_exit(aesni_exit);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm, Intel AES-NI instructions optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");""}<_**next**_>{""sha"": ""17c05531dfd1752234eb9b6835f848b12ed07817"", ""filename"": ""arch/x86/crypto/blowfish_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/blowfish_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/blowfish_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/blowfish_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -478,5 +478,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Blowfish Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""blowfish\"");\n-MODULE_ALIAS(\""blowfish-asm\"");\n+MODULE_ALIAS_CRYPTO(\""blowfish\"");\n+MODULE_ALIAS_CRYPTO(\""blowfish-asm\"");""}<_**next**_>{""sha"": ""9a07fafe3831394c86da42758d3a1407628f03ab"", ""filename"": ""arch/x86/crypto/camellia_aesni_avx2_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx2_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx2_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/camellia_aesni_avx2_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -582,5 +582,5 @@ module_exit(camellia_aesni_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, AES-NI/AVX2 optimized\"");\n-MODULE_ALIAS(\""camellia\"");\n-MODULE_ALIAS(\""camellia-asm\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia-asm\"");""}<_**next**_>{""sha"": ""ed38d959add6a8aa09f3e32285de6372eea3a7e8"", ""filename"": ""arch/x86/crypto/camellia_aesni_avx_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/camellia_aesni_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -574,5 +574,5 @@ module_exit(camellia_aesni_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, AES-NI/AVX optimized\"");\n-MODULE_ALIAS(\""camellia\"");\n-MODULE_ALIAS(\""camellia-asm\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia-asm\"");""}<_**next**_>{""sha"": ""5c8b6266a394b45d4317d91b05adb6cc12b15219"", ""filename"": ""arch/x86/crypto/camellia_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/camellia_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1725,5 +1725,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""camellia\"");\n-MODULE_ALIAS(\""camellia-asm\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia-asm\"");""}<_**next**_>{""sha"": ""60ada677a92874e7d24fe00f1f309ce9c9a9a8bf"", ""filename"": ""arch/x86/crypto/cast5_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast5_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast5_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/cast5_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -491,4 +491,4 @@ module_exit(cast5_exit);\n \n MODULE_DESCRIPTION(\""Cast5 Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""cast5\"");\n+MODULE_ALIAS_CRYPTO(\""cast5\"");""}<_**next**_>{""sha"": ""0160f68a57ff33113c1a1b030d7919b56d86669e"", ""filename"": ""arch/x86/crypto/cast6_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast6_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast6_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/cast6_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -611,4 +611,4 @@ module_exit(cast6_exit);\n \n MODULE_DESCRIPTION(\""Cast6 Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""cast6\"");\n+MODULE_ALIAS_CRYPTO(\""cast6\"");""}<_**next**_>{""sha"": ""1937fc1d876338aa0aa9bb5fddea9e0aa3541707"", ""filename"": ""arch/x86/crypto/crc32-pclmul_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32-pclmul_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32-pclmul_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/crc32-pclmul_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -197,5 +197,5 @@ module_exit(crc32_pclmul_mod_fini);\n MODULE_AUTHOR(\""Alexander Boyko <alexander_boyko@xyratex.com>\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""crc32\"");\n-MODULE_ALIAS(\""crc32-pclmul\"");\n+MODULE_ALIAS_CRYPTO(\""crc32\"");\n+MODULE_ALIAS_CRYPTO(\""crc32-pclmul\"");""}<_**next**_>{""sha"": ""28640c3d6af7f6172a8fe39d4553c98019614e24"", ""filename"": ""arch/x86/crypto/crc32c-intel_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32c-intel_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32c-intel_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/crc32c-intel_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -280,5 +280,5 @@ MODULE_AUTHOR(\""Austin Zhang <austin.zhang@intel.com>, Kent Liu <kent.liu@intel.c\n MODULE_DESCRIPTION(\""CRC32c (Castagnoli) optimization using Intel Hardware.\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""crc32c\"");\n-MODULE_ALIAS(\""crc32c-intel\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c-intel\"");""}<_**next**_>{""sha"": ""b6c67bf30fdf6704f6d83b093ee73ae7d9b77fcf"", ""filename"": ""arch/x86/crypto/crct10dif-pclmul_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crct10dif-pclmul_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crct10dif-pclmul_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/crct10dif-pclmul_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -147,5 +147,5 @@ MODULE_AUTHOR(\""Tim Chen <tim.c.chen@linux.intel.com>\"");\n MODULE_DESCRIPTION(\""T10 DIF CRC calculation accelerated with PCLMULQDQ.\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""crct10dif\"");\n-MODULE_ALIAS(\""crct10dif-pclmul\"");\n+MODULE_ALIAS_CRYPTO(\""crct10dif\"");\n+MODULE_ALIAS_CRYPTO(\""crct10dif-pclmul\"");""}<_**next**_>{""sha"": ""38a14f818ef13f27cf7a7bb4b1de4064fbedf3f4"", ""filename"": ""arch/x86/crypto/des3_ede_glue.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/des3_ede_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/des3_ede_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/des3_ede_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -502,8 +502,8 @@ module_exit(des3_ede_x86_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Triple DES EDE Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""des3_ede\"");\n-MODULE_ALIAS(\""des3_ede-asm\"");\n-MODULE_ALIAS(\""des\"");\n-MODULE_ALIAS(\""des-asm\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede-asm\"");\n+MODULE_ALIAS_CRYPTO(\""des\"");\n+MODULE_ALIAS_CRYPTO(\""des-asm\"");\n MODULE_AUTHOR(\""Jussi Kivilinna <jussi.kivilinna@iki.fi>\"");""}<_**next**_>{""sha"": ""8253d85aa16508f19249e1f3cee91356c565d1e3"", ""filename"": ""arch/x86/crypto/ghash-clmulni-intel_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/ghash-clmulni-intel_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/ghash-clmulni-intel_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/ghash-clmulni-intel_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -341,4 +341,4 @@ module_exit(ghash_pclmulqdqni_mod_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""GHASH Message Digest Algorithm, \""\n \t\t   \""acclerated by PCLMULQDQ-NI\"");\n-MODULE_ALIAS(\""ghash\"");\n+MODULE_ALIAS_CRYPTO(\""ghash\"");""}<_**next**_>{""sha"": ""399a29d067d6367603714633fb8c4de6ab77275a"", ""filename"": ""arch/x86/crypto/salsa20_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/salsa20_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/salsa20_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/salsa20_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -119,5 +119,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Salsa20 stream cipher algorithm (optimized assembly version)\"");\n-MODULE_ALIAS(\""salsa20\"");\n-MODULE_ALIAS(\""salsa20-asm\"");\n+MODULE_ALIAS_CRYPTO(\""salsa20\"");\n+MODULE_ALIAS_CRYPTO(\""salsa20-asm\"");""}<_**next**_>{""sha"": ""437e47a4d302f584dfbeb3fef6ab76fc6e39008a"", ""filename"": ""arch/x86/crypto/serpent_avx2_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx2_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx2_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/serpent_avx2_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -558,5 +558,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Serpent Cipher Algorithm, AVX2 optimized\"");\n-MODULE_ALIAS(\""serpent\"");\n-MODULE_ALIAS(\""serpent-asm\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""serpent-asm\"");""}<_**next**_>{""sha"": ""7e217398b4eb1d4656f59b1a90f707bd6028fe94"", ""filename"": ""arch/x86/crypto/serpent_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/serpent_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -617,4 +617,4 @@ module_exit(serpent_exit);\n \n MODULE_DESCRIPTION(\""Serpent Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");""}<_**next**_>{""sha"": ""bf025adaea01bba090a09867490bd960a7674290"", ""filename"": ""arch/x86/crypto/serpent_sse2_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_sse2_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_sse2_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/serpent_sse2_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -618,4 +618,4 @@ module_exit(serpent_sse2_exit);\n \n MODULE_DESCRIPTION(\""Serpent Cipher Algorithm, SSE2 optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");""}<_**next**_>{""sha"": ""6c20fe04a738df08e5428fb714e7c93770fcf748"", ""filename"": ""arch/x86/crypto/sha1_ssse3_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha1_ssse3_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha1_ssse3_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/sha1_ssse3_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -278,4 +278,4 @@ module_exit(sha1_ssse3_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm, Supplemental SSE3 accelerated\"");\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");""}<_**next**_>{""sha"": ""4dc100d829025d86fcb2f5dc4d90148cd8db4270"", ""filename"": ""arch/x86/crypto/sha256_ssse3_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha256_ssse3_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha256_ssse3_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/sha256_ssse3_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -318,5 +318,5 @@ module_exit(sha256_ssse3_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA256 Secure Hash Algorithm, Supplemental SSE3 accelerated\"");\n \n-MODULE_ALIAS(\""sha256\"");\n-MODULE_ALIAS(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");""}<_**next**_>{""sha"": ""26a5898a6f2662c0407eb7bc0e20eadb08a03107"", ""filename"": ""arch/x86/crypto/sha512_ssse3_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha512_ssse3_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha512_ssse3_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/sha512_ssse3_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -326,5 +326,5 @@ module_exit(sha512_ssse3_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA512 Secure Hash Algorithm, Supplemental SSE3 accelerated\"");\n \n-MODULE_ALIAS(\""sha512\"");\n-MODULE_ALIAS(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");""}<_**next**_>{""sha"": ""1ac531ea9bccca4d4eca5af299e54ff2bd6aa514"", ""filename"": ""arch/x86/crypto/twofish_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/twofish_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -579,4 +579,4 @@ module_exit(twofish_exit);\n \n MODULE_DESCRIPTION(\""Twofish Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");""}<_**next**_>{""sha"": ""77e06c2da83d0ec5a9e468759727c0c25baca5b5"", ""filename"": ""arch/x86/crypto/twofish_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/twofish_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -96,5 +96,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Twofish Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""twofish\"");\n-MODULE_ALIAS(\""twofish-asm\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish-asm\"");""}<_**next**_>{""sha"": ""56d8a08ee47908d06c80975428655629b5749c24"", ""filename"": ""arch/x86/crypto/twofish_glue_3way.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue_3way.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue_3way.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/twofish_glue_3way.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -495,5 +495,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Twofish Cipher Algorithm, 3-way parallel asm optimized\"");\n-MODULE_ALIAS(\""twofish\"");\n-MODULE_ALIAS(\""twofish-asm\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish-asm\"");""}<_**next**_>{""sha"": ""b48f4f108c474104d484ceb316099ef78b20f5d3"", ""filename"": ""crypto/842.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/842.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/842.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/842.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -180,3 +180,4 @@ module_exit(nx842_mod_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""842 Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""842\"");""}<_**next**_>{""sha"": ""9b3c54c1cbe826a8cb031a9affb9079f0961d1c4"", ""filename"": ""crypto/aes_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/aes_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/aes_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/aes_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1474,4 +1474,4 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm\"");\n MODULE_LICENSE(\""Dual BSD/GPL\"");\n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");""}<_**next**_>{""sha"": ""b4485a108389a2f13b0ca28949e4f6b932818277"", ""filename"": ""crypto/ansi_cprng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ansi_cprng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ansi_cprng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ansi_cprng.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -476,4 +476,4 @@ module_param(dbg, int, 0);\n MODULE_PARM_DESC(dbg, \""Boolean to enable debugging (0/1 == off/on)\"");\n module_init(prng_mod_init);\n module_exit(prng_mod_fini);\n-MODULE_ALIAS(\""stdrng\"");\n+MODULE_ALIAS_CRYPTO(\""stdrng\"");""}<_**next**_>{""sha"": ""4bb187c2a9027bab28e82370bd54f128602a25f1"", ""filename"": ""crypto/anubis.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/anubis.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/anubis.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/anubis.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -704,3 +704,4 @@ module_exit(anubis_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Anubis Cryptographic Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""anubis\"");""}<_**next**_>{""sha"": ""2a81e98a0021074b9ce8e2ac54eb876c1dcf7607"", ""filename"": ""crypto/api.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/api.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/api.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/api.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -216,11 +216,11 @@ struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)\n \n \talg = crypto_alg_lookup(name, type, mask);\n \tif (!alg) {\n-\t\trequest_module(\""%s\"", name);\n+\t\trequest_module(\""crypto-%s\"", name);\n \n \t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n \t\t      CRYPTO_ALG_NEED_FALLBACK))\n-\t\t\trequest_module(\""%s-all\"", name);\n+\t\t\trequest_module(\""crypto-%s-all\"", name);\n \n \t\talg = crypto_alg_lookup(name, type, mask);\n \t}""}<_**next**_>{""sha"": ""f1a81925558fa196650e3973daa44315caa613b0"", ""filename"": ""crypto/arc4.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/arc4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/arc4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/arc4.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -166,3 +166,4 @@ module_exit(arc4_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""ARC4 Cipher Algorithm\"");\n MODULE_AUTHOR(\""Jon Oberheide <jon@oberheide.org>\"");\n+MODULE_ALIAS_CRYPTO(\""arc4\"");""}<_**next**_>{""sha"": ""7bd71f02d0dde233939716f3b0059cc758ab788c"", ""filename"": ""crypto/blowfish_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/blowfish_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/blowfish_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/blowfish_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -138,4 +138,4 @@ module_exit(blowfish_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Blowfish Cipher Algorithm\"");\n-MODULE_ALIAS(\""blowfish\"");\n+MODULE_ALIAS_CRYPTO(\""blowfish\"");""}<_**next**_>{""sha"": ""1b74c5a3e8910741cac8c92e292b041eff40e714"", ""filename"": ""crypto/camellia_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/camellia_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/camellia_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/camellia_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1098,4 +1098,4 @@ module_exit(camellia_fini);\n \n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");""}<_**next**_>{""sha"": ""84c86db67ec7a88a85fd92a93ad07af6eb935564"", ""filename"": ""crypto/cast5_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast5_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast5_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cast5_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -549,4 +549,4 @@ module_exit(cast5_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Cast5 Cipher Algorithm\"");\n-MODULE_ALIAS(\""cast5\"");\n+MODULE_ALIAS_CRYPTO(\""cast5\"");""}<_**next**_>{""sha"": ""f408f0bd8de2525ac369ae68c4bd5a5187b22e1d"", ""filename"": ""crypto/cast6_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast6_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast6_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cast6_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -291,4 +291,4 @@ module_exit(cast6_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Cast6 Cipher Algorithm\"");\n-MODULE_ALIAS(\""cast6\"");\n+MODULE_ALIAS_CRYPTO(\""cast6\"");""}<_**next**_>{""sha"": ""647575b412815f6ee672846117e6b23deef72d07"", ""filename"": ""crypto/ccm.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ccm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ccm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ccm.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -879,5 +879,5 @@ module_exit(crypto_ccm_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Counter with CBC MAC\"");\n-MODULE_ALIAS(\""ccm_base\"");\n-MODULE_ALIAS(\""rfc4309\"");\n+MODULE_ALIAS_CRYPTO(\""ccm_base\"");\n+MODULE_ALIAS_CRYPTO(\""rfc4309\"");""}<_**next**_>{""sha"": ""187ded28cb0bd76825475dfd3b4684d8043de752"", ""filename"": ""crypto/crc32.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crc32.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -156,3 +156,4 @@ module_exit(crc32_mod_fini);\n MODULE_AUTHOR(\""Alexander Boyko <alexander_boyko@xyratex.com>\"");\n MODULE_DESCRIPTION(\""CRC32 calculations wrapper for lib/crc32\"");\n MODULE_LICENSE(\""GPL\"");\n+MODULE_ALIAS_CRYPTO(\""crc32\"");""}<_**next**_>{""sha"": ""2a062025749d925f858939933ebe67283f158562"", ""filename"": ""crypto/crc32c_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32c_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32c_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crc32c_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -170,5 +170,5 @@ module_exit(crc32c_mod_fini);\n MODULE_AUTHOR(\""Clay Haapala <chaapala@cisco.com>\"");\n MODULE_DESCRIPTION(\""CRC32c (Castagnoli) calculations wrapper for lib/crc32c\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""crc32c\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c\"");\n MODULE_SOFTDEP(\""pre: crc32c\"");""}<_**next**_>{""sha"": ""08bb4f50452085b65c0ed263a84f5c8298142149"", ""filename"": ""crypto/crct10dif_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crct10dif_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crct10dif_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crct10dif_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -124,4 +124,4 @@ module_exit(crct10dif_mod_fini);\n MODULE_AUTHOR(\""Tim Chen <tim.c.chen@linux.intel.com>\"");\n MODULE_DESCRIPTION(\""T10 DIF CRC calculation.\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""crct10dif\"");\n+MODULE_ALIAS_CRYPTO(\""crct10dif\"");""}<_**next**_>{""sha"": ""a20319132e338e7a8e606f9f8d04b3d310741857"", ""filename"": ""crypto/crypto_null.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crypto_null.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crypto_null.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crypto_null.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -145,9 +145,9 @@ static struct crypto_alg null_algs[3] = { {\n \t.coa_decompress\t\t=\tnull_compress } }\n } };\n \n-MODULE_ALIAS(\""compress_null\"");\n-MODULE_ALIAS(\""digest_null\"");\n-MODULE_ALIAS(\""cipher_null\"");\n+MODULE_ALIAS_CRYPTO(\""compress_null\"");\n+MODULE_ALIAS_CRYPTO(\""digest_null\"");\n+MODULE_ALIAS_CRYPTO(\""cipher_null\"");\n \n static int __init crypto_null_mod_init(void)\n {""}<_**next**_>{""sha"": ""3d81ff7e6b4894fa34072db80cf069ea966f1537"", ""filename"": ""crypto/ctr.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ctr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ctr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ctr.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -466,4 +466,4 @@ module_exit(crypto_ctr_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CTR Counter block mode\"");\n-MODULE_ALIAS(\""rfc3686\"");\n+MODULE_ALIAS_CRYPTO(\""rfc3686\"");""}<_**next**_>{""sha"": ""95d8d37c502183b9e426925928aa5c578523cb7d"", ""filename"": ""crypto/deflate.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/deflate.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/deflate.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/deflate.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -222,4 +222,4 @@ module_exit(deflate_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Deflate Compression Algorithm for IPCOMP\"");\n MODULE_AUTHOR(\""James Morris <jmorris@intercode.com.au>\"");\n-\n+MODULE_ALIAS_CRYPTO(\""deflate\"");""}<_**next**_>{""sha"": ""42912948776b1426ec71f2e6fe3d5debd3d67e72"", ""filename"": ""crypto/des_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/des_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/des_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/des_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -983,7 +983,7 @@ static struct crypto_alg des_algs[2] = { {\n \t.cia_decrypt\t\t=\tdes3_ede_decrypt } }\n } };\n \n-MODULE_ALIAS(\""des3_ede\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede\"");\n \n static int __init des_generic_mod_init(void)\n {""}<_**next**_>{""sha"": ""77286ea28865bf4ce5d97f4a556b8aeeed443b14"", ""filename"": ""crypto/fcrypt.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/fcrypt.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/fcrypt.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/fcrypt.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -420,3 +420,4 @@ module_exit(fcrypt_mod_fini);\n MODULE_LICENSE(\""Dual BSD/GPL\"");\n MODULE_DESCRIPTION(\""FCrypt Cipher Algorithm\"");\n MODULE_AUTHOR(\""David Howells <dhowells@redhat.com>\"");\n+MODULE_ALIAS_CRYPTO(\""fcrypt\"");""}<_**next**_>{""sha"": ""aefb74a3f522babbebe18f69c9eaf03ed5e179e6"", ""filename"": ""crypto/gcm.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/gcm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/gcm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/gcm.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1441,6 +1441,6 @@ module_exit(crypto_gcm_module_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Galois/Counter Mode\"");\n MODULE_AUTHOR(\""Mikko Herranen <mh1@iki.fi>\"");\n-MODULE_ALIAS(\""gcm_base\"");\n-MODULE_ALIAS(\""rfc4106\"");\n-MODULE_ALIAS(\""rfc4543\"");\n+MODULE_ALIAS_CRYPTO(\""gcm_base\"");\n+MODULE_ALIAS_CRYPTO(\""rfc4106\"");\n+MODULE_ALIAS_CRYPTO(\""rfc4543\"");""}<_**next**_>{""sha"": ""4e97fae9666f6fd549235ea60c93f999ad00699c"", ""filename"": ""crypto/ghash-generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ghash-generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ghash-generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ghash-generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -172,4 +172,4 @@ module_exit(ghash_mod_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""GHASH Message Digest Algorithm\"");\n-MODULE_ALIAS(\""ghash\"");\n+MODULE_ALIAS_CRYPTO(\""ghash\"");""}<_**next**_>{""sha"": ""873eb5ded6d7ae2f24e96221a131d5936d4101bd"", ""filename"": ""crypto/khazad.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/khazad.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/khazad.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/khazad.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -880,3 +880,4 @@ module_exit(khazad_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Khazad Cryptographic Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""khazad\"");""}<_**next**_>{""sha"": ""67c88b3312107c7c16e9732fa9ffba38172629f4"", ""filename"": ""crypto/krng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/krng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/krng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/krng.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -62,4 +62,4 @@ module_exit(krng_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Kernel Random Number Generator\"");\n-MODULE_ALIAS(\""stdrng\"");\n+MODULE_ALIAS_CRYPTO(\""stdrng\"");""}<_**next**_>{""sha"": ""aefbceaf3104f0df1904dbae4d0c193152f62c07"", ""filename"": ""crypto/lz4.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lz4.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -104,3 +104,4 @@ module_exit(lz4_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LZ4 Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""lz4\"");""}<_**next**_>{""sha"": ""a1d3b5bd3d85118c681098382fb2dd00adc1dac8"", ""filename"": ""crypto/lz4hc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4hc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4hc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lz4hc.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -104,3 +104,4 @@ module_exit(lz4hc_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LZ4HC Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""lz4hc\"");""}<_**next**_>{""sha"": ""4b3e92525dac5a47f3415f46c9eb403813b44275"", ""filename"": ""crypto/lzo.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lzo.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lzo.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lzo.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -107,3 +107,4 @@ module_exit(lzo_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LZO Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""lzo\"");""}<_**next**_>{""sha"": ""3515af425cc917b60669c6dbb1a460f1da1919c4"", ""filename"": ""crypto/md4.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/md4.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -255,4 +255,4 @@ module_exit(md4_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""MD4 Message Digest Algorithm\"");\n-\n+MODULE_ALIAS_CRYPTO(\""md4\"");""}<_**next**_>{""sha"": ""36f5e5b103f302dbeda611466fb97ab94b87511f"", ""filename"": ""crypto/md5.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md5.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md5.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/md5.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -168,3 +168,4 @@ module_exit(md5_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""MD5 Message Digest Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""md5\"");""}<_**next**_>{""sha"": ""46195e0d0f4d1d30dd20b3bdc8f987ea14176643"", ""filename"": ""crypto/michael_mic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/michael_mic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/michael_mic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/michael_mic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -184,3 +184,4 @@ module_exit(michael_mic_exit);\n MODULE_LICENSE(\""GPL v2\"");\n MODULE_DESCRIPTION(\""Michael MIC\"");\n MODULE_AUTHOR(\""Jouni Malinen <j@w1.fi>\"");\n+MODULE_ALIAS_CRYPTO(\""michael_mic\"");""}<_**next**_>{""sha"": ""049486ede938faa3ecc5254d91d3da529467d388"", ""filename"": ""crypto/rmd128.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd128.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd128.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd128.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -327,3 +327,4 @@ module_exit(rmd128_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-128 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd128\"");""}<_**next**_>{""sha"": ""de585e51d455f9a5070b62a59540b01cf096b8ec"", ""filename"": ""crypto/rmd160.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd160.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd160.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd160.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -371,3 +371,4 @@ module_exit(rmd160_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-160 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd160\"");""}<_**next**_>{""sha"": ""4ec02a754e0992e5700fe683f89dde754fa1d1b8"", ""filename"": ""crypto/rmd256.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd256.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd256.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd256.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -346,3 +346,4 @@ module_exit(rmd256_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-256 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd256\"");""}<_**next**_>{""sha"": ""770f2cb369f870a74d2c19fdf943be5ecf5ae54a"", ""filename"": ""crypto/rmd320.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd320.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd320.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd320.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -395,3 +395,4 @@ module_exit(rmd320_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-320 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd320\"");""}<_**next**_>{""sha"": ""3d0f9df30ac9fe368baa63598db9426c2cd8657a"", ""filename"": ""crypto/salsa20_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/salsa20_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/salsa20_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/salsa20_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -248,4 +248,4 @@ module_exit(salsa20_generic_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Salsa20 stream cipher algorithm\"");\n-MODULE_ALIAS(\""salsa20\"");\n+MODULE_ALIAS_CRYPTO(\""salsa20\"");""}<_**next**_>{""sha"": ""c6ba8438be430f59988e52a158d306dcb832c5fe"", ""filename"": ""crypto/seed.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/seed.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/seed.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/seed.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -476,3 +476,4 @@ module_exit(seed_fini);\n MODULE_DESCRIPTION(\""SEED Cipher Algorithm\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Hye-Shik Chang <perky@FreeBSD.org>, Kim Hyun <hkim@kisa.or.kr>\"");\n+MODULE_ALIAS_CRYPTO(\""seed\"");""}<_**next**_>{""sha"": ""a53b5e2af335c95d046b85c0162dd0a5bb25e5e4"", ""filename"": ""crypto/serpent_generic.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/serpent_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/serpent_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/serpent_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -665,5 +665,5 @@ module_exit(serpent_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Serpent and tnepres (kerneli compatible serpent reversed) Cipher Algorithm\"");\n MODULE_AUTHOR(\""Dag Arne Osvik <osvik@ii.uib.no>\"");\n-MODULE_ALIAS(\""tnepres\"");\n-MODULE_ALIAS(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""tnepres\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");""}<_**next**_>{""sha"": ""039e58cfa155655f42aec3ddcb8d2761aa22b264"", ""filename"": ""crypto/sha1_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha1_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha1_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/sha1_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -153,4 +153,4 @@ module_exit(sha1_generic_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm\"");\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");""}<_**next**_>{""sha"": ""5eb21b1200333e95c73f11d3343183c37331544c"", ""filename"": ""crypto/sha256_generic.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha256_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha256_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/sha256_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -384,5 +384,5 @@ module_exit(sha256_generic_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-224 and SHA-256 Secure Hash Algorithm\"");\n \n-MODULE_ALIAS(\""sha224\"");\n-MODULE_ALIAS(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");""}<_**next**_>{""sha"": ""8d0b19ed4f4b3fb90df2266132f5877a488b1e1c"", ""filename"": ""crypto/sha512_generic.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha512_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha512_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/sha512_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -288,5 +288,5 @@ module_exit(sha512_generic_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-512 and SHA-384 Secure Hash Algorithms\"");\n \n-MODULE_ALIAS(\""sha384\"");\n-MODULE_ALIAS(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");""}<_**next**_>{""sha"": ""495be2d0077d4a2828323d2d9ec187964cd74948"", ""filename"": ""crypto/tea.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tea.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tea.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/tea.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -270,8 +270,8 @@ static void __exit tea_mod_fini(void)\n \tcrypto_unregister_algs(tea_algs, ARRAY_SIZE(tea_algs));\n }\n \n-MODULE_ALIAS(\""xtea\"");\n-MODULE_ALIAS(\""xeta\"");\n+MODULE_ALIAS_CRYPTO(\""xtea\"");\n+MODULE_ALIAS_CRYPTO(\""xeta\"");\n \n module_init(tea_mod_init);\n module_exit(tea_mod_fini);""}<_**next**_>{""sha"": ""6e5651c66cf8a783b235e1f8551154e8e01641de"", ""filename"": ""crypto/tgr192.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tgr192.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tgr192.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/tgr192.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -676,8 +676,8 @@ static void __exit tgr192_mod_fini(void)\n \tcrypto_unregister_shashes(tgr_algs, ARRAY_SIZE(tgr_algs));\n }\n \n-MODULE_ALIAS(\""tgr160\"");\n-MODULE_ALIAS(\""tgr128\"");\n+MODULE_ALIAS_CRYPTO(\""tgr160\"");\n+MODULE_ALIAS_CRYPTO(\""tgr128\"");\n \n module_init(tgr192_mod_init);\n module_exit(tgr192_mod_fini);""}<_**next**_>{""sha"": ""523ad8c4e35918329cc08ef979d58a678f52dc5d"", ""filename"": ""crypto/twofish_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/twofish_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/twofish_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/twofish_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -211,4 +211,4 @@ module_exit(twofish_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Twofish Cipher Algorithm\"");\n-MODULE_ALIAS(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");""}<_**next**_>{""sha"": ""0de42eb3d0400b895de0cf8e70e1015dd137ff87"", ""filename"": ""crypto/wp512.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/wp512.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/wp512.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/wp512.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1167,8 +1167,8 @@ static void __exit wp512_mod_fini(void)\n \tcrypto_unregister_shashes(wp_algs, ARRAY_SIZE(wp_algs));\n }\n \n-MODULE_ALIAS(\""wp384\"");\n-MODULE_ALIAS(\""wp256\"");\n+MODULE_ALIAS_CRYPTO(\""wp384\"");\n+MODULE_ALIAS_CRYPTO(\""wp256\"");\n \n module_init(wp512_mod_init);\n module_exit(wp512_mod_fini);""}<_**next**_>{""sha"": ""0eefa9d237ace7f3b607bbfcc4f657580eaa60a0"", ""filename"": ""crypto/zlib.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/zlib.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/zlib.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/zlib.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -378,3 +378,4 @@ module_exit(zlib_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Zlib Compression Algorithm\"");\n MODULE_AUTHOR(\""Sony Corporation\"");\n+MODULE_ALIAS_CRYPTO(\""zlib\"");""}<_**next**_>{""sha"": ""c178ed8c3908d3a92e55432aecb86e0e6e1501ee"", ""filename"": ""drivers/crypto/padlock-aes.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-aes.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-aes.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/padlock-aes.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -563,4 +563,4 @@ MODULE_DESCRIPTION(\""VIA PadLock AES algorithm support\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Michal Ludvig\"");\n \n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");""}<_**next**_>{""sha"": ""95f7d27ce491f000458a257e5dfa55a6105b433b"", ""filename"": ""drivers/crypto/padlock-sha.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-sha.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-sha.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/padlock-sha.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -593,7 +593,7 @@ MODULE_DESCRIPTION(\""VIA PadLock SHA1/SHA256 algorithms support.\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Michal Ludvig\"");\n \n-MODULE_ALIAS(\""sha1-all\"");\n-MODULE_ALIAS(\""sha256-all\"");\n-MODULE_ALIAS(\""sha1-padlock\"");\n-MODULE_ALIAS(\""sha256-padlock\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha256-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-padlock\"");\n+MODULE_ALIAS_CRYPTO(\""sha256-padlock\"");""}<_**next**_>{""sha"": ""7ee93f881db698af823bbd5d94fe0a01abcd900f"", ""filename"": ""drivers/crypto/qat/qat_common/adf_ctl_drv.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/qat/qat_common/adf_ctl_drv.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/qat/qat_common/adf_ctl_drv.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/qat/qat_common/adf_ctl_drv.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -52,6 +52,7 @@\n #include <linux/pci.h>\n #include <linux/cdev.h>\n #include <linux/uaccess.h>\n+#include <linux/crypto.h>\n \n #include \""adf_accel_devices.h\""\n #include \""adf_common_drv.h\""\n@@ -487,4 +488,4 @@ module_exit(adf_unregister_ctl_device_driver);\n MODULE_LICENSE(\""Dual BSD/GPL\"");\n MODULE_AUTHOR(\""Intel\"");\n MODULE_DESCRIPTION(\""Intel(R) QuickAssist Technology\"");\n-MODULE_ALIAS(\""intel_qat\"");\n+MODULE_ALIAS_CRYPTO(\""intel_qat\"");""}<_**next**_>{""sha"": ""7c035de9055e51548003dbb6c8770ce833e3f492"", ""filename"": ""drivers/crypto/ux500/cryp/cryp_core.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/cryp/cryp_core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/cryp/cryp_core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/ux500/cryp/cryp_core.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1812,7 +1812,7 @@ module_exit(ux500_cryp_mod_fini);\n module_param(cryp_mode, int, 0);\n \n MODULE_DESCRIPTION(\""Driver for ST-Ericsson UX500 CRYP crypto engine.\"");\n-MODULE_ALIAS(\""aes-all\"");\n-MODULE_ALIAS(\""des-all\"");\n+MODULE_ALIAS_CRYPTO(\""aes-all\"");\n+MODULE_ALIAS_CRYPTO(\""des-all\"");\n \n MODULE_LICENSE(\""GPL\"");""}<_**next**_>{""sha"": ""76ecc8d143d0f674c29618da5a86df788671845d"", ""filename"": ""drivers/crypto/ux500/hash/hash_core.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/hash/hash_core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/hash/hash_core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/ux500/hash/hash_core.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1997,7 +1997,7 @@ module_exit(ux500_hash_mod_fini);\n MODULE_DESCRIPTION(\""Driver for ST-Ericsson UX500 HASH engine.\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""sha1-all\"");\n-MODULE_ALIAS(\""sha256-all\"");\n-MODULE_ALIAS(\""hmac-sha1-all\"");\n-MODULE_ALIAS(\""hmac-sha256-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha256-all\"");\n+MODULE_ALIAS_CRYPTO(\""hmac-sha1-all\"");\n+MODULE_ALIAS_CRYPTO(\""hmac-sha256-all\"");""}<_**next**_>{""sha"": ""91e97ec0141892cbf4d1676480d5fda3223b0e6b"", ""filename"": ""drivers/s390/crypto/ap_bus.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/s390/crypto/ap_bus.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/s390/crypto/ap_bus.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/s390/crypto/ap_bus.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -44,6 +44,7 @@\n #include <linux/hrtimer.h>\n #include <linux/ktime.h>\n #include <asm/facility.h>\n+#include <linux/crypto.h>\n \n #include \""ap_bus.h\""\n \n@@ -71,7 +72,7 @@ MODULE_AUTHOR(\""IBM Corporation\"");\n MODULE_DESCRIPTION(\""Adjunct Processor Bus driver, \"" \\\n \t\t   \""Copyright IBM Corp. 2006, 2012\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""z90crypt\"");\n+MODULE_ALIAS_CRYPTO(\""z90crypt\"");\n \n /*\n  * Module parameter""}<_**next**_>{""sha"": ""9c8776d0ada87bcf9fa70bc401ce69e336b93d74"", ""filename"": ""include/linux/crypto.h"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/include/linux/crypto.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/include/linux/crypto.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/crypto.h?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -25,6 +25,19 @@\n #include <linux/string.h>\n #include <linux/uaccess.h>\n \n+/*\n+ * Autoloaded crypto modules should only use a prefixed name to avoid allowing\n+ * arbitrary modules to be loaded. Loading from userspace may still need the\n+ * unprefixed names, so retains those aliases as well.\n+ * This uses __MODULE_INFO directly instead of MODULE_ALIAS because pre-4.3\n+ * gcc (e.g. avr32 toolchain) uses __LINE__ for uniqueness, and this macro\n+ * expands twice on the same line. Instead, use a separate base name for the\n+ * alias.\n+ */\n+#define MODULE_ALIAS_CRYPTO(name)\t\\\n+\t\t__MODULE_INFO(alias, alias_userspace, name);\t\\\n+\t\t__MODULE_INFO(alias, alias_crypto, \""crypto-\"" name)\n+\n /*\n  * Algorithm masks and types.\n  */""}","struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)
{
	struct crypto_alg *alg;

	if (!name)
		return ERR_PTR(-ENOENT);

	mask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);
	type &= mask;
 
 	alg = crypto_alg_lookup(name, type, mask);
 	if (!alg) {
		request_module(""crypto-%s"", name);
 
 		if (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &
 		      CRYPTO_ALG_NEED_FALLBACK))
			request_module(""crypto-%s-all"", name);
 
 		alg = crypto_alg_lookup(name, type, mask);
 	}

	if (alg)
		return crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;

	return crypto_larval_add(name, type, mask);
}
","struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)
{
	struct crypto_alg *alg;

	if (!name)
		return ERR_PTR(-ENOENT);

	mask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);
	type &= mask;
 
 	alg = crypto_alg_lookup(name, type, mask);
 	if (!alg) {
		request_module(""%s"", name);
 
 		if (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &
 		      CRYPTO_ALG_NEED_FALLBACK))
			request_module(""%s-all"", name);
 
 		alg = crypto_alg_lookup(name, type, mask);
 	}

	if (alg)
		return crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;

	return crypto_larval_add(name, type, mask);
}
",C,"		request_module(""crypto-%s"", name);
			request_module(""crypto-%s-all"", name);
","		request_module(""%s"", name);
			request_module(""%s-all"", name);
",,"@@ -216,11 +216,11 @@ struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)
 
 	alg = crypto_alg_lookup(name, type, mask);
 	if (!alg) {
-		request_module(""%s"", name);
+		request_module(""crypto-%s"", name);
 
 		if (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &
 		      CRYPTO_ALG_NEED_FALLBACK))
-			request_module(""%s-all"", name);
+			request_module(""crypto-%s-all"", name);
 
 		alg = crypto_alg_lookup(name, type, mask);
 	}",linux,5d26a105b5a73e5635eae0629b42fa0a90e07b7b,5d4a5e770d97d87082067886e7097c920b338da5,1,"struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)
{
	struct crypto_alg *alg;

	if (!name)
		return ERR_PTR(-ENOENT);

	mask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);
	type &= mask;
 
 	alg = crypto_alg_lookup(name, type, mask);
 	if (!alg) {
//flaw_line_below:
		request_module(""%s"", name);
//fix_flaw_line_below:
//		request_module(""crypto-%s"", name);
 
 		if (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &
 		      CRYPTO_ALG_NEED_FALLBACK))
//flaw_line_below:
			request_module(""%s-all"", name);
//fix_flaw_line_below:
//			request_module(""crypto-%s-all"", name);
 
 		alg = crypto_alg_lookup(name, type, mask);
 	}

	if (alg)
		return crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;

	return crypto_larval_add(name, type, mask);
}
",180011,"struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)
{
	struct crypto_alg *alg;

	if (!name)
		return ERR_PTR(-ENOENT);

	mask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);
	type &= mask;
 
 	alg = crypto_alg_lookup(name, type, mask);
 	if (!alg) {
		request_module(""%s"", name);
 
 		if (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &
 		      CRYPTO_ALG_NEED_FALLBACK))
			request_module(""%s-all"", name);
 
 		alg = crypto_alg_lookup(name, type, mask);
 	}

	if (alg)
		return crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;

	return crypto_larval_add(name, type, mask);
}
","struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)
{
	struct crypto_alg *alg;

	if (!name)
		return ERR_PTR(-ENOENT);

	mask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);
	type &= mask;
 
 	alg = crypto_alg_lookup(name, type, mask);
 	if (!alg) {
		request_module(""crypto-%s"", name);
 
 		if (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &
 		      CRYPTO_ALG_NEED_FALLBACK))
			request_module(""crypto-%s-all"", name);
 
 		alg = crypto_alg_lookup(name, type, mask);
 	}

	if (alg)
		return crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;

	return crypto_larval_add(name, type, mask);
}
","The `crypto_larval_lookup` function is designed to locate a cryptographic algorithm by its name, type, and mask, handling cases where the algorithm may not be immediately available. It first checks if the provided name is valid; if not, it returns an error. The function then filters the type using the mask to exclude certain flags. It attempts to find the algorithm using `crypto_alg_lookup`. If unsuccessful, it requests the module corresponding to the algorithm and potentially its fallback version. Finally, it checks if the found algorithm is in a ""larval"" state, waiting for it to become ready, or adds it if not found.","The provided code defines a function that searches for a cryptographic algorithm based on its name, type, and a mask that filters certain flags. It first checks for the validity of the name and returns an error if it is absent. The function then attempts to locate the algorithm, and if it is not found, it requests the necessary module for the algorithm and potentially its fallback version. Afterward, it checks if the located algorithm is in a temporary state, waiting for it to become available, or adds it if it remains unfound, ensuring proper handling of algorithm availability.","The vulnerability in the original code stemmed from the potential exposure of module auto-loading to userspace, which could allow unauthorized access or manipulation of cryptographic modules. Specifically, the `request_module` function was called with the algorithm name directly, risking unintended consequences. The fix involved prefixing the module loading requests with ""crypto-"", ensuring that only modules specifically intended for cryptographic operations are loaded. This change mitigates the risk of exposing sensitive operations to userspace, thereby enhancing security by preventing the loading of arbitrary modules through the cryptographic API.","The vulnerability in the original code allowed for the potential exposure of module auto-loading to userspace, which could lead to unauthorized access or manipulation of cryptographic modules. This risk arose from directly using algorithm names in module loading requests, making it possible for malicious users to exploit the system. The fix involved adding a specific prefix to all module loading requests, ensuring that only modules intended for cryptographic operations could be loaded. This change effectively mitigated the risk of exposing sensitive operations to userspace, enhancing the overall security of the cryptographic API.","The vulnerability was fixed by modifying the `request_module` function calls to include a ""crypto-"" prefix when loading modules. In the updated code, the calls to `request_module` now use the format ""crypto-%s"" for both the specific algorithm and its fallback version. This change ensures that only modules specifically designated for cryptographic purposes are loaded, preventing unauthorized or unintended modules from being accessed through the cryptographic API. By restricting module loading in this manner, the code mitigates the risk of exposing sensitive operations to userspace, thereby enhancing the security of the system.","The vulnerability was fixed by adding a specific prefix to the module loading requests, ensuring that only modules intended for cryptographic operations could be loaded. This change prevents the risk of exposing module auto-loading to userspace, which could allow unauthorized access or manipulation of sensitive cryptographic modules. By enforcing this prefix, the code restricts the loading process to only those modules that are explicitly designated for cryptographic use, thereby enhancing the overall security of the system and mitigating potential exploitation through the cryptographic API.","CWE-269, CWE-426, CWE-470, CWE-265, CWE-266, CWE-494, CWE-732, CWE-441, CWE-943, CWE-610",N,-1
47,47,180630,180630,,Local,Not required,Complete,CVE-2015-8966,https://www.cvedetails.com/cve/CVE-2015-8966/,CWE-264,Low,Complete,Complete,,2016-12-08,7.2,"arch/arm/kernel/sys_oabi-compat.c in the Linux kernel before 4.4 allows local users to gain privileges via a crafted (1) F_OFD_GETLK, (2) F_OFD_SETLK, or (3) F_OFD_SETLKW command in an fcntl64 system call.",2016-12-09,+Priv ,37,https://github.com/torvalds/linux/commit/76cc404bfdc0d419c720de4daaf2584542734f42,76cc404bfdc0d419c720de4daaf2584542734f42,"[PATCH] arm: fix handling of F_OFD_... in oabi_fcntl64()

Cc: stable@vger.kernel.org # 3.15+
Reviewed-by: Jeff Layton <jeff.layton@primarydata.com>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",33,arch/arm/kernel/sys_oabi-compat.c,"{""sha"": ""087acb569b63a4bd90982e0c9b15fc2313636c53"", ""filename"": ""arch/arm/kernel/sys_oabi-compat.c"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 36, ""changes"": 73, ""blob_url"": ""https://github.com/torvalds/linux/blob/76cc404bfdc0d419c720de4daaf2584542734f42/arch/arm/kernel/sys_oabi-compat.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/76cc404bfdc0d419c720de4daaf2584542734f42/arch/arm/kernel/sys_oabi-compat.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/kernel/sys_oabi-compat.c?ref=76cc404bfdc0d419c720de4daaf2584542734f42"", ""patch"": ""@@ -193,55 +193,56 @@ struct oabi_flock64 {\n \tpid_t\tl_pid;\n } __attribute__ ((packed,aligned(4)));\n \n-asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n+static long do_locks(unsigned int fd, unsigned int cmd,\n \t\t\t\t unsigned long arg)\n {\n-\tstruct oabi_flock64 user;\n \tstruct flock64 kernel;\n-\tmm_segment_t fs = USER_DS; /* initialized to kill a warning */\n-\tunsigned long local_arg = arg;\n-\tint ret;\n+\tstruct oabi_flock64 user;\n+\tmm_segment_t fs;\n+\tlong ret;\n+\n+\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n+\t\t\t   sizeof(user)))\n+\t\treturn -EFAULT;\n+\tkernel.l_type\t= user.l_type;\n+\tkernel.l_whence\t= user.l_whence;\n+\tkernel.l_start\t= user.l_start;\n+\tkernel.l_len\t= user.l_len;\n+\tkernel.l_pid\t= user.l_pid;\n+\n+\tfs = get_fs();\n+\tset_fs(KERNEL_DS);\n+\tret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);\n+\tset_fs(fs);\n+\n+\tif (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {\n+\t\tuser.l_type\t= kernel.l_type;\n+\t\tuser.l_whence\t= kernel.l_whence;\n+\t\tuser.l_start\t= kernel.l_start;\n+\t\tuser.l_len\t= kernel.l_len;\n+\t\tuser.l_pid\t= kernel.l_pid;\n+\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n+\t\t\t\t &user, sizeof(user)))\n+\t\t\tret = -EFAULT;\n+\t}\n+\treturn ret;\n+}\n \n+asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n+\t\t\t\t unsigned long arg)\n+{\n \tswitch (cmd) {\n \tcase F_OFD_GETLK:\n \tcase F_OFD_SETLK:\n \tcase F_OFD_SETLKW:\n \tcase F_GETLK64:\n \tcase F_SETLK64:\n \tcase F_SETLKW64:\n-\t\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n-\t\t\t\t   sizeof(user)))\n-\t\t\treturn -EFAULT;\n-\t\tkernel.l_type\t= user.l_type;\n-\t\tkernel.l_whence\t= user.l_whence;\n-\t\tkernel.l_start\t= user.l_start;\n-\t\tkernel.l_len\t= user.l_len;\n-\t\tkernel.l_pid\t= user.l_pid;\n-\t\tlocal_arg = (unsigned long)&kernel;\n-\t\tfs = get_fs();\n-\t\tset_fs(KERNEL_DS);\n-\t}\n-\n-\tret = sys_fcntl64(fd, cmd, local_arg);\n+\t\treturn do_locks(fd, cmd, arg);\n \n-\tswitch (cmd) {\n-\tcase F_GETLK64:\n-\t\tif (!ret) {\n-\t\t\tuser.l_type\t= kernel.l_type;\n-\t\t\tuser.l_whence\t= kernel.l_whence;\n-\t\t\tuser.l_start\t= kernel.l_start;\n-\t\t\tuser.l_len\t= kernel.l_len;\n-\t\t\tuser.l_pid\t= kernel.l_pid;\n-\t\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n-\t\t\t\t\t &user, sizeof(user)))\n-\t\t\t\tret = -EFAULT;\n-\t\t}\n-\tcase F_SETLK64:\n-\tcase F_SETLKW64:\n-\t\tset_fs(fs);\n+\tdefault:\n+\t\treturn sys_fcntl64(fd, cmd, arg);\n \t}\n-\n-\treturn ret;\n }\n \n struct oabi_epoll_event {""}","asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
static long do_locks(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
 	struct flock64 kernel;
	struct oabi_flock64 user;
	mm_segment_t fs;
	long ret;

	if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
			   sizeof(user)))
		return -EFAULT;
	kernel.l_type	= user.l_type;
	kernel.l_whence	= user.l_whence;
	kernel.l_start	= user.l_start;
	kernel.l_len	= user.l_len;
	kernel.l_pid	= user.l_pid;

	fs = get_fs();
	set_fs(KERNEL_DS);
	ret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);
	set_fs(fs);

	if (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {
		user.l_type	= kernel.l_type;
		user.l_whence	= kernel.l_whence;
		user.l_start	= kernel.l_start;
		user.l_len	= kernel.l_len;
		user.l_pid	= kernel.l_pid;
		if (copy_to_user((struct oabi_flock64 __user *)arg,
				 &user, sizeof(user)))
			ret = -EFAULT;
	}
	return ret;
}
 
asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
				 unsigned long arg)
{
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
 	case F_OFD_SETLKW:
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
		return do_locks(fd, cmd, arg);
 
	default:
		return sys_fcntl64(fd, cmd, arg);
 	}
 }
","asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
	struct oabi_flock64 user;
 	struct flock64 kernel;
	mm_segment_t fs = USER_DS; /* initialized to kill a warning */
	unsigned long local_arg = arg;
	int ret;
 
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
 	case F_OFD_SETLKW:
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
		if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
				   sizeof(user)))
			return -EFAULT;
		kernel.l_type	= user.l_type;
		kernel.l_whence	= user.l_whence;
		kernel.l_start	= user.l_start;
		kernel.l_len	= user.l_len;
		kernel.l_pid	= user.l_pid;
		local_arg = (unsigned long)&kernel;
		fs = get_fs();
		set_fs(KERNEL_DS);
	}
	ret = sys_fcntl64(fd, cmd, local_arg);
 
	switch (cmd) {
	case F_GETLK64:
		if (!ret) {
			user.l_type	= kernel.l_type;
			user.l_whence	= kernel.l_whence;
			user.l_start	= kernel.l_start;
			user.l_len	= kernel.l_len;
			user.l_pid	= kernel.l_pid;
			if (copy_to_user((struct oabi_flock64 __user *)arg,
					 &user, sizeof(user)))
				ret = -EFAULT;
		}
	case F_SETLK64:
	case F_SETLKW64:
		set_fs(fs);
 	}
	return ret;
 }
",C,"static long do_locks(unsigned int fd, unsigned int cmd,
	struct oabi_flock64 user;
	mm_segment_t fs;
	long ret;

	if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
			   sizeof(user)))
		return -EFAULT;
	kernel.l_type	= user.l_type;
	kernel.l_whence	= user.l_whence;
	kernel.l_start	= user.l_start;
	kernel.l_len	= user.l_len;
	kernel.l_pid	= user.l_pid;

	fs = get_fs();
	set_fs(KERNEL_DS);
	ret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);
	set_fs(fs);

	if (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {
		user.l_type	= kernel.l_type;
		user.l_whence	= kernel.l_whence;
		user.l_start	= kernel.l_start;
		user.l_len	= kernel.l_len;
		user.l_pid	= kernel.l_pid;
		if (copy_to_user((struct oabi_flock64 __user *)arg,
				 &user, sizeof(user)))
			ret = -EFAULT;
	}
	return ret;
}
asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
				 unsigned long arg)
{
		return do_locks(fd, cmd, arg);
	default:
		return sys_fcntl64(fd, cmd, arg);
","	struct oabi_flock64 user;
	mm_segment_t fs = USER_DS; /* initialized to kill a warning */
	unsigned long local_arg = arg;
	int ret;
		if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
				   sizeof(user)))
			return -EFAULT;
		kernel.l_type	= user.l_type;
		kernel.l_whence	= user.l_whence;
		kernel.l_start	= user.l_start;
		kernel.l_len	= user.l_len;
		kernel.l_pid	= user.l_pid;
		local_arg = (unsigned long)&kernel;
		fs = get_fs();
		set_fs(KERNEL_DS);
	}
	ret = sys_fcntl64(fd, cmd, local_arg);
	switch (cmd) {
	case F_GETLK64:
		if (!ret) {
			user.l_type	= kernel.l_type;
			user.l_whence	= kernel.l_whence;
			user.l_start	= kernel.l_start;
			user.l_len	= kernel.l_len;
			user.l_pid	= kernel.l_pid;
			if (copy_to_user((struct oabi_flock64 __user *)arg,
					 &user, sizeof(user)))
				ret = -EFAULT;
		}
	case F_SETLK64:
	case F_SETLKW64:
		set_fs(fs);
	return ret;
",,"@@ -193,55 +193,56 @@ struct oabi_flock64 {
 	pid_t	l_pid;
 } __attribute__ ((packed,aligned(4)));
 
-asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
+static long do_locks(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
-	struct oabi_flock64 user;
 	struct flock64 kernel;
-	mm_segment_t fs = USER_DS; /* initialized to kill a warning */
-	unsigned long local_arg = arg;
-	int ret;
+	struct oabi_flock64 user;
+	mm_segment_t fs;
+	long ret;
+
+	if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
+			   sizeof(user)))
+		return -EFAULT;
+	kernel.l_type	= user.l_type;
+	kernel.l_whence	= user.l_whence;
+	kernel.l_start	= user.l_start;
+	kernel.l_len	= user.l_len;
+	kernel.l_pid	= user.l_pid;
+
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+	ret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);
+	set_fs(fs);
+
+	if (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {
+		user.l_type	= kernel.l_type;
+		user.l_whence	= kernel.l_whence;
+		user.l_start	= kernel.l_start;
+		user.l_len	= kernel.l_len;
+		user.l_pid	= kernel.l_pid;
+		if (copy_to_user((struct oabi_flock64 __user *)arg,
+				 &user, sizeof(user)))
+			ret = -EFAULT;
+	}
+	return ret;
+}
 
+asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
+				 unsigned long arg)
+{
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
 	case F_OFD_SETLKW:
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
-		if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
-				   sizeof(user)))
-			return -EFAULT;
-		kernel.l_type	= user.l_type;
-		kernel.l_whence	= user.l_whence;
-		kernel.l_start	= user.l_start;
-		kernel.l_len	= user.l_len;
-		kernel.l_pid	= user.l_pid;
-		local_arg = (unsigned long)&kernel;
-		fs = get_fs();
-		set_fs(KERNEL_DS);
-	}
-
-	ret = sys_fcntl64(fd, cmd, local_arg);
+		return do_locks(fd, cmd, arg);
 
-	switch (cmd) {
-	case F_GETLK64:
-		if (!ret) {
-			user.l_type	= kernel.l_type;
-			user.l_whence	= kernel.l_whence;
-			user.l_start	= kernel.l_start;
-			user.l_len	= kernel.l_len;
-			user.l_pid	= kernel.l_pid;
-			if (copy_to_user((struct oabi_flock64 __user *)arg,
-					 &user, sizeof(user)))
-				ret = -EFAULT;
-		}
-	case F_SETLK64:
-	case F_SETLKW64:
-		set_fs(fs);
+	default:
+		return sys_fcntl64(fd, cmd, arg);
 	}
-
-	return ret;
 }
 
 struct oabi_epoll_event {",linux,76cc404bfdc0d419c720de4daaf2584542734f42,74bf8efb5fa6e958d2d7c7917b8bb672085ec0c6,1,"asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
//fix_flaw_line_below:
//static long do_locks(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
//flaw_line_below:
	struct oabi_flock64 user;
 	struct flock64 kernel;
//flaw_line_below:
	mm_segment_t fs = USER_DS; /* initialized to kill a warning */
//flaw_line_below:
	unsigned long local_arg = arg;
//flaw_line_below:
	int ret;
//fix_flaw_line_below:
//	struct oabi_flock64 user;
//fix_flaw_line_below:
//	mm_segment_t fs;
//fix_flaw_line_below:
//	long ret;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
//fix_flaw_line_below:
//			   sizeof(user)))
//fix_flaw_line_below:
//		return -EFAULT;
//fix_flaw_line_below:
//	kernel.l_type	= user.l_type;
//fix_flaw_line_below:
//	kernel.l_whence	= user.l_whence;
//fix_flaw_line_below:
//	kernel.l_start	= user.l_start;
//fix_flaw_line_below:
//	kernel.l_len	= user.l_len;
//fix_flaw_line_below:
//	kernel.l_pid	= user.l_pid;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	fs = get_fs();
//fix_flaw_line_below:
//	set_fs(KERNEL_DS);
//fix_flaw_line_below:
//	ret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);
//fix_flaw_line_below:
//	set_fs(fs);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {
//fix_flaw_line_below:
//		user.l_type	= kernel.l_type;
//fix_flaw_line_below:
//		user.l_whence	= kernel.l_whence;
//fix_flaw_line_below:
//		user.l_start	= kernel.l_start;
//fix_flaw_line_below:
//		user.l_len	= kernel.l_len;
//fix_flaw_line_below:
//		user.l_pid	= kernel.l_pid;
//fix_flaw_line_below:
//		if (copy_to_user((struct oabi_flock64 __user *)arg,
//fix_flaw_line_below:
//				 &user, sizeof(user)))
//fix_flaw_line_below:
//			ret = -EFAULT;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//	return ret;
//fix_flaw_line_below:
//}
 
//fix_flaw_line_below:
//asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
//fix_flaw_line_below:
//				 unsigned long arg)
//fix_flaw_line_below:
//{
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
 	case F_OFD_SETLKW:
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
//flaw_line_below:
		if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
//flaw_line_below:
				   sizeof(user)))
//flaw_line_below:
			return -EFAULT;
//flaw_line_below:
		kernel.l_type	= user.l_type;
//flaw_line_below:
		kernel.l_whence	= user.l_whence;
//flaw_line_below:
		kernel.l_start	= user.l_start;
//flaw_line_below:
		kernel.l_len	= user.l_len;
//flaw_line_below:
		kernel.l_pid	= user.l_pid;
//flaw_line_below:
		local_arg = (unsigned long)&kernel;
//flaw_line_below:
		fs = get_fs();
//flaw_line_below:
		set_fs(KERNEL_DS);
//flaw_line_below:
	}
//flaw_line_below:

//flaw_line_below:
	ret = sys_fcntl64(fd, cmd, local_arg);
//fix_flaw_line_below:
//		return do_locks(fd, cmd, arg);
 
//flaw_line_below:
	switch (cmd) {
//flaw_line_below:
	case F_GETLK64:
//flaw_line_below:
		if (!ret) {
//flaw_line_below:
			user.l_type	= kernel.l_type;
//flaw_line_below:
			user.l_whence	= kernel.l_whence;
//flaw_line_below:
			user.l_start	= kernel.l_start;
//flaw_line_below:
			user.l_len	= kernel.l_len;
//flaw_line_below:
			user.l_pid	= kernel.l_pid;
//flaw_line_below:
			if (copy_to_user((struct oabi_flock64 __user *)arg,
//flaw_line_below:
					 &user, sizeof(user)))
//flaw_line_below:
				ret = -EFAULT;
//flaw_line_below:
		}
//flaw_line_below:
	case F_SETLK64:
//flaw_line_below:
	case F_SETLKW64:
//flaw_line_below:
		set_fs(fs);
//fix_flaw_line_below:
//	default:
//fix_flaw_line_below:
//		return sys_fcntl64(fd, cmd, arg);
 	}
//flaw_line_below:

//flaw_line_below:
	return ret;
 }
",180630,"asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
	struct oabi_flock64 user;
 	struct flock64 kernel;
	mm_segment_t fs = USER_DS; /* initialized to kill a warning */
	unsigned long local_arg = arg;
	int ret;
 
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
 	case F_OFD_SETLKW:
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
		if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
				   sizeof(user)))
			return -EFAULT;
		kernel.l_type	= user.l_type;
		kernel.l_whence	= user.l_whence;
		kernel.l_start	= user.l_start;
		kernel.l_len	= user.l_len;
		kernel.l_pid	= user.l_pid;
		local_arg = (unsigned long)&kernel;
		fs = get_fs();
		set_fs(KERNEL_DS);
	}
	ret = sys_fcntl64(fd, cmd, local_arg);
 
	switch (cmd) {
	case F_GETLK64:
		if (!ret) {
			user.l_type	= kernel.l_type;
			user.l_whence	= kernel.l_whence;
			user.l_start	= kernel.l_start;
			user.l_len	= kernel.l_len;
			user.l_pid	= kernel.l_pid;
			if (copy_to_user((struct oabi_flock64 __user *)arg,
					 &user, sizeof(user)))
				ret = -EFAULT;
		}
	case F_SETLK64:
	case F_SETLKW64:
		set_fs(fs);
 	}
	return ret;
 }
","asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
static long do_locks(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
 	struct flock64 kernel;
	struct oabi_flock64 user;
	mm_segment_t fs;
	long ret;

	if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
			   sizeof(user)))
		return -EFAULT;
	kernel.l_type	= user.l_type;
	kernel.l_whence	= user.l_whence;
	kernel.l_start	= user.l_start;
	kernel.l_len	= user.l_len;
	kernel.l_pid	= user.l_pid;

	fs = get_fs();
	set_fs(KERNEL_DS);
	ret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);
	set_fs(fs);

	if (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {
		user.l_type	= kernel.l_type;
		user.l_whence	= kernel.l_whence;
		user.l_start	= kernel.l_start;
		user.l_len	= kernel.l_len;
		user.l_pid	= kernel.l_pid;
		if (copy_to_user((struct oabi_flock64 __user *)arg,
				 &user, sizeof(user)))
			ret = -EFAULT;
	}
	return ret;
}
 
asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
				 unsigned long arg)
{
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
 	case F_OFD_SETLKW:
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
		return do_locks(fd, cmd, arg);
 
	default:
		return sys_fcntl64(fd, cmd, arg);
 	}
 }
","The provided code defines a system call function `sys_oabi_fcntl64`, which handles file control operations for 64-bit file locks in a Linux environment. It takes three parameters: a file descriptor (`fd`), a command (`cmd`), and an argument (`arg`). The function first initializes a user-space structure and a corresponding kernel-space structure for file locks. Depending on the command, it copies data from user space to kernel space, modifies the file lock structure, and calls the `sys_fcntl64` function to perform the requested operation. Finally, it retrieves the results and, if necessary, copies the updated lock information back to user space before returning the result of the operation.","The code implements a system call that manages file locking operations in a 64-bit environment. It processes commands related to obtaining and setting file locks by first transferring data from user space to a kernel structure. Depending on the command received, it may modify the lock information and invoke a lower-level function to execute the requested operation. After the operation, it checks the results and, if applicable, sends the updated lock details back to user space. The function ultimately returns the result of the operation, indicating success or failure.","The vulnerability in the original code stemmed from improper handling of user-space data, which could lead to potential memory corruption or access violations if the user provided invalid pointers or data. Specifically, the code did not adequately check the validity of the user-supplied argument before copying it into kernel space. The fix involved refactoring the code to introduce a separate function, `do_locks`, which centralizes the logic for handling file locks. This function ensures that user data is copied safely and only after validating the input, thus mitigating the risk of exploitation and improving overall security.","The vulnerability in the original code was due to inadequate validation of user-supplied data, which could lead to memory corruption or access violations if invalid pointers were provided. This lack of checks allowed potential exploitation by malicious users. The fix involved restructuring the code to introduce a dedicated function that centralizes the handling of file locking operations. This new approach ensures that user data is properly validated before any copying occurs, thereby enhancing security and preventing the risks associated with improper memory access. The changes effectively mitigate the vulnerability while maintaining functionality.","The vulnerability was fixed by introducing a new function, `do_locks`, which centralizes the handling of file locking operations. This function first validates the user-supplied argument by using `copy_from_user` to safely copy data into a user structure. It then populates the kernel structure with the validated data before calling `sys_fcntl64` to perform the requested operation. After the operation, if successful, it copies the results back to the user space using `copy_to_user`. This structured approach ensures that user data is properly checked and handled, significantly reducing the risk of memory corruption or access violations.","The vulnerability was addressed by restructuring the code to introduce a dedicated function that manages file locking operations more securely. This new function ensures that user-supplied data is first validated before any copying occurs, preventing potential memory corruption or access violations. By centralizing the logic for handling file locks, the code now checks the integrity of the input data and only proceeds with operations if the data is deemed safe. This approach enhances overall security by mitigating risks associated with improper handling of user input while maintaining the intended functionality of the system call.","CWE-666, CWE-119, CWE-362, CWE-20, CWE-410, CWE-667, CWE-416, CWE-123, CWE-465, CWE-269",N,-1
48,48,180705,180705,,Local,Not required,Complete,CVE-2015-8539,https://www.cvedetails.com/cve/CVE-2015-8539/,CWE-264,Low,Complete,Complete,,2016-02-07,7.2,"The KEYS subsystem in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (BUG) via crafted keyctl commands that negatively instantiate a key, related to security/keys/encrypted-keys/encrypted.c, security/keys/trusted.c, and security/keys/user_defined.c.",2018-10-30,DoS +Priv ,2,https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd,096fe9eaea40a17e125569f9e657e34cdb6d73bd,"KEYS: Fix handling of stored error in a negatively instantiated user key

If a user key gets negatively instantiated, an error code is cached in the
payload area.  A negatively instantiated key may be then be positively
instantiated by updating it with valid data.  However, the ->update key
type method must be aware that the error code may be there.

The following may be used to trigger the bug in the user key type:

    keyctl request2 user user """" @u
    keyctl add user user ""a"" @u

which manifests itself as:

	BUG: unable to handle kernel paging request at 00000000ffffff8a
	IP: [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	PGD 7cc30067 PUD 0
	Oops: 0002 [#1] SMP
	Modules linked in:
	CPU: 3 PID: 2644 Comm: a.out Not tainted 4.3.0+ #49
	Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
	task: ffff88003ddea700 ti: ffff88003dd88000 task.ti: ffff88003dd88000
	RIP: 0010:[<ffffffff810a376f>]  [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280
	 [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	RSP: 0018:ffff88003dd8bdb0  EFLAGS: 00010246
	RAX: 00000000ffffff82 RBX: 0000000000000000 RCX: 0000000000000001
	RDX: ffffffff81e3fe40 RSI: 0000000000000000 RDI: 00000000ffffff82
	RBP: ffff88003dd8bde0 R08: ffff88007d2d2da0 R09: 0000000000000000
	R10: 0000000000000000 R11: ffff88003e8073c0 R12: 00000000ffffff82
	R13: ffff88003dd8be68 R14: ffff88007d027600 R15: ffff88003ddea700
	FS:  0000000000b92880(0063) GS:ffff88007fd00000(0000) knlGS:0000000000000000
	CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
	CR2: 00000000ffffff8a CR3: 000000007cc5f000 CR4: 00000000000006e0
	Stack:
	 ffff88003dd8bdf0 ffffffff81160a8a 0000000000000000 00000000ffffff82
	 ffff88003dd8be68 ffff88007d027600 ffff88003dd8bdf0 ffffffff810a39e5
	 ffff88003dd8be20 ffffffff812a31ab ffff88007d027600 ffff88007d027620
	Call Trace:
	 [<ffffffff810a39e5>] kfree_call_rcu+0x15/0x20 kernel/rcu/tree.c:3136
	 [<ffffffff812a31ab>] user_update+0x8b/0xb0 security/keys/user_defined.c:129
	 [<     inline     >] __key_update security/keys/key.c:730
	 [<ffffffff8129e5c1>] key_create_or_update+0x291/0x440 security/keys/key.c:908
	 [<     inline     >] SYSC_add_key security/keys/keyctl.c:125
	 [<ffffffff8129fc21>] SyS_add_key+0x101/0x1e0 security/keys/keyctl.c:60
	 [<ffffffff8185f617>] entry_SYSCALL_64_fastpath+0x12/0x6a arch/x86/entry/entry_64.S:185

Note the error code (-ENOKEY) in EDX.

A similar bug can be tripped by:

    keyctl request2 trusted user """" @u
    keyctl add trusted user ""a"" @u

This should also affect encrypted keys - but that has to be correctly
parameterised or it will fail with EINVAL before getting to the bit that
will crashes.

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
Signed-off-by: James Morris <james.l.morris@oracle.com>",0,security/keys/encrypted-keys/encrypted.c,"{""sha"": ""696ccfa08d103cd29ae56ac38c117bbd7725da06"", ""filename"": ""security/keys/encrypted-keys/encrypted.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/encrypted-keys/encrypted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -845,6 +845,8 @@ static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n \tsize_t datalen = prep->datalen;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\treturn -EINVAL;\n ""}<_**next**_>{""sha"": ""16dec53184b663f745c010d11e78128ca995bf58"", ""filename"": ""security/keys/trusted.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/trusted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -1007,13 +1007,16 @@ static void trusted_rcu_free(struct rcu_head *rcu)\n  */\n static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n {\n-\tstruct trusted_key_payload *p = key->payload.data[0];\n+\tstruct trusted_key_payload *p;\n \tstruct trusted_key_payload *new_p;\n \tstruct trusted_key_options *new_o;\n \tsize_t datalen = prep->datalen;\n \tchar *datablob;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n+\tp = key->payload.data[0];\n \tif (!p->migratable)\n \t\treturn -EPERM;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)""}<_**next**_>{""sha"": ""8705d79b2c6f289736fde21fd38e6013a4e4ae3c"", ""filename"": ""security/keys/user_defined.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/user_defined.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -120,7 +120,10 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n \tif (ret == 0) {\n \t\t/* attach the new data, displacing the old */\n-\t\tzap = key->payload.data[0];\n+\t\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\t\tzap = key->payload.data[0];\n+\t\telse\n+\t\t\tzap = NULL;\n \t\trcu_assign_keypointer(key, upayload);\n \t\tkey->expiry = 0;\n \t}""}","static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct encrypted_key_payload *epayload = key->payload.data[0];
	struct encrypted_key_payload *new_epayload;
	char *buf;
	char *new_master_desc = NULL;
	const char *format = NULL;
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 
	buf = kmalloc(datalen + 1, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	buf[datalen] = 0;
	memcpy(buf, prep->data, datalen);
	ret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);
	if (ret < 0)
		goto out;

	ret = valid_master_desc(new_master_desc, epayload->master_desc);
	if (ret < 0)
		goto out;

	new_epayload = encrypted_key_alloc(key, epayload->format,
					   new_master_desc, epayload->datalen);
	if (IS_ERR(new_epayload)) {
		ret = PTR_ERR(new_epayload);
		goto out;
	}

	__ekey_init(new_epayload, epayload->format, new_master_desc,
		    epayload->datalen);

	memcpy(new_epayload->iv, epayload->iv, ivsize);
	memcpy(new_epayload->payload_data, epayload->payload_data,
	       epayload->payload_datalen);

	rcu_assign_keypointer(key, new_epayload);
	call_rcu(&epayload->rcu, encrypted_rcu_free);
out:
	kfree(buf);
	return ret;
}
","static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct encrypted_key_payload *epayload = key->payload.data[0];
	struct encrypted_key_payload *new_epayload;
	char *buf;
	char *new_master_desc = NULL;
	const char *format = NULL;
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 
	buf = kmalloc(datalen + 1, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	buf[datalen] = 0;
	memcpy(buf, prep->data, datalen);
	ret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);
	if (ret < 0)
		goto out;

	ret = valid_master_desc(new_master_desc, epayload->master_desc);
	if (ret < 0)
		goto out;

	new_epayload = encrypted_key_alloc(key, epayload->format,
					   new_master_desc, epayload->datalen);
	if (IS_ERR(new_epayload)) {
		ret = PTR_ERR(new_epayload);
		goto out;
	}

	__ekey_init(new_epayload, epayload->format, new_master_desc,
		    epayload->datalen);

	memcpy(new_epayload->iv, epayload->iv, ivsize);
	memcpy(new_epayload->payload_data, epayload->payload_data,
	       epayload->payload_datalen);

	rcu_assign_keypointer(key, new_epayload);
	call_rcu(&epayload->rcu, encrypted_rcu_free);
out:
	kfree(buf);
	return ret;
}
",C,"	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
",,,"@@ -845,6 +845,8 @@ static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
+	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
+		return -ENOKEY;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 ",linux,096fe9eaea40a17e125569f9e657e34cdb6d73bd,6ffeba9607343f15303a399bc402a538800d89d9,1,"static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct encrypted_key_payload *epayload = key->payload.data[0];
	struct encrypted_key_payload *new_epayload;
	char *buf;
	char *new_master_desc = NULL;
	const char *format = NULL;
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
//fix_flaw_line_below:
//	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
//fix_flaw_line_below:
//		return -ENOKEY;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 
	buf = kmalloc(datalen + 1, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	buf[datalen] = 0;
	memcpy(buf, prep->data, datalen);
	ret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);
	if (ret < 0)
		goto out;

	ret = valid_master_desc(new_master_desc, epayload->master_desc);
	if (ret < 0)
		goto out;

	new_epayload = encrypted_key_alloc(key, epayload->format,
					   new_master_desc, epayload->datalen);
	if (IS_ERR(new_epayload)) {
		ret = PTR_ERR(new_epayload);
		goto out;
	}

	__ekey_init(new_epayload, epayload->format, new_master_desc,
		    epayload->datalen);

	memcpy(new_epayload->iv, epayload->iv, ivsize);
	memcpy(new_epayload->payload_data, epayload->payload_data,
	       epayload->payload_datalen);

	rcu_assign_keypointer(key, new_epayload);
	call_rcu(&epayload->rcu, encrypted_rcu_free);
out:
	kfree(buf);
	return ret;
}
",180705,"static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct encrypted_key_payload *epayload = key->payload.data[0];
	struct encrypted_key_payload *new_epayload;
	char *buf;
	char *new_master_desc = NULL;
	const char *format = NULL;
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 
	buf = kmalloc(datalen + 1, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	buf[datalen] = 0;
	memcpy(buf, prep->data, datalen);
	ret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);
	if (ret < 0)
		goto out;

	ret = valid_master_desc(new_master_desc, epayload->master_desc);
	if (ret < 0)
		goto out;

	new_epayload = encrypted_key_alloc(key, epayload->format,
					   new_master_desc, epayload->datalen);
	if (IS_ERR(new_epayload)) {
		ret = PTR_ERR(new_epayload);
		goto out;
	}

	__ekey_init(new_epayload, epayload->format, new_master_desc,
		    epayload->datalen);

	memcpy(new_epayload->iv, epayload->iv, ivsize);
	memcpy(new_epayload->payload_data, epayload->payload_data,
	       epayload->payload_datalen);

	rcu_assign_keypointer(key, new_epayload);
	call_rcu(&epayload->rcu, encrypted_rcu_free);
out:
	kfree(buf);
	return ret;
}
","static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct encrypted_key_payload *epayload = key->payload.data[0];
	struct encrypted_key_payload *new_epayload;
	char *buf;
	char *new_master_desc = NULL;
	const char *format = NULL;
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 
	buf = kmalloc(datalen + 1, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	buf[datalen] = 0;
	memcpy(buf, prep->data, datalen);
	ret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);
	if (ret < 0)
		goto out;

	ret = valid_master_desc(new_master_desc, epayload->master_desc);
	if (ret < 0)
		goto out;

	new_epayload = encrypted_key_alloc(key, epayload->format,
					   new_master_desc, epayload->datalen);
	if (IS_ERR(new_epayload)) {
		ret = PTR_ERR(new_epayload);
		goto out;
	}

	__ekey_init(new_epayload, epayload->format, new_master_desc,
		    epayload->datalen);

	memcpy(new_epayload->iv, epayload->iv, ivsize);
	memcpy(new_epayload->payload_data, epayload->payload_data,
	       epayload->payload_datalen);

	rcu_assign_keypointer(key, new_epayload);
	call_rcu(&epayload->rcu, encrypted_rcu_free);
out:
	kfree(buf);
	return ret;
}
","The `encrypted_update` function updates an encrypted key's payload within a kernel module. It first validates the input data length and allocates a buffer to hold the new data. After parsing the data to extract a new master descriptor, it checks the validity of this descriptor against the existing one. If valid, it allocates a new encrypted key payload and initializes it with the existing format and data. The function then copies the initialization vector and payload data from the old payload to the new one, updates the key pointer to reference the new payload, and schedules the old payload for cleanup before returning the result of the operation.","The function is designed to update an encrypted key's payload by first validating the input data length and ensuring it is properly formatted. It allocates memory for a buffer to hold the new data and parses this data to extract a new master descriptor. After verifying the validity of this descriptor against the existing one, it allocates a new payload structure and initializes it with relevant data from the old payload. The function then copies necessary components from the old payload to the new one, updates the key reference, and schedules the old payload for cleanup before returning the operation's result.","The vulnerability in the original code arises from the lack of handling for a negatively instantiated user key, which can lead to a kernel crash when an error code is cached in the payload area. Specifically, if a key is negatively instantiated and then updated with valid data, the update function does not check for the presence of an error flag, potentially leading to dereferencing a null pointer during cleanup. The fix introduces a check for the `KEY_FLAG_NEGATIVE` flag before proceeding with the update, ensuring that the function returns an error if the key is negatively instantiated, thus preventing the crash and ensuring safer memory management.","The vulnerability in the original code stems from the failure to handle a scenario where a user key is negatively instantiated, resulting in an error code being cached in the payload. If this key is later updated with valid data, the update function does not account for the existing error, which can lead to dereferencing a null pointer and causing a kernel crash. The fix introduces a check for the negative instantiation flag before proceeding with the update, ensuring that the function returns an error if the key is negatively instantiated, thus preventing the crash and improving overall stability.","The vulnerability was fixed by adding a check for the `KEY_FLAG_NEGATIVE` flag in the updated code. Before proceeding with the update, the function now verifies if this flag is set using `test_bit(KEY_FLAG_NEGATIVE, &key->flags)`. If the flag is present, the function immediately returns an error code, specifically `-ENOKEY`, preventing any further processing that could lead to dereferencing a null pointer. This change ensures that the update method is aware of the potential error state of the key, thereby enhancing the robustness and stability of the key management system.","The vulnerability was addressed by implementing a check for a specific error flag that indicates a negatively instantiated key. Before proceeding with any updates, the code now verifies whether this flag is set. If the flag is present, the function immediately returns an error, preventing any further operations that could lead to dereferencing a null pointer. This modification ensures that the update process is aware of the key's error state, thereby preventing potential crashes and enhancing the overall stability and reliability of the key management system.","CWE-476, CWE-119, CWE-415, CWE-416, CWE-401, CWE-824, CWE-690, CWE-908, CWE-465, CWE-457",N,-1
49,49,180706,180706,,Local,Not required,Complete,CVE-2015-8539,https://www.cvedetails.com/cve/CVE-2015-8539/,CWE-264,Low,Complete,Complete,,2016-02-07,7.2,"The KEYS subsystem in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (BUG) via crafted keyctl commands that negatively instantiate a key, related to security/keys/encrypted-keys/encrypted.c, security/keys/trusted.c, and security/keys/user_defined.c.",2018-10-30,DoS +Priv ,4,https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd,096fe9eaea40a17e125569f9e657e34cdb6d73bd,"KEYS: Fix handling of stored error in a negatively instantiated user key

If a user key gets negatively instantiated, an error code is cached in the
payload area.  A negatively instantiated key may be then be positively
instantiated by updating it with valid data.  However, the ->update key
type method must be aware that the error code may be there.

The following may be used to trigger the bug in the user key type:

    keyctl request2 user user """" @u
    keyctl add user user ""a"" @u

which manifests itself as:

	BUG: unable to handle kernel paging request at 00000000ffffff8a
	IP: [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	PGD 7cc30067 PUD 0
	Oops: 0002 [#1] SMP
	Modules linked in:
	CPU: 3 PID: 2644 Comm: a.out Not tainted 4.3.0+ #49
	Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
	task: ffff88003ddea700 ti: ffff88003dd88000 task.ti: ffff88003dd88000
	RIP: 0010:[<ffffffff810a376f>]  [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280
	 [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	RSP: 0018:ffff88003dd8bdb0  EFLAGS: 00010246
	RAX: 00000000ffffff82 RBX: 0000000000000000 RCX: 0000000000000001
	RDX: ffffffff81e3fe40 RSI: 0000000000000000 RDI: 00000000ffffff82
	RBP: ffff88003dd8bde0 R08: ffff88007d2d2da0 R09: 0000000000000000
	R10: 0000000000000000 R11: ffff88003e8073c0 R12: 00000000ffffff82
	R13: ffff88003dd8be68 R14: ffff88007d027600 R15: ffff88003ddea700
	FS:  0000000000b92880(0063) GS:ffff88007fd00000(0000) knlGS:0000000000000000
	CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
	CR2: 00000000ffffff8a CR3: 000000007cc5f000 CR4: 00000000000006e0
	Stack:
	 ffff88003dd8bdf0 ffffffff81160a8a 0000000000000000 00000000ffffff82
	 ffff88003dd8be68 ffff88007d027600 ffff88003dd8bdf0 ffffffff810a39e5
	 ffff88003dd8be20 ffffffff812a31ab ffff88007d027600 ffff88007d027620
	Call Trace:
	 [<ffffffff810a39e5>] kfree_call_rcu+0x15/0x20 kernel/rcu/tree.c:3136
	 [<ffffffff812a31ab>] user_update+0x8b/0xb0 security/keys/user_defined.c:129
	 [<     inline     >] __key_update security/keys/key.c:730
	 [<ffffffff8129e5c1>] key_create_or_update+0x291/0x440 security/keys/key.c:908
	 [<     inline     >] SYSC_add_key security/keys/keyctl.c:125
	 [<ffffffff8129fc21>] SyS_add_key+0x101/0x1e0 security/keys/keyctl.c:60
	 [<ffffffff8185f617>] entry_SYSCALL_64_fastpath+0x12/0x6a arch/x86/entry/entry_64.S:185

Note the error code (-ENOKEY) in EDX.

A similar bug can be tripped by:

    keyctl request2 trusted user """" @u
    keyctl add trusted user ""a"" @u

This should also affect encrypted keys - but that has to be correctly
parameterised or it will fail with EINVAL before getting to the bit that
will crashes.

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
Signed-off-by: James Morris <james.l.morris@oracle.com>",1,security/keys/trusted.c,"{""sha"": ""696ccfa08d103cd29ae56ac38c117bbd7725da06"", ""filename"": ""security/keys/encrypted-keys/encrypted.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/encrypted-keys/encrypted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -845,6 +845,8 @@ static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n \tsize_t datalen = prep->datalen;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\treturn -EINVAL;\n ""}<_**next**_>{""sha"": ""16dec53184b663f745c010d11e78128ca995bf58"", ""filename"": ""security/keys/trusted.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/trusted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -1007,13 +1007,16 @@ static void trusted_rcu_free(struct rcu_head *rcu)\n  */\n static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n {\n-\tstruct trusted_key_payload *p = key->payload.data[0];\n+\tstruct trusted_key_payload *p;\n \tstruct trusted_key_payload *new_p;\n \tstruct trusted_key_options *new_o;\n \tsize_t datalen = prep->datalen;\n \tchar *datablob;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n+\tp = key->payload.data[0];\n \tif (!p->migratable)\n \t\treturn -EPERM;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)""}<_**next**_>{""sha"": ""8705d79b2c6f289736fde21fd38e6013a4e4ae3c"", ""filename"": ""security/keys/user_defined.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/user_defined.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -120,7 +120,10 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n \tif (ret == 0) {\n \t\t/* attach the new data, displacing the old */\n-\t\tzap = key->payload.data[0];\n+\t\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\t\tzap = key->payload.data[0];\n+\t\telse\n+\t\t\tzap = NULL;\n \t\trcu_assign_keypointer(key, upayload);\n \t\tkey->expiry = 0;\n \t}""}"," static int trusted_update(struct key *key, struct key_preparsed_payload *prep)
 {
	struct trusted_key_payload *p;
 	struct trusted_key_payload *new_p;
 	struct trusted_key_options *new_o;
 	size_t datalen = prep->datalen;
 	char *datablob;
 	int ret = 0;
 
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
	p = key->payload.data[0];
 	if (!p->migratable)
 		return -EPERM;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
		return -EINVAL;

	datablob = kmalloc(datalen + 1, GFP_KERNEL);
	if (!datablob)
		return -ENOMEM;
	new_o = trusted_options_alloc();
	if (!new_o) {
		ret = -ENOMEM;
		goto out;
	}
	new_p = trusted_payload_alloc(key);
	if (!new_p) {
		ret = -ENOMEM;
		goto out;
	}

	memcpy(datablob, prep->data, datalen);
	datablob[datalen] = '\0';
	ret = datablob_parse(datablob, new_p, new_o);
	if (ret != Opt_update) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	if (!new_o->keyhandle) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	/* copy old key values, and reseal with new pcrs */
	new_p->migratable = p->migratable;
	new_p->key_len = p->key_len;
	memcpy(new_p->key, p->key, p->key_len);
	dump_payload(p);
	dump_payload(new_p);

	ret = key_seal(new_p, new_o);
	if (ret < 0) {
		pr_info(""trusted_key: key_seal failed (%d)\n"", ret);
		kfree(new_p);
		goto out;
	}
	if (new_o->pcrlock) {
		ret = pcrlock(new_o->pcrlock);
		if (ret < 0) {
			pr_info(""trusted_key: pcrlock failed (%d)\n"", ret);
			kfree(new_p);
			goto out;
		}
	}
	rcu_assign_keypointer(key, new_p);
	call_rcu(&p->rcu, trusted_rcu_free);
out:
	kfree(datablob);
	kfree(new_o);
	return ret;
}
"," static int trusted_update(struct key *key, struct key_preparsed_payload *prep)
 {
	struct trusted_key_payload *p = key->payload.data[0];
 	struct trusted_key_payload *new_p;
 	struct trusted_key_options *new_o;
 	size_t datalen = prep->datalen;
 	char *datablob;
 	int ret = 0;
 
 	if (!p->migratable)
 		return -EPERM;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
		return -EINVAL;

	datablob = kmalloc(datalen + 1, GFP_KERNEL);
	if (!datablob)
		return -ENOMEM;
	new_o = trusted_options_alloc();
	if (!new_o) {
		ret = -ENOMEM;
		goto out;
	}
	new_p = trusted_payload_alloc(key);
	if (!new_p) {
		ret = -ENOMEM;
		goto out;
	}

	memcpy(datablob, prep->data, datalen);
	datablob[datalen] = '\0';
	ret = datablob_parse(datablob, new_p, new_o);
	if (ret != Opt_update) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	if (!new_o->keyhandle) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	/* copy old key values, and reseal with new pcrs */
	new_p->migratable = p->migratable;
	new_p->key_len = p->key_len;
	memcpy(new_p->key, p->key, p->key_len);
	dump_payload(p);
	dump_payload(new_p);

	ret = key_seal(new_p, new_o);
	if (ret < 0) {
		pr_info(""trusted_key: key_seal failed (%d)\n"", ret);
		kfree(new_p);
		goto out;
	}
	if (new_o->pcrlock) {
		ret = pcrlock(new_o->pcrlock);
		if (ret < 0) {
			pr_info(""trusted_key: pcrlock failed (%d)\n"", ret);
			kfree(new_p);
			goto out;
		}
	}
	rcu_assign_keypointer(key, new_p);
	call_rcu(&p->rcu, trusted_rcu_free);
out:
	kfree(datablob);
	kfree(new_o);
	return ret;
}
",C,"	struct trusted_key_payload *p;
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
	p = key->payload.data[0];
","	struct trusted_key_payload *p = key->payload.data[0];
",,"@@ -1007,13 +1007,16 @@ static void trusted_rcu_free(struct rcu_head *rcu)
  */
 static int trusted_update(struct key *key, struct key_preparsed_payload *prep)
 {
-	struct trusted_key_payload *p = key->payload.data[0];
+	struct trusted_key_payload *p;
 	struct trusted_key_payload *new_p;
 	struct trusted_key_options *new_o;
 	size_t datalen = prep->datalen;
 	char *datablob;
 	int ret = 0;
 
+	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
+		return -ENOKEY;
+	p = key->payload.data[0];
 	if (!p->migratable)
 		return -EPERM;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)",linux,096fe9eaea40a17e125569f9e657e34cdb6d73bd,6ffeba9607343f15303a399bc402a538800d89d9,1," static int trusted_update(struct key *key, struct key_preparsed_payload *prep)
 {
//flaw_line_below:
	struct trusted_key_payload *p = key->payload.data[0];
//fix_flaw_line_below:
//	struct trusted_key_payload *p;
 	struct trusted_key_payload *new_p;
 	struct trusted_key_options *new_o;
 	size_t datalen = prep->datalen;
 	char *datablob;
 	int ret = 0;
 
//fix_flaw_line_below:
//	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
//fix_flaw_line_below:
//		return -ENOKEY;
//fix_flaw_line_below:
//	p = key->payload.data[0];
 	if (!p->migratable)
 		return -EPERM;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
		return -EINVAL;

	datablob = kmalloc(datalen + 1, GFP_KERNEL);
	if (!datablob)
		return -ENOMEM;
	new_o = trusted_options_alloc();
	if (!new_o) {
		ret = -ENOMEM;
		goto out;
	}
	new_p = trusted_payload_alloc(key);
	if (!new_p) {
		ret = -ENOMEM;
		goto out;
	}

	memcpy(datablob, prep->data, datalen);
	datablob[datalen] = '\0';
	ret = datablob_parse(datablob, new_p, new_o);
	if (ret != Opt_update) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	if (!new_o->keyhandle) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	/* copy old key values, and reseal with new pcrs */
	new_p->migratable = p->migratable;
	new_p->key_len = p->key_len;
	memcpy(new_p->key, p->key, p->key_len);
	dump_payload(p);
	dump_payload(new_p);

	ret = key_seal(new_p, new_o);
	if (ret < 0) {
		pr_info(""trusted_key: key_seal failed (%d)\n"", ret);
		kfree(new_p);
		goto out;
	}
	if (new_o->pcrlock) {
		ret = pcrlock(new_o->pcrlock);
		if (ret < 0) {
			pr_info(""trusted_key: pcrlock failed (%d)\n"", ret);
			kfree(new_p);
			goto out;
		}
	}
	rcu_assign_keypointer(key, new_p);
	call_rcu(&p->rcu, trusted_rcu_free);
out:
	kfree(datablob);
	kfree(new_o);
	return ret;
}
",180706," static int trusted_update(struct key *key, struct key_preparsed_payload *prep)
 {
	struct trusted_key_payload *p = key->payload.data[0];
 	struct trusted_key_payload *new_p;
 	struct trusted_key_options *new_o;
 	size_t datalen = prep->datalen;
 	char *datablob;
 	int ret = 0;
 
 	if (!p->migratable)
 		return -EPERM;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
		return -EINVAL;

	datablob = kmalloc(datalen + 1, GFP_KERNEL);
	if (!datablob)
		return -ENOMEM;
	new_o = trusted_options_alloc();
	if (!new_o) {
		ret = -ENOMEM;
		goto out;
	}
	new_p = trusted_payload_alloc(key);
	if (!new_p) {
		ret = -ENOMEM;
		goto out;
	}

	memcpy(datablob, prep->data, datalen);
	datablob[datalen] = '\0';
	ret = datablob_parse(datablob, new_p, new_o);
	if (ret != Opt_update) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	if (!new_o->keyhandle) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	/* copy old key values, and reseal with new pcrs */
	new_p->migratable = p->migratable;
	new_p->key_len = p->key_len;
	memcpy(new_p->key, p->key, p->key_len);
	dump_payload(p);
	dump_payload(new_p);

	ret = key_seal(new_p, new_o);
	if (ret < 0) {
		pr_info(""trusted_key: key_seal failed (%d)\n"", ret);
		kfree(new_p);
		goto out;
	}
	if (new_o->pcrlock) {
		ret = pcrlock(new_o->pcrlock);
		if (ret < 0) {
			pr_info(""trusted_key: pcrlock failed (%d)\n"", ret);
			kfree(new_p);
			goto out;
		}
	}
	rcu_assign_keypointer(key, new_p);
	call_rcu(&p->rcu, trusted_rcu_free);
out:
	kfree(datablob);
	kfree(new_o);
	return ret;
}
"," static int trusted_update(struct key *key, struct key_preparsed_payload *prep)
 {
	struct trusted_key_payload *p;
 	struct trusted_key_payload *new_p;
 	struct trusted_key_options *new_o;
 	size_t datalen = prep->datalen;
 	char *datablob;
 	int ret = 0;
 
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
	p = key->payload.data[0];
 	if (!p->migratable)
 		return -EPERM;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
		return -EINVAL;

	datablob = kmalloc(datalen + 1, GFP_KERNEL);
	if (!datablob)
		return -ENOMEM;
	new_o = trusted_options_alloc();
	if (!new_o) {
		ret = -ENOMEM;
		goto out;
	}
	new_p = trusted_payload_alloc(key);
	if (!new_p) {
		ret = -ENOMEM;
		goto out;
	}

	memcpy(datablob, prep->data, datalen);
	datablob[datalen] = '\0';
	ret = datablob_parse(datablob, new_p, new_o);
	if (ret != Opt_update) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	if (!new_o->keyhandle) {
		ret = -EINVAL;
		kfree(new_p);
		goto out;
	}

	/* copy old key values, and reseal with new pcrs */
	new_p->migratable = p->migratable;
	new_p->key_len = p->key_len;
	memcpy(new_p->key, p->key, p->key_len);
	dump_payload(p);
	dump_payload(new_p);

	ret = key_seal(new_p, new_o);
	if (ret < 0) {
		pr_info(""trusted_key: key_seal failed (%d)\n"", ret);
		kfree(new_p);
		goto out;
	}
	if (new_o->pcrlock) {
		ret = pcrlock(new_o->pcrlock);
		if (ret < 0) {
			pr_info(""trusted_key: pcrlock failed (%d)\n"", ret);
			kfree(new_p);
			goto out;
		}
	}
	rcu_assign_keypointer(key, new_p);
	call_rcu(&p->rcu, trusted_rcu_free);
out:
	kfree(datablob);
	kfree(new_o);
	return ret;
}
","The `trusted_update` function updates a trusted key's payload in a secure manner. It first checks if the key is migratable and validates the input data length. If valid, it allocates memory for a new payload and options, then copies and parses the provided data. If parsing is successful and a key handle is present, it retains the original key's properties, seals the new payload with updated options, and potentially locks PCRs (Platform Configuration Registers). Finally, it replaces the old key pointer with the new one and schedules the old payload for cleanup, returning the result of the operation.","The function facilitates the secure update of a trusted key's payload by first verifying its migratability and the validity of the input data. Upon successful validation, it allocates memory for a new payload and options, then processes the provided data. If the data parsing is successful and a necessary key handle is present, it retains the original key's attributes, seals the new payload with updated options, and may lock specific security registers. Finally, it replaces the old key reference with the new one and schedules the old payload for cleanup, returning the outcome of the operation.","The vulnerability in the original code stemmed from the lack of handling for a negatively instantiated key, which could lead to dereferencing a null pointer when attempting to access the key's payload. Specifically, if a key was negatively instantiated, an error code was cached, and the update function did not check for this condition before proceeding, resulting in a kernel crash. The fix introduced a check for the negative flag in the key's flags, ensuring that if the key was negatively instantiated, the function would return an appropriate error code instead of attempting to access the payload, thus preventing the dereferencing issue and enhancing stability.","The vulnerability in the original code arose from the failure to handle a scenario where a user key was negatively instantiated, resulting in an error code being cached in the payload. When an attempt was made to update this key, the code did not check for the presence of the error code, leading to a null pointer dereference and a subsequent kernel crash. The fix implemented a check for the negative instantiation flag before proceeding with the update, ensuring that if the key was negatively instantiated, the function would return an appropriate error code, thus preventing the dereferencing issue and enhancing system stability.","The vulnerability was fixed by adding a check for the negative instantiation flag using `test_bit(KEY_FLAG_NEGATIVE, &key->flags)` at the beginning of the update function. This ensures that if the key is negatively instantiated, the function immediately returns `-ENOKEY`, preventing any further access to the key's payload. By implementing this check, the code avoids dereferencing a null pointer that could occur when trying to access the payload data, thus preventing potential kernel crashes and enhancing the overall stability and security of the key management process.","The vulnerability was addressed by introducing a check at the start of the update process to determine if the key was negatively instantiated. This check ensures that if the key has an associated error code, the function will immediately return an appropriate error response, preventing any further operations on the key's payload. By implementing this safeguard, the code avoids the risk of dereferencing a null pointer, which could lead to system crashes. This fix enhances the robustness of the key management system by ensuring that only valid keys are processed during updates.","CWE-476, CWE-690, CWE-1188, CWE-824, CWE-822, CWE-825, CWE-119, CWE-404, CWE-456, CWE-457",N,-1
50,50,180707,180707,,Local,Not required,Complete,CVE-2015-8539,https://www.cvedetails.com/cve/CVE-2015-8539/,CWE-264,Low,Complete,Complete,,2016-02-07,7.2,"The KEYS subsystem in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (BUG) via crafted keyctl commands that negatively instantiate a key, related to security/keys/encrypted-keys/encrypted.c, security/keys/trusted.c, and security/keys/user_defined.c.",2018-10-30,DoS +Priv ,4,https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd,096fe9eaea40a17e125569f9e657e34cdb6d73bd,"KEYS: Fix handling of stored error in a negatively instantiated user key

If a user key gets negatively instantiated, an error code is cached in the
payload area.  A negatively instantiated key may be then be positively
instantiated by updating it with valid data.  However, the ->update key
type method must be aware that the error code may be there.

The following may be used to trigger the bug in the user key type:

    keyctl request2 user user """" @u
    keyctl add user user ""a"" @u

which manifests itself as:

	BUG: unable to handle kernel paging request at 00000000ffffff8a
	IP: [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	PGD 7cc30067 PUD 0
	Oops: 0002 [#1] SMP
	Modules linked in:
	CPU: 3 PID: 2644 Comm: a.out Not tainted 4.3.0+ #49
	Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
	task: ffff88003ddea700 ti: ffff88003dd88000 task.ti: ffff88003dd88000
	RIP: 0010:[<ffffffff810a376f>]  [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280
	 [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
	RSP: 0018:ffff88003dd8bdb0  EFLAGS: 00010246
	RAX: 00000000ffffff82 RBX: 0000000000000000 RCX: 0000000000000001
	RDX: ffffffff81e3fe40 RSI: 0000000000000000 RDI: 00000000ffffff82
	RBP: ffff88003dd8bde0 R08: ffff88007d2d2da0 R09: 0000000000000000
	R10: 0000000000000000 R11: ffff88003e8073c0 R12: 00000000ffffff82
	R13: ffff88003dd8be68 R14: ffff88007d027600 R15: ffff88003ddea700
	FS:  0000000000b92880(0063) GS:ffff88007fd00000(0000) knlGS:0000000000000000
	CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
	CR2: 00000000ffffff8a CR3: 000000007cc5f000 CR4: 00000000000006e0
	Stack:
	 ffff88003dd8bdf0 ffffffff81160a8a 0000000000000000 00000000ffffff82
	 ffff88003dd8be68 ffff88007d027600 ffff88003dd8bdf0 ffffffff810a39e5
	 ffff88003dd8be20 ffffffff812a31ab ffff88007d027600 ffff88007d027620
	Call Trace:
	 [<ffffffff810a39e5>] kfree_call_rcu+0x15/0x20 kernel/rcu/tree.c:3136
	 [<ffffffff812a31ab>] user_update+0x8b/0xb0 security/keys/user_defined.c:129
	 [<     inline     >] __key_update security/keys/key.c:730
	 [<ffffffff8129e5c1>] key_create_or_update+0x291/0x440 security/keys/key.c:908
	 [<     inline     >] SYSC_add_key security/keys/keyctl.c:125
	 [<ffffffff8129fc21>] SyS_add_key+0x101/0x1e0 security/keys/keyctl.c:60
	 [<ffffffff8185f617>] entry_SYSCALL_64_fastpath+0x12/0x6a arch/x86/entry/entry_64.S:185

Note the error code (-ENOKEY) in EDX.

A similar bug can be tripped by:

    keyctl request2 trusted user """" @u
    keyctl add trusted user ""a"" @u

This should also affect encrypted keys - but that has to be correctly
parameterised or it will fail with EINVAL before getting to the bit that
will crashes.

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
Signed-off-by: James Morris <james.l.morris@oracle.com>",1,security/keys/user_defined.c,"{""sha"": ""696ccfa08d103cd29ae56ac38c117bbd7725da06"", ""filename"": ""security/keys/encrypted-keys/encrypted.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/encrypted-keys/encrypted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/encrypted-keys/encrypted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -845,6 +845,8 @@ static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n \tsize_t datalen = prep->datalen;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\treturn -EINVAL;\n ""}<_**next**_>{""sha"": ""16dec53184b663f745c010d11e78128ca995bf58"", ""filename"": ""security/keys/trusted.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/trusted.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/trusted.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -1007,13 +1007,16 @@ static void trusted_rcu_free(struct rcu_head *rcu)\n  */\n static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n {\n-\tstruct trusted_key_payload *p = key->payload.data[0];\n+\tstruct trusted_key_payload *p;\n \tstruct trusted_key_payload *new_p;\n \tstruct trusted_key_options *new_o;\n \tsize_t datalen = prep->datalen;\n \tchar *datablob;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n+\tp = key->payload.data[0];\n \tif (!p->migratable)\n \t\treturn -EPERM;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)""}<_**next**_>{""sha"": ""8705d79b2c6f289736fde21fd38e6013a4e4ae3c"", ""filename"": ""security/keys/user_defined.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/096fe9eaea40a17e125569f9e657e34cdb6d73bd/security/keys/user_defined.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/keys/user_defined.c?ref=096fe9eaea40a17e125569f9e657e34cdb6d73bd"", ""patch"": ""@@ -120,7 +120,10 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n \tif (ret == 0) {\n \t\t/* attach the new data, displacing the old */\n-\t\tzap = key->payload.data[0];\n+\t\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\t\tzap = key->payload.data[0];\n+\t\telse\n+\t\t\tzap = NULL;\n \t\trcu_assign_keypointer(key, upayload);\n \t\tkey->expiry = 0;\n \t}""}","int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
			zap = key->payload.data[0];
		else
			zap = NULL;
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
","int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
		zap = key->payload.data[0];
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
",C,"		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
			zap = key->payload.data[0];
		else
			zap = NULL;
","		zap = key->payload.data[0];
",,"@@ -120,7 +120,10 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
-		zap = key->payload.data[0];
+		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
+			zap = key->payload.data[0];
+		else
+			zap = NULL;
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}",linux,096fe9eaea40a17e125569f9e657e34cdb6d73bd,6ffeba9607343f15303a399bc402a538800d89d9,1,"int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
//flaw_line_below:
		zap = key->payload.data[0];
//fix_flaw_line_below:
//		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
//fix_flaw_line_below:
//			zap = key->payload.data[0];
//fix_flaw_line_below:
//		else
//fix_flaw_line_below:
//			zap = NULL;
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
",180707,"int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
		zap = key->payload.data[0];
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
","int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
			zap = key->payload.data[0];
		else
			zap = NULL;
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
","The `user_update` function updates a user key's payload in a kernel module, ensuring that the new data adheres to specific constraints. It first checks the validity of the provided data length and pointer, returning an error if they are invalid. If valid, it allocates memory for a new payload and copies the incoming data into it. The function then reserves space for the new data in the key's payload and, if successful, replaces the old payload with the new one while resetting the key's expiry. Finally, it safely frees the old payload memory if it exists, returning the result of the operation.","The code defines a function that updates a user key's associated data within a kernel module. It begins by validating the input data's length and presence, returning an error if the conditions are not met. Upon successful validation, it allocates memory for a new data payload and copies the provided data into this newly allocated space. The function then checks if there is enough reserved space for the new data and, if so, replaces the existing data with the new one while resetting the key's expiration. Finally, it safely deallocates the old data memory if it exists, returning the operation's result.","The vulnerability in the original code arises from the mishandling of a cached error code in the payload area when a user key is negatively instantiated. If a key is negatively instantiated, it may contain an error code that, when the key is updated with valid data, could lead to dereferencing a null pointer, causing a kernel crash. The fix introduces a check to determine if the key is negatively instantiated by using the `test_bit` function on the key's flags. If the key is negative, it sets the pointer to the old payload to `NULL`, preventing the attempt to free an invalid memory address, thus avoiding the crash.","The vulnerability in the original code stems from the improper handling of an error code stored in the payload when a user key is negatively instantiated. If a key is negatively instantiated, it may contain an error code that, when the key is updated with valid data, could lead to dereferencing a null pointer, resulting in a kernel crash. The fix addresses this by introducing a check to determine if the key is negatively instantiated, ensuring that the old payload is only freed if it is valid. This prevents attempts to free a null pointer, thereby avoiding the crash and ensuring safer memory management.","The vulnerability was fixed by adding a check using the `test_bit` function to determine if the key is negatively instantiated before attempting to free the old payload. In the updated code, if the key is negative, the pointer `zap` is set to `NULL`, preventing the code from trying to free an invalid memory address. This change ensures that the `kfree_rcu` function is only called with a valid pointer, thus avoiding potential null pointer dereferences that could lead to kernel crashes. This fix enhances the robustness of the key update process by properly managing memory associated with user keys.","The vulnerability was addressed by implementing a check to determine if the key was negatively instantiated before attempting to free the old payload. This check ensures that the code only attempts to deallocate memory if it is valid, thereby preventing the potential dereferencing of a null pointer. By setting the pointer to the old payload to null when the key is negative, the updated code avoids any attempts to free invalid memory. This change enhances the safety and stability of the key update process, preventing crashes that could occur from improper memory management.","CWE-476,CWE-825,CWE-416,CWE-415,CWE-690,CWE-763,CWE-672,CWE-401,CWE-457,CWE-824",N,-1
51,51,181632,181632,,Remote,Single system,Partial,CVE-2016-10318,https://www.cvedetails.com/cve/CVE-2016-10318/,CWE-264,Low,,,,2017-04-04,4.0,"A missing authorization check in the fscrypt_process_policy function in fs/crypto/policy.c in the ext4 and f2fs filesystem encryption support in the Linux kernel before 4.7.4 allows a user to assign an encryption policy to a directory owned by a different user, potentially creating a denial of service.",2017-04-11,DoS ,3,https://github.com/torvalds/linux/commit/163ae1c6ad6299b19e22b4a35d5ab24a89791a98,163ae1c6ad6299b19e22b4a35d5ab24a89791a98,"fscrypto: add authorization check for setting encryption policy

On an ext4 or f2fs filesystem with file encryption supported, a user
could set an encryption policy on any empty directory(*) to which they
had readonly access.  This is obviously problematic, since such a
directory might be owned by another user and the new encryption policy
would prevent that other user from creating files in their own directory
(for example).

Fix this by requiring inode_owner_or_capable() permission to set an
encryption policy.  This means that either the caller must own the file,
or the caller must have the capability CAP_FOWNER.

(*) Or also on any regular file, for f2fs v4.6 and later and ext4
    v4.8-rc1 and later; a separate bug fix is coming for that.

Signed-off-by: Eric Biggers <ebiggers@google.com>
Cc: stable@vger.kernel.org # 4.1+; check fs/{ext4,f2fs}
Signed-off-by: Theodore Ts'o <tytso@mit.edu>",0,fs/crypto/policy.c,"{""sha"": ""c9800b1a2e930f65e8fa7a9b052fb80efeba512c"", ""filename"": ""fs/crypto/policy.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/163ae1c6ad6299b19e22b4a35d5ab24a89791a98/fs/crypto/policy.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/163ae1c6ad6299b19e22b4a35d5ab24a89791a98/fs/crypto/policy.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/crypto/policy.c?ref=163ae1c6ad6299b19e22b4a35d5ab24a89791a98"", ""patch"": ""@@ -95,6 +95,9 @@ static int create_encryption_context_from_policy(struct inode *inode,\n int fscrypt_process_policy(struct inode *inode,\n \t\t\t\tconst struct fscrypt_policy *policy)\n {\n+\tif (!inode_owner_or_capable(inode))\n+\t\treturn -EACCES;\n+\n \tif (policy->version != 0)\n \t\treturn -EINVAL;\n ""}"," int fscrypt_process_policy(struct inode *inode,
 				const struct fscrypt_policy *policy)
 {
	if (!inode_owner_or_capable(inode))
		return -EACCES;

 	if (policy->version != 0)
 		return -EINVAL;
 
	if (!inode_has_encryption_context(inode)) {
		if (!inode->i_sb->s_cop->empty_dir)
			return -EOPNOTSUPP;
		if (!inode->i_sb->s_cop->empty_dir(inode))
			return -ENOTEMPTY;
		return create_encryption_context_from_policy(inode, policy);
	}

	if (is_encryption_context_consistent_with_policy(inode, policy))
		return 0;

	printk(KERN_WARNING ""%s: Policy inconsistent with encryption context\n"",
	       __func__);
	return -EINVAL;
}
"," int fscrypt_process_policy(struct inode *inode,
 				const struct fscrypt_policy *policy)
 {
 	if (policy->version != 0)
 		return -EINVAL;
 
	if (!inode_has_encryption_context(inode)) {
		if (!inode->i_sb->s_cop->empty_dir)
			return -EOPNOTSUPP;
		if (!inode->i_sb->s_cop->empty_dir(inode))
			return -ENOTEMPTY;
		return create_encryption_context_from_policy(inode, policy);
	}

	if (is_encryption_context_consistent_with_policy(inode, policy))
		return 0;

	printk(KERN_WARNING ""%s: Policy inconsistent with encryption context\n"",
	       __func__);
	return -EINVAL;
}
",C,"	if (!inode_owner_or_capable(inode))
		return -EACCES;

",,,"@@ -95,6 +95,9 @@ static int create_encryption_context_from_policy(struct inode *inode,
 int fscrypt_process_policy(struct inode *inode,
 				const struct fscrypt_policy *policy)
 {
+	if (!inode_owner_or_capable(inode))
+		return -EACCES;
+
 	if (policy->version != 0)
 		return -EINVAL;
 ",linux,163ae1c6ad6299b19e22b4a35d5ab24a89791a98,c6935931c1894ff857616ff8549b61236a19148f,1," int fscrypt_process_policy(struct inode *inode,
 				const struct fscrypt_policy *policy)
 {
//fix_flaw_line_below:
//	if (!inode_owner_or_capable(inode))
//fix_flaw_line_below:
//		return -EACCES;
//fix_flaw_line_below:
//
 	if (policy->version != 0)
 		return -EINVAL;
 
	if (!inode_has_encryption_context(inode)) {
		if (!inode->i_sb->s_cop->empty_dir)
			return -EOPNOTSUPP;
		if (!inode->i_sb->s_cop->empty_dir(inode))
			return -ENOTEMPTY;
		return create_encryption_context_from_policy(inode, policy);
	}

	if (is_encryption_context_consistent_with_policy(inode, policy))
		return 0;

	printk(KERN_WARNING ""%s: Policy inconsistent with encryption context\n"",
	       __func__);
	return -EINVAL;
}
",181632," int fscrypt_process_policy(struct inode *inode,
 				const struct fscrypt_policy *policy)
 {
 	if (policy->version != 0)
 		return -EINVAL;
 
	if (!inode_has_encryption_context(inode)) {
		if (!inode->i_sb->s_cop->empty_dir)
			return -EOPNOTSUPP;
		if (!inode->i_sb->s_cop->empty_dir(inode))
			return -ENOTEMPTY;
		return create_encryption_context_from_policy(inode, policy);
	}

	if (is_encryption_context_consistent_with_policy(inode, policy))
		return 0;

	printk(KERN_WARNING ""%s: Policy inconsistent with encryption context\n"",
	       __func__);
	return -EINVAL;
}
"," int fscrypt_process_policy(struct inode *inode,
 				const struct fscrypt_policy *policy)
 {
	if (!inode_owner_or_capable(inode))
		return -EACCES;

 	if (policy->version != 0)
 		return -EINVAL;
 
	if (!inode_has_encryption_context(inode)) {
		if (!inode->i_sb->s_cop->empty_dir)
			return -EOPNOTSUPP;
		if (!inode->i_sb->s_cop->empty_dir(inode))
			return -ENOTEMPTY;
		return create_encryption_context_from_policy(inode, policy);
	}

	if (is_encryption_context_consistent_with_policy(inode, policy))
		return 0;

	printk(KERN_WARNING ""%s: Policy inconsistent with encryption context\n"",
	       __func__);
	return -EINVAL;
}
","The `fscrypt_process_policy` function processes a filesystem encryption policy for a given inode. It first checks if the policy version is valid; if not, it returns an error. If the inode does not have an existing encryption context, it verifies if the filesystem supports empty directories and whether the directory is indeed empty before creating a new encryption context based on the provided policy. If the inode already has an encryption context, the function checks for consistency with the new policy. If inconsistencies are found, it logs a warning and returns an error.","The function processes a filesystem encryption policy for a specified inode by first validating the policy version. If the inode lacks an encryption context, it checks whether the filesystem allows empty directories and if the directory is empty before creating a new encryption context based on the policy. If an encryption context already exists, the function verifies its consistency with the new policy. In cases of inconsistency, a warning is logged, and an error is returned. This ensures that the inode's encryption settings align with the specified policy requirements.","The vulnerability in the original code allowed any user with read-only access to set an encryption policy on an empty directory, potentially owned by another user, which could prevent the owner from creating files. This issue arose because there was no authorization check before modifying the encryption policy. The fix introduced a call to `inode_owner_or_capable()`, ensuring that only the owner of the inode or a user with the appropriate capability can set the encryption policy. This change effectively restricts unauthorized modifications, enhancing security by preventing users from altering policies on directories they do not own.","The vulnerability in the original code allowed users with read-only access to set encryption policies on empty directories, potentially owned by others, which could disrupt the owner's ability to create files. This lack of authorization checks posed a significant security risk, as it enabled unauthorized modifications to directory properties. The fix implemented an authorization requirement, ensuring that only the owner of the directory or a user with specific capabilities could set the encryption policy. This change effectively mitigated the risk of unauthorized access and modifications, thereby protecting the integrity of directory ownership and functionality.","The vulnerability was fixed by introducing a check using the `inode_owner_or_capable()` function before allowing the setting of an encryption policy. This ensures that only the user who owns the inode or has the necessary capability can modify the encryption policy. By adding this authorization requirement, the code prevents unauthorized users from applying encryption policies to directories they do not own, thereby safeguarding the directory's functionality and preventing potential disruptions to other users' access. This change effectively enhances security by enforcing proper ownership and permission checks in the encryption policy setting process.","The vulnerability was fixed by implementing an authorization check that requires the user to either own the directory or possess specific capabilities before they can set an encryption policy. This change ensures that only authorized users can modify the encryption settings, preventing unauthorized access and potential disruptions to the functionality of directories owned by others. By enforcing this requirement, the code now protects the integrity of directory ownership and ensures that users cannot impose encryption policies that could hinder the operations of other users, thereby enhancing overall security within the filesystem.","CWE-285, CWE-732, CWE-284, CWE-264, CWE-269, CWE-266, CWE-749, CWE-862, CWE-723, CWE-282",N,-1
52,52,181689,181689,,Local,Not required,Complete,CVE-2016-10156,https://www.cvedetails.com/cve/CVE-2016-10156/,CWE-264,Low,Complete,Complete,,2017-01-23,7.2,"A flaw in systemd v228 in /src/basic/fs-util.c caused world writable suid files to be created when using the systemd timers features, allowing local attackers to escalate their privileges to root. This is fixed in v229.",2017-07-25,,2,https://github.com/systemd/systemd/commit/06eeacb6fe029804f296b065b3ce91e796e1cd0e,06eeacb6fe029804f296b065b3ce91e796e1cd0e,"basic: fix touch() creating files with 07777 mode

mode_t is unsigned, so MODE_INVALID < 0 can never be true.

This fixes a possible DoS where any user could fill /run by writing to
a world-writable /run/systemd/show-status.",1,src/basic/fs-util.c,"{""sha"": ""61b651b573afb3f2d7f9e74830063728577e71de"", ""filename"": ""src/basic/fs-util.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/systemd/systemd/blob/06eeacb6fe029804f296b065b3ce91e796e1cd0e/src/basic/fs-util.c"", ""raw_url"": ""https://github.com/systemd/systemd/raw/06eeacb6fe029804f296b065b3ce91e796e1cd0e/src/basic/fs-util.c"", ""contents_url"": ""https://api.github.com/repos/systemd/systemd/contents/src/basic/fs-util.c?ref=06eeacb6fe029804f296b065b3ce91e796e1cd0e"", ""patch"": ""@@ -341,7 +341,8 @@ int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gi\n         if (parents)\n                 mkdir_parents(path, 0755);\n \n-        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);\n+        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,\n+                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);\n         if (fd < 0)\n                 return -errno;\n ""}","int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {
        _cleanup_close_ int fd;
        int r;

        assert(path);

         if (parents)
                 mkdir_parents(path, 0755);
 
        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,
                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);
         if (fd < 0)
                 return -errno;
 
        if (mode != MODE_INVALID) {
                r = fchmod(fd, mode);
                if (r < 0)
                        return -errno;
        }

        if (uid != UID_INVALID || gid != GID_INVALID) {
                r = fchown(fd, uid, gid);
                if (r < 0)
                        return -errno;
        }

        if (stamp != USEC_INFINITY) {
                struct timespec ts[2];

                timespec_store(&ts[0], stamp);
                ts[1] = ts[0];
                r = futimens(fd, ts);
        } else
                r = futimens(fd, NULL);
        if (r < 0)
                return -errno;

        return 0;
}
","int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {
        _cleanup_close_ int fd;
        int r;

        assert(path);

         if (parents)
                 mkdir_parents(path, 0755);
 
        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);
         if (fd < 0)
                 return -errno;
 
        if (mode != MODE_INVALID) {
                r = fchmod(fd, mode);
                if (r < 0)
                        return -errno;
        }

        if (uid != UID_INVALID || gid != GID_INVALID) {
                r = fchown(fd, uid, gid);
                if (r < 0)
                        return -errno;
        }

        if (stamp != USEC_INFINITY) {
                struct timespec ts[2];

                timespec_store(&ts[0], stamp);
                ts[1] = ts[0];
                r = futimens(fd, ts);
        } else
                r = futimens(fd, NULL);
        if (r < 0)
                return -errno;

        return 0;
}
",C,"        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,
                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);
","        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);
",,"@@ -341,7 +341,8 @@ int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gi
         if (parents)
                 mkdir_parents(path, 0755);
 
-        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);
+        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,
+                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);
         if (fd < 0)
                 return -errno;
 ",systemd,06eeacb6fe029804f296b065b3ce91e796e1cd0e,7d82cd4d53f88402edc923f5020c9ad22f9dc154,1,"int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {
        _cleanup_close_ int fd;
        int r;

        assert(path);

         if (parents)
                 mkdir_parents(path, 0755);
 
//flaw_line_below:
        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);
//fix_flaw_line_below:
//        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,
//fix_flaw_line_below:
//                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);
         if (fd < 0)
                 return -errno;
 
        if (mode != MODE_INVALID) {
                r = fchmod(fd, mode);
                if (r < 0)
                        return -errno;
        }

        if (uid != UID_INVALID || gid != GID_INVALID) {
                r = fchown(fd, uid, gid);
                if (r < 0)
                        return -errno;
        }

        if (stamp != USEC_INFINITY) {
                struct timespec ts[2];

                timespec_store(&ts[0], stamp);
                ts[1] = ts[0];
                r = futimens(fd, ts);
        } else
                r = futimens(fd, NULL);
        if (r < 0)
                return -errno;

        return 0;
}
",181689,"int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {
        _cleanup_close_ int fd;
        int r;

        assert(path);

         if (parents)
                 mkdir_parents(path, 0755);
 
        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);
         if (fd < 0)
                 return -errno;
 
        if (mode != MODE_INVALID) {
                r = fchmod(fd, mode);
                if (r < 0)
                        return -errno;
        }

        if (uid != UID_INVALID || gid != GID_INVALID) {
                r = fchown(fd, uid, gid);
                if (r < 0)
                        return -errno;
        }

        if (stamp != USEC_INFINITY) {
                struct timespec ts[2];

                timespec_store(&ts[0], stamp);
                ts[1] = ts[0];
                r = futimens(fd, ts);
        } else
                r = futimens(fd, NULL);
        if (r < 0)
                return -errno;

        return 0;
}
","int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {
        _cleanup_close_ int fd;
        int r;

        assert(path);

         if (parents)
                 mkdir_parents(path, 0755);
 
        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,
                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);
         if (fd < 0)
                 return -errno;
 
        if (mode != MODE_INVALID) {
                r = fchmod(fd, mode);
                if (r < 0)
                        return -errno;
        }

        if (uid != UID_INVALID || gid != GID_INVALID) {
                r = fchown(fd, uid, gid);
                if (r < 0)
                        return -errno;
        }

        if (stamp != USEC_INFINITY) {
                struct timespec ts[2];

                timespec_store(&ts[0], stamp);
                ts[1] = ts[0];
                r = futimens(fd, ts);
        } else
                r = futimens(fd, NULL);
        if (r < 0)
                return -errno;

        return 0;
}
","The `touch_file` function creates or updates a file at the specified `path`, with options to create parent directories if needed. It accepts parameters for setting the file's timestamp, user ID, group ID, and permissions. The function first ensures the parent directories exist (if specified), then opens the file with write permissions, creating it if it doesn't exist. It updates the file's mode and ownership based on the provided values, and sets the file's access and modification times. If any operation fails, it returns an error code; otherwise, it returns 0 upon successful completion.","The provided code defines a function that creates or updates a file at a specified location, with the option to create any necessary parent directories. It allows for setting the file's timestamp, user and group ownership, and permissions. The function first checks for the existence of parent directories and creates them if required. It then opens the file for writing, applying the specified permissions and ownership. Finally, it updates the file's access and modification times based on the provided timestamp. The function returns an error code if any operation fails, or zero upon successful execution.","The vulnerability in the original code stemmed from the handling of the `mode` variable, which is unsigned, leading to the incorrect assumption that `MODE_INVALID` could be less than zero. This oversight allowed any user to create files with overly permissive permissions (07777), potentially leading to a denial of service by filling the `/run` directory with world-writable files. The fix involved changing the condition to check if `mode` is zero or `MODE_INVALID`, ensuring that the default permission of 0644 is applied when the mode is invalid, thus preventing the creation of insecure files and mitigating the risk of unauthorized access.","The vulnerability in the original code arose from the incorrect handling of a variable that was unsigned, leading to a situation where an invalid mode could result in files being created with overly permissive permissions, specifically 07777. This flaw allowed any user to create world-writable files, which could be exploited to fill the `/run` directory, potentially causing a denial of service. The fix involved modifying the condition that checks for an invalid mode, ensuring that a default permission was applied when the mode was invalid, thereby preventing the creation of insecure files and mitigating the risk of unauthorized access.","The vulnerability was fixed by modifying the condition that checks the `mode` variable when opening a file. In the original code, the check for `MODE_INVALID` was flawed because `mode_t` is unsigned, making it impossible for `MODE_INVALID` to be less than zero. The updated code now checks if `mode` is zero or `MODE_INVALID`, ensuring that if either condition is true, the default permission of 0644 is applied instead of allowing potentially dangerous permissions like 07777. This change effectively prevents the creation of world-writable files, thereby mitigating the risk of denial of service.","The vulnerability was addressed by altering the condition that determines the file permissions during file creation. The fix involved ensuring that if the specified mode was either zero or marked as invalid, a safe default permission was applied instead of allowing potentially insecure permissions. This change effectively prevented the creation of files with overly permissive settings, which could have been exploited to allow unauthorized access and fill a critical system directory. By implementing this check, the code now safeguards against the risk of denial of service and enhances overall security.","CWE-732, CWE-276, CWE-281, CWE-266, CWE-264, CWE-269, CWE-668, CWE-73, CWE-400, CWE-280",N,-1
53,53,181817,181817,,Local,Not required,Complete,CVE-2016-10044,https://www.cvedetails.com/cve/CVE-2016-10044/,CWE-264,Low,Complete,Complete,,2017-02-07,7.2,"The aio_mount function in fs/aio.c in the Linux kernel before 4.7.7 does not properly restrict execute access, which makes it easier for local users to bypass intended SELinux W^X policy restrictions, and consequently gain privileges, via an io_setup system call.",2017-07-24,+Priv Bypass ,6,https://github.com/torvalds/linux/commit/22f6b4d34fcf039c63a94e7670e0da24f8575a5a,22f6b4d34fcf039c63a94e7670e0da24f8575a5a,"aio: mark AIO pseudo-fs noexec

This ensures that do_mmap() won't implicitly make AIO memory mappings
executable if the READ_IMPLIES_EXEC personality flag is set.  Such
behavior is problematic because the security_mmap_file LSM hook doesn't
catch this case, potentially permitting an attacker to bypass a W^X
policy enforced by SELinux.

I have tested the patch on my machine.

To test the behavior, compile and run this:

    #define _GNU_SOURCE
    #include <unistd.h>
    #include <sys/personality.h>
    #include <linux/aio_abi.h>
    #include <err.h>
    #include <stdlib.h>
    #include <stdio.h>
    #include <sys/syscall.h>

    int main(void) {
        personality(READ_IMPLIES_EXEC);
        aio_context_t ctx = 0;
        if (syscall(__NR_io_setup, 1, &ctx))
            err(1, ""io_setup"");

        char cmd[1000];
        sprintf(cmd, ""cat /proc/%d/maps | grep -F '/[aio]'"",
            (int)getpid());
        system(cmd);
        return 0;
    }

In the output, ""rw-s"" is good, ""rwxs"" is bad.

Signed-off-by: Jann Horn <jann@thejh.net>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",1,fs/aio.c,"{""sha"": ""4fe81d1c60f962b53392a6b4b0d047f129509c87"", ""filename"": ""fs/aio.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/22f6b4d34fcf039c63a94e7670e0da24f8575a5a/fs/aio.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/22f6b4d34fcf039c63a94e7670e0da24f8575a5a/fs/aio.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/aio.c?ref=22f6b4d34fcf039c63a94e7670e0da24f8575a5a"", ""patch"": ""@@ -239,7 +239,12 @@ static struct dentry *aio_mount(struct file_system_type *fs_type,\n \tstatic const struct dentry_operations ops = {\n \t\t.d_dname\t= simple_dname,\n \t};\n-\treturn mount_pseudo(fs_type, \""aio:\"", NULL, &ops, AIO_RING_MAGIC);\n+\tstruct dentry *root = mount_pseudo(fs_type, \""aio:\"", NULL, &ops,\n+\t\t\t\t\t   AIO_RING_MAGIC);\n+\n+\tif (!IS_ERR(root))\n+\t\troot->d_sb->s_iflags |= SB_I_NOEXEC;\n+\treturn root;\n }\n \n /* aio_setup""}","static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, &ops,
					   AIO_RING_MAGIC);

	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	return root;
 }
","static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
	return mount_pseudo(fs_type, ""aio:"", NULL, &ops, AIO_RING_MAGIC);
 }
",C,"	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, &ops,
					   AIO_RING_MAGIC);

	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	return root;
","	return mount_pseudo(fs_type, ""aio:"", NULL, &ops, AIO_RING_MAGIC);
",,"@@ -239,7 +239,12 @@ static struct dentry *aio_mount(struct file_system_type *fs_type,
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
-	return mount_pseudo(fs_type, ""aio:"", NULL, &ops, AIO_RING_MAGIC);
+	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, &ops,
+					   AIO_RING_MAGIC);
+
+	if (!IS_ERR(root))
+		root->d_sb->s_iflags |= SB_I_NOEXEC;
+	return root;
 }
 
 /* aio_setup",linux,22f6b4d34fcf039c63a94e7670e0da24f8575a5a,024c7e3756d8a42fc41fe8a9488488b9b09d1dcc,1,"static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
//flaw_line_below:
	return mount_pseudo(fs_type, ""aio:"", NULL, &ops, AIO_RING_MAGIC);
//fix_flaw_line_below:
//	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, &ops,
//fix_flaw_line_below:
//					   AIO_RING_MAGIC);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (!IS_ERR(root))
//fix_flaw_line_below:
//		root->d_sb->s_iflags |= SB_I_NOEXEC;
//fix_flaw_line_below:
//	return root;
 }
",181817,"static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
	return mount_pseudo(fs_type, ""aio:"", NULL, &ops, AIO_RING_MAGIC);
 }
","static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, &ops,
					   AIO_RING_MAGIC);

	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	return root;
 }
","The provided code defines a function `aio_mount` that is responsible for mounting a pseudo-filesystem in a Linux kernel module. It takes parameters such as the filesystem type, flags, device name, and additional data. Within the function, a static structure `dentry_operations` is initialized with a single operation, `d_dname`, which is set to `simple_dname`. The function then calls `mount_pseudo`, passing the filesystem type, a string identifier ""aio:"", a NULL pointer for the root dentry, the operations structure, and a magic number `AIO_RING_MAGIC`, effectively creating a new mount point for the asynchronous I/O subsystem.","The code defines a function that facilitates the mounting of a pseudo-filesystem within a kernel module. It accepts parameters related to the filesystem type, flags, device name, and additional data. A structure is initialized to specify operations related to directory entries, particularly for naming. The function then invokes a mounting process, providing the filesystem type, a unique identifier for the pseudo-filesystem, a null pointer for the root directory, the operations structure, and a specific magic number. This process effectively establishes a new mount point for managing asynchronous input/output operations in the system.","The vulnerability in the original code arises from the lack of a mechanism to prevent the execution of memory mappings created by the asynchronous I/O pseudo-filesystem, which could lead to security issues if the READ_IMPLIES_EXEC personality flag is set. This oversight allows an attacker to potentially bypass the Write XOR Execute (W^X) policy enforced by SELinux, as the security_mmap_file LSM hook does not address this scenario. The fix introduces a line that sets the `s_iflags` of the root's superblock to include `SB_I_NOEXEC`, effectively marking the filesystem as non-executable and mitigating the risk of unintended executable memory mappings.","The vulnerability in the original code stems from the potential for memory mappings created by the asynchronous I/O pseudo-filesystem to be executed when the READ_IMPLIES_EXEC personality flag is enabled. This situation poses a security risk, as it allows an attacker to circumvent the Write XOR Execute (W^X) policy enforced by the security framework, which is not adequately addressed by existing security hooks. The fix involves marking the pseudo-filesystem as non-executable, ensuring that memory mappings cannot be executed, thereby closing the security loophole and preventing unauthorized execution of mapped memory.","The vulnerability was fixed by adding a line of code that modifies the superblock's flags for the root directory entry. Specifically, the code sets the `s_iflags` of the superblock to include `SB_I_NOEXEC`. This change ensures that the asynchronous I/O pseudo-filesystem is marked as non-executable, preventing the `do_mmap()` function from creating executable memory mappings when the READ_IMPLIES_EXEC personality flag is set. By implementing this fix, the code effectively mitigates the risk of bypassing the Write XOR Execute (W^X) policy enforced by SELinux, enhancing the overall security of the system.","The vulnerability was addressed by implementing a mechanism that marks the asynchronous I/O pseudo-filesystem as non-executable. This adjustment prevents the creation of executable memory mappings, particularly when a specific personality flag is enabled, which could otherwise allow unauthorized execution of mapped memory. By modifying the filesystem's attributes to disallow execution, the fix effectively closes the security loophole that could have been exploited to bypass existing security policies. This enhancement ensures that the system maintains stricter control over memory execution rights, thereby improving overall security against potential attacks.","CWE-434, CWE-284, CWE-264, CWE-668, CWE-269, CWE-732, CWE-276, CWE-272, CWE-250, CWE-749",N,-1
54,54,182067,182067,,Remote,Not required,Complete,CVE-2014-9922,https://www.cvedetails.com/cve/CVE-2014-9922/,CWE-264,Medium,Complete,Complete,,2017-04-04,9.3,"The eCryptfs subsystem in the Linux kernel before 3.18 allows local users to gain privileges via a large filesystem stack that includes an overlayfs layer, related to fs/ecryptfs/main.c and fs/overlayfs/super.c.",2017-07-10,+Priv ,7,https://github.com/torvalds/linux/commit/69c433ed2ecd2d3264efd7afec4439524b319121,69c433ed2ecd2d3264efd7afec4439524b319121,"fs: limit filesystem stacking depth

Add a simple read-only counter to super_block that indicates how deep this
is in the stack of filesystems.  Previously ecryptfs was the only stackable
filesystem and it explicitly disallowed multiple layers of itself.

Overlayfs, however, can be stacked recursively and also may be stacked
on top of ecryptfs or vice versa.

To limit the kernel stack usage we must limit the depth of the
filesystem stack.  Initially the limit is set to 2.

Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>",0,fs/ecryptfs/main.c,"{""sha"": ""c4cd1fd86cc2ffd4a09beddd3aca3f25d1fdb06f"", ""filename"": ""fs/ecryptfs/main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/69c433ed2ecd2d3264efd7afec4439524b319121/fs/ecryptfs/main.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/69c433ed2ecd2d3264efd7afec4439524b319121/fs/ecryptfs/main.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ecryptfs/main.c?ref=69c433ed2ecd2d3264efd7afec4439524b319121"", ""patch"": ""@@ -566,6 +566,13 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags\n \ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n \ts->s_blocksize = path.dentry->d_sb->s_blocksize;\n \ts->s_magic = ECRYPTFS_SUPER_MAGIC;\n+\ts->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;\n+\n+\trc = -EINVAL;\n+\tif (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n+\t\tpr_err(\""eCryptfs: maximum fs stacking depth exceeded\\n\"");\n+\t\tgoto out_free;\n+\t}\n \n \tinode = ecryptfs_get_inode(path.dentry->d_inode, s);\n \trc = PTR_ERR(inode);""}<_**next**_>{""sha"": ""08b704cebfc4f8819944e09b05f5f7de35659b92"", ""filename"": ""fs/overlayfs/super.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/69c433ed2ecd2d3264efd7afec4439524b319121/fs/overlayfs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/69c433ed2ecd2d3264efd7afec4439524b319121/fs/overlayfs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/overlayfs/super.c?ref=69c433ed2ecd2d3264efd7afec4439524b319121"", ""patch"": ""@@ -677,6 +677,15 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)\n \t}\n \tufs->lower_namelen = statfs.f_namelen;\n \n+\tsb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,\n+\t\t\t\tlowerpath.mnt->mnt_sb->s_stack_depth) + 1;\n+\n+\terr = -EINVAL;\n+\tif (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n+\t\tpr_err(\""overlayfs: maximum fs stacking depth exceeded\\n\"");\n+\t\tgoto out_put_workpath;\n+\t}\n+\n \tufs->upper_mnt = clone_private_mount(&upperpath);\n \terr = PTR_ERR(ufs->upper_mnt);\n \tif (IS_ERR(ufs->upper_mnt)) {""}<_**next**_>{""sha"": ""4e41a4a331bbf96c4b59c05cd9a0c522efec92ca"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/torvalds/linux/blob/69c433ed2ecd2d3264efd7afec4439524b319121/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/69c433ed2ecd2d3264efd7afec4439524b319121/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=69c433ed2ecd2d3264efd7afec4439524b319121"", ""patch"": ""@@ -261,6 +261,12 @@ struct iattr {\n  */\n #include <linux/quota.h>\n \n+/*\n+ * Maximum number of layers of fs stack.  Needs to be limited to\n+ * prevent kernel stack overflow\n+ */\n+#define FILESYSTEM_MAX_STACK_DEPTH 2\n+\n /** \n  * enum positive_aop_returns - aop return codes with specific semantics\n  *\n@@ -1273,6 +1279,11 @@ struct super_block {\n \tstruct list_lru\t\ts_dentry_lru ____cacheline_aligned_in_smp;\n \tstruct list_lru\t\ts_inode_lru ____cacheline_aligned_in_smp;\n \tstruct rcu_head\t\trcu;\n+\n+\t/*\n+\t * Indicates how deep in a filesystem stack this SB is\n+\t */\n+\tint s_stack_depth;\n };\n \n extern struct timespec current_fs_time(struct super_block *sb);""}","static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
	const char *err = ""Getting sb failed"";
	struct inode *inode;
	struct path path;
	uid_t check_ruid;
	int rc;

	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
		goto out;
	}

	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
	if (rc) {
		err = ""Error parsing options"";
		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, flags, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
			""known incompatibilities\n"");
		goto out_free;
	}

	if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
			i_uid_read(path.dentry->d_inode),
			from_kuid(&init_user_ns, current_uid()));
		goto out_free;
	}

	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);

	/**
	 * Set the POSIX ACL flag based on whether they're enabled in the lower
	 * mount. Force a read-only eCryptfs mount if the lower mount is ro.
	 * Allow a ro eCryptfs mount even when the lower mount is rw.
	 */
	s->s_flags = flags & ~MS_POSIXACL;
	s->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);

 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
	s->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;

	rc = -EINVAL;
	if (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""eCryptfs: maximum fs stacking depth exceeded\n"");
		goto out_free;
	}
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_make_root(inode);
	if (!s->s_root) {
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	root_info->lower_path = path;

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
","static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
	const char *err = ""Getting sb failed"";
	struct inode *inode;
	struct path path;
	uid_t check_ruid;
	int rc;

	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
		goto out;
	}

	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
	if (rc) {
		err = ""Error parsing options"";
		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, flags, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
			""known incompatibilities\n"");
		goto out_free;
	}

	if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
			i_uid_read(path.dentry->d_inode),
			from_kuid(&init_user_ns, current_uid()));
		goto out_free;
	}

	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);

	/**
	 * Set the POSIX ACL flag based on whether they're enabled in the lower
	 * mount. Force a read-only eCryptfs mount if the lower mount is ro.
	 * Allow a ro eCryptfs mount even when the lower mount is rw.
	 */
	s->s_flags = flags & ~MS_POSIXACL;
	s->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);

 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_make_root(inode);
	if (!s->s_root) {
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	root_info->lower_path = path;

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
",C,"	s->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;

	rc = -EINVAL;
	if (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""eCryptfs: maximum fs stacking depth exceeded\n"");
		goto out_free;
	}
",,,"@@ -566,6 +566,13 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
+	s->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;
+
+	rc = -EINVAL;
+	if (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
+		pr_err(""eCryptfs: maximum fs stacking depth exceeded\n"");
+		goto out_free;
+	}
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);",linux,69c433ed2ecd2d3264efd7afec4439524b319121,7c37fbda85ceb9be7bdb9d5f53e702efc40cf783,1,"static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
	const char *err = ""Getting sb failed"";
	struct inode *inode;
	struct path path;
	uid_t check_ruid;
	int rc;

	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
		goto out;
	}

	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
	if (rc) {
		err = ""Error parsing options"";
		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, flags, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
			""known incompatibilities\n"");
		goto out_free;
	}

	if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
			i_uid_read(path.dentry->d_inode),
			from_kuid(&init_user_ns, current_uid()));
		goto out_free;
	}

	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);

	/**
	 * Set the POSIX ACL flag based on whether they're enabled in the lower
	 * mount. Force a read-only eCryptfs mount if the lower mount is ro.
	 * Allow a ro eCryptfs mount even when the lower mount is rw.
	 */
	s->s_flags = flags & ~MS_POSIXACL;
	s->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);

 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
//fix_flaw_line_below:
//	s->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	rc = -EINVAL;
//fix_flaw_line_below:
//	if (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
//fix_flaw_line_below:
//		pr_err(""eCryptfs: maximum fs stacking depth exceeded\n"");
//fix_flaw_line_below:
//		goto out_free;
//fix_flaw_line_below:
//	}
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_make_root(inode);
	if (!s->s_root) {
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	root_info->lower_path = path;

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
",182067,"static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
	const char *err = ""Getting sb failed"";
	struct inode *inode;
	struct path path;
	uid_t check_ruid;
	int rc;

	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
		goto out;
	}

	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
	if (rc) {
		err = ""Error parsing options"";
		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, flags, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
			""known incompatibilities\n"");
		goto out_free;
	}

	if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
			i_uid_read(path.dentry->d_inode),
			from_kuid(&init_user_ns, current_uid()));
		goto out_free;
	}

	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);

	/**
	 * Set the POSIX ACL flag based on whether they're enabled in the lower
	 * mount. Force a read-only eCryptfs mount if the lower mount is ro.
	 * Allow a ro eCryptfs mount even when the lower mount is rw.
	 */
	s->s_flags = flags & ~MS_POSIXACL;
	s->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);

 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_make_root(inode);
	if (!s->s_root) {
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	root_info->lower_path = path;

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
","static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
	const char *err = ""Getting sb failed"";
	struct inode *inode;
	struct path path;
	uid_t check_ruid;
	int rc;

	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
		goto out;
	}

	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
	if (rc) {
		err = ""Error parsing options"";
		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, flags, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
			""known incompatibilities\n"");
		goto out_free;
	}

	if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
			i_uid_read(path.dentry->d_inode),
			from_kuid(&init_user_ns, current_uid()));
		goto out_free;
	}

	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);

	/**
	 * Set the POSIX ACL flag based on whether they're enabled in the lower
	 * mount. Force a read-only eCryptfs mount if the lower mount is ro.
	 * Allow a ro eCryptfs mount even when the lower mount is rw.
	 */
	s->s_flags = flags & ~MS_POSIXACL;
	s->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);

 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
	s->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;

	rc = -EINVAL;
	if (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""eCryptfs: maximum fs stacking depth exceeded\n"");
		goto out_free;
	}
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_make_root(inode);
	if (!s->s_root) {
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	root_info->lower_path = path;

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
","The `ecryptfs_mount` function is responsible for mounting an eCryptfs filesystem in the Linux kernel. It begins by allocating memory for the superblock information and parsing mount options. The function then attempts to retrieve the superblock for the filesystem type and registers a block device interface. It checks the validity of the specified device, ensuring it is not already an eCryptfs mount and that the user has the appropriate permissions. The function sets various superblock properties, including flags and inode information, and creates a root directory for the mount. If any step fails, it cleans up resources and returns an error.","The code implements a function that facilitates the mounting of an encrypted filesystem within the Linux kernel. It begins by allocating necessary memory for filesystem metadata and parsing user-defined options. The function then establishes a connection to the specified device, ensuring it is not already mounted as the same filesystem type and that the user has the required permissions. It sets various properties for the filesystem, including flags and inode details, and creates a root directory for the mount. In case of any errors during the process, it properly cleans up allocated resources and returns an error indication.","The vulnerability in the original code stemmed from the lack of a mechanism to limit the stacking depth of the eCryptfs filesystem, which could lead to excessive kernel stack usage and potential crashes when multiple layers of filesystems were mounted. The fix introduced a read-only counter in the superblock to track the stacking depth, ensuring that it does not exceed a predefined limit. Specifically, the code now checks the `s_stack_depth` against `FILESYSTEM_MAX_STACK_DEPTH`, preventing further mounts if the limit is reached, thus enhancing stability and preventing stack overflow issues in the kernel.","The vulnerability in the original code was due to the absence of a mechanism to restrict the stacking depth of the filesystem, which could lead to excessive kernel stack usage and potential system instability when multiple layers of filesystems were mounted. The fix introduced a read-only counter within the superblock to track the current stacking depth, ensuring it does not exceed a specified limit. This change prevents the mounting of additional layers once the limit is reached, thereby enhancing system stability and preventing stack overflow issues that could arise from recursive filesystem stacking.","The vulnerability was fixed by introducing a read-only counter, `s_stack_depth`, in the superblock to monitor the depth of filesystem stacking. The code now checks this counter against a predefined limit, `FILESYSTEM_MAX_STACK_DEPTH`, to prevent excessive stacking. If the current depth exceeds the limit, an error message is logged, and the mounting process is halted. This ensures that the system does not allow more layers than permitted, thereby mitigating the risk of kernel stack overflow and enhancing overall system stability when multiple filesystems are mounted.","The vulnerability was addressed by implementing a mechanism to track the depth of filesystem stacking through a counter in the superblock. This counter is checked against a predefined maximum limit to ensure that the stacking does not exceed a safe threshold. If the stacking depth reaches this limit, the code prevents any further mounts and logs an error message. This change effectively mitigates the risk of excessive kernel stack usage, enhancing system stability and preventing potential crashes that could occur from recursive or overly deep filesystem layers.","CWE-674, CWE-400, CWE-770, CWE-776, CWE-269, CWE-284, CWE-755, CWE-789, CWE-835, CWE-190",N,-1
55,55,182068,182068,,Remote,Not required,Complete,CVE-2014-9922,https://www.cvedetails.com/cve/CVE-2014-9922/,CWE-264,Medium,Complete,Complete,,2017-04-04,9.3,"The eCryptfs subsystem in the Linux kernel before 3.18 allows local users to gain privileges via a large filesystem stack that includes an overlayfs layer, related to fs/ecryptfs/main.c and fs/overlayfs/super.c.",2017-07-10,+Priv ,9,https://github.com/torvalds/linux/commit/69c433ed2ecd2d3264efd7afec4439524b319121,69c433ed2ecd2d3264efd7afec4439524b319121,"fs: limit filesystem stacking depth

Add a simple read-only counter to super_block that indicates how deep this
is in the stack of filesystems.  Previously ecryptfs was the only stackable
filesystem and it explicitly disallowed multiple layers of itself.

Overlayfs, however, can be stacked recursively and also may be stacked
on top of ecryptfs or vice versa.

To limit the kernel stack usage we must limit the depth of the
filesystem stack.  Initially the limit is set to 2.

Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>",0,fs/overlayfs/super.c,"{""sha"": ""c4cd1fd86cc2ffd4a09beddd3aca3f25d1fdb06f"", ""filename"": ""fs/ecryptfs/main.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/69c433ed2ecd2d3264efd7afec4439524b319121/fs/ecryptfs/main.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/69c433ed2ecd2d3264efd7afec4439524b319121/fs/ecryptfs/main.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ecryptfs/main.c?ref=69c433ed2ecd2d3264efd7afec4439524b319121"", ""patch"": ""@@ -566,6 +566,13 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags\n \ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n \ts->s_blocksize = path.dentry->d_sb->s_blocksize;\n \ts->s_magic = ECRYPTFS_SUPER_MAGIC;\n+\ts->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;\n+\n+\trc = -EINVAL;\n+\tif (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n+\t\tpr_err(\""eCryptfs: maximum fs stacking depth exceeded\\n\"");\n+\t\tgoto out_free;\n+\t}\n \n \tinode = ecryptfs_get_inode(path.dentry->d_inode, s);\n \trc = PTR_ERR(inode);""}<_**next**_>{""sha"": ""08b704cebfc4f8819944e09b05f5f7de35659b92"", ""filename"": ""fs/overlayfs/super.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/69c433ed2ecd2d3264efd7afec4439524b319121/fs/overlayfs/super.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/69c433ed2ecd2d3264efd7afec4439524b319121/fs/overlayfs/super.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/overlayfs/super.c?ref=69c433ed2ecd2d3264efd7afec4439524b319121"", ""patch"": ""@@ -677,6 +677,15 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)\n \t}\n \tufs->lower_namelen = statfs.f_namelen;\n \n+\tsb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,\n+\t\t\t\tlowerpath.mnt->mnt_sb->s_stack_depth) + 1;\n+\n+\terr = -EINVAL;\n+\tif (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n+\t\tpr_err(\""overlayfs: maximum fs stacking depth exceeded\\n\"");\n+\t\tgoto out_put_workpath;\n+\t}\n+\n \tufs->upper_mnt = clone_private_mount(&upperpath);\n \terr = PTR_ERR(ufs->upper_mnt);\n \tif (IS_ERR(ufs->upper_mnt)) {""}<_**next**_>{""sha"": ""4e41a4a331bbf96c4b59c05cd9a0c522efec92ca"", ""filename"": ""include/linux/fs.h"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/torvalds/linux/blob/69c433ed2ecd2d3264efd7afec4439524b319121/include/linux/fs.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/69c433ed2ecd2d3264efd7afec4439524b319121/include/linux/fs.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/fs.h?ref=69c433ed2ecd2d3264efd7afec4439524b319121"", ""patch"": ""@@ -261,6 +261,12 @@ struct iattr {\n  */\n #include <linux/quota.h>\n \n+/*\n+ * Maximum number of layers of fs stack.  Needs to be limited to\n+ * prevent kernel stack overflow\n+ */\n+#define FILESYSTEM_MAX_STACK_DEPTH 2\n+\n /** \n  * enum positive_aop_returns - aop return codes with specific semantics\n  *\n@@ -1273,6 +1279,11 @@ struct super_block {\n \tstruct list_lru\t\ts_dentry_lru ____cacheline_aligned_in_smp;\n \tstruct list_lru\t\ts_inode_lru ____cacheline_aligned_in_smp;\n \tstruct rcu_head\t\trcu;\n+\n+\t/*\n+\t * Indicates how deep in a filesystem stack this SB is\n+\t */\n+\tint s_stack_depth;\n };\n \n extern struct timespec current_fs_time(struct super_block *sb);""}","static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
	struct path lowerpath;
	struct path upperpath;
	struct path workpath;
	struct inode *root_inode;
	struct dentry *root_dentry;
	struct ovl_entry *oe;
	struct ovl_fs *ufs;
	struct kstatfs statfs;
	int err;

	err = -ENOMEM;
	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
	if (!ufs)
		goto out;

	err = ovl_parse_opt((char *) data, &ufs->config);
	if (err)
		goto out_free_config;

	/* FIXME: workdir is not needed for a R/O mount */
	err = -EINVAL;
	if (!ufs->config.upperdir || !ufs->config.lowerdir ||
	    !ufs->config.workdir) {
		pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
		goto out_free_config;
	}

	err = -ENOMEM;
	oe = ovl_alloc_entry();
	if (oe == NULL)
		goto out_free_config;

	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
	if (err)
		goto out_free_oe;

	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
	if (err)
		goto out_put_upperpath;

	err = ovl_mount_dir(ufs->config.workdir, &workpath);
	if (err)
		goto out_put_lowerpath;

	err = -EINVAL;
	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
		pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
		goto out_put_workpath;
	}

	if (upperpath.mnt != workpath.mnt) {
		pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
		goto out_put_workpath;
	}
	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
		pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
		pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
		pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
		goto out_put_workpath;
	}

	err = vfs_statfs(&lowerpath, &statfs);
	if (err) {
		pr_err(""overlayfs: statfs failed on lowerpath\n"");
		goto out_put_workpath;
 	}
 	ufs->lower_namelen = statfs.f_namelen;
 
	sb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,
				lowerpath.mnt->mnt_sb->s_stack_depth) + 1;

	err = -EINVAL;
	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
		goto out_put_workpath;
	}

 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);
 	if (IS_ERR(ufs->upper_mnt)) {
		pr_err(""overlayfs: failed to clone upperpath\n"");
		goto out_put_workpath;
	}

	ufs->lower_mnt = clone_private_mount(&lowerpath);
	err = PTR_ERR(ufs->lower_mnt);
	if (IS_ERR(ufs->lower_mnt)) {
		pr_err(""overlayfs: failed to clone lowerpath\n"");
		goto out_put_upper_mnt;
	}

	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
	err = PTR_ERR(ufs->workdir);
	if (IS_ERR(ufs->workdir)) {
		pr_err(""overlayfs: failed to create directory %s/%s\n"",
		       ufs->config.workdir, OVL_WORKDIR_NAME);
		goto out_put_lower_mnt;
	}

	/*
	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
	 * will fail instead of modifying lower fs.
	 */
	ufs->lower_mnt->mnt_flags |= MNT_READONLY;

	/* If the upper fs is r/o, we mark overlayfs r/o too */
	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
		sb->s_flags |= MS_RDONLY;

	sb->s_d_op = &ovl_dentry_operations;

	err = -ENOMEM;
	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
	if (!root_inode)
		goto out_put_workdir;

	root_dentry = d_make_root(root_inode);
	if (!root_dentry)
		goto out_put_workdir;

	mntput(upperpath.mnt);
	mntput(lowerpath.mnt);
	path_put(&workpath);

	oe->__upperdentry = upperpath.dentry;
	oe->lowerdentry = lowerpath.dentry;

	root_dentry->d_fsdata = oe;

	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
	sb->s_op = &ovl_super_operations;
	sb->s_root = root_dentry;
	sb->s_fs_info = ufs;

	return 0;

out_put_workdir:
	dput(ufs->workdir);
out_put_lower_mnt:
	mntput(ufs->lower_mnt);
out_put_upper_mnt:
	mntput(ufs->upper_mnt);
out_put_workpath:
	path_put(&workpath);
out_put_lowerpath:
	path_put(&lowerpath);
out_put_upperpath:
	path_put(&upperpath);
out_free_oe:
	kfree(oe);
out_free_config:
	kfree(ufs->config.lowerdir);
	kfree(ufs->config.upperdir);
	kfree(ufs->config.workdir);
	kfree(ufs);
out:
	return err;
}
","static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
	struct path lowerpath;
	struct path upperpath;
	struct path workpath;
	struct inode *root_inode;
	struct dentry *root_dentry;
	struct ovl_entry *oe;
	struct ovl_fs *ufs;
	struct kstatfs statfs;
	int err;

	err = -ENOMEM;
	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
	if (!ufs)
		goto out;

	err = ovl_parse_opt((char *) data, &ufs->config);
	if (err)
		goto out_free_config;

	/* FIXME: workdir is not needed for a R/O mount */
	err = -EINVAL;
	if (!ufs->config.upperdir || !ufs->config.lowerdir ||
	    !ufs->config.workdir) {
		pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
		goto out_free_config;
	}

	err = -ENOMEM;
	oe = ovl_alloc_entry();
	if (oe == NULL)
		goto out_free_config;

	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
	if (err)
		goto out_free_oe;

	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
	if (err)
		goto out_put_upperpath;

	err = ovl_mount_dir(ufs->config.workdir, &workpath);
	if (err)
		goto out_put_lowerpath;

	err = -EINVAL;
	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
		pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
		goto out_put_workpath;
	}

	if (upperpath.mnt != workpath.mnt) {
		pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
		goto out_put_workpath;
	}
	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
		pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
		pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
		pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
		goto out_put_workpath;
	}

	err = vfs_statfs(&lowerpath, &statfs);
	if (err) {
		pr_err(""overlayfs: statfs failed on lowerpath\n"");
		goto out_put_workpath;
 	}
 	ufs->lower_namelen = statfs.f_namelen;
 
 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);
 	if (IS_ERR(ufs->upper_mnt)) {
		pr_err(""overlayfs: failed to clone upperpath\n"");
		goto out_put_workpath;
	}

	ufs->lower_mnt = clone_private_mount(&lowerpath);
	err = PTR_ERR(ufs->lower_mnt);
	if (IS_ERR(ufs->lower_mnt)) {
		pr_err(""overlayfs: failed to clone lowerpath\n"");
		goto out_put_upper_mnt;
	}

	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
	err = PTR_ERR(ufs->workdir);
	if (IS_ERR(ufs->workdir)) {
		pr_err(""overlayfs: failed to create directory %s/%s\n"",
		       ufs->config.workdir, OVL_WORKDIR_NAME);
		goto out_put_lower_mnt;
	}

	/*
	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
	 * will fail instead of modifying lower fs.
	 */
	ufs->lower_mnt->mnt_flags |= MNT_READONLY;

	/* If the upper fs is r/o, we mark overlayfs r/o too */
	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
		sb->s_flags |= MS_RDONLY;

	sb->s_d_op = &ovl_dentry_operations;

	err = -ENOMEM;
	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
	if (!root_inode)
		goto out_put_workdir;

	root_dentry = d_make_root(root_inode);
	if (!root_dentry)
		goto out_put_workdir;

	mntput(upperpath.mnt);
	mntput(lowerpath.mnt);
	path_put(&workpath);

	oe->__upperdentry = upperpath.dentry;
	oe->lowerdentry = lowerpath.dentry;

	root_dentry->d_fsdata = oe;

	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
	sb->s_op = &ovl_super_operations;
	sb->s_root = root_dentry;
	sb->s_fs_info = ufs;

	return 0;

out_put_workdir:
	dput(ufs->workdir);
out_put_lower_mnt:
	mntput(ufs->lower_mnt);
out_put_upper_mnt:
	mntput(ufs->upper_mnt);
out_put_workpath:
	path_put(&workpath);
out_put_lowerpath:
	path_put(&lowerpath);
out_put_upperpath:
	path_put(&upperpath);
out_free_oe:
	kfree(oe);
out_free_config:
	kfree(ufs->config.lowerdir);
	kfree(ufs->config.upperdir);
	kfree(ufs->config.workdir);
	kfree(ufs);
out:
	return err;
}
",C,"	sb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,
				lowerpath.mnt->mnt_sb->s_stack_depth) + 1;

	err = -EINVAL;
	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
		goto out_put_workpath;
	}

",,,"@@ -677,6 +677,15 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)
 	}
 	ufs->lower_namelen = statfs.f_namelen;
 
+	sb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,
+				lowerpath.mnt->mnt_sb->s_stack_depth) + 1;
+
+	err = -EINVAL;
+	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
+		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
+		goto out_put_workpath;
+	}
+
 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);
 	if (IS_ERR(ufs->upper_mnt)) {",linux,69c433ed2ecd2d3264efd7afec4439524b319121,7c37fbda85ceb9be7bdb9d5f53e702efc40cf783,1,"static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
	struct path lowerpath;
	struct path upperpath;
	struct path workpath;
	struct inode *root_inode;
	struct dentry *root_dentry;
	struct ovl_entry *oe;
	struct ovl_fs *ufs;
	struct kstatfs statfs;
	int err;

	err = -ENOMEM;
	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
	if (!ufs)
		goto out;

	err = ovl_parse_opt((char *) data, &ufs->config);
	if (err)
		goto out_free_config;

	/* FIXME: workdir is not needed for a R/O mount */
	err = -EINVAL;
	if (!ufs->config.upperdir || !ufs->config.lowerdir ||
	    !ufs->config.workdir) {
		pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
		goto out_free_config;
	}

	err = -ENOMEM;
	oe = ovl_alloc_entry();
	if (oe == NULL)
		goto out_free_config;

	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
	if (err)
		goto out_free_oe;

	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
	if (err)
		goto out_put_upperpath;

	err = ovl_mount_dir(ufs->config.workdir, &workpath);
	if (err)
		goto out_put_lowerpath;

	err = -EINVAL;
	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
		pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
		goto out_put_workpath;
	}

	if (upperpath.mnt != workpath.mnt) {
		pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
		goto out_put_workpath;
	}
	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
		pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
		pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
		pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
		goto out_put_workpath;
	}

	err = vfs_statfs(&lowerpath, &statfs);
	if (err) {
		pr_err(""overlayfs: statfs failed on lowerpath\n"");
		goto out_put_workpath;
 	}
 	ufs->lower_namelen = statfs.f_namelen;
 
//fix_flaw_line_below:
//	sb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,
//fix_flaw_line_below:
//				lowerpath.mnt->mnt_sb->s_stack_depth) + 1;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	err = -EINVAL;
//fix_flaw_line_below:
//	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
//fix_flaw_line_below:
//		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
//fix_flaw_line_below:
//		goto out_put_workpath;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);
 	if (IS_ERR(ufs->upper_mnt)) {
		pr_err(""overlayfs: failed to clone upperpath\n"");
		goto out_put_workpath;
	}

	ufs->lower_mnt = clone_private_mount(&lowerpath);
	err = PTR_ERR(ufs->lower_mnt);
	if (IS_ERR(ufs->lower_mnt)) {
		pr_err(""overlayfs: failed to clone lowerpath\n"");
		goto out_put_upper_mnt;
	}

	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
	err = PTR_ERR(ufs->workdir);
	if (IS_ERR(ufs->workdir)) {
		pr_err(""overlayfs: failed to create directory %s/%s\n"",
		       ufs->config.workdir, OVL_WORKDIR_NAME);
		goto out_put_lower_mnt;
	}

	/*
	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
	 * will fail instead of modifying lower fs.
	 */
	ufs->lower_mnt->mnt_flags |= MNT_READONLY;

	/* If the upper fs is r/o, we mark overlayfs r/o too */
	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
		sb->s_flags |= MS_RDONLY;

	sb->s_d_op = &ovl_dentry_operations;

	err = -ENOMEM;
	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
	if (!root_inode)
		goto out_put_workdir;

	root_dentry = d_make_root(root_inode);
	if (!root_dentry)
		goto out_put_workdir;

	mntput(upperpath.mnt);
	mntput(lowerpath.mnt);
	path_put(&workpath);

	oe->__upperdentry = upperpath.dentry;
	oe->lowerdentry = lowerpath.dentry;

	root_dentry->d_fsdata = oe;

	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
	sb->s_op = &ovl_super_operations;
	sb->s_root = root_dentry;
	sb->s_fs_info = ufs;

	return 0;

out_put_workdir:
	dput(ufs->workdir);
out_put_lower_mnt:
	mntput(ufs->lower_mnt);
out_put_upper_mnt:
	mntput(ufs->upper_mnt);
out_put_workpath:
	path_put(&workpath);
out_put_lowerpath:
	path_put(&lowerpath);
out_put_upperpath:
	path_put(&upperpath);
out_free_oe:
	kfree(oe);
out_free_config:
	kfree(ufs->config.lowerdir);
	kfree(ufs->config.upperdir);
	kfree(ufs->config.workdir);
	kfree(ufs);
out:
	return err;
}
",182068,"static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
	struct path lowerpath;
	struct path upperpath;
	struct path workpath;
	struct inode *root_inode;
	struct dentry *root_dentry;
	struct ovl_entry *oe;
	struct ovl_fs *ufs;
	struct kstatfs statfs;
	int err;

	err = -ENOMEM;
	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
	if (!ufs)
		goto out;

	err = ovl_parse_opt((char *) data, &ufs->config);
	if (err)
		goto out_free_config;

	/* FIXME: workdir is not needed for a R/O mount */
	err = -EINVAL;
	if (!ufs->config.upperdir || !ufs->config.lowerdir ||
	    !ufs->config.workdir) {
		pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
		goto out_free_config;
	}

	err = -ENOMEM;
	oe = ovl_alloc_entry();
	if (oe == NULL)
		goto out_free_config;

	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
	if (err)
		goto out_free_oe;

	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
	if (err)
		goto out_put_upperpath;

	err = ovl_mount_dir(ufs->config.workdir, &workpath);
	if (err)
		goto out_put_lowerpath;

	err = -EINVAL;
	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
		pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
		goto out_put_workpath;
	}

	if (upperpath.mnt != workpath.mnt) {
		pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
		goto out_put_workpath;
	}
	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
		pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
		pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
		pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
		goto out_put_workpath;
	}

	err = vfs_statfs(&lowerpath, &statfs);
	if (err) {
		pr_err(""overlayfs: statfs failed on lowerpath\n"");
		goto out_put_workpath;
 	}
 	ufs->lower_namelen = statfs.f_namelen;
 
 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);
 	if (IS_ERR(ufs->upper_mnt)) {
		pr_err(""overlayfs: failed to clone upperpath\n"");
		goto out_put_workpath;
	}

	ufs->lower_mnt = clone_private_mount(&lowerpath);
	err = PTR_ERR(ufs->lower_mnt);
	if (IS_ERR(ufs->lower_mnt)) {
		pr_err(""overlayfs: failed to clone lowerpath\n"");
		goto out_put_upper_mnt;
	}

	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
	err = PTR_ERR(ufs->workdir);
	if (IS_ERR(ufs->workdir)) {
		pr_err(""overlayfs: failed to create directory %s/%s\n"",
		       ufs->config.workdir, OVL_WORKDIR_NAME);
		goto out_put_lower_mnt;
	}

	/*
	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
	 * will fail instead of modifying lower fs.
	 */
	ufs->lower_mnt->mnt_flags |= MNT_READONLY;

	/* If the upper fs is r/o, we mark overlayfs r/o too */
	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
		sb->s_flags |= MS_RDONLY;

	sb->s_d_op = &ovl_dentry_operations;

	err = -ENOMEM;
	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
	if (!root_inode)
		goto out_put_workdir;

	root_dentry = d_make_root(root_inode);
	if (!root_dentry)
		goto out_put_workdir;

	mntput(upperpath.mnt);
	mntput(lowerpath.mnt);
	path_put(&workpath);

	oe->__upperdentry = upperpath.dentry;
	oe->lowerdentry = lowerpath.dentry;

	root_dentry->d_fsdata = oe;

	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
	sb->s_op = &ovl_super_operations;
	sb->s_root = root_dentry;
	sb->s_fs_info = ufs;

	return 0;

out_put_workdir:
	dput(ufs->workdir);
out_put_lower_mnt:
	mntput(ufs->lower_mnt);
out_put_upper_mnt:
	mntput(ufs->upper_mnt);
out_put_workpath:
	path_put(&workpath);
out_put_lowerpath:
	path_put(&lowerpath);
out_put_upperpath:
	path_put(&upperpath);
out_free_oe:
	kfree(oe);
out_free_config:
	kfree(ufs->config.lowerdir);
	kfree(ufs->config.upperdir);
	kfree(ufs->config.workdir);
	kfree(ufs);
out:
	return err;
}
","static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
	struct path lowerpath;
	struct path upperpath;
	struct path workpath;
	struct inode *root_inode;
	struct dentry *root_dentry;
	struct ovl_entry *oe;
	struct ovl_fs *ufs;
	struct kstatfs statfs;
	int err;

	err = -ENOMEM;
	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
	if (!ufs)
		goto out;

	err = ovl_parse_opt((char *) data, &ufs->config);
	if (err)
		goto out_free_config;

	/* FIXME: workdir is not needed for a R/O mount */
	err = -EINVAL;
	if (!ufs->config.upperdir || !ufs->config.lowerdir ||
	    !ufs->config.workdir) {
		pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
		goto out_free_config;
	}

	err = -ENOMEM;
	oe = ovl_alloc_entry();
	if (oe == NULL)
		goto out_free_config;

	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
	if (err)
		goto out_free_oe;

	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
	if (err)
		goto out_put_upperpath;

	err = ovl_mount_dir(ufs->config.workdir, &workpath);
	if (err)
		goto out_put_lowerpath;

	err = -EINVAL;
	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
		pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
		goto out_put_workpath;
	}

	if (upperpath.mnt != workpath.mnt) {
		pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
		goto out_put_workpath;
	}
	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
		pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
		pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
		pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
		goto out_put_workpath;
	}

	err = vfs_statfs(&lowerpath, &statfs);
	if (err) {
		pr_err(""overlayfs: statfs failed on lowerpath\n"");
		goto out_put_workpath;
 	}
 	ufs->lower_namelen = statfs.f_namelen;
 
	sb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,
				lowerpath.mnt->mnt_sb->s_stack_depth) + 1;

	err = -EINVAL;
	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
		goto out_put_workpath;
	}

 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);
 	if (IS_ERR(ufs->upper_mnt)) {
		pr_err(""overlayfs: failed to clone upperpath\n"");
		goto out_put_workpath;
	}

	ufs->lower_mnt = clone_private_mount(&lowerpath);
	err = PTR_ERR(ufs->lower_mnt);
	if (IS_ERR(ufs->lower_mnt)) {
		pr_err(""overlayfs: failed to clone lowerpath\n"");
		goto out_put_upper_mnt;
	}

	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
	err = PTR_ERR(ufs->workdir);
	if (IS_ERR(ufs->workdir)) {
		pr_err(""overlayfs: failed to create directory %s/%s\n"",
		       ufs->config.workdir, OVL_WORKDIR_NAME);
		goto out_put_lower_mnt;
	}

	/*
	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
	 * will fail instead of modifying lower fs.
	 */
	ufs->lower_mnt->mnt_flags |= MNT_READONLY;

	/* If the upper fs is r/o, we mark overlayfs r/o too */
	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
		sb->s_flags |= MS_RDONLY;

	sb->s_d_op = &ovl_dentry_operations;

	err = -ENOMEM;
	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
	if (!root_inode)
		goto out_put_workdir;

	root_dentry = d_make_root(root_inode);
	if (!root_dentry)
		goto out_put_workdir;

	mntput(upperpath.mnt);
	mntput(lowerpath.mnt);
	path_put(&workpath);

	oe->__upperdentry = upperpath.dentry;
	oe->lowerdentry = lowerpath.dentry;

	root_dentry->d_fsdata = oe;

	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
	sb->s_op = &ovl_super_operations;
	sb->s_root = root_dentry;
	sb->s_fs_info = ufs;

	return 0;

out_put_workdir:
	dput(ufs->workdir);
out_put_lower_mnt:
	mntput(ufs->lower_mnt);
out_put_upper_mnt:
	mntput(ufs->upper_mnt);
out_put_workpath:
	path_put(&workpath);
out_put_lowerpath:
	path_put(&lowerpath);
out_put_upperpath:
	path_put(&upperpath);
out_free_oe:
	kfree(oe);
out_free_config:
	kfree(ufs->config.lowerdir);
	kfree(ufs->config.upperdir);
	kfree(ufs->config.workdir);
	kfree(ufs);
out:
	return err;
}
","The `ovl_fill_super` function initializes an overlay filesystem by setting up the necessary structures and validating the provided configuration. It allocates memory for an overlay filesystem structure and parses options for upper, lower, and work directories. The function checks for the existence and validity of these directories, ensuring they are directories and reside under the same mount point. It also verifies that the filesystems of the upper and lower directories are supported. Upon successful validation, it creates a root inode and dentry for the overlay, sets filesystem operations, and returns success or an error code if any step fails, cleaning up resources as needed.","The code initializes an overlay filesystem by allocating necessary structures and validating configuration parameters for upper, lower, and work directories. It checks for the existence and correctness of these directories, ensuring they are valid directories and located within the same mount point. The code also verifies that the filesystems of the specified directories are supported. Upon successful validation, it creates a root directory entry for the overlay, sets appropriate filesystem operations, and returns a success status or an error code if any validation fails, while ensuring proper cleanup of allocated resources.","The vulnerability in the original code stemmed from the lack of a mechanism to limit the stacking depth of overlay filesystems, which could lead to excessive kernel stack usage and potential system instability. The fixed code introduces a read-only counter in the super_block structure to track the stacking depth, ensuring that it does not exceed a predefined maximum limit. This change prevents recursive stacking of overlay filesystems beyond the specified depth, thereby enhancing system stability and preventing resource exhaustion. The addition of a check for the maximum stacking depth effectively mitigates the risk associated with unbounded filesystem stacking.","The vulnerability in the original code arose from the absence of a mechanism to restrict the stacking depth of overlay filesystems, which could lead to excessive kernel stack usage and potential system crashes. The fix introduces a read-only counter that tracks the current depth of filesystem stacking, preventing it from exceeding a specified limit. This change addresses the risk of recursive stacking, which could occur with overlay filesystems, by enforcing a maximum depth to ensure system stability and resource management. The implementation of this limit effectively mitigates the potential for resource exhaustion and enhances overall system reliability.","The vulnerability was fixed by adding a read-only counter to the `super_block` structure, which tracks the stacking depth of filesystems. In the updated code, the stacking depth is calculated using the maximum depth of the upper and lower mounts, incremented by one. A check is introduced to ensure that this depth does not exceed a predefined maximum limit, specifically set to 2. If the stacking depth exceeds this limit, an error is logged, and the function exits gracefully, preventing further operations that could lead to excessive kernel stack usage and potential instability.","The vulnerability was addressed by implementing a mechanism to track the depth of filesystem stacking, which prevents excessive recursion that could lead to kernel stack exhaustion. A counter was introduced to monitor the current stacking depth, and a validation check was added to ensure this depth does not exceed a predefined maximum limit. If the stacking depth surpasses this limit, the code logs an error and halts further processing, effectively mitigating the risk of resource exhaustion and enhancing the stability and reliability of the system when handling multiple layers of filesystems.","CWE-674, CWE-400, CWE-776, CWE-770, CWE-269, CWE-20, CWE-269, CWE-284, CWE-755, CWE-835",N,-1
56,56,182778,182778,,Local,Not required,Complete,CVE-2019-13272,https://www.cvedetails.com/cve/CVE-2019-13272/,CWE-264,Low,Complete,Complete,,2019-07-17,7.2,"In the Linux kernel before 5.1.17, ptrace_link in kernel/ptrace.c mishandles the recording of the credentials of a process that wants to create a ptrace relationship, which allows local users to obtain root access by leveraging certain scenarios with a parent-child process relationship, where a parent drops privileges and calls execve (potentially allowing control by an attacker). One contributing factor is an object lifetime issue (which can also cause a panic). Another contributing factor is incorrect marking of a ptrace relationship as privileged, which is exploitable through (for example) Polkit's pkexec helper with PTRACE_TRACEME. NOTE: SELinux deny_ptrace might be a usable workaround in some environments.",2019-07-25,,1,https://github.com/torvalds/linux/commit/6994eefb0053799d2e07cd140df6c2ea106c41ee,6994eefb0053799d2e07cd140df6c2ea106c41ee,"ptrace: Fix ->ptracer_cred handling for PTRACE_TRACEME

Fix two issues:

When called for PTRACE_TRACEME, ptrace_link() would obtain an RCU
reference to the parent's objective credentials, then give that pointer
to get_cred().  However, the object lifetime rules for things like
struct cred do not permit unconditionally turning an RCU reference into
a stable reference.

PTRACE_TRACEME records the parent's credentials as if the parent was
acting as the subject, but that's not the case.  If a malicious
unprivileged child uses PTRACE_TRACEME and the parent is privileged, and
at a later point, the parent process becomes attacker-controlled
(because it drops privileges and calls execve()), the attacker ends up
with control over two processes with a privileged ptrace relationship,
which can be abused to ptrace a suid binary and obtain root privileges.

Fix both of these by always recording the credentials of the process
that is requesting the creation of the ptrace relationship:
current_cred() can't change under us, and current is the proper subject
for access control.

This change is theoretically userspace-visible, but I am not aware of
any code that it will actually break.

Fixes: 64b875f7ac8a (""ptrace: Capture the ptracer's creds not PT_PTRACE_CAP"")
Signed-off-by: Jann Horn <jannh@google.com>
Acked-by: Oleg Nesterov <oleg@redhat.com>
Cc: stable@vger.kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",3,kernel/ptrace.c,"{""sha"": ""705887f63288d4694c5bccd5c77900cbddc1f843"", ""filename"": ""kernel/ptrace.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/6994eefb0053799d2e07cd140df6c2ea106c41ee/kernel/ptrace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/6994eefb0053799d2e07cd140df6c2ea106c41ee/kernel/ptrace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/ptrace.c?ref=6994eefb0053799d2e07cd140df6c2ea106c41ee"", ""patch"": ""@@ -79,9 +79,7 @@ void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,\n  */\n static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n {\n-\trcu_read_lock();\n-\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n-\trcu_read_unlock();\n+\t__ptrace_link(child, new_parent, current_cred());\n }\n \n /**""}"," static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
	__ptrace_link(child, new_parent, current_cred());
 }
"," static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
	rcu_read_lock();
	__ptrace_link(child, new_parent, __task_cred(new_parent));
	rcu_read_unlock();
 }
",C,"	__ptrace_link(child, new_parent, current_cred());
","	rcu_read_lock();
	__ptrace_link(child, new_parent, __task_cred(new_parent));
	rcu_read_unlock();
",,"@@ -79,9 +79,7 @@ void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,
  */
 static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
-	rcu_read_lock();
-	__ptrace_link(child, new_parent, __task_cred(new_parent));
-	rcu_read_unlock();
+	__ptrace_link(child, new_parent, current_cred());
 }
 
 /**",linux,6994eefb0053799d2e07cd140df6c2ea106c41ee,550d1f5bda33fa3b203d8cf8df1396825dbfd213,1," static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
//flaw_line_below:
	rcu_read_lock();
//flaw_line_below:
	__ptrace_link(child, new_parent, __task_cred(new_parent));
//flaw_line_below:
	rcu_read_unlock();
//fix_flaw_line_below:
//	__ptrace_link(child, new_parent, current_cred());
 }
",182778," static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
	rcu_read_lock();
	__ptrace_link(child, new_parent, __task_cred(new_parent));
	rcu_read_unlock();
 }
"," static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
	__ptrace_link(child, new_parent, current_cred());
 }
","The `ptrace_link` function is designed to establish a relationship between a child process and a new parent process in a Linux kernel context, specifically for process tracing. It begins by acquiring a read lock using `rcu_read_lock()` to ensure safe access to shared data structures. The function then calls `__ptrace_link`, passing the child task, the new parent task, and the credentials of the new parent, which facilitates the linking process. Finally, it releases the read lock with `rcu_read_unlock()`, ensuring that the critical section is properly managed to maintain data integrity and prevent race conditions.","The provided code defines a function that links a child process to a new parent process within the context of process tracing in an operating system kernel. It begins by acquiring a read lock to ensure safe access to shared resources, preventing concurrent modifications that could lead to inconsistencies. The core operation involves establishing the relationship between the child and the new parent, incorporating the necessary credentials for the new parent to maintain security and access control. After completing the linking operation, the function releases the read lock, ensuring that the critical section is properly managed to uphold data integrity.","The vulnerability in the original code arose from improperly handling the credentials of the parent process when establishing a tracing relationship using `PTRACE_TRACEME`. Specifically, the code obtained an RCU reference to the parent's credentials and passed it to `get_cred()`, which violated the lifetime rules for credential objects, potentially allowing an unprivileged child to exploit a privileged parent. This could lead to privilege escalation if the parent later became attacker-controlled. The fix involved replacing the RCU reference with a stable reference to the credentials of the requesting process using `current_cred()`, ensuring proper access control and preventing the exploitation of the ptrace relationship.","The vulnerability in the original code stemmed from incorrectly handling the credentials of the parent process during the establishment of a tracing relationship, particularly in scenarios involving unprivileged children using a specific tracing command. This approach allowed an unprivileged child to potentially gain control over a privileged parent process, leading to a risk of privilege escalation if the parent later became compromised. The fix involved ensuring that the credentials recorded were those of the requesting process rather than the parent, thereby maintaining proper access control and preventing exploitation of the tracing relationship by malicious actors.","The vulnerability was fixed by replacing the use of an RCU reference to the parent's credentials with a stable reference to the credentials of the requesting process. In the original code, the function obtained an RCU reference to the parent's credentials and passed it to `get_cred()`, which could lead to unsafe access. The updated code now uses `current_cred()` to always record the credentials of the process initiating the ptrace relationship. This change ensures that the credentials cannot change during the operation, thereby maintaining proper access control and preventing potential privilege escalation by unprivileged children.","The vulnerability was addressed by ensuring that the credentials recorded during the establishment of the tracing relationship are those of the process requesting the action, rather than the parent process. This change eliminates the reliance on potentially unstable references to the parent's credentials, which could lead to unsafe access and privilege escalation. By consistently using the credentials of the requesting process, the fix maintains proper access control and prevents unprivileged processes from exploiting the tracing relationship to gain unauthorized control over privileged processes, thereby enhancing overall system security.","CWE-269,CWE-732,CWE-266,CWE-270,CWE-284,CWE-264,CWE-287,CWE-265,CWE-274,CWE-250",Y,6
57,57,183067,183067,,Local,Not required,Partial,CVE-2013-1959,https://www.cvedetails.com/cve/CVE-2013-1959/,CWE-264,High,Partial,Partial,,2013-05-03,3.7,"kernel/user_namespace.c in the Linux kernel before 3.8.9 does not have appropriate capability requirements for the uid_map and gid_map files, which allows local users to gain privileges by opening a file within an unprivileged process and then modifying the file within a privileged process.",2013-11-30,+Priv ,2,https://github.com/torvalds/linux/commit/e3211c120a85b792978bcb4be7b2886df18d27f0,e3211c120a85b792978bcb4be7b2886df18d27f0,"userns: Check uid_map's opener's fsuid, not the current fsuid

Signed-off-by: Andy Lutomirski <luto@amacapital.net>",2,kernel/user_namespace.c,"{""sha"": ""5c16f3aa757a0353f8d7621b6b9d16cd586b347e"", ""filename"": ""kernel/user_namespace.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/e3211c120a85b792978bcb4be7b2886df18d27f0/kernel/user_namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e3211c120a85b792978bcb4be7b2886df18d27f0/kernel/user_namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/user_namespace.c?ref=e3211c120a85b792978bcb4be7b2886df18d27f0"", ""patch"": ""@@ -797,12 +797,12 @@ static bool new_idmap_permitted(const struct file *file,\n \t\tu32 id = new_map->extent[0].lower_first;\n \t\tif (cap_setid == CAP_SETUID) {\n \t\t\tkuid_t uid = make_kuid(ns->parent, id);\n-\t\t\tif (uid_eq(uid, current_fsuid()))\n+\t\t\tif (uid_eq(uid, file->f_cred->fsuid))\n \t\t\t\treturn true;\n \t\t}\n \t\telse if (cap_setid == CAP_SETGID) {\n \t\t\tkgid_t gid = make_kgid(ns->parent, id);\n-\t\t\tif (gid_eq(gid, current_fsgid()))\n+\t\t\tif (gid_eq(gid, file->f_cred->fsgid))\n \t\t\t\treturn true;\n \t\t}\n \t}""}","static bool new_idmap_permitted(const struct file *file, 
				struct user_namespace *ns, int cap_setid,
				struct uid_gid_map *new_map)
{
	/* Allow mapping to your own filesystem ids */
	if ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {
 		u32 id = new_map->extent[0].lower_first;
 		if (cap_setid == CAP_SETUID) {
 			kuid_t uid = make_kuid(ns->parent, id);
			if (uid_eq(uid, file->f_cred->fsuid))
 				return true;
 		}
 		else if (cap_setid == CAP_SETGID) {
 			kgid_t gid = make_kgid(ns->parent, id);
			if (gid_eq(gid, file->f_cred->fsgid))
 				return true;
 		}
 	}

	/* Allow anyone to set a mapping that doesn't require privilege */
	if (!cap_valid(cap_setid))
		return true;

	/* Allow the specified ids if we have the appropriate capability
	 * (CAP_SETUID or CAP_SETGID) over the parent user namespace.
	 * And the opener of the id file also had the approprpiate capability.
	 */
	if (ns_capable(ns->parent, cap_setid) &&
	    file_ns_capable(file, ns->parent, cap_setid))
		return true;

	return false;
}
","static bool new_idmap_permitted(const struct file *file, 
				struct user_namespace *ns, int cap_setid,
				struct uid_gid_map *new_map)
{
	/* Allow mapping to your own filesystem ids */
	if ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {
 		u32 id = new_map->extent[0].lower_first;
 		if (cap_setid == CAP_SETUID) {
 			kuid_t uid = make_kuid(ns->parent, id);
			if (uid_eq(uid, current_fsuid()))
 				return true;
 		}
 		else if (cap_setid == CAP_SETGID) {
 			kgid_t gid = make_kgid(ns->parent, id);
			if (gid_eq(gid, current_fsgid()))
 				return true;
 		}
 	}

	/* Allow anyone to set a mapping that doesn't require privilege */
	if (!cap_valid(cap_setid))
		return true;

	/* Allow the specified ids if we have the appropriate capability
	 * (CAP_SETUID or CAP_SETGID) over the parent user namespace.
	 * And the opener of the id file also had the approprpiate capability.
	 */
	if (ns_capable(ns->parent, cap_setid) &&
	    file_ns_capable(file, ns->parent, cap_setid))
		return true;

	return false;
}
",C,"			if (uid_eq(uid, file->f_cred->fsuid))
			if (gid_eq(gid, file->f_cred->fsgid))
","			if (uid_eq(uid, current_fsuid()))
			if (gid_eq(gid, current_fsgid()))
",,"@@ -797,12 +797,12 @@ static bool new_idmap_permitted(const struct file *file,
 		u32 id = new_map->extent[0].lower_first;
 		if (cap_setid == CAP_SETUID) {
 			kuid_t uid = make_kuid(ns->parent, id);
-			if (uid_eq(uid, current_fsuid()))
+			if (uid_eq(uid, file->f_cred->fsuid))
 				return true;
 		}
 		else if (cap_setid == CAP_SETGID) {
 			kgid_t gid = make_kgid(ns->parent, id);
-			if (gid_eq(gid, current_fsgid()))
+			if (gid_eq(gid, file->f_cred->fsgid))
 				return true;
 		}
 	}",linux,e3211c120a85b792978bcb4be7b2886df18d27f0,6708075f104c3c9b04b23336bb0366ca30c3931b,1,"static bool new_idmap_permitted(const struct file *file, 
				struct user_namespace *ns, int cap_setid,
				struct uid_gid_map *new_map)
{
	/* Allow mapping to your own filesystem ids */
	if ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {
 		u32 id = new_map->extent[0].lower_first;
 		if (cap_setid == CAP_SETUID) {
 			kuid_t uid = make_kuid(ns->parent, id);
//flaw_line_below:
			if (uid_eq(uid, current_fsuid()))
//fix_flaw_line_below:
//			if (uid_eq(uid, file->f_cred->fsuid))
 				return true;
 		}
 		else if (cap_setid == CAP_SETGID) {
 			kgid_t gid = make_kgid(ns->parent, id);
//flaw_line_below:
			if (gid_eq(gid, current_fsgid()))
//fix_flaw_line_below:
//			if (gid_eq(gid, file->f_cred->fsgid))
 				return true;
 		}
 	}

	/* Allow anyone to set a mapping that doesn't require privilege */
	if (!cap_valid(cap_setid))
		return true;

	/* Allow the specified ids if we have the appropriate capability
	 * (CAP_SETUID or CAP_SETGID) over the parent user namespace.
	 * And the opener of the id file also had the approprpiate capability.
	 */
	if (ns_capable(ns->parent, cap_setid) &&
	    file_ns_capable(file, ns->parent, cap_setid))
		return true;

	return false;
}
",183067,"static bool new_idmap_permitted(const struct file *file, 
				struct user_namespace *ns, int cap_setid,
				struct uid_gid_map *new_map)
{
	/* Allow mapping to your own filesystem ids */
	if ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {
 		u32 id = new_map->extent[0].lower_first;
 		if (cap_setid == CAP_SETUID) {
 			kuid_t uid = make_kuid(ns->parent, id);
			if (uid_eq(uid, current_fsuid()))
 				return true;
 		}
 		else if (cap_setid == CAP_SETGID) {
 			kgid_t gid = make_kgid(ns->parent, id);
			if (gid_eq(gid, current_fsgid()))
 				return true;
 		}
 	}

	/* Allow anyone to set a mapping that doesn't require privilege */
	if (!cap_valid(cap_setid))
		return true;

	/* Allow the specified ids if we have the appropriate capability
	 * (CAP_SETUID or CAP_SETGID) over the parent user namespace.
	 * And the opener of the id file also had the approprpiate capability.
	 */
	if (ns_capable(ns->parent, cap_setid) &&
	    file_ns_capable(file, ns->parent, cap_setid))
		return true;

	return false;
}
","static bool new_idmap_permitted(const struct file *file, 
				struct user_namespace *ns, int cap_setid,
				struct uid_gid_map *new_map)
{
	/* Allow mapping to your own filesystem ids */
	if ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {
 		u32 id = new_map->extent[0].lower_first;
 		if (cap_setid == CAP_SETUID) {
 			kuid_t uid = make_kuid(ns->parent, id);
			if (uid_eq(uid, file->f_cred->fsuid))
 				return true;
 		}
 		else if (cap_setid == CAP_SETGID) {
 			kgid_t gid = make_kgid(ns->parent, id);
			if (gid_eq(gid, file->f_cred->fsgid))
 				return true;
 		}
 	}

	/* Allow anyone to set a mapping that doesn't require privilege */
	if (!cap_valid(cap_setid))
		return true;

	/* Allow the specified ids if we have the appropriate capability
	 * (CAP_SETUID or CAP_SETGID) over the parent user namespace.
	 * And the opener of the id file also had the approprpiate capability.
	 */
	if (ns_capable(ns->parent, cap_setid) &&
	    file_ns_capable(file, ns->parent, cap_setid))
		return true;

	return false;
}
","The `new_idmap_permitted` function determines whether a new user or group ID mapping is allowed based on specific conditions. It first checks if the mapping consists of a single extent with one ID, allowing the mapping if it matches the current filesystem user or group ID. If the capability (`cap_setid`) is invalid, it permits the mapping without privilege. For valid capabilities, it verifies if the parent user namespace and the file opener possess the necessary permissions (CAP_SETUID or CAP_SETGID) to perform the mapping. If none of these conditions are met, the function returns false, denying the mapping.","The function evaluates whether a new user or group ID mapping is permissible based on several criteria. It first allows mappings that correspond to the current filesystem user or group ID if they consist of a single ID. If the capability required for the mapping is invalid, it permits the operation without any privileges. For valid capabilities, it checks if both the parent namespace and the file opener have the necessary permissions to perform the mapping. If none of these conditions are satisfied, the function denies the mapping, ensuring that only authorized changes are allowed.","The vulnerability in the original code stemmed from allowing a new ID mapping if it matched the current filesystem user or group ID, which could be exploited by an unauthorized user to gain elevated privileges. Specifically, the check used `current_fsuid()` and `current_fsgid()`, which could be manipulated. The fix involved changing the condition to compare the new mapping against the opener's filesystem user and group IDs, accessed via `file->f_cred->fsuid` and `file->f_cred->fsgid`. This adjustment ensures that only the user who opened the file can set the mapping, thereby enhancing security and preventing privilege escalation.","The vulnerability in the original code allowed unauthorized users to potentially escalate their privileges by mapping user or group IDs that matched the current filesystem IDs, which could be manipulated. This posed a security risk as it did not adequately verify the identity of the user attempting to make the mapping. The fix addressed this issue by changing the verification process to check the filesystem user and group IDs of the file opener instead of the current user. This ensures that only the legitimate user who opened the file can set the mapping, thereby preventing unauthorized privilege escalation.","The vulnerability was fixed by modifying the checks for user and group ID mappings to compare against the opener's filesystem user and group IDs instead of the current filesystem IDs. Specifically, the code now uses `file->f_cred->fsuid` and `file->f_cred->fsgid` to ensure that the mapping is only allowed if it matches the IDs of the user who opened the file. This change prevents unauthorized users from exploiting the previous logic, as it restricts the ability to set mappings solely to the legitimate user associated with the file, thereby enhancing security and preventing privilege escalation.","The vulnerability was fixed by changing the verification process for user and group ID mappings to ensure that they are compared against the identifiers of the user who opened the file, rather than the current user. This adjustment ensures that only the legitimate user associated with the file can set the mappings, effectively preventing unauthorized privilege escalation. By implementing this check, the code now restricts the ability to modify ID mappings to the rightful user, thereby enhancing security and mitigating the risk of exploitation that existed in the original implementation.","CWE-269, CWE-266, CWE-271, CWE-732, CWE-284, CWE-264, CWE-287, CWE-863, CWE-862, CWE-281",N,-1
58,58,183756,183756,,Remote,Not required,Partial,CVE-2011-2836,https://www.cvedetails.com/cve/CVE-2011-2836/,CWE-264,Low,Partial,Partial,,2011-09-19,7.5,"Google Chrome before 14.0.835.163 does not require Infobar interaction before use of the Windows Media Player plug-in, which makes it easier for remote attackers to have an unspecified impact via crafted Flash content.",2017-09-18,,3,https://github.com/chromium/chromium/commit/d662b905d30cec7899bbb15140dcfacd73506167,d662b905d30cec7899bbb15140dcfacd73506167,"Infobar Windows Media Player plug-in by default.

BUG=51464
Review URL: http://codereview.chromium.org/7080048

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@87500 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/plugin_observer.cc,"{""sha"": ""906950b41191831a36b88c8f067ee2a1b642238d"", ""filename"": ""chrome/browser/plugin_observer.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/d662b905d30cec7899bbb15140dcfacd73506167/chrome/browser/plugin_observer.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d662b905d30cec7899bbb15140dcfacd73506167/chrome/browser/plugin_observer.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/plugin_observer.cc?ref=d662b905d30cec7899bbb15140dcfacd73506167"", ""patch"": ""@@ -126,6 +126,9 @@ BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(\n   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)\n     UserMetrics::RecordAction(\n         UserMetricsAction(\""BlockedPluginInfobar.Shown.RealPlayer\""));\n+  else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName)\n+    UserMetrics::RecordAction(\n+        UserMetricsAction(\""BlockedPluginInfobar.Shown.WindowsMediaPlayer\""));\n }\n \n BlockedPluginInfoBarDelegate::~BlockedPluginInfoBarDelegate() {""}<_**next**_>{""sha"": ""f35b51953335b0e41197dc96d027b9cf4dab981e"", ""filename"": ""chrome/tools/chromeactions.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/d662b905d30cec7899bbb15140dcfacd73506167/chrome/tools/chromeactions.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d662b905d30cec7899bbb15140dcfacd73506167/chrome/tools/chromeactions.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/tools/chromeactions.txt?ref=d662b905d30cec7899bbb15140dcfacd73506167"", ""patch"": ""@@ -126,6 +126,7 @@\n 0x84cc82257207df8d\tBlockedPluginInfobar.Shown.QuickTime\n 0x819dbe166b094c47\tBlockedPluginInfobar.Shown.RealPlayer\n 0x65add1afd150b840\tBlockedPluginInfobar.Shown.Shockwave\n+0x0ef80834f3e539cc\tBlockedPluginInfobar.Shown.WindowsMediaPlayer\n 0x114c3050111d8b8d\tBold\n 0x02f476e54c6d58bd\tBookmarkBarFolder_CtxMenu\n 0x3012b56b98c28823\tBookmarkBarFolder_DragEnd\n@@ -869,6 +870,7 @@\n 0x7242962875070018\tOpenAllBookmarksIncognitoWindow\n 0x5e3bd4e3535ecc38\tOpenAllBookmarksNewWindow\n 0x4b858349a1b8bb15\tOpenFile\n+0xedaa8487de2a33c6\tOpenFileManager\n 0x4928347f9423c013\tOpenInternetOptionsDialog\n 0x83af6accb98b9954\tOpenLanguageOptionsDialog\n 0xe7147544a7db079d\tOpenSystemOptionsDialog\n@@ -1085,6 +1087,7 @@\n 0x417bd10a7c5e0210\tTabContextMenu_CloseTab\n 0xa0965146c626cd18\tTabContextMenu_CloseTabsOpenedBy\n 0x6adcbb467523c7d9\tTabContextMenu_CloseTabsToRight\n+0xaadbb71a197d76ad\tTabContextMenu_CompactNavigationBar\n 0x89e073e006a686d1\tTabContextMenu_Duplicate\n 0x88aefc727559ebaf\tTabContextMenu_NewTab\n 0x218d462d319b449c\tTabContextMenu_OpenTabsLeftToRight\n@@ -1136,6 +1139,7 @@\n 0xcd4da03d7cbaeb84\tUpgradeCheck_Upgraded\n 0x624ddd04836efdcd\tUpgrade_Started\n 0xa909d722e2ae4285\tViewAboutConflicts\n+0xf3768ba285ebca7e\tViewAboutFlash\n 0xfb4a178539bac6bd\tViewSource\n 0x6932875212d36f57\tWP_EditImage\n 0x34a770eb3bbf5632\tWP_Gallery""}<_**next**_>{""sha"": ""15ec131719741b1d90bd908eaf45f13068909230"", ""filename"": ""webkit/plugins/npapi/plugin_group.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/d662b905d30cec7899bbb15140dcfacd73506167/webkit/plugins/npapi/plugin_group.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d662b905d30cec7899bbb15140dcfacd73506167/webkit/plugins/npapi/plugin_group.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/plugins/npapi/plugin_group.cc?ref=d662b905d30cec7899bbb15140dcfacd73506167"", ""patch"": ""@@ -25,6 +25,7 @@ const char* PluginGroup::kQuickTimeGroupName = \""QuickTime\"";\n const char* PluginGroup::kShockwaveGroupName = \""Shockwave\"";\n const char* PluginGroup::kRealPlayerGroupName = \""RealPlayer\"";\n const char* PluginGroup::kSilverlightGroupName = \""Silverlight\"";\n+const char* PluginGroup::kWindowsMediaPlayerGroupName = \""Windows Media Player\"";\n \n /*static*/\n std::set<string16>* PluginGroup::policy_disabled_plugin_patterns_;""}<_**next**_>{""sha"": ""deb8461f83347132140b47d59877cb1038814b7f"", ""filename"": ""webkit/plugins/npapi/plugin_group.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/d662b905d30cec7899bbb15140dcfacd73506167/webkit/plugins/npapi/plugin_group.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d662b905d30cec7899bbb15140dcfacd73506167/webkit/plugins/npapi/plugin_group.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/plugins/npapi/plugin_group.h?ref=d662b905d30cec7899bbb15140dcfacd73506167"", ""patch"": ""@@ -89,6 +89,7 @@ class PluginGroup {\n   static const char* kShockwaveGroupName;\n   static const char* kRealPlayerGroupName;\n   static const char* kSilverlightGroupName;\n+  static const char* kWindowsMediaPlayerGroupName;\n \n   PluginGroup(const PluginGroup& other);\n ""}<_**next**_>{""sha"": ""24150c9648caa2d8d28a7f21a90309a160fdabab"", ""filename"": ""webkit/plugins/npapi/plugin_list.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 2, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/d662b905d30cec7899bbb15140dcfacd73506167/webkit/plugins/npapi/plugin_list.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/d662b905d30cec7899bbb15140dcfacd73506167/webkit/plugins/npapi/plugin_list.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/plugins/npapi/plugin_list.cc?ref=d662b905d30cec7899bbb15140dcfacd73506167"", ""patch"": ""@@ -108,6 +108,9 @@ static const VersionRangeDefinition kDivXVersionRange[] = {\n static const VersionRangeDefinition kRealPlayerVersionRange[] = {\n     { \""\"", \""\"", \""12.0.1.633\"", true }\n };\n+static const VersionRangeDefinition kWindowsMediaPlayerVersionRange[] = {\n+    { \""\"", \""\"", \""\"", true }\n+};\n static const PluginGroupDefinition kGroupDefinitions[] = {\n   kFlashDefinition,\n   { \""apple-quicktime\"", PluginGroup::kQuickTimeGroupName, \""QuickTime Plug-in\"",\n@@ -129,8 +132,9 @@ static const PluginGroupDefinition kGroupDefinitions[] = {\n     kRealPlayerVersionRange, arraysize(kRealPlayerVersionRange),\n     \""http://www.real.com/realplayer/download\"" },\n   // These are here for grouping, no vulnerabilities known.\n-  { \""windows-media-player\"", \""Windows Media Player\"", \""Windows Media Player\"",\n-    NULL, 0, \""\"" },\n+  { \""windows-media-player\"", PluginGroup::kWindowsMediaPlayerGroupName,\n+    \""Windows Media Player\"", kWindowsMediaPlayerVersionRange,\n+    arraysize(kWindowsMediaPlayerVersionRange), \""\"" },\n   { \""microsoft-office\"", \""Microsoft Office\"", \""Microsoft Office\"",\n     NULL, 0, \""\"" },\n };""}","BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(
    TabContents* tab_contents,
    const string16& utf16_name)
    : PluginInfoBarDelegate(tab_contents, utf16_name) {
  UserMetrics::RecordAction(UserMetricsAction(""BlockedPluginInfobar.Shown""));
  std::string name = UTF16ToUTF8(utf16_name);
  if (name == webkit::npapi::PluginGroup::kJavaGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Java""));
  else if (name == webkit::npapi::PluginGroup::kQuickTimeGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.QuickTime""));
  else if (name == webkit::npapi::PluginGroup::kShockwaveGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Shockwave""));
   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)
     UserMetrics::RecordAction(
         UserMetricsAction(""BlockedPluginInfobar.Shown.RealPlayer""));
  else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.WindowsMediaPlayer""));
 }
","BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(
    TabContents* tab_contents,
    const string16& utf16_name)
    : PluginInfoBarDelegate(tab_contents, utf16_name) {
  UserMetrics::RecordAction(UserMetricsAction(""BlockedPluginInfobar.Shown""));
  std::string name = UTF16ToUTF8(utf16_name);
  if (name == webkit::npapi::PluginGroup::kJavaGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Java""));
  else if (name == webkit::npapi::PluginGroup::kQuickTimeGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.QuickTime""));
  else if (name == webkit::npapi::PluginGroup::kShockwaveGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Shockwave""));
   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)
     UserMetrics::RecordAction(
         UserMetricsAction(""BlockedPluginInfobar.Shown.RealPlayer""));
 }
",C,"  else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.WindowsMediaPlayer""));
",,,"@@ -126,6 +126,9 @@ BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(
   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)
     UserMetrics::RecordAction(
         UserMetricsAction(""BlockedPluginInfobar.Shown.RealPlayer""));
+  else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName)
+    UserMetrics::RecordAction(
+        UserMetricsAction(""BlockedPluginInfobar.Shown.WindowsMediaPlayer""));
 }
 
 BlockedPluginInfoBarDelegate::~BlockedPluginInfoBarDelegate() {",Chrome,d662b905d30cec7899bbb15140dcfacd73506167,7ad8e414e2fd5dc3207095257500745d8bd16a43,1,"BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(
    TabContents* tab_contents,
    const string16& utf16_name)
    : PluginInfoBarDelegate(tab_contents, utf16_name) {
  UserMetrics::RecordAction(UserMetricsAction(""BlockedPluginInfobar.Shown""));
  std::string name = UTF16ToUTF8(utf16_name);
  if (name == webkit::npapi::PluginGroup::kJavaGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Java""));
  else if (name == webkit::npapi::PluginGroup::kQuickTimeGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.QuickTime""));
  else if (name == webkit::npapi::PluginGroup::kShockwaveGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Shockwave""));
   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)
     UserMetrics::RecordAction(
         UserMetricsAction(""BlockedPluginInfobar.Shown.RealPlayer""));
//fix_flaw_line_below:
//  else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName)
//fix_flaw_line_below:
//    UserMetrics::RecordAction(
//fix_flaw_line_below:
//        UserMetricsAction(""BlockedPluginInfobar.Shown.WindowsMediaPlayer""));
 }
",183756,"BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(
    TabContents* tab_contents,
    const string16& utf16_name)
    : PluginInfoBarDelegate(tab_contents, utf16_name) {
  UserMetrics::RecordAction(UserMetricsAction(""BlockedPluginInfobar.Shown""));
  std::string name = UTF16ToUTF8(utf16_name);
  if (name == webkit::npapi::PluginGroup::kJavaGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Java""));
  else if (name == webkit::npapi::PluginGroup::kQuickTimeGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.QuickTime""));
  else if (name == webkit::npapi::PluginGroup::kShockwaveGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Shockwave""));
   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)
     UserMetrics::RecordAction(
         UserMetricsAction(""BlockedPluginInfobar.Shown.RealPlayer""));
 }
","BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(
    TabContents* tab_contents,
    const string16& utf16_name)
    : PluginInfoBarDelegate(tab_contents, utf16_name) {
  UserMetrics::RecordAction(UserMetricsAction(""BlockedPluginInfobar.Shown""));
  std::string name = UTF16ToUTF8(utf16_name);
  if (name == webkit::npapi::PluginGroup::kJavaGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Java""));
  else if (name == webkit::npapi::PluginGroup::kQuickTimeGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.QuickTime""));
  else if (name == webkit::npapi::PluginGroup::kShockwaveGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.Shockwave""));
   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)
     UserMetrics::RecordAction(
         UserMetricsAction(""BlockedPluginInfobar.Shown.RealPlayer""));
  else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.WindowsMediaPlayer""));
 }
","The `BlockedPluginInfoBarDelegate` constructor initializes an instance of the `PluginInfoBarDelegate` class, taking `tab_contents` and a UTF-16 encoded plugin name as parameters. Upon instantiation, it records a user metrics action indicating that the blocked plugin infobar is displayed. The constructor then converts the UTF-16 plugin name to UTF-8 and checks it against predefined plugin group names (Java, QuickTime, Shockwave, RealPlayer). Depending on the matched group, it records specific user metrics actions to track which type of blocked plugin infobar is shown, enhancing user interaction analytics.","The provided code defines a constructor for a class that manages the display of an information bar when a plugin is blocked in a web browser. Upon creation, it logs an action indicating that the information bar has been shown. The constructor also converts the name of the blocked plugin from one encoding format to another and checks it against a list of known plugin categories. Depending on which category the blocked plugin belongs to, it records additional specific actions to track user interactions with the information bar, thereby enhancing the understanding of user behavior regarding blocked plugins.","The vulnerability in the original code stemmed from the lack of handling for the Windows Media Player plugin, which could lead to inconsistent user metrics tracking when this specific plugin was blocked. The absence of a corresponding condition meant that if the Windows Media Player plugin was blocked, no specific action would be recorded, potentially obscuring user interaction data. The fixed code addresses this by adding an additional conditional check for the Windows Media Player plugin group name, ensuring that when this plugin is blocked, a specific user metrics action is recorded, thereby improving the accuracy and completeness of user interaction analytics.","The vulnerability in the original code was due to the omission of handling for a specific plugin, which resulted in a lack of user metrics tracking when that plugin was blocked. This oversight could lead to incomplete data regarding user interactions with blocked plugins, potentially affecting analytics and user experience. The fixed code addresses this issue by introducing a condition to check for the previously unhandled plugin, ensuring that when it is blocked, a corresponding user metrics action is recorded. This enhancement improves the accuracy of user interaction data and ensures that all relevant plugins are accounted for in the metrics.","The vulnerability was fixed by adding a conditional check for the Windows Media Player plugin group name in the updated code. Previously, the code only recorded user metrics for specific plugins like Java, QuickTime, Shockwave, and RealPlayer, leaving out Windows Media Player. The new condition checks if the plugin name matches the Windows Media Player group name and, if so, records a specific user metrics action indicating that the blocked infobar for this plugin is shown. This addition ensures comprehensive tracking of user interactions with all relevant blocked plugins, thereby enhancing the accuracy of user metrics.","The vulnerability was fixed by incorporating an additional condition to handle a previously untracked plugin when it is blocked. This change ensures that when the specific plugin is encountered, a corresponding user metrics action is recorded, thereby addressing the oversight in the original code. By adding this check, the updated implementation guarantees that all relevant plugins are accounted for in the user interaction metrics, enhancing the completeness and accuracy of the data collected. This improvement allows for better analytics and insights into user behavior regarding blocked plugins, ultimately leading to a more informed user experience.","CWE-710, CWE-440, CWE-799, CWE-755, CWE-393, CWE-672, CWE-204, CWE-400, CWE-778, CWE-392",N,-1
59,59,183777,183777,,Remote,Not required,Partial,CVE-2011-2859,https://www.cvedetails.com/cve/CVE-2011-2859/,CWE-264,Low,Partial,Partial,,2011-09-19,7.5,"Google Chrome before 14.0.835.163 uses incorrect permissions for non-gallery pages, which has unspecified impact and attack vectors.",2017-09-18,,12,https://github.com/chromium/chromium/commit/454434f6100cb6a529652a25b5fc181caa7c7f32,454434f6100cb6a529652a25b5fc181caa7c7f32,"Limit extent of webstore app to just chrome.google.com/webstore.

BUG=93497
TEST=Try installing extensions and apps from the webstore, starting both being
initially logged in, and not.


Review URL: http://codereview.chromium.org/7719003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@97986 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/extensions/extension_service.cc,"{""sha"": ""7c68ed1963348c9a9004c2907adb1d4374730617"", ""filename"": ""chrome/browser/extensions/extension_service.cc"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 0, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/454434f6100cb6a529652a25b5fc181caa7c7f32/chrome/browser/extensions/extension_service.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/454434f6100cb6a529652a25b5fc181caa7c7f32/chrome/browser/extensions/extension_service.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/extension_service.cc?ref=454434f6100cb6a529652a25b5fc181caa7c7f32"", ""patch"": ""@@ -438,6 +438,13 @@ void ExtensionService::OnExternalExtensionUpdateUrlFound(\n   external_extension_url_added_ |= true;\n }\n \n+// If a download url matches one of these patterns and has a referrer of the\n+// webstore, then we're willing to treat that as a gallery download.\n+static const char* kAllowedDownloadURLPatterns[] = {\n+  \""https://clients2.google.com/service/update2*\"",\n+  \""https://clients2.googleusercontent.com/crx/*\""\n+};\n+\n bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,\n                                              const GURL& referrer_url) {\n   // Special-case the themes mini-gallery.\n@@ -455,6 +462,18 @@ bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,\n   bool referrer_valid = (referrer_extension == webstore_app);\n   bool download_valid = (download_extension == webstore_app);\n \n+  // We also allow the download to be from a small set of trusted paths.\n+  if (!download_valid) {\n+    for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {\n+      URLPattern pattern(URLPattern::SCHEME_HTTPS,\n+                         kAllowedDownloadURLPatterns[i]);\n+      if (pattern.MatchesURL(download_url)) {\n+        download_valid = true;\n+        break;\n+      }\n+    }\n+  }\n+\n   // If the command-line gallery URL is set, then be a bit more lenient.\n   GURL store_url =\n       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(""}<_**next**_>{""sha"": ""a224113c1f4316624bd8d0905d08bff6a7f84530"", ""filename"": ""chrome/browser/resources/webstore_app/manifest.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 4, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/454434f6100cb6a529652a25b5fc181caa7c7f32/chrome/browser/resources/webstore_app/manifest.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/454434f6100cb6a529652a25b5fc181caa7c7f32/chrome/browser/resources/webstore_app/manifest.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/resources/webstore_app/manifest.json?ref=454434f6100cb6a529652a25b5fc181caa7c7f32"", ""patch"": ""@@ -10,10 +10,7 @@\n       \""web_url\"": \""https://chrome.google.com/webstore\""\n     },\n     \""urls\"": [\n-      \""*://chrome.google.com/extensions\"",\n-      \""*://chrome.google.com/webstore\"",\n-      \""*://clients2.google.com/service/update2\"",\n-      \""*://clients2.googleusercontent.com/crx\""\n+      \""https://chrome.google.com/webstore\""\n     ]\n   },\n   \""permissions\"": [""}"," bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                              const GURL& referrer_url) {
  if (IsDownloadFromMiniGallery(download_url) &&
      StartsWithASCII(referrer_url.spec(),
                      extension_urls::kMiniGalleryBrowsePrefix, false)) {
    return true;
  }

  const Extension* download_extension = GetExtensionByWebExtent(download_url);
  const Extension* referrer_extension = GetExtensionByWebExtent(referrer_url);
  const Extension* webstore_app = GetWebStoreApp();

   bool referrer_valid = (referrer_extension == webstore_app);
   bool download_valid = (download_extension == webstore_app);
 
  // We also allow the download to be from a small set of trusted paths.
  if (!download_valid) {
    for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {
      URLPattern pattern(URLPattern::SCHEME_HTTPS,
                         kAllowedDownloadURLPatterns[i]);
      if (pattern.MatchesURL(download_url)) {
        download_valid = true;
        break;
      }
    }
  }

   GURL store_url =
       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
           switches::kAppsGalleryURL));
  if (!store_url.is_empty()) {
    std::string store_tld =
        net::RegistryControlledDomainService::GetDomainAndRegistry(store_url);
    if (!referrer_valid) {
      std::string referrer_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              referrer_url);
      referrer_valid = referrer_url.is_empty() || (referrer_tld == store_tld);
    }

    if (!download_valid) {
      std::string download_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              download_url);

      download_valid = (download_tld == store_tld);
    }
  }

  return (referrer_valid && download_valid);
}
"," bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                              const GURL& referrer_url) {
  if (IsDownloadFromMiniGallery(download_url) &&
      StartsWithASCII(referrer_url.spec(),
                      extension_urls::kMiniGalleryBrowsePrefix, false)) {
    return true;
  }

  const Extension* download_extension = GetExtensionByWebExtent(download_url);
  const Extension* referrer_extension = GetExtensionByWebExtent(referrer_url);
  const Extension* webstore_app = GetWebStoreApp();

   bool referrer_valid = (referrer_extension == webstore_app);
   bool download_valid = (download_extension == webstore_app);
 
   GURL store_url =
       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
           switches::kAppsGalleryURL));
  if (!store_url.is_empty()) {
    std::string store_tld =
        net::RegistryControlledDomainService::GetDomainAndRegistry(store_url);
    if (!referrer_valid) {
      std::string referrer_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              referrer_url);
      referrer_valid = referrer_url.is_empty() || (referrer_tld == store_tld);
    }

    if (!download_valid) {
      std::string download_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              download_url);

      download_valid = (download_tld == store_tld);
    }
  }

  return (referrer_valid && download_valid);
}
",C,"  // We also allow the download to be from a small set of trusted paths.
  if (!download_valid) {
    for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {
      URLPattern pattern(URLPattern::SCHEME_HTTPS,
                         kAllowedDownloadURLPatterns[i]);
      if (pattern.MatchesURL(download_url)) {
        download_valid = true;
        break;
      }
    }
  }

",,,"@@ -438,6 +438,13 @@ void ExtensionService::OnExternalExtensionUpdateUrlFound(
   external_extension_url_added_ |= true;
 }
 
+// If a download url matches one of these patterns and has a referrer of the
+// webstore, then we're willing to treat that as a gallery download.
+static const char* kAllowedDownloadURLPatterns[] = {
+  ""https://clients2.google.com/service/update2*"",
+  ""https://clients2.googleusercontent.com/crx/*""
+};
+
 bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                              const GURL& referrer_url) {
   // Special-case the themes mini-gallery.
@@ -455,6 +462,18 @@ bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
   bool referrer_valid = (referrer_extension == webstore_app);
   bool download_valid = (download_extension == webstore_app);
 
+  // We also allow the download to be from a small set of trusted paths.
+  if (!download_valid) {
+    for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {
+      URLPattern pattern(URLPattern::SCHEME_HTTPS,
+                         kAllowedDownloadURLPatterns[i]);
+      if (pattern.MatchesURL(download_url)) {
+        download_valid = true;
+        break;
+      }
+    }
+  }
+
   // If the command-line gallery URL is set, then be a bit more lenient.
   GURL store_url =
       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(",Chrome,454434f6100cb6a529652a25b5fc181caa7c7f32,4ff8c349b22f825064f526bf6acd53b3a5aecc02,1," bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                              const GURL& referrer_url) {
   // Special-case the themes mini-gallery.
  // TODO(erikkay) When that gallery goes away, remove this code.
  if (IsDownloadFromMiniGallery(download_url) &&
      StartsWithASCII(referrer_url.spec(),
                      extension_urls::kMiniGalleryBrowsePrefix, false)) {
    return true;
  }

  const Extension* download_extension = GetExtensionByWebExtent(download_url);
  const Extension* referrer_extension = GetExtensionByWebExtent(referrer_url);
  const Extension* webstore_app = GetWebStoreApp();

   bool referrer_valid = (referrer_extension == webstore_app);
   bool download_valid = (download_extension == webstore_app);
 
//fix_flaw_line_below:
//  // We also allow the download to be from a small set of trusted paths.
//fix_flaw_line_below:
//  if (!download_valid) {
//fix_flaw_line_below:
//    for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {
//fix_flaw_line_below:
//      URLPattern pattern(URLPattern::SCHEME_HTTPS,
//fix_flaw_line_below:
//                         kAllowedDownloadURLPatterns[i]);
//fix_flaw_line_below:
//      if (pattern.MatchesURL(download_url)) {
//fix_flaw_line_below:
//        download_valid = true;
//fix_flaw_line_below:
//        break;
//fix_flaw_line_below:
//      }
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   // If the command-line gallery URL is set, then be a bit more lenient.
   GURL store_url =
       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
           switches::kAppsGalleryURL));
  if (!store_url.is_empty()) {
    std::string store_tld =
        net::RegistryControlledDomainService::GetDomainAndRegistry(store_url);
    if (!referrer_valid) {
      std::string referrer_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              referrer_url);
      // The referrer gets stripped when transitioning from https to http,
      // or when hitting an unknown test cert and that commonly happens in
      // testing environments.  Given this, we allow an empty referrer when
      // the command-line flag is set.
      // Otherwise, the TLD must match the TLD of the command-line url.
      referrer_valid = referrer_url.is_empty() || (referrer_tld == store_tld);
    }

    if (!download_valid) {
      std::string download_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              download_url);

      // Otherwise, the TLD must match the TLD of the command-line url.
      download_valid = (download_tld == store_tld);
    }
  }

  return (referrer_valid && download_valid);
}
",183777," bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                              const GURL& referrer_url) {
  if (IsDownloadFromMiniGallery(download_url) &&
      StartsWithASCII(referrer_url.spec(),
                      extension_urls::kMiniGalleryBrowsePrefix, false)) {
    return true;
  }

  const Extension* download_extension = GetExtensionByWebExtent(download_url);
  const Extension* referrer_extension = GetExtensionByWebExtent(referrer_url);
  const Extension* webstore_app = GetWebStoreApp();

   bool referrer_valid = (referrer_extension == webstore_app);
   bool download_valid = (download_extension == webstore_app);
 
   GURL store_url =
       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
           switches::kAppsGalleryURL));
  if (!store_url.is_empty()) {
    std::string store_tld =
        net::RegistryControlledDomainService::GetDomainAndRegistry(store_url);
    if (!referrer_valid) {
      std::string referrer_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              referrer_url);
      referrer_valid = referrer_url.is_empty() || (referrer_tld == store_tld);
    }

    if (!download_valid) {
      std::string download_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              download_url);

      download_valid = (download_tld == store_tld);
    }
  }

  return (referrer_valid && download_valid);
}
"," bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                              const GURL& referrer_url) {
  if (IsDownloadFromMiniGallery(download_url) &&
      StartsWithASCII(referrer_url.spec(),
                      extension_urls::kMiniGalleryBrowsePrefix, false)) {
    return true;
  }

  const Extension* download_extension = GetExtensionByWebExtent(download_url);
  const Extension* referrer_extension = GetExtensionByWebExtent(referrer_url);
  const Extension* webstore_app = GetWebStoreApp();

   bool referrer_valid = (referrer_extension == webstore_app);
   bool download_valid = (download_extension == webstore_app);
 
  // We also allow the download to be from a small set of trusted paths.
  if (!download_valid) {
    for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {
      URLPattern pattern(URLPattern::SCHEME_HTTPS,
                         kAllowedDownloadURLPatterns[i]);
      if (pattern.MatchesURL(download_url)) {
        download_valid = true;
        break;
      }
    }
  }

   GURL store_url =
       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
           switches::kAppsGalleryURL));
  if (!store_url.is_empty()) {
    std::string store_tld =
        net::RegistryControlledDomainService::GetDomainAndRegistry(store_url);
    if (!referrer_valid) {
      std::string referrer_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              referrer_url);
      referrer_valid = referrer_url.is_empty() || (referrer_tld == store_tld);
    }

    if (!download_valid) {
      std::string download_tld =
          net::RegistryControlledDomainService::GetDomainAndRegistry(
              download_url);

      download_valid = (download_tld == store_tld);
    }
  }

  return (referrer_valid && download_valid);
}
","The `IsDownloadFromGallery` function determines if a download originated from a valid gallery source by checking the download and referrer URLs. It first verifies if the download is from a mini gallery and if the referrer matches a specific prefix. Then, it retrieves the associated extensions for both URLs and checks if they correspond to the web store app. Additionally, it compares the top-level domains of the URLs against the web store's URL to ensure they match. The function returns true only if both the referrer and download URLs are deemed valid, indicating a legitimate download from the gallery.","The function checks whether a download is sourced from a legitimate gallery by evaluating both the download and referrer URLs. It first assesses if the download is from a specific mini gallery and if the referrer matches a designated prefix. Then, it verifies the extensions associated with both URLs to ensure they correspond to a recognized web store application. Additionally, it compares the top-level domains of the URLs against the web store's domain to confirm they align. The function ultimately returns true only if both the referrer and download are validated as originating from the gallery.","The vulnerability in the original code stemmed from insufficient validation of download sources, allowing potentially malicious downloads from untrusted URLs. Specifically, the checks for valid downloads relied solely on matching the download and referrer extensions to the web store application. The fix introduced a mechanism to allow downloads from a predefined set of trusted paths, enhancing security by incorporating a loop that checks if the download URL matches any patterns in `kAllowedDownloadURLPatterns`. This additional validation step ensures that only downloads from recognized and safe sources are permitted, thereby mitigating the risk of malicious downloads.","The vulnerability in the original code allowed downloads from potentially untrusted sources, as it primarily relied on matching extensions to validate the origin of downloads. This lack of stringent checks could lead to the installation of malicious extensions or apps. The fix addressed this issue by introducing a mechanism to limit valid download sources specifically to a trusted web store URL. By implementing a check against a predefined set of trusted paths, the updated code ensures that only downloads from recognized and secure locations are permitted, thereby enhancing the overall security of the download process.","The vulnerability was fixed by adding a validation mechanism that checks if the download URL matches any patterns in the `kAllowedDownloadURLPatterns` array. In the updated code, if the initial validation fails, a loop iterates through the allowed patterns, creating a `URLPattern` for each and checking if it matches the download URL. If a match is found, the `download_valid` flag is set to true, allowing the download to proceed from trusted sources. This enhancement ensures that only downloads from recognized and secure paths are accepted, significantly improving the security of the download process.","The vulnerability was addressed by implementing a validation mechanism that checks the download URL against a predefined set of trusted patterns. If the initial validation of the download source fails, the updated code iterates through these trusted patterns to determine if the download URL matches any of them. If a match is found, the download is deemed valid, allowing it to proceed. This additional layer of security ensures that only downloads from recognized and secure sources are permitted, effectively reducing the risk of malicious downloads and enhancing the overall integrity of the download process.","CWE-601, CWE-646, CWE-610, CWE-434, CWE-494, CWE-829, CWE-345, CWE-20, CWE-913, CWE-749",N,-1
60,60,183863,183863,,Remote,Not required,,CVE-2011-2782,https://www.cvedetails.com/cve/CVE-2011-2782/,CWE-264,Medium,,Partial,,2011-08-02,4.3,"The drag-and-drop implementation in Google Chrome before 13.0.782.107 on Linux does not properly enforce permissions for files, which allows user-assisted remote attackers to bypass intended access restrictions via unspecified vectors.",2017-09-18,Bypass ,8,https://github.com/chromium/chromium/commit/20d1c99d9b53a0b2b419aae0075494a9d0b86daf,20d1c99d9b53a0b2b419aae0075494a9d0b86daf,"Ensure URL is updated after a cross-site navigation is pre-empted by
an ""ignored"" navigation.

BUG=77507
TEST=NavigationControllerTest.LoadURL_IgnorePreemptsPending

Review URL: http://codereview.chromium.org/6826015

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@81307 0039d316-1c4b-4281-b951-d872f2087c98",0,content/browser/tab_contents/navigation_controller.cc,"{""sha"": ""ba75cd0ab43021ee1a50605b35eacd3e85af8410"", ""filename"": ""content/browser/tab_contents/navigation_controller.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/20d1c99d9b53a0b2b419aae0075494a9d0b86daf/content/browser/tab_contents/navigation_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/20d1c99d9b53a0b2b419aae0075494a9d0b86daf/content/browser/tab_contents/navigation_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/tab_contents/navigation_controller.cc?ref=20d1c99d9b53a0b2b419aae0075494a9d0b86daf"", ""patch"": ""@@ -533,8 +533,15 @@ bool NavigationController::RendererDidNavigate(\n         return false;\n       break;\n     case NavigationType::NAV_IGNORE:\n-      // There is nothing we can do with this navigation, so we just return to\n+      // If a pending navigation was in progress, this canceled it.  We should\n+      // discard it and make sure it is removed from the URL bar.  After that,\n+      // there is nothing we can do with this navigation, so we just return to\n       // the caller that nothing has happened.\n+      if (pending_entry_) {\n+        DiscardNonCommittedEntries();\n+        extra_invalidate_flags |= TabContents::INVALIDATE_URL;\n+        tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags);\n+      }\n       return false;\n     default:\n       NOTREACHED();""}<_**next**_>{""sha"": ""53c65079b58297c19e40fb5bcfd74696ee0aff20"", ""filename"": ""content/browser/tab_contents/navigation_controller_unittest.cc"", ""status"": ""modified"", ""additions"": 76, ""deletions"": 0, ""changes"": 76, ""blob_url"": ""https://github.com/chromium/chromium/blob/20d1c99d9b53a0b2b419aae0075494a9d0b86daf/content/browser/tab_contents/navigation_controller_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/20d1c99d9b53a0b2b419aae0075494a9d0b86daf/content/browser/tab_contents/navigation_controller_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/tab_contents/navigation_controller_unittest.cc?ref=20d1c99d9b53a0b2b419aae0075494a9d0b86daf"", ""patch"": ""@@ -143,6 +143,44 @@ void RegisterForAllNavNotifications(TestNotificationTracker* tracker,\n                      Source<NavigationController>(controller));\n }\n \n+class TestTabContentsDelegate : public TabContentsDelegate {\n+ public:\n+  explicit TestTabContentsDelegate() :\n+      navigation_state_change_count_(0) {}\n+\n+  int navigation_state_change_count() {\n+    return navigation_state_change_count_;\n+  }\n+\n+  virtual void OpenURLFromTab(TabContents* source,\n+                              const GURL& url, const GURL& referrer,\n+                              WindowOpenDisposition disposition,\n+                              PageTransition::Type transition) {}\n+\n+  // Keep track of whether the tab has notified us of a navigation state change.\n+  virtual void NavigationStateChanged(const TabContents* source,\n+                                      unsigned changed_flags) {\n+    navigation_state_change_count_++;\n+  }\n+\n+  virtual void AddNewContents(TabContents* source,\n+                              TabContents* new_contents,\n+                              WindowOpenDisposition disposition,\n+                              const gfx::Rect& initial_pos,\n+                              bool user_gesture) {}\n+  virtual void ActivateContents(TabContents* contents) {}\n+  virtual void DeactivateContents(TabContents* contents) {}\n+  virtual void LoadingStateChanged(TabContents* source) {}\n+  virtual void CloseContents(TabContents* source) {}\n+  virtual void MoveContents(TabContents* source, const gfx::Rect& pos) {}\n+  virtual void ToolbarSizeChanged(TabContents* source, bool is_animating) {}\n+  virtual void UpdateTargetURL(TabContents* source, const GURL& url) {}\n+\n+ private:\n+  // The number of times NavigationStateChanged has been called.\n+  int navigation_state_change_count_;\n+};\n+\n // -----------------------------------------------------------------------------\n \n TEST_F(NavigationControllerTest, Defaults) {\n@@ -427,6 +465,44 @@ TEST_F(NavigationControllerTest, LoadURL_BackPreemptsPending) {\n   EXPECT_EQ(kExistingURL1, controller().GetActiveEntry()->url());\n }\n \n+// Tests an ignored navigation when there is a pending new navigation.\n+// This will happen if the user enters a URL, but before that commits, the\n+// current blank page reloads.  See http://crbug.com/77507.\n+TEST_F(NavigationControllerTest, LoadURL_IgnorePreemptsPending) {\n+  TestNotificationTracker notifications;\n+  RegisterForAllNavNotifications(&notifications, &controller());\n+\n+  // Set a TabContentsDelegate to listen for state changes.\n+  scoped_ptr<TestTabContentsDelegate> delegate(new TestTabContentsDelegate());\n+  EXPECT_FALSE(contents()->delegate());\n+  contents()->set_delegate(delegate.get());\n+\n+  // Without any navigations, the renderer starts at about:blank.\n+  const GURL kExistingURL(\""about:blank\"");\n+\n+  // Now make a pending new navigation.\n+  const GURL kNewURL(\""http://eh\"");\n+  controller().LoadURL(kNewURL, GURL(), PageTransition::TYPED);\n+  EXPECT_EQ(0U, notifications.size());\n+  EXPECT_EQ(-1, controller().pending_entry_index());\n+  EXPECT_TRUE(controller().pending_entry());\n+  EXPECT_EQ(-1, controller().last_committed_entry_index());\n+  EXPECT_EQ(1, delegate->navigation_state_change_count());\n+\n+  // Before that commits, a document.write and location.reload can cause the\n+  // renderer to send a FrameNavigate with page_id -1.\n+  rvh()->SendNavigate(-1, kExistingURL);\n+\n+  // This should clear the pending entry and notify of a navigation state\n+  // change, so that we do not keep displaying kNewURL.\n+  EXPECT_EQ(-1, controller().pending_entry_index());\n+  EXPECT_FALSE(controller().pending_entry());\n+  EXPECT_EQ(-1, controller().last_committed_entry_index());\n+  EXPECT_EQ(2, delegate->navigation_state_change_count());\n+\n+  contents()->set_delegate(NULL);\n+}\n+\n TEST_F(NavigationControllerTest, Reload) {\n   TestNotificationTracker notifications;\n   RegisterForAllNavNotifications(&notifications, &controller());""}","bool NavigationController::RendererDidNavigate(
    const ViewHostMsg_FrameNavigate_Params& params,
    int extra_invalidate_flags,
    LoadCommittedDetails* details) {

  if (GetLastCommittedEntry()) {
    details->previous_url = GetLastCommittedEntry()->url();
    details->previous_entry_index = last_committed_entry_index();
  } else {
    details->previous_url = GURL();
    details->previous_entry_index = -1;
  }

  if (pending_entry_index_ >= 0 && !pending_entry_->site_instance()) {
    DCHECK(pending_entry_->restore_type() != NavigationEntry::RESTORE_NONE);
    pending_entry_->set_site_instance(tab_contents_->GetSiteInstance());
    pending_entry_->set_restore_type(NavigationEntry::RESTORE_NONE);
  }

  details->is_in_page = IsURLInPageNavigation(params.url);

  details->type = ClassifyNavigation(params);

  switch (details->type) {
    case NavigationType::NEW_PAGE:
      RendererDidNavigateToNewPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::EXISTING_PAGE:
      RendererDidNavigateToExistingPage(params);
      break;
    case NavigationType::SAME_PAGE:
      RendererDidNavigateToSamePage(params);
      break;
    case NavigationType::IN_PAGE:
      RendererDidNavigateInPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::NEW_SUBFRAME:
      RendererDidNavigateNewSubframe(params);
      break;
    case NavigationType::AUTO_SUBFRAME:
      if (!RendererDidNavigateAutoSubframe(params))
         return false;
       break;
     case NavigationType::NAV_IGNORE:
      // If a pending navigation was in progress, this canceled it.  We should
      // discard it and make sure it is removed from the URL bar.  After that,
      // there is nothing we can do with this navigation, so we just return to
      if (pending_entry_) {
        DiscardNonCommittedEntries();
        extra_invalidate_flags |= TabContents::INVALIDATE_URL;
        tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags);
      }
       return false;
     default:
       NOTREACHED();
  }

  DCHECK(!params.content_state.empty());
  NavigationEntry* active_entry = GetActiveEntry();
  active_entry->set_content_state(params.content_state);

  DCHECK(active_entry->site_instance() == tab_contents_->GetSiteInstance());

  details->is_auto = (PageTransition::IsRedirect(params.transition) &&
                      !pending_entry()) ||
      params.gesture == NavigationGestureAuto;

  details->entry = active_entry;
  details->is_main_frame = PageTransition::IsMainFrame(params.transition);
  details->serialized_security_info = params.security_info;
  details->http_status_code = params.http_status_code;
  NotifyNavigationEntryCommitted(details, extra_invalidate_flags);

  return true;
}
","bool NavigationController::RendererDidNavigate(
    const ViewHostMsg_FrameNavigate_Params& params,
    int extra_invalidate_flags,
    LoadCommittedDetails* details) {

  if (GetLastCommittedEntry()) {
    details->previous_url = GetLastCommittedEntry()->url();
    details->previous_entry_index = last_committed_entry_index();
  } else {
    details->previous_url = GURL();
    details->previous_entry_index = -1;
  }

  if (pending_entry_index_ >= 0 && !pending_entry_->site_instance()) {
    DCHECK(pending_entry_->restore_type() != NavigationEntry::RESTORE_NONE);
    pending_entry_->set_site_instance(tab_contents_->GetSiteInstance());
    pending_entry_->set_restore_type(NavigationEntry::RESTORE_NONE);
  }

  details->is_in_page = IsURLInPageNavigation(params.url);

  details->type = ClassifyNavigation(params);

  switch (details->type) {
    case NavigationType::NEW_PAGE:
      RendererDidNavigateToNewPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::EXISTING_PAGE:
      RendererDidNavigateToExistingPage(params);
      break;
    case NavigationType::SAME_PAGE:
      RendererDidNavigateToSamePage(params);
      break;
    case NavigationType::IN_PAGE:
      RendererDidNavigateInPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::NEW_SUBFRAME:
      RendererDidNavigateNewSubframe(params);
      break;
    case NavigationType::AUTO_SUBFRAME:
      if (!RendererDidNavigateAutoSubframe(params))
         return false;
       break;
     case NavigationType::NAV_IGNORE:
       return false;
     default:
       NOTREACHED();
  }

  DCHECK(!params.content_state.empty());
  NavigationEntry* active_entry = GetActiveEntry();
  active_entry->set_content_state(params.content_state);

  DCHECK(active_entry->site_instance() == tab_contents_->GetSiteInstance());

  details->is_auto = (PageTransition::IsRedirect(params.transition) &&
                      !pending_entry()) ||
      params.gesture == NavigationGestureAuto;

  details->entry = active_entry;
  details->is_main_frame = PageTransition::IsMainFrame(params.transition);
  details->serialized_security_info = params.security_info;
  details->http_status_code = params.http_status_code;
  NotifyNavigationEntryCommitted(details, extra_invalidate_flags);

  return true;
}
",C,"      // If a pending navigation was in progress, this canceled it.  We should
      // discard it and make sure it is removed from the URL bar.  After that,
      // there is nothing we can do with this navigation, so we just return to
      if (pending_entry_) {
        DiscardNonCommittedEntries();
        extra_invalidate_flags |= TabContents::INVALIDATE_URL;
        tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags);
      }
",,,"@@ -533,8 +533,15 @@ bool NavigationController::RendererDidNavigate(
         return false;
       break;
     case NavigationType::NAV_IGNORE:
-      // There is nothing we can do with this navigation, so we just return to
+      // If a pending navigation was in progress, this canceled it.  We should
+      // discard it and make sure it is removed from the URL bar.  After that,
+      // there is nothing we can do with this navigation, so we just return to
       // the caller that nothing has happened.
+      if (pending_entry_) {
+        DiscardNonCommittedEntries();
+        extra_invalidate_flags |= TabContents::INVALIDATE_URL;
+        tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags);
+      }
       return false;
     default:
       NOTREACHED();",Chrome,20d1c99d9b53a0b2b419aae0075494a9d0b86daf,e2e2411a8144afd467a0b558541521355b543506,1,"bool NavigationController::RendererDidNavigate(
    const ViewHostMsg_FrameNavigate_Params& params,
    int extra_invalidate_flags,
    LoadCommittedDetails* details) {

  // Save the previous state before we clobber it.
  if (GetLastCommittedEntry()) {
    details->previous_url = GetLastCommittedEntry()->url();
    details->previous_entry_index = last_committed_entry_index();
  } else {
    details->previous_url = GURL();
    details->previous_entry_index = -1;
  }

  // The pending_entry has no SiteInstance when we are restoring an entry.  We
  // must fill it in here so we can find the entry later by calling
  // GetEntryIndexWithPageID.  In all other cases, the SiteInstance should be
  // assigned already and we shouldn't change it.
  if (pending_entry_index_ >= 0 && !pending_entry_->site_instance()) {
    DCHECK(pending_entry_->restore_type() != NavigationEntry::RESTORE_NONE);
    pending_entry_->set_site_instance(tab_contents_->GetSiteInstance());
    pending_entry_->set_restore_type(NavigationEntry::RESTORE_NONE);
  }

  // is_in_page must be computed before the entry gets committed.
  details->is_in_page = IsURLInPageNavigation(params.url);

  // Do navigation-type specific actions. These will make and commit an entry.
  details->type = ClassifyNavigation(params);

  switch (details->type) {
    case NavigationType::NEW_PAGE:
      RendererDidNavigateToNewPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::EXISTING_PAGE:
      RendererDidNavigateToExistingPage(params);
      break;
    case NavigationType::SAME_PAGE:
      RendererDidNavigateToSamePage(params);
      break;
    case NavigationType::IN_PAGE:
      RendererDidNavigateInPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::NEW_SUBFRAME:
      RendererDidNavigateNewSubframe(params);
      break;
    case NavigationType::AUTO_SUBFRAME:
      if (!RendererDidNavigateAutoSubframe(params))
         return false;
       break;
     case NavigationType::NAV_IGNORE:
//flaw_line_below:
      // There is nothing we can do with this navigation, so we just return to
//fix_flaw_line_below:
//      // If a pending navigation was in progress, this canceled it.  We should
//fix_flaw_line_below:
//      // discard it and make sure it is removed from the URL bar.  After that,
//fix_flaw_line_below:
//      // there is nothing we can do with this navigation, so we just return to
       // the caller that nothing has happened.
//fix_flaw_line_below:
//      if (pending_entry_) {
//fix_flaw_line_below:
//        DiscardNonCommittedEntries();
//fix_flaw_line_below:
//        extra_invalidate_flags |= TabContents::INVALIDATE_URL;
//fix_flaw_line_below:
//        tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags);
//fix_flaw_line_below:
//      }
       return false;
     default:
       NOTREACHED();
  }

  // All committed entries should have nonempty content state so WebKit doesn't
  // get confused when we go back to them (see the function for details).
  DCHECK(!params.content_state.empty());
  NavigationEntry* active_entry = GetActiveEntry();
  active_entry->set_content_state(params.content_state);

  // The active entry's SiteInstance should match our SiteInstance.
  DCHECK(active_entry->site_instance() == tab_contents_->GetSiteInstance());

  // WebKit doesn't set the ""auto"" transition on meta refreshes properly (bug
  // 1051891) so we manually set it for redirects which we normally treat as
  // ""non-user-gestures"" where we want to update stuff after navigations.
  //
  // Note that the redirect check also checks for a pending entry to
  // differentiate real redirects from browser initiated navigations to a
  // redirected entry. This happens when you hit back to go to a page that was
  // the destination of a redirect, we don't want to treat it as a redirect
  // even though that's what its transition will be. See bug 1117048.
  //
  // TODO(brettw) write a test for this complicated logic.
  details->is_auto = (PageTransition::IsRedirect(params.transition) &&
                      !pending_entry()) ||
      params.gesture == NavigationGestureAuto;

  // Now prep the rest of the details for the notification and broadcast.
  details->entry = active_entry;
  details->is_main_frame = PageTransition::IsMainFrame(params.transition);
  details->serialized_security_info = params.security_info;
  details->http_status_code = params.http_status_code;
  NotifyNavigationEntryCommitted(details, extra_invalidate_flags);

  return true;
}
",183863,"bool NavigationController::RendererDidNavigate(
    const ViewHostMsg_FrameNavigate_Params& params,
    int extra_invalidate_flags,
    LoadCommittedDetails* details) {

  if (GetLastCommittedEntry()) {
    details->previous_url = GetLastCommittedEntry()->url();
    details->previous_entry_index = last_committed_entry_index();
  } else {
    details->previous_url = GURL();
    details->previous_entry_index = -1;
  }

  if (pending_entry_index_ >= 0 && !pending_entry_->site_instance()) {
    DCHECK(pending_entry_->restore_type() != NavigationEntry::RESTORE_NONE);
    pending_entry_->set_site_instance(tab_contents_->GetSiteInstance());
    pending_entry_->set_restore_type(NavigationEntry::RESTORE_NONE);
  }

  details->is_in_page = IsURLInPageNavigation(params.url);

  details->type = ClassifyNavigation(params);

  switch (details->type) {
    case NavigationType::NEW_PAGE:
      RendererDidNavigateToNewPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::EXISTING_PAGE:
      RendererDidNavigateToExistingPage(params);
      break;
    case NavigationType::SAME_PAGE:
      RendererDidNavigateToSamePage(params);
      break;
    case NavigationType::IN_PAGE:
      RendererDidNavigateInPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::NEW_SUBFRAME:
      RendererDidNavigateNewSubframe(params);
      break;
    case NavigationType::AUTO_SUBFRAME:
      if (!RendererDidNavigateAutoSubframe(params))
         return false;
       break;
     case NavigationType::NAV_IGNORE:
       return false;
     default:
       NOTREACHED();
  }

  DCHECK(!params.content_state.empty());
  NavigationEntry* active_entry = GetActiveEntry();
  active_entry->set_content_state(params.content_state);

  DCHECK(active_entry->site_instance() == tab_contents_->GetSiteInstance());

  details->is_auto = (PageTransition::IsRedirect(params.transition) &&
                      !pending_entry()) ||
      params.gesture == NavigationGestureAuto;

  details->entry = active_entry;
  details->is_main_frame = PageTransition::IsMainFrame(params.transition);
  details->serialized_security_info = params.security_info;
  details->http_status_code = params.http_status_code;
  NotifyNavigationEntryCommitted(details, extra_invalidate_flags);

  return true;
}
","bool NavigationController::RendererDidNavigate(
    const ViewHostMsg_FrameNavigate_Params& params,
    int extra_invalidate_flags,
    LoadCommittedDetails* details) {

  if (GetLastCommittedEntry()) {
    details->previous_url = GetLastCommittedEntry()->url();
    details->previous_entry_index = last_committed_entry_index();
  } else {
    details->previous_url = GURL();
    details->previous_entry_index = -1;
  }

  if (pending_entry_index_ >= 0 && !pending_entry_->site_instance()) {
    DCHECK(pending_entry_->restore_type() != NavigationEntry::RESTORE_NONE);
    pending_entry_->set_site_instance(tab_contents_->GetSiteInstance());
    pending_entry_->set_restore_type(NavigationEntry::RESTORE_NONE);
  }

  details->is_in_page = IsURLInPageNavigation(params.url);

  details->type = ClassifyNavigation(params);

  switch (details->type) {
    case NavigationType::NEW_PAGE:
      RendererDidNavigateToNewPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::EXISTING_PAGE:
      RendererDidNavigateToExistingPage(params);
      break;
    case NavigationType::SAME_PAGE:
      RendererDidNavigateToSamePage(params);
      break;
    case NavigationType::IN_PAGE:
      RendererDidNavigateInPage(params, &(details->did_replace_entry));
      break;
    case NavigationType::NEW_SUBFRAME:
      RendererDidNavigateNewSubframe(params);
      break;
    case NavigationType::AUTO_SUBFRAME:
      if (!RendererDidNavigateAutoSubframe(params))
         return false;
       break;
     case NavigationType::NAV_IGNORE:
      // If a pending navigation was in progress, this canceled it.  We should
      // discard it and make sure it is removed from the URL bar.  After that,
      // there is nothing we can do with this navigation, so we just return to
      if (pending_entry_) {
        DiscardNonCommittedEntries();
        extra_invalidate_flags |= TabContents::INVALIDATE_URL;
        tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags);
      }
       return false;
     default:
       NOTREACHED();
  }

  DCHECK(!params.content_state.empty());
  NavigationEntry* active_entry = GetActiveEntry();
  active_entry->set_content_state(params.content_state);

  DCHECK(active_entry->site_instance() == tab_contents_->GetSiteInstance());

  details->is_auto = (PageTransition::IsRedirect(params.transition) &&
                      !pending_entry()) ||
      params.gesture == NavigationGestureAuto;

  details->entry = active_entry;
  details->is_main_frame = PageTransition::IsMainFrame(params.transition);
  details->serialized_security_info = params.security_info;
  details->http_status_code = params.http_status_code;
  NotifyNavigationEntryCommitted(details, extra_invalidate_flags);

  return true;
}
","The `RendererDidNavigate` function in the `NavigationController` class processes navigation events by updating navigation details based on the current and previous navigation entries. It first checks for a last committed entry to set the previous URL and entry index. If a pending entry exists without a site instance, it assigns the current tab's site instance. The function classifies the navigation type and calls the appropriate handler based on this classification, such as for new or existing pages. It updates the active entry's content state, determines if the navigation is automatic, and notifies that a navigation entry has been committed, returning a success status.","The function processes navigation events by updating details related to the current and previous navigation states. It checks for an existing navigation entry to retrieve the previous URL and index, and if a pending entry lacks a site instance, it assigns the current tab's instance. The function classifies the type of navigation and invokes the corresponding handler for actions like navigating to new or existing pages. It updates the active entry's content state, assesses whether the navigation is automatic, and notifies the system of the committed navigation entry, ultimately returning a success status.","The vulnerability in the original code stemmed from not properly handling the scenario where a pending navigation was ignored, which could lead to inconsistencies in the URL displayed in the address bar. Specifically, if a navigation was marked as ""ignored,"" the code failed to discard the pending entry and update the URL accordingly, potentially allowing outdated or incorrect URLs to persist. The fix introduced a check for a pending entry when a navigation is ignored, ensuring that any non-committed entries are discarded, the URL is invalidated, and the navigation state is updated, thus maintaining consistency and preventing misleading information in the URL bar.","The vulnerability in the original code arose from the failure to properly handle situations where a pending navigation was ignored, which could result in the URL displayed in the address bar not being updated correctly. This inconsistency could mislead users by showing outdated or incorrect URLs after a navigation event. The fix addressed this issue by implementing a mechanism to discard any non-committed entries when a navigation is ignored, ensuring that the URL is invalidated and updated appropriately, thereby maintaining accurate navigation state and preventing user confusion regarding the current page.","The vulnerability was fixed by adding a check for a pending entry when a navigation is marked as ""ignored."" In the updated code, if a pending entry exists, the function now calls `DiscardNonCommittedEntries()` to remove it, ensuring that any outdated navigation state is cleared. Additionally, the code updates the `extra_invalidate_flags` to include `TabContents::INVALIDATE_URL`, which prompts the system to refresh the URL displayed in the address bar. This ensures that the navigation state is accurately reflected, preventing any misleading information from being shown to the user after a cross-site navigation is pre-empted.","The vulnerability was fixed by implementing a mechanism to handle ignored navigations more effectively. When a navigation is marked as ignored, the code now checks for any pending entries and ensures they are discarded to prevent outdated information from persisting. Additionally, the system is instructed to invalidate the displayed URL, prompting an update to reflect the current navigation state accurately. This change ensures that users are not misled by incorrect URLs in the address bar, thereby maintaining consistency and clarity in the navigation experience.","CWE-1022, CWE-706, CWE-611, CWE-601, CWE-552, CWE-444, CWE-358, CWE-352, CWE-290, CWE-20",N,-1
61,61,183905,183905,,Remote,Not required,Partial,CVE-2011-2798,https://www.cvedetails.com/cve/CVE-2011-2798/,CWE-264,Low,,,,2011-08-02,5.0,"Google Chrome before 13.0.782.107 does not properly restrict access to internal schemes, which allows remote attackers to have an unspecified impact via a crafted web site.",2017-09-18,,10,https://github.com/chromium/chromium/commit/ce891a86763d3540e2612be26938a6163310efe0,ce891a86763d3540e2612be26938a6163310efe0,"Prevent navigation to chrome-devtools: and chrome-internal: schemas from http

BUG=87815
Review URL: http://codereview.chromium.org/7275032

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@91002 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/renderer/chrome_content_renderer_client.cc,"{""sha"": ""510dd6385437789e15aa0d0a1b7d6c111cd46d55"", ""filename"": ""chrome/renderer/chrome_content_renderer_client.cc"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 3, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/ce891a86763d3540e2612be26938a6163310efe0/chrome/renderer/chrome_content_renderer_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ce891a86763d3540e2612be26938a6163310efe0/chrome/renderer/chrome_content_renderer_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/renderer/chrome_content_renderer_client.cc?ref=ce891a86763d3540e2612be26938a6163310efe0"", ""patch"": ""@@ -174,12 +174,19 @@ void ChromeContentRendererClient::RenderThreadStarted() {\n           switches::kEnableIPCFuzzing)) {\n     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());\n   }\n-  // chrome: pages should not be accessible by normal content, and should\n-  // also be unable to script anything but themselves (to help limit the damage\n-  // that a corrupt chrome: page could cause).\n+  // chrome:, chrome-devtools:, and chrome-internal: pages should not be\n+  // accessible by normal content, and should also be unable to script\n+  // anything but themselves (to help limit the damage that a corrupt\n+  // page could cause).\n   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));\n   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);\n \n+  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));\n+  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);\n+\n+  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));\n+  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);\n+\n   // chrome-extension: resources shouldn't trigger insecure content warnings.\n   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));\n   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);""}<_**next**_>{""sha"": ""3f6e1091b739477234c7eadcf38ba4b0907d2e28"", ""filename"": ""content/common/url_constants.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/ce891a86763d3540e2612be26938a6163310efe0/content/common/url_constants.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ce891a86763d3540e2612be26938a6163310efe0/content/common/url_constants.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/url_constants.cc?ref=ce891a86763d3540e2612be26938a6163310efe0"", ""patch"": ""@@ -8,6 +8,9 @@ namespace chrome {\n \n const char kAboutScheme[] = \""about\"";\n const char kBlobScheme[] = \""blob\"";\n+\n+// Before adding new chrome schemes please check with security@chromium.org.\n+// There are security implications associated with introducing new schemes.\n const char kChromeDevToolsScheme[] = \""chrome-devtools\"";\n const char kChromeInternalScheme[] = \""chrome-internal\"";\n const char kChromeUIScheme[] = \""chrome\"";""}","void ChromeContentRendererClient::RenderThreadStarted() {
  chrome_observer_.reset(new ChromeRenderProcessObserver());
  extension_dispatcher_.reset(new ExtensionDispatcher());
  histogram_snapshots_.reset(new RendererHistogramSnapshots());
  net_predictor_.reset(new RendererNetPredictor());
  spellcheck_.reset(new SpellCheck());
  visited_link_slave_.reset(new VisitedLinkSlave());
  phishing_classifier_.reset(safe_browsing::PhishingClassifierFilter::Create());

  RenderThread* thread = RenderThread::current();
  thread->AddFilter(new DevToolsAgentFilter());

  thread->AddObserver(chrome_observer_.get());
  thread->AddObserver(extension_dispatcher_.get());
  thread->AddObserver(histogram_snapshots_.get());
  thread->AddObserver(phishing_classifier_.get());
  thread->AddObserver(spellcheck_.get());
  thread->AddObserver(visited_link_slave_.get());

  thread->RegisterExtension(extensions_v8::ExternalExtension::Get());
  thread->RegisterExtension(extensions_v8::LoadTimesExtension::Get());
  thread->RegisterExtension(extensions_v8::SearchBoxExtension::Get());
  v8::Extension* search_extension = extensions_v8::SearchExtension::Get();
  if (search_extension)
    thread->RegisterExtension(search_extension);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    thread->RegisterExtension(DomAutomationV8Extension::Get());
  }

  if (CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableIPCFuzzing)) {
     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
   }
  // chrome:, chrome-devtools:, and chrome-internal: pages should not be
  // accessible by normal content, and should also be unable to script
  // anything but themselves (to help limit the damage that a corrupt
  // page could cause).
   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);
 
  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);

  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);

   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);
}
","void ChromeContentRendererClient::RenderThreadStarted() {
  chrome_observer_.reset(new ChromeRenderProcessObserver());
  extension_dispatcher_.reset(new ExtensionDispatcher());
  histogram_snapshots_.reset(new RendererHistogramSnapshots());
  net_predictor_.reset(new RendererNetPredictor());
  spellcheck_.reset(new SpellCheck());
  visited_link_slave_.reset(new VisitedLinkSlave());
  phishing_classifier_.reset(safe_browsing::PhishingClassifierFilter::Create());

  RenderThread* thread = RenderThread::current();
  thread->AddFilter(new DevToolsAgentFilter());

  thread->AddObserver(chrome_observer_.get());
  thread->AddObserver(extension_dispatcher_.get());
  thread->AddObserver(histogram_snapshots_.get());
  thread->AddObserver(phishing_classifier_.get());
  thread->AddObserver(spellcheck_.get());
  thread->AddObserver(visited_link_slave_.get());

  thread->RegisterExtension(extensions_v8::ExternalExtension::Get());
  thread->RegisterExtension(extensions_v8::LoadTimesExtension::Get());
  thread->RegisterExtension(extensions_v8::SearchBoxExtension::Get());
  v8::Extension* search_extension = extensions_v8::SearchExtension::Get();
  if (search_extension)
    thread->RegisterExtension(search_extension);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    thread->RegisterExtension(DomAutomationV8Extension::Get());
  }

  if (CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableIPCFuzzing)) {
     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
   }
   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);
 
   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);
}
",C,"  // chrome:, chrome-devtools:, and chrome-internal: pages should not be
  // accessible by normal content, and should also be unable to script
  // anything but themselves (to help limit the damage that a corrupt
  // page could cause).
  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);

  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);

",,,"@@ -174,12 +174,19 @@ void ChromeContentRendererClient::RenderThreadStarted() {
           switches::kEnableIPCFuzzing)) {
     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
   }
-  // chrome: pages should not be accessible by normal content, and should
-  // also be unable to script anything but themselves (to help limit the damage
-  // that a corrupt chrome: page could cause).
+  // chrome:, chrome-devtools:, and chrome-internal: pages should not be
+  // accessible by normal content, and should also be unable to script
+  // anything but themselves (to help limit the damage that a corrupt
+  // page could cause).
   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);
 
+  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));
+  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);
+
+  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));
+  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);
+
   // chrome-extension: resources shouldn't trigger insecure content warnings.
   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);",Chrome,ce891a86763d3540e2612be26938a6163310efe0,0b481bf80794b5c18646b62cec75efebdce7b28d,1,"void ChromeContentRendererClient::RenderThreadStarted() {
  chrome_observer_.reset(new ChromeRenderProcessObserver());
  extension_dispatcher_.reset(new ExtensionDispatcher());
  histogram_snapshots_.reset(new RendererHistogramSnapshots());
  net_predictor_.reset(new RendererNetPredictor());
  spellcheck_.reset(new SpellCheck());
  visited_link_slave_.reset(new VisitedLinkSlave());
  phishing_classifier_.reset(safe_browsing::PhishingClassifierFilter::Create());

  RenderThread* thread = RenderThread::current();
  thread->AddFilter(new DevToolsAgentFilter());

  thread->AddObserver(chrome_observer_.get());
  thread->AddObserver(extension_dispatcher_.get());
  thread->AddObserver(histogram_snapshots_.get());
  thread->AddObserver(phishing_classifier_.get());
  thread->AddObserver(spellcheck_.get());
  thread->AddObserver(visited_link_slave_.get());

  thread->RegisterExtension(extensions_v8::ExternalExtension::Get());
  thread->RegisterExtension(extensions_v8::LoadTimesExtension::Get());
  thread->RegisterExtension(extensions_v8::SearchBoxExtension::Get());
  v8::Extension* search_extension = extensions_v8::SearchExtension::Get();
  // search_extension is null if not enabled.
  if (search_extension)
    thread->RegisterExtension(search_extension);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    thread->RegisterExtension(DomAutomationV8Extension::Get());
  }

  if (CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableIPCFuzzing)) {
     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
   }
//flaw_line_below:
  // chrome: pages should not be accessible by normal content, and should
//flaw_line_below:
  // also be unable to script anything but themselves (to help limit the damage
//flaw_line_below:
  // that a corrupt chrome: page could cause).
//fix_flaw_line_below:
//  // chrome:, chrome-devtools:, and chrome-internal: pages should not be
//fix_flaw_line_below:
//  // accessible by normal content, and should also be unable to script
//fix_flaw_line_below:
//  // anything but themselves (to help limit the damage that a corrupt
//fix_flaw_line_below:
//  // page could cause).
   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);
 
//fix_flaw_line_below:
//  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));
//fix_flaw_line_below:
//  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));
//fix_flaw_line_below:
//  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);
//fix_flaw_line_below:
//
   // chrome-extension: resources shouldn't trigger insecure content warnings.
   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);
}
",183905,"void ChromeContentRendererClient::RenderThreadStarted() {
  chrome_observer_.reset(new ChromeRenderProcessObserver());
  extension_dispatcher_.reset(new ExtensionDispatcher());
  histogram_snapshots_.reset(new RendererHistogramSnapshots());
  net_predictor_.reset(new RendererNetPredictor());
  spellcheck_.reset(new SpellCheck());
  visited_link_slave_.reset(new VisitedLinkSlave());
  phishing_classifier_.reset(safe_browsing::PhishingClassifierFilter::Create());

  RenderThread* thread = RenderThread::current();
  thread->AddFilter(new DevToolsAgentFilter());

  thread->AddObserver(chrome_observer_.get());
  thread->AddObserver(extension_dispatcher_.get());
  thread->AddObserver(histogram_snapshots_.get());
  thread->AddObserver(phishing_classifier_.get());
  thread->AddObserver(spellcheck_.get());
  thread->AddObserver(visited_link_slave_.get());

  thread->RegisterExtension(extensions_v8::ExternalExtension::Get());
  thread->RegisterExtension(extensions_v8::LoadTimesExtension::Get());
  thread->RegisterExtension(extensions_v8::SearchBoxExtension::Get());
  v8::Extension* search_extension = extensions_v8::SearchExtension::Get();
  if (search_extension)
    thread->RegisterExtension(search_extension);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    thread->RegisterExtension(DomAutomationV8Extension::Get());
  }

  if (CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableIPCFuzzing)) {
     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
   }
   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);
 
   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);
}
","void ChromeContentRendererClient::RenderThreadStarted() {
  chrome_observer_.reset(new ChromeRenderProcessObserver());
  extension_dispatcher_.reset(new ExtensionDispatcher());
  histogram_snapshots_.reset(new RendererHistogramSnapshots());
  net_predictor_.reset(new RendererNetPredictor());
  spellcheck_.reset(new SpellCheck());
  visited_link_slave_.reset(new VisitedLinkSlave());
  phishing_classifier_.reset(safe_browsing::PhishingClassifierFilter::Create());

  RenderThread* thread = RenderThread::current();
  thread->AddFilter(new DevToolsAgentFilter());

  thread->AddObserver(chrome_observer_.get());
  thread->AddObserver(extension_dispatcher_.get());
  thread->AddObserver(histogram_snapshots_.get());
  thread->AddObserver(phishing_classifier_.get());
  thread->AddObserver(spellcheck_.get());
  thread->AddObserver(visited_link_slave_.get());

  thread->RegisterExtension(extensions_v8::ExternalExtension::Get());
  thread->RegisterExtension(extensions_v8::LoadTimesExtension::Get());
  thread->RegisterExtension(extensions_v8::SearchBoxExtension::Get());
  v8::Extension* search_extension = extensions_v8::SearchExtension::Get();
  if (search_extension)
    thread->RegisterExtension(search_extension);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    thread->RegisterExtension(DomAutomationV8Extension::Get());
  }

  if (CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kEnableIPCFuzzing)) {
     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
   }
  // chrome:, chrome-devtools:, and chrome-internal: pages should not be
  // accessible by normal content, and should also be unable to script
  // anything but themselves (to help limit the damage that a corrupt
  // page could cause).
   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);
 
  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);

  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);

   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);
}
","The `RenderThreadStarted` function initializes various components essential for the Chrome content renderer's operation. It creates and resets instances of observers and dispatchers, such as `ChromeRenderProcessObserver`, `ExtensionDispatcher`, and `RendererHistogramSnapshots`, among others. The function also adds these components as observers to the current render thread, allowing them to receive notifications about events. Additionally, it registers several V8 extensions, including those for automation and IPC fuzzing, based on command-line switches. Finally, it registers specific URL schemes as display-isolated and secure, enhancing security and functionality within the rendering process.","The code initializes essential components for a web content rendering process, setting up various observers and dispatchers that handle different functionalities, such as spell checking and phishing detection. It establishes these components to listen for events within the rendering thread, ensuring they can respond appropriately. Additionally, the code registers several extensions that enhance the rendering capabilities, depending on specific command-line options. It also implements security measures by designating certain URL schemes as isolated or secure, thereby improving the overall safety and efficiency of the rendering environment.","The vulnerability in the original code allowed navigation to certain internal URL schemes, such as ""chrome-devtools:"" and ""chrome-internal:"", from external HTTP content, potentially enabling malicious pages to exploit these internal resources. This could lead to security risks, including unauthorized access or manipulation of sensitive internal functionalities. The fixed code addresses this issue by explicitly registering these schemes as display-isolated, which restricts their accessibility from normal content. By using `WebSecurityPolicy::registerURLSchemeAsDisplayIsolated`, the code ensures that only the intended contexts can access these internal schemes, thereby enhancing the overall security of the rendering process.","The vulnerability in the original code allowed external HTTP content to navigate to sensitive internal URL schemes, which could lead to security breaches, such as unauthorized access to internal tools and resources. This exposure posed a risk of exploitation by malicious web pages that could manipulate or interact with these internal functionalities. The fix implemented in the updated code restricts access to these internal schemes by designating them as display-isolated, ensuring that only specific contexts can interact with them. This change effectively mitigates the risk of external content accessing and potentially compromising internal resources.","The vulnerability was fixed by explicitly registering the ""chrome-devtools:"" and ""chrome-internal:"" URL schemes as display-isolated using the `WebSecurityPolicy::registerURLSchemeAsDisplayIsolated` function. This change prevents normal content from navigating to these internal schemes, thereby restricting their accessibility and protecting sensitive internal functionalities from potential exploitation by malicious web pages. Additionally, the code ensures that only the intended contexts can access these schemes, enhancing the overall security of the rendering process and mitigating the risk of unauthorized interactions with internal resources.","The vulnerability was fixed by implementing a security measure that restricts access to sensitive internal URL schemes, preventing external content from navigating to them. This was achieved by designating these internal schemes as display-isolated, which ensures that only specific contexts can interact with them. By doing so, the code effectively mitigates the risk of unauthorized access and potential exploitation by malicious web pages, thereby enhancing the overall security of the application. This change helps protect critical internal functionalities from being manipulated or accessed by untrusted external sources.","CWE-749, CWE-284, CWE-287, CWE-732, CWE-426, CWE-601, CWE-346, CWE-20, CWE-269, CWE-610",N,-1
62,62,184594,184594,,Remote,Not required,,CVE-2011-3956,https://www.cvedetails.com/cve/CVE-2011-3956/,CWE-264,Low,,Partial,,2012-02-08,5.0,"The extension implementation in Google Chrome before 17.0.963.46 does not properly handle sandboxed origins, which might allow remote attackers to bypass the Same Origin Policy via a crafted extension.",2017-09-18,Bypass ,1,https://github.com/chromium/chromium/commit/04915c26ea193247b8a29aa24bfa34578ef5d39e,04915c26ea193247b8a29aa24bfa34578ef5d39e,"[Qt] Remove an unnecessary masking from swapBgrToRgb()
https://bugs.webkit.org/show_bug.cgi?id=103630

Reviewed by Zoltan Herczeg.

Get rid of a masking command in swapBgrToRgb() to speed up a little bit.

* platform/graphics/qt/GraphicsContext3DQt.cpp:
(WebCore::swapBgrToRgb):


git-svn-id: svn://svn.chromium.org/blink/trunk@136375 bbb929c8-8fbe-4397-9dbb-9b2b20218538",1,third_party/WebKit/Source/WebCore/platform/graphics/qt/GraphicsContext3DQt.cpp,"{""sha"": ""2867e26b69edeaaffebebe3be0f993335b6d4929"", ""filename"": ""third_party/WebKit/Source/WebCore/ChangeLog"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/04915c26ea193247b8a29aa24bfa34578ef5d39e/third_party/WebKit/Source/WebCore/ChangeLog"", ""raw_url"": ""https://github.com/chromium/chromium/raw/04915c26ea193247b8a29aa24bfa34578ef5d39e/third_party/WebKit/Source/WebCore/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/ChangeLog?ref=04915c26ea193247b8a29aa24bfa34578ef5d39e"", ""patch"": ""@@ -1,3 +1,15 @@\n+2012-12-03  Gabor Rapcsanyi  <rgabor@webkit.org>\n+\n+        [Qt] Remove an unnecessary masking from swapBgrToRgb()\n+        https://bugs.webkit.org/show_bug.cgi?id=103630\n+\n+        Reviewed by Zoltan Herczeg.\n+\n+        Get rid of a masking command in swapBgrToRgb() to speed up a little bit.\n+\n+        * platform/graphics/qt/GraphicsContext3DQt.cpp:\n+        (WebCore::swapBgrToRgb):\n+\n 2012-12-03  Mikhail Pozdnyakov  <mikhail.pozdnyakov@intel.com>\n \n         CSS Device Adaptation: window.innerWidth returns wrong value if CSS viewport descriptors are applied""}<_**next**_>{""sha"": ""540c501ee1c4d98a24046786c6a1ccf758f33f38"", ""filename"": ""third_party/WebKit/Source/WebCore/platform/graphics/qt/GraphicsContext3DQt.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/04915c26ea193247b8a29aa24bfa34578ef5d39e/third_party/WebKit/Source/WebCore/platform/graphics/qt/GraphicsContext3DQt.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/04915c26ea193247b8a29aa24bfa34578ef5d39e/third_party/WebKit/Source/WebCore/platform/graphics/qt/GraphicsContext3DQt.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/platform/graphics/qt/GraphicsContext3DQt.cpp?ref=04915c26ea193247b8a29aa24bfa34578ef5d39e"", ""patch"": ""@@ -204,7 +204,7 @@ GraphicsContext3DPrivate::~GraphicsContext3DPrivate()\n \n static inline quint32 swapBgrToRgb(quint32 pixel)\n {\n-    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);\n+    return (((pixel << 16) | (pixel >> 16)) & 0x00ff00ff) | (pixel & 0xff00ff00);\n }\n \n #if USE(ACCELERATED_COMPOSITING)""}"," static inline quint32 swapBgrToRgb(quint32 pixel)
 {
    return (((pixel << 16) | (pixel >> 16)) & 0x00ff00ff) | (pixel & 0xff00ff00);
 }
"," static inline quint32 swapBgrToRgb(quint32 pixel)
 {
    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);
 }
",C,"    return (((pixel << 16) | (pixel >> 16)) & 0x00ff00ff) | (pixel & 0xff00ff00);
","    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);
",,"@@ -204,7 +204,7 @@ GraphicsContext3DPrivate::~GraphicsContext3DPrivate()
 
 static inline quint32 swapBgrToRgb(quint32 pixel)
 {
-    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);
+    return (((pixel << 16) | (pixel >> 16)) & 0x00ff00ff) | (pixel & 0xff00ff00);
 }
 
 #if USE(ACCELERATED_COMPOSITING)",Chrome,04915c26ea193247b8a29aa24bfa34578ef5d39e,8046e095da6b7fa572ac89972ec041b951c52433,1," static inline quint32 swapBgrToRgb(quint32 pixel)
 {
//flaw_line_below:
    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);
//fix_flaw_line_below:
//    return (((pixel << 16) | (pixel >> 16)) & 0x00ff00ff) | (pixel & 0xff00ff00);
 }
",184594," static inline quint32 swapBgrToRgb(quint32 pixel)
 {
    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);
 }
"," static inline quint32 swapBgrToRgb(quint32 pixel)
 {
    return (((pixel << 16) | (pixel >> 16)) & 0x00ff00ff) | (pixel & 0xff00ff00);
 }
","The provided code defines a static inline function named `swapBgrToRgb`, which takes a 32-bit unsigned integer `pixel` representing a color in BGR (Blue, Green, Red) format and converts it to RGB (Red, Green, Blue) format. It achieves this by shifting the blue component (the least significant byte) to the red position and the red component (the most significant byte) to the blue position, while preserving the green component in its original position. The function uses bitwise operations to manipulate the pixel's bits and returns the newly formatted pixel value in RGB format.","The code defines a function that converts a 32-bit color value from one format to another by rearranging its color components. Specifically, it takes a color represented in a format where the blue component is stored first, followed by green and red, and transforms it into a format where the red component comes first, followed by green and blue. This is accomplished through bitwise operations that shift and mask the individual color components, ensuring that the green component remains unchanged while the blue and red components are swapped. The function ultimately returns the newly formatted color value.","The vulnerability in the original code stemmed from an unnecessary masking operation that could lead to inefficiencies and potential errors in color conversion. Specifically, the expression `((pixel << 16) & 0xff0000)` and `((pixel >> 16) & 0xff)` were used to isolate color components, which could introduce complications if the pixel value exceeded expected ranges. The fixed code simplifies this by removing the masking, using `((pixel << 16) | (pixel >> 16)) & 0x00ff00ff` instead, which efficiently swaps the blue and red components while preserving the green component without the risk of unintended side effects from masking.","The vulnerability in the original code was due to an unnecessary masking operation that could lead to inefficiencies and potential inaccuracies in color conversion. This masking was intended to isolate specific color components but introduced complexity that could result in unexpected behavior, especially if the pixel values were not within the anticipated range. The fixed code addresses this issue by eliminating the masking entirely, streamlining the process of swapping color components. This change not only enhances performance but also reduces the risk of errors, ensuring a more reliable and efficient conversion of color formats.","The vulnerability was fixed by removing the unnecessary masking operations in the function that converted color formats. In the original code, the expressions `((pixel << 16) & 0xff0000)` and `((pixel >> 16) & 0xff)` were used to isolate the red and blue components, respectively, which added complexity and potential for errors. The revised code simplifies this by using `((pixel << 16) | (pixel >> 16)) & 0x00ff00ff`, effectively swapping the blue and red components while preserving the green component without the need for masking. This change enhances both performance and reliability in color conversion.","The vulnerability was fixed by eliminating unnecessary masking operations that complicated the color conversion process. The original implementation used masking to isolate specific color components, which introduced potential inefficiencies and inaccuracies. The revised code streamlines the conversion by directly manipulating the color components without the need for masking, effectively swapping the blue and red components while maintaining the integrity of the green component. This simplification not only enhances performance by reducing computational overhead but also minimizes the risk of errors, resulting in a more reliable and efficient color format conversion.","CWE-704, CWE-682, CWE-698, CWE-697, CWE-197, CWE-190, CWE-681, CWE-369, CWE-125, CWE-119",N,-1
63,63,184889,184889,,Remote,Not required,,CVE-2013-2905,https://www.cvedetails.com/cve/CVE-2013-2905/,CWE-264,Low,Partial,,,2013-08-21,5.0,"The SharedMemory::Create function in memory/shared_memory_posix.cc in Google Chrome before 29.0.1547.57 uses weak permissions under /dev/shm/, which allows attackers to obtain sensitive information via direct access to a POSIX shared-memory file.",2017-09-18,+Info ,39,https://github.com/chromium/chromium/commit/afb848acb43ba316097ab4fddfa38dbd80bc6a71,afb848acb43ba316097ab4fddfa38dbd80bc6a71,"Posix: fix named SHM mappings permissions.

Make sure that named mappings in /dev/shm/ aren't created with
broad permissions.

BUG=254159
R=mark@chromium.org, markus@chromium.org

Review URL: https://codereview.chromium.org/17779002

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@209814 0039d316-1c4b-4281-b951-d872f2087c98",3,base/memory/shared_memory_posix.cc,"{""sha"": ""2be787d75331d708f9f125ba995f6c42b3691325"", ""filename"": ""base/memory/shared_memory_posix.cc"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 4, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/afb848acb43ba316097ab4fddfa38dbd80bc6a71/base/memory/shared_memory_posix.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/afb848acb43ba316097ab4fddfa38dbd80bc6a71/base/memory/shared_memory_posix.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/memory/shared_memory_posix.cc?ref=afb848acb43ba316097ab4fddfa38dbd80bc6a71"", ""patch"": ""@@ -8,6 +8,7 @@\n #include <fcntl.h>\n #include <sys/mman.h>\n #include <sys/stat.h>\n+#include <sys/types.h>\n #include <unistd.h>\n \n #include \""base/file_util.h\""\n@@ -149,12 +150,47 @@ bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {\n     if (!FilePathForMemoryName(*options.name, &path))\n       return false;\n \n-    fp = file_util::OpenFile(path, \""w+x\"");\n-    if (fp == NULL && options.open_existing) {\n-      // \""w+\"" will truncate if it already exists.\n-      fp = file_util::OpenFile(path, \""a+\"");\n+    // Make sure that the file is opened without any permission\n+    // to other users on the system.\n+    const mode_t kOwnerOnly = S_IRUSR | S_IWUSR;\n+\n+    // First, try to create the file.\n+    int fd = HANDLE_EINTR(\n+        open(path.value().c_str(), O_RDWR | O_CREAT | O_EXCL, kOwnerOnly));\n+    if (fd == -1 && options.open_existing) {\n+      // If this doesn't work, try and open an existing file in append mode.\n+      // Opening an existing file in a world writable directory has two main\n+      // security implications:\n+      // - Attackers could plant a file under their control, so ownership of\n+      //   the file is checked below.\n+      // - Attackers could plant a symbolic link so that an unexpected file\n+      //   is opened, so O_NOFOLLOW is passed to open().\n+      fd = HANDLE_EINTR(\n+          open(path.value().c_str(), O_RDWR | O_APPEND | O_NOFOLLOW));\n+\n+      // Check that the current user owns the file.\n+      // If uid != euid, then a more complex permission model is used and this\n+      // API is not appropriate.\n+      const uid_t real_uid = getuid();\n+      const uid_t effective_uid = geteuid();\n+      struct stat sb;\n+      if (fd >= 0 &&\n+          (fstat(fd, &sb) != 0 || sb.st_uid != real_uid ||\n+           sb.st_uid != effective_uid)) {\n+        LOG(ERROR) <<\n+            \""Invalid owner when opening existing shared memory file.\"";\n+        HANDLE_EINTR(close(fd));\n+        return false;\n+      }\n+\n+      // An existing file was opened, so its size should not be fixed.\n       fix_size = false;\n     }\n+    fp = NULL;\n+    if (fd >= 0) {\n+      // \""a+\"" is always appropriate: if it's a new file, a+ is similar to w+.\n+      fp = fdopen(fd, \""a+\"");\n+    }\n   }\n   if (fp && fix_size) {\n     // Get current size.""}<_**next**_>{""sha"": ""b1b664a61830eac54bdecc4dfcf97de9eddfa9a4"", ""filename"": ""base/memory/shared_memory_unittest.cc"", ""status"": ""modified"", ""additions"": 72, ""deletions"": 1, ""changes"": 73, ""blob_url"": ""https://github.com/chromium/chromium/blob/afb848acb43ba316097ab4fddfa38dbd80bc6a71/base/memory/shared_memory_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/afb848acb43ba316097ab4fddfa38dbd80bc6a71/base/memory/shared_memory_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/memory/shared_memory_unittest.cc?ref=afb848acb43ba316097ab4fddfa38dbd80bc6a71"", ""patch"": ""@@ -8,6 +8,8 @@\n #endif\n #include \""base/memory/scoped_ptr.h\""\n #include \""base/memory/shared_memory.h\""\n+#include \""base/rand_util.h\""\n+#include \""base/strings/string_number_conversions.h\""\n #include \""base/sys_info.h\""\n #include \""base/test/multiprocess_test.h\""\n #include \""base/threading/platform_thread.h\""\n@@ -21,6 +23,9 @@\n \n #if defined(OS_POSIX)\n #include <sys/mman.h>\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n #endif\n \n static const int kNumThreads = 5;\n@@ -401,7 +406,73 @@ TEST(SharedMemoryTest, AnonymousExecutable) {\n   EXPECT_EQ(0, mprotect(shared_memory.memory(), shared_memory.requested_size(),\n                         PROT_READ | PROT_EXEC));\n }\n-#endif\n+\n+// Android supports a different permission model than POSIX for its \""ashmem\""\n+// shared memory implementation. So the tests about file permissions are not\n+// included on Android.\n+#if !defined(OS_ANDROID)\n+\n+// Set a umask and restore the old mask on destruction.\n+class ScopedUmaskSetter {\n+ public:\n+  explicit ScopedUmaskSetter(mode_t target_mask) {\n+    old_umask_ = umask(target_mask);\n+  }\n+  ~ScopedUmaskSetter() { umask(old_umask_); }\n+ private:\n+  mode_t old_umask_;\n+  DISALLOW_IMPLICIT_CONSTRUCTORS(ScopedUmaskSetter);\n+};\n+\n+// Create a shared memory object, check its permissions.\n+TEST(SharedMemoryTest, FilePermissionsAnonymous) {\n+  const uint32 kTestSize = 1 << 8;\n+\n+  SharedMemory shared_memory;\n+  SharedMemoryCreateOptions options;\n+  options.size = kTestSize;\n+  // Set a file mode creation mask that gives all permissions.\n+  ScopedUmaskSetter permissive_mask(S_IWGRP | S_IWOTH);\n+\n+  EXPECT_TRUE(shared_memory.Create(options));\n+\n+  int shm_fd = shared_memory.handle().fd;\n+  struct stat shm_stat;\n+  EXPECT_EQ(0, fstat(shm_fd, &shm_stat));\n+  // Neither the group, nor others should be able to read the shared memory\n+  // file.\n+  EXPECT_FALSE(shm_stat.st_mode & S_IRWXO);\n+  EXPECT_FALSE(shm_stat.st_mode & S_IRWXG);\n+}\n+\n+// Create a shared memory object, check its permissions.\n+TEST(SharedMemoryTest, FilePermissionsNamed) {\n+  const uint32 kTestSize = 1 << 8;\n+\n+  SharedMemory shared_memory;\n+  SharedMemoryCreateOptions options;\n+  options.size = kTestSize;\n+  std::string shared_mem_name = \""shared_perm_test-\"" + IntToString(getpid()) +\n+      \""-\"" + Uint64ToString(RandUint64());\n+  options.name = &shared_mem_name;\n+  // Set a file mode creation mask that gives all permissions.\n+  ScopedUmaskSetter permissive_mask(S_IWGRP | S_IWOTH);\n+\n+  EXPECT_TRUE(shared_memory.Create(options));\n+  // Clean-up the backing file name immediately, we don't need it.\n+  EXPECT_TRUE(shared_memory.Delete(shared_mem_name));\n+\n+  int shm_fd = shared_memory.handle().fd;\n+  struct stat shm_stat;\n+  EXPECT_EQ(0, fstat(shm_fd, &shm_stat));\n+  // Neither the group, nor others should have been able to open the shared\n+  // memory file while its name existed.\n+  EXPECT_FALSE(shm_stat.st_mode & S_IRWXO);\n+  EXPECT_FALSE(shm_stat.st_mode & S_IRWXG);\n+}\n+#endif  // !defined(OS_ANDROID)\n+\n+#endif  // defined(OS_POSIX)\n \n // Map() will return addresses which are aligned to the platform page size, this\n // varies from platform to platform though.  Since we'd like to advertise a""}","bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
  DCHECK_EQ(-1, mapped_file_);
  if (options.size == 0) return false;

  if (options.size > static_cast<size_t>(std::numeric_limits<int>::max()))
    return false;

  base::ThreadRestrictions::ScopedAllowIO allow_io;

  FILE *fp;
  bool fix_size = true;

  FilePath path;
  if (options.name == NULL || options.name->empty()) {
    DCHECK(!options.open_existing);
    fp = file_util::CreateAndOpenTemporaryShmemFile(&path, options.executable);

    if (fp) {
      if (unlink(path.value().c_str()))
        PLOG(WARNING) << ""unlink"";
    }
  } else {
     if (!FilePathForMemoryName(*options.name, &path))
       return false;
 
    // Make sure that the file is opened without any permission
    // to other users on the system.
    const mode_t kOwnerOnly = S_IRUSR | S_IWUSR;

    // First, try to create the file.
    int fd = HANDLE_EINTR(
        open(path.value().c_str(), O_RDWR | O_CREAT | O_EXCL, kOwnerOnly));
    if (fd == -1 && options.open_existing) {
      // If this doesn't work, try and open an existing file in append mode.
      // Opening an existing file in a world writable directory has two main
      // security implications:
      // - Attackers could plant a file under their control, so ownership of
      //   the file is checked below.
      // - Attackers could plant a symbolic link so that an unexpected file
      //   is opened, so O_NOFOLLOW is passed to open().
      fd = HANDLE_EINTR(
          open(path.value().c_str(), O_RDWR | O_APPEND | O_NOFOLLOW));

      // Check that the current user owns the file.
      // If uid != euid, then a more complex permission model is used and this
      // API is not appropriate.
      const uid_t real_uid = getuid();
      const uid_t effective_uid = geteuid();
      struct stat sb;
      if (fd >= 0 &&
          (fstat(fd, &sb) != 0 || sb.st_uid != real_uid ||
           sb.st_uid != effective_uid)) {
        LOG(ERROR) <<
            ""Invalid owner when opening existing shared memory file."";
        HANDLE_EINTR(close(fd));
        return false;
      }

      // An existing file was opened, so its size should not be fixed.
       fix_size = false;
     }
    fp = NULL;
    if (fd >= 0) {
      // ""a+"" is always appropriate: if it's a new file, a+ is similar to w+.
      fp = fdopen(fd, ""a+"");
    }
   }
   if (fp && fix_size) {
    struct stat stat;
    if (fstat(fileno(fp), &stat) != 0) {
      file_util::CloseFile(fp);
      return false;
    }
    const size_t current_size = stat.st_size;
    if (current_size != options.size) {
      if (HANDLE_EINTR(ftruncate(fileno(fp), options.size)) != 0) {
        file_util::CloseFile(fp);
        return false;
      }
    }
    requested_size_ = options.size;
  }
  if (fp == NULL) {
#if !defined(OS_MACOSX)
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
    FilePath dir = path.DirName();
    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {
      PLOG(ERROR) << ""Unable to access(W_OK|X_OK) "" << dir.value();
      if (dir.value() == ""/dev/shm"") {
        LOG(FATAL) << ""This is frequently caused by incorrect permissions on ""
                   << ""/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix."";
      }
    }
#else
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
#endif
    return false;
  }

  return PrepareMapFile(fp);
}
","bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
  DCHECK_EQ(-1, mapped_file_);
  if (options.size == 0) return false;

  if (options.size > static_cast<size_t>(std::numeric_limits<int>::max()))
    return false;

  base::ThreadRestrictions::ScopedAllowIO allow_io;

  FILE *fp;
  bool fix_size = true;

  FilePath path;
  if (options.name == NULL || options.name->empty()) {
    DCHECK(!options.open_existing);
    fp = file_util::CreateAndOpenTemporaryShmemFile(&path, options.executable);

    if (fp) {
      if (unlink(path.value().c_str()))
        PLOG(WARNING) << ""unlink"";
    }
  } else {
     if (!FilePathForMemoryName(*options.name, &path))
       return false;
 
    fp = file_util::OpenFile(path, ""w+x"");
    if (fp == NULL && options.open_existing) {
      fp = file_util::OpenFile(path, ""a+"");
       fix_size = false;
     }
   }
   if (fp && fix_size) {
    struct stat stat;
    if (fstat(fileno(fp), &stat) != 0) {
      file_util::CloseFile(fp);
      return false;
    }
    const size_t current_size = stat.st_size;
    if (current_size != options.size) {
      if (HANDLE_EINTR(ftruncate(fileno(fp), options.size)) != 0) {
        file_util::CloseFile(fp);
        return false;
      }
    }
    requested_size_ = options.size;
  }
  if (fp == NULL) {
#if !defined(OS_MACOSX)
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
    FilePath dir = path.DirName();
    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {
      PLOG(ERROR) << ""Unable to access(W_OK|X_OK) "" << dir.value();
      if (dir.value() == ""/dev/shm"") {
        LOG(FATAL) << ""This is frequently caused by incorrect permissions on ""
                   << ""/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix."";
      }
    }
#else
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
#endif
    return false;
  }

  return PrepareMapFile(fp);
}
",C,"    // Make sure that the file is opened without any permission
    // to other users on the system.
    const mode_t kOwnerOnly = S_IRUSR | S_IWUSR;

    // First, try to create the file.
    int fd = HANDLE_EINTR(
        open(path.value().c_str(), O_RDWR | O_CREAT | O_EXCL, kOwnerOnly));
    if (fd == -1 && options.open_existing) {
      // If this doesn't work, try and open an existing file in append mode.
      // Opening an existing file in a world writable directory has two main
      // security implications:
      // - Attackers could plant a file under their control, so ownership of
      //   the file is checked below.
      // - Attackers could plant a symbolic link so that an unexpected file
      //   is opened, so O_NOFOLLOW is passed to open().
      fd = HANDLE_EINTR(
          open(path.value().c_str(), O_RDWR | O_APPEND | O_NOFOLLOW));

      // Check that the current user owns the file.
      // If uid != euid, then a more complex permission model is used and this
      // API is not appropriate.
      const uid_t real_uid = getuid();
      const uid_t effective_uid = geteuid();
      struct stat sb;
      if (fd >= 0 &&
          (fstat(fd, &sb) != 0 || sb.st_uid != real_uid ||
           sb.st_uid != effective_uid)) {
        LOG(ERROR) <<
            ""Invalid owner when opening existing shared memory file."";
        HANDLE_EINTR(close(fd));
        return false;
      }

      // An existing file was opened, so its size should not be fixed.
    fp = NULL;
    if (fd >= 0) {
      // ""a+"" is always appropriate: if it's a new file, a+ is similar to w+.
      fp = fdopen(fd, ""a+"");
    }
","    fp = file_util::OpenFile(path, ""w+x"");
    if (fp == NULL && options.open_existing) {
      fp = file_util::OpenFile(path, ""a+"");
",,"@@ -8,6 +8,7 @@
 #include <fcntl.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 #include <unistd.h>
 
 #include ""base/file_util.h""
@@ -149,12 +150,47 @@ bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
     if (!FilePathForMemoryName(*options.name, &path))
       return false;
 
-    fp = file_util::OpenFile(path, ""w+x"");
-    if (fp == NULL && options.open_existing) {
-      // ""w+"" will truncate if it already exists.
-      fp = file_util::OpenFile(path, ""a+"");
+    // Make sure that the file is opened without any permission
+    // to other users on the system.
+    const mode_t kOwnerOnly = S_IRUSR | S_IWUSR;
+
+    // First, try to create the file.
+    int fd = HANDLE_EINTR(
+        open(path.value().c_str(), O_RDWR | O_CREAT | O_EXCL, kOwnerOnly));
+    if (fd == -1 && options.open_existing) {
+      // If this doesn't work, try and open an existing file in append mode.
+      // Opening an existing file in a world writable directory has two main
+      // security implications:
+      // - Attackers could plant a file under their control, so ownership of
+      //   the file is checked below.
+      // - Attackers could plant a symbolic link so that an unexpected file
+      //   is opened, so O_NOFOLLOW is passed to open().
+      fd = HANDLE_EINTR(
+          open(path.value().c_str(), O_RDWR | O_APPEND | O_NOFOLLOW));
+
+      // Check that the current user owns the file.
+      // If uid != euid, then a more complex permission model is used and this
+      // API is not appropriate.
+      const uid_t real_uid = getuid();
+      const uid_t effective_uid = geteuid();
+      struct stat sb;
+      if (fd >= 0 &&
+          (fstat(fd, &sb) != 0 || sb.st_uid != real_uid ||
+           sb.st_uid != effective_uid)) {
+        LOG(ERROR) <<
+            ""Invalid owner when opening existing shared memory file."";
+        HANDLE_EINTR(close(fd));
+        return false;
+      }
+
+      // An existing file was opened, so its size should not be fixed.
       fix_size = false;
     }
+    fp = NULL;
+    if (fd >= 0) {
+      // ""a+"" is always appropriate: if it's a new file, a+ is similar to w+.
+      fp = fdopen(fd, ""a+"");
+    }
   }
   if (fp && fix_size) {
     // Get current size.",Chrome,afb848acb43ba316097ab4fddfa38dbd80bc6a71,aea03bd0389780cae5f50d6317cbe0d6b0d0735d,1,"bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
  DCHECK_EQ(-1, mapped_file_);
  if (options.size == 0) return false;

  if (options.size > static_cast<size_t>(std::numeric_limits<int>::max()))
    return false;

  // This function theoretically can block on the disk, but realistically
  // the temporary files we create will just go into the buffer cache
  // and be deleted before they ever make it out to disk.
  base::ThreadRestrictions::ScopedAllowIO allow_io;

  FILE *fp;
  bool fix_size = true;

  FilePath path;
  if (options.name == NULL || options.name->empty()) {
    // It doesn't make sense to have a open-existing private piece of shmem
    DCHECK(!options.open_existing);
    // Q: Why not use the shm_open() etc. APIs?
    // A: Because they're limited to 4mb on OS X.  FFFFFFFUUUUUUUUUUU
    fp = file_util::CreateAndOpenTemporaryShmemFile(&path, options.executable);

    // Deleting the file prevents anyone else from mapping it in (making it
    // private), and prevents the need for cleanup (once the last fd is closed,
    // it is truly freed).
    if (fp) {
      if (unlink(path.value().c_str()))
        PLOG(WARNING) << ""unlink"";
    }
  } else {
     if (!FilePathForMemoryName(*options.name, &path))
       return false;
 
//flaw_line_below:
    fp = file_util::OpenFile(path, ""w+x"");
//flaw_line_below:
    if (fp == NULL && options.open_existing) {
//flaw_line_below:
      // ""w+"" will truncate if it already exists.
//flaw_line_below:
      fp = file_util::OpenFile(path, ""a+"");
//fix_flaw_line_below:
//    // Make sure that the file is opened without any permission
//fix_flaw_line_below:
//    // to other users on the system.
//fix_flaw_line_below:
//    const mode_t kOwnerOnly = S_IRUSR | S_IWUSR;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    // First, try to create the file.
//fix_flaw_line_below:
//    int fd = HANDLE_EINTR(
//fix_flaw_line_below:
//        open(path.value().c_str(), O_RDWR | O_CREAT | O_EXCL, kOwnerOnly));
//fix_flaw_line_below:
//    if (fd == -1 && options.open_existing) {
//fix_flaw_line_below:
//      // If this doesn't work, try and open an existing file in append mode.
//fix_flaw_line_below:
//      // Opening an existing file in a world writable directory has two main
//fix_flaw_line_below:
//      // security implications:
//fix_flaw_line_below:
//      // - Attackers could plant a file under their control, so ownership of
//fix_flaw_line_below:
//      //   the file is checked below.
//fix_flaw_line_below:
//      // - Attackers could plant a symbolic link so that an unexpected file
//fix_flaw_line_below:
//      //   is opened, so O_NOFOLLOW is passed to open().
//fix_flaw_line_below:
//      fd = HANDLE_EINTR(
//fix_flaw_line_below:
//          open(path.value().c_str(), O_RDWR | O_APPEND | O_NOFOLLOW));
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//      // Check that the current user owns the file.
//fix_flaw_line_below:
//      // If uid != euid, then a more complex permission model is used and this
//fix_flaw_line_below:
//      // API is not appropriate.
//fix_flaw_line_below:
//      const uid_t real_uid = getuid();
//fix_flaw_line_below:
//      const uid_t effective_uid = geteuid();
//fix_flaw_line_below:
//      struct stat sb;
//fix_flaw_line_below:
//      if (fd >= 0 &&
//fix_flaw_line_below:
//          (fstat(fd, &sb) != 0 || sb.st_uid != real_uid ||
//fix_flaw_line_below:
//           sb.st_uid != effective_uid)) {
//fix_flaw_line_below:
//        LOG(ERROR) <<
//fix_flaw_line_below:
//            ""Invalid owner when opening existing shared memory file."";
//fix_flaw_line_below:
//        HANDLE_EINTR(close(fd));
//fix_flaw_line_below:
//        return false;
//fix_flaw_line_below:
//      }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//      // An existing file was opened, so its size should not be fixed.
       fix_size = false;
     }
//fix_flaw_line_below:
//    fp = NULL;
//fix_flaw_line_below:
//    if (fd >= 0) {
//fix_flaw_line_below:
//      // ""a+"" is always appropriate: if it's a new file, a+ is similar to w+.
//fix_flaw_line_below:
//      fp = fdopen(fd, ""a+"");
//fix_flaw_line_below:
//    }
   }
   if (fp && fix_size) {
     // Get current size.
    struct stat stat;
    if (fstat(fileno(fp), &stat) != 0) {
      file_util::CloseFile(fp);
      return false;
    }
    const size_t current_size = stat.st_size;
    if (current_size != options.size) {
      if (HANDLE_EINTR(ftruncate(fileno(fp), options.size)) != 0) {
        file_util::CloseFile(fp);
        return false;
      }
    }
    requested_size_ = options.size;
  }
  if (fp == NULL) {
#if !defined(OS_MACOSX)
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
    FilePath dir = path.DirName();
    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {
      PLOG(ERROR) << ""Unable to access(W_OK|X_OK) "" << dir.value();
      if (dir.value() == ""/dev/shm"") {
        LOG(FATAL) << ""This is frequently caused by incorrect permissions on ""
                   << ""/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix."";
      }
    }
#else
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
#endif
    return false;
  }

  return PrepareMapFile(fp);
}
",184889,"bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
  DCHECK_EQ(-1, mapped_file_);
  if (options.size == 0) return false;

  if (options.size > static_cast<size_t>(std::numeric_limits<int>::max()))
    return false;

  base::ThreadRestrictions::ScopedAllowIO allow_io;

  FILE *fp;
  bool fix_size = true;

  FilePath path;
  if (options.name == NULL || options.name->empty()) {
    DCHECK(!options.open_existing);
    fp = file_util::CreateAndOpenTemporaryShmemFile(&path, options.executable);

    if (fp) {
      if (unlink(path.value().c_str()))
        PLOG(WARNING) << ""unlink"";
    }
  } else {
     if (!FilePathForMemoryName(*options.name, &path))
       return false;
 
    fp = file_util::OpenFile(path, ""w+x"");
    if (fp == NULL && options.open_existing) {
      fp = file_util::OpenFile(path, ""a+"");
       fix_size = false;
     }
   }
   if (fp && fix_size) {
    struct stat stat;
    if (fstat(fileno(fp), &stat) != 0) {
      file_util::CloseFile(fp);
      return false;
    }
    const size_t current_size = stat.st_size;
    if (current_size != options.size) {
      if (HANDLE_EINTR(ftruncate(fileno(fp), options.size)) != 0) {
        file_util::CloseFile(fp);
        return false;
      }
    }
    requested_size_ = options.size;
  }
  if (fp == NULL) {
#if !defined(OS_MACOSX)
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
    FilePath dir = path.DirName();
    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {
      PLOG(ERROR) << ""Unable to access(W_OK|X_OK) "" << dir.value();
      if (dir.value() == ""/dev/shm"") {
        LOG(FATAL) << ""This is frequently caused by incorrect permissions on ""
                   << ""/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix."";
      }
    }
#else
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
#endif
    return false;
  }

  return PrepareMapFile(fp);
}
","bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
  DCHECK_EQ(-1, mapped_file_);
  if (options.size == 0) return false;

  if (options.size > static_cast<size_t>(std::numeric_limits<int>::max()))
    return false;

  base::ThreadRestrictions::ScopedAllowIO allow_io;

  FILE *fp;
  bool fix_size = true;

  FilePath path;
  if (options.name == NULL || options.name->empty()) {
    DCHECK(!options.open_existing);
    fp = file_util::CreateAndOpenTemporaryShmemFile(&path, options.executable);

    if (fp) {
      if (unlink(path.value().c_str()))
        PLOG(WARNING) << ""unlink"";
    }
  } else {
     if (!FilePathForMemoryName(*options.name, &path))
       return false;
 
    // Make sure that the file is opened without any permission
    // to other users on the system.
    const mode_t kOwnerOnly = S_IRUSR | S_IWUSR;

    // First, try to create the file.
    int fd = HANDLE_EINTR(
        open(path.value().c_str(), O_RDWR | O_CREAT | O_EXCL, kOwnerOnly));
    if (fd == -1 && options.open_existing) {
      // If this doesn't work, try and open an existing file in append mode.
      // Opening an existing file in a world writable directory has two main
      // security implications:
      // - Attackers could plant a file under their control, so ownership of
      //   the file is checked below.
      // - Attackers could plant a symbolic link so that an unexpected file
      //   is opened, so O_NOFOLLOW is passed to open().
      fd = HANDLE_EINTR(
          open(path.value().c_str(), O_RDWR | O_APPEND | O_NOFOLLOW));

      // Check that the current user owns the file.
      // If uid != euid, then a more complex permission model is used and this
      // API is not appropriate.
      const uid_t real_uid = getuid();
      const uid_t effective_uid = geteuid();
      struct stat sb;
      if (fd >= 0 &&
          (fstat(fd, &sb) != 0 || sb.st_uid != real_uid ||
           sb.st_uid != effective_uid)) {
        LOG(ERROR) <<
            ""Invalid owner when opening existing shared memory file."";
        HANDLE_EINTR(close(fd));
        return false;
      }

      // An existing file was opened, so its size should not be fixed.
       fix_size = false;
     }
    fp = NULL;
    if (fd >= 0) {
      // ""a+"" is always appropriate: if it's a new file, a+ is similar to w+.
      fp = fdopen(fd, ""a+"");
    }
   }
   if (fp && fix_size) {
    struct stat stat;
    if (fstat(fileno(fp), &stat) != 0) {
      file_util::CloseFile(fp);
      return false;
    }
    const size_t current_size = stat.st_size;
    if (current_size != options.size) {
      if (HANDLE_EINTR(ftruncate(fileno(fp), options.size)) != 0) {
        file_util::CloseFile(fp);
        return false;
      }
    }
    requested_size_ = options.size;
  }
  if (fp == NULL) {
#if !defined(OS_MACOSX)
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
    FilePath dir = path.DirName();
    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {
      PLOG(ERROR) << ""Unable to access(W_OK|X_OK) "" << dir.value();
      if (dir.value() == ""/dev/shm"") {
        LOG(FATAL) << ""This is frequently caused by incorrect permissions on ""
                   << ""/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix."";
      }
    }
#else
    PLOG(ERROR) << ""Creating shared memory in "" << path.value() << "" failed"";
#endif
    return false;
  }

  return PrepareMapFile(fp);
}
","The `SharedMemory::Create` function is responsible for creating a shared memory segment based on specified options. It first checks if the requested size is valid and initializes a temporary file if no name is provided. If a name is given, it attempts to open the corresponding file, either for writing or appending, depending on whether the existing file should be opened. The function then checks the file size and adjusts it to match the requested size if necessary. If file creation or size adjustment fails, it logs an error and returns false; otherwise, it prepares the file for mapping and returns true, indicating successful creation.","The code defines a function that creates a shared memory segment based on specified options. It first validates the requested size and initializes a temporary file if no name is provided. If a name is given, it attempts to open the corresponding file for writing or appending, depending on whether it should open an existing file. The function checks the file size and adjusts it to match the requested size if needed. If any file operations fail, it logs an error and returns false; otherwise, it prepares the file for mapping and returns true, indicating successful creation.","The vulnerability in the original code stemmed from the potential for creating shared memory files with broad permissions, allowing unauthorized users to access or manipulate these files. This was particularly risky when opening existing files in writable directories, as attackers could exploit this by creating malicious files or symbolic links. The fixed code addresses this issue by enforcing strict permissions when creating new files, using a mode that restricts access to the file owner only. Additionally, it checks the ownership of existing files to ensure that only the legitimate user can access them, thereby enhancing security.","The vulnerability in the original code allowed shared memory files to be created with overly permissive access rights, potentially enabling unauthorized users to read or modify these files. This posed a significant security risk, especially in shared environments where malicious actors could exploit the permissions to gain control over sensitive data. The fixed code mitigates this risk by implementing strict permission settings that limit access to the file owner only. Additionally, it includes checks to verify the ownership of existing files, ensuring that only the legitimate user can interact with them, thereby enhancing overall security.","The vulnerability was fixed by introducing strict permission settings when creating shared memory files. In the updated code, a specific mode was defined, allowing only the owner to read and write the file, which is set using `kOwnerOnly`. When attempting to create a new file, the code uses `open` with the `O_CREAT` and `O_EXCL` flags, ensuring that the file is created with the correct permissions. Additionally, when opening existing files, the code checks the ownership by comparing user IDs, ensuring that only the legitimate user can access the file, thus preventing unauthorized access.","The vulnerability was fixed by implementing strict permission controls when creating shared memory files, ensuring that only the file owner has read and write access. The updated code establishes a specific mode that restricts permissions, preventing unauthorized users from accessing or manipulating the files. Additionally, when opening existing files, the code now verifies the ownership by checking user identifiers, ensuring that only the legitimate user can interact with the file. These changes significantly enhance security by mitigating the risk of unauthorized access and potential exploitation in shared environments.","CWE-732, CWE-276, CWE-266, CWE-264, CWE-668, CWE-281, CWE-284, CWE-269, CWE-732, CWE-669",N,-1
64,64,184959,184959,,Remote,Not required,,CVE-2013-2874,https://www.cvedetails.com/cve/CVE-2013-2874/,CWE-264,Medium,Partial,,,2013-07-10,4.3,"Google Chrome before 28.0.1500.71 on Windows, when an Nvidia GPU is used, allows remote attackers to bypass intended restrictions on access to screen data via vectors involving IPC transmission of GL textures.",2017-09-18,Bypass ,1,https://github.com/chromium/chromium/commit/c0da7c1c6e9ffe5006e146b6426f987238d4bf2e,c0da7c1c6e9ffe5006e146b6426f987238d4bf2e,"DevTools: handle devtools renderer unresponsiveness during beforeunload event interception

This patch fixes the crash which happenes under the following conditions:
1. DevTools window is in undocked state
2. DevTools renderer is unresponsive
3. User attempts to close inspected page

BUG=322380

Review URL: https://codereview.chromium.org/84883002

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@237611 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/devtools/devtools_window.cc,"{""sha"": ""41b7b2f30b4a4a051e13365cd4255fbbb0d1b0b3"", ""filename"": ""chrome/browser/devtools/devtools_sanity_browsertest.cc"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 0, ""changes"": 23, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0da7c1c6e9ffe5006e146b6426f987238d4bf2e/chrome/browser/devtools/devtools_sanity_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0da7c1c6e9ffe5006e146b6426f987238d4bf2e/chrome/browser/devtools/devtools_sanity_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/devtools/devtools_sanity_browsertest.cc?ref=c0da7c1c6e9ffe5006e146b6426f987238d4bf2e"", ""patch"": ""@@ -587,6 +587,29 @@ IN_PROC_BROWSER_TEST_F(DevToolsBeforeUnloadTest,\n       &chrome::CloseAllBrowsers));\n }\n \n+// Tests that inspected tab gets closed if devtools renderer\n+// becomes unresponsive during beforeunload event interception.\n+// @see http://crbug.com/322380\n+IN_PROC_BROWSER_TEST_F(DevToolsBeforeUnloadTest,\n+                       TestUndockedDevToolsUnresponsive) {\n+  ASSERT_TRUE(test_server()->Start());\n+  LoadTestPage(kDebuggerTestPage);\n+  DevToolsWindow* devtools_window = OpenDevToolWindowOnWebContents(\n+      GetInspectedTab());\n+  devtools_window->SetDockSideForTest(DEVTOOLS_DOCK_SIDE_UNDOCKED);\n+  content::WindowedNotificationObserver devtools_close_observer(\n+      content::NOTIFICATION_WEB_CONTENTS_DESTROYED,\n+      content::Source<content::WebContents>(\n+          devtools_window->web_contents()));\n+\n+  ASSERT_TRUE(content::ExecuteScript(\n+      devtools_window->web_contents()->GetRenderViewHost(),\n+      \""window.addEventListener('beforeunload',\""\n+      \""function(event) { while (true); });\""));\n+  CloseInspectedTab();\n+  devtools_close_observer.Wait();\n+}\n+\n // Flaky, see crbug.com/323847.\n //\n // Tests that BeforeUnload event gets called on devtools that are opened""}<_**next**_>{""sha"": ""7ed6e01669c949516d82e6aaab0dd7b5229d5303"", ""filename"": ""chrome/browser/devtools/devtools_window.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0da7c1c6e9ffe5006e146b6426f987238d4bf2e/chrome/browser/devtools/devtools_window.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0da7c1c6e9ffe5006e146b6426f987238d4bf2e/chrome/browser/devtools/devtools_window.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/devtools/devtools_window.cc?ref=c0da7c1c6e9ffe5006e146b6426f987238d4bf2e"", ""patch"": ""@@ -482,6 +482,7 @@ int DevToolsWindow::GetMinimizedHeight() {\n }\n \n void DevToolsWindow::InspectedContentsClosing() {\n+  intercepted_page_beforeunload_ = false;\n   web_contents_->GetRenderViewHost()->ClosePage();\n }\n ""}"," void DevToolsWindow::InspectedContentsClosing() {
  intercepted_page_beforeunload_ = false;
   web_contents_->GetRenderViewHost()->ClosePage();
 }
"," void DevToolsWindow::InspectedContentsClosing() {
   web_contents_->GetRenderViewHost()->ClosePage();
 }
",C,"  intercepted_page_beforeunload_ = false;
",,,"@@ -482,6 +482,7 @@ int DevToolsWindow::GetMinimizedHeight() {
 }
 
 void DevToolsWindow::InspectedContentsClosing() {
+  intercepted_page_beforeunload_ = false;
   web_contents_->GetRenderViewHost()->ClosePage();
 }
 ",Chrome,c0da7c1c6e9ffe5006e146b6426f987238d4bf2e,d4eca59b36fc7957334f425de843022176b7dcfd,1," void DevToolsWindow::InspectedContentsClosing() {
//fix_flaw_line_below:
//  intercepted_page_beforeunload_ = false;
   web_contents_->GetRenderViewHost()->ClosePage();
 }
",184959," void DevToolsWindow::InspectedContentsClosing() {
   web_contents_->GetRenderViewHost()->ClosePage();
 }
"," void DevToolsWindow::InspectedContentsClosing() {
  intercepted_page_beforeunload_ = false;
   web_contents_->GetRenderViewHost()->ClosePage();
 }
","The provided code defines a method named `InspectedContentsClosing` within the `DevToolsWindow` class. This method is responsible for closing the currently inspected web page in a developer tools context. It achieves this by accessing the `web_contents_` member, which represents the content of the web page being inspected. The method then calls `GetRenderViewHost()` on `web_contents_` to obtain the associated render view host, and subsequently invokes the `ClosePage()` function on it. This effectively terminates the rendering of the inspected page, allowing for a clean closure of the developer tools interface.","The code defines a method that handles the closure of a web page currently being inspected within a developer tools interface. When invoked, this method initiates the process to terminate the rendering of the inspected content. It accesses the necessary components associated with the web page and issues a command to close the page. This functionality is essential for managing the lifecycle of web pages in a development environment, ensuring that resources are released and the interface remains responsive when a user decides to stop inspecting a particular page.","The vulnerability in the original code arises from the potential for a crash when the developer tools renderer becomes unresponsive during the interception of the `beforeunload` event while the DevTools window is undocked. If a user attempts to close the inspected page under these conditions, the lack of proper state management could lead to undefined behavior. The fix addresses this issue by introducing a line that sets `intercepted_page_beforeunload_` to `false` before closing the page. This ensures that the state is reset, preventing the crash and allowing for a more graceful handling of the closure process.","The vulnerability in the original code stems from a potential crash that occurs when the developer tools renderer becomes unresponsive while intercepting a page closure event, particularly when the tools window is undocked. If a user attempts to close the inspected page during this unresponsive state, the system may not handle the situation correctly, leading to undefined behavior. The fix addresses this issue by resetting the state related to the interception before proceeding with the page closure. This adjustment ensures that the system can manage the closure process more effectively, preventing crashes and improving overall stability.","The vulnerability was fixed by adding a line to set `intercepted_page_beforeunload_` to `false` before invoking the `ClosePage()` function. This change ensures that the state related to the interception of the `beforeunload` event is reset, which prevents the system from attempting to handle an unresponsive renderer inappropriately. By clearing this state, the code can safely proceed with closing the inspected page without risking a crash, even if the developer tools window is undocked and the renderer is unresponsive. This adjustment enhances the robustness of the page closure process in the developer tools environment.","The vulnerability was addressed by introducing a mechanism to reset the state associated with the interception of the page closure event before proceeding with the closure itself. This adjustment ensures that any lingering conditions related to an unresponsive renderer are cleared, allowing the system to handle the closure process more gracefully. By managing the state effectively, the code prevents potential crashes that could occur when the developer tools are undocked and the renderer is unresponsive. This fix enhances the stability and reliability of the developer tools during page closure operations.","CWE-404, CWE-672, CWE-666, CWE-665, CWE-459, CWE-456, CWE-908, CWE-911, CWE-1245, CWE-674",N,-1
65,65,184960,184960,,Remote,Not required,,CVE-2013-2876,https://www.cvedetails.com/cve/CVE-2013-2876/,CWE-264,Low,Partial,,,2013-07-10,5.0,"browser/extensions/api/tabs/tabs_api.cc in Google Chrome before 28.0.1500.71 does not properly enforce restrictions on the capture of screenshots by extensions, which allows remote attackers to obtain sensitive information about the content of a previous page via vectors involving an interstitial page.",2017-09-18,+Info ,15,https://github.com/chromium/chromium/commit/016da29386308754274675e65fdb73cf9d59dc2d,016da29386308754274675e65fdb73cf9d59dc2d,"Don't allow extensions to take screenshots of interstitial pages. Branched from
https://codereview.chromium.org/14885004/ which is trying to test it.

BUG=229504

Review URL: https://chromiumcodereview.appspot.com/14954004

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@198297 0039d316-1c4b-4281-b951-d872f2087c98",4,chrome/browser/extensions/api/tabs/tabs_api.cc,"{""sha"": ""445857fa0029392571ed26bee157c0b441e2cbf9"", ""filename"": ""chrome/browser/extensions/api/tabs/tabs_api.cc"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/016da29386308754274675e65fdb73cf9d59dc2d/chrome/browser/extensions/api/tabs/tabs_api.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/016da29386308754274675e65fdb73cf9d59dc2d/chrome/browser/extensions/api/tabs/tabs_api.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/api/tabs/tabs_api.cc?ref=016da29386308754274675e65fdb73cf9d59dc2d"", ""patch"": ""@@ -1728,13 +1728,21 @@ bool TabsCaptureVisibleTabFunction::RunImpl() {\n     }\n   }\n \n-  // captureVisibleTab() can return an image containing sensitive information\n-  // that the browser would otherwise protect.  Ensure the extension has\n-  // permission to do this.\n-  if (!GetExtension()->CanCaptureVisiblePage(\n-        web_contents->GetURL(),\n-        SessionID::IdForTab(web_contents),\n-        &error_)) {\n+  // Use the last committed URL rather than the active URL for permissions\n+  // checking, since the visible page won't be updated until it has been\n+  // committed. A canonical example of this is interstitials, which show the\n+  // URL of the new/loading page (active) but would capture the content of the\n+  // old page (last committed).\n+  //\n+  // TODO(creis): Use WebContents::GetLastCommittedURL instead.\n+  // http://crbug.com/237908.\n+  NavigationEntry* last_committed_entry =\n+      web_contents->GetController().GetLastCommittedEntry();\n+  GURL last_committed_url = last_committed_entry ?\n+      last_committed_entry->GetURL() : GURL();\n+  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,\n+                                             SessionID::IdForTab(web_contents),\n+                                             &error_)) {\n     return false;\n   }\n ""}","bool TabsCaptureVisibleTabFunction::RunImpl() {
  PrefService* service = profile()->GetPrefs();
  if (service->GetBoolean(prefs::kDisableScreenshots)) {
    error_ = keys::kScreenshotsDisabled;
    return false;
  }

  WebContents* web_contents = NULL;
  if (!GetTabToCapture(&web_contents))
    return false;

  image_format_ = FORMAT_JPEG;  // Default format is JPEG.
  image_quality_ = kDefaultQuality;  // Default quality setting.

  if (HasOptionalArgument(1)) {
    DictionaryValue* options = NULL;
    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));

    if (options->HasKey(keys::kFormatKey)) {
      std::string format;
      EXTENSION_FUNCTION_VALIDATE(
          options->GetString(keys::kFormatKey, &format));

      if (format == keys::kFormatValueJpeg) {
        image_format_ = FORMAT_JPEG;
      } else if (format == keys::kFormatValuePng) {
        image_format_ = FORMAT_PNG;
      } else {
        EXTENSION_FUNCTION_VALIDATE(0);
      }
    }

    if (options->HasKey(keys::kQualityKey)) {
      EXTENSION_FUNCTION_VALIDATE(
          options->GetInteger(keys::kQualityKey, &image_quality_));
     }
   }
 
  // Use the last committed URL rather than the active URL for permissions
  // checking, since the visible page won't be updated until it has been
  // committed. A canonical example of this is interstitials, which show the
  // URL of the new/loading page (active) but would capture the content of the
  // old page (last committed).
  //
  // TODO(creis): Use WebContents::GetLastCommittedURL instead.
  // http://crbug.com/237908.
  NavigationEntry* last_committed_entry =
      web_contents->GetController().GetLastCommittedEntry();
  GURL last_committed_url = last_committed_entry ?
      last_committed_entry->GetURL() : GURL();
  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,
                                             SessionID::IdForTab(web_contents),
                                             &error_)) {
     return false;
   }
 
  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
  content::RenderWidgetHostView* view = render_view_host->GetView();
  if (!view) {
    error_ = keys::kInternalVisibleTabCaptureError;
    return false;
  }
  render_view_host->CopyFromBackingStore(
      gfx::Rect(),
      view->GetViewBounds().size(),
      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,
                 this));
  return true;
}
","bool TabsCaptureVisibleTabFunction::RunImpl() {
  PrefService* service = profile()->GetPrefs();
  if (service->GetBoolean(prefs::kDisableScreenshots)) {
    error_ = keys::kScreenshotsDisabled;
    return false;
  }

  WebContents* web_contents = NULL;
  if (!GetTabToCapture(&web_contents))
    return false;

  image_format_ = FORMAT_JPEG;  // Default format is JPEG.
  image_quality_ = kDefaultQuality;  // Default quality setting.

  if (HasOptionalArgument(1)) {
    DictionaryValue* options = NULL;
    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));

    if (options->HasKey(keys::kFormatKey)) {
      std::string format;
      EXTENSION_FUNCTION_VALIDATE(
          options->GetString(keys::kFormatKey, &format));

      if (format == keys::kFormatValueJpeg) {
        image_format_ = FORMAT_JPEG;
      } else if (format == keys::kFormatValuePng) {
        image_format_ = FORMAT_PNG;
      } else {
        EXTENSION_FUNCTION_VALIDATE(0);
      }
    }

    if (options->HasKey(keys::kQualityKey)) {
      EXTENSION_FUNCTION_VALIDATE(
          options->GetInteger(keys::kQualityKey, &image_quality_));
     }
   }
 
  if (!GetExtension()->CanCaptureVisiblePage(
        web_contents->GetURL(),
        SessionID::IdForTab(web_contents),
        &error_)) {
     return false;
   }
 
  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
  content::RenderWidgetHostView* view = render_view_host->GetView();
  if (!view) {
    error_ = keys::kInternalVisibleTabCaptureError;
    return false;
  }
  render_view_host->CopyFromBackingStore(
      gfx::Rect(),
      view->GetViewBounds().size(),
      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,
                 this));
  return true;
}
",C,"  // Use the last committed URL rather than the active URL for permissions
  // checking, since the visible page won't be updated until it has been
  // committed. A canonical example of this is interstitials, which show the
  // URL of the new/loading page (active) but would capture the content of the
  // old page (last committed).
  //
  // TODO(creis): Use WebContents::GetLastCommittedURL instead.
  // http://crbug.com/237908.
  NavigationEntry* last_committed_entry =
      web_contents->GetController().GetLastCommittedEntry();
  GURL last_committed_url = last_committed_entry ?
      last_committed_entry->GetURL() : GURL();
  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,
                                             SessionID::IdForTab(web_contents),
                                             &error_)) {
","  if (!GetExtension()->CanCaptureVisiblePage(
        web_contents->GetURL(),
        SessionID::IdForTab(web_contents),
        &error_)) {
",,"@@ -1728,13 +1728,21 @@ bool TabsCaptureVisibleTabFunction::RunImpl() {
     }
   }
 
-  // captureVisibleTab() can return an image containing sensitive information
-  // that the browser would otherwise protect.  Ensure the extension has
-  // permission to do this.
-  if (!GetExtension()->CanCaptureVisiblePage(
-        web_contents->GetURL(),
-        SessionID::IdForTab(web_contents),
-        &error_)) {
+  // Use the last committed URL rather than the active URL for permissions
+  // checking, since the visible page won't be updated until it has been
+  // committed. A canonical example of this is interstitials, which show the
+  // URL of the new/loading page (active) but would capture the content of the
+  // old page (last committed).
+  //
+  // TODO(creis): Use WebContents::GetLastCommittedURL instead.
+  // http://crbug.com/237908.
+  NavigationEntry* last_committed_entry =
+      web_contents->GetController().GetLastCommittedEntry();
+  GURL last_committed_url = last_committed_entry ?
+      last_committed_entry->GetURL() : GURL();
+  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,
+                                             SessionID::IdForTab(web_contents),
+                                             &error_)) {
     return false;
   }
 ",Chrome,016da29386308754274675e65fdb73cf9d59dc2d,7b97cf95eb604105998ab67571c30725fe015ba8,1,"bool TabsCaptureVisibleTabFunction::RunImpl() {
  PrefService* service = profile()->GetPrefs();
  if (service->GetBoolean(prefs::kDisableScreenshots)) {
    error_ = keys::kScreenshotsDisabled;
    return false;
  }

  WebContents* web_contents = NULL;
  if (!GetTabToCapture(&web_contents))
    return false;

  image_format_ = FORMAT_JPEG;  // Default format is JPEG.
  image_quality_ = kDefaultQuality;  // Default quality setting.

  if (HasOptionalArgument(1)) {
    DictionaryValue* options = NULL;
    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));

    if (options->HasKey(keys::kFormatKey)) {
      std::string format;
      EXTENSION_FUNCTION_VALIDATE(
          options->GetString(keys::kFormatKey, &format));

      if (format == keys::kFormatValueJpeg) {
        image_format_ = FORMAT_JPEG;
      } else if (format == keys::kFormatValuePng) {
        image_format_ = FORMAT_PNG;
      } else {
        // Schema validation should make this unreachable.
        EXTENSION_FUNCTION_VALIDATE(0);
      }
    }

    if (options->HasKey(keys::kQualityKey)) {
      EXTENSION_FUNCTION_VALIDATE(
          options->GetInteger(keys::kQualityKey, &image_quality_));
     }
   }
 
//flaw_line_below:
  // captureVisibleTab() can return an image containing sensitive information
//flaw_line_below:
  // that the browser would otherwise protect.  Ensure the extension has
//flaw_line_below:
  // permission to do this.
//flaw_line_below:
  if (!GetExtension()->CanCaptureVisiblePage(
//flaw_line_below:
        web_contents->GetURL(),
//flaw_line_below:
        SessionID::IdForTab(web_contents),
//flaw_line_below:
        &error_)) {
//fix_flaw_line_below:
//  // Use the last committed URL rather than the active URL for permissions
//fix_flaw_line_below:
//  // checking, since the visible page won't be updated until it has been
//fix_flaw_line_below:
//  // committed. A canonical example of this is interstitials, which show the
//fix_flaw_line_below:
//  // URL of the new/loading page (active) but would capture the content of the
//fix_flaw_line_below:
//  // old page (last committed).
//fix_flaw_line_below:
//  //
//fix_flaw_line_below:
//  // TODO(creis): Use WebContents::GetLastCommittedURL instead.
//fix_flaw_line_below:
//  // http://crbug.com/237908.
//fix_flaw_line_below:
//  NavigationEntry* last_committed_entry =
//fix_flaw_line_below:
//      web_contents->GetController().GetLastCommittedEntry();
//fix_flaw_line_below:
//  GURL last_committed_url = last_committed_entry ?
//fix_flaw_line_below:
//      last_committed_entry->GetURL() : GURL();
//fix_flaw_line_below:
//  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,
//fix_flaw_line_below:
//                                             SessionID::IdForTab(web_contents),
//fix_flaw_line_below:
//                                             &error_)) {
     return false;
   }
 
  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
  content::RenderWidgetHostView* view = render_view_host->GetView();
  if (!view) {
    error_ = keys::kInternalVisibleTabCaptureError;
    return false;
  }
  render_view_host->CopyFromBackingStore(
      gfx::Rect(),
      view->GetViewBounds().size(),
      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,
                 this));
  return true;
}
",184960,"bool TabsCaptureVisibleTabFunction::RunImpl() {
  PrefService* service = profile()->GetPrefs();
  if (service->GetBoolean(prefs::kDisableScreenshots)) {
    error_ = keys::kScreenshotsDisabled;
    return false;
  }

  WebContents* web_contents = NULL;
  if (!GetTabToCapture(&web_contents))
    return false;

  image_format_ = FORMAT_JPEG;  // Default format is JPEG.
  image_quality_ = kDefaultQuality;  // Default quality setting.

  if (HasOptionalArgument(1)) {
    DictionaryValue* options = NULL;
    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));

    if (options->HasKey(keys::kFormatKey)) {
      std::string format;
      EXTENSION_FUNCTION_VALIDATE(
          options->GetString(keys::kFormatKey, &format));

      if (format == keys::kFormatValueJpeg) {
        image_format_ = FORMAT_JPEG;
      } else if (format == keys::kFormatValuePng) {
        image_format_ = FORMAT_PNG;
      } else {
        EXTENSION_FUNCTION_VALIDATE(0);
      }
    }

    if (options->HasKey(keys::kQualityKey)) {
      EXTENSION_FUNCTION_VALIDATE(
          options->GetInteger(keys::kQualityKey, &image_quality_));
     }
   }
 
  if (!GetExtension()->CanCaptureVisiblePage(
        web_contents->GetURL(),
        SessionID::IdForTab(web_contents),
        &error_)) {
     return false;
   }
 
  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
  content::RenderWidgetHostView* view = render_view_host->GetView();
  if (!view) {
    error_ = keys::kInternalVisibleTabCaptureError;
    return false;
  }
  render_view_host->CopyFromBackingStore(
      gfx::Rect(),
      view->GetViewBounds().size(),
      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,
                 this));
  return true;
}
","bool TabsCaptureVisibleTabFunction::RunImpl() {
  PrefService* service = profile()->GetPrefs();
  if (service->GetBoolean(prefs::kDisableScreenshots)) {
    error_ = keys::kScreenshotsDisabled;
    return false;
  }

  WebContents* web_contents = NULL;
  if (!GetTabToCapture(&web_contents))
    return false;

  image_format_ = FORMAT_JPEG;  // Default format is JPEG.
  image_quality_ = kDefaultQuality;  // Default quality setting.

  if (HasOptionalArgument(1)) {
    DictionaryValue* options = NULL;
    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));

    if (options->HasKey(keys::kFormatKey)) {
      std::string format;
      EXTENSION_FUNCTION_VALIDATE(
          options->GetString(keys::kFormatKey, &format));

      if (format == keys::kFormatValueJpeg) {
        image_format_ = FORMAT_JPEG;
      } else if (format == keys::kFormatValuePng) {
        image_format_ = FORMAT_PNG;
      } else {
        EXTENSION_FUNCTION_VALIDATE(0);
      }
    }

    if (options->HasKey(keys::kQualityKey)) {
      EXTENSION_FUNCTION_VALIDATE(
          options->GetInteger(keys::kQualityKey, &image_quality_));
     }
   }
 
  // Use the last committed URL rather than the active URL for permissions
  // checking, since the visible page won't be updated until it has been
  // committed. A canonical example of this is interstitials, which show the
  // URL of the new/loading page (active) but would capture the content of the
  // old page (last committed).
  //
  // TODO(creis): Use WebContents::GetLastCommittedURL instead.
  // http://crbug.com/237908.
  NavigationEntry* last_committed_entry =
      web_contents->GetController().GetLastCommittedEntry();
  GURL last_committed_url = last_committed_entry ?
      last_committed_entry->GetURL() : GURL();
  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,
                                             SessionID::IdForTab(web_contents),
                                             &error_)) {
     return false;
   }
 
  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
  content::RenderWidgetHostView* view = render_view_host->GetView();
  if (!view) {
    error_ = keys::kInternalVisibleTabCaptureError;
    return false;
  }
  render_view_host->CopyFromBackingStore(
      gfx::Rect(),
      view->GetViewBounds().size(),
      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,
                 this));
  return true;
}
","The `RunImpl` function in the `TabsCaptureVisibleTabFunction` class captures a screenshot of the currently visible tab in a web browser. It first checks user preferences to ensure that screenshot functionality is not disabled. If allowed, it retrieves the tab to capture and sets default image format to JPEG and quality settings. The function then processes optional arguments to customize the image format (JPEG or PNG) and quality. It verifies if the extension has permission to capture the visible page and, if valid, initiates the screenshot capture by copying the backing store of the tab's render view, ultimately triggering a callback upon completion.","The provided code defines a function that captures a screenshot of the currently visible tab in a web browser. It first checks user settings to ensure that screenshot functionality is enabled. If permitted, it retrieves the active tab and sets default parameters for the image format and quality. The function then processes optional settings to allow customization of the image format and quality. It verifies that the extension has the necessary permissions to capture the visible page, and if all conditions are met, it initiates the screenshot capture process, triggering a callback once the capture is complete.","The vulnerability in the original code allowed extensions to capture screenshots of interstitial pages, which could display outdated or misleading content. This occurred because the code used the active URL for permission checks, potentially allowing a screenshot of a page that was not fully loaded or committed. The fix involved changing the permission check to use the last committed URL instead of the active URL, ensuring that only fully loaded pages could be captured. This adjustment prevents the capture of interstitials, which could misrepresent the current state of the browser, thereby enhancing security and user trust.","The vulnerability in the original code allowed extensions to capture screenshots of interstitial pages, which could lead to the display of outdated or misleading content. This issue arose because the code relied on the active URL for permission checks, potentially allowing the capture of pages that were not fully loaded or committed. The fix involved modifying the permission check to use the last committed URL instead, ensuring that only fully rendered pages could be captured. This change effectively prevents the capture of interstitials, thereby enhancing security and ensuring that users see accurate representations of the content.","The vulnerability was fixed by changing the permission check to utilize the last committed URL instead of the active URL. In the updated code, the last committed entry is retrieved using the `GetLastCommittedEntry` function, and its URL is obtained to perform the permission validation. This ensures that the extension can only capture screenshots of pages that have been fully loaded and committed, thus preventing the capture of interstitial pages that may display outdated content. This adjustment enhances security by ensuring that only valid, user-visible content is eligible for screenshot capture.","The vulnerability was fixed by altering the method used to check permissions for capturing screenshots. Instead of relying on the active URL, which could lead to capturing misleading content from interstitial pages, the updated code now uses the last committed URL. This change ensures that only fully loaded and rendered pages can be captured, thereby preventing the extension from taking screenshots of pages that are not in their final state. This enhancement improves security by ensuring that users only see accurate and relevant content in screenshots, thereby reducing the risk of displaying outdated or incorrect information.","CWE-601, CWE-20, CWE-200, CWE-287, CWE-285, CWE-284, CWE-732, CWE-436, CWE-610, CWE-799",N,-1
66,66,185091,185091,,Remote,Not required,Partial,CVE-2013-0889,https://www.cvedetails.com/cve/CVE-2013-0889/,CWE-264,Medium,Partial,Partial,,2013-02-23,6.8,"Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, does not properly enforce a user gesture requirement before proceeding with a file download, which might make it easier for remote attackers to execute arbitrary code via a crafted file.",2018-10-30,Exec Code ,6,https://github.com/chromium/chromium/commit/1538367452b549d929aabb13d54c85ab99f65cd3,1538367452b549d929aabb13d54c85ab99f65cd3,"For ""Dangerous"" file type, no user gesture will bypass the download warning.

BUG=170569
Review URL: https://codereview.chromium.org/12039015

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@178072 0039d316-1c4b-4281-b951-d872f2087c98",3,chrome/browser/download/chrome_download_manager_delegate.cc,"{""sha"": ""9a56c725c6ea2e3a022ad0ab5fdbbf5990b6e93c"", ""filename"": ""chrome/browser/download/chrome_download_manager_delegate.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 5, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/1538367452b549d929aabb13d54c85ab99f65cd3/chrome/browser/download/chrome_download_manager_delegate.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1538367452b549d929aabb13d54c85ab99f65cd3/chrome/browser/download/chrome_download_manager_delegate.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/download/chrome_download_manager_delegate.cc?ref=1538367452b549d929aabb13d54c85ab99f65cd3"", ""patch"": ""@@ -556,10 +556,6 @@ bool ChromeDownloadManagerDelegate::IsDangerousFile(\n     bool visited_referrer_before) {\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n \n-  // Anything loaded directly from the address bar is OK.\n-  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)\n-    return false;\n-\n   // Extensions that are not from the gallery are considered dangerous.\n   // When off-store install is disabled we skip this, since in this case, we\n   // will not offer to install the extension.\n@@ -578,8 +574,13 @@ bool ChromeDownloadManagerDelegate::IsDangerousFile(\n   // page has been visited before today.\n   download_util::DownloadDangerLevel danger_level =\n       download_util::GetFileDangerLevel(suggested_path.BaseName());\n-  if (danger_level == download_util::AllowOnUserGesture)\n+  if (danger_level == download_util::AllowOnUserGesture) {\n+    if (download.GetTransitionType() &\n+            content::PAGE_TRANSITION_FROM_ADDRESS_BAR) {\n+      return false;\n+    }\n     return !download.HasUserGesture() || !visited_referrer_before;\n+  }\n \n   return danger_level == download_util::Dangerous;\n }""}","bool ChromeDownloadManagerDelegate::IsDangerousFile(
    const DownloadItem& download,
    const FilePath& suggested_path,
     bool visited_referrer_before) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
  if (extensions::FeatureSwitch::easy_off_store_install()->IsEnabled() &&
      download_crx_util::IsExtensionDownload(download) &&
      !extensions::WebstoreInstaller::GetAssociatedApproval(download)) {
    return true;
  }

  if (ShouldOpenFileBasedOnExtension(suggested_path) &&
      download.HasUserGesture())
    return false;

   download_util::DownloadDangerLevel danger_level =
       download_util::GetFileDangerLevel(suggested_path.BaseName());
  if (danger_level == download_util::AllowOnUserGesture) {
    if (download.GetTransitionType() &
            content::PAGE_TRANSITION_FROM_ADDRESS_BAR) {
      return false;
    }
     return !download.HasUserGesture() || !visited_referrer_before;
  }
 
   return danger_level == download_util::Dangerous;
 }
","bool ChromeDownloadManagerDelegate::IsDangerousFile(
    const DownloadItem& download,
    const FilePath& suggested_path,
     bool visited_referrer_before) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)
    return false;
  if (extensions::FeatureSwitch::easy_off_store_install()->IsEnabled() &&
      download_crx_util::IsExtensionDownload(download) &&
      !extensions::WebstoreInstaller::GetAssociatedApproval(download)) {
    return true;
  }

  if (ShouldOpenFileBasedOnExtension(suggested_path) &&
      download.HasUserGesture())
    return false;

   download_util::DownloadDangerLevel danger_level =
       download_util::GetFileDangerLevel(suggested_path.BaseName());
  if (danger_level == download_util::AllowOnUserGesture)
     return !download.HasUserGesture() || !visited_referrer_before;
 
   return danger_level == download_util::Dangerous;
 }
",C,"  if (danger_level == download_util::AllowOnUserGesture) {
    if (download.GetTransitionType() &
            content::PAGE_TRANSITION_FROM_ADDRESS_BAR) {
      return false;
    }
  }
","  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)
    return false;
  if (danger_level == download_util::AllowOnUserGesture)
",,"@@ -556,10 +556,6 @@ bool ChromeDownloadManagerDelegate::IsDangerousFile(
     bool visited_referrer_before) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
-  // Anything loaded directly from the address bar is OK.
-  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)
-    return false;
-
   // Extensions that are not from the gallery are considered dangerous.
   // When off-store install is disabled we skip this, since in this case, we
   // will not offer to install the extension.
@@ -578,8 +574,13 @@ bool ChromeDownloadManagerDelegate::IsDangerousFile(
   // page has been visited before today.
   download_util::DownloadDangerLevel danger_level =
       download_util::GetFileDangerLevel(suggested_path.BaseName());
-  if (danger_level == download_util::AllowOnUserGesture)
+  if (danger_level == download_util::AllowOnUserGesture) {
+    if (download.GetTransitionType() &
+            content::PAGE_TRANSITION_FROM_ADDRESS_BAR) {
+      return false;
+    }
     return !download.HasUserGesture() || !visited_referrer_before;
+  }
 
   return danger_level == download_util::Dangerous;
 }",Chrome,1538367452b549d929aabb13d54c85ab99f65cd3,9b95c83639a96a499e6af8d445f47086fd40a206,1,"bool ChromeDownloadManagerDelegate::IsDangerousFile(
    const DownloadItem& download,
    const FilePath& suggested_path,
     bool visited_referrer_before) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
//flaw_line_below:
  // Anything loaded directly from the address bar is OK.
//flaw_line_below:
  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)
//flaw_line_below:
    return false;
//flaw_line_below:

   // Extensions that are not from the gallery are considered dangerous.
   // When off-store install is disabled we skip this, since in this case, we
   // will not offer to install the extension.
  if (extensions::FeatureSwitch::easy_off_store_install()->IsEnabled() &&
      download_crx_util::IsExtensionDownload(download) &&
      !extensions::WebstoreInstaller::GetAssociatedApproval(download)) {
    return true;
  }

  // Anything the user has marked auto-open is OK if it's user-initiated.
  if (ShouldOpenFileBasedOnExtension(suggested_path) &&
      download.HasUserGesture())
    return false;

  // ""Allow on user gesture"" is OK when we have a user gesture and the hosting
   // page has been visited before today.
   download_util::DownloadDangerLevel danger_level =
       download_util::GetFileDangerLevel(suggested_path.BaseName());
//flaw_line_below:
  if (danger_level == download_util::AllowOnUserGesture)
//fix_flaw_line_below:
//  if (danger_level == download_util::AllowOnUserGesture) {
//fix_flaw_line_below:
//    if (download.GetTransitionType() &
//fix_flaw_line_below:
//            content::PAGE_TRANSITION_FROM_ADDRESS_BAR) {
//fix_flaw_line_below:
//      return false;
//fix_flaw_line_below:
//    }
     return !download.HasUserGesture() || !visited_referrer_before;
//fix_flaw_line_below:
//  }
 
   return danger_level == download_util::Dangerous;
 }
",185091,"bool ChromeDownloadManagerDelegate::IsDangerousFile(
    const DownloadItem& download,
    const FilePath& suggested_path,
     bool visited_referrer_before) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)
    return false;
  if (extensions::FeatureSwitch::easy_off_store_install()->IsEnabled() &&
      download_crx_util::IsExtensionDownload(download) &&
      !extensions::WebstoreInstaller::GetAssociatedApproval(download)) {
    return true;
  }

  if (ShouldOpenFileBasedOnExtension(suggested_path) &&
      download.HasUserGesture())
    return false;

   download_util::DownloadDangerLevel danger_level =
       download_util::GetFileDangerLevel(suggested_path.BaseName());
  if (danger_level == download_util::AllowOnUserGesture)
     return !download.HasUserGesture() || !visited_referrer_before;
 
   return danger_level == download_util::Dangerous;
 }
","bool ChromeDownloadManagerDelegate::IsDangerousFile(
    const DownloadItem& download,
    const FilePath& suggested_path,
     bool visited_referrer_before) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
  if (extensions::FeatureSwitch::easy_off_store_install()->IsEnabled() &&
      download_crx_util::IsExtensionDownload(download) &&
      !extensions::WebstoreInstaller::GetAssociatedApproval(download)) {
    return true;
  }

  if (ShouldOpenFileBasedOnExtension(suggested_path) &&
      download.HasUserGesture())
    return false;

   download_util::DownloadDangerLevel danger_level =
       download_util::GetFileDangerLevel(suggested_path.BaseName());
  if (danger_level == download_util::AllowOnUserGesture) {
    if (download.GetTransitionType() &
            content::PAGE_TRANSITION_FROM_ADDRESS_BAR) {
      return false;
    }
     return !download.HasUserGesture() || !visited_referrer_before;
  }
 
   return danger_level == download_util::Dangerous;
 }
","The `IsDangerousFile` function in the `ChromeDownloadManagerDelegate` class determines whether a downloaded file is considered dangerous based on various criteria. It first checks if the download originated from the address bar, which would exempt it from being flagged. If the download is an extension and lacks user approval, it is marked as dangerous. The function also evaluates the file's extension and user interaction; if the user initiated the download and the file type is deemed safe, it allows the download. Finally, it assesses the file's danger level, returning true for dangerous files and false otherwise, considering user gestures and referrer history.","The function evaluates whether a downloaded file poses a danger based on specific criteria. It first checks if the download originated from a safe source, which would exempt it from being flagged. If the file is an extension without user approval, it is marked as dangerous. The function also considers the file type and whether the user initiated the download; if the user did and the file is safe, it allows the download. Finally, it assesses the file's overall danger level, returning a determination based on user interactions and the context of the download.","The vulnerability in the original code allowed users to bypass download warnings for files deemed ""Dangerous"" if they had previously interacted with the download, as indicated by the `HasUserGesture` check. This could lead to unintentional execution of harmful files. The fix introduced a condition that ensures no user gesture can override the warning for dangerous file types, specifically by modifying the logic in the `AllowOnUserGesture` check. Now, even if a user gesture is present, the function will still flag the download as dangerous, thereby enhancing security and preventing potential exploitation.","The vulnerability in the original code allowed users to bypass download warnings for files classified as ""Dangerous"" if they had previously interacted with the download, potentially leading to the execution of harmful files. This oversight could be exploited by malicious actors to trick users into downloading unsafe content. The fix addressed this issue by ensuring that no user interaction could override the warning for dangerous file types. The updated logic now consistently flags such files as dangerous, regardless of user gestures, thereby enhancing the security measures in place to protect users from unintended risks.","The vulnerability was fixed by modifying the logic within the `AllowOnUserGesture` check to ensure that dangerous file types cannot be bypassed by user gestures. In the updated code, the condition now explicitly states that if the danger level is classified as dangerous, the function will not allow the download to proceed, regardless of whether `HasUserGesture` is true or false. This change prevents any user interaction from overriding the warning for dangerous files, thereby reinforcing the security measures and ensuring that users are adequately protected from potentially harmful downloads.","The vulnerability was fixed by altering the logic that determines whether a download warning can be bypassed based on user interaction. The updated code ensures that for files classified as dangerous, any prior user gestures will no longer allow the download to proceed without a warning. This change effectively removes the ability for user actions to override the security measures in place for dangerous file types, thereby enhancing the overall protection against potentially harmful downloads and ensuring that users are consistently alerted to risks associated with such files.","CWE-1244, CWE-183, CWE-754, CWE-20, CWE-707, CWE-436, CWE-283, CWE-755, CWE-669, CWE-706",N,-1
67,67,185132,185132,,Remote,Not required,Partial,CVE-2013-0918,https://www.cvedetails.com/cve/CVE-2013-0918/,CWE-264,Medium,Partial,Partial,,2013-03-28,6.8,"Google Chrome before 26.0.1410.43 does not prevent navigation to developer tools in response to a drag-and-drop operation, which allows user-assisted remote attackers to have an unspecified impact via a crafted web site.",2017-09-18,,4,https://github.com/chromium/chromium/commit/0a57375ad73780e61e1770a9d88b0529b0dbd33b,0a57375ad73780e61e1770a9d88b0529b0dbd33b,"Let the browser handle external navigations from DevTools.

BUG=180555


Review URL: https://chromiumcodereview.appspot.com/12531004

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@186793 0039d316-1c4b-4281-b951-d872f2087c98",1,content/renderer/render_view_impl.cc,"{""sha"": ""67a61c2652e551b60816bb1a445b332e04edbd90"", ""filename"": ""chrome/browser/devtools/devtools_sanity_browsertest.cc"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 0, ""changes"": 20, ""blob_url"": ""https://github.com/chromium/chromium/blob/0a57375ad73780e61e1770a9d88b0529b0dbd33b/chrome/browser/devtools/devtools_sanity_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0a57375ad73780e61e1770a9d88b0529b0dbd33b/chrome/browser/devtools/devtools_sanity_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/devtools/devtools_sanity_browsertest.cc?ref=0a57375ad73780e61e1770a9d88b0529b0dbd33b"", ""patch"": ""@@ -22,6 +22,7 @@\n #include \""chrome/common/chrome_notification_types.h\""\n #include \""chrome/common/chrome_paths.h\""\n #include \""chrome/common/chrome_switches.h\""\n+#include \""chrome/common/url_constants.h\""\n #include \""chrome/test/base/in_process_browser_test.h\""\n #include \""chrome/test/base/ui_test_utils.h\""\n #include \""content/public/browser/child_process_data.h\""\n@@ -504,6 +505,25 @@ IN_PROC_BROWSER_TEST_F(DevToolsSanityTest, TestConsoleOnNavigateBack) {\n   RunTest(\""testConsoleOnNavigateBack\"", kNavigateBackTestPage);\n }\n \n+\n+// Tests that external navigation from inspector page is always handled by\n+// DevToolsWindow and results in inspected page navigation.\n+IN_PROC_BROWSER_TEST_F(DevToolsSanityTest, TestDevToolsExternalNavigation) {\n+  OpenDevToolsWindow(kDebuggerTestPage);\n+  GURL url = test_server()->GetURL(kNavigateBackTestPage);\n+  content::WindowedNotificationObserver observer(\n+      content::NOTIFICATION_LOAD_STOP,\n+      content::NotificationService::AllSources());\n+  ASSERT_TRUE(content::ExecuteScript(\n+      window_->web_contents(),\n+      std::string(\""window.location = \\\""\"") + url.spec() + \""\\\""\""));\n+  observer.Wait();\n+\n+  ASSERT_TRUE(window_->web_contents()->GetURL().\n+                  SchemeIs(chrome::kChromeDevToolsScheme));\n+  ASSERT_EQ(GetInspectedTab()->GetURL(), url);\n+}\n+\n // Tests that inspector will reattach to inspected page when it is reloaded\n // after a crash. See http://crbug.com/101952\n IN_PROC_BROWSER_TEST_F(DevToolsSanityTest, TestReattachAfterCrash) {""}<_**next**_>{""sha"": ""53e390b6f828d74f69c8c03f10acf0497c5fda41"", ""filename"": ""content/renderer/render_view_impl.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/0a57375ad73780e61e1770a9d88b0529b0dbd33b/content/renderer/render_view_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0a57375ad73780e61e1770a9d88b0529b0dbd33b/content/renderer/render_view_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/render_view_impl.cc?ref=0a57375ad73780e61e1770a9d88b0529b0dbd33b"", ""patch"": ""@@ -3039,9 +3039,9 @@ WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(\n       !url.SchemeIs(chrome::kAboutScheme)) {\n     bool send_referrer = false;\n \n-    // All navigations to WebUI URLs or within WebUI-enabled RenderProcesses\n-    // must be handled by the browser process so that the correct bindings and\n-    // data sources can be registered.\n+    // All navigations to or from WebUI URLs or within WebUI-enabled\n+    // RenderProcesses must be handled by the browser process so that the\n+    // correct bindings and data sources can be registered.\n     // Similarly, navigations to view-source URLs or within ViewSource mode\n     // must be handled by the browser process (except for reloads - those are\n     // safe to leave within the renderer).\n@@ -3050,7 +3050,7 @@ WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(\n     // blessed with file permissions.\n     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();\n     bool is_initial_navigation = page_id_ == -1;\n-    bool should_fork = HasWebUIScheme(url) ||\n+    bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||\n         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||\n         url.SchemeIs(chrome::kViewSourceScheme) ||\n         (frame->isViewSourceModeEnabled() &&""}","WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
    WebFrame* frame, const WebURLRequest& request, WebNavigationType type,
    const WebNode&, WebNavigationPolicy default_policy, bool is_redirect) {
  if (request.url() != GURL(kSwappedOutURL) &&
      GetContentClient()->renderer()->HandleNavigation(frame, request, type,
                                                       default_policy,
                                                       is_redirect)) {
    return WebKit::WebNavigationPolicyIgnore;
  }

  Referrer referrer(
      GURL(request.httpHeaderField(WebString::fromUTF8(""Referer""))),
      GetReferrerPolicyFromRequest(frame, request));

  if (is_swapped_out_) {
    if (request.url() != GURL(kSwappedOutURL)) {
      if (frame->parent() == NULL) {
        OpenURL(frame, request.url(), referrer, default_policy);
        return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
      }

      return WebKit::WebNavigationPolicyIgnore;
    }

    return default_policy;
  }

  const GURL& url = request.url();

  bool is_content_initiated =
      DocumentState::FromDataSource(frame->provisionalDataSource())->
          navigation_state()->is_content_initiated();

  const CommandLine& command_line = *CommandLine::ForCurrentProcess();
  bool force_swap_due_to_flag =
      command_line.HasSwitch(switches::kEnableStrictSiteIsolation) ||
      command_line.HasSwitch(switches::kSitePerProcess);
  if (force_swap_due_to_flag &&
      !frame->parent() && (is_content_initiated || is_redirect)) {
    WebString origin_str = frame->document().securityOrigin().toString();
    GURL frame_url(origin_str.utf8().data());
    if (!net::RegistryControlledDomainService::SameDomainOrHost(frame_url,
                                                                url) ||
        frame_url.scheme() != url.scheme()) {
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;
    }
  }

  if (is_content_initiated) {
    bool browser_handles_request =
        renderer_preferences_.browser_handles_non_local_top_level_requests &&
        IsNonLocalTopLevelNavigation(url, frame, type);
    if (!browser_handles_request) {
      browser_handles_request =
          renderer_preferences_.browser_handles_all_top_level_requests &&
          IsTopLevelNavigation(frame);
    }

    if (browser_handles_request) {
      page_id_ = -1;
      last_page_id_sent_to_browser_ = -1;
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  GURL old_url(frame->dataSource()->request().url());

  if (!frame->parent() && is_content_initiated &&
       !url.SchemeIs(chrome::kAboutScheme)) {
     bool send_referrer = false;
 
    // All navigations to or from WebUI URLs or within WebUI-enabled
    // RenderProcesses must be handled by the browser process so that the
    // correct bindings and data sources can be registered.
     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
     bool is_initial_navigation = page_id_ == -1;
    bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||
         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||
         url.SchemeIs(chrome::kViewSourceScheme) ||
         (frame->isViewSourceModeEnabled() &&
            type != WebKit::WebNavigationTypeReload);

    if (!should_fork && url.SchemeIs(chrome::kFileScheme)) {
      GURL source_url(old_url);
      if (is_initial_navigation && source_url.is_empty() && frame->opener())
        source_url = frame->opener()->top()->document().url();
      DCHECK(!source_url.is_empty());
      should_fork = !source_url.SchemeIs(chrome::kFileScheme);
    }

    if (!should_fork) {
      should_fork = GetContentClient()->renderer()->ShouldFork(
          frame, url, request.httpMethod().utf8(), is_initial_navigation,
          &send_referrer);
    }

    if (should_fork) {
      OpenURL(
          frame, url, send_referrer ? referrer : Referrer(), default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  bool is_fork =
      old_url == GURL(chrome::kAboutBlankURL) &&
      historyBackListCount() < 1 &&
      historyForwardListCount() < 1 &&
      frame->opener() == NULL &&
      frame->parent() == NULL &&
      is_content_initiated &&
      default_policy == WebKit::WebNavigationPolicyCurrentTab &&
      type == WebKit::WebNavigationTypeOther;

  if (is_fork) {
    OpenURL(frame, url, Referrer(), default_policy);
    return WebKit::WebNavigationPolicyIgnore;
  }

  return default_policy;
}
","WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
    WebFrame* frame, const WebURLRequest& request, WebNavigationType type,
    const WebNode&, WebNavigationPolicy default_policy, bool is_redirect) {
  if (request.url() != GURL(kSwappedOutURL) &&
      GetContentClient()->renderer()->HandleNavigation(frame, request, type,
                                                       default_policy,
                                                       is_redirect)) {
    return WebKit::WebNavigationPolicyIgnore;
  }

  Referrer referrer(
      GURL(request.httpHeaderField(WebString::fromUTF8(""Referer""))),
      GetReferrerPolicyFromRequest(frame, request));

  if (is_swapped_out_) {
    if (request.url() != GURL(kSwappedOutURL)) {
      if (frame->parent() == NULL) {
        OpenURL(frame, request.url(), referrer, default_policy);
        return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
      }

      return WebKit::WebNavigationPolicyIgnore;
    }

    return default_policy;
  }

  const GURL& url = request.url();

  bool is_content_initiated =
      DocumentState::FromDataSource(frame->provisionalDataSource())->
          navigation_state()->is_content_initiated();

  const CommandLine& command_line = *CommandLine::ForCurrentProcess();
  bool force_swap_due_to_flag =
      command_line.HasSwitch(switches::kEnableStrictSiteIsolation) ||
      command_line.HasSwitch(switches::kSitePerProcess);
  if (force_swap_due_to_flag &&
      !frame->parent() && (is_content_initiated || is_redirect)) {
    WebString origin_str = frame->document().securityOrigin().toString();
    GURL frame_url(origin_str.utf8().data());
    if (!net::RegistryControlledDomainService::SameDomainOrHost(frame_url,
                                                                url) ||
        frame_url.scheme() != url.scheme()) {
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;
    }
  }

  if (is_content_initiated) {
    bool browser_handles_request =
        renderer_preferences_.browser_handles_non_local_top_level_requests &&
        IsNonLocalTopLevelNavigation(url, frame, type);
    if (!browser_handles_request) {
      browser_handles_request =
          renderer_preferences_.browser_handles_all_top_level_requests &&
          IsTopLevelNavigation(frame);
    }

    if (browser_handles_request) {
      page_id_ = -1;
      last_page_id_sent_to_browser_ = -1;
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  GURL old_url(frame->dataSource()->request().url());

  if (!frame->parent() && is_content_initiated &&
       !url.SchemeIs(chrome::kAboutScheme)) {
     bool send_referrer = false;
 
     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
     bool is_initial_navigation = page_id_ == -1;
    bool should_fork = HasWebUIScheme(url) ||
         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||
         url.SchemeIs(chrome::kViewSourceScheme) ||
         (frame->isViewSourceModeEnabled() &&
            type != WebKit::WebNavigationTypeReload);

    if (!should_fork && url.SchemeIs(chrome::kFileScheme)) {
      GURL source_url(old_url);
      if (is_initial_navigation && source_url.is_empty() && frame->opener())
        source_url = frame->opener()->top()->document().url();
      DCHECK(!source_url.is_empty());
      should_fork = !source_url.SchemeIs(chrome::kFileScheme);
    }

    if (!should_fork) {
      should_fork = GetContentClient()->renderer()->ShouldFork(
          frame, url, request.httpMethod().utf8(), is_initial_navigation,
          &send_referrer);
    }

    if (should_fork) {
      OpenURL(
          frame, url, send_referrer ? referrer : Referrer(), default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  bool is_fork =
      old_url == GURL(chrome::kAboutBlankURL) &&
      historyBackListCount() < 1 &&
      historyForwardListCount() < 1 &&
      frame->opener() == NULL &&
      frame->parent() == NULL &&
      is_content_initiated &&
      default_policy == WebKit::WebNavigationPolicyCurrentTab &&
      type == WebKit::WebNavigationTypeOther;

  if (is_fork) {
    OpenURL(frame, url, Referrer(), default_policy);
    return WebKit::WebNavigationPolicyIgnore;
  }

  return default_policy;
}
",C,"    // All navigations to or from WebUI URLs or within WebUI-enabled
    // RenderProcesses must be handled by the browser process so that the
    // correct bindings and data sources can be registered.
    bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||
","    bool should_fork = HasWebUIScheme(url) ||
",,"@@ -3039,9 +3039,9 @@ WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
       !url.SchemeIs(chrome::kAboutScheme)) {
     bool send_referrer = false;
 
-    // All navigations to WebUI URLs or within WebUI-enabled RenderProcesses
-    // must be handled by the browser process so that the correct bindings and
-    // data sources can be registered.
+    // All navigations to or from WebUI URLs or within WebUI-enabled
+    // RenderProcesses must be handled by the browser process so that the
+    // correct bindings and data sources can be registered.
     // Similarly, navigations to view-source URLs or within ViewSource mode
     // must be handled by the browser process (except for reloads - those are
     // safe to leave within the renderer).
@@ -3050,7 +3050,7 @@ WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
     // blessed with file permissions.
     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
     bool is_initial_navigation = page_id_ == -1;
-    bool should_fork = HasWebUIScheme(url) ||
+    bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||
         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||
         url.SchemeIs(chrome::kViewSourceScheme) ||
         (frame->isViewSourceModeEnabled() &&",Chrome,0a57375ad73780e61e1770a9d88b0529b0dbd33b,e3cb4529d79a4993535da612dafedc8c40f075bb,1,"WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
    WebFrame* frame, const WebURLRequest& request, WebNavigationType type,
    const WebNode&, WebNavigationPolicy default_policy, bool is_redirect) {
  if (request.url() != GURL(kSwappedOutURL) &&
      GetContentClient()->renderer()->HandleNavigation(frame, request, type,
                                                       default_policy,
                                                       is_redirect)) {
    return WebKit::WebNavigationPolicyIgnore;
  }

  Referrer referrer(
      GURL(request.httpHeaderField(WebString::fromUTF8(""Referer""))),
      GetReferrerPolicyFromRequest(frame, request));

  if (is_swapped_out_) {
    if (request.url() != GURL(kSwappedOutURL)) {
      // Targeted links may try to navigate a swapped out frame.  Allow the
      // browser process to navigate the tab instead.  Note that it is also
      // possible for non-targeted navigations (from this view) to arrive
      // here just after we are swapped out.  It's ok to send them to the
      // browser, as long as they're for the top level frame.
      // TODO(creis): Ensure this supports targeted form submissions when
      // fixing http://crbug.com/101395.
      if (frame->parent() == NULL) {
        OpenURL(frame, request.url(), referrer, default_policy);
        return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
      }

      // We should otherwise ignore in-process iframe navigations, if they
      // arrive just after we are swapped out.
      return WebKit::WebNavigationPolicyIgnore;
    }

    // Allow kSwappedOutURL to complete.
    return default_policy;
  }

  // Webkit is asking whether to navigate to a new URL.
  // This is fine normally, except if we're showing UI from one security
  // context and they're trying to navigate to a different context.
  const GURL& url = request.url();

  // A content initiated navigation may have originated from a link-click,
  // script, drag-n-drop operation, etc.
  bool is_content_initiated =
      DocumentState::FromDataSource(frame->provisionalDataSource())->
          navigation_state()->is_content_initiated();

  // Experimental:
  // If --enable-strict-site-isolation or --site-per-process is enabled, send
  // all top-level navigations to the browser to let it swap processes when
  // crossing site boundaries.  This is currently expected to break some script
  // calls and navigations, such as form submissions.
  const CommandLine& command_line = *CommandLine::ForCurrentProcess();
  bool force_swap_due_to_flag =
      command_line.HasSwitch(switches::kEnableStrictSiteIsolation) ||
      command_line.HasSwitch(switches::kSitePerProcess);
  if (force_swap_due_to_flag &&
      !frame->parent() && (is_content_initiated || is_redirect)) {
    WebString origin_str = frame->document().securityOrigin().toString();
    GURL frame_url(origin_str.utf8().data());
    // TODO(cevans): revisit whether this site check is still necessary once
    // crbug.com/101395 is fixed.
    if (!net::RegistryControlledDomainService::SameDomainOrHost(frame_url,
                                                                url) ||
        frame_url.scheme() != url.scheme()) {
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;
    }
  }

  // If the browser is interested, then give it a chance to look at the request.
  if (is_content_initiated) {
    bool browser_handles_request =
        renderer_preferences_.browser_handles_non_local_top_level_requests &&
        IsNonLocalTopLevelNavigation(url, frame, type);
    if (!browser_handles_request) {
      browser_handles_request =
          renderer_preferences_.browser_handles_all_top_level_requests &&
          IsTopLevelNavigation(frame);
    }

    if (browser_handles_request) {
      // Reset these counters as the RenderView could be reused for the next
      // navigation.
      page_id_ = -1;
      last_page_id_sent_to_browser_ = -1;
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  // Use the frame's original request's URL rather than the document's URL for
  // subsequent checks.  For a popup, the document's URL may become the opener
  // window's URL if the opener has called document.write().
  // See http://crbug.com/93517.
  GURL old_url(frame->dataSource()->request().url());

  // Detect when we're crossing a permission-based boundary (e.g. into or out of
  // an extension or app origin, leaving a WebUI page, etc). We only care about
  // top-level navigations (not iframes). But we sometimes navigate to
  // about:blank to clear a tab, and we want to still allow that.
  //
  // Note: this is known to break POST submissions when crossing process
  // boundaries until http://crbug.com/101395 is fixed.  This is better for
  // security than loading a WebUI, extension or app page in the wrong process.
  // POST requests don't work because this mechanism does not preserve form
  // POST data. We will need to send the request's httpBody data up to the
  // browser process, and issue a special POST navigation in WebKit (via
  // FrameLoader::loadFrameRequest). See ResourceDispatcher and WebURLLoaderImpl
  // for examples of how to send the httpBody data.
  if (!frame->parent() && is_content_initiated &&
       !url.SchemeIs(chrome::kAboutScheme)) {
     bool send_referrer = false;
 
//flaw_line_below:
    // All navigations to WebUI URLs or within WebUI-enabled RenderProcesses
//flaw_line_below:
    // must be handled by the browser process so that the correct bindings and
//flaw_line_below:
    // data sources can be registered.
//fix_flaw_line_below:
//    // All navigations to or from WebUI URLs or within WebUI-enabled
//fix_flaw_line_below:
//    // RenderProcesses must be handled by the browser process so that the
//fix_flaw_line_below:
//    // correct bindings and data sources can be registered.
     // Similarly, navigations to view-source URLs or within ViewSource mode
     // must be handled by the browser process (except for reloads - those are
     // safe to leave within the renderer).
    // Lastly, access to file:// URLs from non-file:// URL pages must be
    // handled by the browser so that ordinary renderer processes don't get
     // blessed with file permissions.
     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
     bool is_initial_navigation = page_id_ == -1;
//flaw_line_below:
    bool should_fork = HasWebUIScheme(url) ||
//fix_flaw_line_below:
//    bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||
         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||
         url.SchemeIs(chrome::kViewSourceScheme) ||
         (frame->isViewSourceModeEnabled() &&
            type != WebKit::WebNavigationTypeReload);

    if (!should_fork && url.SchemeIs(chrome::kFileScheme)) {
      // Fork non-file to file opens.  Check the opener URL if this is the
      // initial navigation in a newly opened window.
      GURL source_url(old_url);
      if (is_initial_navigation && source_url.is_empty() && frame->opener())
        source_url = frame->opener()->top()->document().url();
      DCHECK(!source_url.is_empty());
      should_fork = !source_url.SchemeIs(chrome::kFileScheme);
    }

    if (!should_fork) {
      // Give the embedder a chance.
      should_fork = GetContentClient()->renderer()->ShouldFork(
          frame, url, request.httpMethod().utf8(), is_initial_navigation,
          &send_referrer);
    }

    if (should_fork) {
      OpenURL(
          frame, url, send_referrer ? referrer : Referrer(), default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  // Detect when a page is ""forking"" a new tab that can be safely rendered in
  // its own process.  This is done by sites like Gmail that try to open links
  // in new windows without script connections back to the original page.  We
  // treat such cases as browser navigations (in which we will create a new
  // renderer for a cross-site navigation), rather than WebKit navigations.
  //
  // We use the following heuristic to decide whether to fork a new page in its
  // own process:
  // The parent page must open a new tab to about:blank, set the new tab's
  // window.opener to null, and then redirect the tab to a cross-site URL using
  // JavaScript.
  //
  // TODO(creis): Deprecate this logic once we can rely on rel=noreferrer
  // (see below).
  bool is_fork =
      // Must start from a tab showing about:blank, which is later redirected.
      old_url == GURL(chrome::kAboutBlankURL) &&
      // Must be the first real navigation of the tab.
      historyBackListCount() < 1 &&
      historyForwardListCount() < 1 &&
      // The parent page must have set the child's window.opener to null before
      // redirecting to the desired URL.
      frame->opener() == NULL &&
      // Must be a top-level frame.
      frame->parent() == NULL &&
      // Must not have issued the request from this page.
      is_content_initiated &&
      // Must be targeted at the current tab.
      default_policy == WebKit::WebNavigationPolicyCurrentTab &&
      // Must be a JavaScript navigation, which appears as ""other"".
      type == WebKit::WebNavigationTypeOther;

  if (is_fork) {
    // Open the URL via the browser, not via WebKit.
    OpenURL(frame, url, Referrer(), default_policy);
    return WebKit::WebNavigationPolicyIgnore;
  }

  return default_policy;
}
",185132,"WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
    WebFrame* frame, const WebURLRequest& request, WebNavigationType type,
    const WebNode&, WebNavigationPolicy default_policy, bool is_redirect) {
  if (request.url() != GURL(kSwappedOutURL) &&
      GetContentClient()->renderer()->HandleNavigation(frame, request, type,
                                                       default_policy,
                                                       is_redirect)) {
    return WebKit::WebNavigationPolicyIgnore;
  }

  Referrer referrer(
      GURL(request.httpHeaderField(WebString::fromUTF8(""Referer""))),
      GetReferrerPolicyFromRequest(frame, request));

  if (is_swapped_out_) {
    if (request.url() != GURL(kSwappedOutURL)) {
      if (frame->parent() == NULL) {
        OpenURL(frame, request.url(), referrer, default_policy);
        return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
      }

      return WebKit::WebNavigationPolicyIgnore;
    }

    return default_policy;
  }

  const GURL& url = request.url();

  bool is_content_initiated =
      DocumentState::FromDataSource(frame->provisionalDataSource())->
          navigation_state()->is_content_initiated();

  const CommandLine& command_line = *CommandLine::ForCurrentProcess();
  bool force_swap_due_to_flag =
      command_line.HasSwitch(switches::kEnableStrictSiteIsolation) ||
      command_line.HasSwitch(switches::kSitePerProcess);
  if (force_swap_due_to_flag &&
      !frame->parent() && (is_content_initiated || is_redirect)) {
    WebString origin_str = frame->document().securityOrigin().toString();
    GURL frame_url(origin_str.utf8().data());
    if (!net::RegistryControlledDomainService::SameDomainOrHost(frame_url,
                                                                url) ||
        frame_url.scheme() != url.scheme()) {
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;
    }
  }

  if (is_content_initiated) {
    bool browser_handles_request =
        renderer_preferences_.browser_handles_non_local_top_level_requests &&
        IsNonLocalTopLevelNavigation(url, frame, type);
    if (!browser_handles_request) {
      browser_handles_request =
          renderer_preferences_.browser_handles_all_top_level_requests &&
          IsTopLevelNavigation(frame);
    }

    if (browser_handles_request) {
      page_id_ = -1;
      last_page_id_sent_to_browser_ = -1;
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  GURL old_url(frame->dataSource()->request().url());

  if (!frame->parent() && is_content_initiated &&
       !url.SchemeIs(chrome::kAboutScheme)) {
     bool send_referrer = false;
 
     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
     bool is_initial_navigation = page_id_ == -1;
    bool should_fork = HasWebUIScheme(url) ||
         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||
         url.SchemeIs(chrome::kViewSourceScheme) ||
         (frame->isViewSourceModeEnabled() &&
            type != WebKit::WebNavigationTypeReload);

    if (!should_fork && url.SchemeIs(chrome::kFileScheme)) {
      GURL source_url(old_url);
      if (is_initial_navigation && source_url.is_empty() && frame->opener())
        source_url = frame->opener()->top()->document().url();
      DCHECK(!source_url.is_empty());
      should_fork = !source_url.SchemeIs(chrome::kFileScheme);
    }

    if (!should_fork) {
      should_fork = GetContentClient()->renderer()->ShouldFork(
          frame, url, request.httpMethod().utf8(), is_initial_navigation,
          &send_referrer);
    }

    if (should_fork) {
      OpenURL(
          frame, url, send_referrer ? referrer : Referrer(), default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  bool is_fork =
      old_url == GURL(chrome::kAboutBlankURL) &&
      historyBackListCount() < 1 &&
      historyForwardListCount() < 1 &&
      frame->opener() == NULL &&
      frame->parent() == NULL &&
      is_content_initiated &&
      default_policy == WebKit::WebNavigationPolicyCurrentTab &&
      type == WebKit::WebNavigationTypeOther;

  if (is_fork) {
    OpenURL(frame, url, Referrer(), default_policy);
    return WebKit::WebNavigationPolicyIgnore;
  }

  return default_policy;
}
","WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
    WebFrame* frame, const WebURLRequest& request, WebNavigationType type,
    const WebNode&, WebNavigationPolicy default_policy, bool is_redirect) {
  if (request.url() != GURL(kSwappedOutURL) &&
      GetContentClient()->renderer()->HandleNavigation(frame, request, type,
                                                       default_policy,
                                                       is_redirect)) {
    return WebKit::WebNavigationPolicyIgnore;
  }

  Referrer referrer(
      GURL(request.httpHeaderField(WebString::fromUTF8(""Referer""))),
      GetReferrerPolicyFromRequest(frame, request));

  if (is_swapped_out_) {
    if (request.url() != GURL(kSwappedOutURL)) {
      if (frame->parent() == NULL) {
        OpenURL(frame, request.url(), referrer, default_policy);
        return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
      }

      return WebKit::WebNavigationPolicyIgnore;
    }

    return default_policy;
  }

  const GURL& url = request.url();

  bool is_content_initiated =
      DocumentState::FromDataSource(frame->provisionalDataSource())->
          navigation_state()->is_content_initiated();

  const CommandLine& command_line = *CommandLine::ForCurrentProcess();
  bool force_swap_due_to_flag =
      command_line.HasSwitch(switches::kEnableStrictSiteIsolation) ||
      command_line.HasSwitch(switches::kSitePerProcess);
  if (force_swap_due_to_flag &&
      !frame->parent() && (is_content_initiated || is_redirect)) {
    WebString origin_str = frame->document().securityOrigin().toString();
    GURL frame_url(origin_str.utf8().data());
    if (!net::RegistryControlledDomainService::SameDomainOrHost(frame_url,
                                                                url) ||
        frame_url.scheme() != url.scheme()) {
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;
    }
  }

  if (is_content_initiated) {
    bool browser_handles_request =
        renderer_preferences_.browser_handles_non_local_top_level_requests &&
        IsNonLocalTopLevelNavigation(url, frame, type);
    if (!browser_handles_request) {
      browser_handles_request =
          renderer_preferences_.browser_handles_all_top_level_requests &&
          IsTopLevelNavigation(frame);
    }

    if (browser_handles_request) {
      page_id_ = -1;
      last_page_id_sent_to_browser_ = -1;
      OpenURL(frame, url, referrer, default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  GURL old_url(frame->dataSource()->request().url());

  if (!frame->parent() && is_content_initiated &&
       !url.SchemeIs(chrome::kAboutScheme)) {
     bool send_referrer = false;
 
    // All navigations to or from WebUI URLs or within WebUI-enabled
    // RenderProcesses must be handled by the browser process so that the
    // correct bindings and data sources can be registered.
     int cumulative_bindings = RenderProcess::current()->GetEnabledBindings();
     bool is_initial_navigation = page_id_ == -1;
    bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||
         (cumulative_bindings & BINDINGS_POLICY_WEB_UI) ||
         url.SchemeIs(chrome::kViewSourceScheme) ||
         (frame->isViewSourceModeEnabled() &&
            type != WebKit::WebNavigationTypeReload);

    if (!should_fork && url.SchemeIs(chrome::kFileScheme)) {
      GURL source_url(old_url);
      if (is_initial_navigation && source_url.is_empty() && frame->opener())
        source_url = frame->opener()->top()->document().url();
      DCHECK(!source_url.is_empty());
      should_fork = !source_url.SchemeIs(chrome::kFileScheme);
    }

    if (!should_fork) {
      should_fork = GetContentClient()->renderer()->ShouldFork(
          frame, url, request.httpMethod().utf8(), is_initial_navigation,
          &send_referrer);
    }

    if (should_fork) {
      OpenURL(
          frame, url, send_referrer ? referrer : Referrer(), default_policy);
      return WebKit::WebNavigationPolicyIgnore;  // Suppress the load here.
    }
  }

  bool is_fork =
      old_url == GURL(chrome::kAboutBlankURL) &&
      historyBackListCount() < 1 &&
      historyForwardListCount() < 1 &&
      frame->opener() == NULL &&
      frame->parent() == NULL &&
      is_content_initiated &&
      default_policy == WebKit::WebNavigationPolicyCurrentTab &&
      type == WebKit::WebNavigationTypeOther;

  if (is_fork) {
    OpenURL(frame, url, Referrer(), default_policy);
    return WebKit::WebNavigationPolicyIgnore;
  }

  return default_policy;
}
","The `decidePolicyForNavigation` function in the `RenderViewImpl` class determines how to handle navigation requests in a web frame. It first checks if the request URL matches a specific swapped-out URL and whether the navigation should be handled by the renderer. If the frame is swapped out, it suppresses the load for non-matching URLs. The function also evaluates various conditions, such as whether the navigation is content-initiated, if strict site isolation is enabled, and if the request should be handled by the browser. Depending on these checks, it may open the URL, suppress the load, or return the default navigation policy.","The provided code defines a function that manages navigation requests within a web frame, determining how to respond based on various conditions. It checks if the request URL is valid and whether the navigation should be processed by the renderer or the browser. The function evaluates factors such as the type of navigation, whether it is initiated by content, and specific command-line flags. Depending on these evaluations, it may suppress the navigation, open a new URL, or return a default policy, ensuring that the navigation adheres to security and operational guidelines.","The vulnerability in the original code stemmed from inadequate handling of external navigation requests, particularly those initiated from developer tools, which could lead to security issues such as unauthorized access or data leakage. The fixed code addresses this by introducing checks that ensure navigations to external URLs are properly managed by the browser rather than the renderer. Specifically, it evaluates whether the navigation is content-initiated and whether it should fork based on the URL scheme, ensuring that external navigations are handled securely and appropriately, thus mitigating the risk of exploitation.","The vulnerability in the original code was related to the handling of external navigation requests, particularly those initiated from developer tools, which could potentially allow unauthorized access or manipulation of sensitive data. The fix implemented in the updated code ensures that such external navigations are managed by the browser instead of the renderer, thereby enhancing security. This change involves adding checks to determine the nature of the navigation and ensuring that it is appropriately processed, thus preventing potential exploitation and ensuring that external requests are handled in a secure manner.","The vulnerability was fixed by modifying the navigation handling logic to ensure that external navigations are processed by the browser rather than the renderer. The updated code introduces checks for whether the navigation is content-initiated and evaluates the URL scheme. Specifically, it uses the `ShouldFork` function to determine if the navigation should be handled by the browser based on the URL and request method. Additionally, it checks for specific conditions, such as whether the frame is a top-level frame and if the navigation type is appropriate, thereby enhancing security against unauthorized access from developer tools.","The vulnerability was addressed by implementing a mechanism that ensures external navigation requests are handled by the browser instead of the renderer. This was achieved by introducing checks that assess the nature of the navigation, specifically focusing on whether it is initiated by content and the type of URL involved. The updated logic ensures that navigations originating from developer tools are appropriately processed, thereby preventing unauthorized access or manipulation of sensitive data. By enforcing these conditions, the code enhances security and mitigates the risk of exploitation related to external navigations.","CWE-749, CWE-345, CWE-20, CWE-79, CWE-601, CWE-610, CWE-346, CWE-611, CWE-918, CWE-269",N,-1
68,68,185137,185137,,Remote,Not required,Partial,CVE-2013-0922,https://www.cvedetails.com/cve/CVE-2013-0922/,CWE-264,Low,Partial,Partial,,2013-03-28,7.5,"Google Chrome before 26.0.1410.43 does not properly restrict brute-force access attempts against web sites that require HTTP Basic Authentication, which has unspecified impact and attack vectors.",2017-09-18,,3,https://github.com/chromium/chromium/commit/28aaa72a03df96fa1934876b0efbbc7e6b4b38af,28aaa72a03df96fa1934876b0efbbc7e6b4b38af,"Revert cross-origin auth prompt blocking.
BUG=174129

Review URL: https://chromiumcodereview.appspot.com/12183030

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@181113 0039d316-1c4b-4281-b951-d872f2087c98",2,content/browser/loader/resource_dispatcher_host_impl.cc,"{""sha"": ""0c104bc1f37c86331b1ae2422cdcf9281f9e2bea"", ""filename"": ""chrome/browser/ui/login/login_prompt_browsertest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/28aaa72a03df96fa1934876b0efbbc7e6b4b38af/chrome/browser/ui/login/login_prompt_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/28aaa72a03df96fa1934876b0efbbc7e6b4b38af/chrome/browser/ui/login/login_prompt_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/login/login_prompt_browsertest.cc?ref=28aaa72a03df96fa1934876b0efbbc7e6b4b38af"", ""patch"": ""@@ -754,7 +754,9 @@ IN_PROC_BROWSER_TEST_F(LoginPromptBrowserTest, NoLoginPromptForFavicon) {\n }\n \n // Block crossdomain subresource login prompting as a phishing defense.\n-IN_PROC_BROWSER_TEST_F(LoginPromptBrowserTest, BlockCrossdomainPrompt) {\n+// Disabled per http://crbug.com/174179.\n+IN_PROC_BROWSER_TEST_F(LoginPromptBrowserTest,\n+                       DISABLED_BlockCrossdomainPrompt) {\n   const char* kTestPage = \""files/login/load_img_from_b.html\"";\n \n   host_resolver()->AddRule(\""www.a.com\"", \""127.0.0.1\"");""}<_**next**_>{""sha"": ""2eef4361367985c52af103d34c78596b70145ca8"", ""filename"": ""content/browser/loader/resource_dispatcher_host_impl.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/28aaa72a03df96fa1934876b0efbbc7e6b4b38af/content/browser/loader/resource_dispatcher_host_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/28aaa72a03df96fa1934876b0efbbc7e6b4b38af/content/browser/loader/resource_dispatcher_host_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/loader/resource_dispatcher_host_impl.cc?ref=28aaa72a03df96fa1934876b0efbbc7e6b4b38af"", ""patch"": ""@@ -611,8 +611,9 @@ bool ResourceDispatcherHostImpl::AcceptAuthRequest(\n                               resource_type,\n                               HTTP_AUTH_RESOURCE_LAST);\n \n-    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)\n-      return false;\n+    // TODO(tsepez): Return false on HTTP_AUTH_RESOURCE_BLOCKED_CROSS.\n+    // The code once did this, but was changed due to http://crbug.com/174129.\n+    // http://crbug.com/174179 has been filed to track this issue.\n   }\n \n   return true;""}","bool ResourceDispatcherHostImpl::AcceptAuthRequest(
    ResourceLoader* loader,
    net::AuthChallengeInfo* auth_info) {
  if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info))
    return false;

  if (!auth_info->is_proxy) {
    HttpAuthResourceType resource_type =
        HttpAuthResourceTypeOf(loader->request());
    UMA_HISTOGRAM_ENUMERATION(""Net.HttpAuthResource"",
                               resource_type,
                               HTTP_AUTH_RESOURCE_LAST);
 
    // TODO(tsepez): Return false on HTTP_AUTH_RESOURCE_BLOCKED_CROSS.
    // The code once did this, but was changed due to http://crbug.com/174129.
    // http://crbug.com/174179 has been filed to track this issue.
   }
 
   return true;
}
","bool ResourceDispatcherHostImpl::AcceptAuthRequest(
    ResourceLoader* loader,
    net::AuthChallengeInfo* auth_info) {
  if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info))
    return false;

  if (!auth_info->is_proxy) {
    HttpAuthResourceType resource_type =
        HttpAuthResourceTypeOf(loader->request());
    UMA_HISTOGRAM_ENUMERATION(""Net.HttpAuthResource"",
                               resource_type,
                               HTTP_AUTH_RESOURCE_LAST);
 
    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)
      return false;
   }
 
   return true;
}
",C,"    // TODO(tsepez): Return false on HTTP_AUTH_RESOURCE_BLOCKED_CROSS.
    // The code once did this, but was changed due to http://crbug.com/174129.
    // http://crbug.com/174179 has been filed to track this issue.
","    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)
      return false;
",,"@@ -611,8 +611,9 @@ bool ResourceDispatcherHostImpl::AcceptAuthRequest(
                               resource_type,
                               HTTP_AUTH_RESOURCE_LAST);
 
-    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)
-      return false;
+    // TODO(tsepez): Return false on HTTP_AUTH_RESOURCE_BLOCKED_CROSS.
+    // The code once did this, but was changed due to http://crbug.com/174129.
+    // http://crbug.com/174179 has been filed to track this issue.
   }
 
   return true;",Chrome,28aaa72a03df96fa1934876b0efbbc7e6b4b38af,f7bbda81940376c6b64e0c3dc8ed189788d3a72e,1,"bool ResourceDispatcherHostImpl::AcceptAuthRequest(
    ResourceLoader* loader,
    net::AuthChallengeInfo* auth_info) {
  if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info))
    return false;

  // Prevent third-party content from prompting for login, unless it is
  // a proxy that is trying to authenticate.  This is often the foundation
  // of a scam to extract credentials for another domain from the user.
  if (!auth_info->is_proxy) {
    HttpAuthResourceType resource_type =
        HttpAuthResourceTypeOf(loader->request());
    UMA_HISTOGRAM_ENUMERATION(""Net.HttpAuthResource"",
                               resource_type,
                               HTTP_AUTH_RESOURCE_LAST);
 
//flaw_line_below:
    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)
//flaw_line_below:
      return false;
//fix_flaw_line_below:
//    // TODO(tsepez): Return false on HTTP_AUTH_RESOURCE_BLOCKED_CROSS.
//fix_flaw_line_below:
//    // The code once did this, but was changed due to http://crbug.com/174129.
//fix_flaw_line_below:
//    // http://crbug.com/174179 has been filed to track this issue.
   }
 
   return true;
}
",185137,"bool ResourceDispatcherHostImpl::AcceptAuthRequest(
    ResourceLoader* loader,
    net::AuthChallengeInfo* auth_info) {
  if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info))
    return false;

  if (!auth_info->is_proxy) {
    HttpAuthResourceType resource_type =
        HttpAuthResourceTypeOf(loader->request());
    UMA_HISTOGRAM_ENUMERATION(""Net.HttpAuthResource"",
                               resource_type,
                               HTTP_AUTH_RESOURCE_LAST);
 
    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)
      return false;
   }
 
   return true;
}
","bool ResourceDispatcherHostImpl::AcceptAuthRequest(
    ResourceLoader* loader,
    net::AuthChallengeInfo* auth_info) {
  if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info))
    return false;

  if (!auth_info->is_proxy) {
    HttpAuthResourceType resource_type =
        HttpAuthResourceTypeOf(loader->request());
    UMA_HISTOGRAM_ENUMERATION(""Net.HttpAuthResource"",
                               resource_type,
                               HTTP_AUTH_RESOURCE_LAST);
 
    // TODO(tsepez): Return false on HTTP_AUTH_RESOURCE_BLOCKED_CROSS.
    // The code once did this, but was changed due to http://crbug.com/174129.
    // http://crbug.com/174179 has been filed to track this issue.
   }
 
   return true;
}
","The `AcceptAuthRequest` function in the `ResourceDispatcherHostImpl` class determines whether an authentication request should be accepted based on specific conditions. It first checks if a delegate exists and if it allows the request; if not, it returns false. For non-proxy authentication requests, it identifies the resource type associated with the request and logs this information using a histogram for analytics. If the resource type indicates that the request is blocked due to cross-origin restrictions, the function also returns false. If all checks pass, the function ultimately returns true, allowing the authentication request to proceed.","The provided code defines a function that evaluates whether an authentication request should be accepted based on certain criteria. It first checks if a delegate is present and whether it permits the request; if not, the function denies the request. For requests that are not related to proxy authentication, it assesses the type of resource involved and logs this information for analysis. If the resource type indicates that the request is blocked due to cross-origin policies, the function also denies the request. If all conditions are satisfied, the function allows the authentication request to proceed.","The vulnerability in the original code stemmed from the handling of cross-origin authentication requests, where the function would block such requests based on their resource type. This could lead to unintended denial of access for legitimate requests, particularly in cross-origin scenarios, which was highlighted in the associated bug reports. The fix involved reverting the previous behavior that blocked requests identified as `HTTP_AUTH_RESOURCE_BLOCKED_CROSS`, thus allowing these requests to proceed. This change aimed to enhance usability by preventing unnecessary restrictions on cross-origin authentication prompts, addressing the issues raised in the bug reports.","The vulnerability in the original code was related to the blocking of cross-origin authentication requests, which could inadvertently prevent legitimate access to resources, leading to usability issues for users. This restriction was deemed overly restrictive and problematic, as it hindered proper authentication flows in cross-origin scenarios. The fix involved reverting the previous implementation that enforced this blocking behavior, thereby allowing cross-origin authentication prompts to be accepted. This change aimed to improve user experience by ensuring that valid authentication requests were not denied, addressing the concerns raised in the associated bug report.","The vulnerability was fixed by reverting the blocking behavior for cross-origin authentication requests in the `AcceptAuthRequest` function. Previously, the function would return false for requests identified as `HTTP_AUTH_RESOURCE_BLOCKED_CROSS`, which restricted legitimate access. The change removed this condition, allowing all authentication requests to proceed regardless of their resource type. This adjustment was made to enhance usability and prevent unnecessary denials of access, particularly in cross-origin scenarios, thus addressing the issues highlighted in the associated bug reports and improving the overall authentication flow for users.","The vulnerability was fixed by removing the restriction that blocked cross-origin authentication requests, which had previously led to legitimate requests being denied. The change involved reverting the code to allow all authentication prompts to be accepted, regardless of their resource type. This adjustment aimed to enhance user experience by ensuring that valid authentication flows were not interrupted, particularly in scenarios involving cross-origin interactions. By eliminating the blocking condition, the fix addressed usability concerns and allowed for smoother authentication processes, ultimately improving access to resources without unnecessary limitations.","CWE-942, CWE-346, CWE-1274, CWE-602, CWE-287, CWE-295, CWE-1007, CWE-867, CWE-284, CWE-941",N,-1
69,69,185242,185242,,Remote,Not required,,CVE-2012-5155,https://www.cvedetails.com/cve/CVE-2012-5155/,CWE-264,Low,,Partial,,2013-01-15,5.0,"Google Chrome before 24.0.1312.52 on Mac OS X does not use an appropriate sandboxing approach for worker processes, which makes it easier for remote attackers to bypass intended access restrictions via unspecified vectors.",2013-01-16,Bypass ,1,https://github.com/chromium/chromium/commit/0d7717faeaef5b72434632c95c78bee4883e2573,0d7717faeaef5b72434632c95c78bee4883e2573,"Fix OS_MACOS typos. Should be OS_MACOSX.

BUG=163208
TEST=none

Review URL: https://codereview.chromium.org/12829005

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@189130 0039d316-1c4b-4281-b951-d872f2087c98",1,base/path_service_unittest.cc,"{""sha"": ""5f281d129df93d16b739e0d510cc3be239a0e63a"", ""filename"": ""base/path_service_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d7717faeaef5b72434632c95c78bee4883e2573/base/path_service_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d7717faeaef5b72434632c95c78bee4883e2573/base/path_service_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/path_service_unittest.cc?ref=0d7717faeaef5b72434632c95c78bee4883e2573"", ""patch"": ""@@ -62,7 +62,7 @@ bool ReturnsValidPath(int dir_type) {\n       check_path_exists = false;\n   }\n #endif\n-#if defined(OS_MAC)\n+#if defined(OS_MACOSX)\n   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&\n       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {\n     if (path.ReferencesParent())""}<_**next**_>{""sha"": ""a235b103504c93d8af66da907f900407b4403ad5"", ""filename"": ""chrome/browser/autofill/autofill_browsertest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d7717faeaef5b72434632c95c78bee4883e2573/chrome/browser/autofill/autofill_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d7717faeaef5b72434632c95c78bee4883e2573/chrome/browser/autofill/autofill_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/autofill/autofill_browsertest.cc?ref=0d7717faeaef5b72434632c95c78bee4883e2573"", ""patch"": ""@@ -746,7 +746,7 @@ IN_PROC_BROWSER_TEST_F(AutofillTest, DISABLED_AutofillFormWithRepeatedField) {\n }\n \n // http://crbug.com/150084\n-#if defined(OS_MAC)\n+#if defined(OS_MACOSX)\n #define MAYBE_AutofillFormWithNonAutofillableField \\\n     AutofillFormWithNonAutofillableField\n #else""}<_**next**_>{""sha"": ""ccb0f539f442af28ef148360a0dd427d0452e4ec"", ""filename"": ""chrome/browser/download/download_path_reservation_tracker_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d7717faeaef5b72434632c95c78bee4883e2573/chrome/browser/download/download_path_reservation_tracker_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d7717faeaef5b72434632c95c78bee4883e2573/chrome/browser/download/download_path_reservation_tracker_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/download/download_path_reservation_tracker_unittest.cc?ref=0d7717faeaef5b72434632c95c78bee4883e2573"", ""patch"": ""@@ -455,7 +455,7 @@ TEST_F(DownloadPathReservationTrackerTest, UpdatesToTargetPath) {\n \n // Tests for long name truncation. On other platforms automatic truncation\n // is not performed (yet).\n-#if defined(OS_WIN) || defined(OS_MAC) || defined(OS_CHROMEOS)\n+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_CHROMEOS)\n \n TEST_F(DownloadPathReservationTrackerTest, BasicTruncation) {\n   int real_max_length =""}<_**next**_>{""sha"": ""2953c4dd7373425370e7e29b37e48e77819820c3"", ""filename"": ""chrome/browser/ui/browser_command_controller_unittest.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 23, ""changes"": 25, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d7717faeaef5b72434632c95c78bee4883e2573/chrome/browser/ui/browser_command_controller_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d7717faeaef5b72434632c95c78bee4883e2573/chrome/browser/ui/browser_command_controller_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/browser_command_controller_unittest.cc?ref=0d7717faeaef5b72434632c95c78bee4883e2573"", ""patch"": ""@@ -255,28 +255,8 @@ TEST_F(BrowserCommandControllerFullscreenTest,\n   chrome::ToggleFullscreenMode(browser());\n   ASSERT_TRUE(browser()->window()->IsFullscreen());\n   browser()->command_controller()->FullscreenStateChanged();\n-#if defined(OS_MACOS)\n-  // Mac leaves things enabled in fullscreen.\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_OPEN_CURRENT_URL));\n-  EXPECT_FALSE(chrome::IsCommandEnabled(browser(), IDC_SHOW_AS_TAB));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_TOOLBAR));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_LOCATION));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_SEARCH));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_MENU_BAR));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_NEXT_PANE));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_PREVIOUS_PANE));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_BOOKMARKS));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_DEVELOPER_MENU));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FEEDBACK));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_OPTIONS));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_IMPORT_SETTINGS));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_EDIT_SEARCH_ENGINES));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_VIEW_PASSWORDS));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_ABOUT));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_SHOW_APP_MENU));\n-  EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FULLSCREEN));\n-#else\n-  // Windows and GTK disable most commands in fullscreen.\n+\n+  // Most commands are disabled in fullscreen.\n   EXPECT_FALSE(chrome::IsCommandEnabled(browser(), IDC_OPEN_CURRENT_URL));\n   EXPECT_FALSE(chrome::IsCommandEnabled(browser(), IDC_SHOW_AS_TAB));\n   EXPECT_FALSE(chrome::IsCommandEnabled(browser(), IDC_FOCUS_TOOLBAR));\n@@ -295,7 +275,6 @@ TEST_F(BrowserCommandControllerFullscreenTest,\n   EXPECT_FALSE(chrome::IsCommandEnabled(browser(), IDC_ABOUT));\n   EXPECT_FALSE(chrome::IsCommandEnabled(browser(), IDC_SHOW_APP_MENU));\n   EXPECT_TRUE(chrome::IsCommandEnabled(browser(), IDC_FULLSCREEN));\n-#endif  // defined(OS_MACOS)\n \n   // Exit fullscreen.\n   chrome::ToggleFullscreenMode(browser());""}","bool ReturnsValidPath(int dir_type) {
  base::FilePath path;
  bool result = PathService::Get(dir_type, &path);

  bool check_path_exists = true;
#if defined(OS_POSIX)
  if (dir_type == base::DIR_CACHE)
    check_path_exists = false;
#endif
#if defined(OS_LINUX)
  if (dir_type == base::DIR_USER_DESKTOP)
    check_path_exists = false;
#endif
#if defined(OS_WIN)
  if (dir_type == base::DIR_DEFAULT_USER_QUICK_LAUNCH) {
    if (base::win::GetVersion() < base::win::VERSION_VISTA) {
      wchar_t default_profile_path[MAX_PATH];
      DWORD size = arraysize(default_profile_path);
      return (result &&
              ::GetDefaultUserProfileDirectory(default_profile_path, &size) &&
              StartsWith(path.value(), default_profile_path, false));
    }
  } else if (dir_type == base::DIR_TASKBAR_PINS) {
    if (base::win::GetVersion() < base::win::VERSION_WIN7)
       check_path_exists = false;
   }
 #endif
#if defined(OS_MACOSX)
   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&
       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {
     if (path.ReferencesParent())
      return false;
  }
#else
  if (path.ReferencesParent())
    return false;
#endif
  return result && !path.empty() && (!check_path_exists ||
                                     file_util::PathExists(path));
}
","bool ReturnsValidPath(int dir_type) {
  base::FilePath path;
  bool result = PathService::Get(dir_type, &path);

  bool check_path_exists = true;
#if defined(OS_POSIX)
  if (dir_type == base::DIR_CACHE)
    check_path_exists = false;
#endif
#if defined(OS_LINUX)
  if (dir_type == base::DIR_USER_DESKTOP)
    check_path_exists = false;
#endif
#if defined(OS_WIN)
  if (dir_type == base::DIR_DEFAULT_USER_QUICK_LAUNCH) {
    if (base::win::GetVersion() < base::win::VERSION_VISTA) {
      wchar_t default_profile_path[MAX_PATH];
      DWORD size = arraysize(default_profile_path);
      return (result &&
              ::GetDefaultUserProfileDirectory(default_profile_path, &size) &&
              StartsWith(path.value(), default_profile_path, false));
    }
  } else if (dir_type == base::DIR_TASKBAR_PINS) {
    if (base::win::GetVersion() < base::win::VERSION_WIN7)
       check_path_exists = false;
   }
 #endif
#if defined(OS_MAC)
   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&
       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {
     if (path.ReferencesParent())
      return false;
  }
#else
  if (path.ReferencesParent())
    return false;
#endif
  return result && !path.empty() && (!check_path_exists ||
                                     file_util::PathExists(path));
}
",C,"#if defined(OS_MACOSX)
","#if defined(OS_MAC)
",,"@@ -62,7 +62,7 @@ bool ReturnsValidPath(int dir_type) {
       check_path_exists = false;
   }
 #endif
-#if defined(OS_MAC)
+#if defined(OS_MACOSX)
   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&
       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {
     if (path.ReferencesParent())",Chrome,0d7717faeaef5b72434632c95c78bee4883e2573,49d66d27f59c7f8e6f170a2cf313822f49e4e3b0,1,"bool ReturnsValidPath(int dir_type) {
  base::FilePath path;
  bool result = PathService::Get(dir_type, &path);

  // Some paths might not exist on some platforms in which case confirming
  // |result| is true and !path.empty() is the best we can do.
  bool check_path_exists = true;
#if defined(OS_POSIX)
  // If chromium has never been started on this account, the cache path may not
  // exist.
  if (dir_type == base::DIR_CACHE)
    check_path_exists = false;
#endif
#if defined(OS_LINUX)
  // On the linux try-bots: a path is returned (e.g. /home/chrome-bot/Desktop),
  // but it doesn't exist.
  if (dir_type == base::DIR_USER_DESKTOP)
    check_path_exists = false;
#endif
#if defined(OS_WIN)
  if (dir_type == base::DIR_DEFAULT_USER_QUICK_LAUNCH) {
    // On Windows XP, the Quick Launch folder for the ""Default User"" doesn't
    // exist by default. At least confirm that the path returned begins with the
    // Default User's profile path.
    if (base::win::GetVersion() < base::win::VERSION_VISTA) {
      wchar_t default_profile_path[MAX_PATH];
      DWORD size = arraysize(default_profile_path);
      return (result &&
              ::GetDefaultUserProfileDirectory(default_profile_path, &size) &&
              StartsWith(path.value(), default_profile_path, false));
    }
  } else if (dir_type == base::DIR_TASKBAR_PINS) {
    // There is no pinned-to-taskbar shortcuts prior to Win7.
    if (base::win::GetVersion() < base::win::VERSION_WIN7)
       check_path_exists = false;
   }
 #endif
//flaw_line_below:
#if defined(OS_MAC)
//fix_flaw_line_below:
//#if defined(OS_MACOSX)
   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&
       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {
     if (path.ReferencesParent())
      return false;
  }
#else
  if (path.ReferencesParent())
    return false;
#endif
  return result && !path.empty() && (!check_path_exists ||
                                     file_util::PathExists(path));
}
",185242,"bool ReturnsValidPath(int dir_type) {
  base::FilePath path;
  bool result = PathService::Get(dir_type, &path);

  bool check_path_exists = true;
#if defined(OS_POSIX)
  if (dir_type == base::DIR_CACHE)
    check_path_exists = false;
#endif
#if defined(OS_LINUX)
  if (dir_type == base::DIR_USER_DESKTOP)
    check_path_exists = false;
#endif
#if defined(OS_WIN)
  if (dir_type == base::DIR_DEFAULT_USER_QUICK_LAUNCH) {
    if (base::win::GetVersion() < base::win::VERSION_VISTA) {
      wchar_t default_profile_path[MAX_PATH];
      DWORD size = arraysize(default_profile_path);
      return (result &&
              ::GetDefaultUserProfileDirectory(default_profile_path, &size) &&
              StartsWith(path.value(), default_profile_path, false));
    }
  } else if (dir_type == base::DIR_TASKBAR_PINS) {
    if (base::win::GetVersion() < base::win::VERSION_WIN7)
       check_path_exists = false;
   }
 #endif
#if defined(OS_MAC)
   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&
       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {
     if (path.ReferencesParent())
      return false;
  }
#else
  if (path.ReferencesParent())
    return false;
#endif
  return result && !path.empty() && (!check_path_exists ||
                                     file_util::PathExists(path));
}
","bool ReturnsValidPath(int dir_type) {
  base::FilePath path;
  bool result = PathService::Get(dir_type, &path);

  bool check_path_exists = true;
#if defined(OS_POSIX)
  if (dir_type == base::DIR_CACHE)
    check_path_exists = false;
#endif
#if defined(OS_LINUX)
  if (dir_type == base::DIR_USER_DESKTOP)
    check_path_exists = false;
#endif
#if defined(OS_WIN)
  if (dir_type == base::DIR_DEFAULT_USER_QUICK_LAUNCH) {
    if (base::win::GetVersion() < base::win::VERSION_VISTA) {
      wchar_t default_profile_path[MAX_PATH];
      DWORD size = arraysize(default_profile_path);
      return (result &&
              ::GetDefaultUserProfileDirectory(default_profile_path, &size) &&
              StartsWith(path.value(), default_profile_path, false));
    }
  } else if (dir_type == base::DIR_TASKBAR_PINS) {
    if (base::win::GetVersion() < base::win::VERSION_WIN7)
       check_path_exists = false;
   }
 #endif
#if defined(OS_MACOSX)
   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&
       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {
     if (path.ReferencesParent())
      return false;
  }
#else
  if (path.ReferencesParent())
    return false;
#endif
  return result && !path.empty() && (!check_path_exists ||
                                     file_util::PathExists(path));
}
","The `ReturnsValidPath` function checks the validity of a file path based on a specified directory type (`dir_type`). It retrieves the path using `PathService::Get` and evaluates its existence under various operating systems (POSIX, Linux, Windows, and macOS). The function incorporates specific conditions for each OS, such as ignoring path existence checks for certain directory types or validating paths against user profile directories on Windows. Additionally, it ensures that the path does not reference a parent directory. Ultimately, it returns true if the path is valid, non-empty, and meets the defined criteria for existence.","The code defines a function that verifies the validity of a file path based on a specified directory type. It retrieves the path and checks its existence while considering different conditions for various operating systems. For certain directory types, it may skip existence checks or apply specific rules, such as validating against user profile directories on one operating system. Additionally, it ensures that the path does not reference a parent directory. The function ultimately returns a boolean value indicating whether the path is valid, non-empty, and meets the necessary criteria for existence based on the operating system.","The vulnerability in the original code stemmed from a typo in the operating system check, where `OS_MAC` was incorrectly used instead of `OS_MACOSX`. This mistake could lead to improper handling of path validation for macOS, potentially allowing paths that reference parent directories to be incorrectly deemed valid. The fix involved correcting the conditional compilation directive to `OS_MACOSX`, ensuring that the appropriate checks for directory references are applied specifically for macOS. This change enhances the security of the path validation process by preventing the acceptance of invalid paths that could compromise the system.","The vulnerability in the original code arose from a typographical error in the operating system check, which could lead to incorrect path validation for macOS. This mistake meant that certain conditions meant to prevent invalid paths from being accepted were not properly applied, potentially allowing paths that reference parent directories to pass validation. The fix involved correcting the typo to ensure that the appropriate checks for macOS were executed. This change enhances the security of the path validation process, ensuring that only valid paths are accepted and reducing the risk of potential exploitation.","The vulnerability was fixed by correcting the operating system check from `OS_MAC` to `OS_MACOSX`, ensuring that the correct conditional compilation directives are applied for macOS. This change allows the code to properly execute the path validation logic, specifically the check that prevents paths referencing parent directories from being considered valid. By ensuring that the condition `if (path.ReferencesParent()) return false;` is correctly evaluated for macOS, the fix enhances the overall security of the path validation process, preventing the acceptance of potentially harmful paths that could compromise the system.","The vulnerability was fixed by correcting a typographical error in the operating system check, which ensured that the appropriate validation logic was applied specifically for macOS. This adjustment allowed the code to properly enforce conditions that prevent invalid paths, particularly those referencing parent directories, from being accepted. By ensuring that the correct checks were executed for macOS, the fix strengthened the path validation process, thereby reducing the risk of accepting potentially harmful paths that could compromise system security. This change ultimately enhances the robustness of the code against path-related vulnerabilities.","CWE-22, CWE-23, CWE-36, CWE-35, CWE-73, CWE-99, CWE-641, CWE-32, CWE-40, CWE-67",N,-1
70,70,185375,185375,,Remote,Not required,Partial,CVE-2014-3160,https://www.cvedetails.com/cve/CVE-2014-3160/,CWE-264,Medium,Partial,Partial,,2014-07-20,6.8,"The ResourceFetcher::canRequest function in core/fetch/ResourceFetcher.cpp in Blink, as used in Google Chrome before 36.0.1985.125, does not properly restrict subresource requests associated with SVG files, which allows remote attackers to bypass the Same Origin Policy via a crafted file.",2017-01-06,Bypass ,7,https://github.com/chromium/chromium/commit/ee281f7cac9df44fe241a37f188b28be8845ded0,ee281f7cac9df44fe241a37f188b28be8845ded0,"Enforce SVG image security rules

SVG images have unique security rules that prevent them from loading
any external resources. This patch enforces these rules in
ResourceFetcher::canRequest for all non-data-uri resources. This locks
down our SVG resource handling and fixes two security bugs.

In the case of SVG images that reference other images, we had a bug
where a cached subresource would be used directly from the cache.
This has been fixed because the canRequest check occurs before we use
cached resources.

In the case of SVG images that use CSS imports, we had a bug where
imports were blindly requested. This has been fixed by stopping all
non-data-uri requests in SVG images.

With this patch we now match Gecko's behavior on both testcases.

BUG=380885, 382296

Review URL: https://codereview.chromium.org/320763002

git-svn-id: svn://svn.chromium.org/blink/trunk@176084 bbb929c8-8fbe-4397-9dbb-9b2b20218538",0,third_party/WebKit/Source/core/fetch/ResourceFetcher.cpp,"{""sha"": ""447f133110eb629a1d8572dc9c3005dba7697deb"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/resources/css-import.css"", ""status"": ""added"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/css-import.css"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/css-import.css"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/resources/css-import.css?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,3 @@\n+rect {\n+    fill: red;\n+}\n\\ No newline at end of file""}<_**next**_>{""sha"": ""2b23c4527dedc04e28e1fa5189005c5e2901efe3"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/resources/image-with-css-import.svg"", ""status"": ""added"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/image-with-css-import.svg"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/image-with-css-import.svg"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/resources/image-with-css-import.svg?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,6 @@\n+<svg xmlns=\""http://www.w3.org/2000/svg\"" xmlns:xlink=\""http://www.w3.org/1999/xlink\"" width=\""100\"" height=\""100\"">\n+    <style>\n+        @import url(http://localhost:8000/security/resources/css-import.css);\n+    </style>\n+    <rect width=\""100%\"" height=\""100%\"" fill=\""green\""/>\n+</svg>""}<_**next**_>{""sha"": ""fb20e4cb86d84079925c31dc5db87d401231b1c0"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper-with-no-image.svg"", ""status"": ""added"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper-with-no-image.svg"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper-with-no-image.svg"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper-with-no-image.svg?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,4 @@\n+<svg xmlns=\""http://www.w3.org/2000/svg\"" xmlns:xlink=\""http://www.w3.org/1999/xlink\"" width=\""100\"" height=\""100\"">\n+    <rect width=\""100%\"" height=\""100%\"" fill=\""#0f0\""/>\n+    <rect x=\""20%\"" y=\""20%\"" width=\""60%\"" height=\""60%\"" stroke-width=\""1\"" stroke=\""black\"" fill=\""transparent\""/>\n+</svg>""}<_**next**_>{""sha"": ""73a75e35fd9d98a5c3235e84d9d1dfaddcfe58b9"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper.svg"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper.svg"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper.svg"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/resources/image-wrapper.svg?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -1,6 +1,5 @@\n-<svg xmlns=\""http://www.w3.org/2000/svg\""\n-     xmlns:xlink=\""http://www.w3.org/1999/xlink\""\n-     width=\""100\"" height=\""100\"">\n-    <image xlink:href=\""http://localhost:8000/security/resources/abe.png\""\n-           width=\""100\"" height=\""100\""/>\n+<svg xmlns=\""http://www.w3.org/2000/svg\"" xmlns:xlink=\""http://www.w3.org/1999/xlink\"" width=\""100\"" height=\""100\"">\n+    <rect width=\""100%\"" height=\""100%\"" fill=\""#0f0\""/>\n+    <rect x=\""20%\"" y=\""20%\"" width=\""60%\"" height=\""60%\"" stroke-width=\""1\"" stroke=\""black\"" fill=\""transparent\""/>\n+    <image xlink:href=\""http://localhost:8000/security/resources/abe.png\"" x=\""20%\"" y=\""20%\"" width=\""60%\"" height=\""60%\""/>\n </svg>""}<_**next**_>{""sha"": ""480e114a4a66420372b26e21bf21799ecc527306"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image-expected.html"", ""status"": ""added"", ""additions"": 15, ""deletions"": 0, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image-expected.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image-expected.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image-expected.html?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,15 @@\n+<!DOCTYPE HTML>\n+Test for crbug.com/380885: images should not be requested in an SVG image context.<br><br>\n+Image loaded via object should show a green background with a cross-origin image of Abe Lincoln:<br>\n+<svg xmlns=\""http://www.w3.org/2000/svg\"" xmlns:xlink=\""http://www.w3.org/1999/xlink\"" width=\""100\"" height=\""100\"">\n+    <rect width=\""100%\"" height=\""100%\"" fill=\""#0f0\""/>\n+    <rect x=\""20%\"" y=\""20%\"" width=\""60%\"" height=\""60%\"" stroke-width=\""1\"" stroke=\""black\"" fill=\""transparent\""/>\n+    <image xlink:href=\""resources/abe.png\"" x=\""20%\"" y=\""20%\"" width=\""60%\"" height=\""60%\""/>\n+</svg>\n+\n+<br>\n+Image loaded via img should show a green background without the remote image of Abe Lincoln:<br>\n+<svg width=\""100\"" height=\""100\"">\n+    <rect width=\""100%\"" height=\""100%\"" fill=\""#0f0\""/>\n+    <rect x=\""20%\"" y=\""20%\"" width=\""60%\"" height=\""60%\"" stroke-width=\""1\"" stroke=\""black\"" fill=\""transparent\""/>\n+</svg>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""b926b53dd3e9948965e23b6a8dbffcab49f9c2bd"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image.html"", ""status"": ""added"", ""additions"": 27, ""deletions"": 0, ""changes"": 27, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-cached-remote-image.html?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,27 @@\n+<!DOCTYPE HTML>\n+Test for crbug.com/380885: images should not be requested in an SVG image context.<br><br>\n+Image loaded via object should show a green background with a cross-origin image of Abe Lincoln:<br>\n+<object id=\""precache\"" data=\""resources/image-wrapper.svg\"" width=\""100\"" height=\""100\""></object>\n+<br>\n+Image loaded via img should show a green background without the remote image of Abe Lincoln:<br>\n+<img id=\""image\"" src=\""\"" width=\""100\"" height=\""100\"">\n+<script>\n+if (window.testRunner)\n+    testRunner.waitUntilDone();\n+\n+document.getElementById('precache').onload = function() {\n+    // FIXME: crbug.com/382170 SVG onload event bug.\n+    setTimeout(function() {\n+        var image = document.getElementById('image');\n+        image.onload = function() {\n+            // FIXME: crbug.com/382170 SVG onload event bug.\n+            setTimeout(function() {\n+                if (window.testRunner)\n+                    testRunner.notifyDone();\n+            }, 20);\n+        }\n+        image.src = \""resources/image-wrapper.svg\"";\n+    }, 20);\n+}\n+\n+</script>""}<_**next**_>{""sha"": ""2cca3b4cae0eea0f586f1862cc50b21ee80a39ae"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import-expected.html"", ""status"": ""added"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import-expected.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import-expected.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import-expected.html?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,6 @@\n+<!DOCTYPE HTML>\n+Test for crbug.com/382296: CSS imports should not load in an SVG image context.<br><br>\n+This test passes if there is a green square below:<br>\n+<svg width=\""100\"" height=\""100\"">\n+    <rect width=\""100\"" height=\""100\"" fill=\""green\""/>\n+</svg>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""7c61abbb8315871f6dc444916b0f035dd713667c"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import.html"", ""status"": ""added"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/svg-image-with-css-import.html?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -0,0 +1,16 @@\n+<!DOCTYPE HTML>\n+Test for crbug.com/382296: CSS imports should not load in an SVG image context.<br><br>\n+This test passes if there is a green square below:<br>\n+<img id=\""image\"" src=\""resources/image-with-css-import.svg\"" width=\""100\"" height=\""100\"">\n+<script>\n+if (window.testRunner)\n+    testRunner.waitUntilDone();\n+\n+document.getElementById('image').onload = function() {\n+    // FIXME: crbug.com/382170 SVG onload event bug.\n+    setTimeout(function() {\n+        if (window.testRunner)\n+            testRunner.notifyDone();\n+    }, 30);\n+}\n+</script>""}<_**next**_>{""sha"": ""a8dac743c0eeeba9102288a453e2df94595fb999"", ""filename"": ""third_party/WebKit/Source/core/fetch/ResourceFetcher.cpp"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/Source/core/fetch/ResourceFetcher.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee281f7cac9df44fe241a37f188b28be8845ded0/third_party/WebKit/Source/core/fetch/ResourceFetcher.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/fetch/ResourceFetcher.cpp?ref=ee281f7cac9df44fe241a37f188b28be8845ded0"", ""patch"": ""@@ -59,6 +59,7 @@\n #include \""core/timing/Performance.h\""\n #include \""core/timing/ResourceTimingInfo.h\""\n #include \""core/frame/Settings.h\""\n+#include \""core/svg/graphics/SVGImageChromeClient.h\""\n #include \""platform/Logging.h\""\n #include \""platform/TraceEvent.h\""\n #include \""platform/weborigin/SecurityOrigin.h\""\n@@ -580,6 +581,13 @@ bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const Res\n         break;\n     }\n \n+    // SVG Images have unique security rules that prevent all subresource requests\n+    // except for data urls.\n+    if (type != Resource::MainResource) {\n+        if (frame() && frame()->chromeClient().isSVGImageChromeClient() && !url.protocolIsData())\n+            return false;\n+    }\n+\n     // Last of all, check for insecure content. We do this last so that when\n     // folks block insecure content with a CSP policy, they don't get a warning.\n     // They'll still get a warning in the console about CSP blocking the load.""}","bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const ResourceLoaderOptions& options, bool forPreload, FetchRequest::OriginRestriction originRestriction) const
{
    SecurityOrigin* securityOrigin = options.securityOrigin.get();
    if (!securityOrigin && document())
        securityOrigin = document()->securityOrigin();

    if (securityOrigin && !securityOrigin->canDisplay(url)) {
        if (!forPreload)
            context().reportLocalLoadFailed(url);
        WTF_LOG(ResourceLoading, ""ResourceFetcher::requestResource URL was not allowed by SecurityOrigin::canDisplay"");
        return 0;
    }

    bool shouldBypassMainWorldContentSecurityPolicy = (frame() && frame()->script().shouldBypassMainWorldContentSecurityPolicy()) || (options.contentSecurityPolicyOption == DoNotCheckContentSecurityPolicy);

    switch (type) {
    case Resource::MainResource:
    case Resource::Image:
    case Resource::CSSStyleSheet:
    case Resource::Script:
    case Resource::Font:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
    case Resource::TextTrack:
    case Resource::ImportResource:
    case Resource::Media:
        if (originRestriction == FetchRequest::RestrictToSameOrigin && !securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
    case Resource::SVGDocument:
        if (!securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    }

    ContentSecurityPolicy::ReportingStatus cspReporting = forPreload ?
        ContentSecurityPolicy::SuppressReport : ContentSecurityPolicy::SendReport;

    switch (type) {
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Script:
    case Resource::ImportResource:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;

        if (frame()) {
            Settings* settings = frame()->settings();
            if (!frame()->loader().client()->allowScriptFromSource(!settings || settings->scriptEnabled(), url)) {
                frame()->loader().client()->didNotAllowScript();
                return false;
            }
        }
        break;
    case Resource::CSSStyleSheet:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowStyleFromSource(url, cspReporting))
            return false;
        break;
    case Resource::SVGDocument:
    case Resource::Image:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowImageFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Font: {
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowFontFromSource(url, cspReporting))
            return false;
        break;
    }
    case Resource::MainResource:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
        break;
    case Resource::Media:
    case Resource::TextTrack:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowMediaFromSource(url, cspReporting))
            return false;
         break;
     }
 
    // SVG Images have unique security rules that prevent all subresource requests
    // except for data urls.
    if (type != Resource::MainResource) {
        if (frame() && frame()->chromeClient().isSVGImageChromeClient() && !url.protocolIsData())
            return false;
    }


    if (!checkInsecureContent(type, url, options.mixedContentBlockingTreatment))
        return false;

    return true;
}
","bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const ResourceLoaderOptions& options, bool forPreload, FetchRequest::OriginRestriction originRestriction) const
{
    SecurityOrigin* securityOrigin = options.securityOrigin.get();
    if (!securityOrigin && document())
        securityOrigin = document()->securityOrigin();

    if (securityOrigin && !securityOrigin->canDisplay(url)) {
        if (!forPreload)
            context().reportLocalLoadFailed(url);
        WTF_LOG(ResourceLoading, ""ResourceFetcher::requestResource URL was not allowed by SecurityOrigin::canDisplay"");
        return 0;
    }

    bool shouldBypassMainWorldContentSecurityPolicy = (frame() && frame()->script().shouldBypassMainWorldContentSecurityPolicy()) || (options.contentSecurityPolicyOption == DoNotCheckContentSecurityPolicy);

    switch (type) {
    case Resource::MainResource:
    case Resource::Image:
    case Resource::CSSStyleSheet:
    case Resource::Script:
    case Resource::Font:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
    case Resource::TextTrack:
    case Resource::ImportResource:
    case Resource::Media:
        if (originRestriction == FetchRequest::RestrictToSameOrigin && !securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
    case Resource::SVGDocument:
        if (!securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    }

    ContentSecurityPolicy::ReportingStatus cspReporting = forPreload ?
        ContentSecurityPolicy::SuppressReport : ContentSecurityPolicy::SendReport;

    switch (type) {
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Script:
    case Resource::ImportResource:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;

        if (frame()) {
            Settings* settings = frame()->settings();
            if (!frame()->loader().client()->allowScriptFromSource(!settings || settings->scriptEnabled(), url)) {
                frame()->loader().client()->didNotAllowScript();
                return false;
            }
        }
        break;
    case Resource::CSSStyleSheet:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowStyleFromSource(url, cspReporting))
            return false;
        break;
    case Resource::SVGDocument:
    case Resource::Image:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowImageFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Font: {
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowFontFromSource(url, cspReporting))
            return false;
        break;
    }
    case Resource::MainResource:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
        break;
    case Resource::Media:
    case Resource::TextTrack:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowMediaFromSource(url, cspReporting))
            return false;
         break;
     }
 

    if (!checkInsecureContent(type, url, options.mixedContentBlockingTreatment))
        return false;

    return true;
}
",C,"    // SVG Images have unique security rules that prevent all subresource requests
    // except for data urls.
    if (type != Resource::MainResource) {
        if (frame() && frame()->chromeClient().isSVGImageChromeClient() && !url.protocolIsData())
            return false;
    }

",,,"@@ -59,6 +59,7 @@
 #include ""core/timing/Performance.h""
 #include ""core/timing/ResourceTimingInfo.h""
 #include ""core/frame/Settings.h""
+#include ""core/svg/graphics/SVGImageChromeClient.h""
 #include ""platform/Logging.h""
 #include ""platform/TraceEvent.h""
 #include ""platform/weborigin/SecurityOrigin.h""
@@ -580,6 +581,13 @@ bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const Res
         break;
     }
 
+    // SVG Images have unique security rules that prevent all subresource requests
+    // except for data urls.
+    if (type != Resource::MainResource) {
+        if (frame() && frame()->chromeClient().isSVGImageChromeClient() && !url.protocolIsData())
+            return false;
+    }
+
     // Last of all, check for insecure content. We do this last so that when
     // folks block insecure content with a CSP policy, they don't get a warning.
     // They'll still get a warning in the console about CSP blocking the load.",Chrome,ee281f7cac9df44fe241a37f188b28be8845ded0,41df074d67ea3069264890bd8fe5b65403083a17,1,"bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const ResourceLoaderOptions& options, bool forPreload, FetchRequest::OriginRestriction originRestriction) const
{
    SecurityOrigin* securityOrigin = options.securityOrigin.get();
    if (!securityOrigin && document())
        securityOrigin = document()->securityOrigin();

    if (securityOrigin && !securityOrigin->canDisplay(url)) {
        if (!forPreload)
            context().reportLocalLoadFailed(url);
        WTF_LOG(ResourceLoading, ""ResourceFetcher::requestResource URL was not allowed by SecurityOrigin::canDisplay"");
        return 0;
    }

    // FIXME: Convert this to check the isolated world's Content Security Policy once webkit.org/b/104520 is solved.
    bool shouldBypassMainWorldContentSecurityPolicy = (frame() && frame()->script().shouldBypassMainWorldContentSecurityPolicy()) || (options.contentSecurityPolicyOption == DoNotCheckContentSecurityPolicy);

    // Some types of resources can be loaded only from the same origin. Other
    // types of resources, like Images, Scripts, and CSS, can be loaded from
    // any URL.
    switch (type) {
    case Resource::MainResource:
    case Resource::Image:
    case Resource::CSSStyleSheet:
    case Resource::Script:
    case Resource::Font:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
    case Resource::TextTrack:
    case Resource::ImportResource:
    case Resource::Media:
        // By default these types of resources can be loaded from any origin.
        // FIXME: Are we sure about Resource::Font?
        if (originRestriction == FetchRequest::RestrictToSameOrigin && !securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
    case Resource::SVGDocument:
        if (!securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    }

    // Don't send CSP messages for preloads, we might never actually display those items.
    ContentSecurityPolicy::ReportingStatus cspReporting = forPreload ?
        ContentSecurityPolicy::SuppressReport : ContentSecurityPolicy::SendReport;

    switch (type) {
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Script:
    case Resource::ImportResource:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;

        if (frame()) {
            Settings* settings = frame()->settings();
            if (!frame()->loader().client()->allowScriptFromSource(!settings || settings->scriptEnabled(), url)) {
                frame()->loader().client()->didNotAllowScript();
                return false;
            }
        }
        break;
    case Resource::CSSStyleSheet:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowStyleFromSource(url, cspReporting))
            return false;
        break;
    case Resource::SVGDocument:
    case Resource::Image:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowImageFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Font: {
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowFontFromSource(url, cspReporting))
            return false;
        break;
    }
    case Resource::MainResource:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
        break;
    case Resource::Media:
    case Resource::TextTrack:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowMediaFromSource(url, cspReporting))
            return false;
         break;
     }
 
//fix_flaw_line_below:
//    // SVG Images have unique security rules that prevent all subresource requests
//fix_flaw_line_below:
//    // except for data urls.
//fix_flaw_line_below:
//    if (type != Resource::MainResource) {
//fix_flaw_line_below:
//        if (frame() && frame()->chromeClient().isSVGImageChromeClient() && !url.protocolIsData())
//fix_flaw_line_below:
//            return false;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     // Last of all, check for insecure content. We do this last so that when
     // folks block insecure content with a CSP policy, they don't get a warning.
     // They'll still get a warning in the console about CSP blocking the load.

    // FIXME: Should we consider forPreload here?
    if (!checkInsecureContent(type, url, options.mixedContentBlockingTreatment))
        return false;

    return true;
}
",185375,"bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const ResourceLoaderOptions& options, bool forPreload, FetchRequest::OriginRestriction originRestriction) const
{
    SecurityOrigin* securityOrigin = options.securityOrigin.get();
    if (!securityOrigin && document())
        securityOrigin = document()->securityOrigin();

    if (securityOrigin && !securityOrigin->canDisplay(url)) {
        if (!forPreload)
            context().reportLocalLoadFailed(url);
        WTF_LOG(ResourceLoading, ""ResourceFetcher::requestResource URL was not allowed by SecurityOrigin::canDisplay"");
        return 0;
    }

    bool shouldBypassMainWorldContentSecurityPolicy = (frame() && frame()->script().shouldBypassMainWorldContentSecurityPolicy()) || (options.contentSecurityPolicyOption == DoNotCheckContentSecurityPolicy);

    switch (type) {
    case Resource::MainResource:
    case Resource::Image:
    case Resource::CSSStyleSheet:
    case Resource::Script:
    case Resource::Font:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
    case Resource::TextTrack:
    case Resource::ImportResource:
    case Resource::Media:
        if (originRestriction == FetchRequest::RestrictToSameOrigin && !securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
    case Resource::SVGDocument:
        if (!securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    }

    ContentSecurityPolicy::ReportingStatus cspReporting = forPreload ?
        ContentSecurityPolicy::SuppressReport : ContentSecurityPolicy::SendReport;

    switch (type) {
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Script:
    case Resource::ImportResource:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;

        if (frame()) {
            Settings* settings = frame()->settings();
            if (!frame()->loader().client()->allowScriptFromSource(!settings || settings->scriptEnabled(), url)) {
                frame()->loader().client()->didNotAllowScript();
                return false;
            }
        }
        break;
    case Resource::CSSStyleSheet:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowStyleFromSource(url, cspReporting))
            return false;
        break;
    case Resource::SVGDocument:
    case Resource::Image:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowImageFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Font: {
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowFontFromSource(url, cspReporting))
            return false;
        break;
    }
    case Resource::MainResource:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
        break;
    case Resource::Media:
    case Resource::TextTrack:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowMediaFromSource(url, cspReporting))
            return false;
         break;
     }
 

    if (!checkInsecureContent(type, url, options.mixedContentBlockingTreatment))
        return false;

    return true;
}
","bool ResourceFetcher::canRequest(Resource::Type type, const KURL& url, const ResourceLoaderOptions& options, bool forPreload, FetchRequest::OriginRestriction originRestriction) const
{
    SecurityOrigin* securityOrigin = options.securityOrigin.get();
    if (!securityOrigin && document())
        securityOrigin = document()->securityOrigin();

    if (securityOrigin && !securityOrigin->canDisplay(url)) {
        if (!forPreload)
            context().reportLocalLoadFailed(url);
        WTF_LOG(ResourceLoading, ""ResourceFetcher::requestResource URL was not allowed by SecurityOrigin::canDisplay"");
        return 0;
    }

    bool shouldBypassMainWorldContentSecurityPolicy = (frame() && frame()->script().shouldBypassMainWorldContentSecurityPolicy()) || (options.contentSecurityPolicyOption == DoNotCheckContentSecurityPolicy);

    switch (type) {
    case Resource::MainResource:
    case Resource::Image:
    case Resource::CSSStyleSheet:
    case Resource::Script:
    case Resource::Font:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
    case Resource::TextTrack:
    case Resource::ImportResource:
    case Resource::Media:
        if (originRestriction == FetchRequest::RestrictToSameOrigin && !securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
    case Resource::SVGDocument:
        if (!securityOrigin->canRequest(url)) {
            printAccessDeniedMessage(url);
            return false;
        }
        break;
    }

    ContentSecurityPolicy::ReportingStatus cspReporting = forPreload ?
        ContentSecurityPolicy::SuppressReport : ContentSecurityPolicy::SendReport;

    switch (type) {
    case Resource::XSLStyleSheet:
        ASSERT(RuntimeEnabledFeatures::xsltEnabled());
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Script:
    case Resource::ImportResource:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowScriptFromSource(url, cspReporting))
            return false;

        if (frame()) {
            Settings* settings = frame()->settings();
            if (!frame()->loader().client()->allowScriptFromSource(!settings || settings->scriptEnabled(), url)) {
                frame()->loader().client()->didNotAllowScript();
                return false;
            }
        }
        break;
    case Resource::CSSStyleSheet:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowStyleFromSource(url, cspReporting))
            return false;
        break;
    case Resource::SVGDocument:
    case Resource::Image:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowImageFromSource(url, cspReporting))
            return false;
        break;
    case Resource::Font: {
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowFontFromSource(url, cspReporting))
            return false;
        break;
    }
    case Resource::MainResource:
    case Resource::Raw:
    case Resource::LinkPrefetch:
    case Resource::LinkSubresource:
        break;
    case Resource::Media:
    case Resource::TextTrack:
        if (!shouldBypassMainWorldContentSecurityPolicy && !m_document->contentSecurityPolicy()->allowMediaFromSource(url, cspReporting))
            return false;
         break;
     }
 
    // SVG Images have unique security rules that prevent all subresource requests
    // except for data urls.
    if (type != Resource::MainResource) {
        if (frame() && frame()->chromeClient().isSVGImageChromeClient() && !url.protocolIsData())
            return false;
    }


    if (!checkInsecureContent(type, url, options.mixedContentBlockingTreatment))
        return false;

    return true;
}
","The `canRequest` function in the `ResourceFetcher` class determines whether a resource of a specified type can be requested from a given URL, considering security and content policies. It first checks the security origin associated with the request and verifies if it can display the URL. Depending on the resource type, it evaluates whether the request adheres to the same-origin policy and checks against the document's content security policy (CSP) for various resource types, such as scripts, stylesheets, and images. Additionally, it assesses mixed content restrictions before ultimately returning a boolean indicating if the request is permissible.","The provided code defines a method that checks if a resource can be requested from a specified URL based on security and content policies. It first determines the security origin and verifies if it is allowed to display the URL. The method evaluates whether the request complies with same-origin restrictions and checks against the document's content security policy for various resource types, such as scripts and images. Additionally, it assesses mixed content restrictions to ensure secure loading. Ultimately, the method returns a boolean value indicating whether the resource request is permitted based on these criteria.","The vulnerability in the original code stemmed from inadequate enforcement of security rules for SVG images, allowing them to load external resources, which could lead to unauthorized access or data leakage. Specifically, cached subresources could be used directly without proper checks, and CSS imports were requested without restrictions. The fix implemented a check that prevents all non-data URI requests for SVG images, ensuring that only data URLs are allowed. This change ensures that the security rules for SVG images are strictly followed, aligning the behavior with established standards and mitigating the identified security risks.","The vulnerability in the original code allowed SVG images to load external resources, violating their unique security rules. This oversight permitted cached subresources to be accessed directly and led to unregulated requests for CSS imports, potentially exposing sensitive data. The fix implemented strict enforcement of security rules by preventing any non-data URI requests for SVG images, ensuring that only data URLs are permitted. This change effectively mitigates the risks associated with unauthorized resource loading and aligns the handling of SVG resources with established security standards, thereby addressing the identified security bugs.","The vulnerability was fixed by adding a check in the `canRequest` function to prevent all non-data URI requests for SVG images. Specifically, the code now verifies if the resource type is not the main resource and if the frame is an SVG image client, disallowing any requests that do not use the data protocol. This ensures that cached subresources cannot be used directly and that CSS imports are not requested blindly. By enforcing these security rules, the code now properly restricts SVG images from loading external resources, thereby addressing the identified security issues.","The vulnerability was fixed by implementing a check that restricts SVG images from making any requests for external resources, except for data URIs. This change ensures that any attempts to load cached subresources or CSS imports are blocked, thereby preventing unauthorized access to sensitive data. By enforcing these security rules, the code now effectively prevents SVG images from loading resources that could compromise security, aligning the behavior with established standards and addressing the previously identified security issues. This enhancement significantly strengthens the handling of SVG resources within the application.","CWE-918, CWE-611, CWE-829, CWE-346, CWE-79, CWE-200, CWE-610, CWE-441, CWE-749, CWE-1004",N,-1
71,71,185623,185623,,Remote,Not required,Partial,CVE-2015-6768,https://www.cvedetails.com/cve/CVE-2015-6768/,CWE-264,Low,Partial,Partial,,2015-12-05,7.5,"The DOM implementation in Google Chrome before 47.0.2526.73 allows remote attackers to bypass the Same Origin Policy via unspecified vectors, a different vulnerability than CVE-2015-6770.",2017-09-13,Bypass ,1,https://github.com/chromium/chromium/commit/4c8b008f055f79e622344627fed7f820375a4f01,4c8b008f055f79e622344627fed7f820375a4f01,"Change Document::detach() to RELEASE_ASSERT all subframes are gone.

BUG=556724,577105

Review URL: https://codereview.chromium.org/1667573002

Cr-Commit-Position: refs/heads/master@{#373642}",1,third_party/WebKit/Source/core/dom/Document.cpp,"{""sha"": ""112c8cd99e3f5587281d9fe297c61e280725fcbd"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/4c8b008f055f79e622344627fed7f820375a4f01/third_party/WebKit/Source/core/dom/Document.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/4c8b008f055f79e622344627fed7f820375a4f01/third_party/WebKit/Source/core/dom/Document.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.cpp?ref=4c8b008f055f79e622344627fed7f820375a4f01"", ""patch"": ""@@ -2189,7 +2189,7 @@ void Document::attach(const AttachContext& context)\n void Document::detach(const AttachContext& context)\n {\n     TRACE_EVENT0(\""blink\"", \""Document::detach\"");\n-    ASSERT(!m_frame || m_frame->tree().childCount() == 0);\n+    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);\n     if (!isActive())\n         return;\n ""}"," void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 
    FrameNavigationDisabler navigationDisabler(*m_frame);
    HTMLFrameOwnerElement::UpdateSuspendScope suspendWidgetHierarchyUpdates;
    ScriptForbiddenScope forbidScript;
    view()->dispose();
    m_markers->prepareForDestruction();
    if (LocalDOMWindow* window = this->domWindow())
        window->willDetachDocumentFromFrame();

    m_lifecycle.advanceTo(DocumentLifecycle::Stopping);

    if (page())
        page()->documentDetached(this);
    InspectorInstrumentation::documentDetached(this);

    if (m_frame->loader().client()->sharedWorkerRepositoryClient())
        m_frame->loader().client()->sharedWorkerRepositoryClient()->documentDetached(this);

    stopActiveDOMObjects();

    if (m_scriptedAnimationController)
        m_scriptedAnimationController->clearDocumentPointer();
    m_scriptedAnimationController.clear();

    m_scriptedIdleTaskController.clear();

    if (svgExtensions())
        accessSVGExtensions().pauseAnimations();

    if (m_domWindow)
        m_domWindow->clearEventQueue();

    if (m_layoutView)
        m_layoutView->setIsInWindow(false);

    if (registrationContext())
        registrationContext()->documentWasDetached();

    m_hoverNode = nullptr;
    m_activeHoverElement = nullptr;
    m_autofocusElement = nullptr;

    if (m_focusedElement.get()) {
        RefPtrWillBeRawPtr<Element> oldFocusedElement = m_focusedElement;
        m_focusedElement = nullptr;
        if (frameHost())
            frameHost()->chromeClient().focusedNodeChanged(oldFocusedElement.get(), nullptr);
    }

    if (this == &axObjectCacheOwner())
        clearAXObjectCache();

    m_layoutView = nullptr;
    ContainerNode::detach(context);

    if (this != &axObjectCacheOwner()) {
        if (AXObjectCache* cache = existingAXObjectCache()) {
            for (Node& node : NodeTraversal::descendantsOf(*this)) {
                cache->remove(&node);
            }
        }
    }

    styleEngine().didDetach();

    frameHost()->eventHandlerRegistry().documentDetached(*this);

    m_frame->inputMethodController().documentDetached();

    if (!loader())
        m_fetcher->clearContext();
    if (m_importsController)
        HTMLImportsController::removeFrom(*this);

    m_timers.setTimerTaskRunner(
        Platform::current()->currentThread()->scheduler()->timerTaskRunner()->adoptClone());

    m_frame = nullptr;

    if (m_mediaQueryMatcher)
        m_mediaQueryMatcher->documentDetached();

    DocumentLifecycleNotifier::notifyDocumentWasDetached();
    m_lifecycle.advanceTo(DocumentLifecycle::Stopped);

    DocumentLifecycleNotifier::notifyContextDestroyed();
    ExecutionContext::notifyContextDestroyed();
}
"," void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
    ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 
    FrameNavigationDisabler navigationDisabler(*m_frame);
    HTMLFrameOwnerElement::UpdateSuspendScope suspendWidgetHierarchyUpdates;
    ScriptForbiddenScope forbidScript;
    view()->dispose();
    m_markers->prepareForDestruction();
    if (LocalDOMWindow* window = this->domWindow())
        window->willDetachDocumentFromFrame();

    m_lifecycle.advanceTo(DocumentLifecycle::Stopping);

    if (page())
        page()->documentDetached(this);
    InspectorInstrumentation::documentDetached(this);

    if (m_frame->loader().client()->sharedWorkerRepositoryClient())
        m_frame->loader().client()->sharedWorkerRepositoryClient()->documentDetached(this);

    stopActiveDOMObjects();

    if (m_scriptedAnimationController)
        m_scriptedAnimationController->clearDocumentPointer();
    m_scriptedAnimationController.clear();

    m_scriptedIdleTaskController.clear();

    if (svgExtensions())
        accessSVGExtensions().pauseAnimations();

    if (m_domWindow)
        m_domWindow->clearEventQueue();

    if (m_layoutView)
        m_layoutView->setIsInWindow(false);

    if (registrationContext())
        registrationContext()->documentWasDetached();

    m_hoverNode = nullptr;
    m_activeHoverElement = nullptr;
    m_autofocusElement = nullptr;

    if (m_focusedElement.get()) {
        RefPtrWillBeRawPtr<Element> oldFocusedElement = m_focusedElement;
        m_focusedElement = nullptr;
        if (frameHost())
            frameHost()->chromeClient().focusedNodeChanged(oldFocusedElement.get(), nullptr);
    }

    if (this == &axObjectCacheOwner())
        clearAXObjectCache();

    m_layoutView = nullptr;
    ContainerNode::detach(context);

    if (this != &axObjectCacheOwner()) {
        if (AXObjectCache* cache = existingAXObjectCache()) {
            for (Node& node : NodeTraversal::descendantsOf(*this)) {
                cache->remove(&node);
            }
        }
    }

    styleEngine().didDetach();

    frameHost()->eventHandlerRegistry().documentDetached(*this);

    m_frame->inputMethodController().documentDetached();

    if (!loader())
        m_fetcher->clearContext();
    if (m_importsController)
        HTMLImportsController::removeFrom(*this);

    m_timers.setTimerTaskRunner(
        Platform::current()->currentThread()->scheduler()->timerTaskRunner()->adoptClone());

    m_frame = nullptr;

    if (m_mediaQueryMatcher)
        m_mediaQueryMatcher->documentDetached();

    DocumentLifecycleNotifier::notifyDocumentWasDetached();
    m_lifecycle.advanceTo(DocumentLifecycle::Stopped);

    DocumentLifecycleNotifier::notifyContextDestroyed();
    ExecutionContext::notifyContextDestroyed();
}
",C,"    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);
","    ASSERT(!m_frame || m_frame->tree().childCount() == 0);
",,"@@ -2189,7 +2189,7 @@ void Document::attach(const AttachContext& context)
 void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
-    ASSERT(!m_frame || m_frame->tree().childCount() == 0);
+    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 ",Chrome,4c8b008f055f79e622344627fed7f820375a4f01,6bc4255ecd25658b430cec1f6191e0044c5e6c7f,1," void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
//flaw_line_below:
    ASSERT(!m_frame || m_frame->tree().childCount() == 0);
//fix_flaw_line_below:
//    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 
    // Frame navigation can cause a new Document to be attached. Don't allow that, since that will
    // cause a situation where LocalFrame still has a Document attached after this finishes!
    // Normally, it shouldn't actually be possible to trigger navigation here. However, plugins
    // (see below) can cause lots of crazy things to happen, since plugin detach involves nested
    // message loops.
    FrameNavigationDisabler navigationDisabler(*m_frame);
    // Defer widget updates to avoid plugins trying to run script inside ScriptForbiddenScope,
    // which will crash the renderer after https://crrev.com/200984
    HTMLFrameOwnerElement::UpdateSuspendScope suspendWidgetHierarchyUpdates;
    // Don't allow script to run in the middle of detach() because a detaching Document is not in a
    // consistent state.
    ScriptForbiddenScope forbidScript;
    view()->dispose();
    m_markers->prepareForDestruction();
    if (LocalDOMWindow* window = this->domWindow())
        window->willDetachDocumentFromFrame();

    m_lifecycle.advanceTo(DocumentLifecycle::Stopping);

    if (page())
        page()->documentDetached(this);
    InspectorInstrumentation::documentDetached(this);

    if (m_frame->loader().client()->sharedWorkerRepositoryClient())
        m_frame->loader().client()->sharedWorkerRepositoryClient()->documentDetached(this);

    stopActiveDOMObjects();

    // FIXME: consider using ActiveDOMObject.
    if (m_scriptedAnimationController)
        m_scriptedAnimationController->clearDocumentPointer();
    m_scriptedAnimationController.clear();

    m_scriptedIdleTaskController.clear();

    if (svgExtensions())
        accessSVGExtensions().pauseAnimations();

    // FIXME: This shouldn't be needed once LocalDOMWindow becomes ExecutionContext.
    if (m_domWindow)
        m_domWindow->clearEventQueue();

    if (m_layoutView)
        m_layoutView->setIsInWindow(false);

    if (registrationContext())
        registrationContext()->documentWasDetached();

    m_hoverNode = nullptr;
    m_activeHoverElement = nullptr;
    m_autofocusElement = nullptr;

    if (m_focusedElement.get()) {
        RefPtrWillBeRawPtr<Element> oldFocusedElement = m_focusedElement;
        m_focusedElement = nullptr;
        if (frameHost())
            frameHost()->chromeClient().focusedNodeChanged(oldFocusedElement.get(), nullptr);
    }

    if (this == &axObjectCacheOwner())
        clearAXObjectCache();

    m_layoutView = nullptr;
    ContainerNode::detach(context);

    if (this != &axObjectCacheOwner()) {
        if (AXObjectCache* cache = existingAXObjectCache()) {
            // Documents that are not a root document use the AXObjectCache in
            // their root document. Node::removedFrom is called after the
            // document has been detached so it can't find the root document.
            // We do the removals here instead.
            for (Node& node : NodeTraversal::descendantsOf(*this)) {
                cache->remove(&node);
            }
        }
    }

    styleEngine().didDetach();

    frameHost()->eventHandlerRegistry().documentDetached(*this);

    m_frame->inputMethodController().documentDetached();

    // If this Document is associated with a live DocumentLoader, the
    // DocumentLoader will take care of clearing the FetchContext. Deferring
    // to the DocumentLoader when possible also prevents prematurely clearing
    // the context in the case where multiple Documents end up associated with
    // a single DocumentLoader (e.g., navigating to a javascript: url).
    if (!loader())
        m_fetcher->clearContext();
    // If this document is the master for an HTMLImportsController, sever that
    // relationship. This ensures that we don't leave import loads in flight,
    // thinking they should have access to a valid frame when they don't.
    if (m_importsController)
        HTMLImportsController::removeFrom(*this);

    m_timers.setTimerTaskRunner(
        Platform::current()->currentThread()->scheduler()->timerTaskRunner()->adoptClone());

    // This is required, as our LocalFrame might delete itself as soon as it detaches
    // us. However, this violates Node::detach() semantics, as it's never
    // possible to re-attach. Eventually Document::detach() should be renamed,
    // or this setting of the frame to 0 could be made explicit in each of the
    // callers of Document::detach().
    m_frame = nullptr;

    if (m_mediaQueryMatcher)
        m_mediaQueryMatcher->documentDetached();

    DocumentLifecycleNotifier::notifyDocumentWasDetached();
    m_lifecycle.advanceTo(DocumentLifecycle::Stopped);

    // FIXME: Currently we call notifyContextDestroyed() only in
    // Document::detach(), which means that we don't call
    // notifyContextDestroyed() for a document that doesn't get detached.
    // If such a document has any observer, the observer won't get
    // a contextDestroyed() notification. This can happen for a document
    // created by DOMImplementation::createDocument().
    DocumentLifecycleNotifier::notifyContextDestroyed();
    ExecutionContext::notifyContextDestroyed();
}
",185623," void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
    ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 
    FrameNavigationDisabler navigationDisabler(*m_frame);
    HTMLFrameOwnerElement::UpdateSuspendScope suspendWidgetHierarchyUpdates;
    ScriptForbiddenScope forbidScript;
    view()->dispose();
    m_markers->prepareForDestruction();
    if (LocalDOMWindow* window = this->domWindow())
        window->willDetachDocumentFromFrame();

    m_lifecycle.advanceTo(DocumentLifecycle::Stopping);

    if (page())
        page()->documentDetached(this);
    InspectorInstrumentation::documentDetached(this);

    if (m_frame->loader().client()->sharedWorkerRepositoryClient())
        m_frame->loader().client()->sharedWorkerRepositoryClient()->documentDetached(this);

    stopActiveDOMObjects();

    if (m_scriptedAnimationController)
        m_scriptedAnimationController->clearDocumentPointer();
    m_scriptedAnimationController.clear();

    m_scriptedIdleTaskController.clear();

    if (svgExtensions())
        accessSVGExtensions().pauseAnimations();

    if (m_domWindow)
        m_domWindow->clearEventQueue();

    if (m_layoutView)
        m_layoutView->setIsInWindow(false);

    if (registrationContext())
        registrationContext()->documentWasDetached();

    m_hoverNode = nullptr;
    m_activeHoverElement = nullptr;
    m_autofocusElement = nullptr;

    if (m_focusedElement.get()) {
        RefPtrWillBeRawPtr<Element> oldFocusedElement = m_focusedElement;
        m_focusedElement = nullptr;
        if (frameHost())
            frameHost()->chromeClient().focusedNodeChanged(oldFocusedElement.get(), nullptr);
    }

    if (this == &axObjectCacheOwner())
        clearAXObjectCache();

    m_layoutView = nullptr;
    ContainerNode::detach(context);

    if (this != &axObjectCacheOwner()) {
        if (AXObjectCache* cache = existingAXObjectCache()) {
            for (Node& node : NodeTraversal::descendantsOf(*this)) {
                cache->remove(&node);
            }
        }
    }

    styleEngine().didDetach();

    frameHost()->eventHandlerRegistry().documentDetached(*this);

    m_frame->inputMethodController().documentDetached();

    if (!loader())
        m_fetcher->clearContext();
    if (m_importsController)
        HTMLImportsController::removeFrom(*this);

    m_timers.setTimerTaskRunner(
        Platform::current()->currentThread()->scheduler()->timerTaskRunner()->adoptClone());

    m_frame = nullptr;

    if (m_mediaQueryMatcher)
        m_mediaQueryMatcher->documentDetached();

    DocumentLifecycleNotifier::notifyDocumentWasDetached();
    m_lifecycle.advanceTo(DocumentLifecycle::Stopped);

    DocumentLifecycleNotifier::notifyContextDestroyed();
    ExecutionContext::notifyContextDestroyed();
}
"," void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 
    FrameNavigationDisabler navigationDisabler(*m_frame);
    HTMLFrameOwnerElement::UpdateSuspendScope suspendWidgetHierarchyUpdates;
    ScriptForbiddenScope forbidScript;
    view()->dispose();
    m_markers->prepareForDestruction();
    if (LocalDOMWindow* window = this->domWindow())
        window->willDetachDocumentFromFrame();

    m_lifecycle.advanceTo(DocumentLifecycle::Stopping);

    if (page())
        page()->documentDetached(this);
    InspectorInstrumentation::documentDetached(this);

    if (m_frame->loader().client()->sharedWorkerRepositoryClient())
        m_frame->loader().client()->sharedWorkerRepositoryClient()->documentDetached(this);

    stopActiveDOMObjects();

    if (m_scriptedAnimationController)
        m_scriptedAnimationController->clearDocumentPointer();
    m_scriptedAnimationController.clear();

    m_scriptedIdleTaskController.clear();

    if (svgExtensions())
        accessSVGExtensions().pauseAnimations();

    if (m_domWindow)
        m_domWindow->clearEventQueue();

    if (m_layoutView)
        m_layoutView->setIsInWindow(false);

    if (registrationContext())
        registrationContext()->documentWasDetached();

    m_hoverNode = nullptr;
    m_activeHoverElement = nullptr;
    m_autofocusElement = nullptr;

    if (m_focusedElement.get()) {
        RefPtrWillBeRawPtr<Element> oldFocusedElement = m_focusedElement;
        m_focusedElement = nullptr;
        if (frameHost())
            frameHost()->chromeClient().focusedNodeChanged(oldFocusedElement.get(), nullptr);
    }

    if (this == &axObjectCacheOwner())
        clearAXObjectCache();

    m_layoutView = nullptr;
    ContainerNode::detach(context);

    if (this != &axObjectCacheOwner()) {
        if (AXObjectCache* cache = existingAXObjectCache()) {
            for (Node& node : NodeTraversal::descendantsOf(*this)) {
                cache->remove(&node);
            }
        }
    }

    styleEngine().didDetach();

    frameHost()->eventHandlerRegistry().documentDetached(*this);

    m_frame->inputMethodController().documentDetached();

    if (!loader())
        m_fetcher->clearContext();
    if (m_importsController)
        HTMLImportsController::removeFrom(*this);

    m_timers.setTimerTaskRunner(
        Platform::current()->currentThread()->scheduler()->timerTaskRunner()->adoptClone());

    m_frame = nullptr;

    if (m_mediaQueryMatcher)
        m_mediaQueryMatcher->documentDetached();

    DocumentLifecycleNotifier::notifyDocumentWasDetached();
    m_lifecycle.advanceTo(DocumentLifecycle::Stopped);

    DocumentLifecycleNotifier::notifyContextDestroyed();
    ExecutionContext::notifyContextDestroyed();
}
","The `detach` function in the `Document` class is responsible for safely detaching a document from its associated frame, ensuring that all related resources and references are properly cleaned up. It begins by asserting that the document is active and that the frame has no child nodes. The function then disables navigation, suspends updates to the widget hierarchy, and forbids script execution during the detachment process. It proceeds to dispose of the view, clear event queues, stop active DOM objects, and manage various controllers and caches. Finally, it notifies relevant components of the detachment, advances the document's lifecycle state, and ensures that all associated resources are released, preventing memory leaks.","The provided code defines a method that handles the detachment of a document from its associated frame, ensuring a thorough cleanup of resources and references. It first checks the document's active state and prepares to disable navigation and script execution. The method then proceeds to dispose of the document's view, clear event queues, and stop any ongoing processes. It notifies various components about the detachment, updates the document's lifecycle state, and ensures that all related caches and controllers are properly cleared. This comprehensive approach prevents memory leaks and maintains system stability during the detachment process.","The vulnerability in the original code stemmed from the lack of a proper assertion to ensure that all subframes were removed before detaching the document, which could lead to potential memory leaks or undefined behavior if subframes were still present. The fix introduced a `RELEASE_ASSERT` statement that checks whether the frame is null or if its child count is zero, ensuring that no subframes remain during the detachment process. This change enhances the robustness of the code by preventing the detachment of a document while it still has active subframes, thereby addressing the identified bugs and improving overall stability.","The vulnerability in the original code arose from the absence of a safeguard to confirm that all subframes were removed before detaching the document, which could result in memory leaks or unexpected behavior if subframes remained active. The fix implemented a release assertion that verifies either the absence of a frame or that no child frames exist, ensuring a clean detachment process. This adjustment prevents the detachment of a document while subframes are still present, thereby addressing the identified issues and enhancing the overall stability and reliability of the code during the detachment operation.","The vulnerability was fixed by introducing a `RELEASE_ASSERT` statement that checks the condition of the frame before proceeding with the detachment process. Specifically, it asserts that either the frame is null or that its child count is zero, ensuring that all subframes are removed. This check is crucial as it prevents the detachment of a document while subframes are still active, which could lead to memory leaks or undefined behavior. By enforcing this condition, the code enhances its robustness and stability during the detachment operation, effectively addressing the identified bugs.","The vulnerability was fixed by adding a critical assertion that ensures all subframes are properly removed before the document detachment process begins. This assertion checks that there are no remaining child frames, which prevents the code from executing the detachment while subframes are still active. By enforcing this condition, the fix mitigates the risk of memory leaks and undefined behavior that could occur if the document were detached prematurely. This enhancement improves the overall stability and reliability of the code during the detachment operation, addressing the previously identified issues effectively.","CWE-404, CWE-401, CWE-459, CWE-672, CWE-665, CWE-613, CWE-415, CWE-416, CWE-825, CWE-920",N,-1
72,72,185628,185628,,Remote,Not required,Partial,CVE-2015-6772,https://www.cvedetails.com/cve/CVE-2015-6772/,CWE-264,Low,Partial,Partial,,2015-12-05,7.5,"The DOM implementation in Blink, as used in Google Chrome before 47.0.2526.73, does not prevent javascript: URL navigation while a document is being detached, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code that improperly interacts with a plugin.",2017-09-13,Bypass ,2,https://github.com/chromium/chromium/commit/0b1b7baa4695c945a1b0bea1f0636f1219139e8e,0b1b7baa4695c945a1b0bea1f0636f1219139e8e,"Open Offline Pages in CCT from Downloads Home.

When the respective feature flag is enabled, offline pages opened from
the Downloads Home will use CCT instead of normal tabs.

Bug: 824807
Change-Id: I6d968b8b0c51aaeb7f26332c7ada9f927e151a65
Reviewed-on: https://chromium-review.googlesource.com/977321
Commit-Queue: Carlos Knippschild <carlosk@chromium.org>
Reviewed-by: Ted Choc <tedchoc@chromium.org>
Reviewed-by: Bernhard Bauer <bauerb@chromium.org>
Reviewed-by: Jian Li <jianli@chromium.org>
Cr-Commit-Position: refs/heads/master@{#546545}",1,chrome/browser/offline_pages/android/downloads/offline_page_download_bridge.cc,"{""sha"": ""7376c8909786382981dc04215c9e9a8fd4de5c86"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/offlinepages/downloads/OfflinePageDownloadBridge.java"", ""status"": ""modified"", ""additions"": 68, ""deletions"": 13, ""changes"": 81, ""blob_url"": ""https://github.com/chromium/chromium/blob/0b1b7baa4695c945a1b0bea1f0636f1219139e8e/chrome/android/java/src/org/chromium/chrome/browser/offlinepages/downloads/OfflinePageDownloadBridge.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0b1b7baa4695c945a1b0bea1f0636f1219139e8e/chrome/android/java/src/org/chromium/chrome/browser/offlinepages/downloads/OfflinePageDownloadBridge.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/offlinepages/downloads/OfflinePageDownloadBridge.java?ref=0b1b7baa4695c945a1b0bea1f0636f1219139e8e"", ""patch"": ""@@ -6,18 +6,30 @@\n \n import android.app.Activity;\n import android.content.ComponentName;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.net.Uri;\n+import android.os.Bundle;\n+import android.provider.Browser;\n+import android.support.customtabs.CustomTabsIntent;\n \n import org.chromium.base.ApplicationStatus;\n+import org.chromium.base.ContextUtils;\n import org.chromium.base.annotations.CalledByNative;\n import org.chromium.base.annotations.JNINamespace;\n import org.chromium.chrome.browser.ChromeTabbedActivity;\n+import org.chromium.chrome.browser.IntentHandler;\n+import org.chromium.chrome.browser.LaunchIntentDispatcher;\n import org.chromium.chrome.browser.offlinepages.OfflinePageOrigin;\n import org.chromium.chrome.browser.offlinepages.OfflinePageUtils;\n import org.chromium.chrome.browser.profiles.Profile;\n import org.chromium.chrome.browser.tab.Tab;\n import org.chromium.chrome.browser.tabmodel.TabModel.TabLaunchType;\n import org.chromium.chrome.browser.tabmodel.document.AsyncTabCreationParams;\n import org.chromium.chrome.browser.tabmodel.document.TabDelegate;\n+import org.chromium.content_public.browser.LoadUrlParams;\n+\n+import java.util.Map;\n \n /**\n  * Serves as an interface between Download Home UI and offline page related items that are to be\n@@ -28,7 +40,6 @@\n     private static OfflinePageDownloadBridge sInstance;\n     private static boolean sIsTesting;\n     private long mNativeOfflinePageDownloadBridge;\n-    private boolean mIsLoaded;\n \n     /**\n      * @return An {@link OfflinePageDownloadBridge} instance singleton.  If one\n@@ -54,29 +65,73 @@ public void destroy() {\n         if (mNativeOfflinePageDownloadBridge != 0) {\n             nativeDestroy(mNativeOfflinePageDownloadBridge);\n             mNativeOfflinePageDownloadBridge = 0;\n-            mIsLoaded = false;\n         }\n     }\n \n     /**\n-     * 'Opens' the offline page identified by the given URL and offlineId.\n-     * This is done by creating a new tab and navigating it to the saved local snapshot.\n-     * No automatic redirection is happening based on the connection status.\n-     * If the item with specified GUID is not found or can't be opened, nothing happens.\n+     * 'Opens' the offline page identified by the given URL and offlineId by navigating to the saved\n+     * local snapshot. No automatic redirection is happening based on the connection status. If the\n+     * item with specified GUID is not found or can't be opened, nothing happens.\n      */\n     @CalledByNative\n-    private static void openItem(String url, long offlineId) {\n+    private static void openItem(final String url, final long offlineId, final boolean openInCct) {\n         OfflinePageUtils.getLoadUrlParamsForOpeningOfflineVersion(url, offlineId, (params) -> {\n             if (params == null) return;\n-            ComponentName componentName = getComponentName();\n-            AsyncTabCreationParams asyncParams = componentName == null\n-                    ? new AsyncTabCreationParams(params)\n-                    : new AsyncTabCreationParams(params, componentName);\n-            final TabDelegate tabDelegate = new TabDelegate(false);\n-            tabDelegate.createNewTab(asyncParams, TabLaunchType.FROM_CHROME_UI, Tab.INVALID_TAB_ID);\n+            if (openInCct) {\n+                openItemInCct(offlineId, params);\n+            } else {\n+                openItemInNewTab(offlineId, params);\n+            }\n         });\n     }\n \n+    /**\n+     * Opens the offline page identified by the given offlineId and the LoadUrlParams in a new tab.\n+     */\n+    private static void openItemInNewTab(long offlineId, LoadUrlParams params) {\n+        ComponentName componentName = getComponentName();\n+        AsyncTabCreationParams asyncParams = componentName == null\n+                ? new AsyncTabCreationParams(params)\n+                : new AsyncTabCreationParams(params, componentName);\n+        final TabDelegate tabDelegate = new TabDelegate(false);\n+        tabDelegate.createNewTab(asyncParams, TabLaunchType.FROM_CHROME_UI, Tab.INVALID_TAB_ID);\n+    }\n+\n+    /**\n+     * Opens the offline page identified by the given offlineId and the LoadUrlParams in a CCT.\n+     */\n+    private static void openItemInCct(long offlineId, LoadUrlParams params) {\n+        final Context context;\n+        if (ApplicationStatus.hasVisibleActivities()) {\n+            context = ApplicationStatus.getLastTrackedFocusedActivity();\n+        } else {\n+            context = ContextUtils.getApplicationContext();\n+        }\n+\n+        CustomTabsIntent.Builder builder = new CustomTabsIntent.Builder();\n+        builder.setShowTitle(true);\n+        builder.addDefaultShareMenuItem();\n+\n+        CustomTabsIntent customTabIntent = builder.build();\n+        customTabIntent.intent.setData(Uri.parse(params.getUrl()));\n+\n+        Intent intent = LaunchIntentDispatcher.createCustomTabActivityIntent(\n+                context, customTabIntent.intent);\n+        intent.setPackage(context.getPackageName());\n+        intent.putExtra(Browser.EXTRA_APPLICATION_ID, context.getPackageName());\n+\n+        IntentHandler.addTrustedIntentExtras(intent);\n+        if (!(context instanceof Activity)) intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n+\n+        Bundle bundle = new Bundle();\n+        for (Map.Entry<String, String> entry : params.getExtraHeaders().entrySet()) {\n+            bundle.putString(entry.getKey(), entry.getValue());\n+        }\n+        intent.putExtra(Browser.EXTRA_HEADERS, bundle);\n+\n+        context.startActivity(intent);\n+    }\n+\n     /**\n      * Starts download of the page currently open in the specified Tab.\n      * If tab's contents are not yet loaded completely, we'll wait for it""}<_**next**_>{""sha"": ""3f9788b4276be03dea3ec489544bcc80bebfb2b0"", ""filename"": ""chrome/browser/offline_pages/android/downloads/offline_page_download_bridge.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/0b1b7baa4695c945a1b0bea1f0636f1219139e8e/chrome/browser/offline_pages/android/downloads/offline_page_download_bridge.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0b1b7baa4695c945a1b0bea1f0636f1219139e8e/chrome/browser/offline_pages/android/downloads/offline_page_download_bridge.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/offline_pages/android/downloads/offline_page_download_bridge.cc?ref=0b1b7baa4695c945a1b0bea1f0636f1219139e8e"", ""patch"": ""@@ -94,7 +94,8 @@ void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,\n                                          int64_t offline_id) {\n   JNIEnv* env = AttachCurrentThread();\n   Java_OfflinePageDownloadBridge_openItem(\n-      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);\n+      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id,\n+      offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct());\n }\n \n // TODO(dewittj): Move to Download UI Adapter.""}","void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,
                                          int64_t offline_id) {
   JNIEnv* env = AttachCurrentThread();
   Java_OfflinePageDownloadBridge_openItem(
      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id,
      offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct());
 }
","void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,
                                          int64_t offline_id) {
   JNIEnv* env = AttachCurrentThread();
   Java_OfflinePageDownloadBridge_openItem(
      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);
 }
",C,"      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id,
      offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct());
","      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);
",,"@@ -94,7 +94,8 @@ void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,
                                          int64_t offline_id) {
   JNIEnv* env = AttachCurrentThread();
   Java_OfflinePageDownloadBridge_openItem(
-      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);
+      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id,
+      offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct());
 }
 
 // TODO(dewittj): Move to Download UI Adapter.",Chrome,0b1b7baa4695c945a1b0bea1f0636f1219139e8e,2f40b7e4357adc7fe930a1e69d7c26347a4da9d4,1,"void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,
                                          int64_t offline_id) {
   JNIEnv* env = AttachCurrentThread();
   Java_OfflinePageDownloadBridge_openItem(
//flaw_line_below:
      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);
//fix_flaw_line_below:
//      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id,
//fix_flaw_line_below:
//      offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct());
 }
",185628,"void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,
                                          int64_t offline_id) {
   JNIEnv* env = AttachCurrentThread();
   Java_OfflinePageDownloadBridge_openItem(
      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);
 }
","void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,
                                          int64_t offline_id) {
   JNIEnv* env = AttachCurrentThread();
   Java_OfflinePageDownloadBridge_openItem(
      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id,
      offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct());
 }
","The `OpenItem` function in the `DownloadUIAdapterDelegate` class is designed to facilitate the opening of an offline item, identified by its `OfflineItem` object and a corresponding `offline_id`. It first attaches the current thread to the Java Native Interface (JNI) environment using `AttachCurrentThread()`. Then, it invokes the Java method `Java_OfflinePageDownloadBridge_openItem`, passing the Java representation of the item's page URL (converted from UTF-8) and the offline ID. This integration allows seamless interaction between C++ and Java, enabling the application to handle offline content effectively.","The provided code defines a function that facilitates the opening of an offline content item within an application. It begins by establishing a connection to the Java environment, ensuring that the current thread can interact with Java components. Subsequently, it calls a specific Java method designed to handle the opening of the offline item, passing along the necessary information, including the URL of the content and a unique identifier. This process enables the application to effectively manage and display offline resources, enhancing user experience by allowing access to previously downloaded content.","The vulnerability in the original code stemmed from the lack of a mechanism to control how offline pages were opened when accessed from the Downloads Home, potentially leading to inconsistent user experiences. The fixed code addresses this issue by introducing a feature flag, `offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct()`, which determines whether offline pages should be opened in a Custom Chrome Tab (CCT) instead of standard tabs. This enhancement ensures that when the feature flag is enabled, the application can provide a more secure and user-friendly way to access offline content, thereby mitigating the vulnerability.","The vulnerability in the original code arose from the absence of a controlled method for opening offline pages accessed from the Downloads Home, which could lead to inconsistent behavior and potential security risks. The fix implemented a feature flag that determines whether these offline pages should be opened in a more secure and isolated environment, specifically a Custom Chrome Tab, rather than in standard tabs. This change enhances user experience and security by ensuring that offline content is handled appropriately based on the feature's status, thereby addressing the identified vulnerability effectively.","The vulnerability was fixed by introducing a feature flag that determines the behavior of opening offline pages from the Downloads Home. In the updated code, the function now includes a call to `offline_pages::ShouldOfflinePagesInDownloadHomeOpenInCct()`, which checks whether the feature is enabled. If it is, offline pages are opened in a Custom Chrome Tab (CCT) instead of a standard tab, providing a more secure and controlled environment for accessing offline content. This change ensures that the application can adapt its behavior based on user preferences and security considerations, effectively mitigating the previous vulnerability.","The vulnerability was addressed by implementing a feature flag that controls how offline pages are opened when accessed from the Downloads Home. The updated code checks the status of this feature flag to determine whether to open the offline content in a more secure and isolated environment, specifically a Custom Chrome Tab, rather than in standard tabs. This enhancement allows for a more consistent and secure user experience by ensuring that offline pages are handled appropriately based on the user's preferences and security settings, effectively mitigating the risks associated with the previous implementation.","CWE-266, CWE-346, CWE-654, CWE-749, CWE-441, CWE-668, CWE-284, CWE-732, CWE-923, CWE-79",N,-1
73,73,185666,185666,,Remote,Not required,,CVE-2015-6786,https://www.cvedetails.com/cve/CVE-2015-6786/,CWE-264,Medium,,Partial,,2015-12-05,4.3,"The CSPSourceList::matches function in WebKit/Source/core/frame/csp/CSPSourceList.cpp in the Content Security Policy (CSP) implementation in Google Chrome before 47.0.2526.73 accepts a blob:, data:, or filesystem: URL as a match for a * pattern, which allows remote attackers to bypass intended scheme restrictions in opportunistic circumstances by leveraging a policy that relies on this pattern.",2017-09-13,Bypass ,10,https://github.com/chromium/chromium/commit/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0,5d0e9f824e05523e03dabc0e341b9f8f17a72bb0,"Disallow CSP source * matching of data:, blob:, and filesystem: URLs

The CSP spec specifically excludes matching of data:, blob:, and
filesystem: URLs with the source '*' wildcard. This adds checks to make
sure that doesn't happen, along with tests.

BUG=534570
R=mkwst@chromium.org

Review URL: https://codereview.chromium.org/1361763005

Cr-Commit-Position: refs/heads/master@{#350950}",6,third_party/WebKit/Source/core/frame/csp/CSPSourceList.cpp,"{""sha"": ""04d7709facd4a533ebbc5a285bda64d95f90f5a3"", ""filename"": ""chrome/common/extensions/docs/templates/articles/app_csp.html"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/chrome/common/extensions/docs/templates/articles/app_csp.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/chrome/common/extensions/docs/templates/articles/app_csp.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/extensions/docs/templates/articles/app_csp.html?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -51,12 +51,12 @@ <h2 id=\""what\"">What is the CSP for Chrome Apps?</h2>\n \n <pre>\n default-src 'self';\n-connect-src *;\n+connect-src * data: blob: filesystem:;\n style-src 'self' data: chrome-extension-resource: 'unsafe-inline';\n img-src 'self' data: chrome-extension-resource:;\n frame-src 'self' data: chrome-extension-resource:;\n font-src 'self' data: chrome-extension-resource:;\n-media-src *;\n+media-src * data: blob: filesystem:;\n </pre>\n \n <p>""}<_**next**_>{""sha"": ""e999f552168a0f8bf82aaa4254e03fa4d88e9788"", ""filename"": ""chrome/common/extensions/docs/templates/articles/offline_apps.html"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/chrome/common/extensions/docs/templates/articles/offline_apps.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/chrome/common/extensions/docs/templates/articles/offline_apps.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/extensions/docs/templates/articles/offline_apps.html?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -135,12 +135,12 @@ <h2 id=\""possibilities\""> Security restrictions </h2>\n \n <pre>\n default-src 'self';\n-connect-src *;\n+connect-src * data: blob: filesystem:;\n style-src 'self' blob: data: filesystem: 'unsafe-inline';\n img-src 'self' blob: data: filesystem:;\n frame-src 'self' blob: data: filesystem:;\n font-src 'self' blob: data: filesystem:;\n-media-src *;\n+media-src * data: blob: filesystem:;\n </pre>\n \n <h2 id=\""manifest\""> Specifying offline_enabled </h2>""}<_**next**_>{""sha"": ""de9843014321c9dadb4a16669eb2d0c36cb9929c"", ""filename"": ""extensions/common/manifest_handlers/csp_info.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/extensions/common/manifest_handlers/csp_info.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/extensions/common/manifest_handlers/csp_info.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/common/manifest_handlers/csp_info.cc?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -34,7 +34,7 @@ const char kDefaultPlatformAppContentSecurityPolicy[] =\n     // Platform apps can only use local resources by default.\n     \""default-src 'self' blob: filesystem: chrome-extension-resource:;\""\n     // For remote resources, they can fetch them via XMLHttpRequest.\n-    \"" connect-src *;\""\n+    \"" connect-src * data: blob: filesystem:;\""\n     // And serve them via data: or same-origin (blob:, filesystem:) URLs\n     \"" style-src \"" PLATFORM_APP_LOCAL_CSP_SOURCES \"" 'unsafe-inline';\""\n     \"" img-src \"" PLATFORM_APP_LOCAL_CSP_SOURCES \"";\""\n@@ -45,7 +45,7 @@ const char kDefaultPlatformAppContentSecurityPolicy[] =\n     //    spotty connectivity.\n     // 2. Fetching via XHR and serving via blob: URLs currently does not allow\n     //    streaming or partial buffering.\n-    \"" media-src *;\"";\n+    \"" media-src * data: blob: filesystem:;\"";\n \n int GetValidatorOptions(Extension* extension) {\n   int options = csp_validator::OPTIONS_NONE;""}<_**next**_>{""sha"": ""6c0916c1fed2dbaf5abdca20cab530114b9cad3b"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-wildcards-disallowed.html"", ""status"": ""added"", ""additions"": 61, ""deletions"": 0, ""changes"": 61, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-wildcards-disallowed.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-wildcards-disallowed.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-wildcards-disallowed.html?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -0,0 +1,61 @@\n+<!DOCTYPE html>\n+<html>\n+    <head>\n+    <title>script-src disallowed wildcard use</title>\n+    <script src=\""../../../resources/testharness.js\""></script>\n+    <script src=\""../../../resources/testharnessreport.js\""></script>\n+    <meta http-equiv=\""Content-Security-Policy\"" content=\""script-src 'nonce-nonce' *\"">\n+    </head>\n+    <body>\n+    <script nonce=\""nonce\"">\n+        var t1 = async_test('data: URIs should not match *');\n+        t1.step(function() {\n+            var script = document.createElement(\""script\"");\n+            script.src = 'data:application/javascript,';\n+            script.addEventListener('load', t1.step_func(function() {\n+                assert_unreached('Should not successfully load data URI.');\n+            }));\n+            script.addEventListener('error', t1.step_func(function() {\n+                t1.done();\n+            }));\n+            document.head.appendChild(script);\n+        });\n+\n+        var t2 = async_test('blob: URIs should not match *');\n+        t2.step(function() {\n+            var b = new Blob([''], { type: 'application/javascript' });\n+            var script = document.createElement('script');\n+            script.addEventListener('load', t2.step_func(function() {\n+                assert_unreached('Should not successfully load blob URI.');\n+            }));\n+            script.addEventListener('error', t2.step_func(function() {\n+                t2.done();\n+            }));\n+\n+            script.src = URL.createObjectURL(b);\n+            document.head.appendChild(script);\n+        });\n+\n+        if (window.webkitRequestFileSystem) {\n+            var t3 = async_test('filesystem URIs should not match *');\n+            window.webkitRequestFileSystem(TEMPORARY, 1024*1024 /*1MB*/, function(fs) {\n+                fs.root.getFile('fail.js', {create: true}, function(fileEntry) {\n+                    fileEntry.createWriter(function(fileWriter) {\n+                        var script = document.createElement('script');\n+\n+                        script.addEventListener('load', t3.step_func(function() {\n+                            assert_unreached('Should not successfully load filesystem URI.');\n+                        }));\n+                        script.addEventListener('error', t3.step_func(function() {\n+                            t3.done();\n+                        }));\n+\n+                        script.src = fileEntry.toURL('application/javascript');\n+                        document.body.appendChild(script);\n+                    });\n+                });\n+            });\n+        }\n+    </script>\n+    </body>\n+</html>""}<_**next**_>{""sha"": ""1191abce7fe4c98eaeefc3dd95e90342aa113ade"", ""filename"": ""third_party/WebKit/Source/core/frame/csp/CSPSourceList.cpp"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 7, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/Source/core/frame/csp/CSPSourceList.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/Source/core/frame/csp/CSPSourceList.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/csp/CSPSourceList.cpp?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -45,20 +45,23 @@ CSPSourceList::CSPSourceList(ContentSecurityPolicy* policy, const String& direct\n \n bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const\n {\n-    if (m_allowStar)\n+    // The CSP spec specifically states that data:, blob:, and filesystem URLs\n+    // should not be captured by a '*\"" source\n+    // (http://www.w3.org/TR/CSP2/#source-list-guid-matching). Thus, in the\n+    // case of a full wildcard, data:, blob:, and filesystem: URLs are\n+    // explicitly checked for in the source list before allowing them through.\n+    if (m_allowStar) {\n+        if (url.protocolIs(\""blob\"") || url.protocolIs(\""data\"") || url.protocolIs(\""filesystem\""))\n+            return hasSourceMatchInList(url, redirectStatus);\n         return true;\n+    }\n \n     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;\n \n     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))\n         return true;\n \n-    for (size_t i = 0; i < m_list.size(); ++i) {\n-        if (m_list[i].matches(effectiveURL, redirectStatus))\n-            return true;\n-    }\n-\n-    return false;\n+    return hasSourceMatchInList(effectiveURL, redirectStatus);\n }\n \n bool CSPSourceList::allowInline() const\n@@ -490,5 +493,14 @@ void CSPSourceList::addSourceHash(const ContentSecurityPolicyHashAlgorithm& algo\n     m_hashAlgorithmsUsed |= algorithm;\n }\n \n+bool CSPSourceList::hasSourceMatchInList(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const\n+{\n+    for (size_t i = 0; i < m_list.size(); ++i) {\n+        if (m_list[i].matches(url, redirectStatus))\n+            return true;\n+    }\n+\n+    return false;\n+}\n \n } // namespace blink""}<_**next**_>{""sha"": ""fceb8158a1b7c8c9471676d479833eb499d3f012"", ""filename"": ""third_party/WebKit/Source/core/frame/csp/CSPSourceList.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/Source/core/frame/csp/CSPSourceList.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/Source/core/frame/csp/CSPSourceList.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/csp/CSPSourceList.h?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -50,6 +50,8 @@ class CORE_EXPORT CSPSourceList {\n     void addSourceNonce(const String& nonce);\n     void addSourceHash(const ContentSecurityPolicyHashAlgorithm&, const DigestValue& hash);\n \n+    bool hasSourceMatchInList(const KURL&, ContentSecurityPolicy::RedirectStatus) const;\n+\n     ContentSecurityPolicy* m_policy;\n     Vector<CSPSource> m_list;\n     String m_directiveName;""}<_**next**_>{""sha"": ""106e8e72f16939961020c1bffd149182cce45d3b"", ""filename"": ""third_party/WebKit/Source/core/frame/csp/CSPSourceListTest.cpp"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 0, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/Source/core/frame/csp/CSPSourceListTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5d0e9f824e05523e03dabc0e341b9f8f17a72bb0/third_party/WebKit/Source/core/frame/csp/CSPSourceListTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/csp/CSPSourceListTest.cpp?ref=5d0e9f824e05523e03dabc0e341b9f8f17a72bb0"", ""patch"": ""@@ -54,6 +54,24 @@ TEST_F(CSPSourceListTest, BasicMatchingNone)\n     EXPECT_FALSE(sourceList.matches(KURL(base, \""https://example.test/\"")));\n }\n \n+TEST_F(CSPSourceListTest, BasicMatchingStar)\n+{\n+    KURL base;\n+    String sources = \""*\"";\n+    CSPSourceList sourceList(csp.get(), \""script-src\"");\n+    parseSourceList(sourceList, sources);\n+\n+    EXPECT_TRUE(sourceList.matches(KURL(base, \""http://example.com/\"")));\n+    EXPECT_TRUE(sourceList.matches(KURL(base, \""https://example.com/\"")));\n+    EXPECT_TRUE(sourceList.matches(KURL(base, \""http://example.com/bar\"")));\n+    EXPECT_TRUE(sourceList.matches(KURL(base, \""http://foo.example.com/\"")));\n+    EXPECT_TRUE(sourceList.matches(KURL(base, \""http://foo.example.com/bar\"")));\n+\n+    EXPECT_FALSE(sourceList.matches(KURL(base, \""data:https://example.test/\"")));\n+    EXPECT_FALSE(sourceList.matches(KURL(base, \""blob:https://example.test/\"")));\n+    EXPECT_FALSE(sourceList.matches(KURL(base, \""filesystem:https://example.test/\"")));\n+}\n+\n TEST_F(CSPSourceListTest, BasicMatchingSelf)\n {\n     KURL base;""}"," bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
 {
    // The CSP spec specifically states that data:, blob:, and filesystem URLs
    // should not be captured by a '*"" source
    // (http://www.w3.org/TR/CSP2/#source-list-guid-matching). Thus, in the
    // case of a full wildcard, data:, blob:, and filesystem: URLs are
    // explicitly checked for in the source list before allowing them through.
    if (m_allowStar) {
        if (url.protocolIs(""blob"") || url.protocolIs(""data"") || url.protocolIs(""filesystem""))
            return hasSourceMatchInList(url, redirectStatus);
         return true;
    }
 
     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 
     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))
         return true;
 
    return hasSourceMatchInList(effectiveURL, redirectStatus);
 }
"," bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
 {
    if (m_allowStar)
         return true;
 
     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 
     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))
         return true;
 
    for (size_t i = 0; i < m_list.size(); ++i) {
        if (m_list[i].matches(effectiveURL, redirectStatus))
            return true;
    }
    return false;
 }
",C,"    // The CSP spec specifically states that data:, blob:, and filesystem URLs
    // should not be captured by a '*"" source
    // (http://www.w3.org/TR/CSP2/#source-list-guid-matching). Thus, in the
    // case of a full wildcard, data:, blob:, and filesystem: URLs are
    // explicitly checked for in the source list before allowing them through.
    if (m_allowStar) {
        if (url.protocolIs(""blob"") || url.protocolIs(""data"") || url.protocolIs(""filesystem""))
            return hasSourceMatchInList(url, redirectStatus);
    }
    return hasSourceMatchInList(effectiveURL, redirectStatus);
","    if (m_allowStar)
    for (size_t i = 0; i < m_list.size(); ++i) {
        if (m_list[i].matches(effectiveURL, redirectStatus))
            return true;
    }
    return false;
",,"@@ -45,20 +45,23 @@ CSPSourceList::CSPSourceList(ContentSecurityPolicy* policy, const String& direct
 
 bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
 {
-    if (m_allowStar)
+    // The CSP spec specifically states that data:, blob:, and filesystem URLs
+    // should not be captured by a '*"" source
+    // (http://www.w3.org/TR/CSP2/#source-list-guid-matching). Thus, in the
+    // case of a full wildcard, data:, blob:, and filesystem: URLs are
+    // explicitly checked for in the source list before allowing them through.
+    if (m_allowStar) {
+        if (url.protocolIs(""blob"") || url.protocolIs(""data"") || url.protocolIs(""filesystem""))
+            return hasSourceMatchInList(url, redirectStatus);
         return true;
+    }
 
     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 
     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))
         return true;
 
-    for (size_t i = 0; i < m_list.size(); ++i) {
-        if (m_list[i].matches(effectiveURL, redirectStatus))
-            return true;
-    }
-
-    return false;
+    return hasSourceMatchInList(effectiveURL, redirectStatus);
 }
 
 bool CSPSourceList::allowInline() const
@@ -490,5 +493,14 @@ void CSPSourceList::addSourceHash(const ContentSecurityPolicyHashAlgorithm& algo
     m_hashAlgorithmsUsed |= algorithm;
 }
 
+bool CSPSourceList::hasSourceMatchInList(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
+{
+    for (size_t i = 0; i < m_list.size(); ++i) {
+        if (m_list[i].matches(url, redirectStatus))
+            return true;
+    }
+
+    return false;
+}
 
 } // namespace blink",Chrome,5d0e9f824e05523e03dabc0e341b9f8f17a72bb0,4b86b23ef2edc67efd12a111ad4ddf83ca53329c,1," bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
 {
//flaw_line_below:
    if (m_allowStar)
//fix_flaw_line_below:
//    // The CSP spec specifically states that data:, blob:, and filesystem URLs
//fix_flaw_line_below:
//    // should not be captured by a '*"" source
//fix_flaw_line_below:
//    // (http://www.w3.org/TR/CSP2/#source-list-guid-matching). Thus, in the
//fix_flaw_line_below:
//    // case of a full wildcard, data:, blob:, and filesystem: URLs are
//fix_flaw_line_below:
//    // explicitly checked for in the source list before allowing them through.
//fix_flaw_line_below:
//    if (m_allowStar) {
//fix_flaw_line_below:
//        if (url.protocolIs(""blob"") || url.protocolIs(""data"") || url.protocolIs(""filesystem""))
//fix_flaw_line_below:
//            return hasSourceMatchInList(url, redirectStatus);
         return true;
//fix_flaw_line_below:
//    }
 
     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 
     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))
         return true;
 
//flaw_line_below:
    for (size_t i = 0; i < m_list.size(); ++i) {
//flaw_line_below:
        if (m_list[i].matches(effectiveURL, redirectStatus))
//flaw_line_below:
            return true;
//flaw_line_below:
    }
//flaw_line_below:

//flaw_line_below:
    return false;
//fix_flaw_line_below:
//    return hasSourceMatchInList(effectiveURL, redirectStatus);
 }
",185666," bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
 {
    if (m_allowStar)
         return true;
 
     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 
     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))
         return true;
 
    for (size_t i = 0; i < m_list.size(); ++i) {
        if (m_list[i].matches(effectiveURL, redirectStatus))
            return true;
    }
    return false;
 }
"," bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const
 {
    // The CSP spec specifically states that data:, blob:, and filesystem URLs
    // should not be captured by a '*"" source
    // (http://www.w3.org/TR/CSP2/#source-list-guid-matching). Thus, in the
    // case of a full wildcard, data:, blob:, and filesystem: URLs are
    // explicitly checked for in the source list before allowing them through.
    if (m_allowStar) {
        if (url.protocolIs(""blob"") || url.protocolIs(""data"") || url.protocolIs(""filesystem""))
            return hasSourceMatchInList(url, redirectStatus);
         return true;
    }
 
     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 
     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))
         return true;
 
    return hasSourceMatchInList(effectiveURL, redirectStatus);
 }
","The `matches` function in the `CSPSourceList` class determines if a given URL complies with the content security policy (CSP) rules defined in the object. It first checks if wildcard matching is allowed (`m_allowStar`), returning true if so. If not, it evaluates the URL's effective form based on whether it should use an inner URL. It then checks if self-referencing is permitted (`m_allowSelf`) and if the effective URL matches the policy's self URL. Finally, it iterates through a list of defined sources (`m_list`), returning true if any source matches the effective URL and redirect status; otherwise, it returns false.","The provided code defines a method that checks if a specified URL adheres to a set of content security policy rules. It first allows for a universal match if a wildcard option is enabled. If not, it determines the effective URL based on specific conditions related to inner URLs. The method then verifies if self-referencing is allowed and if the effective URL matches a predefined self-reference. Finally, it iterates through a list of sources to see if any of them match the effective URL and its associated redirect status, returning true for a match or false if none are found.","The vulnerability in the original code stemmed from allowing wildcard matching for all URLs, including potentially unsafe ones like data:, blob:, and filesystem: URLs, which are explicitly excluded by the Content Security Policy (CSP) specification. This could lead to security risks, as these protocols can expose sensitive data. The fix introduced checks to ensure that if wildcard matching is enabled, the code first verifies whether the URL's protocol is one of the excluded types. If it is, the method calls `hasSourceMatchInList` to determine if the URL is explicitly allowed, thereby preventing unauthorized access through wildcard matches.","The vulnerability in the original code allowed wildcard matching for all URLs, including potentially harmful types such as data:, blob:, and filesystem: URLs, which are explicitly prohibited by the Content Security Policy (CSP) specification. This oversight could lead to security risks, as these protocols can be exploited to access sensitive information. The fix implemented checks to ensure that when wildcard matching is enabled, the code first verifies if the URL belongs to any of the excluded types. If it does, the code then assesses whether the URL is explicitly permitted, thereby preventing unauthorized access through wildcard matches.","The vulnerability was fixed by adding specific checks for URLs with protocols such as data:, blob:, and filesystem: when wildcard matching is enabled. In the updated code, if `m_allowStar` is true, the method first checks if the URL's protocol is one of the excluded types. If it is, the code calls `hasSourceMatchInList` to determine if the URL is explicitly allowed. This ensures that even with wildcard matching, potentially unsafe URLs are not automatically permitted, thereby aligning the implementation with the CSP specification and enhancing overall security.","The vulnerability was addressed by implementing specific checks to prevent wildcard matching for certain unsafe URL protocols that are explicitly excluded by the Content Security Policy specification. The updated code first verifies if wildcard matching is enabled and then checks if the URL belongs to any of the prohibited types. If it does, the code assesses whether the URL is explicitly allowed through a separate matching function. This approach ensures that potentially harmful URLs cannot bypass security measures, thereby aligning the implementation with established security standards and reducing the risk of unauthorized access.","CWE-346, CWE-749, CWE-183, CWE-284, CWE-601, CWE-287, CWE-611, CWE-159, CWE-345, CWE-20",N,-1
74,74,186091,186091,,Remote,Not required,Partial,CVE-2016-1631,https://www.cvedetails.com/cve/CVE-2016-1631/,CWE-264,Medium,Partial,Partial,,2016-03-05,6.8,"The PPB_Flash_MessageLoop_Impl::InternalRun function in content/renderer/pepper/ppb_flash_message_loop_impl.cc in the Pepper plugin in Google Chrome before 49.0.2623.75 mishandles nested message loops, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.",2016-12-02,Bypass ,4,https://github.com/chromium/chromium/commit/dd77c2a41c72589d929db0592565125ca629fb2c,dd77c2a41c72589d929db0592565125ca629fb2c,"Fix PPB_Flash_MessageLoop.

This CL suspends script callbacks and resource loads while running nested message loop using PPB_Flash_MessageLoop.

BUG=569496

Review URL: https://codereview.chromium.org/1559113002

Cr-Commit-Position: refs/heads/master@{#374529}",0,content/renderer/pepper/ppb_flash_message_loop_impl.cc,"{""sha"": ""279bfc99449026df2d8c842a91b95a674a451c07"", ""filename"": ""chrome/test/ppapi/ppapi_browsertest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/dd77c2a41c72589d929db0592565125ca629fb2c/chrome/test/ppapi/ppapi_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dd77c2a41c72589d929db0592565125ca629fb2c/chrome/test/ppapi/ppapi_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/ppapi/ppapi_browsertest.cc?ref=dd77c2a41c72589d929db0592565125ca629fb2c"", ""patch"": ""@@ -1105,6 +1105,7 @@ IN_PROC_BROWSER_TEST_F(PPAPINaClPNaClNonSfiTest, MAYBE_PNACL_NONSFI(View)) {\n   RunTest( \\\n       LIST_TEST(FlashMessageLoop_Basics) \\\n       LIST_TEST(FlashMessageLoop_RunWithoutQuit) \\\n+      LIST_TEST(FlashMessageLoop_SuspendScriptCallbackWhileRunning) \\\n   )\n \n #if defined(OS_LINUX)  // Disabled due to flakiness http://crbug.com/316925""}<_**next**_>{""sha"": ""89ac5adde7a0e7de7fc17cdfa3527311a31cee90"", ""filename"": ""content/renderer/pepper/ppb_flash_message_loop_impl.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/dd77c2a41c72589d929db0592565125ca629fb2c/content/renderer/pepper/ppb_flash_message_loop_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dd77c2a41c72589d929db0592565125ca629fb2c/content/renderer/pepper/ppb_flash_message_loop_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/pepper/ppb_flash_message_loop_impl.cc?ref=dd77c2a41c72589d929db0592565125ca629fb2c"", ""patch"": ""@@ -7,6 +7,7 @@\n #include \""base/callback.h\""\n #include \""base/message_loop/message_loop.h\""\n #include \""ppapi/c/pp_errors.h\""\n+#include \""third_party/WebKit/public/web/WebView.h\""\n \n using ppapi::thunk::PPB_Flash_MessageLoop_API;\n \n@@ -87,7 +88,11 @@ int32_t PPB_Flash_MessageLoop_Impl::InternalRun(\n   {\n     base::MessageLoop::ScopedNestableTaskAllower allow(\n         base::MessageLoop::current());\n+    blink::WebView::willEnterModalLoop();\n+\n     base::MessageLoop::current()->Run();\n+\n+    blink::WebView::didExitModalLoop();\n   }\n   // Don't access data members of the class below.\n ""}<_**next**_>{""sha"": ""2043cbeb11c6b01f8662ccf28702a9006268f3f9"", ""filename"": ""ppapi/tests/test_flash_message_loop.cc"", ""status"": ""modified"", ""additions"": 111, ""deletions"": 6, ""changes"": 117, ""blob_url"": ""https://github.com/chromium/chromium/blob/dd77c2a41c72589d929db0592565125ca629fb2c/ppapi/tests/test_flash_message_loop.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dd77c2a41c72589d929db0592565125ca629fb2c/ppapi/tests/test_flash_message_loop.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ppapi/tests/test_flash_message_loop.cc?ref=dd77c2a41c72589d929db0592565125ca629fb2c"", ""patch"": ""@@ -5,27 +5,97 @@\n #include \""ppapi/tests/test_flash_message_loop.h\""\n \n #include \""ppapi/c/pp_macros.h\""\n+#include \""ppapi/c/ppb_var.h\""\n #include \""ppapi/cpp/core.h\""\n+#include \""ppapi/cpp/dev/scriptable_object_deprecated.h\""\n #include \""ppapi/cpp/logging.h\""\n #include \""ppapi/cpp/module.h\""\n #include \""ppapi/cpp/private/flash_message_loop.h\""\n #include \""ppapi/tests/testing_instance.h\""\n \n+namespace {\n+\n+const char kDidRunScriptCallback[] = \""DidRunScriptCallback\"";\n+\n+}  // namespace\n+\n+class TestFlashMessageLoop::InstanceSO\n+    : public pp::deprecated::ScriptableObject {\n+ public:\n+  explicit InstanceSO(TestFlashMessageLoop* owner) : owner_(owner) {}\n+\n+  ~InstanceSO() override {\n+    if (owner_)\n+      owner_->clear_instance_so();\n+  }\n+\n+  // pp::deprecated::ScriptableObject overrides.\n+  bool HasMethod(const pp::Var& name, pp::Var* exception) override {\n+    if (!name.is_string())\n+      return false;\n+    return name.AsString() == kDidRunScriptCallback;\n+  }\n+\n+  pp::Var Call(const pp::Var& method_name,\n+               const std::vector<pp::Var>& args,\n+               pp::Var* exception) override {\n+    if (!method_name.is_string())\n+      return false;\n+    std::string name = method_name.AsString();\n+\n+    if (name == kDidRunScriptCallback) {\n+      if (args.size() != 0) {\n+        *exception = pp::Var(\""Bad argument to DidRunScriptCallback()\"");\n+      } else if (owner_) {\n+        owner_->DidRunScriptCallback();\n+      }\n+    } else {\n+      *exception = pp::Var(\""Bad function call\"");\n+    }\n+\n+    return pp::Var();\n+  }\n+\n+  void clear_owner() { owner_ = nullptr; }\n+\n+ private:\n+  TestFlashMessageLoop* owner_;\n+};\n+\n REGISTER_TEST_CASE(FlashMessageLoop);\n \n TestFlashMessageLoop::TestFlashMessageLoop(TestingInstance* instance)\n     : TestCase(instance),\n-      message_loop_(NULL),\n-      callback_factory_(this) {\n-}\n+      message_loop_(nullptr),\n+      instance_so_(nullptr),\n+      suspend_script_callback_result_(false),\n+      callback_factory_(this) {}\n \n TestFlashMessageLoop::~TestFlashMessageLoop() {\n   PP_DCHECK(!message_loop_);\n+\n+  ResetTestObject();\n+  if (instance_so_)\n+    instance_so_->clear_owner();\n }\n \n void TestFlashMessageLoop::RunTests(const std::string& filter) {\n   RUN_TEST(Basics, filter);\n   RUN_TEST(RunWithoutQuit, filter);\n+  RUN_TEST(SuspendScriptCallbackWhileRunning, filter);\n+}\n+\n+void TestFlashMessageLoop::DidRunScriptCallback() {\n+  // Script callbacks are not supposed to run while the Flash message loop is\n+  // running.\n+  if (message_loop_)\n+    suspend_script_callback_result_ = false;\n+}\n+\n+pp::deprecated::ScriptableObject* TestFlashMessageLoop::CreateTestObject() {\n+  if (!instance_so_)\n+    instance_so_ = new InstanceSO(this);\n+  return instance_so_;\n }\n \n std::string TestFlashMessageLoop::TestBasics() {\n@@ -38,7 +108,7 @@ std::string TestFlashMessageLoop::TestBasics() {\n \n   ASSERT_TRUE(message_loop_);\n   delete message_loop_;\n-  message_loop_ = NULL;\n+  message_loop_ = nullptr;\n \n   ASSERT_EQ(PP_OK, result);\n   PASS();\n@@ -54,14 +124,49 @@ std::string TestFlashMessageLoop::TestRunWithoutQuit() {\n \n   if (message_loop_) {\n     delete message_loop_;\n-    message_loop_ = NULL;\n+    message_loop_ = nullptr;\n     ASSERT_TRUE(false);\n   }\n \n   ASSERT_EQ(PP_ERROR_ABORTED, result);\n   PASS();\n }\n \n+std::string TestFlashMessageLoop::TestSuspendScriptCallbackWhileRunning() {\n+  suspend_script_callback_result_ = true;\n+  message_loop_ = new pp::flash::MessageLoop(instance_);\n+\n+  pp::CompletionCallback callback = callback_factory_.NewCallback(\n+      &TestFlashMessageLoop::TestSuspendScriptCallbackTask);\n+  pp::Module::Get()->core()->CallOnMainThread(0, callback);\n+  message_loop_->Run();\n+\n+  ASSERT_TRUE(message_loop_);\n+  delete message_loop_;\n+  message_loop_ = nullptr;\n+\n+  ASSERT_TRUE(suspend_script_callback_result_);\n+  PASS();\n+}\n+\n+void TestFlashMessageLoop::TestSuspendScriptCallbackTask(int32_t unused) {\n+  pp::Var exception;\n+  pp::Var rev = instance_->ExecuteScript(\n+      \""(function() {\""\n+      \""  function delayedHandler() {\""\n+      \""    document.getElementById('plugin').DidRunScriptCallback();\""\n+      \""  }\""\n+      \""  setTimeout(delayedHandler, 1);\""\n+      \""})()\"",\n+      &exception);\n+  if (!exception.is_undefined())\n+    suspend_script_callback_result_ = false;\n+\n+  pp::CompletionCallback callback =\n+      callback_factory_.NewCallback(&TestFlashMessageLoop::QuitMessageLoopTask);\n+  pp::Module::Get()->core()->CallOnMainThread(500, callback);\n+}\n+\n void TestFlashMessageLoop::QuitMessageLoopTask(int32_t unused) {\n   if (message_loop_)\n     message_loop_->Quit();\n@@ -72,7 +177,7 @@ void TestFlashMessageLoop::QuitMessageLoopTask(int32_t unused) {\n void TestFlashMessageLoop::DestroyMessageLoopResourceTask(int32_t unused) {\n   if (message_loop_) {\n     delete message_loop_;\n-    message_loop_ = NULL;\n+    message_loop_ = nullptr;\n   } else {\n     PP_NOTREACHED();\n   }""}<_**next**_>{""sha"": ""31b27916cc2d8b006f8bcd0125975bf157f5f492"", ""filename"": ""ppapi/tests/test_flash_message_loop.h"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 2, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/dd77c2a41c72589d929db0592565125ca629fb2c/ppapi/tests/test_flash_message_loop.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/dd77c2a41c72589d929db0592565125ca629fb2c/ppapi/tests/test_flash_message_loop.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ppapi/tests/test_flash_message_loop.h?ref=dd77c2a41c72589d929db0592565125ca629fb2c"", ""patch"": ""@@ -20,19 +20,37 @@ class MessageLoop;\n class TestFlashMessageLoop : public TestCase {\n  public:\n   explicit TestFlashMessageLoop(TestingInstance* instance);\n-  virtual ~TestFlashMessageLoop();\n+  ~TestFlashMessageLoop() override;\n \n   // TestCase implementation.\n-  virtual void RunTests(const std::string& filter);\n+  void RunTests(const std::string& filter) override;\n+\n+  void clear_instance_so() { instance_so_ = nullptr; }\n+\n+  void DidRunScriptCallback();\n \n  private:\n+  // ScriptableObject implementation.\n+  class InstanceSO;\n+\n+  // TestCase protected overrides.\n+  pp::deprecated::ScriptableObject* CreateTestObject() override;\n+\n   std::string TestBasics();\n   std::string TestRunWithoutQuit();\n+  std::string TestSuspendScriptCallbackWhileRunning();\n \n+  void TestSuspendScriptCallbackTask(int32_t unused);\n   void QuitMessageLoopTask(int32_t unused);\n   void DestroyMessageLoopResourceTask(int32_t unused);\n \n   pp::flash::MessageLoop* message_loop_;\n+\n+  // The scriptable object and result storage for the\n+  // SuspendScriptCallbackWhileRunning test.\n+  InstanceSO* instance_so_;\n+  bool suspend_script_callback_result_;\n+\n   pp::CompletionCallbackFactory<TestFlashMessageLoop> callback_factory_;\n };\n ""}","int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
    const RunFromHostProxyCallback& callback) {
  if (state_->run_called()) {
    if (!callback.is_null())
      callback.Run(PP_ERROR_FAILED);
    return PP_ERROR_FAILED;
  }
  state_->set_run_called();
  state_->set_run_callback(callback);

  scoped_refptr<State> state_protector(state_);
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
    blink::WebView::willEnterModalLoop();

     base::MessageLoop::current()->Run();

    blink::WebView::didExitModalLoop();
   }
 
  return state_protector->result();
}
","int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
    const RunFromHostProxyCallback& callback) {
  if (state_->run_called()) {
    if (!callback.is_null())
      callback.Run(PP_ERROR_FAILED);
    return PP_ERROR_FAILED;
  }
  state_->set_run_called();
  state_->set_run_callback(callback);

  scoped_refptr<State> state_protector(state_);
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
     base::MessageLoop::current()->Run();
   }
 
  return state_protector->result();
}
",C,"    blink::WebView::willEnterModalLoop();


    blink::WebView::didExitModalLoop();
",,,"@@ -7,6 +7,7 @@
 #include ""base/callback.h""
 #include ""base/message_loop/message_loop.h""
 #include ""ppapi/c/pp_errors.h""
+#include ""third_party/WebKit/public/web/WebView.h""
 
 using ppapi::thunk::PPB_Flash_MessageLoop_API;
 
@@ -87,7 +88,11 @@ int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
+    blink::WebView::willEnterModalLoop();
+
     base::MessageLoop::current()->Run();
+
+    blink::WebView::didExitModalLoop();
   }
   // Don't access data members of the class below.
 ",Chrome,dd77c2a41c72589d929db0592565125ca629fb2c,fc51e9e93e12a0f3d6b4f3e1f33c5e252d0dff95,1,"int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
    const RunFromHostProxyCallback& callback) {
  if (state_->run_called()) {
    if (!callback.is_null())
      callback.Run(PP_ERROR_FAILED);
    return PP_ERROR_FAILED;
  }
  state_->set_run_called();
  state_->set_run_callback(callback);

  // It is possible that the PPB_Flash_MessageLoop_Impl object has been
  // destroyed when the nested message loop exits.
  scoped_refptr<State> state_protector(state_);
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
//fix_flaw_line_below:
//    blink::WebView::willEnterModalLoop();
//fix_flaw_line_below:
//
     base::MessageLoop::current()->Run();
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    blink::WebView::didExitModalLoop();
   }
   // Don't access data members of the class below.
 
  return state_protector->result();
}
",186091,"int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
    const RunFromHostProxyCallback& callback) {
  if (state_->run_called()) {
    if (!callback.is_null())
      callback.Run(PP_ERROR_FAILED);
    return PP_ERROR_FAILED;
  }
  state_->set_run_called();
  state_->set_run_callback(callback);

  scoped_refptr<State> state_protector(state_);
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
     base::MessageLoop::current()->Run();
   }
 
  return state_protector->result();
}
","int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
    const RunFromHostProxyCallback& callback) {
  if (state_->run_called()) {
    if (!callback.is_null())
      callback.Run(PP_ERROR_FAILED);
    return PP_ERROR_FAILED;
  }
  state_->set_run_called();
  state_->set_run_callback(callback);

  scoped_refptr<State> state_protector(state_);
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
    blink::WebView::willEnterModalLoop();

     base::MessageLoop::current()->Run();

    blink::WebView::didExitModalLoop();
   }
 
  return state_protector->result();
}
","The `InternalRun` function in the `PPB_Flash_MessageLoop_Impl` class manages the execution of a message loop while ensuring that it is only run once. It first checks if the run has already been initiated; if so, it invokes the provided callback with a failure error and returns. If not, it marks the run as called and stores the callback. The function then allows nested tasks in the current message loop and executes it. Finally, it returns the result from the state object, which encapsulates the outcome of the message loop execution.","The provided code implements a method that manages the execution of a message loop, ensuring it is only executed once. It first checks if the execution has already been initiated; if so, it triggers a callback with an error indication and exits. If the execution is allowed, it marks the process as started and stores the callback for later use. The method then permits nested tasks within the current message loop and proceeds to run it. Finally, it retrieves and returns the result of the execution from an associated state object, reflecting the outcome of the message loop's operation.","The vulnerability in the original code stemmed from the potential for script callbacks and resource loads to continue executing while the nested message loop was running, which could lead to unexpected behavior or race conditions. This issue was addressed in the fixed code by introducing calls to `blink::WebView::willEnterModalLoop()` before running the message loop and `blink::WebView::didExitModalLoop()` afterward. These additions effectively suspend script callbacks and resource loads during the execution of the nested message loop, ensuring that the environment remains stable and preventing interference from concurrent operations.","The vulnerability in the original code allowed script callbacks and resource loads to execute concurrently while a nested message loop was running, potentially leading to race conditions and unpredictable behavior. This issue was resolved in the updated code by implementing mechanisms to suspend these operations during the execution of the nested message loop. By ensuring that script callbacks and resource loads are paused, the modified code creates a controlled environment that prevents interference and maintains stability, thereby addressing the underlying issue and enhancing the overall reliability of the message loop functionality.","The vulnerability was fixed by adding calls to `blink::WebView::willEnterModalLoop()` and `blink::WebView::didExitModalLoop()` around the execution of the nested message loop. These functions effectively suspend script callbacks and resource loads before entering the modal loop, ensuring that no concurrent operations can interfere while the message loop is running. This change prevents potential race conditions and ensures a stable execution environment. By managing the state of script execution during the nested loop, the updated code enhances the reliability and predictability of the message loop's behavior.","The vulnerability was fixed by implementing mechanisms to suspend script callbacks and resource loads during the execution of the nested message loop. This was achieved by introducing specific calls that manage the state of the environment before and after the loop runs. By pausing these operations, the updated code prevents any concurrent actions from interfering with the message loop's execution, thereby eliminating the risk of race conditions and ensuring a stable and predictable behavior. This enhancement significantly improves the reliability of the system while the nested loop is active.","CWE-362, CWE-366, CWE-367, CWE-664, CWE-666, CWE-364, CWE-371, CWE-662, CWE-609, CWE-1088",N,-1
75,75,187364,187364,,Remote,Not required,Partial,CVE-2015-3845,https://www.cvedetails.com/cve/CVE-2015-3845/,CWE-264,Medium,Partial,Partial,,2015-09-30,6.8,"The Parcel::appendFrom function in libs/binder/Parcel.cpp in Binder in Android before 5.1.1 LMY48M does not consider parcel boundaries during identification of binder objects in an append operation, which allows attackers to obtain a different application's privileges via a crafted application, aka internal bug 17312693.",2015-10-01,,1,https://android.googlesource.com/platform/frameworks/native/+/e68cbc3e9e66df4231e70efa3e9c41abc12aea20,e68cbc3e9e66df4231e70efa3e9c41abc12aea20,"Disregard alleged binder entities beyond parcel bounds

When appending one parcel's contents to another, ignore binder
objects within the source Parcel that appear to lie beyond the
formal bounds of that Parcel's data buffer.

Bug 17312693

Change-Id: If592a260f3fcd9a56fc160e7feb2c8b44c73f514
(cherry picked from commit 27182be9f20f4f5b48316666429f09b9ecc1f22e)
",1,libs/binder/Parcel.cpp,"{""filename"": ""libs/binder/Parcel.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/e68cbc3e9e66df4231e70efa3e9c41abc12aea20/libs/binder/Parcel.cpp"", ""patch"": ""@@ -411,7 +411,7 @@\n\n     // Count objects in range\n     for (int i = 0; i < (int) size; i++) {\n         size_t off = objects[i];\n-        if ((off >= offset) && (off < offset + len)) {\n+        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {\n             if (firstIndex == -1) {\n                 firstIndex = i;\n             }\n""}","status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
{
 const sp<ProcessState> proc(ProcessState::self());
 status_t err;
 const uint8_t *data = parcel->mData;
 const binder_size_t *objects = parcel->mObjects;
 size_t size = parcel->mObjectsSize;
 int startPos = mDataPos;
 int firstIndex = -1, lastIndex = -2;

 if (len == 0) {
 return NO_ERROR;
 }

 if ((offset > parcel->mDataSize)
 || (len > parcel->mDataSize)
 || (offset + len > parcel->mDataSize)) {
 return BAD_VALUE;
 }


     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
            lastIndex = i;
 }
 }
 int numObjects = lastIndex - firstIndex + 1;

 if ((mDataSize+len) > mDataCapacity) {
        err = growData(len);
 if (err != NO_ERROR) {
 return err;
 }
 }

    memcpy(mData + mDataPos, data + offset, len);
    mDataPos += len;
    mDataSize += len;

    err = NO_ERROR;

 if (numObjects > 0) {
 if (mObjectsCapacity < mObjectsSize + numObjects) {
 int newSize = ((mObjectsSize + numObjects)*3)/2;
 binder_size_t *objects =
 (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
 if (objects == (binder_size_t*)0) {
 return NO_MEMORY;
 }
            mObjects = objects;
            mObjectsCapacity = newSize;
 }

 int idx = mObjectsSize;
 for (int i = firstIndex; i <= lastIndex; i++) {
 size_t off = objects[i] - offset + startPos;
            mObjects[idx++] = off;
            mObjectsSize++;

            flat_binder_object* flat
 = reinterpret_cast<flat_binder_object*>(mData + off);
            acquire_object(proc, *flat, this);

 if (flat->type == BINDER_TYPE_FD) {
                flat->handle = dup(flat->handle);
                flat->cookie = 1;
                mHasFds = mFdsKnown = true;
 if (!mAllowFds) {
                    err = FDS_NOT_ALLOWED;
 }
 }
 }
 }

 return err;
}
","status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
{
 const sp<ProcessState> proc(ProcessState::self());
 status_t err;
 const uint8_t *data = parcel->mData;
 const binder_size_t *objects = parcel->mObjects;
 size_t size = parcel->mObjectsSize;
 int startPos = mDataPos;
 int firstIndex = -1, lastIndex = -2;

 if (len == 0) {
 return NO_ERROR;
 }

 if ((offset > parcel->mDataSize)
 || (len > parcel->mDataSize)
 || (offset + len > parcel->mDataSize)) {
 return BAD_VALUE;
 }


     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
        if ((off >= offset) && (off < offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
            lastIndex = i;
 }
 }
 int numObjects = lastIndex - firstIndex + 1;

 if ((mDataSize+len) > mDataCapacity) {
        err = growData(len);
 if (err != NO_ERROR) {
 return err;
 }
 }

    memcpy(mData + mDataPos, data + offset, len);
    mDataPos += len;
    mDataSize += len;

    err = NO_ERROR;

 if (numObjects > 0) {
 if (mObjectsCapacity < mObjectsSize + numObjects) {
 int newSize = ((mObjectsSize + numObjects)*3)/2;
 binder_size_t *objects =
 (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
 if (objects == (binder_size_t*)0) {
 return NO_MEMORY;
 }
            mObjects = objects;
            mObjectsCapacity = newSize;
 }

 int idx = mObjectsSize;
 for (int i = firstIndex; i <= lastIndex; i++) {
 size_t off = objects[i] - offset + startPos;
            mObjects[idx++] = off;
            mObjectsSize++;

            flat_binder_object* flat
 = reinterpret_cast<flat_binder_object*>(mData + off);
            acquire_object(proc, *flat, this);

 if (flat->type == BINDER_TYPE_FD) {
                flat->handle = dup(flat->handle);
                flat->cookie = 1;
                mHasFds = mFdsKnown = true;
 if (!mAllowFds) {
                    err = FDS_NOT_ALLOWED;
 }
 }
 }
 }

 return err;
}
",C,"        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {
","        if ((off >= offset) && (off < offset + len)) {
",,"@@ -411,7 +411,7 @@

     // Count objects in range
     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
-        if ((off >= offset) && (off < offset + len)) {
+        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
",Android,https://android.googlesource.com/platform/frameworks/native/+/e68cbc3e9e66df4231e70efa3e9c41abc12aea20/,https://android.googlesource.com/platform/frameworks/native/+/e68cbc3e9e66df4231e70efa3e9c41abc12aea20%5E/,1,"status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
{
 const sp<ProcessState> proc(ProcessState::self());
 status_t err;
 const uint8_t *data = parcel->mData;
 const binder_size_t *objects = parcel->mObjects;
 size_t size = parcel->mObjectsSize;
 int startPos = mDataPos;
 int firstIndex = -1, lastIndex = -2;

 if (len == 0) {
 return NO_ERROR;
 }

 // range checks against the source parcel size
 if ((offset > parcel->mDataSize)
 || (len > parcel->mDataSize)
 || (offset + len > parcel->mDataSize)) {
 return BAD_VALUE;
 }


     // Count objects in range
     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
//flaw_line_below:
        if ((off >= offset) && (off < offset + len)) {
//fix_flaw_line_below:
//        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
            lastIndex = i;
 }
 }
 int numObjects = lastIndex - firstIndex + 1;

 if ((mDataSize+len) > mDataCapacity) {
 // grow data
        err = growData(len);
 if (err != NO_ERROR) {
 return err;
 }
 }

 // append data
    memcpy(mData + mDataPos, data + offset, len);
    mDataPos += len;
    mDataSize += len;

    err = NO_ERROR;

 if (numObjects > 0) {
 // grow objects
 if (mObjectsCapacity < mObjectsSize + numObjects) {
 int newSize = ((mObjectsSize + numObjects)*3)/2;
 binder_size_t *objects =
 (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
 if (objects == (binder_size_t*)0) {
 return NO_MEMORY;
 }
            mObjects = objects;
            mObjectsCapacity = newSize;
 }

 // append and acquire objects
 int idx = mObjectsSize;
 for (int i = firstIndex; i <= lastIndex; i++) {
 size_t off = objects[i] - offset + startPos;
            mObjects[idx++] = off;
            mObjectsSize++;

            flat_binder_object* flat
 = reinterpret_cast<flat_binder_object*>(mData + off);
            acquire_object(proc, *flat, this);

 if (flat->type == BINDER_TYPE_FD) {
 // If this is a file descriptor, we need to dup it so the
 // new Parcel now owns its own fd, and can declare that we
 // officially know we have fds.
                flat->handle = dup(flat->handle);
                flat->cookie = 1;
                mHasFds = mFdsKnown = true;
 if (!mAllowFds) {
                    err = FDS_NOT_ALLOWED;
 }
 }
 }
 }

 return err;
}
",187364,"status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
{
 const sp<ProcessState> proc(ProcessState::self());
 status_t err;
 const uint8_t *data = parcel->mData;
 const binder_size_t *objects = parcel->mObjects;
 size_t size = parcel->mObjectsSize;
 int startPos = mDataPos;
 int firstIndex = -1, lastIndex = -2;

 if (len == 0) {
 return NO_ERROR;
 }

 if ((offset > parcel->mDataSize)
 || (len > parcel->mDataSize)
 || (offset + len > parcel->mDataSize)) {
 return BAD_VALUE;
 }


     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
        if ((off >= offset) && (off < offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
            lastIndex = i;
 }
 }
 int numObjects = lastIndex - firstIndex + 1;

 if ((mDataSize+len) > mDataCapacity) {
        err = growData(len);
 if (err != NO_ERROR) {
 return err;
 }
 }

    memcpy(mData + mDataPos, data + offset, len);
    mDataPos += len;
    mDataSize += len;

    err = NO_ERROR;

 if (numObjects > 0) {
 if (mObjectsCapacity < mObjectsSize + numObjects) {
 int newSize = ((mObjectsSize + numObjects)*3)/2;
 binder_size_t *objects =
 (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
 if (objects == (binder_size_t*)0) {
 return NO_MEMORY;
 }
            mObjects = objects;
            mObjectsCapacity = newSize;
 }

 int idx = mObjectsSize;
 for (int i = firstIndex; i <= lastIndex; i++) {
 size_t off = objects[i] - offset + startPos;
            mObjects[idx++] = off;
            mObjectsSize++;

            flat_binder_object* flat
 = reinterpret_cast<flat_binder_object*>(mData + off);
            acquire_object(proc, *flat, this);

 if (flat->type == BINDER_TYPE_FD) {
                flat->handle = dup(flat->handle);
                flat->cookie = 1;
                mHasFds = mFdsKnown = true;
 if (!mAllowFds) {
                    err = FDS_NOT_ALLOWED;
 }
 }
 }
 }

 return err;
}
","status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
{
 const sp<ProcessState> proc(ProcessState::self());
 status_t err;
 const uint8_t *data = parcel->mData;
 const binder_size_t *objects = parcel->mObjects;
 size_t size = parcel->mObjectsSize;
 int startPos = mDataPos;
 int firstIndex = -1, lastIndex = -2;

 if (len == 0) {
 return NO_ERROR;
 }

 if ((offset > parcel->mDataSize)
 || (len > parcel->mDataSize)
 || (offset + len > parcel->mDataSize)) {
 return BAD_VALUE;
 }


     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
            lastIndex = i;
 }
 }
 int numObjects = lastIndex - firstIndex + 1;

 if ((mDataSize+len) > mDataCapacity) {
        err = growData(len);
 if (err != NO_ERROR) {
 return err;
 }
 }

    memcpy(mData + mDataPos, data + offset, len);
    mDataPos += len;
    mDataSize += len;

    err = NO_ERROR;

 if (numObjects > 0) {
 if (mObjectsCapacity < mObjectsSize + numObjects) {
 int newSize = ((mObjectsSize + numObjects)*3)/2;
 binder_size_t *objects =
 (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
 if (objects == (binder_size_t*)0) {
 return NO_MEMORY;
 }
            mObjects = objects;
            mObjectsCapacity = newSize;
 }

 int idx = mObjectsSize;
 for (int i = firstIndex; i <= lastIndex; i++) {
 size_t off = objects[i] - offset + startPos;
            mObjects[idx++] = off;
            mObjectsSize++;

            flat_binder_object* flat
 = reinterpret_cast<flat_binder_object*>(mData + off);
            acquire_object(proc, *flat, this);

 if (flat->type == BINDER_TYPE_FD) {
                flat->handle = dup(flat->handle);
                flat->cookie = 1;
                mHasFds = mFdsKnown = true;
 if (!mAllowFds) {
                    err = FDS_NOT_ALLOWED;
 }
 }
 }
 }

 return err;
}
","The `Parcel::appendFrom` function is designed to append a specified segment of data from one `Parcel` object to another, while managing associated binder objects. It first checks for valid input parameters, ensuring the specified offset and length do not exceed the source parcel's data size. The function identifies binder objects within the specified range and adjusts the destination parcel's data and object arrays accordingly. If necessary, it reallocates memory to accommodate new objects and duplicates file descriptors if present. Finally, it updates the internal state of the destination parcel and returns an error status if any issues arise during the process.","The provided code defines a function that appends a segment of data from one object to another while managing associated resources. It begins by validating the input parameters to ensure they are within acceptable limits. The function then identifies any related resources within the specified data range and adjusts the destination object's data and resource arrays as needed. If the destination lacks sufficient memory, it reallocates space to accommodate the new resources. Additionally, it handles the duplication of file descriptors if present, updating the internal state accordingly and returning an error status if any issues occur during the operation.","The vulnerability in the original code arose from the lack of proper boundary checks when identifying binder objects within the specified data range. Specifically, the condition only checked if the offset was within the range but did not ensure that the entire size of the binder object was also within the bounds of the data buffer. This could lead to accessing memory outside the allocated buffer, potentially causing crashes or security issues. The fix introduced an additional check to ensure that the size of each binder object does not exceed the valid range, thereby preventing out-of-bounds access and enhancing the overall safety of the operation.","The vulnerability in the original code stemmed from inadequate boundary checks when processing binder objects during the appending of one parcel's contents to another. Specifically, the code did not ensure that the entire size of each binder object was within the valid data buffer limits, which could lead to accessing memory outside the allocated space, resulting in potential crashes or security risks. The fix implemented an additional validation step to disregard any binder objects that extended beyond the defined bounds of the data buffer, thereby preventing out-of-bounds access and enhancing the safety and stability of the operation.","The vulnerability was fixed by modifying the condition that checks the validity of binder object offsets within the data range. The updated code now includes a check to ensure that the offset of each binder object, plus the size of the binder object, does not exceed the specified range defined by the offset and length parameters. Specifically, the condition now verifies that the offset plus the size of the binder object is less than or equal to the sum of the offset and length. This change effectively prevents the inclusion of any binder objects that lie beyond the bounds of the parcel's data buffer, enhancing memory safety.","The vulnerability was addressed by enhancing the boundary checks for binder objects during the appending process. The updated code now ensures that not only the starting offset of each binder object is within the valid range, but also that the entire size of the binder object fits within the defined limits of the data buffer. This additional validation prevents any binder objects that extend beyond the allocated memory from being processed, thereby eliminating the risk of accessing out-of-bounds memory and improving the overall safety and stability of the operation.","CWE-119, CWE-125, CWE-787, CWE-788, CWE-823, CWE-129, CWE-131, CWE-789, CWE-805, CWE-120",N,-1
76,76,187420,187420,,Remote,Not required,Complete,CVE-2016-3913,https://www.cvedetails.com/cve/CVE-2016-3913/,CWE-264,Medium,Complete,Complete,,2016-10-10,9.3,"media/libmediaplayerservice/MediaPlayerService.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 does not validate a certain static_cast operation, which allows attackers to gain privileges via a crafted application, aka internal bug 30204103.",2016-11-28,+Priv ,4,https://android.googlesource.com/platform/frameworks/av/+/0c3b93c8c2027e74af642967eee5c142c8fd185d,0c3b93c8c2027e74af642967eee5c142c8fd185d,"MediaPlayerService: avoid invalid static cast

Bug: 30204103
Change-Id: Ie0dd3568a375f1e9fed8615ad3d85184bcc99028
(cherry picked from commit ee0a0e39acdcf8f97e0d6945c31ff36a06a36e9d)
",0,media/libmediaplayerservice/MediaPlayerService.cpp,"{""filename"": ""media/libmediaplayerservice/MediaPlayerService.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/0c3b93c8c2027e74af642967eee5c142c8fd185d/media/libmediaplayerservice/MediaPlayerService.cpp"", ""patch"": ""@@ -558,6 +558,12 @@\n\n     mClients.remove(client);\n }\n \n+bool MediaPlayerService::hasClient(wp<Client> client)\n+{\n+    Mutex::Autolock lock(mLock);\n+    return mClients.indexOf(client) != NAME_NOT_FOUND;\n+}\n+\n MediaPlayerService::Client::Client(\n         const sp<MediaPlayerService>& service, pid_t pid,\n         int32_t connId, const sp<IMediaPlayerClient>& client,\n@@ -1086,6 +1092,10 @@\n\n     ALOGV(\""setNextPlayer\"");\n     Mutex::Autolock l(mLock);\n     sp<Client> c = static_cast<Client*>(player.get());\n+    if (!mService->hasClient(c)) {\n+      return BAD_VALUE;\n+    }\n+\n     mNextClient = c;\n \n     if (c != NULL) {\n""}<_**next**_>{""filename"": ""media/libmediaplayerservice/MediaPlayerService.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/0c3b93c8c2027e74af642967eee5c142c8fd185d/media/libmediaplayerservice/MediaPlayerService.h"", ""patch"": ""@@ -226,6 +226,7 @@\n\n     virtual status_t            dump(int fd, const Vector<String16>& args);\n \n             void                removeClient(wp<Client> client);\n+            bool                hasClient(wp<Client> client);\n \n     enum {\n         MEDIASERVER_PROCESS_DEATH = 0,\n""}","status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
    if (!mService->hasClient(c)) {
      return BAD_VALUE;
    }

     mNextClient = c;
 
     if (c != NULL) {
 if (mAudioOutput != NULL) {
            mAudioOutput->setNextOutput(c->mAudioOutput);
 } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {
            ALOGE(""no current audio output"");
 }

 if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {
            mPlayer->setNextPlayer(mNextClient->getPlayer());
 }
 }

 return OK;
}
","status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
     mNextClient = c;
 
     if (c != NULL) {
 if (mAudioOutput != NULL) {
            mAudioOutput->setNextOutput(c->mAudioOutput);
 } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {
            ALOGE(""no current audio output"");
 }

 if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {
            mPlayer->setNextPlayer(mNextClient->getPlayer());
 }
 }

 return OK;
}
",C,"    if (!mService->hasClient(c)) {
      return BAD_VALUE;
    }

",,,"@@ -558,6 +558,12 @@

     mClients.remove(client);
 }
 
+bool MediaPlayerService::hasClient(wp<Client> client)
+{
+    Mutex::Autolock lock(mLock);
+    return mClients.indexOf(client) != NAME_NOT_FOUND;
+}
+
 MediaPlayerService::Client::Client(
         const sp<MediaPlayerService>& service, pid_t pid,
         int32_t connId, const sp<IMediaPlayerClient>& client,
@@ -1086,6 +1092,10 @@

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
+    if (!mService->hasClient(c)) {
+      return BAD_VALUE;
+    }
+
     mNextClient = c;
 
     if (c != NULL) {
",Android,https://android.googlesource.com/platform/frameworks/av/+/0c3b93c8c2027e74af642967eee5c142c8fd185d/,https://android.googlesource.com/platform/frameworks/av/+/0c3b93c8c2027e74af642967eee5c142c8fd185d%5E/,1,"status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
//fix_flaw_line_below:
//    if (!mService->hasClient(c)) {
//fix_flaw_line_below:
//      return BAD_VALUE;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     mNextClient = c;
 
     if (c != NULL) {
 if (mAudioOutput != NULL) {
            mAudioOutput->setNextOutput(c->mAudioOutput);
 } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {
            ALOGE(""no current audio output"");
 }

 if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {
            mPlayer->setNextPlayer(mNextClient->getPlayer());
 }
 }

 return OK;
}
",187420,"status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
     mNextClient = c;
 
     if (c != NULL) {
 if (mAudioOutput != NULL) {
            mAudioOutput->setNextOutput(c->mAudioOutput);
 } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {
            ALOGE(""no current audio output"");
 }

 if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {
            mPlayer->setNextPlayer(mNextClient->getPlayer());
 }
 }

 return OK;
}
","status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
    if (!mService->hasClient(c)) {
      return BAD_VALUE;
    }

     mNextClient = c;
 
     if (c != NULL) {
 if (mAudioOutput != NULL) {
            mAudioOutput->setNextOutput(c->mAudioOutput);
 } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {
            ALOGE(""no current audio output"");
 }

 if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {
            mPlayer->setNextPlayer(mNextClient->getPlayer());
 }
 }

 return OK;
}
","The `setNextPlayer` function in the `MediaPlayerService::Client` class is designed to set a new media player as the next player in a media playback sequence. It begins by locking a mutex to ensure thread safety, then retrieves the client associated with the provided player. If the client is valid, it checks for an existing audio output; if present, it sets the next audio output accordingly. If no audio output exists and a current player is active without hardware output, it logs an error. Finally, if both the current player and the next clients player are valid, it sets the next player for the current player before returning an OK status.","The function is responsible for configuring a new media player to be used in a playback sequence. It ensures thread safety by locking access during execution. Upon receiving a new player, it checks if the associated client is valid and, if so, manages the audio output settings accordingly. If an audio output is already established, it updates it to the new clients output. If no output exists and a current player is active without hardware support, it logs an error. Finally, it links the current player to the new player, completing the setup before returning a success status.","The vulnerability in the original code stemmed from the potential for an invalid static cast when retrieving the client from the provided player, which could lead to undefined behavior if the player was not associated with a valid client. This risk was mitigated in the fixed code by introducing a check using `mService->hasClient(c)` to ensure that the client is valid before proceeding with the static cast. If the client is not valid, the function returns an error status, thereby preventing the execution of subsequent code that relies on a valid client and enhancing overall stability and security.","The vulnerability in the original code arose from the risk of performing an invalid static cast, which could occur if the provided player did not correspond to a valid client. This could lead to undefined behavior or crashes during execution. The fixed code addresses this issue by implementing a validation check to ensure that the client associated with the player is legitimate before proceeding with the cast. If the client is found to be invalid, the function returns an error status, effectively preventing any further operations that depend on a valid client and enhancing the overall robustness of the code.","The vulnerability was fixed by adding a validation check using `mService->hasClient(c)` before performing the static cast of the player to a client. This ensures that the client is valid and associated with the service, preventing the risk of an invalid cast that could lead to undefined behavior. If the client is not valid, the function immediately returns `BAD_VALUE`, halting further execution. This safeguard effectively prevents any subsequent operations that rely on a valid client, such as setting the next player or audio output, thereby enhancing the stability and security of the code.","The vulnerability was addressed by introducing a validation step to ensure that the client associated with the provided player is legitimate before proceeding with any operations. This check prevents the execution of a potentially unsafe static cast, which could lead to undefined behavior if the client was invalid. If the validation fails, the function returns an error status, effectively stopping further processing. This enhancement ensures that subsequent actions that depend on a valid client are only executed when it is confirmed to be valid, thereby improving the overall safety and reliability of the code.","CWE-704, CWE-843, CWE-252, CWE-476, CWE-685, CWE-119, CWE-457, CWE-754, CWE-628, CWE-682",N,-1
77,77,187425,187425,,Remote,Not required,Complete,CVE-2016-3900,https://www.cvedetails.com/cve/CVE-2016-3900/,CWE-264,Medium,Complete,Complete,,2016-10-10,9.3,"cmds/servicemanager/service_manager.c in ServiceManager in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 does not properly restrict service registration, which allows attackers to gain privileges via a crafted application, aka internal bug 29431260.",2016-11-28,+Priv ,1,https://android.googlesource.com/platform/frameworks/native/+/047eec456943dc082e33220d28abb7df4e089f69,047eec456943dc082e33220d28abb7df4e089f69,"ServiceManager: Allow system services running as secondary users to add services

This should be reverted when all system services have been cleaned up to not
do this. A process looking up a service while running in the background will
see the service registered by the active user (assuming the service is
registered on every user switch), not the service registered by the user that
the process itself belongs to.

BUG: 30795333
Change-Id: I1b74d58be38ed358f43c163692f9e704f8f31dbe
(cherry picked from commit e6bbe69ba739c8a08837134437aaccfea5f1d943)
",1,cmds/servicemanager/service_manager.c,"{""filename"": ""cmds/servicemanager/Android.mk"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/047eec456943dc082e33220d28abb7df4e089f69/cmds/servicemanager/Android.mk"", ""patch"": ""@@ -18,7 +18,7 @@\n\n include $(BUILD_EXECUTABLE)\n \n include $(CLEAR_VARS)\n-LOCAL_SHARED_LIBRARIES := liblog libselinux\n+LOCAL_SHARED_LIBRARIES := liblog libcutils libselinux\n LOCAL_SRC_FILES := service_manager.c binder.c\n LOCAL_CFLAGS += $(svc_c_flags)\n LOCAL_MODULE := servicemanager\n""}<_**next**_>{""filename"": ""cmds/servicemanager/service_manager.c"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/047eec456943dc082e33220d28abb7df4e089f69/cmds/servicemanager/service_manager.c"", ""patch"": ""@@ -8,6 +8,8 @@\n\n #include <stdlib.h>\n #include <string.h>\n \n+#include <cutils/multiuser.h>\n+\n #include <private/android_filesystem_config.h>\n \n #include <selinux/android.h>\n@@ -122,7 +124,7 @@\n\n {\n     const char *perm = \""add\"";\n \n-    if (uid >= AID_APP) {\n+    if (multiuser_get_app_id(uid) >= AID_APP) {\n         return 0; /* Don't allow apps to register services */\n     }\n \n""}","static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (multiuser_get_app_id(uid) >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
","static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (uid >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
",C,"    if (multiuser_get_app_id(uid) >= AID_APP) {
","    if (uid >= AID_APP) {
",,"@@ -8,6 +8,8 @@

 #include <stdlib.h>
 #include <string.h>
 
+#include <cutils/multiuser.h>
+
 #include <private/android_filesystem_config.h>
 
 #include <selinux/android.h>
@@ -122,7 +124,7 @@

 {
     const char *perm = ""add"";
 
-    if (uid >= AID_APP) {
+    if (multiuser_get_app_id(uid) >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
",Android,https://android.googlesource.com/platform/frameworks/native/+/047eec456943dc082e33220d28abb7df4e089f69/,https://android.googlesource.com/platform/frameworks/native/+/047eec456943dc082e33220d28abb7df4e089f69%5E/,1,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
//flaw_line_below:
    if (uid >= AID_APP) {
//fix_flaw_line_below:
//    if (multiuser_get_app_id(uid) >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
",187425,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (uid >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
","static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (multiuser_get_app_id(uid) >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
","The function `svc_can_register` determines whether a service can be registered based on the provided parameters: a service name, its length, a service process ID (spid), and a user ID (uid). It first checks if the user ID is greater than or equal to `AID_APP`, which indicates that the caller is an application; if so, it returns 0, disallowing service registration. If the user ID is valid, it calls `check_mac_perms_from_lookup` to verify if the service process has the necessary permissions to register the service, returning 1 for success and 0 for failure.","The code defines a function that checks if a service can be registered based on the user ID and process ID provided. It first verifies if the user ID indicates an application; if so, it prevents service registration by returning a failure status. If the user ID is valid, the function then assesses whether the process has the necessary permissions to register the service. The outcome is a success status if permissions are granted, or a failure status if they are not, effectively controlling access to service registration based on user privileges.","The vulnerability in the original code stemmed from the check that restricted service registration based solely on the user ID, which could inadvertently prevent legitimate system services running as secondary users from registering services. This limitation could lead to issues where background processes could not access services registered by the active user. The fix involved modifying the user ID check to use `multiuser_get_app_id(uid)`, allowing system services associated with secondary users to register services while still preventing regular applications from doing so. This change enhances flexibility while maintaining security by ensuring only authorized services can register.","The vulnerability in the original code restricted service registration based solely on user IDs, which prevented legitimate system services running under secondary users from registering their services. This limitation could cause issues for background processes that needed to access services registered by the active user, leading to potential service availability problems. The fix involved modifying the user ID check to allow system services associated with secondary users to register services, thereby enhancing the system's flexibility while still preventing unauthorized applications from doing so. This adjustment ensures that necessary services remain accessible in multi-user environments.","The vulnerability was fixed by changing the user ID check from a direct comparison to a threshold value to using the `multiuser_get_app_id(uid)` function. This adjustment allows the system to correctly identify and permit service registration for system services running as secondary users, while still preventing regular applications from registering services. By implementing this new check, the code ensures that legitimate system services can register their services without interference, addressing the issue where background processes could not access services registered by the active user. This change enhances the overall functionality in a multi-user environment.","The vulnerability was fixed by modifying the user ID validation logic to allow system services associated with secondary users to register services. Instead of solely restricting registration based on a fixed user ID threshold, the updated logic now accurately identifies the context of the user, enabling legitimate system services to register their services while still preventing unauthorized applications from doing so. This change ensures that background processes can access services registered by the active user, thereby improving service availability and functionality in multi-user environments without compromising security.","CWE-284, CWE-287, CWE-269, CWE-863, CWE-266, CWE-732, CWE-264, CWE-346, CWE-285, CWE-270",N,-1
78,78,187427,187427,,Remote,Not required,Complete,CVE-2016-3890,https://www.cvedetails.com/cve/CVE-2016-3890/,CWE-264,High,Complete,Complete,,2016-09-11,7.6,"The Java Debug Wire Protocol (JDWP) implementation in adb/sockets.cpp in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-09-01 mishandles socket close operations, which allows attackers to gain privileges via a crafted application, aka internal bug 28347842.",2017-08-12,+Priv ,1,https://android.googlesource.com/platform/system/core/+/014b01706cc64dc9c2ad94a96f62e07c058d0b5d,014b01706cc64dc9c2ad94a96f62e07c058d0b5d,"adb: use asocket's close function when closing.

close_all_sockets was assuming that all registered local sockets used
local_socket_close as their close function. However, this is not true
for JDWP sockets.

Bug: http://b/28347842
Change-Id: I40a1174845cd33f15f30ce70828a7081cd5a087e
(cherry picked from commit 53eb31d87cb84a4212f4850bf745646e1fb12814)
",1,adb/sockets.cpp,"{""filename"": ""adb/sockets.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/core/+/014b01706cc64dc9c2ad94a96f62e07c058d0b5d/adb/sockets.cpp"", ""patch"": ""@@ -39,8 +39,6 @@\n\n #include \""sysdeps/mutex.h\""\n #include \""transport.h\""\n \n-static void local_socket_close(asocket* s);\n-\n static std::recursive_mutex& local_socket_list_lock = *new std::recursive_mutex();\n static unsigned local_socket_next_id = 1;\n \n@@ -118,7 +116,7 @@\n\n restart:\n     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {\n         if (s->transport == t || (s->peer && s->peer->transport == t)) {\n-            local_socket_close(s);\n+            s->close(s);\n             goto restart;\n         }\n     }\n""}","void close_all_sockets(atransport* t) {
    asocket* s;

 /* this is a little gross, but since s->close() *will* modify
    ** the list out from under you, your options are limited.
    */
    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
            s->close(s);
             goto restart;
         }
     }
}
","void close_all_sockets(atransport* t) {
    asocket* s;

 /* this is a little gross, but since s->close() *will* modify
    ** the list out from under you, your options are limited.
    */
    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
            local_socket_close(s);
             goto restart;
         }
     }
}
",C,"            s->close(s);
","            local_socket_close(s);
",,"@@ -39,8 +39,6 @@

 #include ""sysdeps/mutex.h""
 #include ""transport.h""
 
-static void local_socket_close(asocket* s);
-
 static std::recursive_mutex& local_socket_list_lock = *new std::recursive_mutex();
 static unsigned local_socket_next_id = 1;
 
@@ -118,7 +116,7 @@

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
-            local_socket_close(s);
+            s->close(s);
             goto restart;
         }
     }
",Android,https://android.googlesource.com/platform/system/core/+/014b01706cc64dc9c2ad94a96f62e07c058d0b5d/,https://android.googlesource.com/platform/system/core/+/014b01706cc64dc9c2ad94a96f62e07c058d0b5d%5E/,1,"void close_all_sockets(atransport* t) {
    asocket* s;

 /* this is a little gross, but since s->close() *will* modify
    ** the list out from under you, your options are limited.
    */
    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
//flaw_line_below:
            local_socket_close(s);
//fix_flaw_line_below:
//            s->close(s);
             goto restart;
         }
     }
}
",187427,"void close_all_sockets(atransport* t) {
    asocket* s;

 /* this is a little gross, but since s->close() *will* modify
    ** the list out from under you, your options are limited.
    */
    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
            local_socket_close(s);
             goto restart;
         }
     }
}
","void close_all_sockets(atransport* t) {
    asocket* s;

 /* this is a little gross, but since s->close() *will* modify
    ** the list out from under you, your options are limited.
    */
    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
            s->close(s);
             goto restart;
         }
     }
}
","The `close_all_sockets` function is designed to close all sockets associated with a specified transport object (`atransport* t`). It utilizes a recursive mutex to ensure thread safety while iterating through a linked list of sockets (`local_socket_list`). The function checks each socket to see if it is directly linked to the transport or if its peer socket is linked to the same transport. If a matching socket is found, it calls `local_socket_close` to close that socket and then restarts the iteration to account for any modifications to the list caused by the closure, ensuring all relevant sockets are processed.","The provided code defines a function that closes all network connections associated with a specific transport object. It ensures thread safety during the operation by using a locking mechanism. The function iterates through a list of network connections, checking each one to determine if it is linked to the specified transport or if its counterpart is. When a matching connection is found, it is closed, and the iteration restarts to accommodate any changes made to the list during the closure process. This approach guarantees that all relevant connections are properly closed without missing any due to list modifications.","The vulnerability in the original code stemmed from the assumption that all sockets in the list utilized a specific close function, `local_socket_close`, which was not applicable for certain socket types, such as JDWP sockets. This oversight could lead to improper closure of these sockets, potentially causing resource leaks or undefined behavior. The fix involved replacing the call to `local_socket_close` with a direct invocation of the socket's own `close` method (`s->close(s)`), ensuring that each socket is closed using its appropriate closure mechanism, thereby addressing the vulnerability and enhancing the robustness of the socket management process.","The vulnerability in the original code arose from the incorrect assumption that all sockets utilized a specific closure method, which led to potential issues when handling certain socket types, such as JDWP sockets. This could result in improper resource management and potential leaks. The fix addressed this by ensuring that each socket is closed using its own designated closure function, rather than relying on a single method that may not be applicable to all socket types. This change enhances the reliability of the socket management process, ensuring that all sockets are properly and appropriately closed.","The vulnerability was fixed by replacing the call to `local_socket_close` with a direct invocation of each socket's own `close` method (`s->close(s)`). This change ensures that the appropriate closure function is used for each socket type, addressing the issue where certain sockets, like JDWP sockets, did not utilize the assumed closure method. By allowing each socket to manage its own closure, the code now properly handles all registered local sockets, preventing potential resource leaks and ensuring that the socket management process is robust and reliable across different socket implementations.","The vulnerability was fixed by ensuring that each socket is closed using its specific closure method rather than relying on a single, assumed method that was not universally applicable. This change allows the code to correctly handle different types of sockets, including those that require a distinct approach for closure. By implementing this more flexible and accurate mechanism, the code now effectively manages the closure of all registered sockets, preventing potential resource leaks and ensuring that each socket is properly and appropriately closed according to its own requirements. This enhances the overall reliability of the socket management process.","CWE-772, CWE-404, CWE-775, CWE-401, CWE-403, CWE-400, CWE-674, CWE-405, CWE-763, CWE-911",N,-1
79,79,187796,187796,,Remote,Not required,Complete,CVE-2016-2494,https://www.cvedetails.com/cve/CVE-2016-2494/,CWE-264,Medium,Complete,Complete,,2016-06-12,9.3,"Off-by-one error in sdcard/sdcard.c in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 28085658.",2016-11-29,+Priv ,1,https://android.googlesource.com/platform/system/core/+/864e2e22fcd0cba3f5e67680ccabd0302dfda45d,864e2e22fcd0cba3f5e67680ccabd0302dfda45d,"Fix overflow in path building

An incorrect size was causing an unsigned value
to wrap, causing it to write past the end of
the buffer.

Bug: 28085658
Change-Id: Ie9625c729cca024d514ba2880ff97209d435a165
",1,sdcard/sdcard.c,"{""filename"": ""sdcard/sdcard.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/core/+/864e2e22fcd0cba3f5e67680ccabd0302dfda45d/sdcard/sdcard.c"", ""patch"": ""@@ -337,7 +337,7 @@\n\n \n     ssize_t pathlen = 0;\n     if (node->parent && node->graft_path == NULL) {\n-        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);\n+        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);\n         if (pathlen < 0) {\n             return -1;\n         }\n""}","static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {
 const char* name;
 size_t namelen;
 if (node->graft_path) {
        name = node->graft_path;
        namelen = node->graft_pathlen;
 } else if (node->actual_name) {
        name = node->actual_name;
        namelen = node->namelen;
 } else {
        name = node->name;
        namelen = node->namelen;
 }

 if (bufsize < namelen + 1) {
 return -1;
 }

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);
         if (pathlen < 0) {
             return -1;
         }
        buf[pathlen++] = '/';
 }

    memcpy(buf + pathlen, name, namelen + 1); /* include trailing \0 */
 return pathlen + namelen;
}
","static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {
 const char* name;
 size_t namelen;
 if (node->graft_path) {
        name = node->graft_path;
        namelen = node->graft_pathlen;
 } else if (node->actual_name) {
        name = node->actual_name;
        namelen = node->namelen;
 } else {
        name = node->name;
        namelen = node->namelen;
 }

 if (bufsize < namelen + 1) {
 return -1;
 }

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);
         if (pathlen < 0) {
             return -1;
         }
        buf[pathlen++] = '/';
 }

    memcpy(buf + pathlen, name, namelen + 1); /* include trailing \0 */
 return pathlen + namelen;
}
",C,"        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);
","        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);
",,"@@ -337,7 +337,7 @@

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
-        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);
+        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);
         if (pathlen < 0) {
             return -1;
         }
",Android,https://android.googlesource.com/platform/system/core/+/864e2e22fcd0cba3f5e67680ccabd0302dfda45d/,https://android.googlesource.com/platform/system/core/+/864e2e22fcd0cba3f5e67680ccabd0302dfda45d%5E/,1,"static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {
 const char* name;
 size_t namelen;
 if (node->graft_path) {
        name = node->graft_path;
        namelen = node->graft_pathlen;
 } else if (node->actual_name) {
        name = node->actual_name;
        namelen = node->namelen;
 } else {
        name = node->name;
        namelen = node->namelen;
 }

 if (bufsize < namelen + 1) {
 return -1;
 }

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
//flaw_line_below:
        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);
//fix_flaw_line_below:
//        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);
         if (pathlen < 0) {
             return -1;
         }
        buf[pathlen++] = '/';
 }

    memcpy(buf + pathlen, name, namelen + 1); /* include trailing \0 */
 return pathlen + namelen;
}
",187796,"static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {
 const char* name;
 size_t namelen;
 if (node->graft_path) {
        name = node->graft_path;
        namelen = node->graft_pathlen;
 } else if (node->actual_name) {
        name = node->actual_name;
        namelen = node->namelen;
 } else {
        name = node->name;
        namelen = node->namelen;
 }

 if (bufsize < namelen + 1) {
 return -1;
 }

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);
         if (pathlen < 0) {
             return -1;
         }
        buf[pathlen++] = '/';
 }

    memcpy(buf + pathlen, name, namelen + 1); /* include trailing \0 */
 return pathlen + namelen;
}
","static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {
 const char* name;
 size_t namelen;
 if (node->graft_path) {
        name = node->graft_path;
        namelen = node->graft_pathlen;
 } else if (node->actual_name) {
        name = node->actual_name;
        namelen = node->namelen;
 } else {
        name = node->name;
        namelen = node->namelen;
 }

 if (bufsize < namelen + 1) {
 return -1;
 }

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);
         if (pathlen < 0) {
             return -1;
         }
        buf[pathlen++] = '/';
 }

    memcpy(buf + pathlen, name, namelen + 1); /* include trailing \0 */
 return pathlen + namelen;
}
","The `get_node_path_locked` function constructs a path string for a given node in a tree-like structure, storing the result in a provided buffer. It first determines the node's name based on the presence of a graft path, actual name, or default name. If the buffer is too small to hold the name, it returns -1. The function recursively appends the parent node's path if the node has a parent and no graft path, adding a '/' separator. Finally, it copies the node's name into the buffer, ensuring it is null-terminated, and returns the total length of the constructed path.","The function constructs a path string for a node in a hierarchical structure, storing the result in a specified buffer. It first determines the appropriate name for the node based on available attributes. If the buffer cannot accommodate the name, an error is returned. The function then checks if the node has a parent and, if so, recursively retrieves the parent's path, adding a separator if necessary. Finally, it copies the node's name into the buffer, ensuring it is properly terminated, and returns the total length of the complete path string created.","The vulnerability in the original code stemmed from an incorrect calculation of the buffer size when recursively calling the function for the parent node. Specifically, the expression `bufsize - namelen - 2` could lead to an unsigned integer underflow, resulting in a negative value that would cause the function to write past the end of the buffer, leading to potential memory corruption. The fix involved changing this expression to `bufsize - namelen - 1`, ensuring that the buffer size is correctly calculated and preventing overflow during the path construction process. This adjustment safeguards against writing beyond the allocated buffer space.","The vulnerability in the original code was due to an incorrect calculation of the buffer size, which could lead to an unsigned integer underflow. This underflow risked allowing the function to write beyond the allocated memory for the buffer, potentially causing memory corruption and undefined behavior. The fix addressed this issue by adjusting the buffer size calculation to ensure it accurately accounted for the space needed, thereby preventing any overflow during the path construction process. This change effectively safeguarded the memory boundaries, ensuring that data was written only within the allocated buffer limits.","The vulnerability was fixed by modifying the calculation of the buffer size in the recursive call to `get_node_path_locked`. The original expression `bufsize - namelen - 2` was changed to `bufsize - namelen - 1`, which correctly accounted for the space needed for the node's name and the null terminator. This adjustment prevents the risk of unsigned integer underflow, ensuring that the function does not attempt to write beyond the allocated buffer. As a result, the code now safely constructs the path without exceeding memory boundaries, thereby eliminating the potential for memory corruption.","The vulnerability was addressed by correcting the calculation used to determine the available buffer size during recursive calls. The adjustment ensured that the size accounted for the necessary space for the node's name and the null terminator, thereby preventing any potential underflow. This change effectively eliminated the risk of writing beyond the allocated memory, which could lead to memory corruption. By ensuring that the buffer size was accurately calculated, the code now safely constructs the path without exceeding memory limits, thereby enhancing the overall stability and security of the function.","CWE-119, CWE-131, CWE-191, CWE-120, CWE-122, CWE-787, CWE-788, CWE-124, CWE-680, CWE-789",N,-1
80,80,187905,187905,,Remote,Not required,Complete,CVE-2016-2449,https://www.cvedetails.com/cve/CVE-2016-2449/,CWE-264,Medium,Complete,Complete,,2016-05-09,9.3,"services/camera/libcameraservice/device3/Camera3Device.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not validate template IDs, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27568958.",2016-05-10,+Priv ,7,https://android.googlesource.com/platform/frameworks/av/+/b04aee833c5cfb6b31b8558350feb14bb1a0f353,b04aee833c5cfb6b31b8558350feb14bb1a0f353,"Camera3Device: Validate template ID

Validate template ID before creating a default request.

Bug: 26866110
Bug: 27568958
Change-Id: Ifda457024f1d5c2b1382f189c1a8d5fda852d30d
",0,services/camera/libcameraservice/device3/Camera3Device.cpp,"{""filename"": ""services/camera/libcameraservice/device3/Camera3Device.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/b04aee833c5cfb6b31b8558350feb14bb1a0f353/services/camera/libcameraservice/device3/Camera3Device.cpp"", ""patch"": ""@@ -43,6 +43,7 @@\n\n #include <utils/Trace.h>\n #include <utils/Timers.h>\n \n+#include \""CameraService.h\""\n #include \""utils/CameraTraces.h\""\n #include \""mediautils/SchedulingPolicyService.h\""\n #include \""device3/Camera3Device.h\""\n@@ -1115,6 +1116,13 @@\n\n         CameraMetadata *request) {\n     ATRACE_CALL();\n     ALOGV(\""%s: for template %d\"", __FUNCTION__, templateId);\n+\n+    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {\n+        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, \""26866110\"",\n+                IPCThreadState::self()->getCallingUid(), NULL, 0);\n+        return BAD_VALUE;\n+    }\n+\n     Mutex::Autolock il(mInterfaceLock);\n     Mutex::Autolock l(mLock);\n \n""}","status_t Camera3Device::createDefaultRequest(int templateId,

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);

    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {
        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",
                IPCThreadState::self()->getCallingUid(), NULL, 0);
        return BAD_VALUE;
    }

     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
 switch (mStatus) {
 case STATUS_ERROR:
            CLOGE(""Device has encountered a serious error"");
 return INVALID_OPERATION;
 case STATUS_UNINITIALIZED:
            CLOGE(""Device is not initialized!"");
 return INVALID_OPERATION;
 case STATUS_UNCONFIGURED:
 case STATUS_CONFIGURED:
 case STATUS_ACTIVE:
 break;
 default:
            SET_ERR_L(""Unexpected status: %d"", mStatus);
 return INVALID_OPERATION;
 }

 if (!mRequestTemplateCache[templateId].isEmpty()) {
 *request = mRequestTemplateCache[templateId];
 return OK;
 }

 const camera_metadata_t *rawRequest;
    ATRACE_BEGIN(""camera3->construct_default_request_settings"");
    rawRequest = mHal3Device->ops->construct_default_request_settings(
        mHal3Device, templateId);
    ATRACE_END();
 if (rawRequest == NULL) {
        ALOGI(""%s: template %d is not supported on this camera device"",
              __FUNCTION__, templateId);
 return BAD_VALUE;
 }
 *request = rawRequest;
    mRequestTemplateCache[templateId] = rawRequest;

 return OK;
}
","status_t Camera3Device::createDefaultRequest(int templateId,

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);
     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
 switch (mStatus) {
 case STATUS_ERROR:
            CLOGE(""Device has encountered a serious error"");
 return INVALID_OPERATION;
 case STATUS_UNINITIALIZED:
            CLOGE(""Device is not initialized!"");
 return INVALID_OPERATION;
 case STATUS_UNCONFIGURED:
 case STATUS_CONFIGURED:
 case STATUS_ACTIVE:
 break;
 default:
            SET_ERR_L(""Unexpected status: %d"", mStatus);
 return INVALID_OPERATION;
 }

 if (!mRequestTemplateCache[templateId].isEmpty()) {
 *request = mRequestTemplateCache[templateId];
 return OK;
 }

 const camera_metadata_t *rawRequest;
    ATRACE_BEGIN(""camera3->construct_default_request_settings"");
    rawRequest = mHal3Device->ops->construct_default_request_settings(
        mHal3Device, templateId);
    ATRACE_END();
 if (rawRequest == NULL) {
        ALOGI(""%s: template %d is not supported on this camera device"",
              __FUNCTION__, templateId);
 return BAD_VALUE;
 }
 *request = rawRequest;
    mRequestTemplateCache[templateId] = rawRequest;

 return OK;
}
",C,"
    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {
        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",
                IPCThreadState::self()->getCallingUid(), NULL, 0);
        return BAD_VALUE;
    }

",,,"@@ -43,6 +43,7 @@

 #include <utils/Trace.h>
 #include <utils/Timers.h>
 
+#include ""CameraService.h""
 #include ""utils/CameraTraces.h""
 #include ""mediautils/SchedulingPolicyService.h""
 #include ""device3/Camera3Device.h""
@@ -1115,6 +1116,13 @@

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);
+
+    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {
+        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",
+                IPCThreadState::self()->getCallingUid(), NULL, 0);
+        return BAD_VALUE;
+    }
+
     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
",Android,https://android.googlesource.com/platform/frameworks/av/+/b04aee833c5cfb6b31b8558350feb14bb1a0f353/,https://android.googlesource.com/platform/frameworks/av/+/b04aee833c5cfb6b31b8558350feb14bb1a0f353%5E/,1,"status_t Camera3Device::createDefaultRequest(int templateId,

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {
//fix_flaw_line_below:
//        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",
//fix_flaw_line_below:
//                IPCThreadState::self()->getCallingUid(), NULL, 0);
//fix_flaw_line_below:
//        return BAD_VALUE;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
 switch (mStatus) {
 case STATUS_ERROR:
            CLOGE(""Device has encountered a serious error"");
 return INVALID_OPERATION;
 case STATUS_UNINITIALIZED:
            CLOGE(""Device is not initialized!"");
 return INVALID_OPERATION;
 case STATUS_UNCONFIGURED:
 case STATUS_CONFIGURED:
 case STATUS_ACTIVE:
 // OK
 break;
 default:
            SET_ERR_L(""Unexpected status: %d"", mStatus);
 return INVALID_OPERATION;
 }

 if (!mRequestTemplateCache[templateId].isEmpty()) {
 *request = mRequestTemplateCache[templateId];
 return OK;
 }

 const camera_metadata_t *rawRequest;
    ATRACE_BEGIN(""camera3->construct_default_request_settings"");
    rawRequest = mHal3Device->ops->construct_default_request_settings(
        mHal3Device, templateId);
    ATRACE_END();
 if (rawRequest == NULL) {
        ALOGI(""%s: template %d is not supported on this camera device"",
              __FUNCTION__, templateId);
 return BAD_VALUE;
 }
 *request = rawRequest;
    mRequestTemplateCache[templateId] = rawRequest;

 return OK;
}
",187905,"status_t Camera3Device::createDefaultRequest(int templateId,

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);
     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
 switch (mStatus) {
 case STATUS_ERROR:
            CLOGE(""Device has encountered a serious error"");
 return INVALID_OPERATION;
 case STATUS_UNINITIALIZED:
            CLOGE(""Device is not initialized!"");
 return INVALID_OPERATION;
 case STATUS_UNCONFIGURED:
 case STATUS_CONFIGURED:
 case STATUS_ACTIVE:
 break;
 default:
            SET_ERR_L(""Unexpected status: %d"", mStatus);
 return INVALID_OPERATION;
 }

 if (!mRequestTemplateCache[templateId].isEmpty()) {
 *request = mRequestTemplateCache[templateId];
 return OK;
 }

 const camera_metadata_t *rawRequest;
    ATRACE_BEGIN(""camera3->construct_default_request_settings"");
    rawRequest = mHal3Device->ops->construct_default_request_settings(
        mHal3Device, templateId);
    ATRACE_END();
 if (rawRequest == NULL) {
        ALOGI(""%s: template %d is not supported on this camera device"",
              __FUNCTION__, templateId);
 return BAD_VALUE;
 }
 *request = rawRequest;
    mRequestTemplateCache[templateId] = rawRequest;

 return OK;
}
","status_t Camera3Device::createDefaultRequest(int templateId,

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);

    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {
        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",
                IPCThreadState::self()->getCallingUid(), NULL, 0);
        return BAD_VALUE;
    }

     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
 switch (mStatus) {
 case STATUS_ERROR:
            CLOGE(""Device has encountered a serious error"");
 return INVALID_OPERATION;
 case STATUS_UNINITIALIZED:
            CLOGE(""Device is not initialized!"");
 return INVALID_OPERATION;
 case STATUS_UNCONFIGURED:
 case STATUS_CONFIGURED:
 case STATUS_ACTIVE:
 break;
 default:
            SET_ERR_L(""Unexpected status: %d"", mStatus);
 return INVALID_OPERATION;
 }

 if (!mRequestTemplateCache[templateId].isEmpty()) {
 *request = mRequestTemplateCache[templateId];
 return OK;
 }

 const camera_metadata_t *rawRequest;
    ATRACE_BEGIN(""camera3->construct_default_request_settings"");
    rawRequest = mHal3Device->ops->construct_default_request_settings(
        mHal3Device, templateId);
    ATRACE_END();
 if (rawRequest == NULL) {
        ALOGI(""%s: template %d is not supported on this camera device"",
              __FUNCTION__, templateId);
 return BAD_VALUE;
 }
 *request = rawRequest;
    mRequestTemplateCache[templateId] = rawRequest;

 return OK;
}
","The `Camera3Device::createDefaultRequest` function generates a default camera request based on a specified template ID, ensuring the camera device is in a valid state before proceeding. It first locks the necessary mutexes to prevent concurrent access and checks the device's status, returning an error if the device is uninitialized or has encountered a serious error. If the requested template is already cached, it retrieves and returns it; otherwise, it calls a HAL function to construct the default request settings. If successful, it caches the new request and returns an OK status; otherwise, it indicates unsupported templates.","The code defines a function that creates a default request for a camera based on a specified template ID, while ensuring the camera is in a valid operational state. It first locks necessary resources to prevent conflicts and checks the device's status, returning an error if the device is uninitialized or has encountered a serious issue. If the requested template is already available in the cache, it retrieves and returns it; if not, it constructs a new request using a hardware abstraction layer. The new request is then cached for future use, and the function returns a success or error status accordingly.","The vulnerability in the original code stemmed from the lack of validation for the `templateId` parameter, which could allow an attacker to pass an invalid or out-of-bounds value, potentially leading to undefined behavior or crashes when accessing the request template cache. The fix introduced a validation check for `templateId`, ensuring it falls within a valid range before proceeding with any operations. If the `templateId` is invalid, the code logs an error and returns a `BAD_VALUE` status, thereby preventing further execution and enhancing the robustness of the function against invalid input.","The vulnerability in the original code arose from the absence of checks on the input parameter that specifies the template ID, allowing for the possibility of invalid or out-of-bounds values being processed. This could lead to accessing uninitialized memory or causing crashes, compromising the stability of the application. The fix implemented a validation step to ensure that the template ID is within an acceptable range before any further processing occurs. If the ID is deemed invalid, the code now logs an error and returns a specific status, effectively preventing any unsafe operations and enhancing the overall security of the function.","The vulnerability was fixed by adding a validation check for the `templateId` parameter at the beginning of the function. The code now verifies that `templateId` is greater than zero and less than `CAMERA3_TEMPLATE_COUNT`. If the check fails, it logs an error using `android_errorWriteWithInfoLog` and returns a `BAD_VALUE` status, preventing further execution with an invalid template ID. This ensures that any subsequent operations, such as accessing the request template cache or constructing default request settings, are only performed with valid input, thereby enhancing the function's robustness and security.","The vulnerability was addressed by implementing a validation step for the input parameter that specifies the template ID. This new check ensures that the provided ID falls within a defined valid range before any further processing occurs. If the ID is found to be invalid, the code logs an error and returns a specific status indicating the issue, effectively halting any further execution with potentially harmful input. This proactive measure prevents unsafe operations and enhances the overall stability and security of the function by ensuring that only valid data is processed.","CWE-20, CWE-789, CWE-74, CWE-94, CWE-129, CWE-22, CWE-99, CWE-116, CWE-707, CWE-681",N,-1
81,81,187906,187906,,Remote,Not required,Complete,CVE-2016-2448,https://www.cvedetails.com/cve/CVE-2016-2448/,CWE-264,Medium,Complete,Complete,,2016-05-09,9.3,"media/libmediaplayerservice/nuplayer/NuPlayerStreamListener.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not properly validate entry data structures, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27533704.",2016-05-10,+Priv ,10,https://android.googlesource.com/platform/frameworks/av/+/a2d1d85726aa2a3126e9c331a8e00a8c319c9e2b,a2d1d85726aa2a3126e9c331a8e00a8c319c9e2b,"NuPlayerStreamListener: NULL and bounds check before memcpy

Bug: 27533704
Change-Id: I992a7709b92b1cbc3114c97bec48a3fc5b22ba6e
",1,media/libmediaplayerservice/nuplayer/NuPlayerStreamListener.cpp,"{""filename"": ""media/libmediaplayerservice/nuplayer/NuPlayerStreamListener.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/a2d1d85726aa2a3126e9c331a8e00a8c319c9e2b/media/libmediaplayerservice/nuplayer/NuPlayerStreamListener.cpp"", ""patch"": ""@@ -144,8 +144,17 @@\n\n         copy = size;\n     }\n \n+    if (entry->mIndex >= mBuffers.size()) {\n+        return ERROR_MALFORMED;\n+    }\n+\n+    sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);\n+    if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {\n+        return ERROR_MALFORMED;\n+    }\n+\n     memcpy(data,\n-           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()\n+           (const uint8_t *)mem->pointer()\n             + entry->mOffset,\n            copy);\n \n""}","ssize_t NuPlayer::NuPlayerStreamListener::read(
 void *data, size_t size, sp<AMessage> *extra) {
    CHECK_GT(size, 0u);

    extra->clear();

 Mutex::Autolock autoLock(mLock);

 if (mEOS) {
 return 0;
 }

 if (mQueue.empty()) {
        mSendDataNotification = true;

 return -EWOULDBLOCK;
 }

 QueueEntry *entry = &*mQueue.begin();

 if (entry->mIsCommand) {
 switch (entry->mCommand) {
 case EOS:
 {
                mQueue.erase(mQueue.begin());
                entry = NULL;

                mEOS = true;
 return 0;
 }

 case DISCONTINUITY:
 {
 *extra = entry->mExtra;

                mQueue.erase(mQueue.begin());
                entry = NULL;

 return INFO_DISCONTINUITY;
 }

 default:
                TRESPASS();
 break;
 }
 }

 size_t copy = entry->mSize;
 if (copy > size) {

         copy = size;
     }
 
    if (entry->mIndex >= mBuffers.size()) {
        return ERROR_MALFORMED;
    }

    sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);
    if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {
        return ERROR_MALFORMED;
    }

     memcpy(data,
           (const uint8_t *)mem->pointer()
             + entry->mOffset,
            copy);
 
    entry->mOffset += copy;
    entry->mSize -= copy;

 if (entry->mSize == 0) {
        mSource->onBufferAvailable(entry->mIndex);
        mQueue.erase(mQueue.begin());
        entry = NULL;
 }

 return copy;
}
","ssize_t NuPlayer::NuPlayerStreamListener::read(
 void *data, size_t size, sp<AMessage> *extra) {
    CHECK_GT(size, 0u);

    extra->clear();

 Mutex::Autolock autoLock(mLock);

 if (mEOS) {
 return 0;
 }

 if (mQueue.empty()) {
        mSendDataNotification = true;

 return -EWOULDBLOCK;
 }

 QueueEntry *entry = &*mQueue.begin();

 if (entry->mIsCommand) {
 switch (entry->mCommand) {
 case EOS:
 {
                mQueue.erase(mQueue.begin());
                entry = NULL;

                mEOS = true;
 return 0;
 }

 case DISCONTINUITY:
 {
 *extra = entry->mExtra;

                mQueue.erase(mQueue.begin());
                entry = NULL;

 return INFO_DISCONTINUITY;
 }

 default:
                TRESPASS();
 break;
 }
 }

 size_t copy = entry->mSize;
 if (copy > size) {

         copy = size;
     }
 
     memcpy(data,
           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()
             + entry->mOffset,
            copy);
 
    entry->mOffset += copy;
    entry->mSize -= copy;

 if (entry->mSize == 0) {
        mSource->onBufferAvailable(entry->mIndex);
        mQueue.erase(mQueue.begin());
        entry = NULL;
 }

 return copy;
}
",C,"    if (entry->mIndex >= mBuffers.size()) {
        return ERROR_MALFORMED;
    }

    sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);
    if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {
        return ERROR_MALFORMED;
    }

           (const uint8_t *)mem->pointer()
","           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()
",,"@@ -144,8 +144,17 @@

         copy = size;
     }
 
+    if (entry->mIndex >= mBuffers.size()) {
+        return ERROR_MALFORMED;
+    }
+
+    sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);
+    if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {
+        return ERROR_MALFORMED;
+    }
+
     memcpy(data,
-           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()
+           (const uint8_t *)mem->pointer()
             + entry->mOffset,
            copy);
 
",Android,https://android.googlesource.com/platform/frameworks/av/+/a2d1d85726aa2a3126e9c331a8e00a8c319c9e2b/,https://android.googlesource.com/platform/frameworks/av/+/a2d1d85726aa2a3126e9c331a8e00a8c319c9e2b%5E/,1,"ssize_t NuPlayer::NuPlayerStreamListener::read(
 void *data, size_t size, sp<AMessage> *extra) {
    CHECK_GT(size, 0u);

    extra->clear();

 Mutex::Autolock autoLock(mLock);

 if (mEOS) {
 return 0;
 }

 if (mQueue.empty()) {
        mSendDataNotification = true;

 return -EWOULDBLOCK;
 }

 QueueEntry *entry = &*mQueue.begin();

 if (entry->mIsCommand) {
 switch (entry->mCommand) {
 case EOS:
 {
                mQueue.erase(mQueue.begin());
                entry = NULL;

                mEOS = true;
 return 0;
 }

 case DISCONTINUITY:
 {
 *extra = entry->mExtra;

                mQueue.erase(mQueue.begin());
                entry = NULL;

 return INFO_DISCONTINUITY;
 }

 default:
                TRESPASS();
 break;
 }
 }

 size_t copy = entry->mSize;
 if (copy > size) {

         copy = size;
     }
 
//fix_flaw_line_below:
//    if (entry->mIndex >= mBuffers.size()) {
//fix_flaw_line_below:
//        return ERROR_MALFORMED;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);
//fix_flaw_line_below:
//    if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {
//fix_flaw_line_below:
//        return ERROR_MALFORMED;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     memcpy(data,
//flaw_line_below:
           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()
//fix_flaw_line_below:
//           (const uint8_t *)mem->pointer()
             + entry->mOffset,
            copy);
 
    entry->mOffset += copy;
    entry->mSize -= copy;

 if (entry->mSize == 0) {
        mSource->onBufferAvailable(entry->mIndex);
        mQueue.erase(mQueue.begin());
        entry = NULL;
 }

 return copy;
}
",187906,"ssize_t NuPlayer::NuPlayerStreamListener::read(
 void *data, size_t size, sp<AMessage> *extra) {
    CHECK_GT(size, 0u);

    extra->clear();

 Mutex::Autolock autoLock(mLock);

 if (mEOS) {
 return 0;
 }

 if (mQueue.empty()) {
        mSendDataNotification = true;

 return -EWOULDBLOCK;
 }

 QueueEntry *entry = &*mQueue.begin();

 if (entry->mIsCommand) {
 switch (entry->mCommand) {
 case EOS:
 {
                mQueue.erase(mQueue.begin());
                entry = NULL;

                mEOS = true;
 return 0;
 }

 case DISCONTINUITY:
 {
 *extra = entry->mExtra;

                mQueue.erase(mQueue.begin());
                entry = NULL;

 return INFO_DISCONTINUITY;
 }

 default:
                TRESPASS();
 break;
 }
 }

 size_t copy = entry->mSize;
 if (copy > size) {

         copy = size;
     }
 
     memcpy(data,
           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()
             + entry->mOffset,
            copy);
 
    entry->mOffset += copy;
    entry->mSize -= copy;

 if (entry->mSize == 0) {
        mSource->onBufferAvailable(entry->mIndex);
        mQueue.erase(mQueue.begin());
        entry = NULL;
 }

 return copy;
}
","ssize_t NuPlayer::NuPlayerStreamListener::read(
 void *data, size_t size, sp<AMessage> *extra) {
    CHECK_GT(size, 0u);

    extra->clear();

 Mutex::Autolock autoLock(mLock);

 if (mEOS) {
 return 0;
 }

 if (mQueue.empty()) {
        mSendDataNotification = true;

 return -EWOULDBLOCK;
 }

 QueueEntry *entry = &*mQueue.begin();

 if (entry->mIsCommand) {
 switch (entry->mCommand) {
 case EOS:
 {
                mQueue.erase(mQueue.begin());
                entry = NULL;

                mEOS = true;
 return 0;
 }

 case DISCONTINUITY:
 {
 *extra = entry->mExtra;

                mQueue.erase(mQueue.begin());
                entry = NULL;

 return INFO_DISCONTINUITY;
 }

 default:
                TRESPASS();
 break;
 }
 }

 size_t copy = entry->mSize;
 if (copy > size) {

         copy = size;
     }
 
    if (entry->mIndex >= mBuffers.size()) {
        return ERROR_MALFORMED;
    }

    sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);
    if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {
        return ERROR_MALFORMED;
    }

     memcpy(data,
           (const uint8_t *)mem->pointer()
             + entry->mOffset,
            copy);
 
    entry->mOffset += copy;
    entry->mSize -= copy;

 if (entry->mSize == 0) {
        mSource->onBufferAvailable(entry->mIndex);
        mQueue.erase(mQueue.begin());
        entry = NULL;
 }

 return copy;
}
","The `read` function in the `NuPlayerStreamListener` class is designed to read data from a queue of media buffers, handling various conditions such as end-of-stream (EOS) and discontinuities. It first checks if the requested size is greater than zero and locks the mutex for thread safety. If the end of the stream has been reached or the queue is empty, it returns appropriate error codes. If the queue contains commands like EOS or DISCONTINUITY, it processes them accordingly. Otherwise, it copies data from the current buffer entry to the provided data pointer, updates the entry's offset and size, and manages buffer availability, returning the number of bytes read.","The provided code defines a function that reads data from a media buffer queue while managing various stream states. It ensures that the requested read size is valid and handles synchronization to prevent data races. If the end of the stream is reached or the queue is empty, it returns appropriate error codes. The function processes special commands, such as signaling the end of the stream or indicating a discontinuity, and updates the queue accordingly. When reading data, it copies the specified amount from the buffer to the output, adjusts the buffer's state, and returns the number of bytes successfully read.","The vulnerability in the original code stemmed from a lack of proper checks before accessing memory buffers, which could lead to out-of-bounds memory access or dereferencing null pointers. Specifically, the code did not verify whether the index of the current queue entry was valid or if the memory buffer was adequately sized before performing the `memcpy` operation. The fix introduced additional checks to ensure that the entry's index was within the bounds of the buffer array and that the memory was not null and sufficiently large for the requested copy size. This prevents potential crashes or undefined behavior due to invalid memory access.","The vulnerability in the original code was due to insufficient validation before accessing memory buffers, which could lead to out-of-bounds access or dereferencing null pointers. This lack of checks meant that if an invalid index was used or if the memory was not properly allocated, it could result in crashes or unpredictable behavior during data copying. The fix implemented additional validation steps to ensure that the index was within valid bounds and that the memory was not null and adequately sized before performing any copying operations. This enhancement effectively mitigated the risk of memory-related errors and improved overall stability.","The vulnerability was fixed by adding several critical checks before the `memcpy` operation. Specifically, the code now verifies that the `entry->mIndex` is within the bounds of the `mBuffers` array, ensuring it does not exceed the available buffer size. Additionally, it checks that the memory retrieved using `mBuffers.editItemAt(entry->mIndex)` is not null and that its size is sufficient to accommodate the requested copy size. These checks prevent potential out-of-bounds access and null pointer dereferencing, thereby enhancing the robustness and safety of the memory operations within the function.","The vulnerability was addressed by implementing additional validation checks prior to accessing memory buffers. The updated code ensures that the index used to access the buffer is within valid limits, preventing out-of-bounds access. It also verifies that the memory being accessed is not null and that it has sufficient size to accommodate the data being copied. These enhancements effectively mitigate the risk of crashes or undefined behavior caused by invalid memory operations, thereby improving the overall stability and security of the code.","CWE-125, CWE-119, CWE-787, CWE-788, CWE-823, CWE-124, CWE-126, CWE-789, CWE-822, CWE-824",N,-1
82,82,187907,187907,,Remote,Not required,Complete,CVE-2016-2440,https://www.cvedetails.com/cve/CVE-2016-2440/,CWE-264,Medium,Complete,Complete,,2016-05-09,9.3,"libs/binder/IPCThreadState.cpp in Binder in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 mishandles object references, which allows attackers to gain privileges via a crafted application, aka internal bug 27252896.",2016-05-10,+Priv ,10,https://android.googlesource.com/platform/frameworks/native/+/a59b827869a2ea04022dd225007f29af8d61837a,a59b827869a2ea04022dd225007f29af8d61837a,"Fix issue #27252896: Security Vulnerability -- weak binder

Sending transaction to freed BBinder through weak handle
can cause use of a (mostly) freed object.  We need to try to
safely promote to a strong reference first.

Change-Id: Ic9c6940fa824980472e94ed2dfeca52a6b0fd342
(cherry picked from commit c11146106f94e07016e8e26e4f8628f9a0c73199)
",2,libs/binder/IPCThreadState.cpp,"{""filename"": ""libs/binder/IPCThreadState.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/a59b827869a2ea04022dd225007f29af8d61837a/libs/binder/IPCThreadState.cpp"", ""patch"": ""@@ -1083,8 +1083,16 @@\n\n                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;\n             }\n             if (tr.target.ptr) {\n-                sp<BBinder> b((BBinder*)tr.cookie);\n-                error = b->transact(tr.code, buffer, &reply, tr.flags);\n+                // We only have a weak reference on the target object, so we must first try to\n+                // safely acquire a strong reference before doing anything else with it.\n+                if (reinterpret_cast<RefBase::weakref_type*>(\n+                        tr.target.ptr)->attemptIncStrong(this)) {\n+                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,\n+                            &reply, tr.flags);\n+                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);\n+                } else {\n+                    error = UNKNOWN_TRANSACTION;\n+                }\n \n             } else {\n                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);\n""}","status_t IPCThreadState::executeCommand(int32_t cmd)
{
 BBinder* obj;
 RefBase::weakref_type* refs;
 status_t result = NO_ERROR;
 
 switch ((uint32_t)cmd) {
 case BR_ERROR:
        result = mIn.readInt32();
 break;
 
 case BR_OK:
 break;
 
 case BR_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        obj->incStrong(mProcess.get());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_ACQUIRE from driver on %p"", obj);
            obj->printRefs();
 }
        mOut.writeInt32(BC_ACQUIRE_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_RELEASE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_RELEASE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_RELEASE from driver on %p"", obj);
            obj->printRefs();
 }
        mPendingStrongDerefs.push(obj);
 break;
 
 case BR_INCREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        refs->incWeak(mProcess.get());
        mOut.writeInt32(BC_INCREFS_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_DECREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        mPendingWeakDerefs.push(refs);
 break;
 
 case BR_ATTEMPT_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
 
 {
 const bool success = refs->attemptIncStrong(mProcess.get());
            ALOG_ASSERT(success && refs->refBase() == obj,
 ""BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                       refs, obj, refs->refBase());
 
            mOut.writeInt32(BC_ACQUIRE_RESULT);
            mOut.writeInt32((int32_t)success);
 }
 break;
 
 case BR_TRANSACTION:
 {
            binder_transaction_data tr;
            result = mIn.read(&tr, sizeof(tr));
            ALOG_ASSERT(result == NO_ERROR,
 ""Not enough command data for brTRANSACTION"");
 if (result != NO_ERROR) break;
 
 Parcel buffer;
            buffer.ipcSetDataReference(
 reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),
                tr.data_size,
 reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);
 
 const pid_t origPid = mCallingPid;
 const uid_t origUid = mCallingUid;
 const int32_t origStrictModePolicy = mStrictModePolicy;
 const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;

            mCallingPid = tr.sender_pid;
            mCallingUid = tr.sender_euid;
            mLastTransactionBinderFlags = tr.flags;

 int curPrio = getpriority(PRIO_PROCESS, mMyThreadId);
 if (gDisableBackgroundScheduling) {
 if (curPrio > ANDROID_PRIORITY_NORMAL) {
                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);
 }
 } else {
 if (curPrio >= ANDROID_PRIORITY_BACKGROUND) {
                    set_sched_policy(mMyThreadId, SP_BACKGROUND);
 }
 }


 Parcel reply;
 status_t error;
            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BR_TRANSACTION thr "" << (void*)pthread_self()
 << "" / obj "" << tr.target.ptr << "" / code ""
 << TypeCode(tr.code) << "": "" << indent << buffer
 << dedent << endl
 << ""Data addr = ""
 << reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer)
 << "", offsets addr=""

                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
             }
             if (tr.target.ptr) {
                // We only have a weak reference on the target object, so we must first try to
                // safely acquire a strong reference before doing anything else with it.
                if (reinterpret_cast<RefBase::weakref_type*>(
                        tr.target.ptr)->attemptIncStrong(this)) {
                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,
                            &reply, tr.flags);
                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);
                } else {
                    error = UNKNOWN_TRANSACTION;
                }
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
 }

 
 if ((tr.flags & TF_ONE_WAY) == 0) {
                LOG_ONEWAY(""Sending reply to %d!"", mCallingPid);
 if (error < NO_ERROR) reply.setError(error);
                sendReply(reply, 0);
 } else {
                LOG_ONEWAY(""NOT sending reply to %d!"", mCallingPid);
 }
 
            mCallingPid = origPid;
            mCallingUid = origUid;
            mStrictModePolicy = origStrictModePolicy;
            mLastTransactionBinderFlags = origTransactionBinderFlags;

            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BC_REPLY thr "" << (void*)pthread_self() << "" / obj ""
 << tr.target.ptr << "": "" << indent << reply << dedent << endl;
 }
 
 }
 break;
 
 case BR_DEAD_BINDER:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->sendObituary();
            mOut.writeInt32(BC_DEAD_BINDER_DONE);
            mOut.writePointer((uintptr_t)proxy);
 } break;
 
 case BR_CLEAR_DEATH_NOTIFICATION_DONE:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->getWeakRefs()->decWeak(proxy);
 } break;
 
 case BR_FINISHED:
        result = TIMED_OUT;
 break;
 
 case BR_NOOP:
 break;
 
 case BR_SPAWN_LOOPER:
        mProcess->spawnPooledThread(false);
 break;
 
 default:
        printf(""*** BAD COMMAND %d received from Binder driver\n"", cmd);
        result = UNKNOWN_ERROR;
 break;
 }

 if (result != NO_ERROR) {
        mLastError = result;
 }
 
 return result;
}
","status_t IPCThreadState::executeCommand(int32_t cmd)
{
 BBinder* obj;
 RefBase::weakref_type* refs;
 status_t result = NO_ERROR;
 
 switch ((uint32_t)cmd) {
 case BR_ERROR:
        result = mIn.readInt32();
 break;
 
 case BR_OK:
 break;
 
 case BR_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        obj->incStrong(mProcess.get());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_ACQUIRE from driver on %p"", obj);
            obj->printRefs();
 }
        mOut.writeInt32(BC_ACQUIRE_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_RELEASE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_RELEASE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_RELEASE from driver on %p"", obj);
            obj->printRefs();
 }
        mPendingStrongDerefs.push(obj);
 break;
 
 case BR_INCREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        refs->incWeak(mProcess.get());
        mOut.writeInt32(BC_INCREFS_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_DECREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        mPendingWeakDerefs.push(refs);
 break;
 
 case BR_ATTEMPT_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
 
 {
 const bool success = refs->attemptIncStrong(mProcess.get());
            ALOG_ASSERT(success && refs->refBase() == obj,
 ""BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                       refs, obj, refs->refBase());
 
            mOut.writeInt32(BC_ACQUIRE_RESULT);
            mOut.writeInt32((int32_t)success);
 }
 break;
 
 case BR_TRANSACTION:
 {
            binder_transaction_data tr;
            result = mIn.read(&tr, sizeof(tr));
            ALOG_ASSERT(result == NO_ERROR,
 ""Not enough command data for brTRANSACTION"");
 if (result != NO_ERROR) break;
 
 Parcel buffer;
            buffer.ipcSetDataReference(
 reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),
                tr.data_size,
 reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);
 
 const pid_t origPid = mCallingPid;
 const uid_t origUid = mCallingUid;
 const int32_t origStrictModePolicy = mStrictModePolicy;
 const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;

            mCallingPid = tr.sender_pid;
            mCallingUid = tr.sender_euid;
            mLastTransactionBinderFlags = tr.flags;

 int curPrio = getpriority(PRIO_PROCESS, mMyThreadId);
 if (gDisableBackgroundScheduling) {
 if (curPrio > ANDROID_PRIORITY_NORMAL) {
                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);
 }
 } else {
 if (curPrio >= ANDROID_PRIORITY_BACKGROUND) {
                    set_sched_policy(mMyThreadId, SP_BACKGROUND);
 }
 }


 Parcel reply;
 status_t error;
            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BR_TRANSACTION thr "" << (void*)pthread_self()
 << "" / obj "" << tr.target.ptr << "" / code ""
 << TypeCode(tr.code) << "": "" << indent << buffer
 << dedent << endl
 << ""Data addr = ""
 << reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer)
 << "", offsets addr=""

                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
             }
             if (tr.target.ptr) {
                sp<BBinder> b((BBinder*)tr.cookie);
                error = b->transact(tr.code, buffer, &reply, tr.flags);
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
 }

 
 if ((tr.flags & TF_ONE_WAY) == 0) {
                LOG_ONEWAY(""Sending reply to %d!"", mCallingPid);
 if (error < NO_ERROR) reply.setError(error);
                sendReply(reply, 0);
 } else {
                LOG_ONEWAY(""NOT sending reply to %d!"", mCallingPid);
 }
 
            mCallingPid = origPid;
            mCallingUid = origUid;
            mStrictModePolicy = origStrictModePolicy;
            mLastTransactionBinderFlags = origTransactionBinderFlags;

            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BC_REPLY thr "" << (void*)pthread_self() << "" / obj ""
 << tr.target.ptr << "": "" << indent << reply << dedent << endl;
 }
 
 }
 break;
 
 case BR_DEAD_BINDER:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->sendObituary();
            mOut.writeInt32(BC_DEAD_BINDER_DONE);
            mOut.writePointer((uintptr_t)proxy);
 } break;
 
 case BR_CLEAR_DEATH_NOTIFICATION_DONE:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->getWeakRefs()->decWeak(proxy);
 } break;
 
 case BR_FINISHED:
        result = TIMED_OUT;
 break;
 
 case BR_NOOP:
 break;
 
 case BR_SPAWN_LOOPER:
        mProcess->spawnPooledThread(false);
 break;
 
 default:
        printf(""*** BAD COMMAND %d received from Binder driver\n"", cmd);
        result = UNKNOWN_ERROR;
 break;
 }

 if (result != NO_ERROR) {
        mLastError = result;
 }
 
 return result;
}
",C,"                // We only have a weak reference on the target object, so we must first try to
                // safely acquire a strong reference before doing anything else with it.
                if (reinterpret_cast<RefBase::weakref_type*>(
                        tr.target.ptr)->attemptIncStrong(this)) {
                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,
                            &reply, tr.flags);
                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);
                } else {
                    error = UNKNOWN_TRANSACTION;
                }
","                sp<BBinder> b((BBinder*)tr.cookie);
                error = b->transact(tr.code, buffer, &reply, tr.flags);
",,"@@ -1083,8 +1083,16 @@

                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
             }
             if (tr.target.ptr) {
-                sp<BBinder> b((BBinder*)tr.cookie);
-                error = b->transact(tr.code, buffer, &reply, tr.flags);
+                // We only have a weak reference on the target object, so we must first try to
+                // safely acquire a strong reference before doing anything else with it.
+                if (reinterpret_cast<RefBase::weakref_type*>(
+                        tr.target.ptr)->attemptIncStrong(this)) {
+                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,
+                            &reply, tr.flags);
+                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);
+                } else {
+                    error = UNKNOWN_TRANSACTION;
+                }
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
",Android,https://android.googlesource.com/platform/frameworks/native/+/a59b827869a2ea04022dd225007f29af8d61837a/,https://android.googlesource.com/platform/frameworks/native/+/a59b827869a2ea04022dd225007f29af8d61837a%5E/,1,"status_t IPCThreadState::executeCommand(int32_t cmd)
{
 BBinder* obj;
 RefBase::weakref_type* refs;
 status_t result = NO_ERROR;
 
 switch ((uint32_t)cmd) {
 case BR_ERROR:
        result = mIn.readInt32();
 break;
 
 case BR_OK:
 break;
 
 case BR_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        obj->incStrong(mProcess.get());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_ACQUIRE from driver on %p"", obj);
            obj->printRefs();
 }
        mOut.writeInt32(BC_ACQUIRE_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_RELEASE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_RELEASE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_RELEASE from driver on %p"", obj);
            obj->printRefs();
 }
        mPendingStrongDerefs.push(obj);
 break;
 
 case BR_INCREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        refs->incWeak(mProcess.get());
        mOut.writeInt32(BC_INCREFS_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_DECREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
 // NOTE: This assertion is not valid, because the object may no
 // longer exist (thus the (BBinder*)cast above resulting in a different
 // memory address).
 //ALOG_ASSERT(refs->refBase() == obj,
 //           ""BR_DECREFS: object %p does not match cookie %p (expected %p)"",
 //           refs, obj, refs->refBase());
        mPendingWeakDerefs.push(refs);
 break;
 
 case BR_ATTEMPT_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
 
 {
 const bool success = refs->attemptIncStrong(mProcess.get());
            ALOG_ASSERT(success && refs->refBase() == obj,
 ""BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                       refs, obj, refs->refBase());
 
            mOut.writeInt32(BC_ACQUIRE_RESULT);
            mOut.writeInt32((int32_t)success);
 }
 break;
 
 case BR_TRANSACTION:
 {
            binder_transaction_data tr;
            result = mIn.read(&tr, sizeof(tr));
            ALOG_ASSERT(result == NO_ERROR,
 ""Not enough command data for brTRANSACTION"");
 if (result != NO_ERROR) break;
 
 Parcel buffer;
            buffer.ipcSetDataReference(
 reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),
                tr.data_size,
 reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);
 
 const pid_t origPid = mCallingPid;
 const uid_t origUid = mCallingUid;
 const int32_t origStrictModePolicy = mStrictModePolicy;
 const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;

            mCallingPid = tr.sender_pid;
            mCallingUid = tr.sender_euid;
            mLastTransactionBinderFlags = tr.flags;

 int curPrio = getpriority(PRIO_PROCESS, mMyThreadId);
 if (gDisableBackgroundScheduling) {
 if (curPrio > ANDROID_PRIORITY_NORMAL) {
 // We have inherited a reduced priority from the caller, but do not
 // want to run in that state in this process.  The driver set our
 // priority already (though not our scheduling class), so bounce
 // it back to the default before invoking the transaction.
                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);
 }
 } else {
 if (curPrio >= ANDROID_PRIORITY_BACKGROUND) {
 // We want to use the inherited priority from the caller.
 // Ensure this thread is in the background scheduling class,
 // since the driver won't modify scheduling classes for us.
 // The scheduling group is reset to default by the caller
 // once this method returns after the transaction is complete.
                    set_sched_policy(mMyThreadId, SP_BACKGROUND);
 }
 }

 //ALOGI("">>>> TRANSACT from pid %d uid %d\n"", mCallingPid, mCallingUid);

 Parcel reply;
 status_t error;
            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BR_TRANSACTION thr "" << (void*)pthread_self()
 << "" / obj "" << tr.target.ptr << "" / code ""
 << TypeCode(tr.code) << "": "" << indent << buffer
 << dedent << endl
 << ""Data addr = ""
 << reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer)
 << "", offsets addr=""

                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
             }
             if (tr.target.ptr) {
//flaw_line_below:
                sp<BBinder> b((BBinder*)tr.cookie);
//flaw_line_below:
                error = b->transact(tr.code, buffer, &reply, tr.flags);
//fix_flaw_line_below:
//                // We only have a weak reference on the target object, so we must first try to
//fix_flaw_line_below:
//                // safely acquire a strong reference before doing anything else with it.
//fix_flaw_line_below:
//                if (reinterpret_cast<RefBase::weakref_type*>(
//fix_flaw_line_below:
//                        tr.target.ptr)->attemptIncStrong(this)) {
//fix_flaw_line_below:
//                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,
//fix_flaw_line_below:
//                            &reply, tr.flags);
//fix_flaw_line_below:
//                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);
//fix_flaw_line_below:
//                } else {
//fix_flaw_line_below:
//                    error = UNKNOWN_TRANSACTION;
//fix_flaw_line_below:
//                }
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
 }

 //ALOGI(""<<<< TRANSACT from pid %d restore pid %d uid %d\n"",
 //     mCallingPid, origPid, origUid);
 
 if ((tr.flags & TF_ONE_WAY) == 0) {
                LOG_ONEWAY(""Sending reply to %d!"", mCallingPid);
 if (error < NO_ERROR) reply.setError(error);
                sendReply(reply, 0);
 } else {
                LOG_ONEWAY(""NOT sending reply to %d!"", mCallingPid);
 }
 
            mCallingPid = origPid;
            mCallingUid = origUid;
            mStrictModePolicy = origStrictModePolicy;
            mLastTransactionBinderFlags = origTransactionBinderFlags;

            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BC_REPLY thr "" << (void*)pthread_self() << "" / obj ""
 << tr.target.ptr << "": "" << indent << reply << dedent << endl;
 }
 
 }
 break;
 
 case BR_DEAD_BINDER:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->sendObituary();
            mOut.writeInt32(BC_DEAD_BINDER_DONE);
            mOut.writePointer((uintptr_t)proxy);
 } break;
 
 case BR_CLEAR_DEATH_NOTIFICATION_DONE:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->getWeakRefs()->decWeak(proxy);
 } break;
 
 case BR_FINISHED:
        result = TIMED_OUT;
 break;
 
 case BR_NOOP:
 break;
 
 case BR_SPAWN_LOOPER:
        mProcess->spawnPooledThread(false);
 break;
 
 default:
        printf(""*** BAD COMMAND %d received from Binder driver\n"", cmd);
        result = UNKNOWN_ERROR;
 break;
 }

 if (result != NO_ERROR) {
        mLastError = result;
 }
 
 return result;
}
",187907,"status_t IPCThreadState::executeCommand(int32_t cmd)
{
 BBinder* obj;
 RefBase::weakref_type* refs;
 status_t result = NO_ERROR;
 
 switch ((uint32_t)cmd) {
 case BR_ERROR:
        result = mIn.readInt32();
 break;
 
 case BR_OK:
 break;
 
 case BR_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        obj->incStrong(mProcess.get());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_ACQUIRE from driver on %p"", obj);
            obj->printRefs();
 }
        mOut.writeInt32(BC_ACQUIRE_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_RELEASE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_RELEASE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_RELEASE from driver on %p"", obj);
            obj->printRefs();
 }
        mPendingStrongDerefs.push(obj);
 break;
 
 case BR_INCREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        refs->incWeak(mProcess.get());
        mOut.writeInt32(BC_INCREFS_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_DECREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        mPendingWeakDerefs.push(refs);
 break;
 
 case BR_ATTEMPT_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
 
 {
 const bool success = refs->attemptIncStrong(mProcess.get());
            ALOG_ASSERT(success && refs->refBase() == obj,
 ""BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                       refs, obj, refs->refBase());
 
            mOut.writeInt32(BC_ACQUIRE_RESULT);
            mOut.writeInt32((int32_t)success);
 }
 break;
 
 case BR_TRANSACTION:
 {
            binder_transaction_data tr;
            result = mIn.read(&tr, sizeof(tr));
            ALOG_ASSERT(result == NO_ERROR,
 ""Not enough command data for brTRANSACTION"");
 if (result != NO_ERROR) break;
 
 Parcel buffer;
            buffer.ipcSetDataReference(
 reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),
                tr.data_size,
 reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);
 
 const pid_t origPid = mCallingPid;
 const uid_t origUid = mCallingUid;
 const int32_t origStrictModePolicy = mStrictModePolicy;
 const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;

            mCallingPid = tr.sender_pid;
            mCallingUid = tr.sender_euid;
            mLastTransactionBinderFlags = tr.flags;

 int curPrio = getpriority(PRIO_PROCESS, mMyThreadId);
 if (gDisableBackgroundScheduling) {
 if (curPrio > ANDROID_PRIORITY_NORMAL) {
                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);
 }
 } else {
 if (curPrio >= ANDROID_PRIORITY_BACKGROUND) {
                    set_sched_policy(mMyThreadId, SP_BACKGROUND);
 }
 }


 Parcel reply;
 status_t error;
            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BR_TRANSACTION thr "" << (void*)pthread_self()
 << "" / obj "" << tr.target.ptr << "" / code ""
 << TypeCode(tr.code) << "": "" << indent << buffer
 << dedent << endl
 << ""Data addr = ""
 << reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer)
 << "", offsets addr=""

                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
             }
             if (tr.target.ptr) {
                sp<BBinder> b((BBinder*)tr.cookie);
                error = b->transact(tr.code, buffer, &reply, tr.flags);
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
 }

 
 if ((tr.flags & TF_ONE_WAY) == 0) {
                LOG_ONEWAY(""Sending reply to %d!"", mCallingPid);
 if (error < NO_ERROR) reply.setError(error);
                sendReply(reply, 0);
 } else {
                LOG_ONEWAY(""NOT sending reply to %d!"", mCallingPid);
 }
 
            mCallingPid = origPid;
            mCallingUid = origUid;
            mStrictModePolicy = origStrictModePolicy;
            mLastTransactionBinderFlags = origTransactionBinderFlags;

            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BC_REPLY thr "" << (void*)pthread_self() << "" / obj ""
 << tr.target.ptr << "": "" << indent << reply << dedent << endl;
 }
 
 }
 break;
 
 case BR_DEAD_BINDER:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->sendObituary();
            mOut.writeInt32(BC_DEAD_BINDER_DONE);
            mOut.writePointer((uintptr_t)proxy);
 } break;
 
 case BR_CLEAR_DEATH_NOTIFICATION_DONE:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->getWeakRefs()->decWeak(proxy);
 } break;
 
 case BR_FINISHED:
        result = TIMED_OUT;
 break;
 
 case BR_NOOP:
 break;
 
 case BR_SPAWN_LOOPER:
        mProcess->spawnPooledThread(false);
 break;
 
 default:
        printf(""*** BAD COMMAND %d received from Binder driver\n"", cmd);
        result = UNKNOWN_ERROR;
 break;
 }

 if (result != NO_ERROR) {
        mLastError = result;
 }
 
 return result;
}
","status_t IPCThreadState::executeCommand(int32_t cmd)
{
 BBinder* obj;
 RefBase::weakref_type* refs;
 status_t result = NO_ERROR;
 
 switch ((uint32_t)cmd) {
 case BR_ERROR:
        result = mIn.readInt32();
 break;
 
 case BR_OK:
 break;
 
 case BR_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        obj->incStrong(mProcess.get());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_ACQUIRE from driver on %p"", obj);
            obj->printRefs();
 }
        mOut.writeInt32(BC_ACQUIRE_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_RELEASE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        ALOG_ASSERT(refs->refBase() == obj,
 ""BR_RELEASE: object %p does not match cookie %p (expected %p)"",
                   refs, obj, refs->refBase());
        IF_LOG_REMOTEREFS() {
            LOG_REMOTEREFS(""BR_RELEASE from driver on %p"", obj);
            obj->printRefs();
 }
        mPendingStrongDerefs.push(obj);
 break;
 
 case BR_INCREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        refs->incWeak(mProcess.get());
        mOut.writeInt32(BC_INCREFS_DONE);
        mOut.writePointer((uintptr_t)refs);
        mOut.writePointer((uintptr_t)obj);
 break;
 
 case BR_DECREFS:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
        mPendingWeakDerefs.push(refs);
 break;
 
 case BR_ATTEMPT_ACQUIRE:
        refs = (RefBase::weakref_type*)mIn.readPointer();
        obj = (BBinder*)mIn.readPointer();
 
 {
 const bool success = refs->attemptIncStrong(mProcess.get());
            ALOG_ASSERT(success && refs->refBase() == obj,
 ""BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)"",
                       refs, obj, refs->refBase());
 
            mOut.writeInt32(BC_ACQUIRE_RESULT);
            mOut.writeInt32((int32_t)success);
 }
 break;
 
 case BR_TRANSACTION:
 {
            binder_transaction_data tr;
            result = mIn.read(&tr, sizeof(tr));
            ALOG_ASSERT(result == NO_ERROR,
 ""Not enough command data for brTRANSACTION"");
 if (result != NO_ERROR) break;
 
 Parcel buffer;
            buffer.ipcSetDataReference(
 reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),
                tr.data_size,
 reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);
 
 const pid_t origPid = mCallingPid;
 const uid_t origUid = mCallingUid;
 const int32_t origStrictModePolicy = mStrictModePolicy;
 const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;

            mCallingPid = tr.sender_pid;
            mCallingUid = tr.sender_euid;
            mLastTransactionBinderFlags = tr.flags;

 int curPrio = getpriority(PRIO_PROCESS, mMyThreadId);
 if (gDisableBackgroundScheduling) {
 if (curPrio > ANDROID_PRIORITY_NORMAL) {
                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);
 }
 } else {
 if (curPrio >= ANDROID_PRIORITY_BACKGROUND) {
                    set_sched_policy(mMyThreadId, SP_BACKGROUND);
 }
 }


 Parcel reply;
 status_t error;
            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BR_TRANSACTION thr "" << (void*)pthread_self()
 << "" / obj "" << tr.target.ptr << "" / code ""
 << TypeCode(tr.code) << "": "" << indent << buffer
 << dedent << endl
 << ""Data addr = ""
 << reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer)
 << "", offsets addr=""

                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
             }
             if (tr.target.ptr) {
                // We only have a weak reference on the target object, so we must first try to
                // safely acquire a strong reference before doing anything else with it.
                if (reinterpret_cast<RefBase::weakref_type*>(
                        tr.target.ptr)->attemptIncStrong(this)) {
                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,
                            &reply, tr.flags);
                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);
                } else {
                    error = UNKNOWN_TRANSACTION;
                }
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
 }

 
 if ((tr.flags & TF_ONE_WAY) == 0) {
                LOG_ONEWAY(""Sending reply to %d!"", mCallingPid);
 if (error < NO_ERROR) reply.setError(error);
                sendReply(reply, 0);
 } else {
                LOG_ONEWAY(""NOT sending reply to %d!"", mCallingPid);
 }
 
            mCallingPid = origPid;
            mCallingUid = origUid;
            mStrictModePolicy = origStrictModePolicy;
            mLastTransactionBinderFlags = origTransactionBinderFlags;

            IF_LOG_TRANSACTIONS() {
 TextOutput::Bundle _b(alog);
                alog << ""BC_REPLY thr "" << (void*)pthread_self() << "" / obj ""
 << tr.target.ptr << "": "" << indent << reply << dedent << endl;
 }
 
 }
 break;
 
 case BR_DEAD_BINDER:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->sendObituary();
            mOut.writeInt32(BC_DEAD_BINDER_DONE);
            mOut.writePointer((uintptr_t)proxy);
 } break;
 
 case BR_CLEAR_DEATH_NOTIFICATION_DONE:
 {
 BpBinder *proxy = (BpBinder*)mIn.readPointer();
            proxy->getWeakRefs()->decWeak(proxy);
 } break;
 
 case BR_FINISHED:
        result = TIMED_OUT;
 break;
 
 case BR_NOOP:
 break;
 
 case BR_SPAWN_LOOPER:
        mProcess->spawnPooledThread(false);
 break;
 
 default:
        printf(""*** BAD COMMAND %d received from Binder driver\n"", cmd);
        result = UNKNOWN_ERROR;
 break;
 }

 if (result != NO_ERROR) {
        mLastError = result;
 }
 
 return result;
}
","The `IPCThreadState::executeCommand` function processes various inter-process communication (IPC) commands received from a Binder driver, handling commands such as error reporting, object reference management (acquire, release, increment, decrement), and transaction processing. It reads command identifiers and associated data from input, performs actions based on the command type (e.g., managing strong and weak references, executing transactions, and sending replies), and logs relevant information for debugging. The function ensures proper reference counting and handles errors, returning a status code indicating the outcome of the command execution, while maintaining the integrity of the IPC mechanism.","The provided code defines a function that processes various commands related to inter-process communication, specifically managing object references and handling transactions. It interprets commands to either read or modify object states, such as acquiring or releasing references, incrementing or decrementing reference counts, and executing transactions with potential replies. The function also includes error handling and logging mechanisms to track operations and ensure the integrity of the communication process. Ultimately, it returns a status code indicating the success or failure of the command execution, maintaining the robustness of the inter-process communication framework.","The vulnerability in the original code arises from the potential use of a freed object when sending a transaction through a weak reference to a `BBinder`. If the weak reference is not properly promoted to a strong reference before use, it could lead to undefined behavior or security issues. The fix implemented in the changed code ensures that before any transaction is executed, the code attempts to safely promote the weak reference to a strong reference using the `attemptIncStrong` method. This guarantees that the object remains valid for the duration of the transaction, thus preventing the use of a potentially freed object.","The vulnerability in the original code stems from the risk of using a freed object when sending a transaction through a weak reference. If the weak reference points to an object that has been deallocated, it can lead to undefined behavior or security issues. The fix implemented in the updated code addresses this by ensuring that before any transaction is executed, the weak reference is first promoted to a strong reference. This approach guarantees that the object remains valid and accessible during the transaction, thereby preventing the potential misuse of a freed object and enhancing overall security.","The vulnerability was fixed by introducing a check to safely promote the weak reference to a strong reference before executing any transaction. In the updated code, the `attemptIncStrong` function is called on the weak reference to verify if it can be safely incremented to a strong reference. If successful, the transaction is executed using the strong reference, ensuring that the object remains valid throughout the operation. Additionally, after the transaction, the strong reference is decremented using `decStrong`, which helps maintain proper reference counting and prevents the use of a potentially freed object during the transaction process.","The vulnerability was addressed by implementing a mechanism to safely promote weak references to strong references before any transaction is executed. This ensures that the object being referenced remains valid and is not deallocated during the transaction process. The updated code first checks if the weak reference can be incremented to a strong reference, and only proceeds with the transaction if this promotion is successful. This approach effectively prevents the use of a potentially freed object, thereby enhancing the security and stability of the system during inter-process communication operations.","CWE-416, CWE-825, CWE-672, CWE-415, CWE-911, CWE-664, CWE-119, CWE-476, CWE-404, CWE-613",N,-1
83,83,187909,187909,,Remote,Not required,Complete,CVE-2016-2430,https://www.cvedetails.com/cve/CVE-2016-2430/,CWE-264,Medium,Complete,Complete,,2016-05-09,9.3,"libbacktrace/Backtrace.cpp in debuggerd in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 allows attackers to gain privileges via an application containing a crafted symbol name, aka internal bug 27299236.",2016-05-10,+Priv ,0,https://android.googlesource.com/platform/system/core/+/ad54cfed4516292654c997910839153264ae00a0,ad54cfed4516292654c997910839153264ae00a0,"Don't demangle symbol names.

Bug: http://b/27299236
Change-Id: I26ef47f80d4d6048a316ba51e83365ff65d70439
",12,libbacktrace/Backtrace.cpp,"{""filename"": ""libbacktrace/Backtrace.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/core/+/ad54cfed4516292654c997910839153264ae00a0/libbacktrace/Backtrace.cpp"", ""patch"": ""@@ -54,24 +54,8 @@\n\n   }\n }\n \n-extern \""C\"" char* __cxa_demangle(const char* mangled, char* buf, size_t* len,\n-                                int* status);\n-\n std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {\n   std::string func_name = GetFunctionNameRaw(pc, offset);\n-  if (!func_name.empty()) {\n-#if defined(__APPLE__)\n-    // Mac OS' __cxa_demangle demangles \""f\"" as \""float\""; last tested on 10.7.\n-    if (func_name[0] != '_') {\n-      return func_name;\n-    }\n-#endif\n-    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);\n-    if (name) {\n-      func_name = name;\n-      free(name);\n-    }\n-  }\n   return func_name;\n }\n \n""}"," std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
   return func_name;
 }
"," std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
  if (!func_name.empty()) {
#if defined(__APPLE__)
    if (func_name[0] != '_') {
      return func_name;
    }
#endif
    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
    if (name) {
      func_name = name;
      free(name);
    }
  }
   return func_name;
 }
",C,,"  if (!func_name.empty()) {
#if defined(__APPLE__)
    if (func_name[0] != '_') {
      return func_name;
    }
#endif
    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
    if (name) {
      func_name = name;
      free(name);
    }
  }
",,"@@ -54,24 +54,8 @@

   }
 }
 
-extern ""C"" char* __cxa_demangle(const char* mangled, char* buf, size_t* len,
-                                int* status);
-
 std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
-  if (!func_name.empty()) {
-#if defined(__APPLE__)
-    // Mac OS' __cxa_demangle demangles ""f"" as ""float""; last tested on 10.7.
-    if (func_name[0] != '_') {
-      return func_name;
-    }
-#endif
-    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
-    if (name) {
-      func_name = name;
-      free(name);
-    }
-  }
   return func_name;
 }
 
",Android,https://android.googlesource.com/platform/system/core/+/ad54cfed4516292654c997910839153264ae00a0/,https://android.googlesource.com/platform/system/core/+/ad54cfed4516292654c997910839153264ae00a0%5E/,1," std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
//flaw_line_below:
  if (!func_name.empty()) {
//flaw_line_below:
#if defined(__APPLE__)
//flaw_line_below:
    // Mac OS' __cxa_demangle demangles ""f"" as ""float""; last tested on 10.7.
//flaw_line_below:
    if (func_name[0] != '_') {
//flaw_line_below:
      return func_name;
//flaw_line_below:
    }
//flaw_line_below:
#endif
//flaw_line_below:
    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
//flaw_line_below:
    if (name) {
//flaw_line_below:
      func_name = name;
//flaw_line_below:
      free(name);
//flaw_line_below:
    }
//flaw_line_below:
  }
   return func_name;
 }
",187909," std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
  if (!func_name.empty()) {
#if defined(__APPLE__)
    if (func_name[0] != '_') {
      return func_name;
    }
#endif
    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
    if (name) {
      func_name = name;
      free(name);
    }
  }
   return func_name;
 }
"," std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
   return func_name;
 }
","The provided code defines a method `GetFunctionName` within the `Backtrace` class, which retrieves the name of a function based on a given program counter (PC) address. It first calls `GetFunctionNameRaw` to obtain the raw function name and checks if it is not empty. If the code is running on macOS and the function name does not start with an underscore, it returns the name directly. Otherwise, it uses `__cxa_demangle` to convert the mangled name into a human-readable format, freeing the allocated memory afterward, and finally returns the processed function name.","The code defines a method that retrieves the name of a function based on a specific memory address. It first attempts to obtain the raw name of the function and checks if it is valid. If the environment is macOS and the name does not follow a certain naming convention, it returns the name as is. Otherwise, it demangles the name to convert it from a mangled format into a more readable form. After processing, it ensures any allocated memory is freed before returning the final function name, providing a clear representation of the function associated with the given address.","The vulnerability in the original code stemmed from the use of `__cxa_demangle` to convert mangled function names into a human-readable format, which could lead to potential memory management issues, such as memory leaks or undefined behavior if not handled correctly. The fixed code eliminates this risk by removing the demangling process entirely, directly returning the raw function name obtained from `GetFunctionNameRaw`. This change simplifies the function and mitigates the associated vulnerabilities, ensuring that the function name is returned without additional processing that could introduce instability or security concerns.","The vulnerability in the original code arose from the use of a demangling function that could lead to memory management issues, such as memory leaks or crashes, if the demangled name was not properly handled. This process introduced complexity and potential instability, especially in environments where symbol names could vary. The fixed code addresses this vulnerability by completely removing the demangling step, opting instead to return the raw function name directly. This simplification reduces the risk of memory-related issues and enhances the overall stability and security of the code by eliminating unnecessary processing.","The vulnerability was fixed by removing the demangling process that involved the use of `__cxa_demangle`. In the original code, after obtaining the function name with `GetFunctionNameRaw`, the code attempted to demangle it if certain conditions were met, which could lead to memory management issues. The revised code simplifies this by directly returning the result from `GetFunctionNameRaw`, eliminating the need for demangling altogether. This change not only reduces complexity but also mitigates the risks associated with memory allocation and deallocation, thereby enhancing the stability and security of the function.","The vulnerability was fixed by eliminating the process that involved converting mangled function names into a readable format, which previously introduced potential memory management issues. The revised code directly returns the raw function name obtained from the initial retrieval method, thereby removing the complexity and risks associated with memory allocation and deallocation. This simplification not only enhances the stability of the code but also reduces the likelihood of errors related to memory handling, ultimately improving the overall security and reliability of the function's implementation.","CWE-119, CWE-416, CWE-476, CWE-401, CWE-415, CWE-763, CWE-825, CWE-131, CWE-590, CWE-789",N,-1
84,84,187912,187912,,Remote,Not required,Complete,CVE-2016-2420,https://www.cvedetails.com/cve/CVE-2016-2420/,CWE-264,Medium,Complete,Complete,,2016-04-17,9.3,"rootdir/init.rc in Android 4.x before 4.4.4 does not ensure that the /data/tombstones directory exists for the Debuggerd component, which allows attackers to gain privileges via a crafted application, aka internal bug 26403620.",2016-04-22,+Priv ,1,https://android.googlesource.com/platform/system/core/+/81df1cc77722000f8d0025c1ab00ced123aa573c,81df1cc77722000f8d0025c1ab00ced123aa573c,"Don't create tombstone directory.

Partial backport of cf79748.

Bug: http://b/26403620
Change-Id: Ib877ab6cfab6aef079830c5a50ba81141ead35ee
",12,debuggerd/tombstone.cpp,"{""filename"": ""debuggerd/tombstone.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/core/+/81df1cc77722000f8d0025c1ab00ced123aa573c/debuggerd/tombstone.cpp"", ""patch"": ""@@ -743,21 +743,8 @@\n\n   log.current_tid = tid;\n   log.crashed_tid = tid;\n \n-  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {\n-    _LOG(&log, logtype::ERROR, \""failed to create %s: %s\\n\"", TOMBSTONE_DIR, strerror(errno));\n-  }\n-\n-  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {\n-    _LOG(&log, logtype::ERROR, \""failed to change ownership of %s: %s\\n\"", TOMBSTONE_DIR, strerror(errno));\n-  }\n-\n   int fd = -1;\n-  char* path = NULL;\n-  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {\n-    path = find_and_open_tombstone(&fd);\n-  } else {\n-    _LOG(&log, logtype::ERROR, \""Failed to restore security context, not writing tombstone.\\n\"");\n-  }\n+  char* path = find_and_open_tombstone(&fd);\n \n   if (fd < 0) {\n     _LOG(&log, logtype::ERROR, \""Skipping tombstone write, nothing to do.\\n\"");\n""}","char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,
 uintptr_t abort_msg_address, bool dump_sibling_threads,
 bool* detach_failed, int* total_sleep_time_usec) {

 log_t log;

   log.current_tid = tid;
   log.crashed_tid = tid;
 
   int fd = -1;
  char* path = find_and_open_tombstone(&fd);
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
 *detach_failed = false;
 return NULL;
 }

  log.tfd = fd;
 int amfd = activity_manager_connect();
  log.amfd = amfd;
 *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,
                              dump_sibling_threads, total_sleep_time_usec);

  ALOGI(""\nTombstone written to: %s\n"", path);

  close(amfd);
  close(fd);

 return path;
}
","char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,
 uintptr_t abort_msg_address, bool dump_sibling_threads,
 bool* detach_failed, int* total_sleep_time_usec) {

 log_t log;

   log.current_tid = tid;
   log.crashed_tid = tid;
 
  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {
    _LOG(&log, logtype::ERROR, ""failed to create %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {
    _LOG(&log, logtype::ERROR, ""failed to change ownership of %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
   int fd = -1;
  char* path = NULL;
  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {
    path = find_and_open_tombstone(&fd);
  } else {
    _LOG(&log, logtype::ERROR, ""Failed to restore security context, not writing tombstone.\n"");
  }
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
 *detach_failed = false;
 return NULL;
 }

  log.tfd = fd;
 int amfd = activity_manager_connect();
  log.amfd = amfd;
 *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,
                              dump_sibling_threads, total_sleep_time_usec);

  ALOGI(""\nTombstone written to: %s\n"", path);

  close(amfd);
  close(fd);

 return path;
}
",C,"  char* path = find_and_open_tombstone(&fd);
","  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {
    _LOG(&log, logtype::ERROR, ""failed to create %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {
    _LOG(&log, logtype::ERROR, ""failed to change ownership of %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
  char* path = NULL;
  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {
    path = find_and_open_tombstone(&fd);
  } else {
    _LOG(&log, logtype::ERROR, ""Failed to restore security context, not writing tombstone.\n"");
  }
",,"@@ -743,21 +743,8 @@

   log.current_tid = tid;
   log.crashed_tid = tid;
 
-  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {
-    _LOG(&log, logtype::ERROR, ""failed to create %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
-  }
-
-  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {
-    _LOG(&log, logtype::ERROR, ""failed to change ownership of %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
-  }
-
   int fd = -1;
-  char* path = NULL;
-  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {
-    path = find_and_open_tombstone(&fd);
-  } else {
-    _LOG(&log, logtype::ERROR, ""Failed to restore security context, not writing tombstone.\n"");
-  }
+  char* path = find_and_open_tombstone(&fd);
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
",Android,https://android.googlesource.com/platform/system/core/+/81df1cc77722000f8d0025c1ab00ced123aa573c/,https://android.googlesource.com/platform/system/core/+/81df1cc77722000f8d0025c1ab00ced123aa573c%5E/,1,"char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,
 uintptr_t abort_msg_address, bool dump_sibling_threads,
 bool* detach_failed, int* total_sleep_time_usec) {

 log_t log;

   log.current_tid = tid;
   log.crashed_tid = tid;
 
//flaw_line_below:
  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {
//flaw_line_below:
    _LOG(&log, logtype::ERROR, ""failed to create %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
//flaw_line_below:
  }
//flaw_line_below:

//flaw_line_below:
  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {
//flaw_line_below:
    _LOG(&log, logtype::ERROR, ""failed to change ownership of %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
//flaw_line_below:
  }
//flaw_line_below:

   int fd = -1;
//flaw_line_below:
  char* path = NULL;
//flaw_line_below:
  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {
//flaw_line_below:
    path = find_and_open_tombstone(&fd);
//flaw_line_below:
  } else {
//flaw_line_below:
    _LOG(&log, logtype::ERROR, ""Failed to restore security context, not writing tombstone.\n"");
//flaw_line_below:
  }
//fix_flaw_line_below:
//  char* path = find_and_open_tombstone(&fd);
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
 *detach_failed = false;
 return NULL;
 }

  log.tfd = fd;
 // Preserve amfd since it can be modified through the calls below without
 // being closed.
 int amfd = activity_manager_connect();
  log.amfd = amfd;
 *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,
                              dump_sibling_threads, total_sleep_time_usec);

  ALOGI(""\nTombstone written to: %s\n"", path);

 // Either of these file descriptors can be -1, any error is ignored.
  close(amfd);
  close(fd);

 return path;
}
",187912,"char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,
 uintptr_t abort_msg_address, bool dump_sibling_threads,
 bool* detach_failed, int* total_sleep_time_usec) {

 log_t log;

   log.current_tid = tid;
   log.crashed_tid = tid;
 
  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {
    _LOG(&log, logtype::ERROR, ""failed to create %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {
    _LOG(&log, logtype::ERROR, ""failed to change ownership of %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
   int fd = -1;
  char* path = NULL;
  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {
    path = find_and_open_tombstone(&fd);
  } else {
    _LOG(&log, logtype::ERROR, ""Failed to restore security context, not writing tombstone.\n"");
  }
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
 *detach_failed = false;
 return NULL;
 }

  log.tfd = fd;
 int amfd = activity_manager_connect();
  log.amfd = amfd;
 *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,
                              dump_sibling_threads, total_sleep_time_usec);

  ALOGI(""\nTombstone written to: %s\n"", path);

  close(amfd);
  close(fd);

 return path;
}
","char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,
 uintptr_t abort_msg_address, bool dump_sibling_threads,
 bool* detach_failed, int* total_sleep_time_usec) {

 log_t log;

   log.current_tid = tid;
   log.crashed_tid = tid;
 
   int fd = -1;
  char* path = find_and_open_tombstone(&fd);
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
 *detach_failed = false;
 return NULL;
 }

  log.tfd = fd;
 int amfd = activity_manager_connect();
  log.amfd = amfd;
 *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,
                              dump_sibling_threads, total_sleep_time_usec);

  ALOGI(""\nTombstone written to: %s\n"", path);

  close(amfd);
  close(fd);

 return path;
}
","The `engrave_tombstone` function is designed to create and manage a tombstone file for logging crash information related to a specific thread in a process. It first attempts to create a directory for the tombstone and change its ownership, logging errors if these operations fail. If the security context is successfully restored, it opens a tombstone file; otherwise, it logs an error and exits. The function then connects to the activity manager and calls `dump_crash` to log the crash details, updating the `detach_failed` flag. Finally, it logs the path of the written tombstone, closes file descriptors, and returns the path.","The code is responsible for creating a log entry for a crash event associated with a specific thread in a process. It attempts to establish a directory for storing crash logs and adjusts its permissions, logging any errors encountered during these operations. If the security context is successfully restored, it opens a log file; if not, it logs an error and exits. The code then connects to a management service to record the crash details, updates a flag indicating whether the logging was successful, and finally logs the location of the created log file before closing the necessary connections.","The vulnerability in the original code stemmed from the unnecessary creation of a tombstone directory, which could lead to potential race conditions or permission issues if multiple processes attempted to create or access the same directory simultaneously. The fixed code eliminates this step entirely, removing the directory creation and ownership change operations. Instead, it directly attempts to find and open a tombstone file, checking if the file descriptor is valid before proceeding. This change mitigates the risk of directory-related vulnerabilities, streamlining the process and enhancing overall stability by avoiding unnecessary filesystem interactions.","The vulnerability in the original code arose from the creation of a tombstone directory, which could lead to race conditions or permission issues if multiple processes attempted to access or modify the same directory concurrently. This could result in inconsistent states or crashes. The fixed code addresses this vulnerability by removing the directory creation step entirely, thereby eliminating the associated risks. Instead, it focuses on directly locating and opening a tombstone file, ensuring that the process is streamlined and less prone to errors related to filesystem interactions, ultimately enhancing stability and security.","The vulnerability was fixed by removing the steps that involved creating a tombstone directory and changing its ownership, which were present in the original code. In the updated code, the process directly calls `find_and_open_tombstone` to locate and open a tombstone file without attempting to create a directory first. This change eliminates the potential for race conditions and permission issues associated with directory access. Additionally, the code now checks if the file descriptor is valid before proceeding, ensuring that the logging process is more stable and secure by avoiding unnecessary filesystem interactions.","The vulnerability was fixed by eliminating the creation of a tombstone directory, which previously posed risks of race conditions and permission issues when accessed by multiple processes. The revised approach focuses on directly locating and opening a tombstone file, thereby streamlining the process and reducing the potential for errors related to filesystem interactions. Additionally, the updated code includes a validation check for the file descriptor before proceeding with logging, ensuring that the operation is stable and secure without unnecessary complications from directory management. This change enhances overall reliability and security in handling crash logs.","CWE-367, CWE-732, CWE-362, CWE-379, CWE-266, CWE-282, CWE-269, CWE-552, CWE-378, CWE-280",N,-1
85,85,187913,187913,,Remote,Not required,Complete,CVE-2016-2419,https://www.cvedetails.com/cve/CVE-2016-2419/,CWE-264,Low,Complete,Complete,,2016-04-17,10.0,"media/libmedia/IDrm.cpp in mediaserver in Android 6.x before 2016-04-01 does not initialize a certain key-request data structure, which allows attackers to obtain sensitive information from process memory, and consequently bypass an unspecified protection mechanism, via unspecified vectors, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26323455.",2016-04-25,Bypass +Info ,1,https://android.googlesource.com/platform/frameworks/av/+/5a856f2092f7086aa0fea9ae06b9255befcdcd34,5a856f2092f7086aa0fea9ae06b9255befcdcd34,"Fix info leak vulnerability of IDrm

bug: 26323455
Change-Id: I25bb30d3666ab38d5150496375ed2f55ecb23ba8
",1,media/libmedia/IDrm.cpp,"{""filename"": ""media/libmedia/IDrm.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/5a856f2092f7086aa0fea9ae06b9255befcdcd34/media/libmedia/IDrm.cpp"", ""patch"": ""@@ -658,7 +658,7 @@\n\n \n             Vector<uint8_t> request;\n             String8 defaultUrl;\n-            DrmPlugin::KeyRequestType keyRequestType;\n+            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;\n \n             status_t result = getKeyRequest(sessionId, initData, mimeType,\n                     keyType, optionalParameters, request, defaultUrl,\n""}","status_t BnDrm::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(initCheck());
 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
 String8 mimeType = data.readString8();
            reply->writeInt32(isCryptoSchemeSupported(uuid, mimeType));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(createPlugin(uuid));
 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(destroyPlugin());
 return OK;
 }

 case OPEN_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
 status_t result = openSession(sessionId);
            writeVector(reply, sessionId);
            reply->writeInt32(result);
 return OK;
 }

 case CLOSE_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(closeSession(sessionId));
 return OK;
 }

 case GET_KEY_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, initData;

            readVector(data, sessionId);
            readVector(data, initData);
 String8 mimeType = data.readString8();
 DrmPlugin::KeyType keyType = (DrmPlugin::KeyType)data.readInt32();

 KeyedVector<String8, String8> optionalParameters;
 uint32_t count = data.readInt32();
 for (size_t i = 0; i < count; ++i) {
 String8 key, value;
                key = data.readString8();
                value = data.readString8();
                optionalParameters.add(key, value);
 }

 
             Vector<uint8_t> request;
             String8 defaultUrl;
            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;
 
             status_t result = getKeyRequest(sessionId, initData, mimeType,
                     keyType, optionalParameters, request, defaultUrl,
 &keyRequestType);

            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(static_cast<int32_t>(keyRequestType));
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_KEY_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, response, keySetId;
            readVector(data, sessionId);
            readVector(data, response);
 uint32_t result = provideKeyResponse(sessionId, response, keySetId);
            writeVector(reply, keySetId);
            reply->writeInt32(result);
 return OK;
 }

 case REMOVE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> keySetId;
            readVector(data, keySetId);
            reply->writeInt32(removeKeys(keySetId));
 return OK;
 }

 case RESTORE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keySetId;
            readVector(data, sessionId);
            readVector(data, keySetId);
            reply->writeInt32(restoreKeys(sessionId, keySetId));
 return OK;
 }

 case QUERY_KEY_STATUS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 KeyedVector<String8, String8> infoMap;
 status_t result = queryKeyStatus(sessionId, infoMap);
 size_t count = infoMap.size();
            reply->writeInt32(count);
 for (size_t i = 0; i < count; ++i) {
                reply->writeString8(infoMap.keyAt(i));
                reply->writeString8(infoMap.valueAt(i));
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROVISION_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 certType = data.readString8();
 String8 certAuthority = data.readString8();

 Vector<uint8_t> request;
 String8 defaultUrl;
 status_t result = getProvisionRequest(certType, certAuthority,
                                                  request, defaultUrl);
            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_PROVISION_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> response;
 Vector<uint8_t> certificate;
 Vector<uint8_t> wrappedKey;
            readVector(data, response);
 status_t result = provideProvisionResponse(response, certificate, wrappedKey);
            writeVector(reply, certificate);
            writeVector(reply, wrappedKey);
            reply->writeInt32(result);
 return OK;
 }

 case UNPROVISION_DEVICE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 status_t result = unprovisionDevice();
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 List<Vector<uint8_t> > secureStops;
 status_t result = getSecureStops(secureStops);
 size_t count = secureStops.size();
            reply->writeInt32(count);
 List<Vector<uint8_t> >::iterator iter = secureStops.begin();
 while(iter != secureStops.end()) {
 size_t size = iter->size();
                reply->writeInt32(size);
                reply->write(iter->array(), iter->size());
                iter++;
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOP:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssid, secureStop;
            readVector(data, ssid);
 status_t result = getSecureStop(ssid, secureStop);
            writeVector(reply, secureStop);
            reply->writeInt32(result);
 return OK;
 }

 case RELEASE_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssRelease;
            readVector(data, ssRelease);
            reply->writeInt32(releaseSecureStops(ssRelease));
 return OK;
 }

 case RELEASE_ALL_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(releaseAllSecureStops());
 return OK;
 }

 case GET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value;
 status_t result = getPropertyString(name, value);
            reply->writeString8(value);
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
 status_t result = getPropertyByteArray(name, value);
            writeVector(reply, value);
            reply->writeInt32(result);
 return OK;
 }

 case SET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value = data.readString8();
            reply->writeInt32(setPropertyString(name, value));
 return OK;
 }

 case SET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
            readVector(data, value);
            reply->writeInt32(setPropertyByteArray(name, value));
 return OK;
 }

 case SET_CIPHER_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setCipherAlgorithm(sessionId, algorithm));
 return OK;
 }

 case SET_MAC_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setMacAlgorithm(sessionId, algorithm));
 return OK;
 }

 case ENCRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = encrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = decrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
 uint32_t result = sign(sessionId, keyId, message, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case VERIFY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
            readVector(data, signature);
 bool match;
 uint32_t result = verify(sessionId, keyId, message, signature, match);
            reply->writeInt32(match);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN_RSA:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, message, wrappedKey, signature;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            readVector(data, message);
            readVector(data, wrappedKey);
 uint32_t result = signRSA(sessionId, algorithm, message, wrappedKey, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case SET_LISTENER: {
        CHECK_INTERFACE(IDrm, data, reply);
        sp<IDrmClient> listener =
            interface_cast<IDrmClient>(data.readStrongBinder());
        reply->writeInt32(setListener(listener));
 return NO_ERROR;
 } break;

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","status_t BnDrm::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(initCheck());
 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
 String8 mimeType = data.readString8();
            reply->writeInt32(isCryptoSchemeSupported(uuid, mimeType));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(createPlugin(uuid));
 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(destroyPlugin());
 return OK;
 }

 case OPEN_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
 status_t result = openSession(sessionId);
            writeVector(reply, sessionId);
            reply->writeInt32(result);
 return OK;
 }

 case CLOSE_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(closeSession(sessionId));
 return OK;
 }

 case GET_KEY_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, initData;

            readVector(data, sessionId);
            readVector(data, initData);
 String8 mimeType = data.readString8();
 DrmPlugin::KeyType keyType = (DrmPlugin::KeyType)data.readInt32();

 KeyedVector<String8, String8> optionalParameters;
 uint32_t count = data.readInt32();
 for (size_t i = 0; i < count; ++i) {
 String8 key, value;
                key = data.readString8();
                value = data.readString8();
                optionalParameters.add(key, value);
 }

 
             Vector<uint8_t> request;
             String8 defaultUrl;
            DrmPlugin::KeyRequestType keyRequestType;
 
             status_t result = getKeyRequest(sessionId, initData, mimeType,
                     keyType, optionalParameters, request, defaultUrl,
 &keyRequestType);

            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(static_cast<int32_t>(keyRequestType));
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_KEY_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, response, keySetId;
            readVector(data, sessionId);
            readVector(data, response);
 uint32_t result = provideKeyResponse(sessionId, response, keySetId);
            writeVector(reply, keySetId);
            reply->writeInt32(result);
 return OK;
 }

 case REMOVE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> keySetId;
            readVector(data, keySetId);
            reply->writeInt32(removeKeys(keySetId));
 return OK;
 }

 case RESTORE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keySetId;
            readVector(data, sessionId);
            readVector(data, keySetId);
            reply->writeInt32(restoreKeys(sessionId, keySetId));
 return OK;
 }

 case QUERY_KEY_STATUS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 KeyedVector<String8, String8> infoMap;
 status_t result = queryKeyStatus(sessionId, infoMap);
 size_t count = infoMap.size();
            reply->writeInt32(count);
 for (size_t i = 0; i < count; ++i) {
                reply->writeString8(infoMap.keyAt(i));
                reply->writeString8(infoMap.valueAt(i));
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROVISION_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 certType = data.readString8();
 String8 certAuthority = data.readString8();

 Vector<uint8_t> request;
 String8 defaultUrl;
 status_t result = getProvisionRequest(certType, certAuthority,
                                                  request, defaultUrl);
            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_PROVISION_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> response;
 Vector<uint8_t> certificate;
 Vector<uint8_t> wrappedKey;
            readVector(data, response);
 status_t result = provideProvisionResponse(response, certificate, wrappedKey);
            writeVector(reply, certificate);
            writeVector(reply, wrappedKey);
            reply->writeInt32(result);
 return OK;
 }

 case UNPROVISION_DEVICE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 status_t result = unprovisionDevice();
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 List<Vector<uint8_t> > secureStops;
 status_t result = getSecureStops(secureStops);
 size_t count = secureStops.size();
            reply->writeInt32(count);
 List<Vector<uint8_t> >::iterator iter = secureStops.begin();
 while(iter != secureStops.end()) {
 size_t size = iter->size();
                reply->writeInt32(size);
                reply->write(iter->array(), iter->size());
                iter++;
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOP:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssid, secureStop;
            readVector(data, ssid);
 status_t result = getSecureStop(ssid, secureStop);
            writeVector(reply, secureStop);
            reply->writeInt32(result);
 return OK;
 }

 case RELEASE_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssRelease;
            readVector(data, ssRelease);
            reply->writeInt32(releaseSecureStops(ssRelease));
 return OK;
 }

 case RELEASE_ALL_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(releaseAllSecureStops());
 return OK;
 }

 case GET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value;
 status_t result = getPropertyString(name, value);
            reply->writeString8(value);
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
 status_t result = getPropertyByteArray(name, value);
            writeVector(reply, value);
            reply->writeInt32(result);
 return OK;
 }

 case SET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value = data.readString8();
            reply->writeInt32(setPropertyString(name, value));
 return OK;
 }

 case SET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
            readVector(data, value);
            reply->writeInt32(setPropertyByteArray(name, value));
 return OK;
 }

 case SET_CIPHER_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setCipherAlgorithm(sessionId, algorithm));
 return OK;
 }

 case SET_MAC_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setMacAlgorithm(sessionId, algorithm));
 return OK;
 }

 case ENCRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = encrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = decrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
 uint32_t result = sign(sessionId, keyId, message, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case VERIFY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
            readVector(data, signature);
 bool match;
 uint32_t result = verify(sessionId, keyId, message, signature, match);
            reply->writeInt32(match);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN_RSA:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, message, wrappedKey, signature;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            readVector(data, message);
            readVector(data, wrappedKey);
 uint32_t result = signRSA(sessionId, algorithm, message, wrappedKey, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case SET_LISTENER: {
        CHECK_INTERFACE(IDrm, data, reply);
        sp<IDrmClient> listener =
            interface_cast<IDrmClient>(data.readStrongBinder());
        reply->writeInt32(setListener(listener));
 return NO_ERROR;
 } break;

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
",C,"            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;
","            DrmPlugin::KeyRequestType keyRequestType;
",,"@@ -658,7 +658,7 @@

 
             Vector<uint8_t> request;
             String8 defaultUrl;
-            DrmPlugin::KeyRequestType keyRequestType;
+            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;
 
             status_t result = getKeyRequest(sessionId, initData, mimeType,
                     keyType, optionalParameters, request, defaultUrl,
",Android,https://android.googlesource.com/platform/frameworks/av/+/5a856f2092f7086aa0fea9ae06b9255befcdcd34/,https://android.googlesource.com/platform/frameworks/av/+/5a856f2092f7086aa0fea9ae06b9255befcdcd34%5E/,1,"status_t BnDrm::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(initCheck());
 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
 String8 mimeType = data.readString8();
            reply->writeInt32(isCryptoSchemeSupported(uuid, mimeType));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(createPlugin(uuid));
 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(destroyPlugin());
 return OK;
 }

 case OPEN_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
 status_t result = openSession(sessionId);
            writeVector(reply, sessionId);
            reply->writeInt32(result);
 return OK;
 }

 case CLOSE_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(closeSession(sessionId));
 return OK;
 }

 case GET_KEY_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, initData;

            readVector(data, sessionId);
            readVector(data, initData);
 String8 mimeType = data.readString8();
 DrmPlugin::KeyType keyType = (DrmPlugin::KeyType)data.readInt32();

 KeyedVector<String8, String8> optionalParameters;
 uint32_t count = data.readInt32();
 for (size_t i = 0; i < count; ++i) {
 String8 key, value;
                key = data.readString8();
                value = data.readString8();
                optionalParameters.add(key, value);
 }

 
             Vector<uint8_t> request;
             String8 defaultUrl;
//flaw_line_below:
            DrmPlugin::KeyRequestType keyRequestType;
//fix_flaw_line_below:
//            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;
 
             status_t result = getKeyRequest(sessionId, initData, mimeType,
                     keyType, optionalParameters, request, defaultUrl,
 &keyRequestType);

            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(static_cast<int32_t>(keyRequestType));
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_KEY_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, response, keySetId;
            readVector(data, sessionId);
            readVector(data, response);
 uint32_t result = provideKeyResponse(sessionId, response, keySetId);
            writeVector(reply, keySetId);
            reply->writeInt32(result);
 return OK;
 }

 case REMOVE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> keySetId;
            readVector(data, keySetId);
            reply->writeInt32(removeKeys(keySetId));
 return OK;
 }

 case RESTORE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keySetId;
            readVector(data, sessionId);
            readVector(data, keySetId);
            reply->writeInt32(restoreKeys(sessionId, keySetId));
 return OK;
 }

 case QUERY_KEY_STATUS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 KeyedVector<String8, String8> infoMap;
 status_t result = queryKeyStatus(sessionId, infoMap);
 size_t count = infoMap.size();
            reply->writeInt32(count);
 for (size_t i = 0; i < count; ++i) {
                reply->writeString8(infoMap.keyAt(i));
                reply->writeString8(infoMap.valueAt(i));
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROVISION_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 certType = data.readString8();
 String8 certAuthority = data.readString8();

 Vector<uint8_t> request;
 String8 defaultUrl;
 status_t result = getProvisionRequest(certType, certAuthority,
                                                  request, defaultUrl);
            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_PROVISION_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> response;
 Vector<uint8_t> certificate;
 Vector<uint8_t> wrappedKey;
            readVector(data, response);
 status_t result = provideProvisionResponse(response, certificate, wrappedKey);
            writeVector(reply, certificate);
            writeVector(reply, wrappedKey);
            reply->writeInt32(result);
 return OK;
 }

 case UNPROVISION_DEVICE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 status_t result = unprovisionDevice();
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 List<Vector<uint8_t> > secureStops;
 status_t result = getSecureStops(secureStops);
 size_t count = secureStops.size();
            reply->writeInt32(count);
 List<Vector<uint8_t> >::iterator iter = secureStops.begin();
 while(iter != secureStops.end()) {
 size_t size = iter->size();
                reply->writeInt32(size);
                reply->write(iter->array(), iter->size());
                iter++;
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOP:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssid, secureStop;
            readVector(data, ssid);
 status_t result = getSecureStop(ssid, secureStop);
            writeVector(reply, secureStop);
            reply->writeInt32(result);
 return OK;
 }

 case RELEASE_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssRelease;
            readVector(data, ssRelease);
            reply->writeInt32(releaseSecureStops(ssRelease));
 return OK;
 }

 case RELEASE_ALL_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(releaseAllSecureStops());
 return OK;
 }

 case GET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value;
 status_t result = getPropertyString(name, value);
            reply->writeString8(value);
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
 status_t result = getPropertyByteArray(name, value);
            writeVector(reply, value);
            reply->writeInt32(result);
 return OK;
 }

 case SET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value = data.readString8();
            reply->writeInt32(setPropertyString(name, value));
 return OK;
 }

 case SET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
            readVector(data, value);
            reply->writeInt32(setPropertyByteArray(name, value));
 return OK;
 }

 case SET_CIPHER_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setCipherAlgorithm(sessionId, algorithm));
 return OK;
 }

 case SET_MAC_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setMacAlgorithm(sessionId, algorithm));
 return OK;
 }

 case ENCRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = encrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = decrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
 uint32_t result = sign(sessionId, keyId, message, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case VERIFY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
            readVector(data, signature);
 bool match;
 uint32_t result = verify(sessionId, keyId, message, signature, match);
            reply->writeInt32(match);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN_RSA:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, message, wrappedKey, signature;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            readVector(data, message);
            readVector(data, wrappedKey);
 uint32_t result = signRSA(sessionId, algorithm, message, wrappedKey, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case SET_LISTENER: {
        CHECK_INTERFACE(IDrm, data, reply);
        sp<IDrmClient> listener =
            interface_cast<IDrmClient>(data.readStrongBinder());
        reply->writeInt32(setListener(listener));
 return NO_ERROR;
 } break;

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
",187913,"status_t BnDrm::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(initCheck());
 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
 String8 mimeType = data.readString8();
            reply->writeInt32(isCryptoSchemeSupported(uuid, mimeType));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(createPlugin(uuid));
 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(destroyPlugin());
 return OK;
 }

 case OPEN_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
 status_t result = openSession(sessionId);
            writeVector(reply, sessionId);
            reply->writeInt32(result);
 return OK;
 }

 case CLOSE_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(closeSession(sessionId));
 return OK;
 }

 case GET_KEY_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, initData;

            readVector(data, sessionId);
            readVector(data, initData);
 String8 mimeType = data.readString8();
 DrmPlugin::KeyType keyType = (DrmPlugin::KeyType)data.readInt32();

 KeyedVector<String8, String8> optionalParameters;
 uint32_t count = data.readInt32();
 for (size_t i = 0; i < count; ++i) {
 String8 key, value;
                key = data.readString8();
                value = data.readString8();
                optionalParameters.add(key, value);
 }

 
             Vector<uint8_t> request;
             String8 defaultUrl;
            DrmPlugin::KeyRequestType keyRequestType;
 
             status_t result = getKeyRequest(sessionId, initData, mimeType,
                     keyType, optionalParameters, request, defaultUrl,
 &keyRequestType);

            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(static_cast<int32_t>(keyRequestType));
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_KEY_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, response, keySetId;
            readVector(data, sessionId);
            readVector(data, response);
 uint32_t result = provideKeyResponse(sessionId, response, keySetId);
            writeVector(reply, keySetId);
            reply->writeInt32(result);
 return OK;
 }

 case REMOVE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> keySetId;
            readVector(data, keySetId);
            reply->writeInt32(removeKeys(keySetId));
 return OK;
 }

 case RESTORE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keySetId;
            readVector(data, sessionId);
            readVector(data, keySetId);
            reply->writeInt32(restoreKeys(sessionId, keySetId));
 return OK;
 }

 case QUERY_KEY_STATUS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 KeyedVector<String8, String8> infoMap;
 status_t result = queryKeyStatus(sessionId, infoMap);
 size_t count = infoMap.size();
            reply->writeInt32(count);
 for (size_t i = 0; i < count; ++i) {
                reply->writeString8(infoMap.keyAt(i));
                reply->writeString8(infoMap.valueAt(i));
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROVISION_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 certType = data.readString8();
 String8 certAuthority = data.readString8();

 Vector<uint8_t> request;
 String8 defaultUrl;
 status_t result = getProvisionRequest(certType, certAuthority,
                                                  request, defaultUrl);
            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_PROVISION_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> response;
 Vector<uint8_t> certificate;
 Vector<uint8_t> wrappedKey;
            readVector(data, response);
 status_t result = provideProvisionResponse(response, certificate, wrappedKey);
            writeVector(reply, certificate);
            writeVector(reply, wrappedKey);
            reply->writeInt32(result);
 return OK;
 }

 case UNPROVISION_DEVICE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 status_t result = unprovisionDevice();
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 List<Vector<uint8_t> > secureStops;
 status_t result = getSecureStops(secureStops);
 size_t count = secureStops.size();
            reply->writeInt32(count);
 List<Vector<uint8_t> >::iterator iter = secureStops.begin();
 while(iter != secureStops.end()) {
 size_t size = iter->size();
                reply->writeInt32(size);
                reply->write(iter->array(), iter->size());
                iter++;
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOP:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssid, secureStop;
            readVector(data, ssid);
 status_t result = getSecureStop(ssid, secureStop);
            writeVector(reply, secureStop);
            reply->writeInt32(result);
 return OK;
 }

 case RELEASE_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssRelease;
            readVector(data, ssRelease);
            reply->writeInt32(releaseSecureStops(ssRelease));
 return OK;
 }

 case RELEASE_ALL_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(releaseAllSecureStops());
 return OK;
 }

 case GET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value;
 status_t result = getPropertyString(name, value);
            reply->writeString8(value);
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
 status_t result = getPropertyByteArray(name, value);
            writeVector(reply, value);
            reply->writeInt32(result);
 return OK;
 }

 case SET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value = data.readString8();
            reply->writeInt32(setPropertyString(name, value));
 return OK;
 }

 case SET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
            readVector(data, value);
            reply->writeInt32(setPropertyByteArray(name, value));
 return OK;
 }

 case SET_CIPHER_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setCipherAlgorithm(sessionId, algorithm));
 return OK;
 }

 case SET_MAC_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setMacAlgorithm(sessionId, algorithm));
 return OK;
 }

 case ENCRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = encrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = decrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
 uint32_t result = sign(sessionId, keyId, message, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case VERIFY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
            readVector(data, signature);
 bool match;
 uint32_t result = verify(sessionId, keyId, message, signature, match);
            reply->writeInt32(match);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN_RSA:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, message, wrappedKey, signature;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            readVector(data, message);
            readVector(data, wrappedKey);
 uint32_t result = signRSA(sessionId, algorithm, message, wrappedKey, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case SET_LISTENER: {
        CHECK_INTERFACE(IDrm, data, reply);
        sp<IDrmClient> listener =
            interface_cast<IDrmClient>(data.readStrongBinder());
        reply->writeInt32(setListener(listener));
 return NO_ERROR;
 } break;

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","status_t BnDrm::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case INIT_CHECK:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(initCheck());
 return OK;
 }

 case IS_CRYPTO_SUPPORTED:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
 String8 mimeType = data.readString8();
            reply->writeInt32(isCryptoSchemeSupported(uuid, mimeType));

 return OK;
 }

 case CREATE_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 uint8_t uuid[16];
            data.read(uuid, sizeof(uuid));
            reply->writeInt32(createPlugin(uuid));
 return OK;
 }

 case DESTROY_PLUGIN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(destroyPlugin());
 return OK;
 }

 case OPEN_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
 status_t result = openSession(sessionId);
            writeVector(reply, sessionId);
            reply->writeInt32(result);
 return OK;
 }

 case CLOSE_SESSION:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
            reply->writeInt32(closeSession(sessionId));
 return OK;
 }

 case GET_KEY_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, initData;

            readVector(data, sessionId);
            readVector(data, initData);
 String8 mimeType = data.readString8();
 DrmPlugin::KeyType keyType = (DrmPlugin::KeyType)data.readInt32();

 KeyedVector<String8, String8> optionalParameters;
 uint32_t count = data.readInt32();
 for (size_t i = 0; i < count; ++i) {
 String8 key, value;
                key = data.readString8();
                value = data.readString8();
                optionalParameters.add(key, value);
 }

 
             Vector<uint8_t> request;
             String8 defaultUrl;
            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;
 
             status_t result = getKeyRequest(sessionId, initData, mimeType,
                     keyType, optionalParameters, request, defaultUrl,
 &keyRequestType);

            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(static_cast<int32_t>(keyRequestType));
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_KEY_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, response, keySetId;
            readVector(data, sessionId);
            readVector(data, response);
 uint32_t result = provideKeyResponse(sessionId, response, keySetId);
            writeVector(reply, keySetId);
            reply->writeInt32(result);
 return OK;
 }

 case REMOVE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> keySetId;
            readVector(data, keySetId);
            reply->writeInt32(removeKeys(keySetId));
 return OK;
 }

 case RESTORE_KEYS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keySetId;
            readVector(data, sessionId);
            readVector(data, keySetId);
            reply->writeInt32(restoreKeys(sessionId, keySetId));
 return OK;
 }

 case QUERY_KEY_STATUS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 KeyedVector<String8, String8> infoMap;
 status_t result = queryKeyStatus(sessionId, infoMap);
 size_t count = infoMap.size();
            reply->writeInt32(count);
 for (size_t i = 0; i < count; ++i) {
                reply->writeString8(infoMap.keyAt(i));
                reply->writeString8(infoMap.valueAt(i));
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROVISION_REQUEST:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 certType = data.readString8();
 String8 certAuthority = data.readString8();

 Vector<uint8_t> request;
 String8 defaultUrl;
 status_t result = getProvisionRequest(certType, certAuthority,
                                                  request, defaultUrl);
            writeVector(reply, request);
            reply->writeString8(defaultUrl);
            reply->writeInt32(result);
 return OK;
 }

 case PROVIDE_PROVISION_RESPONSE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> response;
 Vector<uint8_t> certificate;
 Vector<uint8_t> wrappedKey;
            readVector(data, response);
 status_t result = provideProvisionResponse(response, certificate, wrappedKey);
            writeVector(reply, certificate);
            writeVector(reply, wrappedKey);
            reply->writeInt32(result);
 return OK;
 }

 case UNPROVISION_DEVICE:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 status_t result = unprovisionDevice();
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 List<Vector<uint8_t> > secureStops;
 status_t result = getSecureStops(secureStops);
 size_t count = secureStops.size();
            reply->writeInt32(count);
 List<Vector<uint8_t> >::iterator iter = secureStops.begin();
 while(iter != secureStops.end()) {
 size_t size = iter->size();
                reply->writeInt32(size);
                reply->write(iter->array(), iter->size());
                iter++;
 }
            reply->writeInt32(result);
 return OK;
 }

 case GET_SECURE_STOP:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssid, secureStop;
            readVector(data, ssid);
 status_t result = getSecureStop(ssid, secureStop);
            writeVector(reply, secureStop);
            reply->writeInt32(result);
 return OK;
 }

 case RELEASE_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> ssRelease;
            readVector(data, ssRelease);
            reply->writeInt32(releaseSecureStops(ssRelease));
 return OK;
 }

 case RELEASE_ALL_SECURE_STOPS:
 {
            CHECK_INTERFACE(IDrm, data, reply);
            reply->writeInt32(releaseAllSecureStops());
 return OK;
 }

 case GET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value;
 status_t result = getPropertyString(name, value);
            reply->writeString8(value);
            reply->writeInt32(result);
 return OK;
 }

 case GET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
 status_t result = getPropertyByteArray(name, value);
            writeVector(reply, value);
            reply->writeInt32(result);
 return OK;
 }

 case SET_PROPERTY_STRING:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 String8 value = data.readString8();
            reply->writeInt32(setPropertyString(name, value));
 return OK;
 }

 case SET_PROPERTY_BYTE_ARRAY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 String8 name = data.readString8();
 Vector<uint8_t> value;
            readVector(data, value);
            reply->writeInt32(setPropertyByteArray(name, value));
 return OK;
 }

 case SET_CIPHER_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setCipherAlgorithm(sessionId, algorithm));
 return OK;
 }

 case SET_MAC_ALGORITHM:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            reply->writeInt32(setMacAlgorithm(sessionId, algorithm));
 return OK;
 }

 case ENCRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = encrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case DECRYPT:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, input, iv, output;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, input);
            readVector(data, iv);
 uint32_t result = decrypt(sessionId, keyId, input, iv, output);
            writeVector(reply, output);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
 uint32_t result = sign(sessionId, keyId, message, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case VERIFY:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, keyId, message, signature;
            readVector(data, sessionId);
            readVector(data, keyId);
            readVector(data, message);
            readVector(data, signature);
 bool match;
 uint32_t result = verify(sessionId, keyId, message, signature, match);
            reply->writeInt32(match);
            reply->writeInt32(result);
 return OK;
 }

 case SIGN_RSA:
 {
            CHECK_INTERFACE(IDrm, data, reply);
 Vector<uint8_t> sessionId, message, wrappedKey, signature;
            readVector(data, sessionId);
 String8 algorithm = data.readString8();
            readVector(data, message);
            readVector(data, wrappedKey);
 uint32_t result = signRSA(sessionId, algorithm, message, wrappedKey, signature);
            writeVector(reply, signature);
            reply->writeInt32(result);
 return OK;
 }

 case SET_LISTENER: {
        CHECK_INTERFACE(IDrm, data, reply);
        sp<IDrmClient> listener =
            interface_cast<IDrmClient>(data.readStrongBinder());
        reply->writeInt32(setListener(listener));
 return NO_ERROR;
 } break;

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","The provided code defines the `onTransact` method for the `BnDrm` class, which handles various transactions related to Digital Rights Management (DRM) operations. It processes different request codes, such as initializing checks, managing sessions, and handling key requests and responses. Each case reads input data from a `Parcel`, performs the corresponding DRM operation (like creating or destroying plugins, encrypting, or decrypting data), and writes the results back to a reply `Parcel`. The method ensures proper interface checks and returns appropriate status codes, facilitating communication between the client and the DRM service.","The code implements a method that manages various transactions related to Digital Rights Management (DRM) operations. It processes different request types, including initialization checks, session management, key requests, and encryption or decryption tasks. For each request, it reads input data, executes the corresponding operation, and writes the results back to a response object. The method ensures that the interface is correctly checked before proceeding with the operations, returning appropriate status codes to indicate success or failure, thereby facilitating effective communication between the client and the DRM service.","The vulnerability in the original code stemmed from the potential for information leakage through the `GET_PROPERTY_STRING` and `GET_PROPERTY_BYTE_ARRAY` cases, where sensitive data could be inadvertently exposed if the requested property name was not properly validated. This could allow unauthorized access to confidential information. The fix involved ensuring that the property name was validated before attempting to retrieve its value, thereby preventing unauthorized access to sensitive data. By implementing this validation, the code now safeguards against information leaks, ensuring that only legitimate requests for properties are processed.","The vulnerability in the original code allowed for potential information leakage, where sensitive data could be exposed through certain operations without proper validation of the input parameters. This could lead to unauthorized access to confidential information, compromising the security of the system. The fix addressed this issue by implementing validation checks on the input parameters before processing requests, ensuring that only legitimate and authorized requests were handled. This change effectively mitigated the risk of information leaks, enhancing the overall security of the system by safeguarding sensitive data from unauthorized access.","The vulnerability was fixed by adding validation checks for the property names in the `GET_PROPERTY_STRING` and `GET_PROPERTY_BYTE_ARRAY` cases. Specifically, the code now ensures that the property name is checked against a predefined list of allowed properties before attempting to retrieve its value. This prevents unauthorized access to sensitive information by rejecting requests for invalid or potentially harmful property names. By implementing this validation, the code enhances security, ensuring that only legitimate property requests are processed, thereby mitigating the risk of information leakage.","The vulnerability was fixed by introducing validation checks for input parameters before processing requests related to sensitive data retrieval. This involved ensuring that only authorized and legitimate property names were accepted, effectively preventing unauthorized access to confidential information. By implementing these checks, the code now rejects any requests that do not meet the specified criteria, thereby safeguarding against potential information leaks. This enhancement strengthens the overall security of the system, ensuring that sensitive data remains protected from unauthorized exposure while allowing legitimate operations to proceed as intended.","CWE-285, CWE-284, CWE-639, CWE-200, CWE-732, CWE-358, CWE-306, CWE-269, CWE-602, CWE-601",N,-1
86,86,187915,187915,,Remote,Not required,Complete,CVE-2016-2417,https://www.cvedetails.com/cve/CVE-2016-2417/,CWE-264,Low,Complete,Complete,,2016-04-17,10.0,"media/libmedia/IOMX.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not initialize a parameter data structure, which allows attackers to obtain sensitive information from process memory, and consequently bypass an unspecified protection mechanism, via unspecified vectors, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26914474.",2017-09-07,Bypass +Info ,30,https://android.googlesource.com/platform/frameworks/av/+/1171e7c047bf79e7c93342bb6a812c9edd86aa84,1171e7c047bf79e7c93342bb6a812c9edd86aa84,"Clear allocation to avoid info leak

Bug: 26914474
Change-Id: Ie1a86e86d78058d041149fe599a4996e7f8185cf
",24,media/libmedia/IOMX.cpp,"{""filename"": ""media/libmedia/IOMX.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/1171e7c047bf79e7c93342bb6a812c9edd86aa84/media/libmedia/IOMX.cpp"", ""patch"": ""@@ -618,34 +618,39 @@\n\n \n             size_t size = data.readInt64();\n \n-            void *params = malloc(size);\n-            data.read(params, size);\n+            status_t err = NO_MEMORY;\n+            void *params = calloc(size, 1);\n+            if (params) {\n+                err = data.read(params, size);\n+                if (err != OK) {\n+                    android_errorWriteLog(0x534e4554, \""26914474\"");\n+                } else {\n+                    switch (code) {\n+                        case GET_PARAMETER:\n+                            err = getParameter(node, index, params, size);\n+                            break;\n+                        case SET_PARAMETER:\n+                            err = setParameter(node, index, params, size);\n+                            break;\n+                        case GET_CONFIG:\n+                            err = getConfig(node, index, params, size);\n+                            break;\n+                        case SET_CONFIG:\n+                            err = setConfig(node, index, params, size);\n+                            break;\n+                        case SET_INTERNAL_OPTION:\n+                        {\n+                            InternalOptionType type =\n+                                (InternalOptionType)data.readInt32();\n \n-            status_t err;\n-            switch (code) {\n-                case GET_PARAMETER:\n-                    err = getParameter(node, index, params, size);\n-                    break;\n-                case SET_PARAMETER:\n-                    err = setParameter(node, index, params, size);\n-                    break;\n-                case GET_CONFIG:\n-                    err = getConfig(node, index, params, size);\n-                    break;\n-                case SET_CONFIG:\n-                    err = setConfig(node, index, params, size);\n-                    break;\n-                case SET_INTERNAL_OPTION:\n-                {\n-                    InternalOptionType type =\n-                        (InternalOptionType)data.readInt32();\n+                            err = setInternalOption(node, index, type, params, size);\n+                            break;\n+                        }\n \n-                    err = setInternalOption(node, index, type, params, size);\n-                    break;\n+                        default:\n+                            TRESPASS();\n+                    }\n                 }\n-\n-                default:\n-                    TRESPASS();\n             }\n \n             reply->writeInt32(err);\n""}","status_t BnOMX::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case LIVES_LOCALLY:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);
            node_id node = (node_id)data.readInt32();
 pid_t pid = (pid_t)data.readInt32();
            reply->writeInt32(livesLocally(node, pid));

 return OK;
 }

 case LIST_NODES:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 List<ComponentInfo> list;
            listNodes(&list);

            reply->writeInt32(list.size());
 for (List<ComponentInfo>::iterator it = list.begin();
                 it != list.end(); ++it) {
 ComponentInfo &cur = *it;

                reply->writeString8(cur.mName);
                reply->writeInt32(cur.mRoles.size());
 for (List<String8>::iterator role_it = cur.mRoles.begin();
                     role_it != cur.mRoles.end(); ++role_it) {
                    reply->writeString8(*role_it);
 }
 }

 return NO_ERROR;
 }

 case ALLOCATE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 const char *name = data.readCString();

            sp<IOMXObserver> observer =
                interface_cast<IOMXObserver>(data.readStrongBinder());

            node_id node;

 status_t err = allocateNode(name, observer, &node);
            reply->writeInt32(err);
 if (err == OK) {
                reply->writeInt32((int32_t)node);
 }

 return NO_ERROR;
 }

 case FREE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            reply->writeInt32(freeNode(node));

 return NO_ERROR;
 }

 case SEND_COMMAND:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            OMX_COMMANDTYPE cmd =
 static_cast<OMX_COMMANDTYPE>(data.readInt32());

            OMX_S32 param = data.readInt32();
            reply->writeInt32(sendCommand(node, cmd, param));

 return NO_ERROR;
 }

 case GET_PARAMETER:
 case SET_PARAMETER:
 case GET_CONFIG:
 case SET_CONFIG:
 case SET_INTERNAL_OPTION:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());

 
             size_t size = data.readInt64();
 
            status_t err = NO_MEMORY;
            void *params = calloc(size, 1);
            if (params) {
                err = data.read(params, size);
                if (err != OK) {
                    android_errorWriteLog(0x534e4554, ""26914474"");
                } else {
                    switch (code) {
                        case GET_PARAMETER:
                            err = getParameter(node, index, params, size);
                            break;
                        case SET_PARAMETER:
                            err = setParameter(node, index, params, size);
                            break;
                        case GET_CONFIG:
                            err = getConfig(node, index, params, size);
                            break;
                        case SET_CONFIG:
                            err = setConfig(node, index, params, size);
                            break;
                        case SET_INTERNAL_OPTION:
                        {
                            InternalOptionType type =
                                (InternalOptionType)data.readInt32();
 
                            err = setInternalOption(node, index, type, params, size);
                            break;
                        }
 
                        default:
                            TRESPASS();
                    }
                 }
             }
 
             reply->writeInt32(err);

 if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {
                reply->write(params, size);
 }

            free(params);
            params = NULL;

 return NO_ERROR;
 }

 case GET_STATE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_STATETYPE state = OMX_StateInvalid;

 status_t err = getState(node, &state);
            reply->writeInt32(state);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case ENABLE_GRAPHIC_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = enableGraphicBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case GET_GRAPHIC_BUFFER_USAGE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            OMX_U32 usage = 0;
 status_t err = getGraphicBufferUsage(node, port_index, &usage);
            reply->writeInt32(err);
            reply->writeInt32(usage);

 return NO_ERROR;
 }

 case USE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = useBuffer(node, port_index, params, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case USE_GRAPHIC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);

            buffer_id buffer;
 status_t err = useGraphicBuffer(
                    node, port_index, graphicBuffer, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case UPDATE_GRAPHIC_BUFFER_IN_META:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
            buffer_id buffer = (buffer_id)data.readInt32();

 status_t err = updateGraphicBufferInMeta(
                    node, port_index, graphicBuffer, buffer);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CREATE_INPUT_SURFACE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            sp<IGraphicBufferProducer> bufferProducer;
 status_t err = createInputSurface(node, port_index,
 &bufferProducer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeStrongBinder(bufferProducer->asBinder());
 }

 return NO_ERROR;
 }

 case SIGNAL_END_OF_INPUT_STREAM:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

 status_t err = signalEndOfInputStream(node);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case STORE_META_DATA_IN_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = storeMetaDataInBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case PREPARE_FOR_ADAPTIVE_PLAYBACK:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();
            OMX_U32 max_width = data.readInt32();
            OMX_U32 max_height = data.readInt32();

 status_t err = prepareForAdaptivePlayback(
                    node, port_index, enable, max_width, max_height);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CONFIGURE_VIDEO_TUNNEL_MODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();
            OMX_U32 audio_hw_sync = data.readInt32();

 native_handle_t *sideband_handle = NULL;
 status_t err = configureVideoTunnelMode(
                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);
            reply->writeInt32(err);
 if(err == OK){
                reply->writeNativeHandle(sideband_handle);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
 if (!isSecure(node) || port_index != 0 /* kPortIndexInput */) {
                ALOGE(""b/24310423"");
                reply->writeInt32(INVALID_OPERATION);
 return NO_ERROR;
 }

 size_t size = data.readInt64();

            buffer_id buffer;
 void *buffer_data;
 status_t err = allocateBuffer(
                    node, port_index, size, &buffer, &buffer_data);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
                reply->writeInt64((uintptr_t)buffer_data);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER_WITH_BACKUP:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = allocateBufferWithBackup(
                    node, port_index, params, &buffer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case FREE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(freeBuffer(node, port_index, buffer));

 return NO_ERROR;
 }

 case FILL_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(fillBuffer(node, buffer));

 return NO_ERROR;
 }

 case EMPTY_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            OMX_U32 range_offset = data.readInt32();
            OMX_U32 range_length = data.readInt32();
            OMX_U32 flags = data.readInt32();
            OMX_TICKS timestamp = data.readInt64();

            reply->writeInt32(
                    emptyBuffer(
                        node, buffer, range_offset, range_length,
                        flags, timestamp));

 return NO_ERROR;
 }

 case GET_EXTENSION_INDEX:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
 const char *parameter_name = data.readCString();

            OMX_INDEXTYPE index;
 status_t err = getExtensionIndex(node, parameter_name, &index);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32(index);
 }

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","status_t BnOMX::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case LIVES_LOCALLY:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);
            node_id node = (node_id)data.readInt32();
 pid_t pid = (pid_t)data.readInt32();
            reply->writeInt32(livesLocally(node, pid));

 return OK;
 }

 case LIST_NODES:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 List<ComponentInfo> list;
            listNodes(&list);

            reply->writeInt32(list.size());
 for (List<ComponentInfo>::iterator it = list.begin();
                 it != list.end(); ++it) {
 ComponentInfo &cur = *it;

                reply->writeString8(cur.mName);
                reply->writeInt32(cur.mRoles.size());
 for (List<String8>::iterator role_it = cur.mRoles.begin();
                     role_it != cur.mRoles.end(); ++role_it) {
                    reply->writeString8(*role_it);
 }
 }

 return NO_ERROR;
 }

 case ALLOCATE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 const char *name = data.readCString();

            sp<IOMXObserver> observer =
                interface_cast<IOMXObserver>(data.readStrongBinder());

            node_id node;

 status_t err = allocateNode(name, observer, &node);
            reply->writeInt32(err);
 if (err == OK) {
                reply->writeInt32((int32_t)node);
 }

 return NO_ERROR;
 }

 case FREE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            reply->writeInt32(freeNode(node));

 return NO_ERROR;
 }

 case SEND_COMMAND:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            OMX_COMMANDTYPE cmd =
 static_cast<OMX_COMMANDTYPE>(data.readInt32());

            OMX_S32 param = data.readInt32();
            reply->writeInt32(sendCommand(node, cmd, param));

 return NO_ERROR;
 }

 case GET_PARAMETER:
 case SET_PARAMETER:
 case GET_CONFIG:
 case SET_CONFIG:
 case SET_INTERNAL_OPTION:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());

 
             size_t size = data.readInt64();
 
            void *params = malloc(size);
            data.read(params, size);
 
            status_t err;
            switch (code) {
                case GET_PARAMETER:
                    err = getParameter(node, index, params, size);
                    break;
                case SET_PARAMETER:
                    err = setParameter(node, index, params, size);
                    break;
                case GET_CONFIG:
                    err = getConfig(node, index, params, size);
                    break;
                case SET_CONFIG:
                    err = setConfig(node, index, params, size);
                    break;
                case SET_INTERNAL_OPTION:
                {
                    InternalOptionType type =
                        (InternalOptionType)data.readInt32();
 
                    err = setInternalOption(node, index, type, params, size);
                    break;
                 }
                default:
                    TRESPASS();
             }
 
             reply->writeInt32(err);

 if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {
                reply->write(params, size);
 }

            free(params);
            params = NULL;

 return NO_ERROR;
 }

 case GET_STATE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_STATETYPE state = OMX_StateInvalid;

 status_t err = getState(node, &state);
            reply->writeInt32(state);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case ENABLE_GRAPHIC_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = enableGraphicBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case GET_GRAPHIC_BUFFER_USAGE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            OMX_U32 usage = 0;
 status_t err = getGraphicBufferUsage(node, port_index, &usage);
            reply->writeInt32(err);
            reply->writeInt32(usage);

 return NO_ERROR;
 }

 case USE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = useBuffer(node, port_index, params, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case USE_GRAPHIC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);

            buffer_id buffer;
 status_t err = useGraphicBuffer(
                    node, port_index, graphicBuffer, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case UPDATE_GRAPHIC_BUFFER_IN_META:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
            buffer_id buffer = (buffer_id)data.readInt32();

 status_t err = updateGraphicBufferInMeta(
                    node, port_index, graphicBuffer, buffer);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CREATE_INPUT_SURFACE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            sp<IGraphicBufferProducer> bufferProducer;
 status_t err = createInputSurface(node, port_index,
 &bufferProducer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeStrongBinder(bufferProducer->asBinder());
 }

 return NO_ERROR;
 }

 case SIGNAL_END_OF_INPUT_STREAM:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

 status_t err = signalEndOfInputStream(node);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case STORE_META_DATA_IN_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = storeMetaDataInBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case PREPARE_FOR_ADAPTIVE_PLAYBACK:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();
            OMX_U32 max_width = data.readInt32();
            OMX_U32 max_height = data.readInt32();

 status_t err = prepareForAdaptivePlayback(
                    node, port_index, enable, max_width, max_height);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CONFIGURE_VIDEO_TUNNEL_MODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();
            OMX_U32 audio_hw_sync = data.readInt32();

 native_handle_t *sideband_handle = NULL;
 status_t err = configureVideoTunnelMode(
                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);
            reply->writeInt32(err);
 if(err == OK){
                reply->writeNativeHandle(sideband_handle);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
 if (!isSecure(node) || port_index != 0 /* kPortIndexInput */) {
                ALOGE(""b/24310423"");
                reply->writeInt32(INVALID_OPERATION);
 return NO_ERROR;
 }

 size_t size = data.readInt64();

            buffer_id buffer;
 void *buffer_data;
 status_t err = allocateBuffer(
                    node, port_index, size, &buffer, &buffer_data);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
                reply->writeInt64((uintptr_t)buffer_data);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER_WITH_BACKUP:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = allocateBufferWithBackup(
                    node, port_index, params, &buffer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case FREE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(freeBuffer(node, port_index, buffer));

 return NO_ERROR;
 }

 case FILL_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(fillBuffer(node, buffer));

 return NO_ERROR;
 }

 case EMPTY_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            OMX_U32 range_offset = data.readInt32();
            OMX_U32 range_length = data.readInt32();
            OMX_U32 flags = data.readInt32();
            OMX_TICKS timestamp = data.readInt64();

            reply->writeInt32(
                    emptyBuffer(
                        node, buffer, range_offset, range_length,
                        flags, timestamp));

 return NO_ERROR;
 }

 case GET_EXTENSION_INDEX:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
 const char *parameter_name = data.readCString();

            OMX_INDEXTYPE index;
 status_t err = getExtensionIndex(node, parameter_name, &index);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32(index);
 }

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
",C,"            status_t err = NO_MEMORY;
            void *params = calloc(size, 1);
            if (params) {
                err = data.read(params, size);
                if (err != OK) {
                    android_errorWriteLog(0x534e4554, ""26914474"");
                } else {
                    switch (code) {
                        case GET_PARAMETER:
                            err = getParameter(node, index, params, size);
                            break;
                        case SET_PARAMETER:
                            err = setParameter(node, index, params, size);
                            break;
                        case GET_CONFIG:
                            err = getConfig(node, index, params, size);
                            break;
                        case SET_CONFIG:
                            err = setConfig(node, index, params, size);
                            break;
                        case SET_INTERNAL_OPTION:
                        {
                            InternalOptionType type =
                                (InternalOptionType)data.readInt32();
                            err = setInternalOption(node, index, type, params, size);
                            break;
                        }
                        default:
                            TRESPASS();
                    }
","            void *params = malloc(size);
            data.read(params, size);
            status_t err;
            switch (code) {
                case GET_PARAMETER:
                    err = getParameter(node, index, params, size);
                    break;
                case SET_PARAMETER:
                    err = setParameter(node, index, params, size);
                    break;
                case GET_CONFIG:
                    err = getConfig(node, index, params, size);
                    break;
                case SET_CONFIG:
                    err = setConfig(node, index, params, size);
                    break;
                case SET_INTERNAL_OPTION:
                {
                    InternalOptionType type =
                        (InternalOptionType)data.readInt32();
                    err = setInternalOption(node, index, type, params, size);
                    break;
                default:
                    TRESPASS();
",,"@@ -618,34 +618,39 @@

 
             size_t size = data.readInt64();
 
-            void *params = malloc(size);
-            data.read(params, size);
+            status_t err = NO_MEMORY;
+            void *params = calloc(size, 1);
+            if (params) {
+                err = data.read(params, size);
+                if (err != OK) {
+                    android_errorWriteLog(0x534e4554, ""26914474"");
+                } else {
+                    switch (code) {
+                        case GET_PARAMETER:
+                            err = getParameter(node, index, params, size);
+                            break;
+                        case SET_PARAMETER:
+                            err = setParameter(node, index, params, size);
+                            break;
+                        case GET_CONFIG:
+                            err = getConfig(node, index, params, size);
+                            break;
+                        case SET_CONFIG:
+                            err = setConfig(node, index, params, size);
+                            break;
+                        case SET_INTERNAL_OPTION:
+                        {
+                            InternalOptionType type =
+                                (InternalOptionType)data.readInt32();
 
-            status_t err;
-            switch (code) {
-                case GET_PARAMETER:
-                    err = getParameter(node, index, params, size);
-                    break;
-                case SET_PARAMETER:
-                    err = setParameter(node, index, params, size);
-                    break;
-                case GET_CONFIG:
-                    err = getConfig(node, index, params, size);
-                    break;
-                case SET_CONFIG:
-                    err = setConfig(node, index, params, size);
-                    break;
-                case SET_INTERNAL_OPTION:
-                {
-                    InternalOptionType type =
-                        (InternalOptionType)data.readInt32();
+                            err = setInternalOption(node, index, type, params, size);
+                            break;
+                        }
 
-                    err = setInternalOption(node, index, type, params, size);
-                    break;
+                        default:
+                            TRESPASS();
+                    }
                 }
-
-                default:
-                    TRESPASS();
             }
 
             reply->writeInt32(err);
",Android,https://android.googlesource.com/platform/frameworks/av/+/1171e7c047bf79e7c93342bb6a812c9edd86aa84/,https://android.googlesource.com/platform/frameworks/av/+/1171e7c047bf79e7c93342bb6a812c9edd86aa84%5E/,1,"status_t BnOMX::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case LIVES_LOCALLY:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);
            node_id node = (node_id)data.readInt32();
 pid_t pid = (pid_t)data.readInt32();
            reply->writeInt32(livesLocally(node, pid));

 return OK;
 }

 case LIST_NODES:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 List<ComponentInfo> list;
            listNodes(&list);

            reply->writeInt32(list.size());
 for (List<ComponentInfo>::iterator it = list.begin();
                 it != list.end(); ++it) {
 ComponentInfo &cur = *it;

                reply->writeString8(cur.mName);
                reply->writeInt32(cur.mRoles.size());
 for (List<String8>::iterator role_it = cur.mRoles.begin();
                     role_it != cur.mRoles.end(); ++role_it) {
                    reply->writeString8(*role_it);
 }
 }

 return NO_ERROR;
 }

 case ALLOCATE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 const char *name = data.readCString();

            sp<IOMXObserver> observer =
                interface_cast<IOMXObserver>(data.readStrongBinder());

            node_id node;

 status_t err = allocateNode(name, observer, &node);
            reply->writeInt32(err);
 if (err == OK) {
                reply->writeInt32((int32_t)node);
 }

 return NO_ERROR;
 }

 case FREE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            reply->writeInt32(freeNode(node));

 return NO_ERROR;
 }

 case SEND_COMMAND:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            OMX_COMMANDTYPE cmd =
 static_cast<OMX_COMMANDTYPE>(data.readInt32());

            OMX_S32 param = data.readInt32();
            reply->writeInt32(sendCommand(node, cmd, param));

 return NO_ERROR;
 }

 case GET_PARAMETER:
 case SET_PARAMETER:
 case GET_CONFIG:
 case SET_CONFIG:
 case SET_INTERNAL_OPTION:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());

 
             size_t size = data.readInt64();
 
//flaw_line_below:
            void *params = malloc(size);
//flaw_line_below:
            data.read(params, size);
//fix_flaw_line_below:
//            status_t err = NO_MEMORY;
//fix_flaw_line_below:
//            void *params = calloc(size, 1);
//fix_flaw_line_below:
//            if (params) {
//fix_flaw_line_below:
//                err = data.read(params, size);
//fix_flaw_line_below:
//                if (err != OK) {
//fix_flaw_line_below:
//                    android_errorWriteLog(0x534e4554, ""26914474"");
//fix_flaw_line_below:
//                } else {
//fix_flaw_line_below:
//                    switch (code) {
//fix_flaw_line_below:
//                        case GET_PARAMETER:
//fix_flaw_line_below:
//                            err = getParameter(node, index, params, size);
//fix_flaw_line_below:
//                            break;
//fix_flaw_line_below:
//                        case SET_PARAMETER:
//fix_flaw_line_below:
//                            err = setParameter(node, index, params, size);
//fix_flaw_line_below:
//                            break;
//fix_flaw_line_below:
//                        case GET_CONFIG:
//fix_flaw_line_below:
//                            err = getConfig(node, index, params, size);
//fix_flaw_line_below:
//                            break;
//fix_flaw_line_below:
//                        case SET_CONFIG:
//fix_flaw_line_below:
//                            err = setConfig(node, index, params, size);
//fix_flaw_line_below:
//                            break;
//fix_flaw_line_below:
//                        case SET_INTERNAL_OPTION:
//fix_flaw_line_below:
//                        {
//fix_flaw_line_below:
//                            InternalOptionType type =
//fix_flaw_line_below:
//                                (InternalOptionType)data.readInt32();
 
//flaw_line_below:
            status_t err;
//flaw_line_below:
            switch (code) {
//flaw_line_below:
                case GET_PARAMETER:
//flaw_line_below:
                    err = getParameter(node, index, params, size);
//flaw_line_below:
                    break;
//flaw_line_below:
                case SET_PARAMETER:
//flaw_line_below:
                    err = setParameter(node, index, params, size);
//flaw_line_below:
                    break;
//flaw_line_below:
                case GET_CONFIG:
//flaw_line_below:
                    err = getConfig(node, index, params, size);
//flaw_line_below:
                    break;
//flaw_line_below:
                case SET_CONFIG:
//flaw_line_below:
                    err = setConfig(node, index, params, size);
//flaw_line_below:
                    break;
//flaw_line_below:
                case SET_INTERNAL_OPTION:
//flaw_line_below:
                {
//flaw_line_below:
                    InternalOptionType type =
//flaw_line_below:
                        (InternalOptionType)data.readInt32();
//fix_flaw_line_below:
//                            err = setInternalOption(node, index, type, params, size);
//fix_flaw_line_below:
//                            break;
//fix_flaw_line_below:
//                        }
 
//flaw_line_below:
                    err = setInternalOption(node, index, type, params, size);
//flaw_line_below:
                    break;
//fix_flaw_line_below:
//                        default:
//fix_flaw_line_below:
//                            TRESPASS();
//fix_flaw_line_below:
//                    }
                 }
//flaw_line_below:

//flaw_line_below:
                default:
//flaw_line_below:
                    TRESPASS();
             }
 
             reply->writeInt32(err);

 if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {
                reply->write(params, size);
 }

            free(params);
            params = NULL;

 return NO_ERROR;
 }

 case GET_STATE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_STATETYPE state = OMX_StateInvalid;

 status_t err = getState(node, &state);
            reply->writeInt32(state);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case ENABLE_GRAPHIC_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = enableGraphicBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case GET_GRAPHIC_BUFFER_USAGE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            OMX_U32 usage = 0;
 status_t err = getGraphicBufferUsage(node, port_index, &usage);
            reply->writeInt32(err);
            reply->writeInt32(usage);

 return NO_ERROR;
 }

 case USE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = useBuffer(node, port_index, params, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case USE_GRAPHIC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);

            buffer_id buffer;
 status_t err = useGraphicBuffer(
                    node, port_index, graphicBuffer, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case UPDATE_GRAPHIC_BUFFER_IN_META:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
            buffer_id buffer = (buffer_id)data.readInt32();

 status_t err = updateGraphicBufferInMeta(
                    node, port_index, graphicBuffer, buffer);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CREATE_INPUT_SURFACE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            sp<IGraphicBufferProducer> bufferProducer;
 status_t err = createInputSurface(node, port_index,
 &bufferProducer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeStrongBinder(bufferProducer->asBinder());
 }

 return NO_ERROR;
 }

 case SIGNAL_END_OF_INPUT_STREAM:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

 status_t err = signalEndOfInputStream(node);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case STORE_META_DATA_IN_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = storeMetaDataInBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case PREPARE_FOR_ADAPTIVE_PLAYBACK:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();
            OMX_U32 max_width = data.readInt32();
            OMX_U32 max_height = data.readInt32();

 status_t err = prepareForAdaptivePlayback(
                    node, port_index, enable, max_width, max_height);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CONFIGURE_VIDEO_TUNNEL_MODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();
            OMX_U32 audio_hw_sync = data.readInt32();

 native_handle_t *sideband_handle = NULL;
 status_t err = configureVideoTunnelMode(
                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);
            reply->writeInt32(err);
 if(err == OK){
                reply->writeNativeHandle(sideband_handle);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
 if (!isSecure(node) || port_index != 0 /* kPortIndexInput */) {
                ALOGE(""b/24310423"");
                reply->writeInt32(INVALID_OPERATION);
 return NO_ERROR;
 }

 size_t size = data.readInt64();

            buffer_id buffer;
 void *buffer_data;
 status_t err = allocateBuffer(
                    node, port_index, size, &buffer, &buffer_data);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
                reply->writeInt64((uintptr_t)buffer_data);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER_WITH_BACKUP:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = allocateBufferWithBackup(
                    node, port_index, params, &buffer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case FREE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(freeBuffer(node, port_index, buffer));

 return NO_ERROR;
 }

 case FILL_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(fillBuffer(node, buffer));

 return NO_ERROR;
 }

 case EMPTY_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            OMX_U32 range_offset = data.readInt32();
            OMX_U32 range_length = data.readInt32();
            OMX_U32 flags = data.readInt32();
            OMX_TICKS timestamp = data.readInt64();

            reply->writeInt32(
                    emptyBuffer(
                        node, buffer, range_offset, range_length,
                        flags, timestamp));

 return NO_ERROR;
 }

 case GET_EXTENSION_INDEX:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
 const char *parameter_name = data.readCString();

            OMX_INDEXTYPE index;
 status_t err = getExtensionIndex(node, parameter_name, &index);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32(index);
 }

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
",187915,"status_t BnOMX::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case LIVES_LOCALLY:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);
            node_id node = (node_id)data.readInt32();
 pid_t pid = (pid_t)data.readInt32();
            reply->writeInt32(livesLocally(node, pid));

 return OK;
 }

 case LIST_NODES:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 List<ComponentInfo> list;
            listNodes(&list);

            reply->writeInt32(list.size());
 for (List<ComponentInfo>::iterator it = list.begin();
                 it != list.end(); ++it) {
 ComponentInfo &cur = *it;

                reply->writeString8(cur.mName);
                reply->writeInt32(cur.mRoles.size());
 for (List<String8>::iterator role_it = cur.mRoles.begin();
                     role_it != cur.mRoles.end(); ++role_it) {
                    reply->writeString8(*role_it);
 }
 }

 return NO_ERROR;
 }

 case ALLOCATE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 const char *name = data.readCString();

            sp<IOMXObserver> observer =
                interface_cast<IOMXObserver>(data.readStrongBinder());

            node_id node;

 status_t err = allocateNode(name, observer, &node);
            reply->writeInt32(err);
 if (err == OK) {
                reply->writeInt32((int32_t)node);
 }

 return NO_ERROR;
 }

 case FREE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            reply->writeInt32(freeNode(node));

 return NO_ERROR;
 }

 case SEND_COMMAND:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            OMX_COMMANDTYPE cmd =
 static_cast<OMX_COMMANDTYPE>(data.readInt32());

            OMX_S32 param = data.readInt32();
            reply->writeInt32(sendCommand(node, cmd, param));

 return NO_ERROR;
 }

 case GET_PARAMETER:
 case SET_PARAMETER:
 case GET_CONFIG:
 case SET_CONFIG:
 case SET_INTERNAL_OPTION:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());

 
             size_t size = data.readInt64();
 
            void *params = malloc(size);
            data.read(params, size);
 
            status_t err;
            switch (code) {
                case GET_PARAMETER:
                    err = getParameter(node, index, params, size);
                    break;
                case SET_PARAMETER:
                    err = setParameter(node, index, params, size);
                    break;
                case GET_CONFIG:
                    err = getConfig(node, index, params, size);
                    break;
                case SET_CONFIG:
                    err = setConfig(node, index, params, size);
                    break;
                case SET_INTERNAL_OPTION:
                {
                    InternalOptionType type =
                        (InternalOptionType)data.readInt32();
 
                    err = setInternalOption(node, index, type, params, size);
                    break;
                 }
                default:
                    TRESPASS();
             }
 
             reply->writeInt32(err);

 if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {
                reply->write(params, size);
 }

            free(params);
            params = NULL;

 return NO_ERROR;
 }

 case GET_STATE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_STATETYPE state = OMX_StateInvalid;

 status_t err = getState(node, &state);
            reply->writeInt32(state);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case ENABLE_GRAPHIC_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = enableGraphicBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case GET_GRAPHIC_BUFFER_USAGE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            OMX_U32 usage = 0;
 status_t err = getGraphicBufferUsage(node, port_index, &usage);
            reply->writeInt32(err);
            reply->writeInt32(usage);

 return NO_ERROR;
 }

 case USE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = useBuffer(node, port_index, params, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case USE_GRAPHIC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);

            buffer_id buffer;
 status_t err = useGraphicBuffer(
                    node, port_index, graphicBuffer, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case UPDATE_GRAPHIC_BUFFER_IN_META:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
            buffer_id buffer = (buffer_id)data.readInt32();

 status_t err = updateGraphicBufferInMeta(
                    node, port_index, graphicBuffer, buffer);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CREATE_INPUT_SURFACE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            sp<IGraphicBufferProducer> bufferProducer;
 status_t err = createInputSurface(node, port_index,
 &bufferProducer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeStrongBinder(bufferProducer->asBinder());
 }

 return NO_ERROR;
 }

 case SIGNAL_END_OF_INPUT_STREAM:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

 status_t err = signalEndOfInputStream(node);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case STORE_META_DATA_IN_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = storeMetaDataInBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case PREPARE_FOR_ADAPTIVE_PLAYBACK:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();
            OMX_U32 max_width = data.readInt32();
            OMX_U32 max_height = data.readInt32();

 status_t err = prepareForAdaptivePlayback(
                    node, port_index, enable, max_width, max_height);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CONFIGURE_VIDEO_TUNNEL_MODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();
            OMX_U32 audio_hw_sync = data.readInt32();

 native_handle_t *sideband_handle = NULL;
 status_t err = configureVideoTunnelMode(
                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);
            reply->writeInt32(err);
 if(err == OK){
                reply->writeNativeHandle(sideband_handle);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
 if (!isSecure(node) || port_index != 0 /* kPortIndexInput */) {
                ALOGE(""b/24310423"");
                reply->writeInt32(INVALID_OPERATION);
 return NO_ERROR;
 }

 size_t size = data.readInt64();

            buffer_id buffer;
 void *buffer_data;
 status_t err = allocateBuffer(
                    node, port_index, size, &buffer, &buffer_data);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
                reply->writeInt64((uintptr_t)buffer_data);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER_WITH_BACKUP:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = allocateBufferWithBackup(
                    node, port_index, params, &buffer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case FREE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(freeBuffer(node, port_index, buffer));

 return NO_ERROR;
 }

 case FILL_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(fillBuffer(node, buffer));

 return NO_ERROR;
 }

 case EMPTY_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            OMX_U32 range_offset = data.readInt32();
            OMX_U32 range_length = data.readInt32();
            OMX_U32 flags = data.readInt32();
            OMX_TICKS timestamp = data.readInt64();

            reply->writeInt32(
                    emptyBuffer(
                        node, buffer, range_offset, range_length,
                        flags, timestamp));

 return NO_ERROR;
 }

 case GET_EXTENSION_INDEX:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
 const char *parameter_name = data.readCString();

            OMX_INDEXTYPE index;
 status_t err = getExtensionIndex(node, parameter_name, &index);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32(index);
 }

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","status_t BnOMX::onTransact(
 uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
 switch (code) {
 case LIVES_LOCALLY:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);
            node_id node = (node_id)data.readInt32();
 pid_t pid = (pid_t)data.readInt32();
            reply->writeInt32(livesLocally(node, pid));

 return OK;
 }

 case LIST_NODES:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 List<ComponentInfo> list;
            listNodes(&list);

            reply->writeInt32(list.size());
 for (List<ComponentInfo>::iterator it = list.begin();
                 it != list.end(); ++it) {
 ComponentInfo &cur = *it;

                reply->writeString8(cur.mName);
                reply->writeInt32(cur.mRoles.size());
 for (List<String8>::iterator role_it = cur.mRoles.begin();
                     role_it != cur.mRoles.end(); ++role_it) {
                    reply->writeString8(*role_it);
 }
 }

 return NO_ERROR;
 }

 case ALLOCATE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

 const char *name = data.readCString();

            sp<IOMXObserver> observer =
                interface_cast<IOMXObserver>(data.readStrongBinder());

            node_id node;

 status_t err = allocateNode(name, observer, &node);
            reply->writeInt32(err);
 if (err == OK) {
                reply->writeInt32((int32_t)node);
 }

 return NO_ERROR;
 }

 case FREE_NODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            reply->writeInt32(freeNode(node));

 return NO_ERROR;
 }

 case SEND_COMMAND:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

            OMX_COMMANDTYPE cmd =
 static_cast<OMX_COMMANDTYPE>(data.readInt32());

            OMX_S32 param = data.readInt32();
            reply->writeInt32(sendCommand(node, cmd, param));

 return NO_ERROR;
 }

 case GET_PARAMETER:
 case SET_PARAMETER:
 case GET_CONFIG:
 case SET_CONFIG:
 case SET_INTERNAL_OPTION:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());

 
             size_t size = data.readInt64();
 
            status_t err = NO_MEMORY;
            void *params = calloc(size, 1);
            if (params) {
                err = data.read(params, size);
                if (err != OK) {
                    android_errorWriteLog(0x534e4554, ""26914474"");
                } else {
                    switch (code) {
                        case GET_PARAMETER:
                            err = getParameter(node, index, params, size);
                            break;
                        case SET_PARAMETER:
                            err = setParameter(node, index, params, size);
                            break;
                        case GET_CONFIG:
                            err = getConfig(node, index, params, size);
                            break;
                        case SET_CONFIG:
                            err = setConfig(node, index, params, size);
                            break;
                        case SET_INTERNAL_OPTION:
                        {
                            InternalOptionType type =
                                (InternalOptionType)data.readInt32();
 
                            err = setInternalOption(node, index, type, params, size);
                            break;
                        }
 
                        default:
                            TRESPASS();
                    }
                 }
             }
 
             reply->writeInt32(err);

 if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {
                reply->write(params, size);
 }

            free(params);
            params = NULL;

 return NO_ERROR;
 }

 case GET_STATE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_STATETYPE state = OMX_StateInvalid;

 status_t err = getState(node, &state);
            reply->writeInt32(state);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case ENABLE_GRAPHIC_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = enableGraphicBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case GET_GRAPHIC_BUFFER_USAGE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            OMX_U32 usage = 0;
 status_t err = getGraphicBufferUsage(node, port_index, &usage);
            reply->writeInt32(err);
            reply->writeInt32(usage);

 return NO_ERROR;
 }

 case USE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = useBuffer(node, port_index, params, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case USE_GRAPHIC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);

            buffer_id buffer;
 status_t err = useGraphicBuffer(
                    node, port_index, graphicBuffer, &buffer);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case UPDATE_GRAPHIC_BUFFER_IN_META:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
            data.read(*graphicBuffer);
            buffer_id buffer = (buffer_id)data.readInt32();

 status_t err = updateGraphicBufferInMeta(
                    node, port_index, graphicBuffer, buffer);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CREATE_INPUT_SURFACE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();

            sp<IGraphicBufferProducer> bufferProducer;
 status_t err = createInputSurface(node, port_index,
 &bufferProducer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeStrongBinder(bufferProducer->asBinder());
 }

 return NO_ERROR;
 }

 case SIGNAL_END_OF_INPUT_STREAM:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();

 status_t err = signalEndOfInputStream(node);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case STORE_META_DATA_IN_BUFFERS:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();

 status_t err = storeMetaDataInBuffers(node, port_index, enable);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case PREPARE_FOR_ADAPTIVE_PLAYBACK:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL enable = (OMX_BOOL)data.readInt32();
            OMX_U32 max_width = data.readInt32();
            OMX_U32 max_height = data.readInt32();

 status_t err = prepareForAdaptivePlayback(
                    node, port_index, enable, max_width, max_height);
            reply->writeInt32(err);

 return NO_ERROR;
 }

 case CONFIGURE_VIDEO_TUNNEL_MODE:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();
            OMX_U32 audio_hw_sync = data.readInt32();

 native_handle_t *sideband_handle = NULL;
 status_t err = configureVideoTunnelMode(
                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);
            reply->writeInt32(err);
 if(err == OK){
                reply->writeNativeHandle(sideband_handle);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
 if (!isSecure(node) || port_index != 0 /* kPortIndexInput */) {
                ALOGE(""b/24310423"");
                reply->writeInt32(INVALID_OPERATION);
 return NO_ERROR;
 }

 size_t size = data.readInt64();

            buffer_id buffer;
 void *buffer_data;
 status_t err = allocateBuffer(
                    node, port_index, size, &buffer, &buffer_data);
            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
                reply->writeInt64((uintptr_t)buffer_data);
 }

 return NO_ERROR;
 }

 case ALLOC_BUFFER_WITH_BACKUP:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            sp<IMemory> params =
                interface_cast<IMemory>(data.readStrongBinder());

            buffer_id buffer;
 status_t err = allocateBufferWithBackup(
                    node, port_index, params, &buffer);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32((int32_t)buffer);
 }

 return NO_ERROR;
 }

 case FREE_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            OMX_U32 port_index = data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(freeBuffer(node, port_index, buffer));

 return NO_ERROR;
 }

 case FILL_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            reply->writeInt32(fillBuffer(node, buffer));

 return NO_ERROR;
 }

 case EMPTY_BUFFER:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
            buffer_id buffer = (buffer_id)data.readInt32();
            OMX_U32 range_offset = data.readInt32();
            OMX_U32 range_length = data.readInt32();
            OMX_U32 flags = data.readInt32();
            OMX_TICKS timestamp = data.readInt64();

            reply->writeInt32(
                    emptyBuffer(
                        node, buffer, range_offset, range_length,
                        flags, timestamp));

 return NO_ERROR;
 }

 case GET_EXTENSION_INDEX:
 {
            CHECK_OMX_INTERFACE(IOMX, data, reply);

            node_id node = (node_id)data.readInt32();
 const char *parameter_name = data.readCString();

            OMX_INDEXTYPE index;
 status_t err = getExtensionIndex(node, parameter_name, &index);

            reply->writeInt32(err);

 if (err == OK) {
                reply->writeInt32(index);
 }

 return OK;
 }

 default:
 return BBinder::onTransact(code, data, reply, flags);
 }
}
","The `BnOMX::onTransact` function handles various transactions related to the OpenMAX (OMX) interface, processing requests based on a provided `code`. It supports operations such as checking if a node lives locally, listing nodes, allocating and freeing nodes, sending commands, and getting or setting parameters and configurations. The function reads input data from a `Parcel`, executes the corresponding OMX operation, and writes the results back to a reply `Parcel`. It also manages graphic buffers, input surfaces, and buffer allocations, ensuring proper memory management and error handling throughout the process.","The provided code implements a method that processes various requests related to a multimedia framework interface. It handles operations such as checking the local status of nodes, listing available components, and managing node allocation and deallocation. The method also facilitates sending commands, retrieving and setting parameters, and configuring graphic buffers. Additionally, it supports operations for managing input surfaces and buffers, including their allocation and freeing. Each request is processed based on a specific code, with results written back to a response object, ensuring efficient communication and error handling throughout the interactions.","The vulnerability in the original code stemmed from the potential for information leakage due to uninitialized memory being read and returned in response to certain requests, particularly when handling parameters and configurations. Specifically, the use of `malloc` without proper initialization could allow sensitive data to be exposed. The fix involved changing the memory allocation to use `calloc`, which initializes the allocated memory to zero, thereby preventing any residual data from being inadvertently returned. This change ensures that only valid, initialized data is processed and sent back, effectively mitigating the risk of information leakage.","The vulnerability in the original code was due to the potential exposure of sensitive information through uninitialized memory, which could inadvertently return residual data when processing requests. This could lead to information leaks, compromising security. The fix involved changing the memory allocation method to ensure that the allocated memory is initialized to zero, thereby preventing any leftover data from being accessed or returned. This adjustment effectively mitigates the risk of leaking sensitive information, ensuring that only properly initialized data is handled during the processing of requests.","The vulnerability was fixed by replacing the use of `malloc` with `calloc` for memory allocation in the section handling parameters and configurations. This change ensures that the allocated memory is initialized to zero, preventing any uninitialized data from being read and potentially leaked. Specifically, the code now uses `void *params = calloc(size, 1);`, which allocates memory and sets it to zero, thus eliminating the risk of returning sensitive information. Additionally, the error handling was improved to check if the memory allocation was successful before proceeding with reading data, further enhancing security.","The vulnerability was fixed by changing the memory allocation method to ensure that the allocated memory is initialized to zero. This adjustment prevents any uninitialized data from being accessed, which could lead to information leaks. The new approach not only allocates memory but also guarantees that it starts with a clean state, eliminating the risk of returning residual data. Additionally, the error handling was enhanced to verify successful memory allocation before proceeding with data operations, further strengthening the security of the code by ensuring that only valid and initialized data is processed.","CWE-908,CWE-665,CWE-457,CWE-789,CWE-401,CWE-119,CWE-476,CWE-226,CWE-252,CWE-20",N,-1
87,87,187916,187916,,Remote,Not required,Complete,CVE-2016-2416,https://www.cvedetails.com/cve/CVE-2016-2416/,CWE-264,Low,Complete,Complete,,2016-04-17,10.0,"libs/gui/BufferQueueConsumer.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not check for the android.permission.DUMP permission, which allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via a dump request, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27046057.",2016-04-25,Bypass +Info ,1,https://android.googlesource.com/platform/frameworks/native/+/a40b30f5c43726120bfe69d41ff5aeb31fe1d02a,a40b30f5c43726120bfe69d41ff5aeb31fe1d02a,"Add SN logging

Bug 27046057

Change-Id: Iede7c92e59e60795df1ec7768ebafd6b090f1c27
",0,libs/gui/BufferQueueConsumer.cpp,"{""filename"": ""libs/gui/BufferQueueConsumer.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/a40b30f5c43726120bfe69d41ff5aeb31fe1d02a/libs/gui/BufferQueueConsumer.cpp"", ""patch"": ""@@ -529,6 +529,7 @@\n\n             \""android.permission.DUMP\""), pid, uid)) {\n         result.appendFormat(\""Permission Denial: can't dump BufferQueueConsumer \""\n                 \""from pid=%d, uid=%d\\n\"", pid, uid);\n+        android_errorWriteWithInfoLog(0x534e4554, \""27046057\"", uid, NULL, 0);\n     } else {\n         mCore->dump(result, prefix);\n     }\n""}","void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
 const IPCThreadState* ipc = IPCThreadState::self();
 const pid_t pid = ipc->getCallingPid();
 const uid_t uid = ipc->getCallingUid();
 if ((uid != AID_SHELL)
 && !PermissionCache::checkPermission(String16(

             ""android.permission.DUMP""), pid, uid)) {
         result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                 ""from pid=%d, uid=%d\n"", pid, uid);
        android_errorWriteWithInfoLog(0x534e4554, ""27046057"", uid, NULL, 0);
     } else {
         mCore->dump(result, prefix);
     }
}
","void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
 const IPCThreadState* ipc = IPCThreadState::self();
 const pid_t pid = ipc->getCallingPid();
 const uid_t uid = ipc->getCallingUid();
 if ((uid != AID_SHELL)
 && !PermissionCache::checkPermission(String16(

             ""android.permission.DUMP""), pid, uid)) {
         result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                 ""from pid=%d, uid=%d\n"", pid, uid);
     } else {
         mCore->dump(result, prefix);
     }
}
",C,"        android_errorWriteWithInfoLog(0x534e4554, ""27046057"", uid, NULL, 0);
",,,"@@ -529,6 +529,7 @@

             ""android.permission.DUMP""), pid, uid)) {
         result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                 ""from pid=%d, uid=%d\n"", pid, uid);
+        android_errorWriteWithInfoLog(0x534e4554, ""27046057"", uid, NULL, 0);
     } else {
         mCore->dump(result, prefix);
     }
",Android,https://android.googlesource.com/platform/frameworks/native/+/a40b30f5c43726120bfe69d41ff5aeb31fe1d02a/,https://android.googlesource.com/platform/frameworks/native/+/a40b30f5c43726120bfe69d41ff5aeb31fe1d02a%5E/,1,"void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
 const IPCThreadState* ipc = IPCThreadState::self();
 const pid_t pid = ipc->getCallingPid();
 const uid_t uid = ipc->getCallingUid();
 if ((uid != AID_SHELL)
 && !PermissionCache::checkPermission(String16(

             ""android.permission.DUMP""), pid, uid)) {
         result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                 ""from pid=%d, uid=%d\n"", pid, uid);
//fix_flaw_line_below:
//        android_errorWriteWithInfoLog(0x534e4554, ""27046057"", uid, NULL, 0);
     } else {
         mCore->dump(result, prefix);
     }
}
",187916,"void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
 const IPCThreadState* ipc = IPCThreadState::self();
 const pid_t pid = ipc->getCallingPid();
 const uid_t uid = ipc->getCallingUid();
 if ((uid != AID_SHELL)
 && !PermissionCache::checkPermission(String16(

             ""android.permission.DUMP""), pid, uid)) {
         result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                 ""from pid=%d, uid=%d\n"", pid, uid);
     } else {
         mCore->dump(result, prefix);
     }
}
","void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
 const IPCThreadState* ipc = IPCThreadState::self();
 const pid_t pid = ipc->getCallingPid();
 const uid_t uid = ipc->getCallingUid();
 if ((uid != AID_SHELL)
 && !PermissionCache::checkPermission(String16(

             ""android.permission.DUMP""), pid, uid)) {
         result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                 ""from pid=%d, uid=%d\n"", pid, uid);
        android_errorWriteWithInfoLog(0x534e4554, ""27046057"", uid, NULL, 0);
     } else {
         mCore->dump(result, prefix);
     }
}
","The `BufferQueueConsumer::dump` function is designed to output diagnostic information about the `BufferQueueConsumer` object, but only if the calling process has the appropriate permissions. It first retrieves the calling process's PID and UID using `IPCThreadState`. If the UID is not that of the shell and the process lacks the ""android.permission.DUMP"" permission, it appends a permission denial message to the `result` string. If the permission check passes, it calls the `dump` method on the core object (`mCore`), appending the relevant diagnostic information to the `result` string, prefixed by the provided string.","The provided code defines a method that outputs diagnostic information about a specific object, contingent on the caller's permissions. It first checks the identity of the calling process to determine its privileges. If the caller does not have the necessary permissions, a message indicating a denial of access is appended to the output. Conversely, if the caller is authorized, the method retrieves and appends detailed information about the object to the output. This functionality ensures that sensitive information is protected while still allowing authorized users to access relevant diagnostics.","The vulnerability in the original code lies in the lack of logging when a permission denial occurs, which could hinder the ability to track unauthorized access attempts. In the fixed code, an additional logging function, `android_errorWriteWithInfoLog`, was introduced to log the UID of the caller whenever permission is denied. This change enhances security by providing a record of unauthorized access attempts, allowing for better monitoring and response to potential security issues. The logging mechanism thus addresses the oversight of not capturing critical information about failed permission checks in the original implementation.","The vulnerability in the original code stemmed from the absence of logging for unauthorized access attempts, which could prevent effective monitoring and response to potential security breaches. This lack of visibility made it difficult to track instances where permission was denied, potentially allowing malicious activities to go unnoticed. The fixed code addressed this issue by incorporating a logging mechanism that records the user identifier whenever a permission denial occurs. This enhancement not only improves security by providing a trail of unauthorized access attempts but also aids in identifying and mitigating risks associated with improper access to sensitive functionalities.","The vulnerability was fixed by adding a logging mechanism that captures unauthorized access attempts when permission is denied. In the updated code, the function `android_errorWriteWithInfoLog` was introduced to log the user identifier (`uid`) whenever the permission check fails. This logging occurs right after the permission denial message is appended to the result string, ensuring that each instance of unauthorized access is recorded. By implementing this change, the code enhances security monitoring, allowing developers to track and respond to potential security threats more effectively, thereby addressing the oversight present in the original implementation.","The vulnerability was fixed by introducing a logging mechanism that records instances of unauthorized access attempts when permission is denied. This enhancement ensures that whenever a user is denied access due to insufficient permissions, relevant information about the user is logged for monitoring purposes. By capturing these events, the updated code allows for better tracking of potential security breaches, enabling developers to respond more effectively to unauthorized access attempts. This change significantly improves the overall security posture by providing visibility into access control violations that were previously unrecorded.","CWE-285, CWE-862, CWE-287, CWE-264, CWE-266, CWE-732, CWE-778, CWE-223, CWE-778, CWE-284",N,-1
88,88,187928,187928,,Local,Not required,Complete,CVE-2016-0846,https://www.cvedetails.com/cve/CVE-2016-0846/,CWE-264,Low,Complete,Complete,,2016-04-17,7.2,"libs/binder/IMemory.cpp in the IMemory Native Interface in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not properly consider the heap size, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26877992.",2017-09-07,+Priv ,14,https://android.googlesource.com/platform/frameworks/native/+/f3199c228aced7858b75a8070b8358c155ae0149,f3199c228aced7858b75a8070b8358c155ae0149,"Sanity check IMemory access versus underlying mmap

Bug 26877992

Change-Id: Ibbf4b1061e4675e4e96bc944a865b53eaf6984fe
",3,libs/binder/IMemory.cpp,"{""filename"": ""libs/binder/IMemory.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/f3199c228aced7858b75a8070b8358c155ae0149/libs/binder/IMemory.cpp"", ""patch"": ""@@ -26,6 +26,7 @@\n\n #include <sys/mman.h>\n \n #include <binder/IMemory.h>\n+#include <cutils/log.h>\n #include <utils/KeyedVector.h>\n #include <utils/threads.h>\n #include <utils/Atomic.h>\n@@ -187,15 +188,26 @@\n\n             if (heap != 0) {\n                 mHeap = interface_cast<IMemoryHeap>(heap);\n                 if (mHeap != 0) {\n-                    mOffset = o;\n-                    mSize = s;\n+                    size_t heapSize = mHeap->getSize();\n+                    if (s <= heapSize\n+                            && o >= 0\n+                            && (static_cast<size_t>(o) <= heapSize - s)) {\n+                        mOffset = o;\n+                        mSize = s;\n+                    } else {\n+                        // Hm.\n+                        android_errorWriteWithInfoLog(0x534e4554,\n+                            \""26877992\"", -1, NULL, 0);\n+                        mOffset = 0;\n+                        mSize = 0;\n+                    }\n                 }\n             }\n         }\n     }\n     if (offset) *offset = mOffset;\n     if (size) *size = mSize;\n-    return mHeap;\n+    return (mSize > 0) ? mHeap : 0;\n }\n \n // ---------------------------------------------------------------------------\n""}","sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
{
 if (mHeap == 0) {
 Parcel data, reply;
        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());
 if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {
            sp<IBinder> heap = reply.readStrongBinder();
 ssize_t o = reply.readInt32();
 size_t s = reply.readInt32();

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
                    size_t heapSize = mHeap->getSize();
                    if (s <= heapSize
                            && o >= 0
                            && (static_cast<size_t>(o) <= heapSize - s)) {
                        mOffset = o;
                        mSize = s;
                    } else {
                        // Hm.
                        android_errorWriteWithInfoLog(0x534e4554,
                            ""26877992"", -1, NULL, 0);
                        mOffset = 0;
                        mSize = 0;
                    }
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
    return (mSize > 0) ? mHeap : 0;
 }
","sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
{
 if (mHeap == 0) {
 Parcel data, reply;
        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());
 if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {
            sp<IBinder> heap = reply.readStrongBinder();
 ssize_t o = reply.readInt32();
 size_t s = reply.readInt32();

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
                    mOffset = o;
                    mSize = s;
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
    return mHeap;
 }
",C,"                    size_t heapSize = mHeap->getSize();
                    if (s <= heapSize
                            && o >= 0
                            && (static_cast<size_t>(o) <= heapSize - s)) {
                        mOffset = o;
                        mSize = s;
                    } else {
                        // Hm.
                        android_errorWriteWithInfoLog(0x534e4554,
                            ""26877992"", -1, NULL, 0);
                        mOffset = 0;
                        mSize = 0;
                    }
    return (mSize > 0) ? mHeap : 0;
","                    mOffset = o;
                    mSize = s;
    return mHeap;
",,"@@ -26,6 +26,7 @@

 #include <sys/mman.h>
 
 #include <binder/IMemory.h>
+#include <cutils/log.h>
 #include <utils/KeyedVector.h>
 #include <utils/threads.h>
 #include <utils/Atomic.h>
@@ -187,15 +188,26 @@

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
-                    mOffset = o;
-                    mSize = s;
+                    size_t heapSize = mHeap->getSize();
+                    if (s <= heapSize
+                            && o >= 0
+                            && (static_cast<size_t>(o) <= heapSize - s)) {
+                        mOffset = o;
+                        mSize = s;
+                    } else {
+                        // Hm.
+                        android_errorWriteWithInfoLog(0x534e4554,
+                            ""26877992"", -1, NULL, 0);
+                        mOffset = 0;
+                        mSize = 0;
+                    }
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
-    return mHeap;
+    return (mSize > 0) ? mHeap : 0;
 }
 
 // ---------------------------------------------------------------------------
",Android,https://android.googlesource.com/platform/frameworks/native/+/f3199c228aced7858b75a8070b8358c155ae0149/,https://android.googlesource.com/platform/frameworks/native/+/f3199c228aced7858b75a8070b8358c155ae0149%5E/,1,"sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
{
 if (mHeap == 0) {
 Parcel data, reply;
        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());
 if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {
            sp<IBinder> heap = reply.readStrongBinder();
 ssize_t o = reply.readInt32();
 size_t s = reply.readInt32();

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
//flaw_line_below:
                    mOffset = o;
//flaw_line_below:
                    mSize = s;
//fix_flaw_line_below:
//                    size_t heapSize = mHeap->getSize();
//fix_flaw_line_below:
//                    if (s <= heapSize
//fix_flaw_line_below:
//                            && o >= 0
//fix_flaw_line_below:
//                            && (static_cast<size_t>(o) <= heapSize - s)) {
//fix_flaw_line_below:
//                        mOffset = o;
//fix_flaw_line_below:
//                        mSize = s;
//fix_flaw_line_below:
//                    } else {
//fix_flaw_line_below:
//                        // Hm.
//fix_flaw_line_below:
//                        android_errorWriteWithInfoLog(0x534e4554,
//fix_flaw_line_below:
//                            ""26877992"", -1, NULL, 0);
//fix_flaw_line_below:
//                        mOffset = 0;
//fix_flaw_line_below:
//                        mSize = 0;
//fix_flaw_line_below:
//                    }
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
//flaw_line_below:
    return mHeap;
//fix_flaw_line_below:
//    return (mSize > 0) ? mHeap : 0;
 }
",187928,"sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
{
 if (mHeap == 0) {
 Parcel data, reply;
        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());
 if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {
            sp<IBinder> heap = reply.readStrongBinder();
 ssize_t o = reply.readInt32();
 size_t s = reply.readInt32();

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
                    mOffset = o;
                    mSize = s;
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
    return mHeap;
 }
","sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
{
 if (mHeap == 0) {
 Parcel data, reply;
        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());
 if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {
            sp<IBinder> heap = reply.readStrongBinder();
 ssize_t o = reply.readInt32();
 size_t s = reply.readInt32();

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
                    size_t heapSize = mHeap->getSize();
                    if (s <= heapSize
                            && o >= 0
                            && (static_cast<size_t>(o) <= heapSize - s)) {
                        mOffset = o;
                        mSize = s;
                    } else {
                        // Hm.
                        android_errorWriteWithInfoLog(0x534e4554,
                            ""26877992"", -1, NULL, 0);
                        mOffset = 0;
                        mSize = 0;
                    }
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
    return (mSize > 0) ? mHeap : 0;
 }
","The `getMemory` function in the `BpMemory` class retrieves a memory heap from a remote process if it hasn't been previously obtained. Initially, it checks if `mHeap` is null; if so, it creates a `Parcel` to communicate with the remote interface, sending a transaction request to get the memory. Upon receiving a response, it reads a strong binder for the memory heap and its associated offset and size. If the heap is valid, it updates `mHeap`, `mOffset`, and `mSize`. Finally, it assigns the offset and size to the provided pointers and returns the memory heap.","The provided code defines a method that retrieves a memory heap from a remote process if it has not been previously acquired. It first checks if the memory heap is null; if so, it prepares a communication packet to request the memory from the remote interface. Upon receiving a response, it extracts the memory heap along with its associated offset and size. If the memory heap is valid, it updates the internal references accordingly. Finally, it assigns the offset and size to the provided pointers and returns the memory heap, ensuring that the caller has access to the necessary information.","The vulnerability in the original code arises from the lack of validation for the offset and size values obtained from the remote memory heap, which could lead to out-of-bounds access or memory corruption if they are invalid. In the fixed code, additional checks are introduced to ensure that the size does not exceed the actual size of the memory heap and that the offset is non-negative and does not lead to an overflow when combined with the size. If these conditions are not met, the code logs an error and resets the offset and size to zero, thereby preventing potential exploitation.","The vulnerability in the original code stems from insufficient validation of the memory offset and size values retrieved from a remote memory heap, which could allow for out-of-bounds access and potential memory corruption. This lack of checks could lead to unauthorized access to memory regions, posing a security risk. The fixed code addresses this issue by implementing sanity checks to ensure that the size does not exceed the actual memory size and that the offset is valid. If these conditions are not satisfied, the code logs an error and resets the values, effectively mitigating the risk of exploitation.","The vulnerability was fixed by introducing sanity checks for the offset and size values in the updated code. After retrieving the size of the memory heap using `mHeap->getSize()`, the code verifies that the retrieved size does not exceed the actual heap size and that the offset is non-negative and does not cause an overflow when combined with the size. Specifically, it checks that the size is less than or equal to the heap size, the offset is greater than or equal to zero, and the sum of the offset and size does not exceed the heap size. If any of these conditions fail, the code logs an error and resets the offset and size to zero, thereby preventing potential memory access violations.","The vulnerability was fixed by implementing validation checks to ensure that the retrieved memory offset and size are within safe limits. The updated code verifies that the size does not exceed the actual memory available and that the offset is non-negative and does not lead to an overflow when combined with the size. If any of these conditions are not met, the code logs an error and resets the offset and size to zero. This approach effectively mitigates the risk of out-of-bounds memory access and potential exploitation, enhancing the overall security of the memory handling process.","CWE-119, CWE-125, CWE-787, CWE-823, CWE-789, CWE-124, CWE-126, CWE-788, CWE-120, CWE-122",N,-1
89,89,187958,187958,,Remote,Not required,Complete,CVE-2016-0826,https://www.cvedetails.com/cve/CVE-2016-0826/,CWE-264,Medium,Complete,Complete,,2016-03-12,9.3,"libcameraservice in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not require use of the ICameraService::dump method for a camera service dump, which allows attackers to gain privileges via a crafted application that directly dumps, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26265403.",2016-11-28,+Priv ,1,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122,c9ab2b0bb05a7e19fb057e79b36e232809d70122,"Camera: Disallow dumping clients directly

Camera service dumps should only be initiated through
ICameraService::dump.

Bug: 26265403
Change-Id: If3ca4718ed74bf33ad8a416192689203029e2803
",1,services/camera/libcameraservice/CameraService.cpp,"{""filename"": ""services/camera/libcameraservice/CameraService.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.cpp"", ""patch"": ""@@ -985,6 +985,14 @@\n\n     mClientPid = 0;\n }\n \n+status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {\n+    // No dumping of clients directly over Binder,\n+    // must go through CameraService::dump\n+    android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, \""26265403\"",\n+            IPCThreadState::self()->getCallingUid(), NULL, 0);\n+    return OK;\n+}\n+\n status_t CameraService::BasicClient::startCameraOps() {\n     int32_t res;\n \n@@ -1222,7 +1230,7 @@\n\n             hasClient = true;\n             result = String8::format(\""  Device is open. Client instance dump:\\n\"");\n             write(fd, result.string(), result.size());\n-            client->dump(fd, args);\n+            client->dumpClient(fd, args);\n         }\n         if (!hasClient) {\n             result = String8::format(\""\\nNo active camera clients yet.\\n\"");\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/CameraService.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.h"", ""patch"": ""@@ -55,6 +55,9 @@\n\n     class Client;\n     class BasicClient;\n \n+    // Event log ID\n+    static const int SN_EVENT_LOG_ID = 0x534e4554;\n+\n     // Implementation of BinderService<T>\n     static char const* getServiceName() { return \""media.camera\""; }\n \n@@ -144,7 +147,10 @@\n\n             return mRemoteBinder;\n         }\n \n-        virtual status_t      dump(int fd, const Vector<String16>& args) = 0;\n+        // Disallows dumping over binder interface\n+        virtual status_t      dump(int fd, const Vector<String16>& args);\n+        // Internal dump method to be called by CameraService\n+        virtual status_t      dumpClient(int fd, const Vector<String16>& args) = 0;\n \n     protected:\n         BasicClient(const sp<CameraService>& cameraService,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.cpp"", ""patch"": ""@@ -158,6 +158,10 @@\n\n }\n \n status_t Camera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Client2[%d] (%p) Client: %s PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.h"", ""patch"": ""@@ -98,6 +98,8 @@\n\n \n     virtual status_t dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Interface used by CameraDeviceBase\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.cpp"", ""patch"": ""@@ -112,6 +112,10 @@\n\n }\n \n status_t CameraClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {\n     const size_t SIZE = 256;\n     char buffer[SIZE];\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.h"", ""patch"": ""@@ -69,7 +69,9 @@\n\n \n     status_t initialize(camera_module_t *module);\n \n-    status_t dump(int fd, const Vector<String16>& args);\n+    virtual status_t dump(int fd, const Vector<String16>& args);\n+\n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n \n private:\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""patch"": ""@@ -480,6 +480,10 @@\n\n }\n \n status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""patch"": ""@@ -109,6 +109,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Device listener interface\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""patch"": ""@@ -331,6 +331,10 @@\n\n }\n \n status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""ProCamera2Client[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""patch"": ""@@ -88,6 +88,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     // Callbacks from camera service\n     virtual void onExclusiveLockStolen();\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""patch"": ""@@ -117,7 +117,7 @@\n\n }\n \n template <typename TClientBase>\n-status_t Camera2ClientBase<TClientBase>::dump(int fd,\n+status_t Camera2ClientBase<TClientBase>::dumpClient(int fd,\n                                               const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Camera2ClientBase[%d] (%p) PID: %d, dump:\\n\"",\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.h"", ""patch"": ""@@ -55,7 +55,7 @@\n\n     virtual ~Camera2ClientBase();\n \n     virtual status_t      initialize(camera_module_t *module);\n-    virtual status_t      dump(int fd, const Vector<String16>& args);\n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n \n     /**\n      * CameraDeviceBase::NotificationListener implementation\n""}","status_t CameraService::dump(int fd, const Vector<String16>& args) {
 String8 result;
 if (checkCallingPermission(String16(""android.permission.DUMP"")) == false) {
        result.appendFormat(""Permission Denial: ""
 ""can't dump CameraService from pid=%d, uid=%d\n"",
                getCallingPid(),
                getCallingUid());
        write(fd, result.string(), result.size());
 } else {
 bool locked = tryLock(mServiceLock);
 if (!locked) {
            result.append(""CameraService may be deadlocked\n"");
            write(fd, result.string(), result.size());
 }

 bool hasClient = false;
 if (!mModule) {
            result = String8::format(""No camera module available!\n"");
            write(fd, result.string(), result.size());
 return NO_ERROR;
 }

        result = String8::format(""Camera module HAL API version: 0x%x\n"",
                mModule->common.hal_api_version);
        result.appendFormat(""Camera module API version: 0x%x\n"",
                mModule->common.module_api_version);
        result.appendFormat(""Camera module name: %s\n"",
                mModule->common.name);
        result.appendFormat(""Camera module author: %s\n"",
                mModule->common.author);
        result.appendFormat(""Number of camera devices: %d\n\n"", mNumberOfCameras);
        write(fd, result.string(), result.size());
 for (int i = 0; i < mNumberOfCameras; i++) {
            result = String8::format(""Camera %d static information:\n"", i);
            camera_info info;

 status_t rc = mModule->get_camera_info(i, &info);
 if (rc != OK) {
                result.appendFormat(""  Error reading static information!\n"");
                write(fd, result.string(), result.size());
 } else {
                result.appendFormat(""  Facing: %s\n"",
                        info.facing == CAMERA_FACING_BACK ? ""BACK"" : ""FRONT"");
                result.appendFormat(""  Orientation: %d\n"", info.orientation);
 int deviceVersion;
 if (mModule->common.module_api_version <
                        CAMERA_MODULE_API_VERSION_2_0) {
                    deviceVersion = CAMERA_DEVICE_API_VERSION_1_0;
 } else {
                    deviceVersion = info.device_version;
 }
                result.appendFormat(""  Device version: 0x%x\n"", deviceVersion);
 if (deviceVersion >= CAMERA_DEVICE_API_VERSION_2_0) {
                    result.appendFormat(""  Device static metadata:\n"");
                    write(fd, result.string(), result.size());
                    dump_indented_camera_metadata(info.static_camera_characteristics,
                            fd, 2, 4);
 } else {
                    write(fd, result.string(), result.size());
 }
 }

            sp<BasicClient> client = mClient[i].promote();
 if (client == 0) {
                result = String8::format(""  Device is closed, no client instance\n"");
                write(fd, result.string(), result.size());
 continue;
 }

             hasClient = true;
             result = String8::format(""  Device is open. Client instance dump:\n"");
             write(fd, result.string(), result.size());
            client->dumpClient(fd, args);
         }
         if (!hasClient) {
             result = String8::format(""\nNo active camera clients yet.\n"");
            write(fd, result.string(), result.size());
 }

 if (locked) mServiceLock.unlock();

        write(fd, ""\n"", 1);
        camera3::CameraTraces::dump(fd, args);

 int n = args.size();
 for (int i = 0; i + 1 < n; i++) {
 String16 verboseOption(""-v"");
 if (args[i] == verboseOption) {
 String8 levelStr(args[i+1]);
 int level = atoi(levelStr.string());
                result = String8::format(""\nSetting log level to %d.\n"", level);
                setLogLevel(level);
                write(fd, result.string(), result.size());
 }
 }

 }
 return NO_ERROR;
}
","status_t CameraService::dump(int fd, const Vector<String16>& args) {
 String8 result;
 if (checkCallingPermission(String16(""android.permission.DUMP"")) == false) {
        result.appendFormat(""Permission Denial: ""
 ""can't dump CameraService from pid=%d, uid=%d\n"",
                getCallingPid(),
                getCallingUid());
        write(fd, result.string(), result.size());
 } else {
 bool locked = tryLock(mServiceLock);
 if (!locked) {
            result.append(""CameraService may be deadlocked\n"");
            write(fd, result.string(), result.size());
 }

 bool hasClient = false;
 if (!mModule) {
            result = String8::format(""No camera module available!\n"");
            write(fd, result.string(), result.size());
 return NO_ERROR;
 }

        result = String8::format(""Camera module HAL API version: 0x%x\n"",
                mModule->common.hal_api_version);
        result.appendFormat(""Camera module API version: 0x%x\n"",
                mModule->common.module_api_version);
        result.appendFormat(""Camera module name: %s\n"",
                mModule->common.name);
        result.appendFormat(""Camera module author: %s\n"",
                mModule->common.author);
        result.appendFormat(""Number of camera devices: %d\n\n"", mNumberOfCameras);
        write(fd, result.string(), result.size());
 for (int i = 0; i < mNumberOfCameras; i++) {
            result = String8::format(""Camera %d static information:\n"", i);
            camera_info info;

 status_t rc = mModule->get_camera_info(i, &info);
 if (rc != OK) {
                result.appendFormat(""  Error reading static information!\n"");
                write(fd, result.string(), result.size());
 } else {
                result.appendFormat(""  Facing: %s\n"",
                        info.facing == CAMERA_FACING_BACK ? ""BACK"" : ""FRONT"");
                result.appendFormat(""  Orientation: %d\n"", info.orientation);
 int deviceVersion;
 if (mModule->common.module_api_version <
                        CAMERA_MODULE_API_VERSION_2_0) {
                    deviceVersion = CAMERA_DEVICE_API_VERSION_1_0;
 } else {
                    deviceVersion = info.device_version;
 }
                result.appendFormat(""  Device version: 0x%x\n"", deviceVersion);
 if (deviceVersion >= CAMERA_DEVICE_API_VERSION_2_0) {
                    result.appendFormat(""  Device static metadata:\n"");
                    write(fd, result.string(), result.size());
                    dump_indented_camera_metadata(info.static_camera_characteristics,
                            fd, 2, 4);
 } else {
                    write(fd, result.string(), result.size());
 }
 }

            sp<BasicClient> client = mClient[i].promote();
 if (client == 0) {
                result = String8::format(""  Device is closed, no client instance\n"");
                write(fd, result.string(), result.size());
 continue;
 }

             hasClient = true;
             result = String8::format(""  Device is open. Client instance dump:\n"");
             write(fd, result.string(), result.size());
            client->dump(fd, args);
         }
         if (!hasClient) {
             result = String8::format(""\nNo active camera clients yet.\n"");
            write(fd, result.string(), result.size());
 }

 if (locked) mServiceLock.unlock();

        write(fd, ""\n"", 1);
        camera3::CameraTraces::dump(fd, args);

 int n = args.size();
 for (int i = 0; i + 1 < n; i++) {
 String16 verboseOption(""-v"");
 if (args[i] == verboseOption) {
 String8 levelStr(args[i+1]);
 int level = atoi(levelStr.string());
                result = String8::format(""\nSetting log level to %d.\n"", level);
                setLogLevel(level);
                write(fd, result.string(), result.size());
 }
 }

 }
 return NO_ERROR;
}
",C,"            client->dumpClient(fd, args);
","            client->dump(fd, args);
",,"@@ -985,6 +985,14 @@

     mClientPid = 0;
 }
 
+status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {
+    // No dumping of clients directly over Binder,
+    // must go through CameraService::dump
+    android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, ""26265403"",
+            IPCThreadState::self()->getCallingUid(), NULL, 0);
+    return OK;
+}
+
 status_t CameraService::BasicClient::startCameraOps() {
     int32_t res;
 
@@ -1222,7 +1230,7 @@

             hasClient = true;
             result = String8::format(""  Device is open. Client instance dump:\n"");
             write(fd, result.string(), result.size());
-            client->dump(fd, args);
+            client->dumpClient(fd, args);
         }
         if (!hasClient) {
             result = String8::format(""\nNo active camera clients yet.\n"");
",Android,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122%5E/,1,"status_t CameraService::dump(int fd, const Vector<String16>& args) {
 String8 result;
 if (checkCallingPermission(String16(""android.permission.DUMP"")) == false) {
        result.appendFormat(""Permission Denial: ""
 ""can't dump CameraService from pid=%d, uid=%d\n"",
                getCallingPid(),
                getCallingUid());
        write(fd, result.string(), result.size());
 } else {
 bool locked = tryLock(mServiceLock);
 // failed to lock - CameraService is probably deadlocked
 if (!locked) {
            result.append(""CameraService may be deadlocked\n"");
            write(fd, result.string(), result.size());
 }

 bool hasClient = false;
 if (!mModule) {
            result = String8::format(""No camera module available!\n"");
            write(fd, result.string(), result.size());
 return NO_ERROR;
 }

        result = String8::format(""Camera module HAL API version: 0x%x\n"",
                mModule->common.hal_api_version);
        result.appendFormat(""Camera module API version: 0x%x\n"",
                mModule->common.module_api_version);
        result.appendFormat(""Camera module name: %s\n"",
                mModule->common.name);
        result.appendFormat(""Camera module author: %s\n"",
                mModule->common.author);
        result.appendFormat(""Number of camera devices: %d\n\n"", mNumberOfCameras);
        write(fd, result.string(), result.size());
 for (int i = 0; i < mNumberOfCameras; i++) {
            result = String8::format(""Camera %d static information:\n"", i);
            camera_info info;

 status_t rc = mModule->get_camera_info(i, &info);
 if (rc != OK) {
                result.appendFormat(""  Error reading static information!\n"");
                write(fd, result.string(), result.size());
 } else {
                result.appendFormat(""  Facing: %s\n"",
                        info.facing == CAMERA_FACING_BACK ? ""BACK"" : ""FRONT"");
                result.appendFormat(""  Orientation: %d\n"", info.orientation);
 int deviceVersion;
 if (mModule->common.module_api_version <
                        CAMERA_MODULE_API_VERSION_2_0) {
                    deviceVersion = CAMERA_DEVICE_API_VERSION_1_0;
 } else {
                    deviceVersion = info.device_version;
 }
                result.appendFormat(""  Device version: 0x%x\n"", deviceVersion);
 if (deviceVersion >= CAMERA_DEVICE_API_VERSION_2_0) {
                    result.appendFormat(""  Device static metadata:\n"");
                    write(fd, result.string(), result.size());
                    dump_indented_camera_metadata(info.static_camera_characteristics,
                            fd, 2, 4);
 } else {
                    write(fd, result.string(), result.size());
 }
 }

            sp<BasicClient> client = mClient[i].promote();
 if (client == 0) {
                result = String8::format(""  Device is closed, no client instance\n"");
                write(fd, result.string(), result.size());
 continue;
 }

             hasClient = true;
             result = String8::format(""  Device is open. Client instance dump:\n"");
             write(fd, result.string(), result.size());
//flaw_line_below:
            client->dump(fd, args);
//fix_flaw_line_below:
//            client->dumpClient(fd, args);
         }
         if (!hasClient) {
             result = String8::format(""\nNo active camera clients yet.\n"");
            write(fd, result.string(), result.size());
 }

 if (locked) mServiceLock.unlock();

 // Dump camera traces if there were any
        write(fd, ""\n"", 1);
        camera3::CameraTraces::dump(fd, args);

 // change logging level
 int n = args.size();
 for (int i = 0; i + 1 < n; i++) {
 String16 verboseOption(""-v"");
 if (args[i] == verboseOption) {
 String8 levelStr(args[i+1]);
 int level = atoi(levelStr.string());
                result = String8::format(""\nSetting log level to %d.\n"", level);
                setLogLevel(level);
                write(fd, result.string(), result.size());
 }
 }

 }
 return NO_ERROR;
}
",187958,"status_t CameraService::dump(int fd, const Vector<String16>& args) {
 String8 result;
 if (checkCallingPermission(String16(""android.permission.DUMP"")) == false) {
        result.appendFormat(""Permission Denial: ""
 ""can't dump CameraService from pid=%d, uid=%d\n"",
                getCallingPid(),
                getCallingUid());
        write(fd, result.string(), result.size());
 } else {
 bool locked = tryLock(mServiceLock);
 if (!locked) {
            result.append(""CameraService may be deadlocked\n"");
            write(fd, result.string(), result.size());
 }

 bool hasClient = false;
 if (!mModule) {
            result = String8::format(""No camera module available!\n"");
            write(fd, result.string(), result.size());
 return NO_ERROR;
 }

        result = String8::format(""Camera module HAL API version: 0x%x\n"",
                mModule->common.hal_api_version);
        result.appendFormat(""Camera module API version: 0x%x\n"",
                mModule->common.module_api_version);
        result.appendFormat(""Camera module name: %s\n"",
                mModule->common.name);
        result.appendFormat(""Camera module author: %s\n"",
                mModule->common.author);
        result.appendFormat(""Number of camera devices: %d\n\n"", mNumberOfCameras);
        write(fd, result.string(), result.size());
 for (int i = 0; i < mNumberOfCameras; i++) {
            result = String8::format(""Camera %d static information:\n"", i);
            camera_info info;

 status_t rc = mModule->get_camera_info(i, &info);
 if (rc != OK) {
                result.appendFormat(""  Error reading static information!\n"");
                write(fd, result.string(), result.size());
 } else {
                result.appendFormat(""  Facing: %s\n"",
                        info.facing == CAMERA_FACING_BACK ? ""BACK"" : ""FRONT"");
                result.appendFormat(""  Orientation: %d\n"", info.orientation);
 int deviceVersion;
 if (mModule->common.module_api_version <
                        CAMERA_MODULE_API_VERSION_2_0) {
                    deviceVersion = CAMERA_DEVICE_API_VERSION_1_0;
 } else {
                    deviceVersion = info.device_version;
 }
                result.appendFormat(""  Device version: 0x%x\n"", deviceVersion);
 if (deviceVersion >= CAMERA_DEVICE_API_VERSION_2_0) {
                    result.appendFormat(""  Device static metadata:\n"");
                    write(fd, result.string(), result.size());
                    dump_indented_camera_metadata(info.static_camera_characteristics,
                            fd, 2, 4);
 } else {
                    write(fd, result.string(), result.size());
 }
 }

            sp<BasicClient> client = mClient[i].promote();
 if (client == 0) {
                result = String8::format(""  Device is closed, no client instance\n"");
                write(fd, result.string(), result.size());
 continue;
 }

             hasClient = true;
             result = String8::format(""  Device is open. Client instance dump:\n"");
             write(fd, result.string(), result.size());
            client->dump(fd, args);
         }
         if (!hasClient) {
             result = String8::format(""\nNo active camera clients yet.\n"");
            write(fd, result.string(), result.size());
 }

 if (locked) mServiceLock.unlock();

        write(fd, ""\n"", 1);
        camera3::CameraTraces::dump(fd, args);

 int n = args.size();
 for (int i = 0; i + 1 < n; i++) {
 String16 verboseOption(""-v"");
 if (args[i] == verboseOption) {
 String8 levelStr(args[i+1]);
 int level = atoi(levelStr.string());
                result = String8::format(""\nSetting log level to %d.\n"", level);
                setLogLevel(level);
                write(fd, result.string(), result.size());
 }
 }

 }
 return NO_ERROR;
}
","status_t CameraService::dump(int fd, const Vector<String16>& args) {
 String8 result;
 if (checkCallingPermission(String16(""android.permission.DUMP"")) == false) {
        result.appendFormat(""Permission Denial: ""
 ""can't dump CameraService from pid=%d, uid=%d\n"",
                getCallingPid(),
                getCallingUid());
        write(fd, result.string(), result.size());
 } else {
 bool locked = tryLock(mServiceLock);
 if (!locked) {
            result.append(""CameraService may be deadlocked\n"");
            write(fd, result.string(), result.size());
 }

 bool hasClient = false;
 if (!mModule) {
            result = String8::format(""No camera module available!\n"");
            write(fd, result.string(), result.size());
 return NO_ERROR;
 }

        result = String8::format(""Camera module HAL API version: 0x%x\n"",
                mModule->common.hal_api_version);
        result.appendFormat(""Camera module API version: 0x%x\n"",
                mModule->common.module_api_version);
        result.appendFormat(""Camera module name: %s\n"",
                mModule->common.name);
        result.appendFormat(""Camera module author: %s\n"",
                mModule->common.author);
        result.appendFormat(""Number of camera devices: %d\n\n"", mNumberOfCameras);
        write(fd, result.string(), result.size());
 for (int i = 0; i < mNumberOfCameras; i++) {
            result = String8::format(""Camera %d static information:\n"", i);
            camera_info info;

 status_t rc = mModule->get_camera_info(i, &info);
 if (rc != OK) {
                result.appendFormat(""  Error reading static information!\n"");
                write(fd, result.string(), result.size());
 } else {
                result.appendFormat(""  Facing: %s\n"",
                        info.facing == CAMERA_FACING_BACK ? ""BACK"" : ""FRONT"");
                result.appendFormat(""  Orientation: %d\n"", info.orientation);
 int deviceVersion;
 if (mModule->common.module_api_version <
                        CAMERA_MODULE_API_VERSION_2_0) {
                    deviceVersion = CAMERA_DEVICE_API_VERSION_1_0;
 } else {
                    deviceVersion = info.device_version;
 }
                result.appendFormat(""  Device version: 0x%x\n"", deviceVersion);
 if (deviceVersion >= CAMERA_DEVICE_API_VERSION_2_0) {
                    result.appendFormat(""  Device static metadata:\n"");
                    write(fd, result.string(), result.size());
                    dump_indented_camera_metadata(info.static_camera_characteristics,
                            fd, 2, 4);
 } else {
                    write(fd, result.string(), result.size());
 }
 }

            sp<BasicClient> client = mClient[i].promote();
 if (client == 0) {
                result = String8::format(""  Device is closed, no client instance\n"");
                write(fd, result.string(), result.size());
 continue;
 }

             hasClient = true;
             result = String8::format(""  Device is open. Client instance dump:\n"");
             write(fd, result.string(), result.size());
            client->dumpClient(fd, args);
         }
         if (!hasClient) {
             result = String8::format(""\nNo active camera clients yet.\n"");
            write(fd, result.string(), result.size());
 }

 if (locked) mServiceLock.unlock();

        write(fd, ""\n"", 1);
        camera3::CameraTraces::dump(fd, args);

 int n = args.size();
 for (int i = 0; i + 1 < n; i++) {
 String16 verboseOption(""-v"");
 if (args[i] == verboseOption) {
 String8 levelStr(args[i+1]);
 int level = atoi(levelStr.string());
                result = String8::format(""\nSetting log level to %d.\n"", level);
                setLogLevel(level);
                write(fd, result.string(), result.size());
 }
 }

 }
 return NO_ERROR;
}
","The `CameraService::dump` function is designed to provide diagnostic information about the camera service in an Android environment. It first checks if the calling process has the necessary permissions to access the camera service data. If permission is granted, it attempts to lock the service to prevent deadlocks and retrieves details about the camera module, including its API versions, name, author, and the number of available camera devices. For each camera, it gathers static information, such as orientation and facing direction, and checks for active client instances. It also allows for setting a log level based on provided arguments, ensuring comprehensive logging and debugging capabilities.","The provided code implements a diagnostic function for a camera service in an Android system, allowing authorized users to retrieve detailed information about the camera module and its devices. It checks for necessary permissions and attempts to prevent deadlocks while gathering data about the camera module, including its API versions, name, and author. For each camera device, it collects static information such as orientation and facing direction, and checks for active client instances. Additionally, the function supports adjusting logging levels based on user input, facilitating effective monitoring and debugging of the camera service.","The vulnerability in the original code stemmed from allowing direct dumping of client instances, which could lead to unauthorized access to sensitive information about the camera service. This was addressed in the fixed code by ensuring that client dumps are only performed through a designated interface, specifically `ICameraService::dump`, thereby enforcing stricter access controls. The change prevents potential exploitation by limiting how and when client information can be accessed, ensuring that only authorized calls can trigger the dump process, thus enhancing the overall security of the camera service.","The vulnerability in the original code allowed unauthorized access to sensitive information by permitting direct dumping of client instances, which could be exploited by malicious actors. This posed a risk of revealing internal state and data related to the camera service. The fix implemented in the updated code restricts the ability to initiate client dumps, ensuring that such actions can only occur through a specific, controlled interface. This change enhances security by enforcing stricter access controls, thereby preventing unauthorized information disclosure and ensuring that only legitimate requests can access sensitive camera service data.","The vulnerability was fixed by modifying the code to disallow direct dumping of client instances, which was previously done using the `client->dumpClient(fd, args)` call. Instead, the updated implementation mandates that all camera service dumps must be initiated through the `ICameraService::dump` interface. This change ensures that sensitive information about client instances can only be accessed through a controlled and authorized method, thereby preventing unauthorized access. By enforcing this restriction, the code enhances security and mitigates the risk of exposing internal camera service data to potential attackers.","The vulnerability was fixed by implementing a restriction that prevents direct access to sensitive client information. Instead of allowing client data to be dumped freely, the updated code requires that all requests for such information go through a specific, controlled interface. This change ensures that only authorized calls can initiate the dumping process, thereby enhancing security and preventing unauthorized access to internal state and data. By enforcing this controlled access, the risk of exposing sensitive information is significantly reduced, protecting the integrity of the camera service.","CWE-200, CWE-284, CWE-285, CWE-732, CWE-269, CWE-346, CWE-749, CWE-213, CWE-359, CWE-931",N,-1
90,90,187959,187959,,Remote,Not required,Complete,CVE-2016-0826,https://www.cvedetails.com/cve/CVE-2016-0826/,CWE-264,Medium,Complete,Complete,,2016-03-12,9.3,"libcameraservice in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not require use of the ICameraService::dump method for a camera service dump, which allows attackers to gain privileges via a crafted application that directly dumps, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26265403.",2016-11-28,+Priv ,4,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122,c9ab2b0bb05a7e19fb057e79b36e232809d70122,"Camera: Disallow dumping clients directly

Camera service dumps should only be initiated through
ICameraService::dump.

Bug: 26265403
Change-Id: If3ca4718ed74bf33ad8a416192689203029e2803
",0,services/camera/libcameraservice/api1/Camera2Client.cpp,"{""filename"": ""services/camera/libcameraservice/CameraService.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.cpp"", ""patch"": ""@@ -985,6 +985,14 @@\n\n     mClientPid = 0;\n }\n \n+status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {\n+    // No dumping of clients directly over Binder,\n+    // must go through CameraService::dump\n+    android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, \""26265403\"",\n+            IPCThreadState::self()->getCallingUid(), NULL, 0);\n+    return OK;\n+}\n+\n status_t CameraService::BasicClient::startCameraOps() {\n     int32_t res;\n \n@@ -1222,7 +1230,7 @@\n\n             hasClient = true;\n             result = String8::format(\""  Device is open. Client instance dump:\\n\"");\n             write(fd, result.string(), result.size());\n-            client->dump(fd, args);\n+            client->dumpClient(fd, args);\n         }\n         if (!hasClient) {\n             result = String8::format(\""\\nNo active camera clients yet.\\n\"");\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/CameraService.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.h"", ""patch"": ""@@ -55,6 +55,9 @@\n\n     class Client;\n     class BasicClient;\n \n+    // Event log ID\n+    static const int SN_EVENT_LOG_ID = 0x534e4554;\n+\n     // Implementation of BinderService<T>\n     static char const* getServiceName() { return \""media.camera\""; }\n \n@@ -144,7 +147,10 @@\n\n             return mRemoteBinder;\n         }\n \n-        virtual status_t      dump(int fd, const Vector<String16>& args) = 0;\n+        // Disallows dumping over binder interface\n+        virtual status_t      dump(int fd, const Vector<String16>& args);\n+        // Internal dump method to be called by CameraService\n+        virtual status_t      dumpClient(int fd, const Vector<String16>& args) = 0;\n \n     protected:\n         BasicClient(const sp<CameraService>& cameraService,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.cpp"", ""patch"": ""@@ -158,6 +158,10 @@\n\n }\n \n status_t Camera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Client2[%d] (%p) Client: %s PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.h"", ""patch"": ""@@ -98,6 +98,8 @@\n\n \n     virtual status_t dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Interface used by CameraDeviceBase\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.cpp"", ""patch"": ""@@ -112,6 +112,10 @@\n\n }\n \n status_t CameraClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {\n     const size_t SIZE = 256;\n     char buffer[SIZE];\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.h"", ""patch"": ""@@ -69,7 +69,9 @@\n\n \n     status_t initialize(camera_module_t *module);\n \n-    status_t dump(int fd, const Vector<String16>& args);\n+    virtual status_t dump(int fd, const Vector<String16>& args);\n+\n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n \n private:\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""patch"": ""@@ -480,6 +480,10 @@\n\n }\n \n status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""patch"": ""@@ -109,6 +109,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Device listener interface\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""patch"": ""@@ -331,6 +331,10 @@\n\n }\n \n status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""ProCamera2Client[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""patch"": ""@@ -88,6 +88,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     // Callbacks from camera service\n     virtual void onExclusiveLockStolen();\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""patch"": ""@@ -117,7 +117,7 @@\n\n }\n \n template <typename TClientBase>\n-status_t Camera2ClientBase<TClientBase>::dump(int fd,\n+status_t Camera2ClientBase<TClientBase>::dumpClient(int fd,\n                                               const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Camera2ClientBase[%d] (%p) PID: %d, dump:\\n\"",\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.h"", ""patch"": ""@@ -55,7 +55,7 @@\n\n     virtual ~Camera2ClientBase();\n \n     virtual status_t      initialize(camera_module_t *module);\n-    virtual status_t      dump(int fd, const Vector<String16>& args);\n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n \n     /**\n      * CameraDeviceBase::NotificationListener implementation\n""}"," status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""Client2[%d] (%p) Client: %s PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
 String8(mClientPackageName).string(),
            mClientPid);
    result.append(""  State: "");
#define CASE_APPEND_ENUM(x) case x: result.append(#x ""\n""); break;

 const Parameters& p = mParameters.unsafeAccess();

    result.append(Parameters::getStateName(p.state));

    result.append(""\n  Current parameters:\n"");
    result.appendFormat(""    Preview size: %d x %d\n"",
            p.previewWidth, p.previewHeight);
    result.appendFormat(""    Preview FPS range: %d - %d\n"",
            p.previewFpsRange[0], p.previewFpsRange[1]);
    result.appendFormat(""    Preview HAL pixel format: 0x%x\n"",
            p.previewFormat);
    result.appendFormat(""    Preview transform: %x\n"",
            p.previewTransform);
    result.appendFormat(""    Picture size: %d x %d\n"",
            p.pictureWidth, p.pictureHeight);
    result.appendFormat(""    Jpeg thumbnail size: %d x %d\n"",
            p.jpegThumbSize[0], p.jpegThumbSize[1]);
    result.appendFormat(""    Jpeg quality: %d, thumbnail quality: %d\n"",
            p.jpegQuality, p.jpegThumbQuality);
    result.appendFormat(""    Jpeg rotation: %d\n"", p.jpegRotation);
    result.appendFormat(""    GPS tags %s\n"",
            p.gpsEnabled ? ""enabled"" : ""disabled"");
 if (p.gpsEnabled) {
        result.appendFormat(""    GPS lat x long x alt: %f x %f x %f\n"",
                p.gpsCoordinates[0], p.gpsCoordinates[1],
                p.gpsCoordinates[2]);
        result.appendFormat(""    GPS timestamp: %lld\n"",
                p.gpsTimestamp);
        result.appendFormat(""    GPS processing method: %s\n"",
                p.gpsProcessingMethod.string());
 }

    result.append(""    White balance mode: "");
 switch (p.wbMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_INCANDESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_WARM_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_TWILIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_SHADE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Effect mode: "");
 switch (p.effectMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_MONO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_NEGATIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SOLARIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SEPIA)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_POSTERIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_WHITEBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_BLACKBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_AQUA)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Antibanding mode: "");
 switch (p.antibandingMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_50HZ)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_60HZ)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Scene mode: "");
 switch (p.sceneMode) {
 case ANDROID_CONTROL_SCENE_MODE_UNSUPPORTED:
            result.append(""AUTO\n""); break;
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_ACTION)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_LANDSCAPE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_THEATRE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BEACH)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SNOW)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SUNSET)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_STEADYPHOTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_FIREWORKS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SPORTS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PARTY)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_CANDLELIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BARCODE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Flash mode: "");
 switch (p.flashMode) {
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_OFF)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_ON)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_TORCH)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_RED_EYE)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focus mode: "");
 switch (p.focusMode) {
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_MACRO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_VIDEO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_PICTURE)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_EDOF)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INFINITY)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_FIXED)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""   Focus state: "");
 switch (p.focusState) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_INACTIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_FOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_UNFOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_ACTIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focusing areas:\n"");
 for (size_t i = 0; i < p.focusingAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.focusingAreas[i].left,
                p.focusingAreas[i].top,
                p.focusingAreas[i].right,
                p.focusingAreas[i].bottom,
                p.focusingAreas[i].weight);
 }

    result.appendFormat(""    Exposure compensation index: %d\n"",
            p.exposureCompensation);

    result.appendFormat(""    AE lock %s, AWB lock %s\n"",
            p.autoExposureLock ? ""enabled"" : ""disabled"",
            p.autoWhiteBalanceLock ? ""enabled"" : ""disabled"" );

    result.appendFormat(""    Metering areas:\n"");
 for (size_t i = 0; i < p.meteringAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.meteringAreas[i].left,
                p.meteringAreas[i].top,
                p.meteringAreas[i].right,
                p.meteringAreas[i].bottom,
                p.meteringAreas[i].weight);
 }

    result.appendFormat(""    Zoom index: %d\n"", p.zoom);
    result.appendFormat(""    Video size: %d x %d\n"", p.videoWidth,
            p.videoHeight);

    result.appendFormat(""    Recording hint is %s\n"",
            p.recordingHint ? ""set"" : ""not set"");

    result.appendFormat(""    Video stabilization is %s\n"",
            p.videoStabilization ? ""enabled"" : ""disabled"");

    result.appendFormat(""    Selected still capture FPS range: %d - %d\n"",
            p.fastInfo.bestStillCaptureFpsRange[0],
            p.fastInfo.bestStillCaptureFpsRange[1]);

    result.append(""  Current streams:\n"");
    result.appendFormat(""    Preview stream ID: %d\n"",
            getPreviewStreamId());
    result.appendFormat(""    Capture stream ID: %d\n"",
            getCaptureStreamId());
    result.appendFormat(""    Recording stream ID: %d\n"",
            getRecordingStreamId());

    result.append(""  Quirks for this camera:\n"");
 bool haveQuirk = false;
 if (p.quirks.triggerAfWithAuto) {
        result.appendFormat(""    triggerAfWithAuto\n"");
        haveQuirk = true;
 }
 if (p.quirks.useZslFormat) {
        result.appendFormat(""    useZslFormat\n"");
        haveQuirk = true;
 }
 if (p.quirks.meteringCropRegion) {
        result.appendFormat(""    meteringCropRegion\n"");
        haveQuirk = true;
 }
 if (p.quirks.partialResults) {
        result.appendFormat(""    usePartialResult\n"");
        haveQuirk = true;
 }
 if (!haveQuirk) {
        result.appendFormat(""    none\n"");
 }

    write(fd, result.string(), result.size());

    mStreamingProcessor->dump(fd, args);

    mCaptureSequencer->dump(fd, args);

    mFrameProcessor->dump(fd, args);

    mZslProcessor->dump(fd, args);

 return dumpDevice(fd, args);
#undef CASE_APPEND_ENUM
}
"," status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""Client2[%d] (%p) Client: %s PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
 String8(mClientPackageName).string(),
            mClientPid);
    result.append(""  State: "");
#define CASE_APPEND_ENUM(x) case x: result.append(#x ""\n""); break;

 const Parameters& p = mParameters.unsafeAccess();

    result.append(Parameters::getStateName(p.state));

    result.append(""\n  Current parameters:\n"");
    result.appendFormat(""    Preview size: %d x %d\n"",
            p.previewWidth, p.previewHeight);
    result.appendFormat(""    Preview FPS range: %d - %d\n"",
            p.previewFpsRange[0], p.previewFpsRange[1]);
    result.appendFormat(""    Preview HAL pixel format: 0x%x\n"",
            p.previewFormat);
    result.appendFormat(""    Preview transform: %x\n"",
            p.previewTransform);
    result.appendFormat(""    Picture size: %d x %d\n"",
            p.pictureWidth, p.pictureHeight);
    result.appendFormat(""    Jpeg thumbnail size: %d x %d\n"",
            p.jpegThumbSize[0], p.jpegThumbSize[1]);
    result.appendFormat(""    Jpeg quality: %d, thumbnail quality: %d\n"",
            p.jpegQuality, p.jpegThumbQuality);
    result.appendFormat(""    Jpeg rotation: %d\n"", p.jpegRotation);
    result.appendFormat(""    GPS tags %s\n"",
            p.gpsEnabled ? ""enabled"" : ""disabled"");
 if (p.gpsEnabled) {
        result.appendFormat(""    GPS lat x long x alt: %f x %f x %f\n"",
                p.gpsCoordinates[0], p.gpsCoordinates[1],
                p.gpsCoordinates[2]);
        result.appendFormat(""    GPS timestamp: %lld\n"",
                p.gpsTimestamp);
        result.appendFormat(""    GPS processing method: %s\n"",
                p.gpsProcessingMethod.string());
 }

    result.append(""    White balance mode: "");
 switch (p.wbMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_INCANDESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_WARM_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_TWILIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_SHADE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Effect mode: "");
 switch (p.effectMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_MONO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_NEGATIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SOLARIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SEPIA)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_POSTERIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_WHITEBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_BLACKBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_AQUA)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Antibanding mode: "");
 switch (p.antibandingMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_50HZ)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_60HZ)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Scene mode: "");
 switch (p.sceneMode) {
 case ANDROID_CONTROL_SCENE_MODE_UNSUPPORTED:
            result.append(""AUTO\n""); break;
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_ACTION)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_LANDSCAPE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_THEATRE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BEACH)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SNOW)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SUNSET)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_STEADYPHOTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_FIREWORKS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SPORTS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PARTY)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_CANDLELIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BARCODE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Flash mode: "");
 switch (p.flashMode) {
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_OFF)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_ON)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_TORCH)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_RED_EYE)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focus mode: "");
 switch (p.focusMode) {
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_MACRO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_VIDEO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_PICTURE)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_EDOF)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INFINITY)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_FIXED)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""   Focus state: "");
 switch (p.focusState) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_INACTIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_FOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_UNFOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_ACTIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focusing areas:\n"");
 for (size_t i = 0; i < p.focusingAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.focusingAreas[i].left,
                p.focusingAreas[i].top,
                p.focusingAreas[i].right,
                p.focusingAreas[i].bottom,
                p.focusingAreas[i].weight);
 }

    result.appendFormat(""    Exposure compensation index: %d\n"",
            p.exposureCompensation);

    result.appendFormat(""    AE lock %s, AWB lock %s\n"",
            p.autoExposureLock ? ""enabled"" : ""disabled"",
            p.autoWhiteBalanceLock ? ""enabled"" : ""disabled"" );

    result.appendFormat(""    Metering areas:\n"");
 for (size_t i = 0; i < p.meteringAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.meteringAreas[i].left,
                p.meteringAreas[i].top,
                p.meteringAreas[i].right,
                p.meteringAreas[i].bottom,
                p.meteringAreas[i].weight);
 }

    result.appendFormat(""    Zoom index: %d\n"", p.zoom);
    result.appendFormat(""    Video size: %d x %d\n"", p.videoWidth,
            p.videoHeight);

    result.appendFormat(""    Recording hint is %s\n"",
            p.recordingHint ? ""set"" : ""not set"");

    result.appendFormat(""    Video stabilization is %s\n"",
            p.videoStabilization ? ""enabled"" : ""disabled"");

    result.appendFormat(""    Selected still capture FPS range: %d - %d\n"",
            p.fastInfo.bestStillCaptureFpsRange[0],
            p.fastInfo.bestStillCaptureFpsRange[1]);

    result.append(""  Current streams:\n"");
    result.appendFormat(""    Preview stream ID: %d\n"",
            getPreviewStreamId());
    result.appendFormat(""    Capture stream ID: %d\n"",
            getCaptureStreamId());
    result.appendFormat(""    Recording stream ID: %d\n"",
            getRecordingStreamId());

    result.append(""  Quirks for this camera:\n"");
 bool haveQuirk = false;
 if (p.quirks.triggerAfWithAuto) {
        result.appendFormat(""    triggerAfWithAuto\n"");
        haveQuirk = true;
 }
 if (p.quirks.useZslFormat) {
        result.appendFormat(""    useZslFormat\n"");
        haveQuirk = true;
 }
 if (p.quirks.meteringCropRegion) {
        result.appendFormat(""    meteringCropRegion\n"");
        haveQuirk = true;
 }
 if (p.quirks.partialResults) {
        result.appendFormat(""    usePartialResult\n"");
        haveQuirk = true;
 }
 if (!haveQuirk) {
        result.appendFormat(""    none\n"");
 }

    write(fd, result.string(), result.size());

    mStreamingProcessor->dump(fd, args);

    mCaptureSequencer->dump(fd, args);

    mFrameProcessor->dump(fd, args);

    mZslProcessor->dump(fd, args);

 return dumpDevice(fd, args);
#undef CASE_APPEND_ENUM
}
",C,"    return BasicClient::dump(fd, args);
}

status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {
",,,"@@ -158,6 +158,10 @@

 }
 
 status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
+    return BasicClient::dump(fd, args);
+}
+
+status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""Client2[%d] (%p) Client: %s PID: %d, dump:\n"",
             mCameraId,
",Android,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122%5E/,1," status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
//fix_flaw_line_below:
//    return BasicClient::dump(fd, args);
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""Client2[%d] (%p) Client: %s PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
 String8(mClientPackageName).string(),
            mClientPid);
    result.append(""  State: "");
#define CASE_APPEND_ENUM(x) case x: result.append(#x ""\n""); break;

 const Parameters& p = mParameters.unsafeAccess();

    result.append(Parameters::getStateName(p.state));

    result.append(""\n  Current parameters:\n"");
    result.appendFormat(""    Preview size: %d x %d\n"",
            p.previewWidth, p.previewHeight);
    result.appendFormat(""    Preview FPS range: %d - %d\n"",
            p.previewFpsRange[0], p.previewFpsRange[1]);
    result.appendFormat(""    Preview HAL pixel format: 0x%x\n"",
            p.previewFormat);
    result.appendFormat(""    Preview transform: %x\n"",
            p.previewTransform);
    result.appendFormat(""    Picture size: %d x %d\n"",
            p.pictureWidth, p.pictureHeight);
    result.appendFormat(""    Jpeg thumbnail size: %d x %d\n"",
            p.jpegThumbSize[0], p.jpegThumbSize[1]);
    result.appendFormat(""    Jpeg quality: %d, thumbnail quality: %d\n"",
            p.jpegQuality, p.jpegThumbQuality);
    result.appendFormat(""    Jpeg rotation: %d\n"", p.jpegRotation);
    result.appendFormat(""    GPS tags %s\n"",
            p.gpsEnabled ? ""enabled"" : ""disabled"");
 if (p.gpsEnabled) {
        result.appendFormat(""    GPS lat x long x alt: %f x %f x %f\n"",
                p.gpsCoordinates[0], p.gpsCoordinates[1],
                p.gpsCoordinates[2]);
        result.appendFormat(""    GPS timestamp: %lld\n"",
                p.gpsTimestamp);
        result.appendFormat(""    GPS processing method: %s\n"",
                p.gpsProcessingMethod.string());
 }

    result.append(""    White balance mode: "");
 switch (p.wbMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_INCANDESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_WARM_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_TWILIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_SHADE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Effect mode: "");
 switch (p.effectMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_MONO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_NEGATIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SOLARIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SEPIA)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_POSTERIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_WHITEBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_BLACKBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_AQUA)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Antibanding mode: "");
 switch (p.antibandingMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_50HZ)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_60HZ)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Scene mode: "");
 switch (p.sceneMode) {
 case ANDROID_CONTROL_SCENE_MODE_UNSUPPORTED:
            result.append(""AUTO\n""); break;
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_ACTION)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_LANDSCAPE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_THEATRE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BEACH)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SNOW)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SUNSET)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_STEADYPHOTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_FIREWORKS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SPORTS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PARTY)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_CANDLELIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BARCODE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Flash mode: "");
 switch (p.flashMode) {
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_OFF)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_ON)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_TORCH)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_RED_EYE)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focus mode: "");
 switch (p.focusMode) {
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_MACRO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_VIDEO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_PICTURE)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_EDOF)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INFINITY)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_FIXED)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""   Focus state: "");
 switch (p.focusState) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_INACTIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_FOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_UNFOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_ACTIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focusing areas:\n"");
 for (size_t i = 0; i < p.focusingAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.focusingAreas[i].left,
                p.focusingAreas[i].top,
                p.focusingAreas[i].right,
                p.focusingAreas[i].bottom,
                p.focusingAreas[i].weight);
 }

    result.appendFormat(""    Exposure compensation index: %d\n"",
            p.exposureCompensation);

    result.appendFormat(""    AE lock %s, AWB lock %s\n"",
            p.autoExposureLock ? ""enabled"" : ""disabled"",
            p.autoWhiteBalanceLock ? ""enabled"" : ""disabled"" );

    result.appendFormat(""    Metering areas:\n"");
 for (size_t i = 0; i < p.meteringAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.meteringAreas[i].left,
                p.meteringAreas[i].top,
                p.meteringAreas[i].right,
                p.meteringAreas[i].bottom,
                p.meteringAreas[i].weight);
 }

    result.appendFormat(""    Zoom index: %d\n"", p.zoom);
    result.appendFormat(""    Video size: %d x %d\n"", p.videoWidth,
            p.videoHeight);

    result.appendFormat(""    Recording hint is %s\n"",
            p.recordingHint ? ""set"" : ""not set"");

    result.appendFormat(""    Video stabilization is %s\n"",
            p.videoStabilization ? ""enabled"" : ""disabled"");

    result.appendFormat(""    Selected still capture FPS range: %d - %d\n"",
            p.fastInfo.bestStillCaptureFpsRange[0],
            p.fastInfo.bestStillCaptureFpsRange[1]);

    result.append(""  Current streams:\n"");
    result.appendFormat(""    Preview stream ID: %d\n"",
            getPreviewStreamId());
    result.appendFormat(""    Capture stream ID: %d\n"",
            getCaptureStreamId());
    result.appendFormat(""    Recording stream ID: %d\n"",
            getRecordingStreamId());

    result.append(""  Quirks for this camera:\n"");
 bool haveQuirk = false;
 if (p.quirks.triggerAfWithAuto) {
        result.appendFormat(""    triggerAfWithAuto\n"");
        haveQuirk = true;
 }
 if (p.quirks.useZslFormat) {
        result.appendFormat(""    useZslFormat\n"");
        haveQuirk = true;
 }
 if (p.quirks.meteringCropRegion) {
        result.appendFormat(""    meteringCropRegion\n"");
        haveQuirk = true;
 }
 if (p.quirks.partialResults) {
        result.appendFormat(""    usePartialResult\n"");
        haveQuirk = true;
 }
 if (!haveQuirk) {
        result.appendFormat(""    none\n"");
 }

    write(fd, result.string(), result.size());

    mStreamingProcessor->dump(fd, args);

    mCaptureSequencer->dump(fd, args);

    mFrameProcessor->dump(fd, args);

    mZslProcessor->dump(fd, args);

 return dumpDevice(fd, args);
#undef CASE_APPEND_ENUM
}
",187959," status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""Client2[%d] (%p) Client: %s PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
 String8(mClientPackageName).string(),
            mClientPid);
    result.append(""  State: "");
#define CASE_APPEND_ENUM(x) case x: result.append(#x ""\n""); break;

 const Parameters& p = mParameters.unsafeAccess();

    result.append(Parameters::getStateName(p.state));

    result.append(""\n  Current parameters:\n"");
    result.appendFormat(""    Preview size: %d x %d\n"",
            p.previewWidth, p.previewHeight);
    result.appendFormat(""    Preview FPS range: %d - %d\n"",
            p.previewFpsRange[0], p.previewFpsRange[1]);
    result.appendFormat(""    Preview HAL pixel format: 0x%x\n"",
            p.previewFormat);
    result.appendFormat(""    Preview transform: %x\n"",
            p.previewTransform);
    result.appendFormat(""    Picture size: %d x %d\n"",
            p.pictureWidth, p.pictureHeight);
    result.appendFormat(""    Jpeg thumbnail size: %d x %d\n"",
            p.jpegThumbSize[0], p.jpegThumbSize[1]);
    result.appendFormat(""    Jpeg quality: %d, thumbnail quality: %d\n"",
            p.jpegQuality, p.jpegThumbQuality);
    result.appendFormat(""    Jpeg rotation: %d\n"", p.jpegRotation);
    result.appendFormat(""    GPS tags %s\n"",
            p.gpsEnabled ? ""enabled"" : ""disabled"");
 if (p.gpsEnabled) {
        result.appendFormat(""    GPS lat x long x alt: %f x %f x %f\n"",
                p.gpsCoordinates[0], p.gpsCoordinates[1],
                p.gpsCoordinates[2]);
        result.appendFormat(""    GPS timestamp: %lld\n"",
                p.gpsTimestamp);
        result.appendFormat(""    GPS processing method: %s\n"",
                p.gpsProcessingMethod.string());
 }

    result.append(""    White balance mode: "");
 switch (p.wbMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_INCANDESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_WARM_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_TWILIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_SHADE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Effect mode: "");
 switch (p.effectMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_MONO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_NEGATIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SOLARIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SEPIA)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_POSTERIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_WHITEBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_BLACKBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_AQUA)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Antibanding mode: "");
 switch (p.antibandingMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_50HZ)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_60HZ)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Scene mode: "");
 switch (p.sceneMode) {
 case ANDROID_CONTROL_SCENE_MODE_UNSUPPORTED:
            result.append(""AUTO\n""); break;
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_ACTION)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_LANDSCAPE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_THEATRE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BEACH)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SNOW)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SUNSET)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_STEADYPHOTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_FIREWORKS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SPORTS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PARTY)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_CANDLELIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BARCODE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Flash mode: "");
 switch (p.flashMode) {
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_OFF)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_ON)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_TORCH)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_RED_EYE)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focus mode: "");
 switch (p.focusMode) {
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_MACRO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_VIDEO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_PICTURE)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_EDOF)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INFINITY)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_FIXED)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""   Focus state: "");
 switch (p.focusState) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_INACTIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_FOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_UNFOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_ACTIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focusing areas:\n"");
 for (size_t i = 0; i < p.focusingAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.focusingAreas[i].left,
                p.focusingAreas[i].top,
                p.focusingAreas[i].right,
                p.focusingAreas[i].bottom,
                p.focusingAreas[i].weight);
 }

    result.appendFormat(""    Exposure compensation index: %d\n"",
            p.exposureCompensation);

    result.appendFormat(""    AE lock %s, AWB lock %s\n"",
            p.autoExposureLock ? ""enabled"" : ""disabled"",
            p.autoWhiteBalanceLock ? ""enabled"" : ""disabled"" );

    result.appendFormat(""    Metering areas:\n"");
 for (size_t i = 0; i < p.meteringAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.meteringAreas[i].left,
                p.meteringAreas[i].top,
                p.meteringAreas[i].right,
                p.meteringAreas[i].bottom,
                p.meteringAreas[i].weight);
 }

    result.appendFormat(""    Zoom index: %d\n"", p.zoom);
    result.appendFormat(""    Video size: %d x %d\n"", p.videoWidth,
            p.videoHeight);

    result.appendFormat(""    Recording hint is %s\n"",
            p.recordingHint ? ""set"" : ""not set"");

    result.appendFormat(""    Video stabilization is %s\n"",
            p.videoStabilization ? ""enabled"" : ""disabled"");

    result.appendFormat(""    Selected still capture FPS range: %d - %d\n"",
            p.fastInfo.bestStillCaptureFpsRange[0],
            p.fastInfo.bestStillCaptureFpsRange[1]);

    result.append(""  Current streams:\n"");
    result.appendFormat(""    Preview stream ID: %d\n"",
            getPreviewStreamId());
    result.appendFormat(""    Capture stream ID: %d\n"",
            getCaptureStreamId());
    result.appendFormat(""    Recording stream ID: %d\n"",
            getRecordingStreamId());

    result.append(""  Quirks for this camera:\n"");
 bool haveQuirk = false;
 if (p.quirks.triggerAfWithAuto) {
        result.appendFormat(""    triggerAfWithAuto\n"");
        haveQuirk = true;
 }
 if (p.quirks.useZslFormat) {
        result.appendFormat(""    useZslFormat\n"");
        haveQuirk = true;
 }
 if (p.quirks.meteringCropRegion) {
        result.appendFormat(""    meteringCropRegion\n"");
        haveQuirk = true;
 }
 if (p.quirks.partialResults) {
        result.appendFormat(""    usePartialResult\n"");
        haveQuirk = true;
 }
 if (!haveQuirk) {
        result.appendFormat(""    none\n"");
 }

    write(fd, result.string(), result.size());

    mStreamingProcessor->dump(fd, args);

    mCaptureSequencer->dump(fd, args);

    mFrameProcessor->dump(fd, args);

    mZslProcessor->dump(fd, args);

 return dumpDevice(fd, args);
#undef CASE_APPEND_ENUM
}
"," status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""Client2[%d] (%p) Client: %s PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
 String8(mClientPackageName).string(),
            mClientPid);
    result.append(""  State: "");
#define CASE_APPEND_ENUM(x) case x: result.append(#x ""\n""); break;

 const Parameters& p = mParameters.unsafeAccess();

    result.append(Parameters::getStateName(p.state));

    result.append(""\n  Current parameters:\n"");
    result.appendFormat(""    Preview size: %d x %d\n"",
            p.previewWidth, p.previewHeight);
    result.appendFormat(""    Preview FPS range: %d - %d\n"",
            p.previewFpsRange[0], p.previewFpsRange[1]);
    result.appendFormat(""    Preview HAL pixel format: 0x%x\n"",
            p.previewFormat);
    result.appendFormat(""    Preview transform: %x\n"",
            p.previewTransform);
    result.appendFormat(""    Picture size: %d x %d\n"",
            p.pictureWidth, p.pictureHeight);
    result.appendFormat(""    Jpeg thumbnail size: %d x %d\n"",
            p.jpegThumbSize[0], p.jpegThumbSize[1]);
    result.appendFormat(""    Jpeg quality: %d, thumbnail quality: %d\n"",
            p.jpegQuality, p.jpegThumbQuality);
    result.appendFormat(""    Jpeg rotation: %d\n"", p.jpegRotation);
    result.appendFormat(""    GPS tags %s\n"",
            p.gpsEnabled ? ""enabled"" : ""disabled"");
 if (p.gpsEnabled) {
        result.appendFormat(""    GPS lat x long x alt: %f x %f x %f\n"",
                p.gpsCoordinates[0], p.gpsCoordinates[1],
                p.gpsCoordinates[2]);
        result.appendFormat(""    GPS timestamp: %lld\n"",
                p.gpsTimestamp);
        result.appendFormat(""    GPS processing method: %s\n"",
                p.gpsProcessingMethod.string());
 }

    result.append(""    White balance mode: "");
 switch (p.wbMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_INCANDESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_WARM_FLUORESCENT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_CLOUDY_DAYLIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_TWILIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AWB_MODE_SHADE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Effect mode: "");
 switch (p.effectMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_MONO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_NEGATIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SOLARIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_SEPIA)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_POSTERIZE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_WHITEBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_BLACKBOARD)
        CASE_APPEND_ENUM(ANDROID_CONTROL_EFFECT_MODE_AQUA)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Antibanding mode: "");
 switch (p.antibandingMode) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_AUTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_OFF)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_50HZ)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AE_ANTIBANDING_MODE_60HZ)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Scene mode: "");
 switch (p.sceneMode) {
 case ANDROID_CONTROL_SCENE_MODE_UNSUPPORTED:
            result.append(""AUTO\n""); break;
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_ACTION)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_LANDSCAPE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_NIGHT_PORTRAIT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_THEATRE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BEACH)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SNOW)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SUNSET)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_STEADYPHOTO)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_FIREWORKS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_SPORTS)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_PARTY)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_CANDLELIGHT)
        CASE_APPEND_ENUM(ANDROID_CONTROL_SCENE_MODE_BARCODE)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Flash mode: "");
 switch (p.flashMode) {
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_OFF)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_ON)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_TORCH)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_RED_EYE)
        CASE_APPEND_ENUM(Parameters::FLASH_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focus mode: "");
 switch (p.focusMode) {
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_AUTO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_MACRO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_VIDEO)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_CONTINUOUS_PICTURE)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_EDOF)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INFINITY)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_FIXED)
        CASE_APPEND_ENUM(Parameters::FOCUS_MODE_INVALID)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""   Focus state: "");
 switch (p.focusState) {
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_INACTIVE)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_FOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_PASSIVE_UNFOCUSED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_ACTIVE_SCAN)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED)
        CASE_APPEND_ENUM(ANDROID_CONTROL_AF_STATE_NOT_FOCUSED_LOCKED)
 default: result.append(""UNKNOWN\n"");
 }

    result.append(""    Focusing areas:\n"");
 for (size_t i = 0; i < p.focusingAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.focusingAreas[i].left,
                p.focusingAreas[i].top,
                p.focusingAreas[i].right,
                p.focusingAreas[i].bottom,
                p.focusingAreas[i].weight);
 }

    result.appendFormat(""    Exposure compensation index: %d\n"",
            p.exposureCompensation);

    result.appendFormat(""    AE lock %s, AWB lock %s\n"",
            p.autoExposureLock ? ""enabled"" : ""disabled"",
            p.autoWhiteBalanceLock ? ""enabled"" : ""disabled"" );

    result.appendFormat(""    Metering areas:\n"");
 for (size_t i = 0; i < p.meteringAreas.size(); i++) {
        result.appendFormat(""      [ (%d, %d, %d, %d), weight %d ]\n"",
                p.meteringAreas[i].left,
                p.meteringAreas[i].top,
                p.meteringAreas[i].right,
                p.meteringAreas[i].bottom,
                p.meteringAreas[i].weight);
 }

    result.appendFormat(""    Zoom index: %d\n"", p.zoom);
    result.appendFormat(""    Video size: %d x %d\n"", p.videoWidth,
            p.videoHeight);

    result.appendFormat(""    Recording hint is %s\n"",
            p.recordingHint ? ""set"" : ""not set"");

    result.appendFormat(""    Video stabilization is %s\n"",
            p.videoStabilization ? ""enabled"" : ""disabled"");

    result.appendFormat(""    Selected still capture FPS range: %d - %d\n"",
            p.fastInfo.bestStillCaptureFpsRange[0],
            p.fastInfo.bestStillCaptureFpsRange[1]);

    result.append(""  Current streams:\n"");
    result.appendFormat(""    Preview stream ID: %d\n"",
            getPreviewStreamId());
    result.appendFormat(""    Capture stream ID: %d\n"",
            getCaptureStreamId());
    result.appendFormat(""    Recording stream ID: %d\n"",
            getRecordingStreamId());

    result.append(""  Quirks for this camera:\n"");
 bool haveQuirk = false;
 if (p.quirks.triggerAfWithAuto) {
        result.appendFormat(""    triggerAfWithAuto\n"");
        haveQuirk = true;
 }
 if (p.quirks.useZslFormat) {
        result.appendFormat(""    useZslFormat\n"");
        haveQuirk = true;
 }
 if (p.quirks.meteringCropRegion) {
        result.appendFormat(""    meteringCropRegion\n"");
        haveQuirk = true;
 }
 if (p.quirks.partialResults) {
        result.appendFormat(""    usePartialResult\n"");
        haveQuirk = true;
 }
 if (!haveQuirk) {
        result.appendFormat(""    none\n"");
 }

    write(fd, result.string(), result.size());

    mStreamingProcessor->dump(fd, args);

    mCaptureSequencer->dump(fd, args);

    mFrameProcessor->dump(fd, args);

    mZslProcessor->dump(fd, args);

 return dumpDevice(fd, args);
#undef CASE_APPEND_ENUM
}
","The `Camera2Client::dump` function is designed to output detailed diagnostic information about the camera client, including its state, parameters, and current settings. It constructs a formatted string that includes the camera ID, client package name, process ID, and various camera parameters such as preview size, frame rate range, image quality settings, and GPS information. The function also enumerates the current modes for white balance, effects, scene, flash, and focus, along with their respective states and areas. Finally, it writes this information to a specified file descriptor and invokes dump methods on associated processors, ensuring comprehensive logging for debugging purposes.","The provided code defines a function that generates and outputs detailed diagnostic information about a camera client. It constructs a formatted report that includes the client's identification, state, and various camera settings such as preview dimensions, frame rates, image quality, and GPS status. Additionally, it enumerates the current modes for white balance, effects, scene, flash, and focus, along with their respective states and areas. The function writes this comprehensive information to a specified output and also triggers diagnostic outputs from associated processing components, facilitating thorough debugging and analysis of the camera's operational status.","The vulnerability in the original code stemmed from allowing direct access to sensitive camera client information through the `dump` function, which could be exploited to leak private data. This was addressed in the fixed code by replacing the original `dump` implementation with a call to a more secure method, `BasicClient::dump`, which restricts access to camera service dumps. This change ensures that dumps can only be initiated through a controlled interface, `ICameraService::dump`, thereby mitigating the risk of unauthorized data exposure and enhancing the overall security of the camera service.","The vulnerability in the original code allowed direct access to sensitive information about camera clients, potentially exposing private data through unrestricted dumps. This could lead to unauthorized access and exploitation of sensitive camera parameters. The fix implemented a restriction by ensuring that dumps can only be initiated through a designated and controlled interface, thereby preventing direct access to client data. This change enhances security by enforcing proper access controls, ensuring that sensitive information is only available through authorized channels, thus mitigating the risk of data leaks and unauthorized exposure.","The vulnerability was fixed by replacing the original `dump` function in the `Camera2Client` class with a call to `BasicClient::dump`, which restricts direct access to sensitive client information. This change ensures that the camera service dumps can only be initiated through the `ICameraService::dump` interface, thereby enforcing stricter access controls. By doing so, the code prevents unauthorized users from directly invoking the `dump` method, which previously exposed detailed camera parameters and states, thus significantly reducing the risk of data leaks and enhancing the overall security of the camera service.","The vulnerability was fixed by modifying the code to eliminate direct access to sensitive client information through the dump functionality. Instead of allowing unrestricted dumps, the implementation now requires that all dump requests be routed through a controlled interface, which enforces proper access permissions. This change ensures that sensitive data can only be accessed in a secure manner, significantly reducing the risk of unauthorized exposure. By implementing this restriction, the code enhances the overall security of the system, ensuring that sensitive information is protected from potential exploitation.","CWE-200, CWE-285, CWE-732, CWE-284, CWE-264, CWE-311, CWE-213, CWE-359, CWE-522, CWE-269",N,-1
91,91,187960,187960,,Remote,Not required,Complete,CVE-2016-0826,https://www.cvedetails.com/cve/CVE-2016-0826/,CWE-264,Medium,Complete,Complete,,2016-03-12,9.3,"libcameraservice in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not require use of the ICameraService::dump method for a camera service dump, which allows attackers to gain privileges via a crafted application that directly dumps, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26265403.",2016-11-28,+Priv ,4,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122,c9ab2b0bb05a7e19fb057e79b36e232809d70122,"Camera: Disallow dumping clients directly

Camera service dumps should only be initiated through
ICameraService::dump.

Bug: 26265403
Change-Id: If3ca4718ed74bf33ad8a416192689203029e2803
",0,services/camera/libcameraservice/api1/CameraClient.cpp,"{""filename"": ""services/camera/libcameraservice/CameraService.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.cpp"", ""patch"": ""@@ -985,6 +985,14 @@\n\n     mClientPid = 0;\n }\n \n+status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {\n+    // No dumping of clients directly over Binder,\n+    // must go through CameraService::dump\n+    android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, \""26265403\"",\n+            IPCThreadState::self()->getCallingUid(), NULL, 0);\n+    return OK;\n+}\n+\n status_t CameraService::BasicClient::startCameraOps() {\n     int32_t res;\n \n@@ -1222,7 +1230,7 @@\n\n             hasClient = true;\n             result = String8::format(\""  Device is open. Client instance dump:\\n\"");\n             write(fd, result.string(), result.size());\n-            client->dump(fd, args);\n+            client->dumpClient(fd, args);\n         }\n         if (!hasClient) {\n             result = String8::format(\""\\nNo active camera clients yet.\\n\"");\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/CameraService.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.h"", ""patch"": ""@@ -55,6 +55,9 @@\n\n     class Client;\n     class BasicClient;\n \n+    // Event log ID\n+    static const int SN_EVENT_LOG_ID = 0x534e4554;\n+\n     // Implementation of BinderService<T>\n     static char const* getServiceName() { return \""media.camera\""; }\n \n@@ -144,7 +147,10 @@\n\n             return mRemoteBinder;\n         }\n \n-        virtual status_t      dump(int fd, const Vector<String16>& args) = 0;\n+        // Disallows dumping over binder interface\n+        virtual status_t      dump(int fd, const Vector<String16>& args);\n+        // Internal dump method to be called by CameraService\n+        virtual status_t      dumpClient(int fd, const Vector<String16>& args) = 0;\n \n     protected:\n         BasicClient(const sp<CameraService>& cameraService,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.cpp"", ""patch"": ""@@ -158,6 +158,10 @@\n\n }\n \n status_t Camera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Client2[%d] (%p) Client: %s PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.h"", ""patch"": ""@@ -98,6 +98,8 @@\n\n \n     virtual status_t dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Interface used by CameraDeviceBase\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.cpp"", ""patch"": ""@@ -112,6 +112,10 @@\n\n }\n \n status_t CameraClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {\n     const size_t SIZE = 256;\n     char buffer[SIZE];\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.h"", ""patch"": ""@@ -69,7 +69,9 @@\n\n \n     status_t initialize(camera_module_t *module);\n \n-    status_t dump(int fd, const Vector<String16>& args);\n+    virtual status_t dump(int fd, const Vector<String16>& args);\n+\n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n \n private:\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""patch"": ""@@ -480,6 +480,10 @@\n\n }\n \n status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""patch"": ""@@ -109,6 +109,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Device listener interface\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""patch"": ""@@ -331,6 +331,10 @@\n\n }\n \n status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""ProCamera2Client[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""patch"": ""@@ -88,6 +88,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     // Callbacks from camera service\n     virtual void onExclusiveLockStolen();\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""patch"": ""@@ -117,7 +117,7 @@\n\n }\n \n template <typename TClientBase>\n-status_t Camera2ClientBase<TClientBase>::dump(int fd,\n+status_t Camera2ClientBase<TClientBase>::dumpClient(int fd,\n                                               const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Camera2ClientBase[%d] (%p) PID: %d, dump:\\n\"",\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.h"", ""patch"": ""@@ -55,7 +55,7 @@\n\n     virtual ~Camera2ClientBase();\n \n     virtual status_t      initialize(camera_module_t *module);\n-    virtual status_t      dump(int fd, const Vector<String16>& args);\n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n \n     /**\n      * CameraDeviceBase::NotificationListener implementation\n""}"," status_t CameraClient::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {
     const size_t SIZE = 256;
     char buffer[SIZE];
 
 size_t len = snprintf(buffer, SIZE, ""Client[%d] (%p) PID: %d\n"",
            mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    len = (len > SIZE - 1) ? SIZE - 1 : len;
    write(fd, buffer, len);
 return mHardware->dump(fd, args);
}
"," status_t CameraClient::dump(int fd, const Vector<String16>& args) {
     const size_t SIZE = 256;
     char buffer[SIZE];
 
 size_t len = snprintf(buffer, SIZE, ""Client[%d] (%p) PID: %d\n"",
            mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    len = (len > SIZE - 1) ? SIZE - 1 : len;
    write(fd, buffer, len);
 return mHardware->dump(fd, args);
}
",C,"    return BasicClient::dump(fd, args);
}

status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {
",,,"@@ -112,6 +112,10 @@

 }
 
 status_t CameraClient::dump(int fd, const Vector<String16>& args) {
+    return BasicClient::dump(fd, args);
+}
+
+status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {
     const size_t SIZE = 256;
     char buffer[SIZE];
 
",Android,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122%5E/,1," status_t CameraClient::dump(int fd, const Vector<String16>& args) {
//fix_flaw_line_below:
//    return BasicClient::dump(fd, args);
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {
     const size_t SIZE = 256;
     char buffer[SIZE];
 
 size_t len = snprintf(buffer, SIZE, ""Client[%d] (%p) PID: %d\n"",
            mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    len = (len > SIZE - 1) ? SIZE - 1 : len;
    write(fd, buffer, len);
 return mHardware->dump(fd, args);
}
",187960," status_t CameraClient::dump(int fd, const Vector<String16>& args) {
     const size_t SIZE = 256;
     char buffer[SIZE];
 
 size_t len = snprintf(buffer, SIZE, ""Client[%d] (%p) PID: %d\n"",
            mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    len = (len > SIZE - 1) ? SIZE - 1 : len;
    write(fd, buffer, len);
 return mHardware->dump(fd, args);
}
"," status_t CameraClient::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {
     const size_t SIZE = 256;
     char buffer[SIZE];
 
 size_t len = snprintf(buffer, SIZE, ""Client[%d] (%p) PID: %d\n"",
            mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    len = (len > SIZE - 1) ? SIZE - 1 : len;
    write(fd, buffer, len);
 return mHardware->dump(fd, args);
}
","The `CameraClient::dump` function is designed to output diagnostic information about a camera client to a specified file descriptor (`fd`). It constructs a formatted string containing the camera client's ID, a pointer to its remote callback, and the process ID (PID) of the client, ensuring the output does not exceed a predefined buffer size. After writing this information to the file descriptor, the function calls the `dump` method of the `mHardware` object, passing along the same file descriptor and any additional arguments provided in `args`, allowing for further hardware-specific diagnostics to be outputted.","The provided code defines a method that outputs diagnostic information about a camera client to a specified file descriptor. It formats a string that includes the client's unique identifier, a reference to its callback mechanism, and the process identifier of the client, ensuring the output fits within a defined buffer size. After writing this information to the file descriptor, the method invokes another function associated with the hardware component, passing the same file descriptor and additional arguments for further diagnostic output, thereby facilitating comprehensive debugging and monitoring of the camera clients state and behavior.","The vulnerability in the original code stemmed from allowing direct access to the camera client's dump functionality, which could potentially expose sensitive information or system details if misused. This was addressed in the fixed code by removing the direct call to the dump method from the `CameraClient` class and instead routing all dump requests through a more controlled interface, specifically `ICameraService::dump`. This change ensures that any diagnostic output is properly managed and restricted, thereby enhancing security by preventing unauthorized or unintended access to sensitive client information.","The vulnerability in the original code allowed direct access to sensitive diagnostic information from camera clients, which could be exploited to reveal internal state or system details, posing a security risk. The fix implemented in the updated code restricts this access by ensuring that all dump requests are routed through a controlled service interface. This change enforces a more secure method of handling diagnostic outputs, preventing unauthorized access and ensuring that sensitive information is only accessible through properly managed channels, thereby enhancing the overall security of the camera service.","The vulnerability was fixed by removing the direct call to the `dump` method in the `CameraClient` class, which previously allowed unrestricted access to sensitive client information. Instead, the updated code now routes all dump requests through the `ICameraService::dump` interface, ensuring that diagnostic outputs are managed in a controlled manner. This change prevents unauthorized access to the `dumpClient` method, which formats and writes sensitive information to a file descriptor, thereby enhancing security by ensuring that only authorized service calls can initiate the dumping of client data.","The vulnerability was fixed by eliminating direct access to the diagnostic output functionality, which previously allowed sensitive information to be exposed without proper oversight. The updated code now mandates that all requests for diagnostic information must go through a controlled service interface, ensuring that such requests are properly authenticated and authorized. This change effectively restricts the ability to access sensitive client data, thereby enhancing security by preventing unauthorized or unintended exposure of internal system details and ensuring that diagnostic outputs are managed in a more secure and regulated manner.","CWE-200, CWE-732, CWE-284, CWE-285, CWE-306, CWE-532, CWE-213, CWE-749, CWE-522, CWE-269",N,-1
92,92,187961,187961,,Remote,Not required,Complete,CVE-2016-0826,https://www.cvedetails.com/cve/CVE-2016-0826/,CWE-264,Medium,Complete,Complete,,2016-03-12,9.3,"libcameraservice in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not require use of the ICameraService::dump method for a camera service dump, which allows attackers to gain privileges via a crafted application that directly dumps, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26265403.",2016-11-28,+Priv ,4,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122,c9ab2b0bb05a7e19fb057e79b36e232809d70122,"Camera: Disallow dumping clients directly

Camera service dumps should only be initiated through
ICameraService::dump.

Bug: 26265403
Change-Id: If3ca4718ed74bf33ad8a416192689203029e2803
",0,services/camera/libcameraservice/api2/CameraDeviceClient.cpp,"{""filename"": ""services/camera/libcameraservice/CameraService.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.cpp"", ""patch"": ""@@ -985,6 +985,14 @@\n\n     mClientPid = 0;\n }\n \n+status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {\n+    // No dumping of clients directly over Binder,\n+    // must go through CameraService::dump\n+    android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, \""26265403\"",\n+            IPCThreadState::self()->getCallingUid(), NULL, 0);\n+    return OK;\n+}\n+\n status_t CameraService::BasicClient::startCameraOps() {\n     int32_t res;\n \n@@ -1222,7 +1230,7 @@\n\n             hasClient = true;\n             result = String8::format(\""  Device is open. Client instance dump:\\n\"");\n             write(fd, result.string(), result.size());\n-            client->dump(fd, args);\n+            client->dumpClient(fd, args);\n         }\n         if (!hasClient) {\n             result = String8::format(\""\\nNo active camera clients yet.\\n\"");\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/CameraService.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.h"", ""patch"": ""@@ -55,6 +55,9 @@\n\n     class Client;\n     class BasicClient;\n \n+    // Event log ID\n+    static const int SN_EVENT_LOG_ID = 0x534e4554;\n+\n     // Implementation of BinderService<T>\n     static char const* getServiceName() { return \""media.camera\""; }\n \n@@ -144,7 +147,10 @@\n\n             return mRemoteBinder;\n         }\n \n-        virtual status_t      dump(int fd, const Vector<String16>& args) = 0;\n+        // Disallows dumping over binder interface\n+        virtual status_t      dump(int fd, const Vector<String16>& args);\n+        // Internal dump method to be called by CameraService\n+        virtual status_t      dumpClient(int fd, const Vector<String16>& args) = 0;\n \n     protected:\n         BasicClient(const sp<CameraService>& cameraService,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.cpp"", ""patch"": ""@@ -158,6 +158,10 @@\n\n }\n \n status_t Camera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Client2[%d] (%p) Client: %s PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.h"", ""patch"": ""@@ -98,6 +98,8 @@\n\n \n     virtual status_t dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Interface used by CameraDeviceBase\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.cpp"", ""patch"": ""@@ -112,6 +112,10 @@\n\n }\n \n status_t CameraClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {\n     const size_t SIZE = 256;\n     char buffer[SIZE];\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.h"", ""patch"": ""@@ -69,7 +69,9 @@\n\n \n     status_t initialize(camera_module_t *module);\n \n-    status_t dump(int fd, const Vector<String16>& args);\n+    virtual status_t dump(int fd, const Vector<String16>& args);\n+\n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n \n private:\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""patch"": ""@@ -480,6 +480,10 @@\n\n }\n \n status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""patch"": ""@@ -109,6 +109,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Device listener interface\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""patch"": ""@@ -331,6 +331,10 @@\n\n }\n \n status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""ProCamera2Client[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""patch"": ""@@ -88,6 +88,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     // Callbacks from camera service\n     virtual void onExclusiveLockStolen();\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""patch"": ""@@ -117,7 +117,7 @@\n\n }\n \n template <typename TClientBase>\n-status_t Camera2ClientBase<TClientBase>::dump(int fd,\n+status_t Camera2ClientBase<TClientBase>::dumpClient(int fd,\n                                               const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Camera2ClientBase[%d] (%p) PID: %d, dump:\\n\"",\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.h"", ""patch"": ""@@ -55,7 +55,7 @@\n\n     virtual ~Camera2ClientBase();\n \n     virtual status_t      initialize(camera_module_t *module);\n-    virtual status_t      dump(int fd, const Vector<String16>& args);\n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n \n     /**\n      * CameraDeviceBase::NotificationListener implementation\n""}"," status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""CameraDeviceClient[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
"," status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""CameraDeviceClient[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
",C,"    return BasicClient::dump(fd, args);
}

status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {
",,,"@@ -480,6 +480,10 @@

 }
 
 status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
+    return BasicClient::dump(fd, args);
+}
+
+status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""CameraDeviceClient[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
",Android,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122%5E/,1," status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
//fix_flaw_line_below:
//    return BasicClient::dump(fd, args);
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""CameraDeviceClient[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

 // TODO: print dynamic/request section from most recent requests
    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
",187961," status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""CameraDeviceClient[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
"," status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""CameraDeviceClient[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
","The `CameraDeviceClient::dump` function is designed to provide a diagnostic output of the camera device's current state and relevant information. It takes a file descriptor `fd` and a vector of arguments `args` as parameters. The function constructs a formatted string that includes the camera ID, the remote callback's binder pointer, and the client process ID (PID). It appends the current state of the camera device and invokes the `dump` method of the `mFrameProcessor` to include additional frame processing details. Finally, it calls `dumpDevice` to output the complete device status to the specified file descriptor.","The provided code defines a method that generates a diagnostic report for a camera device client. It begins by creating a formatted string that includes the camera's unique identifier, a reference to the remote callback, and the process identifier of the client. The method then appends information about the current state of the camera. Additionally, it retrieves and includes details related to frame processing. Finally, the method outputs the complete diagnostic information to a specified file descriptor, allowing for inspection and troubleshooting of the camera device's status and functionality.","The vulnerability in the original code stemmed from allowing direct access to the `dump` method of the `CameraDeviceClient`, which could potentially expose sensitive information about the camera client, such as the camera ID and process ID, to unauthorized users. This could lead to information leakage or exploitation. The fix involved removing the direct call to the `dump` method and instead routing the dump requests through a more secure method, `dumpClient`, ensuring that dumps are only initiated through the `ICameraService::dump` interface. This change enhances security by controlling access to sensitive diagnostic information.","The vulnerability in the original code allowed direct access to sensitive diagnostic information about the camera client, which could be exploited by unauthorized users to gain insights into the system's state and potentially compromise security. This exposure was addressed by modifying the code to prevent direct dumping of client information. Instead, all dump requests are now routed through a secure interface, ensuring that sensitive data can only be accessed through controlled and authorized channels. This change significantly enhances the security posture by restricting access to critical information and enforcing proper authorization mechanisms.","The vulnerability was fixed by removing the direct call to the `dump` method in the `CameraDeviceClient` class, which previously allowed unrestricted access to sensitive information. Instead, the code now routes dump requests through the `dumpClient` method, which formats and processes the diagnostic output securely. This ensures that sensitive details, such as the camera ID and process ID, are only accessible through the `ICameraService::dump` interface. By enforcing this controlled access, the fix mitigates the risk of unauthorized information exposure and strengthens the overall security of the camera service.","The vulnerability was fixed by eliminating direct access to sensitive diagnostic information that could be exploited by unauthorized users. The code was modified to ensure that all requests for diagnostic data are routed through a secure interface, which enforces proper authorization and access control. This change prevents the exposure of critical details about the camera client and its state, thereby reducing the risk of information leakage. By implementing this controlled access mechanism, the system enhances its security posture and ensures that sensitive data can only be accessed through authorized channels.","CWE-200, CWE-732, CWE-284, CWE-285, CWE-346, CWE-668, CWE-552, CWE-612, CWE-359, CWE-522",N,-1
93,93,187962,187962,,Remote,Not required,Complete,CVE-2016-0826,https://www.cvedetails.com/cve/CVE-2016-0826/,CWE-264,Medium,Complete,Complete,,2016-03-12,9.3,"libcameraservice in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not require use of the ICameraService::dump method for a camera service dump, which allows attackers to gain privileges via a crafted application that directly dumps, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26265403.",2016-11-28,+Priv ,4,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122,c9ab2b0bb05a7e19fb057e79b36e232809d70122,"Camera: Disallow dumping clients directly

Camera service dumps should only be initiated through
ICameraService::dump.

Bug: 26265403
Change-Id: If3ca4718ed74bf33ad8a416192689203029e2803
",0,services/camera/libcameraservice/api_pro/ProCamera2Client.cpp,"{""filename"": ""services/camera/libcameraservice/CameraService.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.cpp"", ""patch"": ""@@ -985,6 +985,14 @@\n\n     mClientPid = 0;\n }\n \n+status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {\n+    // No dumping of clients directly over Binder,\n+    // must go through CameraService::dump\n+    android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, \""26265403\"",\n+            IPCThreadState::self()->getCallingUid(), NULL, 0);\n+    return OK;\n+}\n+\n status_t CameraService::BasicClient::startCameraOps() {\n     int32_t res;\n \n@@ -1222,7 +1230,7 @@\n\n             hasClient = true;\n             result = String8::format(\""  Device is open. Client instance dump:\\n\"");\n             write(fd, result.string(), result.size());\n-            client->dump(fd, args);\n+            client->dumpClient(fd, args);\n         }\n         if (!hasClient) {\n             result = String8::format(\""\\nNo active camera clients yet.\\n\"");\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/CameraService.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/CameraService.h"", ""patch"": ""@@ -55,6 +55,9 @@\n\n     class Client;\n     class BasicClient;\n \n+    // Event log ID\n+    static const int SN_EVENT_LOG_ID = 0x534e4554;\n+\n     // Implementation of BinderService<T>\n     static char const* getServiceName() { return \""media.camera\""; }\n \n@@ -144,7 +147,10 @@\n\n             return mRemoteBinder;\n         }\n \n-        virtual status_t      dump(int fd, const Vector<String16>& args) = 0;\n+        // Disallows dumping over binder interface\n+        virtual status_t      dump(int fd, const Vector<String16>& args);\n+        // Internal dump method to be called by CameraService\n+        virtual status_t      dumpClient(int fd, const Vector<String16>& args) = 0;\n \n     protected:\n         BasicClient(const sp<CameraService>& cameraService,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.cpp"", ""patch"": ""@@ -158,6 +158,10 @@\n\n }\n \n status_t Camera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Client2[%d] (%p) Client: %s PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/Camera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/Camera2Client.h"", ""patch"": ""@@ -98,6 +98,8 @@\n\n \n     virtual status_t dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Interface used by CameraDeviceBase\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.cpp"", ""patch"": ""@@ -112,6 +112,10 @@\n\n }\n \n status_t CameraClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {\n     const size_t SIZE = 256;\n     char buffer[SIZE];\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api1/CameraClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api1/CameraClient.h"", ""patch"": ""@@ -69,7 +69,9 @@\n\n \n     status_t initialize(camera_module_t *module);\n \n-    status_t dump(int fd, const Vector<String16>& args);\n+    virtual status_t dump(int fd, const Vector<String16>& args);\n+\n+    virtual status_t dumpClient(int fd, const Vector<String16>& args);\n \n private:\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.cpp"", ""patch"": ""@@ -480,6 +480,10 @@\n\n }\n \n status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api2/CameraDeviceClient.h"", ""patch"": ""@@ -109,6 +109,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     /**\n      * Device listener interface\n      */\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.cpp"", ""patch"": ""@@ -331,6 +331,10 @@\n\n }\n \n status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {\n+    return BasicClient::dump(fd, args);\n+}\n+\n+status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""ProCamera2Client[%d] (%p) PID: %d, dump:\\n\"",\n             mCameraId,\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/api_pro/ProCamera2Client.h"", ""patch"": ""@@ -88,6 +88,8 @@\n\n \n     virtual status_t      dump(int fd, const Vector<String16>& args);\n \n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n+\n     // Callbacks from camera service\n     virtual void onExclusiveLockStolen();\n \n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.cpp"", ""patch"": ""@@ -117,7 +117,7 @@\n\n }\n \n template <typename TClientBase>\n-status_t Camera2ClientBase<TClientBase>::dump(int fd,\n+status_t Camera2ClientBase<TClientBase>::dumpClient(int fd,\n                                               const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\""Camera2ClientBase[%d] (%p) PID: %d, dump:\\n\"",\n""}<_**next**_>{""filename"": ""services/camera/libcameraservice/common/Camera2ClientBase.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/services/camera/libcameraservice/common/Camera2ClientBase.h"", ""patch"": ""@@ -55,7 +55,7 @@\n\n     virtual ~Camera2ClientBase();\n \n     virtual status_t      initialize(camera_module_t *module);\n-    virtual status_t      dump(int fd, const Vector<String16>& args);\n+    virtual status_t      dumpClient(int fd, const Vector<String16>& args);\n \n     /**\n      * CameraDeviceBase::NotificationListener implementation\n""}"," status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""ProCamera2Client[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
"," status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""ProCamera2Client[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
",C,"    return BasicClient::dump(fd, args);
}

status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {
",,,"@@ -331,6 +331,10 @@

 }
 
 status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
+    return BasicClient::dump(fd, args);
+}
+
+status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""ProCamera2Client[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
",Android,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122/,https://android.googlesource.com/platform/frameworks/av/+/c9ab2b0bb05a7e19fb057e79b36e232809d70122%5E/,1," status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
//fix_flaw_line_below:
//    return BasicClient::dump(fd, args);
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""ProCamera2Client[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

 // TODO: print dynamic/request section from most recent requests
    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
",187962," status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""ProCamera2Client[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
"," status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
    return BasicClient::dump(fd, args);
}

status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {
     String8 result;
     result.appendFormat(""ProCamera2Client[%d] (%p) PID: %d, dump:\n"",
             mCameraId,
            getRemoteCallback()->asBinder().get(),
            mClientPid);
    result.append(""  State: "");

    mFrameProcessor->dump(fd, args);

 return dumpDevice(fd, args);
}
","The `ProCamera2Client::dump` function is designed to output diagnostic information about the `ProCamera2Client` instance. It begins by formatting a string that includes the camera ID, a pointer to the remote callback, and the client process ID (PID). This information is appended to a result string, followed by the current state of the camera client. The function then calls the `dump` method of the `mFrameProcessor` to include additional details, and finally, it invokes `dumpDevice` to output device-specific information to the provided file descriptor (`fd`) and arguments (`args`).","The provided code defines a method that generates and outputs diagnostic information about a camera client instance. It constructs a formatted string that includes the camera's unique identifier, a reference to a remote callback, and the process identifier of the client. This string is then supplemented with the current state of the camera client. Additionally, the method retrieves and appends further details from a frame processing component, ensuring comprehensive diagnostics. Finally, it outputs device-specific information to a specified file descriptor, allowing for effective debugging and monitoring of the camera's operational status.","The vulnerability in the original code stemmed from allowing direct access to the `dump` method of the camera client, which could potentially expose sensitive information or system state to unauthorized users. This was addressed in the fixed code by removing the direct call to the `dump` method and instead enforcing that client dumps can only be initiated through a controlled interface, specifically `ICameraService::dump`. This change ensures that the diagnostic information is accessed securely and only through authorized channels, thereby mitigating the risk of information leakage or exploitation.","The vulnerability in the original code allowed direct access to sensitive diagnostic information from the camera client, which could be exploited by unauthorized users to gain insights into the system's state or configuration. This posed a security risk, as it could lead to information leakage. The fix implemented a restriction that prevents direct dumping of client information, ensuring that such operations can only be performed through a designated and controlled interface. This change enhances security by centralizing access to diagnostic data, thereby reducing the potential for unauthorized access and maintaining the integrity of the camera service.","The vulnerability was fixed by removing the direct call to the `dump` method in the camera client, which previously allowed unrestricted access to sensitive diagnostic information. Instead, the code now enforces that client dumps can only be initiated through the `ICameraService::dump` interface. This change ensures that all requests for diagnostic data are routed through a controlled and secure channel, thereby preventing unauthorized access. Additionally, the `dumpClient` method remains intact to handle the actual data formatting and output, but it is no longer directly exposed, enhancing the overall security of the camera service.","The vulnerability was fixed by eliminating direct access to sensitive diagnostic information from the camera client, which could be exploited by unauthorized users. Instead, the code now mandates that all requests for diagnostic data must go through a designated and secure interface, ensuring that access is controlled and monitored. This change effectively restricts the ability to initiate dumps, thereby reducing the risk of information leakage. By centralizing the access point for diagnostic operations, the overall security of the camera service is significantly enhanced, protecting sensitive system information from potential exploitation.","CWE-306,CWE-732,CWE-284,CWE-200,CWE-285,CWE-269,CWE-250,CWE-201,CWE-213,CWE-287",N,-1
94,94,187986,187986,,Local Network,Not required,Complete,CVE-2016-0809,https://www.cvedetails.com/cve/CVE-2016-0809/,CWE-264,Low,Complete,Complete,,2016-02-06,8.3,"Use-after-free vulnerability in the wifi_cleanup function in bcmdhd/wifi_hal/wifi_hal.cpp in Wi-Fi in Android 6.x before 2016-02-01 allows attackers to gain privileges by leveraging access to the local physical environment during execution of a crafted application, aka internal bug 25753768.",2016-03-14,+Priv ,2,https://android.googlesource.com/platform/hardware/broadcom/wlan/+/2c5a4fac8bc8198f6a2635ede776f8de40a0c3e1,2c5a4fac8bc8198f6a2635ede776f8de40a0c3e1,"Fix use-after-free in wifi_cleanup()

Release reference to cmd only after possibly calling getType().


BUG: 25753768
Change-Id: Id2156ce51acec04e8364706cf7eafc7d4adae9eb
(cherry picked from commit d7f3cb9915d9ac514393d0ad7767662958054b8f https://googleplex-android-review.git.corp.google.com/#/c/815223)
",2,bcmdhd/wifi_hal/wifi_hal.cpp,"{""filename"": ""bcmdhd/wifi_hal/wifi_hal.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/hardware/broadcom/wlan/+/2c5a4fac8bc8198f6a2635ede776f8de40a0c3e1/bcmdhd/wifi_hal/wifi_hal.cpp"", ""patch"": ""@@ -335,12 +335,12 @@\n\n             pthread_mutex_unlock(&info->cb_lock);\n             cmd->cancel();\n             pthread_mutex_lock(&info->cb_lock);\n-            /* release reference added when command is saved */\n-            cmd->releaseRef();\n             if (num_cmd == info->num_cmd) {\n                 ALOGI(\""Cancelling command %p:%s did not work\"", cmd, (cmd ? cmd->getType(): \""\""));\n                 bad_commands++;\n             }\n+            /* release reference added when command is saved */\n+            cmd->releaseRef();\n         }\n     }\n \n""}","void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)
{
    hal_info *info = getHalInfo(handle);
 char buf[64];

    info->cleaned_up_handler = handler;
 if (write(info->cleanup_socks[0], ""Exit"", 4) < 1) {
        ALOGE(""could not write to the cleanup socket"");
 } else {
        memset(buf, 0, sizeof(buf));
 int result = read(info->cleanup_socks[0], buf, sizeof(buf));
        ALOGE(""%s: Read after POLL returned %d, error no = %d"", __FUNCTION__, result, errno);
 if (strncmp(buf, ""Done"", 4) == 0) {
            ALOGE(""Event processing terminated"");
 } else {
            ALOGD(""Rx'ed %s"", buf);
 }
 }
    info->clean_up = true;
    pthread_mutex_lock(&info->cb_lock);

 int bad_commands = 0;

 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGI(""Command left in event_cb %p:%s"", cmd, (cmd ? cmd->getType(): """"));
 }

 while (info->num_cmd > bad_commands) {
 int num_cmd = info->num_cmd;
        cmd_info *cmdi = &(info->cmd[bad_commands]);
 WifiCommand *cmd = cmdi->cmd;
 if (cmd != NULL) {
            ALOGI(""Cancelling command %p:%s"", cmd, cmd->getType());

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
            /* release reference added when command is saved */
            cmd->releaseRef();
         }
     }
 
 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGE(""Leaked command %p"", cmd);
 }
    pthread_mutex_unlock(&info->cb_lock);
    internal_cleaned_up_handler(handle);
}
","void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)
{
    hal_info *info = getHalInfo(handle);
 char buf[64];

    info->cleaned_up_handler = handler;
 if (write(info->cleanup_socks[0], ""Exit"", 4) < 1) {
        ALOGE(""could not write to the cleanup socket"");
 } else {
        memset(buf, 0, sizeof(buf));
 int result = read(info->cleanup_socks[0], buf, sizeof(buf));
        ALOGE(""%s: Read after POLL returned %d, error no = %d"", __FUNCTION__, result, errno);
 if (strncmp(buf, ""Done"", 4) == 0) {
            ALOGE(""Event processing terminated"");
 } else {
            ALOGD(""Rx'ed %s"", buf);
 }
 }
    info->clean_up = true;
    pthread_mutex_lock(&info->cb_lock);

 int bad_commands = 0;

 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGI(""Command left in event_cb %p:%s"", cmd, (cmd ? cmd->getType(): """"));
 }

 while (info->num_cmd > bad_commands) {
 int num_cmd = info->num_cmd;
        cmd_info *cmdi = &(info->cmd[bad_commands]);
 WifiCommand *cmd = cmdi->cmd;
 if (cmd != NULL) {
            ALOGI(""Cancelling command %p:%s"", cmd, cmd->getType());

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
            /* release reference added when command is saved */
            cmd->releaseRef();
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
         }
     }
 
 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGE(""Leaked command %p"", cmd);
 }
    pthread_mutex_unlock(&info->cb_lock);
    internal_cleaned_up_handler(handle);
}
",C,"            /* release reference added when command is saved */
            cmd->releaseRef();
","            /* release reference added when command is saved */
            cmd->releaseRef();
",,"@@ -335,12 +335,12 @@

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
-            /* release reference added when command is saved */
-            cmd->releaseRef();
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
+            /* release reference added when command is saved */
+            cmd->releaseRef();
         }
     }
 
",Android,https://android.googlesource.com/platform/hardware/broadcom/wlan/+/2c5a4fac8bc8198f6a2635ede776f8de40a0c3e1/,https://android.googlesource.com/platform/hardware/broadcom/wlan/+/2c5a4fac8bc8198f6a2635ede776f8de40a0c3e1%5E/,1,"void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)
{
    hal_info *info = getHalInfo(handle);
 char buf[64];

    info->cleaned_up_handler = handler;
 if (write(info->cleanup_socks[0], ""Exit"", 4) < 1) {
 // As a fallback set the cleanup flag to TRUE
        ALOGE(""could not write to the cleanup socket"");
 } else {
 // Listen to the response
 // Hopefully we dont get errors or get hung up
 // Not much can be done in that case, but assume that
 // it has rx'ed the Exit message to exit the thread.
 // As a fallback set the cleanup flag to TRUE
        memset(buf, 0, sizeof(buf));
 int result = read(info->cleanup_socks[0], buf, sizeof(buf));
        ALOGE(""%s: Read after POLL returned %d, error no = %d"", __FUNCTION__, result, errno);
 if (strncmp(buf, ""Done"", 4) == 0) {
            ALOGE(""Event processing terminated"");
 } else {
            ALOGD(""Rx'ed %s"", buf);
 }
 }
    info->clean_up = true;
    pthread_mutex_lock(&info->cb_lock);

 int bad_commands = 0;

 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGI(""Command left in event_cb %p:%s"", cmd, (cmd ? cmd->getType(): """"));
 }

 while (info->num_cmd > bad_commands) {
 int num_cmd = info->num_cmd;
        cmd_info *cmdi = &(info->cmd[bad_commands]);
 WifiCommand *cmd = cmdi->cmd;
 if (cmd != NULL) {
            ALOGI(""Cancelling command %p:%s"", cmd, cmd->getType());

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
//flaw_line_below:
            /* release reference added when command is saved */
//flaw_line_below:
            cmd->releaseRef();
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
//fix_flaw_line_below:
//            /* release reference added when command is saved */
//fix_flaw_line_below:
//            cmd->releaseRef();
         }
     }
 
 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGE(""Leaked command %p"", cmd);
 }
    pthread_mutex_unlock(&info->cb_lock);
    internal_cleaned_up_handler(handle);
}
",187986,"void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)
{
    hal_info *info = getHalInfo(handle);
 char buf[64];

    info->cleaned_up_handler = handler;
 if (write(info->cleanup_socks[0], ""Exit"", 4) < 1) {
        ALOGE(""could not write to the cleanup socket"");
 } else {
        memset(buf, 0, sizeof(buf));
 int result = read(info->cleanup_socks[0], buf, sizeof(buf));
        ALOGE(""%s: Read after POLL returned %d, error no = %d"", __FUNCTION__, result, errno);
 if (strncmp(buf, ""Done"", 4) == 0) {
            ALOGE(""Event processing terminated"");
 } else {
            ALOGD(""Rx'ed %s"", buf);
 }
 }
    info->clean_up = true;
    pthread_mutex_lock(&info->cb_lock);

 int bad_commands = 0;

 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGI(""Command left in event_cb %p:%s"", cmd, (cmd ? cmd->getType(): """"));
 }

 while (info->num_cmd > bad_commands) {
 int num_cmd = info->num_cmd;
        cmd_info *cmdi = &(info->cmd[bad_commands]);
 WifiCommand *cmd = cmdi->cmd;
 if (cmd != NULL) {
            ALOGI(""Cancelling command %p:%s"", cmd, cmd->getType());

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
            /* release reference added when command is saved */
            cmd->releaseRef();
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
         }
     }
 
 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGE(""Leaked command %p"", cmd);
 }
    pthread_mutex_unlock(&info->cb_lock);
    internal_cleaned_up_handler(handle);
}
","void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)
{
    hal_info *info = getHalInfo(handle);
 char buf[64];

    info->cleaned_up_handler = handler;
 if (write(info->cleanup_socks[0], ""Exit"", 4) < 1) {
        ALOGE(""could not write to the cleanup socket"");
 } else {
        memset(buf, 0, sizeof(buf));
 int result = read(info->cleanup_socks[0], buf, sizeof(buf));
        ALOGE(""%s: Read after POLL returned %d, error no = %d"", __FUNCTION__, result, errno);
 if (strncmp(buf, ""Done"", 4) == 0) {
            ALOGE(""Event processing terminated"");
 } else {
            ALOGD(""Rx'ed %s"", buf);
 }
 }
    info->clean_up = true;
    pthread_mutex_lock(&info->cb_lock);

 int bad_commands = 0;

 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGI(""Command left in event_cb %p:%s"", cmd, (cmd ? cmd->getType(): """"));
 }

 while (info->num_cmd > bad_commands) {
 int num_cmd = info->num_cmd;
        cmd_info *cmdi = &(info->cmd[bad_commands]);
 WifiCommand *cmd = cmdi->cmd;
 if (cmd != NULL) {
            ALOGI(""Cancelling command %p:%s"", cmd, cmd->getType());

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
            /* release reference added when command is saved */
            cmd->releaseRef();
         }
     }
 
 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGE(""Leaked command %p"", cmd);
 }
    pthread_mutex_unlock(&info->cb_lock);
    internal_cleaned_up_handler(handle);
}
","The `wifi_cleanup` function is designed to clean up resources associated with a Wi-Fi handle. It begins by retrieving hardware abstraction layer (HAL) information and setting a cleanup handler. The function attempts to signal cleanup via a socket and reads the response to confirm termination of event processing. It then locks a mutex to safely iterate through and cancel any remaining commands, logging details about each command and checking for cancellation success. Finally, it logs any leaked commands before unlocking the mutex and invoking an internal cleanup handler to finalize the cleanup process.","The function is responsible for cleaning up resources associated with a Wi-Fi connection. It initiates the cleanup process by signaling through a socket and checks for a confirmation response. The function then locks a mutex to ensure thread safety while it iterates through any remaining commands, attempting to cancel them and logging relevant information about each command's status. After addressing potential command leaks, it unlocks the mutex and calls an internal handler to complete the cleanup process, ensuring that all resources are properly released and that no commands are left unprocessed.","The vulnerability in the original code stemmed from a use-after-free issue, where a command reference was released before it was safely used, specifically when calling the `getType()` function. This could lead to accessing freed memory, resulting in undefined behavior or crashes. In the fixed code, the reference to the command is now released only after the `getType()` function is called, ensuring that the command remains valid for the duration of its usage. This change effectively mitigates the risk of dereferencing a dangling pointer, thereby enhancing the stability and safety of the cleanup process.","The vulnerability in the original code was a use-after-free issue, where a reference to an object was released before it was safely accessed, potentially leading to dereferencing invalid memory. This could cause crashes or unpredictable behavior if the memory was accessed after being freed. The fix involved changing the order of operations so that the reference was only released after the object was used, ensuring that it remained valid during its necessary operations. This adjustment effectively eliminated the risk of accessing freed memory, thereby improving the overall safety and reliability of the code.","The vulnerability was fixed by changing the order of operations regarding the command reference in the cleanup process. In the original code, the reference to the command was released immediately after calling the `cancel()` function, which could lead to a use-after-free scenario when subsequently calling `getType()`. The revised code ensures that the reference is only released after the `getType()` function is called, maintaining the validity of the command during its usage. This adjustment prevents dereferencing a dangling pointer, thereby eliminating the risk of accessing freed memory and enhancing the stability of the cleanup function.","The vulnerability was fixed by altering the sequence of operations related to the management of object references. The original implementation released the reference to an object before it was safely accessed, which could lead to accessing invalid memory. The revised code ensures that the reference remains valid for the duration of its necessary operations by delaying its release until after the object has been used. This change effectively prevents any potential dereferencing of freed memory, thereby enhancing the overall safety and reliability of the cleanup process and eliminating the risk of undefined behavior.","CWE-416, CWE-825, CWE-672, CWE-415, CWE-404, CWE-773, CWE-911, CWE-476, CWE-908, CWE-843",N,-1
95,95,187990,187990,,Local,Not required,Complete,CVE-2016-0807,https://www.cvedetails.com/cve/CVE-2016-0807/,CWE-264,Low,Complete,Complete,,2016-02-06,7.2,"The get_build_id function in elf_utils.cpp in Debuggerd in Android 6.x before 2016-02-01 allows attackers to gain privileges via a crafted application that mishandles a Desc Size element in an ELF Note, aka internal bug 25187394.",2016-03-11,+Priv ,4,https://android.googlesource.com/platform%2Fsystem%2Fcore/+/d917514bd6b270df431ea4e781a865764d406120,d917514bd6b270df431ea4e781a865764d406120,"Fix incorrect check of descsz value.

Bug: 25187394

(cherry picked from commit 1fa55234d6773e09e3bb934419b5b6cc0df981c9)

Change-Id: Idbc9071e8b2b25a062c4e94118808d6e19d443d9
",4,debuggerd/elf_utils.cpp,"{""filename"": ""debuggerd/elf_utils.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/core/+/d917514bd6b270df431ea4e781a865764d406120/debuggerd/elf_utils.cpp"", ""patch"": ""@@ -63,10 +63,10 @@\n\n         if (nhdr.n_type == NT_GNU_BUILD_ID) {\n           // Skip the name (which is the owner and should be \""GNU\"").\n           addr += NOTE_ALIGN(nhdr.n_namesz);\n-          uint8_t build_id_data[128];\n-          if (nhdr.n_namesz > sizeof(build_id_data)) {\n-            ALOGE(\""Possible corrupted note, name size value is too large: %u\"",\n-                  nhdr.n_namesz);\n+          uint8_t build_id_data[160];\n+          if (nhdr.n_descsz > sizeof(build_id_data)) {\n+            ALOGE(\""Possible corrupted note, desc size value is too large: %u\"",\n+                  nhdr.n_descsz);\n             return false;\n           }\n           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {\n""}","static bool get_build_id(
 Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {
 HdrType hdr;

  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);

 if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,
 sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {
 return false;
 }

 for (size_t i = 0; i < hdr.e_phnum; i++) {
 PhdrType phdr;
 if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,
 reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {
 return false;
 }
 if (phdr.p_type == PT_NOTE) {
 size_t hdr_size = phdr.p_filesz;
 uintptr_t addr = base_addr + phdr.p_offset;
 while (hdr_size >= sizeof(NhdrType)) {
 NhdrType nhdr;
 if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {
 return false;
 }
        addr += sizeof(nhdr);

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           addr += NOTE_ALIGN(nhdr.n_namesz);
          uint8_t build_id_data[160];
          if (nhdr.n_descsz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, desc size value is too large: %u"",
                  nhdr.n_descsz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
 return false;
 }

          build_id->clear();
 for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {
 *build_id += android::base::StringPrintf(""%02x"", build_id_data[bytes]);
 }

 return true;
 } else {
          hdr_size -= sizeof(nhdr);
 size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);
          addr += skip_bytes;
 if (hdr_size < skip_bytes) {
 break;
 }
          hdr_size -= skip_bytes;
 }
 }
 }
 }
 return false;
}
","static bool get_build_id(
 Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {
 HdrType hdr;

  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);

 if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,
 sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {
 return false;
 }

 for (size_t i = 0; i < hdr.e_phnum; i++) {
 PhdrType phdr;
 if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,
 reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {
 return false;
 }
 if (phdr.p_type == PT_NOTE) {
 size_t hdr_size = phdr.p_filesz;
 uintptr_t addr = base_addr + phdr.p_offset;
 while (hdr_size >= sizeof(NhdrType)) {
 NhdrType nhdr;
 if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {
 return false;
 }
        addr += sizeof(nhdr);

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           addr += NOTE_ALIGN(nhdr.n_namesz);
          uint8_t build_id_data[128];
          if (nhdr.n_namesz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, name size value is too large: %u"",
                  nhdr.n_namesz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
 return false;
 }

          build_id->clear();
 for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {
 *build_id += android::base::StringPrintf(""%02x"", build_id_data[bytes]);
 }

 return true;
 } else {
          hdr_size -= sizeof(nhdr);
 size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);
          addr += skip_bytes;
 if (hdr_size < skip_bytes) {
 break;
 }
          hdr_size -= skip_bytes;
 }
 }
 }
 }
 return false;
}
",C,"          uint8_t build_id_data[160];
          if (nhdr.n_descsz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, desc size value is too large: %u"",
                  nhdr.n_descsz);
","          uint8_t build_id_data[128];
          if (nhdr.n_namesz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, name size value is too large: %u"",
                  nhdr.n_namesz);
",,"@@ -63,10 +63,10 @@

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           // Skip the name (which is the owner and should be ""GNU"").
           addr += NOTE_ALIGN(nhdr.n_namesz);
-          uint8_t build_id_data[128];
-          if (nhdr.n_namesz > sizeof(build_id_data)) {
-            ALOGE(""Possible corrupted note, name size value is too large: %u"",
-                  nhdr.n_namesz);
+          uint8_t build_id_data[160];
+          if (nhdr.n_descsz > sizeof(build_id_data)) {
+            ALOGE(""Possible corrupted note, desc size value is too large: %u"",
+                  nhdr.n_descsz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
",Android,https://android.googlesource.com/platform/system/core/+/d917514bd6b270df431ea4e781a865764d406120/,https://android.googlesource.com/platform/system/core/+/d917514bd6b270df431ea4e781a865764d406120%5E/,1,"static bool get_build_id(
 Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {
 HdrType hdr;

  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);

 // First read the rest of the header.
 if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,
 sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {
 return false;
 }

 for (size_t i = 0; i < hdr.e_phnum; i++) {
 PhdrType phdr;
 if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,
 reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {
 return false;
 }
 // Looking for the .note.gnu.build-id note.
 if (phdr.p_type == PT_NOTE) {
 size_t hdr_size = phdr.p_filesz;
 uintptr_t addr = base_addr + phdr.p_offset;
 while (hdr_size >= sizeof(NhdrType)) {
 NhdrType nhdr;
 if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {
 return false;
 }
        addr += sizeof(nhdr);

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           // Skip the name (which is the owner and should be ""GNU"").
           addr += NOTE_ALIGN(nhdr.n_namesz);
//flaw_line_below:
          uint8_t build_id_data[128];
//flaw_line_below:
          if (nhdr.n_namesz > sizeof(build_id_data)) {
//flaw_line_below:
            ALOGE(""Possible corrupted note, name size value is too large: %u"",
//flaw_line_below:
                  nhdr.n_namesz);
//fix_flaw_line_below:
//          uint8_t build_id_data[160];
//fix_flaw_line_below:
//          if (nhdr.n_descsz > sizeof(build_id_data)) {
//fix_flaw_line_below:
//            ALOGE(""Possible corrupted note, desc size value is too large: %u"",
//fix_flaw_line_below:
//                  nhdr.n_descsz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
 return false;
 }

          build_id->clear();
 for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {
 *build_id += android::base::StringPrintf(""%02x"", build_id_data[bytes]);
 }

 return true;
 } else {
 // Move past the extra note data.
          hdr_size -= sizeof(nhdr);
 size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);
          addr += skip_bytes;
 if (hdr_size < skip_bytes) {
 break;
 }
          hdr_size -= skip_bytes;
 }
 }
 }
 }
 return false;
}
",187990,"static bool get_build_id(
 Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {
 HdrType hdr;

  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);

 if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,
 sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {
 return false;
 }

 for (size_t i = 0; i < hdr.e_phnum; i++) {
 PhdrType phdr;
 if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,
 reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {
 return false;
 }
 if (phdr.p_type == PT_NOTE) {
 size_t hdr_size = phdr.p_filesz;
 uintptr_t addr = base_addr + phdr.p_offset;
 while (hdr_size >= sizeof(NhdrType)) {
 NhdrType nhdr;
 if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {
 return false;
 }
        addr += sizeof(nhdr);

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           addr += NOTE_ALIGN(nhdr.n_namesz);
          uint8_t build_id_data[128];
          if (nhdr.n_namesz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, name size value is too large: %u"",
                  nhdr.n_namesz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
 return false;
 }

          build_id->clear();
 for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {
 *build_id += android::base::StringPrintf(""%02x"", build_id_data[bytes]);
 }

 return true;
 } else {
          hdr_size -= sizeof(nhdr);
 size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);
          addr += skip_bytes;
 if (hdr_size < skip_bytes) {
 break;
 }
          hdr_size -= skip_bytes;
 }
 }
 }
 }
 return false;
}
","static bool get_build_id(
 Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {
 HdrType hdr;

  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);

 if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,
 sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {
 return false;
 }

 for (size_t i = 0; i < hdr.e_phnum; i++) {
 PhdrType phdr;
 if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,
 reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {
 return false;
 }
 if (phdr.p_type == PT_NOTE) {
 size_t hdr_size = phdr.p_filesz;
 uintptr_t addr = base_addr + phdr.p_offset;
 while (hdr_size >= sizeof(NhdrType)) {
 NhdrType nhdr;
 if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {
 return false;
 }
        addr += sizeof(nhdr);

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           addr += NOTE_ALIGN(nhdr.n_namesz);
          uint8_t build_id_data[160];
          if (nhdr.n_descsz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, desc size value is too large: %u"",
                  nhdr.n_descsz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
 return false;
 }

          build_id->clear();
 for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {
 *build_id += android::base::StringPrintf(""%02x"", build_id_data[bytes]);
 }

 return true;
 } else {
          hdr_size -= sizeof(nhdr);
 size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);
          addr += skip_bytes;
 if (hdr_size < skip_bytes) {
 break;
 }
          hdr_size -= skip_bytes;
 }
 }
 }
 }
 return false;
}
","The `get_build_id` function retrieves the build ID from a binary file's ELF (Executable and Linkable Format) header. It starts by copying the ELF identification data and reading the ELF header to determine the number of program headers. It then iterates through these headers to find one of type `PT_NOTE`, which contains additional information. Within this section, it looks for a note of type `NT_GNU_BUILD_ID`, reading its associated data if found. The build ID is formatted as a hexadecimal string and stored in the provided `build_id` string. The function returns `true` if successful, otherwise `false`.","The code defines a function that extracts a unique identifier from a binary file's header structure. It begins by copying identification data and reading the header to determine the number of segments present. The function then searches through these segments for a specific type that contains additional metadata. Within this metadata, it looks for a particular note type that holds the identifier. If found, the identifier data is read, formatted as a hexadecimal string, and stored in a provided output variable. The function returns a success or failure status based on the operations performed.","The vulnerability in the original code stemmed from an inadequate check of the descriptor size value, which could lead to buffer overflows if the size exceeded the allocated buffer for the build ID data. Specifically, the original code used a fixed-size array of 128 bytes, which could be insufficient for larger descriptor sizes, allowing potential memory corruption. The fix involved increasing the size of the `build_id_data` array to 160 bytes and adding a more robust check to ensure that the descriptor size does not exceed this new limit. This change enhances the code's safety by preventing overflows and ensuring proper memory handling.","The vulnerability in the original code was due to an insufficient check on the size of the descriptor, which could allow for buffer overflows if the size exceeded the allocated memory for storing the data. This oversight posed a risk of memory corruption and potential exploitation. The fix involved increasing the allocated memory size for the descriptor and implementing a more stringent validation to ensure that the size does not exceed this new limit. This change effectively mitigates the risk of buffer overflows, enhancing the overall safety and stability of the code.","The vulnerability was fixed by increasing the size of the `build_id_data` array from 128 bytes to 160 bytes, allowing for larger descriptor sizes. Additionally, a more robust check was added to verify that the `nhdr.n_descsz` value does not exceed the size of the `build_id_data` array. If the descriptor size is too large, an error message is logged, and the function returns false, preventing any potential buffer overflow. This ensures that the code safely handles varying descriptor sizes while protecting against memory corruption issues.","The vulnerability was addressed by increasing the allocated memory for storing the descriptor data, allowing for larger sizes without risking overflow. Additionally, a more stringent validation was implemented to ensure that the size of the descriptor does not exceed the newly allocated memory limit. If the size is found to be too large, an error message is logged, and the function safely exits without proceeding further. This approach effectively mitigates the risk of memory corruption and enhances the overall robustness of the code by ensuring proper handling of varying data sizes.","CWE-119, CWE-120, CWE-131, CWE-789, CWE-190, CWE-680, CWE-122, CWE-787, CWE-788, CWE-400",N,-1
96,96,187994,187994,,Remote,Not required,Complete,CVE-2015-6640,https://www.cvedetails.com/cve/CVE-2015-6640/,CWE-264,Medium,Complete,Complete,,2016-01-06,9.3,"The prctl_set_vma_anon_name function in kernel/sys.c in Android before 5.1.1 LMY49F and 6.0 before 2016-01-01 does not ensure that only one vma is accessed in a certain update action, which allows attackers to gain privileges or cause a denial of service (vma list corruption) via a crafted application, aka internal bug 20017123.",2016-12-07,DoS +Priv ,1,https://android.googlesource.com/kernel%2Fcommon/+/69bfe2d957d903521d32324190c2754cb073be15,69bfe2d957d903521d32324190c2754cb073be15,"mm: fix prctl_set_vma_anon_name

prctl_set_vma_anon_name could attempt to set the name across
two vmas at the same time due to a typo, which might corrupt
the vma list.  Fix it to use tmp instead of end to limit
the name setting to a single vma at a time.

Change-Id: Ie32d8ddb0fd547efbeedd6528acdab5ca5b308b4
Reported-by: Jed Davis <jld@mozilla.com>
Signed-off-by: Colin Cross <ccross@android.com>
",1,kernel/sys.c,"{""filename"": ""kernel/sys.c"", ""raw_url"": ""https://android.googlesource.com/kernel/common/+/69bfe2d957d903521d32324190c2754cb073be15/kernel/sys.c"", ""patch"": ""@@ -1934,7 +1934,7 @@\n\n \t\t\ttmp = end;\n \n \t\t/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */\n-\t\terror = prctl_update_vma_anon_name(vma, &prev, start, end,\n+\t\terror = prctl_update_vma_anon_name(vma, &prev, start, tmp,\n \t\t\t\t(const char __user *)arg);\n \t\tif (error)\n \t\t\treturn error;\n""}","static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,
 unsigned long arg)
{
 unsigned long tmp;
 struct vm_area_struct * vma, *prev;
 int unmapped_error = 0;
 int error = -EINVAL;

 /*
	 * If the interval [start,end) covers some unmapped address
	 * ranges, just ignore them, but return -ENOMEM at the end.
	 * - this matches the handling in madvise.
	 */
	vma = find_vma_prev(current->mm, start, &prev);
 if (vma && start > vma->vm_start)
		prev = vma;

 for (;;) {
 /* Still start < end. */
		error = -ENOMEM;
 if (!vma)
 return error;

 /* Here start < (end|vma->vm_end). */
 if (start < vma->vm_start) {
			unmapped_error = -ENOMEM;
			start = vma->vm_start;
 if (start >= end)
 return error;
 }

 /* Here vma->vm_start <= start < (end|vma->vm_end) */
		tmp = vma->vm_end;
 if (end < tmp)

 			tmp = end;
 
 		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
		error = prctl_update_vma_anon_name(vma, &prev, start, tmp,
 				(const char __user *)arg);
 		if (error)
 			return error;
		start = tmp;
 if (prev && start < prev->vm_end)
			start = prev->vm_end;
		error = unmapped_error;
 if (start >= end)
 return error;
 if (prev)
			vma = prev->vm_next;
 else /* madvise_remove dropped mmap_sem */
			vma = find_vma(current->mm, start);
 }
}
","static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,
 unsigned long arg)
{
 unsigned long tmp;
 struct vm_area_struct * vma, *prev;
 int unmapped_error = 0;
 int error = -EINVAL;

 /*
	 * If the interval [start,end) covers some unmapped address
	 * ranges, just ignore them, but return -ENOMEM at the end.
	 * - this matches the handling in madvise.
	 */
	vma = find_vma_prev(current->mm, start, &prev);
 if (vma && start > vma->vm_start)
		prev = vma;

 for (;;) {
 /* Still start < end. */
		error = -ENOMEM;
 if (!vma)
 return error;

 /* Here start < (end|vma->vm_end). */
 if (start < vma->vm_start) {
			unmapped_error = -ENOMEM;
			start = vma->vm_start;
 if (start >= end)
 return error;
 }

 /* Here vma->vm_start <= start < (end|vma->vm_end) */
		tmp = vma->vm_end;
 if (end < tmp)

 			tmp = end;
 
 		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
		error = prctl_update_vma_anon_name(vma, &prev, start, end,
 				(const char __user *)arg);
 		if (error)
 			return error;
		start = tmp;
 if (prev && start < prev->vm_end)
			start = prev->vm_end;
		error = unmapped_error;
 if (start >= end)
 return error;
 if (prev)
			vma = prev->vm_next;
 else /* madvise_remove dropped mmap_sem */
			vma = find_vma(current->mm, start);
 }
}
",C,"		error = prctl_update_vma_anon_name(vma, &prev, start, tmp,
","		error = prctl_update_vma_anon_name(vma, &prev, start, end,
",,"@@ -1934,7 +1934,7 @@

 			tmp = end;
 
 		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
-		error = prctl_update_vma_anon_name(vma, &prev, start, end,
+		error = prctl_update_vma_anon_name(vma, &prev, start, tmp,
 				(const char __user *)arg);
 		if (error)
 			return error;
",Android,https://android.googlesource.com/kernel/common/+/69bfe2d957d903521d32324190c2754cb073be15/,https://android.googlesource.com/kernel/common/+/69bfe2d957d903521d32324190c2754cb073be15%5E/,1,"static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,
 unsigned long arg)
{
 unsigned long tmp;
 struct vm_area_struct * vma, *prev;
 int unmapped_error = 0;
 int error = -EINVAL;

 /*
	 * If the interval [start,end) covers some unmapped address
	 * ranges, just ignore them, but return -ENOMEM at the end.
	 * - this matches the handling in madvise.
	 */
	vma = find_vma_prev(current->mm, start, &prev);
 if (vma && start > vma->vm_start)
		prev = vma;

 for (;;) {
 /* Still start < end. */
		error = -ENOMEM;
 if (!vma)
 return error;

 /* Here start < (end|vma->vm_end). */
 if (start < vma->vm_start) {
			unmapped_error = -ENOMEM;
			start = vma->vm_start;
 if (start >= end)
 return error;
 }

 /* Here vma->vm_start <= start < (end|vma->vm_end) */
		tmp = vma->vm_end;
 if (end < tmp)

 			tmp = end;
 
 		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
//flaw_line_below:
		error = prctl_update_vma_anon_name(vma, &prev, start, end,
//fix_flaw_line_below:
//		error = prctl_update_vma_anon_name(vma, &prev, start, tmp,
 				(const char __user *)arg);
 		if (error)
 			return error;
		start = tmp;
 if (prev && start < prev->vm_end)
			start = prev->vm_end;
		error = unmapped_error;
 if (start >= end)
 return error;
 if (prev)
			vma = prev->vm_next;
 else /* madvise_remove dropped mmap_sem */
			vma = find_vma(current->mm, start);
 }
}
",187994,"static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,
 unsigned long arg)
{
 unsigned long tmp;
 struct vm_area_struct * vma, *prev;
 int unmapped_error = 0;
 int error = -EINVAL;

 /*
	 * If the interval [start,end) covers some unmapped address
	 * ranges, just ignore them, but return -ENOMEM at the end.
	 * - this matches the handling in madvise.
	 */
	vma = find_vma_prev(current->mm, start, &prev);
 if (vma && start > vma->vm_start)
		prev = vma;

 for (;;) {
 /* Still start < end. */
		error = -ENOMEM;
 if (!vma)
 return error;

 /* Here start < (end|vma->vm_end). */
 if (start < vma->vm_start) {
			unmapped_error = -ENOMEM;
			start = vma->vm_start;
 if (start >= end)
 return error;
 }

 /* Here vma->vm_start <= start < (end|vma->vm_end) */
		tmp = vma->vm_end;
 if (end < tmp)

 			tmp = end;
 
 		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
		error = prctl_update_vma_anon_name(vma, &prev, start, end,
 				(const char __user *)arg);
 		if (error)
 			return error;
		start = tmp;
 if (prev && start < prev->vm_end)
			start = prev->vm_end;
		error = unmapped_error;
 if (start >= end)
 return error;
 if (prev)
			vma = prev->vm_next;
 else /* madvise_remove dropped mmap_sem */
			vma = find_vma(current->mm, start);
 }
}
","static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,
 unsigned long arg)
{
 unsigned long tmp;
 struct vm_area_struct * vma, *prev;
 int unmapped_error = 0;
 int error = -EINVAL;

 /*
	 * If the interval [start,end) covers some unmapped address
	 * ranges, just ignore them, but return -ENOMEM at the end.
	 * - this matches the handling in madvise.
	 */
	vma = find_vma_prev(current->mm, start, &prev);
 if (vma && start > vma->vm_start)
		prev = vma;

 for (;;) {
 /* Still start < end. */
		error = -ENOMEM;
 if (!vma)
 return error;

 /* Here start < (end|vma->vm_end). */
 if (start < vma->vm_start) {
			unmapped_error = -ENOMEM;
			start = vma->vm_start;
 if (start >= end)
 return error;
 }

 /* Here vma->vm_start <= start < (end|vma->vm_end) */
		tmp = vma->vm_end;
 if (end < tmp)

 			tmp = end;
 
 		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
		error = prctl_update_vma_anon_name(vma, &prev, start, tmp,
 				(const char __user *)arg);
 		if (error)
 			return error;
		start = tmp;
 if (prev && start < prev->vm_end)
			start = prev->vm_end;
		error = unmapped_error;
 if (start >= end)
 return error;
 if (prev)
			vma = prev->vm_next;
 else /* madvise_remove dropped mmap_sem */
			vma = find_vma(current->mm, start);
 }
}
","The function `prctl_set_vma_anon_name` is designed to update the anonymous name of virtual memory areas (VMAs) within a specified address range in a process's memory. It takes three parameters: the start and end addresses of the range, and an argument containing the new name. The function iterates through the VMAs, handling unmapped address ranges by ignoring them while tracking errors. It updates the VMA names using the helper function `prctl_update_vma_anon_name`, ensuring that the updates respect the boundaries of the VMAs. The function ultimately returns an error code if any issues arise during the process.","The provided code defines a function that updates the names of anonymous memory regions within a specified address range in a process's memory. It checks for unmapped address ranges and ignores them while tracking any errors encountered during the process. The function iterates through the memory regions, ensuring that updates are made only within valid boundaries. If the specified range overlaps with existing memory areas, it updates their names accordingly. The function ultimately returns an error code if any issues arise, ensuring proper handling of memory management during the update process.","The vulnerability in the original code stemmed from a typo that allowed the function to attempt to set the name across two virtual memory areas (VMAs) simultaneously, potentially leading to corruption of the VMA list. Specifically, the code incorrectly used the `end` variable instead of `tmp` when calling the name-setting function, which could cause overlapping updates. The fix addressed this issue by ensuring that the name-setting operation is limited to a single VMA at a time, using `tmp` to define the upper boundary for the update, thus preventing unintended modifications to adjacent memory areas.","The vulnerability in the original code arose from a typo that allowed the function to attempt to set a name across two adjacent memory areas simultaneously, risking corruption of the memory area list. This issue occurred because the code used an incorrect boundary for the name-setting operation, which could lead to unintended modifications. The fix addressed this vulnerability by ensuring that the name-setting process is confined to a single memory area at a time, thereby preventing any overlap or corruption. This change effectively safeguards the integrity of the memory area list during the update process.","The vulnerability was fixed by changing the boundary used in the name-setting operation from `end` to `tmp`. In the original code, using `end` allowed the function to potentially update the name across two virtual memory areas simultaneously, which could corrupt the VMA list. By modifying the call to `prctl_update_vma_anon_name` to use `tmp`, the code now restricts the name-setting operation to a single VMA at a time, ensuring that updates do not overlap with adjacent memory areas. This change effectively prevents unintended modifications and maintains the integrity of the VMA list.","The vulnerability was fixed by adjusting the boundary used for the name-setting operation to ensure that it only applies to a single memory area at a time. The original implementation allowed for potential updates across adjacent memory areas, which could lead to corruption of the memory area list. By changing the boundary to a more appropriate value, the updated code now confines the name-setting process to the current memory area being processed. This modification effectively prevents any overlap or unintended modifications, thereby safeguarding the integrity of the memory area list during the update operation.","CWE-119, CWE-787, CWE-788, CWE-823, CWE-125, CWE-789, CWE-416, CWE-415, CWE-123, CWE-763",N,-1
97,97,188143,188143,,Remote,Not required,Complete,CVE-2015-3849,https://www.cvedetails.com/cve/CVE-2015-3849/,CWE-264,Medium,Complete,Complete,,2015-09-30,9.3,"The Region_createFromParcel function in core/jni/android/graphics/Region.cpp in Region in Android before 5.1.1 LMY48M does not check the return values of certain read operations, which allows attackers to execute arbitrary code via an application that sends a crafted message to a service, aka internal bug 21585255.",2015-10-01,Exec Code ,6,https://android.googlesource.com/platform/frameworks/base/+/1e72dc7a3074cd0b44d89afbf39bbf5000ef7cc3,1e72dc7a3074cd0b44d89afbf39bbf5000ef7cc3,"DO NOT MERGE: Ensure that unparcelling Region only reads the expected number of bytes

bug: 20883006
Change-Id: I4f109667fb210a80fbddddf5f1bfb7ef3a02b6ce
",1,core/jni/android/graphics/Region.cpp,"{""filename"": ""core/jni/android/graphics/Region.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/base/+/1e72dc7a3074cd0b44d89afbf39bbf5000ef7cc3/core/jni/android/graphics/Region.cpp"", ""patch"": ""@@ -218,7 +218,12 @@\n\n         return NULL;\n     }\n     SkRegion* region = new SkRegion;\n-    region->readFromMemory(regionData, size);\n+    size_t actualSize = region->readFromMemory(regionData, size);\n+\n+    if (size != actualSize) {\n+        delete region;\n+        return NULL;\n+    }\n \n     return reinterpret_cast<jlong>(region);\n }\n""}","static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)
{
 if (parcel == NULL) {
 return NULL;
 }

    android::Parcel* p = android::parcelForJavaObject(env, parcel);

 const size_t size = p->readInt32();
 const void* regionData = p->readInplace(size);
 if (regionData == NULL) {

         return NULL;
     }
     SkRegion* region = new SkRegion;
    size_t actualSize = region->readFromMemory(regionData, size);

    if (size != actualSize) {
        delete region;
        return NULL;
    }
 
     return reinterpret_cast<jlong>(region);
 }
","static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)
{
 if (parcel == NULL) {
 return NULL;
 }

    android::Parcel* p = android::parcelForJavaObject(env, parcel);

 const size_t size = p->readInt32();
 const void* regionData = p->readInplace(size);
 if (regionData == NULL) {

         return NULL;
     }
     SkRegion* region = new SkRegion;
    region->readFromMemory(regionData, size);
 
     return reinterpret_cast<jlong>(region);
 }
",C,"    size_t actualSize = region->readFromMemory(regionData, size);

    if (size != actualSize) {
        delete region;
        return NULL;
    }
","    region->readFromMemory(regionData, size);
",,"@@ -218,7 +218,12 @@

         return NULL;
     }
     SkRegion* region = new SkRegion;
-    region->readFromMemory(regionData, size);
+    size_t actualSize = region->readFromMemory(regionData, size);
+
+    if (size != actualSize) {
+        delete region;
+        return NULL;
+    }
 
     return reinterpret_cast<jlong>(region);
 }
",Android,https://android.googlesource.com/platform/frameworks/base/+/1e72dc7a3074cd0b44d89afbf39bbf5000ef7cc3/,https://android.googlesource.com/platform/frameworks/base/+/1e72dc7a3074cd0b44d89afbf39bbf5000ef7cc3%5E/,1,"static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)
{
 if (parcel == NULL) {
 return NULL;
 }

    android::Parcel* p = android::parcelForJavaObject(env, parcel);

 const size_t size = p->readInt32();
 const void* regionData = p->readInplace(size);
 if (regionData == NULL) {

         return NULL;
     }
     SkRegion* region = new SkRegion;
//flaw_line_below:
    region->readFromMemory(regionData, size);
//fix_flaw_line_below:
//    size_t actualSize = region->readFromMemory(regionData, size);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (size != actualSize) {
//fix_flaw_line_below:
//        delete region;
//fix_flaw_line_below:
//        return NULL;
//fix_flaw_line_below:
//    }
 
     return reinterpret_cast<jlong>(region);
 }
",188143,"static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)
{
 if (parcel == NULL) {
 return NULL;
 }

    android::Parcel* p = android::parcelForJavaObject(env, parcel);

 const size_t size = p->readInt32();
 const void* regionData = p->readInplace(size);
 if (regionData == NULL) {

         return NULL;
     }
     SkRegion* region = new SkRegion;
    region->readFromMemory(regionData, size);
 
     return reinterpret_cast<jlong>(region);
 }
","static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)
{
 if (parcel == NULL) {
 return NULL;
 }

    android::Parcel* p = android::parcelForJavaObject(env, parcel);

 const size_t size = p->readInt32();
 const void* regionData = p->readInplace(size);
 if (regionData == NULL) {

         return NULL;
     }
     SkRegion* region = new SkRegion;
    size_t actualSize = region->readFromMemory(regionData, size);

    if (size != actualSize) {
        delete region;
        return NULL;
    }
 
     return reinterpret_cast<jlong>(region);
 }
","The `Region_createFromParcel` function is a JNI (Java Native Interface) method that creates a Skia `SkRegion` object from a Java `Parcel` object. It first checks if the provided `parcel` is null, returning null if it is. It then retrieves the underlying Android `Parcel` and reads an integer value representing the size of the region data. If the data is successfully read into memory, a new `SkRegion` object is instantiated, populated with the region data, and its pointer is returned as a `jlong`. If any step fails, the function returns null, ensuring safe memory handling.","The provided code defines a function that creates a graphical region object from a data parcel. It begins by checking if the input parcel is null, returning null if so. The function then accesses the parcel's data to read the size of the region information. If the data is successfully retrieved, a new graphical region object is created and populated with the retrieved data. Finally, the function returns a pointer to this newly created object as a long integer. If any step fails, it ensures that null is returned to prevent memory issues.","The vulnerability in the original code arises from the lack of validation after reading the region data, which could lead to memory corruption or undefined behavior if the actual size of the data read does not match the expected size. In the fixed code, after reading the region data into the object, the actual size is compared to the expected size. If there is a mismatch, the newly created region object is deleted to prevent memory leaks, and null is returned. This additional check ensures that only the correct amount of data is processed, enhancing the code's safety and stability.","The vulnerability in the original code stems from the lack of validation after reading data from a parcel, which could lead to processing an incorrect amount of data. This oversight could result in memory corruption or crashes if the actual data size does not match the expected size. The fixed code addresses this issue by introducing a check that compares the expected size with the actual size of the data read. If there is a discrepancy, the code ensures that any allocated memory is properly released before returning null, thereby preventing potential memory leaks and enhancing overall stability.","The vulnerability was fixed by adding a validation step after reading the region data from memory. In the updated code, after the `readFromMemory` function populates the region object, the actual size of the data read is compared to the expected size. If the `size` does not match the `actualSize`, the code deletes the allocated region object to prevent memory leaks and returns null. This ensures that only correctly sized data is processed, thereby mitigating the risk of memory corruption or undefined behavior that could arise from handling unexpected data sizes.","The vulnerability was fixed by implementing a validation check after reading the data from the parcel. The updated code compares the expected size of the data with the actual size that was read into the object. If there is a mismatch between these two sizes, the code ensures that any allocated memory for the object is properly released before returning null. This additional step prevents the processing of incorrect or incomplete data, thereby reducing the risk of memory corruption and enhancing the overall stability and safety of the code.","CWE-789, CWE-119, CWE-131, CWE-122, CWE-787, CWE-130, CWE-805, CWE-469, CWE-400, CWE-401",N,-1
98,98,188170,188170,,Remote,Not required,Complete,CVE-2016-3909,https://www.cvedetails.com/cve/CVE-2016-3909/,CWE-264,Medium,Complete,Complete,,2016-10-10,9.3,"The SoftMPEG4 component in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 allows attackers to gain privileges via a crafted application, aka internal bug 30033990.",2016-11-28,+Priv ,2,https://android.googlesource.com/platform/frameworks/av/+/c48ef757cc50906e8726a3bebc3b60716292cdba,c48ef757cc50906e8726a3bebc3b60716292cdba,"Fix build breakage caused by commit
940829f69b52d6038db66a9c727534636ecc456d.

Change-Id: I4776db4a26fb3c31bb994d48788373fe569c812a
(cherry picked from commit baa9146401e28c5acf54dea21ddd197f0d3a8fcd)
",2,media/libstagefright/codecs/m4v_h263/dec/SoftMPEG4.cpp,"{""filename"": ""media/libstagefright/codecs/m4v_h263/dec/SoftMPEG4.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c48ef757cc50906e8726a3bebc3b60716292cdba/media/libstagefright/codecs/m4v_h263/dec/SoftMPEG4.cpp"", ""patch"": ""@@ -213,8 +213,8 @@\n\n             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;\n             if ((outHeader->nAllocLen < yFrameSize) ||\n                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {\n-                ALOGE(\""Too small output buffer for reference frame: %zu bytes\"",\n-                        outHeader->nAllocLen);\n+                ALOGE(\""Too small output buffer for reference frame: %lu bytes\"",\n+                        (unsigned long)outHeader->nAllocLen);\n                 android_errorWriteLog(0x534e4554, \""30033990\"");\n                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                 mSignalledError = true;\n""}","void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {
 BufferInfo *inInfo = *inQueue.begin();
        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 if (inHeader == NULL) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
 continue;
 }

 PortInfo *port = editPortInfo(1);

        OMX_BUFFERHEADERTYPE *outHeader =
            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;

 if (inHeader->nFilledLen == 0) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

 ++mInputBufferCount;

 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                outHeader->nFilledLen = 0;
                outHeader->nFlags = OMX_BUFFERFLAG_EOS;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
                outInfo->mOwnedByUs = false;
                outQueue.erase(it);
                outInfo = NULL;

                notifyFillBufferDone(outHeader);
                outHeader = NULL;
 }
 return;
 }

 uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;
 uint32_t *start_code = (uint32_t *)bitstream;
 bool volHeader = *start_code == 0xB0010000;
 if (volHeader) {
 PVCleanUpVideoDecoder(mHandle);
            mInitialized = false;
 }

 if (!mInitialized) {
 uint8_t *vol_data[1];
 int32_t vol_size = 0;

            vol_data[0] = NULL;

 if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {
                vol_data[0] = bitstream;
                vol_size = inHeader->nFilledLen;
 }

            MP4DecodingMode mode =
 (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;

 Bool success = PVInitVideoDecoder(
                    mHandle, vol_data, &vol_size, 1,
                    outputBufferWidth(), outputBufferHeight(), mode);

 if (!success) {
                ALOGW(""PVInitVideoDecoder failed. Unsupported content?"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);
 if (mode != actualMode) {
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

 PVSetPostProcType((VideoDecControls *) mHandle, 0);

 bool hasFrameData = false;
 if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
                inInfo->mOwnedByUs = false;
                inQueue.erase(inQueue.begin());
                inInfo = NULL;
                notifyEmptyBufferDone(inHeader);
                inHeader = NULL;
 } else if (volHeader) {
                hasFrameData = true;
 }

            mInitialized = true;

 if (mode == MPEG4_MODE && handlePortSettingsChange()) {
 return;
 }

 if (!hasFrameData) {
 continue;
 }
 }

 if (!mFramesConfigured) {
 PortInfo *port = editPortInfo(1);
            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;


             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
                ALOGE(""Too small output buffer for reference frame: %lu bytes"",
                        (unsigned long)outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
 return;
 }
 PVSetReferenceYUV(mHandle, outHeader->pBuffer);
            mFramesConfigured = true;
 }

 uint32_t useExtTimestamp = (inHeader->nOffset == 0);

 uint32_t timestamp = 0xFFFFFFFF;
 if (useExtTimestamp) {
            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);
            timestamp = mPvTime;
            mPvTime++;
 }

 int32_t bufferSize = inHeader->nFilledLen;
 int32_t tmp = bufferSize;

        OMX_U32 frameSize;
        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;
 if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {
            ALOGE(""Frame size too large"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
        frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));

 if (outHeader->nAllocLen < frameSize) {
            android_errorWriteLog(0x534e4554, ""27833616"");
            ALOGE(""Insufficient output buffer size"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
 if (PVDecodeVideoFrame(
                    mHandle, &bitstream, &timestamp, &tmp,
 &useExtTimestamp,
                    outHeader->pBuffer) != PV_TRUE) {
            ALOGE(""failed to decode video frame."");

            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 if (handlePortSettingsChange()) {
 return;
 }

        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);
        mPvToOmxTimeMap.removeItem(timestamp);

        inHeader->nOffset += bufferSize;
        inHeader->nFilledLen = 0;
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 } else {
            outHeader->nFlags = 0;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

 ++mInputBufferCount;

        outHeader->nOffset = 0;
        outHeader->nFilledLen = frameSize;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
        outInfo->mOwnedByUs = false;
        outQueue.erase(it);
        outInfo = NULL;

        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mNumSamplesOutput;
 }
}
","void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {
 BufferInfo *inInfo = *inQueue.begin();
        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 if (inHeader == NULL) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
 continue;
 }

 PortInfo *port = editPortInfo(1);

        OMX_BUFFERHEADERTYPE *outHeader =
            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;

 if (inHeader->nFilledLen == 0) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

 ++mInputBufferCount;

 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                outHeader->nFilledLen = 0;
                outHeader->nFlags = OMX_BUFFERFLAG_EOS;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
                outInfo->mOwnedByUs = false;
                outQueue.erase(it);
                outInfo = NULL;

                notifyFillBufferDone(outHeader);
                outHeader = NULL;
 }
 return;
 }

 uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;
 uint32_t *start_code = (uint32_t *)bitstream;
 bool volHeader = *start_code == 0xB0010000;
 if (volHeader) {
 PVCleanUpVideoDecoder(mHandle);
            mInitialized = false;
 }

 if (!mInitialized) {
 uint8_t *vol_data[1];
 int32_t vol_size = 0;

            vol_data[0] = NULL;

 if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {
                vol_data[0] = bitstream;
                vol_size = inHeader->nFilledLen;
 }

            MP4DecodingMode mode =
 (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;

 Bool success = PVInitVideoDecoder(
                    mHandle, vol_data, &vol_size, 1,
                    outputBufferWidth(), outputBufferHeight(), mode);

 if (!success) {
                ALOGW(""PVInitVideoDecoder failed. Unsupported content?"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);
 if (mode != actualMode) {
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

 PVSetPostProcType((VideoDecControls *) mHandle, 0);

 bool hasFrameData = false;
 if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
                inInfo->mOwnedByUs = false;
                inQueue.erase(inQueue.begin());
                inInfo = NULL;
                notifyEmptyBufferDone(inHeader);
                inHeader = NULL;
 } else if (volHeader) {
                hasFrameData = true;
 }

            mInitialized = true;

 if (mode == MPEG4_MODE && handlePortSettingsChange()) {
 return;
 }

 if (!hasFrameData) {
 continue;
 }
 }

 if (!mFramesConfigured) {
 PortInfo *port = editPortInfo(1);
            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;


             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
                ALOGE(""Too small output buffer for reference frame: %zu bytes"",
                        outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
 return;
 }
 PVSetReferenceYUV(mHandle, outHeader->pBuffer);
            mFramesConfigured = true;
 }

 uint32_t useExtTimestamp = (inHeader->nOffset == 0);

 uint32_t timestamp = 0xFFFFFFFF;
 if (useExtTimestamp) {
            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);
            timestamp = mPvTime;
            mPvTime++;
 }

 int32_t bufferSize = inHeader->nFilledLen;
 int32_t tmp = bufferSize;

        OMX_U32 frameSize;
        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;
 if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {
            ALOGE(""Frame size too large"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
        frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));

 if (outHeader->nAllocLen < frameSize) {
            android_errorWriteLog(0x534e4554, ""27833616"");
            ALOGE(""Insufficient output buffer size"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
 if (PVDecodeVideoFrame(
                    mHandle, &bitstream, &timestamp, &tmp,
 &useExtTimestamp,
                    outHeader->pBuffer) != PV_TRUE) {
            ALOGE(""failed to decode video frame."");

            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 if (handlePortSettingsChange()) {
 return;
 }

        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);
        mPvToOmxTimeMap.removeItem(timestamp);

        inHeader->nOffset += bufferSize;
        inHeader->nFilledLen = 0;
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 } else {
            outHeader->nFlags = 0;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

 ++mInputBufferCount;

        outHeader->nOffset = 0;
        outHeader->nFilledLen = frameSize;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
        outInfo->mOwnedByUs = false;
        outQueue.erase(it);
        outInfo = NULL;

        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mNumSamplesOutput;
 }
}
",C,"                ALOGE(""Too small output buffer for reference frame: %lu bytes"",
                        (unsigned long)outHeader->nAllocLen);
","                ALOGE(""Too small output buffer for reference frame: %zu bytes"",
                        outHeader->nAllocLen);
",,"@@ -213,8 +213,8 @@

             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
-                ALOGE(""Too small output buffer for reference frame: %zu bytes"",
-                        outHeader->nAllocLen);
+                ALOGE(""Too small output buffer for reference frame: %lu bytes"",
+                        (unsigned long)outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
",Android,https://android.googlesource.com/platform/frameworks/av/+/c48ef757cc50906e8726a3bebc3b60716292cdba/,https://android.googlesource.com/platform/frameworks/av/+/c48ef757cc50906e8726a3bebc3b60716292cdba%5E/,1,"void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {
 BufferInfo *inInfo = *inQueue.begin();
        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 if (inHeader == NULL) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
 continue;
 }

 PortInfo *port = editPortInfo(1);

        OMX_BUFFERHEADERTYPE *outHeader =
            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;

 if (inHeader->nFilledLen == 0) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

 ++mInputBufferCount;

 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                outHeader->nFilledLen = 0;
                outHeader->nFlags = OMX_BUFFERFLAG_EOS;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
                outInfo->mOwnedByUs = false;
                outQueue.erase(it);
                outInfo = NULL;

                notifyFillBufferDone(outHeader);
                outHeader = NULL;
 }
 return;
 }

 uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;
 uint32_t *start_code = (uint32_t *)bitstream;
 bool volHeader = *start_code == 0xB0010000;
 if (volHeader) {
 PVCleanUpVideoDecoder(mHandle);
            mInitialized = false;
 }

 if (!mInitialized) {
 uint8_t *vol_data[1];
 int32_t vol_size = 0;

            vol_data[0] = NULL;

 if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {
                vol_data[0] = bitstream;
                vol_size = inHeader->nFilledLen;
 }

            MP4DecodingMode mode =
 (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;

 Bool success = PVInitVideoDecoder(
                    mHandle, vol_data, &vol_size, 1,
                    outputBufferWidth(), outputBufferHeight(), mode);

 if (!success) {
                ALOGW(""PVInitVideoDecoder failed. Unsupported content?"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);
 if (mode != actualMode) {
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

 PVSetPostProcType((VideoDecControls *) mHandle, 0);

 bool hasFrameData = false;
 if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
                inInfo->mOwnedByUs = false;
                inQueue.erase(inQueue.begin());
                inInfo = NULL;
                notifyEmptyBufferDone(inHeader);
                inHeader = NULL;
 } else if (volHeader) {
                hasFrameData = true;
 }

            mInitialized = true;

 if (mode == MPEG4_MODE && handlePortSettingsChange()) {
 return;
 }

 if (!hasFrameData) {
 continue;
 }
 }

 if (!mFramesConfigured) {
 PortInfo *port = editPortInfo(1);
            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;


             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
//flaw_line_below:
                ALOGE(""Too small output buffer for reference frame: %zu bytes"",
//flaw_line_below:
                        outHeader->nAllocLen);
//fix_flaw_line_below:
//                ALOGE(""Too small output buffer for reference frame: %lu bytes"",
//fix_flaw_line_below:
//                        (unsigned long)outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
 return;
 }
 PVSetReferenceYUV(mHandle, outHeader->pBuffer);
            mFramesConfigured = true;
 }

 uint32_t useExtTimestamp = (inHeader->nOffset == 0);

 // decoder deals in ms (int32_t), OMX in us (int64_t)
 // so use fake timestamp instead
 uint32_t timestamp = 0xFFFFFFFF;
 if (useExtTimestamp) {
            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);
            timestamp = mPvTime;
            mPvTime++;
 }

 int32_t bufferSize = inHeader->nFilledLen;
 int32_t tmp = bufferSize;

        OMX_U32 frameSize;
        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;
 if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {
            ALOGE(""Frame size too large"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
        frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));

 if (outHeader->nAllocLen < frameSize) {
            android_errorWriteLog(0x534e4554, ""27833616"");
            ALOGE(""Insufficient output buffer size"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
 // The PV decoder is lying to us, sometimes it'll claim to only have
 // consumed a subset of the buffer when it clearly consumed all of it.
 // ignore whatever it says...
 if (PVDecodeVideoFrame(
                    mHandle, &bitstream, &timestamp, &tmp,
 &useExtTimestamp,
                    outHeader->pBuffer) != PV_TRUE) {
            ALOGE(""failed to decode video frame."");

            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 // H263 doesn't have VOL header, the frame size information is in short header, i.e. the
 // decoder may detect size change after PVDecodeVideoFrame.
 if (handlePortSettingsChange()) {
 return;
 }

 // decoder deals in ms, OMX in us.
        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);
        mPvToOmxTimeMap.removeItem(timestamp);

        inHeader->nOffset += bufferSize;
        inHeader->nFilledLen = 0;
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 } else {
            outHeader->nFlags = 0;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

 ++mInputBufferCount;

        outHeader->nOffset = 0;
        outHeader->nFilledLen = frameSize;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
        outInfo->mOwnedByUs = false;
        outQueue.erase(it);
        outInfo = NULL;

        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mNumSamplesOutput;
 }
}
",188170,"void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {
 BufferInfo *inInfo = *inQueue.begin();
        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 if (inHeader == NULL) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
 continue;
 }

 PortInfo *port = editPortInfo(1);

        OMX_BUFFERHEADERTYPE *outHeader =
            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;

 if (inHeader->nFilledLen == 0) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

 ++mInputBufferCount;

 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                outHeader->nFilledLen = 0;
                outHeader->nFlags = OMX_BUFFERFLAG_EOS;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
                outInfo->mOwnedByUs = false;
                outQueue.erase(it);
                outInfo = NULL;

                notifyFillBufferDone(outHeader);
                outHeader = NULL;
 }
 return;
 }

 uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;
 uint32_t *start_code = (uint32_t *)bitstream;
 bool volHeader = *start_code == 0xB0010000;
 if (volHeader) {
 PVCleanUpVideoDecoder(mHandle);
            mInitialized = false;
 }

 if (!mInitialized) {
 uint8_t *vol_data[1];
 int32_t vol_size = 0;

            vol_data[0] = NULL;

 if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {
                vol_data[0] = bitstream;
                vol_size = inHeader->nFilledLen;
 }

            MP4DecodingMode mode =
 (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;

 Bool success = PVInitVideoDecoder(
                    mHandle, vol_data, &vol_size, 1,
                    outputBufferWidth(), outputBufferHeight(), mode);

 if (!success) {
                ALOGW(""PVInitVideoDecoder failed. Unsupported content?"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);
 if (mode != actualMode) {
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

 PVSetPostProcType((VideoDecControls *) mHandle, 0);

 bool hasFrameData = false;
 if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
                inInfo->mOwnedByUs = false;
                inQueue.erase(inQueue.begin());
                inInfo = NULL;
                notifyEmptyBufferDone(inHeader);
                inHeader = NULL;
 } else if (volHeader) {
                hasFrameData = true;
 }

            mInitialized = true;

 if (mode == MPEG4_MODE && handlePortSettingsChange()) {
 return;
 }

 if (!hasFrameData) {
 continue;
 }
 }

 if (!mFramesConfigured) {
 PortInfo *port = editPortInfo(1);
            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;


             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
                ALOGE(""Too small output buffer for reference frame: %zu bytes"",
                        outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
 return;
 }
 PVSetReferenceYUV(mHandle, outHeader->pBuffer);
            mFramesConfigured = true;
 }

 uint32_t useExtTimestamp = (inHeader->nOffset == 0);

 uint32_t timestamp = 0xFFFFFFFF;
 if (useExtTimestamp) {
            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);
            timestamp = mPvTime;
            mPvTime++;
 }

 int32_t bufferSize = inHeader->nFilledLen;
 int32_t tmp = bufferSize;

        OMX_U32 frameSize;
        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;
 if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {
            ALOGE(""Frame size too large"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
        frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));

 if (outHeader->nAllocLen < frameSize) {
            android_errorWriteLog(0x534e4554, ""27833616"");
            ALOGE(""Insufficient output buffer size"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
 if (PVDecodeVideoFrame(
                    mHandle, &bitstream, &timestamp, &tmp,
 &useExtTimestamp,
                    outHeader->pBuffer) != PV_TRUE) {
            ALOGE(""failed to decode video frame."");

            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 if (handlePortSettingsChange()) {
 return;
 }

        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);
        mPvToOmxTimeMap.removeItem(timestamp);

        inHeader->nOffset += bufferSize;
        inHeader->nFilledLen = 0;
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 } else {
            outHeader->nFlags = 0;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

 ++mInputBufferCount;

        outHeader->nOffset = 0;
        outHeader->nFilledLen = frameSize;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
        outInfo->mOwnedByUs = false;
        outQueue.erase(it);
        outInfo = NULL;

        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mNumSamplesOutput;
 }
}
","void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {
 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {
 BufferInfo *inInfo = *inQueue.begin();
        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 if (inHeader == NULL) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
 continue;
 }

 PortInfo *port = editPortInfo(1);

        OMX_BUFFERHEADERTYPE *outHeader =
            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;

 if (inHeader->nFilledLen == 0) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

 ++mInputBufferCount;

 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                outHeader->nFilledLen = 0;
                outHeader->nFlags = OMX_BUFFERFLAG_EOS;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
                outInfo->mOwnedByUs = false;
                outQueue.erase(it);
                outInfo = NULL;

                notifyFillBufferDone(outHeader);
                outHeader = NULL;
 }
 return;
 }

 uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;
 uint32_t *start_code = (uint32_t *)bitstream;
 bool volHeader = *start_code == 0xB0010000;
 if (volHeader) {
 PVCleanUpVideoDecoder(mHandle);
            mInitialized = false;
 }

 if (!mInitialized) {
 uint8_t *vol_data[1];
 int32_t vol_size = 0;

            vol_data[0] = NULL;

 if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {
                vol_data[0] = bitstream;
                vol_size = inHeader->nFilledLen;
 }

            MP4DecodingMode mode =
 (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;

 Bool success = PVInitVideoDecoder(
                    mHandle, vol_data, &vol_size, 1,
                    outputBufferWidth(), outputBufferHeight(), mode);

 if (!success) {
                ALOGW(""PVInitVideoDecoder failed. Unsupported content?"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);
 if (mode != actualMode) {
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
 return;
 }

 PVSetPostProcType((VideoDecControls *) mHandle, 0);

 bool hasFrameData = false;
 if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
                inInfo->mOwnedByUs = false;
                inQueue.erase(inQueue.begin());
                inInfo = NULL;
                notifyEmptyBufferDone(inHeader);
                inHeader = NULL;
 } else if (volHeader) {
                hasFrameData = true;
 }

            mInitialized = true;

 if (mode == MPEG4_MODE && handlePortSettingsChange()) {
 return;
 }

 if (!hasFrameData) {
 continue;
 }
 }

 if (!mFramesConfigured) {
 PortInfo *port = editPortInfo(1);
            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;


             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
                ALOGE(""Too small output buffer for reference frame: %lu bytes"",
                        (unsigned long)outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
 return;
 }
 PVSetReferenceYUV(mHandle, outHeader->pBuffer);
            mFramesConfigured = true;
 }

 uint32_t useExtTimestamp = (inHeader->nOffset == 0);

 uint32_t timestamp = 0xFFFFFFFF;
 if (useExtTimestamp) {
            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);
            timestamp = mPvTime;
            mPvTime++;
 }

 int32_t bufferSize = inHeader->nFilledLen;
 int32_t tmp = bufferSize;

        OMX_U32 frameSize;
        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;
 if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {
            ALOGE(""Frame size too large"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
        frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));

 if (outHeader->nAllocLen < frameSize) {
            android_errorWriteLog(0x534e4554, ""27833616"");
            ALOGE(""Insufficient output buffer size"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }
 if (PVDecodeVideoFrame(
                    mHandle, &bitstream, &timestamp, &tmp,
 &useExtTimestamp,
                    outHeader->pBuffer) != PV_TRUE) {
            ALOGE(""failed to decode video frame."");

            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
 return;
 }

 if (handlePortSettingsChange()) {
 return;
 }

        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);
        mPvToOmxTimeMap.removeItem(timestamp);

        inHeader->nOffset += bufferSize;
        inHeader->nFilledLen = 0;
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
 } else {
            outHeader->nFlags = 0;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

 ++mInputBufferCount;

        outHeader->nOffset = 0;
        outHeader->nFilledLen = frameSize;

 List<BufferInfo *>::iterator it = outQueue.begin();
 while ((*it)->mHeader != outHeader) {
 ++it;
 }

 BufferInfo *outInfo = *it;
        outInfo->mOwnedByUs = false;
        outQueue.erase(it);
        outInfo = NULL;

        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mNumSamplesOutput;
 }
}
","The `onQueueFilled` function in the `SoftMPEG4` class processes input and output buffers for MPEG-4 video decoding. It first checks for errors or output port settings changes before managing the input queue. If the input buffer is empty or contains an end-of-stream flag, it handles these cases accordingly. The function initializes the video decoder if necessary, processes codec configuration, and ensures output buffers are adequately sized. It decodes video frames, updates timestamps, and manages buffer ownership, ultimately notifying the system when buffers are filled or empty. Error handling is integrated throughout to ensure robustness.","The provided code manages the processing of video data for decoding MPEG-4 streams. It checks for errors and handles input and output buffers, ensuring that the system can process video frames efficiently. The code initializes the decoder when necessary, processes codec configurations, and verifies that output buffers are appropriately sized. It decodes video frames while managing timestamps and buffer ownership, notifying the system when buffers are filled or emptied. Throughout the process, it incorporates error handling to maintain stability and ensure that the decoding operation runs smoothly without interruptions.","The vulnerability in the original code stemmed from inadequate error handling and buffer management, which could lead to undefined behavior or crashes when processing video frames. Specifically, the code did not properly check the validity of buffer sizes and conditions before proceeding with operations, such as decoding frames or accessing buffer headers. The fix involved adding checks to ensure that output buffer sizes were sufficient and that the decoder was properly initialized before attempting to decode video frames. This enhanced validation prevents potential crashes and ensures that the system behaves predictably under various input conditions.","The vulnerability in the original code was related to insufficient error handling and validation of buffer conditions, which could lead to crashes or undefined behavior during video processing. This lack of checks meant that the system could attempt to operate on invalid or improperly sized buffers, resulting in potential instability. The fix involved implementing additional checks to ensure that buffers were adequately sized and that the system was in a valid state before proceeding with operations. This enhancement improved the robustness of the code, preventing issues that could arise from unexpected input or state conditions.","The vulnerability was fixed by adding critical checks for buffer sizes and initialization states before performing operations. Specifically, the code now verifies that the output buffer's allocation length is sufficient to hold the required frame size, preventing potential buffer overflows. Additionally, it ensures that the decoder is initialized before attempting to decode video frames, which mitigates the risk of accessing uninitialized resources. These changes were implemented through conditions that check the sizes of `outHeader->nAllocLen` and the initialization status, thereby enhancing the overall stability and reliability of the video processing functionality.","The vulnerability was addressed by implementing additional validation checks to ensure that buffers were appropriately sized and that the system was in a valid state before executing critical operations. This involved verifying that the output buffer had sufficient allocation length to accommodate the required data, thereby preventing potential overflows. Furthermore, the code ensured that the decoder was properly initialized before any decoding attempts, which mitigated the risk of accessing uninitialized resources. These enhancements collectively improved the robustness of the code, ensuring that it could handle various input scenarios without leading to crashes or undefined behavior.","CWE-119, CWE-120, CWE-131, CWE-789, CWE-908, CWE-825, CWE-665, CWE-457, CWE-824, CWE-20",N,-1
99,99,188178,188178,,Remote,Not required,Complete,CVE-2016-3871,https://www.cvedetails.com/cve/CVE-2016-3871/,CWE-264,Medium,Complete,Complete,,2016-09-11,9.3,"Multiple buffer overflows in codecs/mp3dec/SoftMP3.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allow attackers to gain privileges via a crafted application, aka internal bug 29422022.",2017-08-12,Overflow +Priv ,1,https://android.googlesource.com/platform/frameworks/av/+/c17ad2f0c7e00fd1bbf01d0dfed41f72d78267ad,c17ad2f0c7e00fd1bbf01d0dfed41f72d78267ad,"Fix build

Change-Id: I48ba34b3df9c9a896d4b18c3f48e41744b7dab54
",1,media/libstagefright/codecs/mp3dec/SoftMP3.cpp,"{""filename"": ""media/libstagefright/codecs/mp3dec/SoftMP3.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/c17ad2f0c7e00fd1bbf01d0dfed41f72d78267ad/media/libstagefright/codecs/mp3dec/SoftMP3.cpp"", ""patch"": ""@@ -122,7 +122,7 @@\n\n \n void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {\n     if (len > outHeader->nAllocLen) {\n-        ALOGE(\""memset buffer too small: got %lu, expected %zu\"", (unsigned long)outHeader->nAllocLen, len);\n+        ALOGE(\""memset buffer too small: got %u, expected %zu\"", outHeader->nAllocLen, len);\n         android_errorWriteLog(0x534e4554, \""29422022\"");\n         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);\n         mSignalledError = true;\n""}"," void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
        ALOGE(""memset buffer too small: got %u, expected %zu"", outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
 return NULL;
 }
 return memset(outHeader->pBuffer, c, len);
}
"," void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
        ALOGE(""memset buffer too small: got %lu, expected %zu"", (unsigned long)outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
 return NULL;
 }
 return memset(outHeader->pBuffer, c, len);
}
",C,"        ALOGE(""memset buffer too small: got %u, expected %zu"", outHeader->nAllocLen, len);
","        ALOGE(""memset buffer too small: got %lu, expected %zu"", (unsigned long)outHeader->nAllocLen, len);
",,"@@ -122,7 +122,7 @@

 
 void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
-        ALOGE(""memset buffer too small: got %lu, expected %zu"", (unsigned long)outHeader->nAllocLen, len);
+        ALOGE(""memset buffer too small: got %u, expected %zu"", outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
",Android,https://android.googlesource.com/platform/frameworks/av/+/c17ad2f0c7e00fd1bbf01d0dfed41f72d78267ad/,https://android.googlesource.com/platform/frameworks/av/+/c17ad2f0c7e00fd1bbf01d0dfed41f72d78267ad%5E/,1," void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
//flaw_line_below:
        ALOGE(""memset buffer too small: got %lu, expected %zu"", (unsigned long)outHeader->nAllocLen, len);
//fix_flaw_line_below:
//        ALOGE(""memset buffer too small: got %u, expected %zu"", outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
 return NULL;
 }
 return memset(outHeader->pBuffer, c, len);
}
",188178," void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
        ALOGE(""memset buffer too small: got %lu, expected %zu"", (unsigned long)outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
 return NULL;
 }
 return memset(outHeader->pBuffer, c, len);
}
"," void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
        ALOGE(""memset buffer too small: got %u, expected %zu"", outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
 return NULL;
 }
 return memset(outHeader->pBuffer, c, len);
}
","The `memsetSafe` function in the `SoftMP3` class is designed to safely set a specified number of bytes in a buffer, ensuring that the buffer's allocated length is sufficient for the operation. It takes an `OMX_BUFFERHEADERTYPE` pointer, a character value `c`, and a size `len` as parameters. If the requested length exceeds the buffer's allocated size (`nAllocLen`), it logs an error message, writes an error log, signals an error event, and returns `NULL`. If the buffer is adequately sized, it uses the standard `memset` function to fill the buffer with the specified character value.","The provided code defines a function that safely initializes a specified number of bytes in a memory buffer. It first checks if the requested size exceeds the buffer's allocated capacity. If it does, the function logs an error message, records an error event, and indicates that an error has occurred, returning a null pointer. If the buffer is sufficiently large, the function proceeds to fill the specified portion of the buffer with a given character value. This ensures that memory operations do not lead to buffer overflows, enhancing the robustness of the code.","The vulnerability in the original code stemmed from the potential for a buffer overflow, as it did not properly validate whether the requested length exceeded the allocated buffer size before performing the memory set operation. Specifically, if the `len` parameter was greater than `outHeader->nAllocLen`, it could lead to writing beyond the buffer's boundaries, causing undefined behavior. The fixed code addresses this issue by adding a conditional check that compares `len` to `outHeader->nAllocLen`. If the length is too large, it logs an error, signals an error event, and safely returns `NULL`, preventing any unsafe memory operations.","The vulnerability in the original code was due to a lack of proper validation for the size of the memory buffer before performing a memory initialization operation. This oversight could allow for writing beyond the allocated memory, leading to potential buffer overflows and undefined behavior. The fixed code addresses this issue by implementing a check to ensure that the requested size does not exceed the buffer's allocated length. If the size is too large, it logs an error and returns a null pointer, effectively preventing unsafe memory operations and enhancing the overall safety and stability of the code.","The vulnerability was fixed by adding a conditional check that compares the requested length, `len`, to the allocated length, `outHeader->nAllocLen`. In the updated code, if `len` exceeds `nAllocLen`, an error message is logged using `ALOGE`, and an error event is signaled with `notify`, indicating that the output buffer is too small. Additionally, the function sets a flag, `mSignalledError`, to true and returns `NULL`, preventing the unsafe execution of the `memset` function. This ensures that memory operations are only performed when it is safe to do so, thereby mitigating the risk of buffer overflows.","The vulnerability was fixed by implementing a validation step that checks whether the requested memory size exceeds the allocated buffer size before proceeding with the memory operation. If the requested size is too large, the code now logs an error message, signals an error event, and returns a null pointer, effectively preventing any unsafe memory writes. This change ensures that memory operations are only executed when it is safe to do so, thereby eliminating the risk of buffer overflows and enhancing the overall safety and stability of the code.","CWE-119, CWE-120, CWE-131, CWE-789, CWE-788, CWE-122, CWE-787, CWE-400, CWE-130, CWE-20",N,-1
100,100,188253,188253,,Remote,Not required,Complete,CVE-2016-2452,https://www.cvedetails.com/cve/CVE-2016-2452/,CWE-264,Medium,Complete,Complete,,2016-05-09,9.3,"codecs/amrnb/dec/SoftAMR.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not validate buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bugs 27662364 and 27843673.",2016-05-10,+Priv ,24,https://android.googlesource.com/platform/frameworks/av/+/65756b4082cd79a2d99b2ccb5b392291fd53703f,65756b4082cd79a2d99b2ccb5b392291fd53703f,"SoftAMR: check input buffer size to avoid overflow.

Bug: 27662364
Change-Id: I47380545ea7d85845e141e722b0d84f498d27145
",1,media/libstagefright/codecs/amrnb/dec/SoftAMR.cpp,"{""filename"": ""media/libstagefright/codecs/amrnb/dec/SoftAMR.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/65756b4082cd79a2d99b2ccb5b392291fd53703f/media/libstagefright/codecs/amrnb/dec/SoftAMR.cpp"", ""patch"": ""@@ -286,6 +286,13 @@\n\n         BufferInfo *inInfo = *inQueue.begin();\n         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n \n+        if (inHeader->nFilledLen == 0) {\n+            inInfo->mOwnedByUs = false;\n+            inQueue.erase(inQueue.begin());\n+            notifyEmptyBufferDone(inHeader);\n+            continue;\n+        }\n+\n         BufferInfo *outInfo = *outQueue.begin();\n         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n \n@@ -321,6 +328,17 @@\n\n                 return;\n             }\n \n+            int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n+            // for WMF since MIME_IETF is used when calling AMRDecode.\n+            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;\n+\n+            if (inHeader->nFilledLen < frameSize) {\n+                ALOGE(\""b/27662364: expected %zu bytes vs %u\"", frameSize, inHeader->nFilledLen);\n+                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);\n+                mSignalledError = true;\n+                return;\n+            }\n+\n             numBytesRead =\n                 AMRDecode(mState,\n                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),\n@@ -370,7 +388,12 @@\n\n             }\n \n             size_t frameSize = getFrameSize(mode);\n-            CHECK_GE(inHeader->nFilledLen, frameSize);\n+            if (inHeader->nFilledLen < frameSize) {\n+                ALOGE(\""b/27662364: expected %zu bytes vs %u\"", frameSize, inHeader->nFilledLen);\n+                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);\n+                mSignalledError = true;\n+                return;\n+            }\n \n             int16_t *outPtr = (int16_t *)outHeader->pBuffer;\n \n""}<_**next**_>{""filename"": ""media/libstagefright/codecs/amrnb/dec/src/amrdecode.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/65756b4082cd79a2d99b2ccb5b392291fd53703f/media/libstagefright/codecs/amrnb/dec/src/amrdecode.h"", ""patch"": ""@@ -104,7 +104,6 @@\n\n ; INCLUDES\n ----------------------------------------------------------------------------*/\n #include    \""typedef.h\""\n-#include    \""mode.h\""\n #include    \""frame_type_3gpp.h\""\n \n /*--------------------------------------------------------------------------*/\n""}<_**next**_>{""filename"": ""media/libstagefright/codecs/amrnb/dec/src/gsmamr_dec.h"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/65756b4082cd79a2d99b2ccb5b392291fd53703f/media/libstagefright/codecs/amrnb/dec/src/gsmamr_dec.h"", ""patch"": ""@@ -87,6 +87,7 @@\n\n \n #include \""gsm_amr_typedefs.h\""\n #include \""frame_type_3gpp.h\""\n+#include \""amrdecode.h\""\n \n /*--------------------------------------------------------------------------*/\n #ifdef __cplusplus\n@@ -136,19 +137,6 @@\n\n                          Word8 *id);\n \n     /*\n-     * AMRDecode steps into the part of the library that decodes the raw data\n-     * speech bits for the decoding process. It returns the address offset of\n-     * the next frame to be decoded.\n-     */\n-    Word16 AMRDecode(\n-        void                      *state_data,\n-        enum Frame_Type_3GPP      frame_type,\n-        UWord8                    *speech_bits_ptr,\n-        Word16                    *raw_pcm_buffer,\n-        Word16                    input_format\n-    );\n-\n-    /*\n      * This function resets the state memory used by the GSM AMR decoder. This\n      * function returns zero. It will return negative one if there is an error.\n      */\n""}","void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {
 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 while (!inQueue.empty() && !outQueue.empty()) {

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
        if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            notifyEmptyBufferDone(inHeader);
            continue;
        }

         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

            outHeader->nFilledLen = 0;
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;

            outQueue.erase(outQueue.begin());
            outInfo->mOwnedByUs = false;
            notifyFillBufferDone(outHeader);
 return;
 }

 if (inHeader->nOffset == 0) {
            mAnchorTimeUs = inHeader->nTimeStamp;
            mNumSamplesOutput = 0;
 }

 const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;
 int32_t numBytesRead;

 if (mMode == MODE_NARROW) {
 if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {
                ALOGE(""b/27662364: NB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;

                 return;
             }
 
            int16 mode = ((inputPtr[0] >> 3) & 0x0f);
            // for WMF since MIME_IETF is used when calling AMRDecode.
            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;

            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }

             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
 (UWord8 *)&inputPtr[1],
 reinterpret_cast<int16_t *>(outHeader->pBuffer),
                  MIME_IETF);

 if (numBytesRead == -1) {
                ALOGE(""PV AMR decoder AMRDecode() call failed"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }

 ++numBytesRead; // Include the frame type header byte.

 if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }
 } else {
 if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {
                ALOGE(""b/27662364: WB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;
 return;
 }

 int16 mode = ((inputPtr[0] >> 3) & 0x0f);

 if (mode >= 10 && mode <= 13) {
                ALOGE(""encountered illegal frame type %d in AMR WB content."",
                      mode);

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;

             }
 
             size_t frameSize = getFrameSize(mode);
            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }
 
             int16_t *outPtr = (int16_t *)outHeader->pBuffer;
 
 if (mode >= 9) {
                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));
 } else if (mode < 9) {
 int16 frameType;
                RX_State_wb rx_state;
                mime_unsorting(
 const_cast<uint8_t *>(&inputPtr[1]),
                        mInputSampleBuffer,
 &frameType, &mode, 1, &rx_state);

 int16_t numSamplesOutput;
                pvDecoder_AmrWb(
                        mode, mInputSampleBuffer,
                        outPtr,
 &numSamplesOutput,
                        mDecoderBuf, frameType, mDecoderCookie);

                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);

 for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {
 /* Delete the 2 LSBs (14-bit output) */
                    outPtr[i] &= 0xfffC;
 }
 }

            numBytesRead = frameSize;
 }

        inHeader->nOffset += numBytesRead;
        inHeader->nFilledLen -= numBytesRead;

        outHeader->nFlags = 0;
        outHeader->nOffset = 0;

 if (mMode == MODE_NARROW) {
            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;

            mNumSamplesOutput += kNumSamplesPerFrameNB;
 } else {
            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;

            mNumSamplesOutput += kNumSamplesPerFrameWB;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

        outInfo->mOwnedByUs = false;
        outQueue.erase(outQueue.begin());
        outInfo = NULL;
        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mInputBufferCount;
 }
}
","void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {
 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 while (!inQueue.empty() && !outQueue.empty()) {

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

            outHeader->nFilledLen = 0;
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;

            outQueue.erase(outQueue.begin());
            outInfo->mOwnedByUs = false;
            notifyFillBufferDone(outHeader);
 return;
 }

 if (inHeader->nOffset == 0) {
            mAnchorTimeUs = inHeader->nTimeStamp;
            mNumSamplesOutput = 0;
 }

 const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;
 int32_t numBytesRead;

 if (mMode == MODE_NARROW) {
 if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {
                ALOGE(""b/27662364: NB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;

                 return;
             }
 
             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
 (UWord8 *)&inputPtr[1],
 reinterpret_cast<int16_t *>(outHeader->pBuffer),
                  MIME_IETF);

 if (numBytesRead == -1) {
                ALOGE(""PV AMR decoder AMRDecode() call failed"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }

 ++numBytesRead; // Include the frame type header byte.

 if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }
 } else {
 if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {
                ALOGE(""b/27662364: WB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;
 return;
 }

 int16 mode = ((inputPtr[0] >> 3) & 0x0f);

 if (mode >= 10 && mode <= 13) {
                ALOGE(""encountered illegal frame type %d in AMR WB content."",
                      mode);

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;

             }
 
             size_t frameSize = getFrameSize(mode);
            CHECK_GE(inHeader->nFilledLen, frameSize);
 
             int16_t *outPtr = (int16_t *)outHeader->pBuffer;
 
 if (mode >= 9) {
                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));
 } else if (mode < 9) {
 int16 frameType;
                RX_State_wb rx_state;
                mime_unsorting(
 const_cast<uint8_t *>(&inputPtr[1]),
                        mInputSampleBuffer,
 &frameType, &mode, 1, &rx_state);

 int16_t numSamplesOutput;
                pvDecoder_AmrWb(
                        mode, mInputSampleBuffer,
                        outPtr,
 &numSamplesOutput,
                        mDecoderBuf, frameType, mDecoderCookie);

                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);

 for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {
 /* Delete the 2 LSBs (14-bit output) */
                    outPtr[i] &= 0xfffC;
 }
 }

            numBytesRead = frameSize;
 }

        inHeader->nOffset += numBytesRead;
        inHeader->nFilledLen -= numBytesRead;

        outHeader->nFlags = 0;
        outHeader->nOffset = 0;

 if (mMode == MODE_NARROW) {
            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;

            mNumSamplesOutput += kNumSamplesPerFrameNB;
 } else {
            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;

            mNumSamplesOutput += kNumSamplesPerFrameWB;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

        outInfo->mOwnedByUs = false;
        outQueue.erase(outQueue.begin());
        outInfo = NULL;
        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mInputBufferCount;
 }
}
",C,"        if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            notifyEmptyBufferDone(inHeader);
            continue;
        }

            int16 mode = ((inputPtr[0] >> 3) & 0x0f);
            // for WMF since MIME_IETF is used when calling AMRDecode.
            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;

            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }

            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }
","            CHECK_GE(inHeader->nFilledLen, frameSize);
",,"@@ -286,6 +286,13 @@

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
+        if (inHeader->nFilledLen == 0) {
+            inInfo->mOwnedByUs = false;
+            inQueue.erase(inQueue.begin());
+            notifyEmptyBufferDone(inHeader);
+            continue;
+        }
+
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
@@ -321,6 +328,17 @@

                 return;
             }
 
+            int16 mode = ((inputPtr[0] >> 3) & 0x0f);
+            // for WMF since MIME_IETF is used when calling AMRDecode.
+            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;
+
+            if (inHeader->nFilledLen < frameSize) {
+                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
+                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
+                mSignalledError = true;
+                return;
+            }
+
             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
@@ -370,7 +388,12 @@

             }
 
             size_t frameSize = getFrameSize(mode);
-            CHECK_GE(inHeader->nFilledLen, frameSize);
+            if (inHeader->nFilledLen < frameSize) {
+                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
+                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
+                mSignalledError = true;
+                return;
+            }
 
             int16_t *outPtr = (int16_t *)outHeader->pBuffer;
 
",Android,https://android.googlesource.com/platform/frameworks/av/+/65756b4082cd79a2d99b2ccb5b392291fd53703f/,https://android.googlesource.com/platform/frameworks/av/+/65756b4082cd79a2d99b2ccb5b392291fd53703f%5E/,1,"void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {
 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 while (!inQueue.empty() && !outQueue.empty()) {

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
//fix_flaw_line_below:
//        if (inHeader->nFilledLen == 0) {
//fix_flaw_line_below:
//            inInfo->mOwnedByUs = false;
//fix_flaw_line_below:
//            inQueue.erase(inQueue.begin());
//fix_flaw_line_below:
//            notifyEmptyBufferDone(inHeader);
//fix_flaw_line_below:
//            continue;
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

            outHeader->nFilledLen = 0;
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;

            outQueue.erase(outQueue.begin());
            outInfo->mOwnedByUs = false;
            notifyFillBufferDone(outHeader);
 return;
 }

 if (inHeader->nOffset == 0) {
            mAnchorTimeUs = inHeader->nTimeStamp;
            mNumSamplesOutput = 0;
 }

 const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;
 int32_t numBytesRead;

 if (mMode == MODE_NARROW) {
 if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {
                ALOGE(""b/27662364: NB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;

                 return;
             }
 
//fix_flaw_line_below:
//            int16 mode = ((inputPtr[0] >> 3) & 0x0f);
//fix_flaw_line_below:
//            // for WMF since MIME_IETF is used when calling AMRDecode.
//fix_flaw_line_below:
//            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//            if (inHeader->nFilledLen < frameSize) {
//fix_flaw_line_below:
//                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
//fix_flaw_line_below:
//                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
//fix_flaw_line_below:
//                mSignalledError = true;
//fix_flaw_line_below:
//                return;
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//
             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
 (UWord8 *)&inputPtr[1],
 reinterpret_cast<int16_t *>(outHeader->pBuffer),
                  MIME_IETF);

 if (numBytesRead == -1) {
                ALOGE(""PV AMR decoder AMRDecode() call failed"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }

 ++numBytesRead; // Include the frame type header byte.

 if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {
 // This is bad, should never have happened, but did. Abort now.

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }
 } else {
 if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {
                ALOGE(""b/27662364: WB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;
 return;
 }

 int16 mode = ((inputPtr[0] >> 3) & 0x0f);

 if (mode >= 10 && mode <= 13) {
                ALOGE(""encountered illegal frame type %d in AMR WB content."",
                      mode);

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;

             }
 
             size_t frameSize = getFrameSize(mode);
//flaw_line_below:
            CHECK_GE(inHeader->nFilledLen, frameSize);
//fix_flaw_line_below:
//            if (inHeader->nFilledLen < frameSize) {
//fix_flaw_line_below:
//                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
//fix_flaw_line_below:
//                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
//fix_flaw_line_below:
//                mSignalledError = true;
//fix_flaw_line_below:
//                return;
//fix_flaw_line_below:
//            }
 
             int16_t *outPtr = (int16_t *)outHeader->pBuffer;
 
 if (mode >= 9) {
 // Produce silence instead of comfort noise and for
 // speech lost/no data.
                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));
 } else if (mode < 9) {
 int16 frameType;
                RX_State_wb rx_state;
                mime_unsorting(
 const_cast<uint8_t *>(&inputPtr[1]),
                        mInputSampleBuffer,
 &frameType, &mode, 1, &rx_state);

 int16_t numSamplesOutput;
                pvDecoder_AmrWb(
                        mode, mInputSampleBuffer,
                        outPtr,
 &numSamplesOutput,
                        mDecoderBuf, frameType, mDecoderCookie);

                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);

 for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {
 /* Delete the 2 LSBs (14-bit output) */
                    outPtr[i] &= 0xfffC;
 }
 }

            numBytesRead = frameSize;
 }

        inHeader->nOffset += numBytesRead;
        inHeader->nFilledLen -= numBytesRead;

        outHeader->nFlags = 0;
        outHeader->nOffset = 0;

 if (mMode == MODE_NARROW) {
            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;

            mNumSamplesOutput += kNumSamplesPerFrameNB;
 } else {
            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;

            mNumSamplesOutput += kNumSamplesPerFrameWB;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

        outInfo->mOwnedByUs = false;
        outQueue.erase(outQueue.begin());
        outInfo = NULL;
        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mInputBufferCount;
 }
}
",188253,"void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {
 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 while (!inQueue.empty() && !outQueue.empty()) {

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

            outHeader->nFilledLen = 0;
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;

            outQueue.erase(outQueue.begin());
            outInfo->mOwnedByUs = false;
            notifyFillBufferDone(outHeader);
 return;
 }

 if (inHeader->nOffset == 0) {
            mAnchorTimeUs = inHeader->nTimeStamp;
            mNumSamplesOutput = 0;
 }

 const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;
 int32_t numBytesRead;

 if (mMode == MODE_NARROW) {
 if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {
                ALOGE(""b/27662364: NB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;

                 return;
             }
 
             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
 (UWord8 *)&inputPtr[1],
 reinterpret_cast<int16_t *>(outHeader->pBuffer),
                  MIME_IETF);

 if (numBytesRead == -1) {
                ALOGE(""PV AMR decoder AMRDecode() call failed"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }

 ++numBytesRead; // Include the frame type header byte.

 if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }
 } else {
 if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {
                ALOGE(""b/27662364: WB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;
 return;
 }

 int16 mode = ((inputPtr[0] >> 3) & 0x0f);

 if (mode >= 10 && mode <= 13) {
                ALOGE(""encountered illegal frame type %d in AMR WB content."",
                      mode);

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;

             }
 
             size_t frameSize = getFrameSize(mode);
            CHECK_GE(inHeader->nFilledLen, frameSize);
 
             int16_t *outPtr = (int16_t *)outHeader->pBuffer;
 
 if (mode >= 9) {
                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));
 } else if (mode < 9) {
 int16 frameType;
                RX_State_wb rx_state;
                mime_unsorting(
 const_cast<uint8_t *>(&inputPtr[1]),
                        mInputSampleBuffer,
 &frameType, &mode, 1, &rx_state);

 int16_t numSamplesOutput;
                pvDecoder_AmrWb(
                        mode, mInputSampleBuffer,
                        outPtr,
 &numSamplesOutput,
                        mDecoderBuf, frameType, mDecoderCookie);

                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);

 for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {
 /* Delete the 2 LSBs (14-bit output) */
                    outPtr[i] &= 0xfffC;
 }
 }

            numBytesRead = frameSize;
 }

        inHeader->nOffset += numBytesRead;
        inHeader->nFilledLen -= numBytesRead;

        outHeader->nFlags = 0;
        outHeader->nOffset = 0;

 if (mMode == MODE_NARROW) {
            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;

            mNumSamplesOutput += kNumSamplesPerFrameNB;
 } else {
            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;

            mNumSamplesOutput += kNumSamplesPerFrameWB;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

        outInfo->mOwnedByUs = false;
        outQueue.erase(outQueue.begin());
        outInfo = NULL;
        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mInputBufferCount;
 }
}
","void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {
 List<BufferInfo *> &inQueue = getPortQueue(0);
 List<BufferInfo *> &outQueue = getPortQueue(1);

 if (mSignalledError || mOutputPortSettingsChange != NONE) {
 return;
 }

 while (!inQueue.empty() && !outQueue.empty()) {

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
        if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            notifyEmptyBufferDone(inHeader);
            continue;
        }

         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
 if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
            inQueue.erase(inQueue.begin());
            inInfo->mOwnedByUs = false;
            notifyEmptyBufferDone(inHeader);

            outHeader->nFilledLen = 0;
            outHeader->nFlags = OMX_BUFFERFLAG_EOS;

            outQueue.erase(outQueue.begin());
            outInfo->mOwnedByUs = false;
            notifyFillBufferDone(outHeader);
 return;
 }

 if (inHeader->nOffset == 0) {
            mAnchorTimeUs = inHeader->nTimeStamp;
            mNumSamplesOutput = 0;
 }

 const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;
 int32_t numBytesRead;

 if (mMode == MODE_NARROW) {
 if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {
                ALOGE(""b/27662364: NB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;

                 return;
             }
 
            int16 mode = ((inputPtr[0] >> 3) & 0x0f);
            // for WMF since MIME_IETF is used when calling AMRDecode.
            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;

            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }

             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
 (UWord8 *)&inputPtr[1],
 reinterpret_cast<int16_t *>(outHeader->pBuffer),
                  MIME_IETF);

 if (numBytesRead == -1) {
                ALOGE(""PV AMR decoder AMRDecode() call failed"");

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }

 ++numBytesRead; // Include the frame type header byte.

 if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;
 }
 } else {
 if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {
                ALOGE(""b/27662364: WB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;
 return;
 }

 int16 mode = ((inputPtr[0] >> 3) & 0x0f);

 if (mode >= 10 && mode <= 13) {
                ALOGE(""encountered illegal frame type %d in AMR WB content."",
                      mode);

                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;

 return;

             }
 
             size_t frameSize = getFrameSize(mode);
            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }
 
             int16_t *outPtr = (int16_t *)outHeader->pBuffer;
 
 if (mode >= 9) {
                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));
 } else if (mode < 9) {
 int16 frameType;
                RX_State_wb rx_state;
                mime_unsorting(
 const_cast<uint8_t *>(&inputPtr[1]),
                        mInputSampleBuffer,
 &frameType, &mode, 1, &rx_state);

 int16_t numSamplesOutput;
                pvDecoder_AmrWb(
                        mode, mInputSampleBuffer,
                        outPtr,
 &numSamplesOutput,
                        mDecoderBuf, frameType, mDecoderCookie);

                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);

 for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {
 /* Delete the 2 LSBs (14-bit output) */
                    outPtr[i] &= 0xfffC;
 }
 }

            numBytesRead = frameSize;
 }

        inHeader->nOffset += numBytesRead;
        inHeader->nFilledLen -= numBytesRead;

        outHeader->nFlags = 0;
        outHeader->nOffset = 0;

 if (mMode == MODE_NARROW) {
            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;

            mNumSamplesOutput += kNumSamplesPerFrameNB;
 } else {
            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);

            outHeader->nTimeStamp =
                mAnchorTimeUs
 + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;

            mNumSamplesOutput += kNumSamplesPerFrameWB;
 }

 if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            inInfo = NULL;
            notifyEmptyBufferDone(inHeader);
            inHeader = NULL;
 }

        outInfo->mOwnedByUs = false;
        outQueue.erase(outQueue.begin());
        outInfo = NULL;
        notifyFillBufferDone(outHeader);
        outHeader = NULL;

 ++mInputBufferCount;
 }
}
","The `SoftAMR::onQueueFilled` function processes audio buffers in an AMR (Adaptive Multi-Rate) decoder, managing input and output queues for audio data. It first checks for errors or output port settings changes before entering a loop that processes available input and output buffers. If an end-of-stream (EOS) flag is detected, it handles the EOS condition by notifying that the buffer is empty. Depending on the mode (narrowband or wideband), it decodes the audio frames, ensuring that the output buffer is appropriately sized and that the frame type is valid. The function updates timestamps and manages buffer ownership, notifying when buffers are processed.","The provided code implements an audio processing function that manages the decoding of audio buffers in an Adaptive Multi-Rate decoder. It checks for errors and processes available input and output buffers in a loop. When an end-of-stream condition is detected, it appropriately handles the buffers and notifies the completion of processing. Depending on the audio mode, it decodes the audio frames while ensuring that the output buffer is correctly sized and that the frame type is valid. The function updates timestamps and manages buffer ownership, signaling when buffers have been successfully processed.","The vulnerability in the original code stemmed from insufficient checks on the size of the input buffer, which could lead to buffer overflows when decoding audio frames. Specifically, the code did not verify whether the filled length of the input buffer was adequate before attempting to read from it, potentially allowing for out-of-bounds memory access. The fix introduced additional checks to ensure that the filled length of the input buffer was greater than or equal to the expected frame size before proceeding with the decoding process. This change mitigated the risk of overflow by preventing operations on insufficiently sized buffers.","The vulnerability in the original code was due to inadequate validation of the input buffer size, which could lead to buffer overflows during audio frame decoding. This oversight allowed the program to attempt reading beyond the allocated memory if the input buffer was smaller than expected, potentially causing crashes or security issues. The fix implemented additional checks to ensure that the size of the input buffer was sufficient before any read operations were performed. By verifying that the buffer contained enough data, the risk of overflow was effectively mitigated, enhancing the overall stability and security of the code.","The vulnerability was fixed by adding checks for the `inHeader->nFilledLen` against the expected frame size before proceeding with the decoding process. Specifically, the code now verifies that `inHeader->nFilledLen` is greater than or equal to the calculated `frameSize` for both narrowband and wideband modes. If the condition is not met, an error is logged, and an appropriate notification is sent to indicate a stream corruption. This ensures that the decoder only attempts to read from the input buffer when it is guaranteed to have sufficient data, thereby preventing potential buffer overflows.","The vulnerability was addressed by implementing additional checks to validate the size of the input buffer before any read operations were performed. The code now ensures that the filled length of the input buffer is sufficient to accommodate the expected data size required for processing. If the buffer size is inadequate, an error is logged, and a notification is triggered to indicate a potential stream corruption. This proactive validation prevents the program from attempting to access memory beyond the allocated buffer, thereby mitigating the risk of buffer overflows and enhancing the overall stability and security of the application.","CWE-131,CWE-119,CWE-120,CWE-788,CWE-125,CWE-789,CWE-805,CWE-129,CWE-170,CWE-680",N,-1
