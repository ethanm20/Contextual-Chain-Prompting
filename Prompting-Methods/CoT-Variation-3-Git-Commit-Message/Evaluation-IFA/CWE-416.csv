,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,T1_Top_10_CWE_IDs,T2_Correctly_Found_CWE,T3_IFA
0,0,59950,59950,,Local,Not required,Complete,CVE-2017-16528,https://www.cvedetails.com/cve/CVE-2017-16528/,CWE-416,Low,Complete,Complete,,2017-11-03,7.2,sound/core/seq_device.c in the Linux kernel before 4.13.4 allows local users to cause a denial of service (snd_rawmidi_dev_seq_free use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device.,2018-04-06,DoS ,0,https://github.com/torvalds/linux/commit/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57,fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57,"ALSA: seq: Cancel pending autoload work at unbinding device

ALSA sequencer core has a mechanism to load the enumerated devices
automatically, and it's performed in an off-load work.  This seems
causing some race when a sequencer is removed while the pending
autoload work is running.  As syzkaller spotted, it may lead to some
use-after-free:
  BUG: KASAN: use-after-free in snd_rawmidi_dev_seq_free+0x69/0x70
  sound/core/rawmidi.c:1617
  Write of size 8 at addr ffff88006c611d90 by task kworker/2:1/567

  CPU: 2 PID: 567 Comm: kworker/2:1 Not tainted 4.13.0+ #29
  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
  Workqueue: events autoload_drivers
  Call Trace:
   __dump_stack lib/dump_stack.c:16 [inline]
   dump_stack+0x192/0x22c lib/dump_stack.c:52
   print_address_description+0x78/0x280 mm/kasan/report.c:252
   kasan_report_error mm/kasan/report.c:351 [inline]
   kasan_report+0x230/0x340 mm/kasan/report.c:409
   __asan_report_store8_noabort+0x1c/0x20 mm/kasan/report.c:435
   snd_rawmidi_dev_seq_free+0x69/0x70 sound/core/rawmidi.c:1617
   snd_seq_dev_release+0x4f/0x70 sound/core/seq_device.c:192
   device_release+0x13f/0x210 drivers/base/core.c:814
   kobject_cleanup lib/kobject.c:648 [inline]
   kobject_release lib/kobject.c:677 [inline]
   kref_put include/linux/kref.h:70 [inline]
   kobject_put+0x145/0x240 lib/kobject.c:694
   put_device+0x25/0x30 drivers/base/core.c:1799
   klist_devices_put+0x36/0x40 drivers/base/bus.c:827
   klist_next+0x264/0x4a0 lib/klist.c:403
   next_device drivers/base/bus.c:270 [inline]
   bus_for_each_dev+0x17e/0x210 drivers/base/bus.c:312
   autoload_drivers+0x3b/0x50 sound/core/seq_device.c:117
   process_one_work+0x9fb/0x1570 kernel/workqueue.c:2097
   worker_thread+0x1e4/0x1350 kernel/workqueue.c:2231
   kthread+0x324/0x3f0 kernel/kthread.c:231
   ret_from_fork+0x25/0x30 arch/x86/entry/entry_64.S:425

The fix is simply to assure canceling the autoload work at removing
the device.

Reported-by: Andrey Konovalov <andreyknvl@google.com>
Tested-by: Andrey Konovalov <andreyknvl@google.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>",0,sound/core/seq_device.c,"{""sha"": ""e40a2cba5002a817876252074c91de620c6dbce2"", ""filename"": ""sound/core/seq_device.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57/sound/core/seq_device.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57/sound/core/seq_device.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/sound/core/seq_device.c?ref=fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57"", ""patch"": ""@@ -148,8 +148,10 @@ void snd_seq_device_load_drivers(void)\n \tflush_work(&autoload_work);\n }\n EXPORT_SYMBOL(snd_seq_device_load_drivers);\n+#define cancel_autoload_drivers()\tcancel_work_sync(&autoload_work)\n #else\n #define queue_autoload_drivers() /* NOP */\n+#define cancel_autoload_drivers() /* NOP */\n #endif\n \n /*\n@@ -159,6 +161,7 @@ static int snd_seq_device_dev_free(struct snd_device *device)\n {\n \tstruct snd_seq_device *dev = device->device_data;\n \n+\tcancel_autoload_drivers();\n \tput_device(&dev->dev);\n \treturn 0;\n }""}","static int snd_seq_device_dev_disconnect(struct snd_device *device)
{
	struct snd_seq_device *dev = device->device_data;

	device_del(&dev->dev);
	return 0;
}
","static int snd_seq_device_dev_disconnect(struct snd_device *device)
{
	struct snd_seq_device *dev = device->device_data;

	device_del(&dev->dev);
	return 0;
}
",C,,,,"@@ -148,8 +148,10 @@ void snd_seq_device_load_drivers(void)
 	flush_work(&autoload_work);
 }
 EXPORT_SYMBOL(snd_seq_device_load_drivers);
+#define cancel_autoload_drivers()	cancel_work_sync(&autoload_work)
 #else
 #define queue_autoload_drivers() /* NOP */
+#define cancel_autoload_drivers() /* NOP */
 #endif
 
 /*
@@ -159,6 +161,7 @@ static int snd_seq_device_dev_free(struct snd_device *device)
 {
 	struct snd_seq_device *dev = device->device_data;
 
+	cancel_autoload_drivers();
 	put_device(&dev->dev);
 	return 0;
 }",linux,fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57,f16e666b9b7e07237ca0669df9b89ccf8dfc102c,0,"static int snd_seq_device_dev_disconnect(struct snd_device *device)
{
	struct snd_seq_device *dev = device->device_data;

	device_del(&dev->dev);
	return 0;
}
",59950,"static int snd_seq_device_dev_free(struct snd_device *device)
 {
 	struct snd_seq_device *dev = device->device_data;
 
 	put_device(&dev->dev);
 	return 0;
 }
","static int snd_seq_device_dev_disconnect(struct snd_device *device)
{
	struct snd_seq_device *dev = device->device_data;

	device_del(&dev->dev);
	return 0;
}
","The function `snd_seq_device_dev_free` is designed to free a sound device associated with the ALSA (Advanced Linux Sound Architecture) framework. It takes a pointer to a `snd_device` structure as an argument, retrieves the associated `snd_seq_device` from the `device_data` field, and then calls `put_device` on the device to decrement its reference count. This effectively releases the resources allocated for the sound device, ensuring proper memory management and preventing memory leaks. The function returns 0, indicating successful completion of the device freeing process.","The provided code defines a function that is responsible for releasing resources associated with a sound device in a sound architecture framework. It accepts a structure representing the device and retrieves the specific device data linked to it. The function then decreases the reference count of the device, which is a crucial step in managing memory and ensuring that resources are properly freed when they are no longer needed. By returning a success indicator, the function confirms that the resource release process has been completed without errors, contributing to efficient memory management within the system.","The vulnerability in the original code arises from a race condition that occurs when a sequencer device is removed while a pending autoload work is still executing. This can lead to a use-after-free error, as the device's resources may be accessed after they have been freed, resulting in potential memory corruption. The fix in the modified code addresses this issue by ensuring that the autoload work is canceled before the device is unbound, specifically by using the `device_del` function to safely remove the device and prevent any ongoing operations from accessing freed memory, thus eliminating the race condition and enhancing stability.","The vulnerability in the original code stems from a race condition that occurs when a sequencer device is removed while an automatic loading process is still pending. This situation can lead to a use-after-free error, where the system attempts to access memory that has already been released, potentially causing crashes or data corruption. The fix implemented in the updated code involves ensuring that any pending automatic loading tasks are canceled before the device is unbound. This change effectively prevents the race condition, safeguarding memory access and enhancing the overall stability of the system during device removal.","The vulnerability was fixed by introducing the `device_del` function in the updated code, which ensures that any pending autoload work is canceled before the device is unbound. This change prevents the race condition that could occur when a sequencer device is removed while the autoload process is still running. By calling `device_del`, the system safely removes the device and halts any ongoing operations that might access freed memory, thereby eliminating the potential for use-after-free errors. This proactive approach enhances memory safety and stability during the device removal process in the ALSA sequencer core.","The vulnerability was addressed by implementing a mechanism to cancel any pending automatic loading tasks before the device is unbound. This change ensures that the system does not attempt to access resources that may have already been released, thereby preventing potential race conditions and use-after-free errors. By ensuring that all ongoing operations related to the device are halted prior to its removal, the fix enhances memory safety and stability, effectively mitigating the risk of crashes or data corruption during the device unbinding process. This proactive approach significantly improves the robustness of the system.","CWE-666, CWE-364, CWE-825, CWE-415, CWE-416, CWE-667, CWE-362, CWE-404, CWE-672, CWE-665",N,-1
1,1,82760,82760,,Remote,Not required,Partial,CVE-2018-11383,https://www.cvedetails.com/cve/CVE-2018-11383/,CWE-416,Medium,,,,2018-05-22,4.3,The r_strbuf_fini() function in radare2 2.5.0 allows remote attackers to cause a denial of service (invalid free and application crash) via a crafted ELF file because of an uninitialized variable in the CPSE handler in libr/anal/p/anal_avr.c.,2018-06-27,DoS ,0,https://github.com/radare/radare2/commit/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,Fix #9943 - Invalid free on RAnal.avr,0,libr/anal/p/anal_avr.c,"{""sha"": ""93d72ce52ade371a28d0008573d07892499f4b6c"", ""filename"": ""libr/anal/p/anal_avr.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/radareorg/radare2/blob/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a/libr/anal/p/anal_avr.c"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a/libr/anal/p/anal_avr.c"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/libr/anal/p/anal_avr.c?ref=9d348bcc2c4bbd3805e7eec97b594be9febbdf9a"", ""patch"": ""@@ -619,7 +619,7 @@ INST_HANDLER (cpi) { // CPI Rd, K\n INST_HANDLER (cpse) {\t// CPSE Rd, Rr\n \tint r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);\n \tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n-\tRAnalOp next_op;\n+\tRAnalOp next_op = {0};\n \n \t// calculate next instruction size (call recursively avr_op_analyze)\n \t// and free next_op's esil string (we dont need it now)""}<_**next**_>{""sha"": ""969cf32a33d41e5c043608d5cc38f6452d52339a"", ""filename"": ""libr/core/cmd_anal.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/radareorg/radare2/blob/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a/libr/core/cmd_anal.c"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a/libr/core/cmd_anal.c"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/libr/core/cmd_anal.c?ref=9d348bcc2c4bbd3805e7eec97b594be9febbdf9a"", ""patch"": ""@@ -4350,8 +4350,9 @@ static void cmd_anal_esil(RCore *core, const char *input) {\n \t\t{\n \t\t\t// anal ESIL to REIL.\n \t\t\tRAnalEsil *esil = r_anal_esil_new (stacksize, iotrap, addrsize);\n-\t\t\tif (!esil)\n+\t\t\tif (!esil) {\n \t\t\t\treturn;\n+\t\t\t}\n \t\t\tr_anal_esil_to_reil_setup (esil, core->anal, romem, stats);\n \t\t\tr_anal_esil_set_pc (esil, core->offset);\n \t\t\tr_anal_esil_parse (esil, input + 2);""}","INST_HANDLER (sbrx) {	// SBRC Rr, b
	int b = buf[0] & 0x7;
	int r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);
	RAnalOp next_op = {0};

	avr_op_analyze (anal,
			&next_op,
			op->addr + op->size, buf + op->size, len - op->size,
			cpu);
	r_strbuf_fini (&next_op.esil);
	op->jump = op->addr + next_op.size + 2;

	op->cycles = 1;	// XXX: This is a bug, because depends on eval state,
	ESIL_A (""%d,1,<<,r%d,&,"", b, r);			// Rr(b)
	ESIL_A ((buf[1] & 0xe) == 0xc
			? ""!,""		// SBRC => branch if cleared
			: ""!,!,"");	// SBRS => branch if set
	ESIL_A (""?{,%""PFMT64d"",pc,=,},"", op->jump);	// ?true => jmp
}
","INST_HANDLER (sbrx) {	// SBRC Rr, b
	int b = buf[0] & 0x7;
	int r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);
	RAnalOp next_op = {0};

	avr_op_analyze (anal,
			&next_op,
			op->addr + op->size, buf + op->size, len - op->size,
			cpu);
	r_strbuf_fini (&next_op.esil);
	op->jump = op->addr + next_op.size + 2;

	op->cycles = 1;	// XXX: This is a bug, because depends on eval state,
	ESIL_A (""%d,1,<<,r%d,&,"", b, r);			// Rr(b)
	ESIL_A ((buf[1] & 0xe) == 0xc
			? ""!,""		// SBRC => branch if cleared
			: ""!,!,"");	// SBRS => branch if set
	ESIL_A (""?{,%""PFMT64d"",pc,=,},"", op->jump);	// ?true => jmp
}
",C,,,,"@@ -619,7 +619,7 @@ INST_HANDLER (cpi) { // CPI Rd, K
 INST_HANDLER (cpse) {	// CPSE Rd, Rr
 	int r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);
 	int d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);
-	RAnalOp next_op;
+	RAnalOp next_op = {0};
 
 	// calculate next instruction size (call recursively avr_op_analyze)
 	// and free next_op's esil string (we dont need it now)",radare2,9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,ec75785c7cfde4ec36bc3877357ba5e33d80cc31,0,"INST_HANDLER (sbrx) {	// SBRC Rr, b
			// SBRS Rr, b
	int b = buf[0] & 0x7;
	int r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);
	RAnalOp next_op = {0};

	// calculate next instruction size (call recursively avr_op_analyze)
	// and free next_op's esil string (we dont need it now)
	avr_op_analyze (anal,
			&next_op,
			op->addr + op->size, buf + op->size, len - op->size,
			cpu);
	r_strbuf_fini (&next_op.esil);
	op->jump = op->addr + next_op.size + 2;

	// cycles
	op->cycles = 1;	// XXX: This is a bug, because depends on eval state,
			// so it cannot be really be known until this
			// instruction is executed by the ESIL interpreter!!!
			// In case of evaluating to false, this instruction
			// needs 2/3 cycles, elsewhere it needs only 1 cycle.
	ESIL_A (""%d,1,<<,r%d,&,"", b, r);			// Rr(b)
	ESIL_A ((buf[1] & 0xe) == 0xc
			? ""!,""		// SBRC => branch if cleared
			: ""!,!,"");	// SBRS => branch if set
	ESIL_A (""?{,%""PFMT64d"",pc,=,},"", op->jump);	// ?true => jmp
}
",82760,"INST_HANDLER (cpse) {	// CPSE Rd, Rr
	int r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);
	int d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);
	RAnalOp next_op;

	// calculate next instruction size (call recursively avr_op_analyze)
	// and free next_op's esil string (we dont need it now)
	avr_op_analyze (anal,
			&next_op,
			op->addr + op->size, buf + op->size, len - op->size,
			cpu);
	r_strbuf_fini (&next_op.esil);
	op->jump = op->addr + next_op.size + 2;

	// cycles
	op->cycles = 1;	// XXX: This is a bug, because depends on eval state,
			// so it cannot be really be known until this
			// instruction is executed by the ESIL interpreter!!!
			// In case of evaluating to true, this instruction
			// needs 2/3 cycles, elsewhere it needs only 1 cycle.
	ESIL_A (""r%d,r%d,^,!,"", r, d);			// Rr == Rd
	ESIL_A (""?{,%""PFMT64d"",pc,=,},"", op->jump);	// ?true => jmp
}","INST_HANDLER (sbrx) {	// SBRC Rr, b
	int b = buf[0] & 0x7;
	int r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);
	RAnalOp next_op = {0};

	avr_op_analyze (anal,
			&next_op,
			op->addr + op->size, buf + op->size, len - op->size,
			cpu);
	r_strbuf_fini (&next_op.esil);
	op->jump = op->addr + next_op.size + 2;

	op->cycles = 1;	// XXX: This is a bug, because depends on eval state,
	ESIL_A (""%d,1,<<,r%d,&,"", b, r);			// Rr(b)
	ESIL_A ((buf[1] & 0xe) == 0xc
			? ""!,""		// SBRC => branch if cleared
			: ""!,!,"");	// SBRS => branch if set
	ESIL_A (""?{,%""PFMT64d"",pc,=,},"", op->jump);	// ?true => jmp
}
","The provided code defines a handler for the CPSE (Compare, Skip if Equal) instruction in an AVR microcontroller emulator. It extracts the destination and source register indices from a byte buffer, calculates the size of the next instruction by recursively analyzing it, and sets the jump address based on the outcome of the comparison. The instruction's cycle count is initialized to 1, although it notes a potential bug since the actual cycle count depends on the evaluation state during execution. Finally, it constructs an ESIL (Evaluable String Intermediate Language) representation for the instruction, which includes conditional jump logic based on the comparison result.","The code implements a handler for a specific assembly instruction that compares two registers and conditionally alters the program flow based on their equality. It extracts the relevant register indices from a byte buffer and determines the size of the subsequent instruction by analyzing it recursively. The handler sets a jump address for the next instruction based on the comparison result and initializes a cycle count, although it acknowledges a potential issue with this count being dependent on the execution state. Finally, it generates an intermediate representation that includes the logic for the conditional jump based on the comparison outcome.","The vulnerability in the original code arises from the improper handling of the `next_op` structure, particularly the lack of initialization, which could lead to undefined behavior when accessing its members. This issue is addressed in the fixed code by explicitly initializing `next_op` to zero, ensuring that all its fields are set to a known state before use. Additionally, the fixed code maintains the logic for calculating the jump address and cycle count while improving the ESIL representation for the instruction. This change prevents potential memory access violations and ensures the program behaves predictably during execution.","The vulnerability in the original code stems from the improper management of memory associated with an uninitialized structure, which could lead to undefined behavior or crashes when attempting to access or free its contents. In the revised code, this issue is resolved by ensuring that the structure is explicitly initialized to a known state before any operations are performed on it. This change prevents potential memory access violations and ensures that the program operates correctly without attempting to free invalid or uninitialized memory, thereby enhancing the overall stability and reliability of the code.","The vulnerability was fixed by initializing the `next_op` structure to zero in the revised code, which ensures that all its fields are set to a known state before being accessed. This initialization prevents undefined behavior that could occur from using uninitialized memory. Additionally, the code retains the logic for analyzing the next operation and managing the jump address, while also ensuring that the `r_strbuf_fini` function is called to properly free the ESIL string associated with `next_op`. These changes collectively enhance memory safety and prevent invalid memory access during execution.","The vulnerability was fixed by ensuring that the structure used for analyzing the next operation is explicitly initialized to zero before any operations are performed on it. This initialization guarantees that all fields within the structure have defined values, preventing potential access to uninitialized memory, which could lead to crashes or unpredictable behavior. Additionally, the code maintains proper memory management practices by ensuring that any associated resources are correctly freed after use. These changes collectively enhance the stability and reliability of the code, mitigating risks associated with invalid memory access.","CWE-457, CWE-908, CWE-665, CWE-824, CWE-788, CWE-415, CWE-758, CWE-456, CWE-467, CWE-119",N,-1
2,2,177749,177749,,Remote,Not required,Partial,CVE-2018-1000039,https://www.cvedetails.com/cve/CVE-2018-1000039/,CWE-416,Medium,Partial,Partial,,2018-05-24,6.8,"In MuPDF 1.12.0 and earlier, multiple heap use after free bugs in the PDF parser could allow an attacker to execute arbitrary code, read memory, or cause a denial of service via a crafted file.",2018-11-27,DoS Exec Code,1,http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=f597300439e62f5e921f0d7b1e880b5c1a1f1607;hp=093fc3b098dc5fadef5d8ad4b225db9fb124758b,f597300439e62f5e921f0d7b1e880b5c1a1f1607,,0,,,"add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
					/* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                        add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
                                       tree = cmap->tree;
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
","add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
					/* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                        add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
",C,"                                       tree = cmap->tree;
",,093fc3b098dc5fadef5d8ad4b225db9fb124758b,"@@ -525,6 +525,7 @@ add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high,
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                        add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
+                                       tree = cmap->tree;
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {",ghostscript,http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-cmap.c;h=00e2afb72bab07def6ddece70db56c15cee241b9;hb=f597300439e62f5e921f0d7b1e880b5c1a1f1607,http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-cmap.c;h=29d9c50693d0fb6ac35437e3997f713af729111f;hb=093fc3b098dc5fadef5d8ad4b225db9fb124758b,1,"add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
					/* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                        add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
//fix_flaw_line_below:
//                                       tree = cmap->tree;
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
",177749,"add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
					/* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                        add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
","add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
					/* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                        add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
                                       tree = cmap->tree;
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
","The `add_range` function manages a range of values within a splay tree structure associated with a `pdf_cmap` object. It takes parameters for the context, the cmap, the low and high bounds of the range, an output value, and flags for overlap checking and multiple entries. The function first validates the range limits and then traverses the tree to check for overlaps with existing nodes, adjusting or merging them as necessary. If no overlaps are found, it adds the new range to the tree, resizing it if needed, and updates the tree structure accordingly, ensuring efficient management of the range data.","The provided code manages the insertion of a range of values into a splay tree structure associated with a mapping object. It first checks if the specified range is valid and then traverses the tree to identify any overlaps with existing ranges. If overlaps are detected, it adjusts or merges the existing ranges accordingly. If no overlaps are found, it adds the new range to the tree, resizing the tree if necessary. The function ensures that the tree remains balanced and efficiently organized, facilitating quick access and modification of the range data.","The vulnerability in the original code arises from improper handling of overlapping ranges during the insertion process, which could lead to incorrect updates or deletions of nodes in the splay tree. Specifically, when a new range overlaps with an existing range, the code may not correctly adjust the boundaries or merge the ranges, potentially causing data corruption or unexpected behavior. The fix involves adding checks to ensure that when overlaps are detected, the existing nodes are properly adjusted or merged, particularly in the conditions where the current node's boundaries are modified. This ensures that the tree maintains its integrity and that all ranges are accurately represented.","The vulnerability in the original code stems from inadequate handling of overlapping ranges during the insertion process, which could lead to incorrect updates or deletions of nodes in the data structure. This oversight might result in data corruption or unexpected behavior when multiple ranges interact. The fix addresses this issue by implementing additional checks to ensure that when overlaps are detected, the existing ranges are correctly adjusted or merged. This enhancement guarantees that the integrity of the data structure is maintained, allowing for accurate representation and management of all ranges without unintended consequences.","The vulnerability was fixed by enhancing the overlap handling logic within the insertion process. Specifically, the code now includes checks for various overlap cases, such as when the new range's low and high values intersect with existing nodes. For instance, when an overlap is detected, the code adjusts the existing node's boundaries and merges ranges as needed, using conditions that modify the `low`, `high`, and `out` values of the affected nodes. Additionally, the function ensures that if a node becomes invalid after an adjustment, it is removed using the `delete_node` function, thereby maintaining the integrity of the data structure.","The vulnerability was fixed by implementing a more robust mechanism for handling overlapping ranges during the insertion process. The updated code introduces additional checks to identify various overlap scenarios, allowing for proper adjustments to existing ranges. When overlaps are detected, the code modifies the boundaries of the affected ranges and merges them as necessary, ensuring that no data is lost or corrupted. Furthermore, if an existing range becomes invalid due to these adjustments, it is removed from the structure, thereby preserving the overall integrity and accuracy of the data representation.","CWE-665, CWE-416, CWE-123, CWE-476, CWE-457, CWE-415, CWE-761, CWE-763, CWE-404, CWE-762",N,-1
3,3,177751,177751,,Remote,Not required,Partial,CVE-2018-1000039,https://www.cvedetails.com/cve/CVE-2018-1000039/,CWE-416,Medium,Partial,Partial,,2018-05-24,6.8,"In MuPDF 1.12.0 and earlier, multiple heap use after free bugs in the PDF parser could allow an attacker to execute arbitrary code, read memory, or cause a denial of service via a crafted file.",2018-11-27,DoS Exec Code,1,http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=71ceebcf56e682504da22c4035b39a2d451e8ffd;hp=7f82c01523505052615492f8e220f4348ba46995,71ceebcf56e682504da22c4035b39a2d451e8ffd,,1,,,"add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
                                        /* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
","add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
                                        /* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, many);
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
",C,"                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
","                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, many);
",7f82c01523505052615492f8e220f4348ba46995,"@@ -520,7 +520,7 @@ add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high,
                                        /* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
-                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, many);
+                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {",ghostscript,http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-cmap.c;h=bedc13045aa0566e40cc1b4179e108f961d28ff6;hb=71ceebcf56e682504da22c4035b39a2d451e8ffd,http://git.ghostscript.com/?p=mupdf.git;a=blob;f=source/pdf/pdf-cmap.c;h=ade72c443be3388fe522c55ea1105fbd8a7c1735;hb=7f82c01523505052615492f8e220f4348ba46995,1,"add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
                                        /* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
//flaw_line_below:
                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, many);
//fix_flaw_line_below:
//                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
",177751,"add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
                                        /* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, many);
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
","add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
                                        /* case 3, reduces to case 5 */
                                        int new_high = tree[current].high;
                                        tree[current].high = low-1;
                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
                                }
                                /* Now look for where to move to next (left for case 0, right for case 5) */
                                if (tree[current].low > high) {
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}
","The `add_range` function manages the insertion of a range of values into a splay tree structure associated with a character map (`cmap`). It first checks if the provided range is valid and then traverses the tree to identify potential overlaps with existing ranges, adjusting them as necessary. If overlaps are detected, it modifies the existing nodes or merges them accordingly. If the tree's capacity is reached, it dynamically resizes the tree. Finally, it adds the new range as a node, updating parent-child relationships and ensuring the tree remains balanced, while also providing debugging options to check or dump the tree structure.","The code implements a function that manages the insertion of a specified range of values into a tree structure associated with a character mapping. It first validates the range and checks for overlaps with existing ranges, adjusting or merging them as needed. If overlaps are found, it modifies the existing entries to accommodate the new range. The function also handles dynamic resizing of the tree when necessary and ensures that the new range is added correctly while maintaining the tree's balance. Additionally, it includes options for debugging the tree structure during the process.","The vulnerability in the original code arises from improper handling of overlapping ranges during the insertion process, which could lead to incorrect modifications of existing nodes and potential memory corruption. Specifically, when a new range overlaps with an existing one, the code may incorrectly adjust the boundaries of the existing nodes without adequately checking their validity, leading to inconsistencies. The fix addresses this by ensuring that when overlaps are detected, the code carefully adjusts the existing nodes' boundaries and properly manages the merging of ranges, thereby maintaining the integrity of the tree structure and preventing memory-related issues.","The vulnerability in the original code stems from inadequate handling of overlapping ranges during the insertion process, which could lead to incorrect adjustments of existing nodes and potential memory corruption. Specifically, when a new range overlaps with an existing one, the code may modify the boundaries of those nodes without sufficient validation, resulting in inconsistencies within the data structure. The fix addresses this issue by implementing more rigorous checks for overlaps, ensuring that existing nodes are adjusted correctly and safely merged when necessary, thereby preserving the integrity of the data structure and preventing memory-related errors.","The vulnerability was fixed by enhancing the overlap detection and handling logic within the insertion process. Specifically, the code now includes additional checks to ensure that when an overlap is detected, the boundaries of existing nodes are adjusted correctly. For instance, when the condition checks for overlaps, the code modifies the `low` and `high` values of existing nodes and ensures that the `out` values are updated appropriately. Furthermore, the merging logic was refined to ensure that if two adjacent nodes can be merged, they are combined correctly, preventing inconsistencies and maintaining the integrity of the tree structure.","The vulnerability was fixed by implementing more robust checks for overlapping ranges during the insertion process. The updated code ensures that when overlaps are detected, the existing nodes are adjusted with careful validation of their boundaries, preventing any invalid states. Additionally, the merging logic was refined to combine adjacent ranges correctly, ensuring that the data structure remains consistent and free from corruption. This approach not only addresses the immediate issue of incorrect modifications but also enhances the overall integrity and stability of the data management process within the structure.","CWE-123, CWE-119, CWE-787, CWE-416, CWE-125, CWE-789, CWE-190, CWE-762, CWE-131, CWE-404",N,-1
4,4,177867,177867,,Remote,Not required,Partial,CVE-2018-16541,https://www.cvedetails.com/cve/CVE-2018-16541/,CWE-416,Medium,,,,2018-09-05,4.3,"In Artifex Ghostscript before 9.24, attackers able to supply crafted PostScript files could use incorrect free logic in pagedevice replacement to crash the interpreter.",2018-12-18,,10,http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=241d91112771a6104de10b3948c3f350d6690c1d,241d91112771a6104de10b3948c3f350d6690c1d,,0,,,"gs_main_finit(gs_main_instance * minst, int exit_status, int code)
{
    i_ctx_t *i_ctx_p = minst->i_ctx_p;
    gs_dual_memory_t dmem = {0};
    int exit_code;
    ref error_object;
    char *tempnames;

    /* NB: need to free gs_name_table
     */

    /*
     * Previous versions of this code closed the devices in the
     * device list here.  Since these devices are now prototypes,
     * they cannot be opened, so they do not need to be closed;
     * alloc_restore_all will close dynamically allocated devices.
     */
    tempnames = gs_main_tempnames(minst);

    /* by the time we get here, we *must* avoid any random redefinitions of
     * operators etc, so we push systemdict onto the top of the dict stack.
     * We do this in C to avoid running into any other re-defininitions in the
     * Postscript world.
     */
    gs_finit_push_systemdict(i_ctx_p);

    /* We have to disable BGPrint before we call interp_reclaim() to prevent the
     * parent rendering thread initialising for the next page, whilst we are
     * removing objects it may want to access - for example, the I/O device table.
     * We also have to mess with the BeginPage/EndPage procs so that we don't
     * trigger a spurious extra page to be emitted.
     */
    if (minst->init_done >= 2) {
        gs_main_run_string(minst,
            ""/BGPrint /GetDeviceParam .special_op \
            {{ <</BeginPage {pop} /EndPage {pop pop //false } \
              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \
              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \
              .systemvar exec"",
            0 , &exit_code, &error_object);
    }

    /*
     * Close the ""main"" device, because it may need to write out
     * data before destruction. pdfwrite needs so.
     */
    if (minst->init_done >= 2) {
        int code = 0;

        if (idmemory->reclaim != 0) {
            code = interp_reclaim(&minst->i_ctx_p, avm_global);

            if (code < 0) {
                ref error_name;
                if (tempnames)
                    free(tempnames);

                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf2(imemory, ""ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\n"", err_str, code);
                }
                else {
                    emprintf1(imemory, ""UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\n"", code);
                }
#ifdef MEMENTO_SQUEEZE_BUILD
                if (code != gs_error_VMerror ) return gs_error_Fatal;
#else
                return gs_error_Fatal;
#endif
            }
             i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */
         }
 
        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL &&
            gx_device_is_null(i_ctx_p->pgs->device)) {
            /* if the job replaced the device with the nulldevice, we we need to grestore
               away that device, so the block below can properly dispense
               with the default device.
             */
            int code = gs_grestoreall(i_ctx_p->pgs);
            if (code < 0) return_error(gs_error_Fatal);
        }

         if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {
             gx_device *pdev = i_ctx_p->pgs->device;
             const char * dname = pdev->dname;
            if (code < 0) {
                ref error_name;
                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf3(imemory, ""ERROR: %s (%d) on closing %s device.\n"", err_str, code, dname);
                }
                else {
                    emprintf2(imemory, ""UNKNOWN ERROR %d closing %s device.\n"", code, dname);
               }
            }
            rc_decrement(pdev, ""gs_main_finit"");                /* device might be freed */
            if (exit_status == 0 || exit_status == gs_error_Quit)
                exit_status = code;
        }

      /* Flush stdout and stderr */
      gs_main_run_string(minst,
        ""(%stdout) (w) file closefile (%stderr) (w) file closefile \
        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \
          systemdict /savedinitialgstate .forceundef"",
        0 , &exit_code, &error_object);
    }
    gp_readline_finit(minst->readline_data);
    i_ctx_p = minst->i_ctx_p;		/* get current interp context */
    if (gs_debug_c(':')) {
        print_resource_usage(minst, &gs_imemory, ""Final"");
        dmprintf1(minst->heap, ""%% Exiting instance 0x%p\n"", minst);
    }
    /* Do the equivalent of a restore ""past the bottom"". */
    /* This will release all memory, close all open files, etc. */
    if (minst->init_done >= 1) {
        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;
        i_plugin_holder *h = i_ctx_p->plugin_list;

        dmem = *idmemory;
        code = alloc_restore_all(i_ctx_p);
        if (code < 0)
            emprintf1(mem_raw,
                      ""ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\n"",
                      code);
        i_iodev_finit(&dmem);
        i_plugin_finit(mem_raw, h);
    }

    /* clean up redirected stdout */
    if (minst->heap->gs_lib_ctx->fstdout2
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstdout)
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstderr)) {
        fclose(minst->heap->gs_lib_ctx->fstdout2);
        minst->heap->gs_lib_ctx->fstdout2 = (FILE *)NULL;
    }

    minst->heap->gs_lib_ctx->stdout_is_redirected = 0;
    minst->heap->gs_lib_ctx->stdout_to_stderr = 0;
    /* remove any temporary files, after ghostscript has closed files */
    if (tempnames) {
        char *p = tempnames;
        while (*p) {
            unlink(p);
            p += strlen(p) + 1;
        }
        free(tempnames);
    }
    gs_lib_finit(exit_status, code, minst->heap);

    gs_free_object(minst->heap, minst->lib_path.container.value.refs, ""lib_path array"");
    ialloc_finit(&dmem);
    return exit_status;
}
","gs_main_finit(gs_main_instance * minst, int exit_status, int code)
{
    i_ctx_t *i_ctx_p = minst->i_ctx_p;
    gs_dual_memory_t dmem = {0};
    int exit_code;
    ref error_object;
    char *tempnames;

    /* NB: need to free gs_name_table
     */

    /*
     * Previous versions of this code closed the devices in the
     * device list here.  Since these devices are now prototypes,
     * they cannot be opened, so they do not need to be closed;
     * alloc_restore_all will close dynamically allocated devices.
     */
    tempnames = gs_main_tempnames(minst);

    /* by the time we get here, we *must* avoid any random redefinitions of
     * operators etc, so we push systemdict onto the top of the dict stack.
     * We do this in C to avoid running into any other re-defininitions in the
     * Postscript world.
     */
    gs_finit_push_systemdict(i_ctx_p);

    /* We have to disable BGPrint before we call interp_reclaim() to prevent the
     * parent rendering thread initialising for the next page, whilst we are
     * removing objects it may want to access - for example, the I/O device table.
     * We also have to mess with the BeginPage/EndPage procs so that we don't
     * trigger a spurious extra page to be emitted.
     */
    if (minst->init_done >= 2) {
        gs_main_run_string(minst,
            ""/BGPrint /GetDeviceParam .special_op \
            {{ <</BeginPage {pop} /EndPage {pop pop //false } \
              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \
              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \
              .systemvar exec"",
            0 , &exit_code, &error_object);
    }

    /*
     * Close the ""main"" device, because it may need to write out
     * data before destruction. pdfwrite needs so.
     */
    if (minst->init_done >= 2) {
        int code = 0;

        if (idmemory->reclaim != 0) {
            code = interp_reclaim(&minst->i_ctx_p, avm_global);

            if (code < 0) {
                ref error_name;
                if (tempnames)
                    free(tempnames);

                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf2(imemory, ""ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\n"", err_str, code);
                }
                else {
                    emprintf1(imemory, ""UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\n"", code);
                }
#ifdef MEMENTO_SQUEEZE_BUILD
                if (code != gs_error_VMerror ) return gs_error_Fatal;
#else
                return gs_error_Fatal;
#endif
            }
             i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */
         }
 
         if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {
             gx_device *pdev = i_ctx_p->pgs->device;
             const char * dname = pdev->dname;
            if (code < 0) {
                ref error_name;
                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf3(imemory, ""ERROR: %s (%d) on closing %s device.\n"", err_str, code, dname);
                }
                else {
                    emprintf2(imemory, ""UNKNOWN ERROR %d closing %s device.\n"", code, dname);
               }
            }
            rc_decrement(pdev, ""gs_main_finit"");                /* device might be freed */
            if (exit_status == 0 || exit_status == gs_error_Quit)
                exit_status = code;
        }

      /* Flush stdout and stderr */
      gs_main_run_string(minst,
        ""(%stdout) (w) file closefile (%stderr) (w) file closefile \
        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \
          systemdict /savedinitialgstate .forceundef"",
        0 , &exit_code, &error_object);
    }
    gp_readline_finit(minst->readline_data);
    i_ctx_p = minst->i_ctx_p;		/* get current interp context */
    if (gs_debug_c(':')) {
        print_resource_usage(minst, &gs_imemory, ""Final"");
        dmprintf1(minst->heap, ""%% Exiting instance 0x%p\n"", minst);
    }
    /* Do the equivalent of a restore ""past the bottom"". */
    /* This will release all memory, close all open files, etc. */
    if (minst->init_done >= 1) {
        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;
        i_plugin_holder *h = i_ctx_p->plugin_list;

        dmem = *idmemory;
        code = alloc_restore_all(i_ctx_p);
        if (code < 0)
            emprintf1(mem_raw,
                      ""ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\n"",
                      code);
        i_iodev_finit(&dmem);
        i_plugin_finit(mem_raw, h);
    }

    /* clean up redirected stdout */
    if (minst->heap->gs_lib_ctx->fstdout2
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstdout)
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstderr)) {
        fclose(minst->heap->gs_lib_ctx->fstdout2);
        minst->heap->gs_lib_ctx->fstdout2 = (FILE *)NULL;
    }

    minst->heap->gs_lib_ctx->stdout_is_redirected = 0;
    minst->heap->gs_lib_ctx->stdout_to_stderr = 0;
    /* remove any temporary files, after ghostscript has closed files */
    if (tempnames) {
        char *p = tempnames;
        while (*p) {
            unlink(p);
            p += strlen(p) + 1;
        }
        free(tempnames);
    }
    gs_lib_finit(exit_status, code, minst->heap);

    gs_free_object(minst->heap, minst->lib_path.container.value.refs, ""lib_path array"");
    ialloc_finit(&dmem);
    return exit_status;
}
",C,"        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL &&
            gx_device_is_null(i_ctx_p->pgs->device)) {
            /* if the job replaced the device with the nulldevice, we we need to grestore
               away that device, so the block below can properly dispense
               with the default device.
             */
            int code = gs_grestoreall(i_ctx_p->pgs);
            if (code < 0) return_error(gs_error_Fatal);
        }

",,c432131c3fdb2143e148e8ba88555f7f7a63b25e,"@@ -936,6 +936,16 @@ gs_main_finit(gs_main_instance * minst, int exit_status, int code)
             i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */
         }
 
+        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL &&
+            gx_device_is_null(i_ctx_p->pgs->device)) {
+            /* if the job replaced the device with the nulldevice, we we need to grestore
+               away that device, so the block below can properly dispense
+               with the default device.
+             */
+            int code = gs_grestoreall(i_ctx_p->pgs);
+            if (code < 0) return_error(gs_error_Fatal);
+        }
+
         if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {
             gx_device *pdev = i_ctx_p->pgs->device;
             const char * dname = pdev->dname;",ghostscript,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/imain.c;h=138bfc82b0accdad0772ad82bcf8fce51eba782d;hb=138bfc82b0accdad0772ad82bcf8fce51eba782d,http://git.ghostscript.com/?p=ghostpdl.git;a=blob;f=psi/imain.c;h=2fe15465ebadc9f0219c25e7a47faf51f94f226f;hb=2fe15465ebadc9f0219c25e7a47faf51f94f226f,1,"gs_main_finit(gs_main_instance * minst, int exit_status, int code)
{
    i_ctx_t *i_ctx_p = minst->i_ctx_p;
    gs_dual_memory_t dmem = {0};
    int exit_code;
    ref error_object;
    char *tempnames;

    /* NB: need to free gs_name_table
     */

    /*
     * Previous versions of this code closed the devices in the
     * device list here.  Since these devices are now prototypes,
     * they cannot be opened, so they do not need to be closed;
     * alloc_restore_all will close dynamically allocated devices.
     */
    tempnames = gs_main_tempnames(minst);

    /* by the time we get here, we *must* avoid any random redefinitions of
     * operators etc, so we push systemdict onto the top of the dict stack.
     * We do this in C to avoid running into any other re-defininitions in the
     * Postscript world.
     */
    gs_finit_push_systemdict(i_ctx_p);

    /* We have to disable BGPrint before we call interp_reclaim() to prevent the
     * parent rendering thread initialising for the next page, whilst we are
     * removing objects it may want to access - for example, the I/O device table.
     * We also have to mess with the BeginPage/EndPage procs so that we don't
     * trigger a spurious extra page to be emitted.
     */
    if (minst->init_done >= 2) {
        gs_main_run_string(minst,
            ""/BGPrint /GetDeviceParam .special_op \
            {{ <</BeginPage {pop} /EndPage {pop pop //false } \
              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \
              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \
              .systemvar exec"",
            0 , &exit_code, &error_object);
    }

    /*
     * Close the ""main"" device, because it may need to write out
     * data before destruction. pdfwrite needs so.
     */
    if (minst->init_done >= 2) {
        int code = 0;

        if (idmemory->reclaim != 0) {
            code = interp_reclaim(&minst->i_ctx_p, avm_global);

            if (code < 0) {
                ref error_name;
                if (tempnames)
                    free(tempnames);

                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf2(imemory, ""ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\n"", err_str, code);
                }
                else {
                    emprintf1(imemory, ""UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\n"", code);
                }
#ifdef MEMENTO_SQUEEZE_BUILD
                if (code != gs_error_VMerror ) return gs_error_Fatal;
#else
                return gs_error_Fatal;
#endif
            }
             i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */
         }
 
//fix_flaw_line_below:
//        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL &&
//fix_flaw_line_below:
//            gx_device_is_null(i_ctx_p->pgs->device)) {
//fix_flaw_line_below:
//            /* if the job replaced the device with the nulldevice, we we need to grestore
//fix_flaw_line_below:
//               away that device, so the block below can properly dispense
//fix_flaw_line_below:
//               with the default device.
//fix_flaw_line_below:
//             */
//fix_flaw_line_below:
//            int code = gs_grestoreall(i_ctx_p->pgs);
//fix_flaw_line_below:
//            if (code < 0) return_error(gs_error_Fatal);
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//
         if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {
             gx_device *pdev = i_ctx_p->pgs->device;
             const char * dname = pdev->dname;
            if (code < 0) {
                ref error_name;
                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf3(imemory, ""ERROR: %s (%d) on closing %s device.\n"", err_str, code, dname);
                }
                else {
                    emprintf2(imemory, ""UNKNOWN ERROR %d closing %s device.\n"", code, dname);
               }
            }
            rc_decrement(pdev, ""gs_main_finit"");                /* device might be freed */
            if (exit_status == 0 || exit_status == gs_error_Quit)
                exit_status = code;
        }

      /* Flush stdout and stderr */
      gs_main_run_string(minst,
        ""(%stdout) (w) file closefile (%stderr) (w) file closefile \
        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \
          systemdict /savedinitialgstate .forceundef"",
        0 , &exit_code, &error_object);
    }
    gp_readline_finit(minst->readline_data);
    i_ctx_p = minst->i_ctx_p;		/* get current interp context */
    if (gs_debug_c(':')) {
        print_resource_usage(minst, &gs_imemory, ""Final"");
        dmprintf1(minst->heap, ""%% Exiting instance 0x%p\n"", minst);
    }
    /* Do the equivalent of a restore ""past the bottom"". */
    /* This will release all memory, close all open files, etc. */
    if (minst->init_done >= 1) {
        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;
        i_plugin_holder *h = i_ctx_p->plugin_list;

        dmem = *idmemory;
        code = alloc_restore_all(i_ctx_p);
        if (code < 0)
            emprintf1(mem_raw,
                      ""ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\n"",
                      code);
        i_iodev_finit(&dmem);
        i_plugin_finit(mem_raw, h);
    }

    /* clean up redirected stdout */
    if (minst->heap->gs_lib_ctx->fstdout2
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstdout)
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstderr)) {
        fclose(minst->heap->gs_lib_ctx->fstdout2);
        minst->heap->gs_lib_ctx->fstdout2 = (FILE *)NULL;
    }

    minst->heap->gs_lib_ctx->stdout_is_redirected = 0;
    minst->heap->gs_lib_ctx->stdout_to_stderr = 0;
    /* remove any temporary files, after ghostscript has closed files */
    if (tempnames) {
        char *p = tempnames;
        while (*p) {
            unlink(p);
            p += strlen(p) + 1;
        }
        free(tempnames);
    }
    gs_lib_finit(exit_status, code, minst->heap);

    gs_free_object(minst->heap, minst->lib_path.container.value.refs, ""lib_path array"");
    ialloc_finit(&dmem);
    return exit_status;
}
",177867,"gs_main_finit(gs_main_instance * minst, int exit_status, int code)
{
    i_ctx_t *i_ctx_p = minst->i_ctx_p;
    gs_dual_memory_t dmem = {0};
    int exit_code;
    ref error_object;
    char *tempnames;

    /* NB: need to free gs_name_table
     */

    /*
     * Previous versions of this code closed the devices in the
     * device list here.  Since these devices are now prototypes,
     * they cannot be opened, so they do not need to be closed;
     * alloc_restore_all will close dynamically allocated devices.
     */
    tempnames = gs_main_tempnames(minst);

    /* by the time we get here, we *must* avoid any random redefinitions of
     * operators etc, so we push systemdict onto the top of the dict stack.
     * We do this in C to avoid running into any other re-defininitions in the
     * Postscript world.
     */
    gs_finit_push_systemdict(i_ctx_p);

    /* We have to disable BGPrint before we call interp_reclaim() to prevent the
     * parent rendering thread initialising for the next page, whilst we are
     * removing objects it may want to access - for example, the I/O device table.
     * We also have to mess with the BeginPage/EndPage procs so that we don't
     * trigger a spurious extra page to be emitted.
     */
    if (minst->init_done >= 2) {
        gs_main_run_string(minst,
            ""/BGPrint /GetDeviceParam .special_op \
            {{ <</BeginPage {pop} /EndPage {pop pop //false } \
              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \
              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \
              .systemvar exec"",
            0 , &exit_code, &error_object);
    }

    /*
     * Close the ""main"" device, because it may need to write out
     * data before destruction. pdfwrite needs so.
     */
    if (minst->init_done >= 2) {
        int code = 0;

        if (idmemory->reclaim != 0) {
            code = interp_reclaim(&minst->i_ctx_p, avm_global);

            if (code < 0) {
                ref error_name;
                if (tempnames)
                    free(tempnames);

                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf2(imemory, ""ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\n"", err_str, code);
                }
                else {
                    emprintf1(imemory, ""UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\n"", code);
                }
#ifdef MEMENTO_SQUEEZE_BUILD
                if (code != gs_error_VMerror ) return gs_error_Fatal;
#else
                return gs_error_Fatal;
#endif
            }
             i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */
         }
 
         if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {
             gx_device *pdev = i_ctx_p->pgs->device;
             const char * dname = pdev->dname;
            if (code < 0) {
                ref error_name;
                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf3(imemory, ""ERROR: %s (%d) on closing %s device.\n"", err_str, code, dname);
                }
                else {
                    emprintf2(imemory, ""UNKNOWN ERROR %d closing %s device.\n"", code, dname);
               }
            }
            rc_decrement(pdev, ""gs_main_finit"");                /* device might be freed */
            if (exit_status == 0 || exit_status == gs_error_Quit)
                exit_status = code;
        }

      /* Flush stdout and stderr */
      gs_main_run_string(minst,
        ""(%stdout) (w) file closefile (%stderr) (w) file closefile \
        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \
          systemdict /savedinitialgstate .forceundef"",
        0 , &exit_code, &error_object);
    }
    gp_readline_finit(minst->readline_data);
    i_ctx_p = minst->i_ctx_p;		/* get current interp context */
    if (gs_debug_c(':')) {
        print_resource_usage(minst, &gs_imemory, ""Final"");
        dmprintf1(minst->heap, ""%% Exiting instance 0x%p\n"", minst);
    }
    /* Do the equivalent of a restore ""past the bottom"". */
    /* This will release all memory, close all open files, etc. */
    if (minst->init_done >= 1) {
        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;
        i_plugin_holder *h = i_ctx_p->plugin_list;

        dmem = *idmemory;
        code = alloc_restore_all(i_ctx_p);
        if (code < 0)
            emprintf1(mem_raw,
                      ""ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\n"",
                      code);
        i_iodev_finit(&dmem);
        i_plugin_finit(mem_raw, h);
    }

    /* clean up redirected stdout */
    if (minst->heap->gs_lib_ctx->fstdout2
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstdout)
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstderr)) {
        fclose(minst->heap->gs_lib_ctx->fstdout2);
        minst->heap->gs_lib_ctx->fstdout2 = (FILE *)NULL;
    }

    minst->heap->gs_lib_ctx->stdout_is_redirected = 0;
    minst->heap->gs_lib_ctx->stdout_to_stderr = 0;
    /* remove any temporary files, after ghostscript has closed files */
    if (tempnames) {
        char *p = tempnames;
        while (*p) {
            unlink(p);
            p += strlen(p) + 1;
        }
        free(tempnames);
    }
    gs_lib_finit(exit_status, code, minst->heap);

    gs_free_object(minst->heap, minst->lib_path.container.value.refs, ""lib_path array"");
    ialloc_finit(&dmem);
    return exit_status;
}
","gs_main_finit(gs_main_instance * minst, int exit_status, int code)
{
    i_ctx_t *i_ctx_p = minst->i_ctx_p;
    gs_dual_memory_t dmem = {0};
    int exit_code;
    ref error_object;
    char *tempnames;

    /* NB: need to free gs_name_table
     */

    /*
     * Previous versions of this code closed the devices in the
     * device list here.  Since these devices are now prototypes,
     * they cannot be opened, so they do not need to be closed;
     * alloc_restore_all will close dynamically allocated devices.
     */
    tempnames = gs_main_tempnames(minst);

    /* by the time we get here, we *must* avoid any random redefinitions of
     * operators etc, so we push systemdict onto the top of the dict stack.
     * We do this in C to avoid running into any other re-defininitions in the
     * Postscript world.
     */
    gs_finit_push_systemdict(i_ctx_p);

    /* We have to disable BGPrint before we call interp_reclaim() to prevent the
     * parent rendering thread initialising for the next page, whilst we are
     * removing objects it may want to access - for example, the I/O device table.
     * We also have to mess with the BeginPage/EndPage procs so that we don't
     * trigger a spurious extra page to be emitted.
     */
    if (minst->init_done >= 2) {
        gs_main_run_string(minst,
            ""/BGPrint /GetDeviceParam .special_op \
            {{ <</BeginPage {pop} /EndPage {pop pop //false } \
              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \
              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \
              .systemvar exec"",
            0 , &exit_code, &error_object);
    }

    /*
     * Close the ""main"" device, because it may need to write out
     * data before destruction. pdfwrite needs so.
     */
    if (minst->init_done >= 2) {
        int code = 0;

        if (idmemory->reclaim != 0) {
            code = interp_reclaim(&minst->i_ctx_p, avm_global);

            if (code < 0) {
                ref error_name;
                if (tempnames)
                    free(tempnames);

                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf2(imemory, ""ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\n"", err_str, code);
                }
                else {
                    emprintf1(imemory, ""UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\n"", code);
                }
#ifdef MEMENTO_SQUEEZE_BUILD
                if (code != gs_error_VMerror ) return gs_error_Fatal;
#else
                return gs_error_Fatal;
#endif
            }
             i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */
         }
 
        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL &&
            gx_device_is_null(i_ctx_p->pgs->device)) {
            /* if the job replaced the device with the nulldevice, we we need to grestore
               away that device, so the block below can properly dispense
               with the default device.
             */
            int code = gs_grestoreall(i_ctx_p->pgs);
            if (code < 0) return_error(gs_error_Fatal);
        }

         if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {
             gx_device *pdev = i_ctx_p->pgs->device;
             const char * dname = pdev->dname;
            if (code < 0) {
                ref error_name;
                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {
                    char err_str[32] = {0};
                    name_string_ref(imemory, &error_name, &error_name);
                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));
                    emprintf3(imemory, ""ERROR: %s (%d) on closing %s device.\n"", err_str, code, dname);
                }
                else {
                    emprintf2(imemory, ""UNKNOWN ERROR %d closing %s device.\n"", code, dname);
               }
            }
            rc_decrement(pdev, ""gs_main_finit"");                /* device might be freed */
            if (exit_status == 0 || exit_status == gs_error_Quit)
                exit_status = code;
        }

      /* Flush stdout and stderr */
      gs_main_run_string(minst,
        ""(%stdout) (w) file closefile (%stderr) (w) file closefile \
        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \
          systemdict /savedinitialgstate .forceundef"",
        0 , &exit_code, &error_object);
    }
    gp_readline_finit(minst->readline_data);
    i_ctx_p = minst->i_ctx_p;		/* get current interp context */
    if (gs_debug_c(':')) {
        print_resource_usage(minst, &gs_imemory, ""Final"");
        dmprintf1(minst->heap, ""%% Exiting instance 0x%p\n"", minst);
    }
    /* Do the equivalent of a restore ""past the bottom"". */
    /* This will release all memory, close all open files, etc. */
    if (minst->init_done >= 1) {
        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;
        i_plugin_holder *h = i_ctx_p->plugin_list;

        dmem = *idmemory;
        code = alloc_restore_all(i_ctx_p);
        if (code < 0)
            emprintf1(mem_raw,
                      ""ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\n"",
                      code);
        i_iodev_finit(&dmem);
        i_plugin_finit(mem_raw, h);
    }

    /* clean up redirected stdout */
    if (minst->heap->gs_lib_ctx->fstdout2
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstdout)
        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstderr)) {
        fclose(minst->heap->gs_lib_ctx->fstdout2);
        minst->heap->gs_lib_ctx->fstdout2 = (FILE *)NULL;
    }

    minst->heap->gs_lib_ctx->stdout_is_redirected = 0;
    minst->heap->gs_lib_ctx->stdout_to_stderr = 0;
    /* remove any temporary files, after ghostscript has closed files */
    if (tempnames) {
        char *p = tempnames;
        while (*p) {
            unlink(p);
            p += strlen(p) + 1;
        }
        free(tempnames);
    }
    gs_lib_finit(exit_status, code, minst->heap);

    gs_free_object(minst->heap, minst->lib_path.container.value.refs, ""lib_path array"");
    ialloc_finit(&dmem);
    return exit_status;
}
","The `gs_main_finit` function is responsible for finalizing the Ghostscript interpreter instance, performing essential cleanup tasks before exiting. It begins by managing memory and device states, ensuring that any temporary names are handled and that the system dictionary is pushed to prevent operator redefinitions. The function disables background printing, closes the main device if necessary, and reclaims memory while handling potential errors. It also flushes standard output and error streams, restores all allocated memory, and cleans up any redirected output. Finally, it removes temporary files and frees allocated resources, returning the exit status of the operation.","The provided code is responsible for finalizing an interpreter instance in a graphics processing environment. It performs essential cleanup tasks, including managing memory, closing devices, and ensuring that temporary resources are properly handled. The function disables background printing to prevent conflicts during cleanup, flushes output streams, and restores all allocated memory. It also checks for errors during the memory reclamation process and handles any issues that arise. Finally, it removes temporary files created during the session and frees up allocated resources, returning an appropriate exit status to indicate the outcome of the finalization process.","The vulnerability in the original code stemmed from the lack of proper handling when the device was replaced with a null device, which could lead to resource leaks or undefined behavior during the finalization process. Specifically, the absence of a check for a null device could result in attempts to access or manipulate a non-existent device, causing potential crashes or memory corruption. The fixed code addresses this by introducing a check for the null device and calling a function to restore the graphics state if necessary, ensuring that all resources are correctly managed and released before finalization, thus enhancing stability and reliability.","The vulnerability in the original code arose from inadequate handling of device states during the finalization process, particularly when a device was replaced with a null state. This oversight could lead to attempts to access or manipulate non-existent resources, resulting in potential crashes or memory leaks. The revised code rectifies this issue by implementing a check for the null device state, ensuring that the graphics context is properly restored before any further operations are performed. This enhancement guarantees that all resources are managed correctly, thereby improving the stability and reliability of the finalization process.","The vulnerability was fixed by adding a check for a null device state within the finalization process. Specifically, the code now verifies if the device associated with the graphics context is null before proceeding with operations that could lead to errors. If the device is null, the code calls a function to restore the graphics state using `gs_grestoreall`, ensuring that any necessary cleanup is performed. This adjustment prevents attempts to manipulate a non-existent device, thereby enhancing the stability of the finalization process and reducing the risk of crashes or memory leaks.","The vulnerability was addressed by implementing a check to determine if the device state was null before executing any operations that could lead to errors. This added verification ensures that the code does not attempt to access or manipulate a non-existent device, which could result in crashes or resource leaks. If the device is found to be null, the code now properly restores the graphics context to maintain stability. This fix enhances the overall reliability of the finalization process by ensuring that all resources are correctly managed and cleaned up before completion.","CWE-476, CWE-690, CWE-401, CWE-672, CWE-416, CWE-456, CWE-665, CWE-664, CWE-415, CWE-909",N,-1
5,5,178125,178125,,Local,Not required,Partial,CVE-2016-6833,https://www.cvedetails.com/cve/CVE-2016-6833/,CWE-416,Low,,,,2016-12-09,2.1,Use-after-free vulnerability in the vmxnet3_io_bar0_write function in hw/net/vmxnet3.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (QEMU instance crash) by leveraging failure to check if the device is active.,2018-09-07,DoS,4,https://git.qemu.org/?p=qemu.git;a=commit;h=6c352ca9b4ee3e1e286ea9e8434bd8e69ac7d0d8,6c352ca9b4ee3e1e286ea9e8434bd8e69ac7d0d8,,0,,,"vmxnet3_io_bar0_write(void *opaque, hwaddr addr,
                      uint64_t val, unsigned size)
 {
     VMXNET3State *s = opaque;
 
    if (!s->device_active) {
        return;
    }

     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,
                         VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {
         int tx_queue_idx =
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,
                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {
        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,
                                         VMXNET3_REG_ALIGN);

        VMW_CBPRN(""Interrupt mask for line %d written: 0x%"" PRIx64, l, val);

        vmxnet3_on_interrupt_mask_changed(s, l, val);
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN) ||
       VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD2,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN)) {
        return;
    }

    VMW_WRPRN(""BAR0 unknown write [%"" PRIx64 ""] = %"" PRIx64 "", size %d"",
              (uint64_t) addr, val, size);
}
","vmxnet3_io_bar0_write(void *opaque, hwaddr addr,
                      uint64_t val, unsigned size)
 {
     VMXNET3State *s = opaque;
 
     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,
                         VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {
         int tx_queue_idx =
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,
                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {
        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,
                                         VMXNET3_REG_ALIGN);

        VMW_CBPRN(""Interrupt mask for line %d written: 0x%"" PRIx64, l, val);

        vmxnet3_on_interrupt_mask_changed(s, l, val);
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN) ||
       VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD2,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN)) {
        return;
    }

    VMW_WRPRN(""BAR0 unknown write [%"" PRIx64 ""] = %"" PRIx64 "", size %d"",
              (uint64_t) addr, val, size);
}
",C,"    if (!s->device_active) {
        return;
    }

",,ead315e43ea0c2ca3491209c6c8db8ce3f2bbe05,"@@ -1167,6 +1167,10 @@ vmxnet3_io_bar0_write(void *opaque, hwaddr addr,
 {
     VMXNET3State *s = opaque;
 
+    if (!s->device_active) {
+        return;
+    }
+
     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,
                         VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {
         int tx_queue_idx =",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/net/vmxnet3.c;h=90f69436687167907a4e927e1429702c543ec2d2;hb=90f69436687167907a4e927e1429702c543ec2d2,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/net/vmxnet3.c;h=bbf44adbcc54fb5ba0c041a259e06978116397b1;hb=bbf44adbcc54fb5ba0c041a259e06978116397b1,1,"vmxnet3_io_bar0_write(void *opaque, hwaddr addr,
                      uint64_t val, unsigned size)
 {
     VMXNET3State *s = opaque;
 
//fix_flaw_line_below:
//    if (!s->device_active) {
//fix_flaw_line_below:
//        return;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,
                         VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {
         int tx_queue_idx =
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,
                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {
        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,
                                         VMXNET3_REG_ALIGN);

        VMW_CBPRN(""Interrupt mask for line %d written: 0x%"" PRIx64, l, val);

        vmxnet3_on_interrupt_mask_changed(s, l, val);
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN) ||
       VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD2,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN)) {
        return;
    }

    VMW_WRPRN(""BAR0 unknown write [%"" PRIx64 ""] = %"" PRIx64 "", size %d"",
              (uint64_t) addr, val, size);
}
",178125,"vmxnet3_io_bar0_write(void *opaque, hwaddr addr,
                      uint64_t val, unsigned size)
 {
     VMXNET3State *s = opaque;
 
     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,
                         VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {
         int tx_queue_idx =
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,
                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {
        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,
                                         VMXNET3_REG_ALIGN);

        VMW_CBPRN(""Interrupt mask for line %d written: 0x%"" PRIx64, l, val);

        vmxnet3_on_interrupt_mask_changed(s, l, val);
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN) ||
       VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD2,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN)) {
        return;
    }

    VMW_WRPRN(""BAR0 unknown write [%"" PRIx64 ""] = %"" PRIx64 "", size %d"",
              (uint64_t) addr, val, size);
}
","vmxnet3_io_bar0_write(void *opaque, hwaddr addr,
                      uint64_t val, unsigned size)
 {
     VMXNET3State *s = opaque;
 
    if (!s->device_active) {
        return;
    }

     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,
                         VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {
         int tx_queue_idx =
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,
                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {
        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,
                                         VMXNET3_REG_ALIGN);

        VMW_CBPRN(""Interrupt mask for line %d written: 0x%"" PRIx64, l, val);

        vmxnet3_on_interrupt_mask_changed(s, l, val);
        return;
    }

    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN) ||
       VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD2,
                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN)) {
        return;
    }

    VMW_WRPRN(""BAR0 unknown write [%"" PRIx64 ""] = %"" PRIx64 "", size %d"",
              (uint64_t) addr, val, size);
}
","The function `vmxnet3_io_bar0_write` handles write operations to the I/O memory space of a VMXNET3 network device. It takes parameters for the device state, the address to write to, the value to write, and the size of the data. The function first checks if the address corresponds to a transmission queue and returns if it does. It then checks for an interrupt mask register, logging the change and invoking a callback to handle the mask update. If the address pertains to reception queues, it also returns without action. Any unknown addresses trigger a log message indicating an unrecognized write attempt.","The provided code defines a function that manages write operations to a specific memory region of a network device. It checks the address being written to and determines if it corresponds to transmission queues, interrupt masks, or reception queues. If the address relates to transmission queues or reception queues, the function exits without performing any action. For interrupt mask addresses, it logs the change and triggers a callback to update the mask. If the address does not match any known categories, it logs an error message indicating an unrecognized write attempt, ensuring proper handling of device interactions.","The vulnerability in the original code stemmed from the lack of a check to ensure that the device was active before processing write operations. This oversight could allow unauthorized or unintended writes to occur when the device was inactive, potentially leading to undefined behavior or security issues. The fix introduced a condition that checks the `device_active` variable before proceeding with any write operations. If the device is not active, the function immediately returns, effectively preventing any further processing and ensuring that only valid operations are executed when the device is in a proper state.","The vulnerability in the original code arose from the absence of a safeguard to verify whether the device was active before processing write operations. This lack of validation could lead to unauthorized or erroneous writes when the device was inactive, resulting in unpredictable behavior or potential security risks. The fix implemented a check to ensure the device's active status at the beginning of the function. If the device is not active, the function exits immediately, thereby preventing any further processing and ensuring that only legitimate operations are executed when the device is in a valid state.","The vulnerability was fixed by introducing a check for the `device_active` variable at the start of the `vmxnet3_io_bar0_write` function. This condition ensures that if the device is not active, the function will return immediately, preventing any further processing of write operations. By adding this safeguard, the code effectively blocks unauthorized or unintended writes when the device is inactive, thereby mitigating the risk of undefined behavior or security issues. This change ensures that only valid operations are executed, maintaining the integrity of the device's state during I/O interactions.","The vulnerability was addressed by implementing a preliminary check to verify the active status of the device before any write operations are processed. This safeguard ensures that if the device is inactive, the function will terminate early, preventing any further actions that could lead to unauthorized or erroneous writes. By enforcing this condition, the code effectively blocks any attempts to interact with the device when it is not in a valid state, thereby enhancing the overall security and stability of the system by ensuring that only legitimate operations are allowed.","CWE-666, CWE-672, CWE-665, CWE-456, CWE-476, CWE-732, CWE-362, CWE-367, CWE-822, CWE-825",N,-1
6,6,178153,178153,,Remote,Not required,Partial,CVE-2016-6290,https://www.cvedetails.com/cve/CVE-2016-6290/,CWE-416,Low,Partial,Partial,,2016-07-25,7.5,"ext/session/session.c in PHP before 5.5.38, 5.6.x before 5.6.24, and 7.x before 7.0.9 does not properly maintain a certain hash data structure, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via vectors related to session deserialization.",2018-01-04,DoS,1,https://git.php.net/?p=php-src.git;a=commit;h=3798eb6fd5dddb211b01d41495072fd9858d4e32,3798eb6fd5dddb211b01d41495072fd9858d4e32,,0,,,"PS_SERIALIZER_DECODE_FUNC(php_binary) /* {{{ */
{
	const char *p;
	char *name;
	const char *endptr = val + vallen;
	zval *current;
	int namelen;
	int has_value;
	php_unserialize_data_t var_hash;

	PHP_VAR_UNSERIALIZE_INIT(var_hash);

	for (p = val; p < endptr; ) {
		zval **tmp;
                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);
 
                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {
                       PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
                        return FAILURE;
                }

		name = estrndup(p + 1, namelen);

		p += namelen + 1;

		if (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {
			if ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {
				efree(name);
				continue;
			}
		}

		if (has_value) {
			ALLOC_INIT_ZVAL(current);
			if (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {
				php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);
			} else {
				PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
				return FAILURE;
			}
			var_push_dtor_no_addref(&var_hash, &current);
		}
		PS_ADD_VARL(name, namelen);
		efree(name);
	}

	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);

	return SUCCESS;
}
/* }}} */
","PS_SERIALIZER_DECODE_FUNC(php_binary) /* {{{ */
{
	const char *p;
	char *name;
	const char *endptr = val + vallen;
	zval *current;
	int namelen;
	int has_value;
	php_unserialize_data_t var_hash;

	PHP_VAR_UNSERIALIZE_INIT(var_hash);

	for (p = val; p < endptr; ) {
		zval **tmp;
                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);
 
                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {
                        return FAILURE;
                }

		name = estrndup(p + 1, namelen);

		p += namelen + 1;

		if (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {
			if ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {
				efree(name);
				continue;
			}
		}

		if (has_value) {
			ALLOC_INIT_ZVAL(current);
			if (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {
				php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);
			} else {
				PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
				return FAILURE;
			}
			var_push_dtor_no_addref(&var_hash, &current);
		}
		PS_ADD_VARL(name, namelen);
		efree(name);
	}

	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);

	return SUCCESS;
}
/* }}} */
",C,"                       PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
",,aa82e99ed8003c01f1ef4f0940e56b85c5b032d4,"@@ -866,7 +866,7 @@ PS_SERIALIZER_DECODE_FUNC(php_serialize) /* {{{ */
        if (php_var_unserialize(&session_vars, &val, endptr, &var_hash TSRMLS_CC)) {
                var_push_dtor(&var_hash, &session_vars);
        }
-       
+
        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
        if (PS(http_session_vars)) {
                zval_ptr_dtor(&PS(http_session_vars));
@@ -931,6 +931,7 @@ PS_SERIALIZER_DECODE_FUNC(php_binary) /* {{{ */
                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);
 
                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {
+                       PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
                        return FAILURE;
                }",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/session/session.c;h=cb6cc01f219c12922f4ef7f4152aa08de2745123;hb=3798eb6fd5dddb211b01d41495072fd9858d4e32,https://git.php.net/?p=php-src.git;a=blob;f=ext/session/session.c;h=f5439ea79c5b94b9c68adf8a1c5a77e8c318cf24,1,"PS_SERIALIZER_DECODE_FUNC(php_binary) /* {{{ */
{
	const char *p;
	char *name;
	const char *endptr = val + vallen;
	zval *current;
	int namelen;
	int has_value;
	php_unserialize_data_t var_hash;

	PHP_VAR_UNSERIALIZE_INIT(var_hash);

	for (p = val; p < endptr; ) {
		zval **tmp;
                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);
 
                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {
//fix_flaw_line_below:
//                       PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
                        return FAILURE;
                }

		name = estrndup(p + 1, namelen);

		p += namelen + 1;

		if (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {
			if ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {
				efree(name);
				continue;
			}
		}

		if (has_value) {
			ALLOC_INIT_ZVAL(current);
			if (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {
				php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);
			} else {
				PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
				return FAILURE;
			}
			var_push_dtor_no_addref(&var_hash, &current);
		}
		PS_ADD_VARL(name, namelen);
		efree(name);
	}

	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);

	return SUCCESS;
}
/* }}} */
",178153,"PS_SERIALIZER_DECODE_FUNC(php_binary) /* {{{ */
{
	const char *p;
	char *name;
	const char *endptr = val + vallen;
	zval *current;
	int namelen;
	int has_value;
	php_unserialize_data_t var_hash;

	PHP_VAR_UNSERIALIZE_INIT(var_hash);

	for (p = val; p < endptr; ) {
		zval **tmp;
                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);
 
                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {
                        return FAILURE;
                }

		name = estrndup(p + 1, namelen);

		p += namelen + 1;

		if (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {
			if ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {
				efree(name);
				continue;
			}
		}

		if (has_value) {
			ALLOC_INIT_ZVAL(current);
			if (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {
				php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);
			} else {
				PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
				return FAILURE;
			}
			var_push_dtor_no_addref(&var_hash, &current);
		}
		PS_ADD_VARL(name, namelen);
		efree(name);
	}

	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);

	return SUCCESS;
}
/* }}} */
","PS_SERIALIZER_DECODE_FUNC(php_binary) /* {{{ */
{
	const char *p;
	char *name;
	const char *endptr = val + vallen;
	zval *current;
	int namelen;
	int has_value;
	php_unserialize_data_t var_hash;

	PHP_VAR_UNSERIALIZE_INIT(var_hash);

	for (p = val; p < endptr; ) {
		zval **tmp;
                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);
 
                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {
                       PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
                        return FAILURE;
                }

		name = estrndup(p + 1, namelen);

		p += namelen + 1;

		if (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {
			if ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {
				efree(name);
				continue;
			}
		}

		if (has_value) {
			ALLOC_INIT_ZVAL(current);
			if (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {
				php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);
			} else {
				PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
				return FAILURE;
			}
			var_push_dtor_no_addref(&var_hash, &current);
		}
		PS_ADD_VARL(name, namelen);
		efree(name);
	}

	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);

	return SUCCESS;
}
/* }}} */
","The provided code defines a function for decoding serialized PHP binary data, specifically for session management. It initializes a variable hash for unserialization and iterates through the binary data, extracting variable names and their corresponding values. For each variable, it checks if it already exists in the global symbol table and skips it if it does. If a value is present, it allocates a new zval, unserializes the data into it, and sets the session variable accordingly. The function ensures proper memory management by freeing allocated names and cleaning up the variable hash before returning success or failure based on the operations performed.","The code defines a function that decodes serialized binary data used for session management in a programming environment. It initializes a structure to handle variable unserialization and processes the binary input by extracting variable names and their associated values. During this process, it checks for existing variables to avoid duplication. If a value is found, it allocates memory for it, unserializes the data, and assigns it to the session. The function ensures proper memory management by freeing allocated resources and cleaning up before concluding with a success or failure status based on the operations performed.","The vulnerability in the original code arises from insufficient validation of the length of the variable names extracted from the serialized data, which could lead to buffer overflows or memory corruption if the length exceeds expected limits. Specifically, the check for `namelen` did not adequately handle cases where it could be negative or exceed predefined maximum values. In the fixed code, an additional validation step was introduced to ensure that `namelen` is within acceptable bounds before proceeding with memory allocation and data processing. This change mitigates the risk of buffer overflows by ensuring that only valid lengths are processed.","The vulnerability in the original code stemmed from inadequate validation of the length of variable names extracted from serialized data, which could lead to buffer overflows or memory corruption if the lengths were negative or exceeded predefined limits. This lack of proper checks allowed for potential exploitation through malformed input. In the revised code, additional validation was implemented to ensure that the length of the variable names is within acceptable bounds before any memory allocation or processing occurs. This fix effectively mitigates the risk of buffer overflows by enforcing stricter checks on the input data's integrity.","The vulnerability was fixed by adding a validation check for the variable name length, specifically through the condition that verifies if `namelen` is less than 0, greater than a predefined maximum, or if the pointer exceeds the end of the data. This check occurs before the allocation of memory for the variable name using `estrndup`. If any of these conditions are met, the function immediately calls `PHP_VAR_UNSERIALIZE_DESTROY` to clean up and returns `FAILURE`, preventing any further processing of potentially unsafe data. This enhancement ensures that only valid lengths are processed, thereby mitigating the risk of buffer overflows.","The vulnerability was addressed by implementing additional validation checks to ensure that the length of the variable names extracted from the serialized data is within safe and acceptable limits. Specifically, the code now verifies that the length is not negative, does not exceed a predefined maximum, and that the pointer does not surpass the end of the data. If any of these conditions are violated, the function performs necessary cleanup and terminates early, preventing any further processing of potentially harmful data. This enhancement effectively reduces the risk of buffer overflows and memory corruption.","CWE-119, CWE-120, CWE-125, CWE-130, CWE-789, CWE-20, CWE-788, CWE-131, CWE-787, CWE-823",N,-1
7,7,179630,179630,,Local Network,Not required,,CVE-2014-0131,https://www.cvedetails.com/cve/CVE-2014-0131/,CWE-416,Medium,Partial,,,2014-03-24,2.9,Use-after-free vulnerability in the skb_segment function in net/core/skbuff.c in the Linux kernel through 3.13.6 allows attackers to obtain sensitive information from kernel memory by leveraging the absence of a certain orphaning operation.,2019-05-13,+Info ,6,https://github.com/torvalds/linux/commit/1fd819ecb90cc9b822cd84d3056ddba315d3340f,1fd819ecb90cc9b822cd84d3056ddba315d3340f,"skbuff: skb_segment: orphan frags before copying

skb_segment copies frags around, so we need
to copy them carefully to avoid accessing
user memory after reporting completion to userspace
through a callback.

skb_segment doesn't normally happen on datapath:
TSO needs to be disabled - so disabling zero copy
in this case does not look like a big deal.

Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/core/skbuff.c,"{""sha"": ""869c7afe3b070576464693e4d6ca00482c151f42"", ""filename"": ""net/core/skbuff.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/1fd819ecb90cc9b822cd84d3056ddba315d3340f/net/core/skbuff.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/1fd819ecb90cc9b822cd84d3056ddba315d3340f/net/core/skbuff.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/core/skbuff.c?ref=1fd819ecb90cc9b822cd84d3056ddba315d3340f"", ""patch"": ""@@ -2854,6 +2854,7 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,\n \tskb_frag_t *frag = skb_shinfo(head_skb)->frags;\n \tunsigned int mss = skb_shinfo(head_skb)->gso_size;\n \tunsigned int doffset = head_skb->data - skb_mac_header(head_skb);\n+\tstruct sk_buff *frag_skb = head_skb;\n \tunsigned int offset = doffset;\n \tunsigned int tnl_hlen = skb_tnl_header_len(head_skb);\n \tunsigned int headroom;\n@@ -2898,6 +2899,7 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,\n \t\t\ti = 0;\n \t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n \t\t\tfrag = skb_shinfo(list_skb)->frags;\n+\t\t\tfrag_skb = list_skb;\n \t\t\tpos += skb_headlen(list_skb);\n \n \t\t\twhile (pos < offset + len) {\n@@ -2985,6 +2987,7 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,\n \t\t\t\ti = 0;\n \t\t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n \t\t\t\tfrag = skb_shinfo(list_skb)->frags;\n+\t\t\t\tfrag_skb = list_skb;\n \n \t\t\t\tBUG_ON(!nfrags);\n \n@@ -2999,6 +3002,9 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,\n \t\t\t\tgoto err;\n \t\t\t}\n \n+\t\t\tif (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC)))\n+\t\t\t\tgoto err;\n+\n \t\t\t*nskb_frag = *frag;\n \t\t\t__skb_frag_ref(nskb_frag);\n \t\t\tsize = skb_frag_size(nskb_frag);""}","struct sk_buff *skb_segment(struct sk_buff *head_skb,
			    netdev_features_t features)
{
	struct sk_buff *segs = NULL;
	struct sk_buff *tail = NULL;
	struct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;
 	skb_frag_t *frag = skb_shinfo(head_skb)->frags;
 	unsigned int mss = skb_shinfo(head_skb)->gso_size;
 	unsigned int doffset = head_skb->data - skb_mac_header(head_skb);
	struct sk_buff *frag_skb = head_skb;
 	unsigned int offset = doffset;
 	unsigned int tnl_hlen = skb_tnl_header_len(head_skb);
 	unsigned int headroom;
	unsigned int len;
	__be16 proto;
	bool csum;
	int sg = !!(features & NETIF_F_SG);
	int nfrags = skb_shinfo(head_skb)->nr_frags;
	int err = -ENOMEM;
	int i = 0;
	int pos;

	proto = skb_network_protocol(head_skb);
	if (unlikely(!proto))
		return ERR_PTR(-EINVAL);

	csum = !!can_checksum_protocol(features, proto);
	__skb_push(head_skb, doffset);
	headroom = skb_headroom(head_skb);
	pos = skb_headlen(head_skb);

	do {
		struct sk_buff *nskb;
		skb_frag_t *nskb_frag;
		int hsize;
		int size;

		len = head_skb->len - offset;
		if (len > mss)
			len = mss;

		hsize = skb_headlen(head_skb) - offset;
		if (hsize < 0)
			hsize = 0;
		if (hsize > len || !sg)
			hsize = len;

		if (!hsize && i >= nfrags && skb_headlen(list_skb) &&
		    (skb_headlen(list_skb) == len || sg)) {
			BUG_ON(skb_headlen(list_skb) > len);

 			i = 0;
 			nfrags = skb_shinfo(list_skb)->nr_frags;
 			frag = skb_shinfo(list_skb)->frags;
			frag_skb = list_skb;
 			pos += skb_headlen(list_skb);
 
 			while (pos < offset + len) {
				BUG_ON(i >= nfrags);

				size = skb_frag_size(frag);
				if (pos + size > offset + len)
					break;

				i++;
				pos += size;
				frag++;
			}

			nskb = skb_clone(list_skb, GFP_ATOMIC);
			list_skb = list_skb->next;

			if (unlikely(!nskb))
				goto err;

			if (unlikely(pskb_trim(nskb, len))) {
				kfree_skb(nskb);
				goto err;
			}

			hsize = skb_end_offset(nskb);
			if (skb_cow_head(nskb, doffset + headroom)) {
				kfree_skb(nskb);
				goto err;
			}

			nskb->truesize += skb_end_offset(nskb) - hsize;
			skb_release_head_state(nskb);
			__skb_push(nskb, doffset);
		} else {
			nskb = __alloc_skb(hsize + doffset + headroom,
					   GFP_ATOMIC, skb_alloc_rx_flag(head_skb),
					   NUMA_NO_NODE);

			if (unlikely(!nskb))
				goto err;

			skb_reserve(nskb, headroom);
			__skb_put(nskb, doffset);
		}

		if (segs)
			tail->next = nskb;
		else
			segs = nskb;
		tail = nskb;

		__copy_skb_header(nskb, head_skb);
		nskb->mac_len = head_skb->mac_len;

		skb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);

		skb_copy_from_linear_data_offset(head_skb, -tnl_hlen,
						 nskb->data - tnl_hlen,
						 doffset + tnl_hlen);

		if (nskb->len == len + doffset)
			goto perform_csum_check;

		if (!sg) {
			nskb->ip_summed = CHECKSUM_NONE;
			nskb->csum = skb_copy_and_csum_bits(head_skb, offset,
							    skb_put(nskb, len),
							    len, 0);
			continue;
		}

		nskb_frag = skb_shinfo(nskb)->frags;

		skb_copy_from_linear_data_offset(head_skb, offset,
						 skb_put(nskb, hsize), hsize);

		skb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &
			SKBTX_SHARED_FRAG;

		while (pos < offset + len) {
			if (i >= nfrags) {
				BUG_ON(skb_headlen(list_skb));

 				i = 0;
 				nfrags = skb_shinfo(list_skb)->nr_frags;
 				frag = skb_shinfo(list_skb)->frags;
				frag_skb = list_skb;
 
 				BUG_ON(!nfrags);
 
				list_skb = list_skb->next;
			}

			if (unlikely(skb_shinfo(nskb)->nr_frags >=
				     MAX_SKB_FRAGS)) {
				net_warn_ratelimited(
					""skb_segment: too many frags: %u %u\n"",
					pos, mss);
 				goto err;
 			}
 
			if (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC)))
				goto err;

 			*nskb_frag = *frag;
 			__skb_frag_ref(nskb_frag);
 			size = skb_frag_size(nskb_frag);

			if (pos < offset) {
				nskb_frag->page_offset += offset - pos;
				skb_frag_size_sub(nskb_frag, offset - pos);
			}

			skb_shinfo(nskb)->nr_frags++;

			if (pos + size <= offset + len) {
				i++;
				frag++;
				pos += size;
			} else {
				skb_frag_size_sub(nskb_frag, pos + size - (offset + len));
				goto skip_fraglist;
			}

			nskb_frag++;
		}

skip_fraglist:
		nskb->data_len = len - hsize;
		nskb->len += nskb->data_len;
		nskb->truesize += nskb->data_len;

perform_csum_check:
		if (!csum) {
			nskb->csum = skb_checksum(nskb, doffset,
						  nskb->len - doffset, 0);
			nskb->ip_summed = CHECKSUM_NONE;
		}
	} while ((offset += len) < head_skb->len);

	return segs;

err:
	kfree_skb_list(segs);
	return ERR_PTR(err);
}
","struct sk_buff *skb_segment(struct sk_buff *head_skb,
			    netdev_features_t features)
{
	struct sk_buff *segs = NULL;
	struct sk_buff *tail = NULL;
	struct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;
 	skb_frag_t *frag = skb_shinfo(head_skb)->frags;
 	unsigned int mss = skb_shinfo(head_skb)->gso_size;
 	unsigned int doffset = head_skb->data - skb_mac_header(head_skb);
 	unsigned int offset = doffset;
 	unsigned int tnl_hlen = skb_tnl_header_len(head_skb);
 	unsigned int headroom;
	unsigned int len;
	__be16 proto;
	bool csum;
	int sg = !!(features & NETIF_F_SG);
	int nfrags = skb_shinfo(head_skb)->nr_frags;
	int err = -ENOMEM;
	int i = 0;
	int pos;

	proto = skb_network_protocol(head_skb);
	if (unlikely(!proto))
		return ERR_PTR(-EINVAL);

	csum = !!can_checksum_protocol(features, proto);
	__skb_push(head_skb, doffset);
	headroom = skb_headroom(head_skb);
	pos = skb_headlen(head_skb);

	do {
		struct sk_buff *nskb;
		skb_frag_t *nskb_frag;
		int hsize;
		int size;

		len = head_skb->len - offset;
		if (len > mss)
			len = mss;

		hsize = skb_headlen(head_skb) - offset;
		if (hsize < 0)
			hsize = 0;
		if (hsize > len || !sg)
			hsize = len;

		if (!hsize && i >= nfrags && skb_headlen(list_skb) &&
		    (skb_headlen(list_skb) == len || sg)) {
			BUG_ON(skb_headlen(list_skb) > len);

 			i = 0;
 			nfrags = skb_shinfo(list_skb)->nr_frags;
 			frag = skb_shinfo(list_skb)->frags;
 			pos += skb_headlen(list_skb);
 
 			while (pos < offset + len) {
				BUG_ON(i >= nfrags);

				size = skb_frag_size(frag);
				if (pos + size > offset + len)
					break;

				i++;
				pos += size;
				frag++;
			}

			nskb = skb_clone(list_skb, GFP_ATOMIC);
			list_skb = list_skb->next;

			if (unlikely(!nskb))
				goto err;

			if (unlikely(pskb_trim(nskb, len))) {
				kfree_skb(nskb);
				goto err;
			}

			hsize = skb_end_offset(nskb);
			if (skb_cow_head(nskb, doffset + headroom)) {
				kfree_skb(nskb);
				goto err;
			}

			nskb->truesize += skb_end_offset(nskb) - hsize;
			skb_release_head_state(nskb);
			__skb_push(nskb, doffset);
		} else {
			nskb = __alloc_skb(hsize + doffset + headroom,
					   GFP_ATOMIC, skb_alloc_rx_flag(head_skb),
					   NUMA_NO_NODE);

			if (unlikely(!nskb))
				goto err;

			skb_reserve(nskb, headroom);
			__skb_put(nskb, doffset);
		}

		if (segs)
			tail->next = nskb;
		else
			segs = nskb;
		tail = nskb;

		__copy_skb_header(nskb, head_skb);
		nskb->mac_len = head_skb->mac_len;

		skb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);

		skb_copy_from_linear_data_offset(head_skb, -tnl_hlen,
						 nskb->data - tnl_hlen,
						 doffset + tnl_hlen);

		if (nskb->len == len + doffset)
			goto perform_csum_check;

		if (!sg) {
			nskb->ip_summed = CHECKSUM_NONE;
			nskb->csum = skb_copy_and_csum_bits(head_skb, offset,
							    skb_put(nskb, len),
							    len, 0);
			continue;
		}

		nskb_frag = skb_shinfo(nskb)->frags;

		skb_copy_from_linear_data_offset(head_skb, offset,
						 skb_put(nskb, hsize), hsize);

		skb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &
			SKBTX_SHARED_FRAG;

		while (pos < offset + len) {
			if (i >= nfrags) {
				BUG_ON(skb_headlen(list_skb));

 				i = 0;
 				nfrags = skb_shinfo(list_skb)->nr_frags;
 				frag = skb_shinfo(list_skb)->frags;
 
 				BUG_ON(!nfrags);
 
				list_skb = list_skb->next;
			}

			if (unlikely(skb_shinfo(nskb)->nr_frags >=
				     MAX_SKB_FRAGS)) {
				net_warn_ratelimited(
					""skb_segment: too many frags: %u %u\n"",
					pos, mss);
 				goto err;
 			}
 
 			*nskb_frag = *frag;
 			__skb_frag_ref(nskb_frag);
 			size = skb_frag_size(nskb_frag);

			if (pos < offset) {
				nskb_frag->page_offset += offset - pos;
				skb_frag_size_sub(nskb_frag, offset - pos);
			}

			skb_shinfo(nskb)->nr_frags++;

			if (pos + size <= offset + len) {
				i++;
				frag++;
				pos += size;
			} else {
				skb_frag_size_sub(nskb_frag, pos + size - (offset + len));
				goto skip_fraglist;
			}

			nskb_frag++;
		}

skip_fraglist:
		nskb->data_len = len - hsize;
		nskb->len += nskb->data_len;
		nskb->truesize += nskb->data_len;

perform_csum_check:
		if (!csum) {
			nskb->csum = skb_checksum(nskb, doffset,
						  nskb->len - doffset, 0);
			nskb->ip_summed = CHECKSUM_NONE;
		}
	} while ((offset += len) < head_skb->len);

	return segs;

err:
	kfree_skb_list(segs);
	return ERR_PTR(err);
}
",C,"	struct sk_buff *frag_skb = head_skb;
			frag_skb = list_skb;
				frag_skb = list_skb;
			if (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC)))
				goto err;

",,,"@@ -2854,6 +2854,7 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,
 	skb_frag_t *frag = skb_shinfo(head_skb)->frags;
 	unsigned int mss = skb_shinfo(head_skb)->gso_size;
 	unsigned int doffset = head_skb->data - skb_mac_header(head_skb);
+	struct sk_buff *frag_skb = head_skb;
 	unsigned int offset = doffset;
 	unsigned int tnl_hlen = skb_tnl_header_len(head_skb);
 	unsigned int headroom;
@@ -2898,6 +2899,7 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,
 			i = 0;
 			nfrags = skb_shinfo(list_skb)->nr_frags;
 			frag = skb_shinfo(list_skb)->frags;
+			frag_skb = list_skb;
 			pos += skb_headlen(list_skb);
 
 			while (pos < offset + len) {
@@ -2985,6 +2987,7 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,
 				i = 0;
 				nfrags = skb_shinfo(list_skb)->nr_frags;
 				frag = skb_shinfo(list_skb)->frags;
+				frag_skb = list_skb;
 
 				BUG_ON(!nfrags);
 
@@ -2999,6 +3002,9 @@ struct sk_buff *skb_segment(struct sk_buff *head_skb,
 				goto err;
 			}
 
+			if (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC)))
+				goto err;
+
 			*nskb_frag = *frag;
 			__skb_frag_ref(nskb_frag);
 			size = skb_frag_size(nskb_frag);",linux,1fd819ecb90cc9b822cd84d3056ddba315d3340f,1a4cedaf65491e66e1e55b8428c89209da729209,1,"struct sk_buff *skb_segment(struct sk_buff *head_skb,
			    netdev_features_t features)
{
	struct sk_buff *segs = NULL;
	struct sk_buff *tail = NULL;
	struct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;
 	skb_frag_t *frag = skb_shinfo(head_skb)->frags;
 	unsigned int mss = skb_shinfo(head_skb)->gso_size;
 	unsigned int doffset = head_skb->data - skb_mac_header(head_skb);
//fix_flaw_line_below:
//	struct sk_buff *frag_skb = head_skb;
 	unsigned int offset = doffset;
 	unsigned int tnl_hlen = skb_tnl_header_len(head_skb);
 	unsigned int headroom;
	unsigned int len;
	__be16 proto;
	bool csum;
	int sg = !!(features & NETIF_F_SG);
	int nfrags = skb_shinfo(head_skb)->nr_frags;
	int err = -ENOMEM;
	int i = 0;
	int pos;

	proto = skb_network_protocol(head_skb);
	if (unlikely(!proto))
		return ERR_PTR(-EINVAL);

	csum = !!can_checksum_protocol(features, proto);
	__skb_push(head_skb, doffset);
	headroom = skb_headroom(head_skb);
	pos = skb_headlen(head_skb);

	do {
		struct sk_buff *nskb;
		skb_frag_t *nskb_frag;
		int hsize;
		int size;

		len = head_skb->len - offset;
		if (len > mss)
			len = mss;

		hsize = skb_headlen(head_skb) - offset;
		if (hsize < 0)
			hsize = 0;
		if (hsize > len || !sg)
			hsize = len;

		if (!hsize && i >= nfrags && skb_headlen(list_skb) &&
		    (skb_headlen(list_skb) == len || sg)) {
			BUG_ON(skb_headlen(list_skb) > len);

 			i = 0;
 			nfrags = skb_shinfo(list_skb)->nr_frags;
 			frag = skb_shinfo(list_skb)->frags;
//fix_flaw_line_below:
//			frag_skb = list_skb;
 			pos += skb_headlen(list_skb);
 
 			while (pos < offset + len) {
				BUG_ON(i >= nfrags);

				size = skb_frag_size(frag);
				if (pos + size > offset + len)
					break;

				i++;
				pos += size;
				frag++;
			}

			nskb = skb_clone(list_skb, GFP_ATOMIC);
			list_skb = list_skb->next;

			if (unlikely(!nskb))
				goto err;

			if (unlikely(pskb_trim(nskb, len))) {
				kfree_skb(nskb);
				goto err;
			}

			hsize = skb_end_offset(nskb);
			if (skb_cow_head(nskb, doffset + headroom)) {
				kfree_skb(nskb);
				goto err;
			}

			nskb->truesize += skb_end_offset(nskb) - hsize;
			skb_release_head_state(nskb);
			__skb_push(nskb, doffset);
		} else {
			nskb = __alloc_skb(hsize + doffset + headroom,
					   GFP_ATOMIC, skb_alloc_rx_flag(head_skb),
					   NUMA_NO_NODE);

			if (unlikely(!nskb))
				goto err;

			skb_reserve(nskb, headroom);
			__skb_put(nskb, doffset);
		}

		if (segs)
			tail->next = nskb;
		else
			segs = nskb;
		tail = nskb;

		__copy_skb_header(nskb, head_skb);
		nskb->mac_len = head_skb->mac_len;

		skb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);

		skb_copy_from_linear_data_offset(head_skb, -tnl_hlen,
						 nskb->data - tnl_hlen,
						 doffset + tnl_hlen);

		if (nskb->len == len + doffset)
			goto perform_csum_check;

		if (!sg) {
			nskb->ip_summed = CHECKSUM_NONE;
			nskb->csum = skb_copy_and_csum_bits(head_skb, offset,
							    skb_put(nskb, len),
							    len, 0);
			continue;
		}

		nskb_frag = skb_shinfo(nskb)->frags;

		skb_copy_from_linear_data_offset(head_skb, offset,
						 skb_put(nskb, hsize), hsize);

		skb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &
			SKBTX_SHARED_FRAG;

		while (pos < offset + len) {
			if (i >= nfrags) {
				BUG_ON(skb_headlen(list_skb));

 				i = 0;
 				nfrags = skb_shinfo(list_skb)->nr_frags;
 				frag = skb_shinfo(list_skb)->frags;
//fix_flaw_line_below:
//				frag_skb = list_skb;
 
 				BUG_ON(!nfrags);
 
				list_skb = list_skb->next;
			}

			if (unlikely(skb_shinfo(nskb)->nr_frags >=
				     MAX_SKB_FRAGS)) {
				net_warn_ratelimited(
					""skb_segment: too many frags: %u %u\n"",
					pos, mss);
 				goto err;
 			}
 
//fix_flaw_line_below:
//			if (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC)))
//fix_flaw_line_below:
//				goto err;
//fix_flaw_line_below:
//
 			*nskb_frag = *frag;
 			__skb_frag_ref(nskb_frag);
 			size = skb_frag_size(nskb_frag);

			if (pos < offset) {
				nskb_frag->page_offset += offset - pos;
				skb_frag_size_sub(nskb_frag, offset - pos);
			}

			skb_shinfo(nskb)->nr_frags++;

			if (pos + size <= offset + len) {
				i++;
				frag++;
				pos += size;
			} else {
				skb_frag_size_sub(nskb_frag, pos + size - (offset + len));
				goto skip_fraglist;
			}

			nskb_frag++;
		}

skip_fraglist:
		nskb->data_len = len - hsize;
		nskb->len += nskb->data_len;
		nskb->truesize += nskb->data_len;

perform_csum_check:
		if (!csum) {
			nskb->csum = skb_checksum(nskb, doffset,
						  nskb->len - doffset, 0);
			nskb->ip_summed = CHECKSUM_NONE;
		}
	} while ((offset += len) < head_skb->len);

	return segs;

err:
	kfree_skb_list(segs);
	return ERR_PTR(err);
}
",179630,"struct sk_buff *skb_segment(struct sk_buff *head_skb,
			    netdev_features_t features)
{
	struct sk_buff *segs = NULL;
	struct sk_buff *tail = NULL;
	struct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;
 	skb_frag_t *frag = skb_shinfo(head_skb)->frags;
 	unsigned int mss = skb_shinfo(head_skb)->gso_size;
 	unsigned int doffset = head_skb->data - skb_mac_header(head_skb);
 	unsigned int offset = doffset;
 	unsigned int tnl_hlen = skb_tnl_header_len(head_skb);
 	unsigned int headroom;
	unsigned int len;
	__be16 proto;
	bool csum;
	int sg = !!(features & NETIF_F_SG);
	int nfrags = skb_shinfo(head_skb)->nr_frags;
	int err = -ENOMEM;
	int i = 0;
	int pos;

	proto = skb_network_protocol(head_skb);
	if (unlikely(!proto))
		return ERR_PTR(-EINVAL);

	csum = !!can_checksum_protocol(features, proto);
	__skb_push(head_skb, doffset);
	headroom = skb_headroom(head_skb);
	pos = skb_headlen(head_skb);

	do {
		struct sk_buff *nskb;
		skb_frag_t *nskb_frag;
		int hsize;
		int size;

		len = head_skb->len - offset;
		if (len > mss)
			len = mss;

		hsize = skb_headlen(head_skb) - offset;
		if (hsize < 0)
			hsize = 0;
		if (hsize > len || !sg)
			hsize = len;

		if (!hsize && i >= nfrags && skb_headlen(list_skb) &&
		    (skb_headlen(list_skb) == len || sg)) {
			BUG_ON(skb_headlen(list_skb) > len);

 			i = 0;
 			nfrags = skb_shinfo(list_skb)->nr_frags;
 			frag = skb_shinfo(list_skb)->frags;
 			pos += skb_headlen(list_skb);
 
 			while (pos < offset + len) {
				BUG_ON(i >= nfrags);

				size = skb_frag_size(frag);
				if (pos + size > offset + len)
					break;

				i++;
				pos += size;
				frag++;
			}

			nskb = skb_clone(list_skb, GFP_ATOMIC);
			list_skb = list_skb->next;

			if (unlikely(!nskb))
				goto err;

			if (unlikely(pskb_trim(nskb, len))) {
				kfree_skb(nskb);
				goto err;
			}

			hsize = skb_end_offset(nskb);
			if (skb_cow_head(nskb, doffset + headroom)) {
				kfree_skb(nskb);
				goto err;
			}

			nskb->truesize += skb_end_offset(nskb) - hsize;
			skb_release_head_state(nskb);
			__skb_push(nskb, doffset);
		} else {
			nskb = __alloc_skb(hsize + doffset + headroom,
					   GFP_ATOMIC, skb_alloc_rx_flag(head_skb),
					   NUMA_NO_NODE);

			if (unlikely(!nskb))
				goto err;

			skb_reserve(nskb, headroom);
			__skb_put(nskb, doffset);
		}

		if (segs)
			tail->next = nskb;
		else
			segs = nskb;
		tail = nskb;

		__copy_skb_header(nskb, head_skb);
		nskb->mac_len = head_skb->mac_len;

		skb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);

		skb_copy_from_linear_data_offset(head_skb, -tnl_hlen,
						 nskb->data - tnl_hlen,
						 doffset + tnl_hlen);

		if (nskb->len == len + doffset)
			goto perform_csum_check;

		if (!sg) {
			nskb->ip_summed = CHECKSUM_NONE;
			nskb->csum = skb_copy_and_csum_bits(head_skb, offset,
							    skb_put(nskb, len),
							    len, 0);
			continue;
		}

		nskb_frag = skb_shinfo(nskb)->frags;

		skb_copy_from_linear_data_offset(head_skb, offset,
						 skb_put(nskb, hsize), hsize);

		skb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &
			SKBTX_SHARED_FRAG;

		while (pos < offset + len) {
			if (i >= nfrags) {
				BUG_ON(skb_headlen(list_skb));

 				i = 0;
 				nfrags = skb_shinfo(list_skb)->nr_frags;
 				frag = skb_shinfo(list_skb)->frags;
 
 				BUG_ON(!nfrags);
 
				list_skb = list_skb->next;
			}

			if (unlikely(skb_shinfo(nskb)->nr_frags >=
				     MAX_SKB_FRAGS)) {
				net_warn_ratelimited(
					""skb_segment: too many frags: %u %u\n"",
					pos, mss);
 				goto err;
 			}
 
 			*nskb_frag = *frag;
 			__skb_frag_ref(nskb_frag);
 			size = skb_frag_size(nskb_frag);

			if (pos < offset) {
				nskb_frag->page_offset += offset - pos;
				skb_frag_size_sub(nskb_frag, offset - pos);
			}

			skb_shinfo(nskb)->nr_frags++;

			if (pos + size <= offset + len) {
				i++;
				frag++;
				pos += size;
			} else {
				skb_frag_size_sub(nskb_frag, pos + size - (offset + len));
				goto skip_fraglist;
			}

			nskb_frag++;
		}

skip_fraglist:
		nskb->data_len = len - hsize;
		nskb->len += nskb->data_len;
		nskb->truesize += nskb->data_len;

perform_csum_check:
		if (!csum) {
			nskb->csum = skb_checksum(nskb, doffset,
						  nskb->len - doffset, 0);
			nskb->ip_summed = CHECKSUM_NONE;
		}
	} while ((offset += len) < head_skb->len);

	return segs;

err:
	kfree_skb_list(segs);
	return ERR_PTR(err);
}
","struct sk_buff *skb_segment(struct sk_buff *head_skb,
			    netdev_features_t features)
{
	struct sk_buff *segs = NULL;
	struct sk_buff *tail = NULL;
	struct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;
 	skb_frag_t *frag = skb_shinfo(head_skb)->frags;
 	unsigned int mss = skb_shinfo(head_skb)->gso_size;
 	unsigned int doffset = head_skb->data - skb_mac_header(head_skb);
	struct sk_buff *frag_skb = head_skb;
 	unsigned int offset = doffset;
 	unsigned int tnl_hlen = skb_tnl_header_len(head_skb);
 	unsigned int headroom;
	unsigned int len;
	__be16 proto;
	bool csum;
	int sg = !!(features & NETIF_F_SG);
	int nfrags = skb_shinfo(head_skb)->nr_frags;
	int err = -ENOMEM;
	int i = 0;
	int pos;

	proto = skb_network_protocol(head_skb);
	if (unlikely(!proto))
		return ERR_PTR(-EINVAL);

	csum = !!can_checksum_protocol(features, proto);
	__skb_push(head_skb, doffset);
	headroom = skb_headroom(head_skb);
	pos = skb_headlen(head_skb);

	do {
		struct sk_buff *nskb;
		skb_frag_t *nskb_frag;
		int hsize;
		int size;

		len = head_skb->len - offset;
		if (len > mss)
			len = mss;

		hsize = skb_headlen(head_skb) - offset;
		if (hsize < 0)
			hsize = 0;
		if (hsize > len || !sg)
			hsize = len;

		if (!hsize && i >= nfrags && skb_headlen(list_skb) &&
		    (skb_headlen(list_skb) == len || sg)) {
			BUG_ON(skb_headlen(list_skb) > len);

 			i = 0;
 			nfrags = skb_shinfo(list_skb)->nr_frags;
 			frag = skb_shinfo(list_skb)->frags;
			frag_skb = list_skb;
 			pos += skb_headlen(list_skb);
 
 			while (pos < offset + len) {
				BUG_ON(i >= nfrags);

				size = skb_frag_size(frag);
				if (pos + size > offset + len)
					break;

				i++;
				pos += size;
				frag++;
			}

			nskb = skb_clone(list_skb, GFP_ATOMIC);
			list_skb = list_skb->next;

			if (unlikely(!nskb))
				goto err;

			if (unlikely(pskb_trim(nskb, len))) {
				kfree_skb(nskb);
				goto err;
			}

			hsize = skb_end_offset(nskb);
			if (skb_cow_head(nskb, doffset + headroom)) {
				kfree_skb(nskb);
				goto err;
			}

			nskb->truesize += skb_end_offset(nskb) - hsize;
			skb_release_head_state(nskb);
			__skb_push(nskb, doffset);
		} else {
			nskb = __alloc_skb(hsize + doffset + headroom,
					   GFP_ATOMIC, skb_alloc_rx_flag(head_skb),
					   NUMA_NO_NODE);

			if (unlikely(!nskb))
				goto err;

			skb_reserve(nskb, headroom);
			__skb_put(nskb, doffset);
		}

		if (segs)
			tail->next = nskb;
		else
			segs = nskb;
		tail = nskb;

		__copy_skb_header(nskb, head_skb);
		nskb->mac_len = head_skb->mac_len;

		skb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);

		skb_copy_from_linear_data_offset(head_skb, -tnl_hlen,
						 nskb->data - tnl_hlen,
						 doffset + tnl_hlen);

		if (nskb->len == len + doffset)
			goto perform_csum_check;

		if (!sg) {
			nskb->ip_summed = CHECKSUM_NONE;
			nskb->csum = skb_copy_and_csum_bits(head_skb, offset,
							    skb_put(nskb, len),
							    len, 0);
			continue;
		}

		nskb_frag = skb_shinfo(nskb)->frags;

		skb_copy_from_linear_data_offset(head_skb, offset,
						 skb_put(nskb, hsize), hsize);

		skb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &
			SKBTX_SHARED_FRAG;

		while (pos < offset + len) {
			if (i >= nfrags) {
				BUG_ON(skb_headlen(list_skb));

 				i = 0;
 				nfrags = skb_shinfo(list_skb)->nr_frags;
 				frag = skb_shinfo(list_skb)->frags;
				frag_skb = list_skb;
 
 				BUG_ON(!nfrags);
 
				list_skb = list_skb->next;
			}

			if (unlikely(skb_shinfo(nskb)->nr_frags >=
				     MAX_SKB_FRAGS)) {
				net_warn_ratelimited(
					""skb_segment: too many frags: %u %u\n"",
					pos, mss);
 				goto err;
 			}
 
			if (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC)))
				goto err;

 			*nskb_frag = *frag;
 			__skb_frag_ref(nskb_frag);
 			size = skb_frag_size(nskb_frag);

			if (pos < offset) {
				nskb_frag->page_offset += offset - pos;
				skb_frag_size_sub(nskb_frag, offset - pos);
			}

			skb_shinfo(nskb)->nr_frags++;

			if (pos + size <= offset + len) {
				i++;
				frag++;
				pos += size;
			} else {
				skb_frag_size_sub(nskb_frag, pos + size - (offset + len));
				goto skip_fraglist;
			}

			nskb_frag++;
		}

skip_fraglist:
		nskb->data_len = len - hsize;
		nskb->len += nskb->data_len;
		nskb->truesize += nskb->data_len;

perform_csum_check:
		if (!csum) {
			nskb->csum = skb_checksum(nskb, doffset,
						  nskb->len - doffset, 0);
			nskb->ip_summed = CHECKSUM_NONE;
		}
	} while ((offset += len) < head_skb->len);

	return segs;

err:
	kfree_skb_list(segs);
	return ERR_PTR(err);
}
","The `skb_segment` function is designed to segment a given socket buffer (`head_skb`) into smaller buffers based on the Maximum Segment Size (MSS) and network device features. It initializes necessary variables and checks for protocol validity before entering a loop to create new socket buffers (`nskb`) from the original. The function handles both the header and fragment data, ensuring proper memory allocation and checksum calculations. It manages fragmentation by copying data from the original buffer to the new segments while maintaining the integrity of the data structure. If any errors occur during processing, it cleans up and returns an error pointer.","The provided code implements a function that segments a larger data packet into smaller packets based on a specified maximum size and network features. It begins by validating the input and preparing for segmentation. The function iteratively creates new packets, copying data from the original packet while managing headers and fragments. It ensures that each new packet adheres to size constraints and performs necessary checksum calculations for data integrity. If any issues arise during the process, it cleans up allocated resources and returns an error indication, ensuring efficient memory management throughout the segmentation operation.","The vulnerability in the original code arises from the potential access to user memory after the completion of a data transfer, specifically when copying fragments from the original socket buffer. This could lead to security issues, as the code may inadvertently access memory that has been freed or modified by the user. The fix introduces a call to `skb_orphan_frags`, which ensures that the fragments are properly orphaned before they are copied. This change prevents any further access to user memory after the transfer is reported complete, thereby enhancing the security and stability of the segmentation process.","The vulnerability in the original code stems from the risk of accessing user memory after the completion of a data transfer, which could lead to security issues if the memory is modified or freed by the user. This situation arises during the copying of data fragments, where improper handling could result in unintended memory access. The fix addresses this vulnerability by ensuring that the fragments are properly orphaned before any copying occurs. This precaution prevents any further access to user memory after the transfer is reported complete, thereby enhancing the security and integrity of the data handling process.","The vulnerability was fixed by introducing a call to `skb_orphan_frags` before copying the fragments in the updated code. This function ensures that the fragments are orphaned, effectively detaching them from the original socket buffer and preventing any further access to user memory after the transfer is reported complete. By doing this, the code mitigates the risk of accessing potentially invalid or modified memory, thereby enhancing security. This change is particularly important in the context of the `skb_segment` function, which handles the copying of fragments, ensuring safe memory management during the segmentation process.","The vulnerability was addressed by implementing a mechanism to properly detach the data fragments from the original buffer before any copying occurs. This step ensures that the fragments are no longer associated with the user memory, thereby preventing any potential access to memory that could have been modified or freed by the user after the data transfer was reported complete. By ensuring that the fragments are safely managed, the code enhances security and stability during the data handling process, effectively mitigating the risk of unintended memory access and associated vulnerabilities.","CWE-416, CWE-825, CWE-415, CWE-763, CWE-119, CWE-476, CWE-444, CWE-789, CWE-665, CWE-908",Y,1
8,8,180012,180012,,Local,Not required,Complete,CVE-2016-10088,https://www.cvedetails.com/cve/CVE-2016-10088/,CWE-416,Medium,Complete,Complete,,2016-12-30,6.9,"The sg implementation in the Linux kernel through 4.9 does not properly restrict write operations in situations where the KERNEL_DS option is set, which allows local users to read or write to arbitrary kernel memory locations or cause a denial of service (use-after-free) by leveraging access to a /dev/sg device, related to block/bsg.c and drivers/scsi/sg.c.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-9576.",2018-01-04,DoS ,3,https://github.com/torvalds/linux/commit/128394eff343fc6d2f32172f03e24829539c5835,128394eff343fc6d2f32172f03e24829539c5835,"sg_write()/bsg_write() is not fit to be called under KERNEL_DS

Both damn things interpret userland pointers embedded into the payload;
worse, they are actually traversing those.  Leaving aside the bad
API design, this is very much _not_ safe to call with KERNEL_DS.
Bail out early if that happens.

Cc: stable@vger.kernel.org
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",0,block/bsg.c,"{""sha"": ""a57046de2f07f00eae78aaabe9b5e43c1ecc178f"", ""filename"": ""block/bsg.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/128394eff343fc6d2f32172f03e24829539c5835/block/bsg.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/128394eff343fc6d2f32172f03e24829539c5835/block/bsg.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/block/bsg.c?ref=128394eff343fc6d2f32172f03e24829539c5835"", ""patch"": ""@@ -655,6 +655,9 @@ bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n \n \tdprintk(\""%s: write %Zd bytes\\n\"", bd->name, count);\n \n+\tif (unlikely(segment_eq(get_fs(), KERNEL_DS)))\n+\t\treturn -EINVAL;\n+\n \tbsg_set_block(bd, file);\n \n \tbytes_written = 0;""}<_**next**_>{""sha"": ""dbe5b4b95df0d9d317dbdc2261914e4d8771991f"", ""filename"": ""drivers/scsi/sg.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/128394eff343fc6d2f32172f03e24829539c5835/drivers/scsi/sg.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/128394eff343fc6d2f32172f03e24829539c5835/drivers/scsi/sg.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/scsi/sg.c?ref=128394eff343fc6d2f32172f03e24829539c5835"", ""patch"": ""@@ -581,6 +581,9 @@ sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)\n \tsg_io_hdr_t *hp;\n \tunsigned char cmnd[SG_MAX_CDB_SIZE];\n \n+\tif (unlikely(segment_eq(get_fs(), KERNEL_DS)))\n+\t\treturn -EINVAL;\n+\n \tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n \t\treturn -ENXIO;\n \tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,""}","bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
{
	struct bsg_device *bd = file->private_data;
	ssize_t bytes_written;
	int ret;
 
 	dprintk(""%s: write %Zd bytes\n"", bd->name, count);
 
	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
		return -EINVAL;

 	bsg_set_block(bd, file);
 
 	bytes_written = 0;
	ret = __bsg_write(bd, buf, count, &bytes_written,
			  file->f_mode & FMODE_WRITE);

	*ppos = bytes_written;

	/*
	 * return bytes written on non-fatal errors
	 */
	if (!bytes_written || err_block_err(ret))
		bytes_written = ret;

	dprintk(""%s: returning %Zd\n"", bd->name, bytes_written);
	return bytes_written;
}
","bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
{
	struct bsg_device *bd = file->private_data;
	ssize_t bytes_written;
	int ret;
 
 	dprintk(""%s: write %Zd bytes\n"", bd->name, count);
 
 	bsg_set_block(bd, file);
 
 	bytes_written = 0;
	ret = __bsg_write(bd, buf, count, &bytes_written,
			  file->f_mode & FMODE_WRITE);

	*ppos = bytes_written;

	/*
	 * return bytes written on non-fatal errors
	 */
	if (!bytes_written || err_block_err(ret))
		bytes_written = ret;

	dprintk(""%s: returning %Zd\n"", bd->name, bytes_written);
	return bytes_written;
}
",C,"	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
		return -EINVAL;

",,,"@@ -655,6 +655,9 @@ bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
 
 	dprintk(""%s: write %Zd bytes\n"", bd->name, count);
 
+	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
+		return -EINVAL;
+
 	bsg_set_block(bd, file);
 
 	bytes_written = 0;",linux,128394eff343fc6d2f32172f03e24829539c5835,f698cccbc89e33cda4795a375e47daaa3689485e,1,"bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
{
	struct bsg_device *bd = file->private_data;
	ssize_t bytes_written;
	int ret;
 
 	dprintk(""%s: write %Zd bytes\n"", bd->name, count);
 
//fix_flaw_line_below:
//	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
//fix_flaw_line_below:
//		return -EINVAL;
//fix_flaw_line_below:
//
 	bsg_set_block(bd, file);
 
 	bytes_written = 0;
	ret = __bsg_write(bd, buf, count, &bytes_written,
			  file->f_mode & FMODE_WRITE);

	*ppos = bytes_written;

	/*
	 * return bytes written on non-fatal errors
	 */
	if (!bytes_written || err_block_err(ret))
		bytes_written = ret;

	dprintk(""%s: returning %Zd\n"", bd->name, bytes_written);
	return bytes_written;
}
",180012,"bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
{
	struct bsg_device *bd = file->private_data;
	ssize_t bytes_written;
	int ret;
 
 	dprintk(""%s: write %Zd bytes\n"", bd->name, count);
 
 	bsg_set_block(bd, file);
 
 	bytes_written = 0;
	ret = __bsg_write(bd, buf, count, &bytes_written,
			  file->f_mode & FMODE_WRITE);

	*ppos = bytes_written;

	/*
	 * return bytes written on non-fatal errors
	 */
	if (!bytes_written || err_block_err(ret))
		bytes_written = ret;

	dprintk(""%s: returning %Zd\n"", bd->name, bytes_written);
	return bytes_written;
}
","bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
{
	struct bsg_device *bd = file->private_data;
	ssize_t bytes_written;
	int ret;
 
 	dprintk(""%s: write %Zd bytes\n"", bd->name, count);
 
	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
		return -EINVAL;

 	bsg_set_block(bd, file);
 
 	bytes_written = 0;
	ret = __bsg_write(bd, buf, count, &bytes_written,
			  file->f_mode & FMODE_WRITE);

	*ppos = bytes_written;

	/*
	 * return bytes written on non-fatal errors
	 */
	if (!bytes_written || err_block_err(ret))
		bytes_written = ret;

	dprintk(""%s: returning %Zd\n"", bd->name, bytes_written);
	return bytes_written;
}
","The `bsg_write` function is designed to handle write operations for a block device in a Linux kernel module. It takes a file pointer, a user buffer, the number of bytes to write, and a position pointer as parameters. The function retrieves the associated block device from the file's private data, logs the write operation, and sets the block state. It then calls `__bsg_write` to perform the actual write, updating the position pointer with the number of bytes written. Finally, it handles any non-fatal errors by adjusting the return value accordingly and logs the result before returning the number of bytes written.","The provided code implements a function that facilitates writing data to a block device within a Linux kernel module. It begins by logging the amount of data intended for writing and prepares the device for the operation. The function then attempts to execute the write process, tracking the number of bytes successfully written. It updates the position pointer to reflect the new write position and manages any non-fatal errors that may occur during the operation. Finally, it logs the outcome of the write attempt and returns the total number of bytes written, ensuring proper error handling throughout.","The vulnerability in the original code arises from the potential for userland pointers to be processed while operating under the kernel address space (KERNEL_DS), which can lead to unsafe memory access and exploitation. The fixed code addresses this issue by introducing a check that verifies if the current address space is KERNEL_DS using the `segment_eq(get_fs(), KERNEL_DS)` function. If this condition is true, the function immediately returns an error code, effectively preventing any further execution that could compromise system security. This early exit ensures that userland pointers are not mishandled, thus enhancing the safety of the write operation.","The vulnerability in the original code stems from the unsafe handling of userland pointers when the function is executed in kernel address space, which can lead to unauthorized memory access and potential exploitation. The fixed code mitigates this risk by implementing a check that determines if the function is being called under the kernel address space. If this condition is met, the function immediately returns an error, preventing any further processing of userland pointers. This early exit effectively safeguards the system from the dangers associated with traversing userland memory in an inappropriate context, enhancing overall security.","The vulnerability was fixed by adding a check that verifies whether the current address space is KERNEL_DS using the `segment_eq(get_fs(), KERNEL_DS)` function. This check is placed at the beginning of the `bsg_write` function, and if the condition evaluates to true, the function immediately returns `-EINVAL`, effectively preventing any further execution. This early exit ensures that the function does not process userland pointers when operating in kernel space, thereby eliminating the risk of unsafe memory access and protecting the system from potential exploitation associated with traversing userland memory.","The vulnerability was addressed by implementing a safeguard that checks the current execution context to determine if it is operating within the kernel address space. If the context is found to be inappropriate for processing userland pointers, the function immediately returns an error code, preventing any further execution. This proactive measure ensures that the function does not attempt to access or traverse userland memory when it is unsafe to do so, thereby mitigating the risk of unauthorized memory access and enhancing the overall security of the system against potential exploitation.","CWE-119, CWE-787, CWE-416, CWE-476, CWE-125, CWE-120, CWE-122, CWE-200, CWE-789, CWE-134",N,-1
9,9,180013,180013,,Local,Not required,Complete,CVE-2016-10088,https://www.cvedetails.com/cve/CVE-2016-10088/,CWE-416,Medium,Complete,Complete,,2016-12-30,6.9,"The sg implementation in the Linux kernel through 4.9 does not properly restrict write operations in situations where the KERNEL_DS option is set, which allows local users to read or write to arbitrary kernel memory locations or cause a denial of service (use-after-free) by leveraging access to a /dev/sg device, related to block/bsg.c and drivers/scsi/sg.c.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-9576.",2018-01-04,DoS ,3,https://github.com/torvalds/linux/commit/128394eff343fc6d2f32172f03e24829539c5835,128394eff343fc6d2f32172f03e24829539c5835,"sg_write()/bsg_write() is not fit to be called under KERNEL_DS

Both damn things interpret userland pointers embedded into the payload;
worse, they are actually traversing those.  Leaving aside the bad
API design, this is very much _not_ safe to call with KERNEL_DS.
Bail out early if that happens.

Cc: stable@vger.kernel.org
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",0,drivers/scsi/sg.c,"{""sha"": ""a57046de2f07f00eae78aaabe9b5e43c1ecc178f"", ""filename"": ""block/bsg.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/128394eff343fc6d2f32172f03e24829539c5835/block/bsg.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/128394eff343fc6d2f32172f03e24829539c5835/block/bsg.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/block/bsg.c?ref=128394eff343fc6d2f32172f03e24829539c5835"", ""patch"": ""@@ -655,6 +655,9 @@ bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n \n \tdprintk(\""%s: write %Zd bytes\\n\"", bd->name, count);\n \n+\tif (unlikely(segment_eq(get_fs(), KERNEL_DS)))\n+\t\treturn -EINVAL;\n+\n \tbsg_set_block(bd, file);\n \n \tbytes_written = 0;""}<_**next**_>{""sha"": ""dbe5b4b95df0d9d317dbdc2261914e4d8771991f"", ""filename"": ""drivers/scsi/sg.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/128394eff343fc6d2f32172f03e24829539c5835/drivers/scsi/sg.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/128394eff343fc6d2f32172f03e24829539c5835/drivers/scsi/sg.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/scsi/sg.c?ref=128394eff343fc6d2f32172f03e24829539c5835"", ""patch"": ""@@ -581,6 +581,9 @@ sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)\n \tsg_io_hdr_t *hp;\n \tunsigned char cmnd[SG_MAX_CDB_SIZE];\n \n+\tif (unlikely(segment_eq(get_fs(), KERNEL_DS)))\n+\t\treturn -EINVAL;\n+\n \tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n \t\treturn -ENXIO;\n \tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,""}","sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
{
	int mxsize, cmd_size, k;
	int input_size, blocking;
	unsigned char opcode;
	Sg_device *sdp;
	Sg_fd *sfp;
	Sg_request *srp;
	struct sg_header old_hdr;
 	sg_io_hdr_t *hp;
 	unsigned char cmnd[SG_MAX_CDB_SIZE];
 
	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
		return -EINVAL;

 	if ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))
 		return -ENXIO;
 	SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,
				      ""sg_write: count=%d\n"", (int) count));
	if (atomic_read(&sdp->detaching))
		return -ENODEV;
	if (!((filp->f_flags & O_NONBLOCK) ||
	      scsi_block_when_processing_errors(sdp->device)))
		return -ENXIO;

	if (!access_ok(VERIFY_READ, buf, count))
		return -EFAULT;	/* protects following copy_from_user()s + get_user()s */
	if (count < SZ_SG_HEADER)
		return -EIO;
	if (__copy_from_user(&old_hdr, buf, SZ_SG_HEADER))
		return -EFAULT;
	blocking = !(filp->f_flags & O_NONBLOCK);
	if (old_hdr.reply_len < 0)
		return sg_new_write(sfp, filp, buf, count,
				    blocking, 0, 0, NULL);
	if (count < (SZ_SG_HEADER + 6))
		return -EIO;	/* The minimum scsi command length is 6 bytes. */

	if (!(srp = sg_add_request(sfp))) {
		SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sdp,
					      ""sg_write: queue full\n""));
		return -EDOM;
	}
	buf += SZ_SG_HEADER;
	__get_user(opcode, buf);
	if (sfp->next_cmd_len > 0) {
		cmd_size = sfp->next_cmd_len;
		sfp->next_cmd_len = 0;	/* reset so only this write() effected */
	} else {
		cmd_size = COMMAND_SIZE(opcode);	/* based on SCSI command group */
		if ((opcode >= 0xc0) && old_hdr.twelve_byte)
			cmd_size = 12;
	}
	SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sdp,
		""sg_write:   scsi opcode=0x%02x, cmd_size=%d\n"", (int) opcode, cmd_size));
/* Determine buffer size.  */
	input_size = count - cmd_size;
	mxsize = (input_size > old_hdr.reply_len) ? input_size : old_hdr.reply_len;
	mxsize -= SZ_SG_HEADER;
	input_size -= SZ_SG_HEADER;
	if (input_size < 0) {
		sg_remove_request(sfp, srp);
		return -EIO;	/* User did not pass enough bytes for this command. */
	}
	hp = &srp->header;
	hp->interface_id = '\0';	/* indicator of old interface tunnelled */
	hp->cmd_len = (unsigned char) cmd_size;
	hp->iovec_count = 0;
	hp->mx_sb_len = 0;
	if (input_size > 0)
		hp->dxfer_direction = (old_hdr.reply_len > SZ_SG_HEADER) ?
		    SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV;
	else
		hp->dxfer_direction = (mxsize > 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;
	hp->dxfer_len = mxsize;
	if ((hp->dxfer_direction == SG_DXFER_TO_DEV) ||
	    (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV))
		hp->dxferp = (char __user *)buf + cmd_size;
	else
		hp->dxferp = NULL;
	hp->sbp = NULL;
	hp->timeout = old_hdr.reply_len;	/* structure abuse ... */
	hp->flags = input_size;	/* structure abuse ... */
	hp->pack_id = old_hdr.pack_id;
	hp->usr_ptr = NULL;
	if (__copy_from_user(cmnd, buf, cmd_size))
		return -EFAULT;
	/*
	 * SG_DXFER_TO_FROM_DEV is functionally equivalent to SG_DXFER_FROM_DEV,
	 * but is is possible that the app intended SG_DXFER_TO_DEV, because there
	 * is a non-zero input_size, so emit a warning.
	 */
	if (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV) {
		static char cmd[TASK_COMM_LEN];
		if (strcmp(current->comm, cmd)) {
			printk_ratelimited(KERN_WARNING
					   ""sg_write: data in/out %d/%d bytes ""
					   ""for SCSI command 0x%x-- guessing ""
					   ""data in;\n   program %s not setting ""
					   ""count and/or reply_len properly\n"",
					   old_hdr.reply_len - (int)SZ_SG_HEADER,
					   input_size, (unsigned int) cmnd[0],
					   current->comm);
			strcpy(cmd, current->comm);
		}
	}
	k = sg_common_write(sfp, srp, cmnd, sfp->timeout, blocking);
	return (k < 0) ? k : count;
}
","sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
{
	int mxsize, cmd_size, k;
	int input_size, blocking;
	unsigned char opcode;
	Sg_device *sdp;
	Sg_fd *sfp;
	Sg_request *srp;
	struct sg_header old_hdr;
 	sg_io_hdr_t *hp;
 	unsigned char cmnd[SG_MAX_CDB_SIZE];
 
 	if ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))
 		return -ENXIO;
 	SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,
				      ""sg_write: count=%d\n"", (int) count));
	if (atomic_read(&sdp->detaching))
		return -ENODEV;
	if (!((filp->f_flags & O_NONBLOCK) ||
	      scsi_block_when_processing_errors(sdp->device)))
		return -ENXIO;

	if (!access_ok(VERIFY_READ, buf, count))
		return -EFAULT;	/* protects following copy_from_user()s + get_user()s */
	if (count < SZ_SG_HEADER)
		return -EIO;
	if (__copy_from_user(&old_hdr, buf, SZ_SG_HEADER))
		return -EFAULT;
	blocking = !(filp->f_flags & O_NONBLOCK);
	if (old_hdr.reply_len < 0)
		return sg_new_write(sfp, filp, buf, count,
				    blocking, 0, 0, NULL);
	if (count < (SZ_SG_HEADER + 6))
		return -EIO;	/* The minimum scsi command length is 6 bytes. */

	if (!(srp = sg_add_request(sfp))) {
		SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sdp,
					      ""sg_write: queue full\n""));
		return -EDOM;
	}
	buf += SZ_SG_HEADER;
	__get_user(opcode, buf);
	if (sfp->next_cmd_len > 0) {
		cmd_size = sfp->next_cmd_len;
		sfp->next_cmd_len = 0;	/* reset so only this write() effected */
	} else {
		cmd_size = COMMAND_SIZE(opcode);	/* based on SCSI command group */
		if ((opcode >= 0xc0) && old_hdr.twelve_byte)
			cmd_size = 12;
	}
	SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sdp,
		""sg_write:   scsi opcode=0x%02x, cmd_size=%d\n"", (int) opcode, cmd_size));
/* Determine buffer size.  */
	input_size = count - cmd_size;
	mxsize = (input_size > old_hdr.reply_len) ? input_size : old_hdr.reply_len;
	mxsize -= SZ_SG_HEADER;
	input_size -= SZ_SG_HEADER;
	if (input_size < 0) {
		sg_remove_request(sfp, srp);
		return -EIO;	/* User did not pass enough bytes for this command. */
	}
	hp = &srp->header;
	hp->interface_id = '\0';	/* indicator of old interface tunnelled */
	hp->cmd_len = (unsigned char) cmd_size;
	hp->iovec_count = 0;
	hp->mx_sb_len = 0;
	if (input_size > 0)
		hp->dxfer_direction = (old_hdr.reply_len > SZ_SG_HEADER) ?
		    SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV;
	else
		hp->dxfer_direction = (mxsize > 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;
	hp->dxfer_len = mxsize;
	if ((hp->dxfer_direction == SG_DXFER_TO_DEV) ||
	    (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV))
		hp->dxferp = (char __user *)buf + cmd_size;
	else
		hp->dxferp = NULL;
	hp->sbp = NULL;
	hp->timeout = old_hdr.reply_len;	/* structure abuse ... */
	hp->flags = input_size;	/* structure abuse ... */
	hp->pack_id = old_hdr.pack_id;
	hp->usr_ptr = NULL;
	if (__copy_from_user(cmnd, buf, cmd_size))
		return -EFAULT;
	/*
	 * SG_DXFER_TO_FROM_DEV is functionally equivalent to SG_DXFER_FROM_DEV,
	 * but is is possible that the app intended SG_DXFER_TO_DEV, because there
	 * is a non-zero input_size, so emit a warning.
	 */
	if (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV) {
		static char cmd[TASK_COMM_LEN];
		if (strcmp(current->comm, cmd)) {
			printk_ratelimited(KERN_WARNING
					   ""sg_write: data in/out %d/%d bytes ""
					   ""for SCSI command 0x%x-- guessing ""
					   ""data in;\n   program %s not setting ""
					   ""count and/or reply_len properly\n"",
					   old_hdr.reply_len - (int)SZ_SG_HEADER,
					   input_size, (unsigned int) cmnd[0],
					   current->comm);
			strcpy(cmd, current->comm);
		}
	}
	k = sg_common_write(sfp, srp, cmnd, sfp->timeout, blocking);
	return (k < 0) ? k : count;
}
",C,"	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
		return -EINVAL;

",,,"@@ -581,6 +581,9 @@ sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
 	sg_io_hdr_t *hp;
 	unsigned char cmnd[SG_MAX_CDB_SIZE];
 
+	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
+		return -EINVAL;
+
 	if ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))
 		return -ENXIO;
 	SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,",linux,128394eff343fc6d2f32172f03e24829539c5835,f698cccbc89e33cda4795a375e47daaa3689485e,1,"sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
{
	int mxsize, cmd_size, k;
	int input_size, blocking;
	unsigned char opcode;
	Sg_device *sdp;
	Sg_fd *sfp;
	Sg_request *srp;
	struct sg_header old_hdr;
 	sg_io_hdr_t *hp;
 	unsigned char cmnd[SG_MAX_CDB_SIZE];
 
//fix_flaw_line_below:
//	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
//fix_flaw_line_below:
//		return -EINVAL;
//fix_flaw_line_below:
//
 	if ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))
 		return -ENXIO;
 	SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,
				      ""sg_write: count=%d\n"", (int) count));
	if (atomic_read(&sdp->detaching))
		return -ENODEV;
	if (!((filp->f_flags & O_NONBLOCK) ||
	      scsi_block_when_processing_errors(sdp->device)))
		return -ENXIO;

	if (!access_ok(VERIFY_READ, buf, count))
		return -EFAULT;	/* protects following copy_from_user()s + get_user()s */
	if (count < SZ_SG_HEADER)
		return -EIO;
	if (__copy_from_user(&old_hdr, buf, SZ_SG_HEADER))
		return -EFAULT;
	blocking = !(filp->f_flags & O_NONBLOCK);
	if (old_hdr.reply_len < 0)
		return sg_new_write(sfp, filp, buf, count,
				    blocking, 0, 0, NULL);
	if (count < (SZ_SG_HEADER + 6))
		return -EIO;	/* The minimum scsi command length is 6 bytes. */

	if (!(srp = sg_add_request(sfp))) {
		SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sdp,
					      ""sg_write: queue full\n""));
		return -EDOM;
	}
	buf += SZ_SG_HEADER;
	__get_user(opcode, buf);
	if (sfp->next_cmd_len > 0) {
		cmd_size = sfp->next_cmd_len;
		sfp->next_cmd_len = 0;	/* reset so only this write() effected */
	} else {
		cmd_size = COMMAND_SIZE(opcode);	/* based on SCSI command group */
		if ((opcode >= 0xc0) && old_hdr.twelve_byte)
			cmd_size = 12;
	}
	SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sdp,
		""sg_write:   scsi opcode=0x%02x, cmd_size=%d\n"", (int) opcode, cmd_size));
/* Determine buffer size.  */
	input_size = count - cmd_size;
	mxsize = (input_size > old_hdr.reply_len) ? input_size : old_hdr.reply_len;
	mxsize -= SZ_SG_HEADER;
	input_size -= SZ_SG_HEADER;
	if (input_size < 0) {
		sg_remove_request(sfp, srp);
		return -EIO;	/* User did not pass enough bytes for this command. */
	}
	hp = &srp->header;
	hp->interface_id = '\0';	/* indicator of old interface tunnelled */
	hp->cmd_len = (unsigned char) cmd_size;
	hp->iovec_count = 0;
	hp->mx_sb_len = 0;
	if (input_size > 0)
		hp->dxfer_direction = (old_hdr.reply_len > SZ_SG_HEADER) ?
		    SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV;
	else
		hp->dxfer_direction = (mxsize > 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;
	hp->dxfer_len = mxsize;
	if ((hp->dxfer_direction == SG_DXFER_TO_DEV) ||
	    (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV))
		hp->dxferp = (char __user *)buf + cmd_size;
	else
		hp->dxferp = NULL;
	hp->sbp = NULL;
	hp->timeout = old_hdr.reply_len;	/* structure abuse ... */
	hp->flags = input_size;	/* structure abuse ... */
	hp->pack_id = old_hdr.pack_id;
	hp->usr_ptr = NULL;
	if (__copy_from_user(cmnd, buf, cmd_size))
		return -EFAULT;
	/*
	 * SG_DXFER_TO_FROM_DEV is functionally equivalent to SG_DXFER_FROM_DEV,
	 * but is is possible that the app intended SG_DXFER_TO_DEV, because there
	 * is a non-zero input_size, so emit a warning.
	 */
	if (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV) {
		static char cmd[TASK_COMM_LEN];
		if (strcmp(current->comm, cmd)) {
			printk_ratelimited(KERN_WARNING
					   ""sg_write: data in/out %d/%d bytes ""
					   ""for SCSI command 0x%x-- guessing ""
					   ""data in;\n   program %s not setting ""
					   ""count and/or reply_len properly\n"",
					   old_hdr.reply_len - (int)SZ_SG_HEADER,
					   input_size, (unsigned int) cmnd[0],
					   current->comm);
			strcpy(cmd, current->comm);
		}
	}
	k = sg_common_write(sfp, srp, cmnd, sfp->timeout, blocking);
	return (k < 0) ? k : count;
}
",180013,"sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
{
	int mxsize, cmd_size, k;
	int input_size, blocking;
	unsigned char opcode;
	Sg_device *sdp;
	Sg_fd *sfp;
	Sg_request *srp;
	struct sg_header old_hdr;
 	sg_io_hdr_t *hp;
 	unsigned char cmnd[SG_MAX_CDB_SIZE];
 
 	if ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))
 		return -ENXIO;
 	SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,
				      ""sg_write: count=%d\n"", (int) count));
	if (atomic_read(&sdp->detaching))
		return -ENODEV;
	if (!((filp->f_flags & O_NONBLOCK) ||
	      scsi_block_when_processing_errors(sdp->device)))
		return -ENXIO;

	if (!access_ok(VERIFY_READ, buf, count))
		return -EFAULT;	/* protects following copy_from_user()s + get_user()s */
	if (count < SZ_SG_HEADER)
		return -EIO;
	if (__copy_from_user(&old_hdr, buf, SZ_SG_HEADER))
		return -EFAULT;
	blocking = !(filp->f_flags & O_NONBLOCK);
	if (old_hdr.reply_len < 0)
		return sg_new_write(sfp, filp, buf, count,
				    blocking, 0, 0, NULL);
	if (count < (SZ_SG_HEADER + 6))
		return -EIO;	/* The minimum scsi command length is 6 bytes. */

	if (!(srp = sg_add_request(sfp))) {
		SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sdp,
					      ""sg_write: queue full\n""));
		return -EDOM;
	}
	buf += SZ_SG_HEADER;
	__get_user(opcode, buf);
	if (sfp->next_cmd_len > 0) {
		cmd_size = sfp->next_cmd_len;
		sfp->next_cmd_len = 0;	/* reset so only this write() effected */
	} else {
		cmd_size = COMMAND_SIZE(opcode);	/* based on SCSI command group */
		if ((opcode >= 0xc0) && old_hdr.twelve_byte)
			cmd_size = 12;
	}
	SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sdp,
		""sg_write:   scsi opcode=0x%02x, cmd_size=%d\n"", (int) opcode, cmd_size));
/* Determine buffer size.  */
	input_size = count - cmd_size;
	mxsize = (input_size > old_hdr.reply_len) ? input_size : old_hdr.reply_len;
	mxsize -= SZ_SG_HEADER;
	input_size -= SZ_SG_HEADER;
	if (input_size < 0) {
		sg_remove_request(sfp, srp);
		return -EIO;	/* User did not pass enough bytes for this command. */
	}
	hp = &srp->header;
	hp->interface_id = '\0';	/* indicator of old interface tunnelled */
	hp->cmd_len = (unsigned char) cmd_size;
	hp->iovec_count = 0;
	hp->mx_sb_len = 0;
	if (input_size > 0)
		hp->dxfer_direction = (old_hdr.reply_len > SZ_SG_HEADER) ?
		    SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV;
	else
		hp->dxfer_direction = (mxsize > 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;
	hp->dxfer_len = mxsize;
	if ((hp->dxfer_direction == SG_DXFER_TO_DEV) ||
	    (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV))
		hp->dxferp = (char __user *)buf + cmd_size;
	else
		hp->dxferp = NULL;
	hp->sbp = NULL;
	hp->timeout = old_hdr.reply_len;	/* structure abuse ... */
	hp->flags = input_size;	/* structure abuse ... */
	hp->pack_id = old_hdr.pack_id;
	hp->usr_ptr = NULL;
	if (__copy_from_user(cmnd, buf, cmd_size))
		return -EFAULT;
	/*
	 * SG_DXFER_TO_FROM_DEV is functionally equivalent to SG_DXFER_FROM_DEV,
	 * but is is possible that the app intended SG_DXFER_TO_DEV, because there
	 * is a non-zero input_size, so emit a warning.
	 */
	if (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV) {
		static char cmd[TASK_COMM_LEN];
		if (strcmp(current->comm, cmd)) {
			printk_ratelimited(KERN_WARNING
					   ""sg_write: data in/out %d/%d bytes ""
					   ""for SCSI command 0x%x-- guessing ""
					   ""data in;\n   program %s not setting ""
					   ""count and/or reply_len properly\n"",
					   old_hdr.reply_len - (int)SZ_SG_HEADER,
					   input_size, (unsigned int) cmnd[0],
					   current->comm);
			strcpy(cmd, current->comm);
		}
	}
	k = sg_common_write(sfp, srp, cmnd, sfp->timeout, blocking);
	return (k < 0) ? k : count;
}
","sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
{
	int mxsize, cmd_size, k;
	int input_size, blocking;
	unsigned char opcode;
	Sg_device *sdp;
	Sg_fd *sfp;
	Sg_request *srp;
	struct sg_header old_hdr;
 	sg_io_hdr_t *hp;
 	unsigned char cmnd[SG_MAX_CDB_SIZE];
 
	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
		return -EINVAL;

 	if ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))
 		return -ENXIO;
 	SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,
				      ""sg_write: count=%d\n"", (int) count));
	if (atomic_read(&sdp->detaching))
		return -ENODEV;
	if (!((filp->f_flags & O_NONBLOCK) ||
	      scsi_block_when_processing_errors(sdp->device)))
		return -ENXIO;

	if (!access_ok(VERIFY_READ, buf, count))
		return -EFAULT;	/* protects following copy_from_user()s + get_user()s */
	if (count < SZ_SG_HEADER)
		return -EIO;
	if (__copy_from_user(&old_hdr, buf, SZ_SG_HEADER))
		return -EFAULT;
	blocking = !(filp->f_flags & O_NONBLOCK);
	if (old_hdr.reply_len < 0)
		return sg_new_write(sfp, filp, buf, count,
				    blocking, 0, 0, NULL);
	if (count < (SZ_SG_HEADER + 6))
		return -EIO;	/* The minimum scsi command length is 6 bytes. */

	if (!(srp = sg_add_request(sfp))) {
		SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sdp,
					      ""sg_write: queue full\n""));
		return -EDOM;
	}
	buf += SZ_SG_HEADER;
	__get_user(opcode, buf);
	if (sfp->next_cmd_len > 0) {
		cmd_size = sfp->next_cmd_len;
		sfp->next_cmd_len = 0;	/* reset so only this write() effected */
	} else {
		cmd_size = COMMAND_SIZE(opcode);	/* based on SCSI command group */
		if ((opcode >= 0xc0) && old_hdr.twelve_byte)
			cmd_size = 12;
	}
	SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sdp,
		""sg_write:   scsi opcode=0x%02x, cmd_size=%d\n"", (int) opcode, cmd_size));
/* Determine buffer size.  */
	input_size = count - cmd_size;
	mxsize = (input_size > old_hdr.reply_len) ? input_size : old_hdr.reply_len;
	mxsize -= SZ_SG_HEADER;
	input_size -= SZ_SG_HEADER;
	if (input_size < 0) {
		sg_remove_request(sfp, srp);
		return -EIO;	/* User did not pass enough bytes for this command. */
	}
	hp = &srp->header;
	hp->interface_id = '\0';	/* indicator of old interface tunnelled */
	hp->cmd_len = (unsigned char) cmd_size;
	hp->iovec_count = 0;
	hp->mx_sb_len = 0;
	if (input_size > 0)
		hp->dxfer_direction = (old_hdr.reply_len > SZ_SG_HEADER) ?
		    SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV;
	else
		hp->dxfer_direction = (mxsize > 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;
	hp->dxfer_len = mxsize;
	if ((hp->dxfer_direction == SG_DXFER_TO_DEV) ||
	    (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV))
		hp->dxferp = (char __user *)buf + cmd_size;
	else
		hp->dxferp = NULL;
	hp->sbp = NULL;
	hp->timeout = old_hdr.reply_len;	/* structure abuse ... */
	hp->flags = input_size;	/* structure abuse ... */
	hp->pack_id = old_hdr.pack_id;
	hp->usr_ptr = NULL;
	if (__copy_from_user(cmnd, buf, cmd_size))
		return -EFAULT;
	/*
	 * SG_DXFER_TO_FROM_DEV is functionally equivalent to SG_DXFER_FROM_DEV,
	 * but is is possible that the app intended SG_DXFER_TO_DEV, because there
	 * is a non-zero input_size, so emit a warning.
	 */
	if (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV) {
		static char cmd[TASK_COMM_LEN];
		if (strcmp(current->comm, cmd)) {
			printk_ratelimited(KERN_WARNING
					   ""sg_write: data in/out %d/%d bytes ""
					   ""for SCSI command 0x%x-- guessing ""
					   ""data in;\n   program %s not setting ""
					   ""count and/or reply_len properly\n"",
					   old_hdr.reply_len - (int)SZ_SG_HEADER,
					   input_size, (unsigned int) cmnd[0],
					   current->comm);
			strcpy(cmd, current->comm);
		}
	}
	k = sg_common_write(sfp, srp, cmnd, sfp->timeout, blocking);
	return (k < 0) ? k : count;
}
","The `sg_write` function is a kernel-level routine designed to handle write operations for SCSI generic (SG) devices in a Linux environment. It begins by validating the file pointer and device state, ensuring the operation is permissible based on flags and device conditions. The function checks the user-provided buffer for correctness and extracts a command header, determining the size of the SCSI command. It prepares a request structure, setting parameters like data transfer direction and length, and copies the command from user space. Finally, it invokes `sg_common_write` to execute the SCSI command, returning the number of bytes processed or an error code if the operation fails.","The provided code implements a function that manages write operations for SCSI devices in a Linux kernel environment. It begins by validating the file and device states, ensuring the operation is allowed based on specific conditions. The function checks the user-provided buffer for correctness and extracts a command header to determine the command size. It prepares a request structure with parameters like data transfer direction and length, then copies the command from user space. Finally, it executes the SCSI command and returns the number of bytes processed or an error code if the operation encounters issues.","The vulnerability in the original code arises from the potential for userland pointers to be processed while the function is called under the kernel address space (KERNEL_DS). This situation can lead to unsafe memory access, as the function traverses user-provided data without proper validation, risking exploitation through invalid memory references. The fix introduces a check using `unlikely(segment_eq(get_fs(), KERNEL_DS))`, which ensures that the function exits early with an error if it detects that it is being called in the kernel address space, thereby preventing unsafe operations on userland pointers and enhancing overall security.","The vulnerability in the original code stems from the unsafe handling of userland pointers when the function is invoked in the kernel address space, which can lead to unauthorized memory access and potential exploitation. This occurs because the function processes and traverses user-provided data without adequate checks, risking access to invalid memory locations. The fix addresses this issue by implementing an early exit mechanism that detects when the function is called in the kernel address space, thereby preventing any operations that could compromise system integrity and ensuring that userland pointers are not processed inappropriately.","The vulnerability was fixed by adding a check at the beginning of the function that verifies if the current address space is the kernel address space using `unlikely(segment_eq(get_fs(), KERNEL_DS))`. If this condition is true, the function immediately returns an error code, specifically `-EINVAL`, preventing any further processing of userland pointers. This early exit ensures that the function does not attempt to interpret or traverse userland data when it is not safe to do so, thereby mitigating the risk of unauthorized memory access and enhancing the overall security of the code.","The vulnerability was addressed by implementing a safeguard that checks whether the function is being executed in the kernel address space. If this condition is met, the function immediately exits with an error code, preventing any further processing of userland pointers. This early termination effectively blocks any unsafe operations that could lead to unauthorized memory access or exploitation. By ensuring that the function does not handle userland data inappropriately, the fix enhances the overall security and stability of the system, mitigating the risks associated with the original design flaw.","CWE-269,CWE-264,CWE-426,CWE-284,CWE-119,CWE-200,CWE-285,CWE-266,CWE-20,CWE-787",N,-1
10,10,180017,180017,,Local,Not required,Complete,CVE-2016-9794,https://www.cvedetails.com/cve/CVE-2016-9794/,CWE-416,Low,Complete,Complete,,2016-12-28,7.2,Race condition in the snd_pcm_period_elapsed function in sound/core/pcm_lib.c in the ALSA subsystem in the Linux kernel before 4.7 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted SNDRV_PCM_TRIGGER_START command.,2018-01-04,DoS ,1,https://github.com/torvalds/linux/commit/3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4,3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4,"ALSA: pcm : Call kill_fasync() in stream lock

Currently kill_fasync() is called outside the stream lock in
snd_pcm_period_elapsed().  This is potentially racy, since the stream
may get released even during the irq handler is running.  Although
snd_pcm_release_substream() calls snd_pcm_drop(), this doesn't
guarantee that the irq handler finishes, thus the kill_fasync() call
outside the stream spin lock may be invoked after the substream is
detached, as recently reported by KASAN.

As a quick workaround, move kill_fasync() call inside the stream
lock.  The fasync is rarely used interface, so this shouldn't have a
big impact from the performance POV.

Ideally, we should implement some sync mechanism for the proper finish
of stream and irq handler.  But this oneliner should suffice for most
cases, so far.

Reported-by: Baozeng Ding <sploving1@gmail.com>
Signed-off-by: Takashi Iwai <tiwai@suse.de>",1,sound/core/pcm_lib.c,"{""sha"": ""0aca39762ed0ec981fb4f612741010a255a97587"", ""filename"": ""sound/core/pcm_lib.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4/sound/core/pcm_lib.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4/sound/core/pcm_lib.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/sound/core/pcm_lib.c?ref=3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4"", ""patch"": ""@@ -1886,8 +1886,8 @@ void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n \t\tsnd_timer_interrupt(substream->timer, 1);\n #endif\n  _end:\n-\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n \tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n+\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n }\n \n EXPORT_SYMBOL(snd_pcm_period_elapsed);""}","void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
{
	struct snd_pcm_runtime *runtime;
	unsigned long flags;

	if (PCM_RUNTIME_CHECK(substream))
		return;
	runtime = substream->runtime;

	snd_pcm_stream_lock_irqsave(substream, flags);
	if (!snd_pcm_running(substream) ||
	    snd_pcm_update_hw_ptr0(substream, 1) < 0)
		goto _end;

#ifdef CONFIG_SND_PCM_TIMER
	if (substream->timer_running)
 		snd_timer_interrupt(substream->timer, 1);
 #endif
  _end:
 	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
	snd_pcm_stream_unlock_irqrestore(substream, flags);
 }
","void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
{
	struct snd_pcm_runtime *runtime;
	unsigned long flags;

	if (PCM_RUNTIME_CHECK(substream))
		return;
	runtime = substream->runtime;

	snd_pcm_stream_lock_irqsave(substream, flags);
	if (!snd_pcm_running(substream) ||
	    snd_pcm_update_hw_ptr0(substream, 1) < 0)
		goto _end;

#ifdef CONFIG_SND_PCM_TIMER
	if (substream->timer_running)
 		snd_timer_interrupt(substream->timer, 1);
 #endif
  _end:
	snd_pcm_stream_unlock_irqrestore(substream, flags);
 	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
 }
",C,"	snd_pcm_stream_unlock_irqrestore(substream, flags);
","	snd_pcm_stream_unlock_irqrestore(substream, flags);
",,"@@ -1886,8 +1886,8 @@ void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
 		snd_timer_interrupt(substream->timer, 1);
 #endif
  _end:
-	snd_pcm_stream_unlock_irqrestore(substream, flags);
 	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
+	snd_pcm_stream_unlock_irqrestore(substream, flags);
 }
 
 EXPORT_SYMBOL(snd_pcm_period_elapsed);",linux,3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4,fa44b7ec9bc4115513e59f31da1167166bd6346a,1,"void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
{
	struct snd_pcm_runtime *runtime;
	unsigned long flags;

	if (PCM_RUNTIME_CHECK(substream))
		return;
	runtime = substream->runtime;

	snd_pcm_stream_lock_irqsave(substream, flags);
	if (!snd_pcm_running(substream) ||
	    snd_pcm_update_hw_ptr0(substream, 1) < 0)
		goto _end;

#ifdef CONFIG_SND_PCM_TIMER
	if (substream->timer_running)
 		snd_timer_interrupt(substream->timer, 1);
 #endif
  _end:
//flaw_line_below:
	snd_pcm_stream_unlock_irqrestore(substream, flags);
 	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
//fix_flaw_line_below:
//	snd_pcm_stream_unlock_irqrestore(substream, flags);
 }
",180017,"void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
{
	struct snd_pcm_runtime *runtime;
	unsigned long flags;

	if (PCM_RUNTIME_CHECK(substream))
		return;
	runtime = substream->runtime;

	snd_pcm_stream_lock_irqsave(substream, flags);
	if (!snd_pcm_running(substream) ||
	    snd_pcm_update_hw_ptr0(substream, 1) < 0)
		goto _end;

#ifdef CONFIG_SND_PCM_TIMER
	if (substream->timer_running)
 		snd_timer_interrupt(substream->timer, 1);
 #endif
  _end:
	snd_pcm_stream_unlock_irqrestore(substream, flags);
 	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
 }
","void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
{
	struct snd_pcm_runtime *runtime;
	unsigned long flags;

	if (PCM_RUNTIME_CHECK(substream))
		return;
	runtime = substream->runtime;

	snd_pcm_stream_lock_irqsave(substream, flags);
	if (!snd_pcm_running(substream) ||
	    snd_pcm_update_hw_ptr0(substream, 1) < 0)
		goto _end;

#ifdef CONFIG_SND_PCM_TIMER
	if (substream->timer_running)
 		snd_timer_interrupt(substream->timer, 1);
 #endif
  _end:
 	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
	snd_pcm_stream_unlock_irqrestore(substream, flags);
 }
","The function `snd_pcm_period_elapsed` is designed to handle the event when a period of audio data has been processed in a PCM (Pulse Code Modulation) audio stream. It first checks if the PCM runtime is valid for the given substream; if not, it exits early. The function then locks the stream to ensure thread safety while checking if the PCM is running and updating the hardware pointer. If the stream is active and the pointer update is successful, it may trigger a timer interrupt if the PCM timer is enabled. Finally, it unlocks the stream and sends a signal to any processes waiting for audio data availability.","The provided code defines a function that manages the event when a segment of audio data has been processed in an audio stream. It begins by verifying the validity of the audio stream and exits if it is not valid. The function then locks the stream to ensure safe access while checking if the audio playback is active and updating the position of the audio data. If playback is ongoing and the update is successful, it may trigger a timer interrupt if a timer is active. Finally, it unlocks the stream and notifies any waiting processes about the availability of new audio data.","The vulnerability in the original code arises from calling the `kill_fasync()` function outside the stream lock, which creates a race condition. This situation occurs because the audio stream may be released while the interrupt handler is still executing, potentially leading to `kill_fasync()` being invoked after the substream has been detached. The fix involves moving the `kill_fasync()` call inside the stream lock, ensuring that it is executed while the stream is protected, thus preventing any race conditions. This adjustment enhances the safety of the code by ensuring that the substream remains valid during the notification process.","The vulnerability in the original code stems from the potential for a race condition, as a specific function was called outside of a protective lock. This could allow the audio stream to be released while an interrupt handler was still executing, leading to the possibility of invoking the function after the stream had already been detached. The fix involved relocating this function call inside the protective lock, ensuring that it is executed only when the stream is secure and valid. This adjustment mitigates the risk of accessing invalid memory, thereby enhancing the overall stability and safety of the code.","The vulnerability was fixed by moving the `kill_fasync()` function call inside the stream lock, specifically after the check for the stream's validity and before unlocking it. In the original code, `kill_fasync()` was called outside the stream lock, which could lead to a race condition if the stream was released while the interrupt handler was running. By placing `kill_fasync()` within the locked section, the code ensures that the substream remains valid during the notification process, thus preventing any potential access to a detached substream and enhancing the overall safety of the audio handling mechanism.","The vulnerability was addressed by relocating a critical function call into a section of the code that ensures the audio stream is protected by a lock. This change prevents the possibility of accessing the stream after it has been released, which could occur if the function was executed while the interrupt handler was still running. By ensuring that the function is called only when the stream is securely locked, the fix mitigates the risk of race conditions and invalid memory access, thereby enhancing the stability and safety of the audio processing mechanism.","CWE-366, CWE-367, CWE-667, CWE-664, CWE-362, CWE-666, CWE-364, CWE-365, CWE-833, CWE-609",N,-1
11,11,180030,180030,,Local,Not required,Complete,CVE-2016-9576,https://www.cvedetails.com/cve/CVE-2016-9576/,CWE-416,Low,Complete,Complete,,2016-12-28,7.2,"The blk_rq_map_user_iov function in block/blk-map.c in the Linux kernel before 4.8.14 does not properly restrict the type of iterator, which allows local users to read or write to arbitrary kernel memory locations or cause a denial of service (use-after-free) by leveraging access to a /dev/sg device.",2018-01-04,DoS ,4,https://github.com/torvalds/linux/commit/a0ac402cfcdc904f9772e1762b3fda112dcc56a0,a0ac402cfcdc904f9772e1762b3fda112dcc56a0,"Don't feed anything but regular iovec's to blk_rq_map_user_iov

In theory we could map other things, but there's a reason that function
is called ""user_iov"".  Using anything else (like splice can do) just
confuses it.

Reported-and-tested-by: Johannes Thumshirn <jthumshirn@suse.de>
Cc: Al Viro <viro@ZenIV.linux.org.uk>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,block/blk-map.c,"{""sha"": ""27fd8d92892d47e3478d9bcf3e1294a8eb28da89"", ""filename"": ""block/blk-map.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/a0ac402cfcdc904f9772e1762b3fda112dcc56a0/block/blk-map.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a0ac402cfcdc904f9772e1762b3fda112dcc56a0/block/blk-map.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/block/blk-map.c?ref=a0ac402cfcdc904f9772e1762b3fda112dcc56a0"", ""patch"": ""@@ -118,6 +118,9 @@ int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n \tstruct iov_iter i;\n \tint ret;\n \n+\tif (!iter_is_iovec(iter))\n+\t\tgoto fail;\n+\n \tif (map_data)\n \t\tcopy = true;\n \telse if (iov_iter_alignment(iter) & align)\n@@ -140,6 +143,7 @@ int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n \n unmap_rq:\n \t__blk_rq_unmap_user(bio);\n+fail:\n \trq->bio = NULL;\n \treturn -EINVAL;\n }""}","int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,
			struct rq_map_data *map_data,
			const struct iov_iter *iter, gfp_t gfp_mask)
{
	bool copy = false;
	unsigned long align = q->dma_pad_mask | queue_dma_alignment(q);
	struct bio *bio = NULL;
 	struct iov_iter i;
 	int ret;
 
	if (!iter_is_iovec(iter))
		goto fail;

 	if (map_data)
 		copy = true;
 	else if (iov_iter_alignment(iter) & align)
		copy = true;
	else if (queue_virt_boundary(q))
		copy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);

	i = *iter;
	do {
		ret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);
		if (ret)
			goto unmap_rq;
		if (!bio)
			bio = rq->bio;
	} while (iov_iter_count(&i));

	if (!bio_flagged(bio, BIO_USER_MAPPED))
		rq->cmd_flags |= REQ_COPY_USER;
	return 0;
 
 unmap_rq:
 	__blk_rq_unmap_user(bio);
fail:
 	rq->bio = NULL;
 	return -EINVAL;
 }
","int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,
			struct rq_map_data *map_data,
			const struct iov_iter *iter, gfp_t gfp_mask)
{
	bool copy = false;
	unsigned long align = q->dma_pad_mask | queue_dma_alignment(q);
	struct bio *bio = NULL;
 	struct iov_iter i;
 	int ret;
 
 	if (map_data)
 		copy = true;
 	else if (iov_iter_alignment(iter) & align)
		copy = true;
	else if (queue_virt_boundary(q))
		copy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);

	i = *iter;
	do {
		ret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);
		if (ret)
			goto unmap_rq;
		if (!bio)
			bio = rq->bio;
	} while (iov_iter_count(&i));

	if (!bio_flagged(bio, BIO_USER_MAPPED))
		rq->cmd_flags |= REQ_COPY_USER;
	return 0;
 
 unmap_rq:
 	__blk_rq_unmap_user(bio);
 	rq->bio = NULL;
 	return -EINVAL;
 }
",C,"	if (!iter_is_iovec(iter))
		goto fail;

fail:
",,,"@@ -118,6 +118,9 @@ int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,
 	struct iov_iter i;
 	int ret;
 
+	if (!iter_is_iovec(iter))
+		goto fail;
+
 	if (map_data)
 		copy = true;
 	else if (iov_iter_alignment(iter) & align)
@@ -140,6 +143,7 @@ int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,
 
 unmap_rq:
 	__blk_rq_unmap_user(bio);
+fail:
 	rq->bio = NULL;
 	return -EINVAL;
 }",linux,a0ac402cfcdc904f9772e1762b3fda112dcc56a0,bc3913a5378cd0ddefd1dfec6917cc12eb23a946,1,"int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,
			struct rq_map_data *map_data,
			const struct iov_iter *iter, gfp_t gfp_mask)
{
	bool copy = false;
	unsigned long align = q->dma_pad_mask | queue_dma_alignment(q);
	struct bio *bio = NULL;
 	struct iov_iter i;
 	int ret;
 
//fix_flaw_line_below:
//	if (!iter_is_iovec(iter))
//fix_flaw_line_below:
//		goto fail;
//fix_flaw_line_below:
//
 	if (map_data)
 		copy = true;
 	else if (iov_iter_alignment(iter) & align)
		copy = true;
	else if (queue_virt_boundary(q))
		copy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);

	i = *iter;
	do {
		ret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);
		if (ret)
			goto unmap_rq;
		if (!bio)
			bio = rq->bio;
	} while (iov_iter_count(&i));

	if (!bio_flagged(bio, BIO_USER_MAPPED))
		rq->cmd_flags |= REQ_COPY_USER;
	return 0;
 
 unmap_rq:
 	__blk_rq_unmap_user(bio);
//fix_flaw_line_below:
//fail:
 	rq->bio = NULL;
 	return -EINVAL;
 }
",180030,"int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,
			struct rq_map_data *map_data,
			const struct iov_iter *iter, gfp_t gfp_mask)
{
	bool copy = false;
	unsigned long align = q->dma_pad_mask | queue_dma_alignment(q);
	struct bio *bio = NULL;
 	struct iov_iter i;
 	int ret;
 
 	if (map_data)
 		copy = true;
 	else if (iov_iter_alignment(iter) & align)
		copy = true;
	else if (queue_virt_boundary(q))
		copy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);

	i = *iter;
	do {
		ret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);
		if (ret)
			goto unmap_rq;
		if (!bio)
			bio = rq->bio;
	} while (iov_iter_count(&i));

	if (!bio_flagged(bio, BIO_USER_MAPPED))
		rq->cmd_flags |= REQ_COPY_USER;
	return 0;
 
 unmap_rq:
 	__blk_rq_unmap_user(bio);
 	rq->bio = NULL;
 	return -EINVAL;
 }
","int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,
			struct rq_map_data *map_data,
			const struct iov_iter *iter, gfp_t gfp_mask)
{
	bool copy = false;
	unsigned long align = q->dma_pad_mask | queue_dma_alignment(q);
	struct bio *bio = NULL;
 	struct iov_iter i;
 	int ret;
 
	if (!iter_is_iovec(iter))
		goto fail;

 	if (map_data)
 		copy = true;
 	else if (iov_iter_alignment(iter) & align)
		copy = true;
	else if (queue_virt_boundary(q))
		copy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);

	i = *iter;
	do {
		ret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);
		if (ret)
			goto unmap_rq;
		if (!bio)
			bio = rq->bio;
	} while (iov_iter_count(&i));

	if (!bio_flagged(bio, BIO_USER_MAPPED))
		rq->cmd_flags |= REQ_COPY_USER;
	return 0;
 
 unmap_rq:
 	__blk_rq_unmap_user(bio);
fail:
 	rq->bio = NULL;
 	return -EINVAL;
 }
","The function `blk_rq_map_user_iov` is designed to map user-space I/O vectors to a block request in a specified request queue. It first checks if the mapping requires copying based on the provided `map_data` and alignment constraints. If copying is necessary, it prepares to map the user I/O vectors using the `__blk_rq_map_user_iov` function, iterating through the I/O vector until all data is processed. If successful, it sets the appropriate command flags for the request. In case of an error during mapping, it unmaps any previously mapped user data and returns an error code, ensuring proper resource management.","The code defines a function that maps user-space input/output vectors to a block request within a specified request queue. It determines whether the mapping requires copying based on certain conditions related to alignment and the presence of mapping data. The function iterates through the user I/O vectors, attempting to map them to the request. If the mapping is successful, it updates the request's command flags accordingly. In the event of an error during the mapping process, it ensures that any previously mapped data is properly unallocated and returns an error code, maintaining resource integrity.","The vulnerability in the original code stemmed from the lack of validation for the input iterator, allowing non-standard input types to be processed by the mapping function, which could lead to undefined behavior or security issues. The fix introduced a check using `iter_is_iovec(iter)` to ensure that only regular I/O vectors are passed to the mapping function. If the check fails, the code jumps to a failure handling section, preventing any further processing and ensuring that only valid user-space I/O vectors are handled, thus maintaining the integrity and security of the mapping operation.","The vulnerability in the original code arose from the absence of input validation, allowing non-standard input types to be processed, which could lead to unexpected behavior or security risks. This lack of restriction meant that the function could potentially handle data formats that it was not designed for, creating confusion and instability. The fix implemented a validation check to ensure that only standard user-space input types are accepted. If the input does not meet this criterion, the code safely exits before any further processing occurs, thereby enhancing the robustness and security of the mapping operation.","The vulnerability was fixed by introducing a validation check at the beginning of the function using `iter_is_iovec(iter)`. This check ensures that only regular I/O vectors are processed by the mapping function, preventing any non-standard input types from being passed, which could lead to confusion and potential security issues. If the input fails this validation, the code immediately jumps to the failure handling section, bypassing any further processing. This change effectively restricts the function to handle only valid user-space I/O vectors, thereby enhancing the overall safety and reliability of the mapping operation.","The vulnerability was addressed by adding a validation step to ensure that only standard user-space input types are accepted for processing. This check prevents the function from handling any non-standard or unexpected data formats, which could lead to confusion or security risks. If the input does not meet the required criteria, the code safely exits before any further actions are taken, effectively mitigating the risk of undefined behavior. This enhancement ensures that the function operates within its intended parameters, thereby improving the overall security and stability of the mapping operation.","CWE-20, CWE-74, CWE-707, CWE-116, CWE-138, CWE-502, CWE-915, CWE-94, CWE-134, CWE-22",N,-1
12,12,180071,180071,,Remote,Not required,Complete,CVE-2016-9120,https://www.cvedetails.com/cve/CVE-2016-9120/,CWE-416,Medium,Complete,Complete,,2016-12-08,9.3,Race condition in the ion_ioctl function in drivers/staging/android/ion/ion.c in the Linux kernel before 4.6 allows local users to gain privileges or cause a denial of service (use-after-free) by calling ION_IOC_FREE on two CPUs at the same time.,2016-12-09,DoS +Priv ,8,https://github.com/torvalds/linux/commit/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,"staging/android/ion : fix a race condition in the ion driver

There is a use-after-free problem in the ion driver.
This is caused by a race condition in the ion_ioctl()
function.

A handle has ref count of 1 and two tasks on different
cpus calls ION_IOC_FREE simultaneously.

cpu 0                                   cpu 1
-------------------------------------------------------
ion_handle_get_by_id()
(ref == 2)
                            ion_handle_get_by_id()
                            (ref == 3)

ion_free()
(ref == 2)

ion_handle_put()
(ref == 1)

                            ion_free()
                            (ref == 0 so ion_handle_destroy() is
                            called
                            and the handle is freed.)

                            ion_handle_put() is called and it
                            decreases the slub's next free pointer

The problem is detected as an unaligned access in the
spin lock functions since it uses load exclusive
 instruction. In some cases it corrupts the slub's
free pointer which causes a mis-aligned access to the
next free pointer.(kmalloc returns a pointer like
ffffc0745b4580aa). And it causes lots of other
hard-to-debug problems.

This symptom is caused since the first member in the
ion_handle structure is the reference count and the
ion driver decrements the reference after it has been
freed.

To fix this problem client->lock mutex is extended
to protect all the codes that uses the handle.

Signed-off-by: Eun Taik Lee <eun.taik.lee@samsung.com>
Reviewed-by: Laura Abbott <labbott@redhat.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",4,drivers/staging/android/ion/ion.c,"{""sha"": ""33b390e7ea31174558dd95e5da961a61464999e3"", ""filename"": ""drivers/staging/android/ion/ion.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 13, ""changes"": 55, ""blob_url"": ""https://github.com/torvalds/linux/blob/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7/drivers/staging/android/ion/ion.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7/drivers/staging/android/ion/ion.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/staging/android/ion/ion.c?ref=9590232bb4f4cc824f3425a6e1349afbe6d6d2b7"", ""patch"": ""@@ -387,13 +387,22 @@ static void ion_handle_get(struct ion_handle *handle)\n \tkref_get(&handle->ref);\n }\n \n-static int ion_handle_put(struct ion_handle *handle)\n+static int ion_handle_put_nolock(struct ion_handle *handle)\n+{\n+\tint ret;\n+\n+\tret = kref_put(&handle->ref, ion_handle_destroy);\n+\n+\treturn ret;\n+}\n+\n+int ion_handle_put(struct ion_handle *handle)\n {\n \tstruct ion_client *client = handle->client;\n \tint ret;\n \n \tmutex_lock(&client->lock);\n-\tret = kref_put(&handle->ref, ion_handle_destroy);\n+\tret = ion_handle_put_nolock(handle);\n \tmutex_unlock(&client->lock);\n \n \treturn ret;\n@@ -417,20 +426,30 @@ static struct ion_handle *ion_handle_lookup(struct ion_client *client,\n \treturn ERR_PTR(-EINVAL);\n }\n \n-static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\n+static struct ion_handle *ion_handle_get_by_id_nolock(struct ion_client *client,\n \t\t\t\t\t\tint id)\n {\n \tstruct ion_handle *handle;\n \n-\tmutex_lock(&client->lock);\n \thandle = idr_find(&client->idr, id);\n \tif (handle)\n \t\tion_handle_get(handle);\n-\tmutex_unlock(&client->lock);\n \n \treturn handle ? handle : ERR_PTR(-EINVAL);\n }\n \n+struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\n+\t\t\t\t\t\tint id)\n+{\n+\tstruct ion_handle *handle;\n+\n+\tmutex_lock(&client->lock);\n+\thandle = ion_handle_get_by_id_nolock(client, id);\n+\tmutex_unlock(&client->lock);\n+\n+\treturn handle;\n+}\n+\n static bool ion_handle_validate(struct ion_client *client,\n \t\t\t\tstruct ion_handle *handle)\n {\n@@ -532,22 +551,28 @@ struct ion_handle *ion_alloc(struct ion_client *client, size_t len,\n }\n EXPORT_SYMBOL(ion_alloc);\n \n-void ion_free(struct ion_client *client, struct ion_handle *handle)\n+static void ion_free_nolock(struct ion_client *client, struct ion_handle *handle)\n {\n \tbool valid_handle;\n \n \tBUG_ON(client != handle->client);\n \n-\tmutex_lock(&client->lock);\n \tvalid_handle = ion_handle_validate(client, handle);\n \n \tif (!valid_handle) {\n \t\tWARN(1, \""%s: invalid handle passed to free.\\n\"", __func__);\n-\t\tmutex_unlock(&client->lock);\n \t\treturn;\n \t}\n+\tion_handle_put_nolock(handle);\n+}\n+\n+void ion_free(struct ion_client *client, struct ion_handle *handle)\n+{\n+\tBUG_ON(client != handle->client);\n+\n+\tmutex_lock(&client->lock);\n+\tion_free_nolock(client, handle);\n \tmutex_unlock(&client->lock);\n-\tion_handle_put(handle);\n }\n EXPORT_SYMBOL(ion_free);\n \n@@ -1332,11 +1357,15 @@ static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n \t{\n \t\tstruct ion_handle *handle;\n \n-\t\thandle = ion_handle_get_by_id(client, data.handle.handle);\n-\t\tif (IS_ERR(handle))\n+\t\tmutex_lock(&client->lock);\n+\t\thandle = ion_handle_get_by_id_nolock(client, data.handle.handle);\n+\t\tif (IS_ERR(handle)) {\n+\t\t\tmutex_unlock(&client->lock);\n \t\t\treturn PTR_ERR(handle);\n-\t\tion_free(client, handle);\n-\t\tion_handle_put(handle);\n+\t\t}\n+\t\tion_free_nolock(client, handle);\n+\t\tion_handle_put_nolock(handle);\n+\t\tmutex_unlock(&client->lock);\n \t\tbreak;\n \t}\n \tcase ION_IOC_SHARE:""}","static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct ion_client *client = filp->private_data;
	struct ion_device *dev = client->dev;
	struct ion_handle *cleanup_handle = NULL;
	int ret = 0;
	unsigned int dir;

	union {
		struct ion_fd_data fd;
		struct ion_allocation_data allocation;
		struct ion_handle_data handle;
		struct ion_custom_data custom;
	} data;

	dir = ion_ioctl_dir(cmd);

	if (_IOC_SIZE(cmd) > sizeof(data))
		return -EINVAL;

	if (dir & _IOC_WRITE)
		if (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))
			return -EFAULT;

	switch (cmd) {
	case ION_IOC_ALLOC:
	{
		struct ion_handle *handle;

		handle = ion_alloc(client, data.allocation.len,
						data.allocation.align,
						data.allocation.heap_id_mask,
						data.allocation.flags);
		if (IS_ERR(handle))
			return PTR_ERR(handle);

		data.allocation.handle = handle->id;

		cleanup_handle = handle;
		break;
	}
	case ION_IOC_FREE:
 	{
 		struct ion_handle *handle;
 
		mutex_lock(&client->lock);
		handle = ion_handle_get_by_id_nolock(client, data.handle.handle);
		if (IS_ERR(handle)) {
			mutex_unlock(&client->lock);
 			return PTR_ERR(handle);
		}
		ion_free_nolock(client, handle);
		ion_handle_put_nolock(handle);
		mutex_unlock(&client->lock);
 		break;
 	}
 	case ION_IOC_SHARE:
	case ION_IOC_MAP:
	{
		struct ion_handle *handle;

		handle = ion_handle_get_by_id(client, data.handle.handle);
		if (IS_ERR(handle))
			return PTR_ERR(handle);
		data.fd.fd = ion_share_dma_buf_fd(client, handle);
		ion_handle_put(handle);
		if (data.fd.fd < 0)
			ret = data.fd.fd;
		break;
	}
	case ION_IOC_IMPORT:
	{
		struct ion_handle *handle;

		handle = ion_import_dma_buf_fd(client, data.fd.fd);
		if (IS_ERR(handle))
			ret = PTR_ERR(handle);
		else
			data.handle.handle = handle->id;
		break;
	}
	case ION_IOC_SYNC:
	{
		ret = ion_sync_for_device(client, data.fd.fd);
		break;
	}
	case ION_IOC_CUSTOM:
	{
		if (!dev->custom_ioctl)
			return -ENOTTY;
		ret = dev->custom_ioctl(client, data.custom.cmd,
						data.custom.arg);
		break;
	}
	default:
		return -ENOTTY;
	}

	if (dir & _IOC_READ) {
		if (copy_to_user((void __user *)arg, &data, _IOC_SIZE(cmd))) {
			if (cleanup_handle)
				ion_free(client, cleanup_handle);
			return -EFAULT;
		}
	}
	return ret;
}
","static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct ion_client *client = filp->private_data;
	struct ion_device *dev = client->dev;
	struct ion_handle *cleanup_handle = NULL;
	int ret = 0;
	unsigned int dir;

	union {
		struct ion_fd_data fd;
		struct ion_allocation_data allocation;
		struct ion_handle_data handle;
		struct ion_custom_data custom;
	} data;

	dir = ion_ioctl_dir(cmd);

	if (_IOC_SIZE(cmd) > sizeof(data))
		return -EINVAL;

	if (dir & _IOC_WRITE)
		if (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))
			return -EFAULT;

	switch (cmd) {
	case ION_IOC_ALLOC:
	{
		struct ion_handle *handle;

		handle = ion_alloc(client, data.allocation.len,
						data.allocation.align,
						data.allocation.heap_id_mask,
						data.allocation.flags);
		if (IS_ERR(handle))
			return PTR_ERR(handle);

		data.allocation.handle = handle->id;

		cleanup_handle = handle;
		break;
	}
	case ION_IOC_FREE:
 	{
 		struct ion_handle *handle;
 
		handle = ion_handle_get_by_id(client, data.handle.handle);
		if (IS_ERR(handle))
 			return PTR_ERR(handle);
		ion_free(client, handle);
		ion_handle_put(handle);
 		break;
 	}
 	case ION_IOC_SHARE:
	case ION_IOC_MAP:
	{
		struct ion_handle *handle;

		handle = ion_handle_get_by_id(client, data.handle.handle);
		if (IS_ERR(handle))
			return PTR_ERR(handle);
		data.fd.fd = ion_share_dma_buf_fd(client, handle);
		ion_handle_put(handle);
		if (data.fd.fd < 0)
			ret = data.fd.fd;
		break;
	}
	case ION_IOC_IMPORT:
	{
		struct ion_handle *handle;

		handle = ion_import_dma_buf_fd(client, data.fd.fd);
		if (IS_ERR(handle))
			ret = PTR_ERR(handle);
		else
			data.handle.handle = handle->id;
		break;
	}
	case ION_IOC_SYNC:
	{
		ret = ion_sync_for_device(client, data.fd.fd);
		break;
	}
	case ION_IOC_CUSTOM:
	{
		if (!dev->custom_ioctl)
			return -ENOTTY;
		ret = dev->custom_ioctl(client, data.custom.cmd,
						data.custom.arg);
		break;
	}
	default:
		return -ENOTTY;
	}

	if (dir & _IOC_READ) {
		if (copy_to_user((void __user *)arg, &data, _IOC_SIZE(cmd))) {
			if (cleanup_handle)
				ion_free(client, cleanup_handle);
			return -EFAULT;
		}
	}
	return ret;
}
",C,"		mutex_lock(&client->lock);
		handle = ion_handle_get_by_id_nolock(client, data.handle.handle);
		if (IS_ERR(handle)) {
			mutex_unlock(&client->lock);
		}
		ion_free_nolock(client, handle);
		ion_handle_put_nolock(handle);
		mutex_unlock(&client->lock);
","		handle = ion_handle_get_by_id(client, data.handle.handle);
		if (IS_ERR(handle))
		ion_free(client, handle);
		ion_handle_put(handle);
",,"@@ -387,13 +387,22 @@ static void ion_handle_get(struct ion_handle *handle)
 	kref_get(&handle->ref);
 }
 
-static int ion_handle_put(struct ion_handle *handle)
+static int ion_handle_put_nolock(struct ion_handle *handle)
+{
+	int ret;
+
+	ret = kref_put(&handle->ref, ion_handle_destroy);
+
+	return ret;
+}
+
+int ion_handle_put(struct ion_handle *handle)
 {
 	struct ion_client *client = handle->client;
 	int ret;
 
 	mutex_lock(&client->lock);
-	ret = kref_put(&handle->ref, ion_handle_destroy);
+	ret = ion_handle_put_nolock(handle);
 	mutex_unlock(&client->lock);
 
 	return ret;
@@ -417,20 +426,30 @@ static struct ion_handle *ion_handle_lookup(struct ion_client *client,
 	return ERR_PTR(-EINVAL);
 }
 
-static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,
+static struct ion_handle *ion_handle_get_by_id_nolock(struct ion_client *client,
 						int id)
 {
 	struct ion_handle *handle;
 
-	mutex_lock(&client->lock);
 	handle = idr_find(&client->idr, id);
 	if (handle)
 		ion_handle_get(handle);
-	mutex_unlock(&client->lock);
 
 	return handle ? handle : ERR_PTR(-EINVAL);
 }
 
+struct ion_handle *ion_handle_get_by_id(struct ion_client *client,
+						int id)
+{
+	struct ion_handle *handle;
+
+	mutex_lock(&client->lock);
+	handle = ion_handle_get_by_id_nolock(client, id);
+	mutex_unlock(&client->lock);
+
+	return handle;
+}
+
 static bool ion_handle_validate(struct ion_client *client,
 				struct ion_handle *handle)
 {
@@ -532,22 +551,28 @@ struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
 }
 EXPORT_SYMBOL(ion_alloc);
 
-void ion_free(struct ion_client *client, struct ion_handle *handle)
+static void ion_free_nolock(struct ion_client *client, struct ion_handle *handle)
 {
 	bool valid_handle;
 
 	BUG_ON(client != handle->client);
 
-	mutex_lock(&client->lock);
 	valid_handle = ion_handle_validate(client, handle);
 
 	if (!valid_handle) {
 		WARN(1, ""%s: invalid handle passed to free.\n"", __func__);
-		mutex_unlock(&client->lock);
 		return;
 	}
+	ion_handle_put_nolock(handle);
+}
+
+void ion_free(struct ion_client *client, struct ion_handle *handle)
+{
+	BUG_ON(client != handle->client);
+
+	mutex_lock(&client->lock);
+	ion_free_nolock(client, handle);
 	mutex_unlock(&client->lock);
-	ion_handle_put(handle);
 }
 EXPORT_SYMBOL(ion_free);
 
@@ -1332,11 +1357,15 @@ static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 	{
 		struct ion_handle *handle;
 
-		handle = ion_handle_get_by_id(client, data.handle.handle);
-		if (IS_ERR(handle))
+		mutex_lock(&client->lock);
+		handle = ion_handle_get_by_id_nolock(client, data.handle.handle);
+		if (IS_ERR(handle)) {
+			mutex_unlock(&client->lock);
 			return PTR_ERR(handle);
-		ion_free(client, handle);
-		ion_handle_put(handle);
+		}
+		ion_free_nolock(client, handle);
+		ion_handle_put_nolock(handle);
+		mutex_unlock(&client->lock);
 		break;
 	}
 	case ION_IOC_SHARE:",linux,9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,5a20df724f712e9daa9fd41b430ff63ecd203e85,1,"static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct ion_client *client = filp->private_data;
	struct ion_device *dev = client->dev;
	struct ion_handle *cleanup_handle = NULL;
	int ret = 0;
	unsigned int dir;

	union {
		struct ion_fd_data fd;
		struct ion_allocation_data allocation;
		struct ion_handle_data handle;
		struct ion_custom_data custom;
	} data;

	dir = ion_ioctl_dir(cmd);

	if (_IOC_SIZE(cmd) > sizeof(data))
		return -EINVAL;

	if (dir & _IOC_WRITE)
		if (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))
			return -EFAULT;

	switch (cmd) {
	case ION_IOC_ALLOC:
	{
		struct ion_handle *handle;

		handle = ion_alloc(client, data.allocation.len,
						data.allocation.align,
						data.allocation.heap_id_mask,
						data.allocation.flags);
		if (IS_ERR(handle))
			return PTR_ERR(handle);

		data.allocation.handle = handle->id;

		cleanup_handle = handle;
		break;
	}
	case ION_IOC_FREE:
 	{
 		struct ion_handle *handle;
 
//flaw_line_below:
		handle = ion_handle_get_by_id(client, data.handle.handle);
//flaw_line_below:
		if (IS_ERR(handle))
//fix_flaw_line_below:
//		mutex_lock(&client->lock);
//fix_flaw_line_below:
//		handle = ion_handle_get_by_id_nolock(client, data.handle.handle);
//fix_flaw_line_below:
//		if (IS_ERR(handle)) {
//fix_flaw_line_below:
//			mutex_unlock(&client->lock);
 			return PTR_ERR(handle);
//flaw_line_below:
		ion_free(client, handle);
//flaw_line_below:
		ion_handle_put(handle);
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//		ion_free_nolock(client, handle);
//fix_flaw_line_below:
//		ion_handle_put_nolock(handle);
//fix_flaw_line_below:
//		mutex_unlock(&client->lock);
 		break;
 	}
 	case ION_IOC_SHARE:
	case ION_IOC_MAP:
	{
		struct ion_handle *handle;

		handle = ion_handle_get_by_id(client, data.handle.handle);
		if (IS_ERR(handle))
			return PTR_ERR(handle);
		data.fd.fd = ion_share_dma_buf_fd(client, handle);
		ion_handle_put(handle);
		if (data.fd.fd < 0)
			ret = data.fd.fd;
		break;
	}
	case ION_IOC_IMPORT:
	{
		struct ion_handle *handle;

		handle = ion_import_dma_buf_fd(client, data.fd.fd);
		if (IS_ERR(handle))
			ret = PTR_ERR(handle);
		else
			data.handle.handle = handle->id;
		break;
	}
	case ION_IOC_SYNC:
	{
		ret = ion_sync_for_device(client, data.fd.fd);
		break;
	}
	case ION_IOC_CUSTOM:
	{
		if (!dev->custom_ioctl)
			return -ENOTTY;
		ret = dev->custom_ioctl(client, data.custom.cmd,
						data.custom.arg);
		break;
	}
	default:
		return -ENOTTY;
	}

	if (dir & _IOC_READ) {
		if (copy_to_user((void __user *)arg, &data, _IOC_SIZE(cmd))) {
			if (cleanup_handle)
				ion_free(client, cleanup_handle);
			return -EFAULT;
		}
	}
	return ret;
}
",180071,"static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct ion_client *client = filp->private_data;
	struct ion_device *dev = client->dev;
	struct ion_handle *cleanup_handle = NULL;
	int ret = 0;
	unsigned int dir;

	union {
		struct ion_fd_data fd;
		struct ion_allocation_data allocation;
		struct ion_handle_data handle;
		struct ion_custom_data custom;
	} data;

	dir = ion_ioctl_dir(cmd);

	if (_IOC_SIZE(cmd) > sizeof(data))
		return -EINVAL;

	if (dir & _IOC_WRITE)
		if (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))
			return -EFAULT;

	switch (cmd) {
	case ION_IOC_ALLOC:
	{
		struct ion_handle *handle;

		handle = ion_alloc(client, data.allocation.len,
						data.allocation.align,
						data.allocation.heap_id_mask,
						data.allocation.flags);
		if (IS_ERR(handle))
			return PTR_ERR(handle);

		data.allocation.handle = handle->id;

		cleanup_handle = handle;
		break;
	}
	case ION_IOC_FREE:
 	{
 		struct ion_handle *handle;
 
		handle = ion_handle_get_by_id(client, data.handle.handle);
		if (IS_ERR(handle))
 			return PTR_ERR(handle);
		ion_free(client, handle);
		ion_handle_put(handle);
 		break;
 	}
 	case ION_IOC_SHARE:
	case ION_IOC_MAP:
	{
		struct ion_handle *handle;

		handle = ion_handle_get_by_id(client, data.handle.handle);
		if (IS_ERR(handle))
			return PTR_ERR(handle);
		data.fd.fd = ion_share_dma_buf_fd(client, handle);
		ion_handle_put(handle);
		if (data.fd.fd < 0)
			ret = data.fd.fd;
		break;
	}
	case ION_IOC_IMPORT:
	{
		struct ion_handle *handle;

		handle = ion_import_dma_buf_fd(client, data.fd.fd);
		if (IS_ERR(handle))
			ret = PTR_ERR(handle);
		else
			data.handle.handle = handle->id;
		break;
	}
	case ION_IOC_SYNC:
	{
		ret = ion_sync_for_device(client, data.fd.fd);
		break;
	}
	case ION_IOC_CUSTOM:
	{
		if (!dev->custom_ioctl)
			return -ENOTTY;
		ret = dev->custom_ioctl(client, data.custom.cmd,
						data.custom.arg);
		break;
	}
	default:
		return -ENOTTY;
	}

	if (dir & _IOC_READ) {
		if (copy_to_user((void __user *)arg, &data, _IOC_SIZE(cmd))) {
			if (cleanup_handle)
				ion_free(client, cleanup_handle);
			return -EFAULT;
		}
	}
	return ret;
}
","static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct ion_client *client = filp->private_data;
	struct ion_device *dev = client->dev;
	struct ion_handle *cleanup_handle = NULL;
	int ret = 0;
	unsigned int dir;

	union {
		struct ion_fd_data fd;
		struct ion_allocation_data allocation;
		struct ion_handle_data handle;
		struct ion_custom_data custom;
	} data;

	dir = ion_ioctl_dir(cmd);

	if (_IOC_SIZE(cmd) > sizeof(data))
		return -EINVAL;

	if (dir & _IOC_WRITE)
		if (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))
			return -EFAULT;

	switch (cmd) {
	case ION_IOC_ALLOC:
	{
		struct ion_handle *handle;

		handle = ion_alloc(client, data.allocation.len,
						data.allocation.align,
						data.allocation.heap_id_mask,
						data.allocation.flags);
		if (IS_ERR(handle))
			return PTR_ERR(handle);

		data.allocation.handle = handle->id;

		cleanup_handle = handle;
		break;
	}
	case ION_IOC_FREE:
 	{
 		struct ion_handle *handle;
 
		mutex_lock(&client->lock);
		handle = ion_handle_get_by_id_nolock(client, data.handle.handle);
		if (IS_ERR(handle)) {
			mutex_unlock(&client->lock);
 			return PTR_ERR(handle);
		}
		ion_free_nolock(client, handle);
		ion_handle_put_nolock(handle);
		mutex_unlock(&client->lock);
 		break;
 	}
 	case ION_IOC_SHARE:
	case ION_IOC_MAP:
	{
		struct ion_handle *handle;

		handle = ion_handle_get_by_id(client, data.handle.handle);
		if (IS_ERR(handle))
			return PTR_ERR(handle);
		data.fd.fd = ion_share_dma_buf_fd(client, handle);
		ion_handle_put(handle);
		if (data.fd.fd < 0)
			ret = data.fd.fd;
		break;
	}
	case ION_IOC_IMPORT:
	{
		struct ion_handle *handle;

		handle = ion_import_dma_buf_fd(client, data.fd.fd);
		if (IS_ERR(handle))
			ret = PTR_ERR(handle);
		else
			data.handle.handle = handle->id;
		break;
	}
	case ION_IOC_SYNC:
	{
		ret = ion_sync_for_device(client, data.fd.fd);
		break;
	}
	case ION_IOC_CUSTOM:
	{
		if (!dev->custom_ioctl)
			return -ENOTTY;
		ret = dev->custom_ioctl(client, data.custom.cmd,
						data.custom.arg);
		break;
	}
	default:
		return -ENOTTY;
	}

	if (dir & _IOC_READ) {
		if (copy_to_user((void __user *)arg, &data, _IOC_SIZE(cmd))) {
			if (cleanup_handle)
				ion_free(client, cleanup_handle);
			return -EFAULT;
		}
	}
	return ret;
}
","The provided code implements an ioctl handler for an Ion memory allocator in a Linux kernel module, allowing user-space applications to manage memory allocations. It processes various commands, such as allocating (`ION_IOC_ALLOC`), freeing (`ION_IOC_FREE`), sharing (`ION_IOC_SHARE`), mapping (`ION_IOC_MAP`), importing (`ION_IOC_IMPORT`), and synchronizing (`ION_IOC_SYNC`) memory buffers. The function checks the command's direction to handle data transfer between user and kernel space, validates input sizes, and performs the requested operations while managing memory handles. It also supports custom commands through a callback if defined. Error handling is incorporated to ensure robustness.","The code defines a function that serves as an interface for managing memory allocations in a kernel module, allowing user-space applications to request various operations on memory buffers. It processes commands for allocating, freeing, sharing, mapping, importing, and synchronizing memory, while ensuring proper data transfer between user and kernel space. The function validates input sizes and handles errors gracefully, ensuring that memory resources are managed correctly. Additionally, it supports custom operations through a callback mechanism, enhancing its flexibility for specific use cases. Overall, it facilitates efficient memory management within the kernel environment.","The vulnerability in the original code arises from a race condition during simultaneous calls to free a memory handle, leading to a use-after-free scenario. When two tasks on different CPUs invoke the free operation, they can both access and modify the reference count of the same handle, resulting in one task freeing the handle while the other still holds a reference to it. This can corrupt memory management structures, causing undefined behavior. The fix introduces a mutex lock around the handle retrieval and freeing operations, ensuring that only one task can manipulate the handle at a time, thus preventing concurrent access and the associated race condition.","The vulnerability in the original code stems from a race condition that occurs when multiple tasks attempt to free the same memory handle simultaneously, leading to a use-after-free issue. This situation arises when one task frees the handle while another still holds a reference to it, resulting in potential memory corruption and undefined behavior. The fix addresses this vulnerability by implementing a mutex lock that ensures exclusive access to the handle during retrieval and freeing operations. This prevents concurrent modifications, thereby eliminating the race condition and ensuring safe memory management within the driver.","The vulnerability was fixed by extending the use of a mutex lock around the operations that access and modify the handle within the `ION_IOC_FREE` case. Specifically, the code now locks `client->lock` before calling `ion_handle_get_by_id_nolock` to retrieve the handle and again before invoking `ion_free_nolock` to free it. This ensures that only one task can manipulate the handle at a time, preventing simultaneous access that could lead to a race condition. The lock is released after the operations are completed, thus maintaining safe memory management and preventing use-after-free scenarios.","The vulnerability was fixed by implementing a mutex lock to control access to the memory handle during critical operations. By ensuring that only one task can access and modify the handle at a time, the fix prevents simultaneous attempts to free the same handle, which could lead to memory corruption. The locking mechanism is applied before retrieving and freeing the handle, and it is released afterward, thereby maintaining safe memory management. This change effectively eliminates the race condition that caused the use-after-free issue, ensuring that memory operations are performed in a controlled and predictable manner.","CWE-362,CWE-667,CWE-666,CWE-404,CWE-367,CWE-366,CWE-825,CWE-364,CWE-672,CWE-377",N,-1
13,13,180096,180096,,Remote,Not required,Complete,CVE-2016-7912,https://www.cvedetails.com/cve/CVE-2016-7912/,CWE-416,Medium,Complete,Complete,,2016-11-16,9.3,Use-after-free vulnerability in the ffs_user_copy_worker function in drivers/usb/gadget/function/f_fs.c in the Linux kernel before 4.5.3 allows local users to gain privileges by accessing an I/O data structure after a certain callback call.,2016-11-28,+Priv ,2,https://github.com/torvalds/linux/commit/38740a5b87d53ceb89eb2c970150f6e94e00373a,38740a5b87d53ceb89eb2c970150f6e94e00373a,"usb: gadget: f_fs: Fix use-after-free

When using asynchronous read or write operations on the USB endpoints the
issuer of the IO request is notified by calling the ki_complete() callback
of the submitted kiocb when the URB has been completed.

Calling this ki_complete() callback will free kiocb. Make sure that the
structure is no longer accessed beyond that point, otherwise undefined
behaviour might occur.

Fixes: 2e4c7553cd6f (""usb: gadget: f_fs: add aio support"")
Cc: <stable@vger.kernel.org> # v3.15+
Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>",3,drivers/usb/gadget/function/f_fs.c,"{""sha"": ""15b648cbc75c4141bb5c51bd03c2c6e5b5f6c821"", ""filename"": ""drivers/usb/gadget/function/f_fs.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/38740a5b87d53ceb89eb2c970150f6e94e00373a/drivers/usb/gadget/function/f_fs.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/38740a5b87d53ceb89eb2c970150f6e94e00373a/drivers/usb/gadget/function/f_fs.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/gadget/function/f_fs.c?ref=38740a5b87d53ceb89eb2c970150f6e94e00373a"", ""patch"": ""@@ -646,6 +646,7 @@ static void ffs_user_copy_worker(struct work_struct *work)\n \t\t\t\t\t\t   work);\n \tint ret = io_data->req->status ? io_data->req->status :\n \t\t\t\t\t io_data->req->actual;\n+\tbool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;\n \n \tif (io_data->read && ret > 0) {\n \t\tuse_mm(io_data->mm);\n@@ -657,13 +658,11 @@ static void ffs_user_copy_worker(struct work_struct *work)\n \n \tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n \n-\tif (io_data->ffs->ffs_eventfd &&\n-\t    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))\n+\tif (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)\n \t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n \n \tusb_ep_free_request(io_data->ep, io_data->req);\n \n-\tio_data->kiocb->private = NULL;\n \tif (io_data->read)\n \t\tkfree(io_data->to_free);\n \tkfree(io_data->buf);""}","static void ffs_user_copy_worker(struct work_struct *work)
{
	struct ffs_io_data *io_data = container_of(work, struct ffs_io_data,
 						   work);
 	int ret = io_data->req->status ? io_data->req->status :
 					 io_data->req->actual;
	bool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;
 
 	if (io_data->read && ret > 0) {
 		use_mm(io_data->mm);
		ret = copy_to_iter(io_data->buf, ret, &io_data->data);
		if (iov_iter_count(&io_data->data))
			ret = -EFAULT;
		unuse_mm(io_data->mm);
	}
 
 	io_data->kiocb->ki_complete(io_data->kiocb, ret, ret);
 
	if (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)
 		eventfd_signal(io_data->ffs->ffs_eventfd, 1);
 
 	usb_ep_free_request(io_data->ep, io_data->req);
 
 	if (io_data->read)
 		kfree(io_data->to_free);
 	kfree(io_data->buf);
	kfree(io_data);
}
","static void ffs_user_copy_worker(struct work_struct *work)
{
	struct ffs_io_data *io_data = container_of(work, struct ffs_io_data,
 						   work);
 	int ret = io_data->req->status ? io_data->req->status :
 					 io_data->req->actual;
 
 	if (io_data->read && ret > 0) {
 		use_mm(io_data->mm);
		ret = copy_to_iter(io_data->buf, ret, &io_data->data);
		if (iov_iter_count(&io_data->data))
			ret = -EFAULT;
		unuse_mm(io_data->mm);
	}
 
 	io_data->kiocb->ki_complete(io_data->kiocb, ret, ret);
 
	if (io_data->ffs->ffs_eventfd &&
	    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))
 		eventfd_signal(io_data->ffs->ffs_eventfd, 1);
 
 	usb_ep_free_request(io_data->ep, io_data->req);
 
	io_data->kiocb->private = NULL;
 	if (io_data->read)
 		kfree(io_data->to_free);
 	kfree(io_data->buf);
	kfree(io_data);
}
",C,"	bool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;
	if (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)
","	if (io_data->ffs->ffs_eventfd &&
	    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))
	io_data->kiocb->private = NULL;
",,"@@ -646,6 +646,7 @@ static void ffs_user_copy_worker(struct work_struct *work)
 						   work);
 	int ret = io_data->req->status ? io_data->req->status :
 					 io_data->req->actual;
+	bool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;
 
 	if (io_data->read && ret > 0) {
 		use_mm(io_data->mm);
@@ -657,13 +658,11 @@ static void ffs_user_copy_worker(struct work_struct *work)
 
 	io_data->kiocb->ki_complete(io_data->kiocb, ret, ret);
 
-	if (io_data->ffs->ffs_eventfd &&
-	    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))
+	if (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)
 		eventfd_signal(io_data->ffs->ffs_eventfd, 1);
 
 	usb_ep_free_request(io_data->ep, io_data->req);
 
-	io_data->kiocb->private = NULL;
 	if (io_data->read)
 		kfree(io_data->to_free);
 	kfree(io_data->buf);",linux,38740a5b87d53ceb89eb2c970150f6e94e00373a,9772b47a4c2916d645c551228b6085ea24acbe5d,1,"static void ffs_user_copy_worker(struct work_struct *work)
{
	struct ffs_io_data *io_data = container_of(work, struct ffs_io_data,
 						   work);
 	int ret = io_data->req->status ? io_data->req->status :
 					 io_data->req->actual;
//fix_flaw_line_below:
//	bool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;
 
 	if (io_data->read && ret > 0) {
 		use_mm(io_data->mm);
		ret = copy_to_iter(io_data->buf, ret, &io_data->data);
		if (iov_iter_count(&io_data->data))
			ret = -EFAULT;
		unuse_mm(io_data->mm);
	}
 
 	io_data->kiocb->ki_complete(io_data->kiocb, ret, ret);
 
//flaw_line_below:
	if (io_data->ffs->ffs_eventfd &&
//flaw_line_below:
	    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))
//fix_flaw_line_below:
//	if (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)
 		eventfd_signal(io_data->ffs->ffs_eventfd, 1);
 
 	usb_ep_free_request(io_data->ep, io_data->req);
 
//flaw_line_below:
	io_data->kiocb->private = NULL;
 	if (io_data->read)
 		kfree(io_data->to_free);
 	kfree(io_data->buf);
	kfree(io_data);
}
",180096,"static void ffs_user_copy_worker(struct work_struct *work)
{
	struct ffs_io_data *io_data = container_of(work, struct ffs_io_data,
 						   work);
 	int ret = io_data->req->status ? io_data->req->status :
 					 io_data->req->actual;
 
 	if (io_data->read && ret > 0) {
 		use_mm(io_data->mm);
		ret = copy_to_iter(io_data->buf, ret, &io_data->data);
		if (iov_iter_count(&io_data->data))
			ret = -EFAULT;
		unuse_mm(io_data->mm);
	}
 
 	io_data->kiocb->ki_complete(io_data->kiocb, ret, ret);
 
	if (io_data->ffs->ffs_eventfd &&
	    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))
 		eventfd_signal(io_data->ffs->ffs_eventfd, 1);
 
 	usb_ep_free_request(io_data->ep, io_data->req);
 
	io_data->kiocb->private = NULL;
 	if (io_data->read)
 		kfree(io_data->to_free);
 	kfree(io_data->buf);
	kfree(io_data);
}
","static void ffs_user_copy_worker(struct work_struct *work)
{
	struct ffs_io_data *io_data = container_of(work, struct ffs_io_data,
 						   work);
 	int ret = io_data->req->status ? io_data->req->status :
 					 io_data->req->actual;
	bool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;
 
 	if (io_data->read && ret > 0) {
 		use_mm(io_data->mm);
		ret = copy_to_iter(io_data->buf, ret, &io_data->data);
		if (iov_iter_count(&io_data->data))
			ret = -EFAULT;
		unuse_mm(io_data->mm);
	}
 
 	io_data->kiocb->ki_complete(io_data->kiocb, ret, ret);
 
	if (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)
 		eventfd_signal(io_data->ffs->ffs_eventfd, 1);
 
 	usb_ep_free_request(io_data->ep, io_data->req);
 
 	if (io_data->read)
 		kfree(io_data->to_free);
 	kfree(io_data->buf);
	kfree(io_data);
}
","The `ffs_user_copy_worker` function is designed to handle the completion of I/O operations in a USB filesystem context. It retrieves I/O data from a work structure, checks the status of the request, and if reading is required and successful, it copies data from a buffer to an iterator while managing memory access. Upon completion, it invokes a callback to signal the completion of the I/O operation, potentially triggers an event if necessary, and cleans up by freeing the USB request and associated memory. This function ensures proper resource management and error handling during asynchronous I/O operations.","The provided code defines a function that processes the completion of an I/O operation in a USB filesystem context. It checks the status of the operation and, if reading is required and successful, transfers data from a buffer to a specified location while managing memory access. After completing the data transfer, it invokes a callback to signal the operation's completion and may trigger an event if certain conditions are met. Finally, the function ensures proper cleanup by releasing resources associated with the I/O request and freeing any allocated memory, thereby maintaining efficient resource management.","The vulnerability in the original code arises from a potential use-after-free condition, where the `kiocb` structure could be accessed after it has been freed by the `ki_complete()` callback. This occurs because the callback is invoked before the function completes its execution, leading to undefined behavior if any subsequent code attempts to access `kiocb` or its flags. The fix addresses this by introducing a boolean variable to store the event flag status before calling `ki_complete()`, ensuring that the code does not access `kiocb` after it has been freed, thus preventing the use-after-free vulnerability.","The vulnerability in the original code stems from a use-after-free issue, where a structure could be accessed after it has been deallocated. This occurs because the completion callback for an I/O request is called, which frees the associated structure, but subsequent code still attempts to access it. This can lead to undefined behavior, including potential crashes or data corruption. The fix involves storing the necessary state information before invoking the callback, ensuring that the code does not reference the freed structure afterward, thereby eliminating the risk of accessing invalid memory and ensuring safer execution.","The vulnerability was fixed by introducing a boolean variable to store the event flag status of the `kiocb` before calling the `ki_complete()` function. This change ensures that the code can safely check the event flag condition without accessing the `kiocb` structure after it has been freed. Specifically, the line `bool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;` captures the necessary state prior to the callback invocation. As a result, the subsequent check for the event flag is performed using this stored value, preventing any potential use-after-free issues and ensuring safe memory access.","The vulnerability was fixed by capturing the necessary state information before invoking the callback that frees the associated structure. By storing the relevant flag status in a separate variable, the code ensures that it does not access the freed structure afterward. This approach allows the program to safely check conditions related to the structure without risking undefined behavior. Consequently, the fix prevents any potential use-after-free issues by ensuring that all necessary operations are completed using the stored state, thereby maintaining safe memory access and improving overall stability.","CWE-416, CWE-825, CWE-415, CWE-672, CWE-675, CWE-119, CWE-476, CWE-666, CWE-754, CWE-913",Y,1
14,14,180108,180108,,Remote,Not required,Partial,CVE-2016-7413,https://www.cvedetails.com/cve/CVE-2016-7413/,CWE-416,Low,Partial,Partial,,2016-09-17,7.5,"Use-after-free vulnerability in the wddx_stack_destroy function in ext/wddx/wddx.c in PHP before 5.6.26 and 7.x before 7.0.11 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a wddxPacket XML document that lacks an end-tag for a recordset field element, leading to mishandling in a wddx_deserialize call.",2018-05-03,DoS ,2,https://github.com/php/php-src/commit/b88393f08a558eec14964a55d3c680fe67407712?w=1,b88393f08a558eec14964a55d3c680fe67407712?w=1,Fix bug #72860: wddx_deserialize use-after-free,1,ext/wddx/wddx.c,"{""sha"": ""6385457e8ee41b58082462379a87030b1e2cfe23"", ""filename"": ""ext/wddx/tests/bug72860.phpt"", ""status"": ""added"", ""additions"": 27, ""deletions"": 0, ""changes"": 27, ""blob_url"": ""https://github.com/php/php-src/blob/b88393f08a558eec14964a55d3c680fe67407712/ext/wddx/tests/bug72860.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/b88393f08a558eec14964a55d3c680fe67407712/ext/wddx/tests/bug72860.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/tests/bug72860.phpt?ref=b88393f08a558eec14964a55d3c680fe67407712"", ""patch"": ""@@ -0,0 +1,27 @@\n+--TEST--\n+Bug #72860: wddx_deserialize use-after-free\n+--SKIPIF--\n+<?php\n+if (!extension_loaded('wddx')) {\n+    die('skip. wddx not available');\n+}\n+?>\n+--FILE--\n+<?php\n+\n+$xml=<<<XML\n+<?xml version='1.0'?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version='1.0'>\n+       <recordset fieldNames='F'>\n+               <field name='F'>\n+       </recordset>\n+</wddxPacket>\n+XML;\n+\n+var_dump(wddx_deserialize($xml));\n+?>\n+DONE\n+--EXPECT--\n+NULL\n+DONE\n\\ No newline at end of file""}<_**next**_>{""sha"": ""b02d2f07ded469c5ed8256e422428d3ce8bee637"", ""filename"": ""ext/wddx/wddx.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/php/php-src/blob/b88393f08a558eec14964a55d3c680fe67407712/ext/wddx/wddx.c"", ""raw_url"": ""https://github.com/php/php-src/raw/b88393f08a558eec14964a55d3c680fe67407712/ext/wddx/wddx.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/wddx/wddx.c?ref=b88393f08a558eec14964a55d3c680fe67407712"", ""patch"": ""@@ -230,7 +230,8 @@ static int wddx_stack_destroy(wddx_stack *stack)\n \n \tif (stack->elements) {\n \t\tfor (i = 0; i < stack->top; i++) {\n-\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n+\t\t\tif (((st_entry *)stack->elements[i])->data\n+\t\t\t\t\t&& ((st_entry *)stack->elements[i])->type != ST_FIELD)\t{\n \t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n \t\t\t}\n \t\t\tif (((st_entry *)stack->elements[i])->varname) {""}","static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
 
 	if (stack->elements) {
 		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data
					&& ((st_entry *)stack->elements[i])->type != ST_FIELD)	{
 				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
 			}
 			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;
}
","static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
 
 	if (stack->elements) {
 		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
 				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
 			}
 			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;
}
",C,"			if (((st_entry *)stack->elements[i])->data
					&& ((st_entry *)stack->elements[i])->type != ST_FIELD)	{
","			if (((st_entry *)stack->elements[i])->data)	{
",,"@@ -230,7 +230,8 @@ static int wddx_stack_destroy(wddx_stack *stack)
 
 	if (stack->elements) {
 		for (i = 0; i < stack->top; i++) {
-			if (((st_entry *)stack->elements[i])->data)	{
+			if (((st_entry *)stack->elements[i])->data
+					&& ((st_entry *)stack->elements[i])->type != ST_FIELD)	{
 				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
 			}
 			if (((st_entry *)stack->elements[i])->varname) {",php-src,b88393f08a558eec14964a55d3c680fe67407712?w=1,65c8caafa83ca78a8b2fa22257b4dea85b6114e5,1,"static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
 
 	if (stack->elements) {
 		for (i = 0; i < stack->top; i++) {
//flaw_line_below:
			if (((st_entry *)stack->elements[i])->data)	{
//fix_flaw_line_below:
//			if (((st_entry *)stack->elements[i])->data
//fix_flaw_line_below:
//					&& ((st_entry *)stack->elements[i])->type != ST_FIELD)	{
 				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
 			}
 			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;
}
",180108,"static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
 
 	if (stack->elements) {
 		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
 				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
 			}
 			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;
}
","static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
 
 	if (stack->elements) {
 		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data
					&& ((st_entry *)stack->elements[i])->type != ST_FIELD)	{
 				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
 			}
 			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;
}
","The `wddx_stack_destroy` function is designed to safely deallocate memory associated with a WDDX (Web Data Description Exchange) stack structure. It iterates through the elements of the stack, checking for allocated data and variable names within each stack entry. If found, it invokes `zval_ptr_dtor` to properly destroy the data and uses `efree` to free the variable names and the stack entries themselves. Finally, it frees the array of elements in the stack. The function returns a success status, ensuring that all dynamically allocated memory is released to prevent memory leaks.","The provided code defines a function that manages the cleanup of a data structure used for storing elements in a stack format. It checks if the stack contains any elements and, if so, iterates through them to release any associated resources. For each element, it ensures that any dynamically allocated data is properly destroyed and that memory allocated for variable names is freed. After processing all elements, it also frees the memory allocated for the array holding the elements. The function concludes by returning a success status, ensuring efficient memory management and preventing leaks.","The vulnerability in the original code stemmed from the potential for a use-after-free condition, where the `data` associated with a stack entry could be accessed after it had already been deallocated. This risk was particularly present when the `data` was not properly checked against its type before being destroyed, leading to possible dereferencing of freed memory. The fix introduced a conditional check to ensure that `data` is only destroyed if it exists and its type is not `ST_FIELD`, thereby preventing the use-after-free scenario. This additional validation ensures that memory is managed safely, mitigating the risk of accessing invalid memory.","The vulnerability in the original code was related to a use-after-free issue, where memory that had already been deallocated could still be accessed, potentially leading to undefined behavior or crashes. This occurred because the code did not adequately check the conditions under which certain data was destroyed, allowing for the possibility of accessing freed memory. The fix implemented a conditional check to ensure that the data was only destroyed if it was valid and met specific criteria, thereby preventing any attempts to access or manipulate memory that had already been released. This change enhances memory safety and stability.","The vulnerability was fixed by adding a conditional check before destroying the `data` associated with each stack entry. In the updated code, the function now verifies that `data` exists and that the entry's `type` is not equal to `ST_FIELD` before calling `zval_ptr_dtor` to deallocate it. This ensures that the function does not attempt to access or free memory that has already been released, thus preventing the use-after-free issue. By implementing this additional validation, the code enhances memory safety and prevents potential crashes or undefined behavior associated with accessing invalid memory.","The vulnerability was fixed by introducing a conditional check that ensures memory is only deallocated if it is valid and meets specific criteria. This prevents the code from attempting to access or free memory that has already been released, thereby addressing the use-after-free issue. By validating the state of the data before destruction, the updated implementation safeguards against potential crashes or undefined behavior that could arise from accessing invalid memory. This change enhances overall memory management and stability, ensuring that resources are handled safely throughout the execution of the function.","CWE-416, CWE-825, CWE-415, CWE-476, CWE-754, CWE-119, CWE-404, CWE-908, CWE-673, CWE-666",Y,1
15,15,180401,180401,,Local,Not required,Complete,CVE-2016-4805,https://www.cvedetails.com/cve/CVE-2016-4805/,CWE-416,Low,Complete,Complete,,2016-05-23,7.2,"Use-after-free vulnerability in drivers/net/ppp/ppp_generic.c in the Linux kernel before 4.5.2 allows local users to cause a denial of service (memory corruption and system crash, or spinlock) or possibly have unspecified other impact by removing a network namespace, related to the ppp_register_net_channel and ppp_unregister_channel functions.",2019-04-22,DoS Mem. Corr. ,1,https://github.com/torvalds/linux/commit/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,"ppp: take reference on channels netns

Let channels hold a reference on their network namespace.
Some channel types, like ppp_async and ppp_synctty, can have their
userspace controller running in a different namespace. Therefore they
can't rely on them to preclude their netns from being removed from
under them.

==================================================================
BUG: KASAN: use-after-free in ppp_unregister_channel+0x372/0x3a0 at
addr ffff880064e217e0
Read of size 8 by task syz-executor/11581
=============================================================================
BUG net_namespace (Not tainted): kasan: bad access detected
-----------------------------------------------------------------------------

Disabling lock debugging due to kernel taint
INFO: Allocated in copy_net_ns+0x6b/0x1a0 age=92569 cpu=3 pid=6906
[<      none      >] ___slab_alloc+0x4c7/0x500 kernel/mm/slub.c:2440
[<      none      >] __slab_alloc+0x4c/0x90 kernel/mm/slub.c:2469
[<     inline     >] slab_alloc_node kernel/mm/slub.c:2532
[<     inline     >] slab_alloc kernel/mm/slub.c:2574
[<      none      >] kmem_cache_alloc+0x23a/0x2b0 kernel/mm/slub.c:2579
[<     inline     >] kmem_cache_zalloc kernel/include/linux/slab.h:597
[<     inline     >] net_alloc kernel/net/core/net_namespace.c:325
[<      none      >] copy_net_ns+0x6b/0x1a0 kernel/net/core/net_namespace.c:360
[<      none      >] create_new_namespaces+0x2f6/0x610 kernel/kernel/nsproxy.c:95
[<      none      >] copy_namespaces+0x297/0x320 kernel/kernel/nsproxy.c:150
[<      none      >] copy_process.part.35+0x1bf4/0x5760 kernel/kernel/fork.c:1451
[<     inline     >] copy_process kernel/kernel/fork.c:1274
[<      none      >] _do_fork+0x1bc/0xcb0 kernel/kernel/fork.c:1723
[<     inline     >] SYSC_clone kernel/kernel/fork.c:1832
[<      none      >] SyS_clone+0x37/0x50 kernel/kernel/fork.c:1826
[<      none      >] entry_SYSCALL_64_fastpath+0x16/0x7a kernel/arch/x86/entry/entry_64.S:185

INFO: Freed in net_drop_ns+0x67/0x80 age=575 cpu=2 pid=2631
[<      none      >] __slab_free+0x1fc/0x320 kernel/mm/slub.c:2650
[<     inline     >] slab_free kernel/mm/slub.c:2805
[<      none      >] kmem_cache_free+0x2a0/0x330 kernel/mm/slub.c:2814
[<     inline     >] net_free kernel/net/core/net_namespace.c:341
[<      none      >] net_drop_ns+0x67/0x80 kernel/net/core/net_namespace.c:348
[<      none      >] cleanup_net+0x4e5/0x600 kernel/net/core/net_namespace.c:448
[<      none      >] process_one_work+0x794/0x1440 kernel/kernel/workqueue.c:2036
[<      none      >] worker_thread+0xdb/0xfc0 kernel/kernel/workqueue.c:2170
[<      none      >] kthread+0x23f/0x2d0 kernel/drivers/block/aoe/aoecmd.c:1303
[<      none      >] ret_from_fork+0x3f/0x70 kernel/arch/x86/entry/entry_64.S:468
INFO: Slab 0xffffea0001938800 objects=3 used=0 fp=0xffff880064e20000
flags=0x5fffc0000004080
INFO: Object 0xffff880064e20000 @offset=0 fp=0xffff880064e24200

CPU: 1 PID: 11581 Comm: syz-executor Tainted: G    B           4.4.0+
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
rel-1.8.2-0-g33fbe13 by qemu-project.org 04/01/2014
 00000000ffffffff ffff8800662c7790 ffffffff8292049d ffff88003e36a300
 ffff880064e20000 ffff880064e20000 ffff8800662c77c0 ffffffff816f2054
 ffff88003e36a300 ffffea0001938800 ffff880064e20000 0000000000000000
Call Trace:
 [<     inline     >] __dump_stack kernel/lib/dump_stack.c:15
 [<ffffffff8292049d>] dump_stack+0x6f/0xa2 kernel/lib/dump_stack.c:50
 [<ffffffff816f2054>] print_trailer+0xf4/0x150 kernel/mm/slub.c:654
 [<ffffffff816f875f>] object_err+0x2f/0x40 kernel/mm/slub.c:661
 [<     inline     >] print_address_description kernel/mm/kasan/report.c:138
 [<ffffffff816fb0c5>] kasan_report_error+0x215/0x530 kernel/mm/kasan/report.c:236
 [<     inline     >] kasan_report kernel/mm/kasan/report.c:259
 [<ffffffff816fb4de>] __asan_report_load8_noabort+0x3e/0x40 kernel/mm/kasan/report.c:280
 [<     inline     >] ? ppp_pernet kernel/include/linux/compiler.h:218
 [<ffffffff83ad71b2>] ? ppp_unregister_channel+0x372/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392
 [<     inline     >] ppp_pernet kernel/include/linux/compiler.h:218
 [<ffffffff83ad71b2>] ppp_unregister_channel+0x372/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392
 [<     inline     >] ? ppp_pernet kernel/drivers/net/ppp/ppp_generic.c:293
 [<ffffffff83ad6f26>] ? ppp_unregister_channel+0xe6/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392
 [<ffffffff83ae18f3>] ppp_asynctty_close+0xa3/0x130 kernel/drivers/net/ppp/ppp_async.c:241
 [<ffffffff83ae1850>] ? async_lcp_peek+0x5b0/0x5b0 kernel/drivers/net/ppp/ppp_async.c:1000
 [<ffffffff82c33239>] tty_ldisc_close.isra.1+0x99/0xe0 kernel/drivers/tty/tty_ldisc.c:478
 [<ffffffff82c332c0>] tty_ldisc_kill+0x40/0x170 kernel/drivers/tty/tty_ldisc.c:744
 [<ffffffff82c34943>] tty_ldisc_release+0x1b3/0x260 kernel/drivers/tty/tty_ldisc.c:772
 [<ffffffff82c1ef21>] tty_release+0xac1/0x13e0 kernel/drivers/tty/tty_io.c:1901
 [<ffffffff82c1e460>] ? release_tty+0x320/0x320 kernel/drivers/tty/tty_io.c:1688
 [<ffffffff8174de36>] __fput+0x236/0x780 kernel/fs/file_table.c:208
 [<ffffffff8174e405>] ____fput+0x15/0x20 kernel/fs/file_table.c:244
 [<ffffffff813595ab>] task_work_run+0x16b/0x200 kernel/kernel/task_work.c:115
 [<     inline     >] exit_task_work kernel/include/linux/task_work.h:21
 [<ffffffff81307105>] do_exit+0x8b5/0x2c60 kernel/kernel/exit.c:750
 [<ffffffff813fdd20>] ? debug_check_no_locks_freed+0x290/0x290 kernel/kernel/locking/lockdep.c:4123
 [<ffffffff81306850>] ? mm_update_next_owner+0x6f0/0x6f0 kernel/kernel/exit.c:357
 [<ffffffff813215e6>] ? __dequeue_signal+0x136/0x470 kernel/kernel/signal.c:550
 [<ffffffff8132067b>] ? recalc_sigpending_tsk+0x13b/0x180 kernel/kernel/signal.c:145
 [<ffffffff81309628>] do_group_exit+0x108/0x330 kernel/kernel/exit.c:880
 [<ffffffff8132b9d4>] get_signal+0x5e4/0x14f0 kernel/kernel/signal.c:2307
 [<     inline     >] ? kretprobe_table_lock kernel/kernel/kprobes.c:1113
 [<ffffffff8151d355>] ? kprobe_flush_task+0xb5/0x450 kernel/kernel/kprobes.c:1158
 [<ffffffff8115f7d3>] do_signal+0x83/0x1c90 kernel/arch/x86/kernel/signal.c:712
 [<ffffffff8151d2a0>] ? recycle_rp_inst+0x310/0x310 kernel/include/linux/list.h:655
 [<ffffffff8115f750>] ? setup_sigcontext+0x780/0x780 kernel/arch/x86/kernel/signal.c:165
 [<ffffffff81380864>] ? finish_task_switch+0x424/0x5f0 kernel/kernel/sched/core.c:2692
 [<     inline     >] ? finish_lock_switch kernel/kernel/sched/sched.h:1099
 [<ffffffff81380560>] ? finish_task_switch+0x120/0x5f0 kernel/kernel/sched/core.c:2678
 [<     inline     >] ? context_switch kernel/kernel/sched/core.c:2807
 [<ffffffff85d794e9>] ? __schedule+0x919/0x1bd0 kernel/kernel/sched/core.c:3283
 [<ffffffff81003901>] exit_to_usermode_loop+0xf1/0x1a0 kernel/arch/x86/entry/common.c:247
 [<     inline     >] prepare_exit_to_usermode kernel/arch/x86/entry/common.c:282
 [<ffffffff810062ef>] syscall_return_slowpath+0x19f/0x210 kernel/arch/x86/entry/common.c:344
 [<ffffffff85d88022>] int_ret_from_sys_call+0x25/0x9f kernel/arch/x86/entry/entry_64.S:281
Memory state around the buggy address:
 ffff880064e21680: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff880064e21700: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
>ffff880064e21780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                                       ^
 ffff880064e21800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff880064e21880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
==================================================================

Fixes: 273ec51dd7ce (""net: ppp_generic - introduce net-namespace functionality v2"")
Reported-by: Baozeng Ding <sploving1@gmail.com>
Signed-off-by: Guillaume Nault <g.nault@alphalink.fr>
Reviewed-by: Cyrill Gorcunov <gorcunov@openvz.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,drivers/net/ppp/ppp_generic.c,"{""sha"": ""f572b31a2b20cef55e560b8db932c419f14bd8b3"", ""filename"": ""drivers/net/ppp/ppp_generic.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89/drivers/net/ppp/ppp_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89/drivers/net/ppp/ppp_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ppp/ppp_generic.c?ref=1f461dcdd296eecedaffffc6bae2bfa90bd7eb89"", ""patch"": ""@@ -2307,7 +2307,7 @@ int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)\n \n \tpch->ppp = NULL;\n \tpch->chan = chan;\n-\tpch->chan_net = net;\n+\tpch->chan_net = get_net(net);\n \tchan->ppp = pch;\n \tinit_ppp_file(&pch->file, CHANNEL);\n \tpch->file.hdrlen = chan->hdrlen;\n@@ -2404,6 +2404,8 @@ ppp_unregister_channel(struct ppp_channel *chan)\n \tspin_lock_bh(&pn->all_channels_lock);\n \tlist_del(&pch->list);\n \tspin_unlock_bh(&pn->all_channels_lock);\n+\tput_net(pch->chan_net);\n+\tpch->chan_net = NULL;\n \n \tpch->file.dead = 1;\n \twake_up_interruptible(&pch->file.rwait);""}","int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)
{
	struct channel *pch;
	struct ppp_net *pn;

	pch = kzalloc(sizeof(struct channel), GFP_KERNEL);
	if (!pch)
		return -ENOMEM;

	pn = ppp_pernet(net);
 
 	pch->ppp = NULL;
 	pch->chan = chan;
	pch->chan_net = get_net(net);
 	chan->ppp = pch;
 	init_ppp_file(&pch->file, CHANNEL);
 	pch->file.hdrlen = chan->hdrlen;
#ifdef CONFIG_PPP_MULTILINK
	pch->lastseq = -1;
#endif /* CONFIG_PPP_MULTILINK */
	init_rwsem(&pch->chan_sem);
	spin_lock_init(&pch->downl);
	rwlock_init(&pch->upl);

	spin_lock_bh(&pn->all_channels_lock);
	pch->file.index = ++pn->last_channel_index;
	list_add(&pch->list, &pn->new_channels);
	atomic_inc(&channel_count);
	spin_unlock_bh(&pn->all_channels_lock);

	return 0;
}
","int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)
{
	struct channel *pch;
	struct ppp_net *pn;

	pch = kzalloc(sizeof(struct channel), GFP_KERNEL);
	if (!pch)
		return -ENOMEM;

	pn = ppp_pernet(net);
 
 	pch->ppp = NULL;
 	pch->chan = chan;
	pch->chan_net = net;
 	chan->ppp = pch;
 	init_ppp_file(&pch->file, CHANNEL);
 	pch->file.hdrlen = chan->hdrlen;
#ifdef CONFIG_PPP_MULTILINK
	pch->lastseq = -1;
#endif /* CONFIG_PPP_MULTILINK */
	init_rwsem(&pch->chan_sem);
	spin_lock_init(&pch->downl);
	rwlock_init(&pch->upl);

	spin_lock_bh(&pn->all_channels_lock);
	pch->file.index = ++pn->last_channel_index;
	list_add(&pch->list, &pn->new_channels);
	atomic_inc(&channel_count);
	spin_unlock_bh(&pn->all_channels_lock);

	return 0;
}
",C,"	pch->chan_net = get_net(net);
","	pch->chan_net = net;
",,"@@ -2307,7 +2307,7 @@ int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)
 
 	pch->ppp = NULL;
 	pch->chan = chan;
-	pch->chan_net = net;
+	pch->chan_net = get_net(net);
 	chan->ppp = pch;
 	init_ppp_file(&pch->file, CHANNEL);
 	pch->file.hdrlen = chan->hdrlen;
@@ -2404,6 +2404,8 @@ ppp_unregister_channel(struct ppp_channel *chan)
 	spin_lock_bh(&pn->all_channels_lock);
 	list_del(&pch->list);
 	spin_unlock_bh(&pn->all_channels_lock);
+	put_net(pch->chan_net);
+	pch->chan_net = NULL;
 
 	pch->file.dead = 1;
 	wake_up_interruptible(&pch->file.rwait);",linux,1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,5197f3499c470ccc4b247db66ff883e597e3adda,1,"int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)
{
	struct channel *pch;
	struct ppp_net *pn;

	pch = kzalloc(sizeof(struct channel), GFP_KERNEL);
	if (!pch)
		return -ENOMEM;

	pn = ppp_pernet(net);
 
 	pch->ppp = NULL;
 	pch->chan = chan;
//flaw_line_below:
	pch->chan_net = net;
//fix_flaw_line_below:
//	pch->chan_net = get_net(net);
 	chan->ppp = pch;
 	init_ppp_file(&pch->file, CHANNEL);
 	pch->file.hdrlen = chan->hdrlen;
#ifdef CONFIG_PPP_MULTILINK
	pch->lastseq = -1;
#endif /* CONFIG_PPP_MULTILINK */
	init_rwsem(&pch->chan_sem);
	spin_lock_init(&pch->downl);
	rwlock_init(&pch->upl);

	spin_lock_bh(&pn->all_channels_lock);
	pch->file.index = ++pn->last_channel_index;
	list_add(&pch->list, &pn->new_channels);
	atomic_inc(&channel_count);
	spin_unlock_bh(&pn->all_channels_lock);

	return 0;
}
",180401,"int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)
{
	struct channel *pch;
	struct ppp_net *pn;

	pch = kzalloc(sizeof(struct channel), GFP_KERNEL);
	if (!pch)
		return -ENOMEM;

	pn = ppp_pernet(net);
 
 	pch->ppp = NULL;
 	pch->chan = chan;
	pch->chan_net = net;
 	chan->ppp = pch;
 	init_ppp_file(&pch->file, CHANNEL);
 	pch->file.hdrlen = chan->hdrlen;
#ifdef CONFIG_PPP_MULTILINK
	pch->lastseq = -1;
#endif /* CONFIG_PPP_MULTILINK */
	init_rwsem(&pch->chan_sem);
	spin_lock_init(&pch->downl);
	rwlock_init(&pch->upl);

	spin_lock_bh(&pn->all_channels_lock);
	pch->file.index = ++pn->last_channel_index;
	list_add(&pch->list, &pn->new_channels);
	atomic_inc(&channel_count);
	spin_unlock_bh(&pn->all_channels_lock);

	return 0;
}
","int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)
{
	struct channel *pch;
	struct ppp_net *pn;

	pch = kzalloc(sizeof(struct channel), GFP_KERNEL);
	if (!pch)
		return -ENOMEM;

	pn = ppp_pernet(net);
 
 	pch->ppp = NULL;
 	pch->chan = chan;
	pch->chan_net = get_net(net);
 	chan->ppp = pch;
 	init_ppp_file(&pch->file, CHANNEL);
 	pch->file.hdrlen = chan->hdrlen;
#ifdef CONFIG_PPP_MULTILINK
	pch->lastseq = -1;
#endif /* CONFIG_PPP_MULTILINK */
	init_rwsem(&pch->chan_sem);
	spin_lock_init(&pch->downl);
	rwlock_init(&pch->upl);

	spin_lock_bh(&pn->all_channels_lock);
	pch->file.index = ++pn->last_channel_index;
	list_add(&pch->list, &pn->new_channels);
	atomic_inc(&channel_count);
	spin_unlock_bh(&pn->all_channels_lock);

	return 0;
}
","The function `ppp_register_net_channel` is responsible for registering a new PPP (Point-to-Point Protocol) channel within a specified network namespace. It begins by allocating memory for a `channel` structure and checks for successful allocation. If successful, it initializes various fields of the channel, including linking it to the provided `ppp_channel` and setting up file-related parameters. The function also initializes synchronization mechanisms for concurrent access and updates the global channel index within the network namespace. Finally, it adds the newly created channel to a list of active channels and increments the channel count, returning zero to indicate success.","The provided code defines a function that registers a new communication channel within a specific network context. It begins by allocating memory for a channel structure and checks if the allocation was successful. Upon successful allocation, it initializes various properties of the channel, linking it to the provided communication interface and setting up necessary file parameters. The function also establishes synchronization mechanisms to manage concurrent access and updates a global index for active channels. Finally, it adds the newly created channel to a list of channels and increments a counter, indicating the successful registration of the channel.","The vulnerability in the original code stemmed from the potential for a use-after-free condition, where a channel could access its associated network namespace after it had been freed. This situation could occur if the channel's user-space controller operated in a different namespace, leading to the risk of the network namespace being removed while the channel still held a reference to it. The fix involved changing the assignment of the network namespace reference to use a function that increments the reference count, ensuring that the namespace remains valid for the channel's lifetime. This adjustment prevents premature deallocation and mitigates the risk of accessing freed memory.","The vulnerability in the original code was a use-after-free issue, where a communication channel could access its associated network namespace after it had been deallocated. This situation arose because certain channel types could have their user-space controllers operating in different namespaces, making it unsafe to assume that the network namespace would remain valid. The fix involved modifying the code to ensure that the channel holds a reference to its network namespace, thereby preventing it from being freed while still in use. This change ensures that the channel can safely access the network namespace without risking access to freed memory.","The vulnerability was fixed by changing the assignment of the `chan_net` variable to use the `get_net` function, which increments the reference count of the network namespace. This ensures that the network namespace remains valid for the lifetime of the channel, preventing it from being freed while still in use. By holding a reference to the network namespace, the code mitigates the risk of a use-after-free condition, allowing the channel to safely access its associated namespace without encountering invalid memory access. This adjustment enhances the stability and safety of the communication channel management.","The vulnerability was addressed by ensuring that the communication channel maintains a valid reference to its associated network namespace. This was accomplished by modifying the code to increment the reference count of the network namespace when it is assigned to the channel. By doing so, the code prevents the network namespace from being deallocated while the channel is still in use, thereby eliminating the risk of accessing freed memory. This change enhances the safety and stability of the system by ensuring that the channel can reliably interact with its network namespace without encountering invalid memory access issues.","CWE-416,CWE-672,CWE-825,CWE-415,CWE-911,CWE-666,CWE-664,CWE-476,CWE-119,CWE-404",Y,1
16,16,180402,180402,,Local,Not required,Complete,CVE-2016-4805,https://www.cvedetails.com/cve/CVE-2016-4805/,CWE-416,Low,Complete,Complete,,2016-05-23,7.2,"Use-after-free vulnerability in drivers/net/ppp/ppp_generic.c in the Linux kernel before 4.5.2 allows local users to cause a denial of service (memory corruption and system crash, or spinlock) or possibly have unspecified other impact by removing a network namespace, related to the ppp_register_net_channel and ppp_unregister_channel functions.",2019-04-22,DoS Mem. Corr. ,2,https://github.com/torvalds/linux/commit/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,"ppp: take reference on channels netns

Let channels hold a reference on their network namespace.
Some channel types, like ppp_async and ppp_synctty, can have their
userspace controller running in a different namespace. Therefore they
can't rely on them to preclude their netns from being removed from
under them.

==================================================================
BUG: KASAN: use-after-free in ppp_unregister_channel+0x372/0x3a0 at
addr ffff880064e217e0
Read of size 8 by task syz-executor/11581
=============================================================================
BUG net_namespace (Not tainted): kasan: bad access detected
-----------------------------------------------------------------------------

Disabling lock debugging due to kernel taint
INFO: Allocated in copy_net_ns+0x6b/0x1a0 age=92569 cpu=3 pid=6906
[<      none      >] ___slab_alloc+0x4c7/0x500 kernel/mm/slub.c:2440
[<      none      >] __slab_alloc+0x4c/0x90 kernel/mm/slub.c:2469
[<     inline     >] slab_alloc_node kernel/mm/slub.c:2532
[<     inline     >] slab_alloc kernel/mm/slub.c:2574
[<      none      >] kmem_cache_alloc+0x23a/0x2b0 kernel/mm/slub.c:2579
[<     inline     >] kmem_cache_zalloc kernel/include/linux/slab.h:597
[<     inline     >] net_alloc kernel/net/core/net_namespace.c:325
[<      none      >] copy_net_ns+0x6b/0x1a0 kernel/net/core/net_namespace.c:360
[<      none      >] create_new_namespaces+0x2f6/0x610 kernel/kernel/nsproxy.c:95
[<      none      >] copy_namespaces+0x297/0x320 kernel/kernel/nsproxy.c:150
[<      none      >] copy_process.part.35+0x1bf4/0x5760 kernel/kernel/fork.c:1451
[<     inline     >] copy_process kernel/kernel/fork.c:1274
[<      none      >] _do_fork+0x1bc/0xcb0 kernel/kernel/fork.c:1723
[<     inline     >] SYSC_clone kernel/kernel/fork.c:1832
[<      none      >] SyS_clone+0x37/0x50 kernel/kernel/fork.c:1826
[<      none      >] entry_SYSCALL_64_fastpath+0x16/0x7a kernel/arch/x86/entry/entry_64.S:185

INFO: Freed in net_drop_ns+0x67/0x80 age=575 cpu=2 pid=2631
[<      none      >] __slab_free+0x1fc/0x320 kernel/mm/slub.c:2650
[<     inline     >] slab_free kernel/mm/slub.c:2805
[<      none      >] kmem_cache_free+0x2a0/0x330 kernel/mm/slub.c:2814
[<     inline     >] net_free kernel/net/core/net_namespace.c:341
[<      none      >] net_drop_ns+0x67/0x80 kernel/net/core/net_namespace.c:348
[<      none      >] cleanup_net+0x4e5/0x600 kernel/net/core/net_namespace.c:448
[<      none      >] process_one_work+0x794/0x1440 kernel/kernel/workqueue.c:2036
[<      none      >] worker_thread+0xdb/0xfc0 kernel/kernel/workqueue.c:2170
[<      none      >] kthread+0x23f/0x2d0 kernel/drivers/block/aoe/aoecmd.c:1303
[<      none      >] ret_from_fork+0x3f/0x70 kernel/arch/x86/entry/entry_64.S:468
INFO: Slab 0xffffea0001938800 objects=3 used=0 fp=0xffff880064e20000
flags=0x5fffc0000004080
INFO: Object 0xffff880064e20000 @offset=0 fp=0xffff880064e24200

CPU: 1 PID: 11581 Comm: syz-executor Tainted: G    B           4.4.0+
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
rel-1.8.2-0-g33fbe13 by qemu-project.org 04/01/2014
 00000000ffffffff ffff8800662c7790 ffffffff8292049d ffff88003e36a300
 ffff880064e20000 ffff880064e20000 ffff8800662c77c0 ffffffff816f2054
 ffff88003e36a300 ffffea0001938800 ffff880064e20000 0000000000000000
Call Trace:
 [<     inline     >] __dump_stack kernel/lib/dump_stack.c:15
 [<ffffffff8292049d>] dump_stack+0x6f/0xa2 kernel/lib/dump_stack.c:50
 [<ffffffff816f2054>] print_trailer+0xf4/0x150 kernel/mm/slub.c:654
 [<ffffffff816f875f>] object_err+0x2f/0x40 kernel/mm/slub.c:661
 [<     inline     >] print_address_description kernel/mm/kasan/report.c:138
 [<ffffffff816fb0c5>] kasan_report_error+0x215/0x530 kernel/mm/kasan/report.c:236
 [<     inline     >] kasan_report kernel/mm/kasan/report.c:259
 [<ffffffff816fb4de>] __asan_report_load8_noabort+0x3e/0x40 kernel/mm/kasan/report.c:280
 [<     inline     >] ? ppp_pernet kernel/include/linux/compiler.h:218
 [<ffffffff83ad71b2>] ? ppp_unregister_channel+0x372/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392
 [<     inline     >] ppp_pernet kernel/include/linux/compiler.h:218
 [<ffffffff83ad71b2>] ppp_unregister_channel+0x372/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392
 [<     inline     >] ? ppp_pernet kernel/drivers/net/ppp/ppp_generic.c:293
 [<ffffffff83ad6f26>] ? ppp_unregister_channel+0xe6/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392
 [<ffffffff83ae18f3>] ppp_asynctty_close+0xa3/0x130 kernel/drivers/net/ppp/ppp_async.c:241
 [<ffffffff83ae1850>] ? async_lcp_peek+0x5b0/0x5b0 kernel/drivers/net/ppp/ppp_async.c:1000
 [<ffffffff82c33239>] tty_ldisc_close.isra.1+0x99/0xe0 kernel/drivers/tty/tty_ldisc.c:478
 [<ffffffff82c332c0>] tty_ldisc_kill+0x40/0x170 kernel/drivers/tty/tty_ldisc.c:744
 [<ffffffff82c34943>] tty_ldisc_release+0x1b3/0x260 kernel/drivers/tty/tty_ldisc.c:772
 [<ffffffff82c1ef21>] tty_release+0xac1/0x13e0 kernel/drivers/tty/tty_io.c:1901
 [<ffffffff82c1e460>] ? release_tty+0x320/0x320 kernel/drivers/tty/tty_io.c:1688
 [<ffffffff8174de36>] __fput+0x236/0x780 kernel/fs/file_table.c:208
 [<ffffffff8174e405>] ____fput+0x15/0x20 kernel/fs/file_table.c:244
 [<ffffffff813595ab>] task_work_run+0x16b/0x200 kernel/kernel/task_work.c:115
 [<     inline     >] exit_task_work kernel/include/linux/task_work.h:21
 [<ffffffff81307105>] do_exit+0x8b5/0x2c60 kernel/kernel/exit.c:750
 [<ffffffff813fdd20>] ? debug_check_no_locks_freed+0x290/0x290 kernel/kernel/locking/lockdep.c:4123
 [<ffffffff81306850>] ? mm_update_next_owner+0x6f0/0x6f0 kernel/kernel/exit.c:357
 [<ffffffff813215e6>] ? __dequeue_signal+0x136/0x470 kernel/kernel/signal.c:550
 [<ffffffff8132067b>] ? recalc_sigpending_tsk+0x13b/0x180 kernel/kernel/signal.c:145
 [<ffffffff81309628>] do_group_exit+0x108/0x330 kernel/kernel/exit.c:880
 [<ffffffff8132b9d4>] get_signal+0x5e4/0x14f0 kernel/kernel/signal.c:2307
 [<     inline     >] ? kretprobe_table_lock kernel/kernel/kprobes.c:1113
 [<ffffffff8151d355>] ? kprobe_flush_task+0xb5/0x450 kernel/kernel/kprobes.c:1158
 [<ffffffff8115f7d3>] do_signal+0x83/0x1c90 kernel/arch/x86/kernel/signal.c:712
 [<ffffffff8151d2a0>] ? recycle_rp_inst+0x310/0x310 kernel/include/linux/list.h:655
 [<ffffffff8115f750>] ? setup_sigcontext+0x780/0x780 kernel/arch/x86/kernel/signal.c:165
 [<ffffffff81380864>] ? finish_task_switch+0x424/0x5f0 kernel/kernel/sched/core.c:2692
 [<     inline     >] ? finish_lock_switch kernel/kernel/sched/sched.h:1099
 [<ffffffff81380560>] ? finish_task_switch+0x120/0x5f0 kernel/kernel/sched/core.c:2678
 [<     inline     >] ? context_switch kernel/kernel/sched/core.c:2807
 [<ffffffff85d794e9>] ? __schedule+0x919/0x1bd0 kernel/kernel/sched/core.c:3283
 [<ffffffff81003901>] exit_to_usermode_loop+0xf1/0x1a0 kernel/arch/x86/entry/common.c:247
 [<     inline     >] prepare_exit_to_usermode kernel/arch/x86/entry/common.c:282
 [<ffffffff810062ef>] syscall_return_slowpath+0x19f/0x210 kernel/arch/x86/entry/common.c:344
 [<ffffffff85d88022>] int_ret_from_sys_call+0x25/0x9f kernel/arch/x86/entry/entry_64.S:281
Memory state around the buggy address:
 ffff880064e21680: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff880064e21700: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
>ffff880064e21780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                                       ^
 ffff880064e21800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff880064e21880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
==================================================================

Fixes: 273ec51dd7ce (""net: ppp_generic - introduce net-namespace functionality v2"")
Reported-by: Baozeng Ding <sploving1@gmail.com>
Signed-off-by: Guillaume Nault <g.nault@alphalink.fr>
Reviewed-by: Cyrill Gorcunov <gorcunov@openvz.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,drivers/net/ppp/ppp_generic.c,"{""sha"": ""f572b31a2b20cef55e560b8db932c419f14bd8b3"", ""filename"": ""drivers/net/ppp/ppp_generic.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89/drivers/net/ppp/ppp_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89/drivers/net/ppp/ppp_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ppp/ppp_generic.c?ref=1f461dcdd296eecedaffffc6bae2bfa90bd7eb89"", ""patch"": ""@@ -2307,7 +2307,7 @@ int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)\n \n \tpch->ppp = NULL;\n \tpch->chan = chan;\n-\tpch->chan_net = net;\n+\tpch->chan_net = get_net(net);\n \tchan->ppp = pch;\n \tinit_ppp_file(&pch->file, CHANNEL);\n \tpch->file.hdrlen = chan->hdrlen;\n@@ -2404,6 +2404,8 @@ ppp_unregister_channel(struct ppp_channel *chan)\n \tspin_lock_bh(&pn->all_channels_lock);\n \tlist_del(&pch->list);\n \tspin_unlock_bh(&pn->all_channels_lock);\n+\tput_net(pch->chan_net);\n+\tpch->chan_net = NULL;\n \n \tpch->file.dead = 1;\n \twake_up_interruptible(&pch->file.rwait);""}","ppp_unregister_channel(struct ppp_channel *chan)
{
	struct channel *pch = chan->ppp;
	struct ppp_net *pn;

	if (!pch)
		return;		/* should never happen */

	chan->ppp = NULL;

	/*
	 * This ensures that we have returned from any calls into the
	 * the channel's start_xmit or ioctl routine before we proceed.
	 */
	down_write(&pch->chan_sem);
	spin_lock_bh(&pch->downl);
	pch->chan = NULL;
	spin_unlock_bh(&pch->downl);
	up_write(&pch->chan_sem);
	ppp_disconnect_channel(pch);

	pn = ppp_pernet(pch->chan_net);
 	spin_lock_bh(&pn->all_channels_lock);
 	list_del(&pch->list);
 	spin_unlock_bh(&pn->all_channels_lock);
	put_net(pch->chan_net);
	pch->chan_net = NULL;
 
 	pch->file.dead = 1;
 	wake_up_interruptible(&pch->file.rwait);
	if (atomic_dec_and_test(&pch->file.refcnt))
		ppp_destroy_channel(pch);
}
","ppp_unregister_channel(struct ppp_channel *chan)
{
	struct channel *pch = chan->ppp;
	struct ppp_net *pn;

	if (!pch)
		return;		/* should never happen */

	chan->ppp = NULL;

	/*
	 * This ensures that we have returned from any calls into the
	 * the channel's start_xmit or ioctl routine before we proceed.
	 */
	down_write(&pch->chan_sem);
	spin_lock_bh(&pch->downl);
	pch->chan = NULL;
	spin_unlock_bh(&pch->downl);
	up_write(&pch->chan_sem);
	ppp_disconnect_channel(pch);

	pn = ppp_pernet(pch->chan_net);
 	spin_lock_bh(&pn->all_channels_lock);
 	list_del(&pch->list);
 	spin_unlock_bh(&pn->all_channels_lock);
 
 	pch->file.dead = 1;
 	wake_up_interruptible(&pch->file.rwait);
	if (atomic_dec_and_test(&pch->file.refcnt))
		ppp_destroy_channel(pch);
}
",C,"	put_net(pch->chan_net);
	pch->chan_net = NULL;
",,,"@@ -2307,7 +2307,7 @@ int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)
 
 	pch->ppp = NULL;
 	pch->chan = chan;
-	pch->chan_net = net;
+	pch->chan_net = get_net(net);
 	chan->ppp = pch;
 	init_ppp_file(&pch->file, CHANNEL);
 	pch->file.hdrlen = chan->hdrlen;
@@ -2404,6 +2404,8 @@ ppp_unregister_channel(struct ppp_channel *chan)
 	spin_lock_bh(&pn->all_channels_lock);
 	list_del(&pch->list);
 	spin_unlock_bh(&pn->all_channels_lock);
+	put_net(pch->chan_net);
+	pch->chan_net = NULL;
 
 	pch->file.dead = 1;
 	wake_up_interruptible(&pch->file.rwait);",linux,1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,5197f3499c470ccc4b247db66ff883e597e3adda,1,"ppp_unregister_channel(struct ppp_channel *chan)
{
	struct channel *pch = chan->ppp;
	struct ppp_net *pn;

	if (!pch)
		return;		/* should never happen */

	chan->ppp = NULL;

	/*
	 * This ensures that we have returned from any calls into the
	 * the channel's start_xmit or ioctl routine before we proceed.
	 */
	down_write(&pch->chan_sem);
	spin_lock_bh(&pch->downl);
	pch->chan = NULL;
	spin_unlock_bh(&pch->downl);
	up_write(&pch->chan_sem);
	ppp_disconnect_channel(pch);

	pn = ppp_pernet(pch->chan_net);
 	spin_lock_bh(&pn->all_channels_lock);
 	list_del(&pch->list);
 	spin_unlock_bh(&pn->all_channels_lock);
//fix_flaw_line_below:
//	put_net(pch->chan_net);
//fix_flaw_line_below:
//	pch->chan_net = NULL;
 
 	pch->file.dead = 1;
 	wake_up_interruptible(&pch->file.rwait);
	if (atomic_dec_and_test(&pch->file.refcnt))
		ppp_destroy_channel(pch);
}
",180402,"ppp_unregister_channel(struct ppp_channel *chan)
{
	struct channel *pch = chan->ppp;
	struct ppp_net *pn;

	if (!pch)
		return;		/* should never happen */

	chan->ppp = NULL;

	/*
	 * This ensures that we have returned from any calls into the
	 * the channel's start_xmit or ioctl routine before we proceed.
	 */
	down_write(&pch->chan_sem);
	spin_lock_bh(&pch->downl);
	pch->chan = NULL;
	spin_unlock_bh(&pch->downl);
	up_write(&pch->chan_sem);
	ppp_disconnect_channel(pch);

	pn = ppp_pernet(pch->chan_net);
 	spin_lock_bh(&pn->all_channels_lock);
 	list_del(&pch->list);
 	spin_unlock_bh(&pn->all_channels_lock);
 
 	pch->file.dead = 1;
 	wake_up_interruptible(&pch->file.rwait);
	if (atomic_dec_and_test(&pch->file.refcnt))
		ppp_destroy_channel(pch);
}
","ppp_unregister_channel(struct ppp_channel *chan)
{
	struct channel *pch = chan->ppp;
	struct ppp_net *pn;

	if (!pch)
		return;		/* should never happen */

	chan->ppp = NULL;

	/*
	 * This ensures that we have returned from any calls into the
	 * the channel's start_xmit or ioctl routine before we proceed.
	 */
	down_write(&pch->chan_sem);
	spin_lock_bh(&pch->downl);
	pch->chan = NULL;
	spin_unlock_bh(&pch->downl);
	up_write(&pch->chan_sem);
	ppp_disconnect_channel(pch);

	pn = ppp_pernet(pch->chan_net);
 	spin_lock_bh(&pn->all_channels_lock);
 	list_del(&pch->list);
 	spin_unlock_bh(&pn->all_channels_lock);
	put_net(pch->chan_net);
	pch->chan_net = NULL;
 
 	pch->file.dead = 1;
 	wake_up_interruptible(&pch->file.rwait);
	if (atomic_dec_and_test(&pch->file.refcnt))
		ppp_destroy_channel(pch);
}
","The `ppp_unregister_channel` function is responsible for safely unregistering a PPP (Point-to-Point Protocol) channel from the system. It first checks if the provided channel structure is valid, then sets its PPP pointer to NULL. The function ensures that any ongoing operations, such as transmission or IO control, are completed by acquiring a write lock on the channel's semaphore. It subsequently clears the channel reference, disconnects it, and removes it from the list of all channels while managing concurrency with spin locks. Finally, it marks the channel as dead, wakes any waiting processes, and decrements the reference count, potentially leading to the channel's destruction if no references remain.","The provided code defines a function that unregisters a communication channel from a protocol framework. It begins by verifying the validity of the channel and then nullifies its reference to the protocol. The function ensures that any ongoing operations are completed by acquiring necessary locks to prevent concurrent access. It subsequently disconnects the channel and removes it from a list of active channels while maintaining thread safety. Finally, it marks the channel as inactive, notifies any waiting processes, and decreases the reference count, potentially leading to the channel's cleanup if no references remain.","The vulnerability in the original code stemmed from a use-after-free condition, where a channel could access its network namespace after it had been freed, leading to potential crashes or undefined behavior. This occurred because the code did not maintain a reference to the network namespace while the channel was in use, allowing it to be removed while still being accessed. The fix involved adding a reference to the network namespace using `put_net(pch->chan_net)` after the channel was unregistered, ensuring that the namespace remains valid for the duration of the channel's operations, thus preventing any access to freed memory.","The vulnerability in the original code was a use-after-free issue, where a channel could access its network namespace after it had been freed, leading to potential crashes or undefined behavior. This occurred because the code did not maintain a reference to the network namespace while the channel was in use, allowing it to be removed while still being accessed. The fix involved ensuring that channels hold a reference to their network namespace, preventing it from being freed while the channel is still operational. This change guarantees that the network namespace remains valid for the channel's lifetime, thus eliminating the risk of accessing freed memory.","The vulnerability was fixed by adding a reference to the network namespace within the `ppp_unregister_channel` function. Specifically, the code now includes a call to `put_net(pch->chan_net)` after the channel is unregistered, ensuring that the network namespace remains valid while the channel is still in use. This change prevents the network namespace from being freed prematurely, which could lead to a use-after-free condition. Additionally, the channel's network namespace pointer is set to NULL, further safeguarding against accidental access to freed memory, thus enhancing the overall stability and safety of the code.","The vulnerability was addressed by ensuring that the channel maintains a valid reference to its associated network namespace throughout its lifecycle. This was accomplished by implementing a mechanism that prevents the network namespace from being freed while the channel is still in use. By holding a reference to the namespace, the code guarantees that it remains accessible and valid, thereby eliminating the risk of accessing freed memory. Additionally, the code was modified to nullify the pointer to the network namespace once it is no longer needed, further enhancing safety and preventing accidental access to invalid memory.","CWE-416,CWE-825,CWE-672,CWE-415,CWE-476,CWE-664,CWE-665,CWE-119,CWE-404,CWE-666",Y,1
17,17,180637,180637,,Remote,Not required,Complete,CVE-2015-8961,https://www.cvedetails.com/cve/CVE-2015-8961/,CWE-416,Medium,Complete,Complete,,2016-11-16,9.3,The __ext4_journal_stop function in fs/ext4/ext4_jbd2.c in the Linux kernel before 4.3.3 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging improper access to a certain error field.,2017-01-17,DoS +Priv ,3,https://github.com/torvalds/linux/commit/6934da9238da947628be83635e365df41064b09b,6934da9238da947628be83635e365df41064b09b,"ext4: fix potential use after free in __ext4_journal_stop

There is a use-after-free possibility in __ext4_journal_stop() in the
case that we free the handle in the first jbd2_journal_stop() because
we're referencing handle->h_err afterwards. This was introduced in
9705acd63b125dee8b15c705216d7186daea4625 and it is wrong. Fix it by
storing the handle->h_err value beforehand and avoid referencing
potentially freed handle.

Fixes: 9705acd63b125dee8b15c705216d7186daea4625
Signed-off-by: Lukas Czerner <lczerner@redhat.com>
Reviewed-by: Andreas Dilger <adilger@dilger.ca>
Cc: stable@vger.kernel.org",3,fs/ext4/ext4_jbd2.c,"{""sha"": ""e770c1ee4613ed6084518f2ec9dca0ff9e53a29a"", ""filename"": ""fs/ext4/ext4_jbd2.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/6934da9238da947628be83635e365df41064b09b/fs/ext4/ext4_jbd2.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/6934da9238da947628be83635e365df41064b09b/fs/ext4/ext4_jbd2.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/ext4/ext4_jbd2.c?ref=6934da9238da947628be83635e365df41064b09b"", ""patch"": ""@@ -88,13 +88,13 @@ int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n \t\treturn 0;\n \t}\n \n+\terr = handle->h_err;\n \tif (!handle->h_transaction) {\n-\t\terr = jbd2_journal_stop(handle);\n-\t\treturn handle->h_err ? handle->h_err : err;\n+\t\trc = jbd2_journal_stop(handle);\n+\t\treturn err ? err : rc;\n \t}\n \n \tsb = handle->h_transaction->t_journal->j_private;\n-\terr = handle->h_err;\n \trc = jbd2_journal_stop(handle);\n \n \tif (!err)""}","int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)
{
	struct super_block *sb;
	int err;
	int rc;

	if (!ext4_handle_valid(handle)) {
		ext4_put_nojournal(handle);
 		return 0;
 	}
 
	err = handle->h_err;
 	if (!handle->h_transaction) {
		rc = jbd2_journal_stop(handle);
		return err ? err : rc;
 	}
 
 	sb = handle->h_transaction->t_journal->j_private;
 	rc = jbd2_journal_stop(handle);
 
 	if (!err)
		err = rc;
	if (err)
		__ext4_std_error(sb, where, line, err);
	return err;
}
","int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)
{
	struct super_block *sb;
	int err;
	int rc;

	if (!ext4_handle_valid(handle)) {
		ext4_put_nojournal(handle);
 		return 0;
 	}
 
 	if (!handle->h_transaction) {
		err = jbd2_journal_stop(handle);
		return handle->h_err ? handle->h_err : err;
 	}
 
 	sb = handle->h_transaction->t_journal->j_private;
	err = handle->h_err;
 	rc = jbd2_journal_stop(handle);
 
 	if (!err)
		err = rc;
	if (err)
		__ext4_std_error(sb, where, line, err);
	return err;
}
",C,"	err = handle->h_err;
		rc = jbd2_journal_stop(handle);
		return err ? err : rc;
","		err = jbd2_journal_stop(handle);
		return handle->h_err ? handle->h_err : err;
	err = handle->h_err;
",,"@@ -88,13 +88,13 @@ int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)
 		return 0;
 	}
 
+	err = handle->h_err;
 	if (!handle->h_transaction) {
-		err = jbd2_journal_stop(handle);
-		return handle->h_err ? handle->h_err : err;
+		rc = jbd2_journal_stop(handle);
+		return err ? err : rc;
 	}
 
 	sb = handle->h_transaction->t_journal->j_private;
-	err = handle->h_err;
 	rc = jbd2_journal_stop(handle);
 
 	if (!err)",linux,6934da9238da947628be83635e365df41064b09b,33d14975e5ac469963d5d63856b61698ad0bff07,1,"int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)
{
	struct super_block *sb;
	int err;
	int rc;

	if (!ext4_handle_valid(handle)) {
		ext4_put_nojournal(handle);
 		return 0;
 	}
 
//fix_flaw_line_below:
//	err = handle->h_err;
 	if (!handle->h_transaction) {
//flaw_line_below:
		err = jbd2_journal_stop(handle);
//flaw_line_below:
		return handle->h_err ? handle->h_err : err;
//fix_flaw_line_below:
//		rc = jbd2_journal_stop(handle);
//fix_flaw_line_below:
//		return err ? err : rc;
 	}
 
 	sb = handle->h_transaction->t_journal->j_private;
//flaw_line_below:
	err = handle->h_err;
 	rc = jbd2_journal_stop(handle);
 
 	if (!err)
		err = rc;
	if (err)
		__ext4_std_error(sb, where, line, err);
	return err;
}
",180637,"int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)
{
	struct super_block *sb;
	int err;
	int rc;

	if (!ext4_handle_valid(handle)) {
		ext4_put_nojournal(handle);
 		return 0;
 	}
 
 	if (!handle->h_transaction) {
		err = jbd2_journal_stop(handle);
		return handle->h_err ? handle->h_err : err;
 	}
 
 	sb = handle->h_transaction->t_journal->j_private;
	err = handle->h_err;
 	rc = jbd2_journal_stop(handle);
 
 	if (!err)
		err = rc;
	if (err)
		__ext4_std_error(sb, where, line, err);
	return err;
}
","int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)
{
	struct super_block *sb;
	int err;
	int rc;

	if (!ext4_handle_valid(handle)) {
		ext4_put_nojournal(handle);
 		return 0;
 	}
 
	err = handle->h_err;
 	if (!handle->h_transaction) {
		rc = jbd2_journal_stop(handle);
		return err ? err : rc;
 	}
 
 	sb = handle->h_transaction->t_journal->j_private;
 	rc = jbd2_journal_stop(handle);
 
 	if (!err)
		err = rc;
	if (err)
		__ext4_std_error(sb, where, line, err);
	return err;
}
","The function `__ext4_journal_stop` is responsible for stopping a journal transaction in the ext4 filesystem. It first checks if the provided handle is valid; if not, it releases the handle and returns zero. If the handle does not have an associated transaction, it calls `jbd2_journal_stop` to stop the journal and returns any error encountered. If a transaction exists, it retrieves the superblock and checks for errors in the handle. It then attempts to stop the journal again, logging any errors using `__ext4_std_error` if necessary, and returns the final error code.","The provided code defines a function that manages the stopping of a journal transaction within a filesystem. It first verifies the validity of a transaction handle, returning immediately if it is invalid. If the handle lacks an active transaction, the function attempts to stop the journal and returns any encountered error. If a transaction is present, it retrieves associated metadata and checks for existing errors. The function then attempts to stop the journal again, logging any errors that arise during this process, and ultimately returns the appropriate error code, ensuring proper error handling throughout.","The vulnerability in the original code arises from a potential use-after-free scenario, where the handle could be freed during the first call to `jbd2_journal_stop`, yet the code subsequently references `handle->h_err`, which may lead to undefined behavior. This issue was introduced in a previous commit and was addressed by modifying the code to store the value of `handle->h_err` before any potential freeing occurs. By capturing this value early, the fixed code ensures that it does not reference a potentially freed handle, thus eliminating the risk of accessing invalid memory.","The vulnerability in the original code stems from a potential use-after-free condition, where a resource could be deallocated during a function call, yet the code later attempts to access a value from that resource. This situation could lead to accessing invalid memory, resulting in undefined behavior. The fix involved capturing the value of the relevant error state before any potential deallocation occurs, ensuring that the code does not reference a resource that may have already been freed. This change effectively mitigates the risk of accessing invalid memory and enhances the overall stability of the function.","The vulnerability was fixed by modifying the code to store the value of `handle->h_err` before any potential freeing of the handle occurs. In the original code, if the first call to `jbd2_journal_stop` resulted in freeing the handle, subsequent references to `handle->h_err` could lead to accessing invalid memory. The revised code captures the error state early, ensuring that it uses a valid value regardless of whether the handle is freed later. This change prevents the use-after-free issue by ensuring that the error value is safely stored and accessed without risking invalid memory access.","The vulnerability was addressed by ensuring that the error state was captured and stored before any potential deallocation of the resource occurred. By doing this, the code avoids referencing a value that could become invalid if the resource were freed during a function call. The fix involved rearranging the logic to first save the necessary information, thereby safeguarding it from being affected by subsequent operations that might lead to deallocation. This change effectively eliminates the risk of accessing invalid memory, enhancing the stability and reliability of the function.","CWE-416, CWE-415, CWE-825, CWE-672, CWE-911, CWE-666, CWE-910, CWE-476, CWE-456, CWE-908",Y,1
18,18,180801,180801,,Remote,Not required,,CVE-2017-1000211,https://www.cvedetails.com/cve/CVE-2017-1000211/,CWE-416,Low,Partial,,,2017-11-17,5.0,"Lynx before 2.8.9dev.16 is vulnerable to a use after free in the HTML parser resulting in memory disclosure, because HTML_put_string() can append a chunk onto itself.",2018-02-03,,18,https://github.com/ThomasDickey/lynx-snapshots/commit/280a61b300a1614f6037efc0902ff7ecf17146e9,280a61b300a1614f6037efc0902ff7ecf17146e9,"snapshot of project ""lynx"", label v2-8-9dev_15b",7,src/HTML.c,"{""sha"": ""641bd27747db2dabcd8eb41f35b6f9248f526d05"", ""filename"": ""CHANGES"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/ThomasDickey/lynx-snapshots/blob/280a61b300a1614f6037efc0902ff7ecf17146e9/CHANGES"", ""raw_url"": ""https://github.com/ThomasDickey/lynx-snapshots/raw/280a61b300a1614f6037efc0902ff7ecf17146e9/CHANGES"", ""contents_url"": ""https://api.github.com/repos/ThomasDickey/lynx-snapshots/contents/CHANGES?ref=280a61b300a1614f6037efc0902ff7ecf17146e9"", ""patch"": ""@@ -1,9 +1,11 @@\n--- $LynxId: CHANGES,v 1.910 2017/07/05 20:39:40 tom Exp $\n+-- $LynxId: CHANGES,v 1.911 2017/07/05 22:23:00 tom Exp $\n ===============================================================================\n Changes since Lynx 2.8 release\n ===============================================================================\n \n 2017-07-05 (2.8.9dev.16)\n+* add a check to ensure that HTML_put_string() will not append a chunk onto\n+  itself (report by Ned Williamson) -TD\n * update et.po, tr.po from\n     http://translationproject.org/latest/lynx\n ""}<_**next**_>{""sha"": ""a2345b7e5447376f358568d187be471ce6c33e9a"", ""filename"": ""PACKAGE/debian/lynx-dev.lintian-overrides"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/ThomasDickey/lynx-snapshots/blob/280a61b300a1614f6037efc0902ff7ecf17146e9/PACKAGE/debian/lynx-dev.lintian-overrides"", ""raw_url"": ""https://github.com/ThomasDickey/lynx-snapshots/raw/280a61b300a1614f6037efc0902ff7ecf17146e9/PACKAGE/debian/lynx-dev.lintian-overrides"", ""contents_url"": ""https://api.github.com/repos/ThomasDickey/lynx-snapshots/contents/PACKAGE/debian/lynx-dev.lintian-overrides?ref=280a61b300a1614f6037efc0902ff7ecf17146e9"", ""patch"": ""@@ -1,5 +1,5 @@\n # Lynx's version-numbering is not understood by lintian, though legal.\n-lynx-dev: rc-version-greater-than-expected-version 2.8.9dev.15 > 2.8.9 (consider using 2.8.9~dev.15)\n+lynx-dev: rc-version-greater-than-expected-version\n \n # This is intentional because it is referenced from the documentation.\n lynx-dev: extra-license-file usr/share/doc/lynx-dev/COPYING""}<_**next**_>{""sha"": ""63d6720644aa89348cb119fee6dbd9fcb4074bce"", ""filename"": ""src/HTML.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 8, ""changes"": 27, ""blob_url"": ""https://github.com/ThomasDickey/lynx-snapshots/blob/280a61b300a1614f6037efc0902ff7ecf17146e9/src/HTML.c"", ""raw_url"": ""https://github.com/ThomasDickey/lynx-snapshots/raw/280a61b300a1614f6037efc0902ff7ecf17146e9/src/HTML.c"", ""contents_url"": ""https://api.github.com/repos/ThomasDickey/lynx-snapshots/contents/src/HTML.c?ref=280a61b300a1614f6037efc0902ff7ecf17146e9"", ""patch"": ""@@ -1,5 +1,5 @@\n /*\n- * $LynxId: HTML.c,v 1.173 2017/07/04 20:05:01 tom Exp $\n+ * $LynxId: HTML.c,v 1.174 2017/07/05 22:48:09 tom Exp $\n  *\n  *\t\tStructured stream to Rich hypertext converter\n  *\t\t============================================\n@@ -505,6 +505,8 @@ void HTML_put_character(HTStructured * me, int c)\n  */\n void HTML_put_string(HTStructured * me, const char *s)\n {\n+    HTChunk *target = NULL;\n+\n #ifdef USE_PRETTYSRC\n     char *translated_string = NULL;\n #endif\n@@ -525,15 +527,15 @@ void HTML_put_string(HTStructured * me, const char *s)\n \tbreak;\t\t\t/* Do Nothing */\n \n     case HTML_TITLE:\n-\tHTChunkPuts(&me->title, s);\n+\ttarget = &me->title;\n \tbreak;\n \n     case HTML_STYLE:\n-\tHTChunkPuts(&me->style_block, s);\n+\ttarget = &me->style_block;\n \tbreak;\n \n     case HTML_SCRIPT:\n-\tHTChunkPuts(&me->script, s);\n+\ttarget = &me->script;\n \tbreak;\n \n     case HTML_PRE:\t\t/* Formatted text */\n@@ -547,20 +549,20 @@ void HTML_put_string(HTStructured * me, const char *s)\n \tbreak;\n \n     case HTML_OBJECT:\n-\tHTChunkPuts(&me->object, s);\n+\ttarget = &me->object;\n \tbreak;\n \n     case HTML_TEXTAREA:\n-\tHTChunkPuts(&me->textarea, s);\n+\ttarget = &me->textarea;\n \tbreak;\n \n     case HTML_SELECT:\n     case HTML_OPTION:\n-\tHTChunkPuts(&me->option, s);\n+\ttarget = &me->option;\n \tbreak;\n \n     case HTML_MATH:\n-\tHTChunkPuts(&me->math, s);\n+\ttarget = &me->math;\n \tbreak;\n \n     default:\t\t\t/* Free format text? */\n@@ -651,6 +653,15 @@ void HTML_put_string(HTStructured * me, const char *s)\n \t    }\t\t\t/* for */\n \t}\n     }\t\t\t\t/* end switch */\n+\n+    if (target != NULL) {\n+\tif (target->data == s) {\n+\t    CTRACE((tfp, \""BUG: appending chunk to itself: `%.*s'\\n\"",\n+\t\t    target->size, target->data));\n+\t} else {\n+\t    HTChunkPuts(target, s);\n+\t}\n+    }\n #ifdef USE_PRETTYSRC\n     if (psrc_convert_string) {\n \tpsrc_convert_string = FALSE;""}"," void HTML_put_string(HTStructured * me, const char *s)
 {
    HTChunk *target = NULL;

 #ifdef USE_PRETTYSRC
     char *translated_string = NULL;
 #endif

    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))
	return;
#ifdef USE_PRETTYSRC
    if (psrc_convert_string) {
	StrAllocCopy(translated_string, s);
	TRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);
	s = (const char *) translated_string;
    }
#endif

    switch (me->sp[0].tag_number) {

    case HTML_COMMENT:
 	break;			/* Do Nothing */
 
     case HTML_TITLE:
	target = &me->title;
 	break;
 
     case HTML_STYLE:
	target = &me->style_block;
 	break;
 
     case HTML_SCRIPT:
	target = &me->script;
 	break;
 
     case HTML_PRE:		/* Formatted text */
    case HTML_LISTING:		/* Literal text */
    case HTML_XMP:
    case HTML_PLAINTEXT:
	/*
	 * We guarantee that the style is up-to-date in begin_litteral
	 */
	HText_appendText(me->text, s);
 	break;
 
     case HTML_OBJECT:
	target = &me->object;
 	break;
 
     case HTML_TEXTAREA:
	target = &me->textarea;
 	break;
 
     case HTML_SELECT:
     case HTML_OPTION:
	target = &me->option;
 	break;
 
     case HTML_MATH:
	target = &me->math;
 	break;
 
     default:			/* Free format text? */
	if (!me->sp->style->freeFormat) {
	    /*
	     * If we are within a preformatted text style not caught by the
	     * cases above (HTML_PRE or similar may not be the last element
	     * pushed on the style stack).  - kw
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		/*
		 * We do this so that a raw '\r' in the string will not be
		 * interpreted as an internal request to break a line - passing
		 * '\r' to HText_appendText is treated by it as a request to
		 * insert a blank line - VH
		 */
		for (; *s; ++s)
		    HTML_put_character(me, *s);
	    } else
#endif
		HText_appendText(me->text, s);
	    break;
	} else {
	    const char *p = s;
	    char c;

	    if (me->style_change) {
		for (; *p && ((*p == '\n') || (*p == '\r') ||
			      (*p == ' ') || (*p == '\t')); p++) ;	/* Ignore leaders */
		if (!*p)
		    break;
		UPDATE_STYLE;
	    }
	    for (; *p; p++) {
		if (*p == 13 && p[1] != 10) {
		    /*
		     * Treat any '\r' which is not followed by '\n' as '\n', to
		     * account for macintosh lineend in ALT attributes etc.  -
		     * kw
		     */
		    c = '\n';
		} else {
		    c = *p;
		}
		if (me->style_change) {
		    if ((c == '\n') || (c == ' ') || (c == '\t'))
			continue;	/* Ignore it */
		    UPDATE_STYLE;
		}
		if (c == '\n') {
		    if (!FIX_JAPANESE_SPACES) {
			if (me->in_word) {
			    if (HText_getLastChar(me->text) != ' ')
				HText_appendCharacter(me->text, ' ');
			    me->in_word = NO;
			}
		    }

		} else if (c == ' ' || c == '\t') {
		    if (HText_getLastChar(me->text) != ' ')
			HText_appendCharacter(me->text, ' ');

		} else if (c == '\r') {
		    /* ignore */
		} else {
		    HText_appendCharacter(me->text, c);
		    me->in_word = YES;
		}

		/* set the Last Character */
		if (c == '\n' || c == '\t') {
		    /* set it to a generic separator */
		    HText_setLastChar(me->text, ' ');
		} else if (c == '\r' &&
			   HText_getLastChar(me->text) == ' ') {
		    /*
		     * \r's are ignored.  In order to keep collapsing spaces
		     * correctly, we must default back to the previous
		     * separator, if there was one.  So we set LastChar to a
		     * generic separator.
		     */
		    HText_setLastChar(me->text, ' ');
		} else {
		    HText_setLastChar(me->text, c);
		}

 	    }			/* for */
 	}
     }				/* end switch */

    if (target != NULL) {
	if (target->data == s) {
	    CTRACE((tfp, ""BUG: appending chunk to itself: `%.*s'\n"",
		    target->size, target->data));
	} else {
	    HTChunkPuts(target, s);
	}
    }
 #ifdef USE_PRETTYSRC
     if (psrc_convert_string) {
 	psrc_convert_string = FALSE;
	FREE(translated_string);
    }
#endif
}
"," void HTML_put_string(HTStructured * me, const char *s)
 {
 #ifdef USE_PRETTYSRC
     char *translated_string = NULL;
 #endif

    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))
	return;
#ifdef USE_PRETTYSRC
    if (psrc_convert_string) {
	StrAllocCopy(translated_string, s);
	TRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);
	s = (const char *) translated_string;
    }
#endif

    switch (me->sp[0].tag_number) {

    case HTML_COMMENT:
 	break;			/* Do Nothing */
 
     case HTML_TITLE:
	HTChunkPuts(&me->title, s);
 	break;
 
     case HTML_STYLE:
	HTChunkPuts(&me->style_block, s);
 	break;
 
     case HTML_SCRIPT:
	HTChunkPuts(&me->script, s);
 	break;
 
     case HTML_PRE:		/* Formatted text */
    case HTML_LISTING:		/* Literal text */
    case HTML_XMP:
    case HTML_PLAINTEXT:
	/*
	 * We guarantee that the style is up-to-date in begin_litteral
	 */
	HText_appendText(me->text, s);
 	break;
 
     case HTML_OBJECT:
	HTChunkPuts(&me->object, s);
 	break;
 
     case HTML_TEXTAREA:
	HTChunkPuts(&me->textarea, s);
 	break;
 
     case HTML_SELECT:
     case HTML_OPTION:
	HTChunkPuts(&me->option, s);
 	break;
 
     case HTML_MATH:
	HTChunkPuts(&me->math, s);
 	break;
 
     default:			/* Free format text? */
	if (!me->sp->style->freeFormat) {
	    /*
	     * If we are within a preformatted text style not caught by the
	     * cases above (HTML_PRE or similar may not be the last element
	     * pushed on the style stack).  - kw
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		/*
		 * We do this so that a raw '\r' in the string will not be
		 * interpreted as an internal request to break a line - passing
		 * '\r' to HText_appendText is treated by it as a request to
		 * insert a blank line - VH
		 */
		for (; *s; ++s)
		    HTML_put_character(me, *s);
	    } else
#endif
		HText_appendText(me->text, s);
	    break;
	} else {
	    const char *p = s;
	    char c;

	    if (me->style_change) {
		for (; *p && ((*p == '\n') || (*p == '\r') ||
			      (*p == ' ') || (*p == '\t')); p++) ;	/* Ignore leaders */
		if (!*p)
		    break;
		UPDATE_STYLE;
	    }
	    for (; *p; p++) {
		if (*p == 13 && p[1] != 10) {
		    /*
		     * Treat any '\r' which is not followed by '\n' as '\n', to
		     * account for macintosh lineend in ALT attributes etc.  -
		     * kw
		     */
		    c = '\n';
		} else {
		    c = *p;
		}
		if (me->style_change) {
		    if ((c == '\n') || (c == ' ') || (c == '\t'))
			continue;	/* Ignore it */
		    UPDATE_STYLE;
		}
		if (c == '\n') {
		    if (!FIX_JAPANESE_SPACES) {
			if (me->in_word) {
			    if (HText_getLastChar(me->text) != ' ')
				HText_appendCharacter(me->text, ' ');
			    me->in_word = NO;
			}
		    }

		} else if (c == ' ' || c == '\t') {
		    if (HText_getLastChar(me->text) != ' ')
			HText_appendCharacter(me->text, ' ');

		} else if (c == '\r') {
		    /* ignore */
		} else {
		    HText_appendCharacter(me->text, c);
		    me->in_word = YES;
		}

		/* set the Last Character */
		if (c == '\n' || c == '\t') {
		    /* set it to a generic separator */
		    HText_setLastChar(me->text, ' ');
		} else if (c == '\r' &&
			   HText_getLastChar(me->text) == ' ') {
		    /*
		     * \r's are ignored.  In order to keep collapsing spaces
		     * correctly, we must default back to the previous
		     * separator, if there was one.  So we set LastChar to a
		     * generic separator.
		     */
		    HText_setLastChar(me->text, ' ');
		} else {
		    HText_setLastChar(me->text, c);
		}

 	    }			/* for */
 	}
     }				/* end switch */
 #ifdef USE_PRETTYSRC
     if (psrc_convert_string) {
 	psrc_convert_string = FALSE;
	FREE(translated_string);
    }
#endif
}
",C,"    HTChunk *target = NULL;

	target = &me->title;
	target = &me->style_block;
	target = &me->script;
	target = &me->object;
	target = &me->textarea;
	target = &me->option;
	target = &me->math;

    if (target != NULL) {
	if (target->data == s) {
	    CTRACE((tfp, ""BUG: appending chunk to itself: `%.*s'\n"",
		    target->size, target->data));
	} else {
	    HTChunkPuts(target, s);
	}
    }
","	HTChunkPuts(&me->title, s);
	HTChunkPuts(&me->style_block, s);
	HTChunkPuts(&me->script, s);
	HTChunkPuts(&me->object, s);
	HTChunkPuts(&me->textarea, s);
	HTChunkPuts(&me->option, s);
	HTChunkPuts(&me->math, s);
",,"@@ -1,5 +1,5 @@
 /*
- * $LynxId: HTML.c,v 1.173 2017/07/04 20:05:01 tom Exp $
+ * $LynxId: HTML.c,v 1.174 2017/07/05 22:48:09 tom Exp $
  *
  *		Structured stream to Rich hypertext converter
  *		============================================
@@ -505,6 +505,8 @@ void HTML_put_character(HTStructured * me, int c)
  */
 void HTML_put_string(HTStructured * me, const char *s)
 {
+    HTChunk *target = NULL;
+
 #ifdef USE_PRETTYSRC
     char *translated_string = NULL;
 #endif
@@ -525,15 +527,15 @@ void HTML_put_string(HTStructured * me, const char *s)
 	break;			/* Do Nothing */
 
     case HTML_TITLE:
-	HTChunkPuts(&me->title, s);
+	target = &me->title;
 	break;
 
     case HTML_STYLE:
-	HTChunkPuts(&me->style_block, s);
+	target = &me->style_block;
 	break;
 
     case HTML_SCRIPT:
-	HTChunkPuts(&me->script, s);
+	target = &me->script;
 	break;
 
     case HTML_PRE:		/* Formatted text */
@@ -547,20 +549,20 @@ void HTML_put_string(HTStructured * me, const char *s)
 	break;
 
     case HTML_OBJECT:
-	HTChunkPuts(&me->object, s);
+	target = &me->object;
 	break;
 
     case HTML_TEXTAREA:
-	HTChunkPuts(&me->textarea, s);
+	target = &me->textarea;
 	break;
 
     case HTML_SELECT:
     case HTML_OPTION:
-	HTChunkPuts(&me->option, s);
+	target = &me->option;
 	break;
 
     case HTML_MATH:
-	HTChunkPuts(&me->math, s);
+	target = &me->math;
 	break;
 
     default:			/* Free format text? */
@@ -651,6 +653,15 @@ void HTML_put_string(HTStructured * me, const char *s)
 	    }			/* for */
 	}
     }				/* end switch */
+
+    if (target != NULL) {
+	if (target->data == s) {
+	    CTRACE((tfp, ""BUG: appending chunk to itself: `%.*s'\n"",
+		    target->size, target->data));
+	} else {
+	    HTChunkPuts(target, s);
+	}
+    }
 #ifdef USE_PRETTYSRC
     if (psrc_convert_string) {
 	psrc_convert_string = FALSE;",lynx-snapshots,280a61b300a1614f6037efc0902ff7ecf17146e9,3c6d755816137c48e386c84490f685efcd0066ba,1," void HTML_put_string(HTStructured * me, const char *s)
 {
//fix_flaw_line_below:
//    HTChunk *target = NULL;
//fix_flaw_line_below:
//
 #ifdef USE_PRETTYSRC
     char *translated_string = NULL;
 #endif

    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))
	return;
#ifdef USE_PRETTYSRC
    if (psrc_convert_string) {
	StrAllocCopy(translated_string, s);
	TRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);
	s = (const char *) translated_string;
    }
#endif

    switch (me->sp[0].tag_number) {

    case HTML_COMMENT:
 	break;			/* Do Nothing */
 
     case HTML_TITLE:
//flaw_line_below:
	HTChunkPuts(&me->title, s);
//fix_flaw_line_below:
//	target = &me->title;
 	break;
 
     case HTML_STYLE:
//flaw_line_below:
	HTChunkPuts(&me->style_block, s);
//fix_flaw_line_below:
//	target = &me->style_block;
 	break;
 
     case HTML_SCRIPT:
//flaw_line_below:
	HTChunkPuts(&me->script, s);
//fix_flaw_line_below:
//	target = &me->script;
 	break;
 
     case HTML_PRE:		/* Formatted text */
    case HTML_LISTING:		/* Literal text */
    case HTML_XMP:
    case HTML_PLAINTEXT:
	/*
	 * We guarantee that the style is up-to-date in begin_litteral
	 */
	HText_appendText(me->text, s);
 	break;
 
     case HTML_OBJECT:
//flaw_line_below:
	HTChunkPuts(&me->object, s);
//fix_flaw_line_below:
//	target = &me->object;
 	break;
 
     case HTML_TEXTAREA:
//flaw_line_below:
	HTChunkPuts(&me->textarea, s);
//fix_flaw_line_below:
//	target = &me->textarea;
 	break;
 
     case HTML_SELECT:
     case HTML_OPTION:
//flaw_line_below:
	HTChunkPuts(&me->option, s);
//fix_flaw_line_below:
//	target = &me->option;
 	break;
 
     case HTML_MATH:
//flaw_line_below:
	HTChunkPuts(&me->math, s);
//fix_flaw_line_below:
//	target = &me->math;
 	break;
 
     default:			/* Free format text? */
	if (!me->sp->style->freeFormat) {
	    /*
	     * If we are within a preformatted text style not caught by the
	     * cases above (HTML_PRE or similar may not be the last element
	     * pushed on the style stack).  - kw
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		/*
		 * We do this so that a raw '\r' in the string will not be
		 * interpreted as an internal request to break a line - passing
		 * '\r' to HText_appendText is treated by it as a request to
		 * insert a blank line - VH
		 */
		for (; *s; ++s)
		    HTML_put_character(me, *s);
	    } else
#endif
		HText_appendText(me->text, s);
	    break;
	} else {
	    const char *p = s;
	    char c;

	    if (me->style_change) {
		for (; *p && ((*p == '\n') || (*p == '\r') ||
			      (*p == ' ') || (*p == '\t')); p++) ;	/* Ignore leaders */
		if (!*p)
		    break;
		UPDATE_STYLE;
	    }
	    for (; *p; p++) {
		if (*p == 13 && p[1] != 10) {
		    /*
		     * Treat any '\r' which is not followed by '\n' as '\n', to
		     * account for macintosh lineend in ALT attributes etc.  -
		     * kw
		     */
		    c = '\n';
		} else {
		    c = *p;
		}
		if (me->style_change) {
		    if ((c == '\n') || (c == ' ') || (c == '\t'))
			continue;	/* Ignore it */
		    UPDATE_STYLE;
		}
		if (c == '\n') {
		    if (!FIX_JAPANESE_SPACES) {
			if (me->in_word) {
			    if (HText_getLastChar(me->text) != ' ')
				HText_appendCharacter(me->text, ' ');
			    me->in_word = NO;
			}
		    }

		} else if (c == ' ' || c == '\t') {
		    if (HText_getLastChar(me->text) != ' ')
			HText_appendCharacter(me->text, ' ');

		} else if (c == '\r') {
		    /* ignore */
		} else {
		    HText_appendCharacter(me->text, c);
		    me->in_word = YES;
		}

		/* set the Last Character */
		if (c == '\n' || c == '\t') {
		    /* set it to a generic separator */
		    HText_setLastChar(me->text, ' ');
		} else if (c == '\r' &&
			   HText_getLastChar(me->text) == ' ') {
		    /*
		     * \r's are ignored.  In order to keep collapsing spaces
		     * correctly, we must default back to the previous
		     * separator, if there was one.  So we set LastChar to a
		     * generic separator.
		     */
		    HText_setLastChar(me->text, ' ');
		} else {
		    HText_setLastChar(me->text, c);
		}

 	    }			/* for */
 	}
     }				/* end switch */
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (target != NULL) {
//fix_flaw_line_below:
//	if (target->data == s) {
//fix_flaw_line_below:
//	    CTRACE((tfp, ""BUG: appending chunk to itself: `%.*s'\n"",
//fix_flaw_line_below:
//		    target->size, target->data));
//fix_flaw_line_below:
//	} else {
//fix_flaw_line_below:
//	    HTChunkPuts(target, s);
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//    }
 #ifdef USE_PRETTYSRC
     if (psrc_convert_string) {
 	psrc_convert_string = FALSE;
	FREE(translated_string);
    }
#endif
}
",180801," void HTML_put_string(HTStructured * me, const char *s)
 {
 #ifdef USE_PRETTYSRC
     char *translated_string = NULL;
 #endif

    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))
	return;
#ifdef USE_PRETTYSRC
    if (psrc_convert_string) {
	StrAllocCopy(translated_string, s);
	TRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);
	s = (const char *) translated_string;
    }
#endif

    switch (me->sp[0].tag_number) {

    case HTML_COMMENT:
 	break;			/* Do Nothing */
 
     case HTML_TITLE:
	HTChunkPuts(&me->title, s);
 	break;
 
     case HTML_STYLE:
	HTChunkPuts(&me->style_block, s);
 	break;
 
     case HTML_SCRIPT:
	HTChunkPuts(&me->script, s);
 	break;
 
     case HTML_PRE:		/* Formatted text */
    case HTML_LISTING:		/* Literal text */
    case HTML_XMP:
    case HTML_PLAINTEXT:
	/*
	 * We guarantee that the style is up-to-date in begin_litteral
	 */
	HText_appendText(me->text, s);
 	break;
 
     case HTML_OBJECT:
	HTChunkPuts(&me->object, s);
 	break;
 
     case HTML_TEXTAREA:
	HTChunkPuts(&me->textarea, s);
 	break;
 
     case HTML_SELECT:
     case HTML_OPTION:
	HTChunkPuts(&me->option, s);
 	break;
 
     case HTML_MATH:
	HTChunkPuts(&me->math, s);
 	break;
 
     default:			/* Free format text? */
	if (!me->sp->style->freeFormat) {
	    /*
	     * If we are within a preformatted text style not caught by the
	     * cases above (HTML_PRE or similar may not be the last element
	     * pushed on the style stack).  - kw
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		/*
		 * We do this so that a raw '\r' in the string will not be
		 * interpreted as an internal request to break a line - passing
		 * '\r' to HText_appendText is treated by it as a request to
		 * insert a blank line - VH
		 */
		for (; *s; ++s)
		    HTML_put_character(me, *s);
	    } else
#endif
		HText_appendText(me->text, s);
	    break;
	} else {
	    const char *p = s;
	    char c;

	    if (me->style_change) {
		for (; *p && ((*p == '\n') || (*p == '\r') ||
			      (*p == ' ') || (*p == '\t')); p++) ;	/* Ignore leaders */
		if (!*p)
		    break;
		UPDATE_STYLE;
	    }
	    for (; *p; p++) {
		if (*p == 13 && p[1] != 10) {
		    /*
		     * Treat any '\r' which is not followed by '\n' as '\n', to
		     * account for macintosh lineend in ALT attributes etc.  -
		     * kw
		     */
		    c = '\n';
		} else {
		    c = *p;
		}
		if (me->style_change) {
		    if ((c == '\n') || (c == ' ') || (c == '\t'))
			continue;	/* Ignore it */
		    UPDATE_STYLE;
		}
		if (c == '\n') {
		    if (!FIX_JAPANESE_SPACES) {
			if (me->in_word) {
			    if (HText_getLastChar(me->text) != ' ')
				HText_appendCharacter(me->text, ' ');
			    me->in_word = NO;
			}
		    }

		} else if (c == ' ' || c == '\t') {
		    if (HText_getLastChar(me->text) != ' ')
			HText_appendCharacter(me->text, ' ');

		} else if (c == '\r') {
		    /* ignore */
		} else {
		    HText_appendCharacter(me->text, c);
		    me->in_word = YES;
		}

		/* set the Last Character */
		if (c == '\n' || c == '\t') {
		    /* set it to a generic separator */
		    HText_setLastChar(me->text, ' ');
		} else if (c == '\r' &&
			   HText_getLastChar(me->text) == ' ') {
		    /*
		     * \r's are ignored.  In order to keep collapsing spaces
		     * correctly, we must default back to the previous
		     * separator, if there was one.  So we set LastChar to a
		     * generic separator.
		     */
		    HText_setLastChar(me->text, ' ');
		} else {
		    HText_setLastChar(me->text, c);
		}

 	    }			/* for */
 	}
     }				/* end switch */
 #ifdef USE_PRETTYSRC
     if (psrc_convert_string) {
 	psrc_convert_string = FALSE;
	FREE(translated_string);
    }
#endif
}
"," void HTML_put_string(HTStructured * me, const char *s)
 {
    HTChunk *target = NULL;

 #ifdef USE_PRETTYSRC
     char *translated_string = NULL;
 #endif

    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))
	return;
#ifdef USE_PRETTYSRC
    if (psrc_convert_string) {
	StrAllocCopy(translated_string, s);
	TRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);
	s = (const char *) translated_string;
    }
#endif

    switch (me->sp[0].tag_number) {

    case HTML_COMMENT:
 	break;			/* Do Nothing */
 
     case HTML_TITLE:
	target = &me->title;
 	break;
 
     case HTML_STYLE:
	target = &me->style_block;
 	break;
 
     case HTML_SCRIPT:
	target = &me->script;
 	break;
 
     case HTML_PRE:		/* Formatted text */
    case HTML_LISTING:		/* Literal text */
    case HTML_XMP:
    case HTML_PLAINTEXT:
	/*
	 * We guarantee that the style is up-to-date in begin_litteral
	 */
	HText_appendText(me->text, s);
 	break;
 
     case HTML_OBJECT:
	target = &me->object;
 	break;
 
     case HTML_TEXTAREA:
	target = &me->textarea;
 	break;
 
     case HTML_SELECT:
     case HTML_OPTION:
	target = &me->option;
 	break;
 
     case HTML_MATH:
	target = &me->math;
 	break;
 
     default:			/* Free format text? */
	if (!me->sp->style->freeFormat) {
	    /*
	     * If we are within a preformatted text style not caught by the
	     * cases above (HTML_PRE or similar may not be the last element
	     * pushed on the style stack).  - kw
	     */
#ifdef USE_PRETTYSRC
	    if (psrc_view) {
		/*
		 * We do this so that a raw '\r' in the string will not be
		 * interpreted as an internal request to break a line - passing
		 * '\r' to HText_appendText is treated by it as a request to
		 * insert a blank line - VH
		 */
		for (; *s; ++s)
		    HTML_put_character(me, *s);
	    } else
#endif
		HText_appendText(me->text, s);
	    break;
	} else {
	    const char *p = s;
	    char c;

	    if (me->style_change) {
		for (; *p && ((*p == '\n') || (*p == '\r') ||
			      (*p == ' ') || (*p == '\t')); p++) ;	/* Ignore leaders */
		if (!*p)
		    break;
		UPDATE_STYLE;
	    }
	    for (; *p; p++) {
		if (*p == 13 && p[1] != 10) {
		    /*
		     * Treat any '\r' which is not followed by '\n' as '\n', to
		     * account for macintosh lineend in ALT attributes etc.  -
		     * kw
		     */
		    c = '\n';
		} else {
		    c = *p;
		}
		if (me->style_change) {
		    if ((c == '\n') || (c == ' ') || (c == '\t'))
			continue;	/* Ignore it */
		    UPDATE_STYLE;
		}
		if (c == '\n') {
		    if (!FIX_JAPANESE_SPACES) {
			if (me->in_word) {
			    if (HText_getLastChar(me->text) != ' ')
				HText_appendCharacter(me->text, ' ');
			    me->in_word = NO;
			}
		    }

		} else if (c == ' ' || c == '\t') {
		    if (HText_getLastChar(me->text) != ' ')
			HText_appendCharacter(me->text, ' ');

		} else if (c == '\r') {
		    /* ignore */
		} else {
		    HText_appendCharacter(me->text, c);
		    me->in_word = YES;
		}

		/* set the Last Character */
		if (c == '\n' || c == '\t') {
		    /* set it to a generic separator */
		    HText_setLastChar(me->text, ' ');
		} else if (c == '\r' &&
			   HText_getLastChar(me->text) == ' ') {
		    /*
		     * \r's are ignored.  In order to keep collapsing spaces
		     * correctly, we must default back to the previous
		     * separator, if there was one.  So we set LastChar to a
		     * generic separator.
		     */
		    HText_setLastChar(me->text, ' ');
		} else {
		    HText_setLastChar(me->text, c);
		}

 	    }			/* for */
 	}
     }				/* end switch */

    if (target != NULL) {
	if (target->data == s) {
	    CTRACE((tfp, ""BUG: appending chunk to itself: `%.*s'\n"",
		    target->size, target->data));
	} else {
	    HTChunkPuts(target, s);
	}
    }
 #ifdef USE_PRETTYSRC
     if (psrc_convert_string) {
 	psrc_convert_string = FALSE;
	FREE(translated_string);
    }
#endif
}
","The `HTML_put_string` function processes and outputs a string `s` based on the current HTML context defined by the `HTStructured` structure. It first checks for null input or specific conditions before translating the string if the `USE_PRETTYSRC` flag is set. Depending on the `tag_number` of the current HTML element, it appends the string to various components like title, style, script, or text areas, or handles it as formatted text. The function also manages whitespace and line endings, ensuring proper formatting and style updates, while cleaning up any allocated resources if translation was performed.","The provided code defines a function that processes and outputs a given string based on the current HTML context. It checks for null input and specific conditions before potentially translating the string. Depending on the type of HTML element being processed, the function appends the string to various sections, such as titles, styles, or scripts, while also handling formatted text appropriately. It manages whitespace and line endings to ensure proper formatting and updates styles as needed. Finally, it cleans up any resources used during the translation process, ensuring efficient memory management.","The vulnerability in the original code arises from the potential for appending a string to itself, which could lead to undefined behavior or memory corruption. This occurs when the target data pointer matches the input string, as indicated by the condition checking if `target->data` equals `s`. In the fixed code, this check is introduced before appending the string to the target, ensuring that the function does not attempt to append the string to itself. This safeguard prevents the risk of data corruption and maintains the integrity of the data structure being manipulated.","The vulnerability in the original code stems from the risk of appending a string to itself, which could lead to memory corruption or unexpected behavior. This situation arises when the target data and the input string reference the same memory location. In the revised code, a check is implemented to verify that the target data does not match the input string before performing the append operation. This additional validation effectively prevents the function from executing potentially harmful operations, thereby enhancing the stability and reliability of the code by safeguarding against self-referential data manipulation.","The vulnerability was fixed by introducing a conditional check before appending the string to the target. Specifically, the code now verifies if `target->data` is equal to `s`. If they are the same, the function logs a message indicating a potential bug and avoids the append operation. This prevents the scenario where the same string is appended to itself, which could lead to memory corruption or undefined behavior. By ensuring that the target data and the input string are not the same, the code enhances its robustness and prevents unintended side effects during string manipulation.","The vulnerability was addressed by adding a safeguard that checks whether the target data and the input string reference the same memory location before performing the append operation. If they are found to be identical, the code logs a warning message and refrains from executing the append, thereby preventing the risk of appending a string to itself. This modification effectively eliminates the potential for memory corruption or undefined behavior that could arise from such an operation, enhancing the overall stability and reliability of the code during string manipulation processes.","CWE-119, CWE-415, CWE-787, CWE-416, CWE-476, CWE-763, CWE-789, CWE-825, CWE-665, CWE-754",N,-1
19,19,180828,180828,,Local,Not required,Complete,CVE-2017-17052,https://www.cvedetails.com/cve/CVE-2017-17052/,CWE-416,Low,Complete,Complete,,2017-11-28,7.2,"The mm_init function in kernel/fork.c in the Linux kernel before 4.12.10 does not clear the ->exe_file member of a new process's mm_struct, allowing a local attacker to achieve a use-after-free or possibly have unspecified other impact by running a specially crafted program.",2017-12-20,,1,https://github.com/torvalds/linux/commit/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a,2b7e8665b4ff51c034c55df3cff76518d1a9ee3a,"fork: fix incorrect fput of ->exe_file causing use-after-free

Commit 7c051267931a (""mm, fork: make dup_mmap wait for mmap_sem for
write killable"") made it possible to kill a forking task while it is
waiting to acquire its ->mmap_sem for write, in dup_mmap().

However, it was overlooked that this introduced an new error path before
a reference is taken on the mm_struct's ->exe_file.  Since the
->exe_file of the new mm_struct was already set to the old ->exe_file by
the memcpy() in dup_mm(), it was possible for the mmput() in the error
path of dup_mm() to drop a reference to ->exe_file which was never
taken.

This caused the struct file to later be freed prematurely.

Fix it by updating mm_init() to NULL out the ->exe_file, in the same
place it clears other things like the list of mmaps.

This bug was found by syzkaller.  It can be reproduced using the
following C program:

    #define _GNU_SOURCE
    #include <pthread.h>
    #include <stdlib.h>
    #include <sys/mman.h>
    #include <sys/syscall.h>
    #include <sys/wait.h>
    #include <unistd.h>

    static void *mmap_thread(void *_arg)
    {
        for (;;) {
            mmap(NULL, 0x1000000, PROT_READ,
                 MAP_POPULATE|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
        }
    }

    static void *fork_thread(void *_arg)
    {
        usleep(rand() % 10000);
        fork();
    }

    int main(void)
    {
        fork();
        fork();
        fork();
        for (;;) {
            if (fork() == 0) {
                pthread_t t;

                pthread_create(&t, NULL, mmap_thread, NULL);
                pthread_create(&t, NULL, fork_thread, NULL);
                usleep(rand() % 10000);
                syscall(__NR_exit_group, 0);
            }
            wait(NULL);
        }
    }

No special kernel config options are needed.  It usually causes a NULL
pointer dereference in __remove_shared_vm_struct() during exit, or in
dup_mmap() (which is usually inlined into copy_process()) during fork.
Both are due to a vm_area_struct's ->vm_file being used after it's
already been freed.

Google Bug Id: 64772007

Link: http://lkml.kernel.org/r/20170823211408.31198-1-ebiggers3@gmail.com
Fixes: 7c051267931a (""mm, fork: make dup_mmap wait for mmap_sem for write killable"")
Signed-off-by: Eric Biggers <ebiggers@google.com>
Tested-by: Mark Rutland <mark.rutland@arm.com>
Acked-by: Michal Hocko <mhocko@suse.com>
Cc: Dmitry Vyukov <dvyukov@google.com>
Cc: Ingo Molnar <mingo@kernel.org>
Cc: Konstantin Khlebnikov <koct9i@gmail.com>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Vlastimil Babka <vbabka@suse.cz>
Cc: <stable@vger.kernel.org>	[v4.7+]
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,kernel/fork.c,"{""sha"": ""cbbea277b3fba7a8a1ff73ffaf620202a706036a"", ""filename"": ""kernel/fork.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a/kernel/fork.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a/kernel/fork.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/fork.c?ref=2b7e8665b4ff51c034c55df3cff76518d1a9ee3a"", ""patch"": ""@@ -806,6 +806,7 @@ static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n \tmm_init_cpumask(mm);\n \tmm_init_aio(mm);\n \tmm_init_owner(mm, p);\n+\tRCU_INIT_POINTER(mm->exe_file, NULL);\n \tmmu_notifier_mm_init(mm);\n \tinit_tlb_flush_pending(mm);\n #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS""}","static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,
	struct user_namespace *user_ns)
{
	mm->mmap = NULL;
	mm->mm_rb = RB_ROOT;
	mm->vmacache_seqnum = 0;
	atomic_set(&mm->mm_users, 1);
	atomic_set(&mm->mm_count, 1);
	init_rwsem(&mm->mmap_sem);
	INIT_LIST_HEAD(&mm->mmlist);
	mm->core_state = NULL;
	atomic_long_set(&mm->nr_ptes, 0);
	mm_nr_pmds_init(mm);
	mm->map_count = 0;
	mm->locked_vm = 0;
	mm->pinned_vm = 0;
	memset(&mm->rss_stat, 0, sizeof(mm->rss_stat));
	spin_lock_init(&mm->page_table_lock);
 	mm_init_cpumask(mm);
 	mm_init_aio(mm);
 	mm_init_owner(mm, p);
	RCU_INIT_POINTER(mm->exe_file, NULL);
 	mmu_notifier_mm_init(mm);
 	init_tlb_flush_pending(mm);
 #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS
	mm->pmd_huge_pte = NULL;
#endif

	if (current->mm) {
		mm->flags = current->mm->flags & MMF_INIT_MASK;
		mm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;
	} else {
		mm->flags = default_dump_filter;
		mm->def_flags = 0;
	}

	if (mm_alloc_pgd(mm))
		goto fail_nopgd;

	if (init_new_context(p, mm))
		goto fail_nocontext;

	mm->user_ns = get_user_ns(user_ns);
	return mm;

fail_nocontext:
	mm_free_pgd(mm);
fail_nopgd:
	free_mm(mm);
	return NULL;
}
","static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,
	struct user_namespace *user_ns)
{
	mm->mmap = NULL;
	mm->mm_rb = RB_ROOT;
	mm->vmacache_seqnum = 0;
	atomic_set(&mm->mm_users, 1);
	atomic_set(&mm->mm_count, 1);
	init_rwsem(&mm->mmap_sem);
	INIT_LIST_HEAD(&mm->mmlist);
	mm->core_state = NULL;
	atomic_long_set(&mm->nr_ptes, 0);
	mm_nr_pmds_init(mm);
	mm->map_count = 0;
	mm->locked_vm = 0;
	mm->pinned_vm = 0;
	memset(&mm->rss_stat, 0, sizeof(mm->rss_stat));
	spin_lock_init(&mm->page_table_lock);
 	mm_init_cpumask(mm);
 	mm_init_aio(mm);
 	mm_init_owner(mm, p);
 	mmu_notifier_mm_init(mm);
 	init_tlb_flush_pending(mm);
 #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS
	mm->pmd_huge_pte = NULL;
#endif

	if (current->mm) {
		mm->flags = current->mm->flags & MMF_INIT_MASK;
		mm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;
	} else {
		mm->flags = default_dump_filter;
		mm->def_flags = 0;
	}

	if (mm_alloc_pgd(mm))
		goto fail_nopgd;

	if (init_new_context(p, mm))
		goto fail_nocontext;

	mm->user_ns = get_user_ns(user_ns);
	return mm;

fail_nocontext:
	mm_free_pgd(mm);
fail_nopgd:
	free_mm(mm);
	return NULL;
}
",C,"	RCU_INIT_POINTER(mm->exe_file, NULL);
",,,"@@ -806,6 +806,7 @@ static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,
 	mm_init_cpumask(mm);
 	mm_init_aio(mm);
 	mm_init_owner(mm, p);
+	RCU_INIT_POINTER(mm->exe_file, NULL);
 	mmu_notifier_mm_init(mm);
 	init_tlb_flush_pending(mm);
 #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS",linux,2b7e8665b4ff51c034c55df3cff76518d1a9ee3a,263630e8d176d87308481ebdcd78ef9426739c6b,1,"static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,
	struct user_namespace *user_ns)
{
	mm->mmap = NULL;
	mm->mm_rb = RB_ROOT;
	mm->vmacache_seqnum = 0;
	atomic_set(&mm->mm_users, 1);
	atomic_set(&mm->mm_count, 1);
	init_rwsem(&mm->mmap_sem);
	INIT_LIST_HEAD(&mm->mmlist);
	mm->core_state = NULL;
	atomic_long_set(&mm->nr_ptes, 0);
	mm_nr_pmds_init(mm);
	mm->map_count = 0;
	mm->locked_vm = 0;
	mm->pinned_vm = 0;
	memset(&mm->rss_stat, 0, sizeof(mm->rss_stat));
	spin_lock_init(&mm->page_table_lock);
 	mm_init_cpumask(mm);
 	mm_init_aio(mm);
 	mm_init_owner(mm, p);
//fix_flaw_line_below:
//	RCU_INIT_POINTER(mm->exe_file, NULL);
 	mmu_notifier_mm_init(mm);
 	init_tlb_flush_pending(mm);
 #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS
	mm->pmd_huge_pte = NULL;
#endif

	if (current->mm) {
		mm->flags = current->mm->flags & MMF_INIT_MASK;
		mm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;
	} else {
		mm->flags = default_dump_filter;
		mm->def_flags = 0;
	}

	if (mm_alloc_pgd(mm))
		goto fail_nopgd;

	if (init_new_context(p, mm))
		goto fail_nocontext;

	mm->user_ns = get_user_ns(user_ns);
	return mm;

fail_nocontext:
	mm_free_pgd(mm);
fail_nopgd:
	free_mm(mm);
	return NULL;
}
",180828,"static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,
	struct user_namespace *user_ns)
{
	mm->mmap = NULL;
	mm->mm_rb = RB_ROOT;
	mm->vmacache_seqnum = 0;
	atomic_set(&mm->mm_users, 1);
	atomic_set(&mm->mm_count, 1);
	init_rwsem(&mm->mmap_sem);
	INIT_LIST_HEAD(&mm->mmlist);
	mm->core_state = NULL;
	atomic_long_set(&mm->nr_ptes, 0);
	mm_nr_pmds_init(mm);
	mm->map_count = 0;
	mm->locked_vm = 0;
	mm->pinned_vm = 0;
	memset(&mm->rss_stat, 0, sizeof(mm->rss_stat));
	spin_lock_init(&mm->page_table_lock);
 	mm_init_cpumask(mm);
 	mm_init_aio(mm);
 	mm_init_owner(mm, p);
 	mmu_notifier_mm_init(mm);
 	init_tlb_flush_pending(mm);
 #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS
	mm->pmd_huge_pte = NULL;
#endif

	if (current->mm) {
		mm->flags = current->mm->flags & MMF_INIT_MASK;
		mm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;
	} else {
		mm->flags = default_dump_filter;
		mm->def_flags = 0;
	}

	if (mm_alloc_pgd(mm))
		goto fail_nopgd;

	if (init_new_context(p, mm))
		goto fail_nocontext;

	mm->user_ns = get_user_ns(user_ns);
	return mm;

fail_nocontext:
	mm_free_pgd(mm);
fail_nopgd:
	free_mm(mm);
	return NULL;
}
","static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,
	struct user_namespace *user_ns)
{
	mm->mmap = NULL;
	mm->mm_rb = RB_ROOT;
	mm->vmacache_seqnum = 0;
	atomic_set(&mm->mm_users, 1);
	atomic_set(&mm->mm_count, 1);
	init_rwsem(&mm->mmap_sem);
	INIT_LIST_HEAD(&mm->mmlist);
	mm->core_state = NULL;
	atomic_long_set(&mm->nr_ptes, 0);
	mm_nr_pmds_init(mm);
	mm->map_count = 0;
	mm->locked_vm = 0;
	mm->pinned_vm = 0;
	memset(&mm->rss_stat, 0, sizeof(mm->rss_stat));
	spin_lock_init(&mm->page_table_lock);
 	mm_init_cpumask(mm);
 	mm_init_aio(mm);
 	mm_init_owner(mm, p);
	RCU_INIT_POINTER(mm->exe_file, NULL);
 	mmu_notifier_mm_init(mm);
 	init_tlb_flush_pending(mm);
 #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS
	mm->pmd_huge_pte = NULL;
#endif

	if (current->mm) {
		mm->flags = current->mm->flags & MMF_INIT_MASK;
		mm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;
	} else {
		mm->flags = default_dump_filter;
		mm->def_flags = 0;
	}

	if (mm_alloc_pgd(mm))
		goto fail_nopgd;

	if (init_new_context(p, mm))
		goto fail_nocontext;

	mm->user_ns = get_user_ns(user_ns);
	return mm;

fail_nocontext:
	mm_free_pgd(mm);
fail_nopgd:
	free_mm(mm);
	return NULL;
}
","The `mm_init` function initializes a memory management structure (`mm_struct`) for a given task (`task_struct`). It sets up various fields, including memory mappings, reference counts, and semaphore for managing concurrent access. The function initializes locks, statistics, and context for the memory management unit (MMU), while also handling user namespace associations. It checks for existing memory management flags and allocates page tables. If any initialization step fails, it cleans up by freeing allocated resources and returns `NULL`. Ultimately, it prepares the `mm_struct` for use by the specified task, ensuring proper memory management.","The provided code initializes a structure responsible for managing memory for a specific task. It sets various fields to establish the initial state, including memory mappings, reference counts, and synchronization mechanisms for concurrent access. The function also prepares statistics and context for the memory management unit while associating it with the appropriate user namespace. It checks for existing flags and allocates necessary resources for page tables. If any part of the initialization fails, it ensures proper cleanup of allocated resources and returns an indication of failure, ultimately preparing the structure for effective memory management.","The vulnerability in the original code arose from the improper handling of the `exe_file` pointer in the memory management structure, which could lead to a use-after-free condition. Specifically, when a new memory management structure was created, it inherited the `exe_file` from the old structure without taking a reference, and if an error occurred during initialization, the reference was dropped, causing the file to be freed prematurely. The fix involved explicitly setting the `exe_file` pointer to `NULL` during initialization, ensuring that it would not reference a potentially freed object, thus preventing the use-after-free issue.","The vulnerability in the original code stemmed from the mishandling of a pointer associated with an executable file, which could lead to a use-after-free condition. When a new memory management structure was created, it inherited the pointer from an existing structure without properly taking a reference. If an error occurred during initialization, the pointer could be dropped, resulting in the file being freed prematurely. The fix involved explicitly setting the pointer to `NULL` during the initialization process, ensuring that it would not reference a potentially freed object, thereby preventing the use-after-free issue.","The vulnerability was fixed by updating the `mm_init` function to explicitly set the `exe_file` pointer to `NULL` during the initialization of the memory management structure. This change was made in the same section of the code where other fields, such as the list of memory mappings, are cleared. By nullifying the `exe_file`, the code ensures that if an error occurs later in the initialization process, the reference to the executable file will not be dropped inadvertently, thus preventing premature freeing of the associated struct file and eliminating the risk of a use-after-free condition.","The vulnerability was addressed by modifying the initialization process to ensure that the pointer associated with the executable file is explicitly set to a null value during setup. This adjustment prevents the pointer from inadvertently referencing a potentially freed object if an error occurs later in the initialization sequence. By clearing this pointer alongside other fields, the code safeguards against premature deallocation of resources, thereby eliminating the risk of a use-after-free condition. This fix ensures that the memory management structure is correctly initialized without leaving dangling references that could lead to undefined behavior.","CWE-416, CWE-476, CWE-404, CWE-825, CWE-415, CWE-465, CWE-672, CWE-119, CWE-763, CWE-908",Y,1
20,20,180859,180859,,Local,Not required,Complete,CVE-2017-16525,https://www.cvedetails.com/cve/CVE-2017-16525/,CWE-416,Low,Complete,Complete,,2017-11-03,7.2,"The usb_serial_console_disconnect function in drivers/usb/serial/console.c in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device, related to disconnection and failed setup.",2018-03-15,DoS ,1,https://github.com/torvalds/linux/commit/299d7572e46f98534033a9e65973f13ad1ce9047,299d7572e46f98534033a9e65973f13ad1ce9047,"USB: serial: console: fix use-after-free after failed setup

Make sure to reset the USB-console port pointer when console setup fails
in order to avoid having the struct usb_serial be prematurely freed by
the console code when the device is later disconnected.

Fixes: 73e487fdb75f (""[PATCH] USB console: fix disconnection issues"")
Cc: stable <stable@vger.kernel.org>	# 2.6.18
Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Johan Hovold <johan@kernel.org>",0,drivers/usb/serial/console.c,"{""sha"": ""43a862a90a77592eda9eab2aa75be90a69981ffc"", ""filename"": ""drivers/usb/serial/console.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/299d7572e46f98534033a9e65973f13ad1ce9047/drivers/usb/serial/console.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/299d7572e46f98534033a9e65973f13ad1ce9047/drivers/usb/serial/console.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/serial/console.c?ref=299d7572e46f98534033a9e65973f13ad1ce9047"", ""patch"": ""@@ -186,6 +186,7 @@ static int usb_console_setup(struct console *co, char *options)\n \ttty_kref_put(tty);\n  reset_open_count:\n \tport->port.count = 0;\n+\tinfo->port = NULL;\n \tusb_autopm_put_interface(serial->interface);\n  error_get_interface:\n \tusb_serial_put(serial);""}","static int usb_console_setup(struct console *co, char *options)
{
	struct usbcons_info *info = &usbcons_info;
	int baud = 9600;
	int bits = 8;
	int parity = 'n';
	int doflow = 0;
	int cflag = CREAD | HUPCL | CLOCAL;
	char *s;
	struct usb_serial *serial;
	struct usb_serial_port *port;
	int retval;
	struct tty_struct *tty = NULL;
	struct ktermios dummy;

	if (options) {
		baud = simple_strtoul(options, NULL, 10);
		s = options;
		while (*s >= '0' && *s <= '9')
			s++;
		if (*s)
			parity = *s++;
		if (*s)
			bits   = *s++ - '0';
		if (*s)
			doflow = (*s++ == 'r');
	}
	
	/* Sane default */
	if (baud == 0)
		baud = 9600;

	switch (bits) {
	case 7:
		cflag |= CS7;
		break;
	default:
	case 8:
		cflag |= CS8;
		break;
	}
	switch (parity) {
	case 'o': case 'O':
		cflag |= PARODD;
		break;
	case 'e': case 'E':
		cflag |= PARENB;
		break;
	}
	co->cflag = cflag;

	/*
	 * no need to check the index here: if the index is wrong, console
	 * code won't call us
	 */
	port = usb_serial_port_get_by_minor(co->index);
	if (port == NULL) {
		/* no device is connected yet, sorry :( */
		pr_err(""No USB device connected to ttyUSB%i\n"", co->index);
		return -ENODEV;
	}
	serial = port->serial;

	retval = usb_autopm_get_interface(serial->interface);
	if (retval)
		goto error_get_interface;

	tty_port_tty_set(&port->port, NULL);

	info->port = port;

	++port->port.count;
	if (!tty_port_initialized(&port->port)) {
		if (serial->type->set_termios) {
			/*
			 * allocate a fake tty so the driver can initialize
			 * the termios structure, then later call set_termios to
			 * configure according to command line arguments
			 */
			tty = kzalloc(sizeof(*tty), GFP_KERNEL);
			if (!tty) {
				retval = -ENOMEM;
				goto reset_open_count;
			}
			kref_init(&tty->kref);
			tty->driver = usb_serial_tty_driver;
			tty->index = co->index;
			init_ldsem(&tty->ldisc_sem);
			spin_lock_init(&tty->files_lock);
			INIT_LIST_HEAD(&tty->tty_files);
			kref_get(&tty->driver->kref);
			__module_get(tty->driver->owner);
			tty->ops = &usb_console_fake_tty_ops;
			tty_init_termios(tty);
			tty_port_tty_set(&port->port, tty);
		}

		/* only call the device specific open if this
		 * is the first time the port is opened */
		retval = serial->type->open(NULL, port);
		if (retval) {
			dev_err(&port->dev, ""could not open USB console port\n"");
			goto fail;
		}

		if (serial->type->set_termios) {
			tty->termios.c_cflag = cflag;
			tty_termios_encode_baud_rate(&tty->termios, baud, baud);
			memset(&dummy, 0, sizeof(struct ktermios));
			serial->type->set_termios(tty, port, &dummy);

			tty_port_tty_set(&port->port, NULL);
			tty_kref_put(tty);
		}
		tty_port_set_initialized(&port->port, 1);
	}
	/* Now that any required fake tty operations are completed restore
	 * the tty port count */
	--port->port.count;
	/* The console is special in terms of closing the device so
	 * indicate this port is now acting as a system console. */
	port->port.console = 1;

	mutex_unlock(&serial->disc_mutex);
	return retval;

 fail:
	tty_port_tty_set(&port->port, NULL);
 	tty_kref_put(tty);
  reset_open_count:
 	port->port.count = 0;
	info->port = NULL;
 	usb_autopm_put_interface(serial->interface);
  error_get_interface:
 	usb_serial_put(serial);
	mutex_unlock(&serial->disc_mutex);
	return retval;
}
","static int usb_console_setup(struct console *co, char *options)
{
	struct usbcons_info *info = &usbcons_info;
	int baud = 9600;
	int bits = 8;
	int parity = 'n';
	int doflow = 0;
	int cflag = CREAD | HUPCL | CLOCAL;
	char *s;
	struct usb_serial *serial;
	struct usb_serial_port *port;
	int retval;
	struct tty_struct *tty = NULL;
	struct ktermios dummy;

	if (options) {
		baud = simple_strtoul(options, NULL, 10);
		s = options;
		while (*s >= '0' && *s <= '9')
			s++;
		if (*s)
			parity = *s++;
		if (*s)
			bits   = *s++ - '0';
		if (*s)
			doflow = (*s++ == 'r');
	}
	
	/* Sane default */
	if (baud == 0)
		baud = 9600;

	switch (bits) {
	case 7:
		cflag |= CS7;
		break;
	default:
	case 8:
		cflag |= CS8;
		break;
	}
	switch (parity) {
	case 'o': case 'O':
		cflag |= PARODD;
		break;
	case 'e': case 'E':
		cflag |= PARENB;
		break;
	}
	co->cflag = cflag;

	/*
	 * no need to check the index here: if the index is wrong, console
	 * code won't call us
	 */
	port = usb_serial_port_get_by_minor(co->index);
	if (port == NULL) {
		/* no device is connected yet, sorry :( */
		pr_err(""No USB device connected to ttyUSB%i\n"", co->index);
		return -ENODEV;
	}
	serial = port->serial;

	retval = usb_autopm_get_interface(serial->interface);
	if (retval)
		goto error_get_interface;

	tty_port_tty_set(&port->port, NULL);

	info->port = port;

	++port->port.count;
	if (!tty_port_initialized(&port->port)) {
		if (serial->type->set_termios) {
			/*
			 * allocate a fake tty so the driver can initialize
			 * the termios structure, then later call set_termios to
			 * configure according to command line arguments
			 */
			tty = kzalloc(sizeof(*tty), GFP_KERNEL);
			if (!tty) {
				retval = -ENOMEM;
				goto reset_open_count;
			}
			kref_init(&tty->kref);
			tty->driver = usb_serial_tty_driver;
			tty->index = co->index;
			init_ldsem(&tty->ldisc_sem);
			spin_lock_init(&tty->files_lock);
			INIT_LIST_HEAD(&tty->tty_files);
			kref_get(&tty->driver->kref);
			__module_get(tty->driver->owner);
			tty->ops = &usb_console_fake_tty_ops;
			tty_init_termios(tty);
			tty_port_tty_set(&port->port, tty);
		}

		/* only call the device specific open if this
		 * is the first time the port is opened */
		retval = serial->type->open(NULL, port);
		if (retval) {
			dev_err(&port->dev, ""could not open USB console port\n"");
			goto fail;
		}

		if (serial->type->set_termios) {
			tty->termios.c_cflag = cflag;
			tty_termios_encode_baud_rate(&tty->termios, baud, baud);
			memset(&dummy, 0, sizeof(struct ktermios));
			serial->type->set_termios(tty, port, &dummy);

			tty_port_tty_set(&port->port, NULL);
			tty_kref_put(tty);
		}
		tty_port_set_initialized(&port->port, 1);
	}
	/* Now that any required fake tty operations are completed restore
	 * the tty port count */
	--port->port.count;
	/* The console is special in terms of closing the device so
	 * indicate this port is now acting as a system console. */
	port->port.console = 1;

	mutex_unlock(&serial->disc_mutex);
	return retval;

 fail:
	tty_port_tty_set(&port->port, NULL);
 	tty_kref_put(tty);
  reset_open_count:
 	port->port.count = 0;
 	usb_autopm_put_interface(serial->interface);
  error_get_interface:
 	usb_serial_put(serial);
	mutex_unlock(&serial->disc_mutex);
	return retval;
}
",C,"	info->port = NULL;
",,,"@@ -186,6 +186,7 @@ static int usb_console_setup(struct console *co, char *options)
 	tty_kref_put(tty);
  reset_open_count:
 	port->port.count = 0;
+	info->port = NULL;
 	usb_autopm_put_interface(serial->interface);
  error_get_interface:
 	usb_serial_put(serial);",linux,299d7572e46f98534033a9e65973f13ad1ce9047,bd998c2e0df0469707503023d50d46cf0b10c787,1,"static int usb_console_setup(struct console *co, char *options)
{
	struct usbcons_info *info = &usbcons_info;
	int baud = 9600;
	int bits = 8;
	int parity = 'n';
	int doflow = 0;
	int cflag = CREAD | HUPCL | CLOCAL;
	char *s;
	struct usb_serial *serial;
	struct usb_serial_port *port;
	int retval;
	struct tty_struct *tty = NULL;
	struct ktermios dummy;

	if (options) {
		baud = simple_strtoul(options, NULL, 10);
		s = options;
		while (*s >= '0' && *s <= '9')
			s++;
		if (*s)
			parity = *s++;
		if (*s)
			bits   = *s++ - '0';
		if (*s)
			doflow = (*s++ == 'r');
	}
	
	/* Sane default */
	if (baud == 0)
		baud = 9600;

	switch (bits) {
	case 7:
		cflag |= CS7;
		break;
	default:
	case 8:
		cflag |= CS8;
		break;
	}
	switch (parity) {
	case 'o': case 'O':
		cflag |= PARODD;
		break;
	case 'e': case 'E':
		cflag |= PARENB;
		break;
	}
	co->cflag = cflag;

	/*
	 * no need to check the index here: if the index is wrong, console
	 * code won't call us
	 */
	port = usb_serial_port_get_by_minor(co->index);
	if (port == NULL) {
		/* no device is connected yet, sorry :( */
		pr_err(""No USB device connected to ttyUSB%i\n"", co->index);
		return -ENODEV;
	}
	serial = port->serial;

	retval = usb_autopm_get_interface(serial->interface);
	if (retval)
		goto error_get_interface;

	tty_port_tty_set(&port->port, NULL);

	info->port = port;

	++port->port.count;
	if (!tty_port_initialized(&port->port)) {
		if (serial->type->set_termios) {
			/*
			 * allocate a fake tty so the driver can initialize
			 * the termios structure, then later call set_termios to
			 * configure according to command line arguments
			 */
			tty = kzalloc(sizeof(*tty), GFP_KERNEL);
			if (!tty) {
				retval = -ENOMEM;
				goto reset_open_count;
			}
			kref_init(&tty->kref);
			tty->driver = usb_serial_tty_driver;
			tty->index = co->index;
			init_ldsem(&tty->ldisc_sem);
			spin_lock_init(&tty->files_lock);
			INIT_LIST_HEAD(&tty->tty_files);
			kref_get(&tty->driver->kref);
			__module_get(tty->driver->owner);
			tty->ops = &usb_console_fake_tty_ops;
			tty_init_termios(tty);
			tty_port_tty_set(&port->port, tty);
		}

		/* only call the device specific open if this
		 * is the first time the port is opened */
		retval = serial->type->open(NULL, port);
		if (retval) {
			dev_err(&port->dev, ""could not open USB console port\n"");
			goto fail;
		}

		if (serial->type->set_termios) {
			tty->termios.c_cflag = cflag;
			tty_termios_encode_baud_rate(&tty->termios, baud, baud);
			memset(&dummy, 0, sizeof(struct ktermios));
			serial->type->set_termios(tty, port, &dummy);

			tty_port_tty_set(&port->port, NULL);
			tty_kref_put(tty);
		}
		tty_port_set_initialized(&port->port, 1);
	}
	/* Now that any required fake tty operations are completed restore
	 * the tty port count */
	--port->port.count;
	/* The console is special in terms of closing the device so
	 * indicate this port is now acting as a system console. */
	port->port.console = 1;

	mutex_unlock(&serial->disc_mutex);
	return retval;

 fail:
	tty_port_tty_set(&port->port, NULL);
 	tty_kref_put(tty);
  reset_open_count:
 	port->port.count = 0;
//fix_flaw_line_below:
//	info->port = NULL;
 	usb_autopm_put_interface(serial->interface);
  error_get_interface:
 	usb_serial_put(serial);
	mutex_unlock(&serial->disc_mutex);
	return retval;
}
",180859,"static int usb_console_setup(struct console *co, char *options)
{
	struct usbcons_info *info = &usbcons_info;
	int baud = 9600;
	int bits = 8;
	int parity = 'n';
	int doflow = 0;
	int cflag = CREAD | HUPCL | CLOCAL;
	char *s;
	struct usb_serial *serial;
	struct usb_serial_port *port;
	int retval;
	struct tty_struct *tty = NULL;
	struct ktermios dummy;

	if (options) {
		baud = simple_strtoul(options, NULL, 10);
		s = options;
		while (*s >= '0' && *s <= '9')
			s++;
		if (*s)
			parity = *s++;
		if (*s)
			bits   = *s++ - '0';
		if (*s)
			doflow = (*s++ == 'r');
	}
	
	/* Sane default */
	if (baud == 0)
		baud = 9600;

	switch (bits) {
	case 7:
		cflag |= CS7;
		break;
	default:
	case 8:
		cflag |= CS8;
		break;
	}
	switch (parity) {
	case 'o': case 'O':
		cflag |= PARODD;
		break;
	case 'e': case 'E':
		cflag |= PARENB;
		break;
	}
	co->cflag = cflag;

	/*
	 * no need to check the index here: if the index is wrong, console
	 * code won't call us
	 */
	port = usb_serial_port_get_by_minor(co->index);
	if (port == NULL) {
		/* no device is connected yet, sorry :( */
		pr_err(""No USB device connected to ttyUSB%i\n"", co->index);
		return -ENODEV;
	}
	serial = port->serial;

	retval = usb_autopm_get_interface(serial->interface);
	if (retval)
		goto error_get_interface;

	tty_port_tty_set(&port->port, NULL);

	info->port = port;

	++port->port.count;
	if (!tty_port_initialized(&port->port)) {
		if (serial->type->set_termios) {
			/*
			 * allocate a fake tty so the driver can initialize
			 * the termios structure, then later call set_termios to
			 * configure according to command line arguments
			 */
			tty = kzalloc(sizeof(*tty), GFP_KERNEL);
			if (!tty) {
				retval = -ENOMEM;
				goto reset_open_count;
			}
			kref_init(&tty->kref);
			tty->driver = usb_serial_tty_driver;
			tty->index = co->index;
			init_ldsem(&tty->ldisc_sem);
			spin_lock_init(&tty->files_lock);
			INIT_LIST_HEAD(&tty->tty_files);
			kref_get(&tty->driver->kref);
			__module_get(tty->driver->owner);
			tty->ops = &usb_console_fake_tty_ops;
			tty_init_termios(tty);
			tty_port_tty_set(&port->port, tty);
		}

		/* only call the device specific open if this
		 * is the first time the port is opened */
		retval = serial->type->open(NULL, port);
		if (retval) {
			dev_err(&port->dev, ""could not open USB console port\n"");
			goto fail;
		}

		if (serial->type->set_termios) {
			tty->termios.c_cflag = cflag;
			tty_termios_encode_baud_rate(&tty->termios, baud, baud);
			memset(&dummy, 0, sizeof(struct ktermios));
			serial->type->set_termios(tty, port, &dummy);

			tty_port_tty_set(&port->port, NULL);
			tty_kref_put(tty);
		}
		tty_port_set_initialized(&port->port, 1);
	}
	/* Now that any required fake tty operations are completed restore
	 * the tty port count */
	--port->port.count;
	/* The console is special in terms of closing the device so
	 * indicate this port is now acting as a system console. */
	port->port.console = 1;

	mutex_unlock(&serial->disc_mutex);
	return retval;

 fail:
	tty_port_tty_set(&port->port, NULL);
 	tty_kref_put(tty);
  reset_open_count:
 	port->port.count = 0;
 	usb_autopm_put_interface(serial->interface);
  error_get_interface:
 	usb_serial_put(serial);
	mutex_unlock(&serial->disc_mutex);
	return retval;
}
","static int usb_console_setup(struct console *co, char *options)
{
	struct usbcons_info *info = &usbcons_info;
	int baud = 9600;
	int bits = 8;
	int parity = 'n';
	int doflow = 0;
	int cflag = CREAD | HUPCL | CLOCAL;
	char *s;
	struct usb_serial *serial;
	struct usb_serial_port *port;
	int retval;
	struct tty_struct *tty = NULL;
	struct ktermios dummy;

	if (options) {
		baud = simple_strtoul(options, NULL, 10);
		s = options;
		while (*s >= '0' && *s <= '9')
			s++;
		if (*s)
			parity = *s++;
		if (*s)
			bits   = *s++ - '0';
		if (*s)
			doflow = (*s++ == 'r');
	}
	
	/* Sane default */
	if (baud == 0)
		baud = 9600;

	switch (bits) {
	case 7:
		cflag |= CS7;
		break;
	default:
	case 8:
		cflag |= CS8;
		break;
	}
	switch (parity) {
	case 'o': case 'O':
		cflag |= PARODD;
		break;
	case 'e': case 'E':
		cflag |= PARENB;
		break;
	}
	co->cflag = cflag;

	/*
	 * no need to check the index here: if the index is wrong, console
	 * code won't call us
	 */
	port = usb_serial_port_get_by_minor(co->index);
	if (port == NULL) {
		/* no device is connected yet, sorry :( */
		pr_err(""No USB device connected to ttyUSB%i\n"", co->index);
		return -ENODEV;
	}
	serial = port->serial;

	retval = usb_autopm_get_interface(serial->interface);
	if (retval)
		goto error_get_interface;

	tty_port_tty_set(&port->port, NULL);

	info->port = port;

	++port->port.count;
	if (!tty_port_initialized(&port->port)) {
		if (serial->type->set_termios) {
			/*
			 * allocate a fake tty so the driver can initialize
			 * the termios structure, then later call set_termios to
			 * configure according to command line arguments
			 */
			tty = kzalloc(sizeof(*tty), GFP_KERNEL);
			if (!tty) {
				retval = -ENOMEM;
				goto reset_open_count;
			}
			kref_init(&tty->kref);
			tty->driver = usb_serial_tty_driver;
			tty->index = co->index;
			init_ldsem(&tty->ldisc_sem);
			spin_lock_init(&tty->files_lock);
			INIT_LIST_HEAD(&tty->tty_files);
			kref_get(&tty->driver->kref);
			__module_get(tty->driver->owner);
			tty->ops = &usb_console_fake_tty_ops;
			tty_init_termios(tty);
			tty_port_tty_set(&port->port, tty);
		}

		/* only call the device specific open if this
		 * is the first time the port is opened */
		retval = serial->type->open(NULL, port);
		if (retval) {
			dev_err(&port->dev, ""could not open USB console port\n"");
			goto fail;
		}

		if (serial->type->set_termios) {
			tty->termios.c_cflag = cflag;
			tty_termios_encode_baud_rate(&tty->termios, baud, baud);
			memset(&dummy, 0, sizeof(struct ktermios));
			serial->type->set_termios(tty, port, &dummy);

			tty_port_tty_set(&port->port, NULL);
			tty_kref_put(tty);
		}
		tty_port_set_initialized(&port->port, 1);
	}
	/* Now that any required fake tty operations are completed restore
	 * the tty port count */
	--port->port.count;
	/* The console is special in terms of closing the device so
	 * indicate this port is now acting as a system console. */
	port->port.console = 1;

	mutex_unlock(&serial->disc_mutex);
	return retval;

 fail:
	tty_port_tty_set(&port->port, NULL);
 	tty_kref_put(tty);
  reset_open_count:
 	port->port.count = 0;
	info->port = NULL;
 	usb_autopm_put_interface(serial->interface);
  error_get_interface:
 	usb_serial_put(serial);
	mutex_unlock(&serial->disc_mutex);
	return retval;
}
","The `usb_console_setup` function configures a USB console by initializing parameters such as baud rate, data bits, and parity based on provided options. It retrieves the corresponding USB serial port and checks for device connectivity. If the port is uninitialized, it allocates a temporary TTY structure for termios configuration and opens the port. The function sets the terminal attributes and ensures the port is marked as a system console. In case of errors, it handles resource cleanup and returns appropriate error codes, ensuring safe management of USB device interactions and console settings.","The provided code sets up a USB console by configuring communication parameters such as baud rate, data bits, and parity based on user-defined options. It checks for the presence of a connected USB device and initializes the necessary structures for terminal communication. If the device is not already open, it allocates a temporary terminal structure to manage settings and opens the device for communication. The function ensures that the console is properly registered and handles any errors by cleaning up resources, ultimately enabling reliable interaction with the USB console for data transmission.","The vulnerability in the original code stemmed from a potential use-after-free condition, where the USB console port pointer was not reset upon a failed setup. This could lead to the premature freeing of the associated USB serial structure, causing undefined behavior if the console code attempted to access it after a disconnection. The fix involved explicitly setting the USB console port pointer to `NULL` in the error handling section, ensuring that any subsequent operations on the port would not reference a freed structure, thus preventing the use-after-free vulnerability and enhancing the stability of the USB console functionality.","The vulnerability in the original code was a use-after-free issue that occurred when the setup of the USB console failed, leaving a pointer to the USB console port unreset. This could lead to the premature deallocation of the associated structure, resulting in potential access to invalid memory if the console code attempted to interact with it after a device disconnection. The fix involved ensuring that the pointer to the USB console port was explicitly reset during error handling, thereby preventing any subsequent operations from referencing a freed structure and enhancing the overall stability and safety of the code.","The vulnerability was fixed by adding a line to reset the USB console port pointer to `NULL` in the error handling section of the code. Specifically, when the setup fails, the code now includes `info->port = NULL;`, ensuring that the pointer does not reference a potentially freed structure. This change prevents the console code from mistakenly accessing the USB serial structure after it has been deallocated, thereby eliminating the use-after-free condition. By implementing this safeguard, the code enhances memory safety and stability during USB console operations, particularly during device disconnections.","The vulnerability was addressed by ensuring that the pointer to the USB console port is explicitly reset to `NULL` during error handling when the setup process fails. This modification prevents the code from referencing a potentially freed structure, thereby eliminating the risk of accessing invalid memory. By implementing this safeguard, the fix ensures that any subsequent operations do not inadvertently interact with deallocated resources, enhancing the overall memory safety and stability of the system during USB console operations, particularly in scenarios involving device disconnections.","CWE-416, CWE-825, CWE-476, CWE-672, CWE-415, CWE-119, CWE-465, CWE-908, CWE-911, CWE-367",Y,1
21,21,180900,180900,,Local,Not required,Complete,CVE-2017-15265,https://www.cvedetails.com/cve/CVE-2017-15265/,CWE-416,Medium,Complete,Complete,,2017-10-16,6.9,"Race condition in the ALSA subsystem in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted /dev/snd/seq ioctl calls, related to sound/core/seq/seq_clientmgr.c and sound/core/seq/seq_ports.c.",2019-04-23,DoS ,5,https://github.com/torvalds/linux/commit/71105998845fb012937332fe2e806d443c09e026,71105998845fb012937332fe2e806d443c09e026,"ALSA: seq: Fix use-after-free at creating a port

There is a potential race window opened at creating and deleting a
port via ioctl, as spotted by fuzzing.  snd_seq_create_port() creates
a port object and returns its pointer, but it doesn't take the
refcount, thus it can be deleted immediately by another thread.
Meanwhile, snd_seq_ioctl_create_port() still calls the function
snd_seq_system_client_ev_port_start() with the created port object
that is being deleted, and this triggers use-after-free like:

 BUG: KASAN: use-after-free in snd_seq_ioctl_create_port+0x504/0x630 [snd_seq] at addr ffff8801f2241cb1
 =============================================================================
 BUG kmalloc-512 (Tainted: G    B          ): kasan: bad access detected
 -----------------------------------------------------------------------------
 INFO: Allocated in snd_seq_create_port+0x94/0x9b0 [snd_seq] age=1 cpu=3 pid=4511
 	___slab_alloc+0x425/0x460
 	__slab_alloc+0x20/0x40
  	kmem_cache_alloc_trace+0x150/0x190
	snd_seq_create_port+0x94/0x9b0 [snd_seq]
	snd_seq_ioctl_create_port+0xd1/0x630 [snd_seq]
 	snd_seq_do_ioctl+0x11c/0x190 [snd_seq]
 	snd_seq_ioctl+0x40/0x80 [snd_seq]
 	do_vfs_ioctl+0x54b/0xda0
 	SyS_ioctl+0x79/0x90
 	entry_SYSCALL_64_fastpath+0x16/0x75
 INFO: Freed in port_delete+0x136/0x1a0 [snd_seq] age=1 cpu=2 pid=4717
 	__slab_free+0x204/0x310
 	kfree+0x15f/0x180
 	port_delete+0x136/0x1a0 [snd_seq]
 	snd_seq_delete_port+0x235/0x350 [snd_seq]
 	snd_seq_ioctl_delete_port+0xc8/0x180 [snd_seq]
 	snd_seq_do_ioctl+0x11c/0x190 [snd_seq]
 	snd_seq_ioctl+0x40/0x80 [snd_seq]
 	do_vfs_ioctl+0x54b/0xda0
 	SyS_ioctl+0x79/0x90
 	entry_SYSCALL_64_fastpath+0x16/0x75
 Call Trace:
  [<ffffffff81b03781>] dump_stack+0x63/0x82
  [<ffffffff81531b3b>] print_trailer+0xfb/0x160
  [<ffffffff81536db4>] object_err+0x34/0x40
  [<ffffffff815392d3>] kasan_report.part.2+0x223/0x520
  [<ffffffffa07aadf4>] ? snd_seq_ioctl_create_port+0x504/0x630 [snd_seq]
  [<ffffffff815395fe>] __asan_report_load1_noabort+0x2e/0x30
  [<ffffffffa07aadf4>] snd_seq_ioctl_create_port+0x504/0x630 [snd_seq]
  [<ffffffffa07aa8f0>] ? snd_seq_ioctl_delete_port+0x180/0x180 [snd_seq]
  [<ffffffff8136be50>] ? taskstats_exit+0xbc0/0xbc0
  [<ffffffffa07abc5c>] snd_seq_do_ioctl+0x11c/0x190 [snd_seq]
  [<ffffffffa07abd10>] snd_seq_ioctl+0x40/0x80 [snd_seq]
  [<ffffffff8136d433>] ? acct_account_cputime+0x63/0x80
  [<ffffffff815b515b>] do_vfs_ioctl+0x54b/0xda0
  .....

We may fix this in a few different ways, and in this patch, it's fixed
simply by taking the refcount properly at snd_seq_create_port() and
letting the caller unref the object after use.  Also, there is another
potential use-after-free by sprintf() call in snd_seq_create_port(),
and this is moved inside the lock.

This fix covers CVE-2017-15265.

Reported-and-tested-by: Michael23 Yu <ycqzsy@gmail.com>
Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>",1,sound/core/seq/seq_clientmgr.c,"{""sha"": ""6c9cba2166d95b3b9175cc9eb39ca14e3a14f0f5"", ""filename"": ""sound/core/seq/seq_clientmgr.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/71105998845fb012937332fe2e806d443c09e026/sound/core/seq/seq_clientmgr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/71105998845fb012937332fe2e806d443c09e026/sound/core/seq/seq_clientmgr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/sound/core/seq/seq_clientmgr.c?ref=71105998845fb012937332fe2e806d443c09e026"", ""patch"": ""@@ -1259,6 +1259,7 @@ static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n \tstruct snd_seq_port_info *info = arg;\n \tstruct snd_seq_client_port *port;\n \tstruct snd_seq_port_callback *callback;\n+\tint port_idx;\n \n \t/* it is not allowed to create the port for an another client */\n \tif (info->addr.client != client->number)\n@@ -1269,7 +1270,9 @@ static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n \t\treturn -ENOMEM;\n \n \tif (client->type == USER_CLIENT && info->kernel) {\n-\t\tsnd_seq_delete_port(client, port->addr.port);\n+\t\tport_idx = port->addr.port;\n+\t\tsnd_seq_port_unlock(port);\n+\t\tsnd_seq_delete_port(client, port_idx);\n \t\treturn -EINVAL;\n \t}\n \tif (client->type == KERNEL_CLIENT) {\n@@ -1290,6 +1293,7 @@ static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n \n \tsnd_seq_set_port_info(port, info);\n \tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n+\tsnd_seq_port_unlock(port);\n \n \treturn 0;\n }""}<_**next**_>{""sha"": ""d21ece9f8d7365e5e621156f1e44b85aa11eb1a1"", ""filename"": ""sound/core/seq/seq_ports.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/71105998845fb012937332fe2e806d443c09e026/sound/core/seq/seq_ports.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/71105998845fb012937332fe2e806d443c09e026/sound/core/seq/seq_ports.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/sound/core/seq/seq_ports.c?ref=71105998845fb012937332fe2e806d443c09e026"", ""patch"": ""@@ -122,7 +122,9 @@ static void port_subs_info_init(struct snd_seq_port_subs_info *grp)\n }\n \n \n-/* create a port, port number is returned (-1 on failure) */\n+/* create a port, port number is returned (-1 on failure);\n+ * the caller needs to unref the port via snd_seq_port_unlock() appropriately\n+ */\n struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \t\t\t\t\t\tint port)\n {\n@@ -151,6 +153,7 @@ struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \tsnd_use_lock_init(&new_port->use_lock);\n \tport_subs_info_init(&new_port->c_src);\n \tport_subs_info_init(&new_port->c_dest);\n+\tsnd_use_lock_use(&new_port->use_lock);\n \n \tnum = port >= 0 ? port : 0;\n \tmutex_lock(&client->ports_mutex);\n@@ -165,9 +168,9 @@ struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \tlist_add_tail(&new_port->list, &p->list);\n \tclient->num_ports++;\n \tnew_port->addr.port = num;\t/* store the port number in the port */\n+\tsprintf(new_port->name, \""port-%d\"", num);\n \twrite_unlock_irqrestore(&client->ports_lock, flags);\n \tmutex_unlock(&client->ports_mutex);\n-\tsprintf(new_port->name, \""port-%d\"", num);\n \n \treturn new_port;\n }""}","static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)
{
 	struct snd_seq_port_info *info = arg;
 	struct snd_seq_client_port *port;
 	struct snd_seq_port_callback *callback;
	int port_idx;
 
 	/* it is not allowed to create the port for an another client */
 	if (info->addr.client != client->number)
		return -EPERM;

	port = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);
	if (port == NULL)
 		return -ENOMEM;
 
 	if (client->type == USER_CLIENT && info->kernel) {
		port_idx = port->addr.port;
		snd_seq_port_unlock(port);
		snd_seq_delete_port(client, port_idx);
 		return -EINVAL;
 	}
 	if (client->type == KERNEL_CLIENT) {
		if ((callback = info->kernel) != NULL) {
			if (callback->owner)
				port->owner = callback->owner;
			port->private_data = callback->private_data;
			port->private_free = callback->private_free;
			port->event_input = callback->event_input;
			port->c_src.open = callback->subscribe;
			port->c_src.close = callback->unsubscribe;
			port->c_dest.open = callback->use;
			port->c_dest.close = callback->unuse;
		}
	}

	info->addr = port->addr;
 
 	snd_seq_set_port_info(port, info);
 	snd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);
	snd_seq_port_unlock(port);
 
 	return 0;
 }
","static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)
{
 	struct snd_seq_port_info *info = arg;
 	struct snd_seq_client_port *port;
 	struct snd_seq_port_callback *callback;
 
 	/* it is not allowed to create the port for an another client */
 	if (info->addr.client != client->number)
		return -EPERM;

	port = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);
	if (port == NULL)
 		return -ENOMEM;
 
 	if (client->type == USER_CLIENT && info->kernel) {
		snd_seq_delete_port(client, port->addr.port);
 		return -EINVAL;
 	}
 	if (client->type == KERNEL_CLIENT) {
		if ((callback = info->kernel) != NULL) {
			if (callback->owner)
				port->owner = callback->owner;
			port->private_data = callback->private_data;
			port->private_free = callback->private_free;
			port->event_input = callback->event_input;
			port->c_src.open = callback->subscribe;
			port->c_src.close = callback->unsubscribe;
			port->c_dest.open = callback->use;
			port->c_dest.close = callback->unuse;
		}
	}

	info->addr = port->addr;
 
 	snd_seq_set_port_info(port, info);
 	snd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);
 
 	return 0;
 }
",C,"	int port_idx;
		port_idx = port->addr.port;
		snd_seq_port_unlock(port);
		snd_seq_delete_port(client, port_idx);
	snd_seq_port_unlock(port);
","		snd_seq_delete_port(client, port->addr.port);
",,"@@ -1259,6 +1259,7 @@ static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)
 	struct snd_seq_port_info *info = arg;
 	struct snd_seq_client_port *port;
 	struct snd_seq_port_callback *callback;
+	int port_idx;
 
 	/* it is not allowed to create the port for an another client */
 	if (info->addr.client != client->number)
@@ -1269,7 +1270,9 @@ static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)
 		return -ENOMEM;
 
 	if (client->type == USER_CLIENT && info->kernel) {
-		snd_seq_delete_port(client, port->addr.port);
+		port_idx = port->addr.port;
+		snd_seq_port_unlock(port);
+		snd_seq_delete_port(client, port_idx);
 		return -EINVAL;
 	}
 	if (client->type == KERNEL_CLIENT) {
@@ -1290,6 +1293,7 @@ static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)
 
 	snd_seq_set_port_info(port, info);
 	snd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);
+	snd_seq_port_unlock(port);
 
 	return 0;
 }",linux,71105998845fb012937332fe2e806d443c09e026,124751d5e63c823092060074bd0abaae61aaa9c4,1,"static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)
{
 	struct snd_seq_port_info *info = arg;
 	struct snd_seq_client_port *port;
 	struct snd_seq_port_callback *callback;
//fix_flaw_line_below:
//	int port_idx;
 
 	/* it is not allowed to create the port for an another client */
 	if (info->addr.client != client->number)
		return -EPERM;

	port = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);
	if (port == NULL)
 		return -ENOMEM;
 
 	if (client->type == USER_CLIENT && info->kernel) {
//flaw_line_below:
		snd_seq_delete_port(client, port->addr.port);
//fix_flaw_line_below:
//		port_idx = port->addr.port;
//fix_flaw_line_below:
//		snd_seq_port_unlock(port);
//fix_flaw_line_below:
//		snd_seq_delete_port(client, port_idx);
 		return -EINVAL;
 	}
 	if (client->type == KERNEL_CLIENT) {
		if ((callback = info->kernel) != NULL) {
			if (callback->owner)
				port->owner = callback->owner;
			port->private_data = callback->private_data;
			port->private_free = callback->private_free;
			port->event_input = callback->event_input;
			port->c_src.open = callback->subscribe;
			port->c_src.close = callback->unsubscribe;
			port->c_dest.open = callback->use;
			port->c_dest.close = callback->unuse;
		}
	}

	info->addr = port->addr;
 
 	snd_seq_set_port_info(port, info);
 	snd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);
//fix_flaw_line_below:
//	snd_seq_port_unlock(port);
 
 	return 0;
 }
",180900,"static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)
{
 	struct snd_seq_port_info *info = arg;
 	struct snd_seq_client_port *port;
 	struct snd_seq_port_callback *callback;
 
 	/* it is not allowed to create the port for an another client */
 	if (info->addr.client != client->number)
		return -EPERM;

	port = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);
	if (port == NULL)
 		return -ENOMEM;
 
 	if (client->type == USER_CLIENT && info->kernel) {
		snd_seq_delete_port(client, port->addr.port);
 		return -EINVAL;
 	}
 	if (client->type == KERNEL_CLIENT) {
		if ((callback = info->kernel) != NULL) {
			if (callback->owner)
				port->owner = callback->owner;
			port->private_data = callback->private_data;
			port->private_free = callback->private_free;
			port->event_input = callback->event_input;
			port->c_src.open = callback->subscribe;
			port->c_src.close = callback->unsubscribe;
			port->c_dest.open = callback->use;
			port->c_dest.close = callback->unuse;
		}
	}

	info->addr = port->addr;
 
 	snd_seq_set_port_info(port, info);
 	snd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);
 
 	return 0;
 }
","static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)
{
 	struct snd_seq_port_info *info = arg;
 	struct snd_seq_client_port *port;
 	struct snd_seq_port_callback *callback;
	int port_idx;
 
 	/* it is not allowed to create the port for an another client */
 	if (info->addr.client != client->number)
		return -EPERM;

	port = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);
	if (port == NULL)
 		return -ENOMEM;
 
 	if (client->type == USER_CLIENT && info->kernel) {
		port_idx = port->addr.port;
		snd_seq_port_unlock(port);
		snd_seq_delete_port(client, port_idx);
 		return -EINVAL;
 	}
 	if (client->type == KERNEL_CLIENT) {
		if ((callback = info->kernel) != NULL) {
			if (callback->owner)
				port->owner = callback->owner;
			port->private_data = callback->private_data;
			port->private_free = callback->private_free;
			port->event_input = callback->event_input;
			port->c_src.open = callback->subscribe;
			port->c_src.close = callback->unsubscribe;
			port->c_dest.open = callback->use;
			port->c_dest.close = callback->unuse;
		}
	}

	info->addr = port->addr;
 
 	snd_seq_set_port_info(port, info);
 	snd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);
	snd_seq_port_unlock(port);
 
 	return 0;
 }
","The `snd_seq_ioctl_create_port` function is responsible for creating a new port for a given MIDI client in a sound sequence system. It first checks if the port creation request is for the correct client; if not, it returns a permission error. If valid, it attempts to create the port and handles memory allocation errors. For user clients, it ensures that kernel ports cannot be created. For kernel clients, it sets up various callback functions and private data associated with the port. Finally, it updates the port information and notifies the system of the new port's creation, returning success or an error code as appropriate.","The provided code defines a function that facilitates the creation of a new port for a MIDI client within a sound sequence system. It begins by verifying that the port creation request is made by the correct client, returning an error if it is not. Upon validation, it attempts to create the port and handles any memory allocation issues. The function also ensures that user clients cannot create kernel ports. For kernel clients, it configures various callback functions and associated data for the port. Finally, it updates the port's information and notifies the system of the new port's establishment, returning an appropriate status.","The vulnerability in the original code stemmed from a race condition during the creation and deletion of a port, which could lead to a use-after-free error. Specifically, the function created a port object without incrementing its reference count, allowing another thread to delete it while the current thread was still using it. This was evident when the code attempted to call a function with the potentially deleted port object, resulting in memory access violations. The fix involved properly managing the reference count in the `snd_seq_create_port` function, ensuring that the port remains valid while in use, and moving certain operations within a lock to prevent concurrent access issues.","The vulnerability in the original code arose from a race condition during the creation and deletion of a port, which could lead to a use-after-free error. Specifically, the code created a port object without incrementing its reference count, allowing another thread to delete it while the current thread was still using it. This situation resulted in accessing a freed memory location, causing instability. The fix involved properly managing the reference count during the port creation process, ensuring the object remains valid while in use, and moving certain operations within a lock to prevent concurrent access issues, thereby eliminating the race condition.","The vulnerability was fixed by modifying the `snd_seq_create_port` function to properly manage the reference count of the port object upon creation. This ensures that the port remains valid while it is being used, preventing it from being deleted by another thread prematurely. Additionally, the code now includes a call to `snd_seq_port_unlock` before deleting the port in the case of user clients, which helps to avoid potential use-after-free scenarios. Furthermore, the `sprintf` call within `snd_seq_create_port` was moved inside a lock to prevent concurrent access issues, enhancing overall thread safety.","The vulnerability was addressed by implementing proper reference counting for the port object during its creation, ensuring that it remains valid while in use and cannot be deleted by another thread prematurely. This change prevents the potential for accessing freed memory, which could lead to instability. Additionally, certain operations were moved within a locking mechanism to safeguard against concurrent access issues, further enhancing thread safety. These modifications collectively eliminate the race condition that previously allowed for use-after-free errors, thereby improving the reliability of the code.","CWE-666, CWE-825, CWE-416, CWE-667, CWE-362, CWE-609, CWE-675, CWE-772, CWE-662, CWE-673",N,-1
22,22,180901,180901,,Local,Not required,Complete,CVE-2017-15265,https://www.cvedetails.com/cve/CVE-2017-15265/,CWE-416,Medium,Complete,Complete,,2017-10-16,6.9,"Race condition in the ALSA subsystem in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted /dev/snd/seq ioctl calls, related to sound/core/seq/seq_clientmgr.c and sound/core/seq/seq_ports.c.",2019-04-23,DoS ,2,https://github.com/torvalds/linux/commit/71105998845fb012937332fe2e806d443c09e026,71105998845fb012937332fe2e806d443c09e026,"ALSA: seq: Fix use-after-free at creating a port

There is a potential race window opened at creating and deleting a
port via ioctl, as spotted by fuzzing.  snd_seq_create_port() creates
a port object and returns its pointer, but it doesn't take the
refcount, thus it can be deleted immediately by another thread.
Meanwhile, snd_seq_ioctl_create_port() still calls the function
snd_seq_system_client_ev_port_start() with the created port object
that is being deleted, and this triggers use-after-free like:

 BUG: KASAN: use-after-free in snd_seq_ioctl_create_port+0x504/0x630 [snd_seq] at addr ffff8801f2241cb1
 =============================================================================
 BUG kmalloc-512 (Tainted: G    B          ): kasan: bad access detected
 -----------------------------------------------------------------------------
 INFO: Allocated in snd_seq_create_port+0x94/0x9b0 [snd_seq] age=1 cpu=3 pid=4511
 	___slab_alloc+0x425/0x460
 	__slab_alloc+0x20/0x40
  	kmem_cache_alloc_trace+0x150/0x190
	snd_seq_create_port+0x94/0x9b0 [snd_seq]
	snd_seq_ioctl_create_port+0xd1/0x630 [snd_seq]
 	snd_seq_do_ioctl+0x11c/0x190 [snd_seq]
 	snd_seq_ioctl+0x40/0x80 [snd_seq]
 	do_vfs_ioctl+0x54b/0xda0
 	SyS_ioctl+0x79/0x90
 	entry_SYSCALL_64_fastpath+0x16/0x75
 INFO: Freed in port_delete+0x136/0x1a0 [snd_seq] age=1 cpu=2 pid=4717
 	__slab_free+0x204/0x310
 	kfree+0x15f/0x180
 	port_delete+0x136/0x1a0 [snd_seq]
 	snd_seq_delete_port+0x235/0x350 [snd_seq]
 	snd_seq_ioctl_delete_port+0xc8/0x180 [snd_seq]
 	snd_seq_do_ioctl+0x11c/0x190 [snd_seq]
 	snd_seq_ioctl+0x40/0x80 [snd_seq]
 	do_vfs_ioctl+0x54b/0xda0
 	SyS_ioctl+0x79/0x90
 	entry_SYSCALL_64_fastpath+0x16/0x75
 Call Trace:
  [<ffffffff81b03781>] dump_stack+0x63/0x82
  [<ffffffff81531b3b>] print_trailer+0xfb/0x160
  [<ffffffff81536db4>] object_err+0x34/0x40
  [<ffffffff815392d3>] kasan_report.part.2+0x223/0x520
  [<ffffffffa07aadf4>] ? snd_seq_ioctl_create_port+0x504/0x630 [snd_seq]
  [<ffffffff815395fe>] __asan_report_load1_noabort+0x2e/0x30
  [<ffffffffa07aadf4>] snd_seq_ioctl_create_port+0x504/0x630 [snd_seq]
  [<ffffffffa07aa8f0>] ? snd_seq_ioctl_delete_port+0x180/0x180 [snd_seq]
  [<ffffffff8136be50>] ? taskstats_exit+0xbc0/0xbc0
  [<ffffffffa07abc5c>] snd_seq_do_ioctl+0x11c/0x190 [snd_seq]
  [<ffffffffa07abd10>] snd_seq_ioctl+0x40/0x80 [snd_seq]
  [<ffffffff8136d433>] ? acct_account_cputime+0x63/0x80
  [<ffffffff815b515b>] do_vfs_ioctl+0x54b/0xda0
  .....

We may fix this in a few different ways, and in this patch, it's fixed
simply by taking the refcount properly at snd_seq_create_port() and
letting the caller unref the object after use.  Also, there is another
potential use-after-free by sprintf() call in snd_seq_create_port(),
and this is moved inside the lock.

This fix covers CVE-2017-15265.

Reported-and-tested-by: Michael23 Yu <ycqzsy@gmail.com>
Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>",1,sound/core/seq/seq_ports.c,"{""sha"": ""6c9cba2166d95b3b9175cc9eb39ca14e3a14f0f5"", ""filename"": ""sound/core/seq/seq_clientmgr.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/71105998845fb012937332fe2e806d443c09e026/sound/core/seq/seq_clientmgr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/71105998845fb012937332fe2e806d443c09e026/sound/core/seq/seq_clientmgr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/sound/core/seq/seq_clientmgr.c?ref=71105998845fb012937332fe2e806d443c09e026"", ""patch"": ""@@ -1259,6 +1259,7 @@ static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n \tstruct snd_seq_port_info *info = arg;\n \tstruct snd_seq_client_port *port;\n \tstruct snd_seq_port_callback *callback;\n+\tint port_idx;\n \n \t/* it is not allowed to create the port for an another client */\n \tif (info->addr.client != client->number)\n@@ -1269,7 +1270,9 @@ static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n \t\treturn -ENOMEM;\n \n \tif (client->type == USER_CLIENT && info->kernel) {\n-\t\tsnd_seq_delete_port(client, port->addr.port);\n+\t\tport_idx = port->addr.port;\n+\t\tsnd_seq_port_unlock(port);\n+\t\tsnd_seq_delete_port(client, port_idx);\n \t\treturn -EINVAL;\n \t}\n \tif (client->type == KERNEL_CLIENT) {\n@@ -1290,6 +1293,7 @@ static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n \n \tsnd_seq_set_port_info(port, info);\n \tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n+\tsnd_seq_port_unlock(port);\n \n \treturn 0;\n }""}<_**next**_>{""sha"": ""d21ece9f8d7365e5e621156f1e44b85aa11eb1a1"", ""filename"": ""sound/core/seq/seq_ports.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/71105998845fb012937332fe2e806d443c09e026/sound/core/seq/seq_ports.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/71105998845fb012937332fe2e806d443c09e026/sound/core/seq/seq_ports.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/sound/core/seq/seq_ports.c?ref=71105998845fb012937332fe2e806d443c09e026"", ""patch"": ""@@ -122,7 +122,9 @@ static void port_subs_info_init(struct snd_seq_port_subs_info *grp)\n }\n \n \n-/* create a port, port number is returned (-1 on failure) */\n+/* create a port, port number is returned (-1 on failure);\n+ * the caller needs to unref the port via snd_seq_port_unlock() appropriately\n+ */\n struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \t\t\t\t\t\tint port)\n {\n@@ -151,6 +153,7 @@ struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \tsnd_use_lock_init(&new_port->use_lock);\n \tport_subs_info_init(&new_port->c_src);\n \tport_subs_info_init(&new_port->c_dest);\n+\tsnd_use_lock_use(&new_port->use_lock);\n \n \tnum = port >= 0 ? port : 0;\n \tmutex_lock(&client->ports_mutex);\n@@ -165,9 +168,9 @@ struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \tlist_add_tail(&new_port->list, &p->list);\n \tclient->num_ports++;\n \tnew_port->addr.port = num;\t/* store the port number in the port */\n+\tsprintf(new_port->name, \""port-%d\"", num);\n \twrite_unlock_irqrestore(&client->ports_lock, flags);\n \tmutex_unlock(&client->ports_mutex);\n-\tsprintf(new_port->name, \""port-%d\"", num);\n \n \treturn new_port;\n }""}"," struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 						int port)
 {
	unsigned long flags;
	struct snd_seq_client_port *new_port, *p;
	int num = -1;
	
	/* sanity check */
	if (snd_BUG_ON(!client))
		return NULL;

	if (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {
		pr_warn(""ALSA: seq: too many ports for client %d\n"", client->number);
		return NULL;
	}

	/* create a new port */
	new_port = kzalloc(sizeof(*new_port), GFP_KERNEL);
	if (!new_port)
		return NULL;	/* failure, out of memory */
	/* init port data */
	new_port->addr.client = client->number;
	new_port->addr.port = -1;
	new_port->owner = THIS_MODULE;
	sprintf(new_port->name, ""port-%d"", num);
 	snd_use_lock_init(&new_port->use_lock);
 	port_subs_info_init(&new_port->c_src);
 	port_subs_info_init(&new_port->c_dest);
	snd_use_lock_use(&new_port->use_lock);
 
 	num = port >= 0 ? port : 0;
 	mutex_lock(&client->ports_mutex);
	write_lock_irqsave(&client->ports_lock, flags);
	list_for_each_entry(p, &client->ports_list_head, list) {
		if (p->addr.port > num)
			break;
		if (port < 0) /* auto-probe mode */
			num = p->addr.port + 1;
	}
	/* insert the new port */
 	list_add_tail(&new_port->list, &p->list);
 	client->num_ports++;
 	new_port->addr.port = num;	/* store the port number in the port */
	sprintf(new_port->name, ""port-%d"", num);
 	write_unlock_irqrestore(&client->ports_lock, flags);
 	mutex_unlock(&client->ports_mutex);
 
 	return new_port;
 }
"," struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 						int port)
 {
	unsigned long flags;
	struct snd_seq_client_port *new_port, *p;
	int num = -1;
	
	/* sanity check */
	if (snd_BUG_ON(!client))
		return NULL;

	if (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {
		pr_warn(""ALSA: seq: too many ports for client %d\n"", client->number);
		return NULL;
	}

	/* create a new port */
	new_port = kzalloc(sizeof(*new_port), GFP_KERNEL);
	if (!new_port)
		return NULL;	/* failure, out of memory */
	/* init port data */
	new_port->addr.client = client->number;
	new_port->addr.port = -1;
	new_port->owner = THIS_MODULE;
	sprintf(new_port->name, ""port-%d"", num);
 	snd_use_lock_init(&new_port->use_lock);
 	port_subs_info_init(&new_port->c_src);
 	port_subs_info_init(&new_port->c_dest);
 
 	num = port >= 0 ? port : 0;
 	mutex_lock(&client->ports_mutex);
	write_lock_irqsave(&client->ports_lock, flags);
	list_for_each_entry(p, &client->ports_list_head, list) {
		if (p->addr.port > num)
			break;
		if (port < 0) /* auto-probe mode */
			num = p->addr.port + 1;
	}
	/* insert the new port */
 	list_add_tail(&new_port->list, &p->list);
 	client->num_ports++;
 	new_port->addr.port = num;	/* store the port number in the port */
 	write_unlock_irqrestore(&client->ports_lock, flags);
 	mutex_unlock(&client->ports_mutex);
	sprintf(new_port->name, ""port-%d"", num);
 
 	return new_port;
 }
",C,"	snd_use_lock_use(&new_port->use_lock);
	sprintf(new_port->name, ""port-%d"", num);
","	sprintf(new_port->name, ""port-%d"", num);
",,"@@ -122,7 +122,9 @@ static void port_subs_info_init(struct snd_seq_port_subs_info *grp)
 }
 
 
-/* create a port, port number is returned (-1 on failure) */
+/* create a port, port number is returned (-1 on failure);
+ * the caller needs to unref the port via snd_seq_port_unlock() appropriately
+ */
 struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 						int port)
 {
@@ -151,6 +153,7 @@ struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 	snd_use_lock_init(&new_port->use_lock);
 	port_subs_info_init(&new_port->c_src);
 	port_subs_info_init(&new_port->c_dest);
+	snd_use_lock_use(&new_port->use_lock);
 
 	num = port >= 0 ? port : 0;
 	mutex_lock(&client->ports_mutex);
@@ -165,9 +168,9 @@ struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 	list_add_tail(&new_port->list, &p->list);
 	client->num_ports++;
 	new_port->addr.port = num;	/* store the port number in the port */
+	sprintf(new_port->name, ""port-%d"", num);
 	write_unlock_irqrestore(&client->ports_lock, flags);
 	mutex_unlock(&client->ports_mutex);
-	sprintf(new_port->name, ""port-%d"", num);
 
 	return new_port;
 }",linux,71105998845fb012937332fe2e806d443c09e026,124751d5e63c823092060074bd0abaae61aaa9c4,1," struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 						int port)
 {
	unsigned long flags;
	struct snd_seq_client_port *new_port, *p;
	int num = -1;
	
	/* sanity check */
	if (snd_BUG_ON(!client))
		return NULL;

	if (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {
		pr_warn(""ALSA: seq: too many ports for client %d\n"", client->number);
		return NULL;
	}

	/* create a new port */
	new_port = kzalloc(sizeof(*new_port), GFP_KERNEL);
	if (!new_port)
		return NULL;	/* failure, out of memory */
	/* init port data */
	new_port->addr.client = client->number;
	new_port->addr.port = -1;
	new_port->owner = THIS_MODULE;
	sprintf(new_port->name, ""port-%d"", num);
 	snd_use_lock_init(&new_port->use_lock);
 	port_subs_info_init(&new_port->c_src);
 	port_subs_info_init(&new_port->c_dest);
//fix_flaw_line_below:
//	snd_use_lock_use(&new_port->use_lock);
 
 	num = port >= 0 ? port : 0;
 	mutex_lock(&client->ports_mutex);
	write_lock_irqsave(&client->ports_lock, flags);
	list_for_each_entry(p, &client->ports_list_head, list) {
		if (p->addr.port > num)
			break;
		if (port < 0) /* auto-probe mode */
			num = p->addr.port + 1;
	}
	/* insert the new port */
 	list_add_tail(&new_port->list, &p->list);
 	client->num_ports++;
 	new_port->addr.port = num;	/* store the port number in the port */
//fix_flaw_line_below:
//	sprintf(new_port->name, ""port-%d"", num);
 	write_unlock_irqrestore(&client->ports_lock, flags);
 	mutex_unlock(&client->ports_mutex);
//flaw_line_below:
	sprintf(new_port->name, ""port-%d"", num);
 
 	return new_port;
 }
",180901," struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 						int port)
 {
	unsigned long flags;
	struct snd_seq_client_port *new_port, *p;
	int num = -1;
	
	/* sanity check */
	if (snd_BUG_ON(!client))
		return NULL;

	if (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {
		pr_warn(""ALSA: seq: too many ports for client %d\n"", client->number);
		return NULL;
	}

	/* create a new port */
	new_port = kzalloc(sizeof(*new_port), GFP_KERNEL);
	if (!new_port)
		return NULL;	/* failure, out of memory */
	/* init port data */
	new_port->addr.client = client->number;
	new_port->addr.port = -1;
	new_port->owner = THIS_MODULE;
	sprintf(new_port->name, ""port-%d"", num);
 	snd_use_lock_init(&new_port->use_lock);
 	port_subs_info_init(&new_port->c_src);
 	port_subs_info_init(&new_port->c_dest);
 
 	num = port >= 0 ? port : 0;
 	mutex_lock(&client->ports_mutex);
	write_lock_irqsave(&client->ports_lock, flags);
	list_for_each_entry(p, &client->ports_list_head, list) {
		if (p->addr.port > num)
			break;
		if (port < 0) /* auto-probe mode */
			num = p->addr.port + 1;
	}
	/* insert the new port */
 	list_add_tail(&new_port->list, &p->list);
 	client->num_ports++;
 	new_port->addr.port = num;	/* store the port number in the port */
 	write_unlock_irqrestore(&client->ports_lock, flags);
 	mutex_unlock(&client->ports_mutex);
	sprintf(new_port->name, ""port-%d"", num);
 
 	return new_port;
 }
"," struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 						int port)
 {
	unsigned long flags;
	struct snd_seq_client_port *new_port, *p;
	int num = -1;
	
	/* sanity check */
	if (snd_BUG_ON(!client))
		return NULL;

	if (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {
		pr_warn(""ALSA: seq: too many ports for client %d\n"", client->number);
		return NULL;
	}

	/* create a new port */
	new_port = kzalloc(sizeof(*new_port), GFP_KERNEL);
	if (!new_port)
		return NULL;	/* failure, out of memory */
	/* init port data */
	new_port->addr.client = client->number;
	new_port->addr.port = -1;
	new_port->owner = THIS_MODULE;
	sprintf(new_port->name, ""port-%d"", num);
 	snd_use_lock_init(&new_port->use_lock);
 	port_subs_info_init(&new_port->c_src);
 	port_subs_info_init(&new_port->c_dest);
	snd_use_lock_use(&new_port->use_lock);
 
 	num = port >= 0 ? port : 0;
 	mutex_lock(&client->ports_mutex);
	write_lock_irqsave(&client->ports_lock, flags);
	list_for_each_entry(p, &client->ports_list_head, list) {
		if (p->addr.port > num)
			break;
		if (port < 0) /* auto-probe mode */
			num = p->addr.port + 1;
	}
	/* insert the new port */
 	list_add_tail(&new_port->list, &p->list);
 	client->num_ports++;
 	new_port->addr.port = num;	/* store the port number in the port */
	sprintf(new_port->name, ""port-%d"", num);
 	write_unlock_irqrestore(&client->ports_lock, flags);
 	mutex_unlock(&client->ports_mutex);
 
 	return new_port;
 }
","The `snd_seq_create_port` function is responsible for creating a new port for a given ALSA (Advanced Linux Sound Architecture) client. It first checks if the client is valid and whether it has reached the maximum number of allowed ports. If valid, it allocates memory for a new port and initializes its properties, including the client number and a default name. The function then acquires necessary locks to ensure thread safety while inserting the new port into the client's port list, either at a specified position or in auto-probe mode. Finally, it updates the port number and returns a pointer to the newly created port.","The provided code defines a function that creates a new communication port for a specified audio client within a sound architecture framework. It begins by validating the client and checking if the maximum number of ports has been reached. Upon successful validation, it allocates memory for the new port and initializes its attributes. The function then acquires necessary locks to ensure safe access to shared resources while inserting the new port into the client's list of ports, either at a designated position or automatically. Finally, it updates the port's identifier and returns a reference to the newly created port.","The vulnerability in the original code arises from a race condition where a newly created port object can be deleted by another thread immediately after its creation, leading to a use-after-free error. Specifically, the function creates a port and returns its pointer without incrementing the reference count, allowing another thread to free the object while it is still in use. The fix addresses this by properly incrementing the reference count using `snd_use_lock_use` after the port is created, ensuring that the object remains valid while it is being accessed. Additionally, the `sprintf` call was moved inside the lock to prevent potential race conditions during string formatting.","The vulnerability in the original code stems from a race condition that occurs when a newly created port object can be deleted by another thread immediately after its creation, leading to a use-after-free error. This happens because the code returns a pointer to the port without incrementing its reference count, allowing another thread to free it while it is still in use. The fix addresses this issue by properly incrementing the reference count upon creation, ensuring the object remains valid during its usage. Additionally, a potential use-after-free related to string formatting was resolved by moving the formatting operation within a critical section to prevent concurrent access issues.","The vulnerability was fixed by adding a reference count increment using `snd_use_lock_use` immediately after the creation of the new port object in the `snd_seq_create_port` function. This ensures that the port remains valid while it is being accessed by other functions, preventing it from being freed prematurely. Additionally, the `sprintf` call that formats the port name was moved inside the critical section protected by locks, ensuring that it is not executed concurrently with any potential deletion of the port, thereby mitigating the risk of a use-after-free condition.","The vulnerability was addressed by ensuring that the reference count of the newly created port object is incremented immediately after its creation, which prevents it from being deleted by another thread while still in use. This change guarantees that the object remains valid during its lifecycle, thus avoiding potential use-after-free errors. Additionally, the formatting operation for the port's name was relocated within a critical section to ensure that it is not executed concurrently with any deletion processes, further safeguarding against race conditions and ensuring thread safety throughout the port's management.","CWE-664,CWE-825,CWE-366,CWE-667,CWE-672,CWE-362,CWE-666,CWE-675,CWE-609,CWE-665",N,-1
23,23,180908,180908,,Local,Not required,Complete,CVE-2017-15115,https://www.cvedetails.com/cve/CVE-2017-15115/,CWE-416,Low,Complete,Complete,,2017-11-15,7.2,"The sctp_do_peeloff function in net/sctp/socket.c in the Linux kernel before 4.14 does not check whether the intended netns is used in a peel-off action, which allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via crafted system calls.",2019-05-08,DoS ,4,https://github.com/torvalds/linux/commit/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74,df80cd9b28b9ebaa284a41df611dbf3a2d05ca74,"sctp: do not peel off an assoc from one netns to another one

Now when peeling off an association to the sock in another netns, all
transports in this assoc are not to be rehashed and keep use the old
key in hashtable.

As a transport uses sk->net as the hash key to insert into hashtable,
it would miss removing these transports from hashtable due to the new
netns when closing the sock and all transports are being freeed, then
later an use-after-free issue could be caused when looking up an asoc
and dereferencing those transports.

This is a very old issue since very beginning, ChunYu found it with
syzkaller fuzz testing with this series:

  socket$inet6_sctp()
  bind$inet6()
  sendto$inet6()
  unshare(0x40000000)
  getsockopt$inet_sctp6_SCTP_GET_ASSOC_ID_LIST()
  getsockopt$inet_sctp6_SCTP_SOCKOPT_PEELOFF()

This patch is to block this call when peeling one assoc off from one
netns to another one, so that the netns of all transport would not
go out-sync with the key in hashtable.

Note that this patch didn't fix it by rehashing transports, as it's
difficult to handle the situation when the tuple is already in use
in the new netns. Besides, no one would like to peel off one assoc
to another netns, considering ipaddrs, ifaces, etc. are usually
different.

Reported-by: ChunYu Wang <chunwang@redhat.com>
Signed-off-by: Xin Long <lucien.xin@gmail.com>
Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Acked-by: Neil Horman <nhorman@tuxdriver.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/sctp/socket.c,"{""sha"": ""17841ab30798ecb2d7269296dcda3c62d434d622"", ""filename"": ""net/sctp/socket.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74/net/sctp/socket.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74/net/sctp/socket.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/sctp/socket.c?ref=df80cd9b28b9ebaa284a41df611dbf3a2d05ca74"", ""patch"": ""@@ -4906,6 +4906,10 @@ int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n \tstruct socket *sock;\n \tint err = 0;\n \n+\t/* Do not peel off from one netns to another one. */\n+\tif (!net_eq(current->nsproxy->net_ns, sock_net(sk)))\n+\t\treturn -EINVAL;\n+\n \tif (!asoc)\n \t\treturn -EINVAL;\n ""}","int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 
	/* Do not peel off from one netns to another one. */
	if (!net_eq(current->nsproxy->net_ns, sock_net(sk)))
		return -EINVAL;

 	if (!asoc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
","int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 
 	if (!asoc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
",C,"	/* Do not peel off from one netns to another one. */
	if (!net_eq(current->nsproxy->net_ns, sock_net(sk)))
		return -EINVAL;

",,,"@@ -4906,6 +4906,10 @@ int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
 	struct socket *sock;
 	int err = 0;
 
+	/* Do not peel off from one netns to another one. */
+	if (!net_eq(current->nsproxy->net_ns, sock_net(sk)))
+		return -EINVAL;
+
 	if (!asoc)
 		return -EINVAL;
 ",linux,df80cd9b28b9ebaa284a41df611dbf3a2d05ca74,4bbb5083484016d4448739237aa1e6a9577ebb43,1,"int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 
//fix_flaw_line_below:
//	/* Do not peel off from one netns to another one. */
//fix_flaw_line_below:
//	if (!net_eq(current->nsproxy->net_ns, sock_net(sk)))
//fix_flaw_line_below:
//		return -EINVAL;
//fix_flaw_line_below:
//
 	if (!asoc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
",180908,"int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 
 	if (!asoc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
","int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 
	/* Do not peel off from one netns to another one. */
	if (!net_eq(current->nsproxy->net_ns, sock_net(sk)))
		return -EINVAL;

 	if (!asoc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
","The `sctp_do_peeloff` function facilitates the creation of a new socket from an existing SCTP (Stream Control Transmission Protocol) socket, allowing for the separation of an association identified by `id`. It first verifies the validity of the association and checks if there are any active waiters for sending buffer space, which would prevent peeling off. If the socket is not of the UDP style, it returns an error. Upon successful validation, it creates a new socket, copies relevant properties from the original socket, and migrates the association to the new socket, ultimately returning the new socket through the `sockp` pointer.","The provided code defines a function that enables the creation of a new socket from an existing one, specifically for a certain communication association. It begins by validating the association and checking for any active processes waiting for buffer space, which would prevent the operation. If the socket type is not suitable, it returns an error. Upon successful checks, a new socket is created, and essential properties are transferred from the original socket. The association is then migrated to the new socket, allowing for independent communication, and the new socket is returned to the caller.","The vulnerability in the original code arises from the lack of checks to prevent peeling off an association from one network namespace to another, which could lead to a use-after-free issue. When an association is peeled off, the transport sockets use the original network namespace as a hash key in the hashtable. If the association is moved to a different namespace without rehashing, the old key remains, causing inconsistencies and potential dereferencing of freed memory. The fix introduces a check to ensure that the current network namespace matches the socket's namespace, thereby preventing this unsafe operation and maintaining synchronization between the transport sockets and their hash keys.","The vulnerability in the original code stems from the absence of checks to prevent the peeling off of an association from one network namespace to another, which could lead to a use-after-free condition. When an association is peeled off, the transport sockets retain their original namespace as a hash key, resulting in inconsistencies if the association is moved to a different namespace without rehashing. The fix introduces a validation step to ensure that the current network namespace matches the socket's namespace, thereby preventing this operation and ensuring that the transport sockets remain synchronized with their corresponding hash keys.","The vulnerability was fixed by adding a check at the beginning of the function to ensure that the current network namespace matches the socket's network namespace using the `net_eq` function. This prevents the peeling off of an association from one network namespace to another, which could lead to inconsistencies in the hash table where transport sockets are stored. By enforcing this condition, the code ensures that all transports remain synchronized with their hash keys, thus eliminating the risk of a use-after-free issue when dereferencing transports after the socket is closed.","The vulnerability was addressed by implementing a validation step that checks whether the current network namespace is the same as that of the socket before allowing the peeling off of an association. This prevents the operation from occurring across different network namespaces, which could lead to inconsistencies in the management of transport sockets and their associated hash keys. By enforcing this restriction, the fix ensures that all transport sockets remain properly synchronized with their hash entries, thereby eliminating the risk of dereferencing freed memory and preventing potential use-after-free issues.","CWE-119, CWE-416, CWE-909, CWE-269, CWE-266, CWE-668, CWE-732, CWE-284, CWE-664, CWE-20",N,-1
24,24,181134,181134,,Remote,Not required,Partial,CVE-2017-12877,https://www.cvedetails.com/cve/CVE-2017-12877/,CWE-416,Medium,,,,2017-08-28,4.3,Use-after-free vulnerability in the DestroyImage function in image.c in ImageMagick before 7.0.6-6 allows remote attackers to cause a denial of service via a crafted file.,2018-06-13,DoS ,2,https://github.com/ImageMagick/ImageMagick/commit/04178de2247e353fc095846784b9a10fefdbf890,04178de2247e353fc095846784b9a10fefdbf890,https://github.com/ImageMagick/ImageMagick/issues/662,2,coders/mat.c,"{""sha"": ""fc8da2b144d7c8b08e25b6b110c0db52f0eaeb3a"", ""filename"": ""coders/mat.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/04178de2247e353fc095846784b9a10fefdbf890/coders/mat.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/04178de2247e353fc095846784b9a10fefdbf890/coders/mat.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/mat.c?ref=04178de2247e353fc095846784b9a10fefdbf890"", ""patch"": ""@@ -1330,8 +1330,6 @@ RestoreMSCWarning\n   if (quantum_info != (QuantumInfo *) NULL)\n     quantum_info=DestroyQuantumInfo(quantum_info);\n END_OF_READING:\n-  if (clone_info)\n-    clone_info=DestroyImageInfo(clone_info);\n   CloseBlob(image);\n \n \n@@ -1349,6 +1347,8 @@ RestoreMSCWarning\n         Image *tmp=p;\n         if ((p->rows == 0) || (p->columns == 0)) {\n           p=p->previous;\n+          if (tmp == image2)\n+            image2=(Image *) NULL;\n           DeleteImageFromList(&tmp);\n         } else {\n           image=p;""}","static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  register Quantum *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  image = AcquireImage(image_info,exception);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  quantum_info=(QuantumInfo *) NULL;
  clone_info=(ImageInfo *) NULL;
  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
    {
MATLAB_KO:
      if ((image != image2) && (image2 != (Image *) NULL))
        image2=DestroyImage(image2);
      if (clone_info != (ImageInfo *) NULL)
        clone_info=DestroyImageInfo(clone_info);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
      goto MATLAB_KO;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    clone_info=CloneImageInfo(image_info);
    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if (MATLAB_HDR.DataType!=miMATRIX)
      {
        clone_info=DestroyImageInfo(clone_info);
        continue;  /* skip another objects. */
      }

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           (void) ReadBlobXXXLong(image2);
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
            ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default:
        if (clone_info != (ImageInfo *) NULL)
          clone_info=DestroyImageInfo(clone_info);
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

    NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        if (clone_info)
          clone_info=DestroyImageInfo(clone_info);
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
      goto MATLAB_KO;
    /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        image->type=GrayscaleType;
        SetImageColorspace(image,GRAYColorspace,exception);
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      {
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        return(DestroyImageList(image));
      }
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");

  /* ----- Load raster data ----- */
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (Quantum *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(image,q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
            exception);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
            exception);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image,exception);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }
    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
        }

    if (quantum_info != (QuantumInfo *) NULL)
      quantum_info=DestroyQuantumInfo(quantum_info);
    if (clone_info)
      clone_info=DestroyImageInfo(clone_info);
  }

  RelinquishMagickMemory(BImgBuff);
   if (quantum_info != (QuantumInfo *) NULL)
     quantum_info=DestroyQuantumInfo(quantum_info);
 END_OF_READING:
   CloseBlob(image);
 
 
  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
         Image *tmp=p;
         if ((p->rows == 0) || (p->columns == 0)) {
           p=p->previous;
          if (tmp == image2)
            image2=(Image *) NULL;
           DeleteImageFromList(&tmp);
         } else {
           image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if (image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"")
  else
    if ((image != image2) && (image2 != (Image *) NULL))
      image2=DestroyImage(image2);
  return (image);
}
","static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  register Quantum *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  image = AcquireImage(image_info,exception);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  quantum_info=(QuantumInfo *) NULL;
  clone_info=(ImageInfo *) NULL;
  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
    {
MATLAB_KO:
      if ((image != image2) && (image2 != (Image *) NULL))
        image2=DestroyImage(image2);
      if (clone_info != (ImageInfo *) NULL)
        clone_info=DestroyImageInfo(clone_info);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
      goto MATLAB_KO;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    clone_info=CloneImageInfo(image_info);
    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if (MATLAB_HDR.DataType!=miMATRIX)
      {
        clone_info=DestroyImageInfo(clone_info);
        continue;  /* skip another objects. */
      }

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           (void) ReadBlobXXXLong(image2);
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
            ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default:
        if (clone_info != (ImageInfo *) NULL)
          clone_info=DestroyImageInfo(clone_info);
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

    NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        if (clone_info)
          clone_info=DestroyImageInfo(clone_info);
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
      goto MATLAB_KO;
    /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        image->type=GrayscaleType;
        SetImageColorspace(image,GRAYColorspace,exception);
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      {
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        return(DestroyImageList(image));
      }
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");

  /* ----- Load raster data ----- */
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (Quantum *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(image,q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
            exception);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
            exception);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image,exception);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }
    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
        }

    if (quantum_info != (QuantumInfo *) NULL)
      quantum_info=DestroyQuantumInfo(quantum_info);
    if (clone_info)
      clone_info=DestroyImageInfo(clone_info);
  }

  RelinquishMagickMemory(BImgBuff);
   if (quantum_info != (QuantumInfo *) NULL)
     quantum_info=DestroyQuantumInfo(quantum_info);
 END_OF_READING:
  if (clone_info)
    clone_info=DestroyImageInfo(clone_info);
   CloseBlob(image);
 
 
  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
         Image *tmp=p;
         if ((p->rows == 0) || (p->columns == 0)) {
           p=p->previous;
           DeleteImageFromList(&tmp);
         } else {
           image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if (image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"")
  else
    if ((image != image2) && (image2 != (Image *) NULL))
      image2=DestroyImage(image2);
  return (image);
}
",C,"          if (tmp == image2)
            image2=(Image *) NULL;
","  if (clone_info)
    clone_info=DestroyImageInfo(clone_info);
",,"@@ -1330,8 +1330,6 @@ RestoreMSCWarning
   if (quantum_info != (QuantumInfo *) NULL)
     quantum_info=DestroyQuantumInfo(quantum_info);
 END_OF_READING:
-  if (clone_info)
-    clone_info=DestroyImageInfo(clone_info);
   CloseBlob(image);
 
 
@@ -1349,6 +1347,8 @@ RestoreMSCWarning
         Image *tmp=p;
         if ((p->rows == 0) || (p->columns == 0)) {
           p=p->previous;
+          if (tmp == image2)
+            image2=(Image *) NULL;
           DeleteImageFromList(&tmp);
         } else {
           image=p;",ImageMagick,04178de2247e353fc095846784b9a10fefdbf890,44c66e1521d7e3f88e64f070395e0b4de8a3964c,1,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  register Quantum *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  image = AcquireImage(image_info,exception);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  quantum_info=(QuantumInfo *) NULL;
  clone_info=(ImageInfo *) NULL;
  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
    {
MATLAB_KO:
      if ((image != image2) && (image2 != (Image *) NULL))
        image2=DestroyImage(image2);
      if (clone_info != (ImageInfo *) NULL)
        clone_info=DestroyImageInfo(clone_info);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
      goto MATLAB_KO;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    clone_info=CloneImageInfo(image_info);
    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if (MATLAB_HDR.DataType!=miMATRIX)
      {
        clone_info=DestroyImageInfo(clone_info);
        continue;  /* skip another objects. */
      }

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           (void) ReadBlobXXXLong(image2);
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
            ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default:
        if (clone_info != (ImageInfo *) NULL)
          clone_info=DestroyImageInfo(clone_info);
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

    NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        if (clone_info)
          clone_info=DestroyImageInfo(clone_info);
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
      goto MATLAB_KO;
    /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        image->type=GrayscaleType;
        SetImageColorspace(image,GRAYColorspace,exception);
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      {
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        return(DestroyImageList(image));
      }
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");

  /* ----- Load raster data ----- */
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (Quantum *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(image,q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
            exception);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
            exception);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image,exception);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }
    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
        }

    if (quantum_info != (QuantumInfo *) NULL)
      quantum_info=DestroyQuantumInfo(quantum_info);
    if (clone_info)
      clone_info=DestroyImageInfo(clone_info);
  }

  RelinquishMagickMemory(BImgBuff);
   if (quantum_info != (QuantumInfo *) NULL)
     quantum_info=DestroyQuantumInfo(quantum_info);
 END_OF_READING:
//flaw_line_below:
  if (clone_info)
//flaw_line_below:
    clone_info=DestroyImageInfo(clone_info);
   CloseBlob(image);
 
 
  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
         Image *tmp=p;
         if ((p->rows == 0) || (p->columns == 0)) {
           p=p->previous;
//fix_flaw_line_below:
//          if (tmp == image2)
//fix_flaw_line_below:
//            image2=(Image *) NULL;
           DeleteImageFromList(&tmp);
         } else {
           image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if (image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"")
  else
    if ((image != image2) && (image2 != (Image *) NULL))
      image2=DestroyImage(image2);
  return (image);
}
",181134,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  register Quantum *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  image = AcquireImage(image_info,exception);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  quantum_info=(QuantumInfo *) NULL;
  clone_info=(ImageInfo *) NULL;
  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
    {
MATLAB_KO:
      if ((image != image2) && (image2 != (Image *) NULL))
        image2=DestroyImage(image2);
      if (clone_info != (ImageInfo *) NULL)
        clone_info=DestroyImageInfo(clone_info);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
      goto MATLAB_KO;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    clone_info=CloneImageInfo(image_info);
    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if (MATLAB_HDR.DataType!=miMATRIX)
      {
        clone_info=DestroyImageInfo(clone_info);
        continue;  /* skip another objects. */
      }

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           (void) ReadBlobXXXLong(image2);
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
            ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default:
        if (clone_info != (ImageInfo *) NULL)
          clone_info=DestroyImageInfo(clone_info);
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

    NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        if (clone_info)
          clone_info=DestroyImageInfo(clone_info);
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
      goto MATLAB_KO;
    /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        image->type=GrayscaleType;
        SetImageColorspace(image,GRAYColorspace,exception);
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      {
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        return(DestroyImageList(image));
      }
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");

  /* ----- Load raster data ----- */
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (Quantum *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(image,q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
            exception);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
            exception);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image,exception);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }
    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
        }

    if (quantum_info != (QuantumInfo *) NULL)
      quantum_info=DestroyQuantumInfo(quantum_info);
    if (clone_info)
      clone_info=DestroyImageInfo(clone_info);
  }

  RelinquishMagickMemory(BImgBuff);
   if (quantum_info != (QuantumInfo *) NULL)
     quantum_info=DestroyQuantumInfo(quantum_info);
 END_OF_READING:
  if (clone_info)
    clone_info=DestroyImageInfo(clone_info);
   CloseBlob(image);
 
 
  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
         Image *tmp=p;
         if ((p->rows == 0) || (p->columns == 0)) {
           p=p->previous;
           DeleteImageFromList(&tmp);
         } else {
           image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if (image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"")
  else
    if ((image != image2) && (image2 != (Image *) NULL))
      image2=DestroyImage(image2);
  return (image);
}
","static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  register Quantum *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  image = AcquireImage(image_info,exception);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  quantum_info=(QuantumInfo *) NULL;
  clone_info=(ImageInfo *) NULL;
  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
    {
MATLAB_KO:
      if ((image != image2) && (image2 != (Image *) NULL))
        image2=DestroyImage(image2);
      if (clone_info != (ImageInfo *) NULL)
        clone_info=DestroyImageInfo(clone_info);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
      goto MATLAB_KO;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    clone_info=CloneImageInfo(image_info);
    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if (MATLAB_HDR.DataType!=miMATRIX)
      {
        clone_info=DestroyImageInfo(clone_info);
        continue;  /* skip another objects. */
      }

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           (void) ReadBlobXXXLong(image2);
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
            ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default:
        if (clone_info != (ImageInfo *) NULL)
          clone_info=DestroyImageInfo(clone_info);
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

    NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        if (clone_info)
          clone_info=DestroyImageInfo(clone_info);
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
      goto MATLAB_KO;
    /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        image->type=GrayscaleType;
        SetImageColorspace(image,GRAYColorspace,exception);
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      {
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        return(DestroyImageList(image));
      }
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");

  /* ----- Load raster data ----- */
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (Quantum *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(image,q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
            exception);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
            exception);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image,exception);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }
    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
        }

    if (quantum_info != (QuantumInfo *) NULL)
      quantum_info=DestroyQuantumInfo(quantum_info);
    if (clone_info)
      clone_info=DestroyImageInfo(clone_info);
  }

  RelinquishMagickMemory(BImgBuff);
   if (quantum_info != (QuantumInfo *) NULL)
     quantum_info=DestroyQuantumInfo(quantum_info);
 END_OF_READING:
   CloseBlob(image);
 
 
  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
         Image *tmp=p;
         if ((p->rows == 0) || (p->columns == 0)) {
           p=p->previous;
          if (tmp == image2)
            image2=(Image *) NULL;
           DeleteImageFromList(&tmp);
         } else {
           image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if (image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"")
  else
    if ((image != image2) && (image2 != (Image *) NULL))
      image2=DestroyImage(image2);
  return (image);
}
","The `ReadMATImage` function is designed to read MATLAB image files and convert them into a format usable by the MagickCore image processing library. It begins by validating input parameters and opening the specified image file. The function reads the MATLAB header to determine the file's endian format and data type, then processes the image data based on its dimensions and structure class. It handles various data types, including integers and floating-point numbers, while also managing complex data if present. The function constructs an image object, populates pixel data, and performs necessary transformations, such as rotation, before returning the final image or an error if the process fails.","The code defines a function that reads MATLAB image files and converts them into a compatible image format for processing. It begins by validating input parameters and opening the specified file, then reads the header to determine the file's format and data type. The function processes the image data based on its dimensions and structure, handling various data types, including integers and floating-point numbers, while also accommodating complex data if present. It constructs an image object, populates pixel data, applies necessary transformations, such as rotation, and returns the final image or an error if any issues arise during processing.","The vulnerability in the original code stemmed from insufficient validation of the MATLAB header and data types, which could lead to buffer overflows or memory corruption when processing unsupported or malformed files. Specifically, the code did not adequately check the dimensions and structure class of the data being read, allowing for potential exploitation through crafted input. The fixed code addresses this by implementing stricter checks on the data type and dimensions, ensuring that only supported types are processed. Additionally, it includes error handling to safely manage memory and resources, thereby mitigating the risk of crashes or security breaches.","The vulnerability in the original code arose from inadequate validation of the input data, particularly regarding the MATLAB header and data types, which could lead to buffer overflows or memory corruption when processing malformed files. This lack of strict checks allowed attackers to exploit the code by providing crafted input that the system could not handle safely. The revised code addresses this issue by implementing more rigorous validation of the data types and dimensions, ensuring that only supported formats are processed. Additionally, it enhances error handling to manage resources more effectively, thereby reducing the risk of crashes and security vulnerabilities.","The vulnerability was fixed by enhancing the validation checks for the MATLAB header and data types. The code now verifies that the data type read from the input matches supported types, such as checking the `StructureClass` against known valid classes. Additionally, the checks for `DimFlag` ensure that only 2D and 3D matrices are processed, preventing unsupported multidimensional matrices from being handled. The introduction of error handling mechanisms, such as throwing exceptions when encountering corrupt headers or unsupported types, ensures that resources are managed safely, reducing the risk of memory corruption and crashes.","The vulnerability was addressed by implementing stricter validation checks for the input data, ensuring that only supported data types and dimensions are processed. The code now verifies that the header information conforms to expected formats, rejecting any unsupported or malformed input. Additionally, enhanced error handling was introduced to manage resources more effectively, allowing the system to safely terminate operations when encountering issues. This combination of rigorous validation and improved error management significantly reduces the risk of buffer overflows and memory corruption, thereby enhancing the overall security and stability of the code.","CWE-119,CWE-20,CWE-131,CWE-789,CWE-121,CWE-122,CWE-680,CWE-754,CWE-664,CWE-190",N,-1
25,25,181219,181219,,Local,Not required,Complete,CVE-2017-11176,https://www.cvedetails.com/cve/CVE-2017-11176/,CWE-416,Low,Complete,Complete,,2017-07-11,7.2,"The mq_notify function in the Linux kernel through 4.11.9 does not set the sock pointer to NULL upon entry into the retry logic. During a user-space close of a Netlink socket, it allows attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact.",2018-12-13,DoS ,3,https://github.com/torvalds/linux/commit/f991af3daabaecff34684fd51fac80319d1baad1,f991af3daabaecff34684fd51fac80319d1baad1,"mqueue: fix a use-after-free in sys_mq_notify()

The retry logic for netlink_attachskb() inside sys_mq_notify()
is nasty and vulnerable:

1) The sock refcnt is already released when retry is needed
2) The fd is controllable by user-space because we already
   release the file refcnt

so we when retry but the fd has been just closed by user-space
during this small window, we end up calling netlink_detachskb()
on the error path which releases the sock again, later when
the user-space closes this socket a use-after-free could be
triggered.

Setting 'sock' to NULL here should be sufficient to fix it.

Reported-by: GeneBlue <geneblue.mail@gmail.com>
Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Manfred Spraul <manfred@colorfullife.com>
Cc: stable@kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",1,ipc/mqueue.c,"{""sha"": ""eb1391b52c6f84fe75dec4e8366d858341ac665a"", ""filename"": ""ipc/mqueue.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/f991af3daabaecff34684fd51fac80319d1baad1/ipc/mqueue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f991af3daabaecff34684fd51fac80319d1baad1/ipc/mqueue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/ipc/mqueue.c?ref=f991af3daabaecff34684fd51fac80319d1baad1"", ""patch"": ""@@ -1270,8 +1270,10 @@ static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n \n \t\t\ttimeo = MAX_SCHEDULE_TIMEOUT;\n \t\t\tret = netlink_attachskb(sock, nc, &timeo, NULL);\n-\t\t\tif (ret == 1)\n+\t\t\tif (ret == 1) {\n+\t\t\t\tsock = NULL;\n \t\t\t\tgoto retry;\n+\t\t\t}\n \t\t\tif (ret) {\n \t\t\t\tsock = NULL;\n \t\t\t\tnc = NULL;""}","static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)
{
	int ret;
	struct fd f;
	struct sock *sock;
	struct inode *inode;
	struct mqueue_inode_info *info;
	struct sk_buff *nc;

	audit_mq_notify(mqdes, notification);

	nc = NULL;
	sock = NULL;
	if (notification != NULL) {
		if (unlikely(notification->sigev_notify != SIGEV_NONE &&
			     notification->sigev_notify != SIGEV_SIGNAL &&
			     notification->sigev_notify != SIGEV_THREAD))
			return -EINVAL;
		if (notification->sigev_notify == SIGEV_SIGNAL &&
			!valid_signal(notification->sigev_signo)) {
			return -EINVAL;
		}
		if (notification->sigev_notify == SIGEV_THREAD) {
			long timeo;

			/* create the notify skb */
			nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);
			if (!nc) {
				ret = -ENOMEM;
				goto out;
			}
			if (copy_from_user(nc->data,
					notification->sigev_value.sival_ptr,
					NOTIFY_COOKIE_LEN)) {
				ret = -EFAULT;
				goto out;
			}

			/* TODO: add a header? */
			skb_put(nc, NOTIFY_COOKIE_LEN);
			/* and attach it to the socket */
retry:
			f = fdget(notification->sigev_signo);
			if (!f.file) {
				ret = -EBADF;
				goto out;
			}
			sock = netlink_getsockbyfilp(f.file);
			fdput(f);
			if (IS_ERR(sock)) {
				ret = PTR_ERR(sock);
				sock = NULL;
				goto out;
			}
 
 			timeo = MAX_SCHEDULE_TIMEOUT;
 			ret = netlink_attachskb(sock, nc, &timeo, NULL);
			if (ret == 1) {
				sock = NULL;
 				goto retry;
			}
 			if (ret) {
 				sock = NULL;
 				nc = NULL;
				goto out;
			}
		}
	}

	f = fdget(mqdes);
	if (!f.file) {
		ret = -EBADF;
		goto out;
	}

	inode = file_inode(f.file);
	if (unlikely(f.file->f_op != &mqueue_file_operations)) {
		ret = -EBADF;
		goto out_fput;
	}
	info = MQUEUE_I(inode);

	ret = 0;
	spin_lock(&info->lock);
	if (notification == NULL) {
		if (info->notify_owner == task_tgid(current)) {
			remove_notification(info);
			inode->i_atime = inode->i_ctime = current_time(inode);
		}
	} else if (info->notify_owner != NULL) {
		ret = -EBUSY;
	} else {
		switch (notification->sigev_notify) {
		case SIGEV_NONE:
			info->notify.sigev_notify = SIGEV_NONE;
			break;
		case SIGEV_THREAD:
			info->notify_sock = sock;
			info->notify_cookie = nc;
			sock = NULL;
			nc = NULL;
			info->notify.sigev_notify = SIGEV_THREAD;
			break;
		case SIGEV_SIGNAL:
			info->notify.sigev_signo = notification->sigev_signo;
			info->notify.sigev_value = notification->sigev_value;
			info->notify.sigev_notify = SIGEV_SIGNAL;
			break;
		}

		info->notify_owner = get_pid(task_tgid(current));
		info->notify_user_ns = get_user_ns(current_user_ns());
		inode->i_atime = inode->i_ctime = current_time(inode);
	}
	spin_unlock(&info->lock);
out_fput:
	fdput(f);
out:
	if (sock)
		netlink_detachskb(sock, nc);
	else if (nc)
		dev_kfree_skb(nc);

	return ret;
}
","static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)
{
	int ret;
	struct fd f;
	struct sock *sock;
	struct inode *inode;
	struct mqueue_inode_info *info;
	struct sk_buff *nc;

	audit_mq_notify(mqdes, notification);

	nc = NULL;
	sock = NULL;
	if (notification != NULL) {
		if (unlikely(notification->sigev_notify != SIGEV_NONE &&
			     notification->sigev_notify != SIGEV_SIGNAL &&
			     notification->sigev_notify != SIGEV_THREAD))
			return -EINVAL;
		if (notification->sigev_notify == SIGEV_SIGNAL &&
			!valid_signal(notification->sigev_signo)) {
			return -EINVAL;
		}
		if (notification->sigev_notify == SIGEV_THREAD) {
			long timeo;

			/* create the notify skb */
			nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);
			if (!nc) {
				ret = -ENOMEM;
				goto out;
			}
			if (copy_from_user(nc->data,
					notification->sigev_value.sival_ptr,
					NOTIFY_COOKIE_LEN)) {
				ret = -EFAULT;
				goto out;
			}

			/* TODO: add a header? */
			skb_put(nc, NOTIFY_COOKIE_LEN);
			/* and attach it to the socket */
retry:
			f = fdget(notification->sigev_signo);
			if (!f.file) {
				ret = -EBADF;
				goto out;
			}
			sock = netlink_getsockbyfilp(f.file);
			fdput(f);
			if (IS_ERR(sock)) {
				ret = PTR_ERR(sock);
				sock = NULL;
				goto out;
			}
 
 			timeo = MAX_SCHEDULE_TIMEOUT;
 			ret = netlink_attachskb(sock, nc, &timeo, NULL);
			if (ret == 1)
 				goto retry;
 			if (ret) {
 				sock = NULL;
 				nc = NULL;
				goto out;
			}
		}
	}

	f = fdget(mqdes);
	if (!f.file) {
		ret = -EBADF;
		goto out;
	}

	inode = file_inode(f.file);
	if (unlikely(f.file->f_op != &mqueue_file_operations)) {
		ret = -EBADF;
		goto out_fput;
	}
	info = MQUEUE_I(inode);

	ret = 0;
	spin_lock(&info->lock);
	if (notification == NULL) {
		if (info->notify_owner == task_tgid(current)) {
			remove_notification(info);
			inode->i_atime = inode->i_ctime = current_time(inode);
		}
	} else if (info->notify_owner != NULL) {
		ret = -EBUSY;
	} else {
		switch (notification->sigev_notify) {
		case SIGEV_NONE:
			info->notify.sigev_notify = SIGEV_NONE;
			break;
		case SIGEV_THREAD:
			info->notify_sock = sock;
			info->notify_cookie = nc;
			sock = NULL;
			nc = NULL;
			info->notify.sigev_notify = SIGEV_THREAD;
			break;
		case SIGEV_SIGNAL:
			info->notify.sigev_signo = notification->sigev_signo;
			info->notify.sigev_value = notification->sigev_value;
			info->notify.sigev_notify = SIGEV_SIGNAL;
			break;
		}

		info->notify_owner = get_pid(task_tgid(current));
		info->notify_user_ns = get_user_ns(current_user_ns());
		inode->i_atime = inode->i_ctime = current_time(inode);
	}
	spin_unlock(&info->lock);
out_fput:
	fdput(f);
out:
	if (sock)
		netlink_detachskb(sock, nc);
	else if (nc)
		dev_kfree_skb(nc);

	return ret;
}
",C,"			if (ret == 1) {
				sock = NULL;
			}
","			if (ret == 1)
",,"@@ -1270,8 +1270,10 @@ static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)
 
 			timeo = MAX_SCHEDULE_TIMEOUT;
 			ret = netlink_attachskb(sock, nc, &timeo, NULL);
-			if (ret == 1)
+			if (ret == 1) {
+				sock = NULL;
 				goto retry;
+			}
 			if (ret) {
 				sock = NULL;
 				nc = NULL;",linux,f991af3daabaecff34684fd51fac80319d1baad1,2b976203417cf033079e0be30cae5f41d88e385e,1,"static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)
{
	int ret;
	struct fd f;
	struct sock *sock;
	struct inode *inode;
	struct mqueue_inode_info *info;
	struct sk_buff *nc;

	audit_mq_notify(mqdes, notification);

	nc = NULL;
	sock = NULL;
	if (notification != NULL) {
		if (unlikely(notification->sigev_notify != SIGEV_NONE &&
			     notification->sigev_notify != SIGEV_SIGNAL &&
			     notification->sigev_notify != SIGEV_THREAD))
			return -EINVAL;
		if (notification->sigev_notify == SIGEV_SIGNAL &&
			!valid_signal(notification->sigev_signo)) {
			return -EINVAL;
		}
		if (notification->sigev_notify == SIGEV_THREAD) {
			long timeo;

			/* create the notify skb */
			nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);
			if (!nc) {
				ret = -ENOMEM;
				goto out;
			}
			if (copy_from_user(nc->data,
					notification->sigev_value.sival_ptr,
					NOTIFY_COOKIE_LEN)) {
				ret = -EFAULT;
				goto out;
			}

			/* TODO: add a header? */
			skb_put(nc, NOTIFY_COOKIE_LEN);
			/* and attach it to the socket */
retry:
			f = fdget(notification->sigev_signo);
			if (!f.file) {
				ret = -EBADF;
				goto out;
			}
			sock = netlink_getsockbyfilp(f.file);
			fdput(f);
			if (IS_ERR(sock)) {
				ret = PTR_ERR(sock);
				sock = NULL;
				goto out;
			}
 
 			timeo = MAX_SCHEDULE_TIMEOUT;
 			ret = netlink_attachskb(sock, nc, &timeo, NULL);
//flaw_line_below:
			if (ret == 1)
//fix_flaw_line_below:
//			if (ret == 1) {
//fix_flaw_line_below:
//				sock = NULL;
 				goto retry;
//fix_flaw_line_below:
//			}
 			if (ret) {
 				sock = NULL;
 				nc = NULL;
				goto out;
			}
		}
	}

	f = fdget(mqdes);
	if (!f.file) {
		ret = -EBADF;
		goto out;
	}

	inode = file_inode(f.file);
	if (unlikely(f.file->f_op != &mqueue_file_operations)) {
		ret = -EBADF;
		goto out_fput;
	}
	info = MQUEUE_I(inode);

	ret = 0;
	spin_lock(&info->lock);
	if (notification == NULL) {
		if (info->notify_owner == task_tgid(current)) {
			remove_notification(info);
			inode->i_atime = inode->i_ctime = current_time(inode);
		}
	} else if (info->notify_owner != NULL) {
		ret = -EBUSY;
	} else {
		switch (notification->sigev_notify) {
		case SIGEV_NONE:
			info->notify.sigev_notify = SIGEV_NONE;
			break;
		case SIGEV_THREAD:
			info->notify_sock = sock;
			info->notify_cookie = nc;
			sock = NULL;
			nc = NULL;
			info->notify.sigev_notify = SIGEV_THREAD;
			break;
		case SIGEV_SIGNAL:
			info->notify.sigev_signo = notification->sigev_signo;
			info->notify.sigev_value = notification->sigev_value;
			info->notify.sigev_notify = SIGEV_SIGNAL;
			break;
		}

		info->notify_owner = get_pid(task_tgid(current));
		info->notify_user_ns = get_user_ns(current_user_ns());
		inode->i_atime = inode->i_ctime = current_time(inode);
	}
	spin_unlock(&info->lock);
out_fput:
	fdput(f);
out:
	if (sock)
		netlink_detachskb(sock, nc);
	else if (nc)
		dev_kfree_skb(nc);

	return ret;
}
",181219,"static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)
{
	int ret;
	struct fd f;
	struct sock *sock;
	struct inode *inode;
	struct mqueue_inode_info *info;
	struct sk_buff *nc;

	audit_mq_notify(mqdes, notification);

	nc = NULL;
	sock = NULL;
	if (notification != NULL) {
		if (unlikely(notification->sigev_notify != SIGEV_NONE &&
			     notification->sigev_notify != SIGEV_SIGNAL &&
			     notification->sigev_notify != SIGEV_THREAD))
			return -EINVAL;
		if (notification->sigev_notify == SIGEV_SIGNAL &&
			!valid_signal(notification->sigev_signo)) {
			return -EINVAL;
		}
		if (notification->sigev_notify == SIGEV_THREAD) {
			long timeo;

			/* create the notify skb */
			nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);
			if (!nc) {
				ret = -ENOMEM;
				goto out;
			}
			if (copy_from_user(nc->data,
					notification->sigev_value.sival_ptr,
					NOTIFY_COOKIE_LEN)) {
				ret = -EFAULT;
				goto out;
			}

			/* TODO: add a header? */
			skb_put(nc, NOTIFY_COOKIE_LEN);
			/* and attach it to the socket */
retry:
			f = fdget(notification->sigev_signo);
			if (!f.file) {
				ret = -EBADF;
				goto out;
			}
			sock = netlink_getsockbyfilp(f.file);
			fdput(f);
			if (IS_ERR(sock)) {
				ret = PTR_ERR(sock);
				sock = NULL;
				goto out;
			}
 
 			timeo = MAX_SCHEDULE_TIMEOUT;
 			ret = netlink_attachskb(sock, nc, &timeo, NULL);
			if (ret == 1)
 				goto retry;
 			if (ret) {
 				sock = NULL;
 				nc = NULL;
				goto out;
			}
		}
	}

	f = fdget(mqdes);
	if (!f.file) {
		ret = -EBADF;
		goto out;
	}

	inode = file_inode(f.file);
	if (unlikely(f.file->f_op != &mqueue_file_operations)) {
		ret = -EBADF;
		goto out_fput;
	}
	info = MQUEUE_I(inode);

	ret = 0;
	spin_lock(&info->lock);
	if (notification == NULL) {
		if (info->notify_owner == task_tgid(current)) {
			remove_notification(info);
			inode->i_atime = inode->i_ctime = current_time(inode);
		}
	} else if (info->notify_owner != NULL) {
		ret = -EBUSY;
	} else {
		switch (notification->sigev_notify) {
		case SIGEV_NONE:
			info->notify.sigev_notify = SIGEV_NONE;
			break;
		case SIGEV_THREAD:
			info->notify_sock = sock;
			info->notify_cookie = nc;
			sock = NULL;
			nc = NULL;
			info->notify.sigev_notify = SIGEV_THREAD;
			break;
		case SIGEV_SIGNAL:
			info->notify.sigev_signo = notification->sigev_signo;
			info->notify.sigev_value = notification->sigev_value;
			info->notify.sigev_notify = SIGEV_SIGNAL;
			break;
		}

		info->notify_owner = get_pid(task_tgid(current));
		info->notify_user_ns = get_user_ns(current_user_ns());
		inode->i_atime = inode->i_ctime = current_time(inode);
	}
	spin_unlock(&info->lock);
out_fput:
	fdput(f);
out:
	if (sock)
		netlink_detachskb(sock, nc);
	else if (nc)
		dev_kfree_skb(nc);

	return ret;
}
","static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)
{
	int ret;
	struct fd f;
	struct sock *sock;
	struct inode *inode;
	struct mqueue_inode_info *info;
	struct sk_buff *nc;

	audit_mq_notify(mqdes, notification);

	nc = NULL;
	sock = NULL;
	if (notification != NULL) {
		if (unlikely(notification->sigev_notify != SIGEV_NONE &&
			     notification->sigev_notify != SIGEV_SIGNAL &&
			     notification->sigev_notify != SIGEV_THREAD))
			return -EINVAL;
		if (notification->sigev_notify == SIGEV_SIGNAL &&
			!valid_signal(notification->sigev_signo)) {
			return -EINVAL;
		}
		if (notification->sigev_notify == SIGEV_THREAD) {
			long timeo;

			/* create the notify skb */
			nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);
			if (!nc) {
				ret = -ENOMEM;
				goto out;
			}
			if (copy_from_user(nc->data,
					notification->sigev_value.sival_ptr,
					NOTIFY_COOKIE_LEN)) {
				ret = -EFAULT;
				goto out;
			}

			/* TODO: add a header? */
			skb_put(nc, NOTIFY_COOKIE_LEN);
			/* and attach it to the socket */
retry:
			f = fdget(notification->sigev_signo);
			if (!f.file) {
				ret = -EBADF;
				goto out;
			}
			sock = netlink_getsockbyfilp(f.file);
			fdput(f);
			if (IS_ERR(sock)) {
				ret = PTR_ERR(sock);
				sock = NULL;
				goto out;
			}
 
 			timeo = MAX_SCHEDULE_TIMEOUT;
 			ret = netlink_attachskb(sock, nc, &timeo, NULL);
			if (ret == 1) {
				sock = NULL;
 				goto retry;
			}
 			if (ret) {
 				sock = NULL;
 				nc = NULL;
				goto out;
			}
		}
	}

	f = fdget(mqdes);
	if (!f.file) {
		ret = -EBADF;
		goto out;
	}

	inode = file_inode(f.file);
	if (unlikely(f.file->f_op != &mqueue_file_operations)) {
		ret = -EBADF;
		goto out_fput;
	}
	info = MQUEUE_I(inode);

	ret = 0;
	spin_lock(&info->lock);
	if (notification == NULL) {
		if (info->notify_owner == task_tgid(current)) {
			remove_notification(info);
			inode->i_atime = inode->i_ctime = current_time(inode);
		}
	} else if (info->notify_owner != NULL) {
		ret = -EBUSY;
	} else {
		switch (notification->sigev_notify) {
		case SIGEV_NONE:
			info->notify.sigev_notify = SIGEV_NONE;
			break;
		case SIGEV_THREAD:
			info->notify_sock = sock;
			info->notify_cookie = nc;
			sock = NULL;
			nc = NULL;
			info->notify.sigev_notify = SIGEV_THREAD;
			break;
		case SIGEV_SIGNAL:
			info->notify.sigev_signo = notification->sigev_signo;
			info->notify.sigev_value = notification->sigev_value;
			info->notify.sigev_notify = SIGEV_SIGNAL;
			break;
		}

		info->notify_owner = get_pid(task_tgid(current));
		info->notify_user_ns = get_user_ns(current_user_ns());
		inode->i_atime = inode->i_ctime = current_time(inode);
	}
	spin_unlock(&info->lock);
out_fput:
	fdput(f);
out:
	if (sock)
		netlink_detachskb(sock, nc);
	else if (nc)
		dev_kfree_skb(nc);

	return ret;
}
","The `do_mq_notify` function manages notifications for message queues in a Linux kernel environment. It accepts a message queue descriptor and a notification structure, validating the notification type (signal or thread) and associated parameters. If a thread notification is requested, it allocates a socket buffer and attaches it to a socket identified by a signal number. The function also handles the removal of existing notifications and updates the inode's access and modification times. It employs locking mechanisms to ensure thread safety while modifying notification states and returns appropriate error codes for various failure scenarios, ensuring robust error handling throughout.","The code implements a function that manages notifications for message queues in a kernel environment. It validates the type of notification requested, ensuring it is either a signal or a thread notification. For thread notifications, it allocates a buffer and associates it with a socket identified by a signal number. The function also allows for the removal of existing notifications and updates the metadata of the message queue. It employs synchronization mechanisms to ensure safe access to shared resources while handling various error conditions, returning appropriate error codes when necessary to indicate the status of the operation.","The vulnerability in the original code stemmed from a use-after-free condition caused by the retry logic for attaching a socket buffer. When a retry was needed after calling `netlink_attachskb`, the reference count for the socket was already released, allowing user-space to close the file descriptor in the interim. This could lead to a situation where `netlink_detachskb` was called on a socket that had already been freed, resulting in potential memory corruption. The fix involved setting the `sock` variable to NULL after a retry, ensuring that the code would not attempt to detach a socket that could have been freed, thus preventing the use-after-free vulnerability.","The vulnerability in the original code arose from a use-after-free issue related to the retry mechanism for attaching a socket buffer. When a retry was necessary, the reference count for the socket was already decremented, allowing user-space to close the file descriptor in the interim. This created a risk where the code could attempt to detach a socket that had already been freed, leading to potential memory corruption. The fix involved ensuring that the socket reference was set to NULL after a retry, preventing any further operations on a potentially freed socket and thus eliminating the use-after-free vulnerability.","The vulnerability was fixed by modifying the handling of the `sock` variable during the retry logic for `netlink_attachskb`. In the original code, if a retry was needed, the reference count for the socket was already released, which could lead to a use-after-free condition. The fix involved setting the `sock` variable to NULL after a failed attempt to attach the socket buffer. This change ensures that subsequent calls to `netlink_detachskb` do not operate on a potentially freed socket, thereby preventing any memory corruption issues associated with accessing invalid memory.","The vulnerability was addressed by ensuring that the reference to the socket was properly managed during the retry process. Specifically, after a failed attempt to attach the socket buffer, the code was modified to set the socket reference to NULL. This change prevents any further operations on a socket that may have already been freed, thereby eliminating the risk of accessing invalid memory. By implementing this safeguard, the code ensures that subsequent actions do not inadvertently lead to memory corruption or use-after-free conditions, enhancing the overall stability and security of the system.","CWE-416, CWE-825, CWE-672, CWE-415, CWE-119, CWE-476, CWE-908, CWE-824, CWE-404, CWE-665",Y,1
26,26,181266,181266,,Remote,Not required,Partial,CVE-2017-9527,https://www.cvedetails.com/cve/CVE-2017-9527/,CWE-416,Medium,Partial,Partial,,2017-06-11,6.8,The mark_context_stack function in gc.c in mruby through 1.2.0 allows attackers to cause a denial of service (heap-based use-after-free and application crash) or possibly have unspecified other impact via a crafted .rb file.,2017-06-22,DoS ,7,https://github.com/mruby/mruby/commit/5c114c91d4ff31859fcd84cf8bf349b737b90d99,5c114c91d4ff31859fcd84cf8bf349b737b90d99,Clear unused stack region that may refer freed objects; fix #3596,6,src/gc.c,"{""sha"": ""19bc1ad4b2bb5103803a6a813567031cab2cdc78"", ""filename"": ""src/gc.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 6, ""changes"": 13, ""blob_url"": ""https://github.com/mruby/mruby/blob/5c114c91d4ff31859fcd84cf8bf349b737b90d99/src/gc.c"", ""raw_url"": ""https://github.com/mruby/mruby/raw/5c114c91d4ff31859fcd84cf8bf349b737b90d99/src/gc.c"", ""contents_url"": ""https://api.github.com/repos/mruby/mruby/contents/src/gc.c?ref=5c114c91d4ff31859fcd84cf8bf349b737b90d99"", ""patch"": ""@@ -544,6 +544,7 @@ mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n {\n   size_t i;\n   size_t e;\n+  mrb_value nil;\n \n   if (c->stack == NULL) return;\n   e = c->stack - c->stbase;\n@@ -553,14 +554,14 @@ mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n     mrb_value v = c->stbase[i];\n \n     if (!mrb_immediate_p(v)) {\n-      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n-        c->stbase[i] = mrb_nil_value();\n-      }\n-      else {\n-        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n-      }\n+      mrb_gc_mark(mrb, mrb_basic_ptr(v));\n     }\n   }\n+  e = c->stend - c->stbase;\n+  nil = mrb_nil_value();\n+  for (; i<e; i++) {\n+    c->stbase[i] = nil;\n+  }\n }\n \n static void""}","mark_context_stack(mrb_state *mrb, struct mrb_context *c)
 {
   size_t i;
   size_t e;
  mrb_value nil;
 
   if (c->stack == NULL) return;
   e = c->stack - c->stbase;
  if (c->ci) e += c->ci->nregs;
  if (c->stbase + e > c->stend) e = c->stend - c->stbase;
  for (i=0; i<e; i++) {
     mrb_value v = c->stbase[i];
 
     if (!mrb_immediate_p(v)) {
      mrb_gc_mark(mrb, mrb_basic_ptr(v));
     }
   }
  e = c->stend - c->stbase;
  nil = mrb_nil_value();
  for (; i<e; i++) {
    c->stbase[i] = nil;
  }
 }
","mark_context_stack(mrb_state *mrb, struct mrb_context *c)
 {
   size_t i;
   size_t e;
 
   if (c->stack == NULL) return;
   e = c->stack - c->stbase;
  if (c->ci) e += c->ci->nregs;
  if (c->stbase + e > c->stend) e = c->stend - c->stbase;
  for (i=0; i<e; i++) {
     mrb_value v = c->stbase[i];
 
     if (!mrb_immediate_p(v)) {
      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {
        c->stbase[i] = mrb_nil_value();
      }
      else {
        mrb_gc_mark(mrb, mrb_basic_ptr(v));
      }
     }
   }
 }
",C,"  mrb_value nil;
      mrb_gc_mark(mrb, mrb_basic_ptr(v));
  e = c->stend - c->stbase;
  nil = mrb_nil_value();
  for (; i<e; i++) {
    c->stbase[i] = nil;
  }
","      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {
        c->stbase[i] = mrb_nil_value();
      }
      else {
        mrb_gc_mark(mrb, mrb_basic_ptr(v));
      }
",,"@@ -544,6 +544,7 @@ mark_context_stack(mrb_state *mrb, struct mrb_context *c)
 {
   size_t i;
   size_t e;
+  mrb_value nil;
 
   if (c->stack == NULL) return;
   e = c->stack - c->stbase;
@@ -553,14 +554,14 @@ mark_context_stack(mrb_state *mrb, struct mrb_context *c)
     mrb_value v = c->stbase[i];
 
     if (!mrb_immediate_p(v)) {
-      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {
-        c->stbase[i] = mrb_nil_value();
-      }
-      else {
-        mrb_gc_mark(mrb, mrb_basic_ptr(v));
-      }
+      mrb_gc_mark(mrb, mrb_basic_ptr(v));
     }
   }
+  e = c->stend - c->stbase;
+  nil = mrb_nil_value();
+  for (; i<e; i++) {
+    c->stbase[i] = nil;
+  }
 }
 
 static void",mruby,5c114c91d4ff31859fcd84cf8bf349b737b90d99,491d68bb3004eb8d7deec4a3a682b25de0d4afc2,1,"mark_context_stack(mrb_state *mrb, struct mrb_context *c)
 {
   size_t i;
   size_t e;
//fix_flaw_line_below:
//  mrb_value nil;
 
   if (c->stack == NULL) return;
   e = c->stack - c->stbase;
  if (c->ci) e += c->ci->nregs;
  if (c->stbase + e > c->stend) e = c->stend - c->stbase;
  for (i=0; i<e; i++) {
     mrb_value v = c->stbase[i];
 
     if (!mrb_immediate_p(v)) {
//flaw_line_below:
      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {
//flaw_line_below:
        c->stbase[i] = mrb_nil_value();
//flaw_line_below:
      }
//flaw_line_below:
      else {
//flaw_line_below:
        mrb_gc_mark(mrb, mrb_basic_ptr(v));
//flaw_line_below:
      }
//fix_flaw_line_below:
//      mrb_gc_mark(mrb, mrb_basic_ptr(v));
     }
   }
//fix_flaw_line_below:
//  e = c->stend - c->stbase;
//fix_flaw_line_below:
//  nil = mrb_nil_value();
//fix_flaw_line_below:
//  for (; i<e; i++) {
//fix_flaw_line_below:
//    c->stbase[i] = nil;
//fix_flaw_line_below:
//  }
 }
",181266,"mark_context_stack(mrb_state *mrb, struct mrb_context *c)
 {
   size_t i;
   size_t e;
 
   if (c->stack == NULL) return;
   e = c->stack - c->stbase;
  if (c->ci) e += c->ci->nregs;
  if (c->stbase + e > c->stend) e = c->stend - c->stbase;
  for (i=0; i<e; i++) {
     mrb_value v = c->stbase[i];
 
     if (!mrb_immediate_p(v)) {
      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {
        c->stbase[i] = mrb_nil_value();
      }
      else {
        mrb_gc_mark(mrb, mrb_basic_ptr(v));
      }
     }
   }
 }
","mark_context_stack(mrb_state *mrb, struct mrb_context *c)
 {
   size_t i;
   size_t e;
  mrb_value nil;
 
   if (c->stack == NULL) return;
   e = c->stack - c->stbase;
  if (c->ci) e += c->ci->nregs;
  if (c->stbase + e > c->stend) e = c->stend - c->stbase;
  for (i=0; i<e; i++) {
     mrb_value v = c->stbase[i];
 
     if (!mrb_immediate_p(v)) {
      mrb_gc_mark(mrb, mrb_basic_ptr(v));
     }
   }
  e = c->stend - c->stbase;
  nil = mrb_nil_value();
  for (; i<e; i++) {
    c->stbase[i] = nil;
  }
 }
","The `mark_context_stack` function is designed to manage garbage collection in a Ruby-like environment by marking objects in the context stack for preservation. It first checks if the context stack is initialized; if not, it exits early. The function calculates the effective stack size, considering the current instruction context and the limits of the stack. It then iterates through the stack, marking each object that is not immediate. If an object is found to be free, it replaces it with a nil value; otherwise, it invokes the garbage collector to mark the object, ensuring that it is not collected during the garbage collection cycle.","The provided code is responsible for managing memory during garbage collection by marking objects in a specific context stack. It begins by checking if the stack is initialized, and if not, it terminates early. The code calculates the number of elements to process, taking into account the current execution context and stack boundaries. It then iterates through the elements, identifying those that are not immediate values. If an element is marked as free, it replaces it with a null value; otherwise, it marks the object for preservation, preventing it from being collected during the garbage collection process.","The vulnerability in the original code arises from the potential for uninitialized or freed objects to remain in the stack, which could lead to undefined behavior or memory corruption during garbage collection. Specifically, the code did not handle the scenario where elements beyond the current stack size could still reference freed objects. The fix introduced a second loop that iterates through the remaining stack elements after marking, explicitly setting them to a nil value. This ensures that any unused stack regions are cleared, preventing references to freed objects and enhancing the overall safety and stability of the garbage collection process.","The vulnerability in the original code stems from the failure to clear unused regions of the stack, which could still reference freed objects, leading to potential memory corruption or undefined behavior during garbage collection. This oversight allowed for the possibility of accessing invalid memory locations. The fix addressed this issue by adding a second loop that iterates through the remaining stack elements after the marking process, explicitly setting them to a null value. This ensures that any unused stack areas are properly cleared, thereby eliminating references to freed objects and enhancing the safety and reliability of the memory management process.","The vulnerability was fixed by introducing a second loop that iterates through the stack elements after the initial marking process. In this loop, the code calculates the total number of elements in the stack and assigns a nil value to any remaining elements beyond the marked range. Specifically, after marking the valid objects with `mrb_gc_mark`, the code sets `c->stbase[i]` to `nil` for all indices from the current position to the end of the stack. This effectively clears any unused stack regions, preventing references to freed objects and ensuring safer memory management during garbage collection.","The vulnerability was addressed by adding a second loop that processes the remaining elements in the stack after the initial marking of valid objects. This loop ensures that any unused portions of the stack are explicitly set to a null value, effectively clearing out references to potentially freed objects. By doing so, the code prevents any access to invalid memory locations that could lead to undefined behavior or memory corruption. This enhancement improves the overall safety and reliability of the memory management process during garbage collection, ensuring that only valid references are retained.","CWE-416, CWE-476, CWE-404, CWE-401, CWE-763, CWE-415, CWE-762, CWE-825, CWE-672, CWE-911",Y,1
27,27,181267,181267,,Remote,Not required,Partial,CVE-2017-9520,https://www.cvedetails.com/cve/CVE-2017-9520/,CWE-416,Medium,,,,2017-06-08,4.3,The r_config_set function in libr/config/config.c in radare2 1.5.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted DEX file.,2017-06-27,DoS ,2,https://github.com/radare/radare2/commit/f85bc674b2a2256a364fe796351bc1971e106005,f85bc674b2a2256a364fe796351bc1971e106005,Fix #7698 - UAF in r_config_set when loading a dex,1,libr/config/config.c,"{""sha"": ""c2b3662b294230c45c3acbf85628eeb85d996953"", ""filename"": ""libr/config/config.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/radareorg/radare2/blob/f85bc674b2a2256a364fe796351bc1971e106005/libr/config/config.c"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/f85bc674b2a2256a364fe796351bc1971e106005/libr/config/config.c"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/libr/config/config.c?ref=f85bc674b2a2256a364fe796351bc1971e106005"", ""patch"": ""@@ -388,8 +388,9 @@ R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *valu\n \t\t\t\tif (node->value == value) {\n \t\t\t\t\tgoto beach;\n \t\t\t\t}\n-\t\t\t\tfree (node->value);\n+\t\t\t\tchar *tmp = node->value;\n \t\t\t\tnode->value = strdup (value);\n+\t\t\t\tfree (tmp);\n \t\t\t\tif (IS_DIGIT (*value)) {\n \t\t\t\t\tif (strchr (value, '/')) {\n \t\t\t\t\t\tnode->i_value = r_num_get (cfg->num, value);""}<_**next**_>{""sha"": ""add791c1c7a28159e92b6ba244d1c7628c1e7bb9"", ""filename"": ""libr/core/cbin.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 3, ""changes"": 9, ""blob_url"": ""https://github.com/radareorg/radare2/blob/f85bc674b2a2256a364fe796351bc1971e106005/libr/core/cbin.c"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/f85bc674b2a2256a364fe796351bc1971e106005/libr/core/cbin.c"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/libr/core/cbin.c?ref=f85bc674b2a2256a364fe796351bc1971e106005"", ""patch"": ""@@ -96,7 +96,8 @@ R_API int r_core_bin_set_env(RCore *r, RBinFile *binfile) {\n \tRBinInfo *info = binobj ? binobj->info: NULL;\n \tif (info) {\n \t\tint va = info->has_va;\n-\t\tconst char * arch = info->arch;\n+\t\tchar * arch = strdup(info->arch);\n+\t\tchar * cpu = info->cpu? strdup(info->cpu): NULL;\n \t\tut16 bits = info->bits;\n \t\tut64 baseaddr = r_bin_get_baddr (r->bin);\n \t\t/* Hack to make baddr work on some corner */\n@@ -106,14 +107,16 @@ R_API int r_core_bin_set_env(RCore *r, RBinFile *binfile) {\n \t\tr_config_set (r->config, \""asm.arch\"", arch);\n \t\tr_config_set_i (r->config, \""asm.bits\"", bits);\n \t\tr_config_set (r->config, \""anal.arch\"", arch);\n-\t\tif (info->cpu && *info->cpu) {\n-\t\t\tr_config_set (r->config, \""anal.cpu\"", info->cpu);\n+\t\tif (cpu && *cpu) {\n+\t\t\tr_config_set (r->config, \""anal.cpu\"", cpu);\n \t\t} else {\n \t\t\tr_config_set (r->config, \""anal.cpu\"", arch);\n \t\t}\n \t\tr_asm_use (r->assembler, arch);\n \t\tr_core_bin_info (r, R_CORE_BIN_ACC_ALL, R_CORE_BIN_SET, va, NULL, NULL);\n \t\tr_core_bin_set_cur (r, binfile);\n+\t\tfree (cpu);\n+\t\tfree (arch);\n \t\treturn true;\n \t}\n \treturn false;""}","R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) {
	RConfigNode *node = NULL;
	char *ov = NULL;
	ut64 oi;
	if (!cfg || STRNULL (name)) {
		return NULL;
	}
	node = r_config_node_get (cfg, name);
	if (node) {
		if (node->flags & CN_RO) {
			eprintf (""(error: '%s' config key is read only)\n"", name);
			return node;
		}
		oi = node->i_value;
		if (node->value) {
			ov = strdup (node->value);
			if (!ov) {
				goto beach;
			}
		} else {
			free (node->value);
			node->value = strdup ("""");
		}
		if (node->flags & CN_BOOL) {
			bool b = is_true (value);
			node->i_value = (ut64) b? 1: 0;
			char *value = strdup (r_str_bool (b));
			if (value) {
				free (node->value);
				node->value = value;
			}
		} else {
			if (!value) {
				free (node->value);
				node->value = strdup ("""");
				node->i_value = 0;
			} else {
 				if (node->value == value) {
 					goto beach;
 				}
				char *tmp = node->value;
 				node->value = strdup (value);
				free (tmp);
 				if (IS_DIGIT (*value)) {
 					if (strchr (value, '/')) {
 						node->i_value = r_num_get (cfg->num, value);
					} else {
						node->i_value = r_num_math (cfg->num, value);
					}
				} else {
					node->i_value = 0;
				}
				node->flags |= CN_INT;
			}
		}
	} else { // Create a new RConfigNode
		oi = UT64_MAX;
		if (!cfg->lock) {
			node = r_config_node_new (name, value);
			if (node) {
				if (value && is_bool (value)) {
					node->flags |= CN_BOOL;
					node->i_value = is_true (value)? 1: 0;
				}
				if (cfg->ht) {
					ht_insert (cfg->ht, node->name, node);
					r_list_append (cfg->nodes, node);
					cfg->n_nodes++;
				}
			} else {
				eprintf (""r_config_set: unable to create a new RConfigNode\n"");
			}
		} else {
			eprintf (""r_config_set: variable '%s' not found\n"", name);
		}
	}

	if (node && node->setter) {
		int ret = node->setter (cfg->user, node);
		if (ret == false) {
			if (oi != UT64_MAX) {
				node->i_value = oi;
			}
			free (node->value);
			node->value = strdup (ov? ov: """");
		}
	}
beach:
	free (ov);
	return node;
}
","R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) {
	RConfigNode *node = NULL;
	char *ov = NULL;
	ut64 oi;
	if (!cfg || STRNULL (name)) {
		return NULL;
	}
	node = r_config_node_get (cfg, name);
	if (node) {
		if (node->flags & CN_RO) {
			eprintf (""(error: '%s' config key is read only)\n"", name);
			return node;
		}
		oi = node->i_value;
		if (node->value) {
			ov = strdup (node->value);
			if (!ov) {
				goto beach;
			}
		} else {
			free (node->value);
			node->value = strdup ("""");
		}
		if (node->flags & CN_BOOL) {
			bool b = is_true (value);
			node->i_value = (ut64) b? 1: 0;
			char *value = strdup (r_str_bool (b));
			if (value) {
				free (node->value);
				node->value = value;
			}
		} else {
			if (!value) {
				free (node->value);
				node->value = strdup ("""");
				node->i_value = 0;
			} else {
 				if (node->value == value) {
 					goto beach;
 				}
				free (node->value);
 				node->value = strdup (value);
 				if (IS_DIGIT (*value)) {
 					if (strchr (value, '/')) {
 						node->i_value = r_num_get (cfg->num, value);
					} else {
						node->i_value = r_num_math (cfg->num, value);
					}
				} else {
					node->i_value = 0;
				}
				node->flags |= CN_INT;
			}
		}
	} else { // Create a new RConfigNode
		oi = UT64_MAX;
		if (!cfg->lock) {
			node = r_config_node_new (name, value);
			if (node) {
				if (value && is_bool (value)) {
					node->flags |= CN_BOOL;
					node->i_value = is_true (value)? 1: 0;
				}
				if (cfg->ht) {
					ht_insert (cfg->ht, node->name, node);
					r_list_append (cfg->nodes, node);
					cfg->n_nodes++;
				}
			} else {
				eprintf (""r_config_set: unable to create a new RConfigNode\n"");
			}
		} else {
			eprintf (""r_config_set: variable '%s' not found\n"", name);
		}
	}

	if (node && node->setter) {
		int ret = node->setter (cfg->user, node);
		if (ret == false) {
			if (oi != UT64_MAX) {
				node->i_value = oi;
			}
			free (node->value);
			node->value = strdup (ov? ov: """");
		}
	}
beach:
	free (ov);
	return node;
}
",C,"				char *tmp = node->value;
				free (tmp);
","				free (node->value);
",,"@@ -388,8 +388,9 @@ R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *valu
 				if (node->value == value) {
 					goto beach;
 				}
-				free (node->value);
+				char *tmp = node->value;
 				node->value = strdup (value);
+				free (tmp);
 				if (IS_DIGIT (*value)) {
 					if (strchr (value, '/')) {
 						node->i_value = r_num_get (cfg->num, value);",radare2,f85bc674b2a2256a364fe796351bc1971e106005,bcdbfcaf8a5cc028edc10f38fab72b2ae8a5f101,1,"R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) {
	RConfigNode *node = NULL;
	char *ov = NULL;
	ut64 oi;
	if (!cfg || STRNULL (name)) {
		return NULL;
	}
	node = r_config_node_get (cfg, name);
	if (node) {
		if (node->flags & CN_RO) {
			eprintf (""(error: '%s' config key is read only)\n"", name);
			return node;
		}
		oi = node->i_value;
		if (node->value) {
			ov = strdup (node->value);
			if (!ov) {
				goto beach;
			}
		} else {
			free (node->value);
			node->value = strdup ("""");
		}
		if (node->flags & CN_BOOL) {
			bool b = is_true (value);
			node->i_value = (ut64) b? 1: 0;
			char *value = strdup (r_str_bool (b));
			if (value) {
				free (node->value);
				node->value = value;
			}
		} else {
			if (!value) {
				free (node->value);
				node->value = strdup ("""");
				node->i_value = 0;
			} else {
 				if (node->value == value) {
 					goto beach;
 				}
//flaw_line_below:
				free (node->value);
//fix_flaw_line_below:
//				char *tmp = node->value;
 				node->value = strdup (value);
//fix_flaw_line_below:
//				free (tmp);
 				if (IS_DIGIT (*value)) {
 					if (strchr (value, '/')) {
 						node->i_value = r_num_get (cfg->num, value);
					} else {
						node->i_value = r_num_math (cfg->num, value);
					}
				} else {
					node->i_value = 0;
				}
				node->flags |= CN_INT;
			}
		}
	} else { // Create a new RConfigNode
		oi = UT64_MAX;
		if (!cfg->lock) {
			node = r_config_node_new (name, value);
			if (node) {
				if (value && is_bool (value)) {
					node->flags |= CN_BOOL;
					node->i_value = is_true (value)? 1: 0;
				}
				if (cfg->ht) {
					ht_insert (cfg->ht, node->name, node);
					r_list_append (cfg->nodes, node);
					cfg->n_nodes++;
				}
			} else {
				eprintf (""r_config_set: unable to create a new RConfigNode\n"");
			}
		} else {
			eprintf (""r_config_set: variable '%s' not found\n"", name);
		}
	}

	if (node && node->setter) {
		int ret = node->setter (cfg->user, node);
		if (ret == false) {
			if (oi != UT64_MAX) {
				node->i_value = oi;
			}
			free (node->value);
			node->value = strdup (ov? ov: """");
		}
	}
beach:
	free (ov);
	return node;
}
",181267,"R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) {
	RConfigNode *node = NULL;
	char *ov = NULL;
	ut64 oi;
	if (!cfg || STRNULL (name)) {
		return NULL;
	}
	node = r_config_node_get (cfg, name);
	if (node) {
		if (node->flags & CN_RO) {
			eprintf (""(error: '%s' config key is read only)\n"", name);
			return node;
		}
		oi = node->i_value;
		if (node->value) {
			ov = strdup (node->value);
			if (!ov) {
				goto beach;
			}
		} else {
			free (node->value);
			node->value = strdup ("""");
		}
		if (node->flags & CN_BOOL) {
			bool b = is_true (value);
			node->i_value = (ut64) b? 1: 0;
			char *value = strdup (r_str_bool (b));
			if (value) {
				free (node->value);
				node->value = value;
			}
		} else {
			if (!value) {
				free (node->value);
				node->value = strdup ("""");
				node->i_value = 0;
			} else {
 				if (node->value == value) {
 					goto beach;
 				}
				free (node->value);
 				node->value = strdup (value);
 				if (IS_DIGIT (*value)) {
 					if (strchr (value, '/')) {
 						node->i_value = r_num_get (cfg->num, value);
					} else {
						node->i_value = r_num_math (cfg->num, value);
					}
				} else {
					node->i_value = 0;
				}
				node->flags |= CN_INT;
			}
		}
	} else { // Create a new RConfigNode
		oi = UT64_MAX;
		if (!cfg->lock) {
			node = r_config_node_new (name, value);
			if (node) {
				if (value && is_bool (value)) {
					node->flags |= CN_BOOL;
					node->i_value = is_true (value)? 1: 0;
				}
				if (cfg->ht) {
					ht_insert (cfg->ht, node->name, node);
					r_list_append (cfg->nodes, node);
					cfg->n_nodes++;
				}
			} else {
				eprintf (""r_config_set: unable to create a new RConfigNode\n"");
			}
		} else {
			eprintf (""r_config_set: variable '%s' not found\n"", name);
		}
	}

	if (node && node->setter) {
		int ret = node->setter (cfg->user, node);
		if (ret == false) {
			if (oi != UT64_MAX) {
				node->i_value = oi;
			}
			free (node->value);
			node->value = strdup (ov? ov: """");
		}
	}
beach:
	free (ov);
	return node;
}
","R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) {
	RConfigNode *node = NULL;
	char *ov = NULL;
	ut64 oi;
	if (!cfg || STRNULL (name)) {
		return NULL;
	}
	node = r_config_node_get (cfg, name);
	if (node) {
		if (node->flags & CN_RO) {
			eprintf (""(error: '%s' config key is read only)\n"", name);
			return node;
		}
		oi = node->i_value;
		if (node->value) {
			ov = strdup (node->value);
			if (!ov) {
				goto beach;
			}
		} else {
			free (node->value);
			node->value = strdup ("""");
		}
		if (node->flags & CN_BOOL) {
			bool b = is_true (value);
			node->i_value = (ut64) b? 1: 0;
			char *value = strdup (r_str_bool (b));
			if (value) {
				free (node->value);
				node->value = value;
			}
		} else {
			if (!value) {
				free (node->value);
				node->value = strdup ("""");
				node->i_value = 0;
			} else {
 				if (node->value == value) {
 					goto beach;
 				}
				char *tmp = node->value;
 				node->value = strdup (value);
				free (tmp);
 				if (IS_DIGIT (*value)) {
 					if (strchr (value, '/')) {
 						node->i_value = r_num_get (cfg->num, value);
					} else {
						node->i_value = r_num_math (cfg->num, value);
					}
				} else {
					node->i_value = 0;
				}
				node->flags |= CN_INT;
			}
		}
	} else { // Create a new RConfigNode
		oi = UT64_MAX;
		if (!cfg->lock) {
			node = r_config_node_new (name, value);
			if (node) {
				if (value && is_bool (value)) {
					node->flags |= CN_BOOL;
					node->i_value = is_true (value)? 1: 0;
				}
				if (cfg->ht) {
					ht_insert (cfg->ht, node->name, node);
					r_list_append (cfg->nodes, node);
					cfg->n_nodes++;
				}
			} else {
				eprintf (""r_config_set: unable to create a new RConfigNode\n"");
			}
		} else {
			eprintf (""r_config_set: variable '%s' not found\n"", name);
		}
	}

	if (node && node->setter) {
		int ret = node->setter (cfg->user, node);
		if (ret == false) {
			if (oi != UT64_MAX) {
				node->i_value = oi;
			}
			free (node->value);
			node->value = strdup (ov? ov: """");
		}
	}
beach:
	free (ov);
	return node;
}
","The `r_config_set` function updates or creates a configuration node within a given configuration structure (`RConfig`). It first checks if the configuration and the name are valid, then retrieves the corresponding node. If the node exists and is not read-only, it updates its value based on the provided input, handling boolean and numeric types appropriately. If the node does not exist, it creates a new one and inserts it into the configuration. Additionally, if a setter function is defined for the node, it is called to apply any custom logic. The function returns the updated or newly created node, or NULL in case of errors.","The provided code defines a function that manages configuration settings by either updating an existing setting or creating a new one. It first verifies the validity of the configuration and the setting name, then retrieves the corresponding setting. If the setting is found and is not restricted, it updates its value based on the input, accommodating different data types such as boolean and numeric. If the setting does not exist, a new one is created and added to the configuration. Additionally, a callback function is invoked to handle any custom logic, and the function returns the modified or newly created setting.","The vulnerability in the original code was a use-after-free (UAF) issue, which occurred when the function attempted to free and then reassign the `node->value` without ensuring that the previous value was not still in use. Specifically, if the new value was the same as the existing one, the code would skip the reassignment, leading to potential access to freed memory. The fix involved introducing a temporary variable (`tmp`) to hold the original `node->value` before it was reassigned. This ensured that the original value was safely freed only after the new value was successfully assigned, preventing any UAF scenarios.","The vulnerability in the original code was a use-after-free (UAF) issue, which arose when the function freed a memory allocation and then attempted to access or modify that memory without proper checks. This could lead to undefined behavior, including crashes or data corruption, especially if the freed memory was accessed later in the execution. The fix involved introducing a temporary variable to hold the original memory before it was freed, ensuring that the original data was safely managed and only released after confirming that it was no longer needed. This change effectively mitigated the risk of accessing freed memory.","The vulnerability was fixed by introducing a temporary variable, `tmp`, to hold the original value of `node->value` before it was reassigned. In the updated code, when the new value is set using `strdup(value)`, the original `node->value` is first stored in `tmp`, allowing it to be safely freed afterward. This ensures that the memory is not accessed after being freed, thus preventing the use-after-free issue. By managing the memory in this way, the code maintains proper ownership and lifecycle of the allocated memory, effectively eliminating the risk of accessing invalid memory locations.","The vulnerability was fixed by implementing a strategy to safely manage memory during the reassignment of a value. A temporary variable was introduced to hold the original data before it was freed, ensuring that the original memory could be accessed until it was no longer needed. This approach allowed the code to free the old memory only after confirming that the new value had been successfully assigned, thereby preventing any access to freed memory. By carefully controlling the memory lifecycle, the fix effectively eliminated the risk of undefined behavior associated with the use-after-free issue.","CWE-416, CWE-825, CWE-415, CWE-763, CWE-401, CWE-119, CWE-476, CWE-665, CWE-404, CWE-761",Y,1
28,28,181444,181444,,Local,Not required,Complete,CVE-2017-7487,https://www.cvedetails.com/cve/CVE-2017-7487/,CWE-416,Low,Complete,Complete,,2017-05-14,7.2,"The ipxitf_ioctl function in net/ipx/af_ipx.c in the Linux kernel through 4.11.1 mishandles reference counts, which allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a failed SIOCGIFADDR ioctl call for an IPX interface.",2017-11-03,DoS ,2,https://github.com/torvalds/linux/commit/ee0d8d8482345ff97a75a7d747efc309f13b0d80,ee0d8d8482345ff97a75a7d747efc309f13b0d80,"ipx: call ipxitf_put() in ioctl error path

We should call ipxitf_put() if the copy_to_user() fails.

Reported-by: 李强 <liqiang6-s@360.cn>
Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",3,net/ipx/af_ipx.c,"{""sha"": ""fa31ef29e3fa0bf3973e12e43c57b48eb7d1be45"", ""filename"": ""net/ipx/af_ipx.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/ee0d8d8482345ff97a75a7d747efc309f13b0d80/net/ipx/af_ipx.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ee0d8d8482345ff97a75a7d747efc309f13b0d80/net/ipx/af_ipx.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipx/af_ipx.c?ref=ee0d8d8482345ff97a75a7d747efc309f13b0d80"", ""patch"": ""@@ -1168,11 +1168,10 @@ static int ipxitf_ioctl(unsigned int cmd, void __user *arg)\n \t\tsipx->sipx_network\t= ipxif->if_netnum;\n \t\tmemcpy(sipx->sipx_node, ipxif->if_node,\n \t\t\tsizeof(sipx->sipx_node));\n-\t\trc = -EFAULT;\n+\t\trc = 0;\n \t\tif (copy_to_user(arg, &ifr, sizeof(ifr)))\n-\t\t\tbreak;\n+\t\t\trc = -EFAULT;\n \t\tipxitf_put(ipxif);\n-\t\trc = 0;\n \t\tbreak;\n \t}\n \tcase SIOCAIPXITFCRT:""}","static int ipxitf_ioctl(unsigned int cmd, void __user *arg)
{
	int rc = -EINVAL;
	struct ifreq ifr;
	int val;

	switch (cmd) {
	case SIOCSIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface_definition f;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		rc = -EINVAL;
		if (sipx->sipx_family != AF_IPX)
			break;
		f.ipx_network = sipx->sipx_network;
		memcpy(f.ipx_device, ifr.ifr_name,
			sizeof(f.ipx_device));
		memcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);
		f.ipx_dlink_type = sipx->sipx_type;
		f.ipx_special = sipx->sipx_special;

		if (sipx->sipx_action == IPX_DLTITF)
			rc = ipxitf_delete(&f);
		else
			rc = ipxitf_create(&f);
		break;
	}
	case SIOCGIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface *ipxif;
		struct net_device *dev;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		dev  = __dev_get_by_name(&init_net, ifr.ifr_name);
		rc   = -ENODEV;
		if (!dev)
			break;
		ipxif = ipxitf_find_using_phys(dev,
					   ipx_map_frame_type(sipx->sipx_type));
		rc = -EADDRNOTAVAIL;
		if (!ipxif)
			break;

		sipx->sipx_family	= AF_IPX;
 		sipx->sipx_network	= ipxif->if_netnum;
 		memcpy(sipx->sipx_node, ipxif->if_node,
 			sizeof(sipx->sipx_node));
		rc = 0;
 		if (copy_to_user(arg, &ifr, sizeof(ifr)))
			rc = -EFAULT;
 		ipxitf_put(ipxif);
 		break;
 	}
 	case SIOCAIPXITFCRT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_auto_create_interfaces = val;
		break;
	case SIOCAIPXPRISLT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_set_auto_select(val);
		break;
	}

	return rc;
}
","static int ipxitf_ioctl(unsigned int cmd, void __user *arg)
{
	int rc = -EINVAL;
	struct ifreq ifr;
	int val;

	switch (cmd) {
	case SIOCSIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface_definition f;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		rc = -EINVAL;
		if (sipx->sipx_family != AF_IPX)
			break;
		f.ipx_network = sipx->sipx_network;
		memcpy(f.ipx_device, ifr.ifr_name,
			sizeof(f.ipx_device));
		memcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);
		f.ipx_dlink_type = sipx->sipx_type;
		f.ipx_special = sipx->sipx_special;

		if (sipx->sipx_action == IPX_DLTITF)
			rc = ipxitf_delete(&f);
		else
			rc = ipxitf_create(&f);
		break;
	}
	case SIOCGIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface *ipxif;
		struct net_device *dev;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		dev  = __dev_get_by_name(&init_net, ifr.ifr_name);
		rc   = -ENODEV;
		if (!dev)
			break;
		ipxif = ipxitf_find_using_phys(dev,
					   ipx_map_frame_type(sipx->sipx_type));
		rc = -EADDRNOTAVAIL;
		if (!ipxif)
			break;

		sipx->sipx_family	= AF_IPX;
 		sipx->sipx_network	= ipxif->if_netnum;
 		memcpy(sipx->sipx_node, ipxif->if_node,
 			sizeof(sipx->sipx_node));
		rc = -EFAULT;
 		if (copy_to_user(arg, &ifr, sizeof(ifr)))
			break;
 		ipxitf_put(ipxif);
		rc = 0;
 		break;
 	}
 	case SIOCAIPXITFCRT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_auto_create_interfaces = val;
		break;
	case SIOCAIPXPRISLT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_set_auto_select(val);
		break;
	}

	return rc;
}
",C,"		rc = 0;
			rc = -EFAULT;
","		rc = -EFAULT;
			break;
		rc = 0;
",,"@@ -1168,11 +1168,10 @@ static int ipxitf_ioctl(unsigned int cmd, void __user *arg)
 		sipx->sipx_network	= ipxif->if_netnum;
 		memcpy(sipx->sipx_node, ipxif->if_node,
 			sizeof(sipx->sipx_node));
-		rc = -EFAULT;
+		rc = 0;
 		if (copy_to_user(arg, &ifr, sizeof(ifr)))
-			break;
+			rc = -EFAULT;
 		ipxitf_put(ipxif);
-		rc = 0;
 		break;
 	}
 	case SIOCAIPXITFCRT:",linux,ee0d8d8482345ff97a75a7d747efc309f13b0d80,9da3242e6a83b6f315aa9c394c939da8e4ad7774,1,"static int ipxitf_ioctl(unsigned int cmd, void __user *arg)
{
	int rc = -EINVAL;
	struct ifreq ifr;
	int val;

	switch (cmd) {
	case SIOCSIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface_definition f;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		rc = -EINVAL;
		if (sipx->sipx_family != AF_IPX)
			break;
		f.ipx_network = sipx->sipx_network;
		memcpy(f.ipx_device, ifr.ifr_name,
			sizeof(f.ipx_device));
		memcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);
		f.ipx_dlink_type = sipx->sipx_type;
		f.ipx_special = sipx->sipx_special;

		if (sipx->sipx_action == IPX_DLTITF)
			rc = ipxitf_delete(&f);
		else
			rc = ipxitf_create(&f);
		break;
	}
	case SIOCGIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface *ipxif;
		struct net_device *dev;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		dev  = __dev_get_by_name(&init_net, ifr.ifr_name);
		rc   = -ENODEV;
		if (!dev)
			break;
		ipxif = ipxitf_find_using_phys(dev,
					   ipx_map_frame_type(sipx->sipx_type));
		rc = -EADDRNOTAVAIL;
		if (!ipxif)
			break;

		sipx->sipx_family	= AF_IPX;
 		sipx->sipx_network	= ipxif->if_netnum;
 		memcpy(sipx->sipx_node, ipxif->if_node,
 			sizeof(sipx->sipx_node));
//flaw_line_below:
		rc = -EFAULT;
//fix_flaw_line_below:
//		rc = 0;
 		if (copy_to_user(arg, &ifr, sizeof(ifr)))
//flaw_line_below:
			break;
//fix_flaw_line_below:
//			rc = -EFAULT;
 		ipxitf_put(ipxif);
//flaw_line_below:
		rc = 0;
 		break;
 	}
 	case SIOCAIPXITFCRT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_auto_create_interfaces = val;
		break;
	case SIOCAIPXPRISLT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_set_auto_select(val);
		break;
	}

	return rc;
}
",181444,"static int ipxitf_ioctl(unsigned int cmd, void __user *arg)
{
	int rc = -EINVAL;
	struct ifreq ifr;
	int val;

	switch (cmd) {
	case SIOCSIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface_definition f;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		rc = -EINVAL;
		if (sipx->sipx_family != AF_IPX)
			break;
		f.ipx_network = sipx->sipx_network;
		memcpy(f.ipx_device, ifr.ifr_name,
			sizeof(f.ipx_device));
		memcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);
		f.ipx_dlink_type = sipx->sipx_type;
		f.ipx_special = sipx->sipx_special;

		if (sipx->sipx_action == IPX_DLTITF)
			rc = ipxitf_delete(&f);
		else
			rc = ipxitf_create(&f);
		break;
	}
	case SIOCGIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface *ipxif;
		struct net_device *dev;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		dev  = __dev_get_by_name(&init_net, ifr.ifr_name);
		rc   = -ENODEV;
		if (!dev)
			break;
		ipxif = ipxitf_find_using_phys(dev,
					   ipx_map_frame_type(sipx->sipx_type));
		rc = -EADDRNOTAVAIL;
		if (!ipxif)
			break;

		sipx->sipx_family	= AF_IPX;
 		sipx->sipx_network	= ipxif->if_netnum;
 		memcpy(sipx->sipx_node, ipxif->if_node,
 			sizeof(sipx->sipx_node));
		rc = -EFAULT;
 		if (copy_to_user(arg, &ifr, sizeof(ifr)))
			break;
 		ipxitf_put(ipxif);
		rc = 0;
 		break;
 	}
 	case SIOCAIPXITFCRT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_auto_create_interfaces = val;
		break;
	case SIOCAIPXPRISLT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_set_auto_select(val);
		break;
	}

	return rc;
}
","static int ipxitf_ioctl(unsigned int cmd, void __user *arg)
{
	int rc = -EINVAL;
	struct ifreq ifr;
	int val;

	switch (cmd) {
	case SIOCSIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface_definition f;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		rc = -EINVAL;
		if (sipx->sipx_family != AF_IPX)
			break;
		f.ipx_network = sipx->sipx_network;
		memcpy(f.ipx_device, ifr.ifr_name,
			sizeof(f.ipx_device));
		memcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);
		f.ipx_dlink_type = sipx->sipx_type;
		f.ipx_special = sipx->sipx_special;

		if (sipx->sipx_action == IPX_DLTITF)
			rc = ipxitf_delete(&f);
		else
			rc = ipxitf_create(&f);
		break;
	}
	case SIOCGIFADDR: {
		struct sockaddr_ipx *sipx;
		struct ipx_interface *ipxif;
		struct net_device *dev;

		rc = -EFAULT;
		if (copy_from_user(&ifr, arg, sizeof(ifr)))
			break;
		sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
		dev  = __dev_get_by_name(&init_net, ifr.ifr_name);
		rc   = -ENODEV;
		if (!dev)
			break;
		ipxif = ipxitf_find_using_phys(dev,
					   ipx_map_frame_type(sipx->sipx_type));
		rc = -EADDRNOTAVAIL;
		if (!ipxif)
			break;

		sipx->sipx_family	= AF_IPX;
 		sipx->sipx_network	= ipxif->if_netnum;
 		memcpy(sipx->sipx_node, ipxif->if_node,
 			sizeof(sipx->sipx_node));
		rc = 0;
 		if (copy_to_user(arg, &ifr, sizeof(ifr)))
			rc = -EFAULT;
 		ipxitf_put(ipxif);
 		break;
 	}
 	case SIOCAIPXITFCRT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_auto_create_interfaces = val;
		break;
	case SIOCAIPXPRISLT:
		rc = -EFAULT;
		if (get_user(val, (unsigned char __user *) arg))
			break;
		rc = 0;
		ipxcfg_set_auto_select(val);
		break;
	}

	return rc;
}
","The `ipxitf_ioctl` function handles various input/output control commands for IPX network interfaces in a Linux kernel module. It processes commands such as setting and getting the interface address (`SIOCSIFADDR` and `SIOCGIFADDR`), which involve copying data between user space and kernel space, validating the IPX address family, and managing interface creation or deletion. Additionally, it allows configuration of automatic interface creation and priority selection through `SIOCAIPXITFCRT` and `SIOCAIPXPRISLT` commands. The function returns appropriate error codes or success status based on the operations performed.","The provided code implements a function that manages input/output control commands for network interfaces using a specific protocol. It allows for setting and retrieving interface addresses, ensuring that the addresses conform to the expected protocol format. The function handles the creation and deletion of interfaces based on user commands, while also enabling configuration options for automatic interface creation and priority selection. It performs necessary checks and data transfers between user space and kernel space, returning appropriate error codes or success indicators based on the outcome of each operation.","The vulnerability in the original code arises from a potential memory leak when the `copy_to_user` function fails after successfully retrieving an interface structure. In this scenario, the reference to the interface is not released, leading to resource exhaustion. The fix addresses this issue by ensuring that `ipxitf_put()` is called in the error path following the `copy_to_user` operation. This guarantees that the reference to the interface is properly released, preventing memory leaks and ensuring that resources are managed correctly, thus enhancing the stability and security of the code.","The vulnerability in the original code stems from a potential memory leak that occurs when an operation to copy data to user space fails after successfully obtaining a reference to a network interface. In such cases, the reference is not released, which can lead to resource exhaustion over time. The fix addresses this issue by ensuring that the reference is properly released in the error handling path if the copy operation fails. This change enhances resource management and stability by preventing memory leaks, thereby improving the overall reliability of the code.","The vulnerability was fixed by adding a call to `ipxitf_put()` in the error handling path after the `copy_to_user()` function. In the original code, if `copy_to_user()` failed, the reference to the interface was not released, leading to a memory leak. By including the call to `ipxitf_put()` in the error path, the code ensures that the reference to the interface is properly released regardless of whether the copy operation succeeds or fails. This change effectively prevents resource exhaustion and enhances the overall stability and reliability of the code.","The vulnerability was fixed by ensuring that resources are properly released in the error handling process. Specifically, the code was modified to include a mechanism that releases the reference to the network interface if a data copy operation fails. This addition guarantees that even in the event of an error, the system does not retain unnecessary references, which could lead to memory leaks. By implementing this change, the code improves resource management and enhances overall stability, preventing potential exhaustion of system resources over time.","CWE-401, CWE-772, CWE-404, CWE-775, CWE-400, CWE-674, CWE-415, CWE-459, CWE-460, CWE-911",N,-1
29,29,181487,181487,,Local,Not required,Complete,CVE-2017-6874,https://www.cvedetails.com/cve/CVE-2017-6874/,CWE-416,Medium,Complete,Complete,,2017-03-14,6.9,Race condition in kernel/ucount.c in the Linux kernel through 4.10.2 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via crafted system calls that leverage certain decrement behavior that causes incorrect interaction between put_ucounts and get_ucounts.,2017-03-15,DoS ,4,https://github.com/torvalds/linux/commit/040757f738e13caaa9c5078bca79aa97e11dde88,040757f738e13caaa9c5078bca79aa97e11dde88,"ucount: Remove the atomicity from ucount->count

Always increment/decrement ucount->count under the ucounts_lock.  The
increments are there already and moving the decrements there means the
locking logic of the code is simpler.  This simplification in the
locking logic fixes a race between put_ucounts and get_ucounts that
could result in a use-after-free because the count could go zero then
be found by get_ucounts and then be freed by put_ucounts.

A bug presumably this one was found by a combination of syzkaller and
KASAN.  JongWhan Kim reported the syzkaller failure and Dmitry Vyukov
spotted the race in the code.

Cc: stable@vger.kernel.org
Fixes: f6b2db1a3e8d (""userns: Make the count of user namespaces per user"")
Reported-by: JongHwan Kim <zzoru007@gmail.com>
Reported-by: Dmitry Vyukov <dvyukov@google.com>
Reviewed-by: Andrei Vagin <avagin@gmail.com>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",2,kernel/ucount.c,"{""sha"": ""32354b4b4b2ba5ae72034d00c3b1d43fa8c2a15c"", ""filename"": ""include/linux/user_namespace.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/040757f738e13caaa9c5078bca79aa97e11dde88/include/linux/user_namespace.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/040757f738e13caaa9c5078bca79aa97e11dde88/include/linux/user_namespace.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/user_namespace.h?ref=040757f738e13caaa9c5078bca79aa97e11dde88"", ""patch"": ""@@ -72,7 +72,7 @@ struct ucounts {\n \tstruct hlist_node node;\n \tstruct user_namespace *ns;\n \tkuid_t uid;\n-\tatomic_t count;\n+\tint count;\n \tatomic_t ucount[UCOUNT_COUNTS];\n };\n ""}<_**next**_>{""sha"": ""b4eeee03934fe8f083b70e9907be0721759bc3be"", ""filename"": ""kernel/ucount.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 7, ""changes"": 18, ""blob_url"": ""https://github.com/torvalds/linux/blob/040757f738e13caaa9c5078bca79aa97e11dde88/kernel/ucount.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/040757f738e13caaa9c5078bca79aa97e11dde88/kernel/ucount.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/ucount.c?ref=040757f738e13caaa9c5078bca79aa97e11dde88"", ""patch"": ""@@ -144,7 +144,7 @@ static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n \n \t\tnew->ns = ns;\n \t\tnew->uid = uid;\n-\t\tatomic_set(&new->count, 0);\n+\t\tnew->count = 0;\n \n \t\tspin_lock_irq(&ucounts_lock);\n \t\tucounts = find_ucounts(ns, uid, hashent);\n@@ -155,8 +155,10 @@ static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n \t\t\tucounts = new;\n \t\t}\n \t}\n-\tif (!atomic_add_unless(&ucounts->count, 1, INT_MAX))\n+\tif (ucounts->count == INT_MAX)\n \t\tucounts = NULL;\n+\telse\n+\t\tucounts->count += 1;\n \tspin_unlock_irq(&ucounts_lock);\n \treturn ucounts;\n }\n@@ -165,13 +167,15 @@ static void put_ucounts(struct ucounts *ucounts)\n {\n \tunsigned long flags;\n \n-\tif (atomic_dec_and_test(&ucounts->count)) {\n-\t\tspin_lock_irqsave(&ucounts_lock, flags);\n+\tspin_lock_irqsave(&ucounts_lock, flags);\n+\tucounts->count -= 1;\n+\tif (!ucounts->count)\n \t\thlist_del_init(&ucounts->node);\n-\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n+\telse\n+\t\tucounts = NULL;\n+\tspin_unlock_irqrestore(&ucounts_lock, flags);\n \n-\t\tkfree(ucounts);\n-\t}\n+\tkfree(ucounts);\n }\n \n static inline bool atomic_inc_below(atomic_t *v, int u)""}","static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)
{
	struct hlist_head *hashent = ucounts_hashentry(ns, uid);
	struct ucounts *ucounts, *new;

	spin_lock_irq(&ucounts_lock);
	ucounts = find_ucounts(ns, uid, hashent);
	if (!ucounts) {
		spin_unlock_irq(&ucounts_lock);

		new = kzalloc(sizeof(*new), GFP_KERNEL);
		if (!new)
			return NULL;
 
 		new->ns = ns;
 		new->uid = uid;
		new->count = 0;
 
 		spin_lock_irq(&ucounts_lock);
 		ucounts = find_ucounts(ns, uid, hashent);
		if (ucounts) {
			kfree(new);
		} else {
			hlist_add_head(&new->node, hashent);
 			ucounts = new;
 		}
 	}
	if (ucounts->count == INT_MAX)
 		ucounts = NULL;
	else
		ucounts->count += 1;
 	spin_unlock_irq(&ucounts_lock);
 	return ucounts;
 }
","static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)
{
	struct hlist_head *hashent = ucounts_hashentry(ns, uid);
	struct ucounts *ucounts, *new;

	spin_lock_irq(&ucounts_lock);
	ucounts = find_ucounts(ns, uid, hashent);
	if (!ucounts) {
		spin_unlock_irq(&ucounts_lock);

		new = kzalloc(sizeof(*new), GFP_KERNEL);
		if (!new)
			return NULL;
 
 		new->ns = ns;
 		new->uid = uid;
		atomic_set(&new->count, 0);
 
 		spin_lock_irq(&ucounts_lock);
 		ucounts = find_ucounts(ns, uid, hashent);
		if (ucounts) {
			kfree(new);
		} else {
			hlist_add_head(&new->node, hashent);
 			ucounts = new;
 		}
 	}
	if (!atomic_add_unless(&ucounts->count, 1, INT_MAX))
 		ucounts = NULL;
 	spin_unlock_irq(&ucounts_lock);
 	return ucounts;
 }
",C,"		new->count = 0;
	if (ucounts->count == INT_MAX)
	else
		ucounts->count += 1;
","		atomic_set(&new->count, 0);
	if (!atomic_add_unless(&ucounts->count, 1, INT_MAX))
",,"@@ -144,7 +144,7 @@ static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)
 
 		new->ns = ns;
 		new->uid = uid;
-		atomic_set(&new->count, 0);
+		new->count = 0;
 
 		spin_lock_irq(&ucounts_lock);
 		ucounts = find_ucounts(ns, uid, hashent);
@@ -155,8 +155,10 @@ static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)
 			ucounts = new;
 		}
 	}
-	if (!atomic_add_unless(&ucounts->count, 1, INT_MAX))
+	if (ucounts->count == INT_MAX)
 		ucounts = NULL;
+	else
+		ucounts->count += 1;
 	spin_unlock_irq(&ucounts_lock);
 	return ucounts;
 }
@@ -165,13 +167,15 @@ static void put_ucounts(struct ucounts *ucounts)
 {
 	unsigned long flags;
 
-	if (atomic_dec_and_test(&ucounts->count)) {
-		spin_lock_irqsave(&ucounts_lock, flags);
+	spin_lock_irqsave(&ucounts_lock, flags);
+	ucounts->count -= 1;
+	if (!ucounts->count)
 		hlist_del_init(&ucounts->node);
-		spin_unlock_irqrestore(&ucounts_lock, flags);
+	else
+		ucounts = NULL;
+	spin_unlock_irqrestore(&ucounts_lock, flags);
 
-		kfree(ucounts);
-	}
+	kfree(ucounts);
 }
 
 static inline bool atomic_inc_below(atomic_t *v, int u)",linux,040757f738e13caaa9c5078bca79aa97e11dde88,c1ae3cfa0e89fa1a7ecc4c99031f5e9ae99d9201,1,"static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)
{
	struct hlist_head *hashent = ucounts_hashentry(ns, uid);
	struct ucounts *ucounts, *new;

	spin_lock_irq(&ucounts_lock);
	ucounts = find_ucounts(ns, uid, hashent);
	if (!ucounts) {
		spin_unlock_irq(&ucounts_lock);

		new = kzalloc(sizeof(*new), GFP_KERNEL);
		if (!new)
			return NULL;
 
 		new->ns = ns;
 		new->uid = uid;
//flaw_line_below:
		atomic_set(&new->count, 0);
//fix_flaw_line_below:
//		new->count = 0;
 
 		spin_lock_irq(&ucounts_lock);
 		ucounts = find_ucounts(ns, uid, hashent);
		if (ucounts) {
			kfree(new);
		} else {
			hlist_add_head(&new->node, hashent);
 			ucounts = new;
 		}
 	}
//flaw_line_below:
	if (!atomic_add_unless(&ucounts->count, 1, INT_MAX))
//fix_flaw_line_below:
//	if (ucounts->count == INT_MAX)
 		ucounts = NULL;
//fix_flaw_line_below:
//	else
//fix_flaw_line_below:
//		ucounts->count += 1;
 	spin_unlock_irq(&ucounts_lock);
 	return ucounts;
 }
",181487,"static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)
{
	struct hlist_head *hashent = ucounts_hashentry(ns, uid);
	struct ucounts *ucounts, *new;

	spin_lock_irq(&ucounts_lock);
	ucounts = find_ucounts(ns, uid, hashent);
	if (!ucounts) {
		spin_unlock_irq(&ucounts_lock);

		new = kzalloc(sizeof(*new), GFP_KERNEL);
		if (!new)
			return NULL;
 
 		new->ns = ns;
 		new->uid = uid;
		atomic_set(&new->count, 0);
 
 		spin_lock_irq(&ucounts_lock);
 		ucounts = find_ucounts(ns, uid, hashent);
		if (ucounts) {
			kfree(new);
		} else {
			hlist_add_head(&new->node, hashent);
 			ucounts = new;
 		}
 	}
	if (!atomic_add_unless(&ucounts->count, 1, INT_MAX))
 		ucounts = NULL;
 	spin_unlock_irq(&ucounts_lock);
 	return ucounts;
 }
","static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)
{
	struct hlist_head *hashent = ucounts_hashentry(ns, uid);
	struct ucounts *ucounts, *new;

	spin_lock_irq(&ucounts_lock);
	ucounts = find_ucounts(ns, uid, hashent);
	if (!ucounts) {
		spin_unlock_irq(&ucounts_lock);

		new = kzalloc(sizeof(*new), GFP_KERNEL);
		if (!new)
			return NULL;
 
 		new->ns = ns;
 		new->uid = uid;
		new->count = 0;
 
 		spin_lock_irq(&ucounts_lock);
 		ucounts = find_ucounts(ns, uid, hashent);
		if (ucounts) {
			kfree(new);
		} else {
			hlist_add_head(&new->node, hashent);
 			ucounts = new;
 		}
 	}
	if (ucounts->count == INT_MAX)
 		ucounts = NULL;
	else
		ucounts->count += 1;
 	spin_unlock_irq(&ucounts_lock);
 	return ucounts;
 }
","The `get_ucounts` function retrieves or creates a user count structure (`ucounts`) associated with a specific user ID (`uid`) within a given user namespace (`ns`). It first attempts to find an existing `ucounts` entry in a hash table. If not found, it allocates memory for a new `ucounts` structure, initializes it, and rechecks for an existing entry to avoid duplicates. If the entry is still absent, it adds the new structure to the hash table. The function then increments the count atomically, ensuring thread safety, and returns the pointer to the `ucounts` structure or `NULL` if the count increment fails.","The provided code defines a function that manages user count structures associated with specific user IDs within a user namespace. It first checks for an existing structure in a hash table. If none is found, it allocates memory for a new structure, initializes it, and checks again to prevent duplicates. If the structure is still absent, it adds the new entry to the hash table. The function then safely increments a count value associated with the structure, ensuring thread safety, and returns a pointer to the structure or `NULL` if the increment operation fails.","The vulnerability in the original code stemmed from the use of atomic operations on the count variable, which could lead to a race condition between the `put_ucounts` and `get_ucounts` functions. Specifically, the count could reach zero and be freed, while `get_ucounts` could still find the structure, resulting in a use-after-free scenario. The fix involved removing atomicity from the count and ensuring that all increments and decrements occur under the `ucounts_lock`. This change simplified the locking logic and eliminated the race condition, thereby preventing potential memory access violations.","The vulnerability in the original code arose from a race condition between two functions that managed user count structures, which could lead to a use-after-free error. Specifically, the count could be decremented to zero and subsequently freed while another function still referenced it, resulting in unsafe memory access. The fix involved removing atomic operations on the count and ensuring that all increments and decrements occur under a specific lock. This change simplified the locking mechanism, effectively preventing the race condition and ensuring that the memory management of the user count structures was safe and reliable.","The vulnerability was fixed by removing the atomic operations on the `count` variable and ensuring that all increments and decrements occur under the `ucounts_lock`. This change meant that both the increment operation, which was already protected by the lock, and the newly moved decrement operation would be executed in a thread-safe manner. By consistently using the lock for both operations, the code eliminated the race condition between `put_ucounts` and `get_ucounts`, preventing scenarios where the count could reach zero and lead to a use-after-free error, thereby enhancing memory safety.","The vulnerability was addressed by ensuring that all operations related to the count variable, including both increments and decrements, are performed under a specific locking mechanism. This change eliminated the potential for race conditions by enforcing that only one thread can modify the count at a time. By consolidating the locking logic, the code prevents scenarios where the count could be decremented to zero and subsequently freed while still being accessed by another part of the program. This approach enhances memory safety and ensures that the management of user count structures is reliable and secure.","CWE-366,CWE-362,CWE-667,CWE-732,CWE-772,CWE-833,CWE-413,CWE-567,CWE-609,CWE-665",N,-1
30,30,181488,181488,,Local,Not required,Complete,CVE-2017-6874,https://www.cvedetails.com/cve/CVE-2017-6874/,CWE-416,Medium,Complete,Complete,,2017-03-14,6.9,Race condition in kernel/ucount.c in the Linux kernel through 4.10.2 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via crafted system calls that leverage certain decrement behavior that causes incorrect interaction between put_ucounts and get_ucounts.,2017-03-15,DoS ,7,https://github.com/torvalds/linux/commit/040757f738e13caaa9c5078bca79aa97e11dde88,040757f738e13caaa9c5078bca79aa97e11dde88,"ucount: Remove the atomicity from ucount->count

Always increment/decrement ucount->count under the ucounts_lock.  The
increments are there already and moving the decrements there means the
locking logic of the code is simpler.  This simplification in the
locking logic fixes a race between put_ucounts and get_ucounts that
could result in a use-after-free because the count could go zero then
be found by get_ucounts and then be freed by put_ucounts.

A bug presumably this one was found by a combination of syzkaller and
KASAN.  JongWhan Kim reported the syzkaller failure and Dmitry Vyukov
spotted the race in the code.

Cc: stable@vger.kernel.org
Fixes: f6b2db1a3e8d (""userns: Make the count of user namespaces per user"")
Reported-by: JongHwan Kim <zzoru007@gmail.com>
Reported-by: Dmitry Vyukov <dvyukov@google.com>
Reviewed-by: Andrei Vagin <avagin@gmail.com>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",5,kernel/ucount.c,"{""sha"": ""32354b4b4b2ba5ae72034d00c3b1d43fa8c2a15c"", ""filename"": ""include/linux/user_namespace.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/040757f738e13caaa9c5078bca79aa97e11dde88/include/linux/user_namespace.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/040757f738e13caaa9c5078bca79aa97e11dde88/include/linux/user_namespace.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/user_namespace.h?ref=040757f738e13caaa9c5078bca79aa97e11dde88"", ""patch"": ""@@ -72,7 +72,7 @@ struct ucounts {\n \tstruct hlist_node node;\n \tstruct user_namespace *ns;\n \tkuid_t uid;\n-\tatomic_t count;\n+\tint count;\n \tatomic_t ucount[UCOUNT_COUNTS];\n };\n ""}<_**next**_>{""sha"": ""b4eeee03934fe8f083b70e9907be0721759bc3be"", ""filename"": ""kernel/ucount.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 7, ""changes"": 18, ""blob_url"": ""https://github.com/torvalds/linux/blob/040757f738e13caaa9c5078bca79aa97e11dde88/kernel/ucount.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/040757f738e13caaa9c5078bca79aa97e11dde88/kernel/ucount.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/ucount.c?ref=040757f738e13caaa9c5078bca79aa97e11dde88"", ""patch"": ""@@ -144,7 +144,7 @@ static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n \n \t\tnew->ns = ns;\n \t\tnew->uid = uid;\n-\t\tatomic_set(&new->count, 0);\n+\t\tnew->count = 0;\n \n \t\tspin_lock_irq(&ucounts_lock);\n \t\tucounts = find_ucounts(ns, uid, hashent);\n@@ -155,8 +155,10 @@ static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n \t\t\tucounts = new;\n \t\t}\n \t}\n-\tif (!atomic_add_unless(&ucounts->count, 1, INT_MAX))\n+\tif (ucounts->count == INT_MAX)\n \t\tucounts = NULL;\n+\telse\n+\t\tucounts->count += 1;\n \tspin_unlock_irq(&ucounts_lock);\n \treturn ucounts;\n }\n@@ -165,13 +167,15 @@ static void put_ucounts(struct ucounts *ucounts)\n {\n \tunsigned long flags;\n \n-\tif (atomic_dec_and_test(&ucounts->count)) {\n-\t\tspin_lock_irqsave(&ucounts_lock, flags);\n+\tspin_lock_irqsave(&ucounts_lock, flags);\n+\tucounts->count -= 1;\n+\tif (!ucounts->count)\n \t\thlist_del_init(&ucounts->node);\n-\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n+\telse\n+\t\tucounts = NULL;\n+\tspin_unlock_irqrestore(&ucounts_lock, flags);\n \n-\t\tkfree(ucounts);\n-\t}\n+\tkfree(ucounts);\n }\n \n static inline bool atomic_inc_below(atomic_t *v, int u)""}","static void put_ucounts(struct ucounts *ucounts)
 {
 	unsigned long flags;
 
	spin_lock_irqsave(&ucounts_lock, flags);
	ucounts->count -= 1;
	if (!ucounts->count)
 		hlist_del_init(&ucounts->node);
	else
		ucounts = NULL;
	spin_unlock_irqrestore(&ucounts_lock, flags);
 
	kfree(ucounts);
 }
","static void put_ucounts(struct ucounts *ucounts)
 {
 	unsigned long flags;
 
	if (atomic_dec_and_test(&ucounts->count)) {
		spin_lock_irqsave(&ucounts_lock, flags);
 		hlist_del_init(&ucounts->node);
		spin_unlock_irqrestore(&ucounts_lock, flags);
 
		kfree(ucounts);
	}
 }
",C,"	spin_lock_irqsave(&ucounts_lock, flags);
	ucounts->count -= 1;
	if (!ucounts->count)
	else
		ucounts = NULL;
	spin_unlock_irqrestore(&ucounts_lock, flags);
	kfree(ucounts);
","	if (atomic_dec_and_test(&ucounts->count)) {
		spin_lock_irqsave(&ucounts_lock, flags);
		spin_unlock_irqrestore(&ucounts_lock, flags);
		kfree(ucounts);
	}
",,"@@ -144,7 +144,7 @@ static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)
 
 		new->ns = ns;
 		new->uid = uid;
-		atomic_set(&new->count, 0);
+		new->count = 0;
 
 		spin_lock_irq(&ucounts_lock);
 		ucounts = find_ucounts(ns, uid, hashent);
@@ -155,8 +155,10 @@ static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)
 			ucounts = new;
 		}
 	}
-	if (!atomic_add_unless(&ucounts->count, 1, INT_MAX))
+	if (ucounts->count == INT_MAX)
 		ucounts = NULL;
+	else
+		ucounts->count += 1;
 	spin_unlock_irq(&ucounts_lock);
 	return ucounts;
 }
@@ -165,13 +167,15 @@ static void put_ucounts(struct ucounts *ucounts)
 {
 	unsigned long flags;
 
-	if (atomic_dec_and_test(&ucounts->count)) {
-		spin_lock_irqsave(&ucounts_lock, flags);
+	spin_lock_irqsave(&ucounts_lock, flags);
+	ucounts->count -= 1;
+	if (!ucounts->count)
 		hlist_del_init(&ucounts->node);
-		spin_unlock_irqrestore(&ucounts_lock, flags);
+	else
+		ucounts = NULL;
+	spin_unlock_irqrestore(&ucounts_lock, flags);
 
-		kfree(ucounts);
-	}
+	kfree(ucounts);
 }
 
 static inline bool atomic_inc_below(atomic_t *v, int u)",linux,040757f738e13caaa9c5078bca79aa97e11dde88,c1ae3cfa0e89fa1a7ecc4c99031f5e9ae99d9201,1,"static void put_ucounts(struct ucounts *ucounts)
 {
 	unsigned long flags;
 
//flaw_line_below:
	if (atomic_dec_and_test(&ucounts->count)) {
//flaw_line_below:
		spin_lock_irqsave(&ucounts_lock, flags);
//fix_flaw_line_below:
//	spin_lock_irqsave(&ucounts_lock, flags);
//fix_flaw_line_below:
//	ucounts->count -= 1;
//fix_flaw_line_below:
//	if (!ucounts->count)
 		hlist_del_init(&ucounts->node);
//flaw_line_below:
		spin_unlock_irqrestore(&ucounts_lock, flags);
//fix_flaw_line_below:
//	else
//fix_flaw_line_below:
//		ucounts = NULL;
//fix_flaw_line_below:
//	spin_unlock_irqrestore(&ucounts_lock, flags);
 
//flaw_line_below:
		kfree(ucounts);
//flaw_line_below:
	}
//fix_flaw_line_below:
//	kfree(ucounts);
 }
",181488,"static void put_ucounts(struct ucounts *ucounts)
 {
 	unsigned long flags;
 
	if (atomic_dec_and_test(&ucounts->count)) {
		spin_lock_irqsave(&ucounts_lock, flags);
 		hlist_del_init(&ucounts->node);
		spin_unlock_irqrestore(&ucounts_lock, flags);
 
		kfree(ucounts);
	}
 }
","static void put_ucounts(struct ucounts *ucounts)
 {
 	unsigned long flags;
 
	spin_lock_irqsave(&ucounts_lock, flags);
	ucounts->count -= 1;
	if (!ucounts->count)
 		hlist_del_init(&ucounts->node);
	else
		ucounts = NULL;
	spin_unlock_irqrestore(&ucounts_lock, flags);
 
	kfree(ucounts);
 }
","The provided code defines a function `put_ucounts` that manages the lifecycle of a `ucounts` structure, which likely tracks user counts in a system. It first attempts to decrement the reference count of the `ucounts` object atomically. If the count reaches zero, indicating no remaining references, it acquires a spinlock to safely remove the `ucounts` node from a hash list, ensuring thread safety during this operation. After removing the node, it releases the spinlock and subsequently frees the memory allocated for the `ucounts` structure, effectively cleaning up resources when they are no longer needed.","The code defines a function that manages the reference counting and cleanup of a specific data structure. It first checks if the reference count can be decremented and if it reaches zero, indicating no remaining references. Upon confirming this, the function acquires a lock to ensure safe access to shared resources, removes the structure from a linked list, and then releases the lock. Finally, it frees the memory allocated for the structure, effectively releasing resources and preventing memory leaks when the structure is no longer in use.","The vulnerability in the original code stemmed from the use of atomic operations on the reference count, which created a race condition between the `put_ucounts` and `get_ucounts` functions. Specifically, the reference count could be decremented to zero, allowing `put_ucounts` to free the memory while `get_ucounts` could still access the now-freed structure, leading to a use-after-free error. The fixed code addresses this by ensuring that all increments and decrements of the reference count occur while holding a lock, simplifying the locking logic and preventing the race condition that could result in accessing freed memory.","The vulnerability in the original code arose from the use of atomic operations for managing a reference count, which led to a race condition between two functions that handle the lifecycle of a data structure. This race condition allowed the reference count to be decremented to zero, potentially freeing the memory while another function could still access it, resulting in a use-after-free error. The fix involved ensuring that all modifications to the reference count occur while holding a lock, thereby simplifying the locking logic and effectively preventing the race condition that could lead to accessing freed memory.","The vulnerability was fixed by ensuring that all increments and decrements of the reference count occur under the `ucounts_lock`. In the revised code, the decrement operation on `ucounts->count` is now performed while the lock is held, which prevents any race conditions with the `get_ucounts` function. This change simplifies the locking logic, as both the increment and decrement operations are now consistently protected by the same lock. Additionally, the check for whether the count is zero and the subsequent removal of the node from the list are also performed within the locked context, ensuring safe memory management.","The vulnerability was fixed by ensuring that all operations related to the reference count are performed while holding a lock, which prevents race conditions between functions managing the lifecycle of the data structure. By moving the decrement operation under the lock, the code guarantees that the reference count cannot be modified concurrently by multiple threads. This change also ensures that the check for a zero count and the subsequent removal of the data structure from its list occur in a safe context, effectively eliminating the risk of accessing freed memory and simplifying the overall locking logic.","CWE-362,CWE-366,CWE-609,CWE-367,CWE-667,CWE-833,CWE-567,CWE-820,CWE-765,CWE-665",N,-1
31,31,181653,181653,,Remote,Not required,Partial,CVE-2016-10211,https://www.cvedetails.com/cve/CVE-2016-10211/,CWE-416,Low,,,,2017-04-03,5.0,libyara/grammar.y in YARA 3.5.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted rule that is mishandled in the yr_parser_lookup_loop_variable function.,2017-05-01,DoS ,176,https://github.com/VirusTotal/yara/commit/890c3f850293176c0e996a602ffa88b315f4e98f,890c3f850293176c0e996a602ffa88b315f4e98f,Fix issue #575,167,libyara/grammar.c,"{""sha"": ""6e5c46e5e122a2677d5839cedf873fc6c99dcd40"", ""filename"": ""libyara/grammar.c"", ""status"": ""modified"", ""additions"": 327, ""deletions"": 318, ""changes"": 645, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/890c3f850293176c0e996a602ffa88b315f4e98f/libyara/grammar.c"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/890c3f850293176c0e996a602ffa88b315f4e98f/libyara/grammar.c"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/libyara/grammar.c?ref=890c3f850293176c0e996a602ffa88b315f4e98f"", ""patch"": ""@@ -546,16 +546,16 @@ union yyalloc\n /* YYFINAL -- State number of the termination state.  */\n #define YYFINAL  2\n /* YYLAST -- Last index in YYTABLE.  */\n-#define YYLAST   408\n+#define YYLAST   406\n \n /* YYNTOKENS -- Number of terminals.  */\n #define YYNTOKENS  72\n /* YYNNTS -- Number of nonterminals.  */\n #define YYNNTS  41\n /* YYNRULES -- Number of rules.  */\n-#define YYNRULES  121\n+#define YYNRULES  122\n /* YYNSTATES -- Number of states.  */\n-#define YYNSTATES  209\n+#define YYNSTATES  210\n \n /* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned\n    by yylex, with out-of-bounds checking.  */\n@@ -612,13 +612,13 @@ static const yytype_uint16 yyrline[] =\n      472,   485,   502,   503,   509,   508,   524,   523,   539,   553,\n      554,   559,   560,   561,   562,   567,   652,   698,   756,   801,\n      802,   806,   831,   867,   913,   935,   944,   953,   968,   980,\n-     994,  1007,  1019,  1049,  1018,  1163,  1162,  1241,  1247,  1254,\n-    1253,  1316,  1315,  1376,  1385,  1394,  1403,  1412,  1421,  1430,\n-    1434,  1442,  1443,  1448,  1470,  1482,  1498,  1497,  1503,  1514,\n-    1515,  1520,  1527,  1538,  1539,  1543,  1551,  1555,  1565,  1579,\n-    1595,  1605,  1614,  1639,  1651,  1663,  1679,  1691,  1707,  1752,\n-    1771,  1789,  1807,  1825,  1851,  1869,  1879,  1889,  1899,  1909,\n-    1919,  1929\n+     994,  1007,  1018,  1024,  1054,  1023,  1168,  1167,  1246,  1252,\n+    1259,  1258,  1321,  1320,  1381,  1390,  1399,  1408,  1417,  1426,\n+    1435,  1439,  1447,  1448,  1453,  1475,  1487,  1503,  1502,  1508,\n+    1519,  1520,  1525,  1532,  1543,  1544,  1548,  1556,  1560,  1570,\n+    1584,  1600,  1610,  1619,  1644,  1656,  1668,  1684,  1696,  1712,\n+    1757,  1776,  1794,  1812,  1830,  1856,  1874,  1884,  1894,  1904,\n+    1914,  1924,  1934\n };\n #endif\n \n@@ -672,7 +672,7 @@ static const yytype_uint16 yytoknum[] =\n #define yypact_value_is_default(Yystate) \\\n   (!!((Yystate) == (-73)))\n \n-#define YYTABLE_NINF -94\n+#define YYTABLE_NINF -95\n \n #define yytable_value_is_error(Yytable_value) \\\n   0\n@@ -681,27 +681,27 @@ static const yytype_uint16 yytoknum[] =\n      STATE-NUM.  */\n static const yytype_int16 yypact[] =\n {\n-     -73,    79,   -73,   -32,    -4,   -73,   -73,    94,   -73,   -73,\n-     -73,   -73,    13,   -73,   -73,   -73,   -73,    -8,    72,     6,\n-     -73,    78,   111,   -73,    61,   122,   123,    82,   -73,    90,\n-     123,   -73,   147,   150,    16,   -73,    96,   147,   -73,   101,\n-      97,   -73,   -73,   -73,   -73,   151,    53,   -73,    48,   -73,\n-     -73,   -73,   149,   145,   -73,    -9,   -73,   103,   107,   -73,\n-     -73,   106,   -73,   -73,   -73,   -73,   -73,   -73,   110,   -73,\n-     -73,   135,    48,   135,    48,   -33,   -73,    64,   -73,   144,\n-     306,   -73,   -73,   135,   108,   135,   135,   135,   135,    -7,\n-     322,   -73,   -73,   -73,    64,   117,   163,   168,   135,    48,\n-     -73,   -73,    -6,   167,   135,   135,   135,   135,   135,   135,\n-     135,   135,   135,   135,   135,   135,   135,   135,   135,   135,\n-     135,    86,    86,   322,   135,   -73,   243,   261,   183,   203,\n-     159,    -6,   -73,   -73,   -73,   279,   121,   125,    95,    48,\n-      48,   -73,   -73,   -73,   -73,   322,   337,   351,   -43,   322,\n-     322,   322,   322,   322,   322,    40,    40,    58,    58,   -73,\n-     -73,   -73,   -73,   -73,   -73,   -73,   -73,   129,   -73,   -73,\n-     -73,   -73,   128,   -73,   -73,    48,   152,   -73,    15,   135,\n-     131,   -73,    95,   -73,   -73,    71,   -73,   223,   135,   133,\n-     -73,   132,   -73,    15,   -73,    73,   129,   -73,    48,   -73,\n-     -73,   135,   134,    31,   322,    48,   -73,    49,   -73\n+     -73,    90,   -73,   -32,   -10,   -73,   -73,    93,   -73,   -73,\n+     -73,   -73,     1,   -73,   -73,   -73,   -73,   -49,     7,   -36,\n+     -73,    20,    26,   -73,   -28,    92,    46,     4,   -73,    40,\n+      46,   -73,   100,   119,    16,   -73,    72,   100,   -73,    77,\n+      83,   -73,   -73,   -73,   -73,   134,    59,   -73,    48,   -73,\n+     -73,   -73,   133,   136,   -73,   -18,   -73,    88,    95,   -73,\n+     -73,    91,   -73,   -73,   -73,   -73,   -73,   -73,   102,   -73,\n+     -73,   126,    48,   126,    48,   -44,   -73,    85,   -73,   127,\n+     297,   -73,   -73,   126,   110,   126,   126,   126,   126,     2,\n+     313,   -73,   -73,   -73,    85,   111,   154,   172,   126,    48,\n+     -73,   -73,    -6,   162,   126,   126,   126,   126,   126,   126,\n+     126,   126,   126,   126,   126,   126,   126,   126,   126,   126,\n+     126,    60,    60,   313,   126,   -73,   234,   252,   174,   194,\n+     -73,   153,    -6,   -73,   -73,   -73,   270,   117,   120,   108,\n+      48,    48,   -73,   -73,   -73,   -73,   313,   328,   342,   349,\n+     313,   313,   313,   313,   313,   313,   113,   113,    53,    53,\n+     -73,   -73,   -73,   -73,   -73,   -73,   -73,   -73,   121,   -73,\n+     -73,   -73,   -73,   124,   -73,   -73,    48,   151,   -73,    -1,\n+     126,   125,   -73,   108,   -73,   -73,    18,   -73,   214,   126,\n+     129,   -73,   143,   -73,    -1,   -73,    63,   121,   -73,    48,\n+     -73,   -73,   126,   144,    31,   313,    48,   -73,    33,   -73\n };\n \n   /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.\n@@ -714,31 +714,31 @@ static const yytype_uint8 yydefact[] =\n       23,    22,    12,    24,     0,    14,     0,     0,    10,     0,\n       13,    25,     0,     0,     0,    26,     0,    15,    32,     0,\n        0,    28,    27,    30,    31,     0,    34,    33,     0,    11,\n-      29,    38,     0,     0,    45,    59,   103,   105,   107,   100,\n-     101,     0,   102,    53,    97,    98,    94,    95,     0,    55,\n-      56,     0,     0,     0,     0,   108,   121,    16,    54,     0,\n-      79,    39,    39,     0,     0,     0,     0,     0,     0,     0,\n-      93,   109,    68,   118,     0,    54,    79,     0,     0,    49,\n-      71,    69,     0,     0,     0,     0,     0,     0,     0,     0,\n+      29,    38,     0,     0,    45,    59,   104,   106,   108,   101,\n+     102,     0,   103,    53,    98,    99,    95,    96,     0,    55,\n+      56,     0,     0,     0,     0,   109,   122,    16,    54,     0,\n+      80,    39,    39,     0,     0,     0,     0,     0,     0,     0,\n+      94,   110,    69,   119,     0,    54,    80,     0,     0,    49,\n+      72,    70,     0,     0,     0,     0,     0,     0,     0,     0,\n        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n        0,    35,    37,    60,     0,    61,     0,     0,     0,     0,\n-       0,     0,    80,    96,    46,     0,     0,    50,    51,     0,\n-       0,    88,    86,    67,    57,    58,   117,   115,   116,    77,\n-      78,    73,    75,    74,    76,   119,   120,   110,   111,   112,\n-     113,   114,    42,    41,    43,    44,    40,     0,   104,   106,\n-      99,    62,     0,    47,    48,     0,    72,    70,     0,     0,\n-       0,    65,    52,    91,    92,     0,    89,     0,     0,     0,\n-      82,     0,    87,     0,    83,     0,    84,    63,     0,    90,\n-      81,     0,     0,     0,    85,     0,    66,     0,    64\n+      62,     0,     0,    81,    97,    46,     0,     0,    50,    51,\n+       0,     0,    89,    87,    68,    57,    58,   118,   116,   117,\n+      78,    79,    74,    76,    75,    77,   120,   121,   111,   112,\n+     113,   114,   115,    42,    41,    43,    44,    40,     0,   105,\n+     107,   100,    63,     0,    47,    48,     0,    73,    71,     0,\n+       0,     0,    66,    52,    92,    93,     0,    90,     0,     0,\n+       0,    83,     0,    88,     0,    84,     0,    85,    64,     0,\n+      91,    82,     0,     0,     0,    86,     0,    67,     0,    65\n };\n \n   /* YYPGOTO[NTERM-NUM].  */\n static const yytype_int16 yypgoto[] =\n {\n-     -73,   -73,   199,   218,   -73,   -73,   -73,   -73,   -73,   -73,\n-     -73,   -73,   -73,   -73,   192,   -73,   186,   -73,   -73,   142,\n-     -73,   -73,   -73,   -73,   126,   -48,   -72,   -73,   -73,   -73,\n-     -73,   -73,   -73,    50,   -73,   100,   -73,   -73,    35,   164,\n+     -73,   -73,   211,   212,   -73,   -73,   -73,   -73,   -73,   -73,\n+     -73,   -73,   -73,   -73,   189,   -73,   183,   -73,   -73,   139,\n+     -73,   -73,   -73,   -73,   130,   -48,   -72,   -73,   -73,   -73,\n+     -73,   -73,   -73,    41,   -73,   103,   -73,   -73,    29,   164,\n      -67\n };\n \n@@ -747,8 +747,8 @@ static const yytype_int16 yydefgoto[] =\n {\n       -1,     1,     5,     6,    17,    33,    25,    28,    40,     7,\n       15,    19,    21,    30,    31,    37,    38,    52,    53,   121,\n-     166,    75,   136,   137,    76,    94,    78,   180,   202,   191,\n-     140,   139,   189,   125,   195,   143,   178,   185,   186,    79,\n+     167,    75,   137,   138,    76,    94,    78,   181,   203,   192,\n+     141,   140,   190,   125,   196,   144,   179,   186,   187,    79,\n       80\n };\n \n@@ -757,92 +757,92 @@ static const yytype_int16 yydefgoto[] =\n      number is the opposite.  If YYTABLE_NINF, syntax error.  */\n static const yytype_int16 yytable[] =\n {\n-      77,    90,    95,   130,    91,     4,    93,    96,   114,   115,\n-     116,   117,   118,   119,   120,    11,   123,    83,   126,   127,\n-     128,   129,    84,    16,    92,   131,   183,   138,   141,     8,\n-     184,   135,    41,    97,    98,    42,    99,   145,   146,   147,\n-     148,   149,   150,   151,   152,   153,   154,   155,   156,   157,\n-     158,   159,   160,   161,    43,    44,    18,   167,    54,    55,\n-      56,    57,    58,   142,    59,    60,    61,    62,    22,    63,\n-      45,   100,   101,    51,   -36,    64,    65,    66,    67,     2,\n-       3,    68,    20,   -17,   -17,   -17,    69,    70,    23,   100,\n-     101,   176,   177,   116,   117,   118,   119,   120,    12,    13,\n-      14,   206,    71,   182,   100,   101,    72,    73,   162,   163,\n-     164,   165,   187,   118,   119,   120,     4,    74,    24,   208,\n-      54,   196,    56,    57,    58,    26,    59,    60,    61,    62,\n-      27,    63,   179,    29,   204,   -54,   -54,    64,    65,    66,\n-      67,   192,   193,   200,   201,    54,    32,    56,    57,    58,\n-     203,    59,    60,    61,    62,    34,    63,   207,    36,    39,\n-      49,    46,    64,    65,    71,    48,    82,    50,    81,    73,\n-      85,   105,   106,   107,    86,    87,   102,   124,   134,    88,\n-     114,   115,   116,   117,   118,   119,   120,   132,    63,    71,\n-     171,   174,   181,   101,    73,   -93,   175,   197,   103,   104,\n-     188,   198,     9,   205,    88,   105,   106,   107,   108,   109,\n-     110,   111,   112,   113,   114,   115,   116,   117,   118,   119,\n-     120,    10,    35,    47,   122,   105,   106,   107,   199,   144,\n-     190,   172,    89,   133,   114,   115,   116,   117,   118,   119,\n-     120,     0,     0,     0,     0,   105,   106,   107,     0,     0,\n-       0,     0,     0,   170,   114,   115,   116,   117,   118,   119,\n-     120,     0,     0,     0,     0,   105,   106,   107,     0,     0,\n-       0,     0,     0,   133,   114,   115,   116,   117,   118,   119,\n-     120,     0,     0,     0,     0,   105,   106,   107,     0,     0,\n-       0,     0,     0,   194,   114,   115,   116,   117,   118,   119,\n-     120,     0,     0,   105,   106,   107,     0,     0,     0,     0,\n-       0,   168,   114,   115,   116,   117,   118,   119,   120,     0,\n-       0,   105,   106,   107,     0,     0,     0,     0,     0,   169,\n-     114,   115,   116,   117,   118,   119,   120,     0,   -93,     0,\n-       0,   103,   104,     0,     0,     0,     0,   173,   105,   106,\n-     107,   108,   109,   110,   111,   112,   113,   114,   115,   116,\n-     117,   118,   119,   120,   105,   106,   107,     0,     0,     0,\n+      77,    90,    95,   130,    91,     4,    93,    96,    83,    11,\n+     184,    16,   131,    84,   185,    18,   123,    20,   126,   127,\n+     128,   129,    97,    98,    92,    99,    22,   139,   142,     8,\n+      23,   136,    41,    24,   132,    42,    26,   146,   147,   148,\n+     149,   150,   151,   152,   153,   154,   155,   156,   157,   158,\n+     159,   160,   161,   162,    43,    44,    29,   168,    54,    55,\n+      56,    57,    58,   143,    59,    60,    61,    62,    32,    63,\n+      45,   100,   101,   100,   101,    64,    65,    66,    67,    51,\n+     -36,    68,   163,   164,   165,   166,    69,    70,   193,   194,\n+       2,     3,   177,   178,   -17,   -17,   -17,    12,    13,    14,\n+      27,   207,    71,   209,   183,    34,    72,    73,   118,   119,\n+     120,    36,    54,   188,    56,    57,    58,    74,    59,    60,\n+      61,    62,   197,    63,   180,   100,   101,     4,    39,    64,\n+      65,    66,    67,   201,   202,   205,    54,    46,    56,    57,\n+      58,    48,    59,    60,    61,    62,    49,    63,   -54,   -54,\n+      50,   204,    81,    64,    65,    85,    71,    82,   208,   102,\n+      87,    73,    86,   105,   106,   107,   116,   117,   118,   119,\n+     120,    88,   114,   115,   116,   117,   118,   119,   120,   124,\n+      71,   133,   135,    63,   172,    73,   -94,   175,   182,   103,\n+     104,   176,   101,   198,   189,    88,   105,   106,   107,   108,\n+     109,   110,   111,   112,   113,   114,   115,   116,   117,   118,\n+     119,   120,   199,   206,     9,    10,   105,   106,   107,    35,\n+      47,   122,   191,   200,   134,   114,   115,   116,   117,   118,\n+     119,   120,    89,   145,     0,   173,   105,   106,   107,     0,\n+       0,     0,     0,     0,   171,   114,   115,   116,   117,   118,\n+     119,   120,     0,     0,     0,     0,   105,   106,   107,     0,\n+       0,     0,     0,     0,   134,   114,   115,   116,   117,   118,\n+     119,   120,     0,     0,     0,     0,   105,   106,   107,     0,\n+       0,     0,     0,     0,   195,   114,   115,   116,   117,   118,\n+     119,   120,     0,     0,   105,   106,   107,     0,     0,     0,\n+       0,     0,   169,   114,   115,   116,   117,   118,   119,   120,\n+       0,     0,   105,   106,   107,     0,     0,     0,     0,     0,\n+     170,   114,   115,   116,   117,   118,   119,   120,     0,   -94,\n+       0,     0,   103,   104,     0,     0,     0,     0,   174,   105,\n+     106,   107,   108,   109,   110,   111,   112,   113,   114,   115,\n+     116,   117,   118,   119,   120,   105,   106,   107,     0,     0,\n+       0,     0,     0,     0,   114,   115,   116,   117,   118,   119,\n+     120,   106,   107,     0,     0,     0,     0,     0,     0,   114,\n+     115,   116,   117,   118,   119,   120,   107,     0,     0,     0,\n        0,     0,     0,   114,   115,   116,   117,   118,   119,   120,\n-     106,   107,     0,     0,     0,     0,     0,     0,   114,   115,\n-     116,   117,   118,   119,   120,   107,     0,     0,     0,     0,\n-       0,     0,   114,   115,   116,   117,   118,   119,   120\n+     114,   115,   116,   117,   118,   119,   120\n };\n \n static const yytype_int16 yycheck[] =\n {\n-      48,    68,    74,    10,    71,    37,    73,    74,    51,    52,\n-      53,    54,    55,    56,    57,    19,    83,    26,    85,    86,\n-      87,    88,    31,    10,    72,    32,    11,    99,    34,    61,\n-      15,    98,    16,    66,    67,    19,    69,   104,   105,   106,\n+      48,    68,    74,     1,    71,    37,    73,    74,    26,    19,\n+      11,    10,    10,    31,    15,    64,    83,    10,    85,    86,\n+      87,    88,    66,    67,    72,    69,    62,    99,    34,    61,\n+      10,    98,    16,     7,    32,    19,    64,   104,   105,   106,\n      107,   108,   109,   110,   111,   112,   113,   114,   115,   116,\n-     117,   118,   119,   120,    38,    39,    64,   124,    10,    11,\n-      12,    13,    14,    69,    16,    17,    18,    19,    62,    21,\n-      54,    40,    41,    20,    21,    27,    28,    29,    30,     0,\n-       1,    33,    10,     4,     5,     6,    38,    39,    10,    40,\n-      41,   139,   140,    53,    54,    55,    56,    57,     4,     5,\n-       6,    70,    54,   175,    40,    41,    58,    59,    22,    23,\n-      24,    25,   179,    55,    56,    57,    37,    69,     7,    70,\n-      10,   188,    12,    13,    14,    64,    16,    17,    18,    19,\n-       8,    21,     3,    10,   201,    40,    41,    27,    28,    29,\n-      30,    70,    71,    70,    71,    10,    64,    12,    13,    14,\n-     198,    16,    17,    18,    19,    65,    21,   205,    11,     9,\n-      63,    65,    27,    28,    54,    64,    21,    16,    19,    59,\n-      67,    42,    43,    44,    67,    69,    32,    69,    10,    69,\n-      51,    52,    53,    54,    55,    56,    57,    70,    21,    54,\n-      31,    70,    64,    41,    59,    32,    71,    64,    35,    36,\n-      69,    69,     3,    69,    69,    42,    43,    44,    45,    46,\n-      47,    48,    49,    50,    51,    52,    53,    54,    55,    56,\n-      57,     3,    30,    37,    82,    42,    43,    44,   193,   103,\n-     180,   131,    68,    70,    51,    52,    53,    54,    55,    56,\n-      57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,    -1,\n-      -1,    -1,    -1,    70,    51,    52,    53,    54,    55,    56,\n-      57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,    -1,\n-      -1,    -1,    -1,    70,    51,    52,    53,    54,    55,    56,\n-      57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,    -1,\n-      -1,    -1,    -1,    70,    51,    52,    53,    54,    55,    56,\n-      57,    -1,    -1,    42,    43,    44,    -1,    -1,    -1,    -1,\n-      -1,    68,    51,    52,    53,    54,    55,    56,    57,    -1,\n-      -1,    42,    43,    44,    -1,    -1,    -1,    -1,    -1,    68,\n-      51,    52,    53,    54,    55,    56,    57,    -1,    32,    -1,\n-      -1,    35,    36,    -1,    -1,    -1,    -1,    68,    42,    43,\n-      44,    45,    46,    47,    48,    49,    50,    51,    52,    53,\n-      54,    55,    56,    57,    42,    43,    44,    -1,    -1,    -1,\n+     117,   118,   119,   120,    38,    39,    10,   124,    10,    11,\n+      12,    13,    14,    69,    16,    17,    18,    19,    64,    21,\n+      54,    40,    41,    40,    41,    27,    28,    29,    30,    20,\n+      21,    33,    22,    23,    24,    25,    38,    39,    70,    71,\n+       0,     1,   140,   141,     4,     5,     6,     4,     5,     6,\n+       8,    70,    54,    70,   176,    65,    58,    59,    55,    56,\n+      57,    11,    10,   180,    12,    13,    14,    69,    16,    17,\n+      18,    19,   189,    21,     3,    40,    41,    37,     9,    27,\n+      28,    29,    30,    70,    71,   202,    10,    65,    12,    13,\n+      14,    64,    16,    17,    18,    19,    63,    21,    40,    41,\n+      16,   199,    19,    27,    28,    67,    54,    21,   206,    32,\n+      69,    59,    67,    42,    43,    44,    53,    54,    55,    56,\n+      57,    69,    51,    52,    53,    54,    55,    56,    57,    69,\n+      54,    70,    10,    21,    31,    59,    32,    70,    64,    35,\n+      36,    71,    41,    64,    69,    69,    42,    43,    44,    45,\n+      46,    47,    48,    49,    50,    51,    52,    53,    54,    55,\n+      56,    57,    69,    69,     3,     3,    42,    43,    44,    30,\n+      37,    82,   181,   194,    70,    51,    52,    53,    54,    55,\n+      56,    57,    68,   103,    -1,   132,    42,    43,    44,    -1,\n+      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,\n+      56,    57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,\n+      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,\n+      56,    57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,\n+      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,\n+      56,    57,    -1,    -1,    42,    43,    44,    -1,    -1,    -1,\n+      -1,    -1,    68,    51,    52,    53,    54,    55,    56,    57,\n+      -1,    -1,    42,    43,    44,    -1,    -1,    -1,    -1,    -1,\n+      68,    51,    52,    53,    54,    55,    56,    57,    -1,    32,\n+      -1,    -1,    35,    36,    -1,    -1,    -1,    -1,    68,    42,\n+      43,    44,    45,    46,    47,    48,    49,    50,    51,    52,\n+      53,    54,    55,    56,    57,    42,    43,    44,    -1,    -1,\n+      -1,    -1,    -1,    -1,    51,    52,    53,    54,    55,    56,\n+      57,    43,    44,    -1,    -1,    -1,    -1,    -1,    -1,    51,\n+      52,    53,    54,    55,    56,    57,    44,    -1,    -1,    -1,\n       -1,    -1,    -1,    51,    52,    53,    54,    55,    56,    57,\n-      43,    44,    -1,    -1,    -1,    -1,    -1,    -1,    51,    52,\n-      53,    54,    55,    56,    57,    44,    -1,    -1,    -1,    -1,\n-      -1,    -1,    51,    52,    53,    54,    55,    56,    57\n+      51,    52,    53,    54,    55,    56,    57\n };\n \n   /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing\n@@ -862,14 +862,14 @@ static const yytype_uint8 yystos[] =\n       40,    41,    32,    35,    36,    42,    43,    44,    45,    46,\n       47,    48,    49,    50,    51,    52,    53,    54,    55,    56,\n       57,    91,    91,   112,    69,   105,   112,   112,   112,   112,\n-      10,    32,    70,    70,    10,   112,    94,    95,    98,   103,\n-     102,    34,    69,   107,    96,   112,   112,   112,   112,   112,\n+       1,    10,    32,    70,    70,    10,   112,    94,    95,    98,\n+     103,   102,    34,    69,   107,    96,   112,   112,   112,   112,\n      112,   112,   112,   112,   112,   112,   112,   112,   112,   112,\n-     112,   112,    22,    23,    24,    25,    92,   112,    68,    68,\n-      70,    31,   107,    68,    70,    71,    97,    97,   108,     3,\n-      99,    64,    98,    11,    15,   109,   110,   112,    69,   104,\n-     105,   101,    70,    71,    70,   106,   112,    64,    69,   110,\n-      70,    71,   100,    97,   112,    69,    70,    97,    70\n+     112,   112,   112,    22,    23,    24,    25,    92,   112,    68,\n+      68,    70,    31,   107,    68,    70,    71,    97,    97,   108,\n+       3,    99,    64,    98,    11,    15,   109,   110,   112,    69,\n+     104,   105,   101,    70,    71,    70,   106,   112,    64,    69,\n+     110,    70,    71,   100,    97,   112,    69,    70,    97,    70\n };\n \n   /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */\n@@ -881,13 +881,13 @@ static const yytype_uint8 yyr1[] =\n       86,    86,    87,    87,    89,    88,    90,    88,    88,    91,\n       91,    92,    92,    92,    92,    93,    93,    93,    93,    94,\n       94,    95,    95,    96,    97,    98,    98,    98,    98,    98,\n-      98,    98,    99,   100,    98,   101,    98,    98,    98,   102,\n-      98,   103,    98,    98,    98,    98,    98,    98,    98,    98,\n-      98,   104,   104,   105,   106,   106,   108,   107,   107,   109,\n-     109,   110,   110,   111,   111,   111,   112,   112,   112,   112,\n+      98,    98,    98,    99,   100,    98,   101,    98,    98,    98,\n+     102,    98,   103,    98,    98,    98,    98,    98,    98,    98,\n+      98,    98,   104,   104,   105,   106,   106,   108,   107,   107,\n+     109,   109,   110,   110,   111,   111,   111,   112,   112,   112,\n      112,   112,   112,   112,   112,   112,   112,   112,   112,   112,\n      112,   112,   112,   112,   112,   112,   112,   112,   112,   112,\n-     112,   112\n+     112,   112,   112\n };\n \n   /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */\n@@ -899,13 +899,13 @@ static const yytype_uint8 yyr2[] =\n        3,     3,     1,     2,     0,     5,     0,     5,     3,     0,\n        2,     1,     1,     1,     1,     1,     3,     4,     4,     0,\n        1,     1,     3,     1,     1,     1,     1,     3,     3,     1,\n-       3,     3,     0,     0,    11,     0,     9,     3,     2,     0,\n-       4,     0,     4,     3,     3,     3,     3,     3,     3,     1,\n-       3,     3,     1,     5,     1,     3,     0,     4,     1,     1,\n-       3,     1,     1,     1,     1,     1,     3,     1,     1,     4,\n-       1,     1,     1,     1,     4,     1,     4,     1,     1,     2,\n-       3,     3,     3,     3,     3,     3,     3,     3,     2,     3,\n-       3,     1\n+       3,     3,     3,     0,     0,    11,     0,     9,     3,     2,\n+       0,     4,     0,     4,     3,     3,     3,     3,     3,     3,\n+       1,     3,     3,     1,     5,     1,     3,     0,     4,     1,\n+       1,     3,     1,     1,     1,     1,     1,     3,     1,     1,\n+       4,     1,     1,     1,     1,     4,     1,     4,     1,     1,\n+       2,     3,     3,     3,     3,     3,     3,     3,     3,     2,\n+       3,     3,     1\n };\n \n \n@@ -2586,6 +2586,15 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n   case 62:\n #line 1019 \""grammar.y\"" /* yacc.c:1646  */\n+    {\n+        compiler->loop_depth--;\n+        compiler->loop_identifier[compiler->loop_depth] = NULL;\n+      }\n+#line 2594 \""grammar.c\"" /* yacc.c:1646  */\n+    break;\n+\n+  case 63:\n+#line 1024 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         int var_index;\n \n@@ -2615,11 +2624,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 2619 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2628 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 63:\n-#line 1049 \""grammar.y\"" /* yacc.c:1646  */\n+  case 64:\n+#line 1054 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n         uint8_t* addr;\n@@ -2654,11 +2663,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);\n         compiler->loop_depth++;\n       }\n-#line 2658 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2667 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 64:\n-#line 1084 \""grammar.y\"" /* yacc.c:1646  */\n+  case 65:\n+#line 1089 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         int mem_offset;\n \n@@ -2737,11 +2746,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2741 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2750 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 65:\n-#line 1163 \""grammar.y\"" /* yacc.c:1646  */\n+  case 66:\n+#line 1168 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n         uint8_t* addr;\n@@ -2771,11 +2780,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         compiler->loop_identifier[compiler->loop_depth] = NULL;\n         compiler->loop_depth++;\n       }\n-#line 2775 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2784 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 66:\n-#line 1193 \""grammar.y\"" /* yacc.c:1646  */\n+  case 67:\n+#line 1198 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         int mem_offset;\n \n@@ -2824,31 +2833,31 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n \n       }\n-#line 2828 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2837 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 67:\n-#line 1242 \""grammar.y\"" /* yacc.c:1646  */\n+  case 68:\n+#line 1247 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         yr_parser_emit(yyscanner, OP_OF, NULL);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2838 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2847 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 68:\n-#line 1248 \""grammar.y\"" /* yacc.c:1646  */\n+  case 69:\n+#line 1253 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         yr_parser_emit(yyscanner, OP_NOT, NULL);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2848 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2857 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 69:\n-#line 1254 \""grammar.y\"" /* yacc.c:1646  */\n+  case 70:\n+#line 1259 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         void* jmp_destination_addr;\n@@ -2874,11 +2883,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         fixup->next = compiler->fixup_stack_head;\n         compiler->fixup_stack_head = fixup;\n       }\n-#line 2878 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2887 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 70:\n-#line 1280 \""grammar.y\"" /* yacc.c:1646  */\n+  case 71:\n+#line 1285 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         uint8_t* and_addr;\n@@ -2914,11 +2923,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2918 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2927 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 71:\n-#line 1316 \""grammar.y\"" /* yacc.c:1646  */\n+  case 72:\n+#line 1321 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         void* jmp_destination_addr;\n@@ -2943,11 +2952,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         fixup->next = compiler->fixup_stack_head;\n         compiler->fixup_stack_head = fixup;\n       }\n-#line 2947 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2956 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 72:\n-#line 1341 \""grammar.y\"" /* yacc.c:1646  */\n+  case 73:\n+#line 1346 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         YR_FIXUP* fixup;\n         uint8_t* or_addr;\n@@ -2983,11 +2992,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2987 \""grammar.c\"" /* yacc.c:1646  */\n+#line 2996 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 73:\n-#line 1377 \""grammar.y\"" /* yacc.c:1646  */\n+  case 74:\n+#line 1382 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \""<\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -2996,11 +3005,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 3000 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3009 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 74:\n-#line 1386 \""grammar.y\"" /* yacc.c:1646  */\n+  case 75:\n+#line 1391 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"">\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3009,11 +3018,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 3013 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3022 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 75:\n-#line 1395 \""grammar.y\"" /* yacc.c:1646  */\n+  case 76:\n+#line 1400 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \""<=\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3022,11 +3031,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 3026 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3035 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 76:\n-#line 1404 \""grammar.y\"" /* yacc.c:1646  */\n+  case 77:\n+#line 1409 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"">=\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3035,11 +3044,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 3039 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3048 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 77:\n-#line 1413 \""grammar.y\"" /* yacc.c:1646  */\n+  case 78:\n+#line 1418 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \""==\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3048,11 +3057,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 3052 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3061 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 78:\n-#line 1422 \""grammar.y\"" /* yacc.c:1646  */\n+  case 79:\n+#line 1427 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \""!=\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3061,39 +3070,39 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 3065 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3074 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 79:\n-#line 1431 \""grammar.y\"" /* yacc.c:1646  */\n+  case 80:\n+#line 1436 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[0].expression);\n       }\n-#line 3073 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3082 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 80:\n-#line 1435 \""grammar.y\"" /* yacc.c:1646  */\n+  case 81:\n+#line 1440 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[-1].expression);\n       }\n-#line 3081 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3090 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 81:\n-#line 1442 \""grammar.y\"" /* yacc.c:1646  */\n+  case 82:\n+#line 1447 \""grammar.y\"" /* yacc.c:1646  */\n     { (yyval.integer) = INTEGER_SET_ENUMERATION; }\n-#line 3087 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3096 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 82:\n-#line 1443 \""grammar.y\"" /* yacc.c:1646  */\n+  case 83:\n+#line 1448 \""grammar.y\"" /* yacc.c:1646  */\n     { (yyval.integer) = INTEGER_SET_RANGE; }\n-#line 3093 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3102 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 83:\n-#line 1449 \""grammar.y\"" /* yacc.c:1646  */\n+  case 84:\n+#line 1454 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n@@ -3111,11 +3120,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3115 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3124 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 84:\n-#line 1471 \""grammar.y\"" /* yacc.c:1646  */\n+  case 85:\n+#line 1476 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n@@ -3127,11 +3136,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3131 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3140 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 85:\n-#line 1483 \""grammar.y\"" /* yacc.c:1646  */\n+  case 86:\n+#line 1488 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n@@ -3142,77 +3151,77 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3146 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3155 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 86:\n-#line 1498 \""grammar.y\"" /* yacc.c:1646  */\n+  case 87:\n+#line 1503 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         // Push end-of-list marker\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n       }\n-#line 3155 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3164 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 88:\n-#line 1504 \""grammar.y\"" /* yacc.c:1646  */\n+  case 89:\n+#line 1509 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n         yr_parser_emit_pushes_for_strings(yyscanner, \""$*\"");\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3166 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3175 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 91:\n-#line 1521 \""grammar.y\"" /* yacc.c:1646  */\n+  case 92:\n+#line 1526 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n         yr_free((yyvsp[0].c_string));\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3177 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3186 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 92:\n-#line 1528 \""grammar.y\"" /* yacc.c:1646  */\n+  case 93:\n+#line 1533 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n         yr_free((yyvsp[0].c_string));\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3188 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3197 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 94:\n-#line 1540 \""grammar.y\"" /* yacc.c:1646  */\n+  case 95:\n+#line 1545 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n       }\n-#line 3196 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3205 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 95:\n-#line 1544 \""grammar.y\"" /* yacc.c:1646  */\n+  case 96:\n+#line 1549 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);\n       }\n-#line 3204 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3213 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 96:\n-#line 1552 \""grammar.y\"" /* yacc.c:1646  */\n+  case 97:\n+#line 1557 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[-1].expression);\n       }\n-#line 3212 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3221 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 97:\n-#line 1556 \""grammar.y\"" /* yacc.c:1646  */\n+  case 98:\n+#line 1561 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit(\n             yyscanner, OP_FILESIZE, NULL);\n@@ -3222,11 +3231,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3226 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3235 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 98:\n-#line 1566 \""grammar.y\"" /* yacc.c:1646  */\n+  case 99:\n+#line 1571 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         yywarning(yyscanner,\n             \""Using deprecated \\\""entrypoint\\\"" keyword. Use the \\\""entry_point\\\"" \""\n@@ -3240,11 +3249,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3244 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3253 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 99:\n-#line 1580 \""grammar.y\"" /* yacc.c:1646  */\n+  case 100:\n+#line 1585 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, \""intXXXX or uintXXXX\"");\n \n@@ -3260,11 +3269,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3264 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3273 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 100:\n-#line 1596 \""grammar.y\"" /* yacc.c:1646  */\n+  case 101:\n+#line 1601 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);\n@@ -3274,11 +3283,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = (yyvsp[0].integer);\n       }\n-#line 3278 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3287 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 101:\n-#line 1606 \""grammar.y\"" /* yacc.c:1646  */\n+  case 102:\n+#line 1611 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg_double(\n             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);\n@@ -3287,11 +3296,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n       }\n-#line 3291 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3300 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 102:\n-#line 1615 \""grammar.y\"" /* yacc.c:1646  */\n+  case 103:\n+#line 1620 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         SIZED_STRING* sized_string;\n \n@@ -3316,11 +3325,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_STRING;\n         (yyval.expression).value.sized_string = sized_string;\n       }\n-#line 3320 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3329 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 103:\n-#line 1640 \""grammar.y\"" /* yacc.c:1646  */\n+  case 104:\n+#line 1645 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);\n@@ -3332,11 +3341,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3336 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3345 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 104:\n-#line 1652 \""grammar.y\"" /* yacc.c:1646  */\n+  case 105:\n+#line 1657 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);\n@@ -3348,11 +3357,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3352 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3361 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 105:\n-#line 1664 \""grammar.y\"" /* yacc.c:1646  */\n+  case 106:\n+#line 1669 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n@@ -3368,11 +3377,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3372 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3381 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 106:\n-#line 1680 \""grammar.y\"" /* yacc.c:1646  */\n+  case 107:\n+#line 1685 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);\n@@ -3384,11 +3393,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3388 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3397 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 107:\n-#line 1692 \""grammar.y\"" /* yacc.c:1646  */\n+  case 108:\n+#line 1697 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n@@ -3404,11 +3413,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3408 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3417 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 108:\n-#line 1708 \""grammar.y\"" /* yacc.c:1646  */\n+  case 109:\n+#line 1713 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier\n         {\n@@ -3453,11 +3462,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3457 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3466 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 109:\n-#line 1753 \""grammar.y\"" /* yacc.c:1646  */\n+  case 110:\n+#line 1758 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, \""-\"");\n \n@@ -3476,11 +3485,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3480 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3489 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 110:\n-#line 1772 \""grammar.y\"" /* yacc.c:1646  */\n+  case 111:\n+#line 1777 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \""+\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3498,11 +3507,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n-#line 3502 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3511 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 111:\n-#line 1790 \""grammar.y\"" /* yacc.c:1646  */\n+  case 112:\n+#line 1795 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \""-\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3520,11 +3529,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n-#line 3524 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3533 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 112:\n-#line 1808 \""grammar.y\"" /* yacc.c:1646  */\n+  case 113:\n+#line 1813 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \""*\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3542,11 +3551,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n-#line 3546 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3555 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 113:\n-#line 1826 \""grammar.y\"" /* yacc.c:1646  */\n+  case 114:\n+#line 1831 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \""\\\\\"", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3572,11 +3581,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n-#line 3576 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3585 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 114:\n-#line 1852 \""grammar.y\"" /* yacc.c:1646  */\n+  case 115:\n+#line 1857 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \""%\"");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \""%\"");\n@@ -3594,11 +3603,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n           ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n         }\n       }\n-#line 3598 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3607 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 115:\n-#line 1870 \""grammar.y\"" /* yacc.c:1646  */\n+  case 116:\n+#line 1875 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \""^\"");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \""^\"");\n@@ -3608,11 +3617,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n-#line 3612 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3621 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 116:\n-#line 1880 \""grammar.y\"" /* yacc.c:1646  */\n+  case 117:\n+#line 1885 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \""^\"");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \""^\"");\n@@ -3622,11 +3631,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n-#line 3626 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3635 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 117:\n-#line 1890 \""grammar.y\"" /* yacc.c:1646  */\n+  case 118:\n+#line 1895 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \""|\"");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \""|\"");\n@@ -3636,11 +3645,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n-#line 3640 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3649 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 118:\n-#line 1900 \""grammar.y\"" /* yacc.c:1646  */\n+  case 119:\n+#line 1905 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \""~\"");\n \n@@ -3650,11 +3659,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\n             UNDEFINED : ~((yyvsp[0].expression).value.integer);\n       }\n-#line 3654 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3663 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 119:\n-#line 1910 \""grammar.y\"" /* yacc.c:1646  */\n+  case 120:\n+#line 1915 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \""<<\"");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \""<<\"");\n@@ -3664,11 +3673,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n-#line 3668 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3677 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 120:\n-#line 1920 \""grammar.y\"" /* yacc.c:1646  */\n+  case 121:\n+#line 1925 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"">>\"");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"">>\"");\n@@ -3678,19 +3687,19 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n-#line 3682 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3691 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n-  case 121:\n-#line 1930 \""grammar.y\"" /* yacc.c:1646  */\n+  case 122:\n+#line 1935 \""grammar.y\"" /* yacc.c:1646  */\n     {\n         (yyval.expression) = (yyvsp[0].expression);\n       }\n-#line 3690 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3699 \""grammar.c\"" /* yacc.c:1646  */\n     break;\n \n \n-#line 3694 \""grammar.c\"" /* yacc.c:1646  */\n+#line 3703 \""grammar.c\"" /* yacc.c:1646  */\n       default: break;\n     }\n   /* User semantic actions sometimes alter yychar, and that requires\n@@ -3918,5 +3927,5 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n #endif\n   return yyresult;\n }\n-#line 1935 \""grammar.y\"" /* yacc.c:1906  */\n+#line 1940 \""grammar.y\"" /* yacc.c:1906  */\n ""}<_**next**_>{""sha"": ""446d37410e0aa33e663f2547406d353290f213a4"", ""filename"": ""libyara/grammar.y"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/VirusTotal/yara/blob/890c3f850293176c0e996a602ffa88b315f4e98f/libyara/grammar.y"", ""raw_url"": ""https://github.com/VirusTotal/yara/raw/890c3f850293176c0e996a602ffa88b315f4e98f/libyara/grammar.y"", ""contents_url"": ""https://api.github.com/repos/VirusTotal/yara/contents/libyara/grammar.y?ref=890c3f850293176c0e996a602ffa88b315f4e98f"", ""patch"": ""@@ -1015,6 +1015,11 @@ expression\n \n         $$.type = EXPRESSION_TYPE_BOOLEAN;\n       }\n+    | _FOR_ for_expression error\n+      {\n+        compiler->loop_depth--;\n+        compiler->loop_identifier[compiler->loop_depth] = NULL;\n+      }\n     | _FOR_ for_expression _IDENTIFIER_ _IN_\n       {\n         int var_index;""}","yyparse (void *yyscanner, YR_COMPILER* compiler)
{
/* The lookahead symbol.  */
int yychar;


/* The semantic value of the lookahead symbol.  */
/* Default value used for initialization, for pacifying older GCCs
   or non-GCC compilers.  */
YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);

    /* Number of syntax errors so far.  */
    int yynerrs;

    int yystate;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus;

    /* The stacks and their tools:
       'yyss': related to states.
       'yyvs': related to semantic values.

       Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* The state stack.  */
    yytype_int16 yyssa[YYINITDEPTH];
    yytype_int16 *yyss;
    yytype_int16 *yyssp;

    /* The semantic value stack.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs;
    YYSTYPE *yyvsp;

    YYSIZE_T yystacksize;

  int yyn;
  int yyresult;
  /* Lookahead token as an internal (translated) token number.  */
  int yytoken = 0;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;

#if YYERROR_VERBOSE
  /* Buffer for error messages, and its allocated size.  */
  char yymsgbuf[128];
  char *yymsg = yymsgbuf;
  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
#endif

#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  yyssp = yyss = yyssa;
  yyvsp = yyvs = yyvsa;
  yystacksize = YYINITDEPTH;

  YYDPRINTF ((stderr, ""Starting parse\n""));

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY; /* Cause a token to be read.  */
  goto yysetstate;

/*------------------------------------------------------------.
| yynewstate -- Push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
 yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;

 yysetstate:
  *yyssp = yystate;

  if (yyss + yystacksize - 1 <= yyssp)
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYSIZE_T yysize = yyssp - yyss + 1;

#ifdef yyoverflow
      {
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &'s don't force the real ones into
           memory.  */
        YYSTYPE *yyvs1 = yyvs;
        yytype_int16 *yyss1 = yyss;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_(""memory exhausted""),
                    &yyss1, yysize * sizeof (*yyssp),
                    &yyvs1, yysize * sizeof (*yyvsp),
                    &yystacksize);

        yyss = yyss1;
        yyvs = yyvs1;
      }
#else /* no yyoverflow */
# ifndef YYSTACK_RELOCATE
      goto yyexhaustedlab;
# else
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
        goto yyexhaustedlab;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
        yystacksize = YYMAXDEPTH;

      {
        yytype_int16 *yyss1 = yyss;
        union yyalloc *yyptr =
          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
        if (! yyptr)
          goto yyexhaustedlab;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
#  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
          YYSTACK_FREE (yyss1);
      }
# endif
#endif /* no yyoverflow */

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;

      YYDPRINTF ((stderr, ""Stack size increased to %lu\n"",
                  (unsigned long int) yystacksize));

      if (yyss + yystacksize - 1 <= yyssp)
        YYABORT;
    }

  YYDPRINTF ((stderr, ""Entering state %d\n"", yystate));

  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;

/*-----------.
| yybackup.  |
`-----------*/
yybackup:

  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, ""Reading a token: ""));
      yychar = yylex (&yylval, yyscanner, compiler);
    }

  if (yychar <= YYEOF)
    {
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, ""Now at end of input.\n""));
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT (""Next token is"", yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT (""Shifting"", yytoken, &yylval, &yylloc);

  /* Discard the shifted token.  */
  yychar = YYEMPTY;

  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- Do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
        case 8:
#line 230 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));

        yr_free((yyvsp[0].sized_string));

        ERROR_IF(result != ERROR_SUCCESS);
      }
#line 1661 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 9:
#line 242 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(
            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));

        ERROR_IF(rule == NULL);

        (yyval.rule) = rule;
      }
#line 1674 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 10:
#line 251 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1

        rule->tags = (yyvsp[-3].c_string);
        rule->metas = (yyvsp[-1].meta);
        rule->strings = (yyvsp[0].string);
      }
#line 1686 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 11:
#line 259 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-7].rule); // rule created in phase 1

        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(
            yyscanner, rule);

        yr_free((yyvsp[-8].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1701 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 12:
#line 274 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = NULL;
      }
#line 1709 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 13:
#line 278 ""grammar.y"" /* yacc.c:1646  */
    {

        YR_META null_meta;

        memset(&null_meta, 0xFF, sizeof(YR_META));
        null_meta.type = META_TYPE_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->metas_arena,
            &null_meta,
            sizeof(YR_META),
            NULL);

        (yyval.meta) = (yyvsp[0].meta);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1736 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 14:
#line 305 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = NULL;
      }
#line 1744 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 15:
#line 309 ""grammar.y"" /* yacc.c:1646  */
    {

        YR_STRING null_string;

        memset(&null_string, 0xFF, sizeof(YR_STRING));
        null_string.g_flags = STRING_GFLAGS_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->strings_arena,
            &null_string,
            sizeof(YR_STRING),
            NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.string) = (yyvsp[0].string);
      }
#line 1771 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 17:
#line 340 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0;  }
#line 1777 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 18:
#line 341 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 1783 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 19:
#line 346 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
#line 1789 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 20:
#line 347 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
#line 1795 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 21:
#line 353 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = NULL;
      }
#line 1803 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 22:
#line 357 ""grammar.y"" /* yacc.c:1646  */
    {

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, """", NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[0].c_string);
      }
#line 1821 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 23:
#line 375 ""grammar.y"" /* yacc.c:1646  */
    {
        char* identifier;

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = identifier;
      }
#line 1838 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 24:
#line 388 ""grammar.y"" /* yacc.c:1646  */
    {
        char* tag_name = (yyvsp[-1].c_string);
        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;

        while (tag_length > 0)
        {
          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
          {
            yr_compiler_set_error_extra_info(compiler, tag_name);
            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;
            break;
          }

          tag_name = (char*) yr_arena_next_address(
              yyget_extra(yyscanner)->sz_arena,
              tag_name,
              tag_length + 1);

          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        }

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_arena_write_string(
              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-1].c_string);
      }
#line 1874 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 25:
#line 424 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[0].meta); }
#line 1880 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 26:
#line 425 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[-1].meta); }
#line 1886 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 27:
#line 431 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);

        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_STRING,
            (yyvsp[-2].c_string),
            sized_string->c_string,
            0);

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1906 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 28:
#line 447 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-2].c_string),
            NULL,
            (yyvsp[0].integer));

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1923 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 29:
#line 460 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-3].c_string),
            NULL,
            -(yyvsp[0].integer));

        yr_free((yyvsp[-3].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1940 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 30:
#line 473 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            TRUE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1957 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 31:
#line 486 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            FALSE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1974 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 32:
#line 502 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[0].string); }
#line 1980 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 33:
#line 503 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[-1].string); }
#line 1986 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 34:
#line 509 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 1994 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 35:
#line 513 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);
        compiler->error_line = 0;
      }
#line 2009 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 36:
#line 524 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 2017 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 37:
#line 528 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);

        compiler->error_line = 0;
      }
#line 2033 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 38:
#line 540 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.string) == NULL);
      }
#line 2047 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 39:
#line 553 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0; }
#line 2053 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 40:
#line 554 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 2059 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 41:
#line 559 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_WIDE; }
#line 2065 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 42:
#line 560 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_ASCII; }
#line 2071 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 43:
#line 561 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
#line 2077 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 44:
#line 562 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
#line 2083 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 45:
#line 568 ""grammar.y"" /* yacc.c:1646  */
    {
        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));

        if (var_index >= 0)
        {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner,
              OP_PUSH_M,
              LOOP_LOCAL_VARS * var_index,
              NULL,
              NULL);

          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
          (yyval.expression).identifier = compiler->loop_identifier[var_index];
        }
        else
        {

          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
              compiler->objects_table, (yyvsp[0].c_string), NULL);

          if (object == NULL)
          {
            char* ns = compiler->current_namespace->name;

            object = (YR_OBJECT*) yr_hash_table_lookup(
                compiler->objects_table, (yyvsp[0].c_string), ns);
          }

          if (object != NULL)
          {
            char* id;

            compiler->last_result = yr_arena_write_string(
                compiler->sz_arena, (yyvsp[0].c_string), &id);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_LOAD,
                  id,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = object;
            (yyval.expression).identifier = object->identifier;
          }
          else
          {
            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
                compiler->rules_table,
                (yyvsp[0].c_string),
                compiler->current_namespace->name);

            if (rule != NULL)
            {
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_PUSH_RULE,
                  rule,
                  NULL,
                  NULL);

              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
              (yyval.expression).value.integer = UNDEFINED;
              (yyval.expression).identifier = rule->identifier;
            }
            else
            {
              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;
            }
          }
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2172 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 46:
#line 653 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT* field = NULL;

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
        {
          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));

          if (field != NULL)
          {
            char* ident;

            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[0].c_string), &ident);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_FIELD,
                  ident,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = field;
            (yyval.expression).identifier = field->identifier;
          }
          else
          {
            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
            compiler->last_result = ERROR_INVALID_FIELD_NAME;
          }
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-2].expression).identifier);

          compiler->last_result = ERROR_NOT_A_STRUCTURE;
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2222 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 47:
#line 699 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_ARRAY* array;
        YR_OBJECT_DICTIONARY* dict;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""array indexes must be of integer type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_INDEX_ARRAY, NULL);

          array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = array->prototype_item;
          (yyval.expression).identifier = array->identifier;
        }
        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""dictionary keys must be of string type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_LOOKUP_DICT, NULL);

          dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = dict->prototype_item;
          (yyval.expression).identifier = dict->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_INDEXABLE;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2283 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 48:
#line 757 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_FUNCTION* function;
        char* args_fmt;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
        {
          compiler->last_result = yr_parser_check_types(
              compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_parser_emit_with_arg_reloc(
                yyscanner,
                OP_CALL,
                args_fmt,
                NULL,
                NULL);

          function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = function->return_obj;
          (yyval.expression).identifier = function->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_A_FUNCTION;
        }

        yr_free((yyvsp[-1].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2328 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 49:
#line 801 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = yr_strdup(""""); }
#line 2334 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 50:
#line 802 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = (yyvsp[0].c_string); }
#line 2340 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 51:
#line 807 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);

        switch((yyvsp[0].expression).type)
        {
          case EXPRESSION_TYPE_INTEGER:
            strlcpy((yyval.c_string), ""i"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_FLOAT:
            strlcpy((yyval.c_string), ""f"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_BOOLEAN:
            strlcpy((yyval.c_string), ""b"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_STRING:
            strlcpy((yyval.c_string), ""s"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_REGEXP:
            strlcpy((yyval.c_string), ""r"", MAX_FUNCTION_ARGS);
            break;
        }

        ERROR_IF((yyval.c_string) == NULL);
      }
#line 2369 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 52:
#line 832 ""grammar.y"" /* yacc.c:1646  */
    {
        if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)
        {
          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;
        }
        else
        {
          switch((yyvsp[0].expression).type)
          {
            case EXPRESSION_TYPE_INTEGER:
              strlcat((yyvsp[-2].c_string), ""i"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_FLOAT:
              strlcat((yyvsp[-2].c_string), ""f"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_BOOLEAN:
              strlcat((yyvsp[-2].c_string), ""b"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_STRING:
              strlcat((yyvsp[-2].c_string), ""s"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_REGEXP:
              strlcat((yyvsp[-2].c_string), ""r"", MAX_FUNCTION_ARGS);
              break;
          }
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-2].c_string);
      }
#line 2405 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 53:
#line 868 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        RE* re;
        RE_ERROR error;

        int re_flags = 0;

        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
          re_flags |= RE_FLAGS_NO_CASE;

        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
          re_flags |= RE_FLAGS_DOT_ALL;

        compiler->last_result = yr_re_compile(
            sized_string->c_string,
            re_flags,
            compiler->re_code_arena,
            &re,
            &error);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)
          yr_compiler_set_error_extra_info(compiler, error.message);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              re->root_node->forward_code,
              NULL,
              NULL);

        yr_re_destroy(re);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
      }
#line 2451 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 54:
#line 914 ""grammar.y"" /* yacc.c:1646  */
    {
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
        {
          if ((yyvsp[0].expression).value.sized_string != NULL)
          {
            yywarning(yyscanner,
              ""Using literal string \""%s\"" in a boolean operation."",
              (yyvsp[0].expression).value.sized_string->c_string);
          }

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_STR_TO_BOOL, NULL);

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2474 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 55:
#line 936 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 1, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2487 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 56:
#line 945 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 0, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2500 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 57:
#line 954 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""matches"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, ""matches"");

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit(
              yyscanner,
              OP_MATCHES,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2519 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 58:
#line 969 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""contains"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, ""contains"");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_CONTAINS, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2535 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 59:
#line 981 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_string_identifier(
            yyscanner,
            (yyvsp[0].c_string),
            OP_FOUND,
            UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2553 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 60:
#line 995 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""at"");

        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2570 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 61:
#line 1008 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2585 ""grammar.c"" /* yacc.c:1646  */
    break;
 
   case 62:
 #line 1019 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->loop_depth--;
        compiler->loop_identifier[compiler->loop_depth] = NULL;
      }
#line 2594 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 63:
#line 1024 ""grammar.y"" /* yacc.c:1646  */
     {
         int var_index;
 
        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        var_index = yr_parser_lookup_loop_variable(
            yyscanner, (yyvsp[-1].c_string));

        if (var_index >= 0)
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-1].c_string));

          compiler->last_result = \
              ERROR_DUPLICATED_LOOP_IDENTIFIER;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 2628 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 64:
#line 1054 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        }
        else // INTEGER_SET_RANGE
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        }

        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
         compiler->loop_depth++;
       }
#line 2667 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 65:
#line 1089 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;


        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JNUNDEF,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);
        }
        else // INTEGER_SET_RANGE
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);

          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JLE,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);

          yr_parser_emit(yyscanner, OP_POP, NULL);
          yr_parser_emit(yyscanner, OP_POP, NULL);
        }

        yr_parser_emit(yyscanner, OP_POP, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

        compiler->loop_identifier[compiler->loop_depth] = NULL;
        yr_free((yyvsp[-8].c_string));
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2750 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 66:
#line 1168 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        if (compiler->loop_for_of_mem_offset != -1)
          compiler->last_result = \
            ERROR_NESTED_FOR_OF_LOOP;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_POP_M, mem_offset, &addr, NULL);

        compiler->loop_for_of_mem_offset = mem_offset;
        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = NULL;
         compiler->loop_depth++;
       }
#line 2784 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 67:
#line 1198 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        compiler->loop_for_of_mem_offset = -1;

        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;


        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JNUNDEF,
            compiler->loop_address[compiler->loop_depth],
            NULL,
            NULL);

        yr_parser_emit(yyscanner, OP_POP, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
 
       }
#line 2837 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 68:
#line 1247 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_OF, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2847 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 69:
#line 1253 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_NOT, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2857 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 70:
#line 1259 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JFALSE,
            0,          // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2887 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 71:
#line 1285 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* and_addr;


        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);


        fixup = compiler->fixup_stack_head;


        *(void**)(fixup->address) = (void*)(and_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2927 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 72:
#line 1321 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JTRUE,
            0,         // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2956 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 73:
#line 1346 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* or_addr;


        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);


        fixup = compiler->fixup_stack_head;


        *(void**)(fixup->address) = (void*)(or_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2996 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 74:
#line 1382 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3009 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 75:
#line 1391 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3022 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 76:
#line 1400 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3035 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 77:
#line 1409 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3048 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 78:
#line 1418 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""=="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3061 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 79:
#line 1427 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""!="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3074 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 80:
#line 1436 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3082 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 81:
#line 1440 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3090 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 82:
#line 1447 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_ENUMERATION; }
#line 3096 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 83:
#line 1448 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_RANGE; }
#line 3102 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 84:
#line 1454 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's lower bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }

        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's upper bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3124 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 85:
#line 1476 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;

        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3140 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 86:
#line 1488 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3155 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 87:
#line 1503 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3164 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 89:
#line 1509 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
         yr_parser_emit_pushes_for_strings(yyscanner, ""$*"");
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3175 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 92:
#line 1526 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3186 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 93:
#line 1533 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3197 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 95:
#line 1545 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3205 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 96:
#line 1549 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
       }
#line 3213 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 97:
#line 1557 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3221 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 98:
#line 1561 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_FILESIZE, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3235 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 99:
#line 1571 ""grammar.y"" /* yacc.c:1646  */
     {
         yywarning(yyscanner,
             ""Using deprecated \""entrypoint\"" keyword. Use the \""entry_point\"" ""
            ""function from PE module instead."");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_ENTRYPOINT, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3253 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 100:
#line 1585 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, ""intXXXX or uintXXXX"");
 

        compiler->last_result = yr_parser_emit(
            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3273 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 101:
#line 1601 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = (yyvsp[0].integer);
       }
#line 3287 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 102:
#line 1611 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg_double(
             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
       }
#line 3300 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 103:
#line 1620 ""grammar.y"" /* yacc.c:1646  */
     {
         SIZED_STRING* sized_string;
 
        compiler->last_result = yr_arena_write_data(
            compiler->sz_arena,
            (yyvsp[0].sized_string),
            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
            (void**) &sized_string);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              sized_string,
              NULL,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_STRING;
         (yyval.expression).value.sized_string = sized_string;
       }
#line 3329 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 104:
#line 1645 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3345 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 105:
#line 1657 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3361 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 106:
#line 1669 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3381 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 107:
#line 1685 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3397 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 108:
#line 1697 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3417 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 109:
#line 1713 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier
         {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        {
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
        {
          compiler->last_result = yr_parser_emit(
              yyscanner, OP_OBJ_VALUE, NULL);

          switch((yyvsp[0].expression).value.object->type)
          {
            case OBJECT_TYPE_INTEGER:
              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
              (yyval.expression).value.integer = UNDEFINED;
              break;
            case OBJECT_TYPE_FLOAT:
              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
              break;
            case OBJECT_TYPE_STRING:
              (yyval.expression).type = EXPRESSION_TYPE_STRING;
              (yyval.expression).value.sized_string = NULL;
              break;
            default:
              yr_compiler_set_error_extra_info_fmt(
                  compiler,
                  ""wrong usage of identifier \""%s\"""",
                  (yyvsp[0].expression).identifier);
              compiler->last_result = ERROR_WRONG_TYPE;
          }
        }
        else
        {
          assert(FALSE);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3466 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 110:
#line 1758 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, ""-"");
 
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
              UNDEFINED : -((yyvsp[0].expression).value.integer);
          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3489 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 111:
#line 1777 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""+"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3511 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 112:
#line 1795 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""-"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3533 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 113:
#line 1813 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""*"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3555 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 114:
#line 1831 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""\\"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          if ((yyvsp[0].expression).value.integer != 0)
          {
            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          }
          else
          {
            compiler->last_result = ERROR_DIVISION_BY_ZERO;
            ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          }
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3585 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 115:
#line 1857 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""%"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""%"");

        yr_parser_emit(yyscanner, OP_MOD, NULL);

        if ((yyvsp[0].expression).value.integer != 0)
        {
          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
          compiler->last_result = ERROR_DIVISION_BY_ZERO;
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         }
       }
#line 3607 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 116:
#line 1875 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3621 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 117:
#line 1885 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3635 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 118:
#line 1895 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""|"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""|"");

        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3649 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 119:
#line 1905 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""~"");
 
        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
             UNDEFINED : ~((yyvsp[0].expression).value.integer);
       }
#line 3663 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 120:
#line 1915 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""<<"");

        yr_parser_emit(yyscanner, OP_SHL, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3677 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 121:
#line 1925 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "">>"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "">>"");

        yr_parser_emit(yyscanner, OP_SHR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3691 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 122:
#line 1935 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3699 ""grammar.c"" /* yacc.c:1646  */
     break;
 
 
#line 3703 ""grammar.c"" /* yacc.c:1646  */
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT (""-> $$ ="", yyr1[yyn], &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;

  /* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTOKENS];

  goto yynewstate;


/*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);

  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (yyscanner, compiler, YY_(""syntax error""));
#else
# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                        yyssp, yytoken)
      {
        char const *yymsgp = YY_(""syntax error"");
        int yysyntax_error_status;
        yysyntax_error_status = YYSYNTAX_ERROR;
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == 1)
          {
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
            if (!yymsg)
              {
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = 2;
              }
            else
              {
                yysyntax_error_status = YYSYNTAX_ERROR;
                yymsgp = yymsg;
              }
          }
        yyerror (yyscanner, compiler, yymsgp);
        if (yysyntax_error_status == 2)
          goto yyexhaustedlab;
      }
# undef YYSYNTAX_ERROR
#endif
    }



  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar <= YYEOF)
        {
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        }
      else
        {
          yydestruct (""Error: discarding"",
                      yytoken, &yylval, yyscanner, compiler);
          yychar = YYEMPTY;
        }
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        {
          yyn += YYTERROR;
          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
            {
              yyn = yytable[yyn];
              if (0 < yyn)
                break;
            }
        }

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;


      yydestruct (""Error: popping"",
                  yystos[yystate], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END


  /* Shift the error token.  */
  YY_SYMBOL_PRINT (""Shifting"", yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#if !defined yyoverflow || YYERROR_VERBOSE
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (yyscanner, compiler, YY_(""memory exhausted""));
  yyresult = 2;
  /* Fall through.  */
#endif

yyreturn:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct (""Cleanup: discarding lookahead"",
                  yytoken, &yylval, yyscanner, compiler);
    }
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct (""Cleanup: popping"",
                  yystos[*yyssp], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
 #endif
   return yyresult;
 }
","yyparse (void *yyscanner, YR_COMPILER* compiler)
{
/* The lookahead symbol.  */
int yychar;


/* The semantic value of the lookahead symbol.  */
/* Default value used for initialization, for pacifying older GCCs
   or non-GCC compilers.  */
YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);

    /* Number of syntax errors so far.  */
    int yynerrs;

    int yystate;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus;

    /* The stacks and their tools:
       'yyss': related to states.
       'yyvs': related to semantic values.

       Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* The state stack.  */
    yytype_int16 yyssa[YYINITDEPTH];
    yytype_int16 *yyss;
    yytype_int16 *yyssp;

    /* The semantic value stack.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs;
    YYSTYPE *yyvsp;

    YYSIZE_T yystacksize;

  int yyn;
  int yyresult;
  /* Lookahead token as an internal (translated) token number.  */
  int yytoken = 0;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;

#if YYERROR_VERBOSE
  /* Buffer for error messages, and its allocated size.  */
  char yymsgbuf[128];
  char *yymsg = yymsgbuf;
  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
#endif

#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  yyssp = yyss = yyssa;
  yyvsp = yyvs = yyvsa;
  yystacksize = YYINITDEPTH;

  YYDPRINTF ((stderr, ""Starting parse\n""));

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY; /* Cause a token to be read.  */
  goto yysetstate;

/*------------------------------------------------------------.
| yynewstate -- Push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
 yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;

 yysetstate:
  *yyssp = yystate;

  if (yyss + yystacksize - 1 <= yyssp)
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYSIZE_T yysize = yyssp - yyss + 1;

#ifdef yyoverflow
      {
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &'s don't force the real ones into
           memory.  */
        YYSTYPE *yyvs1 = yyvs;
        yytype_int16 *yyss1 = yyss;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_(""memory exhausted""),
                    &yyss1, yysize * sizeof (*yyssp),
                    &yyvs1, yysize * sizeof (*yyvsp),
                    &yystacksize);

        yyss = yyss1;
        yyvs = yyvs1;
      }
#else /* no yyoverflow */
# ifndef YYSTACK_RELOCATE
      goto yyexhaustedlab;
# else
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
        goto yyexhaustedlab;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
        yystacksize = YYMAXDEPTH;

      {
        yytype_int16 *yyss1 = yyss;
        union yyalloc *yyptr =
          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
        if (! yyptr)
          goto yyexhaustedlab;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
#  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
          YYSTACK_FREE (yyss1);
      }
# endif
#endif /* no yyoverflow */

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;

      YYDPRINTF ((stderr, ""Stack size increased to %lu\n"",
                  (unsigned long int) yystacksize));

      if (yyss + yystacksize - 1 <= yyssp)
        YYABORT;
    }

  YYDPRINTF ((stderr, ""Entering state %d\n"", yystate));

  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;

/*-----------.
| yybackup.  |
`-----------*/
yybackup:

  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, ""Reading a token: ""));
      yychar = yylex (&yylval, yyscanner, compiler);
    }

  if (yychar <= YYEOF)
    {
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, ""Now at end of input.\n""));
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT (""Next token is"", yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT (""Shifting"", yytoken, &yylval, &yylloc);

  /* Discard the shifted token.  */
  yychar = YYEMPTY;

  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- Do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
        case 8:
#line 230 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));

        yr_free((yyvsp[0].sized_string));

        ERROR_IF(result != ERROR_SUCCESS);
      }
#line 1661 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 9:
#line 242 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(
            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));

        ERROR_IF(rule == NULL);

        (yyval.rule) = rule;
      }
#line 1674 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 10:
#line 251 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1

        rule->tags = (yyvsp[-3].c_string);
        rule->metas = (yyvsp[-1].meta);
        rule->strings = (yyvsp[0].string);
      }
#line 1686 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 11:
#line 259 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-7].rule); // rule created in phase 1

        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(
            yyscanner, rule);

        yr_free((yyvsp[-8].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1701 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 12:
#line 274 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = NULL;
      }
#line 1709 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 13:
#line 278 ""grammar.y"" /* yacc.c:1646  */
    {

        YR_META null_meta;

        memset(&null_meta, 0xFF, sizeof(YR_META));
        null_meta.type = META_TYPE_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->metas_arena,
            &null_meta,
            sizeof(YR_META),
            NULL);

        (yyval.meta) = (yyvsp[0].meta);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1736 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 14:
#line 305 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = NULL;
      }
#line 1744 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 15:
#line 309 ""grammar.y"" /* yacc.c:1646  */
    {

        YR_STRING null_string;

        memset(&null_string, 0xFF, sizeof(YR_STRING));
        null_string.g_flags = STRING_GFLAGS_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->strings_arena,
            &null_string,
            sizeof(YR_STRING),
            NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.string) = (yyvsp[0].string);
      }
#line 1771 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 17:
#line 340 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0;  }
#line 1777 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 18:
#line 341 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 1783 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 19:
#line 346 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
#line 1789 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 20:
#line 347 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
#line 1795 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 21:
#line 353 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = NULL;
      }
#line 1803 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 22:
#line 357 ""grammar.y"" /* yacc.c:1646  */
    {

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, """", NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[0].c_string);
      }
#line 1821 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 23:
#line 375 ""grammar.y"" /* yacc.c:1646  */
    {
        char* identifier;

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = identifier;
      }
#line 1838 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 24:
#line 388 ""grammar.y"" /* yacc.c:1646  */
    {
        char* tag_name = (yyvsp[-1].c_string);
        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;

        while (tag_length > 0)
        {
          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
          {
            yr_compiler_set_error_extra_info(compiler, tag_name);
            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;
            break;
          }

          tag_name = (char*) yr_arena_next_address(
              yyget_extra(yyscanner)->sz_arena,
              tag_name,
              tag_length + 1);

          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        }

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_arena_write_string(
              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-1].c_string);
      }
#line 1874 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 25:
#line 424 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[0].meta); }
#line 1880 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 26:
#line 425 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[-1].meta); }
#line 1886 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 27:
#line 431 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);

        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_STRING,
            (yyvsp[-2].c_string),
            sized_string->c_string,
            0);

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1906 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 28:
#line 447 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-2].c_string),
            NULL,
            (yyvsp[0].integer));

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1923 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 29:
#line 460 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-3].c_string),
            NULL,
            -(yyvsp[0].integer));

        yr_free((yyvsp[-3].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1940 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 30:
#line 473 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            TRUE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1957 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 31:
#line 486 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            FALSE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1974 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 32:
#line 502 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[0].string); }
#line 1980 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 33:
#line 503 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[-1].string); }
#line 1986 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 34:
#line 509 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 1994 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 35:
#line 513 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);
        compiler->error_line = 0;
      }
#line 2009 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 36:
#line 524 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 2017 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 37:
#line 528 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);

        compiler->error_line = 0;
      }
#line 2033 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 38:
#line 540 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.string) == NULL);
      }
#line 2047 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 39:
#line 553 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0; }
#line 2053 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 40:
#line 554 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 2059 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 41:
#line 559 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_WIDE; }
#line 2065 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 42:
#line 560 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_ASCII; }
#line 2071 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 43:
#line 561 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
#line 2077 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 44:
#line 562 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
#line 2083 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 45:
#line 568 ""grammar.y"" /* yacc.c:1646  */
    {
        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));

        if (var_index >= 0)
        {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner,
              OP_PUSH_M,
              LOOP_LOCAL_VARS * var_index,
              NULL,
              NULL);

          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
          (yyval.expression).identifier = compiler->loop_identifier[var_index];
        }
        else
        {

          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
              compiler->objects_table, (yyvsp[0].c_string), NULL);

          if (object == NULL)
          {
            char* ns = compiler->current_namespace->name;

            object = (YR_OBJECT*) yr_hash_table_lookup(
                compiler->objects_table, (yyvsp[0].c_string), ns);
          }

          if (object != NULL)
          {
            char* id;

            compiler->last_result = yr_arena_write_string(
                compiler->sz_arena, (yyvsp[0].c_string), &id);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_LOAD,
                  id,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = object;
            (yyval.expression).identifier = object->identifier;
          }
          else
          {
            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
                compiler->rules_table,
                (yyvsp[0].c_string),
                compiler->current_namespace->name);

            if (rule != NULL)
            {
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_PUSH_RULE,
                  rule,
                  NULL,
                  NULL);

              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
              (yyval.expression).value.integer = UNDEFINED;
              (yyval.expression).identifier = rule->identifier;
            }
            else
            {
              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;
            }
          }
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2172 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 46:
#line 653 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT* field = NULL;

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
        {
          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));

          if (field != NULL)
          {
            char* ident;

            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[0].c_string), &ident);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_FIELD,
                  ident,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = field;
            (yyval.expression).identifier = field->identifier;
          }
          else
          {
            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
            compiler->last_result = ERROR_INVALID_FIELD_NAME;
          }
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-2].expression).identifier);

          compiler->last_result = ERROR_NOT_A_STRUCTURE;
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2222 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 47:
#line 699 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_ARRAY* array;
        YR_OBJECT_DICTIONARY* dict;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""array indexes must be of integer type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_INDEX_ARRAY, NULL);

          array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = array->prototype_item;
          (yyval.expression).identifier = array->identifier;
        }
        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""dictionary keys must be of string type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_LOOKUP_DICT, NULL);

          dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = dict->prototype_item;
          (yyval.expression).identifier = dict->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_INDEXABLE;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2283 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 48:
#line 757 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_FUNCTION* function;
        char* args_fmt;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
        {
          compiler->last_result = yr_parser_check_types(
              compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_parser_emit_with_arg_reloc(
                yyscanner,
                OP_CALL,
                args_fmt,
                NULL,
                NULL);

          function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = function->return_obj;
          (yyval.expression).identifier = function->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_A_FUNCTION;
        }

        yr_free((yyvsp[-1].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2328 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 49:
#line 801 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = yr_strdup(""""); }
#line 2334 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 50:
#line 802 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = (yyvsp[0].c_string); }
#line 2340 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 51:
#line 807 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);

        switch((yyvsp[0].expression).type)
        {
          case EXPRESSION_TYPE_INTEGER:
            strlcpy((yyval.c_string), ""i"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_FLOAT:
            strlcpy((yyval.c_string), ""f"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_BOOLEAN:
            strlcpy((yyval.c_string), ""b"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_STRING:
            strlcpy((yyval.c_string), ""s"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_REGEXP:
            strlcpy((yyval.c_string), ""r"", MAX_FUNCTION_ARGS);
            break;
        }

        ERROR_IF((yyval.c_string) == NULL);
      }
#line 2369 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 52:
#line 832 ""grammar.y"" /* yacc.c:1646  */
    {
        if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)
        {
          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;
        }
        else
        {
          switch((yyvsp[0].expression).type)
          {
            case EXPRESSION_TYPE_INTEGER:
              strlcat((yyvsp[-2].c_string), ""i"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_FLOAT:
              strlcat((yyvsp[-2].c_string), ""f"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_BOOLEAN:
              strlcat((yyvsp[-2].c_string), ""b"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_STRING:
              strlcat((yyvsp[-2].c_string), ""s"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_REGEXP:
              strlcat((yyvsp[-2].c_string), ""r"", MAX_FUNCTION_ARGS);
              break;
          }
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-2].c_string);
      }
#line 2405 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 53:
#line 868 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        RE* re;
        RE_ERROR error;

        int re_flags = 0;

        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
          re_flags |= RE_FLAGS_NO_CASE;

        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
          re_flags |= RE_FLAGS_DOT_ALL;

        compiler->last_result = yr_re_compile(
            sized_string->c_string,
            re_flags,
            compiler->re_code_arena,
            &re,
            &error);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)
          yr_compiler_set_error_extra_info(compiler, error.message);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              re->root_node->forward_code,
              NULL,
              NULL);

        yr_re_destroy(re);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
      }
#line 2451 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 54:
#line 914 ""grammar.y"" /* yacc.c:1646  */
    {
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
        {
          if ((yyvsp[0].expression).value.sized_string != NULL)
          {
            yywarning(yyscanner,
              ""Using literal string \""%s\"" in a boolean operation."",
              (yyvsp[0].expression).value.sized_string->c_string);
          }

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_STR_TO_BOOL, NULL);

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2474 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 55:
#line 936 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 1, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2487 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 56:
#line 945 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 0, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2500 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 57:
#line 954 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""matches"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, ""matches"");

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit(
              yyscanner,
              OP_MATCHES,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2519 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 58:
#line 969 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""contains"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, ""contains"");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_CONTAINS, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2535 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 59:
#line 981 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_string_identifier(
            yyscanner,
            (yyvsp[0].c_string),
            OP_FOUND,
            UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2553 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 60:
#line 995 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""at"");

        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2570 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 61:
#line 1008 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2585 ""grammar.c"" /* yacc.c:1646  */
    break;
 
   case 62:
 #line 1019 ""grammar.y"" /* yacc.c:1646  */
     {
         int var_index;
 
        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        var_index = yr_parser_lookup_loop_variable(
            yyscanner, (yyvsp[-1].c_string));

        if (var_index >= 0)
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-1].c_string));

          compiler->last_result = \
              ERROR_DUPLICATED_LOOP_IDENTIFIER;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 2619 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 63:
#line 1049 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        }
        else // INTEGER_SET_RANGE
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        }

        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
         compiler->loop_depth++;
       }
#line 2658 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 64:
#line 1084 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;


        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JNUNDEF,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);
        }
        else // INTEGER_SET_RANGE
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);

          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JLE,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);

          yr_parser_emit(yyscanner, OP_POP, NULL);
          yr_parser_emit(yyscanner, OP_POP, NULL);
        }

        yr_parser_emit(yyscanner, OP_POP, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

        compiler->loop_identifier[compiler->loop_depth] = NULL;
        yr_free((yyvsp[-8].c_string));
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2741 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 65:
#line 1163 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        if (compiler->loop_for_of_mem_offset != -1)
          compiler->last_result = \
            ERROR_NESTED_FOR_OF_LOOP;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_POP_M, mem_offset, &addr, NULL);

        compiler->loop_for_of_mem_offset = mem_offset;
        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = NULL;
         compiler->loop_depth++;
       }
#line 2775 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 66:
#line 1193 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        compiler->loop_for_of_mem_offset = -1;

        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;


        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JNUNDEF,
            compiler->loop_address[compiler->loop_depth],
            NULL,
            NULL);

        yr_parser_emit(yyscanner, OP_POP, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
 
       }
#line 2828 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 67:
#line 1242 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_OF, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2838 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 68:
#line 1248 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_NOT, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2848 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 69:
#line 1254 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JFALSE,
            0,          // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2878 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 70:
#line 1280 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* and_addr;


        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);


        fixup = compiler->fixup_stack_head;


        *(void**)(fixup->address) = (void*)(and_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2918 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 71:
#line 1316 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JTRUE,
            0,         // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2947 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 72:
#line 1341 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* or_addr;


        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);


        fixup = compiler->fixup_stack_head;


        *(void**)(fixup->address) = (void*)(or_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2987 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 73:
#line 1377 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3000 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 74:
#line 1386 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3013 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 75:
#line 1395 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3026 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 76:
#line 1404 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3039 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 77:
#line 1413 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""=="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3052 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 78:
#line 1422 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""!="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3065 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 79:
#line 1431 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3073 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 80:
#line 1435 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3081 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 81:
#line 1442 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_ENUMERATION; }
#line 3087 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 82:
#line 1443 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_RANGE; }
#line 3093 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 83:
#line 1449 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's lower bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }

        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's upper bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3115 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 84:
#line 1471 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;

        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3131 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 85:
#line 1483 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3146 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 86:
#line 1498 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3155 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 88:
#line 1504 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
         yr_parser_emit_pushes_for_strings(yyscanner, ""$*"");
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3166 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 91:
#line 1521 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3177 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 92:
#line 1528 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3188 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 94:
#line 1540 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3196 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 95:
#line 1544 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
       }
#line 3204 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 96:
#line 1552 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3212 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 97:
#line 1556 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_FILESIZE, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3226 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 98:
#line 1566 ""grammar.y"" /* yacc.c:1646  */
     {
         yywarning(yyscanner,
             ""Using deprecated \""entrypoint\"" keyword. Use the \""entry_point\"" ""
            ""function from PE module instead."");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_ENTRYPOINT, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3244 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 99:
#line 1580 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, ""intXXXX or uintXXXX"");
 

        compiler->last_result = yr_parser_emit(
            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3264 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 100:
#line 1596 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = (yyvsp[0].integer);
       }
#line 3278 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 101:
#line 1606 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg_double(
             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
       }
#line 3291 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 102:
#line 1615 ""grammar.y"" /* yacc.c:1646  */
     {
         SIZED_STRING* sized_string;
 
        compiler->last_result = yr_arena_write_data(
            compiler->sz_arena,
            (yyvsp[0].sized_string),
            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
            (void**) &sized_string);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              sized_string,
              NULL,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_STRING;
         (yyval.expression).value.sized_string = sized_string;
       }
#line 3320 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 103:
#line 1640 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3336 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 104:
#line 1652 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3352 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 105:
#line 1664 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3372 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 106:
#line 1680 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3388 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 107:
#line 1692 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3408 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 108:
#line 1708 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier
         {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        {
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
        {
          compiler->last_result = yr_parser_emit(
              yyscanner, OP_OBJ_VALUE, NULL);

          switch((yyvsp[0].expression).value.object->type)
          {
            case OBJECT_TYPE_INTEGER:
              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
              (yyval.expression).value.integer = UNDEFINED;
              break;
            case OBJECT_TYPE_FLOAT:
              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
              break;
            case OBJECT_TYPE_STRING:
              (yyval.expression).type = EXPRESSION_TYPE_STRING;
              (yyval.expression).value.sized_string = NULL;
              break;
            default:
              yr_compiler_set_error_extra_info_fmt(
                  compiler,
                  ""wrong usage of identifier \""%s\"""",
                  (yyvsp[0].expression).identifier);
              compiler->last_result = ERROR_WRONG_TYPE;
          }
        }
        else
        {
          assert(FALSE);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3457 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 109:
#line 1753 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, ""-"");
 
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
              UNDEFINED : -((yyvsp[0].expression).value.integer);
          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3480 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 110:
#line 1772 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""+"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3502 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 111:
#line 1790 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""-"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3524 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 112:
#line 1808 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""*"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3546 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 113:
#line 1826 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""\\"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          if ((yyvsp[0].expression).value.integer != 0)
          {
            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          }
          else
          {
            compiler->last_result = ERROR_DIVISION_BY_ZERO;
            ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          }
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3576 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 114:
#line 1852 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""%"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""%"");

        yr_parser_emit(yyscanner, OP_MOD, NULL);

        if ((yyvsp[0].expression).value.integer != 0)
        {
          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
          compiler->last_result = ERROR_DIVISION_BY_ZERO;
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         }
       }
#line 3598 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 115:
#line 1870 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3612 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 116:
#line 1880 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3626 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 117:
#line 1890 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""|"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""|"");

        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3640 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 118:
#line 1900 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""~"");
 
        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
             UNDEFINED : ~((yyvsp[0].expression).value.integer);
       }
#line 3654 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 119:
#line 1910 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""<<"");

        yr_parser_emit(yyscanner, OP_SHL, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3668 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 120:
#line 1920 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "">>"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "">>"");

        yr_parser_emit(yyscanner, OP_SHR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3682 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 121:
#line 1930 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3690 ""grammar.c"" /* yacc.c:1646  */
     break;
 
 
#line 3694 ""grammar.c"" /* yacc.c:1646  */
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT (""-> $$ ="", yyr1[yyn], &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;

  /* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTOKENS];

  goto yynewstate;


/*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);

  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (yyscanner, compiler, YY_(""syntax error""));
#else
# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                        yyssp, yytoken)
      {
        char const *yymsgp = YY_(""syntax error"");
        int yysyntax_error_status;
        yysyntax_error_status = YYSYNTAX_ERROR;
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == 1)
          {
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
            if (!yymsg)
              {
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = 2;
              }
            else
              {
                yysyntax_error_status = YYSYNTAX_ERROR;
                yymsgp = yymsg;
              }
          }
        yyerror (yyscanner, compiler, yymsgp);
        if (yysyntax_error_status == 2)
          goto yyexhaustedlab;
      }
# undef YYSYNTAX_ERROR
#endif
    }



  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar <= YYEOF)
        {
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        }
      else
        {
          yydestruct (""Error: discarding"",
                      yytoken, &yylval, yyscanner, compiler);
          yychar = YYEMPTY;
        }
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        {
          yyn += YYTERROR;
          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
            {
              yyn = yytable[yyn];
              if (0 < yyn)
                break;
            }
        }

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;


      yydestruct (""Error: popping"",
                  yystos[yystate], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END


  /* Shift the error token.  */
  YY_SYMBOL_PRINT (""Shifting"", yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#if !defined yyoverflow || YYERROR_VERBOSE
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (yyscanner, compiler, YY_(""memory exhausted""));
  yyresult = 2;
  /* Fall through.  */
#endif

yyreturn:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct (""Cleanup: discarding lookahead"",
                  yytoken, &yylval, yyscanner, compiler);
    }
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct (""Cleanup: popping"",
                  yystos[*yyssp], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
 #endif
   return yyresult;
 }
",C,"    {
        compiler->loop_depth--;
        compiler->loop_identifier[compiler->loop_depth] = NULL;
      }
#line 2594 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 63:
#line 1024 ""grammar.y"" /* yacc.c:1646  */
#line 2628 ""grammar.c"" /* yacc.c:1646  */
  case 64:
#line 1054 ""grammar.y"" /* yacc.c:1646  */
#line 2667 ""grammar.c"" /* yacc.c:1646  */
  case 65:
#line 1089 ""grammar.y"" /* yacc.c:1646  */
#line 2750 ""grammar.c"" /* yacc.c:1646  */
  case 66:
#line 1168 ""grammar.y"" /* yacc.c:1646  */
#line 2784 ""grammar.c"" /* yacc.c:1646  */
  case 67:
#line 1198 ""grammar.y"" /* yacc.c:1646  */
#line 2837 ""grammar.c"" /* yacc.c:1646  */
  case 68:
#line 1247 ""grammar.y"" /* yacc.c:1646  */
#line 2847 ""grammar.c"" /* yacc.c:1646  */
  case 69:
#line 1253 ""grammar.y"" /* yacc.c:1646  */
#line 2857 ""grammar.c"" /* yacc.c:1646  */
  case 70:
#line 1259 ""grammar.y"" /* yacc.c:1646  */
#line 2887 ""grammar.c"" /* yacc.c:1646  */
  case 71:
#line 1285 ""grammar.y"" /* yacc.c:1646  */
#line 2927 ""grammar.c"" /* yacc.c:1646  */
  case 72:
#line 1321 ""grammar.y"" /* yacc.c:1646  */
#line 2956 ""grammar.c"" /* yacc.c:1646  */
  case 73:
#line 1346 ""grammar.y"" /* yacc.c:1646  */
#line 2996 ""grammar.c"" /* yacc.c:1646  */
  case 74:
#line 1382 ""grammar.y"" /* yacc.c:1646  */
#line 3009 ""grammar.c"" /* yacc.c:1646  */
  case 75:
#line 1391 ""grammar.y"" /* yacc.c:1646  */
#line 3022 ""grammar.c"" /* yacc.c:1646  */
  case 76:
#line 1400 ""grammar.y"" /* yacc.c:1646  */
#line 3035 ""grammar.c"" /* yacc.c:1646  */
  case 77:
#line 1409 ""grammar.y"" /* yacc.c:1646  */
#line 3048 ""grammar.c"" /* yacc.c:1646  */
  case 78:
#line 1418 ""grammar.y"" /* yacc.c:1646  */
#line 3061 ""grammar.c"" /* yacc.c:1646  */
  case 79:
#line 1427 ""grammar.y"" /* yacc.c:1646  */
#line 3074 ""grammar.c"" /* yacc.c:1646  */
  case 80:
#line 1436 ""grammar.y"" /* yacc.c:1646  */
#line 3082 ""grammar.c"" /* yacc.c:1646  */
  case 81:
#line 1440 ""grammar.y"" /* yacc.c:1646  */
#line 3090 ""grammar.c"" /* yacc.c:1646  */
  case 82:
#line 1447 ""grammar.y"" /* yacc.c:1646  */
#line 3096 ""grammar.c"" /* yacc.c:1646  */
  case 83:
#line 1448 ""grammar.y"" /* yacc.c:1646  */
#line 3102 ""grammar.c"" /* yacc.c:1646  */
  case 84:
#line 1454 ""grammar.y"" /* yacc.c:1646  */
#line 3124 ""grammar.c"" /* yacc.c:1646  */
  case 85:
#line 1476 ""grammar.y"" /* yacc.c:1646  */
#line 3140 ""grammar.c"" /* yacc.c:1646  */
  case 86:
#line 1488 ""grammar.y"" /* yacc.c:1646  */
#line 3155 ""grammar.c"" /* yacc.c:1646  */
  case 87:
#line 1503 ""grammar.y"" /* yacc.c:1646  */
#line 3164 ""grammar.c"" /* yacc.c:1646  */
  case 89:
#line 1509 ""grammar.y"" /* yacc.c:1646  */
#line 3175 ""grammar.c"" /* yacc.c:1646  */
  case 92:
#line 1526 ""grammar.y"" /* yacc.c:1646  */
#line 3186 ""grammar.c"" /* yacc.c:1646  */
  case 93:
#line 1533 ""grammar.y"" /* yacc.c:1646  */
#line 3197 ""grammar.c"" /* yacc.c:1646  */
  case 95:
#line 1545 ""grammar.y"" /* yacc.c:1646  */
#line 3205 ""grammar.c"" /* yacc.c:1646  */
  case 96:
#line 1549 ""grammar.y"" /* yacc.c:1646  */
#line 3213 ""grammar.c"" /* yacc.c:1646  */
  case 97:
#line 1557 ""grammar.y"" /* yacc.c:1646  */
#line 3221 ""grammar.c"" /* yacc.c:1646  */
  case 98:
#line 1561 ""grammar.y"" /* yacc.c:1646  */
#line 3235 ""grammar.c"" /* yacc.c:1646  */
  case 99:
#line 1571 ""grammar.y"" /* yacc.c:1646  */
#line 3253 ""grammar.c"" /* yacc.c:1646  */
  case 100:
#line 1585 ""grammar.y"" /* yacc.c:1646  */
#line 3273 ""grammar.c"" /* yacc.c:1646  */
  case 101:
#line 1601 ""grammar.y"" /* yacc.c:1646  */
#line 3287 ""grammar.c"" /* yacc.c:1646  */
  case 102:
#line 1611 ""grammar.y"" /* yacc.c:1646  */
#line 3300 ""grammar.c"" /* yacc.c:1646  */
  case 103:
#line 1620 ""grammar.y"" /* yacc.c:1646  */
#line 3329 ""grammar.c"" /* yacc.c:1646  */
  case 104:
#line 1645 ""grammar.y"" /* yacc.c:1646  */
#line 3345 ""grammar.c"" /* yacc.c:1646  */
  case 105:
#line 1657 ""grammar.y"" /* yacc.c:1646  */
#line 3361 ""grammar.c"" /* yacc.c:1646  */
  case 106:
#line 1669 ""grammar.y"" /* yacc.c:1646  */
#line 3381 ""grammar.c"" /* yacc.c:1646  */
  case 107:
#line 1685 ""grammar.y"" /* yacc.c:1646  */
#line 3397 ""grammar.c"" /* yacc.c:1646  */
  case 108:
#line 1697 ""grammar.y"" /* yacc.c:1646  */
#line 3417 ""grammar.c"" /* yacc.c:1646  */
  case 109:
#line 1713 ""grammar.y"" /* yacc.c:1646  */
#line 3466 ""grammar.c"" /* yacc.c:1646  */
  case 110:
#line 1758 ""grammar.y"" /* yacc.c:1646  */
#line 3489 ""grammar.c"" /* yacc.c:1646  */
  case 111:
#line 1777 ""grammar.y"" /* yacc.c:1646  */
#line 3511 ""grammar.c"" /* yacc.c:1646  */
  case 112:
#line 1795 ""grammar.y"" /* yacc.c:1646  */
#line 3533 ""grammar.c"" /* yacc.c:1646  */
  case 113:
#line 1813 ""grammar.y"" /* yacc.c:1646  */
#line 3555 ""grammar.c"" /* yacc.c:1646  */
  case 114:
#line 1831 ""grammar.y"" /* yacc.c:1646  */
#line 3585 ""grammar.c"" /* yacc.c:1646  */
  case 115:
#line 1857 ""grammar.y"" /* yacc.c:1646  */
#line 3607 ""grammar.c"" /* yacc.c:1646  */
  case 116:
#line 1875 ""grammar.y"" /* yacc.c:1646  */
#line 3621 ""grammar.c"" /* yacc.c:1646  */
  case 117:
#line 1885 ""grammar.y"" /* yacc.c:1646  */
#line 3635 ""grammar.c"" /* yacc.c:1646  */
  case 118:
#line 1895 ""grammar.y"" /* yacc.c:1646  */
#line 3649 ""grammar.c"" /* yacc.c:1646  */
  case 119:
#line 1905 ""grammar.y"" /* yacc.c:1646  */
#line 3663 ""grammar.c"" /* yacc.c:1646  */
  case 120:
#line 1915 ""grammar.y"" /* yacc.c:1646  */
#line 3677 ""grammar.c"" /* yacc.c:1646  */
  case 121:
#line 1925 ""grammar.y"" /* yacc.c:1646  */
#line 3691 ""grammar.c"" /* yacc.c:1646  */
  case 122:
#line 1935 ""grammar.y"" /* yacc.c:1646  */
#line 3699 ""grammar.c"" /* yacc.c:1646  */
#line 3703 ""grammar.c"" /* yacc.c:1646  */
","#line 2619 ""grammar.c"" /* yacc.c:1646  */
  case 63:
#line 1049 ""grammar.y"" /* yacc.c:1646  */
#line 2658 ""grammar.c"" /* yacc.c:1646  */
  case 64:
#line 1084 ""grammar.y"" /* yacc.c:1646  */
#line 2741 ""grammar.c"" /* yacc.c:1646  */
  case 65:
#line 1163 ""grammar.y"" /* yacc.c:1646  */
#line 2775 ""grammar.c"" /* yacc.c:1646  */
  case 66:
#line 1193 ""grammar.y"" /* yacc.c:1646  */
#line 2828 ""grammar.c"" /* yacc.c:1646  */
  case 67:
#line 1242 ""grammar.y"" /* yacc.c:1646  */
#line 2838 ""grammar.c"" /* yacc.c:1646  */
  case 68:
#line 1248 ""grammar.y"" /* yacc.c:1646  */
#line 2848 ""grammar.c"" /* yacc.c:1646  */
  case 69:
#line 1254 ""grammar.y"" /* yacc.c:1646  */
#line 2878 ""grammar.c"" /* yacc.c:1646  */
  case 70:
#line 1280 ""grammar.y"" /* yacc.c:1646  */
#line 2918 ""grammar.c"" /* yacc.c:1646  */
  case 71:
#line 1316 ""grammar.y"" /* yacc.c:1646  */
#line 2947 ""grammar.c"" /* yacc.c:1646  */
  case 72:
#line 1341 ""grammar.y"" /* yacc.c:1646  */
#line 2987 ""grammar.c"" /* yacc.c:1646  */
  case 73:
#line 1377 ""grammar.y"" /* yacc.c:1646  */
#line 3000 ""grammar.c"" /* yacc.c:1646  */
  case 74:
#line 1386 ""grammar.y"" /* yacc.c:1646  */
#line 3013 ""grammar.c"" /* yacc.c:1646  */
  case 75:
#line 1395 ""grammar.y"" /* yacc.c:1646  */
#line 3026 ""grammar.c"" /* yacc.c:1646  */
  case 76:
#line 1404 ""grammar.y"" /* yacc.c:1646  */
#line 3039 ""grammar.c"" /* yacc.c:1646  */
  case 77:
#line 1413 ""grammar.y"" /* yacc.c:1646  */
#line 3052 ""grammar.c"" /* yacc.c:1646  */
  case 78:
#line 1422 ""grammar.y"" /* yacc.c:1646  */
#line 3065 ""grammar.c"" /* yacc.c:1646  */
  case 79:
#line 1431 ""grammar.y"" /* yacc.c:1646  */
#line 3073 ""grammar.c"" /* yacc.c:1646  */
  case 80:
#line 1435 ""grammar.y"" /* yacc.c:1646  */
#line 3081 ""grammar.c"" /* yacc.c:1646  */
  case 81:
#line 1442 ""grammar.y"" /* yacc.c:1646  */
#line 3087 ""grammar.c"" /* yacc.c:1646  */
  case 82:
#line 1443 ""grammar.y"" /* yacc.c:1646  */
#line 3093 ""grammar.c"" /* yacc.c:1646  */
  case 83:
#line 1449 ""grammar.y"" /* yacc.c:1646  */
#line 3115 ""grammar.c"" /* yacc.c:1646  */
  case 84:
#line 1471 ""grammar.y"" /* yacc.c:1646  */
#line 3131 ""grammar.c"" /* yacc.c:1646  */
  case 85:
#line 1483 ""grammar.y"" /* yacc.c:1646  */
#line 3146 ""grammar.c"" /* yacc.c:1646  */
  case 86:
#line 1498 ""grammar.y"" /* yacc.c:1646  */
#line 3155 ""grammar.c"" /* yacc.c:1646  */
  case 88:
#line 1504 ""grammar.y"" /* yacc.c:1646  */
#line 3166 ""grammar.c"" /* yacc.c:1646  */
  case 91:
#line 1521 ""grammar.y"" /* yacc.c:1646  */
#line 3177 ""grammar.c"" /* yacc.c:1646  */
  case 92:
#line 1528 ""grammar.y"" /* yacc.c:1646  */
#line 3188 ""grammar.c"" /* yacc.c:1646  */
  case 94:
#line 1540 ""grammar.y"" /* yacc.c:1646  */
#line 3196 ""grammar.c"" /* yacc.c:1646  */
  case 95:
#line 1544 ""grammar.y"" /* yacc.c:1646  */
#line 3204 ""grammar.c"" /* yacc.c:1646  */
  case 96:
#line 1552 ""grammar.y"" /* yacc.c:1646  */
#line 3212 ""grammar.c"" /* yacc.c:1646  */
  case 97:
#line 1556 ""grammar.y"" /* yacc.c:1646  */
#line 3226 ""grammar.c"" /* yacc.c:1646  */
  case 98:
#line 1566 ""grammar.y"" /* yacc.c:1646  */
#line 3244 ""grammar.c"" /* yacc.c:1646  */
  case 99:
#line 1580 ""grammar.y"" /* yacc.c:1646  */
#line 3264 ""grammar.c"" /* yacc.c:1646  */
  case 100:
#line 1596 ""grammar.y"" /* yacc.c:1646  */
#line 3278 ""grammar.c"" /* yacc.c:1646  */
  case 101:
#line 1606 ""grammar.y"" /* yacc.c:1646  */
#line 3291 ""grammar.c"" /* yacc.c:1646  */
  case 102:
#line 1615 ""grammar.y"" /* yacc.c:1646  */
#line 3320 ""grammar.c"" /* yacc.c:1646  */
  case 103:
#line 1640 ""grammar.y"" /* yacc.c:1646  */
#line 3336 ""grammar.c"" /* yacc.c:1646  */
  case 104:
#line 1652 ""grammar.y"" /* yacc.c:1646  */
#line 3352 ""grammar.c"" /* yacc.c:1646  */
  case 105:
#line 1664 ""grammar.y"" /* yacc.c:1646  */
#line 3372 ""grammar.c"" /* yacc.c:1646  */
  case 106:
#line 1680 ""grammar.y"" /* yacc.c:1646  */
#line 3388 ""grammar.c"" /* yacc.c:1646  */
  case 107:
#line 1692 ""grammar.y"" /* yacc.c:1646  */
#line 3408 ""grammar.c"" /* yacc.c:1646  */
  case 108:
#line 1708 ""grammar.y"" /* yacc.c:1646  */
#line 3457 ""grammar.c"" /* yacc.c:1646  */
  case 109:
#line 1753 ""grammar.y"" /* yacc.c:1646  */
#line 3480 ""grammar.c"" /* yacc.c:1646  */
  case 110:
#line 1772 ""grammar.y"" /* yacc.c:1646  */
#line 3502 ""grammar.c"" /* yacc.c:1646  */
  case 111:
#line 1790 ""grammar.y"" /* yacc.c:1646  */
#line 3524 ""grammar.c"" /* yacc.c:1646  */
  case 112:
#line 1808 ""grammar.y"" /* yacc.c:1646  */
#line 3546 ""grammar.c"" /* yacc.c:1646  */
  case 113:
#line 1826 ""grammar.y"" /* yacc.c:1646  */
#line 3576 ""grammar.c"" /* yacc.c:1646  */
  case 114:
#line 1852 ""grammar.y"" /* yacc.c:1646  */
#line 3598 ""grammar.c"" /* yacc.c:1646  */
  case 115:
#line 1870 ""grammar.y"" /* yacc.c:1646  */
#line 3612 ""grammar.c"" /* yacc.c:1646  */
  case 116:
#line 1880 ""grammar.y"" /* yacc.c:1646  */
#line 3626 ""grammar.c"" /* yacc.c:1646  */
  case 117:
#line 1890 ""grammar.y"" /* yacc.c:1646  */
#line 3640 ""grammar.c"" /* yacc.c:1646  */
  case 118:
#line 1900 ""grammar.y"" /* yacc.c:1646  */
#line 3654 ""grammar.c"" /* yacc.c:1646  */
  case 119:
#line 1910 ""grammar.y"" /* yacc.c:1646  */
#line 3668 ""grammar.c"" /* yacc.c:1646  */
  case 120:
#line 1920 ""grammar.y"" /* yacc.c:1646  */
#line 3682 ""grammar.c"" /* yacc.c:1646  */
  case 121:
#line 1930 ""grammar.y"" /* yacc.c:1646  */
#line 3690 ""grammar.c"" /* yacc.c:1646  */
#line 3694 ""grammar.c"" /* yacc.c:1646  */
",,"@@ -546,16 +546,16 @@ union yyalloc
 /* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  2
 /* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   408
+#define YYLAST   406
 
 /* YYNTOKENS -- Number of terminals.  */
 #define YYNTOKENS  72
 /* YYNNTS -- Number of nonterminals.  */
 #define YYNNTS  41
 /* YYNRULES -- Number of rules.  */
-#define YYNRULES  121
+#define YYNRULES  122
 /* YYNSTATES -- Number of states.  */
-#define YYNSTATES  209
+#define YYNSTATES  210
 
 /* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
    by yylex, with out-of-bounds checking.  */
@@ -612,13 +612,13 @@ static const yytype_uint16 yyrline[] =
      472,   485,   502,   503,   509,   508,   524,   523,   539,   553,
      554,   559,   560,   561,   562,   567,   652,   698,   756,   801,
      802,   806,   831,   867,   913,   935,   944,   953,   968,   980,
-     994,  1007,  1019,  1049,  1018,  1163,  1162,  1241,  1247,  1254,
-    1253,  1316,  1315,  1376,  1385,  1394,  1403,  1412,  1421,  1430,
-    1434,  1442,  1443,  1448,  1470,  1482,  1498,  1497,  1503,  1514,
-    1515,  1520,  1527,  1538,  1539,  1543,  1551,  1555,  1565,  1579,
-    1595,  1605,  1614,  1639,  1651,  1663,  1679,  1691,  1707,  1752,
-    1771,  1789,  1807,  1825,  1851,  1869,  1879,  1889,  1899,  1909,
-    1919,  1929
+     994,  1007,  1018,  1024,  1054,  1023,  1168,  1167,  1246,  1252,
+    1259,  1258,  1321,  1320,  1381,  1390,  1399,  1408,  1417,  1426,
+    1435,  1439,  1447,  1448,  1453,  1475,  1487,  1503,  1502,  1508,
+    1519,  1520,  1525,  1532,  1543,  1544,  1548,  1556,  1560,  1570,
+    1584,  1600,  1610,  1619,  1644,  1656,  1668,  1684,  1696,  1712,
+    1757,  1776,  1794,  1812,  1830,  1856,  1874,  1884,  1894,  1904,
+    1914,  1924,  1934
 };
 #endif
 
@@ -672,7 +672,7 @@ static const yytype_uint16 yytoknum[] =
 #define yypact_value_is_default(Yystate) \
   (!!((Yystate) == (-73)))
 
-#define YYTABLE_NINF -94
+#define YYTABLE_NINF -95
 
 #define yytable_value_is_error(Yytable_value) \
   0
@@ -681,27 +681,27 @@ static const yytype_uint16 yytoknum[] =
      STATE-NUM.  */
 static const yytype_int16 yypact[] =
 {
-     -73,    79,   -73,   -32,    -4,   -73,   -73,    94,   -73,   -73,
-     -73,   -73,    13,   -73,   -73,   -73,   -73,    -8,    72,     6,
-     -73,    78,   111,   -73,    61,   122,   123,    82,   -73,    90,
-     123,   -73,   147,   150,    16,   -73,    96,   147,   -73,   101,
-      97,   -73,   -73,   -73,   -73,   151,    53,   -73,    48,   -73,
-     -73,   -73,   149,   145,   -73,    -9,   -73,   103,   107,   -73,
-     -73,   106,   -73,   -73,   -73,   -73,   -73,   -73,   110,   -73,
-     -73,   135,    48,   135,    48,   -33,   -73,    64,   -73,   144,
-     306,   -73,   -73,   135,   108,   135,   135,   135,   135,    -7,
-     322,   -73,   -73,   -73,    64,   117,   163,   168,   135,    48,
-     -73,   -73,    -6,   167,   135,   135,   135,   135,   135,   135,
-     135,   135,   135,   135,   135,   135,   135,   135,   135,   135,
-     135,    86,    86,   322,   135,   -73,   243,   261,   183,   203,
-     159,    -6,   -73,   -73,   -73,   279,   121,   125,    95,    48,
-      48,   -73,   -73,   -73,   -73,   322,   337,   351,   -43,   322,
-     322,   322,   322,   322,   322,    40,    40,    58,    58,   -73,
-     -73,   -73,   -73,   -73,   -73,   -73,   -73,   129,   -73,   -73,
-     -73,   -73,   128,   -73,   -73,    48,   152,   -73,    15,   135,
-     131,   -73,    95,   -73,   -73,    71,   -73,   223,   135,   133,
-     -73,   132,   -73,    15,   -73,    73,   129,   -73,    48,   -73,
-     -73,   135,   134,    31,   322,    48,   -73,    49,   -73
+     -73,    90,   -73,   -32,   -10,   -73,   -73,    93,   -73,   -73,
+     -73,   -73,     1,   -73,   -73,   -73,   -73,   -49,     7,   -36,
+     -73,    20,    26,   -73,   -28,    92,    46,     4,   -73,    40,
+      46,   -73,   100,   119,    16,   -73,    72,   100,   -73,    77,
+      83,   -73,   -73,   -73,   -73,   134,    59,   -73,    48,   -73,
+     -73,   -73,   133,   136,   -73,   -18,   -73,    88,    95,   -73,
+     -73,    91,   -73,   -73,   -73,   -73,   -73,   -73,   102,   -73,
+     -73,   126,    48,   126,    48,   -44,   -73,    85,   -73,   127,
+     297,   -73,   -73,   126,   110,   126,   126,   126,   126,     2,
+     313,   -73,   -73,   -73,    85,   111,   154,   172,   126,    48,
+     -73,   -73,    -6,   162,   126,   126,   126,   126,   126,   126,
+     126,   126,   126,   126,   126,   126,   126,   126,   126,   126,
+     126,    60,    60,   313,   126,   -73,   234,   252,   174,   194,
+     -73,   153,    -6,   -73,   -73,   -73,   270,   117,   120,   108,
+      48,    48,   -73,   -73,   -73,   -73,   313,   328,   342,   349,
+     313,   313,   313,   313,   313,   313,   113,   113,    53,    53,
+     -73,   -73,   -73,   -73,   -73,   -73,   -73,   -73,   121,   -73,
+     -73,   -73,   -73,   124,   -73,   -73,    48,   151,   -73,    -1,
+     126,   125,   -73,   108,   -73,   -73,    18,   -73,   214,   126,
+     129,   -73,   143,   -73,    -1,   -73,    63,   121,   -73,    48,
+     -73,   -73,   126,   144,    31,   313,    48,   -73,    33,   -73
 };
 
   /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
@@ -714,31 +714,31 @@ static const yytype_uint8 yydefact[] =
       23,    22,    12,    24,     0,    14,     0,     0,    10,     0,
       13,    25,     0,     0,     0,    26,     0,    15,    32,     0,
        0,    28,    27,    30,    31,     0,    34,    33,     0,    11,
-      29,    38,     0,     0,    45,    59,   103,   105,   107,   100,
-     101,     0,   102,    53,    97,    98,    94,    95,     0,    55,
-      56,     0,     0,     0,     0,   108,   121,    16,    54,     0,
-      79,    39,    39,     0,     0,     0,     0,     0,     0,     0,
-      93,   109,    68,   118,     0,    54,    79,     0,     0,    49,
-      71,    69,     0,     0,     0,     0,     0,     0,     0,     0,
+      29,    38,     0,     0,    45,    59,   104,   106,   108,   101,
+     102,     0,   103,    53,    98,    99,    95,    96,     0,    55,
+      56,     0,     0,     0,     0,   109,   122,    16,    54,     0,
+      80,    39,    39,     0,     0,     0,     0,     0,     0,     0,
+      94,   110,    69,   119,     0,    54,    80,     0,     0,    49,
+      72,    70,     0,     0,     0,     0,     0,     0,     0,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
        0,    35,    37,    60,     0,    61,     0,     0,     0,     0,
-       0,     0,    80,    96,    46,     0,     0,    50,    51,     0,
-       0,    88,    86,    67,    57,    58,   117,   115,   116,    77,
-      78,    73,    75,    74,    76,   119,   120,   110,   111,   112,
-     113,   114,    42,    41,    43,    44,    40,     0,   104,   106,
-      99,    62,     0,    47,    48,     0,    72,    70,     0,     0,
-       0,    65,    52,    91,    92,     0,    89,     0,     0,     0,
-      82,     0,    87,     0,    83,     0,    84,    63,     0,    90,
-      81,     0,     0,     0,    85,     0,    66,     0,    64
+      62,     0,     0,    81,    97,    46,     0,     0,    50,    51,
+       0,     0,    89,    87,    68,    57,    58,   118,   116,   117,
+      78,    79,    74,    76,    75,    77,   120,   121,   111,   112,
+     113,   114,   115,    42,    41,    43,    44,    40,     0,   105,
+     107,   100,    63,     0,    47,    48,     0,    73,    71,     0,
+       0,     0,    66,    52,    92,    93,     0,    90,     0,     0,
+       0,    83,     0,    88,     0,    84,     0,    85,    64,     0,
+      91,    82,     0,     0,     0,    86,     0,    67,     0,    65
 };
 
   /* YYPGOTO[NTERM-NUM].  */
 static const yytype_int16 yypgoto[] =
 {
-     -73,   -73,   199,   218,   -73,   -73,   -73,   -73,   -73,   -73,
-     -73,   -73,   -73,   -73,   192,   -73,   186,   -73,   -73,   142,
-     -73,   -73,   -73,   -73,   126,   -48,   -72,   -73,   -73,   -73,
-     -73,   -73,   -73,    50,   -73,   100,   -73,   -73,    35,   164,
+     -73,   -73,   211,   212,   -73,   -73,   -73,   -73,   -73,   -73,
+     -73,   -73,   -73,   -73,   189,   -73,   183,   -73,   -73,   139,
+     -73,   -73,   -73,   -73,   130,   -48,   -72,   -73,   -73,   -73,
+     -73,   -73,   -73,    41,   -73,   103,   -73,   -73,    29,   164,
      -67
 };
 
@@ -747,8 +747,8 @@ static const yytype_int16 yydefgoto[] =
 {
       -1,     1,     5,     6,    17,    33,    25,    28,    40,     7,
       15,    19,    21,    30,    31,    37,    38,    52,    53,   121,
-     166,    75,   136,   137,    76,    94,    78,   180,   202,   191,
-     140,   139,   189,   125,   195,   143,   178,   185,   186,    79,
+     167,    75,   137,   138,    76,    94,    78,   181,   203,   192,
+     141,   140,   190,   125,   196,   144,   179,   186,   187,    79,
       80
 };
 
@@ -757,92 +757,92 @@ static const yytype_int16 yydefgoto[] =
      number is the opposite.  If YYTABLE_NINF, syntax error.  */
 static const yytype_int16 yytable[] =
 {
-      77,    90,    95,   130,    91,     4,    93,    96,   114,   115,
-     116,   117,   118,   119,   120,    11,   123,    83,   126,   127,
-     128,   129,    84,    16,    92,   131,   183,   138,   141,     8,
-     184,   135,    41,    97,    98,    42,    99,   145,   146,   147,
-     148,   149,   150,   151,   152,   153,   154,   155,   156,   157,
-     158,   159,   160,   161,    43,    44,    18,   167,    54,    55,
-      56,    57,    58,   142,    59,    60,    61,    62,    22,    63,
-      45,   100,   101,    51,   -36,    64,    65,    66,    67,     2,
-       3,    68,    20,   -17,   -17,   -17,    69,    70,    23,   100,
-     101,   176,   177,   116,   117,   118,   119,   120,    12,    13,
-      14,   206,    71,   182,   100,   101,    72,    73,   162,   163,
-     164,   165,   187,   118,   119,   120,     4,    74,    24,   208,
-      54,   196,    56,    57,    58,    26,    59,    60,    61,    62,
-      27,    63,   179,    29,   204,   -54,   -54,    64,    65,    66,
-      67,   192,   193,   200,   201,    54,    32,    56,    57,    58,
-     203,    59,    60,    61,    62,    34,    63,   207,    36,    39,
-      49,    46,    64,    65,    71,    48,    82,    50,    81,    73,
-      85,   105,   106,   107,    86,    87,   102,   124,   134,    88,
-     114,   115,   116,   117,   118,   119,   120,   132,    63,    71,
-     171,   174,   181,   101,    73,   -93,   175,   197,   103,   104,
-     188,   198,     9,   205,    88,   105,   106,   107,   108,   109,
-     110,   111,   112,   113,   114,   115,   116,   117,   118,   119,
-     120,    10,    35,    47,   122,   105,   106,   107,   199,   144,
-     190,   172,    89,   133,   114,   115,   116,   117,   118,   119,
-     120,     0,     0,     0,     0,   105,   106,   107,     0,     0,
-       0,     0,     0,   170,   114,   115,   116,   117,   118,   119,
-     120,     0,     0,     0,     0,   105,   106,   107,     0,     0,
-       0,     0,     0,   133,   114,   115,   116,   117,   118,   119,
-     120,     0,     0,     0,     0,   105,   106,   107,     0,     0,
-       0,     0,     0,   194,   114,   115,   116,   117,   118,   119,
-     120,     0,     0,   105,   106,   107,     0,     0,     0,     0,
-       0,   168,   114,   115,   116,   117,   118,   119,   120,     0,
-       0,   105,   106,   107,     0,     0,     0,     0,     0,   169,
-     114,   115,   116,   117,   118,   119,   120,     0,   -93,     0,
-       0,   103,   104,     0,     0,     0,     0,   173,   105,   106,
-     107,   108,   109,   110,   111,   112,   113,   114,   115,   116,
-     117,   118,   119,   120,   105,   106,   107,     0,     0,     0,
+      77,    90,    95,   130,    91,     4,    93,    96,    83,    11,
+     184,    16,   131,    84,   185,    18,   123,    20,   126,   127,
+     128,   129,    97,    98,    92,    99,    22,   139,   142,     8,
+      23,   136,    41,    24,   132,    42,    26,   146,   147,   148,
+     149,   150,   151,   152,   153,   154,   155,   156,   157,   158,
+     159,   160,   161,   162,    43,    44,    29,   168,    54,    55,
+      56,    57,    58,   143,    59,    60,    61,    62,    32,    63,
+      45,   100,   101,   100,   101,    64,    65,    66,    67,    51,
+     -36,    68,   163,   164,   165,   166,    69,    70,   193,   194,
+       2,     3,   177,   178,   -17,   -17,   -17,    12,    13,    14,
+      27,   207,    71,   209,   183,    34,    72,    73,   118,   119,
+     120,    36,    54,   188,    56,    57,    58,    74,    59,    60,
+      61,    62,   197,    63,   180,   100,   101,     4,    39,    64,
+      65,    66,    67,   201,   202,   205,    54,    46,    56,    57,
+      58,    48,    59,    60,    61,    62,    49,    63,   -54,   -54,
+      50,   204,    81,    64,    65,    85,    71,    82,   208,   102,
+      87,    73,    86,   105,   106,   107,   116,   117,   118,   119,
+     120,    88,   114,   115,   116,   117,   118,   119,   120,   124,
+      71,   133,   135,    63,   172,    73,   -94,   175,   182,   103,
+     104,   176,   101,   198,   189,    88,   105,   106,   107,   108,
+     109,   110,   111,   112,   113,   114,   115,   116,   117,   118,
+     119,   120,   199,   206,     9,    10,   105,   106,   107,    35,
+      47,   122,   191,   200,   134,   114,   115,   116,   117,   118,
+     119,   120,    89,   145,     0,   173,   105,   106,   107,     0,
+       0,     0,     0,     0,   171,   114,   115,   116,   117,   118,
+     119,   120,     0,     0,     0,     0,   105,   106,   107,     0,
+       0,     0,     0,     0,   134,   114,   115,   116,   117,   118,
+     119,   120,     0,     0,     0,     0,   105,   106,   107,     0,
+       0,     0,     0,     0,   195,   114,   115,   116,   117,   118,
+     119,   120,     0,     0,   105,   106,   107,     0,     0,     0,
+       0,     0,   169,   114,   115,   116,   117,   118,   119,   120,
+       0,     0,   105,   106,   107,     0,     0,     0,     0,     0,
+     170,   114,   115,   116,   117,   118,   119,   120,     0,   -94,
+       0,     0,   103,   104,     0,     0,     0,     0,   174,   105,
+     106,   107,   108,   109,   110,   111,   112,   113,   114,   115,
+     116,   117,   118,   119,   120,   105,   106,   107,     0,     0,
+       0,     0,     0,     0,   114,   115,   116,   117,   118,   119,
+     120,   106,   107,     0,     0,     0,     0,     0,     0,   114,
+     115,   116,   117,   118,   119,   120,   107,     0,     0,     0,
        0,     0,     0,   114,   115,   116,   117,   118,   119,   120,
-     106,   107,     0,     0,     0,     0,     0,     0,   114,   115,
-     116,   117,   118,   119,   120,   107,     0,     0,     0,     0,
-       0,     0,   114,   115,   116,   117,   118,   119,   120
+     114,   115,   116,   117,   118,   119,   120
 };
 
 static const yytype_int16 yycheck[] =
 {
-      48,    68,    74,    10,    71,    37,    73,    74,    51,    52,
-      53,    54,    55,    56,    57,    19,    83,    26,    85,    86,
-      87,    88,    31,    10,    72,    32,    11,    99,    34,    61,
-      15,    98,    16,    66,    67,    19,    69,   104,   105,   106,
+      48,    68,    74,     1,    71,    37,    73,    74,    26,    19,
+      11,    10,    10,    31,    15,    64,    83,    10,    85,    86,
+      87,    88,    66,    67,    72,    69,    62,    99,    34,    61,
+      10,    98,    16,     7,    32,    19,    64,   104,   105,   106,
      107,   108,   109,   110,   111,   112,   113,   114,   115,   116,
-     117,   118,   119,   120,    38,    39,    64,   124,    10,    11,
-      12,    13,    14,    69,    16,    17,    18,    19,    62,    21,
-      54,    40,    41,    20,    21,    27,    28,    29,    30,     0,
-       1,    33,    10,     4,     5,     6,    38,    39,    10,    40,
-      41,   139,   140,    53,    54,    55,    56,    57,     4,     5,
-       6,    70,    54,   175,    40,    41,    58,    59,    22,    23,
-      24,    25,   179,    55,    56,    57,    37,    69,     7,    70,
-      10,   188,    12,    13,    14,    64,    16,    17,    18,    19,
-       8,    21,     3,    10,   201,    40,    41,    27,    28,    29,
-      30,    70,    71,    70,    71,    10,    64,    12,    13,    14,
-     198,    16,    17,    18,    19,    65,    21,   205,    11,     9,
-      63,    65,    27,    28,    54,    64,    21,    16,    19,    59,
-      67,    42,    43,    44,    67,    69,    32,    69,    10,    69,
-      51,    52,    53,    54,    55,    56,    57,    70,    21,    54,
-      31,    70,    64,    41,    59,    32,    71,    64,    35,    36,
-      69,    69,     3,    69,    69,    42,    43,    44,    45,    46,
-      47,    48,    49,    50,    51,    52,    53,    54,    55,    56,
-      57,     3,    30,    37,    82,    42,    43,    44,   193,   103,
-     180,   131,    68,    70,    51,    52,    53,    54,    55,    56,
-      57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,    -1,
-      -1,    -1,    -1,    70,    51,    52,    53,    54,    55,    56,
-      57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,    -1,
-      -1,    -1,    -1,    70,    51,    52,    53,    54,    55,    56,
-      57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,    -1,
-      -1,    -1,    -1,    70,    51,    52,    53,    54,    55,    56,
-      57,    -1,    -1,    42,    43,    44,    -1,    -1,    -1,    -1,
-      -1,    68,    51,    52,    53,    54,    55,    56,    57,    -1,
-      -1,    42,    43,    44,    -1,    -1,    -1,    -1,    -1,    68,
-      51,    52,    53,    54,    55,    56,    57,    -1,    32,    -1,
-      -1,    35,    36,    -1,    -1,    -1,    -1,    68,    42,    43,
-      44,    45,    46,    47,    48,    49,    50,    51,    52,    53,
-      54,    55,    56,    57,    42,    43,    44,    -1,    -1,    -1,
+     117,   118,   119,   120,    38,    39,    10,   124,    10,    11,
+      12,    13,    14,    69,    16,    17,    18,    19,    64,    21,
+      54,    40,    41,    40,    41,    27,    28,    29,    30,    20,
+      21,    33,    22,    23,    24,    25,    38,    39,    70,    71,
+       0,     1,   140,   141,     4,     5,     6,     4,     5,     6,
+       8,    70,    54,    70,   176,    65,    58,    59,    55,    56,
+      57,    11,    10,   180,    12,    13,    14,    69,    16,    17,
+      18,    19,   189,    21,     3,    40,    41,    37,     9,    27,
+      28,    29,    30,    70,    71,   202,    10,    65,    12,    13,
+      14,    64,    16,    17,    18,    19,    63,    21,    40,    41,
+      16,   199,    19,    27,    28,    67,    54,    21,   206,    32,
+      69,    59,    67,    42,    43,    44,    53,    54,    55,    56,
+      57,    69,    51,    52,    53,    54,    55,    56,    57,    69,
+      54,    70,    10,    21,    31,    59,    32,    70,    64,    35,
+      36,    71,    41,    64,    69,    69,    42,    43,    44,    45,
+      46,    47,    48,    49,    50,    51,    52,    53,    54,    55,
+      56,    57,    69,    69,     3,     3,    42,    43,    44,    30,
+      37,    82,   181,   194,    70,    51,    52,    53,    54,    55,
+      56,    57,    68,   103,    -1,   132,    42,    43,    44,    -1,
+      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,
+      56,    57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,
+      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,
+      56,    57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,
+      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,
+      56,    57,    -1,    -1,    42,    43,    44,    -1,    -1,    -1,
+      -1,    -1,    68,    51,    52,    53,    54,    55,    56,    57,
+      -1,    -1,    42,    43,    44,    -1,    -1,    -1,    -1,    -1,
+      68,    51,    52,    53,    54,    55,    56,    57,    -1,    32,
+      -1,    -1,    35,    36,    -1,    -1,    -1,    -1,    68,    42,
+      43,    44,    45,    46,    47,    48,    49,    50,    51,    52,
+      53,    54,    55,    56,    57,    42,    43,    44,    -1,    -1,
+      -1,    -1,    -1,    -1,    51,    52,    53,    54,    55,    56,
+      57,    43,    44,    -1,    -1,    -1,    -1,    -1,    -1,    51,
+      52,    53,    54,    55,    56,    57,    44,    -1,    -1,    -1,
       -1,    -1,    -1,    51,    52,    53,    54,    55,    56,    57,
-      43,    44,    -1,    -1,    -1,    -1,    -1,    -1,    51,    52,
-      53,    54,    55,    56,    57,    44,    -1,    -1,    -1,    -1,
-      -1,    -1,    51,    52,    53,    54,    55,    56,    57
+      51,    52,    53,    54,    55,    56,    57
 };
 
   /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
@@ -862,14 +862,14 @@ static const yytype_uint8 yystos[] =
       40,    41,    32,    35,    36,    42,    43,    44,    45,    46,
       47,    48,    49,    50,    51,    52,    53,    54,    55,    56,
       57,    91,    91,   112,    69,   105,   112,   112,   112,   112,
-      10,    32,    70,    70,    10,   112,    94,    95,    98,   103,
-     102,    34,    69,   107,    96,   112,   112,   112,   112,   112,
+       1,    10,    32,    70,    70,    10,   112,    94,    95,    98,
+     103,   102,    34,    69,   107,    96,   112,   112,   112,   112,
      112,   112,   112,   112,   112,   112,   112,   112,   112,   112,
-     112,   112,    22,    23,    24,    25,    92,   112,    68,    68,
-      70,    31,   107,    68,    70,    71,    97,    97,   108,     3,
-      99,    64,    98,    11,    15,   109,   110,   112,    69,   104,
-     105,   101,    70,    71,    70,   106,   112,    64,    69,   110,
-      70,    71,   100,    97,   112,    69,    70,    97,    70
+     112,   112,   112,    22,    23,    24,    25,    92,   112,    68,
+      68,    70,    31,   107,    68,    70,    71,    97,    97,   108,
+       3,    99,    64,    98,    11,    15,   109,   110,   112,    69,
+     104,   105,   101,    70,    71,    70,   106,   112,    64,    69,
+     110,    70,    71,   100,    97,   112,    69,    70,    97,    70
 };
 
   /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
@@ -881,13 +881,13 @@ static const yytype_uint8 yyr1[] =
       86,    86,    87,    87,    89,    88,    90,    88,    88,    91,
       91,    92,    92,    92,    92,    93,    93,    93,    93,    94,
       94,    95,    95,    96,    97,    98,    98,    98,    98,    98,
-      98,    98,    99,   100,    98,   101,    98,    98,    98,   102,
-      98,   103,    98,    98,    98,    98,    98,    98,    98,    98,
-      98,   104,   104,   105,   106,   106,   108,   107,   107,   109,
-     109,   110,   110,   111,   111,   111,   112,   112,   112,   112,
+      98,    98,    98,    99,   100,    98,   101,    98,    98,    98,
+     102,    98,   103,    98,    98,    98,    98,    98,    98,    98,
+      98,    98,   104,   104,   105,   106,   106,   108,   107,   107,
+     109,   109,   110,   110,   111,   111,   111,   112,   112,   112,
      112,   112,   112,   112,   112,   112,   112,   112,   112,   112,
      112,   112,   112,   112,   112,   112,   112,   112,   112,   112,
-     112,   112
+     112,   112,   112
 };
 
   /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
@@ -899,13 +899,13 @@ static const yytype_uint8 yyr2[] =
        3,     3,     1,     2,     0,     5,     0,     5,     3,     0,
        2,     1,     1,     1,     1,     1,     3,     4,     4,     0,
        1,     1,     3,     1,     1,     1,     1,     3,     3,     1,
-       3,     3,     0,     0,    11,     0,     9,     3,     2,     0,
-       4,     0,     4,     3,     3,     3,     3,     3,     3,     1,
-       3,     3,     1,     5,     1,     3,     0,     4,     1,     1,
-       3,     1,     1,     1,     1,     1,     3,     1,     1,     4,
-       1,     1,     1,     1,     4,     1,     4,     1,     1,     2,
-       3,     3,     3,     3,     3,     3,     3,     3,     2,     3,
-       3,     1
+       3,     3,     3,     0,     0,    11,     0,     9,     3,     2,
+       0,     4,     0,     4,     3,     3,     3,     3,     3,     3,
+       1,     3,     3,     1,     5,     1,     3,     0,     4,     1,
+       1,     3,     1,     1,     1,     1,     1,     3,     1,     1,
+       4,     1,     1,     1,     1,     4,     1,     4,     1,     1,
+       2,     3,     3,     3,     3,     3,     3,     3,     3,     2,
+       3,     3,     1
 };
 
 
@@ -2586,6 +2586,15 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
   case 62:
 #line 1019 ""grammar.y"" /* yacc.c:1646  */
+    {
+        compiler->loop_depth--;
+        compiler->loop_identifier[compiler->loop_depth] = NULL;
+      }
+#line 2594 ""grammar.c"" /* yacc.c:1646  */
+    break;
+
+  case 63:
+#line 1024 ""grammar.y"" /* yacc.c:1646  */
     {
         int var_index;
 
@@ -2615,11 +2624,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
-#line 2619 ""grammar.c"" /* yacc.c:1646  */
+#line 2628 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 63:
-#line 1049 ""grammar.y"" /* yacc.c:1646  */
+  case 64:
+#line 1054 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;
@@ -2654,11 +2663,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
         compiler->loop_depth++;
       }
-#line 2658 ""grammar.c"" /* yacc.c:1646  */
+#line 2667 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 64:
-#line 1084 ""grammar.y"" /* yacc.c:1646  */
+  case 65:
+#line 1089 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
@@ -2737,11 +2746,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 2741 ""grammar.c"" /* yacc.c:1646  */
+#line 2750 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 65:
-#line 1163 ""grammar.y"" /* yacc.c:1646  */
+  case 66:
+#line 1168 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;
@@ -2771,11 +2780,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         compiler->loop_identifier[compiler->loop_depth] = NULL;
         compiler->loop_depth++;
       }
-#line 2775 ""grammar.c"" /* yacc.c:1646  */
+#line 2784 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 66:
-#line 1193 ""grammar.y"" /* yacc.c:1646  */
+  case 67:
+#line 1198 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
@@ -2824,31 +2833,31 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
 
       }
-#line 2828 ""grammar.c"" /* yacc.c:1646  */
+#line 2837 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 67:
-#line 1242 ""grammar.y"" /* yacc.c:1646  */
+  case 68:
+#line 1247 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_OF, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 2838 ""grammar.c"" /* yacc.c:1646  */
+#line 2847 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 68:
-#line 1248 ""grammar.y"" /* yacc.c:1646  */
+  case 69:
+#line 1253 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_NOT, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 2848 ""grammar.c"" /* yacc.c:1646  */
+#line 2857 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 69:
-#line 1254 ""grammar.y"" /* yacc.c:1646  */
+  case 70:
+#line 1259 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;
@@ -2874,11 +2883,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
-#line 2878 ""grammar.c"" /* yacc.c:1646  */
+#line 2887 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 70:
-#line 1280 ""grammar.y"" /* yacc.c:1646  */
+  case 71:
+#line 1285 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* and_addr;
@@ -2914,11 +2923,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 2918 ""grammar.c"" /* yacc.c:1646  */
+#line 2927 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 71:
-#line 1316 ""grammar.y"" /* yacc.c:1646  */
+  case 72:
+#line 1321 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;
@@ -2943,11 +2952,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
-#line 2947 ""grammar.c"" /* yacc.c:1646  */
+#line 2956 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 72:
-#line 1341 ""grammar.y"" /* yacc.c:1646  */
+  case 73:
+#line 1346 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* or_addr;
@@ -2983,11 +2992,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 2987 ""grammar.c"" /* yacc.c:1646  */
+#line 2996 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 73:
-#line 1377 ""grammar.y"" /* yacc.c:1646  */
+  case 74:
+#line 1382 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<"", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -2996,11 +3005,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 3000 ""grammar.c"" /* yacc.c:1646  */
+#line 3009 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 74:
-#line 1386 ""grammar.y"" /* yacc.c:1646  */
+  case 75:
+#line 1391 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">"", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -3009,11 +3018,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 3013 ""grammar.c"" /* yacc.c:1646  */
+#line 3022 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 75:
-#line 1395 ""grammar.y"" /* yacc.c:1646  */
+  case 76:
+#line 1400 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<="", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -3022,11 +3031,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 3026 ""grammar.c"" /* yacc.c:1646  */
+#line 3035 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 76:
-#line 1404 ""grammar.y"" /* yacc.c:1646  */
+  case 77:
+#line 1409 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">="", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -3035,11 +3044,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 3039 ""grammar.c"" /* yacc.c:1646  */
+#line 3048 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 77:
-#line 1413 ""grammar.y"" /* yacc.c:1646  */
+  case 78:
+#line 1418 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""=="", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -3048,11 +3057,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 3052 ""grammar.c"" /* yacc.c:1646  */
+#line 3061 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 78:
-#line 1422 ""grammar.y"" /* yacc.c:1646  */
+  case 79:
+#line 1427 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""!="", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -3061,39 +3070,39 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
-#line 3065 ""grammar.c"" /* yacc.c:1646  */
+#line 3074 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 79:
-#line 1431 ""grammar.y"" /* yacc.c:1646  */
+  case 80:
+#line 1436 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
-#line 3073 ""grammar.c"" /* yacc.c:1646  */
+#line 3082 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 80:
-#line 1435 ""grammar.y"" /* yacc.c:1646  */
+  case 81:
+#line 1440 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
-#line 3081 ""grammar.c"" /* yacc.c:1646  */
+#line 3090 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 81:
-#line 1442 ""grammar.y"" /* yacc.c:1646  */
+  case 82:
+#line 1447 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_ENUMERATION; }
-#line 3087 ""grammar.c"" /* yacc.c:1646  */
+#line 3096 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 82:
-#line 1443 ""grammar.y"" /* yacc.c:1646  */
+  case 83:
+#line 1448 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_RANGE; }
-#line 3093 ""grammar.c"" /* yacc.c:1646  */
+#line 3102 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 83:
-#line 1449 ""grammar.y"" /* yacc.c:1646  */
+  case 84:
+#line 1454 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
         {
@@ -3111,11 +3120,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
-#line 3115 ""grammar.c"" /* yacc.c:1646  */
+#line 3124 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 84:
-#line 1471 ""grammar.y"" /* yacc.c:1646  */
+  case 85:
+#line 1476 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
@@ -3127,11 +3136,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
-#line 3131 ""grammar.c"" /* yacc.c:1646  */
+#line 3140 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 85:
-#line 1483 ""grammar.y"" /* yacc.c:1646  */
+  case 86:
+#line 1488 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
@@ -3142,77 +3151,77 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
-#line 3146 ""grammar.c"" /* yacc.c:1646  */
+#line 3155 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 86:
-#line 1498 ""grammar.y"" /* yacc.c:1646  */
+  case 87:
+#line 1503 ""grammar.y"" /* yacc.c:1646  */
     {
         // Push end-of-list marker
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
-#line 3155 ""grammar.c"" /* yacc.c:1646  */
+#line 3164 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 88:
-#line 1504 ""grammar.y"" /* yacc.c:1646  */
+  case 89:
+#line 1509 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
         yr_parser_emit_pushes_for_strings(yyscanner, ""$*"");
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
-#line 3166 ""grammar.c"" /* yacc.c:1646  */
+#line 3175 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 91:
-#line 1521 ""grammar.y"" /* yacc.c:1646  */
+  case 92:
+#line 1526 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
-#line 3177 ""grammar.c"" /* yacc.c:1646  */
+#line 3186 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 92:
-#line 1528 ""grammar.y"" /* yacc.c:1646  */
+  case 93:
+#line 1533 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
-#line 3188 ""grammar.c"" /* yacc.c:1646  */
+#line 3197 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 94:
-#line 1540 ""grammar.y"" /* yacc.c:1646  */
+  case 95:
+#line 1545 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
-#line 3196 ""grammar.c"" /* yacc.c:1646  */
+#line 3205 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 95:
-#line 1544 ""grammar.y"" /* yacc.c:1646  */
+  case 96:
+#line 1549 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
       }
-#line 3204 ""grammar.c"" /* yacc.c:1646  */
+#line 3213 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 96:
-#line 1552 ""grammar.y"" /* yacc.c:1646  */
+  case 97:
+#line 1557 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
-#line 3212 ""grammar.c"" /* yacc.c:1646  */
+#line 3221 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 97:
-#line 1556 ""grammar.y"" /* yacc.c:1646  */
+  case 98:
+#line 1561 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_FILESIZE, NULL);
@@ -3222,11 +3231,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
-#line 3226 ""grammar.c"" /* yacc.c:1646  */
+#line 3235 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 98:
-#line 1566 ""grammar.y"" /* yacc.c:1646  */
+  case 99:
+#line 1571 ""grammar.y"" /* yacc.c:1646  */
     {
         yywarning(yyscanner,
             ""Using deprecated \""entrypoint\"" keyword. Use the \""entry_point\"" ""
@@ -3240,11 +3249,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
-#line 3244 ""grammar.c"" /* yacc.c:1646  */
+#line 3253 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 99:
-#line 1580 ""grammar.y"" /* yacc.c:1646  */
+  case 100:
+#line 1585 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, ""intXXXX or uintXXXX"");
 
@@ -3260,11 +3269,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
-#line 3264 ""grammar.c"" /* yacc.c:1646  */
+#line 3273 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 100:
-#line 1596 ""grammar.y"" /* yacc.c:1646  */
+  case 101:
+#line 1601 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);
@@ -3274,11 +3283,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = (yyvsp[0].integer);
       }
-#line 3278 ""grammar.c"" /* yacc.c:1646  */
+#line 3287 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 101:
-#line 1606 ""grammar.y"" /* yacc.c:1646  */
+  case 102:
+#line 1611 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg_double(
             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);
@@ -3287,11 +3296,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
       }
-#line 3291 ""grammar.c"" /* yacc.c:1646  */
+#line 3300 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 102:
-#line 1615 ""grammar.y"" /* yacc.c:1646  */
+  case 103:
+#line 1620 ""grammar.y"" /* yacc.c:1646  */
     {
         SIZED_STRING* sized_string;
 
@@ -3316,11 +3325,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_STRING;
         (yyval.expression).value.sized_string = sized_string;
       }
-#line 3320 ""grammar.c"" /* yacc.c:1646  */
+#line 3329 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 103:
-#line 1640 ""grammar.y"" /* yacc.c:1646  */
+  case 104:
+#line 1645 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);
@@ -3332,11 +3341,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
-#line 3336 ""grammar.c"" /* yacc.c:1646  */
+#line 3345 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 104:
-#line 1652 ""grammar.y"" /* yacc.c:1646  */
+  case 105:
+#line 1657 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);
@@ -3348,11 +3357,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
-#line 3352 ""grammar.c"" /* yacc.c:1646  */
+#line 3361 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 105:
-#line 1664 ""grammar.y"" /* yacc.c:1646  */
+  case 106:
+#line 1669 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);
@@ -3368,11 +3377,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
-#line 3372 ""grammar.c"" /* yacc.c:1646  */
+#line 3381 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 106:
-#line 1680 ""grammar.y"" /* yacc.c:1646  */
+  case 107:
+#line 1685 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);
@@ -3384,11 +3393,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
-#line 3388 ""grammar.c"" /* yacc.c:1646  */
+#line 3397 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 107:
-#line 1692 ""grammar.y"" /* yacc.c:1646  */
+  case 108:
+#line 1697 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);
@@ -3404,11 +3413,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
-#line 3408 ""grammar.c"" /* yacc.c:1646  */
+#line 3417 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 108:
-#line 1708 ""grammar.y"" /* yacc.c:1646  */
+  case 109:
+#line 1713 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier
         {
@@ -3453,11 +3462,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
-#line 3457 ""grammar.c"" /* yacc.c:1646  */
+#line 3466 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 109:
-#line 1753 ""grammar.y"" /* yacc.c:1646  */
+  case 110:
+#line 1758 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, ""-"");
 
@@ -3476,11 +3485,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
-#line 3480 ""grammar.c"" /* yacc.c:1646  */
+#line 3489 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 110:
-#line 1772 ""grammar.y"" /* yacc.c:1646  */
+  case 111:
+#line 1777 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""+"", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -3498,11 +3507,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
-#line 3502 ""grammar.c"" /* yacc.c:1646  */
+#line 3511 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 111:
-#line 1790 ""grammar.y"" /* yacc.c:1646  */
+  case 112:
+#line 1795 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""-"", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -3520,11 +3529,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
-#line 3524 ""grammar.c"" /* yacc.c:1646  */
+#line 3533 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 112:
-#line 1808 ""grammar.y"" /* yacc.c:1646  */
+  case 113:
+#line 1813 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""*"", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -3542,11 +3551,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
-#line 3546 ""grammar.c"" /* yacc.c:1646  */
+#line 3555 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 113:
-#line 1826 ""grammar.y"" /* yacc.c:1646  */
+  case 114:
+#line 1831 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""\\"", (yyvsp[-2].expression), (yyvsp[0].expression));
@@ -3572,11 +3581,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
-#line 3576 ""grammar.c"" /* yacc.c:1646  */
+#line 3585 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 114:
-#line 1852 ""grammar.y"" /* yacc.c:1646  */
+  case 115:
+#line 1857 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""%"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""%"");
@@ -3594,11 +3603,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         }
       }
-#line 3598 ""grammar.c"" /* yacc.c:1646  */
+#line 3607 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 115:
-#line 1870 ""grammar.y"" /* yacc.c:1646  */
+  case 116:
+#line 1875 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");
@@ -3608,11 +3617,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
-#line 3612 ""grammar.c"" /* yacc.c:1646  */
+#line 3621 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 116:
-#line 1880 ""grammar.y"" /* yacc.c:1646  */
+  case 117:
+#line 1885 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");
@@ -3622,11 +3631,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
-#line 3626 ""grammar.c"" /* yacc.c:1646  */
+#line 3635 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 117:
-#line 1890 ""grammar.y"" /* yacc.c:1646  */
+  case 118:
+#line 1895 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""|"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""|"");
@@ -3636,11 +3645,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
-#line 3640 ""grammar.c"" /* yacc.c:1646  */
+#line 3649 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 118:
-#line 1900 ""grammar.y"" /* yacc.c:1646  */
+  case 119:
+#line 1905 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""~"");
 
@@ -3650,11 +3659,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
             UNDEFINED : ~((yyvsp[0].expression).value.integer);
       }
-#line 3654 ""grammar.c"" /* yacc.c:1646  */
+#line 3663 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 119:
-#line 1910 ""grammar.y"" /* yacc.c:1646  */
+  case 120:
+#line 1915 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
@@ -3664,11 +3673,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
-#line 3668 ""grammar.c"" /* yacc.c:1646  */
+#line 3677 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 120:
-#line 1920 ""grammar.y"" /* yacc.c:1646  */
+  case 121:
+#line 1925 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "">>"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "">>"");
@@ -3678,19 +3687,19 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
-#line 3682 ""grammar.c"" /* yacc.c:1646  */
+#line 3691 ""grammar.c"" /* yacc.c:1646  */
     break;
 
-  case 121:
-#line 1930 ""grammar.y"" /* yacc.c:1646  */
+  case 122:
+#line 1935 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
-#line 3690 ""grammar.c"" /* yacc.c:1646  */
+#line 3699 ""grammar.c"" /* yacc.c:1646  */
     break;
 
 
-#line 3694 ""grammar.c"" /* yacc.c:1646  */
+#line 3703 ""grammar.c"" /* yacc.c:1646  */
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
@@ -3918,5 +3927,5 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 #endif
   return yyresult;
 }
-#line 1935 ""grammar.y"" /* yacc.c:1906  */
+#line 1940 ""grammar.y"" /* yacc.c:1906  */
 ",yara,890c3f850293176c0e996a602ffa88b315f4e98f,eb491e03851a11bc811173f5e13c89cefa7257ac,1,"yyparse (void *yyscanner, YR_COMPILER* compiler)
{
/* The lookahead symbol.  */
int yychar;


/* The semantic value of the lookahead symbol.  */
/* Default value used for initialization, for pacifying older GCCs
   or non-GCC compilers.  */
YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);

    /* Number of syntax errors so far.  */
    int yynerrs;

    int yystate;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus;

    /* The stacks and their tools:
       'yyss': related to states.
       'yyvs': related to semantic values.

       Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* The state stack.  */
    yytype_int16 yyssa[YYINITDEPTH];
    yytype_int16 *yyss;
    yytype_int16 *yyssp;

    /* The semantic value stack.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs;
    YYSTYPE *yyvsp;

    YYSIZE_T yystacksize;

  int yyn;
  int yyresult;
  /* Lookahead token as an internal (translated) token number.  */
  int yytoken = 0;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;

#if YYERROR_VERBOSE
  /* Buffer for error messages, and its allocated size.  */
  char yymsgbuf[128];
  char *yymsg = yymsgbuf;
  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
#endif

#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  yyssp = yyss = yyssa;
  yyvsp = yyvs = yyvsa;
  yystacksize = YYINITDEPTH;

  YYDPRINTF ((stderr, ""Starting parse\n""));

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY; /* Cause a token to be read.  */
  goto yysetstate;

/*------------------------------------------------------------.
| yynewstate -- Push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
 yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;

 yysetstate:
  *yyssp = yystate;

  if (yyss + yystacksize - 1 <= yyssp)
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYSIZE_T yysize = yyssp - yyss + 1;

#ifdef yyoverflow
      {
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &'s don't force the real ones into
           memory.  */
        YYSTYPE *yyvs1 = yyvs;
        yytype_int16 *yyss1 = yyss;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_(""memory exhausted""),
                    &yyss1, yysize * sizeof (*yyssp),
                    &yyvs1, yysize * sizeof (*yyvsp),
                    &yystacksize);

        yyss = yyss1;
        yyvs = yyvs1;
      }
#else /* no yyoverflow */
# ifndef YYSTACK_RELOCATE
      goto yyexhaustedlab;
# else
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
        goto yyexhaustedlab;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
        yystacksize = YYMAXDEPTH;

      {
        yytype_int16 *yyss1 = yyss;
        union yyalloc *yyptr =
          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
        if (! yyptr)
          goto yyexhaustedlab;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
#  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
          YYSTACK_FREE (yyss1);
      }
# endif
#endif /* no yyoverflow */

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;

      YYDPRINTF ((stderr, ""Stack size increased to %lu\n"",
                  (unsigned long int) yystacksize));

      if (yyss + yystacksize - 1 <= yyssp)
        YYABORT;
    }

  YYDPRINTF ((stderr, ""Entering state %d\n"", yystate));

  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;

/*-----------.
| yybackup.  |
`-----------*/
yybackup:

  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, ""Reading a token: ""));
      yychar = yylex (&yylval, yyscanner, compiler);
    }

  if (yychar <= YYEOF)
    {
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, ""Now at end of input.\n""));
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT (""Next token is"", yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT (""Shifting"", yytoken, &yylval, &yylloc);

  /* Discard the shifted token.  */
  yychar = YYEMPTY;

  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- Do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
        case 8:
#line 230 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));

        yr_free((yyvsp[0].sized_string));

        ERROR_IF(result != ERROR_SUCCESS);
      }
#line 1661 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 9:
#line 242 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(
            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));

        ERROR_IF(rule == NULL);

        (yyval.rule) = rule;
      }
#line 1674 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 10:
#line 251 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1

        rule->tags = (yyvsp[-3].c_string);
        rule->metas = (yyvsp[-1].meta);
        rule->strings = (yyvsp[0].string);
      }
#line 1686 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 11:
#line 259 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-7].rule); // rule created in phase 1

        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(
            yyscanner, rule);

        yr_free((yyvsp[-8].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1701 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 12:
#line 274 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = NULL;
      }
#line 1709 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 13:
#line 278 ""grammar.y"" /* yacc.c:1646  */
    {
        // Each rule have a list of meta-data info, consisting in a
        // sequence of YR_META structures. The last YR_META structure does
        // not represent a real meta-data, it's just a end-of-list marker
        // identified by a specific type (META_TYPE_NULL). Here we
        // write the end-of-list marker.

        YR_META null_meta;

        memset(&null_meta, 0xFF, sizeof(YR_META));
        null_meta.type = META_TYPE_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->metas_arena,
            &null_meta,
            sizeof(YR_META),
            NULL);

        (yyval.meta) = (yyvsp[0].meta);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1736 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 14:
#line 305 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = NULL;
      }
#line 1744 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 15:
#line 309 ""grammar.y"" /* yacc.c:1646  */
    {
        // Each rule have a list of strings, consisting in a sequence
        // of YR_STRING structures. The last YR_STRING structure does not
        // represent a real string, it's just a end-of-list marker
        // identified by a specific flag (STRING_FLAGS_NULL). Here we
        // write the end-of-list marker.

        YR_STRING null_string;

        memset(&null_string, 0xFF, sizeof(YR_STRING));
        null_string.g_flags = STRING_GFLAGS_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->strings_arena,
            &null_string,
            sizeof(YR_STRING),
            NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.string) = (yyvsp[0].string);
      }
#line 1771 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 17:
#line 340 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0;  }
#line 1777 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 18:
#line 341 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 1783 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 19:
#line 346 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
#line 1789 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 20:
#line 347 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
#line 1795 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 21:
#line 353 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = NULL;
      }
#line 1803 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 22:
#line 357 ""grammar.y"" /* yacc.c:1646  */
    {
        // Tags list is represented in the arena as a sequence
        // of null-terminated strings, the sequence ends with an
        // additional null character. Here we write the ending null
        //character. Example: tag1\0tag2\0tag3\0\0

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, """", NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[0].c_string);
      }
#line 1821 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 23:
#line 375 ""grammar.y"" /* yacc.c:1646  */
    {
        char* identifier;

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = identifier;
      }
#line 1838 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 24:
#line 388 ""grammar.y"" /* yacc.c:1646  */
    {
        char* tag_name = (yyvsp[-1].c_string);
        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;

        while (tag_length > 0)
        {
          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
          {
            yr_compiler_set_error_extra_info(compiler, tag_name);
            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;
            break;
          }

          tag_name = (char*) yr_arena_next_address(
              yyget_extra(yyscanner)->sz_arena,
              tag_name,
              tag_length + 1);

          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        }

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_arena_write_string(
              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-1].c_string);
      }
#line 1874 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 25:
#line 424 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[0].meta); }
#line 1880 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 26:
#line 425 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[-1].meta); }
#line 1886 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 27:
#line 431 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);

        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_STRING,
            (yyvsp[-2].c_string),
            sized_string->c_string,
            0);

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1906 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 28:
#line 447 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-2].c_string),
            NULL,
            (yyvsp[0].integer));

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1923 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 29:
#line 460 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-3].c_string),
            NULL,
            -(yyvsp[0].integer));

        yr_free((yyvsp[-3].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1940 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 30:
#line 473 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            TRUE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1957 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 31:
#line 486 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            FALSE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1974 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 32:
#line 502 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[0].string); }
#line 1980 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 33:
#line 503 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[-1].string); }
#line 1986 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 34:
#line 509 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 1994 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 35:
#line 513 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);
        compiler->error_line = 0;
      }
#line 2009 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 36:
#line 524 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 2017 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 37:
#line 528 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);

        compiler->error_line = 0;
      }
#line 2033 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 38:
#line 540 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.string) == NULL);
      }
#line 2047 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 39:
#line 553 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0; }
#line 2053 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 40:
#line 554 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 2059 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 41:
#line 559 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_WIDE; }
#line 2065 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 42:
#line 560 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_ASCII; }
#line 2071 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 43:
#line 561 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
#line 2077 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 44:
#line 562 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
#line 2083 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 45:
#line 568 ""grammar.y"" /* yacc.c:1646  */
    {
        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));

        if (var_index >= 0)
        {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner,
              OP_PUSH_M,
              LOOP_LOCAL_VARS * var_index,
              NULL,
              NULL);

          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
          (yyval.expression).identifier = compiler->loop_identifier[var_index];
        }
        else
        {
          // Search for identifier within the global namespace, where the
          // externals variables reside.

          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
              compiler->objects_table, (yyvsp[0].c_string), NULL);

          if (object == NULL)
          {
            // If not found, search within the current namespace.
            char* ns = compiler->current_namespace->name;

            object = (YR_OBJECT*) yr_hash_table_lookup(
                compiler->objects_table, (yyvsp[0].c_string), ns);
          }

          if (object != NULL)
          {
            char* id;

            compiler->last_result = yr_arena_write_string(
                compiler->sz_arena, (yyvsp[0].c_string), &id);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_LOAD,
                  id,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = object;
            (yyval.expression).identifier = object->identifier;
          }
          else
          {
            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
                compiler->rules_table,
                (yyvsp[0].c_string),
                compiler->current_namespace->name);

            if (rule != NULL)
            {
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_PUSH_RULE,
                  rule,
                  NULL,
                  NULL);

              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
              (yyval.expression).value.integer = UNDEFINED;
              (yyval.expression).identifier = rule->identifier;
            }
            else
            {
              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;
            }
          }
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2172 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 46:
#line 653 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT* field = NULL;

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
        {
          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));

          if (field != NULL)
          {
            char* ident;

            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[0].c_string), &ident);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_FIELD,
                  ident,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = field;
            (yyval.expression).identifier = field->identifier;
          }
          else
          {
            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
            compiler->last_result = ERROR_INVALID_FIELD_NAME;
          }
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-2].expression).identifier);

          compiler->last_result = ERROR_NOT_A_STRUCTURE;
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2222 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 47:
#line 699 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_ARRAY* array;
        YR_OBJECT_DICTIONARY* dict;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""array indexes must be of integer type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_INDEX_ARRAY, NULL);

          array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = array->prototype_item;
          (yyval.expression).identifier = array->identifier;
        }
        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""dictionary keys must be of string type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_LOOKUP_DICT, NULL);

          dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = dict->prototype_item;
          (yyval.expression).identifier = dict->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_INDEXABLE;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2283 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 48:
#line 757 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_FUNCTION* function;
        char* args_fmt;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
        {
          compiler->last_result = yr_parser_check_types(
              compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_parser_emit_with_arg_reloc(
                yyscanner,
                OP_CALL,
                args_fmt,
                NULL,
                NULL);

          function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = function->return_obj;
          (yyval.expression).identifier = function->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_A_FUNCTION;
        }

        yr_free((yyvsp[-1].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2328 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 49:
#line 801 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = yr_strdup(""""); }
#line 2334 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 50:
#line 802 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = (yyvsp[0].c_string); }
#line 2340 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 51:
#line 807 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);

        switch((yyvsp[0].expression).type)
        {
          case EXPRESSION_TYPE_INTEGER:
            strlcpy((yyval.c_string), ""i"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_FLOAT:
            strlcpy((yyval.c_string), ""f"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_BOOLEAN:
            strlcpy((yyval.c_string), ""b"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_STRING:
            strlcpy((yyval.c_string), ""s"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_REGEXP:
            strlcpy((yyval.c_string), ""r"", MAX_FUNCTION_ARGS);
            break;
        }

        ERROR_IF((yyval.c_string) == NULL);
      }
#line 2369 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 52:
#line 832 ""grammar.y"" /* yacc.c:1646  */
    {
        if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)
        {
          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;
        }
        else
        {
          switch((yyvsp[0].expression).type)
          {
            case EXPRESSION_TYPE_INTEGER:
              strlcat((yyvsp[-2].c_string), ""i"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_FLOAT:
              strlcat((yyvsp[-2].c_string), ""f"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_BOOLEAN:
              strlcat((yyvsp[-2].c_string), ""b"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_STRING:
              strlcat((yyvsp[-2].c_string), ""s"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_REGEXP:
              strlcat((yyvsp[-2].c_string), ""r"", MAX_FUNCTION_ARGS);
              break;
          }
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-2].c_string);
      }
#line 2405 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 53:
#line 868 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        RE* re;
        RE_ERROR error;

        int re_flags = 0;

        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
          re_flags |= RE_FLAGS_NO_CASE;

        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
          re_flags |= RE_FLAGS_DOT_ALL;

        compiler->last_result = yr_re_compile(
            sized_string->c_string,
            re_flags,
            compiler->re_code_arena,
            &re,
            &error);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)
          yr_compiler_set_error_extra_info(compiler, error.message);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              re->root_node->forward_code,
              NULL,
              NULL);

        yr_re_destroy(re);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
      }
#line 2451 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 54:
#line 914 ""grammar.y"" /* yacc.c:1646  */
    {
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
        {
          if ((yyvsp[0].expression).value.sized_string != NULL)
          {
            yywarning(yyscanner,
              ""Using literal string \""%s\"" in a boolean operation."",
              (yyvsp[0].expression).value.sized_string->c_string);
          }

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_STR_TO_BOOL, NULL);

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2474 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 55:
#line 936 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 1, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2487 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 56:
#line 945 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 0, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2500 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 57:
#line 954 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""matches"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, ""matches"");

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit(
              yyscanner,
              OP_MATCHES,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2519 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 58:
#line 969 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""contains"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, ""contains"");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_CONTAINS, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2535 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 59:
#line 981 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_string_identifier(
            yyscanner,
            (yyvsp[0].c_string),
            OP_FOUND,
            UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2553 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 60:
#line 995 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""at"");

        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2570 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 61:
#line 1008 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2585 ""grammar.c"" /* yacc.c:1646  */
    break;
 
   case 62:
 #line 1019 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//        compiler->loop_depth--;
//fix_flaw_line_below:
//        compiler->loop_identifier[compiler->loop_depth] = NULL;
//fix_flaw_line_below:
//      }
//fix_flaw_line_below:
//#line 2594 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//    break;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  case 63:
//fix_flaw_line_below:
//#line 1024 ""grammar.y"" /* yacc.c:1646  */
     {
         int var_index;
 
        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        var_index = yr_parser_lookup_loop_variable(
            yyscanner, (yyvsp[-1].c_string));

        if (var_index >= 0)
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-1].c_string));

          compiler->last_result = \
              ERROR_DUPLICATED_LOOP_IDENTIFIER;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        // Push end-of-list marker
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
//flaw_line_below:
#line 2619 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2628 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 63:
//flaw_line_below:
#line 1049 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 64:
//fix_flaw_line_below:
//#line 1054 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        // Clear counter for number of expressions evaluating
        // to TRUE.
        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        // Clear iterations counter
        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
        {
          // Pop the first integer
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        }
        else // INTEGER_SET_RANGE
        {
          // Pop higher bound of set range
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);

          // Pop lower bound of set range
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        }

        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
         compiler->loop_depth++;
       }
//flaw_line_below:
#line 2658 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2667 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 64:
//flaw_line_below:
#line 1084 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 65:
//fix_flaw_line_below:
//#line 1089 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;

        // The value at the top of the stack is the result of
        // evaluating the boolean expression, so it could be
        // 0, 1 or UNDEFINED. Add this value to a counter
        // keeping the number of expressions evaluating to true.
        // If the value is UNDEFINED instruction OP_ADD_M
        // does nothing.

        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        // Increment iterations counter
        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JNUNDEF,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);
        }
        else // INTEGER_SET_RANGE
        {
          // Increment lower bound of integer set
          yr_parser_emit_with_arg(
              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);

          // Push lower bound of integer set
          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);

          // Push higher bound of integer set
          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);

          // Compare higher bound with lower bound, do loop again
          // if lower bound is still lower or equal than higher bound
          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JLE,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);

          yr_parser_emit(yyscanner, OP_POP, NULL);
          yr_parser_emit(yyscanner, OP_POP, NULL);
        }

        // Pop end-of-list marker.
        yr_parser_emit(yyscanner, OP_POP, NULL);

        // At this point the loop quantifier (any, all, 1, 2,..)
        // is at the top of the stack. Check if the quantifier
        // is undefined (meaning ""all"") and replace it with the
        // iterations counter in that case.
        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        // Compare the loop quantifier with the number of
        // expressions evaluating to TRUE.
        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

        compiler->loop_identifier[compiler->loop_depth] = NULL;
        yr_free((yyvsp[-8].c_string));
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 2741 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2750 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 65:
//flaw_line_below:
#line 1163 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 66:
//fix_flaw_line_below:
//#line 1168 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        if (compiler->loop_for_of_mem_offset != -1)
          compiler->last_result = \
            ERROR_NESTED_FOR_OF_LOOP;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        // Pop the first string.
        yr_parser_emit_with_arg(
            yyscanner, OP_POP_M, mem_offset, &addr, NULL);

        compiler->loop_for_of_mem_offset = mem_offset;
        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = NULL;
         compiler->loop_depth++;
       }
//flaw_line_below:
#line 2775 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2784 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 66:
//flaw_line_below:
#line 1193 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 67:
//fix_flaw_line_below:
//#line 1198 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        compiler->loop_for_of_mem_offset = -1;

        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;

        // Increment counter by the value returned by the
        // boolean expression (0 or 1). If the boolean expression
        // returned UNDEFINED the OP_ADD_M won't do anything.

        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        // Increment iterations counter.
        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        // If next string is not undefined, go back to the
        // beginning of the loop.
        yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JNUNDEF,
            compiler->loop_address[compiler->loop_depth],
            NULL,
            NULL);

        // Pop end-of-list marker.
        yr_parser_emit(yyscanner, OP_POP, NULL);

        // At this point the loop quantifier (any, all, 1, 2,..)
        // is at top of the stack. Check if the quantifier is
        // undefined (meaning ""all"") and replace it with the
        // iterations counter in that case.
        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        // Compare the loop quantifier with the number of
        // expressions evaluating to TRUE.
        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
 
       }
//flaw_line_below:
#line 2828 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2837 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 67:
//flaw_line_below:
#line 1242 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 68:
//fix_flaw_line_below:
//#line 1247 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_OF, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 2838 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2847 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 68:
//flaw_line_below:
#line 1248 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 69:
//fix_flaw_line_below:
//#line 1253 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_NOT, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 2848 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2857 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 69:
//flaw_line_below:
#line 1254 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 70:
//fix_flaw_line_below:
//#line 1259 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JFALSE,
            0,          // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        // create a fixup entry for the jump and push it in the stack
        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
//flaw_line_below:
#line 2878 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2887 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 70:
//flaw_line_below:
#line 1280 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 71:
//fix_flaw_line_below:
//#line 1285 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* and_addr;

        // Ensure that we have at least two consecutive bytes in the arena's
        // current page, one for the AND opcode and one for opcode following the
        // AND. This is necessary because we need to compute the address for the
        // opcode following the AND, and we don't want the AND in one page and
        // the following opcode in another page.

        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        // Now we know the jump destination, which is the address of the
        // instruction following the AND. Let's fixup the jump address.

        fixup = compiler->fixup_stack_head;

        // We know that the AND opcode and the following one are within the same
        // page, so we can compute the address for the opcode following the AND
        // by simply adding one to its address.

        *(void**)(fixup->address) = (void*)(and_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 2918 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2927 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 71:
//flaw_line_below:
#line 1316 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 72:
//fix_flaw_line_below:
//#line 1321 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JTRUE,
            0,         // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
//flaw_line_below:
#line 2947 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2956 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 72:
//flaw_line_below:
#line 1341 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 73:
//fix_flaw_line_below:
//#line 1346 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* or_addr;

        // Ensure that we have at least two consecutive bytes in the arena's
        // current page, one for the OR opcode and one for opcode following the
        // OR. This is necessary because we need to compute the address for the
        // opcode following the OR, and we don't want the OR in one page and
        // the following opcode in another page.

        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        // Now we know the jump destination, which is the address of the
        // instruction following the OP_OR. Let's fixup the jump address.

        fixup = compiler->fixup_stack_head;

        // We know that the OR opcode and the following one are within the same
        // page, so we can compute the address for the opcode following the OR
        // by simply adding one to its address.

        *(void**)(fixup->address) = (void*)(or_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 2987 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 2996 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 73:
//flaw_line_below:
#line 1377 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 74:
//fix_flaw_line_below:
//#line 1382 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 3000 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3009 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 74:
//flaw_line_below:
#line 1386 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 75:
//fix_flaw_line_below:
//#line 1391 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 3013 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3022 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 75:
//flaw_line_below:
#line 1395 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 76:
//fix_flaw_line_below:
//#line 1400 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 3026 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3035 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 76:
//flaw_line_below:
#line 1404 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 77:
//fix_flaw_line_below:
//#line 1409 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 3039 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3048 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 77:
//flaw_line_below:
#line 1413 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 78:
//fix_flaw_line_below:
//#line 1418 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""=="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 3052 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3061 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 78:
//flaw_line_below:
#line 1422 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 79:
//fix_flaw_line_below:
//#line 1427 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""!="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
//flaw_line_below:
#line 3065 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3074 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 79:
//flaw_line_below:
#line 1431 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 80:
//fix_flaw_line_below:
//#line 1436 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
//flaw_line_below:
#line 3073 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3082 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 80:
//flaw_line_below:
#line 1435 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 81:
//fix_flaw_line_below:
//#line 1440 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
//flaw_line_below:
#line 3081 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3090 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 81:
//flaw_line_below:
#line 1442 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 82:
//fix_flaw_line_below:
//#line 1447 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_ENUMERATION; }
//flaw_line_below:
#line 3087 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3096 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 82:
//flaw_line_below:
#line 1443 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 83:
//fix_flaw_line_below:
//#line 1448 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_RANGE; }
//flaw_line_below:
#line 3093 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3102 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 83:
//flaw_line_below:
#line 1449 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 84:
//fix_flaw_line_below:
//#line 1454 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's lower bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }

        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's upper bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
//flaw_line_below:
#line 3115 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3124 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 84:
//flaw_line_below:
#line 1471 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 85:
//fix_flaw_line_below:
//#line 1476 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;

        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
//flaw_line_below:
#line 3131 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3140 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 85:
//flaw_line_below:
#line 1483 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 86:
//fix_flaw_line_below:
//#line 1488 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
//flaw_line_below:
#line 3146 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3155 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 86:
//flaw_line_below:
#line 1498 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 87:
//fix_flaw_line_below:
//#line 1503 ""grammar.y"" /* yacc.c:1646  */
     {
         // Push end-of-list marker
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
//flaw_line_below:
#line 3155 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3164 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 88:
//flaw_line_below:
#line 1504 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 89:
//fix_flaw_line_below:
//#line 1509 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
         yr_parser_emit_pushes_for_strings(yyscanner, ""$*"");
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
//flaw_line_below:
#line 3166 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3175 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 91:
//flaw_line_below:
#line 1521 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 92:
//fix_flaw_line_below:
//#line 1526 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
//flaw_line_below:
#line 3177 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3186 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 92:
//flaw_line_below:
#line 1528 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 93:
//fix_flaw_line_below:
//#line 1533 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
//flaw_line_below:
#line 3188 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3197 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 94:
//flaw_line_below:
#line 1540 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 95:
//fix_flaw_line_below:
//#line 1545 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
//flaw_line_below:
#line 3196 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3205 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 95:
//flaw_line_below:
#line 1544 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 96:
//fix_flaw_line_below:
//#line 1549 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
       }
//flaw_line_below:
#line 3204 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3213 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 96:
//flaw_line_below:
#line 1552 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 97:
//fix_flaw_line_below:
//#line 1557 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
//flaw_line_below:
#line 3212 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3221 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 97:
//flaw_line_below:
#line 1556 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 98:
//fix_flaw_line_below:
//#line 1561 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_FILESIZE, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
//flaw_line_below:
#line 3226 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3235 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 98:
//flaw_line_below:
#line 1566 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 99:
//fix_flaw_line_below:
//#line 1571 ""grammar.y"" /* yacc.c:1646  */
     {
         yywarning(yyscanner,
             ""Using deprecated \""entrypoint\"" keyword. Use the \""entry_point\"" ""
            ""function from PE module instead."");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_ENTRYPOINT, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
//flaw_line_below:
#line 3244 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3253 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 99:
//flaw_line_below:
#line 1580 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 100:
//fix_flaw_line_below:
//#line 1585 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, ""intXXXX or uintXXXX"");
 
        // _INTEGER_FUNCTION_ could be any of int8, int16, int32, uint8,
        // uint32, etc. $1 contains an index that added to OP_READ_INT results
        // in the proper OP_INTXX opcode.

        compiler->last_result = yr_parser_emit(
            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
//flaw_line_below:
#line 3264 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3273 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 100:
//flaw_line_below:
#line 1596 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 101:
//fix_flaw_line_below:
//#line 1601 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = (yyvsp[0].integer);
       }
//flaw_line_below:
#line 3278 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3287 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 101:
//flaw_line_below:
#line 1606 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 102:
//fix_flaw_line_below:
//#line 1611 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg_double(
             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
       }
//flaw_line_below:
#line 3291 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3300 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 102:
//flaw_line_below:
#line 1615 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 103:
//fix_flaw_line_below:
//#line 1620 ""grammar.y"" /* yacc.c:1646  */
     {
         SIZED_STRING* sized_string;
 
        compiler->last_result = yr_arena_write_data(
            compiler->sz_arena,
            (yyvsp[0].sized_string),
            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
            (void**) &sized_string);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              sized_string,
              NULL,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_STRING;
         (yyval.expression).value.sized_string = sized_string;
       }
//flaw_line_below:
#line 3320 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3329 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 103:
//flaw_line_below:
#line 1640 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 104:
//fix_flaw_line_below:
//#line 1645 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
//flaw_line_below:
#line 3336 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3345 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 104:
//flaw_line_below:
#line 1652 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 105:
//fix_flaw_line_below:
//#line 1657 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
//flaw_line_below:
#line 3352 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3361 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 105:
//flaw_line_below:
#line 1664 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 106:
//fix_flaw_line_below:
//#line 1669 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
//flaw_line_below:
#line 3372 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3381 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 106:
//flaw_line_below:
#line 1680 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 107:
//fix_flaw_line_below:
//#line 1685 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
//flaw_line_below:
#line 3388 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3397 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 107:
//flaw_line_below:
#line 1692 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 108:
//fix_flaw_line_below:
//#line 1697 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
//flaw_line_below:
#line 3408 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3417 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 108:
//flaw_line_below:
#line 1708 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 109:
//fix_flaw_line_below:
//#line 1713 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier
         {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        {
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
        {
          compiler->last_result = yr_parser_emit(
              yyscanner, OP_OBJ_VALUE, NULL);

          switch((yyvsp[0].expression).value.object->type)
          {
            case OBJECT_TYPE_INTEGER:
              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
              (yyval.expression).value.integer = UNDEFINED;
              break;
            case OBJECT_TYPE_FLOAT:
              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
              break;
            case OBJECT_TYPE_STRING:
              (yyval.expression).type = EXPRESSION_TYPE_STRING;
              (yyval.expression).value.sized_string = NULL;
              break;
            default:
              yr_compiler_set_error_extra_info_fmt(
                  compiler,
                  ""wrong usage of identifier \""%s\"""",
                  (yyvsp[0].expression).identifier);
              compiler->last_result = ERROR_WRONG_TYPE;
          }
        }
        else
        {
          assert(FALSE);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
//flaw_line_below:
#line 3457 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3466 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 109:
//flaw_line_below:
#line 1753 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 110:
//fix_flaw_line_below:
//#line 1758 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, ""-"");
 
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
              UNDEFINED : -((yyvsp[0].expression).value.integer);
          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
//flaw_line_below:
#line 3480 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3489 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 110:
//flaw_line_below:
#line 1772 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 111:
//fix_flaw_line_below:
//#line 1777 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""+"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
//flaw_line_below:
#line 3502 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3511 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 111:
//flaw_line_below:
#line 1790 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 112:
//fix_flaw_line_below:
//#line 1795 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""-"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
//flaw_line_below:
#line 3524 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3533 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 112:
//flaw_line_below:
#line 1808 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 113:
//fix_flaw_line_below:
//#line 1813 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""*"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
//flaw_line_below:
#line 3546 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3555 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 113:
//flaw_line_below:
#line 1826 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 114:
//fix_flaw_line_below:
//#line 1831 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""\\"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          if ((yyvsp[0].expression).value.integer != 0)
          {
            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          }
          else
          {
            compiler->last_result = ERROR_DIVISION_BY_ZERO;
            ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          }
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
//flaw_line_below:
#line 3576 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3585 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 114:
//flaw_line_below:
#line 1852 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 115:
//fix_flaw_line_below:
//#line 1857 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""%"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""%"");

        yr_parser_emit(yyscanner, OP_MOD, NULL);

        if ((yyvsp[0].expression).value.integer != 0)
        {
          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
          compiler->last_result = ERROR_DIVISION_BY_ZERO;
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         }
       }
//flaw_line_below:
#line 3598 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3607 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 115:
//flaw_line_below:
#line 1870 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 116:
//fix_flaw_line_below:
//#line 1875 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
//flaw_line_below:
#line 3612 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3621 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 116:
//flaw_line_below:
#line 1880 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 117:
//fix_flaw_line_below:
//#line 1885 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
//flaw_line_below:
#line 3626 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3635 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 117:
//flaw_line_below:
#line 1890 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 118:
//fix_flaw_line_below:
//#line 1895 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""|"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""|"");

        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
//flaw_line_below:
#line 3640 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3649 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 118:
//flaw_line_below:
#line 1900 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 119:
//fix_flaw_line_below:
//#line 1905 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""~"");
 
        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
             UNDEFINED : ~((yyvsp[0].expression).value.integer);
       }
//flaw_line_below:
#line 3654 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3663 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 119:
//flaw_line_below:
#line 1910 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 120:
//fix_flaw_line_below:
//#line 1915 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""<<"");

        yr_parser_emit(yyscanner, OP_SHL, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
//flaw_line_below:
#line 3668 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3677 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 120:
//flaw_line_below:
#line 1920 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 121:
//fix_flaw_line_below:
//#line 1925 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "">>"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "">>"");

        yr_parser_emit(yyscanner, OP_SHR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
//flaw_line_below:
#line 3682 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3691 ""grammar.c"" /* yacc.c:1646  */
     break;
 
//flaw_line_below:
  case 121:
//flaw_line_below:
#line 1930 ""grammar.y"" /* yacc.c:1646  */
//fix_flaw_line_below:
//  case 122:
//fix_flaw_line_below:
//#line 1935 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
//flaw_line_below:
#line 3690 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3699 ""grammar.c"" /* yacc.c:1646  */
     break;
 
 
//flaw_line_below:
#line 3694 ""grammar.c"" /* yacc.c:1646  */
//fix_flaw_line_below:
//#line 3703 ""grammar.c"" /* yacc.c:1646  */
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT (""-> $$ ="", yyr1[yyn], &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;

  /* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTOKENS];

  goto yynewstate;


/*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);

  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (yyscanner, compiler, YY_(""syntax error""));
#else
# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                        yyssp, yytoken)
      {
        char const *yymsgp = YY_(""syntax error"");
        int yysyntax_error_status;
        yysyntax_error_status = YYSYNTAX_ERROR;
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == 1)
          {
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
            if (!yymsg)
              {
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = 2;
              }
            else
              {
                yysyntax_error_status = YYSYNTAX_ERROR;
                yymsgp = yymsg;
              }
          }
        yyerror (yyscanner, compiler, yymsgp);
        if (yysyntax_error_status == 2)
          goto yyexhaustedlab;
      }
# undef YYSYNTAX_ERROR
#endif
    }



  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar <= YYEOF)
        {
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        }
      else
        {
          yydestruct (""Error: discarding"",
                      yytoken, &yylval, yyscanner, compiler);
          yychar = YYEMPTY;
        }
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        {
          yyn += YYTERROR;
          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
            {
              yyn = yytable[yyn];
              if (0 < yyn)
                break;
            }
        }

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;


      yydestruct (""Error: popping"",
                  yystos[yystate], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END


  /* Shift the error token.  */
  YY_SYMBOL_PRINT (""Shifting"", yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#if !defined yyoverflow || YYERROR_VERBOSE
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (yyscanner, compiler, YY_(""memory exhausted""));
  yyresult = 2;
  /* Fall through.  */
#endif

yyreturn:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct (""Cleanup: discarding lookahead"",
                  yytoken, &yylval, yyscanner, compiler);
    }
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct (""Cleanup: popping"",
                  yystos[*yyssp], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
 #endif
   return yyresult;
 }
",181653,"yyparse (void *yyscanner, YR_COMPILER* compiler)
{
/* The lookahead symbol.  */
int yychar;


/* The semantic value of the lookahead symbol.  */
/* Default value used for initialization, for pacifying older GCCs
   or non-GCC compilers.  */
YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);

    /* Number of syntax errors so far.  */
    int yynerrs;

    int yystate;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus;

    /* The stacks and their tools:
       'yyss': related to states.
       'yyvs': related to semantic values.

       Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* The state stack.  */
    yytype_int16 yyssa[YYINITDEPTH];
    yytype_int16 *yyss;
    yytype_int16 *yyssp;

    /* The semantic value stack.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs;
    YYSTYPE *yyvsp;

    YYSIZE_T yystacksize;

  int yyn;
  int yyresult;
  /* Lookahead token as an internal (translated) token number.  */
  int yytoken = 0;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;

#if YYERROR_VERBOSE
  /* Buffer for error messages, and its allocated size.  */
  char yymsgbuf[128];
  char *yymsg = yymsgbuf;
  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
#endif

#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  yyssp = yyss = yyssa;
  yyvsp = yyvs = yyvsa;
  yystacksize = YYINITDEPTH;

  YYDPRINTF ((stderr, ""Starting parse\n""));

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY; /* Cause a token to be read.  */
  goto yysetstate;

/*------------------------------------------------------------.
| yynewstate -- Push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
 yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;

 yysetstate:
  *yyssp = yystate;

  if (yyss + yystacksize - 1 <= yyssp)
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYSIZE_T yysize = yyssp - yyss + 1;

#ifdef yyoverflow
      {
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &'s don't force the real ones into
           memory.  */
        YYSTYPE *yyvs1 = yyvs;
        yytype_int16 *yyss1 = yyss;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_(""memory exhausted""),
                    &yyss1, yysize * sizeof (*yyssp),
                    &yyvs1, yysize * sizeof (*yyvsp),
                    &yystacksize);

        yyss = yyss1;
        yyvs = yyvs1;
      }
#else /* no yyoverflow */
# ifndef YYSTACK_RELOCATE
      goto yyexhaustedlab;
# else
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
        goto yyexhaustedlab;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
        yystacksize = YYMAXDEPTH;

      {
        yytype_int16 *yyss1 = yyss;
        union yyalloc *yyptr =
          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
        if (! yyptr)
          goto yyexhaustedlab;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
#  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
          YYSTACK_FREE (yyss1);
      }
# endif
#endif /* no yyoverflow */

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;

      YYDPRINTF ((stderr, ""Stack size increased to %lu\n"",
                  (unsigned long int) yystacksize));

      if (yyss + yystacksize - 1 <= yyssp)
        YYABORT;
    }

  YYDPRINTF ((stderr, ""Entering state %d\n"", yystate));

  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;

/*-----------.
| yybackup.  |
`-----------*/
yybackup:

  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, ""Reading a token: ""));
      yychar = yylex (&yylval, yyscanner, compiler);
    }

  if (yychar <= YYEOF)
    {
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, ""Now at end of input.\n""));
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT (""Next token is"", yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT (""Shifting"", yytoken, &yylval, &yylloc);

  /* Discard the shifted token.  */
  yychar = YYEMPTY;

  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- Do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
        case 8:
#line 230 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));

        yr_free((yyvsp[0].sized_string));

        ERROR_IF(result != ERROR_SUCCESS);
      }
#line 1661 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 9:
#line 242 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(
            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));

        ERROR_IF(rule == NULL);

        (yyval.rule) = rule;
      }
#line 1674 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 10:
#line 251 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1

        rule->tags = (yyvsp[-3].c_string);
        rule->metas = (yyvsp[-1].meta);
        rule->strings = (yyvsp[0].string);
      }
#line 1686 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 11:
#line 259 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-7].rule); // rule created in phase 1

        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(
            yyscanner, rule);

        yr_free((yyvsp[-8].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1701 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 12:
#line 274 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = NULL;
      }
#line 1709 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 13:
#line 278 ""grammar.y"" /* yacc.c:1646  */
    {

        YR_META null_meta;

        memset(&null_meta, 0xFF, sizeof(YR_META));
        null_meta.type = META_TYPE_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->metas_arena,
            &null_meta,
            sizeof(YR_META),
            NULL);

        (yyval.meta) = (yyvsp[0].meta);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1736 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 14:
#line 305 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = NULL;
      }
#line 1744 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 15:
#line 309 ""grammar.y"" /* yacc.c:1646  */
    {

        YR_STRING null_string;

        memset(&null_string, 0xFF, sizeof(YR_STRING));
        null_string.g_flags = STRING_GFLAGS_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->strings_arena,
            &null_string,
            sizeof(YR_STRING),
            NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.string) = (yyvsp[0].string);
      }
#line 1771 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 17:
#line 340 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0;  }
#line 1777 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 18:
#line 341 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 1783 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 19:
#line 346 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
#line 1789 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 20:
#line 347 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
#line 1795 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 21:
#line 353 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = NULL;
      }
#line 1803 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 22:
#line 357 ""grammar.y"" /* yacc.c:1646  */
    {

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, """", NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[0].c_string);
      }
#line 1821 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 23:
#line 375 ""grammar.y"" /* yacc.c:1646  */
    {
        char* identifier;

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = identifier;
      }
#line 1838 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 24:
#line 388 ""grammar.y"" /* yacc.c:1646  */
    {
        char* tag_name = (yyvsp[-1].c_string);
        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;

        while (tag_length > 0)
        {
          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
          {
            yr_compiler_set_error_extra_info(compiler, tag_name);
            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;
            break;
          }

          tag_name = (char*) yr_arena_next_address(
              yyget_extra(yyscanner)->sz_arena,
              tag_name,
              tag_length + 1);

          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        }

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_arena_write_string(
              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-1].c_string);
      }
#line 1874 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 25:
#line 424 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[0].meta); }
#line 1880 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 26:
#line 425 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[-1].meta); }
#line 1886 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 27:
#line 431 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);

        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_STRING,
            (yyvsp[-2].c_string),
            sized_string->c_string,
            0);

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1906 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 28:
#line 447 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-2].c_string),
            NULL,
            (yyvsp[0].integer));

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1923 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 29:
#line 460 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-3].c_string),
            NULL,
            -(yyvsp[0].integer));

        yr_free((yyvsp[-3].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1940 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 30:
#line 473 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            TRUE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1957 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 31:
#line 486 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            FALSE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1974 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 32:
#line 502 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[0].string); }
#line 1980 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 33:
#line 503 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[-1].string); }
#line 1986 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 34:
#line 509 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 1994 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 35:
#line 513 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);
        compiler->error_line = 0;
      }
#line 2009 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 36:
#line 524 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 2017 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 37:
#line 528 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);

        compiler->error_line = 0;
      }
#line 2033 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 38:
#line 540 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.string) == NULL);
      }
#line 2047 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 39:
#line 553 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0; }
#line 2053 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 40:
#line 554 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 2059 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 41:
#line 559 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_WIDE; }
#line 2065 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 42:
#line 560 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_ASCII; }
#line 2071 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 43:
#line 561 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
#line 2077 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 44:
#line 562 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
#line 2083 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 45:
#line 568 ""grammar.y"" /* yacc.c:1646  */
    {
        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));

        if (var_index >= 0)
        {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner,
              OP_PUSH_M,
              LOOP_LOCAL_VARS * var_index,
              NULL,
              NULL);

          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
          (yyval.expression).identifier = compiler->loop_identifier[var_index];
        }
        else
        {

          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
              compiler->objects_table, (yyvsp[0].c_string), NULL);

          if (object == NULL)
          {
            char* ns = compiler->current_namespace->name;

            object = (YR_OBJECT*) yr_hash_table_lookup(
                compiler->objects_table, (yyvsp[0].c_string), ns);
          }

          if (object != NULL)
          {
            char* id;

            compiler->last_result = yr_arena_write_string(
                compiler->sz_arena, (yyvsp[0].c_string), &id);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_LOAD,
                  id,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = object;
            (yyval.expression).identifier = object->identifier;
          }
          else
          {
            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
                compiler->rules_table,
                (yyvsp[0].c_string),
                compiler->current_namespace->name);

            if (rule != NULL)
            {
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_PUSH_RULE,
                  rule,
                  NULL,
                  NULL);

              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
              (yyval.expression).value.integer = UNDEFINED;
              (yyval.expression).identifier = rule->identifier;
            }
            else
            {
              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;
            }
          }
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2172 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 46:
#line 653 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT* field = NULL;

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
        {
          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));

          if (field != NULL)
          {
            char* ident;

            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[0].c_string), &ident);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_FIELD,
                  ident,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = field;
            (yyval.expression).identifier = field->identifier;
          }
          else
          {
            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
            compiler->last_result = ERROR_INVALID_FIELD_NAME;
          }
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-2].expression).identifier);

          compiler->last_result = ERROR_NOT_A_STRUCTURE;
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2222 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 47:
#line 699 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_ARRAY* array;
        YR_OBJECT_DICTIONARY* dict;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""array indexes must be of integer type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_INDEX_ARRAY, NULL);

          array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = array->prototype_item;
          (yyval.expression).identifier = array->identifier;
        }
        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""dictionary keys must be of string type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_LOOKUP_DICT, NULL);

          dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = dict->prototype_item;
          (yyval.expression).identifier = dict->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_INDEXABLE;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2283 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 48:
#line 757 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_FUNCTION* function;
        char* args_fmt;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
        {
          compiler->last_result = yr_parser_check_types(
              compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_parser_emit_with_arg_reloc(
                yyscanner,
                OP_CALL,
                args_fmt,
                NULL,
                NULL);

          function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = function->return_obj;
          (yyval.expression).identifier = function->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_A_FUNCTION;
        }

        yr_free((yyvsp[-1].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2328 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 49:
#line 801 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = yr_strdup(""""); }
#line 2334 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 50:
#line 802 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = (yyvsp[0].c_string); }
#line 2340 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 51:
#line 807 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);

        switch((yyvsp[0].expression).type)
        {
          case EXPRESSION_TYPE_INTEGER:
            strlcpy((yyval.c_string), ""i"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_FLOAT:
            strlcpy((yyval.c_string), ""f"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_BOOLEAN:
            strlcpy((yyval.c_string), ""b"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_STRING:
            strlcpy((yyval.c_string), ""s"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_REGEXP:
            strlcpy((yyval.c_string), ""r"", MAX_FUNCTION_ARGS);
            break;
        }

        ERROR_IF((yyval.c_string) == NULL);
      }
#line 2369 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 52:
#line 832 ""grammar.y"" /* yacc.c:1646  */
    {
        if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)
        {
          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;
        }
        else
        {
          switch((yyvsp[0].expression).type)
          {
            case EXPRESSION_TYPE_INTEGER:
              strlcat((yyvsp[-2].c_string), ""i"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_FLOAT:
              strlcat((yyvsp[-2].c_string), ""f"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_BOOLEAN:
              strlcat((yyvsp[-2].c_string), ""b"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_STRING:
              strlcat((yyvsp[-2].c_string), ""s"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_REGEXP:
              strlcat((yyvsp[-2].c_string), ""r"", MAX_FUNCTION_ARGS);
              break;
          }
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-2].c_string);
      }
#line 2405 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 53:
#line 868 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        RE* re;
        RE_ERROR error;

        int re_flags = 0;

        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
          re_flags |= RE_FLAGS_NO_CASE;

        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
          re_flags |= RE_FLAGS_DOT_ALL;

        compiler->last_result = yr_re_compile(
            sized_string->c_string,
            re_flags,
            compiler->re_code_arena,
            &re,
            &error);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)
          yr_compiler_set_error_extra_info(compiler, error.message);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              re->root_node->forward_code,
              NULL,
              NULL);

        yr_re_destroy(re);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
      }
#line 2451 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 54:
#line 914 ""grammar.y"" /* yacc.c:1646  */
    {
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
        {
          if ((yyvsp[0].expression).value.sized_string != NULL)
          {
            yywarning(yyscanner,
              ""Using literal string \""%s\"" in a boolean operation."",
              (yyvsp[0].expression).value.sized_string->c_string);
          }

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_STR_TO_BOOL, NULL);

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2474 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 55:
#line 936 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 1, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2487 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 56:
#line 945 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 0, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2500 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 57:
#line 954 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""matches"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, ""matches"");

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit(
              yyscanner,
              OP_MATCHES,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2519 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 58:
#line 969 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""contains"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, ""contains"");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_CONTAINS, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2535 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 59:
#line 981 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_string_identifier(
            yyscanner,
            (yyvsp[0].c_string),
            OP_FOUND,
            UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2553 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 60:
#line 995 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""at"");

        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2570 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 61:
#line 1008 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2585 ""grammar.c"" /* yacc.c:1646  */
    break;
 
   case 62:
 #line 1019 ""grammar.y"" /* yacc.c:1646  */
     {
         int var_index;
 
        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        var_index = yr_parser_lookup_loop_variable(
            yyscanner, (yyvsp[-1].c_string));

        if (var_index >= 0)
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-1].c_string));

          compiler->last_result = \
              ERROR_DUPLICATED_LOOP_IDENTIFIER;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 2619 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 63:
#line 1049 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        }
        else // INTEGER_SET_RANGE
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        }

        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
         compiler->loop_depth++;
       }
#line 2658 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 64:
#line 1084 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;


        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JNUNDEF,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);
        }
        else // INTEGER_SET_RANGE
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);

          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JLE,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);

          yr_parser_emit(yyscanner, OP_POP, NULL);
          yr_parser_emit(yyscanner, OP_POP, NULL);
        }

        yr_parser_emit(yyscanner, OP_POP, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

        compiler->loop_identifier[compiler->loop_depth] = NULL;
        yr_free((yyvsp[-8].c_string));
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2741 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 65:
#line 1163 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        if (compiler->loop_for_of_mem_offset != -1)
          compiler->last_result = \
            ERROR_NESTED_FOR_OF_LOOP;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_POP_M, mem_offset, &addr, NULL);

        compiler->loop_for_of_mem_offset = mem_offset;
        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = NULL;
         compiler->loop_depth++;
       }
#line 2775 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 66:
#line 1193 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        compiler->loop_for_of_mem_offset = -1;

        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;


        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JNUNDEF,
            compiler->loop_address[compiler->loop_depth],
            NULL,
            NULL);

        yr_parser_emit(yyscanner, OP_POP, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
 
       }
#line 2828 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 67:
#line 1242 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_OF, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2838 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 68:
#line 1248 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_NOT, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2848 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 69:
#line 1254 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JFALSE,
            0,          // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2878 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 70:
#line 1280 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* and_addr;


        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);


        fixup = compiler->fixup_stack_head;


        *(void**)(fixup->address) = (void*)(and_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2918 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 71:
#line 1316 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JTRUE,
            0,         // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2947 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 72:
#line 1341 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* or_addr;


        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);


        fixup = compiler->fixup_stack_head;


        *(void**)(fixup->address) = (void*)(or_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2987 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 73:
#line 1377 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3000 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 74:
#line 1386 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3013 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 75:
#line 1395 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3026 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 76:
#line 1404 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3039 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 77:
#line 1413 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""=="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3052 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 78:
#line 1422 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""!="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3065 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 79:
#line 1431 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3073 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 80:
#line 1435 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3081 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 81:
#line 1442 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_ENUMERATION; }
#line 3087 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 82:
#line 1443 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_RANGE; }
#line 3093 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 83:
#line 1449 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's lower bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }

        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's upper bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3115 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 84:
#line 1471 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;

        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3131 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 85:
#line 1483 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3146 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 86:
#line 1498 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3155 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 88:
#line 1504 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
         yr_parser_emit_pushes_for_strings(yyscanner, ""$*"");
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3166 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 91:
#line 1521 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3177 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 92:
#line 1528 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3188 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 94:
#line 1540 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3196 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 95:
#line 1544 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
       }
#line 3204 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 96:
#line 1552 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3212 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 97:
#line 1556 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_FILESIZE, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3226 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 98:
#line 1566 ""grammar.y"" /* yacc.c:1646  */
     {
         yywarning(yyscanner,
             ""Using deprecated \""entrypoint\"" keyword. Use the \""entry_point\"" ""
            ""function from PE module instead."");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_ENTRYPOINT, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3244 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 99:
#line 1580 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, ""intXXXX or uintXXXX"");
 

        compiler->last_result = yr_parser_emit(
            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3264 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 100:
#line 1596 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = (yyvsp[0].integer);
       }
#line 3278 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 101:
#line 1606 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg_double(
             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
       }
#line 3291 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 102:
#line 1615 ""grammar.y"" /* yacc.c:1646  */
     {
         SIZED_STRING* sized_string;
 
        compiler->last_result = yr_arena_write_data(
            compiler->sz_arena,
            (yyvsp[0].sized_string),
            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
            (void**) &sized_string);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              sized_string,
              NULL,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_STRING;
         (yyval.expression).value.sized_string = sized_string;
       }
#line 3320 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 103:
#line 1640 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3336 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 104:
#line 1652 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3352 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 105:
#line 1664 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3372 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 106:
#line 1680 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3388 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 107:
#line 1692 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3408 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 108:
#line 1708 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier
         {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        {
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
        {
          compiler->last_result = yr_parser_emit(
              yyscanner, OP_OBJ_VALUE, NULL);

          switch((yyvsp[0].expression).value.object->type)
          {
            case OBJECT_TYPE_INTEGER:
              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
              (yyval.expression).value.integer = UNDEFINED;
              break;
            case OBJECT_TYPE_FLOAT:
              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
              break;
            case OBJECT_TYPE_STRING:
              (yyval.expression).type = EXPRESSION_TYPE_STRING;
              (yyval.expression).value.sized_string = NULL;
              break;
            default:
              yr_compiler_set_error_extra_info_fmt(
                  compiler,
                  ""wrong usage of identifier \""%s\"""",
                  (yyvsp[0].expression).identifier);
              compiler->last_result = ERROR_WRONG_TYPE;
          }
        }
        else
        {
          assert(FALSE);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3457 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 109:
#line 1753 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, ""-"");
 
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
              UNDEFINED : -((yyvsp[0].expression).value.integer);
          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3480 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 110:
#line 1772 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""+"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3502 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 111:
#line 1790 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""-"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3524 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 112:
#line 1808 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""*"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3546 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 113:
#line 1826 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""\\"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          if ((yyvsp[0].expression).value.integer != 0)
          {
            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          }
          else
          {
            compiler->last_result = ERROR_DIVISION_BY_ZERO;
            ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          }
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3576 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 114:
#line 1852 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""%"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""%"");

        yr_parser_emit(yyscanner, OP_MOD, NULL);

        if ((yyvsp[0].expression).value.integer != 0)
        {
          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
          compiler->last_result = ERROR_DIVISION_BY_ZERO;
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         }
       }
#line 3598 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 115:
#line 1870 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3612 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 116:
#line 1880 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3626 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 117:
#line 1890 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""|"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""|"");

        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3640 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 118:
#line 1900 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""~"");
 
        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
             UNDEFINED : ~((yyvsp[0].expression).value.integer);
       }
#line 3654 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 119:
#line 1910 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""<<"");

        yr_parser_emit(yyscanner, OP_SHL, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3668 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 120:
#line 1920 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "">>"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "">>"");

        yr_parser_emit(yyscanner, OP_SHR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3682 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 121:
#line 1930 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3690 ""grammar.c"" /* yacc.c:1646  */
     break;
 
 
#line 3694 ""grammar.c"" /* yacc.c:1646  */
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT (""-> $$ ="", yyr1[yyn], &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;

  /* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTOKENS];

  goto yynewstate;


/*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);

  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (yyscanner, compiler, YY_(""syntax error""));
#else
# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                        yyssp, yytoken)
      {
        char const *yymsgp = YY_(""syntax error"");
        int yysyntax_error_status;
        yysyntax_error_status = YYSYNTAX_ERROR;
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == 1)
          {
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
            if (!yymsg)
              {
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = 2;
              }
            else
              {
                yysyntax_error_status = YYSYNTAX_ERROR;
                yymsgp = yymsg;
              }
          }
        yyerror (yyscanner, compiler, yymsgp);
        if (yysyntax_error_status == 2)
          goto yyexhaustedlab;
      }
# undef YYSYNTAX_ERROR
#endif
    }



  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar <= YYEOF)
        {
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        }
      else
        {
          yydestruct (""Error: discarding"",
                      yytoken, &yylval, yyscanner, compiler);
          yychar = YYEMPTY;
        }
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        {
          yyn += YYTERROR;
          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
            {
              yyn = yytable[yyn];
              if (0 < yyn)
                break;
            }
        }

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;


      yydestruct (""Error: popping"",
                  yystos[yystate], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END


  /* Shift the error token.  */
  YY_SYMBOL_PRINT (""Shifting"", yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#if !defined yyoverflow || YYERROR_VERBOSE
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (yyscanner, compiler, YY_(""memory exhausted""));
  yyresult = 2;
  /* Fall through.  */
#endif

yyreturn:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct (""Cleanup: discarding lookahead"",
                  yytoken, &yylval, yyscanner, compiler);
    }
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct (""Cleanup: popping"",
                  yystos[*yyssp], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
 #endif
   return yyresult;
 }
","yyparse (void *yyscanner, YR_COMPILER* compiler)
{
/* The lookahead symbol.  */
int yychar;


/* The semantic value of the lookahead symbol.  */
/* Default value used for initialization, for pacifying older GCCs
   or non-GCC compilers.  */
YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);

    /* Number of syntax errors so far.  */
    int yynerrs;

    int yystate;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus;

    /* The stacks and their tools:
       'yyss': related to states.
       'yyvs': related to semantic values.

       Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* The state stack.  */
    yytype_int16 yyssa[YYINITDEPTH];
    yytype_int16 *yyss;
    yytype_int16 *yyssp;

    /* The semantic value stack.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs;
    YYSTYPE *yyvsp;

    YYSIZE_T yystacksize;

  int yyn;
  int yyresult;
  /* Lookahead token as an internal (translated) token number.  */
  int yytoken = 0;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;

#if YYERROR_VERBOSE
  /* Buffer for error messages, and its allocated size.  */
  char yymsgbuf[128];
  char *yymsg = yymsgbuf;
  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
#endif

#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  yyssp = yyss = yyssa;
  yyvsp = yyvs = yyvsa;
  yystacksize = YYINITDEPTH;

  YYDPRINTF ((stderr, ""Starting parse\n""));

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY; /* Cause a token to be read.  */
  goto yysetstate;

/*------------------------------------------------------------.
| yynewstate -- Push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
 yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;

 yysetstate:
  *yyssp = yystate;

  if (yyss + yystacksize - 1 <= yyssp)
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYSIZE_T yysize = yyssp - yyss + 1;

#ifdef yyoverflow
      {
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &'s don't force the real ones into
           memory.  */
        YYSTYPE *yyvs1 = yyvs;
        yytype_int16 *yyss1 = yyss;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_(""memory exhausted""),
                    &yyss1, yysize * sizeof (*yyssp),
                    &yyvs1, yysize * sizeof (*yyvsp),
                    &yystacksize);

        yyss = yyss1;
        yyvs = yyvs1;
      }
#else /* no yyoverflow */
# ifndef YYSTACK_RELOCATE
      goto yyexhaustedlab;
# else
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
        goto yyexhaustedlab;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
        yystacksize = YYMAXDEPTH;

      {
        yytype_int16 *yyss1 = yyss;
        union yyalloc *yyptr =
          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
        if (! yyptr)
          goto yyexhaustedlab;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
#  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
          YYSTACK_FREE (yyss1);
      }
# endif
#endif /* no yyoverflow */

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;

      YYDPRINTF ((stderr, ""Stack size increased to %lu\n"",
                  (unsigned long int) yystacksize));

      if (yyss + yystacksize - 1 <= yyssp)
        YYABORT;
    }

  YYDPRINTF ((stderr, ""Entering state %d\n"", yystate));

  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;

/*-----------.
| yybackup.  |
`-----------*/
yybackup:

  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, ""Reading a token: ""));
      yychar = yylex (&yylval, yyscanner, compiler);
    }

  if (yychar <= YYEOF)
    {
      yychar = yytoken = YYEOF;
      YYDPRINTF ((stderr, ""Now at end of input.\n""));
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT (""Next token is"", yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT (""Shifting"", yytoken, &yylval, &yylloc);

  /* Discard the shifted token.  */
  yychar = YYEMPTY;

  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- Do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
        case 8:
#line 230 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));

        yr_free((yyvsp[0].sized_string));

        ERROR_IF(result != ERROR_SUCCESS);
      }
#line 1661 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 9:
#line 242 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(
            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));

        ERROR_IF(rule == NULL);

        (yyval.rule) = rule;
      }
#line 1674 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 10:
#line 251 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1

        rule->tags = (yyvsp[-3].c_string);
        rule->metas = (yyvsp[-1].meta);
        rule->strings = (yyvsp[0].string);
      }
#line 1686 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 11:
#line 259 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_RULE* rule = (yyvsp[-7].rule); // rule created in phase 1

        compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(
            yyscanner, rule);

        yr_free((yyvsp[-8].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1701 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 12:
#line 274 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = NULL;
      }
#line 1709 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 13:
#line 278 ""grammar.y"" /* yacc.c:1646  */
    {

        YR_META null_meta;

        memset(&null_meta, 0xFF, sizeof(YR_META));
        null_meta.type = META_TYPE_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->metas_arena,
            &null_meta,
            sizeof(YR_META),
            NULL);

        (yyval.meta) = (yyvsp[0].meta);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 1736 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 14:
#line 305 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = NULL;
      }
#line 1744 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 15:
#line 309 ""grammar.y"" /* yacc.c:1646  */
    {

        YR_STRING null_string;

        memset(&null_string, 0xFF, sizeof(YR_STRING));
        null_string.g_flags = STRING_GFLAGS_NULL;

        compiler->last_result = yr_arena_write_data(
            compiler->strings_arena,
            &null_string,
            sizeof(YR_STRING),
            NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.string) = (yyvsp[0].string);
      }
#line 1771 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 17:
#line 340 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0;  }
#line 1777 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 18:
#line 341 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 1783 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 19:
#line 346 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
#line 1789 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 20:
#line 347 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
#line 1795 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 21:
#line 353 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = NULL;
      }
#line 1803 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 22:
#line 357 ""grammar.y"" /* yacc.c:1646  */
    {

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, """", NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[0].c_string);
      }
#line 1821 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 23:
#line 375 ""grammar.y"" /* yacc.c:1646  */
    {
        char* identifier;

        compiler->last_result = yr_arena_write_string(
            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = identifier;
      }
#line 1838 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 24:
#line 388 ""grammar.y"" /* yacc.c:1646  */
    {
        char* tag_name = (yyvsp[-1].c_string);
        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;

        while (tag_length > 0)
        {
          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
          {
            yr_compiler_set_error_extra_info(compiler, tag_name);
            compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;
            break;
          }

          tag_name = (char*) yr_arena_next_address(
              yyget_extra(yyscanner)->sz_arena,
              tag_name,
              tag_length + 1);

          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        }

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_arena_write_string(
              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-1].c_string);
      }
#line 1874 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 25:
#line 424 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[0].meta); }
#line 1880 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 26:
#line 425 ""grammar.y"" /* yacc.c:1646  */
    {  (yyval.meta) = (yyvsp[-1].meta); }
#line 1886 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 27:
#line 431 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);

        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_STRING,
            (yyvsp[-2].c_string),
            sized_string->c_string,
            0);

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1906 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 28:
#line 447 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-2].c_string),
            NULL,
            (yyvsp[0].integer));

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1923 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 29:
#line 460 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_INTEGER,
            (yyvsp[-3].c_string),
            NULL,
            -(yyvsp[0].integer));

        yr_free((yyvsp[-3].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1940 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 30:
#line 473 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            TRUE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1957 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 31:
#line 486 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.meta) = yr_parser_reduce_meta_declaration(
            yyscanner,
            META_TYPE_BOOLEAN,
            (yyvsp[-2].c_string),
            NULL,
            FALSE);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF((yyval.meta) == NULL);
      }
#line 1974 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 32:
#line 502 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[0].string); }
#line 1980 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 33:
#line 503 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.string) = (yyvsp[-1].string); }
#line 1986 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 34:
#line 509 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 1994 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 35:
#line 513 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);
        compiler->error_line = 0;
      }
#line 2009 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 36:
#line 524 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->error_line = yyget_lineno(yyscanner);
      }
#line 2017 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 37:
#line 528 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));

        yr_free((yyvsp[-4].c_string));
        yr_free((yyvsp[-1].sized_string));

        ERROR_IF((yyval.string) == NULL);

        compiler->error_line = 0;
      }
#line 2033 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 38:
#line 540 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.string) = yr_parser_reduce_string_declaration(
            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));

        yr_free((yyvsp[-2].c_string));
        yr_free((yyvsp[0].sized_string));

        ERROR_IF((yyval.string) == NULL);
      }
#line 2047 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 39:
#line 553 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = 0; }
#line 2053 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 40:
#line 554 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
#line 2059 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 41:
#line 559 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_WIDE; }
#line 2065 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 42:
#line 560 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_ASCII; }
#line 2071 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 43:
#line 561 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
#line 2077 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 44:
#line 562 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
#line 2083 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 45:
#line 568 ""grammar.y"" /* yacc.c:1646  */
    {
        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));

        if (var_index >= 0)
        {
          compiler->last_result = yr_parser_emit_with_arg(
              yyscanner,
              OP_PUSH_M,
              LOOP_LOCAL_VARS * var_index,
              NULL,
              NULL);

          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
          (yyval.expression).identifier = compiler->loop_identifier[var_index];
        }
        else
        {

          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
              compiler->objects_table, (yyvsp[0].c_string), NULL);

          if (object == NULL)
          {
            char* ns = compiler->current_namespace->name;

            object = (YR_OBJECT*) yr_hash_table_lookup(
                compiler->objects_table, (yyvsp[0].c_string), ns);
          }

          if (object != NULL)
          {
            char* id;

            compiler->last_result = yr_arena_write_string(
                compiler->sz_arena, (yyvsp[0].c_string), &id);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_LOAD,
                  id,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = object;
            (yyval.expression).identifier = object->identifier;
          }
          else
          {
            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
                compiler->rules_table,
                (yyvsp[0].c_string),
                compiler->current_namespace->name);

            if (rule != NULL)
            {
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_PUSH_RULE,
                  rule,
                  NULL,
                  NULL);

              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
              (yyval.expression).value.integer = UNDEFINED;
              (yyval.expression).identifier = rule->identifier;
            }
            else
            {
              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
              compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;
            }
          }
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2172 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 46:
#line 653 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT* field = NULL;

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
        {
          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));

          if (field != NULL)
          {
            char* ident;

            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[0].c_string), &ident);

            if (compiler->last_result == ERROR_SUCCESS)
              compiler->last_result = yr_parser_emit_with_arg_reloc(
                  yyscanner,
                  OP_OBJ_FIELD,
                  ident,
                  NULL,
                  NULL);

            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
            (yyval.expression).value.object = field;
            (yyval.expression).identifier = field->identifier;
          }
          else
          {
            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
            compiler->last_result = ERROR_INVALID_FIELD_NAME;
          }
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-2].expression).identifier);

          compiler->last_result = ERROR_NOT_A_STRUCTURE;
        }

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2222 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 47:
#line 699 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_ARRAY* array;
        YR_OBJECT_DICTIONARY* dict;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""array indexes must be of integer type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_INDEX_ARRAY, NULL);

          array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = array->prototype_item;
          (yyval.expression).identifier = array->identifier;
        }
        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
        {
          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
          {
            yr_compiler_set_error_extra_info(
                compiler, ""dictionary keys must be of string type"");
            compiler->last_result = ERROR_WRONG_TYPE;
          }

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_LOOKUP_DICT, NULL);

          dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = dict->prototype_item;
          (yyval.expression).identifier = dict->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_INDEXABLE;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2283 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 48:
#line 757 ""grammar.y"" /* yacc.c:1646  */
    {
        YR_OBJECT_FUNCTION* function;
        char* args_fmt;

        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
        {
          compiler->last_result = yr_parser_check_types(
              compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_arena_write_string(
              compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);

          if (compiler->last_result == ERROR_SUCCESS)
            compiler->last_result = yr_parser_emit_with_arg_reloc(
                yyscanner,
                OP_CALL,
                args_fmt,
                NULL,
                NULL);

          function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;

          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
          (yyval.expression).value.object = function->return_obj;
          (yyval.expression).identifier = function->identifier;
        }
        else
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-3].expression).identifier);

          compiler->last_result = ERROR_NOT_A_FUNCTION;
        }

        yr_free((yyvsp[-1].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
      }
#line 2328 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 49:
#line 801 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = yr_strdup(""""); }
#line 2334 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 50:
#line 802 ""grammar.y"" /* yacc.c:1646  */
    { (yyval.c_string) = (yyvsp[0].c_string); }
#line 2340 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 51:
#line 807 ""grammar.y"" /* yacc.c:1646  */
    {
        (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);

        switch((yyvsp[0].expression).type)
        {
          case EXPRESSION_TYPE_INTEGER:
            strlcpy((yyval.c_string), ""i"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_FLOAT:
            strlcpy((yyval.c_string), ""f"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_BOOLEAN:
            strlcpy((yyval.c_string), ""b"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_STRING:
            strlcpy((yyval.c_string), ""s"", MAX_FUNCTION_ARGS);
            break;
          case EXPRESSION_TYPE_REGEXP:
            strlcpy((yyval.c_string), ""r"", MAX_FUNCTION_ARGS);
            break;
        }

        ERROR_IF((yyval.c_string) == NULL);
      }
#line 2369 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 52:
#line 832 ""grammar.y"" /* yacc.c:1646  */
    {
        if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)
        {
          compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;
        }
        else
        {
          switch((yyvsp[0].expression).type)
          {
            case EXPRESSION_TYPE_INTEGER:
              strlcat((yyvsp[-2].c_string), ""i"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_FLOAT:
              strlcat((yyvsp[-2].c_string), ""f"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_BOOLEAN:
              strlcat((yyvsp[-2].c_string), ""b"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_STRING:
              strlcat((yyvsp[-2].c_string), ""s"", MAX_FUNCTION_ARGS);
              break;
            case EXPRESSION_TYPE_REGEXP:
              strlcat((yyvsp[-2].c_string), ""r"", MAX_FUNCTION_ARGS);
              break;
          }
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.c_string) = (yyvsp[-2].c_string);
      }
#line 2405 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 53:
#line 868 ""grammar.y"" /* yacc.c:1646  */
    {
        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        RE* re;
        RE_ERROR error;

        int re_flags = 0;

        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
          re_flags |= RE_FLAGS_NO_CASE;

        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
          re_flags |= RE_FLAGS_DOT_ALL;

        compiler->last_result = yr_re_compile(
            sized_string->c_string,
            re_flags,
            compiler->re_code_arena,
            &re,
            &error);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)
          yr_compiler_set_error_extra_info(compiler, error.message);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              re->root_node->forward_code,
              NULL,
              NULL);

        yr_re_destroy(re);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
      }
#line 2451 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 54:
#line 914 ""grammar.y"" /* yacc.c:1646  */
    {
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
        {
          if ((yyvsp[0].expression).value.sized_string != NULL)
          {
            yywarning(yyscanner,
              ""Using literal string \""%s\"" in a boolean operation."",
              (yyvsp[0].expression).value.sized_string->c_string);
          }

          compiler->last_result = yr_parser_emit(
              yyscanner, OP_STR_TO_BOOL, NULL);

          ERROR_IF(compiler->last_result != ERROR_SUCCESS);
        }

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2474 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 55:
#line 936 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 1, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2487 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 56:
#line 945 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, 0, NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2500 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 57:
#line 954 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""matches"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, ""matches"");

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit(
              yyscanner,
              OP_MATCHES,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2519 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 58:
#line 969 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""contains"");
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, ""contains"");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_CONTAINS, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2535 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 59:
#line 981 ""grammar.y"" /* yacc.c:1646  */
    {
        int result = yr_parser_reduce_string_identifier(
            yyscanner,
            (yyvsp[0].c_string),
            OP_FOUND,
            UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2553 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 60:
#line 995 ""grammar.y"" /* yacc.c:1646  */
    {
        CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""at"");

        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2570 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 61:
#line 1008 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->last_result = yr_parser_reduce_string_identifier(
            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);

        yr_free((yyvsp[-2].c_string));

        ERROR_IF(compiler->last_result!= ERROR_SUCCESS);

        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
      }
#line 2585 ""grammar.c"" /* yacc.c:1646  */
    break;
 
   case 62:
 #line 1019 ""grammar.y"" /* yacc.c:1646  */
    {
        compiler->loop_depth--;
        compiler->loop_identifier[compiler->loop_depth] = NULL;
      }
#line 2594 ""grammar.c"" /* yacc.c:1646  */
    break;

  case 63:
#line 1024 ""grammar.y"" /* yacc.c:1646  */
     {
         int var_index;
 
        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
              ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        var_index = yr_parser_lookup_loop_variable(
            yyscanner, (yyvsp[-1].c_string));

        if (var_index >= 0)
        {
          yr_compiler_set_error_extra_info(
              compiler, (yyvsp[-1].c_string));

          compiler->last_result = \
              ERROR_DUPLICATED_LOOP_IDENTIFIER;
        }

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit_with_arg(
            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 2628 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 64:
#line 1054 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        }
        else // INTEGER_SET_RANGE
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        }

        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
         compiler->loop_depth++;
       }
#line 2667 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 65:
#line 1089 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;


        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
        {
          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JNUNDEF,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);
        }
        else // INTEGER_SET_RANGE
        {
          yr_parser_emit_with_arg(
              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);

          yr_parser_emit_with_arg(
              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);

          yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_JLE,
              compiler->loop_address[compiler->loop_depth],
              NULL,
              NULL);

          yr_parser_emit(yyscanner, OP_POP, NULL);
          yr_parser_emit(yyscanner, OP_POP, NULL);
        }

        yr_parser_emit(yyscanner, OP_POP, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

        compiler->loop_identifier[compiler->loop_depth] = NULL;
        yr_free((yyvsp[-8].c_string));
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2750 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 66:
#line 1168 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;

        if (compiler->loop_depth == MAX_LOOP_NESTING)
          compiler->last_result = \
            ERROR_LOOP_NESTING_LIMIT_EXCEEDED;

        if (compiler->loop_for_of_mem_offset != -1)
          compiler->last_result = \
            ERROR_NESTED_FOR_OF_LOOP;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_POP_M, mem_offset, &addr, NULL);

        compiler->loop_for_of_mem_offset = mem_offset;
        compiler->loop_address[compiler->loop_depth] = addr;
         compiler->loop_identifier[compiler->loop_depth] = NULL;
         compiler->loop_depth++;
       }
#line 2784 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 67:
#line 1198 ""grammar.y"" /* yacc.c:1646  */
     {
         int mem_offset;
 
        compiler->loop_depth--;
        compiler->loop_for_of_mem_offset = -1;

        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;


        yr_parser_emit_with_arg(
            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JNUNDEF,
            compiler->loop_address[compiler->loop_depth],
            NULL,
            NULL);

        yr_parser_emit(yyscanner, OP_POP, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);

        yr_parser_emit_with_arg(
            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);

        yr_parser_emit(yyscanner, OP_INT_LE, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
 
       }
#line 2837 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 68:
#line 1247 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_OF, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2847 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 69:
#line 1253 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit(yyscanner, OP_NOT, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2857 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 70:
#line 1259 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JFALSE,
            0,          // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2887 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 71:
#line 1285 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* and_addr;


        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);


        fixup = compiler->fixup_stack_head;


        *(void**)(fixup->address) = (void*)(and_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2927 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 72:
#line 1321 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;

        compiler->last_result = yr_parser_emit_with_arg_reloc(
            yyscanner,
            OP_JTRUE,
            0,         // still don't know the jump destination
            NULL,
            &jmp_destination_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));

        if (fixup == NULL)
          compiler->last_error = ERROR_INSUFFICIENT_MEMORY;

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        fixup->address = jmp_destination_addr;
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2956 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 73:
#line 1346 ""grammar.y"" /* yacc.c:1646  */
     {
         YR_FIXUP* fixup;
         uint8_t* or_addr;


        compiler->last_result = yr_arena_reserve_memory(
            compiler->code_arena, 2);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);


        fixup = compiler->fixup_stack_head;


        *(void**)(fixup->address) = (void*)(or_addr + 1);

        compiler->fixup_stack_head = fixup->next;
        yr_free(fixup);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2996 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 74:
#line 1382 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3009 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 75:
#line 1391 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3022 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 76:
#line 1400 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3035 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 77:
#line 1409 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3048 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 78:
#line 1418 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""=="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3061 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 79:
#line 1427 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""!="", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3074 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 80:
#line 1436 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3082 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 81:
#line 1440 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3090 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 82:
#line 1447 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_ENUMERATION; }
#line 3096 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 83:
#line 1448 ""grammar.y"" /* yacc.c:1646  */
     { (yyval.integer) = INTEGER_SET_RANGE; }
#line 3102 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 84:
#line 1454 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's lower bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }

        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for range's upper bound"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3124 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 85:
#line 1476 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;

        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3140 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 86:
#line 1488 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
          yr_compiler_set_error_extra_info(
              compiler, ""wrong type for enumeration item"");
          compiler->last_result = ERROR_WRONG_TYPE;
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3155 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 87:
#line 1503 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3164 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 89:
#line 1509 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
         yr_parser_emit_pushes_for_strings(yyscanner, ""$*"");
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3175 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 92:
#line 1526 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3186 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 93:
#line 1533 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3197 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 95:
#line 1545 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3205 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 96:
#line 1549 ""grammar.y"" /* yacc.c:1646  */
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
       }
#line 3213 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 97:
#line 1557 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3221 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 98:
#line 1561 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_FILESIZE, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3235 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 99:
#line 1571 ""grammar.y"" /* yacc.c:1646  */
     {
         yywarning(yyscanner,
             ""Using deprecated \""entrypoint\"" keyword. Use the \""entry_point\"" ""
            ""function from PE module instead."");

        compiler->last_result = yr_parser_emit(
            yyscanner, OP_ENTRYPOINT, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3253 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 100:
#line 1585 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, ""intXXXX or uintXXXX"");
 

        compiler->last_result = yr_parser_emit(
            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3273 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 101:
#line 1601 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = (yyvsp[0].integer);
       }
#line 3287 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 102:
#line 1611 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg_double(
             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
       }
#line 3300 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 103:
#line 1620 ""grammar.y"" /* yacc.c:1646  */
     {
         SIZED_STRING* sized_string;
 
        compiler->last_result = yr_arena_write_data(
            compiler->sz_arena,
            (yyvsp[0].sized_string),
            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
            (void**) &sized_string);

        yr_free((yyvsp[0].sized_string));

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_emit_with_arg_reloc(
              yyscanner,
              OP_PUSH,
              sized_string,
              NULL,
              NULL);

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_STRING;
         (yyval.expression).value.sized_string = sized_string;
       }
#line 3329 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 104:
#line 1645 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3345 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 105:
#line 1657 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3361 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 106:
#line 1669 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3381 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 107:
#line 1685 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[-3].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3397 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 108:
#line 1697 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);

        if (compiler->last_result == ERROR_SUCCESS)
          compiler->last_result = yr_parser_reduce_string_identifier(
              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);

        yr_free((yyvsp[0].c_string));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3417 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 109:
#line 1713 ""grammar.y"" /* yacc.c:1646  */
     {
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier
         {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        {
          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
          (yyval.expression).value.integer = UNDEFINED;
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
        {
          compiler->last_result = yr_parser_emit(
              yyscanner, OP_OBJ_VALUE, NULL);

          switch((yyvsp[0].expression).value.object->type)
          {
            case OBJECT_TYPE_INTEGER:
              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
              (yyval.expression).value.integer = UNDEFINED;
              break;
            case OBJECT_TYPE_FLOAT:
              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
              break;
            case OBJECT_TYPE_STRING:
              (yyval.expression).type = EXPRESSION_TYPE_STRING;
              (yyval.expression).value.sized_string = NULL;
              break;
            default:
              yr_compiler_set_error_extra_info_fmt(
                  compiler,
                  ""wrong usage of identifier \""%s\"""",
                  (yyvsp[0].expression).identifier);
              compiler->last_result = ERROR_WRONG_TYPE;
          }
        }
        else
        {
          assert(FALSE);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3466 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 110:
#line 1758 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, ""-"");
 
        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
              UNDEFINED : -((yyvsp[0].expression).value.integer);
          compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        }
        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
        {
          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
          compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3489 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 111:
#line 1777 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""+"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3511 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 112:
#line 1795 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""-"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3533 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 113:
#line 1813 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""*"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3555 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 114:
#line 1831 ""grammar.y"" /* yacc.c:1646  */
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""\\"", (yyvsp[-2].expression), (yyvsp[0].expression));

        ERROR_IF(compiler->last_result != ERROR_SUCCESS);

        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        {
          if ((yyvsp[0].expression).value.integer != 0)
          {
            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
          }
          else
          {
            compiler->last_result = ERROR_DIVISION_BY_ZERO;
            ERROR_IF(compiler->last_result != ERROR_SUCCESS);
          }
        }
        else
        {
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3585 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 115:
#line 1857 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""%"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""%"");

        yr_parser_emit(yyscanner, OP_MOD, NULL);

        if ((yyvsp[0].expression).value.integer != 0)
        {
          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        }
        else
        {
          compiler->last_result = ERROR_DIVISION_BY_ZERO;
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         }
       }
#line 3607 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 116:
#line 1875 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3621 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 117:
#line 1885 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");

        yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3635 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 118:
#line 1895 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""|"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""|"");

        yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3649 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 119:
#line 1905 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""~"");
 
        yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);

        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
             UNDEFINED : ~((yyvsp[0].expression).value.integer);
       }
#line 3663 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 120:
#line 1915 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""<<"");

        yr_parser_emit(yyscanner, OP_SHL, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3677 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 121:
#line 1925 ""grammar.y"" /* yacc.c:1646  */
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "">>"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "">>"");

        yr_parser_emit(yyscanner, OP_SHR, NULL);

         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3691 ""grammar.c"" /* yacc.c:1646  */
     break;
 
  case 122:
#line 1935 ""grammar.y"" /* yacc.c:1646  */
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3699 ""grammar.c"" /* yacc.c:1646  */
     break;
 
 
#line 3703 ""grammar.c"" /* yacc.c:1646  */
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT (""-> $$ ="", yyr1[yyn], &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;

  /* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTOKENS];

  goto yynewstate;


/*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);

  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (yyscanner, compiler, YY_(""syntax error""));
#else
# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                        yyssp, yytoken)
      {
        char const *yymsgp = YY_(""syntax error"");
        int yysyntax_error_status;
        yysyntax_error_status = YYSYNTAX_ERROR;
        if (yysyntax_error_status == 0)
          yymsgp = yymsg;
        else if (yysyntax_error_status == 1)
          {
            if (yymsg != yymsgbuf)
              YYSTACK_FREE (yymsg);
            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
            if (!yymsg)
              {
                yymsg = yymsgbuf;
                yymsg_alloc = sizeof yymsgbuf;
                yysyntax_error_status = 2;
              }
            else
              {
                yysyntax_error_status = YYSYNTAX_ERROR;
                yymsgp = yymsg;
              }
          }
        yyerror (yyscanner, compiler, yymsgp);
        if (yysyntax_error_status == 2)
          goto yyexhaustedlab;
      }
# undef YYSYNTAX_ERROR
#endif
    }



  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar <= YYEOF)
        {
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        }
      else
        {
          yydestruct (""Error: discarding"",
                      yytoken, &yylval, yyscanner, compiler);
          yychar = YYEMPTY;
        }
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        {
          yyn += YYTERROR;
          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
            {
              yyn = yytable[yyn];
              if (0 < yyn)
                break;
            }
        }

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;


      yydestruct (""Error: popping"",
                  yystos[yystate], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END


  /* Shift the error token.  */
  YY_SYMBOL_PRINT (""Shifting"", yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#if !defined yyoverflow || YYERROR_VERBOSE
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (yyscanner, compiler, YY_(""memory exhausted""));
  yyresult = 2;
  /* Fall through.  */
#endif

yyreturn:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct (""Cleanup: discarding lookahead"",
                  yytoken, &yylval, yyscanner, compiler);
    }
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct (""Cleanup: popping"",
                  yystos[*yyssp], yyvsp, yyscanner, compiler);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
 #endif
   return yyresult;
 }
","The provided code implements a parser function, `yyparse`, which is part of a parser generated by a tool like Bison. This function is responsible for analyzing the syntax of input data based on predefined grammar rules. It initializes various variables and stacks to manage states and semantic values during parsing. The function reads tokens, processes them according to the current state, and handles syntax errors. It supports dynamic stack resizing to accommodate varying input sizes and includes mechanisms for semantic actions, such as reducing rules and managing error reporting. Overall, it facilitates the parsing of structured input into a format suitable for further processing.","The code implements a parser that processes structured input based on defined grammar rules. It initializes necessary data structures to manage states and semantic values, allowing for dynamic adjustments to accommodate varying input sizes. The parser reads tokens, evaluates them according to the current state, and performs actions such as reducing rules and handling errors. It includes mechanisms for error reporting and recovery, ensuring robust parsing. Overall, the functionality focuses on transforming input data into a structured format suitable for further analysis or processing, while maintaining the integrity of the parsing process.","The vulnerability in the original code stemmed from inadequate handling of memory allocation during stack resizing, which could lead to a buffer overflow or memory exhaustion if the stack size exceeded predefined limits. Specifically, the code did not properly check the results of memory allocation functions, potentially allowing for the use of uninitialized pointers. The fix involved implementing checks after memory allocation calls, such as `yr_malloc` and `yyoverflow`, to ensure that the allocated memory was valid before proceeding. This added robustness by preventing the parser from operating on invalid memory, thus mitigating the risk of crashes or undefined behavior.","The vulnerability in the original code was related to insufficient checks during memory allocation and stack resizing, which could lead to buffer overflows or memory exhaustion. This lack of validation meant that the program could attempt to use uninitialized or invalid memory, resulting in potential crashes or undefined behavior. The fix involved adding explicit checks after memory allocation operations to ensure that the allocated memory was valid before further use. This enhancement improved the robustness of the code by preventing operations on invalid memory, thereby mitigating risks associated with memory management errors.","The vulnerability was fixed by implementing checks after memory allocation functions, specifically within the stack resizing logic. In the updated code, after calling `yyoverflow` and `yr_malloc`, the results are validated to ensure that the allocated pointers are not null. For instance, if `yyptr` from `yr_malloc` is null, the code now properly handles this scenario by transitioning to an error handling state. Additionally, the code checks if the new stack size exceeds predefined limits, preventing further operations if the allocation fails, thus enhancing the overall stability and safety of the parser.","The vulnerability was addressed by incorporating rigorous checks after memory allocation operations to ensure that the allocated memory was valid before any further processing. This involved verifying that pointers returned from allocation functions were not null, which would indicate a failure in memory allocation. Additionally, the code was modified to handle scenarios where the requested memory size exceeded predefined limits, preventing potential buffer overflows. These enhancements improved the overall robustness of the code by ensuring that operations were only performed on valid memory, thereby reducing the risk of crashes and undefined behavior.","CWE-789, CWE-119, CWE-476, CWE-131, CWE-789, CWE-401, CWE-122, CWE-190, CWE-680, CWE-400",N,-1
32,32,181661,181661,,Local,Not required,Complete,CVE-2016-10200,https://www.cvedetails.com/cve/CVE-2016-10200/,CWE-416,Medium,Complete,Complete,,2017-03-07,6.9,"Race condition in the L2TPv3 IP Encapsulation feature in the Linux kernel before 4.8.14 allows local users to gain privileges or cause a denial of service (use-after-free) by making multiple bind system calls without properly ascertaining whether a socket has the SOCK_ZAPPED status, related to net/l2tp/l2tp_ip.c and net/l2tp/l2tp_ip6.c.",2018-01-04,DoS +Priv ,3,https://github.com/torvalds/linux/commit/32c231164b762dddefa13af5a0101032c70b50ef,32c231164b762dddefa13af5a0101032c70b50ef,"l2tp: fix racy SOCK_ZAPPED flag check in l2tp_ip{,6}_bind()

Lock socket before checking the SOCK_ZAPPED flag in l2tp_ip6_bind().
Without lock, a concurrent call could modify the socket flags between
the sock_flag(sk, SOCK_ZAPPED) test and the lock_sock() call. This way,
a socket could be inserted twice in l2tp_ip6_bind_table. Releasing it
would then leave a stale pointer there, generating use-after-free
errors when walking through the list or modifying adjacent entries.

BUG: KASAN: use-after-free in l2tp_ip6_close+0x22e/0x290 at addr ffff8800081b0ed8
Write of size 8 by task syz-executor/10987
CPU: 0 PID: 10987 Comm: syz-executor Not tainted 4.8.0+ #39
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.8.2-0-g33fbe13 by qemu-project.org 04/01/2014
 ffff880031d97838 ffffffff829f835b ffff88001b5a1640 ffff8800081b0ec0
 ffff8800081b15a0 ffff8800081b6d20 ffff880031d97860 ffffffff8174d3cc
 ffff880031d978f0 ffff8800081b0e80 ffff88001b5a1640 ffff880031d978e0
Call Trace:
 [<ffffffff829f835b>] dump_stack+0xb3/0x118 lib/dump_stack.c:15
 [<ffffffff8174d3cc>] kasan_object_err+0x1c/0x70 mm/kasan/report.c:156
 [<     inline     >] print_address_description mm/kasan/report.c:194
 [<ffffffff8174d666>] kasan_report_error+0x1f6/0x4d0 mm/kasan/report.c:283
 [<     inline     >] kasan_report mm/kasan/report.c:303
 [<ffffffff8174db7e>] __asan_report_store8_noabort+0x3e/0x40 mm/kasan/report.c:329
 [<     inline     >] __write_once_size ./include/linux/compiler.h:249
 [<     inline     >] __hlist_del ./include/linux/list.h:622
 [<     inline     >] hlist_del_init ./include/linux/list.h:637
 [<ffffffff8579047e>] l2tp_ip6_close+0x22e/0x290 net/l2tp/l2tp_ip6.c:239
 [<ffffffff850b2dfd>] inet_release+0xed/0x1c0 net/ipv4/af_inet.c:415
 [<ffffffff851dc5a0>] inet6_release+0x50/0x70 net/ipv6/af_inet6.c:422
 [<ffffffff84c4581d>] sock_release+0x8d/0x1d0 net/socket.c:570
 [<ffffffff84c45976>] sock_close+0x16/0x20 net/socket.c:1017
 [<ffffffff817a108c>] __fput+0x28c/0x780 fs/file_table.c:208
 [<ffffffff817a1605>] ____fput+0x15/0x20 fs/file_table.c:244
 [<ffffffff813774f9>] task_work_run+0xf9/0x170
 [<ffffffff81324aae>] do_exit+0x85e/0x2a00
 [<ffffffff81326dc8>] do_group_exit+0x108/0x330
 [<ffffffff81348cf7>] get_signal+0x617/0x17a0 kernel/signal.c:2307
 [<ffffffff811b49af>] do_signal+0x7f/0x18f0
 [<ffffffff810039bf>] exit_to_usermode_loop+0xbf/0x150 arch/x86/entry/common.c:156
 [<     inline     >] prepare_exit_to_usermode arch/x86/entry/common.c:190
 [<ffffffff81006060>] syscall_return_slowpath+0x1a0/0x1e0 arch/x86/entry/common.c:259
 [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4/0xc6
Object at ffff8800081b0ec0, in cache L2TP/IPv6 size: 1448
Allocated:
PID = 10987
 [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16/0x20
 [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46/0xd0
 [ 1116.897025] [<ffffffff8174c9ad>] kasan_kmalloc+0xad/0xe0
 [ 1116.897025] [<ffffffff8174cee2>] kasan_slab_alloc+0x12/0x20
 [ 1116.897025] [<     inline     >] slab_post_alloc_hook mm/slab.h:417
 [ 1116.897025] [<     inline     >] slab_alloc_node mm/slub.c:2708
 [ 1116.897025] [<     inline     >] slab_alloc mm/slub.c:2716
 [ 1116.897025] [<ffffffff817476a8>] kmem_cache_alloc+0xc8/0x2b0 mm/slub.c:2721
 [ 1116.897025] [<ffffffff84c4f6a9>] sk_prot_alloc+0x69/0x2b0 net/core/sock.c:1326
 [ 1116.897025] [<ffffffff84c58ac8>] sk_alloc+0x38/0xae0 net/core/sock.c:1388
 [ 1116.897025] [<ffffffff851ddf67>] inet6_create+0x2d7/0x1000 net/ipv6/af_inet6.c:182
 [ 1116.897025] [<ffffffff84c4af7b>] __sock_create+0x37b/0x640 net/socket.c:1153
 [ 1116.897025] [<     inline     >] sock_create net/socket.c:1193
 [ 1116.897025] [<     inline     >] SYSC_socket net/socket.c:1223
 [ 1116.897025] [<ffffffff84c4b46f>] SyS_socket+0xef/0x1b0 net/socket.c:1203
 [ 1116.897025] [<ffffffff85e4d685>] entry_SYSCALL_64_fastpath+0x23/0xc6
Freed:
PID = 10987
 [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16/0x20
 [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46/0xd0
 [ 1116.897025] [<ffffffff8174cf61>] kasan_slab_free+0x71/0xb0
 [ 1116.897025] [<     inline     >] slab_free_hook mm/slub.c:1352
 [ 1116.897025] [<     inline     >] slab_free_freelist_hook mm/slub.c:1374
 [ 1116.897025] [<     inline     >] slab_free mm/slub.c:2951
 [ 1116.897025] [<ffffffff81748b28>] kmem_cache_free+0xc8/0x330 mm/slub.c:2973
 [ 1116.897025] [<     inline     >] sk_prot_free net/core/sock.c:1369
 [ 1116.897025] [<ffffffff84c541eb>] __sk_destruct+0x32b/0x4f0 net/core/sock.c:1444
 [ 1116.897025] [<ffffffff84c5aca4>] sk_destruct+0x44/0x80 net/core/sock.c:1452
 [ 1116.897025] [<ffffffff84c5ad33>] __sk_free+0x53/0x220 net/core/sock.c:1460
 [ 1116.897025] [<ffffffff84c5af23>] sk_free+0x23/0x30 net/core/sock.c:1471
 [ 1116.897025] [<ffffffff84c5cb6c>] sk_common_release+0x28c/0x3e0 ./include/net/sock.h:1589
 [ 1116.897025] [<ffffffff8579044e>] l2tp_ip6_close+0x1fe/0x290 net/l2tp/l2tp_ip6.c:243
 [ 1116.897025] [<ffffffff850b2dfd>] inet_release+0xed/0x1c0 net/ipv4/af_inet.c:415
 [ 1116.897025] [<ffffffff851dc5a0>] inet6_release+0x50/0x70 net/ipv6/af_inet6.c:422
 [ 1116.897025] [<ffffffff84c4581d>] sock_release+0x8d/0x1d0 net/socket.c:570
 [ 1116.897025] [<ffffffff84c45976>] sock_close+0x16/0x20 net/socket.c:1017
 [ 1116.897025] [<ffffffff817a108c>] __fput+0x28c/0x780 fs/file_table.c:208
 [ 1116.897025] [<ffffffff817a1605>] ____fput+0x15/0x20 fs/file_table.c:244
 [ 1116.897025] [<ffffffff813774f9>] task_work_run+0xf9/0x170
 [ 1116.897025] [<ffffffff81324aae>] do_exit+0x85e/0x2a00
 [ 1116.897025] [<ffffffff81326dc8>] do_group_exit+0x108/0x330
 [ 1116.897025] [<ffffffff81348cf7>] get_signal+0x617/0x17a0 kernel/signal.c:2307
 [ 1116.897025] [<ffffffff811b49af>] do_signal+0x7f/0x18f0
 [ 1116.897025] [<ffffffff810039bf>] exit_to_usermode_loop+0xbf/0x150 arch/x86/entry/common.c:156
 [ 1116.897025] [<     inline     >] prepare_exit_to_usermode arch/x86/entry/common.c:190
 [ 1116.897025] [<ffffffff81006060>] syscall_return_slowpath+0x1a0/0x1e0 arch/x86/entry/common.c:259
 [ 1116.897025] [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4/0xc6
Memory state around the buggy address:
 ffff8800081b0d80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ffff8800081b0e00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
>ffff8800081b0e80: fc fc fc fc fc fc fc fc fb fb fb fb fb fb fb fb
                                                    ^
 ffff8800081b0f00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff8800081b0f80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb

==================================================================

The same issue exists with l2tp_ip_bind() and l2tp_ip_bind_table.

Fixes: c51ce49735c1 (""l2tp: fix oops in L2TP IP sockets for connect() AF_UNSPEC case"")
Reported-by: Baozeng Ding <sploving1@gmail.com>
Reported-by: Andrey Konovalov <andreyknvl@google.com>
Tested-by: Baozeng Ding <sploving1@gmail.com>
Signed-off-by: Guillaume Nault <g.nault@alphalink.fr>
Signed-off-by: David S. Miller <davem@davemloft.net>",2,net/l2tp/l2tp_ip.c,"{""sha"": ""982f6c44ea01f053a51afcbb4b271a2e77df2178"", ""filename"": ""net/l2tp/l2tp_ip.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/32c231164b762dddefa13af5a0101032c70b50ef/net/l2tp/l2tp_ip.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/32c231164b762dddefa13af5a0101032c70b50ef/net/l2tp/l2tp_ip.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/l2tp/l2tp_ip.c?ref=32c231164b762dddefa13af5a0101032c70b50ef"", ""patch"": ""@@ -251,8 +251,6 @@ static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tint ret;\n \tint chk_addr_ret;\n \n-\tif (!sock_flag(sk, SOCK_ZAPPED))\n-\t\treturn -EINVAL;\n \tif (addr_len < sizeof(struct sockaddr_l2tpip))\n \t\treturn -EINVAL;\n \tif (addr->l2tp_family != AF_INET)\n@@ -267,6 +265,9 @@ static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tread_unlock_bh(&l2tp_ip_lock);\n \n \tlock_sock(sk);\n+\tif (!sock_flag(sk, SOCK_ZAPPED))\n+\t\tgoto out;\n+\n \tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n \t\tgoto out;\n ""}<_**next**_>{""sha"": ""9978d01ba0bae4eaf34810665d581ddd06579e96"", ""filename"": ""net/l2tp/l2tp_ip6.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/32c231164b762dddefa13af5a0101032c70b50ef/net/l2tp/l2tp_ip6.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/32c231164b762dddefa13af5a0101032c70b50ef/net/l2tp/l2tp_ip6.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/l2tp/l2tp_ip6.c?ref=32c231164b762dddefa13af5a0101032c70b50ef"", ""patch"": ""@@ -269,8 +269,6 @@ static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tint addr_type;\n \tint err;\n \n-\tif (!sock_flag(sk, SOCK_ZAPPED))\n-\t\treturn -EINVAL;\n \tif (addr->l2tp_family != AF_INET6)\n \t\treturn -EINVAL;\n \tif (addr_len < sizeof(*addr))\n@@ -296,6 +294,9 @@ static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tlock_sock(sk);\n \n \terr = -EINVAL;\n+\tif (!sock_flag(sk, SOCK_ZAPPED))\n+\t\tgoto out_unlock;\n+\n \tif (sk->sk_state != TCP_CLOSE)\n \t\tgoto out_unlock;\n ""}","static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;
	struct net *net = sock_net(sk);
 	int ret;
 	int chk_addr_ret;
 
 	if (addr_len < sizeof(struct sockaddr_l2tpip))
 		return -EINVAL;
 	if (addr->l2tp_family != AF_INET)
		return -EINVAL;

	ret = -EADDRINUSE;
	read_lock_bh(&l2tp_ip_lock);
	if (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,
				  sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;

 	read_unlock_bh(&l2tp_ip_lock);
 
 	lock_sock(sk);
	if (!sock_flag(sk, SOCK_ZAPPED))
		goto out;

 	if (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))
 		goto out;
 
	chk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);
	ret = -EADDRNOTAVAIL;
	if (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&
	    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)
		goto out;

	if (addr->l2tp_addr.s_addr)
		inet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;
	if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
		inet->inet_saddr = 0;  /* Use device */
	sk_dst_reset(sk);

	l2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip_lock);
	sk_add_bind_node(sk, &l2tp_ip_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip_lock);
	ret = 0;
	sock_reset_flag(sk, SOCK_ZAPPED);

out:
	release_sock(sk);

	return ret;

out_in_use:
	read_unlock_bh(&l2tp_ip_lock);

	return ret;
}
","static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;
	struct net *net = sock_net(sk);
 	int ret;
 	int chk_addr_ret;
 
	if (!sock_flag(sk, SOCK_ZAPPED))
		return -EINVAL;
 	if (addr_len < sizeof(struct sockaddr_l2tpip))
 		return -EINVAL;
 	if (addr->l2tp_family != AF_INET)
		return -EINVAL;

	ret = -EADDRINUSE;
	read_lock_bh(&l2tp_ip_lock);
	if (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,
				  sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;

 	read_unlock_bh(&l2tp_ip_lock);
 
 	lock_sock(sk);
 	if (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))
 		goto out;
 
	chk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);
	ret = -EADDRNOTAVAIL;
	if (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&
	    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)
		goto out;

	if (addr->l2tp_addr.s_addr)
		inet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;
	if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
		inet->inet_saddr = 0;  /* Use device */
	sk_dst_reset(sk);

	l2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip_lock);
	sk_add_bind_node(sk, &l2tp_ip_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip_lock);
	ret = 0;
	sock_reset_flag(sk, SOCK_ZAPPED);

out:
	release_sock(sk);

	return ret;

out_in_use:
	read_unlock_bh(&l2tp_ip_lock);

	return ret;
}
",C,"	if (!sock_flag(sk, SOCK_ZAPPED))
		goto out;

","	if (!sock_flag(sk, SOCK_ZAPPED))
		return -EINVAL;
",,"@@ -251,8 +251,6 @@ static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 	int ret;
 	int chk_addr_ret;
 
-	if (!sock_flag(sk, SOCK_ZAPPED))
-		return -EINVAL;
 	if (addr_len < sizeof(struct sockaddr_l2tpip))
 		return -EINVAL;
 	if (addr->l2tp_family != AF_INET)
@@ -267,6 +265,9 @@ static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 	read_unlock_bh(&l2tp_ip_lock);
 
 	lock_sock(sk);
+	if (!sock_flag(sk, SOCK_ZAPPED))
+		goto out;
+
 	if (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))
 		goto out;
 ",linux,32c231164b762dddefa13af5a0101032c70b50ef,adda306744ec64c7bcd6c230a6bc060fb77bd7c3,1,"static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;
	struct net *net = sock_net(sk);
 	int ret;
 	int chk_addr_ret;
 
//flaw_line_below:
	if (!sock_flag(sk, SOCK_ZAPPED))
//flaw_line_below:
		return -EINVAL;
 	if (addr_len < sizeof(struct sockaddr_l2tpip))
 		return -EINVAL;
 	if (addr->l2tp_family != AF_INET)
		return -EINVAL;

	ret = -EADDRINUSE;
	read_lock_bh(&l2tp_ip_lock);
	if (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,
				  sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;

 	read_unlock_bh(&l2tp_ip_lock);
 
 	lock_sock(sk);
//fix_flaw_line_below:
//	if (!sock_flag(sk, SOCK_ZAPPED))
//fix_flaw_line_below:
//		goto out;
//fix_flaw_line_below:
//
 	if (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))
 		goto out;
 
	chk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);
	ret = -EADDRNOTAVAIL;
	if (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&
	    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)
		goto out;

	if (addr->l2tp_addr.s_addr)
		inet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;
	if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
		inet->inet_saddr = 0;  /* Use device */
	sk_dst_reset(sk);

	l2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip_lock);
	sk_add_bind_node(sk, &l2tp_ip_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip_lock);
	ret = 0;
	sock_reset_flag(sk, SOCK_ZAPPED);

out:
	release_sock(sk);

	return ret;

out_in_use:
	read_unlock_bh(&l2tp_ip_lock);

	return ret;
}
",181661,"static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;
	struct net *net = sock_net(sk);
 	int ret;
 	int chk_addr_ret;
 
	if (!sock_flag(sk, SOCK_ZAPPED))
		return -EINVAL;
 	if (addr_len < sizeof(struct sockaddr_l2tpip))
 		return -EINVAL;
 	if (addr->l2tp_family != AF_INET)
		return -EINVAL;

	ret = -EADDRINUSE;
	read_lock_bh(&l2tp_ip_lock);
	if (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,
				  sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;

 	read_unlock_bh(&l2tp_ip_lock);
 
 	lock_sock(sk);
 	if (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))
 		goto out;
 
	chk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);
	ret = -EADDRNOTAVAIL;
	if (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&
	    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)
		goto out;

	if (addr->l2tp_addr.s_addr)
		inet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;
	if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
		inet->inet_saddr = 0;  /* Use device */
	sk_dst_reset(sk);

	l2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip_lock);
	sk_add_bind_node(sk, &l2tp_ip_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip_lock);
	ret = 0;
	sock_reset_flag(sk, SOCK_ZAPPED);

out:
	release_sock(sk);

	return ret;

out_in_use:
	read_unlock_bh(&l2tp_ip_lock);

	return ret;
}
","static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;
	struct net *net = sock_net(sk);
 	int ret;
 	int chk_addr_ret;
 
 	if (addr_len < sizeof(struct sockaddr_l2tpip))
 		return -EINVAL;
 	if (addr->l2tp_family != AF_INET)
		return -EINVAL;

	ret = -EADDRINUSE;
	read_lock_bh(&l2tp_ip_lock);
	if (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,
				  sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;

 	read_unlock_bh(&l2tp_ip_lock);
 
 	lock_sock(sk);
	if (!sock_flag(sk, SOCK_ZAPPED))
		goto out;

 	if (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))
 		goto out;
 
	chk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);
	ret = -EADDRNOTAVAIL;
	if (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&
	    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)
		goto out;

	if (addr->l2tp_addr.s_addr)
		inet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;
	if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
		inet->inet_saddr = 0;  /* Use device */
	sk_dst_reset(sk);

	l2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip_lock);
	sk_add_bind_node(sk, &l2tp_ip_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip_lock);
	ret = 0;
	sock_reset_flag(sk, SOCK_ZAPPED);

out:
	release_sock(sk);

	return ret;

out_in_use:
	read_unlock_bh(&l2tp_ip_lock);

	return ret;
}
","The `l2tp_ip_bind` function is responsible for binding a socket to a specified L2TP/IP address. It first checks if the socket is in a valid state and if the provided address structure is correctly sized and formatted. If the address is already in use, it returns an error. The function then verifies the address type to ensure it is valid for binding, updating the socket's source address accordingly. If successful, it adds the socket to a binding table and resets the socket's flags. Finally, it releases the socket and returns the result of the binding operation, indicating success or failure.","The function facilitates the binding of a socket to a specified address for L2TP/IP communication. It begins by validating the socket's state and the address structure's integrity. If the address is already in use, an error is returned. The function then checks the address type to ensure it is appropriate for binding, updating the socket's source address as needed. Upon successful validation, the socket is added to a binding table, and its flags are reset. Finally, the function releases the socket and returns a status indicating whether the binding operation was successful or encountered an error.","The vulnerability in the original code stemmed from a race condition involving the check of the SOCK_ZAPPED flag and the subsequent locking of the socket. Without proper synchronization, a concurrent operation could modify the socket's flags between the flag check and the lock acquisition, potentially allowing the same socket to be added multiple times to the binding table. This could lead to use-after-free errors when the socket was released, as stale pointers could remain in the list. The fix involved locking the socket before checking the SOCK_ZAPPED flag, ensuring that the state of the socket remains consistent throughout the binding process, thus preventing the race condition.","The vulnerability in the original code arose from a race condition that allowed concurrent modifications to the socket's flags, specifically the SOCK_ZAPPED flag, between the flag check and the subsequent locking of the socket. This could lead to a scenario where the same socket was added multiple times to the binding table, resulting in stale pointers and use-after-free errors when the socket was released. The fix involved ensuring that the socket was locked before checking the SOCK_ZAPPED flag, thereby preventing any concurrent changes to the socket's state and maintaining the integrity of the binding process.","The vulnerability was fixed by modifying the order of operations in the binding function. Specifically, the code now locks the socket using `lock_sock(sk)` before checking the SOCK_ZAPPED flag with `sock_flag(sk, SOCK_ZAPPED)`. This change ensures that no concurrent modifications can occur to the socket's flags between the flag check and the lock acquisition. By enforcing this locking mechanism, the risk of a socket being inserted multiple times into the binding table is eliminated, thus preventing stale pointers and subsequent use-after-free errors during socket release operations.","The vulnerability was addressed by restructuring the sequence of operations to ensure proper synchronization. The fix involved acquiring a lock on the socket before checking its state, which prevents any concurrent modifications to the socket's flags during the critical section. This change ensures that the socket's status remains consistent throughout the binding process, thereby eliminating the possibility of the same socket being added multiple times to the binding table. As a result, the risk of stale pointers and subsequent memory access errors when releasing the socket is effectively mitigated.","CWE-366, CWE-362, CWE-543, CWE-667, CWE-365, CWE-664, CWE-567, CWE-609, CWE-833, CWE-764",N,-1
33,33,181662,181662,,Local,Not required,Complete,CVE-2016-10200,https://www.cvedetails.com/cve/CVE-2016-10200/,CWE-416,Medium,Complete,Complete,,2017-03-07,6.9,"Race condition in the L2TPv3 IP Encapsulation feature in the Linux kernel before 4.8.14 allows local users to gain privileges or cause a denial of service (use-after-free) by making multiple bind system calls without properly ascertaining whether a socket has the SOCK_ZAPPED status, related to net/l2tp/l2tp_ip.c and net/l2tp/l2tp_ip6.c.",2018-01-04,DoS +Priv ,3,https://github.com/torvalds/linux/commit/32c231164b762dddefa13af5a0101032c70b50ef,32c231164b762dddefa13af5a0101032c70b50ef,"l2tp: fix racy SOCK_ZAPPED flag check in l2tp_ip{,6}_bind()

Lock socket before checking the SOCK_ZAPPED flag in l2tp_ip6_bind().
Without lock, a concurrent call could modify the socket flags between
the sock_flag(sk, SOCK_ZAPPED) test and the lock_sock() call. This way,
a socket could be inserted twice in l2tp_ip6_bind_table. Releasing it
would then leave a stale pointer there, generating use-after-free
errors when walking through the list or modifying adjacent entries.

BUG: KASAN: use-after-free in l2tp_ip6_close+0x22e/0x290 at addr ffff8800081b0ed8
Write of size 8 by task syz-executor/10987
CPU: 0 PID: 10987 Comm: syz-executor Not tainted 4.8.0+ #39
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.8.2-0-g33fbe13 by qemu-project.org 04/01/2014
 ffff880031d97838 ffffffff829f835b ffff88001b5a1640 ffff8800081b0ec0
 ffff8800081b15a0 ffff8800081b6d20 ffff880031d97860 ffffffff8174d3cc
 ffff880031d978f0 ffff8800081b0e80 ffff88001b5a1640 ffff880031d978e0
Call Trace:
 [<ffffffff829f835b>] dump_stack+0xb3/0x118 lib/dump_stack.c:15
 [<ffffffff8174d3cc>] kasan_object_err+0x1c/0x70 mm/kasan/report.c:156
 [<     inline     >] print_address_description mm/kasan/report.c:194
 [<ffffffff8174d666>] kasan_report_error+0x1f6/0x4d0 mm/kasan/report.c:283
 [<     inline     >] kasan_report mm/kasan/report.c:303
 [<ffffffff8174db7e>] __asan_report_store8_noabort+0x3e/0x40 mm/kasan/report.c:329
 [<     inline     >] __write_once_size ./include/linux/compiler.h:249
 [<     inline     >] __hlist_del ./include/linux/list.h:622
 [<     inline     >] hlist_del_init ./include/linux/list.h:637
 [<ffffffff8579047e>] l2tp_ip6_close+0x22e/0x290 net/l2tp/l2tp_ip6.c:239
 [<ffffffff850b2dfd>] inet_release+0xed/0x1c0 net/ipv4/af_inet.c:415
 [<ffffffff851dc5a0>] inet6_release+0x50/0x70 net/ipv6/af_inet6.c:422
 [<ffffffff84c4581d>] sock_release+0x8d/0x1d0 net/socket.c:570
 [<ffffffff84c45976>] sock_close+0x16/0x20 net/socket.c:1017
 [<ffffffff817a108c>] __fput+0x28c/0x780 fs/file_table.c:208
 [<ffffffff817a1605>] ____fput+0x15/0x20 fs/file_table.c:244
 [<ffffffff813774f9>] task_work_run+0xf9/0x170
 [<ffffffff81324aae>] do_exit+0x85e/0x2a00
 [<ffffffff81326dc8>] do_group_exit+0x108/0x330
 [<ffffffff81348cf7>] get_signal+0x617/0x17a0 kernel/signal.c:2307
 [<ffffffff811b49af>] do_signal+0x7f/0x18f0
 [<ffffffff810039bf>] exit_to_usermode_loop+0xbf/0x150 arch/x86/entry/common.c:156
 [<     inline     >] prepare_exit_to_usermode arch/x86/entry/common.c:190
 [<ffffffff81006060>] syscall_return_slowpath+0x1a0/0x1e0 arch/x86/entry/common.c:259
 [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4/0xc6
Object at ffff8800081b0ec0, in cache L2TP/IPv6 size: 1448
Allocated:
PID = 10987
 [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16/0x20
 [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46/0xd0
 [ 1116.897025] [<ffffffff8174c9ad>] kasan_kmalloc+0xad/0xe0
 [ 1116.897025] [<ffffffff8174cee2>] kasan_slab_alloc+0x12/0x20
 [ 1116.897025] [<     inline     >] slab_post_alloc_hook mm/slab.h:417
 [ 1116.897025] [<     inline     >] slab_alloc_node mm/slub.c:2708
 [ 1116.897025] [<     inline     >] slab_alloc mm/slub.c:2716
 [ 1116.897025] [<ffffffff817476a8>] kmem_cache_alloc+0xc8/0x2b0 mm/slub.c:2721
 [ 1116.897025] [<ffffffff84c4f6a9>] sk_prot_alloc+0x69/0x2b0 net/core/sock.c:1326
 [ 1116.897025] [<ffffffff84c58ac8>] sk_alloc+0x38/0xae0 net/core/sock.c:1388
 [ 1116.897025] [<ffffffff851ddf67>] inet6_create+0x2d7/0x1000 net/ipv6/af_inet6.c:182
 [ 1116.897025] [<ffffffff84c4af7b>] __sock_create+0x37b/0x640 net/socket.c:1153
 [ 1116.897025] [<     inline     >] sock_create net/socket.c:1193
 [ 1116.897025] [<     inline     >] SYSC_socket net/socket.c:1223
 [ 1116.897025] [<ffffffff84c4b46f>] SyS_socket+0xef/0x1b0 net/socket.c:1203
 [ 1116.897025] [<ffffffff85e4d685>] entry_SYSCALL_64_fastpath+0x23/0xc6
Freed:
PID = 10987
 [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16/0x20
 [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46/0xd0
 [ 1116.897025] [<ffffffff8174cf61>] kasan_slab_free+0x71/0xb0
 [ 1116.897025] [<     inline     >] slab_free_hook mm/slub.c:1352
 [ 1116.897025] [<     inline     >] slab_free_freelist_hook mm/slub.c:1374
 [ 1116.897025] [<     inline     >] slab_free mm/slub.c:2951
 [ 1116.897025] [<ffffffff81748b28>] kmem_cache_free+0xc8/0x330 mm/slub.c:2973
 [ 1116.897025] [<     inline     >] sk_prot_free net/core/sock.c:1369
 [ 1116.897025] [<ffffffff84c541eb>] __sk_destruct+0x32b/0x4f0 net/core/sock.c:1444
 [ 1116.897025] [<ffffffff84c5aca4>] sk_destruct+0x44/0x80 net/core/sock.c:1452
 [ 1116.897025] [<ffffffff84c5ad33>] __sk_free+0x53/0x220 net/core/sock.c:1460
 [ 1116.897025] [<ffffffff84c5af23>] sk_free+0x23/0x30 net/core/sock.c:1471
 [ 1116.897025] [<ffffffff84c5cb6c>] sk_common_release+0x28c/0x3e0 ./include/net/sock.h:1589
 [ 1116.897025] [<ffffffff8579044e>] l2tp_ip6_close+0x1fe/0x290 net/l2tp/l2tp_ip6.c:243
 [ 1116.897025] [<ffffffff850b2dfd>] inet_release+0xed/0x1c0 net/ipv4/af_inet.c:415
 [ 1116.897025] [<ffffffff851dc5a0>] inet6_release+0x50/0x70 net/ipv6/af_inet6.c:422
 [ 1116.897025] [<ffffffff84c4581d>] sock_release+0x8d/0x1d0 net/socket.c:570
 [ 1116.897025] [<ffffffff84c45976>] sock_close+0x16/0x20 net/socket.c:1017
 [ 1116.897025] [<ffffffff817a108c>] __fput+0x28c/0x780 fs/file_table.c:208
 [ 1116.897025] [<ffffffff817a1605>] ____fput+0x15/0x20 fs/file_table.c:244
 [ 1116.897025] [<ffffffff813774f9>] task_work_run+0xf9/0x170
 [ 1116.897025] [<ffffffff81324aae>] do_exit+0x85e/0x2a00
 [ 1116.897025] [<ffffffff81326dc8>] do_group_exit+0x108/0x330
 [ 1116.897025] [<ffffffff81348cf7>] get_signal+0x617/0x17a0 kernel/signal.c:2307
 [ 1116.897025] [<ffffffff811b49af>] do_signal+0x7f/0x18f0
 [ 1116.897025] [<ffffffff810039bf>] exit_to_usermode_loop+0xbf/0x150 arch/x86/entry/common.c:156
 [ 1116.897025] [<     inline     >] prepare_exit_to_usermode arch/x86/entry/common.c:190
 [ 1116.897025] [<ffffffff81006060>] syscall_return_slowpath+0x1a0/0x1e0 arch/x86/entry/common.c:259
 [ 1116.897025] [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4/0xc6
Memory state around the buggy address:
 ffff8800081b0d80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ffff8800081b0e00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
>ffff8800081b0e80: fc fc fc fc fc fc fc fc fb fb fb fb fb fb fb fb
                                                    ^
 ffff8800081b0f00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff8800081b0f80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb

==================================================================

The same issue exists with l2tp_ip_bind() and l2tp_ip_bind_table.

Fixes: c51ce49735c1 (""l2tp: fix oops in L2TP IP sockets for connect() AF_UNSPEC case"")
Reported-by: Baozeng Ding <sploving1@gmail.com>
Reported-by: Andrey Konovalov <andreyknvl@google.com>
Tested-by: Baozeng Ding <sploving1@gmail.com>
Signed-off-by: Guillaume Nault <g.nault@alphalink.fr>
Signed-off-by: David S. Miller <davem@davemloft.net>",2,net/l2tp/l2tp_ip6.c,"{""sha"": ""982f6c44ea01f053a51afcbb4b271a2e77df2178"", ""filename"": ""net/l2tp/l2tp_ip.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/32c231164b762dddefa13af5a0101032c70b50ef/net/l2tp/l2tp_ip.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/32c231164b762dddefa13af5a0101032c70b50ef/net/l2tp/l2tp_ip.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/l2tp/l2tp_ip.c?ref=32c231164b762dddefa13af5a0101032c70b50ef"", ""patch"": ""@@ -251,8 +251,6 @@ static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tint ret;\n \tint chk_addr_ret;\n \n-\tif (!sock_flag(sk, SOCK_ZAPPED))\n-\t\treturn -EINVAL;\n \tif (addr_len < sizeof(struct sockaddr_l2tpip))\n \t\treturn -EINVAL;\n \tif (addr->l2tp_family != AF_INET)\n@@ -267,6 +265,9 @@ static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tread_unlock_bh(&l2tp_ip_lock);\n \n \tlock_sock(sk);\n+\tif (!sock_flag(sk, SOCK_ZAPPED))\n+\t\tgoto out;\n+\n \tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n \t\tgoto out;\n ""}<_**next**_>{""sha"": ""9978d01ba0bae4eaf34810665d581ddd06579e96"", ""filename"": ""net/l2tp/l2tp_ip6.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/32c231164b762dddefa13af5a0101032c70b50ef/net/l2tp/l2tp_ip6.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/32c231164b762dddefa13af5a0101032c70b50ef/net/l2tp/l2tp_ip6.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/l2tp/l2tp_ip6.c?ref=32c231164b762dddefa13af5a0101032c70b50ef"", ""patch"": ""@@ -269,8 +269,6 @@ static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tint addr_type;\n \tint err;\n \n-\tif (!sock_flag(sk, SOCK_ZAPPED))\n-\t\treturn -EINVAL;\n \tif (addr->l2tp_family != AF_INET6)\n \t\treturn -EINVAL;\n \tif (addr_len < sizeof(*addr))\n@@ -296,6 +294,9 @@ static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tlock_sock(sk);\n \n \terr = -EINVAL;\n+\tif (!sock_flag(sk, SOCK_ZAPPED))\n+\t\tgoto out_unlock;\n+\n \tif (sk->sk_state != TCP_CLOSE)\n \t\tgoto out_unlock;\n ""}","static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;
	struct net *net = sock_net(sk);
	__be32 v4addr = 0;
 	int addr_type;
 	int err;
 
 	if (addr->l2tp_family != AF_INET6)
 		return -EINVAL;
 	if (addr_len < sizeof(*addr))
		return -EINVAL;

	addr_type = ipv6_addr_type(&addr->l2tp_addr);

	/* l2tp_ip6 sockets are IPv6 only */
	if (addr_type == IPV6_ADDR_MAPPED)
		return -EADDRNOTAVAIL;

	/* L2TP is point-point, not multicast */
	if (addr_type & IPV6_ADDR_MULTICAST)
		return -EADDRNOTAVAIL;

	err = -EADDRINUSE;
	read_lock_bh(&l2tp_ip6_lock);
	if (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,
				   sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;
	read_unlock_bh(&l2tp_ip6_lock);

 	lock_sock(sk);
 
 	err = -EINVAL;
	if (!sock_flag(sk, SOCK_ZAPPED))
		goto out_unlock;

 	if (sk->sk_state != TCP_CLOSE)
 		goto out_unlock;
 
	/* Check if the address belongs to the host. */
	rcu_read_lock();
	if (addr_type != IPV6_ADDR_ANY) {
		struct net_device *dev = NULL;

		if (addr_type & IPV6_ADDR_LINKLOCAL) {
			if (addr_len >= sizeof(struct sockaddr_in6) &&
			    addr->l2tp_scope_id) {
				/* Override any existing binding, if another
				 * one is supplied by user.
				 */
				sk->sk_bound_dev_if = addr->l2tp_scope_id;
			}

			/* Binding to link-local address requires an
			   interface */
			if (!sk->sk_bound_dev_if)
				goto out_unlock_rcu;

			err = -ENODEV;
			dev = dev_get_by_index_rcu(sock_net(sk),
						   sk->sk_bound_dev_if);
			if (!dev)
				goto out_unlock_rcu;
		}

		/* ipv4 addr of the socket is invalid.  Only the
		 * unspecified and mapped address have a v4 equivalent.
		 */
		v4addr = LOOPBACK4_IPV6;
		err = -EADDRNOTAVAIL;
		if (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))
			goto out_unlock_rcu;
	}
	rcu_read_unlock();

	inet->inet_rcv_saddr = inet->inet_saddr = v4addr;
	sk->sk_v6_rcv_saddr = addr->l2tp_addr;
	np->saddr = addr->l2tp_addr;

	l2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip6_lock);
	sk_add_bind_node(sk, &l2tp_ip6_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip6_lock);

	sock_reset_flag(sk, SOCK_ZAPPED);
	release_sock(sk);
	return 0;

out_unlock_rcu:
	rcu_read_unlock();
out_unlock:
	release_sock(sk);
	return err;

out_in_use:
	read_unlock_bh(&l2tp_ip6_lock);
	return err;
}
","static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;
	struct net *net = sock_net(sk);
	__be32 v4addr = 0;
 	int addr_type;
 	int err;
 
	if (!sock_flag(sk, SOCK_ZAPPED))
		return -EINVAL;
 	if (addr->l2tp_family != AF_INET6)
 		return -EINVAL;
 	if (addr_len < sizeof(*addr))
		return -EINVAL;

	addr_type = ipv6_addr_type(&addr->l2tp_addr);

	/* l2tp_ip6 sockets are IPv6 only */
	if (addr_type == IPV6_ADDR_MAPPED)
		return -EADDRNOTAVAIL;

	/* L2TP is point-point, not multicast */
	if (addr_type & IPV6_ADDR_MULTICAST)
		return -EADDRNOTAVAIL;

	err = -EADDRINUSE;
	read_lock_bh(&l2tp_ip6_lock);
	if (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,
				   sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;
	read_unlock_bh(&l2tp_ip6_lock);

 	lock_sock(sk);
 
 	err = -EINVAL;
 	if (sk->sk_state != TCP_CLOSE)
 		goto out_unlock;
 
	/* Check if the address belongs to the host. */
	rcu_read_lock();
	if (addr_type != IPV6_ADDR_ANY) {
		struct net_device *dev = NULL;

		if (addr_type & IPV6_ADDR_LINKLOCAL) {
			if (addr_len >= sizeof(struct sockaddr_in6) &&
			    addr->l2tp_scope_id) {
				/* Override any existing binding, if another
				 * one is supplied by user.
				 */
				sk->sk_bound_dev_if = addr->l2tp_scope_id;
			}

			/* Binding to link-local address requires an
			   interface */
			if (!sk->sk_bound_dev_if)
				goto out_unlock_rcu;

			err = -ENODEV;
			dev = dev_get_by_index_rcu(sock_net(sk),
						   sk->sk_bound_dev_if);
			if (!dev)
				goto out_unlock_rcu;
		}

		/* ipv4 addr of the socket is invalid.  Only the
		 * unspecified and mapped address have a v4 equivalent.
		 */
		v4addr = LOOPBACK4_IPV6;
		err = -EADDRNOTAVAIL;
		if (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))
			goto out_unlock_rcu;
	}
	rcu_read_unlock();

	inet->inet_rcv_saddr = inet->inet_saddr = v4addr;
	sk->sk_v6_rcv_saddr = addr->l2tp_addr;
	np->saddr = addr->l2tp_addr;

	l2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip6_lock);
	sk_add_bind_node(sk, &l2tp_ip6_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip6_lock);

	sock_reset_flag(sk, SOCK_ZAPPED);
	release_sock(sk);
	return 0;

out_unlock_rcu:
	rcu_read_unlock();
out_unlock:
	release_sock(sk);
	return err;

out_in_use:
	read_unlock_bh(&l2tp_ip6_lock);
	return err;
}
",C,"	if (!sock_flag(sk, SOCK_ZAPPED))
		goto out_unlock;

","	if (!sock_flag(sk, SOCK_ZAPPED))
		return -EINVAL;
",,"@@ -269,8 +269,6 @@ static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 	int addr_type;
 	int err;
 
-	if (!sock_flag(sk, SOCK_ZAPPED))
-		return -EINVAL;
 	if (addr->l2tp_family != AF_INET6)
 		return -EINVAL;
 	if (addr_len < sizeof(*addr))
@@ -296,6 +294,9 @@ static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 	lock_sock(sk);
 
 	err = -EINVAL;
+	if (!sock_flag(sk, SOCK_ZAPPED))
+		goto out_unlock;
+
 	if (sk->sk_state != TCP_CLOSE)
 		goto out_unlock;
 ",linux,32c231164b762dddefa13af5a0101032c70b50ef,adda306744ec64c7bcd6c230a6bc060fb77bd7c3,1,"static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;
	struct net *net = sock_net(sk);
	__be32 v4addr = 0;
 	int addr_type;
 	int err;
 
//flaw_line_below:
	if (!sock_flag(sk, SOCK_ZAPPED))
//flaw_line_below:
		return -EINVAL;
 	if (addr->l2tp_family != AF_INET6)
 		return -EINVAL;
 	if (addr_len < sizeof(*addr))
		return -EINVAL;

	addr_type = ipv6_addr_type(&addr->l2tp_addr);

	/* l2tp_ip6 sockets are IPv6 only */
	if (addr_type == IPV6_ADDR_MAPPED)
		return -EADDRNOTAVAIL;

	/* L2TP is point-point, not multicast */
	if (addr_type & IPV6_ADDR_MULTICAST)
		return -EADDRNOTAVAIL;

	err = -EADDRINUSE;
	read_lock_bh(&l2tp_ip6_lock);
	if (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,
				   sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;
	read_unlock_bh(&l2tp_ip6_lock);

 	lock_sock(sk);
 
 	err = -EINVAL;
//fix_flaw_line_below:
//	if (!sock_flag(sk, SOCK_ZAPPED))
//fix_flaw_line_below:
//		goto out_unlock;
//fix_flaw_line_below:
//
 	if (sk->sk_state != TCP_CLOSE)
 		goto out_unlock;
 
	/* Check if the address belongs to the host. */
	rcu_read_lock();
	if (addr_type != IPV6_ADDR_ANY) {
		struct net_device *dev = NULL;

		if (addr_type & IPV6_ADDR_LINKLOCAL) {
			if (addr_len >= sizeof(struct sockaddr_in6) &&
			    addr->l2tp_scope_id) {
				/* Override any existing binding, if another
				 * one is supplied by user.
				 */
				sk->sk_bound_dev_if = addr->l2tp_scope_id;
			}

			/* Binding to link-local address requires an
			   interface */
			if (!sk->sk_bound_dev_if)
				goto out_unlock_rcu;

			err = -ENODEV;
			dev = dev_get_by_index_rcu(sock_net(sk),
						   sk->sk_bound_dev_if);
			if (!dev)
				goto out_unlock_rcu;
		}

		/* ipv4 addr of the socket is invalid.  Only the
		 * unspecified and mapped address have a v4 equivalent.
		 */
		v4addr = LOOPBACK4_IPV6;
		err = -EADDRNOTAVAIL;
		if (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))
			goto out_unlock_rcu;
	}
	rcu_read_unlock();

	inet->inet_rcv_saddr = inet->inet_saddr = v4addr;
	sk->sk_v6_rcv_saddr = addr->l2tp_addr;
	np->saddr = addr->l2tp_addr;

	l2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip6_lock);
	sk_add_bind_node(sk, &l2tp_ip6_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip6_lock);

	sock_reset_flag(sk, SOCK_ZAPPED);
	release_sock(sk);
	return 0;

out_unlock_rcu:
	rcu_read_unlock();
out_unlock:
	release_sock(sk);
	return err;

out_in_use:
	read_unlock_bh(&l2tp_ip6_lock);
	return err;
}
",181662,"static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;
	struct net *net = sock_net(sk);
	__be32 v4addr = 0;
 	int addr_type;
 	int err;
 
	if (!sock_flag(sk, SOCK_ZAPPED))
		return -EINVAL;
 	if (addr->l2tp_family != AF_INET6)
 		return -EINVAL;
 	if (addr_len < sizeof(*addr))
		return -EINVAL;

	addr_type = ipv6_addr_type(&addr->l2tp_addr);

	/* l2tp_ip6 sockets are IPv6 only */
	if (addr_type == IPV6_ADDR_MAPPED)
		return -EADDRNOTAVAIL;

	/* L2TP is point-point, not multicast */
	if (addr_type & IPV6_ADDR_MULTICAST)
		return -EADDRNOTAVAIL;

	err = -EADDRINUSE;
	read_lock_bh(&l2tp_ip6_lock);
	if (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,
				   sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;
	read_unlock_bh(&l2tp_ip6_lock);

 	lock_sock(sk);
 
 	err = -EINVAL;
 	if (sk->sk_state != TCP_CLOSE)
 		goto out_unlock;
 
	/* Check if the address belongs to the host. */
	rcu_read_lock();
	if (addr_type != IPV6_ADDR_ANY) {
		struct net_device *dev = NULL;

		if (addr_type & IPV6_ADDR_LINKLOCAL) {
			if (addr_len >= sizeof(struct sockaddr_in6) &&
			    addr->l2tp_scope_id) {
				/* Override any existing binding, if another
				 * one is supplied by user.
				 */
				sk->sk_bound_dev_if = addr->l2tp_scope_id;
			}

			/* Binding to link-local address requires an
			   interface */
			if (!sk->sk_bound_dev_if)
				goto out_unlock_rcu;

			err = -ENODEV;
			dev = dev_get_by_index_rcu(sock_net(sk),
						   sk->sk_bound_dev_if);
			if (!dev)
				goto out_unlock_rcu;
		}

		/* ipv4 addr of the socket is invalid.  Only the
		 * unspecified and mapped address have a v4 equivalent.
		 */
		v4addr = LOOPBACK4_IPV6;
		err = -EADDRNOTAVAIL;
		if (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))
			goto out_unlock_rcu;
	}
	rcu_read_unlock();

	inet->inet_rcv_saddr = inet->inet_saddr = v4addr;
	sk->sk_v6_rcv_saddr = addr->l2tp_addr;
	np->saddr = addr->l2tp_addr;

	l2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip6_lock);
	sk_add_bind_node(sk, &l2tp_ip6_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip6_lock);

	sock_reset_flag(sk, SOCK_ZAPPED);
	release_sock(sk);
	return 0;

out_unlock_rcu:
	rcu_read_unlock();
out_unlock:
	release_sock(sk);
	return err;

out_in_use:
	read_unlock_bh(&l2tp_ip6_lock);
	return err;
}
","static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;
	struct net *net = sock_net(sk);
	__be32 v4addr = 0;
 	int addr_type;
 	int err;
 
 	if (addr->l2tp_family != AF_INET6)
 		return -EINVAL;
 	if (addr_len < sizeof(*addr))
		return -EINVAL;

	addr_type = ipv6_addr_type(&addr->l2tp_addr);

	/* l2tp_ip6 sockets are IPv6 only */
	if (addr_type == IPV6_ADDR_MAPPED)
		return -EADDRNOTAVAIL;

	/* L2TP is point-point, not multicast */
	if (addr_type & IPV6_ADDR_MULTICAST)
		return -EADDRNOTAVAIL;

	err = -EADDRINUSE;
	read_lock_bh(&l2tp_ip6_lock);
	if (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,
				   sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;
	read_unlock_bh(&l2tp_ip6_lock);

 	lock_sock(sk);
 
 	err = -EINVAL;
	if (!sock_flag(sk, SOCK_ZAPPED))
		goto out_unlock;

 	if (sk->sk_state != TCP_CLOSE)
 		goto out_unlock;
 
	/* Check if the address belongs to the host. */
	rcu_read_lock();
	if (addr_type != IPV6_ADDR_ANY) {
		struct net_device *dev = NULL;

		if (addr_type & IPV6_ADDR_LINKLOCAL) {
			if (addr_len >= sizeof(struct sockaddr_in6) &&
			    addr->l2tp_scope_id) {
				/* Override any existing binding, if another
				 * one is supplied by user.
				 */
				sk->sk_bound_dev_if = addr->l2tp_scope_id;
			}

			/* Binding to link-local address requires an
			   interface */
			if (!sk->sk_bound_dev_if)
				goto out_unlock_rcu;

			err = -ENODEV;
			dev = dev_get_by_index_rcu(sock_net(sk),
						   sk->sk_bound_dev_if);
			if (!dev)
				goto out_unlock_rcu;
		}

		/* ipv4 addr of the socket is invalid.  Only the
		 * unspecified and mapped address have a v4 equivalent.
		 */
		v4addr = LOOPBACK4_IPV6;
		err = -EADDRNOTAVAIL;
		if (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))
			goto out_unlock_rcu;
	}
	rcu_read_unlock();

	inet->inet_rcv_saddr = inet->inet_saddr = v4addr;
	sk->sk_v6_rcv_saddr = addr->l2tp_addr;
	np->saddr = addr->l2tp_addr;

	l2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip6_lock);
	sk_add_bind_node(sk, &l2tp_ip6_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip6_lock);

	sock_reset_flag(sk, SOCK_ZAPPED);
	release_sock(sk);
	return 0;

out_unlock_rcu:
	rcu_read_unlock();
out_unlock:
	release_sock(sk);
	return err;

out_in_use:
	read_unlock_bh(&l2tp_ip6_lock);
	return err;
}
","The `l2tp_ip6_bind` function is responsible for binding a socket to an IPv6 address for L2TP (Layer 2 Tunneling Protocol) communication. It first checks if the socket is in a valid state and if the provided address is an IPv6 address. The function ensures that the address is not multicast or mapped from IPv4, and verifies that the address belongs to the host. If the checks pass, it sets the socket's source address and connection ID, updates the binding table, and resets the socket's state. If any validation fails, appropriate error codes are returned, indicating the nature of the failure.","The function facilitates the binding of a socket to an IPv6 address specifically for Layer 2 Tunneling Protocol communication. It performs several validation checks to ensure the socket is in a proper state and that the provided address is a valid, non-multicast IPv6 address belonging to the host. If the checks are successful, it assigns the appropriate source address and connection identifier, updates the binding table, and resets the socket's state. If any validation fails, it returns specific error codes to indicate the type of issue encountered during the binding process.","The vulnerability in the original code stemmed from a race condition involving the check of the SOCK_ZAPPED flag and the subsequent locking of the socket. Without proper locking, a concurrent operation could modify the socket flags between the flag check and the lock acquisition, potentially allowing the same socket to be inserted multiple times into the binding table. This could lead to use-after-free errors when the socket was later released. The fix implemented a lock on the socket before checking the SOCK_ZAPPED flag, ensuring that the state of the socket remains consistent and preventing concurrent modifications during the binding process.","The vulnerability in the original code arose from a race condition related to the check of a specific socket flag and the subsequent locking of the socket. Without proper synchronization, a concurrent operation could alter the socket's state between the flag check and the lock acquisition, potentially allowing the same socket to be added multiple times to a binding table. This could lead to stale pointers and use-after-free errors when the socket was released. The fix involved locking the socket before checking the flag, ensuring that the socket's state remains consistent and preventing concurrent modifications during the binding process.","The vulnerability was fixed by introducing a lock on the socket before checking the SOCK_ZAPPED flag in the `l2tp_ip6_bind` function. This change ensures that the state of the socket remains consistent during the flag check and the subsequent call to `lock_sock()`. By locking the socket first, the code prevents any concurrent modifications to the socket flags that could occur between the flag check and the locking operation. This effectively eliminates the risk of inserting the same socket multiple times into the binding table, thereby preventing stale pointers and use-after-free errors during socket release.","The vulnerability was addressed by ensuring that the socket is locked before checking its specific flag. This modification prevents any concurrent operations from altering the socket's state between the flag check and the locking process. By establishing this synchronization, the code guarantees that the socket's status remains stable, thereby eliminating the possibility of inserting the same socket multiple times into the binding table. This change effectively mitigates the risk of stale pointers and use-after-free errors that could occur when the socket is released, enhancing the overall safety and reliability of the binding operation.","CWE-362, CWE-666, CWE-366, CWE-367, CWE-364, CWE-667, CWE-543, CWE-567, CWE-609, CWE-832",N,-1
34,34,181811,181811,,Remote,Not required,Partial,CVE-2016-10051,https://www.cvedetails.com/cve/CVE-2016-10051/,CWE-416,Medium,Partial,Partial,,2017-03-23,6.8,Use-after-free vulnerability in the ReadPWPImage function in coders/pwp.c in ImageMagick 6.9.5-5 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted file.,2018-10-30,DoS ,0,https://github.com/ImageMagick/ImageMagick/commit/ecc03a2518c2b7dd375fde3a040fdae0bdf6a521,ecc03a2518c2b7dd375fde3a040fdae0bdf6a521,Prevent memory use after free,2,coders/pwp.c,"{""sha"": ""8199991cc4e8896474339ed5752dfb863fb71f74"", ""filename"": ""ChangeLog"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/ecc03a2518c2b7dd375fde3a040fdae0bdf6a521/ChangeLog"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/ecc03a2518c2b7dd375fde3a040fdae0bdf6a521/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/ChangeLog?ref=ecc03a2518c2b7dd375fde3a040fdae0bdf6a521"", ""patch"": ""@@ -1,5 +1,7 @@\n 2016-08-03  6.9.5-5 Cristy  <quetzlzacatenango@image...>\n   * Prevent buffer overflow (bug report from Max Thrane).\n+  * Prevent memory use after free (reference\n+    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30245).\n \n 2016-07-30  6.9.5-4 Cristy  <quetzlzacatenango@image...>\n   * Release ImageMagick version 6.9.5-4, GIT revision 10973:a00fa93:20160729.""}<_**next**_>{""sha"": ""9432daad6308c533c4882bc405947eabedd14b1d"", ""filename"": ""coders/pwp.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/ecc03a2518c2b7dd375fde3a040fdae0bdf6a521/coders/pwp.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/ecc03a2518c2b7dd375fde3a040fdae0bdf6a521/coders/pwp.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/pwp.c?ref=ecc03a2518c2b7dd375fde3a040fdae0bdf6a521"", ""patch"": ""@@ -248,8 +248,6 @@ static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     (void) close(unique_file);\n   (void) RelinquishUniqueFileResource(read_info->filename);\n   read_info=DestroyImageInfo(read_info);\n-  (void) CloseBlob(pwp_image);\n-  pwp_image=DestroyImage(pwp_image);\n   if (EOFBlob(image) != MagickFalse)\n     {\n       char""}","static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  FILE
    *file;

  Image
    *image,
    *next_image,
    *pwp_image;

  ImageInfo
    *read_info;

  int
    c,
    unique_file;

  MagickBooleanType
    status;

  register Image
    *p;

  register ssize_t
    i;

  size_t
    filesize,
    length;

  ssize_t
    count;

  unsigned char
    magick[MaxTextExtent];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  pwp_image=AcquireImage(image_info);
  image=pwp_image;
  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return((Image *) NULL);
  count=ReadBlob(pwp_image,5,magick);
  if ((count != 5) || (LocaleNCompare((char *) magick,""SFW95"",5) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  read_info=CloneImageInfo(image_info);
  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,
    (void *) NULL);
  SetImageInfoBlob(read_info,(void *) NULL,0);
  unique_file=AcquireUniqueFileResource(read_info->filename);
  for ( ; ; )
  {
    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))
    {
      for (i=0; i < 17; i++)
        magick[i]=magick[i+1];
      magick[17]=(unsigned char) c;
      if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) == 0)
        break;
    }
    if (c == EOF)
      break;
    if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) != 0)
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      }
    /*
      Dump SFW image to a temporary file.
    */
    file=(FILE *) NULL;
    if (unique_file != -1)
      file=fdopen(unique_file,""wb"");
    if ((unique_file == -1) || (file == (FILE *) NULL))
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",
          image->filename);
        image=DestroyImageList(image);
        return((Image *) NULL);
      }
    length=fwrite(""SFW94A"",1,6,file);
    (void) length;
    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];
    for (i=0; i < (ssize_t) filesize; i++)
    {
      c=ReadBlobByte(pwp_image);
      (void) fputc(c,file);
    }
    (void) fclose(file);
    next_image=ReadImage(read_info,exception);
    if (next_image == (Image *) NULL)
      break;
    (void) FormatLocaleString(next_image->filename,MaxTextExtent,
      ""slide_%02ld.sfw"",(long) next_image->scene);
    if (image == (Image *) NULL)
      image=next_image;
    else
      {
        /*
          Link image into image list.
        */
        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;
        next_image->previous=p;
        next_image->scene=p->scene+1;
        p->next=next_image;
      }
    if (image_info->number_scenes != 0)
      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),
      GetBlobSize(pwp_image));
    if (status == MagickFalse)
      break;
  }
  if (unique_file != -1)
     (void) close(unique_file);
   (void) RelinquishUniqueFileResource(read_info->filename);
   read_info=DestroyImageInfo(read_info);
   if (EOFBlob(image) != MagickFalse)
     {
       char
        *message;

      message=GetExceptionMessage(errno);
      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,
        ""UnexpectedEndOfFile"",""`%s': %s"",image->filename,message);
      message=DestroyString(message);
    }
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  FILE
    *file;

  Image
    *image,
    *next_image,
    *pwp_image;

  ImageInfo
    *read_info;

  int
    c,
    unique_file;

  MagickBooleanType
    status;

  register Image
    *p;

  register ssize_t
    i;

  size_t
    filesize,
    length;

  ssize_t
    count;

  unsigned char
    magick[MaxTextExtent];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  pwp_image=AcquireImage(image_info);
  image=pwp_image;
  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return((Image *) NULL);
  count=ReadBlob(pwp_image,5,magick);
  if ((count != 5) || (LocaleNCompare((char *) magick,""SFW95"",5) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  read_info=CloneImageInfo(image_info);
  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,
    (void *) NULL);
  SetImageInfoBlob(read_info,(void *) NULL,0);
  unique_file=AcquireUniqueFileResource(read_info->filename);
  for ( ; ; )
  {
    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))
    {
      for (i=0; i < 17; i++)
        magick[i]=magick[i+1];
      magick[17]=(unsigned char) c;
      if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) == 0)
        break;
    }
    if (c == EOF)
      break;
    if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) != 0)
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      }
    /*
      Dump SFW image to a temporary file.
    */
    file=(FILE *) NULL;
    if (unique_file != -1)
      file=fdopen(unique_file,""wb"");
    if ((unique_file == -1) || (file == (FILE *) NULL))
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",
          image->filename);
        image=DestroyImageList(image);
        return((Image *) NULL);
      }
    length=fwrite(""SFW94A"",1,6,file);
    (void) length;
    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];
    for (i=0; i < (ssize_t) filesize; i++)
    {
      c=ReadBlobByte(pwp_image);
      (void) fputc(c,file);
    }
    (void) fclose(file);
    next_image=ReadImage(read_info,exception);
    if (next_image == (Image *) NULL)
      break;
    (void) FormatLocaleString(next_image->filename,MaxTextExtent,
      ""slide_%02ld.sfw"",(long) next_image->scene);
    if (image == (Image *) NULL)
      image=next_image;
    else
      {
        /*
          Link image into image list.
        */
        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;
        next_image->previous=p;
        next_image->scene=p->scene+1;
        p->next=next_image;
      }
    if (image_info->number_scenes != 0)
      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),
      GetBlobSize(pwp_image));
    if (status == MagickFalse)
      break;
  }
  if (unique_file != -1)
     (void) close(unique_file);
   (void) RelinquishUniqueFileResource(read_info->filename);
   read_info=DestroyImageInfo(read_info);
  (void) CloseBlob(pwp_image);
  pwp_image=DestroyImage(pwp_image);
   if (EOFBlob(image) != MagickFalse)
     {
       char
        *message;

      message=GetExceptionMessage(errno);
      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,
        ""UnexpectedEndOfFile"",""`%s': %s"",image->filename,message);
      message=DestroyString(message);
    }
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",C,,"  (void) CloseBlob(pwp_image);
  pwp_image=DestroyImage(pwp_image);
",,"@@ -248,8 +248,6 @@ static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)
     (void) close(unique_file);
   (void) RelinquishUniqueFileResource(read_info->filename);
   read_info=DestroyImageInfo(read_info);
-  (void) CloseBlob(pwp_image);
-  pwp_image=DestroyImage(pwp_image);
   if (EOFBlob(image) != MagickFalse)
     {
       char",ImageMagick,ecc03a2518c2b7dd375fde3a040fdae0bdf6a521,989f9f88ea6db09b99d25586e912c921c0da8d3f,1,"static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  FILE
    *file;

  Image
    *image,
    *next_image,
    *pwp_image;

  ImageInfo
    *read_info;

  int
    c,
    unique_file;

  MagickBooleanType
    status;

  register Image
    *p;

  register ssize_t
    i;

  size_t
    filesize,
    length;

  ssize_t
    count;

  unsigned char
    magick[MaxTextExtent];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  pwp_image=AcquireImage(image_info);
  image=pwp_image;
  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return((Image *) NULL);
  count=ReadBlob(pwp_image,5,magick);
  if ((count != 5) || (LocaleNCompare((char *) magick,""SFW95"",5) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  read_info=CloneImageInfo(image_info);
  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,
    (void *) NULL);
  SetImageInfoBlob(read_info,(void *) NULL,0);
  unique_file=AcquireUniqueFileResource(read_info->filename);
  for ( ; ; )
  {
    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))
    {
      for (i=0; i < 17; i++)
        magick[i]=magick[i+1];
      magick[17]=(unsigned char) c;
      if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) == 0)
        break;
    }
    if (c == EOF)
      break;
    if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) != 0)
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      }
    /*
      Dump SFW image to a temporary file.
    */
    file=(FILE *) NULL;
    if (unique_file != -1)
      file=fdopen(unique_file,""wb"");
    if ((unique_file == -1) || (file == (FILE *) NULL))
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",
          image->filename);
        image=DestroyImageList(image);
        return((Image *) NULL);
      }
    length=fwrite(""SFW94A"",1,6,file);
    (void) length;
    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];
    for (i=0; i < (ssize_t) filesize; i++)
    {
      c=ReadBlobByte(pwp_image);
      (void) fputc(c,file);
    }
    (void) fclose(file);
    next_image=ReadImage(read_info,exception);
    if (next_image == (Image *) NULL)
      break;
    (void) FormatLocaleString(next_image->filename,MaxTextExtent,
      ""slide_%02ld.sfw"",(long) next_image->scene);
    if (image == (Image *) NULL)
      image=next_image;
    else
      {
        /*
          Link image into image list.
        */
        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;
        next_image->previous=p;
        next_image->scene=p->scene+1;
        p->next=next_image;
      }
    if (image_info->number_scenes != 0)
      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),
      GetBlobSize(pwp_image));
    if (status == MagickFalse)
      break;
  }
  if (unique_file != -1)
     (void) close(unique_file);
   (void) RelinquishUniqueFileResource(read_info->filename);
   read_info=DestroyImageInfo(read_info);
//flaw_line_below:
  (void) CloseBlob(pwp_image);
//flaw_line_below:
  pwp_image=DestroyImage(pwp_image);
   if (EOFBlob(image) != MagickFalse)
     {
       char
        *message;

      message=GetExceptionMessage(errno);
      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,
        ""UnexpectedEndOfFile"",""`%s': %s"",image->filename,message);
      message=DestroyString(message);
    }
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",181811,"static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  FILE
    *file;

  Image
    *image,
    *next_image,
    *pwp_image;

  ImageInfo
    *read_info;

  int
    c,
    unique_file;

  MagickBooleanType
    status;

  register Image
    *p;

  register ssize_t
    i;

  size_t
    filesize,
    length;

  ssize_t
    count;

  unsigned char
    magick[MaxTextExtent];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  pwp_image=AcquireImage(image_info);
  image=pwp_image;
  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return((Image *) NULL);
  count=ReadBlob(pwp_image,5,magick);
  if ((count != 5) || (LocaleNCompare((char *) magick,""SFW95"",5) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  read_info=CloneImageInfo(image_info);
  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,
    (void *) NULL);
  SetImageInfoBlob(read_info,(void *) NULL,0);
  unique_file=AcquireUniqueFileResource(read_info->filename);
  for ( ; ; )
  {
    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))
    {
      for (i=0; i < 17; i++)
        magick[i]=magick[i+1];
      magick[17]=(unsigned char) c;
      if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) == 0)
        break;
    }
    if (c == EOF)
      break;
    if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) != 0)
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      }
    /*
      Dump SFW image to a temporary file.
    */
    file=(FILE *) NULL;
    if (unique_file != -1)
      file=fdopen(unique_file,""wb"");
    if ((unique_file == -1) || (file == (FILE *) NULL))
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",
          image->filename);
        image=DestroyImageList(image);
        return((Image *) NULL);
      }
    length=fwrite(""SFW94A"",1,6,file);
    (void) length;
    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];
    for (i=0; i < (ssize_t) filesize; i++)
    {
      c=ReadBlobByte(pwp_image);
      (void) fputc(c,file);
    }
    (void) fclose(file);
    next_image=ReadImage(read_info,exception);
    if (next_image == (Image *) NULL)
      break;
    (void) FormatLocaleString(next_image->filename,MaxTextExtent,
      ""slide_%02ld.sfw"",(long) next_image->scene);
    if (image == (Image *) NULL)
      image=next_image;
    else
      {
        /*
          Link image into image list.
        */
        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;
        next_image->previous=p;
        next_image->scene=p->scene+1;
        p->next=next_image;
      }
    if (image_info->number_scenes != 0)
      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),
      GetBlobSize(pwp_image));
    if (status == MagickFalse)
      break;
  }
  if (unique_file != -1)
     (void) close(unique_file);
   (void) RelinquishUniqueFileResource(read_info->filename);
   read_info=DestroyImageInfo(read_info);
  (void) CloseBlob(pwp_image);
  pwp_image=DestroyImage(pwp_image);
   if (EOFBlob(image) != MagickFalse)
     {
       char
        *message;

      message=GetExceptionMessage(errno);
      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,
        ""UnexpectedEndOfFile"",""`%s': %s"",image->filename,message);
      message=DestroyString(message);
    }
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  FILE
    *file;

  Image
    *image,
    *next_image,
    *pwp_image;

  ImageInfo
    *read_info;

  int
    c,
    unique_file;

  MagickBooleanType
    status;

  register Image
    *p;

  register ssize_t
    i;

  size_t
    filesize,
    length;

  ssize_t
    count;

  unsigned char
    magick[MaxTextExtent];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  pwp_image=AcquireImage(image_info);
  image=pwp_image;
  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return((Image *) NULL);
  count=ReadBlob(pwp_image,5,magick);
  if ((count != 5) || (LocaleNCompare((char *) magick,""SFW95"",5) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  read_info=CloneImageInfo(image_info);
  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,
    (void *) NULL);
  SetImageInfoBlob(read_info,(void *) NULL,0);
  unique_file=AcquireUniqueFileResource(read_info->filename);
  for ( ; ; )
  {
    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))
    {
      for (i=0; i < 17; i++)
        magick[i]=magick[i+1];
      magick[17]=(unsigned char) c;
      if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) == 0)
        break;
    }
    if (c == EOF)
      break;
    if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) != 0)
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      }
    /*
      Dump SFW image to a temporary file.
    */
    file=(FILE *) NULL;
    if (unique_file != -1)
      file=fdopen(unique_file,""wb"");
    if ((unique_file == -1) || (file == (FILE *) NULL))
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",
          image->filename);
        image=DestroyImageList(image);
        return((Image *) NULL);
      }
    length=fwrite(""SFW94A"",1,6,file);
    (void) length;
    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];
    for (i=0; i < (ssize_t) filesize; i++)
    {
      c=ReadBlobByte(pwp_image);
      (void) fputc(c,file);
    }
    (void) fclose(file);
    next_image=ReadImage(read_info,exception);
    if (next_image == (Image *) NULL)
      break;
    (void) FormatLocaleString(next_image->filename,MaxTextExtent,
      ""slide_%02ld.sfw"",(long) next_image->scene);
    if (image == (Image *) NULL)
      image=next_image;
    else
      {
        /*
          Link image into image list.
        */
        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;
        next_image->previous=p;
        next_image->scene=p->scene+1;
        p->next=next_image;
      }
    if (image_info->number_scenes != 0)
      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),
      GetBlobSize(pwp_image));
    if (status == MagickFalse)
      break;
  }
  if (unique_file != -1)
     (void) close(unique_file);
   (void) RelinquishUniqueFileResource(read_info->filename);
   read_info=DestroyImageInfo(read_info);
   if (EOFBlob(image) != MagickFalse)
     {
       char
        *message;

      message=GetExceptionMessage(errno);
      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,
        ""UnexpectedEndOfFile"",""`%s': %s"",image->filename,message);
      message=DestroyString(message);
    }
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","The `ReadPWPImage` function is designed to read and process images in the PWP (PhotoWorks Picture) format. It begins by validating input parameters and opening the image file for reading. The function checks the file header to ensure it is a valid PWP image, then enters a loop to read image data, looking for specific markers that indicate the start of each image segment. It writes these segments to a temporary file and constructs a linked list of images. The function also manages resources, handles errors, and updates progress, ultimately returning the first image in the list or an error if the reading process fails.","The code defines a function that reads and processes images in a specific format. It begins by validating input parameters and opening the image file for reading. The function checks the file header to confirm it is a valid image format, then enters a loop to read image data, identifying segments based on specific markers. Each segment is written to a temporary file, and a linked list of images is constructed. The function manages resources, handles potential errors, and updates progress throughout the process, ultimately returning the first image in the list or signaling an error if reading fails.","The vulnerability in the original code arises from the potential for accessing freed memory, particularly when the function attempts to use the `image` variable after it has been destroyed with `DestroyImageList`. If an error occurs during the reading process, the code may still reference `image`, leading to undefined behavior. The fix involves ensuring that the `image` variable is not accessed after it has been destroyed. The updated code checks for the validity of `next_image` before linking it to the list and ensures that resources are properly managed, preventing any use of memory that has already been freed.","The vulnerability in the original code stems from the risk of accessing memory that has already been freed, which can lead to undefined behavior and potential crashes. This occurs when the code attempts to reference an object after it has been destroyed, particularly in error handling scenarios. The fix addresses this issue by ensuring that the code does not attempt to use any freed memory. The updated implementation includes checks to validate the integrity of objects before accessing them, thereby preventing any operations on deallocated memory and ensuring safer resource management throughout the process.","The vulnerability was fixed by adding checks to ensure that the `next_image` variable is valid before it is linked to the `image` list. Specifically, the code now verifies that `next_image` is not `NULL` after calling `ReadImage`, preventing any operations on a potentially freed object. Additionally, the code ensures that the `image` variable is not accessed after it has been destroyed with `DestroyImageList`. By managing the flow of control more carefully and validating object states, the updated implementation effectively prevents any use of memory that has already been freed, enhancing overall stability.","The vulnerability was fixed by implementing checks to ensure that objects are valid before any operations are performed on them, particularly after they may have been deallocated. The updated code includes conditions that verify the integrity of newly read objects before linking them to the existing list, preventing any access to freed memory. Additionally, the flow of control was adjusted to avoid referencing any objects that have already been destroyed, thereby ensuring that all memory management is handled safely. This approach effectively mitigates the risk of undefined behavior and enhances the overall stability of the code.","CWE-416,CWE-825,CWE-415,CWE-476,CWE-119,CWE-404,CWE-664,CWE-824,CWE-367,CWE-672",Y,1
35,35,181838,181838,,Remote,Not required,Partial,CVE-2016-9936,https://www.cvedetails.com/cve/CVE-2016-9936/,CWE-416,Low,Partial,Partial,,2017-01-04,7.5,The unserialize implementation in ext/standard/var.c in PHP 7.x before 7.0.14 allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted serialized data.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-6834.,2018-05-03,DoS ,5,https://github.com/php/php-src/commit/b2af4e8868726a040234de113436c6e4f6372d17,b2af4e8868726a040234de113436c6e4f6372d17,Complete the fix of bug #70172 for PHP 7,5,ext/standard/var.c,"{""sha"": ""2b12a78edb5be332c0fbef46a76402a58125dbcf"", ""filename"": ""ext/standard/tests/serialize/bug70172_2.phpt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/php/php-src/blob/b2af4e8868726a040234de113436c6e4f6372d17/ext/standard/tests/serialize/bug70172_2.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/b2af4e8868726a040234de113436c6e4f6372d17/ext/standard/tests/serialize/bug70172_2.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/standard/tests/serialize/bug70172_2.phpt?ref=b2af4e8868726a040234de113436c6e4f6372d17"", ""patch"": ""@@ -1,7 +1,5 @@\n --TEST--\n Bug #70172 - Use After Free Vulnerability in unserialize()\n---XFAIL--\n-Unfinished merge, needs fix.\n --FILE--\n <?php\n class obj implements Serializable {\n@@ -61,10 +59,10 @@ array(2) {\n     [0]=>\n     array(1) {\n       [0]=>\n-      &object(obj2)#%d (1) {\n+      object(obj2)#%d (1) {\n         [\""ryat\""]=>\n         int(1)\n       }\n     }\n   }\n-}\n\\ No newline at end of file\n+}""}<_**next**_>{""sha"": ""88719ccb64dcdb8f19723775a63f079debe6261f"", ""filename"": ""ext/standard/var.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/php/php-src/blob/b2af4e8868726a040234de113436c6e4f6372d17/ext/standard/var.c"", ""raw_url"": ""https://github.com/php/php-src/raw/b2af4e8868726a040234de113436c6e4f6372d17/ext/standard/var.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/standard/var.c?ref=b2af4e8868726a040234de113436c6e4f6372d17"", ""patch"": ""@@ -1036,6 +1036,7 @@ PHP_FUNCTION(unserialize)\n \tconst unsigned char *p;\n \tphp_unserialize_data_t var_hash;\n \tzval *options = NULL, *classes = NULL;\n+\tzval *retval;\n \tHashTable *class_hash = NULL;\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS(), \""s|a\"", &buf, &buf_len, &options) == FAILURE) {\n@@ -1067,22 +1068,21 @@ PHP_FUNCTION(unserialize)\n \t\t}\n \t}\n \n-\tif (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {\n+\tretval = var_tmp_var(&var_hash);\n+\tif (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {\n \t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n \t\tif (class_hash) {\n \t\t\tzend_hash_destroy(class_hash);\n \t\t\tFREE_HASHTABLE(class_hash);\n \t\t}\n-\t\tzval_ptr_dtor(return_value);\n \t\tif (!EG(exception)) {\n \t\t\tphp_error_docref(NULL, E_NOTICE, \""Error at offset \"" ZEND_LONG_FMT \"" of %zd bytes\"",\n \t\t\t\t(zend_long)((char*)p - buf), buf_len);\n \t\t}\n \t\tRETURN_FALSE;\n \t}\n-\t/* We should keep an reference to return_value to prevent it from being dtor\n-\t   in case nesting calls to unserialize */\n-\tvar_push_dtor(&var_hash, return_value);\n+\n+\tZVAL_COPY(return_value, retval);\n \n \tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n \tif (class_hash) {""}","PHP_FUNCTION(unserialize)
{
	char *buf = NULL;
	size_t buf_len;
 	const unsigned char *p;
 	php_unserialize_data_t var_hash;
 	zval *options = NULL, *classes = NULL;
	zval *retval;
 	HashTable *class_hash = NULL;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s|a"", &buf, &buf_len, &options) == FAILURE) {
		RETURN_FALSE;
	}

	if (buf_len == 0) {
		RETURN_FALSE;
	}

	p = (const unsigned char*) buf;
	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	if(options != NULL) {
		classes = zend_hash_str_find(Z_ARRVAL_P(options), ""allowed_classes"", sizeof(""allowed_classes"")-1);
		if(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {
			ALLOC_HASHTABLE(class_hash);
			zend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);
		}
		if(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {
			zval *entry;
			zend_string *lcname;

			ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {
				convert_to_string_ex(entry);
				lcname = zend_string_tolower(Z_STR_P(entry));
				zend_hash_add_empty_element(class_hash, lcname);
		        zend_string_release(lcname);
			} ZEND_HASH_FOREACH_END();
 		}
 	}
 
	retval = var_tmp_var(&var_hash);
	if (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {
 		PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 		if (class_hash) {
 			zend_hash_destroy(class_hash);
 			FREE_HASHTABLE(class_hash);
 		}
 		if (!EG(exception)) {
 			php_error_docref(NULL, E_NOTICE, ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"",
 				(zend_long)((char*)p - buf), buf_len);
 		}
 		RETURN_FALSE;
 	}

	ZVAL_COPY(return_value, retval);
 
 	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 	if (class_hash) {
		zend_hash_destroy(class_hash);
		FREE_HASHTABLE(class_hash);
	}
}
","PHP_FUNCTION(unserialize)
{
	char *buf = NULL;
	size_t buf_len;
 	const unsigned char *p;
 	php_unserialize_data_t var_hash;
 	zval *options = NULL, *classes = NULL;
 	HashTable *class_hash = NULL;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s|a"", &buf, &buf_len, &options) == FAILURE) {
		RETURN_FALSE;
	}

	if (buf_len == 0) {
		RETURN_FALSE;
	}

	p = (const unsigned char*) buf;
	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	if(options != NULL) {
		classes = zend_hash_str_find(Z_ARRVAL_P(options), ""allowed_classes"", sizeof(""allowed_classes"")-1);
		if(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {
			ALLOC_HASHTABLE(class_hash);
			zend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);
		}
		if(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {
			zval *entry;
			zend_string *lcname;

			ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {
				convert_to_string_ex(entry);
				lcname = zend_string_tolower(Z_STR_P(entry));
				zend_hash_add_empty_element(class_hash, lcname);
		        zend_string_release(lcname);
			} ZEND_HASH_FOREACH_END();
 		}
 	}
 
	if (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {
 		PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 		if (class_hash) {
 			zend_hash_destroy(class_hash);
 			FREE_HASHTABLE(class_hash);
 		}
		zval_ptr_dtor(return_value);
 		if (!EG(exception)) {
 			php_error_docref(NULL, E_NOTICE, ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"",
 				(zend_long)((char*)p - buf), buf_len);
 		}
 		RETURN_FALSE;
 	}
	/* We should keep an reference to return_value to prevent it from being dtor
	   in case nesting calls to unserialize */
	var_push_dtor(&var_hash, return_value);
 
 	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 	if (class_hash) {
		zend_hash_destroy(class_hash);
		FREE_HASHTABLE(class_hash);
	}
}
",C,"	zval *retval;
	retval = var_tmp_var(&var_hash);
	if (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {

	ZVAL_COPY(return_value, retval);
","	if (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {
		zval_ptr_dtor(return_value);
	/* We should keep an reference to return_value to prevent it from being dtor
	   in case nesting calls to unserialize */
	var_push_dtor(&var_hash, return_value);
",,"@@ -1036,6 +1036,7 @@ PHP_FUNCTION(unserialize)
 	const unsigned char *p;
 	php_unserialize_data_t var_hash;
 	zval *options = NULL, *classes = NULL;
+	zval *retval;
 	HashTable *class_hash = NULL;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s|a"", &buf, &buf_len, &options) == FAILURE) {
@@ -1067,22 +1068,21 @@ PHP_FUNCTION(unserialize)
 		}
 	}
 
-	if (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {
+	retval = var_tmp_var(&var_hash);
+	if (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {
 		PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 		if (class_hash) {
 			zend_hash_destroy(class_hash);
 			FREE_HASHTABLE(class_hash);
 		}
-		zval_ptr_dtor(return_value);
 		if (!EG(exception)) {
 			php_error_docref(NULL, E_NOTICE, ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"",
 				(zend_long)((char*)p - buf), buf_len);
 		}
 		RETURN_FALSE;
 	}
-	/* We should keep an reference to return_value to prevent it from being dtor
-	   in case nesting calls to unserialize */
-	var_push_dtor(&var_hash, return_value);
+
+	ZVAL_COPY(return_value, retval);
 
 	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 	if (class_hash) {",php-src,b2af4e8868726a040234de113436c6e4f6372d17,3d73f718b2715c65be088ef6cb038d30e5d4bb86,1,"PHP_FUNCTION(unserialize)
{
	char *buf = NULL;
	size_t buf_len;
 	const unsigned char *p;
 	php_unserialize_data_t var_hash;
 	zval *options = NULL, *classes = NULL;
//fix_flaw_line_below:
//	zval *retval;
 	HashTable *class_hash = NULL;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s|a"", &buf, &buf_len, &options) == FAILURE) {
		RETURN_FALSE;
	}

	if (buf_len == 0) {
		RETURN_FALSE;
	}

	p = (const unsigned char*) buf;
	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	if(options != NULL) {
		classes = zend_hash_str_find(Z_ARRVAL_P(options), ""allowed_classes"", sizeof(""allowed_classes"")-1);
		if(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {
			ALLOC_HASHTABLE(class_hash);
			zend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);
		}
		if(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {
			zval *entry;
			zend_string *lcname;

			ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {
				convert_to_string_ex(entry);
				lcname = zend_string_tolower(Z_STR_P(entry));
				zend_hash_add_empty_element(class_hash, lcname);
		        zend_string_release(lcname);
			} ZEND_HASH_FOREACH_END();
 		}
 	}
 
//flaw_line_below:
	if (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {
//fix_flaw_line_below:
//	retval = var_tmp_var(&var_hash);
//fix_flaw_line_below:
//	if (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {
 		PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 		if (class_hash) {
 			zend_hash_destroy(class_hash);
 			FREE_HASHTABLE(class_hash);
 		}
//flaw_line_below:
		zval_ptr_dtor(return_value);
 		if (!EG(exception)) {
 			php_error_docref(NULL, E_NOTICE, ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"",
 				(zend_long)((char*)p - buf), buf_len);
 		}
 		RETURN_FALSE;
 	}
//flaw_line_below:
	/* We should keep an reference to return_value to prevent it from being dtor
//flaw_line_below:
	   in case nesting calls to unserialize */
//flaw_line_below:
	var_push_dtor(&var_hash, return_value);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	ZVAL_COPY(return_value, retval);
 
 	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 	if (class_hash) {
		zend_hash_destroy(class_hash);
		FREE_HASHTABLE(class_hash);
	}
}
",181838,"PHP_FUNCTION(unserialize)
{
	char *buf = NULL;
	size_t buf_len;
 	const unsigned char *p;
 	php_unserialize_data_t var_hash;
 	zval *options = NULL, *classes = NULL;
 	HashTable *class_hash = NULL;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s|a"", &buf, &buf_len, &options) == FAILURE) {
		RETURN_FALSE;
	}

	if (buf_len == 0) {
		RETURN_FALSE;
	}

	p = (const unsigned char*) buf;
	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	if(options != NULL) {
		classes = zend_hash_str_find(Z_ARRVAL_P(options), ""allowed_classes"", sizeof(""allowed_classes"")-1);
		if(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {
			ALLOC_HASHTABLE(class_hash);
			zend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);
		}
		if(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {
			zval *entry;
			zend_string *lcname;

			ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {
				convert_to_string_ex(entry);
				lcname = zend_string_tolower(Z_STR_P(entry));
				zend_hash_add_empty_element(class_hash, lcname);
		        zend_string_release(lcname);
			} ZEND_HASH_FOREACH_END();
 		}
 	}
 
	if (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {
 		PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 		if (class_hash) {
 			zend_hash_destroy(class_hash);
 			FREE_HASHTABLE(class_hash);
 		}
		zval_ptr_dtor(return_value);
 		if (!EG(exception)) {
 			php_error_docref(NULL, E_NOTICE, ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"",
 				(zend_long)((char*)p - buf), buf_len);
 		}
 		RETURN_FALSE;
 	}
	/* We should keep an reference to return_value to prevent it from being dtor
	   in case nesting calls to unserialize */
	var_push_dtor(&var_hash, return_value);
 
 	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 	if (class_hash) {
		zend_hash_destroy(class_hash);
		FREE_HASHTABLE(class_hash);
	}
}
","PHP_FUNCTION(unserialize)
{
	char *buf = NULL;
	size_t buf_len;
 	const unsigned char *p;
 	php_unserialize_data_t var_hash;
 	zval *options = NULL, *classes = NULL;
	zval *retval;
 	HashTable *class_hash = NULL;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s|a"", &buf, &buf_len, &options) == FAILURE) {
		RETURN_FALSE;
	}

	if (buf_len == 0) {
		RETURN_FALSE;
	}

	p = (const unsigned char*) buf;
	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	if(options != NULL) {
		classes = zend_hash_str_find(Z_ARRVAL_P(options), ""allowed_classes"", sizeof(""allowed_classes"")-1);
		if(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {
			ALLOC_HASHTABLE(class_hash);
			zend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);
		}
		if(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {
			zval *entry;
			zend_string *lcname;

			ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {
				convert_to_string_ex(entry);
				lcname = zend_string_tolower(Z_STR_P(entry));
				zend_hash_add_empty_element(class_hash, lcname);
		        zend_string_release(lcname);
			} ZEND_HASH_FOREACH_END();
 		}
 	}
 
	retval = var_tmp_var(&var_hash);
	if (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {
 		PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 		if (class_hash) {
 			zend_hash_destroy(class_hash);
 			FREE_HASHTABLE(class_hash);
 		}
 		if (!EG(exception)) {
 			php_error_docref(NULL, E_NOTICE, ""Error at offset "" ZEND_LONG_FMT "" of %zd bytes"",
 				(zend_long)((char*)p - buf), buf_len);
 		}
 		RETURN_FALSE;
 	}

	ZVAL_COPY(return_value, retval);
 
 	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 	if (class_hash) {
		zend_hash_destroy(class_hash);
		FREE_HASHTABLE(class_hash);
	}
}
","The provided PHP code defines a function `unserialize` that deserializes a string representation of a PHP variable back into its original form. It begins by parsing input parameters, including the serialized string and optional settings for allowed classes. If the string is empty, it returns false. The function initializes a variable hash for tracking variables during the unserialization process. It checks for allowed classes and populates a hash table if specified. The core deserialization is performed by `php_var_unserialize_ex`, which reconstructs the variable. If successful, it manages memory and references appropriately; otherwise, it handles errors and cleans up resources.","The code defines a function that deserializes a string representation of a variable back into its original form. It begins by validating the input parameters, including the serialized string and optional settings for allowed classes. If the string is empty, the function returns a failure response. It initializes a structure to track variables during the deserialization process and checks for any specified allowed classes, creating a hash table if necessary. The main deserialization occurs through a dedicated process, which reconstructs the variable while managing memory and references, and handles any errors that may arise during the operation.","The vulnerability in the original code stemmed from the potential for object injection attacks during the deserialization process, particularly when handling untrusted input. This was due to the lack of proper validation for allowed classes, which could lead to the instantiation of arbitrary objects. The fixed code addresses this issue by introducing a temporary variable (`retval`) to store the result of the deserialization. It ensures that the deserialized value is copied to the return value only after successful validation, thereby preventing the direct manipulation of the return value and enhancing security by controlling the deserialization process more effectively.","The vulnerability in the original code was related to the deserialization process, which allowed for object injection attacks by not properly validating allowed classes. This could enable an attacker to instantiate arbitrary objects, potentially leading to security breaches. The fixed code mitigates this risk by introducing a mechanism to store the result of the deserialization in a temporary variable, ensuring that the final output is only set after successful validation. This change enhances security by controlling the deserialization flow and preventing untrusted input from directly affecting the return value, thereby addressing the underlying issue effectively.","The vulnerability was fixed by introducing a temporary variable, `retval`, to hold the result of the deserialization process. In the updated code, the function `var_tmp_var` is called to initialize this temporary variable before invoking `php_var_unserialize_ex`. This ensures that the deserialized value is only copied to `return_value` after confirming that the deserialization was successful. By doing so, the code prevents untrusted input from directly affecting the return value, thereby mitigating the risk of object injection attacks and enhancing the overall security of the deserialization process.","The vulnerability was addressed by implementing a mechanism to store the result of the deserialization in a temporary variable before assigning it to the final output. This change ensures that the deserialized data is only copied to the return value after confirming that the deserialization process was successful. By separating the temporary storage from the final output, the code effectively prevents untrusted input from directly influencing the return value, thereby reducing the risk of object injection attacks and enhancing the overall security of the deserialization operation.","CWE-502, CWE-915, CWE-494, CWE-470, CWE-913, CWE-538, CWE-159, CWE-134, CWE-74, CWE-20",N,-1
36,36,181948,181948,,Remote,Not required,Partial,CVE-2016-7906,https://www.cvedetails.com/cve/CVE-2016-7906/,CWE-416,Medium,,,,2017-01-18,4.3,magick/attribute.c in ImageMagick 7.0.3-2 allows remote attackers to cause a denial of service (use-after-free) via a crafted file.,2017-11-03,DoS ,1,https://github.com/ImageMagick/ImageMagick/commit/d63a3c5729df59f183e9e110d5d8385d17caaad0,d63a3c5729df59f183e9e110d5d8385d17caaad0,https://github.com/ImageMagick/ImageMagick/issues/281,1,magick/attribute.c,"{""sha"": ""53d270692f7ed6633cd34414d3aad52452ae2ab9"", ""filename"": ""magick/attribute.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/d63a3c5729df59f183e9e110d5d8385d17caaad0/magick/attribute.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/d63a3c5729df59f183e9e110d5d8385d17caaad0/magick/attribute.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/magick/attribute.c?ref=d63a3c5729df59f183e9e110d5d8385d17caaad0"", ""patch"": ""@@ -1296,7 +1296,7 @@ MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)\n           status=QuantizeImage(quantize_info,image);\n           quantize_info=DestroyQuantizeInfo(quantize_info);\n         }\n-      image->colors=2;\n+      status=AcquireImageColormap(image,2);\n       image->matte=MagickFalse;\n       break;\n     }""}","MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)
{
  const char
    *artifact;

  ImageInfo
    *image_info;

  MagickBooleanType
    status;

  QuantizeInfo
    *quantize_info;

  assert(image != (Image *) NULL);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->signature == MagickSignature);
  status=MagickTrue;
  image_info=AcquireImageInfo();
  image_info->dither=image->dither;
  artifact=GetImageArtifact(image,""dither"");
  if (artifact != (const char *) NULL)
    (void) SetImageOption(image_info,""dither"",artifact);
  switch (type)
  {
    case BilevelType:
    {
      if (SetImageMonochrome(image,&image->exception) == MagickFalse)
        {
          status=TransformImageColorspace(image,GRAYColorspace);
          (void) NormalizeImage(image);
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=2;
          quantize_info->colorspace=GRAYColorspace;
           status=QuantizeImage(quantize_info,image);
           quantize_info=DestroyQuantizeInfo(quantize_info);
         }
      status=AcquireImageColormap(image,2);
       image->matte=MagickFalse;
       break;
     }
    case GrayscaleType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      image->matte=MagickFalse;
      break;
    }
    case GrayscaleMatteType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case PaletteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if ((image->storage_class == DirectClass) || (image->colors > 256))
        {
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=256;
          status=QuantizeImage(quantize_info,image);
          quantize_info=DestroyQuantizeInfo(quantize_info);
        }
      image->matte=MagickFalse;
      break;
    }
    case PaletteBilevelMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      (void) BilevelImageChannel(image,AlphaChannel,(double) QuantumRange/2.0);
      quantize_info=AcquireQuantizeInfo(image_info);
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case PaletteMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      quantize_info=AcquireQuantizeInfo(image_info);
      quantize_info->colorspace=TransparentColorspace;
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case TrueColorType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case TrueColorMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case ColorSeparationType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case ColorSeparationMatteType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case OptimizeType:
    case UndefinedType:
      break;
  }
  image_info=DestroyImageInfo(image_info);
  if (status == MagickFalse)
    return(MagickFalse);
  image->type=type;
  return(MagickTrue);
}
","MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)
{
  const char
    *artifact;

  ImageInfo
    *image_info;

  MagickBooleanType
    status;

  QuantizeInfo
    *quantize_info;

  assert(image != (Image *) NULL);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->signature == MagickSignature);
  status=MagickTrue;
  image_info=AcquireImageInfo();
  image_info->dither=image->dither;
  artifact=GetImageArtifact(image,""dither"");
  if (artifact != (const char *) NULL)
    (void) SetImageOption(image_info,""dither"",artifact);
  switch (type)
  {
    case BilevelType:
    {
      if (SetImageMonochrome(image,&image->exception) == MagickFalse)
        {
          status=TransformImageColorspace(image,GRAYColorspace);
          (void) NormalizeImage(image);
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=2;
          quantize_info->colorspace=GRAYColorspace;
           status=QuantizeImage(quantize_info,image);
           quantize_info=DestroyQuantizeInfo(quantize_info);
         }
      image->colors=2;
       image->matte=MagickFalse;
       break;
     }
    case GrayscaleType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      image->matte=MagickFalse;
      break;
    }
    case GrayscaleMatteType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case PaletteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if ((image->storage_class == DirectClass) || (image->colors > 256))
        {
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=256;
          status=QuantizeImage(quantize_info,image);
          quantize_info=DestroyQuantizeInfo(quantize_info);
        }
      image->matte=MagickFalse;
      break;
    }
    case PaletteBilevelMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      (void) BilevelImageChannel(image,AlphaChannel,(double) QuantumRange/2.0);
      quantize_info=AcquireQuantizeInfo(image_info);
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case PaletteMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      quantize_info=AcquireQuantizeInfo(image_info);
      quantize_info->colorspace=TransparentColorspace;
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case TrueColorType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case TrueColorMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case ColorSeparationType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case ColorSeparationMatteType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case OptimizeType:
    case UndefinedType:
      break;
  }
  image_info=DestroyImageInfo(image_info);
  if (status == MagickFalse)
    return(MagickFalse);
  image->type=type;
  return(MagickTrue);
}
",C,"      status=AcquireImageColormap(image,2);
","      image->colors=2;
",,"@@ -1296,7 +1296,7 @@ MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)
           status=QuantizeImage(quantize_info,image);
           quantize_info=DestroyQuantizeInfo(quantize_info);
         }
-      image->colors=2;
+      status=AcquireImageColormap(image,2);
       image->matte=MagickFalse;
       break;
     }",ImageMagick,d63a3c5729df59f183e9e110d5d8385d17caaad0,105e0a32afde5e5a24bc04885d2c099db850e207,1,"MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)
{
  const char
    *artifact;

  ImageInfo
    *image_info;

  MagickBooleanType
    status;

  QuantizeInfo
    *quantize_info;

  assert(image != (Image *) NULL);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->signature == MagickSignature);
  status=MagickTrue;
  image_info=AcquireImageInfo();
  image_info->dither=image->dither;
  artifact=GetImageArtifact(image,""dither"");
  if (artifact != (const char *) NULL)
    (void) SetImageOption(image_info,""dither"",artifact);
  switch (type)
  {
    case BilevelType:
    {
      if (SetImageMonochrome(image,&image->exception) == MagickFalse)
        {
          status=TransformImageColorspace(image,GRAYColorspace);
          (void) NormalizeImage(image);
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=2;
          quantize_info->colorspace=GRAYColorspace;
           status=QuantizeImage(quantize_info,image);
           quantize_info=DestroyQuantizeInfo(quantize_info);
         }
//flaw_line_below:
      image->colors=2;
//fix_flaw_line_below:
//      status=AcquireImageColormap(image,2);
       image->matte=MagickFalse;
       break;
     }
    case GrayscaleType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      image->matte=MagickFalse;
      break;
    }
    case GrayscaleMatteType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case PaletteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if ((image->storage_class == DirectClass) || (image->colors > 256))
        {
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=256;
          status=QuantizeImage(quantize_info,image);
          quantize_info=DestroyQuantizeInfo(quantize_info);
        }
      image->matte=MagickFalse;
      break;
    }
    case PaletteBilevelMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      (void) BilevelImageChannel(image,AlphaChannel,(double) QuantumRange/2.0);
      quantize_info=AcquireQuantizeInfo(image_info);
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case PaletteMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      quantize_info=AcquireQuantizeInfo(image_info);
      quantize_info->colorspace=TransparentColorspace;
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case TrueColorType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case TrueColorMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case ColorSeparationType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case ColorSeparationMatteType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case OptimizeType:
    case UndefinedType:
      break;
  }
  image_info=DestroyImageInfo(image_info);
  if (status == MagickFalse)
    return(MagickFalse);
  image->type=type;
  return(MagickTrue);
}
",181948,"MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)
{
  const char
    *artifact;

  ImageInfo
    *image_info;

  MagickBooleanType
    status;

  QuantizeInfo
    *quantize_info;

  assert(image != (Image *) NULL);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->signature == MagickSignature);
  status=MagickTrue;
  image_info=AcquireImageInfo();
  image_info->dither=image->dither;
  artifact=GetImageArtifact(image,""dither"");
  if (artifact != (const char *) NULL)
    (void) SetImageOption(image_info,""dither"",artifact);
  switch (type)
  {
    case BilevelType:
    {
      if (SetImageMonochrome(image,&image->exception) == MagickFalse)
        {
          status=TransformImageColorspace(image,GRAYColorspace);
          (void) NormalizeImage(image);
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=2;
          quantize_info->colorspace=GRAYColorspace;
           status=QuantizeImage(quantize_info,image);
           quantize_info=DestroyQuantizeInfo(quantize_info);
         }
      image->colors=2;
       image->matte=MagickFalse;
       break;
     }
    case GrayscaleType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      image->matte=MagickFalse;
      break;
    }
    case GrayscaleMatteType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case PaletteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if ((image->storage_class == DirectClass) || (image->colors > 256))
        {
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=256;
          status=QuantizeImage(quantize_info,image);
          quantize_info=DestroyQuantizeInfo(quantize_info);
        }
      image->matte=MagickFalse;
      break;
    }
    case PaletteBilevelMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      (void) BilevelImageChannel(image,AlphaChannel,(double) QuantumRange/2.0);
      quantize_info=AcquireQuantizeInfo(image_info);
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case PaletteMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      quantize_info=AcquireQuantizeInfo(image_info);
      quantize_info->colorspace=TransparentColorspace;
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case TrueColorType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case TrueColorMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case ColorSeparationType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case ColorSeparationMatteType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case OptimizeType:
    case UndefinedType:
      break;
  }
  image_info=DestroyImageInfo(image_info);
  if (status == MagickFalse)
    return(MagickFalse);
  image->type=type;
  return(MagickTrue);
}
","MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)
{
  const char
    *artifact;

  ImageInfo
    *image_info;

  MagickBooleanType
    status;

  QuantizeInfo
    *quantize_info;

  assert(image != (Image *) NULL);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->signature == MagickSignature);
  status=MagickTrue;
  image_info=AcquireImageInfo();
  image_info->dither=image->dither;
  artifact=GetImageArtifact(image,""dither"");
  if (artifact != (const char *) NULL)
    (void) SetImageOption(image_info,""dither"",artifact);
  switch (type)
  {
    case BilevelType:
    {
      if (SetImageMonochrome(image,&image->exception) == MagickFalse)
        {
          status=TransformImageColorspace(image,GRAYColorspace);
          (void) NormalizeImage(image);
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=2;
          quantize_info->colorspace=GRAYColorspace;
           status=QuantizeImage(quantize_info,image);
           quantize_info=DestroyQuantizeInfo(quantize_info);
         }
      status=AcquireImageColormap(image,2);
       image->matte=MagickFalse;
       break;
     }
    case GrayscaleType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      image->matte=MagickFalse;
      break;
    }
    case GrayscaleMatteType:
    {
      if (SetImageGray(image,&image->exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case PaletteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if ((image->storage_class == DirectClass) || (image->colors > 256))
        {
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=256;
          status=QuantizeImage(quantize_info,image);
          quantize_info=DestroyQuantizeInfo(quantize_info);
        }
      image->matte=MagickFalse;
      break;
    }
    case PaletteBilevelMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      (void) BilevelImageChannel(image,AlphaChannel,(double) QuantumRange/2.0);
      quantize_info=AcquireQuantizeInfo(image_info);
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case PaletteMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      quantize_info=AcquireQuantizeInfo(image_info);
      quantize_info->colorspace=TransparentColorspace;
      status=QuantizeImage(quantize_info,image);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case TrueColorType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case TrueColorMatteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case ColorSeparationType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      image->matte=MagickFalse;
      break;
    }
    case ColorSeparationMatteType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            (void) TransformImageColorspace(image,sRGBColorspace);
          status=TransformImageColorspace(image,CMYKColorspace);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass);
      if (image->matte == MagickFalse)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
      break;
    }
    case OptimizeType:
    case UndefinedType:
      break;
  }
  image_info=DestroyImageInfo(image_info);
  if (status == MagickFalse)
    return(MagickFalse);
  image->type=type;
  return(MagickTrue);
}
","The `SetImageType` function modifies the type of a given image based on the specified `ImageType`. It begins by validating the input image and logging debug information if enabled. Depending on the requested type (e.g., Bilevel, Grayscale, Palette), the function performs various transformations, such as changing the colorspace, quantizing the image, and setting alpha channels. It also manages memory for `QuantizeInfo` and `ImageInfo` structures. After processing, it updates the image's type and returns a success status. The function ensures that the image meets the requirements for the specified type while handling exceptions appropriately.","The provided code defines a function that alters the type of an image based on a specified category. It begins by validating the image and logging debug information if necessary. The function then processes the image according to the requested type, which may involve changing its colorspace, applying quantization, and adjusting transparency settings. Memory management is handled for auxiliary structures used during processing. After completing the transformations, the function updates the image's type and returns a success status, ensuring that the image conforms to the requirements of the new type while managing any exceptions that arise.","The vulnerability in the original code stemmed from the lack of proper handling for the image's color map when converting to a Bilevel type, which could lead to unexpected behavior or crashes if the image did not have a suitable color map. Specifically, the absence of a call to acquire a color map for the image could result in operations that assumed the presence of a valid color map failing. The fix introduced a call to acquire the image's color map after attempting to set it to Bilevel, ensuring that the image is properly prepared for the conversion and preventing potential errors related to color map access.","The vulnerability in the original code arose from inadequate handling of the image's color map during the conversion to a specific type, which could lead to crashes or undefined behavior if the image lacked a proper color map. This oversight meant that subsequent operations could fail when they relied on the existence of a valid color map. The fix addressed this issue by explicitly acquiring the color map after initiating the conversion process, ensuring that the image was correctly prepared for the new type and preventing potential errors related to color map access during further processing.","The vulnerability was fixed by adding a call to acquire the image's color map after attempting to set the image to Bilevel type. Specifically, the code now includes the line `status=AcquireImageColormap(image,2);` within the BilevelType case. This ensures that a valid color map is created for the image, which is essential for subsequent operations that depend on it. By ensuring that the color map is properly initialized, the fix prevents potential crashes or undefined behavior that could occur if the image processing functions later attempted to access a non-existent or invalid color map.","The vulnerability was addressed by incorporating a step to ensure that a valid color map is acquired when converting the image to a specific type. This addition guarantees that the image is properly prepared for processing, preventing potential crashes or undefined behavior that could arise from attempting to access a non-existent color map. By explicitly initializing the color map during the conversion process, the fix enhances the robustness of the code, ensuring that subsequent operations can safely rely on the presence of a valid color map, thereby improving overall stability and reliability.","CWE-456, CWE-665, CWE-457, CWE-824, CWE-909, CWE-908, CWE-476, CWE-119, CWE-416, CWE-404",N,-1
37,37,182046,182046,,Remote,Not required,Partial,CVE-2015-5221,https://www.cvedetails.com/cve/CVE-2015-5221/,CWE-416,Medium,,,,2017-07-25,4.3,Use-after-free vulnerability in the mif_process_cmpt function in libjasper/mif/mif_cod.c in the JasPer JPEG-2000 library before 1.900.2 allows remote attackers to cause a denial of service (crash) via a crafted JPEG 2000 image file.,2018-11-22,DoS ,1,https://github.com/mdadams/jasper/commit/df5d2867e8004e51e18b89865bc4aa69229227b3,df5d2867e8004e51e18b89865bc4aa69229227b3,CVE-2015-5221,1,src/libjasper/mif/mif_cod.c,"{""sha"": ""5afc0a249ba700ab337e47ef56ead0114cfc5385"", ""filename"": ""src/libjasper/mif/mif_cod.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/mdadams/jasper/blob/df5d2867e8004e51e18b89865bc4aa69229227b3/src/libjasper/mif/mif_cod.c"", ""raw_url"": ""https://github.com/mdadams/jasper/raw/df5d2867e8004e51e18b89865bc4aa69229227b3/src/libjasper/mif/mif_cod.c"", ""contents_url"": ""https://api.github.com/repos/mdadams/jasper/contents/src/libjasper/mif/mif_cod.c?ref=df5d2867e8004e51e18b89865bc4aa69229227b3"", ""patch"": ""@@ -570,13 +570,13 @@ static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)\n \t\t\tbreak;\n \t\t}\n \t}\n-\tjas_tvparser_destroy(tvp);\n \tif (!cmpt->sampperx || !cmpt->samppery) {\n \t\tgoto error;\n \t}\n \tif (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {\n \t\tgoto error;\n \t}\n+\tjas_tvparser_destroy(tvp);\n \treturn 0;\n \n error:""}","static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)
{
	jas_tvparser_t *tvp;
	mif_cmpt_t *cmpt;
	int id;

	cmpt = 0;
	tvp = 0;

	if (!(cmpt = mif_cmpt_create())) {
		goto error;
	}
	cmpt->tlx = 0;
	cmpt->tly = 0;
	cmpt->sampperx = 0;
	cmpt->samppery = 0;
	cmpt->width = 0;
	cmpt->height = 0;
	cmpt->prec = 0;
	cmpt->sgnd = -1;
	cmpt->data = 0;

	if (!(tvp = jas_tvparser_create(buf))) {
		goto error;
	}
	while (!(id = jas_tvparser_next(tvp))) {
		switch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,
		  jas_tvparser_gettag(tvp)))->id) {
		case MIF_TLX:
			cmpt->tlx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_TLY:
			cmpt->tly = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_WIDTH:
			cmpt->width = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HEIGHT:
			cmpt->height = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HSAMP:
			cmpt->sampperx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_VSAMP:
			cmpt->samppery = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_PREC:
			cmpt->prec = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_SGND:
			cmpt->sgnd = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_DATA:
			if (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {
				return -1;
			}
 			break;
 		}
 	}
 	if (!cmpt->sampperx || !cmpt->samppery) {
 		goto error;
 	}
 	if (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {
 		goto error;
 	}
	jas_tvparser_destroy(tvp);
 	return 0;
 
 error:
	if (cmpt) {
		mif_cmpt_destroy(cmpt);
	}
	if (tvp) {
		jas_tvparser_destroy(tvp);
	}
	return -1;
}
","static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)
{
	jas_tvparser_t *tvp;
	mif_cmpt_t *cmpt;
	int id;

	cmpt = 0;
	tvp = 0;

	if (!(cmpt = mif_cmpt_create())) {
		goto error;
	}
	cmpt->tlx = 0;
	cmpt->tly = 0;
	cmpt->sampperx = 0;
	cmpt->samppery = 0;
	cmpt->width = 0;
	cmpt->height = 0;
	cmpt->prec = 0;
	cmpt->sgnd = -1;
	cmpt->data = 0;

	if (!(tvp = jas_tvparser_create(buf))) {
		goto error;
	}
	while (!(id = jas_tvparser_next(tvp))) {
		switch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,
		  jas_tvparser_gettag(tvp)))->id) {
		case MIF_TLX:
			cmpt->tlx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_TLY:
			cmpt->tly = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_WIDTH:
			cmpt->width = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HEIGHT:
			cmpt->height = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HSAMP:
			cmpt->sampperx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_VSAMP:
			cmpt->samppery = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_PREC:
			cmpt->prec = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_SGND:
			cmpt->sgnd = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_DATA:
			if (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {
				return -1;
			}
 			break;
 		}
 	}
	jas_tvparser_destroy(tvp);
 	if (!cmpt->sampperx || !cmpt->samppery) {
 		goto error;
 	}
 	if (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {
 		goto error;
 	}
 	return 0;
 
 error:
	if (cmpt) {
		mif_cmpt_destroy(cmpt);
	}
	if (tvp) {
		jas_tvparser_destroy(tvp);
	}
	return -1;
}
",C,"	jas_tvparser_destroy(tvp);
","	jas_tvparser_destroy(tvp);
",,"@@ -570,13 +570,13 @@ static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)
 			break;
 		}
 	}
-	jas_tvparser_destroy(tvp);
 	if (!cmpt->sampperx || !cmpt->samppery) {
 		goto error;
 	}
 	if (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {
 		goto error;
 	}
+	jas_tvparser_destroy(tvp);
 	return 0;
 
 error:",jasper,df5d2867e8004e51e18b89865bc4aa69229227b3,b13b8c86be870107f83b0a9a4b77557cb2b65d69,1,"static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)
{
	jas_tvparser_t *tvp;
	mif_cmpt_t *cmpt;
	int id;

	cmpt = 0;
	tvp = 0;

	if (!(cmpt = mif_cmpt_create())) {
		goto error;
	}
	cmpt->tlx = 0;
	cmpt->tly = 0;
	cmpt->sampperx = 0;
	cmpt->samppery = 0;
	cmpt->width = 0;
	cmpt->height = 0;
	cmpt->prec = 0;
	cmpt->sgnd = -1;
	cmpt->data = 0;

	if (!(tvp = jas_tvparser_create(buf))) {
		goto error;
	}
	while (!(id = jas_tvparser_next(tvp))) {
		switch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,
		  jas_tvparser_gettag(tvp)))->id) {
		case MIF_TLX:
			cmpt->tlx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_TLY:
			cmpt->tly = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_WIDTH:
			cmpt->width = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HEIGHT:
			cmpt->height = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HSAMP:
			cmpt->sampperx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_VSAMP:
			cmpt->samppery = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_PREC:
			cmpt->prec = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_SGND:
			cmpt->sgnd = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_DATA:
			if (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {
				return -1;
			}
 			break;
 		}
 	}
//flaw_line_below:
	jas_tvparser_destroy(tvp);
 	if (!cmpt->sampperx || !cmpt->samppery) {
 		goto error;
 	}
 	if (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {
 		goto error;
 	}
//fix_flaw_line_below:
//	jas_tvparser_destroy(tvp);
 	return 0;
 
 error:
	if (cmpt) {
		mif_cmpt_destroy(cmpt);
	}
	if (tvp) {
		jas_tvparser_destroy(tvp);
	}
	return -1;
}
",182046,"static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)
{
	jas_tvparser_t *tvp;
	mif_cmpt_t *cmpt;
	int id;

	cmpt = 0;
	tvp = 0;

	if (!(cmpt = mif_cmpt_create())) {
		goto error;
	}
	cmpt->tlx = 0;
	cmpt->tly = 0;
	cmpt->sampperx = 0;
	cmpt->samppery = 0;
	cmpt->width = 0;
	cmpt->height = 0;
	cmpt->prec = 0;
	cmpt->sgnd = -1;
	cmpt->data = 0;

	if (!(tvp = jas_tvparser_create(buf))) {
		goto error;
	}
	while (!(id = jas_tvparser_next(tvp))) {
		switch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,
		  jas_tvparser_gettag(tvp)))->id) {
		case MIF_TLX:
			cmpt->tlx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_TLY:
			cmpt->tly = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_WIDTH:
			cmpt->width = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HEIGHT:
			cmpt->height = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HSAMP:
			cmpt->sampperx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_VSAMP:
			cmpt->samppery = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_PREC:
			cmpt->prec = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_SGND:
			cmpt->sgnd = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_DATA:
			if (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {
				return -1;
			}
 			break;
 		}
 	}
	jas_tvparser_destroy(tvp);
 	if (!cmpt->sampperx || !cmpt->samppery) {
 		goto error;
 	}
 	if (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {
 		goto error;
 	}
 	return 0;
 
 error:
	if (cmpt) {
		mif_cmpt_destroy(cmpt);
	}
	if (tvp) {
		jas_tvparser_destroy(tvp);
	}
	return -1;
}
","static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)
{
	jas_tvparser_t *tvp;
	mif_cmpt_t *cmpt;
	int id;

	cmpt = 0;
	tvp = 0;

	if (!(cmpt = mif_cmpt_create())) {
		goto error;
	}
	cmpt->tlx = 0;
	cmpt->tly = 0;
	cmpt->sampperx = 0;
	cmpt->samppery = 0;
	cmpt->width = 0;
	cmpt->height = 0;
	cmpt->prec = 0;
	cmpt->sgnd = -1;
	cmpt->data = 0;

	if (!(tvp = jas_tvparser_create(buf))) {
		goto error;
	}
	while (!(id = jas_tvparser_next(tvp))) {
		switch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,
		  jas_tvparser_gettag(tvp)))->id) {
		case MIF_TLX:
			cmpt->tlx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_TLY:
			cmpt->tly = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_WIDTH:
			cmpt->width = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HEIGHT:
			cmpt->height = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_HSAMP:
			cmpt->sampperx = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_VSAMP:
			cmpt->samppery = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_PREC:
			cmpt->prec = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_SGND:
			cmpt->sgnd = atoi(jas_tvparser_getval(tvp));
			break;
		case MIF_DATA:
			if (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {
				return -1;
			}
 			break;
 		}
 	}
 	if (!cmpt->sampperx || !cmpt->samppery) {
 		goto error;
 	}
 	if (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {
 		goto error;
 	}
	jas_tvparser_destroy(tvp);
 	return 0;
 
 error:
	if (cmpt) {
		mif_cmpt_destroy(cmpt);
	}
	if (tvp) {
		jas_tvparser_destroy(tvp);
	}
	return -1;
}
","The `mif_process_cmpt` function processes a component from a given buffer, extracting various attributes such as top-left coordinates, dimensions, sampling rates, precision, and sign from a parsed data structure. It initializes a component structure (`mif_cmpt_t`) and a tag-value parser (`jas_tvparser_t`), then iteratively retrieves tags and their corresponding values from the buffer. Depending on the tag type, it populates the component's properties. If successful, it adds the component to a header structure (`mif_hdr_t`). The function handles errors by cleaning up allocated resources and returns an appropriate status code, indicating success or failure.","The code defines a function that processes a component from a specified data buffer, extracting essential attributes such as coordinates, dimensions, sampling rates, precision, and sign. It initializes a structure to hold the component's properties and a parser to read the data. As it parses the buffer, it assigns values to the component based on identified tags. If the parsing is successful, the component is added to a header structure. The function includes error handling to clean up resources if any step fails, ultimately returning a status code to indicate success or failure of the operation.","The vulnerability in the original code arises from the lack of validation for the input data being parsed, particularly when assigning values to the component's properties. If the input buffer contains unexpected or malicious data, it could lead to improper initialization of the component, potentially causing memory corruption or application crashes. The fix involves adding checks to ensure that the sampling rates (`sampperx` and `samppery`) are non-zero before proceeding to add the component to the header. This validation prevents the addition of improperly configured components, thereby enhancing the robustness and security of the code against malformed input.","The vulnerability in the original code stems from inadequate validation of input data, which could allow for the processing of malformed or malicious data, leading to potential memory corruption or application crashes. Specifically, the code did not check whether certain critical properties were properly initialized before proceeding with further operations. The fix involved implementing checks to ensure that essential attributes were valid and non-zero before adding the component to the header. This added validation step enhances the security and stability of the code by preventing the acceptance of improperly configured components, thereby mitigating the risk associated with unexpected input.","The vulnerability was fixed by adding validation checks for the sampling rates, specifically ensuring that both `sampperx` and `samppery` are non-zero before proceeding to add the component to the header using `mif_hdr_addcmpt`. This prevents the addition of components that may have been improperly initialized due to malformed input data. Additionally, the code now ensures that if the parsing fails or if critical attributes are not set correctly, it will trigger the error handling routine, which cleans up allocated resources and returns an error status, thereby enhancing the overall robustness and security of the function.","The vulnerability was addressed by implementing validation checks to ensure that critical attributes of the component are properly initialized before proceeding with further operations. Specifically, the code now verifies that essential properties are non-zero, which prevents the addition of improperly configured components to the header. Additionally, the error handling routine was enhanced to ensure that resources are cleaned up appropriately if any validation fails or if parsing does not succeed. This approach significantly improves the robustness and security of the code by mitigating the risks associated with processing malformed or unexpected input data.","CWE-665, CWE-457, CWE-456, CWE-476, CWE-704, CWE-824, CWE-416, CWE-404, CWE-682, CWE-908",N,-1
38,38,182066,182066,,Remote,Not required,Complete,CVE-2014-9940,https://www.cvedetails.com/cve/CVE-2014-9940/,CWE-416,High,Complete,Complete,,2017-05-02,7.6,The regulator_ena_gpio_free function in drivers/regulator/core.c in the Linux kernel before 3.19 allows local users to gain privileges or cause a denial of service (use-after-free) via a crafted application.,2017-11-03,DoS +Priv ,2,https://github.com/torvalds/linux/commit/60a2362f769cf549dc466134efe71c8bf9fbaaba,60a2362f769cf549dc466134efe71c8bf9fbaaba,"regulator: core: Fix regualtor_ena_gpio_free not to access pin after freeing

After freeing pin from regulator_ena_gpio_free, loop can access
the pin. So this patch fixes not to access pin after freeing.

Signed-off-by: Seung-Woo Kim <sw0312.kim@samsung.com>
Signed-off-by: Mark Brown <broonie@kernel.org>",0,drivers/regulator/core.c,"{""sha"": ""47a455cfe04fb344409a1f48ac52a7c9450edad3"", ""filename"": ""drivers/regulator/core.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/60a2362f769cf549dc466134efe71c8bf9fbaaba/drivers/regulator/core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/60a2362f769cf549dc466134efe71c8bf9fbaaba/drivers/regulator/core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/regulator/core.c?ref=60a2362f769cf549dc466134efe71c8bf9fbaaba"", ""patch"": ""@@ -1713,6 +1713,8 @@ static void regulator_ena_gpio_free(struct regulator_dev *rdev)\n \t\t\t\tgpiod_put(pin->gpiod);\n \t\t\t\tlist_del(&pin->list);\n \t\t\t\tkfree(pin);\n+\t\t\t\trdev->ena_pin = NULL;\n+\t\t\t\treturn;\n \t\t\t} else {\n \t\t\t\tpin->request_count--;\n \t\t\t}""}","static void regulator_ena_gpio_free(struct regulator_dev *rdev)
{
	struct regulator_enable_gpio *pin, *n;

	if (!rdev->ena_pin)
		return;

	/* Free the GPIO only in case of no use */
	list_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {
		if (pin->gpiod == rdev->ena_pin->gpiod) {
			if (pin->request_count <= 1) {
				pin->request_count = 0;
 				gpiod_put(pin->gpiod);
 				list_del(&pin->list);
 				kfree(pin);
				rdev->ena_pin = NULL;
				return;
 			} else {
 				pin->request_count--;
 			}
		}
	}
}
","static void regulator_ena_gpio_free(struct regulator_dev *rdev)
{
	struct regulator_enable_gpio *pin, *n;

	if (!rdev->ena_pin)
		return;

	/* Free the GPIO only in case of no use */
	list_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {
		if (pin->gpiod == rdev->ena_pin->gpiod) {
			if (pin->request_count <= 1) {
				pin->request_count = 0;
 				gpiod_put(pin->gpiod);
 				list_del(&pin->list);
 				kfree(pin);
 			} else {
 				pin->request_count--;
 			}
		}
	}
}
",C,"				rdev->ena_pin = NULL;
				return;
",,,"@@ -1713,6 +1713,8 @@ static void regulator_ena_gpio_free(struct regulator_dev *rdev)
 				gpiod_put(pin->gpiod);
 				list_del(&pin->list);
 				kfree(pin);
+				rdev->ena_pin = NULL;
+				return;
 			} else {
 				pin->request_count--;
 			}",linux,60a2362f769cf549dc466134efe71c8bf9fbaaba,194dbaefa0da24bb60d9df1c99dda807f51fc33f,1,"static void regulator_ena_gpio_free(struct regulator_dev *rdev)
{
	struct regulator_enable_gpio *pin, *n;

	if (!rdev->ena_pin)
		return;

	/* Free the GPIO only in case of no use */
	list_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {
		if (pin->gpiod == rdev->ena_pin->gpiod) {
			if (pin->request_count <= 1) {
				pin->request_count = 0;
 				gpiod_put(pin->gpiod);
 				list_del(&pin->list);
 				kfree(pin);
//fix_flaw_line_below:
//				rdev->ena_pin = NULL;
//fix_flaw_line_below:
//				return;
 			} else {
 				pin->request_count--;
 			}
		}
	}
}
",182066,"static void regulator_ena_gpio_free(struct regulator_dev *rdev)
{
	struct regulator_enable_gpio *pin, *n;

	if (!rdev->ena_pin)
		return;

	/* Free the GPIO only in case of no use */
	list_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {
		if (pin->gpiod == rdev->ena_pin->gpiod) {
			if (pin->request_count <= 1) {
				pin->request_count = 0;
 				gpiod_put(pin->gpiod);
 				list_del(&pin->list);
 				kfree(pin);
 			} else {
 				pin->request_count--;
 			}
		}
	}
}
","static void regulator_ena_gpio_free(struct regulator_dev *rdev)
{
	struct regulator_enable_gpio *pin, *n;

	if (!rdev->ena_pin)
		return;

	/* Free the GPIO only in case of no use */
	list_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {
		if (pin->gpiod == rdev->ena_pin->gpiod) {
			if (pin->request_count <= 1) {
				pin->request_count = 0;
 				gpiod_put(pin->gpiod);
 				list_del(&pin->list);
 				kfree(pin);
				rdev->ena_pin = NULL;
				return;
 			} else {
 				pin->request_count--;
 			}
		}
	}
}
","The `regulator_ena_gpio_free` function is designed to manage the release of GPIO resources associated with a regulator device (`rdev`). It first checks if the regulator has an enabled GPIO pin; if not, it exits early. The function then iterates through a linked list of GPIO pins (`regulator_ena_gpio_list`) to find the matching GPIO descriptor. If the reference count (`request_count`) for that GPIO is less than or equal to one, it resets the count, releases the GPIO resource using `gpiod_put`, removes the pin from the list, and frees the memory allocated for it. If the count is greater than one, it simply decrements the count.","The provided code manages the release of GPIO resources associated with a regulator device. It first checks if there is an enabled GPIO pin; if none exists, the function terminates early. The code then traverses a linked list of GPIO pins to locate the corresponding descriptor. If the reference count for that GPIO is one or less, it resets the count, releases the GPIO resource, removes the pin from the list, and frees the associated memory. If the reference count is greater than one, it simply decrements the count, ensuring proper resource management and preventing memory leaks.","The vulnerability in the original code arises from the potential for accessing a freed memory location after the GPIO pin is released. Specifically, after the `gpiod_put` and `kfree` functions are called, the loop could still attempt to access the `pin` variable, leading to undefined behavior or crashes. The fix addresses this issue by setting `rdev->ena_pin` to `NULL` immediately after freeing the `pin`, ensuring that any subsequent access to `pin` is avoided. This change prevents dereferencing a pointer to freed memory, thereby enhancing the stability and safety of the code.","The vulnerability in the original code stems from the risk of accessing a memory location that has already been freed, which can lead to undefined behavior or crashes. After releasing the GPIO resource and deallocating memory, the loop could still attempt to reference the freed memory, resulting in potential errors. The fix addresses this issue by ensuring that the code does not access the freed memory by modifying the relevant state immediately after the deallocation. This change effectively prevents any further operations on the released resource, thereby enhancing the safety and reliability of the code.","The vulnerability was fixed by modifying the code to set `rdev->ena_pin` to `NULL` immediately after the `kfree(pin)` call. This change ensures that once the memory for the GPIO pin is freed, the code does not attempt to access the `pin` variable in subsequent iterations of the loop. By doing this, the code prevents any potential dereferencing of a pointer to freed memory, which could lead to undefined behavior. This safeguard effectively eliminates the risk of accessing invalid memory, thereby enhancing the overall stability and safety of the function.","The vulnerability was fixed by ensuring that the code does not access any memory that has already been freed. After the memory deallocation occurs, the relevant state is updated to indicate that the resource is no longer valid. This prevents any subsequent operations from attempting to reference the freed memory, thereby eliminating the risk of undefined behavior or crashes. By implementing this safeguard, the code enhances its reliability and stability, ensuring that it does not inadvertently operate on invalid pointers after the resource has been released.","CWE-416, CWE-415, CWE-825, CWE-476, CWE-758, CWE-763, CWE-562, CWE-908, CWE-690, CWE-672",Y,1
39,39,182069,182069,,Local,Not required,Complete,CVE-2014-9914,https://www.cvedetails.com/cve/CVE-2014-9914/,CWE-416,Low,Complete,Complete,,2017-02-07,7.2,Race condition in the ip4_datagram_release_cb function in net/ipv4/datagram.c in the Linux kernel before 3.15.2 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging incorrect expectations about locking during multithreaded access to internal data structures for IPv4 UDP sockets.,2017-07-24,DoS +Priv ,11,https://github.com/torvalds/linux/commit/9709674e68646cee5a24e3000b3558d25412203a,9709674e68646cee5a24e3000b3558d25412203a,"ipv4: fix a race in ip4_datagram_release_cb()

Alexey gave a AddressSanitizer[1] report that finally gave a good hint
at where was the origin of various problems already reported by Dormando
in the past [2]

Problem comes from the fact that UDP can have a lockless TX path, and
concurrent threads can manipulate sk_dst_cache, while another thread,
is holding socket lock and calls __sk_dst_set() in
ip4_datagram_release_cb() (this was added in linux-3.8)

It seems that all we need to do is to use sk_dst_check() and
sk_dst_set() so that all the writers hold same spinlock
(sk->sk_dst_lock) to prevent corruptions.

TCP stack do not need this protection, as all sk_dst_cache writers hold
the socket lock.

[1]
https://code.google.com/p/address-sanitizer/wiki/AddressSanitizerForKernel

AddressSanitizer: heap-use-after-free in ipv4_dst_check
Read of size 2 by thread T15453:
 [<ffffffff817daa3a>] ipv4_dst_check+0x1a/0x90 ./net/ipv4/route.c:1116
 [<ffffffff8175b789>] __sk_dst_check+0x89/0xe0 ./net/core/sock.c:531
 [<ffffffff81830a36>] ip4_datagram_release_cb+0x46/0x390 ??:0
 [<ffffffff8175eaea>] release_sock+0x17a/0x230 ./net/core/sock.c:2413
 [<ffffffff81830882>] ip4_datagram_connect+0x462/0x5d0 ??:0
 [<ffffffff81846d06>] inet_dgram_connect+0x76/0xd0 ./net/ipv4/af_inet.c:534
 [<ffffffff817580ac>] SYSC_connect+0x15c/0x1c0 ./net/socket.c:1701
 [<ffffffff817596ce>] SyS_connect+0xe/0x10 ./net/socket.c:1682
 [<ffffffff818b0a29>] system_call_fastpath+0x16/0x1b
./arch/x86/kernel/entry_64.S:629

Freed by thread T15455:
 [<ffffffff8178d9b8>] dst_destroy+0xa8/0x160 ./net/core/dst.c:251
 [<ffffffff8178de25>] dst_release+0x45/0x80 ./net/core/dst.c:280
 [<ffffffff818304c1>] ip4_datagram_connect+0xa1/0x5d0 ??:0
 [<ffffffff81846d06>] inet_dgram_connect+0x76/0xd0 ./net/ipv4/af_inet.c:534
 [<ffffffff817580ac>] SYSC_connect+0x15c/0x1c0 ./net/socket.c:1701
 [<ffffffff817596ce>] SyS_connect+0xe/0x10 ./net/socket.c:1682
 [<ffffffff818b0a29>] system_call_fastpath+0x16/0x1b
./arch/x86/kernel/entry_64.S:629

Allocated by thread T15453:
 [<ffffffff8178d291>] dst_alloc+0x81/0x2b0 ./net/core/dst.c:171
 [<ffffffff817db3b7>] rt_dst_alloc+0x47/0x50 ./net/ipv4/route.c:1406
 [<     inlined    >] __ip_route_output_key+0x3e8/0xf70
__mkroute_output ./net/ipv4/route.c:1939
 [<ffffffff817dde08>] __ip_route_output_key+0x3e8/0xf70 ./net/ipv4/route.c:2161
 [<ffffffff817deb34>] ip_route_output_flow+0x14/0x30 ./net/ipv4/route.c:2249
 [<ffffffff81830737>] ip4_datagram_connect+0x317/0x5d0 ??:0
 [<ffffffff81846d06>] inet_dgram_connect+0x76/0xd0 ./net/ipv4/af_inet.c:534
 [<ffffffff817580ac>] SYSC_connect+0x15c/0x1c0 ./net/socket.c:1701
 [<ffffffff817596ce>] SyS_connect+0xe/0x10 ./net/socket.c:1682
 [<ffffffff818b0a29>] system_call_fastpath+0x16/0x1b
./arch/x86/kernel/entry_64.S:629

[2]
<4>[196727.311203] general protection fault: 0000 [#1] SMP
<4>[196727.311224] Modules linked in: xt_TEE xt_dscp xt_DSCP macvlan bridge coretemp crc32_pclmul ghash_clmulni_intel gpio_ich microcode ipmi_watchdog ipmi_devintf sb_edac edac_core lpc_ich mfd_core tpm_tis tpm tpm_bios ipmi_si ipmi_msghandler isci igb libsas i2c_algo_bit ixgbe ptp pps_core mdio
<4>[196727.311333] CPU: 17 PID: 0 Comm: swapper/17 Not tainted 3.10.26 #1
<4>[196727.311344] Hardware name: Supermicro X9DRi-LN4+/X9DR3-LN4+/X9DRi-LN4+/X9DR3-LN4+, BIOS 3.0 07/05/2013
<4>[196727.311364] task: ffff885e6f069700 ti: ffff885e6f072000 task.ti: ffff885e6f072000
<4>[196727.311377] RIP: 0010:[<ffffffff815f8c7f>]  [<ffffffff815f8c7f>] ipv4_dst_destroy+0x4f/0x80
<4>[196727.311399] RSP: 0018:ffff885effd23a70  EFLAGS: 00010282
<4>[196727.311409] RAX: dead000000200200 RBX: ffff8854c398ecc0 RCX: 0000000000000040
<4>[196727.311423] RDX: dead000000100100 RSI: dead000000100100 RDI: dead000000200200
<4>[196727.311437] RBP: ffff885effd23a80 R08: ffffffff815fd9e0 R09: ffff885d5a590800
<4>[196727.311451] R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000
<4>[196727.311464] R13: ffffffff81c8c280 R14: 0000000000000000 R15: ffff880e85ee16ce
<4>[196727.311510] FS:  0000000000000000(0000) GS:ffff885effd20000(0000) knlGS:0000000000000000
<4>[196727.311554] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
<4>[196727.311581] CR2: 00007a46751eb000 CR3: 0000005e65688000 CR4: 00000000000407e0
<4>[196727.311625] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
<4>[196727.311669] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
<4>[196727.311713] Stack:
<4>[196727.311733]  ffff8854c398ecc0 ffff8854c398ecc0 ffff885effd23ab0 ffffffff815b7f42
<4>[196727.311784]  ffff88be6595bc00 ffff8854c398ecc0 0000000000000000 ffff8854c398ecc0
<4>[196727.311834]  ffff885effd23ad0 ffffffff815b86c6 ffff885d5a590800 ffff8816827821c0
<4>[196727.311885] Call Trace:
<4>[196727.311907]  <IRQ>
<4>[196727.311912]  [<ffffffff815b7f42>] dst_destroy+0x32/0xe0
<4>[196727.311959]  [<ffffffff815b86c6>] dst_release+0x56/0x80
<4>[196727.311986]  [<ffffffff81620bd5>] tcp_v4_do_rcv+0x2a5/0x4a0
<4>[196727.312013]  [<ffffffff81622b5a>] tcp_v4_rcv+0x7da/0x820
<4>[196727.312041]  [<ffffffff815fd9e0>] ? ip_rcv_finish+0x360/0x360
<4>[196727.312070]  [<ffffffff815de02d>] ? nf_hook_slow+0x7d/0x150
<4>[196727.312097]  [<ffffffff815fd9e0>] ? ip_rcv_finish+0x360/0x360
<4>[196727.312125]  [<ffffffff815fda92>] ip_local_deliver_finish+0xb2/0x230
<4>[196727.312154]  [<ffffffff815fdd9a>] ip_local_deliver+0x4a/0x90
<4>[196727.312183]  [<ffffffff815fd799>] ip_rcv_finish+0x119/0x360
<4>[196727.312212]  [<ffffffff815fe00b>] ip_rcv+0x22b/0x340
<4>[196727.312242]  [<ffffffffa0339680>] ? macvlan_broadcast+0x160/0x160 [macvlan]
<4>[196727.312275]  [<ffffffff815b0c62>] __netif_receive_skb_core+0x512/0x640
<4>[196727.312308]  [<ffffffff811427fb>] ? kmem_cache_alloc+0x13b/0x150
<4>[196727.312338]  [<ffffffff815b0db1>] __netif_receive_skb+0x21/0x70
<4>[196727.312368]  [<ffffffff815b0fa1>] netif_receive_skb+0x31/0xa0
<4>[196727.312397]  [<ffffffff815b1ae8>] napi_gro_receive+0xe8/0x140
<4>[196727.312433]  [<ffffffffa00274f1>] ixgbe_poll+0x551/0x11f0 [ixgbe]
<4>[196727.312463]  [<ffffffff815fe00b>] ? ip_rcv+0x22b/0x340
<4>[196727.312491]  [<ffffffff815b1691>] net_rx_action+0x111/0x210
<4>[196727.312521]  [<ffffffff815b0db1>] ? __netif_receive_skb+0x21/0x70
<4>[196727.312552]  [<ffffffff810519d0>] __do_softirq+0xd0/0x270
<4>[196727.312583]  [<ffffffff816cef3c>] call_softirq+0x1c/0x30
<4>[196727.312613]  [<ffffffff81004205>] do_softirq+0x55/0x90
<4>[196727.312640]  [<ffffffff81051c85>] irq_exit+0x55/0x60
<4>[196727.312668]  [<ffffffff816cf5c3>] do_IRQ+0x63/0xe0
<4>[196727.312696]  [<ffffffff816c5aaa>] common_interrupt+0x6a/0x6a
<4>[196727.312722]  <EOI>
<1>[196727.313071] RIP  [<ffffffff815f8c7f>] ipv4_dst_destroy+0x4f/0x80
<4>[196727.313100]  RSP <ffff885effd23a70>
<4>[196727.313377] ---[ end trace 64b3f14fae0f2e29 ]---
<0>[196727.380908] Kernel panic - not syncing: Fatal exception in interrupt

Reported-by: Alexey Preobrazhensky <preobr@google.com>
Reported-by: dormando <dormando@rydia.ne>
Signed-off-by: Eric Dumazet <edumazet@google.com>
Fixes: 8141ed9fcedb2 (""ipv4: Add a socket release callback for datagram sockets"")
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",4,net/ipv4/datagram.c,"{""sha"": ""a3095fdefbed98ed4e320ac6c44ea3e18241d1a4"", ""filename"": ""net/ipv4/datagram.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 5, ""changes"": 20, ""blob_url"": ""https://github.com/torvalds/linux/blob/9709674e68646cee5a24e3000b3558d25412203a/net/ipv4/datagram.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9709674e68646cee5a24e3000b3558d25412203a/net/ipv4/datagram.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/datagram.c?ref=9709674e68646cee5a24e3000b3558d25412203a"", ""patch"": ""@@ -86,27 +86,37 @@ int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n }\n EXPORT_SYMBOL(ip4_datagram_connect);\n \n+/* Because UDP xmit path can manipulate sk_dst_cache without holding\n+ * socket lock, we need to use sk_dst_set() here,\n+ * even if we own the socket lock.\n+ */\n void ip4_datagram_release_cb(struct sock *sk)\n {\n \tconst struct inet_sock *inet = inet_sk(sk);\n \tconst struct ip_options_rcu *inet_opt;\n \t__be32 daddr = inet->inet_daddr;\n+\tstruct dst_entry *dst;\n \tstruct flowi4 fl4;\n \tstruct rtable *rt;\n \n-\tif (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))\n-\t\treturn;\n-\n \trcu_read_lock();\n+\n+\tdst = __sk_dst_get(sk);\n+\tif (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {\n+\t\trcu_read_unlock();\n+\t\treturn;\n+\t}\n \tinet_opt = rcu_dereference(inet->inet_opt);\n \tif (inet_opt && inet_opt->opt.srr)\n \t\tdaddr = inet_opt->opt.faddr;\n \trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n \t\t\t\t   inet->inet_saddr, inet->inet_dport,\n \t\t\t\t   inet->inet_sport, sk->sk_protocol,\n \t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n-\tif (!IS_ERR(rt))\n-\t\t__sk_dst_set(sk, &rt->dst);\n+\n+\tdst = !IS_ERR(rt) ? &rt->dst : NULL;\n+\tsk_dst_set(sk, dst);\n+\n \trcu_read_unlock();\n }\n EXPORT_SYMBOL_GPL(ip4_datagram_release_cb);""}"," void ip4_datagram_release_cb(struct sock *sk)
 {
 	const struct inet_sock *inet = inet_sk(sk);
 	const struct ip_options_rcu *inet_opt;
 	__be32 daddr = inet->inet_daddr;
	struct dst_entry *dst;
 	struct flowi4 fl4;
 	struct rtable *rt;
 
 	rcu_read_lock();

	dst = __sk_dst_get(sk);
	if (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {
		rcu_read_unlock();
		return;
	}
 	inet_opt = rcu_dereference(inet->inet_opt);
 	if (inet_opt && inet_opt->opt.srr)
 		daddr = inet_opt->opt.faddr;
 	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
 				   inet->inet_saddr, inet->inet_dport,
 				   inet->inet_sport, sk->sk_protocol,
 				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);

	dst = !IS_ERR(rt) ? &rt->dst : NULL;
	sk_dst_set(sk, dst);

 	rcu_read_unlock();
 }
"," void ip4_datagram_release_cb(struct sock *sk)
 {
 	const struct inet_sock *inet = inet_sk(sk);
 	const struct ip_options_rcu *inet_opt;
 	__be32 daddr = inet->inet_daddr;
 	struct flowi4 fl4;
 	struct rtable *rt;
 
	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
		return;
 	rcu_read_lock();
 	inet_opt = rcu_dereference(inet->inet_opt);
 	if (inet_opt && inet_opt->opt.srr)
 		daddr = inet_opt->opt.faddr;
 	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
 				   inet->inet_saddr, inet->inet_dport,
 				   inet->inet_sport, sk->sk_protocol,
 				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
	if (!IS_ERR(rt))
		__sk_dst_set(sk, &rt->dst);
 	rcu_read_unlock();
 }
",C,"	struct dst_entry *dst;

	dst = __sk_dst_get(sk);
	if (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {
		rcu_read_unlock();
		return;
	}

	dst = !IS_ERR(rt) ? &rt->dst : NULL;
	sk_dst_set(sk, dst);

","	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
		return;
	if (!IS_ERR(rt))
		__sk_dst_set(sk, &rt->dst);
",,"@@ -86,27 +86,37 @@ int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 }
 EXPORT_SYMBOL(ip4_datagram_connect);
 
+/* Because UDP xmit path can manipulate sk_dst_cache without holding
+ * socket lock, we need to use sk_dst_set() here,
+ * even if we own the socket lock.
+ */
 void ip4_datagram_release_cb(struct sock *sk)
 {
 	const struct inet_sock *inet = inet_sk(sk);
 	const struct ip_options_rcu *inet_opt;
 	__be32 daddr = inet->inet_daddr;
+	struct dst_entry *dst;
 	struct flowi4 fl4;
 	struct rtable *rt;
 
-	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
-		return;
-
 	rcu_read_lock();
+
+	dst = __sk_dst_get(sk);
+	if (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {
+		rcu_read_unlock();
+		return;
+	}
 	inet_opt = rcu_dereference(inet->inet_opt);
 	if (inet_opt && inet_opt->opt.srr)
 		daddr = inet_opt->opt.faddr;
 	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
 				   inet->inet_saddr, inet->inet_dport,
 				   inet->inet_sport, sk->sk_protocol,
 				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
-	if (!IS_ERR(rt))
-		__sk_dst_set(sk, &rt->dst);
+
+	dst = !IS_ERR(rt) ? &rt->dst : NULL;
+	sk_dst_set(sk, dst);
+
 	rcu_read_unlock();
 }
 EXPORT_SYMBOL_GPL(ip4_datagram_release_cb);",linux,9709674e68646cee5a24e3000b3558d25412203a,a101ccd141fa777febc510a5c3f3da0c23cd47ce,1," void ip4_datagram_release_cb(struct sock *sk)
 {
 	const struct inet_sock *inet = inet_sk(sk);
 	const struct ip_options_rcu *inet_opt;
 	__be32 daddr = inet->inet_daddr;
//fix_flaw_line_below:
//	struct dst_entry *dst;
 	struct flowi4 fl4;
 	struct rtable *rt;
 
//flaw_line_below:
	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
//flaw_line_below:
		return;
//flaw_line_below:

 	rcu_read_lock();
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	dst = __sk_dst_get(sk);
//fix_flaw_line_below:
//	if (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {
//fix_flaw_line_below:
//		rcu_read_unlock();
//fix_flaw_line_below:
//		return;
//fix_flaw_line_below:
//	}
 	inet_opt = rcu_dereference(inet->inet_opt);
 	if (inet_opt && inet_opt->opt.srr)
 		daddr = inet_opt->opt.faddr;
 	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
 				   inet->inet_saddr, inet->inet_dport,
 				   inet->inet_sport, sk->sk_protocol,
 				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
//flaw_line_below:
	if (!IS_ERR(rt))
//flaw_line_below:
		__sk_dst_set(sk, &rt->dst);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	dst = !IS_ERR(rt) ? &rt->dst : NULL;
//fix_flaw_line_below:
//	sk_dst_set(sk, dst);
//fix_flaw_line_below:
//
 	rcu_read_unlock();
 }
",182069," void ip4_datagram_release_cb(struct sock *sk)
 {
 	const struct inet_sock *inet = inet_sk(sk);
 	const struct ip_options_rcu *inet_opt;
 	__be32 daddr = inet->inet_daddr;
 	struct flowi4 fl4;
 	struct rtable *rt;
 
	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
		return;
 	rcu_read_lock();
 	inet_opt = rcu_dereference(inet->inet_opt);
 	if (inet_opt && inet_opt->opt.srr)
 		daddr = inet_opt->opt.faddr;
 	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
 				   inet->inet_saddr, inet->inet_dport,
 				   inet->inet_sport, sk->sk_protocol,
 				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
	if (!IS_ERR(rt))
		__sk_dst_set(sk, &rt->dst);
 	rcu_read_unlock();
 }
"," void ip4_datagram_release_cb(struct sock *sk)
 {
 	const struct inet_sock *inet = inet_sk(sk);
 	const struct ip_options_rcu *inet_opt;
 	__be32 daddr = inet->inet_daddr;
	struct dst_entry *dst;
 	struct flowi4 fl4;
 	struct rtable *rt;
 
 	rcu_read_lock();

	dst = __sk_dst_get(sk);
	if (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {
		rcu_read_unlock();
		return;
	}
 	inet_opt = rcu_dereference(inet->inet_opt);
 	if (inet_opt && inet_opt->opt.srr)
 		daddr = inet_opt->opt.faddr;
 	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
 				   inet->inet_saddr, inet->inet_dport,
 				   inet->inet_sport, sk->sk_protocol,
 				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);

	dst = !IS_ERR(rt) ? &rt->dst : NULL;
	sk_dst_set(sk, dst);

 	rcu_read_unlock();
 }
","The `ip4_datagram_release_cb` function is designed to manage the release of an IPv4 datagram socket in a network stack. It first checks if the socket has a valid destination and whether it is still active. If valid, it acquires a read lock for safe access to shared data. The function retrieves any IP options associated with the socket, particularly checking for a source routing request. It then prepares a flow structure and attempts to resolve the route to the destination address, updating the socket's destination if successful. Finally, it releases the read lock, ensuring thread safety throughout the process.","The function is responsible for managing the release of an IPv4 datagram socket within a network stack. It first verifies the validity of the socket's destination and its active status. Upon confirming these conditions, it safely accesses shared data while ensuring thread safety. The function checks for any special routing options associated with the socket, particularly focusing on source routing. It then prepares to determine the appropriate route to the destination address and updates the socket's destination if the route resolution is successful. Finally, it concludes by releasing the lock on the shared data.","The vulnerability in the original code stemmed from a race condition where concurrent threads could manipulate the socket's destination cache while another thread was accessing it, leading to potential use-after-free errors. This was particularly problematic in the context of UDP, which allows a lockless transmission path. The fix involved using specific functions to check and set the destination, ensuring that all threads accessing the destination cache held the same lock, thus preventing data corruption. By implementing these changes, the code now safely manages concurrent access, eliminating the risk of accessing invalid memory.","The vulnerability in the original code arose from a race condition where multiple threads could concurrently manipulate the socket's destination cache while another thread was accessing it, leading to potential memory corruption and use-after-free errors. This issue was particularly relevant for UDP, which allows for a lockless transmission path. The fix involved ensuring that all threads accessing the destination cache used a consistent locking mechanism, thereby preventing simultaneous modifications. By implementing this locking strategy, the code now safely manages concurrent access, eliminating the risk of accessing invalid memory and ensuring data integrity.","The vulnerability was fixed by modifying the code to use specific functions that ensure all threads accessing the destination cache hold the same spinlock. Instead of directly calling `__sk_dst_set()`, the updated code first retrieves the destination using `__sk_dst_get()` and checks its validity, including whether it is obsolete or requires validation through `check()`. This ensures that any modifications to the destination cache are synchronized. By using `sk_dst_check()` and `sk_dst_set()`, the code now prevents concurrent threads from corrupting the destination cache, thereby eliminating the race condition and potential memory corruption issues.","The vulnerability was addressed by implementing a synchronization mechanism that ensures all threads accessing the destination cache do so in a controlled manner. The updated code checks the validity of the destination before making any modifications, ensuring that it is not obsolete and that it meets specific conditions. This approach prevents simultaneous access and modifications by multiple threads, thereby eliminating the race condition that could lead to memory corruption. By enforcing consistent locking during these operations, the code now safely manages concurrent access, ensuring data integrity and stability within the network stack.","CWE-362, CWE-366, CWE-367, CWE-412, CWE-567, CWE-667, CWE-833, CWE-820, CWE-488, CWE-609",N,-1
40,40,182096,182096,,Remote,Not required,,CVE-2018-1999013,https://www.cvedetails.com/cve/CVE-2018-1999013/,CWE-416,Medium,Partial,,,2018-07-23,4.3,FFmpeg before commit a7e032a277452366771951e29fd0bf2bd5c029f0 contains a use-after-free vulnerability in the realmedia demuxer that can result in vulnerability allows attacker to read heap memory. This attack appear to be exploitable via specially crafted RM file has to be provided as input. This vulnerability appears to have been fixed in a7e032a277452366771951e29fd0bf2bd5c029f0 and later.,2018-09-20,,1,https://github.com/FFmpeg/FFmpeg/commit/a7e032a277452366771951e29fd0bf2bd5c029f0,a7e032a277452366771951e29fd0bf2bd5c029f0,"avformat/rmdec: Do not pass mime type in rm_read_multi() to ff_rm_read_mdpr_codecdata()

Fixes: use after free()
Fixes: rmdec-crash-ffe85b4cab1597d1cfea6955705e53f1f5c8a362

Found-by: Paul Ch <paulcher@icloud.com>
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",1,libavformat/rmdec.c,"{""sha"": ""0216003e88e46a52c254cb1a6fa4f7099f3a3414"", ""filename"": ""libavformat/rmdec.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/a7e032a277452366771951e29fd0bf2bd5c029f0/libavformat/rmdec.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/a7e032a277452366771951e29fd0bf2bd5c029f0/libavformat/rmdec.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavformat/rmdec.c?ref=a7e032a277452366771951e29fd0bf2bd5c029f0"", ""patch"": ""@@ -522,7 +522,7 @@ static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,\n \n         size2 = avio_rb32(pb);\n         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,\n-                                        size2, mime);\n+                                        size2, NULL);\n         if (ret < 0)\n             return ret;\n     }""}","static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,
                         AVStream *st, char *mime)
{
    int number_of_streams = avio_rb16(pb);
    int number_of_mdpr;
    int i, ret;
    unsigned size2;
    for (i = 0; i<number_of_streams; i++)
        avio_rb16(pb);
    number_of_mdpr = avio_rb16(pb);
    if (number_of_mdpr != 1) {
        avpriv_request_sample(s, ""MLTI with multiple (%d) MDPR"", number_of_mdpr);
    }
    for (i = 0; i < number_of_mdpr; i++) {
        AVStream *st2;
        if (i > 0) {
            st2 = avformat_new_stream(s, NULL);
            if (!st2) {
                ret = AVERROR(ENOMEM);
                return ret;
            }
            st2->id = st->id + (i<<16);
            st2->codecpar->bit_rate = st->codecpar->bit_rate;
            st2->start_time = st->start_time;
            st2->duration   = st->duration;
            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;
            st2->priv_data = ff_rm_alloc_rmstream();
            if (!st2->priv_data)
                return AVERROR(ENOMEM);
        } else
            st2 = st;
 
         size2 = avio_rb32(pb);
         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,
                                        size2, NULL);
         if (ret < 0)
             return ret;
     }
    return 0;
}
","static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,
                         AVStream *st, char *mime)
{
    int number_of_streams = avio_rb16(pb);
    int number_of_mdpr;
    int i, ret;
    unsigned size2;
    for (i = 0; i<number_of_streams; i++)
        avio_rb16(pb);
    number_of_mdpr = avio_rb16(pb);
    if (number_of_mdpr != 1) {
        avpriv_request_sample(s, ""MLTI with multiple (%d) MDPR"", number_of_mdpr);
    }
    for (i = 0; i < number_of_mdpr; i++) {
        AVStream *st2;
        if (i > 0) {
            st2 = avformat_new_stream(s, NULL);
            if (!st2) {
                ret = AVERROR(ENOMEM);
                return ret;
            }
            st2->id = st->id + (i<<16);
            st2->codecpar->bit_rate = st->codecpar->bit_rate;
            st2->start_time = st->start_time;
            st2->duration   = st->duration;
            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;
            st2->priv_data = ff_rm_alloc_rmstream();
            if (!st2->priv_data)
                return AVERROR(ENOMEM);
        } else
            st2 = st;
 
         size2 = avio_rb32(pb);
         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,
                                        size2, mime);
         if (ret < 0)
             return ret;
     }
    return 0;
}
",C,"                                        size2, NULL);
","                                        size2, mime);
",,"@@ -522,7 +522,7 @@ static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,
 
         size2 = avio_rb32(pb);
         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,
-                                        size2, mime);
+                                        size2, NULL);
         if (ret < 0)
             return ret;
     }",FFmpeg,a7e032a277452366771951e29fd0bf2bd5c029f0,2b46ebdbff1d8dec7a3d8ea280a612b91a582869,1,"static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,
                         AVStream *st, char *mime)
{
    int number_of_streams = avio_rb16(pb);
    int number_of_mdpr;
    int i, ret;
    unsigned size2;
    for (i = 0; i<number_of_streams; i++)
        avio_rb16(pb);
    number_of_mdpr = avio_rb16(pb);
    if (number_of_mdpr != 1) {
        avpriv_request_sample(s, ""MLTI with multiple (%d) MDPR"", number_of_mdpr);
    }
    for (i = 0; i < number_of_mdpr; i++) {
        AVStream *st2;
        if (i > 0) {
            st2 = avformat_new_stream(s, NULL);
            if (!st2) {
                ret = AVERROR(ENOMEM);
                return ret;
            }
            st2->id = st->id + (i<<16);
            st2->codecpar->bit_rate = st->codecpar->bit_rate;
            st2->start_time = st->start_time;
            st2->duration   = st->duration;
            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;
            st2->priv_data = ff_rm_alloc_rmstream();
            if (!st2->priv_data)
                return AVERROR(ENOMEM);
        } else
            st2 = st;
 
         size2 = avio_rb32(pb);
         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,
//flaw_line_below:
                                        size2, mime);
//fix_flaw_line_below:
//                                        size2, NULL);
         if (ret < 0)
             return ret;
     }
    return 0;
}
",182096,"static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,
                         AVStream *st, char *mime)
{
    int number_of_streams = avio_rb16(pb);
    int number_of_mdpr;
    int i, ret;
    unsigned size2;
    for (i = 0; i<number_of_streams; i++)
        avio_rb16(pb);
    number_of_mdpr = avio_rb16(pb);
    if (number_of_mdpr != 1) {
        avpriv_request_sample(s, ""MLTI with multiple (%d) MDPR"", number_of_mdpr);
    }
    for (i = 0; i < number_of_mdpr; i++) {
        AVStream *st2;
        if (i > 0) {
            st2 = avformat_new_stream(s, NULL);
            if (!st2) {
                ret = AVERROR(ENOMEM);
                return ret;
            }
            st2->id = st->id + (i<<16);
            st2->codecpar->bit_rate = st->codecpar->bit_rate;
            st2->start_time = st->start_time;
            st2->duration   = st->duration;
            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;
            st2->priv_data = ff_rm_alloc_rmstream();
            if (!st2->priv_data)
                return AVERROR(ENOMEM);
        } else
            st2 = st;
 
         size2 = avio_rb32(pb);
         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,
                                        size2, mime);
         if (ret < 0)
             return ret;
     }
    return 0;
}
","static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,
                         AVStream *st, char *mime)
{
    int number_of_streams = avio_rb16(pb);
    int number_of_mdpr;
    int i, ret;
    unsigned size2;
    for (i = 0; i<number_of_streams; i++)
        avio_rb16(pb);
    number_of_mdpr = avio_rb16(pb);
    if (number_of_mdpr != 1) {
        avpriv_request_sample(s, ""MLTI with multiple (%d) MDPR"", number_of_mdpr);
    }
    for (i = 0; i < number_of_mdpr; i++) {
        AVStream *st2;
        if (i > 0) {
            st2 = avformat_new_stream(s, NULL);
            if (!st2) {
                ret = AVERROR(ENOMEM);
                return ret;
            }
            st2->id = st->id + (i<<16);
            st2->codecpar->bit_rate = st->codecpar->bit_rate;
            st2->start_time = st->start_time;
            st2->duration   = st->duration;
            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;
            st2->priv_data = ff_rm_alloc_rmstream();
            if (!st2->priv_data)
                return AVERROR(ENOMEM);
        } else
            st2 = st;
 
         size2 = avio_rb32(pb);
         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,
                                        size2, NULL);
         if (ret < 0)
             return ret;
     }
    return 0;
}
","The `rm_read_multi` function reads multiple media streams from a given input buffer in a specific format, handling the initialization and allocation of stream data structures. It first retrieves the number of streams and checks for the presence of multiple metadata records (MDPR), issuing a request for samples if more than one is found. For each MDPR, it either reuses the existing stream or creates a new one, copying relevant properties such as bitrate and duration. The function then reads codec data for each stream and populates the stream's private data, returning an error code if any allocation or reading fails, or zero on success.","The function processes multiple media streams from an input buffer, beginning by determining the total number of streams and checking for metadata records. If more than one metadata record is detected, it requests additional samples. For each metadata record, it either utilizes an existing stream or creates a new one, ensuring that essential properties like bitrate and duration are preserved. The function then reads codec data for each stream and allocates necessary resources. It returns an error code if any issues arise during allocation or data reading, or zero to indicate successful completion.","The vulnerability in the original code stemmed from a potential ""use after free"" issue, where the function passed a pointer to a variable that could be invalidated before it was used. Specifically, the `mime` parameter was passed to the `ff_rm_read_mdpr_codecdata` function, which could lead to accessing freed memory if the variable was modified or deallocated elsewhere. The fix involved removing the `mime` parameter from the function call, ensuring that no invalid memory references occur during the reading of codec data. This change mitigated the risk of crashes and undefined behavior associated with accessing freed memory.","The vulnerability in the original code was related to a ""use after free"" issue, where a pointer to a variable could be accessed after it had been deallocated, potentially leading to crashes or undefined behavior. This occurred because a specific parameter was passed to a function that could reference memory that might no longer be valid. The fix involved removing this parameter from the function call, thereby eliminating the risk of accessing freed memory. This change ensured that the code no longer attempted to use potentially invalid references, enhancing stability and preventing crashes associated with memory management errors.","The vulnerability was fixed by removing the `mime` parameter from the call to `ff_rm_read_mdpr_codecdata` within the `rm_read_multi` function. In the original code, passing the `mime` variable could lead to a ""use after free"" scenario if the variable was modified or deallocated before being accessed. By eliminating this parameter, the function no longer risks referencing invalid memory, thus preventing potential crashes. This change directly addressed the memory management issue, ensuring that the code operates safely without accessing freed memory, thereby enhancing overall stability and reliability.","The vulnerability was fixed by removing a specific parameter from a function call that could lead to accessing invalid memory. This change eliminated the risk of a ""use after free"" scenario, where the code might attempt to reference memory that had already been deallocated. By ensuring that the function no longer relied on this potentially invalid reference, the fix enhanced memory safety and stability. This adjustment effectively prevented crashes and undefined behavior associated with improper memory access, thereby improving the overall reliability of the code.","CWE-416, CWE-825, CWE-415, CWE-476, CWE-119, CWE-824, CWE-401, CWE-763, CWE-754, CWE-664",Y,1
41,41,182202,182202,,Remote,Not required,Partial,CVE-2018-16840,https://www.cvedetails.com/cve/CVE-2018-16840/,CWE-416,Low,Partial,Partial,,2018-10-31,7.5,"A heap use-after-free flaw was found in curl versions from 7.59.0 through 7.61.1 in the code related to closing an easy handle. When closing and cleaning up an 'easy' handle in the `Curl_close()` function, the library code first frees a struct (without nulling the pointer) and might then subsequently erroneously write to a struct field within that already freed struct.",2019-10-09,,3,https://github.com/curl/curl/commit/81d135d67155c5295b1033679c606165d4e28f3f,81d135d67155c5295b1033679c606165d4e28f3f,"Curl_close: clear data->multi_easy on free to avoid use-after-free

Regression from b46cfbc068 (7.59.0)
CVE-2018-16840
Reported-by: Brian Carpenter (Geeknik Labs)

Bug: https://curl.haxx.se/docs/CVE-2018-16840.html",1,lib/url.c,"{""sha"": ""0d5a13f99639b2444a8a1b1eeadf9be2fe036fd0"", ""filename"": ""lib/url.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/curl/curl/blob/81d135d67155c5295b1033679c606165d4e28f3f/lib/url.c"", ""raw_url"": ""https://github.com/curl/curl/raw/81d135d67155c5295b1033679c606165d4e28f3f/lib/url.c"", ""contents_url"": ""https://api.github.com/repos/curl/curl/contents/lib/url.c?ref=81d135d67155c5295b1033679c606165d4e28f3f"", ""patch"": ""@@ -331,10 +331,12 @@ CURLcode Curl_close(struct Curl_easy *data)\n        and detach this handle from there. */\n     curl_multi_remove_handle(data->multi, data);\n \n-  if(data->multi_easy)\n+  if(data->multi_easy) {\n     /* when curl_easy_perform() is used, it creates its own multi handle to\n        use and this is the one */\n     curl_multi_cleanup(data->multi_easy);\n+    data->multi_easy = NULL;\n+  }\n \n   /* Destroy the timeout list that is held in the easy handle. It is\n      /normally/ done by curl_multi_remove_handle() but this is \""just in""}","CURLcode Curl_close(struct Curl_easy *data)
{
  struct Curl_multi *m;

  if(!data)
    return CURLE_OK;

  Curl_expire_clear(data); /* shut off timers */

  m = data->multi;
  if(m)
    /* This handle is still part of a multi handle, take care of this first
        and detach this handle from there. */
     curl_multi_remove_handle(data->multi, data);
 
  if(data->multi_easy) {
     /* when curl_easy_perform() is used, it creates its own multi handle to
        use and this is the one */
     curl_multi_cleanup(data->multi_easy);
    data->multi_easy = NULL;
  }
 
   /* Destroy the timeout list that is held in the easy handle. It is
      /normally/ done by curl_multi_remove_handle() but this is ""just in
     case"" */
  Curl_llist_destroy(&data->state.timeoutlist, NULL);

  data->magic = 0; /* force a clear AFTER the possibly enforced removal from
                      the multi handle, since that function uses the magic
                      field! */

  if(data->state.rangestringalloc)
    free(data->state.range);

  /* freed here just in case DONE wasn't called */
  Curl_free_request_state(data);

  /* Close down all open SSL info and sessions */
  Curl_ssl_close_all(data);
  Curl_safefree(data->state.first_host);
  Curl_safefree(data->state.scratch);
  Curl_ssl_free_certinfo(data);

  /* Cleanup possible redirect junk */
  free(data->req.newurl);
  data->req.newurl = NULL;

  if(data->change.referer_alloc) {
    Curl_safefree(data->change.referer);
    data->change.referer_alloc = FALSE;
  }
  data->change.referer = NULL;

  Curl_up_free(data);
  Curl_safefree(data->state.buffer);
  Curl_safefree(data->state.headerbuff);
  Curl_safefree(data->state.ulbuf);
  Curl_flush_cookies(data, 1);
  Curl_digest_cleanup(data);
  Curl_safefree(data->info.contenttype);
  Curl_safefree(data->info.wouldredirect);

  /* this destroys the channel and we cannot use it anymore after this */
  Curl_resolver_cleanup(data->state.resolver);

  Curl_http2_cleanup_dependencies(data);
  Curl_convert_close(data);

  /* No longer a dirty share, if it exists */
  if(data->share) {
    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);
    data->share->dirty--;
    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
  }

  /* destruct wildcard structures if it is needed */
  Curl_wildcard_dtor(&data->wildcard);
  Curl_freeset(data);
  free(data);
  return CURLE_OK;
}
","CURLcode Curl_close(struct Curl_easy *data)
{
  struct Curl_multi *m;

  if(!data)
    return CURLE_OK;

  Curl_expire_clear(data); /* shut off timers */

  m = data->multi;
  if(m)
    /* This handle is still part of a multi handle, take care of this first
        and detach this handle from there. */
     curl_multi_remove_handle(data->multi, data);
 
  if(data->multi_easy)
     /* when curl_easy_perform() is used, it creates its own multi handle to
        use and this is the one */
     curl_multi_cleanup(data->multi_easy);
 
   /* Destroy the timeout list that is held in the easy handle. It is
      /normally/ done by curl_multi_remove_handle() but this is ""just in
     case"" */
  Curl_llist_destroy(&data->state.timeoutlist, NULL);

  data->magic = 0; /* force a clear AFTER the possibly enforced removal from
                      the multi handle, since that function uses the magic
                      field! */

  if(data->state.rangestringalloc)
    free(data->state.range);

  /* freed here just in case DONE wasn't called */
  Curl_free_request_state(data);

  /* Close down all open SSL info and sessions */
  Curl_ssl_close_all(data);
  Curl_safefree(data->state.first_host);
  Curl_safefree(data->state.scratch);
  Curl_ssl_free_certinfo(data);

  /* Cleanup possible redirect junk */
  free(data->req.newurl);
  data->req.newurl = NULL;

  if(data->change.referer_alloc) {
    Curl_safefree(data->change.referer);
    data->change.referer_alloc = FALSE;
  }
  data->change.referer = NULL;

  Curl_up_free(data);
  Curl_safefree(data->state.buffer);
  Curl_safefree(data->state.headerbuff);
  Curl_safefree(data->state.ulbuf);
  Curl_flush_cookies(data, 1);
  Curl_digest_cleanup(data);
  Curl_safefree(data->info.contenttype);
  Curl_safefree(data->info.wouldredirect);

  /* this destroys the channel and we cannot use it anymore after this */
  Curl_resolver_cleanup(data->state.resolver);

  Curl_http2_cleanup_dependencies(data);
  Curl_convert_close(data);

  /* No longer a dirty share, if it exists */
  if(data->share) {
    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);
    data->share->dirty--;
    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
  }

  /* destruct wildcard structures if it is needed */
  Curl_wildcard_dtor(&data->wildcard);
  Curl_freeset(data);
  free(data);
  return CURLE_OK;
}
",C,"  if(data->multi_easy) {
    data->multi_easy = NULL;
  }
","  if(data->multi_easy)
",,"@@ -331,10 +331,12 @@ CURLcode Curl_close(struct Curl_easy *data)
        and detach this handle from there. */
     curl_multi_remove_handle(data->multi, data);
 
-  if(data->multi_easy)
+  if(data->multi_easy) {
     /* when curl_easy_perform() is used, it creates its own multi handle to
        use and this is the one */
     curl_multi_cleanup(data->multi_easy);
+    data->multi_easy = NULL;
+  }
 
   /* Destroy the timeout list that is held in the easy handle. It is
      /normally/ done by curl_multi_remove_handle() but this is ""just in",curl,81d135d67155c5295b1033679c606165d4e28f3f,9d8dad1a9d79d60e021f0c4e0f66bf5d51fb3c4e,1,"CURLcode Curl_close(struct Curl_easy *data)
{
  struct Curl_multi *m;

  if(!data)
    return CURLE_OK;

  Curl_expire_clear(data); /* shut off timers */

  m = data->multi;
  if(m)
    /* This handle is still part of a multi handle, take care of this first
        and detach this handle from there. */
     curl_multi_remove_handle(data->multi, data);
 
//flaw_line_below:
  if(data->multi_easy)
//fix_flaw_line_below:
//  if(data->multi_easy) {
     /* when curl_easy_perform() is used, it creates its own multi handle to
        use and this is the one */
     curl_multi_cleanup(data->multi_easy);
//fix_flaw_line_below:
//    data->multi_easy = NULL;
//fix_flaw_line_below:
//  }
 
   /* Destroy the timeout list that is held in the easy handle. It is
      /normally/ done by curl_multi_remove_handle() but this is ""just in
     case"" */
  Curl_llist_destroy(&data->state.timeoutlist, NULL);

  data->magic = 0; /* force a clear AFTER the possibly enforced removal from
                      the multi handle, since that function uses the magic
                      field! */

  if(data->state.rangestringalloc)
    free(data->state.range);

  /* freed here just in case DONE wasn't called */
  Curl_free_request_state(data);

  /* Close down all open SSL info and sessions */
  Curl_ssl_close_all(data);
  Curl_safefree(data->state.first_host);
  Curl_safefree(data->state.scratch);
  Curl_ssl_free_certinfo(data);

  /* Cleanup possible redirect junk */
  free(data->req.newurl);
  data->req.newurl = NULL;

  if(data->change.referer_alloc) {
    Curl_safefree(data->change.referer);
    data->change.referer_alloc = FALSE;
  }
  data->change.referer = NULL;

  Curl_up_free(data);
  Curl_safefree(data->state.buffer);
  Curl_safefree(data->state.headerbuff);
  Curl_safefree(data->state.ulbuf);
  Curl_flush_cookies(data, 1);
  Curl_digest_cleanup(data);
  Curl_safefree(data->info.contenttype);
  Curl_safefree(data->info.wouldredirect);

  /* this destroys the channel and we cannot use it anymore after this */
  Curl_resolver_cleanup(data->state.resolver);

  Curl_http2_cleanup_dependencies(data);
  Curl_convert_close(data);

  /* No longer a dirty share, if it exists */
  if(data->share) {
    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);
    data->share->dirty--;
    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
  }

  /* destruct wildcard structures if it is needed */
  Curl_wildcard_dtor(&data->wildcard);
  Curl_freeset(data);
  free(data);
  return CURLE_OK;
}
",182202,"CURLcode Curl_close(struct Curl_easy *data)
{
  struct Curl_multi *m;

  if(!data)
    return CURLE_OK;

  Curl_expire_clear(data); /* shut off timers */

  m = data->multi;
  if(m)
    /* This handle is still part of a multi handle, take care of this first
        and detach this handle from there. */
     curl_multi_remove_handle(data->multi, data);
 
  if(data->multi_easy)
     /* when curl_easy_perform() is used, it creates its own multi handle to
        use and this is the one */
     curl_multi_cleanup(data->multi_easy);
 
   /* Destroy the timeout list that is held in the easy handle. It is
      /normally/ done by curl_multi_remove_handle() but this is ""just in
     case"" */
  Curl_llist_destroy(&data->state.timeoutlist, NULL);

  data->magic = 0; /* force a clear AFTER the possibly enforced removal from
                      the multi handle, since that function uses the magic
                      field! */

  if(data->state.rangestringalloc)
    free(data->state.range);

  /* freed here just in case DONE wasn't called */
  Curl_free_request_state(data);

  /* Close down all open SSL info and sessions */
  Curl_ssl_close_all(data);
  Curl_safefree(data->state.first_host);
  Curl_safefree(data->state.scratch);
  Curl_ssl_free_certinfo(data);

  /* Cleanup possible redirect junk */
  free(data->req.newurl);
  data->req.newurl = NULL;

  if(data->change.referer_alloc) {
    Curl_safefree(data->change.referer);
    data->change.referer_alloc = FALSE;
  }
  data->change.referer = NULL;

  Curl_up_free(data);
  Curl_safefree(data->state.buffer);
  Curl_safefree(data->state.headerbuff);
  Curl_safefree(data->state.ulbuf);
  Curl_flush_cookies(data, 1);
  Curl_digest_cleanup(data);
  Curl_safefree(data->info.contenttype);
  Curl_safefree(data->info.wouldredirect);

  /* this destroys the channel and we cannot use it anymore after this */
  Curl_resolver_cleanup(data->state.resolver);

  Curl_http2_cleanup_dependencies(data);
  Curl_convert_close(data);

  /* No longer a dirty share, if it exists */
  if(data->share) {
    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);
    data->share->dirty--;
    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
  }

  /* destruct wildcard structures if it is needed */
  Curl_wildcard_dtor(&data->wildcard);
  Curl_freeset(data);
  free(data);
  return CURLE_OK;
}
","CURLcode Curl_close(struct Curl_easy *data)
{
  struct Curl_multi *m;

  if(!data)
    return CURLE_OK;

  Curl_expire_clear(data); /* shut off timers */

  m = data->multi;
  if(m)
    /* This handle is still part of a multi handle, take care of this first
        and detach this handle from there. */
     curl_multi_remove_handle(data->multi, data);
 
  if(data->multi_easy) {
     /* when curl_easy_perform() is used, it creates its own multi handle to
        use and this is the one */
     curl_multi_cleanup(data->multi_easy);
    data->multi_easy = NULL;
  }
 
   /* Destroy the timeout list that is held in the easy handle. It is
      /normally/ done by curl_multi_remove_handle() but this is ""just in
     case"" */
  Curl_llist_destroy(&data->state.timeoutlist, NULL);

  data->magic = 0; /* force a clear AFTER the possibly enforced removal from
                      the multi handle, since that function uses the magic
                      field! */

  if(data->state.rangestringalloc)
    free(data->state.range);

  /* freed here just in case DONE wasn't called */
  Curl_free_request_state(data);

  /* Close down all open SSL info and sessions */
  Curl_ssl_close_all(data);
  Curl_safefree(data->state.first_host);
  Curl_safefree(data->state.scratch);
  Curl_ssl_free_certinfo(data);

  /* Cleanup possible redirect junk */
  free(data->req.newurl);
  data->req.newurl = NULL;

  if(data->change.referer_alloc) {
    Curl_safefree(data->change.referer);
    data->change.referer_alloc = FALSE;
  }
  data->change.referer = NULL;

  Curl_up_free(data);
  Curl_safefree(data->state.buffer);
  Curl_safefree(data->state.headerbuff);
  Curl_safefree(data->state.ulbuf);
  Curl_flush_cookies(data, 1);
  Curl_digest_cleanup(data);
  Curl_safefree(data->info.contenttype);
  Curl_safefree(data->info.wouldredirect);

  /* this destroys the channel and we cannot use it anymore after this */
  Curl_resolver_cleanup(data->state.resolver);

  Curl_http2_cleanup_dependencies(data);
  Curl_convert_close(data);

  /* No longer a dirty share, if it exists */
  if(data->share) {
    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);
    data->share->dirty--;
    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
  }

  /* destruct wildcard structures if it is needed */
  Curl_wildcard_dtor(&data->wildcard);
  Curl_freeset(data);
  free(data);
  return CURLE_OK;
}
","The `Curl_close` function is responsible for cleaning up and releasing resources associated with a `Curl_easy` handle. It first clears any active timers and detaches the handle from a multi handle if it is still part of one. The function then frees various allocated resources, including SSL sessions, request states, and memory buffers, while ensuring that any potential redirects and cookies are properly cleaned up. Additionally, it handles the cleanup of shared data and wildcard structures, ultimately freeing the `Curl_easy` handle itself. The function returns `CURLE_OK` to indicate successful completion of the cleanup process.","The provided code defines a function that manages the cleanup and resource deallocation for a network connection handle. It begins by ensuring that any active timers are stopped and detaches the handle from any associated multi-handle if necessary. The function then systematically frees various allocated resources, including memory for SSL sessions, request states, and buffers, while also handling potential redirects and cookie cleanup. Additionally, it manages shared data and wildcard structures before finally releasing the handle itself, ensuring that all resources are properly cleaned up to prevent memory leaks. The function concludes by indicating successful completion of the cleanup process.","The vulnerability in the original code stemmed from a potential use-after-free condition related to the `multi_easy` pointer. When the `Curl_close` function was called, it would clean up resources associated with the handle, including the multi handle created during `curl_easy_perform()`, but it did not set `data->multi_easy` to `NULL` after cleanup. This oversight could lead to dereferencing a freed pointer if the handle was accessed afterward. The fix involved adding a line to explicitly set `data->multi_easy` to `NULL` after calling `curl_multi_cleanup(data->multi_easy)`, thereby preventing any further access to the now-invalid memory.","The vulnerability in the original code was a use-after-free issue that occurred when a pointer to a multi handle was not properly cleared after its associated resources were freed. This oversight could lead to dereferencing a pointer that pointed to deallocated memory, potentially causing crashes or allowing for exploitation. The fix involved explicitly setting the pointer to `NULL` after the cleanup process, ensuring that any subsequent access attempts would not reference invalid memory. This change effectively mitigated the risk of accessing freed resources, thereby enhancing the overall stability and security of the code.","The vulnerability was fixed by adding a line to set the `data->multi_easy` pointer to `NULL` immediately after calling `curl_multi_cleanup(data->multi_easy)`. This change ensures that once the multi handle is cleaned up, the pointer no longer points to freed memory, thus preventing any potential use-after-free scenarios. By explicitly nullifying the pointer, the code safeguards against accidental dereferencing of invalid memory in future operations, enhancing the stability and security of the resource management within the `Curl_close` function. This fix addresses the regression introduced in a previous version of the code.","The vulnerability was fixed by ensuring that the pointer associated with the multi handle was explicitly set to null after its resources were cleaned up. This adjustment prevents any future attempts to access the pointer from referencing freed memory, thereby mitigating the risk of a use-after-free condition. By nullifying the pointer immediately following the cleanup process, the code safeguards against accidental dereferencing of invalid memory, enhancing the overall stability and security of the resource management. This change effectively addresses the regression introduced in a prior version of the code.","CWE-416,CWE-825,CWE-415,CWE-476,CWE-763,CWE-404,CWE-672,CWE-908,CWE-681,CWE-119",Y,1
42,42,182265,182265,,Local,Not required,Partial,CVE-2018-15857,https://www.cvedetails.com/cve/CVE-2018-15857/,CWE-416,Low,Partial,Partial,,2018-08-25,4.6,An invalid free in ExprAppendMultiKeysymList in xkbcomp/ast-build.c in xkbcommon before 0.8.1 could be used by local attackers to crash xkbcommon keymap parsers or possibly have unspecified other impact by supplying a crafted keymap file.,2019-08-06,,1,https://github.com/xkbcommon/libxkbcommon/commit/c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb,c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb,"xkbcomp: fix pointer value for FreeStmt

Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>",1,src/xkbcomp/ast-build.c,"{""sha"": ""2de9e61dbd6655ab4e834158f3632d37c0d535e5"", ""filename"": ""src/xkbcomp/ast-build.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/xkbcommon/libxkbcommon/blob/c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb/src/xkbcomp/ast-build.c"", ""raw_url"": ""https://github.com/xkbcommon/libxkbcommon/raw/c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb/src/xkbcomp/ast-build.c"", ""contents_url"": ""https://api.github.com/repos/xkbcommon/libxkbcommon/contents/src/xkbcomp/ast-build.c?ref=c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb"", ""patch"": ""@@ -240,7 +240,7 @@ ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n     darray_append(expr->keysym_list.symsNumEntries, numEntries);\n     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n \n-    FreeStmt((ParseCommon *) &append);\n+    FreeStmt((ParseCommon *) append);\n \n     return expr;\n }""}","ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)
{
    unsigned nSyms = darray_size(expr->keysym_list.syms);
    unsigned numEntries = darray_size(append->keysym_list.syms);

    darray_append(expr->keysym_list.symsMapIndex, nSyms);
     darray_append(expr->keysym_list.symsNumEntries, numEntries);
     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);
 
    FreeStmt((ParseCommon *) append);
 
     return expr;
 }
","ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)
{
    unsigned nSyms = darray_size(expr->keysym_list.syms);
    unsigned numEntries = darray_size(append->keysym_list.syms);

    darray_append(expr->keysym_list.symsMapIndex, nSyms);
     darray_append(expr->keysym_list.symsNumEntries, numEntries);
     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);
 
    FreeStmt((ParseCommon *) &append);
 
     return expr;
 }
",C,"    FreeStmt((ParseCommon *) append);
","    FreeStmt((ParseCommon *) &append);
",,"@@ -240,7 +240,7 @@ ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)
     darray_append(expr->keysym_list.symsNumEntries, numEntries);
     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);
 
-    FreeStmt((ParseCommon *) &append);
+    FreeStmt((ParseCommon *) append);
 
     return expr;
 }",libxkbcommon,c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb,badb428e63387140720f22486b3acbd3d738859f,1,"ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)
{
    unsigned nSyms = darray_size(expr->keysym_list.syms);
    unsigned numEntries = darray_size(append->keysym_list.syms);

    darray_append(expr->keysym_list.symsMapIndex, nSyms);
     darray_append(expr->keysym_list.symsNumEntries, numEntries);
     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);
 
//flaw_line_below:
    FreeStmt((ParseCommon *) &append);
//fix_flaw_line_below:
//    FreeStmt((ParseCommon *) append);
 
     return expr;
 }
",182265,"ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)
{
    unsigned nSyms = darray_size(expr->keysym_list.syms);
    unsigned numEntries = darray_size(append->keysym_list.syms);

    darray_append(expr->keysym_list.symsMapIndex, nSyms);
     darray_append(expr->keysym_list.symsNumEntries, numEntries);
     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);
 
    FreeStmt((ParseCommon *) &append);
 
     return expr;
 }
","ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)
{
    unsigned nSyms = darray_size(expr->keysym_list.syms);
    unsigned numEntries = darray_size(append->keysym_list.syms);

    darray_append(expr->keysym_list.symsMapIndex, nSyms);
     darray_append(expr->keysym_list.symsNumEntries, numEntries);
     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);
 
    FreeStmt((ParseCommon *) append);
 
     return expr;
 }
","The `ExprAppendMultiKeysymList` function is designed to append a list of key symbols from one expression (`append`) to another (`expr`). It first determines the current size of the key symbol list in `expr` and the number of entries in `append`. The function then updates the `symsMapIndex` and `symsNumEntries` arrays in `expr` to reflect the new sizes after the append operation. It concatenates the key symbols from `append` into `expr`'s symbol list and subsequently frees the memory associated with `append`. Finally, it returns the updated `expr`.","The provided function facilitates the merging of two lists of key symbols by appending the contents of one list to another. It first calculates the sizes of both lists to ensure proper indexing and updates related metadata to reflect the new total number of entries. The function then combines the symbols from the second list into the first, effectively expanding the first list with new elements. After completing the merge, it releases the memory allocated for the second list to prevent memory leaks. Finally, the function returns the updated first list, now containing all symbols from both sources.","The vulnerability in the original code stemmed from incorrectly casting the pointer to the `append` variable when calling the `FreeStmt` function, which could lead to undefined behavior or memory corruption. Specifically, the original code casted `append` to a pointer type that may not have been appropriate, potentially causing issues during memory deallocation. In the fixed code, the cast was corrected to ensure that the pointer passed to `FreeStmt` accurately reflects the type of `append`, thereby ensuring safe and proper memory management. This change mitigates the risk of memory-related vulnerabilities associated with improper pointer handling.","The vulnerability in the original code was due to an incorrect pointer cast when deallocating memory, which could lead to undefined behavior or memory corruption. This mismanagement of memory could result in potential crashes or security issues, as the wrong pointer type might not align with the expected structure, causing improper memory access. The fix involved correcting the pointer cast to ensure that the memory deallocation function received the appropriate type, thereby ensuring safe and accurate memory management. This adjustment mitigates the risk of memory-related vulnerabilities and enhances the overall stability of the code.","The vulnerability was fixed by correcting the pointer cast in the call to the `FreeStmt` function. In the original code, the pointer to the `append` variable was cast to an incorrect type, which could lead to improper memory deallocation. The updated code now correctly casts `append` as a pointer to `ParseCommon`, ensuring that the memory management function receives the appropriate type. This change guarantees that the memory associated with `append` is freed correctly, preventing potential memory corruption or undefined behavior, and enhancing the overall safety and reliability of the code.","The vulnerability was addressed by correcting the type used for memory deallocation, ensuring that the pointer passed to the memory management function accurately reflected the structure being freed. This adjustment involved changing the cast to match the expected type, which prevents potential issues related to improper memory access and corruption. By ensuring that the memory management function receives the correct pointer type, the fix enhances the safety and reliability of the code, mitigating risks associated with memory leaks or undefined behavior that could arise from incorrect pointer handling.","CWE-763, CWE-762, CWE-761, CWE-415, CWE-401, CWE-404, CWE-590, CWE-119, CWE-476, CWE-704",N,-1
43,43,182282,182282,,Local,Not required,Complete,CVE-2018-14734,https://www.cvedetails.com/cve/CVE-2018-14734/,CWE-416,Low,Partial,Partial,,2018-07-29,6.1,"drivers/infiniband/core/ucma.c in the Linux kernel through 4.17.11 allows ucma_leave_multicast to access a certain data structure after a cleanup step in ucma_process_join, which allows attackers to cause a denial of service (use-after-free).",2019-04-23,DoS ,4,https://github.com/torvalds/linux/commit/cb2595c1393b4a5211534e6f0a0fbad369e21ad8,cb2595c1393b4a5211534e6f0a0fbad369e21ad8,"infiniband: fix a possible use-after-free bug

ucma_process_join() will free the new allocated ""mc"" struct,
if there is any error after that, especially the copy_to_user().

But in parallel, ucma_leave_multicast() could find this ""mc""
through idr_find() before ucma_process_join() frees it, since it
is already published.

So ""mc"" could be used in ucma_leave_multicast() after it is been
allocated and freed in ucma_process_join(), since we don't refcnt
it.

Fix this by separating ""publish"" from ID allocation, so that we
can get an ID first and publish it later after copy_to_user().

Fixes: c8f6a362bf3e (""RDMA/cma: Add multicast communication support"")
Reported-by: Noam Rathaus <noamr@beyondsecurity.com>
Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>",0,drivers/infiniband/core/ucma.c,"{""sha"": ""ec8fb289621fb7590dd3e3f4000967fa2b6c9aae"", ""filename"": ""drivers/infiniband/core/ucma.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/cb2595c1393b4a5211534e6f0a0fbad369e21ad8/drivers/infiniband/core/ucma.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/cb2595c1393b4a5211534e6f0a0fbad369e21ad8/drivers/infiniband/core/ucma.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/infiniband/core/ucma.c?ref=cb2595c1393b4a5211534e6f0a0fbad369e21ad8"", ""patch"": ""@@ -235,7 +235,7 @@ static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)\n \t\treturn NULL;\n \n \tmutex_lock(&mut);\n-\tmc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);\n+\tmc->id = idr_alloc(&multicast_idr, NULL, 0, 0, GFP_KERNEL);\n \tmutex_unlock(&mut);\n \tif (mc->id < 0)\n \t\tgoto error;\n@@ -1421,6 +1421,10 @@ static ssize_t ucma_process_join(struct ucma_file *file,\n \t\tgoto err3;\n \t}\n \n+\tmutex_lock(&mut);\n+\tidr_replace(&multicast_idr, mc, mc->id);\n+\tmutex_unlock(&mut);\n+\n \tmutex_unlock(&file->mut);\n \tucma_put_ctx(ctx);\n \treturn 0;""}","static ssize_t ucma_process_join(struct ucma_file *file,
				 struct rdma_ucm_join_mcast *cmd,  int out_len)
{
	struct rdma_ucm_create_id_resp resp;
	struct ucma_context *ctx;
	struct ucma_multicast *mc;
	struct sockaddr *addr;
	int ret;
	u8 join_state;

	if (out_len < sizeof(resp))
		return -ENOSPC;

	addr = (struct sockaddr *) &cmd->addr;
	if (cmd->addr_size != rdma_addr_size(addr))
		return -EINVAL;

	if (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)
		join_state = BIT(FULLMEMBER_JOIN);
	else if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)
		join_state = BIT(SENDONLY_FULLMEMBER_JOIN);
	else
		return -EINVAL;

	ctx = ucma_get_ctx_dev(file, cmd->id);
	if (IS_ERR(ctx))
		return PTR_ERR(ctx);

	mutex_lock(&file->mut);
	mc = ucma_alloc_multicast(ctx);
	if (!mc) {
		ret = -ENOMEM;
		goto err1;
	}
	mc->join_state = join_state;
	mc->uid = cmd->uid;
	memcpy(&mc->addr, addr, cmd->addr_size);
	ret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,
				  join_state, mc);
	if (ret)
		goto err2;

	resp.id = mc->id;
	if (copy_to_user(u64_to_user_ptr(cmd->response),
			 &resp, sizeof(resp))) {
		ret = -EFAULT;
 		goto err3;
 	}
 
	mutex_lock(&mut);
	idr_replace(&multicast_idr, mc, mc->id);
	mutex_unlock(&mut);

 	mutex_unlock(&file->mut);
 	ucma_put_ctx(ctx);
 	return 0;

err3:
	rdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);
	ucma_cleanup_mc_events(mc);
err2:
	mutex_lock(&mut);
	idr_remove(&multicast_idr, mc->id);
	mutex_unlock(&mut);
	list_del(&mc->list);
	kfree(mc);
err1:
	mutex_unlock(&file->mut);
	ucma_put_ctx(ctx);
	return ret;
}
","static ssize_t ucma_process_join(struct ucma_file *file,
				 struct rdma_ucm_join_mcast *cmd,  int out_len)
{
	struct rdma_ucm_create_id_resp resp;
	struct ucma_context *ctx;
	struct ucma_multicast *mc;
	struct sockaddr *addr;
	int ret;
	u8 join_state;

	if (out_len < sizeof(resp))
		return -ENOSPC;

	addr = (struct sockaddr *) &cmd->addr;
	if (cmd->addr_size != rdma_addr_size(addr))
		return -EINVAL;

	if (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)
		join_state = BIT(FULLMEMBER_JOIN);
	else if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)
		join_state = BIT(SENDONLY_FULLMEMBER_JOIN);
	else
		return -EINVAL;

	ctx = ucma_get_ctx_dev(file, cmd->id);
	if (IS_ERR(ctx))
		return PTR_ERR(ctx);

	mutex_lock(&file->mut);
	mc = ucma_alloc_multicast(ctx);
	if (!mc) {
		ret = -ENOMEM;
		goto err1;
	}
	mc->join_state = join_state;
	mc->uid = cmd->uid;
	memcpy(&mc->addr, addr, cmd->addr_size);
	ret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,
				  join_state, mc);
	if (ret)
		goto err2;

	resp.id = mc->id;
	if (copy_to_user(u64_to_user_ptr(cmd->response),
			 &resp, sizeof(resp))) {
		ret = -EFAULT;
 		goto err3;
 	}
 
 	mutex_unlock(&file->mut);
 	ucma_put_ctx(ctx);
 	return 0;

err3:
	rdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);
	ucma_cleanup_mc_events(mc);
err2:
	mutex_lock(&mut);
	idr_remove(&multicast_idr, mc->id);
	mutex_unlock(&mut);
	list_del(&mc->list);
	kfree(mc);
err1:
	mutex_unlock(&file->mut);
	ucma_put_ctx(ctx);
	return ret;
}
",C,"	mutex_lock(&mut);
	idr_replace(&multicast_idr, mc, mc->id);
	mutex_unlock(&mut);

",,,"@@ -235,7 +235,7 @@ static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)
 		return NULL;
 
 	mutex_lock(&mut);
-	mc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);
+	mc->id = idr_alloc(&multicast_idr, NULL, 0, 0, GFP_KERNEL);
 	mutex_unlock(&mut);
 	if (mc->id < 0)
 		goto error;
@@ -1421,6 +1421,10 @@ static ssize_t ucma_process_join(struct ucma_file *file,
 		goto err3;
 	}
 
+	mutex_lock(&mut);
+	idr_replace(&multicast_idr, mc, mc->id);
+	mutex_unlock(&mut);
+
 	mutex_unlock(&file->mut);
 	ucma_put_ctx(ctx);
 	return 0;",linux,cb2595c1393b4a5211534e6f0a0fbad369e21ad8,e4b1672ac0a54c7740cbc4ff39dfdc56182236cb,1,"static ssize_t ucma_process_join(struct ucma_file *file,
				 struct rdma_ucm_join_mcast *cmd,  int out_len)
{
	struct rdma_ucm_create_id_resp resp;
	struct ucma_context *ctx;
	struct ucma_multicast *mc;
	struct sockaddr *addr;
	int ret;
	u8 join_state;

	if (out_len < sizeof(resp))
		return -ENOSPC;

	addr = (struct sockaddr *) &cmd->addr;
	if (cmd->addr_size != rdma_addr_size(addr))
		return -EINVAL;

	if (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)
		join_state = BIT(FULLMEMBER_JOIN);
	else if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)
		join_state = BIT(SENDONLY_FULLMEMBER_JOIN);
	else
		return -EINVAL;

	ctx = ucma_get_ctx_dev(file, cmd->id);
	if (IS_ERR(ctx))
		return PTR_ERR(ctx);

	mutex_lock(&file->mut);
	mc = ucma_alloc_multicast(ctx);
	if (!mc) {
		ret = -ENOMEM;
		goto err1;
	}
	mc->join_state = join_state;
	mc->uid = cmd->uid;
	memcpy(&mc->addr, addr, cmd->addr_size);
	ret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,
				  join_state, mc);
	if (ret)
		goto err2;

	resp.id = mc->id;
	if (copy_to_user(u64_to_user_ptr(cmd->response),
			 &resp, sizeof(resp))) {
		ret = -EFAULT;
 		goto err3;
 	}
 
//fix_flaw_line_below:
//	mutex_lock(&mut);
//fix_flaw_line_below:
//	idr_replace(&multicast_idr, mc, mc->id);
//fix_flaw_line_below:
//	mutex_unlock(&mut);
//fix_flaw_line_below:
//
 	mutex_unlock(&file->mut);
 	ucma_put_ctx(ctx);
 	return 0;

err3:
	rdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);
	ucma_cleanup_mc_events(mc);
err2:
	mutex_lock(&mut);
	idr_remove(&multicast_idr, mc->id);
	mutex_unlock(&mut);
	list_del(&mc->list);
	kfree(mc);
err1:
	mutex_unlock(&file->mut);
	ucma_put_ctx(ctx);
	return ret;
}
",182282,"static ssize_t ucma_process_join(struct ucma_file *file,
				 struct rdma_ucm_join_mcast *cmd,  int out_len)
{
	struct rdma_ucm_create_id_resp resp;
	struct ucma_context *ctx;
	struct ucma_multicast *mc;
	struct sockaddr *addr;
	int ret;
	u8 join_state;

	if (out_len < sizeof(resp))
		return -ENOSPC;

	addr = (struct sockaddr *) &cmd->addr;
	if (cmd->addr_size != rdma_addr_size(addr))
		return -EINVAL;

	if (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)
		join_state = BIT(FULLMEMBER_JOIN);
	else if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)
		join_state = BIT(SENDONLY_FULLMEMBER_JOIN);
	else
		return -EINVAL;

	ctx = ucma_get_ctx_dev(file, cmd->id);
	if (IS_ERR(ctx))
		return PTR_ERR(ctx);

	mutex_lock(&file->mut);
	mc = ucma_alloc_multicast(ctx);
	if (!mc) {
		ret = -ENOMEM;
		goto err1;
	}
	mc->join_state = join_state;
	mc->uid = cmd->uid;
	memcpy(&mc->addr, addr, cmd->addr_size);
	ret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,
				  join_state, mc);
	if (ret)
		goto err2;

	resp.id = mc->id;
	if (copy_to_user(u64_to_user_ptr(cmd->response),
			 &resp, sizeof(resp))) {
		ret = -EFAULT;
 		goto err3;
 	}
 
 	mutex_unlock(&file->mut);
 	ucma_put_ctx(ctx);
 	return 0;

err3:
	rdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);
	ucma_cleanup_mc_events(mc);
err2:
	mutex_lock(&mut);
	idr_remove(&multicast_idr, mc->id);
	mutex_unlock(&mut);
	list_del(&mc->list);
	kfree(mc);
err1:
	mutex_unlock(&file->mut);
	ucma_put_ctx(ctx);
	return ret;
}
","static ssize_t ucma_process_join(struct ucma_file *file,
				 struct rdma_ucm_join_mcast *cmd,  int out_len)
{
	struct rdma_ucm_create_id_resp resp;
	struct ucma_context *ctx;
	struct ucma_multicast *mc;
	struct sockaddr *addr;
	int ret;
	u8 join_state;

	if (out_len < sizeof(resp))
		return -ENOSPC;

	addr = (struct sockaddr *) &cmd->addr;
	if (cmd->addr_size != rdma_addr_size(addr))
		return -EINVAL;

	if (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)
		join_state = BIT(FULLMEMBER_JOIN);
	else if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)
		join_state = BIT(SENDONLY_FULLMEMBER_JOIN);
	else
		return -EINVAL;

	ctx = ucma_get_ctx_dev(file, cmd->id);
	if (IS_ERR(ctx))
		return PTR_ERR(ctx);

	mutex_lock(&file->mut);
	mc = ucma_alloc_multicast(ctx);
	if (!mc) {
		ret = -ENOMEM;
		goto err1;
	}
	mc->join_state = join_state;
	mc->uid = cmd->uid;
	memcpy(&mc->addr, addr, cmd->addr_size);
	ret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,
				  join_state, mc);
	if (ret)
		goto err2;

	resp.id = mc->id;
	if (copy_to_user(u64_to_user_ptr(cmd->response),
			 &resp, sizeof(resp))) {
		ret = -EFAULT;
 		goto err3;
 	}
 
	mutex_lock(&mut);
	idr_replace(&multicast_idr, mc, mc->id);
	mutex_unlock(&mut);

 	mutex_unlock(&file->mut);
 	ucma_put_ctx(ctx);
 	return 0;

err3:
	rdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);
	ucma_cleanup_mc_events(mc);
err2:
	mutex_lock(&mut);
	idr_remove(&multicast_idr, mc->id);
	mutex_unlock(&mut);
	list_del(&mc->list);
	kfree(mc);
err1:
	mutex_unlock(&file->mut);
	ucma_put_ctx(ctx);
	return ret;
}
","The `ucma_process_join` function facilitates the joining of a multicast group in a Remote Direct Memory Access (RDMA) context. It first validates the input parameters, including the address size and join flags, ensuring they conform to expected values. Upon successful validation, it retrieves the context associated with the provided ID and allocates a multicast structure. The function then attempts to join the multicast group using the specified address and join state. If successful, it copies the response back to the user. In case of errors, it performs necessary cleanup, including leaving the multicast group and freeing allocated resources, before returning the appropriate error code.","The provided code implements a function that manages the process of joining a multicast group within a specific communication context. It begins by validating input parameters, ensuring they meet required criteria. After confirming the parameters, it retrieves the relevant context and allocates resources for the multicast structure. The function then attempts to join the multicast group using the specified address and state. If successful, it prepares a response to be sent back to the user. In the event of any errors, it performs necessary cleanup operations to release resources and maintain system integrity before returning an error code.","The vulnerability in the original code stemmed from a potential use-after-free issue with the multicast structure, which could be freed after an error, particularly following the `copy_to_user()` function. If an error occurred after the multicast structure was allocated and before it was freed, another function could still reference this structure, leading to undefined behavior. The fix involved separating the allocation of the ID from its publication. By ensuring that the ID is allocated first and only published after confirming that `copy_to_user()` succeeds, the code prevents any chance of accessing a freed structure, thus eliminating the vulnerability.","The vulnerability in the original code was a potential use-after-free issue, where a newly allocated structure could be freed after an error, particularly following a user data copy operation. This created a risk that another function could access the structure while it was already marked for deletion, leading to undefined behavior. The fix addressed this by decoupling the allocation of the structure's identifier from its publication. By ensuring that the identifier is allocated first and only published after confirming the success of the user data copy, the code prevents any possibility of accessing a structure that has been freed, thereby eliminating the vulnerability.","The vulnerability was fixed by separating the publication of the multicast structure from its identifier allocation. In the revised code, the identifier is allocated first using `ucma_alloc_multicast()` and only published to the IDR after the successful execution of `copy_to_user()`. This change ensures that the multicast structure remains valid and is not freed prematurely, preventing any potential use-after-free scenarios. Additionally, the code now properly handles errors by ensuring that the structure is only removed from the IDR and cleaned up if the user data copy fails, thus maintaining the integrity of the multicast structure throughout its lifecycle.","The vulnerability was fixed by restructuring the process of handling the multicast structure to ensure that it is not prematurely freed. The identifier for the structure is now allocated first, and its publication is delayed until after confirming that a critical operation involving user data is successful. This change prevents any chance of accessing a structure that may have been freed due to an error occurring later in the process. By ensuring that the structure remains valid until all necessary operations are completed, the fix effectively eliminates the risk of use-after-free scenarios.","CWE-416, CWE-825, CWE-415, CWE-666, CWE-675, CWE-404, CWE-762, CWE-911, CWE-773, CWE-401",Y,1
44,44,182371,182371,,Remote,Not required,Partial,CVE-2018-12320,https://www.cvedetails.com/cve/CVE-2018-12320/,CWE-416,Medium,Partial,Partial,,2018-06-13,6.8,There is a use after free in radare2 2.6.0 in r_anal_bb_free() in libr/anal/bb.c via a crafted Java binary file.,2018-08-02,,5,https://github.com/radare/radare2/commit/90b71c017a7fa9732fe45fd21b245ee051b1f548,90b71c017a7fa9732fe45fd21b245ee051b1f548,Fix #10293 - Use-after-free in r_anal_bb_free(),1,libr/anal/bb.c,"{""sha"": ""a693c55856df26689b41121ed86457107e37602d"", ""filename"": ""libr/anal/bb.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/radareorg/radare2/blob/90b71c017a7fa9732fe45fd21b245ee051b1f548/libr/anal/bb.c"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/90b71c017a7fa9732fe45fd21b245ee051b1f548/libr/anal/bb.c"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/libr/anal/bb.c?ref=90b71c017a7fa9732fe45fd21b245ee051b1f548"", ""patch"": ""@@ -62,7 +62,11 @@ R_API void r_anal_bb_free(RAnalBlock *bb) {\n \t\tbb->failbb->prev = NULL;\n \t\tbb->failbb = NULL;\n \t}\n-\tR_FREE (bb);\n+\tif (bb->next) {\n+\t\t// avoid double free\n+\t\tbb->next->prev = NULL;\n+\t}\n+\tR_FREE (bb); // double free\n }\n \n R_API RList *r_anal_bb_list_new() {""}","R_API void r_anal_bb_free(RAnalBlock *bb) {
	if (!bb) {
		return;
	}
	r_anal_cond_free (bb->cond);
	R_FREE (bb->fingerprint);
	r_anal_diff_free (bb->diff);
	bb->diff = NULL;
	R_FREE (bb->op_bytes);
	r_anal_switch_op_free (bb->switch_op);
	bb->switch_op = NULL;
	bb->fingerprint = NULL;
	bb->cond = NULL;
	R_FREE (bb->label);
	R_FREE (bb->op_pos);
	R_FREE (bb->parent_reg_arena);
	if (bb->prev) {
		if (bb->prev->jumpbb == bb) {
			bb->prev->jumpbb = NULL;
		}
		if (bb->prev->failbb == bb) {
			bb->prev->failbb = NULL;
		}
		bb->prev = NULL;
	}
	if (bb->jumpbb) {
		bb->jumpbb->prev = NULL;
		bb->jumpbb = NULL;
	}
	if (bb->failbb) {
 		bb->failbb->prev = NULL;
 		bb->failbb = NULL;
 	}
	if (bb->next) {
		// avoid double free
		bb->next->prev = NULL;
	}
	R_FREE (bb); // double free
 }
","R_API void r_anal_bb_free(RAnalBlock *bb) {
	if (!bb) {
		return;
	}
	r_anal_cond_free (bb->cond);
	R_FREE (bb->fingerprint);
	r_anal_diff_free (bb->diff);
	bb->diff = NULL;
	R_FREE (bb->op_bytes);
	r_anal_switch_op_free (bb->switch_op);
	bb->switch_op = NULL;
	bb->fingerprint = NULL;
	bb->cond = NULL;
	R_FREE (bb->label);
	R_FREE (bb->op_pos);
	R_FREE (bb->parent_reg_arena);
	if (bb->prev) {
		if (bb->prev->jumpbb == bb) {
			bb->prev->jumpbb = NULL;
		}
		if (bb->prev->failbb == bb) {
			bb->prev->failbb = NULL;
		}
		bb->prev = NULL;
	}
	if (bb->jumpbb) {
		bb->jumpbb->prev = NULL;
		bb->jumpbb = NULL;
	}
	if (bb->failbb) {
 		bb->failbb->prev = NULL;
 		bb->failbb = NULL;
 	}
	R_FREE (bb);
 }
",C,"	if (bb->next) {
		// avoid double free
		bb->next->prev = NULL;
	}
	R_FREE (bb); // double free
","	R_FREE (bb);
",,"@@ -62,7 +62,11 @@ R_API void r_anal_bb_free(RAnalBlock *bb) {
 		bb->failbb->prev = NULL;
 		bb->failbb = NULL;
 	}
-	R_FREE (bb);
+	if (bb->next) {
+		// avoid double free
+		bb->next->prev = NULL;
+	}
+	R_FREE (bb); // double free
 }
 
 R_API RList *r_anal_bb_list_new() {",radare2,90b71c017a7fa9732fe45fd21b245ee051b1f548,224e6bc13fa353dd3b7f7a2334588f1c4229e58d,1,"R_API void r_anal_bb_free(RAnalBlock *bb) {
	if (!bb) {
		return;
	}
	r_anal_cond_free (bb->cond);
	R_FREE (bb->fingerprint);
	r_anal_diff_free (bb->diff);
	bb->diff = NULL;
	R_FREE (bb->op_bytes);
	r_anal_switch_op_free (bb->switch_op);
	bb->switch_op = NULL;
	bb->fingerprint = NULL;
	bb->cond = NULL;
	R_FREE (bb->label);
	R_FREE (bb->op_pos);
	R_FREE (bb->parent_reg_arena);
	if (bb->prev) {
		if (bb->prev->jumpbb == bb) {
			bb->prev->jumpbb = NULL;
		}
		if (bb->prev->failbb == bb) {
			bb->prev->failbb = NULL;
		}
		bb->prev = NULL;
	}
	if (bb->jumpbb) {
		bb->jumpbb->prev = NULL;
		bb->jumpbb = NULL;
	}
	if (bb->failbb) {
 		bb->failbb->prev = NULL;
 		bb->failbb = NULL;
 	}
//flaw_line_below:
	R_FREE (bb);
//fix_flaw_line_below:
//	if (bb->next) {
//fix_flaw_line_below:
//		// avoid double free
//fix_flaw_line_below:
//		bb->next->prev = NULL;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//	R_FREE (bb); // double free
 }
",182371,"R_API void r_anal_bb_free(RAnalBlock *bb) {
	if (!bb) {
		return;
	}
	r_anal_cond_free (bb->cond);
	R_FREE (bb->fingerprint);
	r_anal_diff_free (bb->diff);
	bb->diff = NULL;
	R_FREE (bb->op_bytes);
	r_anal_switch_op_free (bb->switch_op);
	bb->switch_op = NULL;
	bb->fingerprint = NULL;
	bb->cond = NULL;
	R_FREE (bb->label);
	R_FREE (bb->op_pos);
	R_FREE (bb->parent_reg_arena);
	if (bb->prev) {
		if (bb->prev->jumpbb == bb) {
			bb->prev->jumpbb = NULL;
		}
		if (bb->prev->failbb == bb) {
			bb->prev->failbb = NULL;
		}
		bb->prev = NULL;
	}
	if (bb->jumpbb) {
		bb->jumpbb->prev = NULL;
		bb->jumpbb = NULL;
	}
	if (bb->failbb) {
 		bb->failbb->prev = NULL;
 		bb->failbb = NULL;
 	}
	R_FREE (bb);
 }
","R_API void r_anal_bb_free(RAnalBlock *bb) {
	if (!bb) {
		return;
	}
	r_anal_cond_free (bb->cond);
	R_FREE (bb->fingerprint);
	r_anal_diff_free (bb->diff);
	bb->diff = NULL;
	R_FREE (bb->op_bytes);
	r_anal_switch_op_free (bb->switch_op);
	bb->switch_op = NULL;
	bb->fingerprint = NULL;
	bb->cond = NULL;
	R_FREE (bb->label);
	R_FREE (bb->op_pos);
	R_FREE (bb->parent_reg_arena);
	if (bb->prev) {
		if (bb->prev->jumpbb == bb) {
			bb->prev->jumpbb = NULL;
		}
		if (bb->prev->failbb == bb) {
			bb->prev->failbb = NULL;
		}
		bb->prev = NULL;
	}
	if (bb->jumpbb) {
		bb->jumpbb->prev = NULL;
		bb->jumpbb = NULL;
	}
	if (bb->failbb) {
 		bb->failbb->prev = NULL;
 		bb->failbb = NULL;
 	}
	if (bb->next) {
		// avoid double free
		bb->next->prev = NULL;
	}
	R_FREE (bb); // double free
 }
","The provided code defines a function `r_anal_bb_free` that is responsible for deallocating memory associated with a `RAnalBlock` structure, which represents a block of code in an analysis context. The function first checks if the block pointer is null, returning early if it is. It then systematically frees various components of the block, including conditional structures, fingerprints, operation bytes, and parent references, ensuring to nullify pointers to prevent dangling references. Additionally, it updates the previous and next block pointers to maintain the integrity of the linked structure before finally freeing the block itself, thus preventing memory leaks.","The code defines a function that manages the cleanup of a data structure representing a block of code in an analysis framework. It begins by checking if the block is null, and if not, it proceeds to free various associated resources, such as conditions, fingerprints, and operation data. The function also ensures that any references to previous or next blocks are properly updated to maintain the integrity of the linked structure. Finally, it releases the memory allocated for the block itself, effectively preventing memory leaks and ensuring that all related resources are appropriately deallocated.","The vulnerability in the original code arises from a potential double free scenario, where the function could inadvertently free the same memory multiple times, particularly when handling the `prev`, `jumpbb`, and `failbb` pointers. This could lead to undefined behavior or crashes. The fix addresses this by adding a check for the `next` pointer, ensuring that if it exists, the `prev` pointer of the next block is set to null before freeing the current block. This prevents any references to the freed block from being accessed again, effectively eliminating the use-after-free vulnerability.","The vulnerability in the original code stems from a use-after-free issue, where memory could be accessed after it had already been deallocated, potentially leading to crashes or security exploits. This occurred due to improper handling of pointers that referenced the freed memory, particularly when managing relationships between blocks. The fix addresses this by ensuring that any pointers referencing the current block are properly nullified before the block is freed. This prevents any subsequent access to the deallocated memory, thereby eliminating the risk of use-after-free vulnerabilities and ensuring safer memory management.","The vulnerability was fixed by adding a check for the `next` pointer in the cleanup process. Specifically, before freeing the current block, the code now ensures that if the `next` pointer exists, its `prev` pointer is set to null. This prevents any potential references to the freed block from being accessed again, thereby mitigating the use-after-free issue. Additionally, the code maintains the integrity of the linked structure by nullifying the `prev`, `jumpbb`, and `failbb` pointers of the current block before it is freed, ensuring that all relationships are properly managed and no dangling references remain.","The vulnerability was fixed by implementing additional checks to ensure that any pointers referencing the block being deallocated are properly managed before the memory is freed. Specifically, the code now nullifies references in related structures to prevent any access to the freed memory. This adjustment ensures that no dangling pointers remain, which could lead to accessing invalid memory. By carefully updating the relationships between the blocks and ensuring that all relevant pointers are cleared, the fix effectively eliminates the risk of use-after-free issues, enhancing the overall safety and stability of the memory management process.","CWE-416, CWE-415, CWE-476, CWE-825, CWE-119, CWE-763, CWE-401, CWE-456, CWE-672, CWE-404",Y,1
45,45,182420,182420,,Local,Not required,Complete,CVE-2018-10675,https://www.cvedetails.com/cve/CVE-2018-10675/,CWE-416,Low,Complete,Complete,,2018-05-02,7.2,The do_get_mempolicy function in mm/mempolicy.c in the Linux kernel before 4.12.9 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted system calls.,2019-04-16,DoS ,0,https://github.com/torvalds/linux/commit/73223e4e2e3867ebf033a5a8eb2e5df0158ccc99,73223e4e2e3867ebf033a5a8eb2e5df0158ccc99,"mm/mempolicy: fix use after free when calling get_mempolicy

I hit a use after free issue when executing trinity and repoduced it
with KASAN enabled.  The related call trace is as follows.

  BUG: KASan: use after free in SyS_get_mempolicy+0x3c8/0x960 at addr ffff8801f582d766
  Read of size 2 by task syz-executor1/798

  INFO: Allocated in mpol_new.part.2+0x74/0x160 age=3 cpu=1 pid=799
     __slab_alloc+0x768/0x970
     kmem_cache_alloc+0x2e7/0x450
     mpol_new.part.2+0x74/0x160
     mpol_new+0x66/0x80
     SyS_mbind+0x267/0x9f0
     system_call_fastpath+0x16/0x1b
  INFO: Freed in __mpol_put+0x2b/0x40 age=4 cpu=1 pid=799
     __slab_free+0x495/0x8e0
     kmem_cache_free+0x2f3/0x4c0
     __mpol_put+0x2b/0x40
     SyS_mbind+0x383/0x9f0
     system_call_fastpath+0x16/0x1b
  INFO: Slab 0xffffea0009cb8dc0 objects=23 used=8 fp=0xffff8801f582de40 flags=0x200000000004080
  INFO: Object 0xffff8801f582d760 @offset=5984 fp=0xffff8801f582d600

  Bytes b4 ffff8801f582d750: ae 01 ff ff 00 00 00 00 5a 5a 5a 5a 5a 5a 5a 5a  ........ZZZZZZZZ
  Object ffff8801f582d760: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
  Object ffff8801f582d770: 6b 6b 6b 6b 6b 6b 6b a5                          kkkkkkk.
  Redzone ffff8801f582d778: bb bb bb bb bb bb bb bb                          ........
  Padding ffff8801f582d8b8: 5a 5a 5a 5a 5a 5a 5a 5a                          ZZZZZZZZ
  Memory state around the buggy address:
  ffff8801f582d600: fb fb fb fc fc fc fc fc fc fc fc fc fc fc fc fc
  ffff8801f582d680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
  >ffff8801f582d700: fc fc fc fc fc fc fc fc fc fc fc fc fb fb fb fc

!shared memory policy is not protected against parallel removal by other
thread which is normally protected by the mmap_sem.  do_get_mempolicy,
however, drops the lock midway while we can still access it later.

Early premature up_read is a historical artifact from times when
put_user was called in this path see https://lwn.net/Articles/124754/
but that is gone since 8bccd85ffbaf (""[PATCH] Implement sys_* do_*
layering in the memory policy layer."").  but when we have the the
current mempolicy ref count model.  The issue was introduced
accordingly.

Fix the issue by removing the premature release.

Link: http://lkml.kernel.org/r/1502950924-27521-1-git-send-email-zhongjiang@huawei.com
Signed-off-by: zhong jiang <zhongjiang@huawei.com>
Acked-by: Michal Hocko <mhocko@suse.com>
Cc: Minchan Kim <minchan@kernel.org>
Cc: Vlastimil Babka <vbabka@suse.cz>
Cc: David Rientjes <rientjes@google.com>
Cc: Mel Gorman <mgorman@techsingularity.net>
Cc: <stable@vger.kernel.org>	[2.6+]
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",4,mm/mempolicy.c,"{""sha"": ""618ab125228baec0810146a0638ce80ce4d50284"", ""filename"": ""mm/mempolicy.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/73223e4e2e3867ebf033a5a8eb2e5df0158ccc99/mm/mempolicy.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/73223e4e2e3867ebf033a5a8eb2e5df0158ccc99/mm/mempolicy.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/mempolicy.c?ref=73223e4e2e3867ebf033a5a8eb2e5df0158ccc99"", ""patch"": ""@@ -861,11 +861,6 @@ static long do_get_mempolicy(int *policy, nodemask_t *nmask,\n \t\t*policy |= (pol->flags & MPOL_MODE_FLAGS);\n \t}\n \n-\tif (vma) {\n-\t\tup_read(&current->mm->mmap_sem);\n-\t\tvma = NULL;\n-\t}\n-\n \terr = 0;\n \tif (nmask) {\n \t\tif (mpol_store_user_nodemask(pol)) {""}","static long do_get_mempolicy(int *policy, nodemask_t *nmask,
			     unsigned long addr, unsigned long flags)
{
	int err;
	struct mm_struct *mm = current->mm;
	struct vm_area_struct *vma = NULL;
	struct mempolicy *pol = current->mempolicy;

	if (flags &
		~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))
		return -EINVAL;

	if (flags & MPOL_F_MEMS_ALLOWED) {
		if (flags & (MPOL_F_NODE|MPOL_F_ADDR))
			return -EINVAL;
		*policy = 0;	/* just so it's initialized */
		task_lock(current);
		*nmask  = cpuset_current_mems_allowed;
		task_unlock(current);
		return 0;
	}

	if (flags & MPOL_F_ADDR) {
		/*
		 * Do NOT fall back to task policy if the
		 * vma/shared policy at addr is NULL.  We
		 * want to return MPOL_DEFAULT in this case.
		 */
		down_read(&mm->mmap_sem);
		vma = find_vma_intersection(mm, addr, addr+1);
		if (!vma) {
			up_read(&mm->mmap_sem);
			return -EFAULT;
		}
		if (vma->vm_ops && vma->vm_ops->get_policy)
			pol = vma->vm_ops->get_policy(vma, addr);
		else
			pol = vma->vm_policy;
	} else if (addr)
		return -EINVAL;

	if (!pol)
		pol = &default_policy;	/* indicates default behavior */

	if (flags & MPOL_F_NODE) {
		if (flags & MPOL_F_ADDR) {
			err = lookup_node(addr);
			if (err < 0)
				goto out;
			*policy = err;
		} else if (pol == current->mempolicy &&
				pol->mode == MPOL_INTERLEAVE) {
			*policy = next_node_in(current->il_prev, pol->v.nodes);
		} else {
			err = -EINVAL;
			goto out;
		}
	} else {
		*policy = pol == &default_policy ? MPOL_DEFAULT :
						pol->mode;
		/*
		 * Internal mempolicy flags must be masked off before exposing
		 * the policy to userspace.
		 */
 		*policy |= (pol->flags & MPOL_MODE_FLAGS);
 	}
 
 	err = 0;
 	if (nmask) {
 		if (mpol_store_user_nodemask(pol)) {
			*nmask = pol->w.user_nodemask;
		} else {
			task_lock(current);
			get_policy_nodemask(pol, nmask);
			task_unlock(current);
		}
	}

 out:
	mpol_cond_put(pol);
	if (vma)
		up_read(&current->mm->mmap_sem);
	return err;
}
","static long do_get_mempolicy(int *policy, nodemask_t *nmask,
			     unsigned long addr, unsigned long flags)
{
	int err;
	struct mm_struct *mm = current->mm;
	struct vm_area_struct *vma = NULL;
	struct mempolicy *pol = current->mempolicy;

	if (flags &
		~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))
		return -EINVAL;

	if (flags & MPOL_F_MEMS_ALLOWED) {
		if (flags & (MPOL_F_NODE|MPOL_F_ADDR))
			return -EINVAL;
		*policy = 0;	/* just so it's initialized */
		task_lock(current);
		*nmask  = cpuset_current_mems_allowed;
		task_unlock(current);
		return 0;
	}

	if (flags & MPOL_F_ADDR) {
		/*
		 * Do NOT fall back to task policy if the
		 * vma/shared policy at addr is NULL.  We
		 * want to return MPOL_DEFAULT in this case.
		 */
		down_read(&mm->mmap_sem);
		vma = find_vma_intersection(mm, addr, addr+1);
		if (!vma) {
			up_read(&mm->mmap_sem);
			return -EFAULT;
		}
		if (vma->vm_ops && vma->vm_ops->get_policy)
			pol = vma->vm_ops->get_policy(vma, addr);
		else
			pol = vma->vm_policy;
	} else if (addr)
		return -EINVAL;

	if (!pol)
		pol = &default_policy;	/* indicates default behavior */

	if (flags & MPOL_F_NODE) {
		if (flags & MPOL_F_ADDR) {
			err = lookup_node(addr);
			if (err < 0)
				goto out;
			*policy = err;
		} else if (pol == current->mempolicy &&
				pol->mode == MPOL_INTERLEAVE) {
			*policy = next_node_in(current->il_prev, pol->v.nodes);
		} else {
			err = -EINVAL;
			goto out;
		}
	} else {
		*policy = pol == &default_policy ? MPOL_DEFAULT :
						pol->mode;
		/*
		 * Internal mempolicy flags must be masked off before exposing
		 * the policy to userspace.
		 */
 		*policy |= (pol->flags & MPOL_MODE_FLAGS);
 	}
 
	if (vma) {
		up_read(&current->mm->mmap_sem);
		vma = NULL;
	}
 	err = 0;
 	if (nmask) {
 		if (mpol_store_user_nodemask(pol)) {
			*nmask = pol->w.user_nodemask;
		} else {
			task_lock(current);
			get_policy_nodemask(pol, nmask);
			task_unlock(current);
		}
	}

 out:
	mpol_cond_put(pol);
	if (vma)
		up_read(&current->mm->mmap_sem);
	return err;
}
",C,,"	if (vma) {
		up_read(&current->mm->mmap_sem);
		vma = NULL;
	}
",,"@@ -861,11 +861,6 @@ static long do_get_mempolicy(int *policy, nodemask_t *nmask,
 		*policy |= (pol->flags & MPOL_MODE_FLAGS);
 	}
 
-	if (vma) {
-		up_read(&current->mm->mmap_sem);
-		vma = NULL;
-	}
-
 	err = 0;
 	if (nmask) {
 		if (mpol_store_user_nodemask(pol)) {",linux,73223e4e2e3867ebf033a5a8eb2e5df0158ccc99,da094e42848e3c36feaa3b5271e53983fd45424f,1,"static long do_get_mempolicy(int *policy, nodemask_t *nmask,
			     unsigned long addr, unsigned long flags)
{
	int err;
	struct mm_struct *mm = current->mm;
	struct vm_area_struct *vma = NULL;
	struct mempolicy *pol = current->mempolicy;

	if (flags &
		~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))
		return -EINVAL;

	if (flags & MPOL_F_MEMS_ALLOWED) {
		if (flags & (MPOL_F_NODE|MPOL_F_ADDR))
			return -EINVAL;
		*policy = 0;	/* just so it's initialized */
		task_lock(current);
		*nmask  = cpuset_current_mems_allowed;
		task_unlock(current);
		return 0;
	}

	if (flags & MPOL_F_ADDR) {
		/*
		 * Do NOT fall back to task policy if the
		 * vma/shared policy at addr is NULL.  We
		 * want to return MPOL_DEFAULT in this case.
		 */
		down_read(&mm->mmap_sem);
		vma = find_vma_intersection(mm, addr, addr+1);
		if (!vma) {
			up_read(&mm->mmap_sem);
			return -EFAULT;
		}
		if (vma->vm_ops && vma->vm_ops->get_policy)
			pol = vma->vm_ops->get_policy(vma, addr);
		else
			pol = vma->vm_policy;
	} else if (addr)
		return -EINVAL;

	if (!pol)
		pol = &default_policy;	/* indicates default behavior */

	if (flags & MPOL_F_NODE) {
		if (flags & MPOL_F_ADDR) {
			err = lookup_node(addr);
			if (err < 0)
				goto out;
			*policy = err;
		} else if (pol == current->mempolicy &&
				pol->mode == MPOL_INTERLEAVE) {
			*policy = next_node_in(current->il_prev, pol->v.nodes);
		} else {
			err = -EINVAL;
			goto out;
		}
	} else {
		*policy = pol == &default_policy ? MPOL_DEFAULT :
						pol->mode;
		/*
		 * Internal mempolicy flags must be masked off before exposing
		 * the policy to userspace.
		 */
 		*policy |= (pol->flags & MPOL_MODE_FLAGS);
 	}
 
//flaw_line_below:
	if (vma) {
//flaw_line_below:
		up_read(&current->mm->mmap_sem);
//flaw_line_below:
		vma = NULL;
//flaw_line_below:
	}
//flaw_line_below:

 	err = 0;
 	if (nmask) {
 		if (mpol_store_user_nodemask(pol)) {
			*nmask = pol->w.user_nodemask;
		} else {
			task_lock(current);
			get_policy_nodemask(pol, nmask);
			task_unlock(current);
		}
	}

 out:
	mpol_cond_put(pol);
	if (vma)
		up_read(&current->mm->mmap_sem);
	return err;
}
",182420,"static long do_get_mempolicy(int *policy, nodemask_t *nmask,
			     unsigned long addr, unsigned long flags)
{
	int err;
	struct mm_struct *mm = current->mm;
	struct vm_area_struct *vma = NULL;
	struct mempolicy *pol = current->mempolicy;

	if (flags &
		~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))
		return -EINVAL;

	if (flags & MPOL_F_MEMS_ALLOWED) {
		if (flags & (MPOL_F_NODE|MPOL_F_ADDR))
			return -EINVAL;
		*policy = 0;	/* just so it's initialized */
		task_lock(current);
		*nmask  = cpuset_current_mems_allowed;
		task_unlock(current);
		return 0;
	}

	if (flags & MPOL_F_ADDR) {
		/*
		 * Do NOT fall back to task policy if the
		 * vma/shared policy at addr is NULL.  We
		 * want to return MPOL_DEFAULT in this case.
		 */
		down_read(&mm->mmap_sem);
		vma = find_vma_intersection(mm, addr, addr+1);
		if (!vma) {
			up_read(&mm->mmap_sem);
			return -EFAULT;
		}
		if (vma->vm_ops && vma->vm_ops->get_policy)
			pol = vma->vm_ops->get_policy(vma, addr);
		else
			pol = vma->vm_policy;
	} else if (addr)
		return -EINVAL;

	if (!pol)
		pol = &default_policy;	/* indicates default behavior */

	if (flags & MPOL_F_NODE) {
		if (flags & MPOL_F_ADDR) {
			err = lookup_node(addr);
			if (err < 0)
				goto out;
			*policy = err;
		} else if (pol == current->mempolicy &&
				pol->mode == MPOL_INTERLEAVE) {
			*policy = next_node_in(current->il_prev, pol->v.nodes);
		} else {
			err = -EINVAL;
			goto out;
		}
	} else {
		*policy = pol == &default_policy ? MPOL_DEFAULT :
						pol->mode;
		/*
		 * Internal mempolicy flags must be masked off before exposing
		 * the policy to userspace.
		 */
 		*policy |= (pol->flags & MPOL_MODE_FLAGS);
 	}
 
	if (vma) {
		up_read(&current->mm->mmap_sem);
		vma = NULL;
	}
 	err = 0;
 	if (nmask) {
 		if (mpol_store_user_nodemask(pol)) {
			*nmask = pol->w.user_nodemask;
		} else {
			task_lock(current);
			get_policy_nodemask(pol, nmask);
			task_unlock(current);
		}
	}

 out:
	mpol_cond_put(pol);
	if (vma)
		up_read(&current->mm->mmap_sem);
	return err;
}
","static long do_get_mempolicy(int *policy, nodemask_t *nmask,
			     unsigned long addr, unsigned long flags)
{
	int err;
	struct mm_struct *mm = current->mm;
	struct vm_area_struct *vma = NULL;
	struct mempolicy *pol = current->mempolicy;

	if (flags &
		~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))
		return -EINVAL;

	if (flags & MPOL_F_MEMS_ALLOWED) {
		if (flags & (MPOL_F_NODE|MPOL_F_ADDR))
			return -EINVAL;
		*policy = 0;	/* just so it's initialized */
		task_lock(current);
		*nmask  = cpuset_current_mems_allowed;
		task_unlock(current);
		return 0;
	}

	if (flags & MPOL_F_ADDR) {
		/*
		 * Do NOT fall back to task policy if the
		 * vma/shared policy at addr is NULL.  We
		 * want to return MPOL_DEFAULT in this case.
		 */
		down_read(&mm->mmap_sem);
		vma = find_vma_intersection(mm, addr, addr+1);
		if (!vma) {
			up_read(&mm->mmap_sem);
			return -EFAULT;
		}
		if (vma->vm_ops && vma->vm_ops->get_policy)
			pol = vma->vm_ops->get_policy(vma, addr);
		else
			pol = vma->vm_policy;
	} else if (addr)
		return -EINVAL;

	if (!pol)
		pol = &default_policy;	/* indicates default behavior */

	if (flags & MPOL_F_NODE) {
		if (flags & MPOL_F_ADDR) {
			err = lookup_node(addr);
			if (err < 0)
				goto out;
			*policy = err;
		} else if (pol == current->mempolicy &&
				pol->mode == MPOL_INTERLEAVE) {
			*policy = next_node_in(current->il_prev, pol->v.nodes);
		} else {
			err = -EINVAL;
			goto out;
		}
	} else {
		*policy = pol == &default_policy ? MPOL_DEFAULT :
						pol->mode;
		/*
		 * Internal mempolicy flags must be masked off before exposing
		 * the policy to userspace.
		 */
 		*policy |= (pol->flags & MPOL_MODE_FLAGS);
 	}
 
 	err = 0;
 	if (nmask) {
 		if (mpol_store_user_nodemask(pol)) {
			*nmask = pol->w.user_nodemask;
		} else {
			task_lock(current);
			get_policy_nodemask(pol, nmask);
			task_unlock(current);
		}
	}

 out:
	mpol_cond_put(pol);
	if (vma)
		up_read(&current->mm->mmap_sem);
	return err;
}
","The `do_get_mempolicy` function retrieves the memory policy associated with the current process or a specific memory address, depending on the provided flags. It checks for valid flag combinations and initializes the policy and nodemask accordingly. If the `MPOL_F_ADDR` flag is set, it locates the virtual memory area (VMA) corresponding to the address and retrieves its policy; otherwise, it defaults to the current task's memory policy. The function also handles cases for node-specific policies and ensures proper synchronization when accessing shared resources. Finally, it populates the output parameters and returns any errors encountered during execution.","The provided code defines a function that retrieves the memory allocation policy for the current process or a specified memory address based on certain flags. It validates the flags to ensure they are appropriate and initializes the policy and nodemask as needed. If an address is specified, the function locates the corresponding memory area and retrieves its policy; otherwise, it defaults to the current process's policy. The function also manages synchronization to prevent concurrent access issues and populates the output parameters with the relevant policy information, returning any errors encountered during the process.","The vulnerability in the original code stemmed from a use-after-free issue, where the memory policy could be accessed after it had been freed due to premature release of a lock. Specifically, the function dropped the lock on the memory map before it was done using the memory policy, allowing other threads to modify or free it, leading to potential crashes or data corruption. The fix involved removing this premature release of the lock, ensuring that the memory policy remains valid for the entire duration of its use within the function, thus preventing any access to freed memory.","The vulnerability in the original code was a use-after-free issue, where a memory policy could be accessed after it had been freed due to an early release of a lock. This premature release allowed other threads to modify or free the memory policy while it was still being accessed, leading to potential crashes or data corruption. The fix involved removing this early release of the lock, ensuring that the memory policy remains valid for the entire duration of its use within the function, thus preventing any access to freed memory and ensuring proper synchronization during concurrent operations.","The vulnerability was fixed by removing the premature call to `up_read` on the memory map's semaphore, which was previously executed before the function completed its operations on the memory policy. By ensuring that the lock remains held until all accesses to the memory policy are finished, the code prevents other threads from modifying or freeing the policy while it is still in use. This change ensures that the reference count of the memory policy is properly managed, thus eliminating the risk of accessing freed memory and ensuring safe concurrent access to shared resources.","The vulnerability was fixed by eliminating the early release of the lock that protected access to the memory policy. By ensuring that the lock remains held for the entire duration of the function's operations, the code prevents other threads from modifying or freeing the memory policy while it is still being accessed. This change guarantees that the memory policy remains valid throughout its use, thereby avoiding any potential access to freed memory. The fix enhances synchronization and ensures safe concurrent access to shared resources, ultimately preventing the use-after-free issue from occurring.","CWE-666,CWE-667,CWE-822,CWE-364,CWE-362,CWE-665,CWE-772,CWE-365,CWE-833,CWE-762",N,-1
46,46,182427,182427,,Remote,Not required,Partial,CVE-2018-10199,https://www.cvedetails.com/cve/CVE-2018-10199/,CWE-416,Low,Partial,Partial,,2018-04-18,7.5,"In versions of mruby up to and including 1.4.0, a use-after-free vulnerability exists in src/io.c::File#initilialize_copy(). An attacker that can cause Ruby code to be run can possibly use this to execute arbitrary code.",2018-05-22,Exec Code ,1,https://github.com/mruby/mruby/commit/b51b21fc63c9805862322551387d9036f2b63433,b51b21fc63c9805862322551387d9036f2b63433,"Fix `use after free in File#initilialize_copy`; fix #4001

The bug and the fix were reported by https://hackerone.com/pnoltof",1,mrbgems/mruby-io/src/io.c,"{""sha"": ""6ace9e1673d1c919219dcb83f853a956227a9598"", ""filename"": ""mrbgems/mruby-io/src/io.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/mruby/mruby/blob/b51b21fc63c9805862322551387d9036f2b63433/mrbgems/mruby-io/src/io.c"", ""raw_url"": ""https://github.com/mruby/mruby/raw/b51b21fc63c9805862322551387d9036f2b63433/mrbgems/mruby-io/src/io.c"", ""contents_url"": ""https://api.github.com/repos/mruby/mruby/contents/mrbgems/mruby-io/src/io.c?ref=b51b21fc63c9805862322551387d9036f2b63433"", ""patch"": ""@@ -561,13 +561,13 @@ mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n   mrb_bool failed = TRUE;\n \n   mrb_get_args(mrb, \""o\"", &orig);\n+  fptr_orig = io_get_open_fptr(mrb, orig);\n   fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n   if (fptr_copy != NULL) {\n     fptr_finalize(mrb, fptr_copy, FALSE);\n     mrb_free(mrb, fptr_copy);\n   }\n   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n-  fptr_orig = io_get_open_fptr(mrb, orig);\n \n   DATA_TYPE(copy) = &mrb_io_type;\n   DATA_PTR(copy) = fptr_copy;""}","mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)
{
  mrb_value orig;
  mrb_value buf;
  struct mrb_io *fptr_copy;
  struct mrb_io *fptr_orig;
   mrb_bool failed = TRUE;
 
   mrb_get_args(mrb, ""o"", &orig);
  fptr_orig = io_get_open_fptr(mrb, orig);
   fptr_copy = (struct mrb_io *)DATA_PTR(copy);
   if (fptr_copy != NULL) {
     fptr_finalize(mrb, fptr_copy, FALSE);
     mrb_free(mrb, fptr_copy);
   }
   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);
 
   DATA_TYPE(copy) = &mrb_io_type;
   DATA_PTR(copy) = fptr_copy;

  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, ""@buf""));
  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, ""@buf""), buf);

  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);
  if (failed) {
    mrb_sys_fail(mrb, 0);
  }
  mrb_fd_cloexec(mrb, fptr_copy->fd);

  if (fptr_orig->fd2 != -1) {
    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);
    if (failed) {
      close(fptr_copy->fd);
      mrb_sys_fail(mrb, 0);
    }
    mrb_fd_cloexec(mrb, fptr_copy->fd2);
  }

  fptr_copy->pid = fptr_orig->pid;
  fptr_copy->readable = fptr_orig->readable;
  fptr_copy->writable = fptr_orig->writable;
  fptr_copy->sync = fptr_orig->sync;
  fptr_copy->is_socket = fptr_orig->is_socket;

  return copy;
}
","mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)
{
  mrb_value orig;
  mrb_value buf;
  struct mrb_io *fptr_copy;
  struct mrb_io *fptr_orig;
   mrb_bool failed = TRUE;
 
   mrb_get_args(mrb, ""o"", &orig);
   fptr_copy = (struct mrb_io *)DATA_PTR(copy);
   if (fptr_copy != NULL) {
     fptr_finalize(mrb, fptr_copy, FALSE);
     mrb_free(mrb, fptr_copy);
   }
   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);
  fptr_orig = io_get_open_fptr(mrb, orig);
 
   DATA_TYPE(copy) = &mrb_io_type;
   DATA_PTR(copy) = fptr_copy;

  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, ""@buf""));
  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, ""@buf""), buf);

  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);
  if (failed) {
    mrb_sys_fail(mrb, 0);
  }
  mrb_fd_cloexec(mrb, fptr_copy->fd);

  if (fptr_orig->fd2 != -1) {
    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);
    if (failed) {
      close(fptr_copy->fd);
      mrb_sys_fail(mrb, 0);
    }
    mrb_fd_cloexec(mrb, fptr_copy->fd2);
  }

  fptr_copy->pid = fptr_orig->pid;
  fptr_copy->readable = fptr_orig->readable;
  fptr_copy->writable = fptr_orig->writable;
  fptr_copy->sync = fptr_orig->sync;
  fptr_copy->is_socket = fptr_orig->is_socket;

  return copy;
}
",C,"  fptr_orig = io_get_open_fptr(mrb, orig);
","  fptr_orig = io_get_open_fptr(mrb, orig);
",,"@@ -561,13 +561,13 @@ mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)
   mrb_bool failed = TRUE;
 
   mrb_get_args(mrb, ""o"", &orig);
+  fptr_orig = io_get_open_fptr(mrb, orig);
   fptr_copy = (struct mrb_io *)DATA_PTR(copy);
   if (fptr_copy != NULL) {
     fptr_finalize(mrb, fptr_copy, FALSE);
     mrb_free(mrb, fptr_copy);
   }
   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);
-  fptr_orig = io_get_open_fptr(mrb, orig);
 
   DATA_TYPE(copy) = &mrb_io_type;
   DATA_PTR(copy) = fptr_copy;",mruby,b51b21fc63c9805862322551387d9036f2b63433,fabc460880fbabd18369a7ef8715538c83ebffc9,1,"mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)
{
  mrb_value orig;
  mrb_value buf;
  struct mrb_io *fptr_copy;
  struct mrb_io *fptr_orig;
   mrb_bool failed = TRUE;
 
   mrb_get_args(mrb, ""o"", &orig);
//fix_flaw_line_below:
//  fptr_orig = io_get_open_fptr(mrb, orig);
   fptr_copy = (struct mrb_io *)DATA_PTR(copy);
   if (fptr_copy != NULL) {
     fptr_finalize(mrb, fptr_copy, FALSE);
     mrb_free(mrb, fptr_copy);
   }
   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);
//flaw_line_below:
  fptr_orig = io_get_open_fptr(mrb, orig);
 
   DATA_TYPE(copy) = &mrb_io_type;
   DATA_PTR(copy) = fptr_copy;

  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, ""@buf""));
  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, ""@buf""), buf);

  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);
  if (failed) {
    mrb_sys_fail(mrb, 0);
  }
  mrb_fd_cloexec(mrb, fptr_copy->fd);

  if (fptr_orig->fd2 != -1) {
    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);
    if (failed) {
      close(fptr_copy->fd);
      mrb_sys_fail(mrb, 0);
    }
    mrb_fd_cloexec(mrb, fptr_copy->fd2);
  }

  fptr_copy->pid = fptr_orig->pid;
  fptr_copy->readable = fptr_orig->readable;
  fptr_copy->writable = fptr_orig->writable;
  fptr_copy->sync = fptr_orig->sync;
  fptr_copy->is_socket = fptr_orig->is_socket;

  return copy;
}
",182427,"mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)
{
  mrb_value orig;
  mrb_value buf;
  struct mrb_io *fptr_copy;
  struct mrb_io *fptr_orig;
   mrb_bool failed = TRUE;
 
   mrb_get_args(mrb, ""o"", &orig);
   fptr_copy = (struct mrb_io *)DATA_PTR(copy);
   if (fptr_copy != NULL) {
     fptr_finalize(mrb, fptr_copy, FALSE);
     mrb_free(mrb, fptr_copy);
   }
   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);
  fptr_orig = io_get_open_fptr(mrb, orig);
 
   DATA_TYPE(copy) = &mrb_io_type;
   DATA_PTR(copy) = fptr_copy;

  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, ""@buf""));
  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, ""@buf""), buf);

  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);
  if (failed) {
    mrb_sys_fail(mrb, 0);
  }
  mrb_fd_cloexec(mrb, fptr_copy->fd);

  if (fptr_orig->fd2 != -1) {
    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);
    if (failed) {
      close(fptr_copy->fd);
      mrb_sys_fail(mrb, 0);
    }
    mrb_fd_cloexec(mrb, fptr_copy->fd2);
  }

  fptr_copy->pid = fptr_orig->pid;
  fptr_copy->readable = fptr_orig->readable;
  fptr_copy->writable = fptr_orig->writable;
  fptr_copy->sync = fptr_orig->sync;
  fptr_copy->is_socket = fptr_orig->is_socket;

  return copy;
}
","mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)
{
  mrb_value orig;
  mrb_value buf;
  struct mrb_io *fptr_copy;
  struct mrb_io *fptr_orig;
   mrb_bool failed = TRUE;
 
   mrb_get_args(mrb, ""o"", &orig);
  fptr_orig = io_get_open_fptr(mrb, orig);
   fptr_copy = (struct mrb_io *)DATA_PTR(copy);
   if (fptr_copy != NULL) {
     fptr_finalize(mrb, fptr_copy, FALSE);
     mrb_free(mrb, fptr_copy);
   }
   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);
 
   DATA_TYPE(copy) = &mrb_io_type;
   DATA_PTR(copy) = fptr_copy;

  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, ""@buf""));
  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, ""@buf""), buf);

  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);
  if (failed) {
    mrb_sys_fail(mrb, 0);
  }
  mrb_fd_cloexec(mrb, fptr_copy->fd);

  if (fptr_orig->fd2 != -1) {
    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);
    if (failed) {
      close(fptr_copy->fd);
      mrb_sys_fail(mrb, 0);
    }
    mrb_fd_cloexec(mrb, fptr_copy->fd2);
  }

  fptr_copy->pid = fptr_orig->pid;
  fptr_copy->readable = fptr_orig->readable;
  fptr_copy->writable = fptr_orig->writable;
  fptr_copy->sync = fptr_orig->sync;
  fptr_copy->is_socket = fptr_orig->is_socket;

  return copy;
}
","The function `mrb_io_initialize_copy` is designed to create a copy of an existing IO object in the MRuby environment. It takes a source IO object (`orig`) and initializes a new IO object (`copy`) by duplicating its file descriptors and associated properties. The function first retrieves the original IO's buffer and file descriptors, ensuring proper memory management by finalizing and freeing any existing data in `copy`. It then duplicates the file descriptors, sets various attributes like readability and writability, and handles potential errors during duplication. Finally, it returns the newly initialized copy of the IO object.","The provided code defines a function that initializes a copy of an input IO object by duplicating its properties and file descriptors. It first retrieves the original object's buffer and checks for any existing data in the copy, ensuring proper memory management by finalizing and freeing it if necessary. The function then allocates a new IO object, duplicates the file descriptors, and sets various attributes such as readability and writability. It also includes error handling to manage potential failures during the duplication process, ultimately returning the newly created copy of the IO object.","The vulnerability in the original code stemmed from a use-after-free error, where the function attempted to access and manipulate a pointer to an IO object after it had been freed. Specifically, the issue arose when the code freed the existing `fptr_copy` without ensuring that it was not accessed afterward, leading to potential undefined behavior. The fix involved reordering the code to first retrieve the original IO's file pointer before freeing the existing copy. This change ensures that the function only operates on valid memory, preventing any access to freed memory and thus eliminating the vulnerability.","The vulnerability in the original code was a use-after-free error, where the program accessed a pointer to an object after it had been deallocated, potentially leading to undefined behavior or crashes. This occurred because the code freed the memory of an existing object before ensuring that it was no longer needed. The fix addressed this issue by reordering the operations, ensuring that the necessary data was retrieved and processed before any memory was freed. This change effectively prevented any access to deallocated memory, thereby eliminating the vulnerability and enhancing the overall stability of the code.","The vulnerability was fixed by reordering the operations in the function to ensure safe memory management. In the revised code, the original file pointer is retrieved using `io_get_open_fptr` before any memory is freed. This prevents accessing the freed `fptr_copy` pointer, which was a source of the use-after-free error. The check for `fptr_copy` being non-null and its subsequent finalization and freeing are now performed after the necessary data has been safely accessed. This adjustment ensures that all operations are performed on valid memory, effectively eliminating the risk of undefined behavior.","The vulnerability was fixed by restructuring the order of operations to ensure that memory management is handled safely. The code now retrieves the necessary data from the original object before any existing memory is freed, preventing access to deallocated memory. This change ensures that all required information is available and valid before any cleanup occurs. By delaying the freeing of memory until after the necessary operations are completed, the fix effectively eliminates the risk of accessing freed memory, thereby enhancing the stability and reliability of the code.","CWE-416, CWE-825, CWE-415, CWE-476, CWE-675, CWE-401, CWE-763, CWE-672, CWE-826, CWE-119",Y,1
47,47,182521,182521,,Local,Not required,Complete,CVE-2018-5873,https://www.cvedetails.com/cve/CVE-2018-5873/,CWE-416,Medium,Complete,Complete,,2018-07-06,6.9,"An issue was discovered in the __ns_get_path function in fs/nsfs.c in the Linux kernel before 4.11. Due to a race condition when accessing files, a Use After Free condition can occur. This also affects all Android releases from CAF using the Linux kernel (Android for MSM, Firefox OS for MSM, QRD Android) before security patch level 2018-07-05.",2018-08-29,,1,https://github.com/torvalds/linux/commit/073c516ff73557a8f7315066856c04b50383ac34,073c516ff73557a8f7315066856c04b50383ac34,"nsfs: mark dentry with DCACHE_RCUACCESS

Andrey reported a use-after-free in __ns_get_path():

  spin_lock include/linux/spinlock.h:299 [inline]
  lockref_get_not_dead+0x19/0x80 lib/lockref.c:179
  __ns_get_path+0x197/0x860 fs/nsfs.c:66
  open_related_ns+0xda/0x200 fs/nsfs.c:143
  sock_ioctl+0x39d/0x440 net/socket.c:1001
  vfs_ioctl fs/ioctl.c:45 [inline]
  do_vfs_ioctl+0x1bf/0x1780 fs/ioctl.c:685
  SYSC_ioctl fs/ioctl.c:700 [inline]
  SyS_ioctl+0x8f/0xc0 fs/ioctl.c:691

We are under rcu read lock protection at that point:

        rcu_read_lock();
        d = atomic_long_read(&ns->stashed);
        if (!d)
                goto slow;
        dentry = (struct dentry *)d;
        if (!lockref_get_not_dead(&dentry->d_lockref))
                goto slow;
        rcu_read_unlock();

but don't use a proper RCU API on the free path, therefore a parallel
__d_free() could free it at the same time.  We need to mark the stashed
dentry with DCACHE_RCUACCESS so that __d_free() will be called after all
readers leave RCU.

Fixes: e149ed2b805f (""take the targets of /proc/*/ns/* symlinks to separate fs"")
Cc: Alexander Viro <viro@zeniv.linux.org.uk>
Cc: Andrew Morton <akpm@linux-foundation.org>
Reported-by: Andrey Konovalov <andreyknvl@google.com>
Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,fs/nsfs.c,"{""sha"": ""323f492e0822dd3286365d5cdbe56c59ec2d5463"", ""filename"": ""fs/nsfs.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/073c516ff73557a8f7315066856c04b50383ac34/fs/nsfs.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/073c516ff73557a8f7315066856c04b50383ac34/fs/nsfs.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nsfs.c?ref=073c516ff73557a8f7315066856c04b50383ac34"", ""patch"": ""@@ -91,6 +91,7 @@ static void *__ns_get_path(struct path *path, struct ns_common *ns)\n \t\treturn ERR_PTR(-ENOMEM);\n \t}\n \td_instantiate(dentry, inode);\n+\tdentry->d_flags |= DCACHE_RCUACCESS;\n \tdentry->d_fsdata = (void *)ns->ops;\n \td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n \tif (d) {""}","static void *__ns_get_path(struct path *path, struct ns_common *ns)
{
	struct vfsmount *mnt = nsfs_mnt;
	struct qstr qname = { .name = """", };
	struct dentry *dentry;
	struct inode *inode;
	unsigned long d;

	rcu_read_lock();
	d = atomic_long_read(&ns->stashed);
	if (!d)
		goto slow;
	dentry = (struct dentry *)d;
	if (!lockref_get_not_dead(&dentry->d_lockref))
		goto slow;
	rcu_read_unlock();
	ns->ops->put(ns);
got_it:
	path->mnt = mntget(mnt);
	path->dentry = dentry;
	return NULL;
slow:
	rcu_read_unlock();
	inode = new_inode_pseudo(mnt->mnt_sb);
	if (!inode) {
		ns->ops->put(ns);
		return ERR_PTR(-ENOMEM);
	}
	inode->i_ino = ns->inum;
	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
	inode->i_flags |= S_IMMUTABLE;
	inode->i_mode = S_IFREG | S_IRUGO;
	inode->i_fop = &ns_file_operations;
	inode->i_private = ns;

	dentry = d_alloc_pseudo(mnt->mnt_sb, &qname);
	if (!dentry) {
		iput(inode);
 		return ERR_PTR(-ENOMEM);
 	}
 	d_instantiate(dentry, inode);
	dentry->d_flags |= DCACHE_RCUACCESS;
 	dentry->d_fsdata = (void *)ns->ops;
 	d = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);
 	if (d) {
		d_delete(dentry);	/* make sure ->d_prune() does nothing */
		dput(dentry);
		cpu_relax();
		return ERR_PTR(-EAGAIN);
	}
	goto got_it;
}
","static void *__ns_get_path(struct path *path, struct ns_common *ns)
{
	struct vfsmount *mnt = nsfs_mnt;
	struct qstr qname = { .name = """", };
	struct dentry *dentry;
	struct inode *inode;
	unsigned long d;

	rcu_read_lock();
	d = atomic_long_read(&ns->stashed);
	if (!d)
		goto slow;
	dentry = (struct dentry *)d;
	if (!lockref_get_not_dead(&dentry->d_lockref))
		goto slow;
	rcu_read_unlock();
	ns->ops->put(ns);
got_it:
	path->mnt = mntget(mnt);
	path->dentry = dentry;
	return NULL;
slow:
	rcu_read_unlock();
	inode = new_inode_pseudo(mnt->mnt_sb);
	if (!inode) {
		ns->ops->put(ns);
		return ERR_PTR(-ENOMEM);
	}
	inode->i_ino = ns->inum;
	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
	inode->i_flags |= S_IMMUTABLE;
	inode->i_mode = S_IFREG | S_IRUGO;
	inode->i_fop = &ns_file_operations;
	inode->i_private = ns;

	dentry = d_alloc_pseudo(mnt->mnt_sb, &qname);
	if (!dentry) {
		iput(inode);
 		return ERR_PTR(-ENOMEM);
 	}
 	d_instantiate(dentry, inode);
 	dentry->d_fsdata = (void *)ns->ops;
 	d = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);
 	if (d) {
		d_delete(dentry);	/* make sure ->d_prune() does nothing */
		dput(dentry);
		cpu_relax();
		return ERR_PTR(-EAGAIN);
	}
	goto got_it;
}
",C,"	dentry->d_flags |= DCACHE_RCUACCESS;
",,,"@@ -91,6 +91,7 @@ static void *__ns_get_path(struct path *path, struct ns_common *ns)
 		return ERR_PTR(-ENOMEM);
 	}
 	d_instantiate(dentry, inode);
+	dentry->d_flags |= DCACHE_RCUACCESS;
 	dentry->d_fsdata = (void *)ns->ops;
 	d = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);
 	if (d) {",linux,073c516ff73557a8f7315066856c04b50383ac34,80d136e138f59de35aafb0440e8ab2f51c40ccd5,1,"static void *__ns_get_path(struct path *path, struct ns_common *ns)
{
	struct vfsmount *mnt = nsfs_mnt;
	struct qstr qname = { .name = """", };
	struct dentry *dentry;
	struct inode *inode;
	unsigned long d;

	rcu_read_lock();
	d = atomic_long_read(&ns->stashed);
	if (!d)
		goto slow;
	dentry = (struct dentry *)d;
	if (!lockref_get_not_dead(&dentry->d_lockref))
		goto slow;
	rcu_read_unlock();
	ns->ops->put(ns);
got_it:
	path->mnt = mntget(mnt);
	path->dentry = dentry;
	return NULL;
slow:
	rcu_read_unlock();
	inode = new_inode_pseudo(mnt->mnt_sb);
	if (!inode) {
		ns->ops->put(ns);
		return ERR_PTR(-ENOMEM);
	}
	inode->i_ino = ns->inum;
	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
	inode->i_flags |= S_IMMUTABLE;
	inode->i_mode = S_IFREG | S_IRUGO;
	inode->i_fop = &ns_file_operations;
	inode->i_private = ns;

	dentry = d_alloc_pseudo(mnt->mnt_sb, &qname);
	if (!dentry) {
		iput(inode);
 		return ERR_PTR(-ENOMEM);
 	}
 	d_instantiate(dentry, inode);
//fix_flaw_line_below:
//	dentry->d_flags |= DCACHE_RCUACCESS;
 	dentry->d_fsdata = (void *)ns->ops;
 	d = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);
 	if (d) {
		d_delete(dentry);	/* make sure ->d_prune() does nothing */
		dput(dentry);
		cpu_relax();
		return ERR_PTR(-EAGAIN);
	}
	goto got_it;
}
",182521,"static void *__ns_get_path(struct path *path, struct ns_common *ns)
{
	struct vfsmount *mnt = nsfs_mnt;
	struct qstr qname = { .name = """", };
	struct dentry *dentry;
	struct inode *inode;
	unsigned long d;

	rcu_read_lock();
	d = atomic_long_read(&ns->stashed);
	if (!d)
		goto slow;
	dentry = (struct dentry *)d;
	if (!lockref_get_not_dead(&dentry->d_lockref))
		goto slow;
	rcu_read_unlock();
	ns->ops->put(ns);
got_it:
	path->mnt = mntget(mnt);
	path->dentry = dentry;
	return NULL;
slow:
	rcu_read_unlock();
	inode = new_inode_pseudo(mnt->mnt_sb);
	if (!inode) {
		ns->ops->put(ns);
		return ERR_PTR(-ENOMEM);
	}
	inode->i_ino = ns->inum;
	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
	inode->i_flags |= S_IMMUTABLE;
	inode->i_mode = S_IFREG | S_IRUGO;
	inode->i_fop = &ns_file_operations;
	inode->i_private = ns;

	dentry = d_alloc_pseudo(mnt->mnt_sb, &qname);
	if (!dentry) {
		iput(inode);
 		return ERR_PTR(-ENOMEM);
 	}
 	d_instantiate(dentry, inode);
 	dentry->d_fsdata = (void *)ns->ops;
 	d = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);
 	if (d) {
		d_delete(dentry);	/* make sure ->d_prune() does nothing */
		dput(dentry);
		cpu_relax();
		return ERR_PTR(-EAGAIN);
	}
	goto got_it;
}
","static void *__ns_get_path(struct path *path, struct ns_common *ns)
{
	struct vfsmount *mnt = nsfs_mnt;
	struct qstr qname = { .name = """", };
	struct dentry *dentry;
	struct inode *inode;
	unsigned long d;

	rcu_read_lock();
	d = atomic_long_read(&ns->stashed);
	if (!d)
		goto slow;
	dentry = (struct dentry *)d;
	if (!lockref_get_not_dead(&dentry->d_lockref))
		goto slow;
	rcu_read_unlock();
	ns->ops->put(ns);
got_it:
	path->mnt = mntget(mnt);
	path->dentry = dentry;
	return NULL;
slow:
	rcu_read_unlock();
	inode = new_inode_pseudo(mnt->mnt_sb);
	if (!inode) {
		ns->ops->put(ns);
		return ERR_PTR(-ENOMEM);
	}
	inode->i_ino = ns->inum;
	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
	inode->i_flags |= S_IMMUTABLE;
	inode->i_mode = S_IFREG | S_IRUGO;
	inode->i_fop = &ns_file_operations;
	inode->i_private = ns;

	dentry = d_alloc_pseudo(mnt->mnt_sb, &qname);
	if (!dentry) {
		iput(inode);
 		return ERR_PTR(-ENOMEM);
 	}
 	d_instantiate(dentry, inode);
	dentry->d_flags |= DCACHE_RCUACCESS;
 	dentry->d_fsdata = (void *)ns->ops;
 	d = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);
 	if (d) {
		d_delete(dentry);	/* make sure ->d_prune() does nothing */
		dput(dentry);
		cpu_relax();
		return ERR_PTR(-EAGAIN);
	}
	goto got_it;
}
","The provided code defines a function `__ns_get_path` that retrieves a filesystem path associated with a namespace structure (`ns`). It first attempts to read a cached dentry (directory entry) from the namespace's stashed value. If successful, it increments the reference count and assigns the dentry and mount to the provided path structure. If the cached dentry is not available, it creates a new inode and dentry, initializing their properties and linking them to the namespace. The function handles potential memory allocation failures and ensures proper reference counting to manage resources effectively, returning appropriate error codes when necessary.","The code defines a function that retrieves a filesystem path linked to a specific namespace. It first checks for a cached entry associated with the namespace and, if found, increments its reference count and assigns it to the output path. If no cached entry exists, the function creates a new inode and directory entry, initializing their attributes and linking them to the namespace. It carefully manages memory allocation and reference counting to ensure resources are handled correctly, returning appropriate error codes in case of failures, thus maintaining the integrity of the filesystem operations.","The vulnerability in the original code stemmed from a use-after-free condition, where a directory entry could be freed while still being accessed under a read lock. Specifically, after reading the stashed value, the code did not properly mark the directory entry with the appropriate RCU access flag, allowing a concurrent free operation to occur. The fix involved adding the `DCACHE_RCUACCESS` flag to the directory entry, ensuring that the entry would not be freed until all readers had exited the RCU critical section. This change prevents the race condition, thereby eliminating the potential for accessing freed memory.","The vulnerability in the original code was a use-after-free issue, where a directory entry could be accessed after it had been freed due to a lack of proper synchronization. Specifically, while the code was under a read lock, it did not utilize the correct mechanisms to prevent concurrent freeing of the directory entry, allowing a race condition. The fix involved marking the directory entry with a specific access flag, ensuring that it would not be freed until all readers had completed their operations. This change effectively synchronized access to the entry, preventing the potential for accessing invalid memory.","The vulnerability was fixed by adding the `DCACHE_RCUACCESS` flag to the directory entry, which ensures that the entry cannot be freed while it is still being accessed by readers under the RCU read lock. This change allows the `__d_free()` function to be called only after all readers have exited the critical section, thus preventing a race condition. By marking the stashed directory entry appropriately, the code guarantees that the entry remains valid for the duration of its use, effectively eliminating the use-after-free issue that was previously present in the function.","The vulnerability was addressed by introducing a specific access flag to the directory entry, which ensures that it remains protected from being freed while still in use by readers. This modification guarantees that the entry cannot be deallocated until all read operations have completed, effectively preventing any race conditions that could lead to accessing invalid memory. By implementing this synchronization mechanism, the code ensures safe access to the directory entry, thereby eliminating the potential for use-after-free errors that could compromise system stability and security.","CWE-416, CWE-825, CWE-666, CWE-362, CWE-367, CWE-667, CWE-364, CWE-365, CWE-675, CWE-672",Y,1
48,48,182524,182524,,Local,Not required,Partial,CVE-2018-5344,https://www.cvedetails.com/cve/CVE-2018-5344/,CWE-416,Low,Partial,Partial,,2018-01-12,4.6,"In the Linux kernel through 4.14.13, drivers/block/loop.c mishandles lo_release serialization, which allows attackers to cause a denial of service (__lock_acquire use-after-free) or possibly have unspecified other impact.",2018-10-31,DoS ,1,https://github.com/torvalds/linux/commit/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5,ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5,"loop: fix concurrent lo_open/lo_release

范龙飞 reports that KASAN can report a use-after-free in __lock_acquire.
The reason is due to insufficient serialization in lo_release(), which
will continue to use the loop device even after it has decremented the
lo_refcnt to zero.

In the meantime, another process can come in, open the loop device
again as it is being shut down. Confusion ensues.

Reported-by: 范龙飞 <long7573@126.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Jens Axboe <axboe@kernel.dk>",1,drivers/block/loop.c,"{""sha"": ""d5fe720cf14940b668f8764de2bad6cf95549528"", ""filename"": ""drivers/block/loop.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 2, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5/drivers/block/loop.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5/drivers/block/loop.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/block/loop.c?ref=ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5"", ""patch"": ""@@ -1581,9 +1581,8 @@ static int lo_open(struct block_device *bdev, fmode_t mode)\n \treturn err;\n }\n \n-static void lo_release(struct gendisk *disk, fmode_t mode)\n+static void __lo_release(struct loop_device *lo)\n {\n-\tstruct loop_device *lo = disk->private_data;\n \tint err;\n \n \tif (atomic_dec_return(&lo->lo_refcnt))\n@@ -1610,6 +1609,13 @@ static void lo_release(struct gendisk *disk, fmode_t mode)\n \tmutex_unlock(&lo->lo_ctl_mutex);\n }\n \n+static void lo_release(struct gendisk *disk, fmode_t mode)\n+{\n+\tmutex_lock(&loop_index_mutex);\n+\t__lo_release(disk->private_data);\n+\tmutex_unlock(&loop_index_mutex);\n+}\n+\n static const struct block_device_operations lo_fops = {\n \t.owner =\tTHIS_MODULE,\n \t.open =\t\tlo_open,""}","static void lo_release(struct gendisk *disk, fmode_t mode)
static void __lo_release(struct loop_device *lo)
 {
 	int err;
 
 	if (atomic_dec_return(&lo->lo_refcnt))
		return;

	mutex_lock(&lo->lo_ctl_mutex);
	if (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {
		/*
		 * In autoclear mode, stop the loop thread
		 * and remove configuration after last close.
		 */
		err = loop_clr_fd(lo);
		if (!err)
			return;
	} else if (lo->lo_state == Lo_bound) {
		/*
		 * Otherwise keep thread (if running) and config,
		 * but flush possible ongoing bios in thread.
		 */
		blk_mq_freeze_queue(lo->lo_queue);
		blk_mq_unfreeze_queue(lo->lo_queue);
	}

 	mutex_unlock(&lo->lo_ctl_mutex);
 }
","static void lo_release(struct gendisk *disk, fmode_t mode)
 {
	struct loop_device *lo = disk->private_data;
 	int err;
 
 	if (atomic_dec_return(&lo->lo_refcnt))
		return;

	mutex_lock(&lo->lo_ctl_mutex);
	if (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {
		/*
		 * In autoclear mode, stop the loop thread
		 * and remove configuration after last close.
		 */
		err = loop_clr_fd(lo);
		if (!err)
			return;
	} else if (lo->lo_state == Lo_bound) {
		/*
		 * Otherwise keep thread (if running) and config,
		 * but flush possible ongoing bios in thread.
		 */
		blk_mq_freeze_queue(lo->lo_queue);
		blk_mq_unfreeze_queue(lo->lo_queue);
	}

 	mutex_unlock(&lo->lo_ctl_mutex);
 }
",C,"static void __lo_release(struct loop_device *lo)
","	struct loop_device *lo = disk->private_data;
",,"@@ -1581,9 +1581,8 @@ static int lo_open(struct block_device *bdev, fmode_t mode)
 	return err;
 }
 
-static void lo_release(struct gendisk *disk, fmode_t mode)
+static void __lo_release(struct loop_device *lo)
 {
-	struct loop_device *lo = disk->private_data;
 	int err;
 
 	if (atomic_dec_return(&lo->lo_refcnt))
@@ -1610,6 +1609,13 @@ static void lo_release(struct gendisk *disk, fmode_t mode)
 	mutex_unlock(&lo->lo_ctl_mutex);
 }
 
+static void lo_release(struct gendisk *disk, fmode_t mode)
+{
+	mutex_lock(&loop_index_mutex);
+	__lo_release(disk->private_data);
+	mutex_unlock(&loop_index_mutex);
+}
+
 static const struct block_device_operations lo_fops = {
 	.owner =	THIS_MODULE,
 	.open =		lo_open,",linux,ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5,cbf3a95924d515c1883aec2322fec277e4726134,1,"static void lo_release(struct gendisk *disk, fmode_t mode)
//fix_flaw_line_below:
//static void __lo_release(struct loop_device *lo)
 {
//flaw_line_below:
	struct loop_device *lo = disk->private_data;
 	int err;
 
 	if (atomic_dec_return(&lo->lo_refcnt))
		return;

	mutex_lock(&lo->lo_ctl_mutex);
	if (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {
		/*
		 * In autoclear mode, stop the loop thread
		 * and remove configuration after last close.
		 */
		err = loop_clr_fd(lo);
		if (!err)
			return;
	} else if (lo->lo_state == Lo_bound) {
		/*
		 * Otherwise keep thread (if running) and config,
		 * but flush possible ongoing bios in thread.
		 */
		blk_mq_freeze_queue(lo->lo_queue);
		blk_mq_unfreeze_queue(lo->lo_queue);
	}

 	mutex_unlock(&lo->lo_ctl_mutex);
 }
",182524,"static void lo_release(struct gendisk *disk, fmode_t mode)
 {
	struct loop_device *lo = disk->private_data;
 	int err;
 
 	if (atomic_dec_return(&lo->lo_refcnt))
		return;

	mutex_lock(&lo->lo_ctl_mutex);
	if (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {
		/*
		 * In autoclear mode, stop the loop thread
		 * and remove configuration after last close.
		 */
		err = loop_clr_fd(lo);
		if (!err)
			return;
	} else if (lo->lo_state == Lo_bound) {
		/*
		 * Otherwise keep thread (if running) and config,
		 * but flush possible ongoing bios in thread.
		 */
		blk_mq_freeze_queue(lo->lo_queue);
		blk_mq_unfreeze_queue(lo->lo_queue);
	}

 	mutex_unlock(&lo->lo_ctl_mutex);
 }
","static void lo_release(struct gendisk *disk, fmode_t mode)
static void __lo_release(struct loop_device *lo)
 {
 	int err;
 
 	if (atomic_dec_return(&lo->lo_refcnt))
		return;

	mutex_lock(&lo->lo_ctl_mutex);
	if (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {
		/*
		 * In autoclear mode, stop the loop thread
		 * and remove configuration after last close.
		 */
		err = loop_clr_fd(lo);
		if (!err)
			return;
	} else if (lo->lo_state == Lo_bound) {
		/*
		 * Otherwise keep thread (if running) and config,
		 * but flush possible ongoing bios in thread.
		 */
		blk_mq_freeze_queue(lo->lo_queue);
		blk_mq_unfreeze_queue(lo->lo_queue);
	}

 	mutex_unlock(&lo->lo_ctl_mutex);
 }
","The `lo_release` function is designed to manage the release of a loop device associated with a given disk. It first decrements the reference count of the loop device and returns if it is still in use. If the reference count reaches zero, it locks the device's control mutex to check if it is in autoclear mode; if so, it clears the file descriptor and stops the loop thread. If not in autoclear mode and the device is bound, it freezes and then unfreezes the block queue to ensure any ongoing I/O operations are completed before releasing the device. Finally, it unlocks the mutex.","The provided code manages the release process of a loop device associated with a disk. It first checks if the device is still in use by decrementing a reference count, and if it is not, it proceeds to lock the device's control mechanism. Depending on the device's configuration, it either clears the associated file descriptor and stops the loop thread or ensures that any ongoing input/output operations are completed while keeping the device configuration intact. Finally, it unlocks the control mechanism, allowing other operations to proceed.","The vulnerability in the original code arises from insufficient serialization in the `lo_release` function, which allows a loop device to be accessed after its reference count (`lo_refcnt`) has been decremented to zero. This creates a race condition where another process could open the loop device while it is in the process of being released, leading to potential use-after-free errors. The fix introduces a new function, `__lo_release`, which ensures that the release process is properly serialized, preventing concurrent access to the loop device during its shutdown and thereby eliminating the risk of confusion and memory corruption.","The vulnerability in the original code stems from a lack of proper synchronization during the release process of a loop device, allowing it to be accessed even after its reference count indicated it was no longer in use. This situation could lead to a race condition where another process might open the device while it was being shut down, resulting in potential memory corruption and use-after-free errors. The fix addresses this issue by implementing a new function that ensures the release process is serialized, preventing concurrent access and thereby eliminating the risk of confusion and instability during device management.","The vulnerability was fixed by introducing a new function, `__lo_release`, which ensures proper serialization during the release process of the loop device. In the updated code, the reference count is decremented using `atomic_dec_return`, and if it reaches zero, the control mutex is locked to prevent concurrent access. The logic for handling the device's state and flags remains intact, but the new function structure ensures that the release process is clearly separated from any potential re-opening of the device. This change effectively prevents race conditions and use-after-free errors by managing access to the loop device more safely.","The vulnerability was fixed by restructuring the release process to ensure proper synchronization and prevent concurrent access to the loop device. The updated code introduces a dedicated function that manages the release logic, ensuring that the reference count is decremented and the device is locked before any further operations are performed. This prevents other processes from opening the device while it is being shut down, effectively eliminating the race condition that could lead to memory corruption. By clearly separating the release operations and enforcing mutual exclusion, the fix enhances the stability and safety of the device management process.","CWE-362,CWE-366,CWE-667,CWE-764,CWE-821,CWE-833,CWE-927,CWE-664,CWE-567,CWE-609",N,-1
49,49,182575,182575,,Local,Not required,Complete,CVE-2017-18218,https://www.cvedetails.com/cve/CVE-2017-18218/,CWE-416,Low,Complete,Complete,,2018-03-05,7.2,"In drivers/net/ethernet/hisilicon/hns/hns_enet.c in the Linux kernel before 4.13, local users can cause a denial of service (use-after-free and BUG) or possibly have unspecified other impact by leveraging differences in skb handling between hns_nic_net_xmit_hw and hns_nic_net_xmit.",2018-05-02,DoS ,3,https://github.com/torvalds/linux/commit/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,"net: hns: Fix a skb used after free bug

skb maybe freed in hns_nic_net_xmit_hw() and return NETDEV_TX_OK,
which cause hns_nic_net_xmit to use a freed skb.

BUG: KASAN: use-after-free in hns_nic_net_xmit_hw+0x62c/0x940...
	[17659.112635]      alloc_debug_processing+0x18c/0x1a0
	[17659.117208]      __slab_alloc+0x52c/0x560
	[17659.120909]      kmem_cache_alloc_node+0xac/0x2c0
	[17659.125309]      __alloc_skb+0x6c/0x260
	[17659.128837]      tcp_send_ack+0x8c/0x280
	[17659.132449]      __tcp_ack_snd_check+0x9c/0xf0
	[17659.136587]      tcp_rcv_established+0x5a4/0xa70
	[17659.140899]      tcp_v4_do_rcv+0x27c/0x620
	[17659.144687]      tcp_prequeue_process+0x108/0x170
	[17659.149085]      tcp_recvmsg+0x940/0x1020
	[17659.152787]      inet_recvmsg+0x124/0x180
	[17659.156488]      sock_recvmsg+0x64/0x80
	[17659.160012]      SyS_recvfrom+0xd8/0x180
	[17659.163626]      __sys_trace_return+0x0/0x4
	[17659.167506] INFO: Freed in kfree_skbmem+0xa0/0xb0 age=23 cpu=1 pid=13
	[17659.174000]      free_debug_processing+0x1d4/0x2c0
	[17659.178486]      __slab_free+0x240/0x390
	[17659.182100]      kmem_cache_free+0x24c/0x270
	[17659.186062]      kfree_skbmem+0xa0/0xb0
	[17659.189587]      __kfree_skb+0x28/0x40
	[17659.193025]      napi_gro_receive+0x168/0x1c0
	[17659.197074]      hns_nic_rx_up_pro+0x58/0x90
	[17659.201038]      hns_nic_rx_poll_one+0x518/0xbc0
	[17659.205352]      hns_nic_common_poll+0x94/0x140
	[17659.209576]      net_rx_action+0x458/0x5e0
	[17659.213363]      __do_softirq+0x1b8/0x480
	[17659.217062]      run_ksoftirqd+0x64/0x80
	[17659.220679]      smpboot_thread_fn+0x224/0x310
	[17659.224821]      kthread+0x150/0x170
	[17659.228084]      ret_from_fork+0x10/0x40

	BUG: KASAN: use-after-free in hns_nic_net_xmit+0x8c/0xc0...
	[17751.080490]      __slab_alloc+0x52c/0x560
	[17751.084188]      kmem_cache_alloc+0x244/0x280
	[17751.088238]      __build_skb+0x40/0x150
	[17751.091764]      build_skb+0x28/0x100
	[17751.095115]      __alloc_rx_skb+0x94/0x150
	[17751.098900]      __napi_alloc_skb+0x34/0x90
	[17751.102776]      hns_nic_rx_poll_one+0x180/0xbc0
	[17751.107097]      hns_nic_common_poll+0x94/0x140
	[17751.111333]      net_rx_action+0x458/0x5e0
	[17751.115123]      __do_softirq+0x1b8/0x480
	[17751.118823]      run_ksoftirqd+0x64/0x80
	[17751.122437]      smpboot_thread_fn+0x224/0x310
	[17751.126575]      kthread+0x150/0x170
	[17751.129838]      ret_from_fork+0x10/0x40
	[17751.133454] INFO: Freed in kfree_skbmem+0xa0/0xb0 age=19 cpu=7 pid=43
	[17751.139951]      free_debug_processing+0x1d4/0x2c0
	[17751.144436]      __slab_free+0x240/0x390
	[17751.148051]      kmem_cache_free+0x24c/0x270
	[17751.152014]      kfree_skbmem+0xa0/0xb0
	[17751.155543]      __kfree_skb+0x28/0x40
	[17751.159022]      napi_gro_receive+0x168/0x1c0
	[17751.163074]      hns_nic_rx_up_pro+0x58/0x90
	[17751.167041]      hns_nic_rx_poll_one+0x518/0xbc0
	[17751.171358]      hns_nic_common_poll+0x94/0x140
	[17751.175585]      net_rx_action+0x458/0x5e0
	[17751.179373]      __do_softirq+0x1b8/0x480
	[17751.183076]      run_ksoftirqd+0x64/0x80
	[17751.186691]      smpboot_thread_fn+0x224/0x310
	[17751.190826]      kthread+0x150/0x170
	[17751.194093]      ret_from_fork+0x10/0x40

Fixes: 13ac695e7ea1 (""net:hns: Add support of Hip06 SoC to the Hislicon Network Subsystem"")
Signed-off-by: Yunsheng Lin <linyunsheng@huawei.com>
Signed-off-by: lipeng <lipeng321@huawei.com>
Reported-by: Jun He <hjat2005@huawei.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",9,drivers/net/ethernet/hisilicon/hns/hns_enet.c,"{""sha"": ""fe166e0f678101bb8b0eee7dfab32380e0a0f3a7"", ""filename"": ""drivers/net/ethernet/hisilicon/hns/hns_enet.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 12, ""changes"": 22, ""blob_url"": ""https://github.com/torvalds/linux/blob/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2/drivers/net/ethernet/hisilicon/hns/hns_enet.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2/drivers/net/ethernet/hisilicon/hns/hns_enet.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/hisilicon/hns/hns_enet.c?ref=27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2"", ""patch"": ""@@ -300,9 +300,9 @@ static void fill_tso_desc(struct hnae_ring *ring, void *priv,\n \t\t\t     mtu);\n }\n \n-int hns_nic_net_xmit_hw(struct net_device *ndev,\n-\t\t\tstruct sk_buff *skb,\n-\t\t\tstruct hns_nic_ring_data *ring_data)\n+netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,\n+\t\t\t\tstruct sk_buff *skb,\n+\t\t\t\tstruct hns_nic_ring_data *ring_data)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n \tstruct hnae_ring *ring = ring_data->ring;\n@@ -361,6 +361,10 @@ int hns_nic_net_xmit_hw(struct net_device *ndev,\n \tdev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);\n \tnetdev_tx_sent_queue(dev_queue, skb->len);\n \n+\tnetif_trans_update(ndev);\n+\tndev->stats.tx_bytes += skb->len;\n+\tndev->stats.tx_packets++;\n+\n \twmb(); /* commit all data before submit */\n \tassert(skb->queue_mapping < priv->ae_handle->q_num);\n \thnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);\n@@ -1469,17 +1473,11 @@ static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n \t\t\t\t    struct net_device *ndev)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n-\tint ret;\n \n \tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n-\tret = hns_nic_net_xmit_hw(ndev, skb,\n-\t\t\t\t  &tx_ring_data(priv, skb->queue_mapping));\n-\tif (ret == NETDEV_TX_OK) {\n-\t\tnetif_trans_update(ndev);\n-\t\tndev->stats.tx_bytes += skb->len;\n-\t\tndev->stats.tx_packets++;\n-\t}\n-\treturn (netdev_tx_t)ret;\n+\n+\treturn hns_nic_net_xmit_hw(ndev, skb,\n+\t\t\t\t   &tx_ring_data(priv, skb->queue_mapping));\n }\n \n static void hns_nic_drop_rx_fetch(struct hns_nic_ring_data *ring_data,""}<_**next**_>{""sha"": ""9cb4c7884201e1eb4c1c160a85517f62f397646a"", ""filename"": ""drivers/net/ethernet/hisilicon/hns/hns_enet.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2/drivers/net/ethernet/hisilicon/hns/hns_enet.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2/drivers/net/ethernet/hisilicon/hns/hns_enet.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/hisilicon/hns/hns_enet.h?ref=27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2"", ""patch"": ""@@ -92,8 +92,8 @@ void hns_ethtool_set_ops(struct net_device *ndev);\n void hns_nic_net_reset(struct net_device *ndev);\n void hns_nic_net_reinit(struct net_device *netdev);\n int hns_nic_init_phy(struct net_device *ndev, struct hnae_handle *h);\n-int hns_nic_net_xmit_hw(struct net_device *ndev,\n-\t\t\tstruct sk_buff *skb,\n-\t\t\tstruct hns_nic_ring_data *ring_data);\n+netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,\n+\t\t\t\tstruct sk_buff *skb,\n+\t\t\t\tstruct hns_nic_ring_data *ring_data);\n \n #endif\t/**__HNS_ENET_H */""}","static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);

	return hns_nic_net_xmit_hw(ndev, skb,
				   &tx_ring_data(priv, skb->queue_mapping));
 }
","static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
	int ret;
 
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);
	ret = hns_nic_net_xmit_hw(ndev, skb,
				  &tx_ring_data(priv, skb->queue_mapping));
	if (ret == NETDEV_TX_OK) {
		netif_trans_update(ndev);
		ndev->stats.tx_bytes += skb->len;
		ndev->stats.tx_packets++;
	}
	return (netdev_tx_t)ret;
 }
",C,"
	return hns_nic_net_xmit_hw(ndev, skb,
				   &tx_ring_data(priv, skb->queue_mapping));
","	int ret;
	ret = hns_nic_net_xmit_hw(ndev, skb,
				  &tx_ring_data(priv, skb->queue_mapping));
	if (ret == NETDEV_TX_OK) {
		netif_trans_update(ndev);
		ndev->stats.tx_bytes += skb->len;
		ndev->stats.tx_packets++;
	}
	return (netdev_tx_t)ret;
",,"@@ -300,9 +300,9 @@ static void fill_tso_desc(struct hnae_ring *ring, void *priv,
 			     mtu);
 }
 
-int hns_nic_net_xmit_hw(struct net_device *ndev,
-			struct sk_buff *skb,
-			struct hns_nic_ring_data *ring_data)
+netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,
+				struct sk_buff *skb,
+				struct hns_nic_ring_data *ring_data)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 	struct hnae_ring *ring = ring_data->ring;
@@ -361,6 +361,10 @@ int hns_nic_net_xmit_hw(struct net_device *ndev,
 	dev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);
 	netdev_tx_sent_queue(dev_queue, skb->len);
 
+	netif_trans_update(ndev);
+	ndev->stats.tx_bytes += skb->len;
+	ndev->stats.tx_packets++;
+
 	wmb(); /* commit all data before submit */
 	assert(skb->queue_mapping < priv->ae_handle->q_num);
 	hnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);
@@ -1469,17 +1473,11 @@ static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
-	int ret;
 
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);
-	ret = hns_nic_net_xmit_hw(ndev, skb,
-				  &tx_ring_data(priv, skb->queue_mapping));
-	if (ret == NETDEV_TX_OK) {
-		netif_trans_update(ndev);
-		ndev->stats.tx_bytes += skb->len;
-		ndev->stats.tx_packets++;
-	}
-	return (netdev_tx_t)ret;
+
+	return hns_nic_net_xmit_hw(ndev, skb,
+				   &tx_ring_data(priv, skb->queue_mapping));
 }
 
 static void hns_nic_drop_rx_fetch(struct hns_nic_ring_data *ring_data,",linux,27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,ebe8d359c90d6e237527f4d0544b62bdcc0ff286,1,"static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
//flaw_line_below:
	int ret;
 
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);
//flaw_line_below:
	ret = hns_nic_net_xmit_hw(ndev, skb,
//flaw_line_below:
				  &tx_ring_data(priv, skb->queue_mapping));
//flaw_line_below:
	if (ret == NETDEV_TX_OK) {
//flaw_line_below:
		netif_trans_update(ndev);
//flaw_line_below:
		ndev->stats.tx_bytes += skb->len;
//flaw_line_below:
		ndev->stats.tx_packets++;
//flaw_line_below:
	}
//flaw_line_below:
	return (netdev_tx_t)ret;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	return hns_nic_net_xmit_hw(ndev, skb,
//fix_flaw_line_below:
//				   &tx_ring_data(priv, skb->queue_mapping));
 }
",182575,"static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
	int ret;
 
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);
	ret = hns_nic_net_xmit_hw(ndev, skb,
				  &tx_ring_data(priv, skb->queue_mapping));
	if (ret == NETDEV_TX_OK) {
		netif_trans_update(ndev);
		ndev->stats.tx_bytes += skb->len;
		ndev->stats.tx_packets++;
	}
	return (netdev_tx_t)ret;
 }
","static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);

	return hns_nic_net_xmit_hw(ndev, skb,
				   &tx_ring_data(priv, skb->queue_mapping));
 }
","The provided code defines a function `hns_nic_net_xmit` that handles the transmission of network packets from a socket buffer (`skb`) through a specified network device (`ndev`). It first retrieves the private data associated with the network device and checks that the queue mapping of the socket buffer is valid. The function then attempts to transmit the packet using the `hns_nic_net_xmit_hw` function, passing the network device and the corresponding transmission ring data. If the transmission is successful, it updates the network device's transmission statistics, including the total bytes and packets transmitted, before returning the result of the transmission attempt.","The code defines a function responsible for managing the transmission of network packets from a buffer through a specified network device. It begins by verifying that the packet's queue mapping is valid for the device. The function then attempts to send the packet using a hardware-specific transmission method, while also handling the associated transmission data. If the transmission is successful, it updates the device's statistics to reflect the number of bytes and packets sent. Finally, the function returns the result of the transmission attempt, indicating whether it was successful or if an error occurred.","The vulnerability in the original code arises from the potential use of a socket buffer that may have been freed during the execution of the transmission function. Specifically, if the transmission function returns a success status while the socket buffer is already deallocated, the subsequent use of that buffer in the original function leads to a use-after-free error, which can cause undefined behavior or crashes. The fix involves removing the update of transmission statistics and the call to the update function, ensuring that the socket buffer is not accessed after it has been freed, thus preventing the use-after-free condition.","The vulnerability in the original code stems from the possibility that a socket buffer could be freed during the execution of a transmission function, yet the function still returns a success status. This situation leads to a use-after-free error, where the code attempts to access a buffer that has already been deallocated, potentially causing crashes or undefined behavior. The fix involves removing the update of transmission statistics and the associated function call, ensuring that the code does not attempt to use the freed buffer, thereby eliminating the risk of accessing invalid memory.","The vulnerability was fixed by removing the lines that updated the transmission statistics and called the `netif_trans_update` function in the `hns_nic_net_xmit` function. This change ensures that the code does not attempt to access the socket buffer (`skb`) after it may have been freed in the `hns_nic_net_xmit_hw` function. By eliminating the statistics update and the associated function call, the code prevents any potential use of a freed socket buffer, thereby addressing the use-after-free issue and enhancing the overall stability and safety of the transmission process.","The vulnerability was fixed by removing the code that updated transmission statistics and performed a state update after attempting to transmit a packet. This change prevents the code from accessing a potentially freed buffer, which could lead to undefined behavior or crashes. By eliminating these operations, the revised code ensures that it does not rely on the validity of the buffer after a transmission attempt, thereby addressing the use-after-free issue. This adjustment enhances the safety and reliability of the transmission process, ensuring that only valid memory is accessed during execution.","CWE-416, CWE-825, CWE-415, CWE-476, CWE-465, CWE-763, CWE-119, CWE-754, CWE-664, CWE-758",Y,1
50,50,182576,182576,,Local,Not required,Complete,CVE-2017-18218,https://www.cvedetails.com/cve/CVE-2017-18218/,CWE-416,Low,Complete,Complete,,2018-03-05,7.2,"In drivers/net/ethernet/hisilicon/hns/hns_enet.c in the Linux kernel before 4.13, local users can cause a denial of service (use-after-free and BUG) or possibly have unspecified other impact by leveraging differences in skb handling between hns_nic_net_xmit_hw and hns_nic_net_xmit.",2018-05-02,DoS ,7,https://github.com/torvalds/linux/commit/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,"net: hns: Fix a skb used after free bug

skb maybe freed in hns_nic_net_xmit_hw() and return NETDEV_TX_OK,
which cause hns_nic_net_xmit to use a freed skb.

BUG: KASAN: use-after-free in hns_nic_net_xmit_hw+0x62c/0x940...
	[17659.112635]      alloc_debug_processing+0x18c/0x1a0
	[17659.117208]      __slab_alloc+0x52c/0x560
	[17659.120909]      kmem_cache_alloc_node+0xac/0x2c0
	[17659.125309]      __alloc_skb+0x6c/0x260
	[17659.128837]      tcp_send_ack+0x8c/0x280
	[17659.132449]      __tcp_ack_snd_check+0x9c/0xf0
	[17659.136587]      tcp_rcv_established+0x5a4/0xa70
	[17659.140899]      tcp_v4_do_rcv+0x27c/0x620
	[17659.144687]      tcp_prequeue_process+0x108/0x170
	[17659.149085]      tcp_recvmsg+0x940/0x1020
	[17659.152787]      inet_recvmsg+0x124/0x180
	[17659.156488]      sock_recvmsg+0x64/0x80
	[17659.160012]      SyS_recvfrom+0xd8/0x180
	[17659.163626]      __sys_trace_return+0x0/0x4
	[17659.167506] INFO: Freed in kfree_skbmem+0xa0/0xb0 age=23 cpu=1 pid=13
	[17659.174000]      free_debug_processing+0x1d4/0x2c0
	[17659.178486]      __slab_free+0x240/0x390
	[17659.182100]      kmem_cache_free+0x24c/0x270
	[17659.186062]      kfree_skbmem+0xa0/0xb0
	[17659.189587]      __kfree_skb+0x28/0x40
	[17659.193025]      napi_gro_receive+0x168/0x1c0
	[17659.197074]      hns_nic_rx_up_pro+0x58/0x90
	[17659.201038]      hns_nic_rx_poll_one+0x518/0xbc0
	[17659.205352]      hns_nic_common_poll+0x94/0x140
	[17659.209576]      net_rx_action+0x458/0x5e0
	[17659.213363]      __do_softirq+0x1b8/0x480
	[17659.217062]      run_ksoftirqd+0x64/0x80
	[17659.220679]      smpboot_thread_fn+0x224/0x310
	[17659.224821]      kthread+0x150/0x170
	[17659.228084]      ret_from_fork+0x10/0x40

	BUG: KASAN: use-after-free in hns_nic_net_xmit+0x8c/0xc0...
	[17751.080490]      __slab_alloc+0x52c/0x560
	[17751.084188]      kmem_cache_alloc+0x244/0x280
	[17751.088238]      __build_skb+0x40/0x150
	[17751.091764]      build_skb+0x28/0x100
	[17751.095115]      __alloc_rx_skb+0x94/0x150
	[17751.098900]      __napi_alloc_skb+0x34/0x90
	[17751.102776]      hns_nic_rx_poll_one+0x180/0xbc0
	[17751.107097]      hns_nic_common_poll+0x94/0x140
	[17751.111333]      net_rx_action+0x458/0x5e0
	[17751.115123]      __do_softirq+0x1b8/0x480
	[17751.118823]      run_ksoftirqd+0x64/0x80
	[17751.122437]      smpboot_thread_fn+0x224/0x310
	[17751.126575]      kthread+0x150/0x170
	[17751.129838]      ret_from_fork+0x10/0x40
	[17751.133454] INFO: Freed in kfree_skbmem+0xa0/0xb0 age=19 cpu=7 pid=43
	[17751.139951]      free_debug_processing+0x1d4/0x2c0
	[17751.144436]      __slab_free+0x240/0x390
	[17751.148051]      kmem_cache_free+0x24c/0x270
	[17751.152014]      kfree_skbmem+0xa0/0xb0
	[17751.155543]      __kfree_skb+0x28/0x40
	[17751.159022]      napi_gro_receive+0x168/0x1c0
	[17751.163074]      hns_nic_rx_up_pro+0x58/0x90
	[17751.167041]      hns_nic_rx_poll_one+0x518/0xbc0
	[17751.171358]      hns_nic_common_poll+0x94/0x140
	[17751.175585]      net_rx_action+0x458/0x5e0
	[17751.179373]      __do_softirq+0x1b8/0x480
	[17751.183076]      run_ksoftirqd+0x64/0x80
	[17751.186691]      smpboot_thread_fn+0x224/0x310
	[17751.190826]      kthread+0x150/0x170
	[17751.194093]      ret_from_fork+0x10/0x40

Fixes: 13ac695e7ea1 (""net:hns: Add support of Hip06 SoC to the Hislicon Network Subsystem"")
Signed-off-by: Yunsheng Lin <linyunsheng@huawei.com>
Signed-off-by: lipeng <lipeng321@huawei.com>
Reported-by: Jun He <hjat2005@huawei.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",2,drivers/net/ethernet/hisilicon/hns/hns_enet.c,"{""sha"": ""fe166e0f678101bb8b0eee7dfab32380e0a0f3a7"", ""filename"": ""drivers/net/ethernet/hisilicon/hns/hns_enet.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 12, ""changes"": 22, ""blob_url"": ""https://github.com/torvalds/linux/blob/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2/drivers/net/ethernet/hisilicon/hns/hns_enet.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2/drivers/net/ethernet/hisilicon/hns/hns_enet.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/hisilicon/hns/hns_enet.c?ref=27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2"", ""patch"": ""@@ -300,9 +300,9 @@ static void fill_tso_desc(struct hnae_ring *ring, void *priv,\n \t\t\t     mtu);\n }\n \n-int hns_nic_net_xmit_hw(struct net_device *ndev,\n-\t\t\tstruct sk_buff *skb,\n-\t\t\tstruct hns_nic_ring_data *ring_data)\n+netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,\n+\t\t\t\tstruct sk_buff *skb,\n+\t\t\t\tstruct hns_nic_ring_data *ring_data)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n \tstruct hnae_ring *ring = ring_data->ring;\n@@ -361,6 +361,10 @@ int hns_nic_net_xmit_hw(struct net_device *ndev,\n \tdev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);\n \tnetdev_tx_sent_queue(dev_queue, skb->len);\n \n+\tnetif_trans_update(ndev);\n+\tndev->stats.tx_bytes += skb->len;\n+\tndev->stats.tx_packets++;\n+\n \twmb(); /* commit all data before submit */\n \tassert(skb->queue_mapping < priv->ae_handle->q_num);\n \thnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);\n@@ -1469,17 +1473,11 @@ static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n \t\t\t\t    struct net_device *ndev)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n-\tint ret;\n \n \tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n-\tret = hns_nic_net_xmit_hw(ndev, skb,\n-\t\t\t\t  &tx_ring_data(priv, skb->queue_mapping));\n-\tif (ret == NETDEV_TX_OK) {\n-\t\tnetif_trans_update(ndev);\n-\t\tndev->stats.tx_bytes += skb->len;\n-\t\tndev->stats.tx_packets++;\n-\t}\n-\treturn (netdev_tx_t)ret;\n+\n+\treturn hns_nic_net_xmit_hw(ndev, skb,\n+\t\t\t\t   &tx_ring_data(priv, skb->queue_mapping));\n }\n \n static void hns_nic_drop_rx_fetch(struct hns_nic_ring_data *ring_data,""}<_**next**_>{""sha"": ""9cb4c7884201e1eb4c1c160a85517f62f397646a"", ""filename"": ""drivers/net/ethernet/hisilicon/hns/hns_enet.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2/drivers/net/ethernet/hisilicon/hns/hns_enet.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2/drivers/net/ethernet/hisilicon/hns/hns_enet.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ethernet/hisilicon/hns/hns_enet.h?ref=27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2"", ""patch"": ""@@ -92,8 +92,8 @@ void hns_ethtool_set_ops(struct net_device *ndev);\n void hns_nic_net_reset(struct net_device *ndev);\n void hns_nic_net_reinit(struct net_device *netdev);\n int hns_nic_init_phy(struct net_device *ndev, struct hnae_handle *h);\n-int hns_nic_net_xmit_hw(struct net_device *ndev,\n-\t\t\tstruct sk_buff *skb,\n-\t\t\tstruct hns_nic_ring_data *ring_data);\n+netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,\n+\t\t\t\tstruct sk_buff *skb,\n+\t\t\t\tstruct hns_nic_ring_data *ring_data);\n \n #endif\t/**__HNS_ENET_H */""}","int hns_nic_net_xmit_hw(struct net_device *ndev,
netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,
				struct sk_buff *skb,
				struct hns_nic_ring_data *ring_data)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 	struct hnae_ring *ring = ring_data->ring;
	struct device *dev = ring_to_dev(ring);
	struct netdev_queue *dev_queue;
	struct skb_frag_struct *frag;
	int buf_num;
	int seg_num;
	dma_addr_t dma;
	int size, next_to_use;
	int i;

	switch (priv->ops.maybe_stop_tx(&skb, &buf_num, ring)) {
	case -EBUSY:
		ring->stats.tx_busy++;
		goto out_net_tx_busy;
	case -ENOMEM:
		ring->stats.sw_err_cnt++;
		netdev_err(ndev, ""no memory to xmit!\n"");
		goto out_err_tx_ok;
	default:
		break;
	}

	/* no. of segments (plus a header) */
	seg_num = skb_shinfo(skb)->nr_frags + 1;
	next_to_use = ring->next_to_use;

	/* fill the first part */
	size = skb_headlen(skb);
	dma = dma_map_single(dev, skb->data, size, DMA_TO_DEVICE);
	if (dma_mapping_error(dev, dma)) {
		netdev_err(ndev, ""TX head DMA map failed\n"");
		ring->stats.sw_err_cnt++;
		goto out_err_tx_ok;
	}
	priv->ops.fill_desc(ring, skb, size, dma, seg_num == 1 ? 1 : 0,
			    buf_num, DESC_TYPE_SKB, ndev->mtu);

	/* fill the fragments */
	for (i = 1; i < seg_num; i++) {
		frag = &skb_shinfo(skb)->frags[i - 1];
		size = skb_frag_size(frag);
		dma = skb_frag_dma_map(dev, frag, 0, size, DMA_TO_DEVICE);
		if (dma_mapping_error(dev, dma)) {
			netdev_err(ndev, ""TX frag(%d) DMA map failed\n"", i);
			ring->stats.sw_err_cnt++;
			goto out_map_frag_fail;
		}
		priv->ops.fill_desc(ring, skb_frag_page(frag), size, dma,
				    seg_num - 1 == i ? 1 : 0, buf_num,
				    DESC_TYPE_PAGE, ndev->mtu);
	}

	/*complete translate all packets*/
 	dev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);
 	netdev_tx_sent_queue(dev_queue, skb->len);
 
	netif_trans_update(ndev);
	ndev->stats.tx_bytes += skb->len;
	ndev->stats.tx_packets++;

 	wmb(); /* commit all data before submit */
 	assert(skb->queue_mapping < priv->ae_handle->q_num);
 	hnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);
	ring->stats.tx_pkts++;
	ring->stats.tx_bytes += skb->len;

	return NETDEV_TX_OK;

out_map_frag_fail:

	while (ring->next_to_use != next_to_use) {
		unfill_desc(ring);
		if (ring->next_to_use != next_to_use)
			dma_unmap_page(dev,
				       ring->desc_cb[ring->next_to_use].dma,
				       ring->desc_cb[ring->next_to_use].length,
				       DMA_TO_DEVICE);
		else
			dma_unmap_single(dev,
					 ring->desc_cb[next_to_use].dma,
					 ring->desc_cb[next_to_use].length,
					 DMA_TO_DEVICE);
	}

out_err_tx_ok:

	dev_kfree_skb_any(skb);
	return NETDEV_TX_OK;

out_net_tx_busy:

	netif_stop_subqueue(ndev, skb->queue_mapping);

	/* Herbert's original patch had:
	 *  smp_mb__after_netif_stop_queue();
	 * but since that doesn't exist yet, just open code it.
	 */
	smp_mb();
	return NETDEV_TX_BUSY;
}
","int hns_nic_net_xmit_hw(struct net_device *ndev,
			struct sk_buff *skb,
			struct hns_nic_ring_data *ring_data)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 	struct hnae_ring *ring = ring_data->ring;
	struct device *dev = ring_to_dev(ring);
	struct netdev_queue *dev_queue;
	struct skb_frag_struct *frag;
	int buf_num;
	int seg_num;
	dma_addr_t dma;
	int size, next_to_use;
	int i;

	switch (priv->ops.maybe_stop_tx(&skb, &buf_num, ring)) {
	case -EBUSY:
		ring->stats.tx_busy++;
		goto out_net_tx_busy;
	case -ENOMEM:
		ring->stats.sw_err_cnt++;
		netdev_err(ndev, ""no memory to xmit!\n"");
		goto out_err_tx_ok;
	default:
		break;
	}

	/* no. of segments (plus a header) */
	seg_num = skb_shinfo(skb)->nr_frags + 1;
	next_to_use = ring->next_to_use;

	/* fill the first part */
	size = skb_headlen(skb);
	dma = dma_map_single(dev, skb->data, size, DMA_TO_DEVICE);
	if (dma_mapping_error(dev, dma)) {
		netdev_err(ndev, ""TX head DMA map failed\n"");
		ring->stats.sw_err_cnt++;
		goto out_err_tx_ok;
	}
	priv->ops.fill_desc(ring, skb, size, dma, seg_num == 1 ? 1 : 0,
			    buf_num, DESC_TYPE_SKB, ndev->mtu);

	/* fill the fragments */
	for (i = 1; i < seg_num; i++) {
		frag = &skb_shinfo(skb)->frags[i - 1];
		size = skb_frag_size(frag);
		dma = skb_frag_dma_map(dev, frag, 0, size, DMA_TO_DEVICE);
		if (dma_mapping_error(dev, dma)) {
			netdev_err(ndev, ""TX frag(%d) DMA map failed\n"", i);
			ring->stats.sw_err_cnt++;
			goto out_map_frag_fail;
		}
		priv->ops.fill_desc(ring, skb_frag_page(frag), size, dma,
				    seg_num - 1 == i ? 1 : 0, buf_num,
				    DESC_TYPE_PAGE, ndev->mtu);
	}

	/*complete translate all packets*/
 	dev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);
 	netdev_tx_sent_queue(dev_queue, skb->len);
 
 	wmb(); /* commit all data before submit */
 	assert(skb->queue_mapping < priv->ae_handle->q_num);
 	hnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);
	ring->stats.tx_pkts++;
	ring->stats.tx_bytes += skb->len;

	return NETDEV_TX_OK;

out_map_frag_fail:

	while (ring->next_to_use != next_to_use) {
		unfill_desc(ring);
		if (ring->next_to_use != next_to_use)
			dma_unmap_page(dev,
				       ring->desc_cb[ring->next_to_use].dma,
				       ring->desc_cb[ring->next_to_use].length,
				       DMA_TO_DEVICE);
		else
			dma_unmap_single(dev,
					 ring->desc_cb[next_to_use].dma,
					 ring->desc_cb[next_to_use].length,
					 DMA_TO_DEVICE);
	}

out_err_tx_ok:

	dev_kfree_skb_any(skb);
	return NETDEV_TX_OK;

out_net_tx_busy:

	netif_stop_subqueue(ndev, skb->queue_mapping);

	/* Herbert's original patch had:
	 *  smp_mb__after_netif_stop_queue();
	 * but since that doesn't exist yet, just open code it.
	 */
	smp_mb();
	return NETDEV_TX_BUSY;
}
",C,"netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,
				struct sk_buff *skb,
				struct hns_nic_ring_data *ring_data)
	netif_trans_update(ndev);
	ndev->stats.tx_bytes += skb->len;
	ndev->stats.tx_packets++;

","			struct sk_buff *skb,
			struct hns_nic_ring_data *ring_data)
",,"@@ -300,9 +300,9 @@ static void fill_tso_desc(struct hnae_ring *ring, void *priv,
 			     mtu);
 }
 
-int hns_nic_net_xmit_hw(struct net_device *ndev,
-			struct sk_buff *skb,
-			struct hns_nic_ring_data *ring_data)
+netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,
+				struct sk_buff *skb,
+				struct hns_nic_ring_data *ring_data)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 	struct hnae_ring *ring = ring_data->ring;
@@ -361,6 +361,10 @@ int hns_nic_net_xmit_hw(struct net_device *ndev,
 	dev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);
 	netdev_tx_sent_queue(dev_queue, skb->len);
 
+	netif_trans_update(ndev);
+	ndev->stats.tx_bytes += skb->len;
+	ndev->stats.tx_packets++;
+
 	wmb(); /* commit all data before submit */
 	assert(skb->queue_mapping < priv->ae_handle->q_num);
 	hnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);
@@ -1469,17 +1473,11 @@ static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
-	int ret;
 
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);
-	ret = hns_nic_net_xmit_hw(ndev, skb,
-				  &tx_ring_data(priv, skb->queue_mapping));
-	if (ret == NETDEV_TX_OK) {
-		netif_trans_update(ndev);
-		ndev->stats.tx_bytes += skb->len;
-		ndev->stats.tx_packets++;
-	}
-	return (netdev_tx_t)ret;
+
+	return hns_nic_net_xmit_hw(ndev, skb,
+				   &tx_ring_data(priv, skb->queue_mapping));
 }
 
 static void hns_nic_drop_rx_fetch(struct hns_nic_ring_data *ring_data,",linux,27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2,ebe8d359c90d6e237527f4d0544b62bdcc0ff286,1,"int hns_nic_net_xmit_hw(struct net_device *ndev,
//flaw_line_below:
			struct sk_buff *skb,
//flaw_line_below:
			struct hns_nic_ring_data *ring_data)
//fix_flaw_line_below:
//netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,
//fix_flaw_line_below:
//				struct sk_buff *skb,
//fix_flaw_line_below:
//				struct hns_nic_ring_data *ring_data)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 	struct hnae_ring *ring = ring_data->ring;
	struct device *dev = ring_to_dev(ring);
	struct netdev_queue *dev_queue;
	struct skb_frag_struct *frag;
	int buf_num;
	int seg_num;
	dma_addr_t dma;
	int size, next_to_use;
	int i;

	switch (priv->ops.maybe_stop_tx(&skb, &buf_num, ring)) {
	case -EBUSY:
		ring->stats.tx_busy++;
		goto out_net_tx_busy;
	case -ENOMEM:
		ring->stats.sw_err_cnt++;
		netdev_err(ndev, ""no memory to xmit!\n"");
		goto out_err_tx_ok;
	default:
		break;
	}

	/* no. of segments (plus a header) */
	seg_num = skb_shinfo(skb)->nr_frags + 1;
	next_to_use = ring->next_to_use;

	/* fill the first part */
	size = skb_headlen(skb);
	dma = dma_map_single(dev, skb->data, size, DMA_TO_DEVICE);
	if (dma_mapping_error(dev, dma)) {
		netdev_err(ndev, ""TX head DMA map failed\n"");
		ring->stats.sw_err_cnt++;
		goto out_err_tx_ok;
	}
	priv->ops.fill_desc(ring, skb, size, dma, seg_num == 1 ? 1 : 0,
			    buf_num, DESC_TYPE_SKB, ndev->mtu);

	/* fill the fragments */
	for (i = 1; i < seg_num; i++) {
		frag = &skb_shinfo(skb)->frags[i - 1];
		size = skb_frag_size(frag);
		dma = skb_frag_dma_map(dev, frag, 0, size, DMA_TO_DEVICE);
		if (dma_mapping_error(dev, dma)) {
			netdev_err(ndev, ""TX frag(%d) DMA map failed\n"", i);
			ring->stats.sw_err_cnt++;
			goto out_map_frag_fail;
		}
		priv->ops.fill_desc(ring, skb_frag_page(frag), size, dma,
				    seg_num - 1 == i ? 1 : 0, buf_num,
				    DESC_TYPE_PAGE, ndev->mtu);
	}

	/*complete translate all packets*/
 	dev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);
 	netdev_tx_sent_queue(dev_queue, skb->len);
 
//fix_flaw_line_below:
//	netif_trans_update(ndev);
//fix_flaw_line_below:
//	ndev->stats.tx_bytes += skb->len;
//fix_flaw_line_below:
//	ndev->stats.tx_packets++;
//fix_flaw_line_below:
//
 	wmb(); /* commit all data before submit */
 	assert(skb->queue_mapping < priv->ae_handle->q_num);
 	hnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);
	ring->stats.tx_pkts++;
	ring->stats.tx_bytes += skb->len;

	return NETDEV_TX_OK;

out_map_frag_fail:

	while (ring->next_to_use != next_to_use) {
		unfill_desc(ring);
		if (ring->next_to_use != next_to_use)
			dma_unmap_page(dev,
				       ring->desc_cb[ring->next_to_use].dma,
				       ring->desc_cb[ring->next_to_use].length,
				       DMA_TO_DEVICE);
		else
			dma_unmap_single(dev,
					 ring->desc_cb[next_to_use].dma,
					 ring->desc_cb[next_to_use].length,
					 DMA_TO_DEVICE);
	}

out_err_tx_ok:

	dev_kfree_skb_any(skb);
	return NETDEV_TX_OK;

out_net_tx_busy:

	netif_stop_subqueue(ndev, skb->queue_mapping);

	/* Herbert's original patch had:
	 *  smp_mb__after_netif_stop_queue();
	 * but since that doesn't exist yet, just open code it.
	 */
	smp_mb();
	return NETDEV_TX_BUSY;
}
",182576,"int hns_nic_net_xmit_hw(struct net_device *ndev,
			struct sk_buff *skb,
			struct hns_nic_ring_data *ring_data)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 	struct hnae_ring *ring = ring_data->ring;
	struct device *dev = ring_to_dev(ring);
	struct netdev_queue *dev_queue;
	struct skb_frag_struct *frag;
	int buf_num;
	int seg_num;
	dma_addr_t dma;
	int size, next_to_use;
	int i;

	switch (priv->ops.maybe_stop_tx(&skb, &buf_num, ring)) {
	case -EBUSY:
		ring->stats.tx_busy++;
		goto out_net_tx_busy;
	case -ENOMEM:
		ring->stats.sw_err_cnt++;
		netdev_err(ndev, ""no memory to xmit!\n"");
		goto out_err_tx_ok;
	default:
		break;
	}

	/* no. of segments (plus a header) */
	seg_num = skb_shinfo(skb)->nr_frags + 1;
	next_to_use = ring->next_to_use;

	/* fill the first part */
	size = skb_headlen(skb);
	dma = dma_map_single(dev, skb->data, size, DMA_TO_DEVICE);
	if (dma_mapping_error(dev, dma)) {
		netdev_err(ndev, ""TX head DMA map failed\n"");
		ring->stats.sw_err_cnt++;
		goto out_err_tx_ok;
	}
	priv->ops.fill_desc(ring, skb, size, dma, seg_num == 1 ? 1 : 0,
			    buf_num, DESC_TYPE_SKB, ndev->mtu);

	/* fill the fragments */
	for (i = 1; i < seg_num; i++) {
		frag = &skb_shinfo(skb)->frags[i - 1];
		size = skb_frag_size(frag);
		dma = skb_frag_dma_map(dev, frag, 0, size, DMA_TO_DEVICE);
		if (dma_mapping_error(dev, dma)) {
			netdev_err(ndev, ""TX frag(%d) DMA map failed\n"", i);
			ring->stats.sw_err_cnt++;
			goto out_map_frag_fail;
		}
		priv->ops.fill_desc(ring, skb_frag_page(frag), size, dma,
				    seg_num - 1 == i ? 1 : 0, buf_num,
				    DESC_TYPE_PAGE, ndev->mtu);
	}

	/*complete translate all packets*/
 	dev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);
 	netdev_tx_sent_queue(dev_queue, skb->len);
 
 	wmb(); /* commit all data before submit */
 	assert(skb->queue_mapping < priv->ae_handle->q_num);
 	hnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);
	ring->stats.tx_pkts++;
	ring->stats.tx_bytes += skb->len;

	return NETDEV_TX_OK;

out_map_frag_fail:

	while (ring->next_to_use != next_to_use) {
		unfill_desc(ring);
		if (ring->next_to_use != next_to_use)
			dma_unmap_page(dev,
				       ring->desc_cb[ring->next_to_use].dma,
				       ring->desc_cb[ring->next_to_use].length,
				       DMA_TO_DEVICE);
		else
			dma_unmap_single(dev,
					 ring->desc_cb[next_to_use].dma,
					 ring->desc_cb[next_to_use].length,
					 DMA_TO_DEVICE);
	}

out_err_tx_ok:

	dev_kfree_skb_any(skb);
	return NETDEV_TX_OK;

out_net_tx_busy:

	netif_stop_subqueue(ndev, skb->queue_mapping);

	/* Herbert's original patch had:
	 *  smp_mb__after_netif_stop_queue();
	 * but since that doesn't exist yet, just open code it.
	 */
	smp_mb();
	return NETDEV_TX_BUSY;
}
","int hns_nic_net_xmit_hw(struct net_device *ndev,
netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,
				struct sk_buff *skb,
				struct hns_nic_ring_data *ring_data)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 	struct hnae_ring *ring = ring_data->ring;
	struct device *dev = ring_to_dev(ring);
	struct netdev_queue *dev_queue;
	struct skb_frag_struct *frag;
	int buf_num;
	int seg_num;
	dma_addr_t dma;
	int size, next_to_use;
	int i;

	switch (priv->ops.maybe_stop_tx(&skb, &buf_num, ring)) {
	case -EBUSY:
		ring->stats.tx_busy++;
		goto out_net_tx_busy;
	case -ENOMEM:
		ring->stats.sw_err_cnt++;
		netdev_err(ndev, ""no memory to xmit!\n"");
		goto out_err_tx_ok;
	default:
		break;
	}

	/* no. of segments (plus a header) */
	seg_num = skb_shinfo(skb)->nr_frags + 1;
	next_to_use = ring->next_to_use;

	/* fill the first part */
	size = skb_headlen(skb);
	dma = dma_map_single(dev, skb->data, size, DMA_TO_DEVICE);
	if (dma_mapping_error(dev, dma)) {
		netdev_err(ndev, ""TX head DMA map failed\n"");
		ring->stats.sw_err_cnt++;
		goto out_err_tx_ok;
	}
	priv->ops.fill_desc(ring, skb, size, dma, seg_num == 1 ? 1 : 0,
			    buf_num, DESC_TYPE_SKB, ndev->mtu);

	/* fill the fragments */
	for (i = 1; i < seg_num; i++) {
		frag = &skb_shinfo(skb)->frags[i - 1];
		size = skb_frag_size(frag);
		dma = skb_frag_dma_map(dev, frag, 0, size, DMA_TO_DEVICE);
		if (dma_mapping_error(dev, dma)) {
			netdev_err(ndev, ""TX frag(%d) DMA map failed\n"", i);
			ring->stats.sw_err_cnt++;
			goto out_map_frag_fail;
		}
		priv->ops.fill_desc(ring, skb_frag_page(frag), size, dma,
				    seg_num - 1 == i ? 1 : 0, buf_num,
				    DESC_TYPE_PAGE, ndev->mtu);
	}

	/*complete translate all packets*/
 	dev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);
 	netdev_tx_sent_queue(dev_queue, skb->len);
 
	netif_trans_update(ndev);
	ndev->stats.tx_bytes += skb->len;
	ndev->stats.tx_packets++;

 	wmb(); /* commit all data before submit */
 	assert(skb->queue_mapping < priv->ae_handle->q_num);
 	hnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);
	ring->stats.tx_pkts++;
	ring->stats.tx_bytes += skb->len;

	return NETDEV_TX_OK;

out_map_frag_fail:

	while (ring->next_to_use != next_to_use) {
		unfill_desc(ring);
		if (ring->next_to_use != next_to_use)
			dma_unmap_page(dev,
				       ring->desc_cb[ring->next_to_use].dma,
				       ring->desc_cb[ring->next_to_use].length,
				       DMA_TO_DEVICE);
		else
			dma_unmap_single(dev,
					 ring->desc_cb[next_to_use].dma,
					 ring->desc_cb[next_to_use].length,
					 DMA_TO_DEVICE);
	}

out_err_tx_ok:

	dev_kfree_skb_any(skb);
	return NETDEV_TX_OK;

out_net_tx_busy:

	netif_stop_subqueue(ndev, skb->queue_mapping);

	/* Herbert's original patch had:
	 *  smp_mb__after_netif_stop_queue();
	 * but since that doesn't exist yet, just open code it.
	 */
	smp_mb();
	return NETDEV_TX_BUSY;
}
","The function `hns_nic_net_xmit_hw` is responsible for transmitting network packets from a network device. It first checks if the transmission can proceed, handling cases where the transmission is busy or memory allocation fails. It then prepares the packet by mapping its data and any fragments to DMA addresses, filling in descriptor entries for the transmission. After successfully preparing the packet, it updates the transmission statistics and submits the packet to the hardware queue. If any mapping fails, it cleans up by unmapping previously mapped descriptors and frees the socket buffer. The function ultimately returns the status of the transmission attempt.","The code implements a function that manages the transmission of network packets from a device. It begins by checking if the transmission can proceed, handling scenarios where the device is busy or memory allocation fails. Upon confirming readiness, it prepares the packet by mapping its data and any associated fragments for direct memory access, while filling in necessary descriptors for the hardware. After successfully preparing the packet, it updates transmission statistics and submits the packet for processing. In case of mapping failures, it ensures proper cleanup by unmapping previously allocated resources and freeing the associated memory. The function concludes by returning the transmission status.","The vulnerability in the original code arises from the potential use of a socket buffer (skb) after it has been freed, specifically when the function returns a success status while the skb may have already been deallocated. This can lead to undefined behavior and memory corruption, as indicated by the use-after-free errors reported. The fix involves ensuring that the skb is only freed after all necessary operations are completed, particularly by restructuring the flow to prevent premature deallocation. The updated code introduces a more careful management of the skb's lifecycle, ensuring it is not accessed after being freed, thus eliminating the vulnerability.","The vulnerability in the original code stems from the possibility of a socket buffer being freed while still being referenced, leading to a use-after-free condition. This occurs when the function returns a success status even after the buffer has been deallocated, allowing subsequent operations to access invalid memory. The fix addresses this issue by restructuring the code to ensure that the buffer is not freed until all necessary operations are completed, thereby preventing any access to the freed memory. This careful management of the buffer's lifecycle eliminates the risk of undefined behavior associated with accessing freed memory.","The vulnerability was fixed by restructuring the flow of the function to ensure that the socket buffer is not freed prematurely. In the updated code, the condition that previously allowed the function to return `NETDEV_TX_OK` while the buffer might still be in use was modified. Specifically, the code now ensures that the buffer is only freed in the `out_err_tx_ok` section after all necessary operations, including DMA mapping and descriptor filling, are completed. This change prevents any access to the buffer after it has been deallocated, thus eliminating the use-after-free issue.","The vulnerability was fixed by modifying the control flow to ensure that the memory associated with the socket buffer is not freed until all necessary operations are completed. The updated code introduces checks that prevent the function from returning a success status when the buffer may still be in use, thereby avoiding any potential access to freed memory. By carefully managing the lifecycle of the buffer and ensuring it is only deallocated after all processing is finished, the fix effectively eliminates the risk of undefined behavior associated with accessing invalid memory.","CWE-416, CWE-825, CWE-415, CWE-763, CWE-404, CWE-401, CWE-672, CWE-666, CWE-665, CWE-119",Y,1
51,51,182584,182584,,Local,Not required,Complete,CVE-2017-18202,https://www.cvedetails.com/cve/CVE-2017-18202/,CWE-416,Medium,Complete,Complete,,2018-02-27,6.9,"The __oom_reap_task_mm function in mm/oom_kill.c in the Linux kernel before 4.14.4 mishandles gather operations, which allows attackers to cause a denial of service (TLB entry leak or use-after-free) or possibly have unspecified other impact by triggering a copy_to_user call within a certain time window.",2018-09-26,DoS ,4,https://github.com/torvalds/linux/commit/687cb0884a714ff484d038e9190edc874edcf146,687cb0884a714ff484d038e9190edc874edcf146,"mm, oom_reaper: gather each vma to prevent leaking TLB entry

tlb_gather_mmu(&tlb, mm, 0, -1) means gathering the whole virtual memory
space.  In this case, tlb->fullmm is true.  Some archs like arm64
doesn't flush TLB when tlb->fullmm is true:

  commit 5a7862e83000 (""arm64: tlbflush: avoid flushing when fullmm == 1"").

Which causes leaking of tlb entries.

Will clarifies his patch:
 ""Basically, we tag each address space with an ASID (PCID on x86) which
  is resident in the TLB. This means we can elide TLB invalidation when
  pulling down a full mm because we won't ever assign that ASID to
  another mm without doing TLB invalidation elsewhere (which actually
  just nukes the whole TLB).

  I think that means that we could potentially not fault on a kernel
  uaccess, because we could hit in the TLB""

There could be a window between complete_signal() sending IPI to other
cores and all threads sharing this mm are really kicked off from cores.
In this window, the oom reaper may calls tlb_flush_mmu_tlbonly() to
flush TLB then frees pages.  However, due to the above problem, the TLB
entries are not really flushed on arm64.  Other threads are possible to
access these pages through TLB entries.  Moreover, a copy_to_user() can
also write to these pages without generating page fault, causes
use-after-free bugs.

This patch gathers each vma instead of gathering full vm space.  In this
case tlb->fullmm is not true.  The behavior of oom reaper become similar
to munmapping before do_exit, which should be safe for all archs.

Link: http://lkml.kernel.org/r/20171107095453.179940-1-wangnan0@huawei.com
Fixes: aac453635549 (""mm, oom: introduce oom reaper"")
Signed-off-by: Wang Nan <wangnan0@huawei.com>
Acked-by: Michal Hocko <mhocko@suse.com>
Acked-by: David Rientjes <rientjes@google.com>
Cc: Minchan Kim <minchan@kernel.org>
Cc: Will Deacon <will.deacon@arm.com>
Cc: Bob Liu <liubo95@huawei.com>
Cc: Ingo Molnar <mingo@kernel.org>
Cc: Roman Gushchin <guro@fb.com>
Cc: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
Cc: Andrea Arcangeli <aarcange@redhat.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",3,mm/oom_kill.c,"{""sha"": ""c957be32b27a9e7a17a6e33e69a31b1b6fa8e820"", ""filename"": ""mm/oom_kill.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/687cb0884a714ff484d038e9190edc874edcf146/mm/oom_kill.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/687cb0884a714ff484d038e9190edc874edcf146/mm/oom_kill.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/oom_kill.c?ref=687cb0884a714ff484d038e9190edc874edcf146"", ""patch"": ""@@ -550,7 +550,6 @@ static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n \t */\n \tset_bit(MMF_UNSTABLE, &mm->flags);\n \n-\ttlb_gather_mmu(&tlb, mm, 0, -1);\n \tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n \t\tif (!can_madv_dontneed_vma(vma))\n \t\t\tcontinue;\n@@ -565,11 +564,13 @@ static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n \t\t * we do not want to block exit_mmap by keeping mm ref\n \t\t * count elevated without a good reason.\n \t\t */\n-\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\n+\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {\n+\t\t\ttlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);\n \t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n \t\t\t\t\t NULL);\n+\t\t\ttlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);\n+\t\t}\n \t}\n-\ttlb_finish_mmu(&tlb, 0, -1);\n \tpr_info(\""oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\"",\n \t\t\ttask_pid_nr(tsk), tsk->comm,\n \t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),""}","static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
{
	struct mmu_gather tlb;
	struct vm_area_struct *vma;
	bool ret = true;

	/*
	 * We have to make sure to not race with the victim exit path
	 * and cause premature new oom victim selection:
	 * __oom_reap_task_mm		exit_mm
	 *   mmget_not_zero
	 *				  mmput
	 *				    atomic_dec_and_test
	 *				  exit_oom_victim
	 *				[...]
	 *				out_of_memory
	 *				  select_bad_process
	 *				    # no TIF_MEMDIE task selects new victim
	 *  unmap_page_range # frees some memory
	 */
	mutex_lock(&oom_lock);

	if (!down_read_trylock(&mm->mmap_sem)) {
		ret = false;
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	/*
	 * If the mm has notifiers then we would need to invalidate them around
	 * unmap_page_range and that is risky because notifiers can sleep and
	 * what they do is basically undeterministic.  So let's have a short
	 * sleep to give the oom victim some more time.
	 * TODO: we really want to get rid of this ugly hack and make sure that
	 * notifiers cannot block for unbounded amount of time and add
	 * mmu_notifier_invalidate_range_{start,end} around unmap_page_range
	 */
	if (mm_has_notifiers(mm)) {
		up_read(&mm->mmap_sem);
		schedule_timeout_idle(HZ);
		goto unlock_oom;
	}

	/*
	 * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't
	 * work on the mm anymore. The check for MMF_OOM_SKIP must run
	 * under mmap_sem for reading because it serializes against the
	 * down_write();up_write() cycle in exit_mmap().
	 */
	if (test_bit(MMF_OOM_SKIP, &mm->flags)) {
		up_read(&mm->mmap_sem);
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	trace_start_task_reaping(tsk->pid);

	/*
	 * Tell all users of get_user/copy_from_user etc... that the content
	 * is no longer stable. No barriers really needed because unmapping
	 * should imply barriers already and the reader would hit a page fault
	 * if it stumbled over a reaped memory.
 	 */
 	set_bit(MMF_UNSTABLE, &mm->flags);
 
 	for (vma = mm->mmap ; vma; vma = vma->vm_next) {
 		if (!can_madv_dontneed_vma(vma))
 			continue;

		/*
		 * Only anonymous pages have a good chance to be dropped
		 * without additional steps which we cannot afford as we
		 * are OOM already.
		 *
		 * We do not even care about fs backed pages because all
		 * which are reclaimable have already been reclaimed and
 		 * we do not want to block exit_mmap by keeping mm ref
 		 * count elevated without a good reason.
 		 */
		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {
			tlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);
 			unmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,
 					 NULL);
			tlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);
		}
 	}
 	pr_info(""oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n"",
 			task_pid_nr(tsk), tsk->comm,
 			K(get_mm_counter(mm, MM_ANONPAGES)),
			K(get_mm_counter(mm, MM_FILEPAGES)),
			K(get_mm_counter(mm, MM_SHMEMPAGES)));
	up_read(&mm->mmap_sem);

	trace_finish_task_reaping(tsk->pid);
unlock_oom:
	mutex_unlock(&oom_lock);
	return ret;
}
","static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
{
	struct mmu_gather tlb;
	struct vm_area_struct *vma;
	bool ret = true;

	/*
	 * We have to make sure to not race with the victim exit path
	 * and cause premature new oom victim selection:
	 * __oom_reap_task_mm		exit_mm
	 *   mmget_not_zero
	 *				  mmput
	 *				    atomic_dec_and_test
	 *				  exit_oom_victim
	 *				[...]
	 *				out_of_memory
	 *				  select_bad_process
	 *				    # no TIF_MEMDIE task selects new victim
	 *  unmap_page_range # frees some memory
	 */
	mutex_lock(&oom_lock);

	if (!down_read_trylock(&mm->mmap_sem)) {
		ret = false;
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	/*
	 * If the mm has notifiers then we would need to invalidate them around
	 * unmap_page_range and that is risky because notifiers can sleep and
	 * what they do is basically undeterministic.  So let's have a short
	 * sleep to give the oom victim some more time.
	 * TODO: we really want to get rid of this ugly hack and make sure that
	 * notifiers cannot block for unbounded amount of time and add
	 * mmu_notifier_invalidate_range_{start,end} around unmap_page_range
	 */
	if (mm_has_notifiers(mm)) {
		up_read(&mm->mmap_sem);
		schedule_timeout_idle(HZ);
		goto unlock_oom;
	}

	/*
	 * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't
	 * work on the mm anymore. The check for MMF_OOM_SKIP must run
	 * under mmap_sem for reading because it serializes against the
	 * down_write();up_write() cycle in exit_mmap().
	 */
	if (test_bit(MMF_OOM_SKIP, &mm->flags)) {
		up_read(&mm->mmap_sem);
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	trace_start_task_reaping(tsk->pid);

	/*
	 * Tell all users of get_user/copy_from_user etc... that the content
	 * is no longer stable. No barriers really needed because unmapping
	 * should imply barriers already and the reader would hit a page fault
	 * if it stumbled over a reaped memory.
 	 */
 	set_bit(MMF_UNSTABLE, &mm->flags);
 
	tlb_gather_mmu(&tlb, mm, 0, -1);
 	for (vma = mm->mmap ; vma; vma = vma->vm_next) {
 		if (!can_madv_dontneed_vma(vma))
 			continue;

		/*
		 * Only anonymous pages have a good chance to be dropped
		 * without additional steps which we cannot afford as we
		 * are OOM already.
		 *
		 * We do not even care about fs backed pages because all
		 * which are reclaimable have already been reclaimed and
 		 * we do not want to block exit_mmap by keeping mm ref
 		 * count elevated without a good reason.
 		 */
		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))
 			unmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,
 					 NULL);
 	}
	tlb_finish_mmu(&tlb, 0, -1);
 	pr_info(""oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n"",
 			task_pid_nr(tsk), tsk->comm,
 			K(get_mm_counter(mm, MM_ANONPAGES)),
			K(get_mm_counter(mm, MM_FILEPAGES)),
			K(get_mm_counter(mm, MM_SHMEMPAGES)));
	up_read(&mm->mmap_sem);

	trace_finish_task_reaping(tsk->pid);
unlock_oom:
	mutex_unlock(&oom_lock);
	return ret;
}
",C,"		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {
			tlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);
			tlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);
		}
","	tlb_gather_mmu(&tlb, mm, 0, -1);
		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))
	tlb_finish_mmu(&tlb, 0, -1);
",,"@@ -550,7 +550,6 @@ static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
 	 */
 	set_bit(MMF_UNSTABLE, &mm->flags);
 
-	tlb_gather_mmu(&tlb, mm, 0, -1);
 	for (vma = mm->mmap ; vma; vma = vma->vm_next) {
 		if (!can_madv_dontneed_vma(vma))
 			continue;
@@ -565,11 +564,13 @@ static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
 		 * we do not want to block exit_mmap by keeping mm ref
 		 * count elevated without a good reason.
 		 */
-		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))
+		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {
+			tlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);
 			unmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,
 					 NULL);
+			tlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);
+		}
 	}
-	tlb_finish_mmu(&tlb, 0, -1);
 	pr_info(""oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n"",
 			task_pid_nr(tsk), tsk->comm,
 			K(get_mm_counter(mm, MM_ANONPAGES)),",linux,687cb0884a714ff484d038e9190edc874edcf146,4b81cb2ff69c8a8e297a147d2eb4d9b5e8d7c435,1,"static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
{
	struct mmu_gather tlb;
	struct vm_area_struct *vma;
	bool ret = true;

	/*
	 * We have to make sure to not race with the victim exit path
	 * and cause premature new oom victim selection:
	 * __oom_reap_task_mm		exit_mm
	 *   mmget_not_zero
	 *				  mmput
	 *				    atomic_dec_and_test
	 *				  exit_oom_victim
	 *				[...]
	 *				out_of_memory
	 *				  select_bad_process
	 *				    # no TIF_MEMDIE task selects new victim
	 *  unmap_page_range # frees some memory
	 */
	mutex_lock(&oom_lock);

	if (!down_read_trylock(&mm->mmap_sem)) {
		ret = false;
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	/*
	 * If the mm has notifiers then we would need to invalidate them around
	 * unmap_page_range and that is risky because notifiers can sleep and
	 * what they do is basically undeterministic.  So let's have a short
	 * sleep to give the oom victim some more time.
	 * TODO: we really want to get rid of this ugly hack and make sure that
	 * notifiers cannot block for unbounded amount of time and add
	 * mmu_notifier_invalidate_range_{start,end} around unmap_page_range
	 */
	if (mm_has_notifiers(mm)) {
		up_read(&mm->mmap_sem);
		schedule_timeout_idle(HZ);
		goto unlock_oom;
	}

	/*
	 * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't
	 * work on the mm anymore. The check for MMF_OOM_SKIP must run
	 * under mmap_sem for reading because it serializes against the
	 * down_write();up_write() cycle in exit_mmap().
	 */
	if (test_bit(MMF_OOM_SKIP, &mm->flags)) {
		up_read(&mm->mmap_sem);
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	trace_start_task_reaping(tsk->pid);

	/*
	 * Tell all users of get_user/copy_from_user etc... that the content
	 * is no longer stable. No barriers really needed because unmapping
	 * should imply barriers already and the reader would hit a page fault
	 * if it stumbled over a reaped memory.
 	 */
 	set_bit(MMF_UNSTABLE, &mm->flags);
 
//flaw_line_below:
	tlb_gather_mmu(&tlb, mm, 0, -1);
 	for (vma = mm->mmap ; vma; vma = vma->vm_next) {
 		if (!can_madv_dontneed_vma(vma))
 			continue;

		/*
		 * Only anonymous pages have a good chance to be dropped
		 * without additional steps which we cannot afford as we
		 * are OOM already.
		 *
		 * We do not even care about fs backed pages because all
		 * which are reclaimable have already been reclaimed and
 		 * we do not want to block exit_mmap by keeping mm ref
 		 * count elevated without a good reason.
 		 */
//flaw_line_below:
		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))
//fix_flaw_line_below:
//		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {
//fix_flaw_line_below:
//			tlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);
 			unmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,
 					 NULL);
//fix_flaw_line_below:
//			tlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);
//fix_flaw_line_below:
//		}
 	}
//flaw_line_below:
	tlb_finish_mmu(&tlb, 0, -1);
 	pr_info(""oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n"",
 			task_pid_nr(tsk), tsk->comm,
 			K(get_mm_counter(mm, MM_ANONPAGES)),
			K(get_mm_counter(mm, MM_FILEPAGES)),
			K(get_mm_counter(mm, MM_SHMEMPAGES)));
	up_read(&mm->mmap_sem);

	trace_finish_task_reaping(tsk->pid);
unlock_oom:
	mutex_unlock(&oom_lock);
	return ret;
}
",182584,"static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
{
	struct mmu_gather tlb;
	struct vm_area_struct *vma;
	bool ret = true;

	/*
	 * We have to make sure to not race with the victim exit path
	 * and cause premature new oom victim selection:
	 * __oom_reap_task_mm		exit_mm
	 *   mmget_not_zero
	 *				  mmput
	 *				    atomic_dec_and_test
	 *				  exit_oom_victim
	 *				[...]
	 *				out_of_memory
	 *				  select_bad_process
	 *				    # no TIF_MEMDIE task selects new victim
	 *  unmap_page_range # frees some memory
	 */
	mutex_lock(&oom_lock);

	if (!down_read_trylock(&mm->mmap_sem)) {
		ret = false;
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	/*
	 * If the mm has notifiers then we would need to invalidate them around
	 * unmap_page_range and that is risky because notifiers can sleep and
	 * what they do is basically undeterministic.  So let's have a short
	 * sleep to give the oom victim some more time.
	 * TODO: we really want to get rid of this ugly hack and make sure that
	 * notifiers cannot block for unbounded amount of time and add
	 * mmu_notifier_invalidate_range_{start,end} around unmap_page_range
	 */
	if (mm_has_notifiers(mm)) {
		up_read(&mm->mmap_sem);
		schedule_timeout_idle(HZ);
		goto unlock_oom;
	}

	/*
	 * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't
	 * work on the mm anymore. The check for MMF_OOM_SKIP must run
	 * under mmap_sem for reading because it serializes against the
	 * down_write();up_write() cycle in exit_mmap().
	 */
	if (test_bit(MMF_OOM_SKIP, &mm->flags)) {
		up_read(&mm->mmap_sem);
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	trace_start_task_reaping(tsk->pid);

	/*
	 * Tell all users of get_user/copy_from_user etc... that the content
	 * is no longer stable. No barriers really needed because unmapping
	 * should imply barriers already and the reader would hit a page fault
	 * if it stumbled over a reaped memory.
 	 */
 	set_bit(MMF_UNSTABLE, &mm->flags);
 
	tlb_gather_mmu(&tlb, mm, 0, -1);
 	for (vma = mm->mmap ; vma; vma = vma->vm_next) {
 		if (!can_madv_dontneed_vma(vma))
 			continue;

		/*
		 * Only anonymous pages have a good chance to be dropped
		 * without additional steps which we cannot afford as we
		 * are OOM already.
		 *
		 * We do not even care about fs backed pages because all
		 * which are reclaimable have already been reclaimed and
 		 * we do not want to block exit_mmap by keeping mm ref
 		 * count elevated without a good reason.
 		 */
		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))
 			unmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,
 					 NULL);
 	}
	tlb_finish_mmu(&tlb, 0, -1);
 	pr_info(""oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n"",
 			task_pid_nr(tsk), tsk->comm,
 			K(get_mm_counter(mm, MM_ANONPAGES)),
			K(get_mm_counter(mm, MM_FILEPAGES)),
			K(get_mm_counter(mm, MM_SHMEMPAGES)));
	up_read(&mm->mmap_sem);

	trace_finish_task_reaping(tsk->pid);
unlock_oom:
	mutex_unlock(&oom_lock);
	return ret;
}
","static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
{
	struct mmu_gather tlb;
	struct vm_area_struct *vma;
	bool ret = true;

	/*
	 * We have to make sure to not race with the victim exit path
	 * and cause premature new oom victim selection:
	 * __oom_reap_task_mm		exit_mm
	 *   mmget_not_zero
	 *				  mmput
	 *				    atomic_dec_and_test
	 *				  exit_oom_victim
	 *				[...]
	 *				out_of_memory
	 *				  select_bad_process
	 *				    # no TIF_MEMDIE task selects new victim
	 *  unmap_page_range # frees some memory
	 */
	mutex_lock(&oom_lock);

	if (!down_read_trylock(&mm->mmap_sem)) {
		ret = false;
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	/*
	 * If the mm has notifiers then we would need to invalidate them around
	 * unmap_page_range and that is risky because notifiers can sleep and
	 * what they do is basically undeterministic.  So let's have a short
	 * sleep to give the oom victim some more time.
	 * TODO: we really want to get rid of this ugly hack and make sure that
	 * notifiers cannot block for unbounded amount of time and add
	 * mmu_notifier_invalidate_range_{start,end} around unmap_page_range
	 */
	if (mm_has_notifiers(mm)) {
		up_read(&mm->mmap_sem);
		schedule_timeout_idle(HZ);
		goto unlock_oom;
	}

	/*
	 * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't
	 * work on the mm anymore. The check for MMF_OOM_SKIP must run
	 * under mmap_sem for reading because it serializes against the
	 * down_write();up_write() cycle in exit_mmap().
	 */
	if (test_bit(MMF_OOM_SKIP, &mm->flags)) {
		up_read(&mm->mmap_sem);
		trace_skip_task_reaping(tsk->pid);
		goto unlock_oom;
	}

	trace_start_task_reaping(tsk->pid);

	/*
	 * Tell all users of get_user/copy_from_user etc... that the content
	 * is no longer stable. No barriers really needed because unmapping
	 * should imply barriers already and the reader would hit a page fault
	 * if it stumbled over a reaped memory.
 	 */
 	set_bit(MMF_UNSTABLE, &mm->flags);
 
 	for (vma = mm->mmap ; vma; vma = vma->vm_next) {
 		if (!can_madv_dontneed_vma(vma))
 			continue;

		/*
		 * Only anonymous pages have a good chance to be dropped
		 * without additional steps which we cannot afford as we
		 * are OOM already.
		 *
		 * We do not even care about fs backed pages because all
		 * which are reclaimable have already been reclaimed and
 		 * we do not want to block exit_mmap by keeping mm ref
 		 * count elevated without a good reason.
 		 */
		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {
			tlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);
 			unmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,
 					 NULL);
			tlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);
		}
 	}
 	pr_info(""oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n"",
 			task_pid_nr(tsk), tsk->comm,
 			K(get_mm_counter(mm, MM_ANONPAGES)),
			K(get_mm_counter(mm, MM_FILEPAGES)),
			K(get_mm_counter(mm, MM_SHMEMPAGES)));
	up_read(&mm->mmap_sem);

	trace_finish_task_reaping(tsk->pid);
unlock_oom:
	mutex_unlock(&oom_lock);
	return ret;
}
","The `__oom_reap_task_mm` function is designed to manage memory cleanup for a task that has been selected as an Out-Of-Memory (OOM) victim in a Linux kernel environment. It first acquires a mutex lock to prevent race conditions with the task's exit path. The function attempts to read-lock the memory management structure (`mm`) of the task; if unsuccessful, it skips reaping. It checks for memory notifiers and the OOM skip flag, delaying if necessary. If conditions permit, it marks the memory as unstable and iterates through the virtual memory areas (VMAs) to unmap anonymous or non-shared pages, ultimately logging the memory statistics before releasing the lock.","The provided code implements a mechanism to reclaim memory from a process identified as an Out-Of-Memory victim in a kernel environment. It ensures safe access to the process's memory management structure while preventing conflicts with the process's exit operations. The function checks for conditions that would prevent memory reaping, such as active memory notifiers or flags indicating the process should not be reaped. If conditions allow, it marks the memory as unstable and proceeds to unmap specific types of memory pages, ultimately logging the memory usage statistics before releasing the lock and completing the operation.","The vulnerability in the original code stemmed from the potential for TLB (Translation Lookaside Buffer) entries to leak on certain architectures, such as arm64, when the entire virtual memory space was gathered for flushing. This could lead to a situation where other threads could access freed memory pages without generating a page fault, resulting in use-after-free bugs during operations like `copy_to_user()`. The fix involved changing the approach to gather each individual virtual memory area instead of the entire memory space, ensuring that TLB entries are properly managed and reducing the risk of accessing invalid memory, thus enhancing safety across all architectures.","The vulnerability in the original code arose from the potential for TLB entries to remain valid even after memory pages were freed, particularly on certain architectures where flushing the TLB was not guaranteed when the entire virtual memory space was gathered. This could lead to scenarios where other threads could access these freed pages, resulting in use-after-free errors during operations that did not trigger a page fault. The fix involved modifying the approach to gather memory areas individually rather than the entire space, ensuring that TLB entries were properly managed and reducing the risk of accessing invalid memory, thus enhancing overall safety.","The vulnerability was fixed by changing the memory management approach from gathering the entire virtual memory space using `tlb_gather_mmu(&tlb, mm, 0, -1)` to gathering each individual virtual memory area (VMA) instead. This adjustment ensured that the `tlb->fullmm` flag remained false, allowing for proper TLB management and preventing the leakage of TLB entries. By iterating through each VMA and using `unmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end, NULL)`, the code now behaves similarly to safe unmapping operations, effectively mitigating the risk of accessing freed memory and preventing potential use-after-free bugs.","The vulnerability was addressed by altering the memory management strategy to focus on individual memory areas rather than the entire memory space at once. This change ensured that the system did not retain potentially invalid entries in the translation cache, which could lead to other threads accessing freed memory. By processing each memory area separately, the code effectively managed memory cleanup in a way that minimized the risk of accessing invalid memory, thereby preventing use-after-free errors and enhancing overall system stability and safety during memory reclamation operations.","CWE-416, CWE-825, CWE-415, CWE-119, CWE-763, CWE-401, CWE-404, CWE-665, CWE-400, CWE-459",Y,1
52,52,182598,182598,,Remote,Not required,Complete,CVE-2017-18017,https://www.cvedetails.com/cve/CVE-2017-18017/,CWE-416,Low,Complete,Complete,,2018-01-03,10.0,"The tcpmss_mangle_packet function in net/netfilter/xt_TCPMSS.c in the Linux kernel before 4.11, and 4.9.x before 4.9.36, allows remote attackers to cause a denial of service (use-after-free and memory corruption) or possibly have unspecified other impact by leveraging the presence of xt_TCPMSS in an iptables action.",2018-11-30,DoS Mem. Corr. ,5,https://github.com/torvalds/linux/commit/2638fd0f92d4397884fd991d8f4925cb3f081901,2638fd0f92d4397884fd991d8f4925cb3f081901,"netfilter: xt_TCPMSS: add more sanity tests on tcph->doff

Denys provided an awesome KASAN report pointing to an use
after free in xt_TCPMSS

I have provided three patches to fix this issue, either in xt_TCPMSS or
in xt_tcpudp.c. It seems xt_TCPMSS patch has the smallest possible
impact.

Signed-off-by: Eric Dumazet <edumazet@google.com>
Reported-by: Denys Fedoryshchenko <nuclearcat@nuclearcat.com>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",1,net/netfilter/xt_TCPMSS.c,"{""sha"": ""c64aca611ac5c5f81ad7c925652bbb90554763ac"", ""filename"": ""net/netfilter/xt_TCPMSS.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/2638fd0f92d4397884fd991d8f4925cb3f081901/net/netfilter/xt_TCPMSS.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/2638fd0f92d4397884fd991d8f4925cb3f081901/net/netfilter/xt_TCPMSS.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/netfilter/xt_TCPMSS.c?ref=2638fd0f92d4397884fd991d8f4925cb3f081901"", ""patch"": ""@@ -104,7 +104,7 @@ tcpmss_mangle_packet(struct sk_buff *skb,\n \ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n \ttcp_hdrlen = tcph->doff * 4;\n \n-\tif (len < tcp_hdrlen)\n+\tif (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))\n \t\treturn -1;\n \n \tif (info->mss == XT_TCPMSS_CLAMP_PMTU) {\n@@ -152,6 +152,10 @@ tcpmss_mangle_packet(struct sk_buff *skb,\n \tif (len > tcp_hdrlen)\n \t\treturn 0;\n \n+\t/* tcph->doff has 4 bits, do not wrap it to 0 */\n+\tif (tcp_hdrlen >= 15 * 4)\n+\t\treturn 0;\n+\n \t/*\n \t * MSS Option not found ?! add it..\n \t */""}","tcpmss_mangle_packet(struct sk_buff *skb,
		     const struct xt_action_param *par,
		     unsigned int family,
		     unsigned int tcphoff,
		     unsigned int minlen)
{
	const struct xt_tcpmss_info *info = par->targinfo;
	struct tcphdr *tcph;
	int len, tcp_hdrlen;
	unsigned int i;
	__be16 oldval;
	u16 newmss;
	u8 *opt;

	/* This is a fragment, no TCP header is available */
	if (par->fragoff != 0)
		return 0;

	if (!skb_make_writable(skb, skb->len))
		return -1;

	len = skb->len - tcphoff;
	if (len < (int)sizeof(struct tcphdr))
		return -1;

 	tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
 	tcp_hdrlen = tcph->doff * 4;
 
	if (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))
 		return -1;
 
 	if (info->mss == XT_TCPMSS_CLAMP_PMTU) {
		struct net *net = xt_net(par);
		unsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);
		unsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);

		if (min_mtu <= minlen) {
			net_err_ratelimited(""unknown or invalid path-MTU (%u)\n"",
					    min_mtu);
			return -1;
		}
		newmss = min_mtu - minlen;
	} else
		newmss = info->mss;

	opt = (u_int8_t *)tcph;
	for (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {
		if (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {
			u_int16_t oldmss;

			oldmss = (opt[i+2] << 8) | opt[i+3];

			/* Never increase MSS, even when setting it, as
			 * doing so results in problems for hosts that rely
			 * on MSS being set correctly.
			 */
			if (oldmss <= newmss)
				return 0;

			opt[i+2] = (newmss & 0xff00) >> 8;
			opt[i+3] = newmss & 0x00ff;

			inet_proto_csum_replace2(&tcph->check, skb,
						 htons(oldmss), htons(newmss),
						 false);
			return 0;
		}
	}

	/* There is data after the header so the option can't be added
	 * without moving it, and doing so may make the SYN packet
	 * itself too large. Accept the packet unmodified instead.
	 */
 	if (len > tcp_hdrlen)
 		return 0;
 
	/* tcph->doff has 4 bits, do not wrap it to 0 */
	if (tcp_hdrlen >= 15 * 4)
		return 0;

 	/*
 	 * MSS Option not found ?! add it..
 	 */
	if (skb_tailroom(skb) < TCPOLEN_MSS) {
		if (pskb_expand_head(skb, 0,
				     TCPOLEN_MSS - skb_tailroom(skb),
				     GFP_ATOMIC))
			return -1;
		tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
	}

	skb_put(skb, TCPOLEN_MSS);

	/*
	 * IPv4: RFC 1122 states ""If an MSS option is not received at
	 * connection setup, TCP MUST assume a default send MSS of 536"".
	 * IPv6: RFC 2460 states IPv6 has a minimum MTU of 1280 and a minimum
	 * length IPv6 header of 60, ergo the default MSS value is 1220
	 * Since no MSS was provided, we must use the default values
	 */
	if (xt_family(par) == NFPROTO_IPV4)
		newmss = min(newmss, (u16)536);
	else
		newmss = min(newmss, (u16)1220);

	opt = (u_int8_t *)tcph + sizeof(struct tcphdr);
	memmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));

	inet_proto_csum_replace2(&tcph->check, skb,
				 htons(len), htons(len + TCPOLEN_MSS), true);
	opt[0] = TCPOPT_MSS;
	opt[1] = TCPOLEN_MSS;
	opt[2] = (newmss & 0xff00) >> 8;
	opt[3] = newmss & 0x00ff;

	inet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);

	oldval = ((__be16 *)tcph)[6];
	tcph->doff += TCPOLEN_MSS/4;
	inet_proto_csum_replace2(&tcph->check, skb,
				 oldval, ((__be16 *)tcph)[6], false);
	return TCPOLEN_MSS;
}
","tcpmss_mangle_packet(struct sk_buff *skb,
		     const struct xt_action_param *par,
		     unsigned int family,
		     unsigned int tcphoff,
		     unsigned int minlen)
{
	const struct xt_tcpmss_info *info = par->targinfo;
	struct tcphdr *tcph;
	int len, tcp_hdrlen;
	unsigned int i;
	__be16 oldval;
	u16 newmss;
	u8 *opt;

	/* This is a fragment, no TCP header is available */
	if (par->fragoff != 0)
		return 0;

	if (!skb_make_writable(skb, skb->len))
		return -1;

	len = skb->len - tcphoff;
	if (len < (int)sizeof(struct tcphdr))
		return -1;

 	tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
 	tcp_hdrlen = tcph->doff * 4;
 
	if (len < tcp_hdrlen)
 		return -1;
 
 	if (info->mss == XT_TCPMSS_CLAMP_PMTU) {
		struct net *net = xt_net(par);
		unsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);
		unsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);

		if (min_mtu <= minlen) {
			net_err_ratelimited(""unknown or invalid path-MTU (%u)\n"",
					    min_mtu);
			return -1;
		}
		newmss = min_mtu - minlen;
	} else
		newmss = info->mss;

	opt = (u_int8_t *)tcph;
	for (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {
		if (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {
			u_int16_t oldmss;

			oldmss = (opt[i+2] << 8) | opt[i+3];

			/* Never increase MSS, even when setting it, as
			 * doing so results in problems for hosts that rely
			 * on MSS being set correctly.
			 */
			if (oldmss <= newmss)
				return 0;

			opt[i+2] = (newmss & 0xff00) >> 8;
			opt[i+3] = newmss & 0x00ff;

			inet_proto_csum_replace2(&tcph->check, skb,
						 htons(oldmss), htons(newmss),
						 false);
			return 0;
		}
	}

	/* There is data after the header so the option can't be added
	 * without moving it, and doing so may make the SYN packet
	 * itself too large. Accept the packet unmodified instead.
	 */
 	if (len > tcp_hdrlen)
 		return 0;
 
 	/*
 	 * MSS Option not found ?! add it..
 	 */
	if (skb_tailroom(skb) < TCPOLEN_MSS) {
		if (pskb_expand_head(skb, 0,
				     TCPOLEN_MSS - skb_tailroom(skb),
				     GFP_ATOMIC))
			return -1;
		tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
	}

	skb_put(skb, TCPOLEN_MSS);

	/*
	 * IPv4: RFC 1122 states ""If an MSS option is not received at
	 * connection setup, TCP MUST assume a default send MSS of 536"".
	 * IPv6: RFC 2460 states IPv6 has a minimum MTU of 1280 and a minimum
	 * length IPv6 header of 60, ergo the default MSS value is 1220
	 * Since no MSS was provided, we must use the default values
	 */
	if (xt_family(par) == NFPROTO_IPV4)
		newmss = min(newmss, (u16)536);
	else
		newmss = min(newmss, (u16)1220);

	opt = (u_int8_t *)tcph + sizeof(struct tcphdr);
	memmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));

	inet_proto_csum_replace2(&tcph->check, skb,
				 htons(len), htons(len + TCPOLEN_MSS), true);
	opt[0] = TCPOPT_MSS;
	opt[1] = TCPOLEN_MSS;
	opt[2] = (newmss & 0xff00) >> 8;
	opt[3] = newmss & 0x00ff;

	inet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);

	oldval = ((__be16 *)tcph)[6];
	tcph->doff += TCPOLEN_MSS/4;
	inet_proto_csum_replace2(&tcph->check, skb,
				 oldval, ((__be16 *)tcph)[6], false);
	return TCPOLEN_MSS;
}
",C,"	if (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))
	/* tcph->doff has 4 bits, do not wrap it to 0 */
	if (tcp_hdrlen >= 15 * 4)
		return 0;

","	if (len < tcp_hdrlen)
",,"@@ -104,7 +104,7 @@ tcpmss_mangle_packet(struct sk_buff *skb,
 	tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
 	tcp_hdrlen = tcph->doff * 4;
 
-	if (len < tcp_hdrlen)
+	if (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))
 		return -1;
 
 	if (info->mss == XT_TCPMSS_CLAMP_PMTU) {
@@ -152,6 +152,10 @@ tcpmss_mangle_packet(struct sk_buff *skb,
 	if (len > tcp_hdrlen)
 		return 0;
 
+	/* tcph->doff has 4 bits, do not wrap it to 0 */
+	if (tcp_hdrlen >= 15 * 4)
+		return 0;
+
 	/*
 	 * MSS Option not found ?! add it..
 	 */",linux,2638fd0f92d4397884fd991d8f4925cb3f081901,0b9aefea860063bb39e36bd7fe6c7087fed0ba87,1,"tcpmss_mangle_packet(struct sk_buff *skb,
		     const struct xt_action_param *par,
		     unsigned int family,
		     unsigned int tcphoff,
		     unsigned int minlen)
{
	const struct xt_tcpmss_info *info = par->targinfo;
	struct tcphdr *tcph;
	int len, tcp_hdrlen;
	unsigned int i;
	__be16 oldval;
	u16 newmss;
	u8 *opt;

	/* This is a fragment, no TCP header is available */
	if (par->fragoff != 0)
		return 0;

	if (!skb_make_writable(skb, skb->len))
		return -1;

	len = skb->len - tcphoff;
	if (len < (int)sizeof(struct tcphdr))
		return -1;

 	tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
 	tcp_hdrlen = tcph->doff * 4;
 
//flaw_line_below:
	if (len < tcp_hdrlen)
//fix_flaw_line_below:
//	if (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))
 		return -1;
 
 	if (info->mss == XT_TCPMSS_CLAMP_PMTU) {
		struct net *net = xt_net(par);
		unsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);
		unsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);

		if (min_mtu <= minlen) {
			net_err_ratelimited(""unknown or invalid path-MTU (%u)\n"",
					    min_mtu);
			return -1;
		}
		newmss = min_mtu - minlen;
	} else
		newmss = info->mss;

	opt = (u_int8_t *)tcph;
	for (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {
		if (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {
			u_int16_t oldmss;

			oldmss = (opt[i+2] << 8) | opt[i+3];

			/* Never increase MSS, even when setting it, as
			 * doing so results in problems for hosts that rely
			 * on MSS being set correctly.
			 */
			if (oldmss <= newmss)
				return 0;

			opt[i+2] = (newmss & 0xff00) >> 8;
			opt[i+3] = newmss & 0x00ff;

			inet_proto_csum_replace2(&tcph->check, skb,
						 htons(oldmss), htons(newmss),
						 false);
			return 0;
		}
	}

	/* There is data after the header so the option can't be added
	 * without moving it, and doing so may make the SYN packet
	 * itself too large. Accept the packet unmodified instead.
	 */
 	if (len > tcp_hdrlen)
 		return 0;
 
//fix_flaw_line_below:
//	/* tcph->doff has 4 bits, do not wrap it to 0 */
//fix_flaw_line_below:
//	if (tcp_hdrlen >= 15 * 4)
//fix_flaw_line_below:
//		return 0;
//fix_flaw_line_below:
//
 	/*
 	 * MSS Option not found ?! add it..
 	 */
	if (skb_tailroom(skb) < TCPOLEN_MSS) {
		if (pskb_expand_head(skb, 0,
				     TCPOLEN_MSS - skb_tailroom(skb),
				     GFP_ATOMIC))
			return -1;
		tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
	}

	skb_put(skb, TCPOLEN_MSS);

	/*
	 * IPv4: RFC 1122 states ""If an MSS option is not received at
	 * connection setup, TCP MUST assume a default send MSS of 536"".
	 * IPv6: RFC 2460 states IPv6 has a minimum MTU of 1280 and a minimum
	 * length IPv6 header of 60, ergo the default MSS value is 1220
	 * Since no MSS was provided, we must use the default values
	 */
	if (xt_family(par) == NFPROTO_IPV4)
		newmss = min(newmss, (u16)536);
	else
		newmss = min(newmss, (u16)1220);

	opt = (u_int8_t *)tcph + sizeof(struct tcphdr);
	memmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));

	inet_proto_csum_replace2(&tcph->check, skb,
				 htons(len), htons(len + TCPOLEN_MSS), true);
	opt[0] = TCPOPT_MSS;
	opt[1] = TCPOLEN_MSS;
	opt[2] = (newmss & 0xff00) >> 8;
	opt[3] = newmss & 0x00ff;

	inet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);

	oldval = ((__be16 *)tcph)[6];
	tcph->doff += TCPOLEN_MSS/4;
	inet_proto_csum_replace2(&tcph->check, skb,
				 oldval, ((__be16 *)tcph)[6], false);
	return TCPOLEN_MSS;
}
",182598,"tcpmss_mangle_packet(struct sk_buff *skb,
		     const struct xt_action_param *par,
		     unsigned int family,
		     unsigned int tcphoff,
		     unsigned int minlen)
{
	const struct xt_tcpmss_info *info = par->targinfo;
	struct tcphdr *tcph;
	int len, tcp_hdrlen;
	unsigned int i;
	__be16 oldval;
	u16 newmss;
	u8 *opt;

	/* This is a fragment, no TCP header is available */
	if (par->fragoff != 0)
		return 0;

	if (!skb_make_writable(skb, skb->len))
		return -1;

	len = skb->len - tcphoff;
	if (len < (int)sizeof(struct tcphdr))
		return -1;

 	tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
 	tcp_hdrlen = tcph->doff * 4;
 
	if (len < tcp_hdrlen)
 		return -1;
 
 	if (info->mss == XT_TCPMSS_CLAMP_PMTU) {
		struct net *net = xt_net(par);
		unsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);
		unsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);

		if (min_mtu <= minlen) {
			net_err_ratelimited(""unknown or invalid path-MTU (%u)\n"",
					    min_mtu);
			return -1;
		}
		newmss = min_mtu - minlen;
	} else
		newmss = info->mss;

	opt = (u_int8_t *)tcph;
	for (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {
		if (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {
			u_int16_t oldmss;

			oldmss = (opt[i+2] << 8) | opt[i+3];

			/* Never increase MSS, even when setting it, as
			 * doing so results in problems for hosts that rely
			 * on MSS being set correctly.
			 */
			if (oldmss <= newmss)
				return 0;

			opt[i+2] = (newmss & 0xff00) >> 8;
			opt[i+3] = newmss & 0x00ff;

			inet_proto_csum_replace2(&tcph->check, skb,
						 htons(oldmss), htons(newmss),
						 false);
			return 0;
		}
	}

	/* There is data after the header so the option can't be added
	 * without moving it, and doing so may make the SYN packet
	 * itself too large. Accept the packet unmodified instead.
	 */
 	if (len > tcp_hdrlen)
 		return 0;
 
 	/*
 	 * MSS Option not found ?! add it..
 	 */
	if (skb_tailroom(skb) < TCPOLEN_MSS) {
		if (pskb_expand_head(skb, 0,
				     TCPOLEN_MSS - skb_tailroom(skb),
				     GFP_ATOMIC))
			return -1;
		tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
	}

	skb_put(skb, TCPOLEN_MSS);

	/*
	 * IPv4: RFC 1122 states ""If an MSS option is not received at
	 * connection setup, TCP MUST assume a default send MSS of 536"".
	 * IPv6: RFC 2460 states IPv6 has a minimum MTU of 1280 and a minimum
	 * length IPv6 header of 60, ergo the default MSS value is 1220
	 * Since no MSS was provided, we must use the default values
	 */
	if (xt_family(par) == NFPROTO_IPV4)
		newmss = min(newmss, (u16)536);
	else
		newmss = min(newmss, (u16)1220);

	opt = (u_int8_t *)tcph + sizeof(struct tcphdr);
	memmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));

	inet_proto_csum_replace2(&tcph->check, skb,
				 htons(len), htons(len + TCPOLEN_MSS), true);
	opt[0] = TCPOPT_MSS;
	opt[1] = TCPOLEN_MSS;
	opt[2] = (newmss & 0xff00) >> 8;
	opt[3] = newmss & 0x00ff;

	inet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);

	oldval = ((__be16 *)tcph)[6];
	tcph->doff += TCPOLEN_MSS/4;
	inet_proto_csum_replace2(&tcph->check, skb,
				 oldval, ((__be16 *)tcph)[6], false);
	return TCPOLEN_MSS;
}
","tcpmss_mangle_packet(struct sk_buff *skb,
		     const struct xt_action_param *par,
		     unsigned int family,
		     unsigned int tcphoff,
		     unsigned int minlen)
{
	const struct xt_tcpmss_info *info = par->targinfo;
	struct tcphdr *tcph;
	int len, tcp_hdrlen;
	unsigned int i;
	__be16 oldval;
	u16 newmss;
	u8 *opt;

	/* This is a fragment, no TCP header is available */
	if (par->fragoff != 0)
		return 0;

	if (!skb_make_writable(skb, skb->len))
		return -1;

	len = skb->len - tcphoff;
	if (len < (int)sizeof(struct tcphdr))
		return -1;

 	tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
 	tcp_hdrlen = tcph->doff * 4;
 
	if (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))
 		return -1;
 
 	if (info->mss == XT_TCPMSS_CLAMP_PMTU) {
		struct net *net = xt_net(par);
		unsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);
		unsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);

		if (min_mtu <= minlen) {
			net_err_ratelimited(""unknown or invalid path-MTU (%u)\n"",
					    min_mtu);
			return -1;
		}
		newmss = min_mtu - minlen;
	} else
		newmss = info->mss;

	opt = (u_int8_t *)tcph;
	for (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {
		if (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {
			u_int16_t oldmss;

			oldmss = (opt[i+2] << 8) | opt[i+3];

			/* Never increase MSS, even when setting it, as
			 * doing so results in problems for hosts that rely
			 * on MSS being set correctly.
			 */
			if (oldmss <= newmss)
				return 0;

			opt[i+2] = (newmss & 0xff00) >> 8;
			opt[i+3] = newmss & 0x00ff;

			inet_proto_csum_replace2(&tcph->check, skb,
						 htons(oldmss), htons(newmss),
						 false);
			return 0;
		}
	}

	/* There is data after the header so the option can't be added
	 * without moving it, and doing so may make the SYN packet
	 * itself too large. Accept the packet unmodified instead.
	 */
 	if (len > tcp_hdrlen)
 		return 0;
 
	/* tcph->doff has 4 bits, do not wrap it to 0 */
	if (tcp_hdrlen >= 15 * 4)
		return 0;

 	/*
 	 * MSS Option not found ?! add it..
 	 */
	if (skb_tailroom(skb) < TCPOLEN_MSS) {
		if (pskb_expand_head(skb, 0,
				     TCPOLEN_MSS - skb_tailroom(skb),
				     GFP_ATOMIC))
			return -1;
		tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
	}

	skb_put(skb, TCPOLEN_MSS);

	/*
	 * IPv4: RFC 1122 states ""If an MSS option is not received at
	 * connection setup, TCP MUST assume a default send MSS of 536"".
	 * IPv6: RFC 2460 states IPv6 has a minimum MTU of 1280 and a minimum
	 * length IPv6 header of 60, ergo the default MSS value is 1220
	 * Since no MSS was provided, we must use the default values
	 */
	if (xt_family(par) == NFPROTO_IPV4)
		newmss = min(newmss, (u16)536);
	else
		newmss = min(newmss, (u16)1220);

	opt = (u_int8_t *)tcph + sizeof(struct tcphdr);
	memmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));

	inet_proto_csum_replace2(&tcph->check, skb,
				 htons(len), htons(len + TCPOLEN_MSS), true);
	opt[0] = TCPOPT_MSS;
	opt[1] = TCPOLEN_MSS;
	opt[2] = (newmss & 0xff00) >> 8;
	opt[3] = newmss & 0x00ff;

	inet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);

	oldval = ((__be16 *)tcph)[6];
	tcph->doff += TCPOLEN_MSS/4;
	inet_proto_csum_replace2(&tcph->check, skb,
				 oldval, ((__be16 *)tcph)[6], false);
	return TCPOLEN_MSS;
}
","The `tcpmss_mangle_packet` function modifies the Maximum Segment Size (MSS) option in TCP packets within the Linux kernel networking stack. It first checks if the packet is a fragment or if the TCP header is available. If the MSS option is present, it updates it based on the specified conditions, ensuring that the new MSS does not exceed the old value. If the MSS option is absent, it adds it while considering the minimum transmission unit (MTU) constraints. The function also adjusts the TCP checksum accordingly and handles memory allocation for the packet if necessary, returning the size of the added MSS option or an error code.","The provided code modifies the Maximum Segment Size (MSS) option in TCP packets within the networking stack of the Linux kernel. It checks for packet fragmentation and the presence of a TCP header before determining the appropriate MSS value based on network conditions. If the MSS option is found, it updates it if the new value is smaller; if absent, it adds the option while ensuring sufficient space in the packet. The code also recalculates the TCP checksum to maintain data integrity, returning the size of the added option or an error code if issues arise.","The vulnerability in the original code stemmed from insufficient validation of the TCP header length, specifically the `doff` field, which could lead to a use-after-free condition. If the TCP header length was incorrectly set, the code could attempt to access memory beyond the allocated space, causing potential crashes or security issues. The fix introduced additional sanity checks to ensure that the TCP header length is valid and does not exceed a certain limit, preventing the code from processing packets with invalid header lengths and thereby mitigating the risk of memory access violations.","The vulnerability in the original code was due to inadequate validation of the TCP header length, which could lead to accessing memory that had already been freed, resulting in a use-after-free condition. This flaw was highlighted in a report that indicated potential crashes or security breaches. The fix involved implementing additional sanity checks to ensure that the TCP header length was within acceptable limits, thereby preventing the code from processing packets with invalid header lengths. This enhancement effectively mitigated the risk of memory access violations and improved the overall stability and security of the code.","The vulnerability was fixed by adding sanity checks for the `doff` field of the TCP header to ensure it does not exceed a specified limit. In the updated code, a condition was introduced to verify that the calculated TCP header length is less than a maximum value, preventing the processing of packets with invalid header lengths. Specifically, the check `if (tcp_hdrlen >= 15 * 4)` was added to return early if the header length is too large. This change ensures that the code does not attempt to access memory beyond the allocated space, thus mitigating the use-after-free issue.","The vulnerability was addressed by implementing additional checks to validate the length of the TCP header, ensuring it remains within acceptable limits. By introducing a condition that verifies the header length does not exceed a predefined maximum, the code prevents the processing of packets with potentially invalid or excessive header sizes. This proactive measure ensures that the code does not access memory beyond the allocated space, effectively mitigating the risk of memory access violations and enhancing the overall stability and security of the system. The changes help prevent scenarios that could lead to crashes or exploitation.","CWE-789,CWE-130,CWE-131,CWE-119,CWE-120,CWE-680,CWE-789,CWE-805,CWE-129,CWE-20",N,-1
53,53,182599,182599,,Local,Not required,Complete,CVE-2017-15129,https://www.cvedetails.com/cve/CVE-2017-15129/,CWE-416,Low,,,,2018-01-09,4.9,"A use-after-free vulnerability was found in network namespaces code affecting the Linux kernel before 4.14.11. The function get_net_ns_by_id() in net/core/net_namespace.c does not check for the net::count value after it has found a peer network in netns_ids idr, which could lead to double free and memory corruption. This vulnerability could allow an unprivileged local user to induce kernel memory corruption on the system, leading to a crash. Due to the nature of the flaw, privilege escalation cannot be fully ruled out, although it is thought to be unlikely.",2018-05-03,Mem. Corr. ,1,https://github.com/torvalds/linux/commit/21b5944350052d2583e82dd59b19a9ba94a007f0,21b5944350052d2583e82dd59b19a9ba94a007f0,"net: Fix double free and memory corruption in get_net_ns_by_id()

(I can trivially verify that that idr_remove in cleanup_net happens
 after the network namespace count has dropped to zero --EWB)

Function get_net_ns_by_id() does not check for net::count
after it has found a peer in netns_ids idr.

It may dereference a peer, after its count has already been
finaly decremented. This leads to double free and memory
corruption:

put_net(peer)                                   rtnl_lock()
atomic_dec_and_test(&peer->count) [count=0]     ...
__put_net(peer)                                 get_net_ns_by_id(net, id)
  spin_lock(&cleanup_list_lock)
  list_add(&net->cleanup_list, &cleanup_list)
  spin_unlock(&cleanup_list_lock)
queue_work()                                      peer = idr_find(&net->netns_ids, id)
  |                                               get_net(peer) [count=1]
  |                                               ...
  |                                               (use after final put)
  v                                               ...
  cleanup_net()                                   ...
    spin_lock(&cleanup_list_lock)                 ...
    list_replace_init(&cleanup_list, ..)          ...
    spin_unlock(&cleanup_list_lock)               ...
    ...                                           ...
    ...                                           put_net(peer)
    ...                                             atomic_dec_and_test(&peer->count) [count=0]
    ...                                               spin_lock(&cleanup_list_lock)
    ...                                               list_add(&net->cleanup_list, &cleanup_list)
    ...                                               spin_unlock(&cleanup_list_lock)
    ...                                             queue_work()
    ...                                           rtnl_unlock()
    rtnl_lock()                                   ...
    for_each_net(tmp) {                           ...
      id = __peernet2id(tmp, peer)                ...
      spin_lock_irq(&tmp->nsid_lock)              ...
      idr_remove(&tmp->netns_ids, id)             ...
      ...                                         ...
      net_drop_ns()                               ...
	net_free(peer)                            ...
    }                                             ...
  |
  v
  cleanup_net()
    ...
    (Second free of peer)

Also, put_net() on the right cpu may reorder with left's cpu
list_replace_init(&cleanup_list, ..), and then cleanup_list
will be corrupted.

Since cleanup_net() is executed in worker thread, while
put_net(peer) can happen everywhere, there should be
enough time for concurrent get_net_ns_by_id() to pick
the peer up, and the race does not seem to be unlikely.
The patch fixes the problem in standard way.

(Also, there is possible problem in peernet2id_alloc(), which requires
check for net::count under nsid_lock and maybe_get_net(peer), but
in current stable kernel it's used under rtnl_lock() and it has to be
safe. Openswitch begun to use peernet2id_alloc(), and possibly it should
be fixed too. While this is not in stable kernel yet, so I'll send
a separate message to netdev@ later).

Cc: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Signed-off-by: Kirill Tkhai <ktkhai@virtuozzo.com>
Fixes: 0c7aecd4bde4 ""netns: add rtnl cmd to add and get peer netns ids""
Reviewed-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
Reviewed-by: ""Eric W. Biederman"" <ebiederm@xmission.com>
Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Acked-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/core/net_namespace.c,"{""sha"": ""60a71be75aea063b418a48ade2a1e1c7804ab35c"", ""filename"": ""net/core/net_namespace.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/21b5944350052d2583e82dd59b19a9ba94a007f0/net/core/net_namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/21b5944350052d2583e82dd59b19a9ba94a007f0/net/core/net_namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/core/net_namespace.c?ref=21b5944350052d2583e82dd59b19a9ba94a007f0"", ""patch"": ""@@ -267,7 +267,7 @@ struct net *get_net_ns_by_id(struct net *net, int id)\n \tspin_lock_bh(&net->nsid_lock);\n \tpeer = idr_find(&net->netns_ids, id);\n \tif (peer)\n-\t\tget_net(peer);\n+\t\tpeer = maybe_get_net(peer);\n \tspin_unlock_bh(&net->nsid_lock);\n \trcu_read_unlock();\n ""}","struct net *get_net_ns_by_id(struct net *net, int id)
{
	struct net *peer;

	if (id < 0)
		return NULL;

	rcu_read_lock();
 	spin_lock_bh(&net->nsid_lock);
 	peer = idr_find(&net->netns_ids, id);
 	if (peer)
		peer = maybe_get_net(peer);
 	spin_unlock_bh(&net->nsid_lock);
 	rcu_read_unlock();
 
	return peer;
}
","struct net *get_net_ns_by_id(struct net *net, int id)
{
	struct net *peer;

	if (id < 0)
		return NULL;

	rcu_read_lock();
 	spin_lock_bh(&net->nsid_lock);
 	peer = idr_find(&net->netns_ids, id);
 	if (peer)
		get_net(peer);
 	spin_unlock_bh(&net->nsid_lock);
 	rcu_read_unlock();
 
	return peer;
}
",C,"		peer = maybe_get_net(peer);
","		get_net(peer);
",,"@@ -267,7 +267,7 @@ struct net *get_net_ns_by_id(struct net *net, int id)
 	spin_lock_bh(&net->nsid_lock);
 	peer = idr_find(&net->netns_ids, id);
 	if (peer)
-		get_net(peer);
+		peer = maybe_get_net(peer);
 	spin_unlock_bh(&net->nsid_lock);
 	rcu_read_unlock();
 ",linux,21b5944350052d2583e82dd59b19a9ba94a007f0,eda9873e19d83c68d0c477f6bc13718fee7a7b3c,1,"struct net *get_net_ns_by_id(struct net *net, int id)
{
	struct net *peer;

	if (id < 0)
		return NULL;

	rcu_read_lock();
 	spin_lock_bh(&net->nsid_lock);
 	peer = idr_find(&net->netns_ids, id);
 	if (peer)
//flaw_line_below:
		get_net(peer);
//fix_flaw_line_below:
//		peer = maybe_get_net(peer);
 	spin_unlock_bh(&net->nsid_lock);
 	rcu_read_unlock();
 
	return peer;
}
",182599,"struct net *get_net_ns_by_id(struct net *net, int id)
{
	struct net *peer;

	if (id < 0)
		return NULL;

	rcu_read_lock();
 	spin_lock_bh(&net->nsid_lock);
 	peer = idr_find(&net->netns_ids, id);
 	if (peer)
		get_net(peer);
 	spin_unlock_bh(&net->nsid_lock);
 	rcu_read_unlock();
 
	return peer;
}
","struct net *get_net_ns_by_id(struct net *net, int id)
{
	struct net *peer;

	if (id < 0)
		return NULL;

	rcu_read_lock();
 	spin_lock_bh(&net->nsid_lock);
 	peer = idr_find(&net->netns_ids, id);
 	if (peer)
		peer = maybe_get_net(peer);
 	spin_unlock_bh(&net->nsid_lock);
 	rcu_read_unlock();
 
	return peer;
}
","The function `get_net_ns_by_id` retrieves a network namespace structure (`struct net`) associated with a given identifier (`id`). It first checks if the `id` is negative, returning `NULL` if so. The function then acquires read and spin locks to ensure thread safety while accessing the network namespace ID registry (`netns_ids`). It uses the IDR (ID Radix Tree) to find the corresponding network namespace. If a valid peer is found, it increments the reference count of that namespace to prevent it from being freed while in use. Finally, it releases the locks and returns the found peer or `NULL` if not found.","The code defines a function that retrieves a network namespace based on a specified identifier. It first checks if the identifier is valid, returning a null value if it is negative. The function then ensures safe access to shared data by acquiring necessary locks. It searches for the network namespace associated with the identifier in a registry. If a matching namespace is found, it increases its reference count to prevent it from being deallocated while in use. Finally, the function releases the locks and returns the found namespace or a null value if no match exists.","The vulnerability in the original code arises from the lack of a check on the reference count of the network namespace after retrieving a peer from the ID registry. This oversight could lead to a situation where the reference count is decremented to zero, allowing the memory to be freed while still being accessed, resulting in double free and memory corruption. The fix introduces the `maybe_get_net(peer)` function, which safely increments the reference count only if the peer is still valid, ensuring that the namespace remains accessible and preventing potential race conditions that could lead to memory corruption.","The vulnerability in the original code stems from the failure to verify the reference count of a network namespace after retrieving it from the ID registry. This oversight could lead to dereferencing a namespace that has already been freed, resulting in double free and memory corruption. The fix addresses this issue by introducing a mechanism that safely increments the reference count only if the namespace is still valid, ensuring that it remains accessible and preventing race conditions that could lead to memory corruption. This change effectively safeguards against concurrent modifications that could compromise the integrity of the namespace.","The vulnerability was fixed by replacing the direct call to `get_net(peer)` with `peer = maybe_get_net(peer)`. This change ensures that the reference count of the network namespace is only incremented if the namespace is still valid, thereby preventing the situation where a namespace could be accessed after it has been freed. By using `maybe_get_net`, the code now safely checks the reference count before proceeding, which mitigates the risk of double free and memory corruption. This adjustment enhances the overall safety of the function by ensuring that the namespace remains valid during its usage.","The vulnerability was addressed by implementing a mechanism that safely checks the validity of the network namespace before incrementing its reference count. This change ensures that the namespace is only accessed if it is still valid, thereby preventing potential issues related to accessing freed memory. By introducing this additional validation step, the code now avoids scenarios where a namespace could be dereferenced after it has been deallocated, effectively mitigating the risks of double free and memory corruption. This fix enhances the robustness of the function and ensures safer concurrent access to network namespaces.","CWE-416, CWE-672, CWE-825, CWE-415, CWE-665, CWE-476, CWE-908, CWE-754, CWE-666, CWE-911",Y,1
54,54,182700,182700,,Local,Not required,Complete,CVE-2019-15917,https://www.cvedetails.com/cve/CVE-2019-15917/,CWE-416,Low,Complete,Complete,,2019-09-04,7.2,An issue was discovered in the Linux kernel before 5.0.5. There is a use-after-free issue when hci_uart_register_dev() fails in hci_uart_set_proto() in drivers/bluetooth/hci_ldisc.c.,2019-09-24,,1,https://github.com/torvalds/linux/commit/56897b217a1d0a91c9920cb418d6b3fe922f590a,56897b217a1d0a91c9920cb418d6b3fe922f590a,"Bluetooth: hci_ldisc: Postpone HCI_UART_PROTO_READY bit set in hci_uart_set_proto()

task A:                                task B:
hci_uart_set_proto                     flush_to_ldisc
 - p->open(hu) -> h5_open  //alloc h5  - receive_buf
 - set_bit HCI_UART_PROTO_READY         - tty_port_default_receive_buf
 - hci_uart_register_dev                 - tty_ldisc_receive_buf
                                          - hci_uart_tty_receive
				           - test_bit HCI_UART_PROTO_READY
				            - h5_recv
 - clear_bit HCI_UART_PROTO_READY             while() {
 - p->open(hu) -> h5_close //free h5
				              - h5_rx_3wire_hdr
				               - h5_reset()  //use-after-free
                                              }

It could use ioctl to set hci uart proto, but there is
a use-after-free issue when hci_uart_register_dev() fail in
hci_uart_set_proto(), see stack above, fix this by setting
HCI_UART_PROTO_READY bit only when hci_uart_register_dev()
return success.

Reported-by: syzbot+899a33dc0fa0dbaf06a6@syzkaller.appspotmail.com
Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
Reviewed-by: Jeremy Cline <jcline@redhat.com>
Signed-off-by: Marcel Holtmann <marcel@holtmann.org>",2,drivers/bluetooth/hci_ldisc.c,"{""sha"": ""9562e72c1ae5792092361cf22bca9a1d96782549"", ""filename"": ""drivers/bluetooth/hci_ldisc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/56897b217a1d0a91c9920cb418d6b3fe922f590a/drivers/bluetooth/hci_ldisc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/56897b217a1d0a91c9920cb418d6b3fe922f590a/drivers/bluetooth/hci_ldisc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/bluetooth/hci_ldisc.c?ref=56897b217a1d0a91c9920cb418d6b3fe922f590a"", ""patch"": ""@@ -696,14 +696,13 @@ static int hci_uart_set_proto(struct hci_uart *hu, int id)\n \t\treturn -EPROTONOSUPPORT;\n \n \thu->proto = p;\n-\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n \n \terr = hci_uart_register_dev(hu);\n \tif (err) {\n-\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n \t\treturn err;\n \t}\n \n+\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n \treturn 0;\n }\n ""}","static int hci_uart_set_proto(struct hci_uart *hu, int id)
{
	const struct hci_uart_proto *p;
	int err;

	p = hci_uart_get_proto(id);
	if (!p)
 		return -EPROTONOSUPPORT;
 
 	hu->proto = p;
 
 	err = hci_uart_register_dev(hu);
 	if (err) {
 		return err;
 	}
 
	set_bit(HCI_UART_PROTO_READY, &hu->flags);
 	return 0;
 }
","static int hci_uart_set_proto(struct hci_uart *hu, int id)
{
	const struct hci_uart_proto *p;
	int err;

	p = hci_uart_get_proto(id);
	if (!p)
 		return -EPROTONOSUPPORT;
 
 	hu->proto = p;
	set_bit(HCI_UART_PROTO_READY, &hu->flags);
 
 	err = hci_uart_register_dev(hu);
 	if (err) {
		clear_bit(HCI_UART_PROTO_READY, &hu->flags);
 		return err;
 	}
 
 	return 0;
 }
",C,"	set_bit(HCI_UART_PROTO_READY, &hu->flags);
","	set_bit(HCI_UART_PROTO_READY, &hu->flags);
		clear_bit(HCI_UART_PROTO_READY, &hu->flags);
",,"@@ -696,14 +696,13 @@ static int hci_uart_set_proto(struct hci_uart *hu, int id)
 		return -EPROTONOSUPPORT;
 
 	hu->proto = p;
-	set_bit(HCI_UART_PROTO_READY, &hu->flags);
 
 	err = hci_uart_register_dev(hu);
 	if (err) {
-		clear_bit(HCI_UART_PROTO_READY, &hu->flags);
 		return err;
 	}
 
+	set_bit(HCI_UART_PROTO_READY, &hu->flags);
 	return 0;
 }
 ",linux,56897b217a1d0a91c9920cb418d6b3fe922f590a,4a67e5d4adbf3b419f17924322f468ac5cb8c14f,1,"static int hci_uart_set_proto(struct hci_uart *hu, int id)
{
	const struct hci_uart_proto *p;
	int err;

	p = hci_uart_get_proto(id);
	if (!p)
 		return -EPROTONOSUPPORT;
 
 	hu->proto = p;
//flaw_line_below:
	set_bit(HCI_UART_PROTO_READY, &hu->flags);
 
 	err = hci_uart_register_dev(hu);
 	if (err) {
//flaw_line_below:
		clear_bit(HCI_UART_PROTO_READY, &hu->flags);
 		return err;
 	}
 
//fix_flaw_line_below:
//	set_bit(HCI_UART_PROTO_READY, &hu->flags);
 	return 0;
 }
",182700,"static int hci_uart_set_proto(struct hci_uart *hu, int id)
{
	const struct hci_uart_proto *p;
	int err;

	p = hci_uart_get_proto(id);
	if (!p)
 		return -EPROTONOSUPPORT;
 
 	hu->proto = p;
	set_bit(HCI_UART_PROTO_READY, &hu->flags);
 
 	err = hci_uart_register_dev(hu);
 	if (err) {
		clear_bit(HCI_UART_PROTO_READY, &hu->flags);
 		return err;
 	}
 
 	return 0;
 }
","static int hci_uart_set_proto(struct hci_uart *hu, int id)
{
	const struct hci_uart_proto *p;
	int err;

	p = hci_uart_get_proto(id);
	if (!p)
 		return -EPROTONOSUPPORT;
 
 	hu->proto = p;
 
 	err = hci_uart_register_dev(hu);
 	if (err) {
 		return err;
 	}
 
	set_bit(HCI_UART_PROTO_READY, &hu->flags);
 	return 0;
 }
","The `hci_uart_set_proto` function configures a Bluetooth UART protocol for a given `hci_uart` structure. It first retrieves the protocol associated with the provided `id` using `hci_uart_get_proto`. If the protocol is not found, it returns an error indicating unsupported protocol. If found, it assigns the protocol to the `hci_uart` instance and marks it as ready by setting a corresponding flag. The function then attempts to register the device with `hci_uart_register_dev`. If registration fails, it clears the ready flag and returns the error; otherwise, it returns zero, indicating success.","The function is responsible for setting up a Bluetooth UART protocol for a specified device. It begins by attempting to retrieve the protocol associated with a given identifier. If the protocol is not available, it returns an error indicating that the protocol is unsupported. Upon successfully obtaining the protocol, it marks the device as ready for use. The function then attempts to register the device; if this registration fails, it resets the ready status and returns the error encountered. If all operations succeed, the function concludes by returning a success status.","The vulnerability in the original code arises from setting the `HCI_UART_PROTO_READY` bit before successfully registering the device with `hci_uart_register_dev()`. This premature setting can lead to a use-after-free issue if the registration fails, as subsequent operations may attempt to access resources that have already been freed. The fix addresses this vulnerability by postponing the setting of the `HCI_UART_PROTO_READY` bit until after the successful registration of the device. This change ensures that the protocol is only marked as ready when it is safe to do so, preventing potential access to invalid memory.","The vulnerability in the original code stems from the premature marking of a protocol as ready before confirming the successful registration of the device. This can lead to a use-after-free scenario if the registration fails, as subsequent operations may attempt to access resources that have already been released. The fix addresses this issue by delaying the marking of the protocol as ready until after the device registration is confirmed to be successful. This change ensures that the protocol is only considered ready when it is safe to do so, thereby preventing potential access to invalid memory and enhancing overall stability.","The vulnerability was fixed by postponing the setting of the `HCI_UART_PROTO_READY` bit until after the successful execution of the `hci_uart_register_dev()` function. In the original code, the bit was set immediately after assigning the protocol, which could lead to a use-after-free issue if the registration failed. The revised code first attempts to register the device, and only if this operation returns success does it proceed to set the `HCI_UART_PROTO_READY` bit. This change ensures that the protocol is only marked as ready when it is safe, thus preventing access to freed resources.","The vulnerability was fixed by changing the order of operations related to marking the protocol as ready. In the original implementation, the protocol was marked as ready before confirming the successful registration of the device, which could lead to accessing freed resources if the registration failed. The revised approach ensures that the protocol is only marked as ready after the registration process is completed successfully. This adjustment prevents any potential use-after-free issues by ensuring that the system only considers the protocol ready when it is safe to do so, thereby enhancing overall stability and reliability.","CWE-416, CWE-825, CWE-672, CWE-415, CWE-666, CWE-826, CWE-913, CWE-404, CWE-665, CWE-911",Y,1
55,55,182735,182735,,Remote,Not required,Partial,CVE-2019-14980,https://www.cvedetails.com/cve/CVE-2019-14980/,CWE-416,Medium,,,,2019-08-12,4.3,"In ImageMagick 7.x before 7.0.8-42 and 6.x before 6.9.10-42, there is a use after free vulnerability in the UnmapBlob function that allows an attacker to cause a denial of service by sending a crafted file.",2019-08-16,DoS ,1,https://github.com/ImageMagick/ImageMagick6/commit/614a257295bdcdeda347086761062ac7658b6830,614a257295bdcdeda347086761062ac7658b6830,https://github.com/ImageMagick/ImageMagick6/issues/43,0,magick/blob.c,"{""sha"": ""cdc693203976a5f78028574294a247d9e347ae09"", ""filename"": ""magick/blob.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick6/blob/614a257295bdcdeda347086761062ac7658b6830/magick/blob.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick6/raw/614a257295bdcdeda347086761062ac7658b6830/magick/blob.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick6/contents/magick/blob.c?ref=614a257295bdcdeda347086761062ac7658b6830"", ""patch"": ""@@ -700,6 +700,7 @@ MagickExport unsigned char *DetachBlob(BlobInfo *blob_info)\n   if (blob_info->mapped != MagickFalse)\n     {\n       (void) UnmapBlob(blob_info->data,blob_info->length);\n+      blob_info->data=NULL;\n       RelinquishMagickResource(MapResource,blob_info->length);\n     }\n   blob_info->mapped=MagickFalse;""}","MagickExport unsigned char *DetachBlob(BlobInfo *blob_info)
{
  unsigned char
    *data;

  assert(blob_info != (BlobInfo *) NULL);
  if (blob_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
      blob_info->data=NULL;
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;
  blob_info->length=0;
  blob_info->offset=0;
  blob_info->eof=MagickFalse;
  blob_info->error=0;
  blob_info->exempt=MagickFalse;
  blob_info->type=UndefinedStream;
  blob_info->file_info.file=(FILE *) NULL;
  data=blob_info->data;
  blob_info->data=(unsigned char *) NULL;
  blob_info->stream=(StreamHandler) NULL;
  return(data);
}
","MagickExport unsigned char *DetachBlob(BlobInfo *blob_info)
{
  unsigned char
    *data;

  assert(blob_info != (BlobInfo *) NULL);
  if (blob_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;
  blob_info->length=0;
  blob_info->offset=0;
  blob_info->eof=MagickFalse;
  blob_info->error=0;
  blob_info->exempt=MagickFalse;
  blob_info->type=UndefinedStream;
  blob_info->file_info.file=(FILE *) NULL;
  data=blob_info->data;
  blob_info->data=(unsigned char *) NULL;
  blob_info->stream=(StreamHandler) NULL;
  return(data);
}
",C,"      blob_info->data=NULL;
",,,"@@ -700,6 +700,7 @@ MagickExport unsigned char *DetachBlob(BlobInfo *blob_info)
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
+      blob_info->data=NULL;
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;",ImageMagick6,614a257295bdcdeda347086761062ac7658b6830,a1a7f79975cde3728b1283ba845bccf1a26a825d,1,"MagickExport unsigned char *DetachBlob(BlobInfo *blob_info)
{
  unsigned char
    *data;

  assert(blob_info != (BlobInfo *) NULL);
  if (blob_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
//fix_flaw_line_below:
//      blob_info->data=NULL;
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;
  blob_info->length=0;
  blob_info->offset=0;
  blob_info->eof=MagickFalse;
  blob_info->error=0;
  blob_info->exempt=MagickFalse;
  blob_info->type=UndefinedStream;
  blob_info->file_info.file=(FILE *) NULL;
  data=blob_info->data;
  blob_info->data=(unsigned char *) NULL;
  blob_info->stream=(StreamHandler) NULL;
  return(data);
}
",182735,"MagickExport unsigned char *DetachBlob(BlobInfo *blob_info)
{
  unsigned char
    *data;

  assert(blob_info != (BlobInfo *) NULL);
  if (blob_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;
  blob_info->length=0;
  blob_info->offset=0;
  blob_info->eof=MagickFalse;
  blob_info->error=0;
  blob_info->exempt=MagickFalse;
  blob_info->type=UndefinedStream;
  blob_info->file_info.file=(FILE *) NULL;
  data=blob_info->data;
  blob_info->data=(unsigned char *) NULL;
  blob_info->stream=(StreamHandler) NULL;
  return(data);
}
","MagickExport unsigned char *DetachBlob(BlobInfo *blob_info)
{
  unsigned char
    *data;

  assert(blob_info != (BlobInfo *) NULL);
  if (blob_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
      blob_info->data=NULL;
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;
  blob_info->length=0;
  blob_info->offset=0;
  blob_info->eof=MagickFalse;
  blob_info->error=0;
  blob_info->exempt=MagickFalse;
  blob_info->type=UndefinedStream;
  blob_info->file_info.file=(FILE *) NULL;
  data=blob_info->data;
  blob_info->data=(unsigned char *) NULL;
  blob_info->stream=(StreamHandler) NULL;
  return(data);
}
","The `DetachBlob` function is designed to safely detach and return the data from a `BlobInfo` structure, which represents a binary data blob. It first checks that the `blob_info` pointer is valid and logs an event if debugging is enabled. If the blob is currently mapped in memory, it unmaps the data and releases the associated resources. The function then resets various properties of the `blob_info`, such as length, offset, and error status, to prepare it for potential reuse. Finally, it retrieves the data pointer, nullifies the blob's data reference, and returns the detached data to the caller.","The provided code defines a function that safely detaches and returns binary data from a structure representing a data blob. It begins by verifying the validity of the input structure and logs an event if debugging is enabled. If the data is currently mapped in memory, the function unmaps it and releases the associated resources. It then resets various attributes of the structure, such as length and offset, to prepare it for future use. Finally, the function retrieves the data pointer, clears the reference to the data within the structure, and returns the detached data to the caller.","The vulnerability in the original code arises from the potential use of a dangling pointer, as the `data` pointer is returned after the blob's data has been set to `NULL` without ensuring it is properly cleared first. This could lead to undefined behavior if the caller attempts to access the data after it has been unmapped and the reference cleared. The fix addresses this by explicitly setting `blob_info->data` to `NULL` immediately after unmapping the data, ensuring that the pointer is not left dangling. This change enhances safety by preventing access to invalid memory, thus mitigating the risk of crashes or data corruption.","The vulnerability in the original code stems from the risk of returning a pointer to data that has been cleared, which could lead to accessing invalid memory and undefined behavior. This occurs because the data pointer is returned after the associated memory has been unmapped and the reference is set to null, leaving a dangling pointer. The fix addresses this issue by ensuring that the data is explicitly set to null immediately after unmapping, thereby preventing any potential access to invalid memory. This change enhances the safety of the code by ensuring that no references to cleared memory are returned to the caller.","The vulnerability was fixed by modifying the code to set `blob_info->data` to `NULL` immediately after the call to `UnmapBlob`. This change ensures that once the data is unmapped and the resources are relinquished, the pointer to the data is explicitly cleared, preventing any potential access to invalid memory. By doing this, the code eliminates the risk of returning a dangling pointer when the `data` variable is retrieved and returned to the caller. This adjustment enhances memory safety and ensures that the function does not expose references to already freed or invalidated memory.","The vulnerability was fixed by ensuring that the pointer to the data is explicitly set to null immediately after the memory is unmapped and the associated resources are released. This adjustment prevents the function from returning a pointer to memory that has been cleared, thereby eliminating the risk of accessing invalid memory. By implementing this change, the code enhances its safety by ensuring that no references to freed memory are exposed to the caller, thus preventing potential crashes or undefined behavior that could arise from using a dangling pointer.","CWE-416, CWE-476, CWE-825, CWE-415, CWE-672, CWE-763, CWE-401, CWE-762, CWE-119, CWE-404",Y,1
56,56,182785,182785,,Remote,Not required,Partial,CVE-2019-13224,https://www.cvedetails.com/cve/CVE-2019-13224/,CWE-416,Low,Partial,Partial,,2019-07-10,7.5,"A use-after-free in onig_new_deluxe() in regext.c in Oniguruma 6.9.2 allows attackers to potentially cause information disclosure, denial of service, or possibly code execution by providing a crafted regular expression. The attacker provides a pair of a regex pattern and a string, with a multi-byte encoding that gets handled by onig_new_deluxe(). Oniguruma issues often affect Ruby, as well as common optional libraries for PHP and Rust.",2019-07-17,DoS Exec Code ,1,https://github.com/kkos/oniguruma/commit/0f7f61ed1b7b697e283e37bd2d731d0bd57adb55,0f7f61ed1b7b697e283e37bd2d731d0bd57adb55,Fix CVE-2019-13224: don't allow different encodings for onig_new_deluxe(),3,src/regext.c,"{""sha"": ""965c7933d9c06c13284e4245115676647bf2b2d8"", ""filename"": ""src/regext.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/kkos/oniguruma/blob/0f7f61ed1b7b697e283e37bd2d731d0bd57adb55/src/regext.c"", ""raw_url"": ""https://github.com/kkos/oniguruma/raw/0f7f61ed1b7b697e283e37bd2d731d0bd57adb55/src/regext.c"", ""contents_url"": ""https://api.github.com/repos/kkos/oniguruma/contents/src/regext.c?ref=0f7f61ed1b7b697e283e37bd2d731d0bd57adb55"", ""patch"": ""@@ -29,6 +29,7 @@\n \n #include \""regint.h\""\n \n+#if 0\n static void\n conv_ext0be32(const UChar* s, const UChar* end, UChar* conv)\n {\n@@ -158,6 +159,7 @@ conv_encoding(OnigEncoding from, OnigEncoding to, const UChar* s, const UChar* e\n \n   return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;\n }\n+#endif\n \n extern int\n onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n@@ -169,9 +171,7 @@ onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n \n   if (ci->pattern_enc != ci->target_enc) {\n-    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n-                      &cpat, &cpat_end);\n-    if (r != 0) return r;\n+    return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;\n   }\n   else {\n     cpat     = (UChar* )pattern;""}"," onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,
                OnigCompileInfo* ci, OnigErrorInfo* einfo)
{
  int r;
  UChar *cpat, *cpat_end;

   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;
 
   if (ci->pattern_enc != ci->target_enc) {
    return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;
   }
   else {
     cpat     = (UChar* )pattern;
    cpat_end = (UChar* )pattern_end;
  }

  *reg = (regex_t* )xmalloc(sizeof(regex_t));
  if (IS_NULL(*reg)) {
    r = ONIGERR_MEMORY;
    goto err2;
  }

  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,
                    ci->syntax);
  if (r != 0) goto err;

  r = onig_compile(*reg, cpat, cpat_end, einfo);
  if (r != 0) {
  err:
    onig_free(*reg);
    *reg = NULL;
  }

 err2:
  if (cpat != pattern) xfree(cpat);

  return r;
}
"," onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,
                OnigCompileInfo* ci, OnigErrorInfo* einfo)
{
  int r;
  UChar *cpat, *cpat_end;

   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;
 
   if (ci->pattern_enc != ci->target_enc) {
    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,
                      &cpat, &cpat_end);
    if (r != 0) return r;
   }
   else {
     cpat     = (UChar* )pattern;
    cpat_end = (UChar* )pattern_end;
  }

  *reg = (regex_t* )xmalloc(sizeof(regex_t));
  if (IS_NULL(*reg)) {
    r = ONIGERR_MEMORY;
    goto err2;
  }

  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,
                    ci->syntax);
  if (r != 0) goto err;

  r = onig_compile(*reg, cpat, cpat_end, einfo);
  if (r != 0) {
  err:
    onig_free(*reg);
    *reg = NULL;
  }

 err2:
  if (cpat != pattern) xfree(cpat);

  return r;
}
",C,"    return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;
","    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,
                      &cpat, &cpat_end);
    if (r != 0) return r;
",,"@@ -29,6 +29,7 @@
 
 #include ""regint.h""
 
+#if 0
 static void
 conv_ext0be32(const UChar* s, const UChar* end, UChar* conv)
 {
@@ -158,6 +159,7 @@ conv_encoding(OnigEncoding from, OnigEncoding to, const UChar* s, const UChar* e
 
   return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;
 }
+#endif
 
 extern int
 onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,
@@ -169,9 +171,7 @@ onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,
   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;
 
   if (ci->pattern_enc != ci->target_enc) {
-    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,
-                      &cpat, &cpat_end);
-    if (r != 0) return r;
+    return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;
   }
   else {
     cpat     = (UChar* )pattern;",oniguruma,0f7f61ed1b7b697e283e37bd2d731d0bd57adb55,c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c,1," onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,
                OnigCompileInfo* ci, OnigErrorInfo* einfo)
{
  int r;
  UChar *cpat, *cpat_end;

   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;
 
   if (ci->pattern_enc != ci->target_enc) {
//flaw_line_below:
    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,
//flaw_line_below:
                      &cpat, &cpat_end);
//flaw_line_below:
    if (r != 0) return r;
//fix_flaw_line_below:
//    return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;
   }
   else {
     cpat     = (UChar* )pattern;
    cpat_end = (UChar* )pattern_end;
  }

  *reg = (regex_t* )xmalloc(sizeof(regex_t));
  if (IS_NULL(*reg)) {
    r = ONIGERR_MEMORY;
    goto err2;
  }

  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,
                    ci->syntax);
  if (r != 0) goto err;

  r = onig_compile(*reg, cpat, cpat_end, einfo);
  if (r != 0) {
  err:
    onig_free(*reg);
    *reg = NULL;
  }

 err2:
  if (cpat != pattern) xfree(cpat);

  return r;
}
",182785," onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,
                OnigCompileInfo* ci, OnigErrorInfo* einfo)
{
  int r;
  UChar *cpat, *cpat_end;

   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;
 
   if (ci->pattern_enc != ci->target_enc) {
    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,
                      &cpat, &cpat_end);
    if (r != 0) return r;
   }
   else {
     cpat     = (UChar* )pattern;
    cpat_end = (UChar* )pattern_end;
  }

  *reg = (regex_t* )xmalloc(sizeof(regex_t));
  if (IS_NULL(*reg)) {
    r = ONIGERR_MEMORY;
    goto err2;
  }

  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,
                    ci->syntax);
  if (r != 0) goto err;

  r = onig_compile(*reg, cpat, cpat_end, einfo);
  if (r != 0) {
  err:
    onig_free(*reg);
    *reg = NULL;
  }

 err2:
  if (cpat != pattern) xfree(cpat);

  return r;
}
"," onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,
                OnigCompileInfo* ci, OnigErrorInfo* einfo)
{
  int r;
  UChar *cpat, *cpat_end;

   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;
 
   if (ci->pattern_enc != ci->target_enc) {
    return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;
   }
   else {
     cpat     = (UChar* )pattern;
    cpat_end = (UChar* )pattern_end;
  }

  *reg = (regex_t* )xmalloc(sizeof(regex_t));
  if (IS_NULL(*reg)) {
    r = ONIGERR_MEMORY;
    goto err2;
  }

  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,
                    ci->syntax);
  if (r != 0) goto err;

  r = onig_compile(*reg, cpat, cpat_end, einfo);
  if (r != 0) {
  err:
    onig_free(*reg);
    *reg = NULL;
  }

 err2:
  if (cpat != pattern) xfree(cpat);

  return r;
}
","The `onig_new_deluxe` function is designed to create and initialize a new regular expression object (`regex_t`) based on a specified pattern and its encoding. It first checks if the pattern's encoding differs from the target encoding, converting it if necessary. The function allocates memory for the regex object and initializes it with options, case folding flags, target encoding, and syntax. It then compiles the regex pattern, handling any errors by freeing allocated memory and setting the regex pointer to NULL. The function ultimately returns an error code or success status, indicating the outcome of the operation.","The provided code defines a function that creates and initializes a new regular expression object based on a specified pattern. It first checks if the encoding of the pattern matches the target encoding, converting it if they differ. The function allocates memory for the regular expression object and initializes it with various options and settings. It then attempts to compile the pattern, handling any errors by freeing the allocated memory and nullifying the object pointer if necessary. The function ultimately returns a status code indicating whether the operation was successful or if an error occurred during the process.","The vulnerability in the original code stemmed from allowing the creation of a regular expression object with mismatched pattern and target encodings, which could lead to undefined behavior or security issues. Specifically, the function attempted to convert the encoding without validating if the combination was supported. The fix implemented in the updated code prevents this issue by immediately returning an error code when the pattern encoding does not match the target encoding, thus avoiding any further processing or potential exploitation. This change ensures that only compatible encodings are used, enhancing the overall security of the function.","The vulnerability in the original code allowed the creation of a regular expression object with incompatible encodings, which could lead to unexpected behavior or security risks during pattern matching. This lack of validation meant that the function could proceed with potentially harmful operations if the encodings did not align. The fix implemented in the updated code addresses this issue by introducing a check that immediately returns an error when the pattern and target encodings are different. This change effectively prevents any further processing with unsupported encoding combinations, thereby enhancing the security and stability of the function.","The vulnerability was fixed by adding a validation check for encoding compatibility in the updated code. Specifically, the condition that checks if the pattern encoding differs from the target encoding now leads to an immediate return of an error code, `ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION`, instead of attempting to convert the encoding. This change prevents the function from proceeding with incompatible encodings, thereby eliminating the risk of undefined behavior or security issues. As a result, the function ensures that only valid encoding combinations are processed, enhancing the overall robustness and security of the regular expression creation process.","The vulnerability was fixed by implementing a validation step that checks for compatibility between the pattern and target encodings before any further processing occurs. If the encodings are found to be different, the function immediately returns an error code, preventing any potentially harmful operations that could arise from mismatched encodings. This proactive approach ensures that only supported encoding combinations are allowed, effectively eliminating the risk of undefined behavior or security issues associated with the previous implementation. As a result, the overall integrity and security of the regular expression creation process are significantly improved.","CWE-116, CWE-838, CWE-172, CWE-176, CWE-171, CWE-175, CWE-170, CWE-174, CWE-20, CWE-1287",N,-1
57,57,182824,182824,,Local,Not required,Partial,CVE-2019-12819,https://www.cvedetails.com/cve/CVE-2019-12819/,CWE-416,Low,,,,2019-06-13,2.1,"An issue was discovered in the Linux kernel before 5.0. The function __mdiobus_register() in drivers/net/phy/mdio_bus.c calls put_device(), which will trigger a fixed_mdio_bus_init use-after-free. This will cause a denial of service.",2019-06-18,DoS ,0,https://github.com/torvalds/linux/commit/6ff7b060535e87c2ae14dd8548512abfdda528fb,6ff7b060535e87c2ae14dd8548512abfdda528fb,"mdio_bus: Fix use-after-free on device_register fails

KASAN has found use-after-free in fixed_mdio_bus_init,
commit 0c692d07842a (""drivers/net/phy/mdio_bus.c: call
put_device on device_register() failure"") call put_device()
while device_register() fails,give up the last reference
to the device and allow mdiobus_release to be executed
,kfreeing the bus. However in most drives, mdiobus_free
be called to free the bus while mdiobus_register fails.
use-after-free occurs when access bus again, this patch
revert it to let mdiobus_free free the bus.

KASAN report details as below:

BUG: KASAN: use-after-free in mdiobus_free+0x85/0x90 drivers/net/phy/mdio_bus.c:482
Read of size 4 at addr ffff8881dc824d78 by task syz-executor.0/3524

CPU: 1 PID: 3524 Comm: syz-executor.0 Not tainted 5.0.0-rc7+ #45
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
Call Trace:
 __dump_stack lib/dump_stack.c:77 [inline]
 dump_stack+0xfa/0x1ce lib/dump_stack.c:113
 print_address_description+0x65/0x270 mm/kasan/report.c:187
 kasan_report+0x149/0x18d mm/kasan/report.c:317
 mdiobus_free+0x85/0x90 drivers/net/phy/mdio_bus.c:482
 fixed_mdio_bus_init+0x283/0x1000 [fixed_phy]
 ? 0xffffffffc0e40000
 ? 0xffffffffc0e40000
 ? 0xffffffffc0e40000
 do_one_initcall+0xfa/0x5ca init/main.c:887
 do_init_module+0x204/0x5f6 kernel/module.c:3460
 load_module+0x66b2/0x8570 kernel/module.c:3808
 __do_sys_finit_module+0x238/0x2a0 kernel/module.c:3902
 do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe
RIP: 0033:0x462e99
Code: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007f6215c19c58 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
RAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99
RDX: 0000000000000000 RSI: 0000000020000080 RDI: 0000000000000003
RBP: 00007f6215c19c70 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 00007f6215c1a6bc
R13: 00000000004bcefb R14: 00000000006f7030 R15: 0000000000000004

Allocated by task 3524:
 set_track mm/kasan/common.c:85 [inline]
 __kasan_kmalloc.constprop.3+0xa0/0xd0 mm/kasan/common.c:496
 kmalloc include/linux/slab.h:545 [inline]
 kzalloc include/linux/slab.h:740 [inline]
 mdiobus_alloc_size+0x54/0x1b0 drivers/net/phy/mdio_bus.c:143
 fixed_mdio_bus_init+0x163/0x1000 [fixed_phy]
 do_one_initcall+0xfa/0x5ca init/main.c:887
 do_init_module+0x204/0x5f6 kernel/module.c:3460
 load_module+0x66b2/0x8570 kernel/module.c:3808
 __do_sys_finit_module+0x238/0x2a0 kernel/module.c:3902
 do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe

Freed by task 3524:
 set_track mm/kasan/common.c:85 [inline]
 __kasan_slab_free+0x130/0x180 mm/kasan/common.c:458
 slab_free_hook mm/slub.c:1409 [inline]
 slab_free_freelist_hook mm/slub.c:1436 [inline]
 slab_free mm/slub.c:2986 [inline]
 kfree+0xe1/0x270 mm/slub.c:3938
 device_release+0x78/0x200 drivers/base/core.c:919
 kobject_cleanup lib/kobject.c:662 [inline]
 kobject_release lib/kobject.c:691 [inline]
 kref_put include/linux/kref.h:67 [inline]
 kobject_put+0x146/0x240 lib/kobject.c:708
 put_device+0x1c/0x30 drivers/base/core.c:2060
 __mdiobus_register+0x483/0x560 drivers/net/phy/mdio_bus.c:382
 fixed_mdio_bus_init+0x26b/0x1000 [fixed_phy]
 do_one_initcall+0xfa/0x5ca init/main.c:887
 do_init_module+0x204/0x5f6 kernel/module.c:3460
 load_module+0x66b2/0x8570 kernel/module.c:3808
 __do_sys_finit_module+0x238/0x2a0 kernel/module.c:3902
 do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe

The buggy address belongs to the object at ffff8881dc824c80
 which belongs to the cache kmalloc-2k of size 2048
The buggy address is located 248 bytes inside of
 2048-byte region [ffff8881dc824c80, ffff8881dc825480)
The buggy address belongs to the page:
page:ffffea0007720800 count:1 mapcount:0 mapping:ffff8881f6c02800 index:0x0 compound_mapcount: 0
flags: 0x2fffc0000010200(slab|head)
raw: 02fffc0000010200 0000000000000000 0000000500000001 ffff8881f6c02800
raw: 0000000000000000 00000000800f000f 00000001ffffffff 0000000000000000
page dumped because: kasan: bad access detected

Memory state around the buggy address:
 ffff8881dc824c00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ffff8881dc824c80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
>ffff8881dc824d00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                                                ^
 ffff8881dc824d80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff8881dc824e00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb

Fixes: 0c692d07842a (""drivers/net/phy/mdio_bus.c: call put_device on device_register() failure"")
Signed-off-by: YueHaibing <yuehaibing@huawei.com>
Reviewed-by: Andrew Lunn <andrew@lunn.ch>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,drivers/net/phy/mdio_bus.c,"{""sha"": ""7368616286ae9ced5b44e782e69877604025a7b6"", ""filename"": ""drivers/net/phy/mdio_bus.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/6ff7b060535e87c2ae14dd8548512abfdda528fb/drivers/net/phy/mdio_bus.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/6ff7b060535e87c2ae14dd8548512abfdda528fb/drivers/net/phy/mdio_bus.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/phy/mdio_bus.c?ref=6ff7b060535e87c2ae14dd8548512abfdda528fb"", ""patch"": ""@@ -379,7 +379,6 @@ int __mdiobus_register(struct mii_bus *bus, struct module *owner)\n \terr = device_register(&bus->dev);\n \tif (err) {\n \t\tpr_err(\""mii_bus %s failed to register\\n\"", bus->id);\n-\t\tput_device(&bus->dev);\n \t\treturn -EINVAL;\n \t}\n ""}","int __mdiobus_register(struct mii_bus *bus, struct module *owner)
{
	struct mdio_device *mdiodev;
	int i, err;
	struct gpio_desc *gpiod;

	if (NULL == bus || NULL == bus->name ||
	    NULL == bus->read || NULL == bus->write)
		return -EINVAL;

	BUG_ON(bus->state != MDIOBUS_ALLOCATED &&
	       bus->state != MDIOBUS_UNREGISTERED);

	bus->owner = owner;
	bus->dev.parent = bus->parent;
	bus->dev.class = &mdio_bus_class;
	bus->dev.groups = NULL;
	dev_set_name(&bus->dev, ""%s"", bus->id);

 	err = device_register(&bus->dev);
 	if (err) {
 		pr_err(""mii_bus %s failed to register\n"", bus->id);
 		return -EINVAL;
 	}
 
	mutex_init(&bus->mdio_lock);

	/* de-assert bus level PHY GPIO reset */
	gpiod = devm_gpiod_get_optional(&bus->dev, ""reset"", GPIOD_OUT_LOW);
	if (IS_ERR(gpiod)) {
		dev_err(&bus->dev, ""mii_bus %s couldn't get reset GPIO\n"",
			bus->id);
		device_del(&bus->dev);
		return PTR_ERR(gpiod);
	} else	if (gpiod) {
		bus->reset_gpiod = gpiod;

		gpiod_set_value_cansleep(gpiod, 1);
		udelay(bus->reset_delay_us);
		gpiod_set_value_cansleep(gpiod, 0);
	}

	if (bus->reset)
		bus->reset(bus);

	for (i = 0; i < PHY_MAX_ADDR; i++) {
		if ((bus->phy_mask & (1 << i)) == 0) {
			struct phy_device *phydev;

			phydev = mdiobus_scan(bus, i);
			if (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {
				err = PTR_ERR(phydev);
				goto error;
			}
		}
	}

	mdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);

	bus->state = MDIOBUS_REGISTERED;
	pr_info(""%s: probed\n"", bus->name);
	return 0;

error:
	while (--i >= 0) {
		mdiodev = bus->mdio_map[i];
		if (!mdiodev)
			continue;

		mdiodev->device_remove(mdiodev);
		mdiodev->device_free(mdiodev);
	}

	/* Put PHYs in RESET to save power */
	if (bus->reset_gpiod)
		gpiod_set_value_cansleep(bus->reset_gpiod, 1);

	device_del(&bus->dev);
	return err;
}
","int __mdiobus_register(struct mii_bus *bus, struct module *owner)
{
	struct mdio_device *mdiodev;
	int i, err;
	struct gpio_desc *gpiod;

	if (NULL == bus || NULL == bus->name ||
	    NULL == bus->read || NULL == bus->write)
		return -EINVAL;

	BUG_ON(bus->state != MDIOBUS_ALLOCATED &&
	       bus->state != MDIOBUS_UNREGISTERED);

	bus->owner = owner;
	bus->dev.parent = bus->parent;
	bus->dev.class = &mdio_bus_class;
	bus->dev.groups = NULL;
	dev_set_name(&bus->dev, ""%s"", bus->id);

 	err = device_register(&bus->dev);
 	if (err) {
 		pr_err(""mii_bus %s failed to register\n"", bus->id);
		put_device(&bus->dev);
 		return -EINVAL;
 	}
 
	mutex_init(&bus->mdio_lock);

	/* de-assert bus level PHY GPIO reset */
	gpiod = devm_gpiod_get_optional(&bus->dev, ""reset"", GPIOD_OUT_LOW);
	if (IS_ERR(gpiod)) {
		dev_err(&bus->dev, ""mii_bus %s couldn't get reset GPIO\n"",
			bus->id);
		device_del(&bus->dev);
		return PTR_ERR(gpiod);
	} else	if (gpiod) {
		bus->reset_gpiod = gpiod;

		gpiod_set_value_cansleep(gpiod, 1);
		udelay(bus->reset_delay_us);
		gpiod_set_value_cansleep(gpiod, 0);
	}

	if (bus->reset)
		bus->reset(bus);

	for (i = 0; i < PHY_MAX_ADDR; i++) {
		if ((bus->phy_mask & (1 << i)) == 0) {
			struct phy_device *phydev;

			phydev = mdiobus_scan(bus, i);
			if (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {
				err = PTR_ERR(phydev);
				goto error;
			}
		}
	}

	mdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);

	bus->state = MDIOBUS_REGISTERED;
	pr_info(""%s: probed\n"", bus->name);
	return 0;

error:
	while (--i >= 0) {
		mdiodev = bus->mdio_map[i];
		if (!mdiodev)
			continue;

		mdiodev->device_remove(mdiodev);
		mdiodev->device_free(mdiodev);
	}

	/* Put PHYs in RESET to save power */
	if (bus->reset_gpiod)
		gpiod_set_value_cansleep(bus->reset_gpiod, 1);

	device_del(&bus->dev);
	return err;
}
",C,,"		put_device(&bus->dev);
",,"@@ -379,7 +379,6 @@ int __mdiobus_register(struct mii_bus *bus, struct module *owner)
 	err = device_register(&bus->dev);
 	if (err) {
 		pr_err(""mii_bus %s failed to register\n"", bus->id);
-		put_device(&bus->dev);
 		return -EINVAL;
 	}
 ",linux,6ff7b060535e87c2ae14dd8548512abfdda528fb,97f0082a0592212fc15d4680f5a4d80f79a1687c,1,"int __mdiobus_register(struct mii_bus *bus, struct module *owner)
{
	struct mdio_device *mdiodev;
	int i, err;
	struct gpio_desc *gpiod;

	if (NULL == bus || NULL == bus->name ||
	    NULL == bus->read || NULL == bus->write)
		return -EINVAL;

	BUG_ON(bus->state != MDIOBUS_ALLOCATED &&
	       bus->state != MDIOBUS_UNREGISTERED);

	bus->owner = owner;
	bus->dev.parent = bus->parent;
	bus->dev.class = &mdio_bus_class;
	bus->dev.groups = NULL;
	dev_set_name(&bus->dev, ""%s"", bus->id);

 	err = device_register(&bus->dev);
 	if (err) {
 		pr_err(""mii_bus %s failed to register\n"", bus->id);
//flaw_line_below:
		put_device(&bus->dev);
 		return -EINVAL;
 	}
 
	mutex_init(&bus->mdio_lock);

	/* de-assert bus level PHY GPIO reset */
	gpiod = devm_gpiod_get_optional(&bus->dev, ""reset"", GPIOD_OUT_LOW);
	if (IS_ERR(gpiod)) {
		dev_err(&bus->dev, ""mii_bus %s couldn't get reset GPIO\n"",
			bus->id);
		device_del(&bus->dev);
		return PTR_ERR(gpiod);
	} else	if (gpiod) {
		bus->reset_gpiod = gpiod;

		gpiod_set_value_cansleep(gpiod, 1);
		udelay(bus->reset_delay_us);
		gpiod_set_value_cansleep(gpiod, 0);
	}

	if (bus->reset)
		bus->reset(bus);

	for (i = 0; i < PHY_MAX_ADDR; i++) {
		if ((bus->phy_mask & (1 << i)) == 0) {
			struct phy_device *phydev;

			phydev = mdiobus_scan(bus, i);
			if (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {
				err = PTR_ERR(phydev);
				goto error;
			}
		}
	}

	mdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);

	bus->state = MDIOBUS_REGISTERED;
	pr_info(""%s: probed\n"", bus->name);
	return 0;

error:
	while (--i >= 0) {
		mdiodev = bus->mdio_map[i];
		if (!mdiodev)
			continue;

		mdiodev->device_remove(mdiodev);
		mdiodev->device_free(mdiodev);
	}

	/* Put PHYs in RESET to save power */
	if (bus->reset_gpiod)
		gpiod_set_value_cansleep(bus->reset_gpiod, 1);

	device_del(&bus->dev);
	return err;
}
",182824,"int __mdiobus_register(struct mii_bus *bus, struct module *owner)
{
	struct mdio_device *mdiodev;
	int i, err;
	struct gpio_desc *gpiod;

	if (NULL == bus || NULL == bus->name ||
	    NULL == bus->read || NULL == bus->write)
		return -EINVAL;

	BUG_ON(bus->state != MDIOBUS_ALLOCATED &&
	       bus->state != MDIOBUS_UNREGISTERED);

	bus->owner = owner;
	bus->dev.parent = bus->parent;
	bus->dev.class = &mdio_bus_class;
	bus->dev.groups = NULL;
	dev_set_name(&bus->dev, ""%s"", bus->id);

 	err = device_register(&bus->dev);
 	if (err) {
 		pr_err(""mii_bus %s failed to register\n"", bus->id);
		put_device(&bus->dev);
 		return -EINVAL;
 	}
 
	mutex_init(&bus->mdio_lock);

	/* de-assert bus level PHY GPIO reset */
	gpiod = devm_gpiod_get_optional(&bus->dev, ""reset"", GPIOD_OUT_LOW);
	if (IS_ERR(gpiod)) {
		dev_err(&bus->dev, ""mii_bus %s couldn't get reset GPIO\n"",
			bus->id);
		device_del(&bus->dev);
		return PTR_ERR(gpiod);
	} else	if (gpiod) {
		bus->reset_gpiod = gpiod;

		gpiod_set_value_cansleep(gpiod, 1);
		udelay(bus->reset_delay_us);
		gpiod_set_value_cansleep(gpiod, 0);
	}

	if (bus->reset)
		bus->reset(bus);

	for (i = 0; i < PHY_MAX_ADDR; i++) {
		if ((bus->phy_mask & (1 << i)) == 0) {
			struct phy_device *phydev;

			phydev = mdiobus_scan(bus, i);
			if (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {
				err = PTR_ERR(phydev);
				goto error;
			}
		}
	}

	mdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);

	bus->state = MDIOBUS_REGISTERED;
	pr_info(""%s: probed\n"", bus->name);
	return 0;

error:
	while (--i >= 0) {
		mdiodev = bus->mdio_map[i];
		if (!mdiodev)
			continue;

		mdiodev->device_remove(mdiodev);
		mdiodev->device_free(mdiodev);
	}

	/* Put PHYs in RESET to save power */
	if (bus->reset_gpiod)
		gpiod_set_value_cansleep(bus->reset_gpiod, 1);

	device_del(&bus->dev);
	return err;
}
","int __mdiobus_register(struct mii_bus *bus, struct module *owner)
{
	struct mdio_device *mdiodev;
	int i, err;
	struct gpio_desc *gpiod;

	if (NULL == bus || NULL == bus->name ||
	    NULL == bus->read || NULL == bus->write)
		return -EINVAL;

	BUG_ON(bus->state != MDIOBUS_ALLOCATED &&
	       bus->state != MDIOBUS_UNREGISTERED);

	bus->owner = owner;
	bus->dev.parent = bus->parent;
	bus->dev.class = &mdio_bus_class;
	bus->dev.groups = NULL;
	dev_set_name(&bus->dev, ""%s"", bus->id);

 	err = device_register(&bus->dev);
 	if (err) {
 		pr_err(""mii_bus %s failed to register\n"", bus->id);
 		return -EINVAL;
 	}
 
	mutex_init(&bus->mdio_lock);

	/* de-assert bus level PHY GPIO reset */
	gpiod = devm_gpiod_get_optional(&bus->dev, ""reset"", GPIOD_OUT_LOW);
	if (IS_ERR(gpiod)) {
		dev_err(&bus->dev, ""mii_bus %s couldn't get reset GPIO\n"",
			bus->id);
		device_del(&bus->dev);
		return PTR_ERR(gpiod);
	} else	if (gpiod) {
		bus->reset_gpiod = gpiod;

		gpiod_set_value_cansleep(gpiod, 1);
		udelay(bus->reset_delay_us);
		gpiod_set_value_cansleep(gpiod, 0);
	}

	if (bus->reset)
		bus->reset(bus);

	for (i = 0; i < PHY_MAX_ADDR; i++) {
		if ((bus->phy_mask & (1 << i)) == 0) {
			struct phy_device *phydev;

			phydev = mdiobus_scan(bus, i);
			if (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {
				err = PTR_ERR(phydev);
				goto error;
			}
		}
	}

	mdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);

	bus->state = MDIOBUS_REGISTERED;
	pr_info(""%s: probed\n"", bus->name);
	return 0;

error:
	while (--i >= 0) {
		mdiodev = bus->mdio_map[i];
		if (!mdiodev)
			continue;

		mdiodev->device_remove(mdiodev);
		mdiodev->device_free(mdiodev);
	}

	/* Put PHYs in RESET to save power */
	if (bus->reset_gpiod)
		gpiod_set_value_cansleep(bus->reset_gpiod, 1);

	device_del(&bus->dev);
	return err;
}
","The `__mdiobus_register` function is responsible for registering a Media Independent Interface (MII) bus in a Linux kernel module. It first validates the input parameters and checks the bus state, then initializes the bus's device structure and registers it with the device model. The function handles GPIO for resetting the bus, scans for PHY devices, and sets up the MDIO devices based on board information. If any errors occur during registration or scanning, it cleans up by removing and freeing any registered devices, ensuring proper resource management. Finally, it logs the successful registration of the bus.","The code defines a function that registers a Media Independent Interface bus within a Linux kernel module. It begins by validating input parameters and checking the bus's state before initializing the device structure and registering it. The function manages GPIO for resetting the bus, scans for connected PHY devices, and configures them based on board specifications. In case of errors during registration or scanning, it ensures proper cleanup by removing and freeing any registered devices. Finally, it logs a message indicating the successful registration of the bus, ensuring efficient resource management throughout the process.","The vulnerability in the original code stemmed from a use-after-free condition that occurred when the `device_register` function failed. In this scenario, the code called `put_device`, which released the last reference to the device, allowing the `mdiobus_release` function to be executed and freeing the bus. However, subsequent access to the bus led to undefined behavior. The fix involved removing the call to `put_device` upon `device_register` failure, ensuring that the bus remained valid for cleanup operations. This change prevents the use-after-free issue by allowing the `mdiobus_free` function to manage the bus's lifecycle correctly.","The vulnerability in the original code was a use-after-free issue that occurred when the registration of a device failed. The code incorrectly released the last reference to the device, which allowed the cleanup function to free the bus prematurely. This led to potential access of freed memory, causing undefined behavior. The fix involved removing the call that released the device reference upon registration failure, ensuring that the bus remained valid for cleanup operations. This change allowed the proper management of the bus's lifecycle, preventing any access to freed memory and thus eliminating the use-after-free vulnerability.","The vulnerability was fixed by removing the call to `put_device` after the failure of `device_register`. In the original code, this call released the last reference to the device, which could lead to a use-after-free condition when the bus was accessed again. By eliminating this call, the bus remains valid even if `device_register` fails, allowing the cleanup process to be handled correctly by `mdiobus_free`. This ensures that the bus is not prematurely freed, thus preventing any access to freed memory and maintaining the integrity of the device's lifecycle management.","The vulnerability was fixed by removing the reference release that occurred after a failed device registration. In the original implementation, this release led to the premature freeing of the device, which could result in accessing invalid memory later on. By eliminating this release, the device remains valid even if the registration fails, allowing for proper cleanup without risking access to freed memory. This change ensures that the device's lifecycle is managed correctly, preventing any undefined behavior associated with use-after-free conditions and maintaining the stability of the system.","CWE-416, CWE-825, CWE-415, CWE-404, CWE-762, CWE-911, CWE-672, CWE-913, CWE-908, CWE-666",Y,1
58,58,182841,182841,,Remote,Not required,Partial,CVE-2019-12106,https://www.cvedetails.com/cve/CVE-2019-12106/,CWE-416,Low,,,,2019-05-15,5.0,The updateDevice function in minissdpd.c in MiniUPnP MiniSSDPd 1.4 and 1.5 allows a remote attacker to crash the process due to a Use After Free vulnerability.,2019-05-26,,1,https://github.com/miniupnp/miniupnp/commit/cd506a67e174a45c6a202eff182a712955ed6d6f,cd506a67e174a45c6a202eff182a712955ed6d6f,updateDevice() remove element from the list when realloc fails,0,minissdpd/minissdpd.c,"{""sha"": ""5c9c5d6207c69365554e4c6c15feb28ea586558b"", ""filename"": ""minissdpd/minissdpd.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/miniupnp/miniupnp/blob/cd506a67e174a45c6a202eff182a712955ed6d6f/minissdpd/minissdpd.c"", ""raw_url"": ""https://github.com/miniupnp/miniupnp/raw/cd506a67e174a45c6a202eff182a712955ed6d6f/minissdpd/minissdpd.c"", ""contents_url"": ""https://api.github.com/repos/miniupnp/miniupnp/contents/minissdpd/minissdpd.c?ref=cd506a67e174a45c6a202eff182a712955ed6d6f"", ""patch"": ""@@ -318,6 +318,7 @@ updateDevice(const struct header * headers, time_t t)\n \t\t\t\tif(!tmp)\t/* allocation error */\n \t\t\t\t{\n \t\t\t\t\tsyslog(LOG_ERR, \""updateDevice() : memory allocation error\"");\n+\t\t\t\t\t*pp = p->next;\t/* remove \""p\"" from the list */\n \t\t\t\t\tfree(p);\n \t\t\t\t\treturn 0;\n \t\t\t\t}""}","updateDevice(const struct header * headers, time_t t)
{
	struct device ** pp = &devlist;
	struct device * p = *pp;	/* = devlist; */
	while(p)
	{
		if(  p->headers[HEADER_NT].l == headers[HEADER_NT].l
		  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))
		  && p->headers[HEADER_USN].l == headers[HEADER_USN].l
		  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )
		{
			/*printf(""found! %d\n"", (int)(t - p->t));*/
			syslog(LOG_DEBUG, ""device updated : %.*s"", headers[HEADER_USN].l, headers[HEADER_USN].p);
			p->t = t;
			/* update Location ! */
			if(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)
			{
				struct device * tmp;
				tmp = realloc(p, sizeof(struct device)
				    + headers[0].l+headers[1].l+headers[2].l);
 				if(!tmp)	/* allocation error */
 				{
 					syslog(LOG_ERR, ""updateDevice() : memory allocation error"");
					*pp = p->next;	/* remove ""p"" from the list */
 					free(p);
 					return 0;
 				}
				p = tmp;
				*pp = p;
			}
			memcpy(p->data + p->headers[0].l + p->headers[1].l,
			       headers[2].p, headers[2].l);
			/* TODO : check p->headers[HEADER_LOCATION].l */
			return 0;
		}
		pp = &p->next;
		p = *pp;	/* p = p->next; */
	}
	syslog(LOG_INFO, ""new device discovered : %.*s"",
	       headers[HEADER_USN].l, headers[HEADER_USN].p);
	/* add */
	{
		char * pc;
		int i;
		p = malloc(  sizeof(struct device)
		           + headers[0].l+headers[1].l+headers[2].l );
		if(!p) {
			syslog(LOG_ERR, ""updateDevice(): cannot allocate memory"");
			return -1;
		}
		p->next = devlist;
		p->t = t;
		pc = p->data;
		for(i = 0; i < 3; i++)
		{
			p->headers[i].p = pc;
			p->headers[i].l = headers[i].l;
			memcpy(pc, headers[i].p, headers[i].l);
			pc += headers[i].l;
		}
		devlist = p;
		sendNotifications(NOTIF_NEW, p, NULL);
	}
	return 1;
}
","updateDevice(const struct header * headers, time_t t)
{
	struct device ** pp = &devlist;
	struct device * p = *pp;	/* = devlist; */
	while(p)
	{
		if(  p->headers[HEADER_NT].l == headers[HEADER_NT].l
		  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))
		  && p->headers[HEADER_USN].l == headers[HEADER_USN].l
		  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )
		{
			/*printf(""found! %d\n"", (int)(t - p->t));*/
			syslog(LOG_DEBUG, ""device updated : %.*s"", headers[HEADER_USN].l, headers[HEADER_USN].p);
			p->t = t;
			/* update Location ! */
			if(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)
			{
				struct device * tmp;
				tmp = realloc(p, sizeof(struct device)
				    + headers[0].l+headers[1].l+headers[2].l);
 				if(!tmp)	/* allocation error */
 				{
 					syslog(LOG_ERR, ""updateDevice() : memory allocation error"");
 					free(p);
 					return 0;
 				}
				p = tmp;
				*pp = p;
			}
			memcpy(p->data + p->headers[0].l + p->headers[1].l,
			       headers[2].p, headers[2].l);
			/* TODO : check p->headers[HEADER_LOCATION].l */
			return 0;
		}
		pp = &p->next;
		p = *pp;	/* p = p->next; */
	}
	syslog(LOG_INFO, ""new device discovered : %.*s"",
	       headers[HEADER_USN].l, headers[HEADER_USN].p);
	/* add */
	{
		char * pc;
		int i;
		p = malloc(  sizeof(struct device)
		           + headers[0].l+headers[1].l+headers[2].l );
		if(!p) {
			syslog(LOG_ERR, ""updateDevice(): cannot allocate memory"");
			return -1;
		}
		p->next = devlist;
		p->t = t;
		pc = p->data;
		for(i = 0; i < 3; i++)
		{
			p->headers[i].p = pc;
			p->headers[i].l = headers[i].l;
			memcpy(pc, headers[i].p, headers[i].l);
			pc += headers[i].l;
		}
		devlist = p;
		sendNotifications(NOTIF_NEW, p, NULL);
	}
	return 1;
}
",C,"					*pp = p->next;	/* remove ""p"" from the list */
",,,"@@ -318,6 +318,7 @@ updateDevice(const struct header * headers, time_t t)
 				if(!tmp)	/* allocation error */
 				{
 					syslog(LOG_ERR, ""updateDevice() : memory allocation error"");
+					*pp = p->next;	/* remove ""p"" from the list */
 					free(p);
 					return 0;
 				}",miniupnp,cd506a67e174a45c6a202eff182a712955ed6d6f,9066896195927f9ffad4e3708d060c5c666b7bfd,1,"updateDevice(const struct header * headers, time_t t)
{
	struct device ** pp = &devlist;
	struct device * p = *pp;	/* = devlist; */
	while(p)
	{
		if(  p->headers[HEADER_NT].l == headers[HEADER_NT].l
		  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))
		  && p->headers[HEADER_USN].l == headers[HEADER_USN].l
		  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )
		{
			/*printf(""found! %d\n"", (int)(t - p->t));*/
			syslog(LOG_DEBUG, ""device updated : %.*s"", headers[HEADER_USN].l, headers[HEADER_USN].p);
			p->t = t;
			/* update Location ! */
			if(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)
			{
				struct device * tmp;
				tmp = realloc(p, sizeof(struct device)
				    + headers[0].l+headers[1].l+headers[2].l);
 				if(!tmp)	/* allocation error */
 				{
 					syslog(LOG_ERR, ""updateDevice() : memory allocation error"");
//fix_flaw_line_below:
//					*pp = p->next;	/* remove ""p"" from the list */
 					free(p);
 					return 0;
 				}
				p = tmp;
				*pp = p;
			}
			memcpy(p->data + p->headers[0].l + p->headers[1].l,
			       headers[2].p, headers[2].l);
			/* TODO : check p->headers[HEADER_LOCATION].l */
			return 0;
		}
		pp = &p->next;
		p = *pp;	/* p = p->next; */
	}
	syslog(LOG_INFO, ""new device discovered : %.*s"",
	       headers[HEADER_USN].l, headers[HEADER_USN].p);
	/* add */
	{
		char * pc;
		int i;
		p = malloc(  sizeof(struct device)
		           + headers[0].l+headers[1].l+headers[2].l );
		if(!p) {
			syslog(LOG_ERR, ""updateDevice(): cannot allocate memory"");
			return -1;
		}
		p->next = devlist;
		p->t = t;
		pc = p->data;
		for(i = 0; i < 3; i++)
		{
			p->headers[i].p = pc;
			p->headers[i].l = headers[i].l;
			memcpy(pc, headers[i].p, headers[i].l);
			pc += headers[i].l;
		}
		devlist = p;
		sendNotifications(NOTIF_NEW, p, NULL);
	}
	return 1;
}
",182841,"updateDevice(const struct header * headers, time_t t)
{
	struct device ** pp = &devlist;
	struct device * p = *pp;	/* = devlist; */
	while(p)
	{
		if(  p->headers[HEADER_NT].l == headers[HEADER_NT].l
		  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))
		  && p->headers[HEADER_USN].l == headers[HEADER_USN].l
		  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )
		{
			/*printf(""found! %d\n"", (int)(t - p->t));*/
			syslog(LOG_DEBUG, ""device updated : %.*s"", headers[HEADER_USN].l, headers[HEADER_USN].p);
			p->t = t;
			/* update Location ! */
			if(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)
			{
				struct device * tmp;
				tmp = realloc(p, sizeof(struct device)
				    + headers[0].l+headers[1].l+headers[2].l);
 				if(!tmp)	/* allocation error */
 				{
 					syslog(LOG_ERR, ""updateDevice() : memory allocation error"");
 					free(p);
 					return 0;
 				}
				p = tmp;
				*pp = p;
			}
			memcpy(p->data + p->headers[0].l + p->headers[1].l,
			       headers[2].p, headers[2].l);
			/* TODO : check p->headers[HEADER_LOCATION].l */
			return 0;
		}
		pp = &p->next;
		p = *pp;	/* p = p->next; */
	}
	syslog(LOG_INFO, ""new device discovered : %.*s"",
	       headers[HEADER_USN].l, headers[HEADER_USN].p);
	/* add */
	{
		char * pc;
		int i;
		p = malloc(  sizeof(struct device)
		           + headers[0].l+headers[1].l+headers[2].l );
		if(!p) {
			syslog(LOG_ERR, ""updateDevice(): cannot allocate memory"");
			return -1;
		}
		p->next = devlist;
		p->t = t;
		pc = p->data;
		for(i = 0; i < 3; i++)
		{
			p->headers[i].p = pc;
			p->headers[i].l = headers[i].l;
			memcpy(pc, headers[i].p, headers[i].l);
			pc += headers[i].l;
		}
		devlist = p;
		sendNotifications(NOTIF_NEW, p, NULL);
	}
	return 1;
}
","updateDevice(const struct header * headers, time_t t)
{
	struct device ** pp = &devlist;
	struct device * p = *pp;	/* = devlist; */
	while(p)
	{
		if(  p->headers[HEADER_NT].l == headers[HEADER_NT].l
		  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))
		  && p->headers[HEADER_USN].l == headers[HEADER_USN].l
		  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )
		{
			/*printf(""found! %d\n"", (int)(t - p->t));*/
			syslog(LOG_DEBUG, ""device updated : %.*s"", headers[HEADER_USN].l, headers[HEADER_USN].p);
			p->t = t;
			/* update Location ! */
			if(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)
			{
				struct device * tmp;
				tmp = realloc(p, sizeof(struct device)
				    + headers[0].l+headers[1].l+headers[2].l);
 				if(!tmp)	/* allocation error */
 				{
 					syslog(LOG_ERR, ""updateDevice() : memory allocation error"");
					*pp = p->next;	/* remove ""p"" from the list */
 					free(p);
 					return 0;
 				}
				p = tmp;
				*pp = p;
			}
			memcpy(p->data + p->headers[0].l + p->headers[1].l,
			       headers[2].p, headers[2].l);
			/* TODO : check p->headers[HEADER_LOCATION].l */
			return 0;
		}
		pp = &p->next;
		p = *pp;	/* p = p->next; */
	}
	syslog(LOG_INFO, ""new device discovered : %.*s"",
	       headers[HEADER_USN].l, headers[HEADER_USN].p);
	/* add */
	{
		char * pc;
		int i;
		p = malloc(  sizeof(struct device)
		           + headers[0].l+headers[1].l+headers[2].l );
		if(!p) {
			syslog(LOG_ERR, ""updateDevice(): cannot allocate memory"");
			return -1;
		}
		p->next = devlist;
		p->t = t;
		pc = p->data;
		for(i = 0; i < 3; i++)
		{
			p->headers[i].p = pc;
			p->headers[i].l = headers[i].l;
			memcpy(pc, headers[i].p, headers[i].l);
			pc += headers[i].l;
		}
		devlist = p;
		sendNotifications(NOTIF_NEW, p, NULL);
	}
	return 1;
}
","The `updateDevice` function updates or adds a device to a linked list based on provided header information and a timestamp. It first searches for an existing device in the list that matches the specified headers for `HEADER_NT` and `HEADER_USN`. If found, it updates the device's timestamp and potentially reallocates memory for the device's location data if the new location is larger. If no matching device is found, it allocates memory for a new device, initializes its headers and data, and adds it to the front of the list, subsequently sending a notification about the new device.","The code defines a function that manages a list of devices by updating existing entries or adding new ones based on incoming header information and a timestamp. It first checks for a matching device in the list using specific criteria. If a match is found, it updates the device's timestamp and may resize its memory if the new location data is larger. If no match is found, it allocates memory for a new device, initializes it with the provided headers, and adds it to the list while also sending a notification about the newly discovered device.","The vulnerability in the original code arises from a failure to properly handle memory allocation errors during the resizing of a device's data. Specifically, if the `realloc` function fails, the code does not remove the device from the list, leading to potential memory leaks and dangling pointers. In the fixed code, when `realloc` fails, the device is removed from the list by updating the pointer to skip the current device, and the memory is freed. This ensures that the list remains consistent and prevents memory-related issues, enhancing the overall stability and safety of the function.","The vulnerability in the original code stems from inadequate handling of memory allocation failures during the resizing of a device's data. If the memory reallocation fails, the code does not remove the affected device from the list, which can lead to memory leaks and inconsistencies in the device list. The fix addresses this issue by ensuring that when memory allocation fails, the device is properly removed from the list, and its memory is freed. This change enhances the robustness of the code by maintaining the integrity of the device list and preventing potential memory-related problems.","The vulnerability was fixed by modifying the error handling in the memory allocation process. In the updated code, when the `realloc` function fails, the code now updates the pointer to skip the current device by setting `*pp` to `p->next`, effectively removing the device from the list. Additionally, the memory allocated for the device is freed to prevent memory leaks. This ensures that the device list remains consistent and that resources are properly managed, thereby enhancing the stability and reliability of the function when faced with memory allocation errors.","The vulnerability was fixed by improving the error handling for memory allocation failures. When the resizing of a device's data fails, the updated code now ensures that the affected device is removed from the list to maintain consistency. This is achieved by adjusting the pointer that links to the device, effectively skipping over it. Additionally, the memory allocated for the device is freed to prevent any memory leaks. These changes enhance the overall stability and reliability of the function by ensuring that resources are managed correctly in the event of allocation errors.","CWE-789, CWE-401, CWE-476, CWE-119, CWE-404, CWE-763, CWE-415, CWE-742, CWE-400, CWE-672",N,-1
59,59,182852,182852,,Remote,Not required,Complete,CVE-2019-11811,https://www.cvedetails.com/cve/CVE-2019-11811/,CWE-416,Low,Complete,Complete,,2019-05-07,10.0,"An issue was discovered in the Linux kernel before 5.0.4. There is a use-after-free upon attempted read access to /proc/ioports after the ipmi_si module is removed, related to drivers/char/ipmi/ipmi_si_intf.c, drivers/char/ipmi/ipmi_si_mem_io.c, and drivers/char/ipmi/ipmi_si_port_io.c.",2019-05-31,,5,https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4,401e7e88d4ef80188ffa07095ac00456f901b8c4,"ipmi_si: fix use-after-free of resource->name

When we excute the following commands, we got oops
rmmod ipmi_si
cat /proc/ioports

[ 1623.482380] Unable to handle kernel paging request at virtual address ffff00000901d478
[ 1623.482382] Mem abort info:
[ 1623.482383]   ESR = 0x96000007
[ 1623.482385]   Exception class = DABT (current EL), IL = 32 bits
[ 1623.482386]   SET = 0, FnV = 0
[ 1623.482387]   EA = 0, S1PTW = 0
[ 1623.482388] Data abort info:
[ 1623.482389]   ISV = 0, ISS = 0x00000007
[ 1623.482390]   CM = 0, WnR = 0
[ 1623.482393] swapper pgtable: 4k pages, 48-bit VAs, pgdp = 00000000d7d94a66
[ 1623.482395] [ffff00000901d478] pgd=000000dffbfff003, pud=000000dffbffe003, pmd=0000003f5d06e003, pte=0000000000000000
[ 1623.482399] Internal error: Oops: 96000007 [#1] SMP
[ 1623.487407] Modules linked in: ipmi_si(E) nls_utf8 isofs rpcrdma ib_iser ib_srpt target_core_mod ib_srp scsi_transport_srp ib_ipoib rdma_ucm ib_umad rdma_cm ib_cm dm_mirror dm_region_hash dm_log iw_cm dm_mod aes_ce_blk crypto_simd cryptd aes_ce_cipher ses ghash_ce sha2_ce enclosure sha256_arm64 sg sha1_ce hisi_sas_v2_hw hibmc_drm sbsa_gwdt hisi_sas_main ip_tables mlx5_ib ib_uverbs marvell ib_core mlx5_core ixgbe mdio hns_dsaf ipmi_devintf hns_enet_drv ipmi_msghandler hns_mdio [last unloaded: ipmi_si]
[ 1623.532410] CPU: 30 PID: 11438 Comm: cat Kdump: loaded Tainted: G            E     5.0.0-rc3+ #168
[ 1623.541498] Hardware name: Huawei TaiShan 2280 /BC11SPCD, BIOS 1.37 11/21/2017
[ 1623.548822] pstate: a0000005 (NzCv daif -PAN -UAO)
[ 1623.553684] pc : string+0x28/0x98
[ 1623.557040] lr : vsnprintf+0x368/0x5e8
[ 1623.560837] sp : ffff000013213a80
[ 1623.564191] x29: ffff000013213a80 x28: ffff00001138abb5
[ 1623.569577] x27: ffff000013213c18 x26: ffff805f67d06049
[ 1623.574963] x25: 0000000000000000 x24: ffff00001138abb5
[ 1623.580349] x23: 0000000000000fb7 x22: ffff0000117ed000
[ 1623.585734] x21: ffff000011188fd8 x20: ffff805f67d07000
[ 1623.591119] x19: ffff805f67d06061 x18: ffffffffffffffff
[ 1623.596505] x17: 0000000000000200 x16: 0000000000000000
[ 1623.601890] x15: ffff0000117ed748 x14: ffff805f67d07000
[ 1623.607276] x13: ffff805f67d0605e x12: 0000000000000000
[ 1623.612661] x11: 0000000000000000 x10: 0000000000000000
[ 1623.618046] x9 : 0000000000000000 x8 : 000000000000000f
[ 1623.623432] x7 : ffff805f67d06061 x6 : fffffffffffffffe
[ 1623.628817] x5 : 0000000000000012 x4 : ffff00000901d478
[ 1623.634203] x3 : ffff0a00ffffff04 x2 : ffff805f67d07000
[ 1623.639588] x1 : ffff805f67d07000 x0 : ffffffffffffffff
[ 1623.644974] Process cat (pid: 11438, stack limit = 0x000000008d4cbc10)
[ 1623.651592] Call trace:
[ 1623.654068]  string+0x28/0x98
[ 1623.657071]  vsnprintf+0x368/0x5e8
[ 1623.660517]  seq_vprintf+0x70/0x98
[ 1623.668009]  seq_printf+0x7c/0xa0
[ 1623.675530]  r_show+0xc8/0xf8
[ 1623.682558]  seq_read+0x330/0x440
[ 1623.689877]  proc_reg_read+0x78/0xd0
[ 1623.697346]  __vfs_read+0x60/0x1a0
[ 1623.704564]  vfs_read+0x94/0x150
[ 1623.711339]  ksys_read+0x6c/0xd8
[ 1623.717939]  __arm64_sys_read+0x24/0x30
[ 1623.725077]  el0_svc_common+0x120/0x148
[ 1623.732035]  el0_svc_handler+0x30/0x40
[ 1623.738757]  el0_svc+0x8/0xc
[ 1623.744520] Code: d1000406 aa0103e2 54000149 b4000080 (39400085)
[ 1623.753441] ---[ end trace f91b6a4937de9835 ]---
[ 1623.760871] Kernel panic - not syncing: Fatal exception
[ 1623.768935] SMP: stopping secondary CPUs
[ 1623.775718] Kernel Offset: disabled
[ 1623.781998] CPU features: 0x002,21006008
[ 1623.788777] Memory Limit: none
[ 1623.798329] Starting crashdump kernel...
[ 1623.805202] Bye!

If io_setup is called successful in try_smi_init() but try_smi_init()
goes out_err before calling ipmi_register_smi(), so ipmi_unregister_smi()
will not be called while removing module. It leads to the resource that
allocated in io_setup() can not be freed, but the name(DEVICE_NAME) of
resource is freed while removing the module. It causes use-after-free
when cat /proc/ioports.

Fix this by calling io_cleanup() while try_smi_init() goes to out_err.
and don't call io_cleanup() until io_setup() returns successful to avoid
warning prints.

Fixes: 93c303d2045b (""ipmi_si: Clean up shutdown a bit"")
Cc: stable@vger.kernel.org
Reported-by: NuoHan Qiao <qiaonuohan@huawei.com>
Suggested-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Yang Yingliang <yangyingliang@huawei.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>",0,drivers/char/ipmi/ipmi_si_intf.c,"{""sha"": ""f1b9fda6b9dfbc7e89b1d02b7a5777393923783f"", ""filename"": ""drivers/char/ipmi/ipmi_si_intf.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_intf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_intf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/ipmi/ipmi_si_intf.c?ref=401e7e88d4ef80188ffa07095ac00456f901b8c4"", ""patch"": ""@@ -2085,6 +2085,11 @@ static int try_smi_init(struct smi_info *new_smi)\n \tWARN_ON(new_smi->io.dev->init_name != NULL);\n \n  out_err:\n+\tif (rv && new_smi->io.io_cleanup) {\n+\t\tnew_smi->io.io_cleanup(&new_smi->io);\n+\t\tnew_smi->io.io_cleanup = NULL;\n+\t}\n+\n \tkfree(init_name);\n \treturn rv;\n }""}<_**next**_>{""sha"": ""75583612ab10551367cd74d727a0cbda958d0429"", ""filename"": ""drivers/char/ipmi/ipmi_si_mem_io.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_mem_io.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_mem_io.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/ipmi/ipmi_si_mem_io.c?ref=401e7e88d4ef80188ffa07095ac00456f901b8c4"", ""patch"": ""@@ -81,8 +81,6 @@ int ipmi_si_mem_setup(struct si_sm_io *io)\n \tif (!addr)\n \t\treturn -ENODEV;\n \n-\tio->io_cleanup = mem_cleanup;\n-\n \t/*\n \t * Figure out the actual readb/readw/readl/etc routine to use based\n \t * upon the register size.\n@@ -141,5 +139,8 @@ int ipmi_si_mem_setup(struct si_sm_io *io)\n \t\tmem_region_cleanup(io, io->io_size);\n \t\treturn -EIO;\n \t}\n+\n+\tio->io_cleanup = mem_cleanup;\n+\n \treturn 0;\n }""}<_**next**_>{""sha"": ""03924c32b6e98035ad3b873c4d19320d8aa89567"", ""filename"": ""drivers/char/ipmi/ipmi_si_port_io.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_port_io.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_port_io.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/ipmi/ipmi_si_port_io.c?ref=401e7e88d4ef80188ffa07095ac00456f901b8c4"", ""patch"": ""@@ -68,8 +68,6 @@ int ipmi_si_port_setup(struct si_sm_io *io)\n \tif (!addr)\n \t\treturn -ENODEV;\n \n-\tio->io_cleanup = port_cleanup;\n-\n \t/*\n \t * Figure out the actual inb/inw/inl/etc routine to use based\n \t * upon the register size.\n@@ -109,5 +107,8 @@ int ipmi_si_port_setup(struct si_sm_io *io)\n \t\t\treturn -EIO;\n \t\t}\n \t}\n+\n+\tio->io_cleanup = port_cleanup;\n+\n \treturn 0;\n }""}","static int try_smi_init(struct smi_info *new_smi)
{
	int rv = 0;
	int i;
	char *init_name = NULL;

	pr_info(""Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\n"",
		ipmi_addr_src_to_str(new_smi->io.addr_source),
		si_to_str[new_smi->io.si_type],
		addr_space_to_str[new_smi->io.addr_type],
		new_smi->io.addr_data,
		new_smi->io.slave_addr, new_smi->io.irq);

	switch (new_smi->io.si_type) {
	case SI_KCS:
		new_smi->handlers = &kcs_smi_handlers;
		break;

	case SI_SMIC:
		new_smi->handlers = &smic_smi_handlers;
		break;

	case SI_BT:
		new_smi->handlers = &bt_smi_handlers;
		break;

	default:
		/* No support for anything else yet. */
		rv = -EIO;
		goto out_err;
	}

	new_smi->si_num = smi_num;

	/* Do this early so it's available for logs. */
	if (!new_smi->io.dev) {
		init_name = kasprintf(GFP_KERNEL, ""ipmi_si.%d"",
				      new_smi->si_num);

		/*
		 * If we don't already have a device from something
		 * else (like PCI), then register a new one.
		 */
		new_smi->pdev = platform_device_alloc(""ipmi_si"",
						      new_smi->si_num);
		if (!new_smi->pdev) {
			pr_err(""Unable to allocate platform device\n"");
			rv = -ENOMEM;
			goto out_err;
		}
		new_smi->io.dev = &new_smi->pdev->dev;
		new_smi->io.dev->driver = &ipmi_platform_driver.driver;
		/* Nulled by device_add() */
		new_smi->io.dev->init_name = init_name;
	}

	/* Allocate the state machine's data and initialize it. */
	new_smi->si_sm = kmalloc(new_smi->handlers->size(), GFP_KERNEL);
	if (!new_smi->si_sm) {
		rv = -ENOMEM;
		goto out_err;
	}
	new_smi->io.io_size = new_smi->handlers->init_data(new_smi->si_sm,
							   &new_smi->io);

	/* Now that we know the I/O size, we can set up the I/O. */
	rv = new_smi->io.io_setup(&new_smi->io);
	if (rv) {
		dev_err(new_smi->io.dev, ""Could not set up I/O space\n"");
		goto out_err;
	}

	/* Do low-level detection first. */
	if (new_smi->handlers->detect(new_smi->si_sm)) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
				""Interface detection failed\n"");
		rv = -ENODEV;
		goto out_err;
	}

	/*
	 * Attempt a get device id command.  If it fails, we probably
	 * don't have a BMC here.
	 */
	rv = try_get_dev_id(new_smi);
	if (rv) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
			       ""There appears to be no BMC at this location\n"");
		goto out_err;
	}

	setup_oem_data_handler(new_smi);
	setup_xaction_handlers(new_smi);
	check_for_broken_irqs(new_smi);

	new_smi->waiting_msg = NULL;
	new_smi->curr_msg = NULL;
	atomic_set(&new_smi->req_events, 0);
	new_smi->run_to_completion = false;
	for (i = 0; i < SI_NUM_STATS; i++)
		atomic_set(&new_smi->stats[i], 0);

	new_smi->interrupt_disabled = true;
	atomic_set(&new_smi->need_watch, 0);

	rv = try_enable_event_buffer(new_smi);
	if (rv == 0)
		new_smi->has_event_buffer = true;

	/*
	 * Start clearing the flags before we enable interrupts or the
	 * timer to avoid racing with the timer.
	 */
	start_clear_flags(new_smi);

	/*
	 * IRQ is defined to be set when non-zero.  req_events will
	 * cause a global flags check that will enable interrupts.
	 */
	if (new_smi->io.irq) {
		new_smi->interrupt_disabled = false;
		atomic_set(&new_smi->req_events, 1);
	}

	if (new_smi->pdev && !new_smi->pdev_registered) {
		rv = platform_device_add(new_smi->pdev);
		if (rv) {
			dev_err(new_smi->io.dev,
				""Unable to register system interface device: %d\n"",
				rv);
			goto out_err;
		}
		new_smi->pdev_registered = true;
	}

	dev_set_drvdata(new_smi->io.dev, new_smi);
	rv = device_add_group(new_smi->io.dev, &ipmi_si_dev_attr_group);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to add device attributes: error %d\n"",
			rv);
		goto out_err;
	}
	new_smi->dev_group_added = true;

	rv = ipmi_register_smi(&handlers,
			       new_smi,
			       new_smi->io.dev,
			       new_smi->io.slave_addr);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to register device: error %d\n"",
			rv);
		goto out_err;
	}

	/* Don't increment till we know we have succeeded. */
	smi_num++;

	dev_info(new_smi->io.dev, ""IPMI %s interface initialized\n"",
		 si_to_str[new_smi->io.si_type]);

 	WARN_ON(new_smi->io.dev->init_name != NULL);
 
  out_err:
	if (rv && new_smi->io.io_cleanup) {
		new_smi->io.io_cleanup(&new_smi->io);
		new_smi->io.io_cleanup = NULL;
	}

 	kfree(init_name);
 	return rv;
 }
","static int try_smi_init(struct smi_info *new_smi)
{
	int rv = 0;
	int i;
	char *init_name = NULL;

	pr_info(""Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\n"",
		ipmi_addr_src_to_str(new_smi->io.addr_source),
		si_to_str[new_smi->io.si_type],
		addr_space_to_str[new_smi->io.addr_type],
		new_smi->io.addr_data,
		new_smi->io.slave_addr, new_smi->io.irq);

	switch (new_smi->io.si_type) {
	case SI_KCS:
		new_smi->handlers = &kcs_smi_handlers;
		break;

	case SI_SMIC:
		new_smi->handlers = &smic_smi_handlers;
		break;

	case SI_BT:
		new_smi->handlers = &bt_smi_handlers;
		break;

	default:
		/* No support for anything else yet. */
		rv = -EIO;
		goto out_err;
	}

	new_smi->si_num = smi_num;

	/* Do this early so it's available for logs. */
	if (!new_smi->io.dev) {
		init_name = kasprintf(GFP_KERNEL, ""ipmi_si.%d"",
				      new_smi->si_num);

		/*
		 * If we don't already have a device from something
		 * else (like PCI), then register a new one.
		 */
		new_smi->pdev = platform_device_alloc(""ipmi_si"",
						      new_smi->si_num);
		if (!new_smi->pdev) {
			pr_err(""Unable to allocate platform device\n"");
			rv = -ENOMEM;
			goto out_err;
		}
		new_smi->io.dev = &new_smi->pdev->dev;
		new_smi->io.dev->driver = &ipmi_platform_driver.driver;
		/* Nulled by device_add() */
		new_smi->io.dev->init_name = init_name;
	}

	/* Allocate the state machine's data and initialize it. */
	new_smi->si_sm = kmalloc(new_smi->handlers->size(), GFP_KERNEL);
	if (!new_smi->si_sm) {
		rv = -ENOMEM;
		goto out_err;
	}
	new_smi->io.io_size = new_smi->handlers->init_data(new_smi->si_sm,
							   &new_smi->io);

	/* Now that we know the I/O size, we can set up the I/O. */
	rv = new_smi->io.io_setup(&new_smi->io);
	if (rv) {
		dev_err(new_smi->io.dev, ""Could not set up I/O space\n"");
		goto out_err;
	}

	/* Do low-level detection first. */
	if (new_smi->handlers->detect(new_smi->si_sm)) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
				""Interface detection failed\n"");
		rv = -ENODEV;
		goto out_err;
	}

	/*
	 * Attempt a get device id command.  If it fails, we probably
	 * don't have a BMC here.
	 */
	rv = try_get_dev_id(new_smi);
	if (rv) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
			       ""There appears to be no BMC at this location\n"");
		goto out_err;
	}

	setup_oem_data_handler(new_smi);
	setup_xaction_handlers(new_smi);
	check_for_broken_irqs(new_smi);

	new_smi->waiting_msg = NULL;
	new_smi->curr_msg = NULL;
	atomic_set(&new_smi->req_events, 0);
	new_smi->run_to_completion = false;
	for (i = 0; i < SI_NUM_STATS; i++)
		atomic_set(&new_smi->stats[i], 0);

	new_smi->interrupt_disabled = true;
	atomic_set(&new_smi->need_watch, 0);

	rv = try_enable_event_buffer(new_smi);
	if (rv == 0)
		new_smi->has_event_buffer = true;

	/*
	 * Start clearing the flags before we enable interrupts or the
	 * timer to avoid racing with the timer.
	 */
	start_clear_flags(new_smi);

	/*
	 * IRQ is defined to be set when non-zero.  req_events will
	 * cause a global flags check that will enable interrupts.
	 */
	if (new_smi->io.irq) {
		new_smi->interrupt_disabled = false;
		atomic_set(&new_smi->req_events, 1);
	}

	if (new_smi->pdev && !new_smi->pdev_registered) {
		rv = platform_device_add(new_smi->pdev);
		if (rv) {
			dev_err(new_smi->io.dev,
				""Unable to register system interface device: %d\n"",
				rv);
			goto out_err;
		}
		new_smi->pdev_registered = true;
	}

	dev_set_drvdata(new_smi->io.dev, new_smi);
	rv = device_add_group(new_smi->io.dev, &ipmi_si_dev_attr_group);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to add device attributes: error %d\n"",
			rv);
		goto out_err;
	}
	new_smi->dev_group_added = true;

	rv = ipmi_register_smi(&handlers,
			       new_smi,
			       new_smi->io.dev,
			       new_smi->io.slave_addr);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to register device: error %d\n"",
			rv);
		goto out_err;
	}

	/* Don't increment till we know we have succeeded. */
	smi_num++;

	dev_info(new_smi->io.dev, ""IPMI %s interface initialized\n"",
		 si_to_str[new_smi->io.si_type]);

 	WARN_ON(new_smi->io.dev->init_name != NULL);
 
  out_err:
 	kfree(init_name);
 	return rv;
 }
",C,"	if (rv && new_smi->io.io_cleanup) {
		new_smi->io.io_cleanup(&new_smi->io);
		new_smi->io.io_cleanup = NULL;
	}

",,,"@@ -2085,6 +2085,11 @@ static int try_smi_init(struct smi_info *new_smi)
 	WARN_ON(new_smi->io.dev->init_name != NULL);
 
  out_err:
+	if (rv && new_smi->io.io_cleanup) {
+		new_smi->io.io_cleanup(&new_smi->io);
+		new_smi->io.io_cleanup = NULL;
+	}
+
 	kfree(init_name);
 	return rv;
 }",linux,401e7e88d4ef80188ffa07095ac00456f901b8c4,df3865f8f56879b7e9f0ca47fa7bc5f2252df6d3,1,"static int try_smi_init(struct smi_info *new_smi)
{
	int rv = 0;
	int i;
	char *init_name = NULL;

	pr_info(""Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\n"",
		ipmi_addr_src_to_str(new_smi->io.addr_source),
		si_to_str[new_smi->io.si_type],
		addr_space_to_str[new_smi->io.addr_type],
		new_smi->io.addr_data,
		new_smi->io.slave_addr, new_smi->io.irq);

	switch (new_smi->io.si_type) {
	case SI_KCS:
		new_smi->handlers = &kcs_smi_handlers;
		break;

	case SI_SMIC:
		new_smi->handlers = &smic_smi_handlers;
		break;

	case SI_BT:
		new_smi->handlers = &bt_smi_handlers;
		break;

	default:
		/* No support for anything else yet. */
		rv = -EIO;
		goto out_err;
	}

	new_smi->si_num = smi_num;

	/* Do this early so it's available for logs. */
	if (!new_smi->io.dev) {
		init_name = kasprintf(GFP_KERNEL, ""ipmi_si.%d"",
				      new_smi->si_num);

		/*
		 * If we don't already have a device from something
		 * else (like PCI), then register a new one.
		 */
		new_smi->pdev = platform_device_alloc(""ipmi_si"",
						      new_smi->si_num);
		if (!new_smi->pdev) {
			pr_err(""Unable to allocate platform device\n"");
			rv = -ENOMEM;
			goto out_err;
		}
		new_smi->io.dev = &new_smi->pdev->dev;
		new_smi->io.dev->driver = &ipmi_platform_driver.driver;
		/* Nulled by device_add() */
		new_smi->io.dev->init_name = init_name;
	}

	/* Allocate the state machine's data and initialize it. */
	new_smi->si_sm = kmalloc(new_smi->handlers->size(), GFP_KERNEL);
	if (!new_smi->si_sm) {
		rv = -ENOMEM;
		goto out_err;
	}
	new_smi->io.io_size = new_smi->handlers->init_data(new_smi->si_sm,
							   &new_smi->io);

	/* Now that we know the I/O size, we can set up the I/O. */
	rv = new_smi->io.io_setup(&new_smi->io);
	if (rv) {
		dev_err(new_smi->io.dev, ""Could not set up I/O space\n"");
		goto out_err;
	}

	/* Do low-level detection first. */
	if (new_smi->handlers->detect(new_smi->si_sm)) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
				""Interface detection failed\n"");
		rv = -ENODEV;
		goto out_err;
	}

	/*
	 * Attempt a get device id command.  If it fails, we probably
	 * don't have a BMC here.
	 */
	rv = try_get_dev_id(new_smi);
	if (rv) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
			       ""There appears to be no BMC at this location\n"");
		goto out_err;
	}

	setup_oem_data_handler(new_smi);
	setup_xaction_handlers(new_smi);
	check_for_broken_irqs(new_smi);

	new_smi->waiting_msg = NULL;
	new_smi->curr_msg = NULL;
	atomic_set(&new_smi->req_events, 0);
	new_smi->run_to_completion = false;
	for (i = 0; i < SI_NUM_STATS; i++)
		atomic_set(&new_smi->stats[i], 0);

	new_smi->interrupt_disabled = true;
	atomic_set(&new_smi->need_watch, 0);

	rv = try_enable_event_buffer(new_smi);
	if (rv == 0)
		new_smi->has_event_buffer = true;

	/*
	 * Start clearing the flags before we enable interrupts or the
	 * timer to avoid racing with the timer.
	 */
	start_clear_flags(new_smi);

	/*
	 * IRQ is defined to be set when non-zero.  req_events will
	 * cause a global flags check that will enable interrupts.
	 */
	if (new_smi->io.irq) {
		new_smi->interrupt_disabled = false;
		atomic_set(&new_smi->req_events, 1);
	}

	if (new_smi->pdev && !new_smi->pdev_registered) {
		rv = platform_device_add(new_smi->pdev);
		if (rv) {
			dev_err(new_smi->io.dev,
				""Unable to register system interface device: %d\n"",
				rv);
			goto out_err;
		}
		new_smi->pdev_registered = true;
	}

	dev_set_drvdata(new_smi->io.dev, new_smi);
	rv = device_add_group(new_smi->io.dev, &ipmi_si_dev_attr_group);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to add device attributes: error %d\n"",
			rv);
		goto out_err;
	}
	new_smi->dev_group_added = true;

	rv = ipmi_register_smi(&handlers,
			       new_smi,
			       new_smi->io.dev,
			       new_smi->io.slave_addr);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to register device: error %d\n"",
			rv);
		goto out_err;
	}

	/* Don't increment till we know we have succeeded. */
	smi_num++;

	dev_info(new_smi->io.dev, ""IPMI %s interface initialized\n"",
		 si_to_str[new_smi->io.si_type]);

 	WARN_ON(new_smi->io.dev->init_name != NULL);
 
  out_err:
//fix_flaw_line_below:
//	if (rv && new_smi->io.io_cleanup) {
//fix_flaw_line_below:
//		new_smi->io.io_cleanup(&new_smi->io);
//fix_flaw_line_below:
//		new_smi->io.io_cleanup = NULL;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	kfree(init_name);
 	return rv;
 }
",182852,"static int try_smi_init(struct smi_info *new_smi)
{
	int rv = 0;
	int i;
	char *init_name = NULL;

	pr_info(""Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\n"",
		ipmi_addr_src_to_str(new_smi->io.addr_source),
		si_to_str[new_smi->io.si_type],
		addr_space_to_str[new_smi->io.addr_type],
		new_smi->io.addr_data,
		new_smi->io.slave_addr, new_smi->io.irq);

	switch (new_smi->io.si_type) {
	case SI_KCS:
		new_smi->handlers = &kcs_smi_handlers;
		break;

	case SI_SMIC:
		new_smi->handlers = &smic_smi_handlers;
		break;

	case SI_BT:
		new_smi->handlers = &bt_smi_handlers;
		break;

	default:
		/* No support for anything else yet. */
		rv = -EIO;
		goto out_err;
	}

	new_smi->si_num = smi_num;

	/* Do this early so it's available for logs. */
	if (!new_smi->io.dev) {
		init_name = kasprintf(GFP_KERNEL, ""ipmi_si.%d"",
				      new_smi->si_num);

		/*
		 * If we don't already have a device from something
		 * else (like PCI), then register a new one.
		 */
		new_smi->pdev = platform_device_alloc(""ipmi_si"",
						      new_smi->si_num);
		if (!new_smi->pdev) {
			pr_err(""Unable to allocate platform device\n"");
			rv = -ENOMEM;
			goto out_err;
		}
		new_smi->io.dev = &new_smi->pdev->dev;
		new_smi->io.dev->driver = &ipmi_platform_driver.driver;
		/* Nulled by device_add() */
		new_smi->io.dev->init_name = init_name;
	}

	/* Allocate the state machine's data and initialize it. */
	new_smi->si_sm = kmalloc(new_smi->handlers->size(), GFP_KERNEL);
	if (!new_smi->si_sm) {
		rv = -ENOMEM;
		goto out_err;
	}
	new_smi->io.io_size = new_smi->handlers->init_data(new_smi->si_sm,
							   &new_smi->io);

	/* Now that we know the I/O size, we can set up the I/O. */
	rv = new_smi->io.io_setup(&new_smi->io);
	if (rv) {
		dev_err(new_smi->io.dev, ""Could not set up I/O space\n"");
		goto out_err;
	}

	/* Do low-level detection first. */
	if (new_smi->handlers->detect(new_smi->si_sm)) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
				""Interface detection failed\n"");
		rv = -ENODEV;
		goto out_err;
	}

	/*
	 * Attempt a get device id command.  If it fails, we probably
	 * don't have a BMC here.
	 */
	rv = try_get_dev_id(new_smi);
	if (rv) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
			       ""There appears to be no BMC at this location\n"");
		goto out_err;
	}

	setup_oem_data_handler(new_smi);
	setup_xaction_handlers(new_smi);
	check_for_broken_irqs(new_smi);

	new_smi->waiting_msg = NULL;
	new_smi->curr_msg = NULL;
	atomic_set(&new_smi->req_events, 0);
	new_smi->run_to_completion = false;
	for (i = 0; i < SI_NUM_STATS; i++)
		atomic_set(&new_smi->stats[i], 0);

	new_smi->interrupt_disabled = true;
	atomic_set(&new_smi->need_watch, 0);

	rv = try_enable_event_buffer(new_smi);
	if (rv == 0)
		new_smi->has_event_buffer = true;

	/*
	 * Start clearing the flags before we enable interrupts or the
	 * timer to avoid racing with the timer.
	 */
	start_clear_flags(new_smi);

	/*
	 * IRQ is defined to be set when non-zero.  req_events will
	 * cause a global flags check that will enable interrupts.
	 */
	if (new_smi->io.irq) {
		new_smi->interrupt_disabled = false;
		atomic_set(&new_smi->req_events, 1);
	}

	if (new_smi->pdev && !new_smi->pdev_registered) {
		rv = platform_device_add(new_smi->pdev);
		if (rv) {
			dev_err(new_smi->io.dev,
				""Unable to register system interface device: %d\n"",
				rv);
			goto out_err;
		}
		new_smi->pdev_registered = true;
	}

	dev_set_drvdata(new_smi->io.dev, new_smi);
	rv = device_add_group(new_smi->io.dev, &ipmi_si_dev_attr_group);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to add device attributes: error %d\n"",
			rv);
		goto out_err;
	}
	new_smi->dev_group_added = true;

	rv = ipmi_register_smi(&handlers,
			       new_smi,
			       new_smi->io.dev,
			       new_smi->io.slave_addr);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to register device: error %d\n"",
			rv);
		goto out_err;
	}

	/* Don't increment till we know we have succeeded. */
	smi_num++;

	dev_info(new_smi->io.dev, ""IPMI %s interface initialized\n"",
		 si_to_str[new_smi->io.si_type]);

 	WARN_ON(new_smi->io.dev->init_name != NULL);
 
  out_err:
 	kfree(init_name);
 	return rv;
 }
","static int try_smi_init(struct smi_info *new_smi)
{
	int rv = 0;
	int i;
	char *init_name = NULL;

	pr_info(""Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\n"",
		ipmi_addr_src_to_str(new_smi->io.addr_source),
		si_to_str[new_smi->io.si_type],
		addr_space_to_str[new_smi->io.addr_type],
		new_smi->io.addr_data,
		new_smi->io.slave_addr, new_smi->io.irq);

	switch (new_smi->io.si_type) {
	case SI_KCS:
		new_smi->handlers = &kcs_smi_handlers;
		break;

	case SI_SMIC:
		new_smi->handlers = &smic_smi_handlers;
		break;

	case SI_BT:
		new_smi->handlers = &bt_smi_handlers;
		break;

	default:
		/* No support for anything else yet. */
		rv = -EIO;
		goto out_err;
	}

	new_smi->si_num = smi_num;

	/* Do this early so it's available for logs. */
	if (!new_smi->io.dev) {
		init_name = kasprintf(GFP_KERNEL, ""ipmi_si.%d"",
				      new_smi->si_num);

		/*
		 * If we don't already have a device from something
		 * else (like PCI), then register a new one.
		 */
		new_smi->pdev = platform_device_alloc(""ipmi_si"",
						      new_smi->si_num);
		if (!new_smi->pdev) {
			pr_err(""Unable to allocate platform device\n"");
			rv = -ENOMEM;
			goto out_err;
		}
		new_smi->io.dev = &new_smi->pdev->dev;
		new_smi->io.dev->driver = &ipmi_platform_driver.driver;
		/* Nulled by device_add() */
		new_smi->io.dev->init_name = init_name;
	}

	/* Allocate the state machine's data and initialize it. */
	new_smi->si_sm = kmalloc(new_smi->handlers->size(), GFP_KERNEL);
	if (!new_smi->si_sm) {
		rv = -ENOMEM;
		goto out_err;
	}
	new_smi->io.io_size = new_smi->handlers->init_data(new_smi->si_sm,
							   &new_smi->io);

	/* Now that we know the I/O size, we can set up the I/O. */
	rv = new_smi->io.io_setup(&new_smi->io);
	if (rv) {
		dev_err(new_smi->io.dev, ""Could not set up I/O space\n"");
		goto out_err;
	}

	/* Do low-level detection first. */
	if (new_smi->handlers->detect(new_smi->si_sm)) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
				""Interface detection failed\n"");
		rv = -ENODEV;
		goto out_err;
	}

	/*
	 * Attempt a get device id command.  If it fails, we probably
	 * don't have a BMC here.
	 */
	rv = try_get_dev_id(new_smi);
	if (rv) {
		if (new_smi->io.addr_source)
			dev_err(new_smi->io.dev,
			       ""There appears to be no BMC at this location\n"");
		goto out_err;
	}

	setup_oem_data_handler(new_smi);
	setup_xaction_handlers(new_smi);
	check_for_broken_irqs(new_smi);

	new_smi->waiting_msg = NULL;
	new_smi->curr_msg = NULL;
	atomic_set(&new_smi->req_events, 0);
	new_smi->run_to_completion = false;
	for (i = 0; i < SI_NUM_STATS; i++)
		atomic_set(&new_smi->stats[i], 0);

	new_smi->interrupt_disabled = true;
	atomic_set(&new_smi->need_watch, 0);

	rv = try_enable_event_buffer(new_smi);
	if (rv == 0)
		new_smi->has_event_buffer = true;

	/*
	 * Start clearing the flags before we enable interrupts or the
	 * timer to avoid racing with the timer.
	 */
	start_clear_flags(new_smi);

	/*
	 * IRQ is defined to be set when non-zero.  req_events will
	 * cause a global flags check that will enable interrupts.
	 */
	if (new_smi->io.irq) {
		new_smi->interrupt_disabled = false;
		atomic_set(&new_smi->req_events, 1);
	}

	if (new_smi->pdev && !new_smi->pdev_registered) {
		rv = platform_device_add(new_smi->pdev);
		if (rv) {
			dev_err(new_smi->io.dev,
				""Unable to register system interface device: %d\n"",
				rv);
			goto out_err;
		}
		new_smi->pdev_registered = true;
	}

	dev_set_drvdata(new_smi->io.dev, new_smi);
	rv = device_add_group(new_smi->io.dev, &ipmi_si_dev_attr_group);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to add device attributes: error %d\n"",
			rv);
		goto out_err;
	}
	new_smi->dev_group_added = true;

	rv = ipmi_register_smi(&handlers,
			       new_smi,
			       new_smi->io.dev,
			       new_smi->io.slave_addr);
	if (rv) {
		dev_err(new_smi->io.dev,
			""Unable to register device: error %d\n"",
			rv);
		goto out_err;
	}

	/* Don't increment till we know we have succeeded. */
	smi_num++;

	dev_info(new_smi->io.dev, ""IPMI %s interface initialized\n"",
		 si_to_str[new_smi->io.si_type]);

 	WARN_ON(new_smi->io.dev->init_name != NULL);
 
  out_err:
	if (rv && new_smi->io.io_cleanup) {
		new_smi->io.io_cleanup(&new_smi->io);
		new_smi->io.io_cleanup = NULL;
	}

 	kfree(init_name);
 	return rv;
 }
","The `try_smi_init` function initializes a state machine interface (SMI) for IPMI (Intelligent Platform Management Interface) by configuring various parameters based on the specified interface type. It logs the initialization attempt, allocates necessary resources, and sets up device attributes. The function handles different SMI types (KCS, SMIC, BT) by assigning appropriate handlers and performing low-level detection to ensure the interface is operational. It also manages event buffers, interrupts, and device registration, while checking for errors at each step. Finally, it returns a status code indicating success or failure of the initialization process.","The provided code initializes a state machine interface for a specific communication protocol by configuring its parameters and allocating necessary resources. It logs the initialization attempt and assigns appropriate handlers based on the interface type. The function performs checks to ensure the interface is operational, manages event buffers and interrupts, and registers the device within the system. It also handles error conditions at various stages, ensuring that resources are properly allocated and cleaned up if any issues arise. Ultimately, it returns a status code indicating the success or failure of the initialization process.","The vulnerability in the original code stemmed from a use-after-free condition, where resources allocated during the I/O setup were not properly cleaned up if the initialization process failed before reaching the registration step. Specifically, if the function exited early due to an error after successfully calling the I/O setup, the allocated resources would remain unfreed while the name associated with those resources was deallocated upon module removal, leading to potential access violations. The fix involved adding a check to call the cleanup function for the I/O resources if an error occurred, ensuring that resources were released appropriately before the function exited, thus preventing the use-after-free issue.","The vulnerability in the original code was a use-after-free issue that occurred when resources allocated during the I/O setup were not properly released if the initialization process failed before reaching the registration step. This situation arose because, if an error occurred after the I/O setup was successful, the allocated resources would remain unfreed while the associated name was deallocated upon module removal, leading to potential access violations. The fix involved ensuring that the cleanup function for the I/O resources was called whenever an error occurred, thus preventing the use-after-free condition by ensuring all resources were properly managed before exiting the function.","The vulnerability was fixed by modifying the error handling in the `try_smi_init` function. Specifically, the code now checks if an error occurs after the successful call to `io_setup` and ensures that `io_cleanup` is called in the `out_err` section if `rv` indicates a failure. This prevents the use-after-free issue by ensuring that resources allocated during `io_setup` are properly released before the function exits. Additionally, the cleanup is only invoked if `io_setup` was successful, avoiding unnecessary warnings and ensuring that resources are managed correctly throughout the initialization process.","The vulnerability was addressed by enhancing the error handling mechanism within the initialization process. The fix ensures that if an error occurs after successfully setting up resources, a cleanup function is invoked to release those resources before exiting the function. This prevents the situation where allocated resources remain unfreed while associated identifiers are deallocated, which could lead to access violations. By implementing this check, the code now properly manages resource allocation and deallocation, ensuring that all resources are correctly handled throughout the initialization and error recovery processes.","CWE-404, CWE-401, CWE-772, CWE-415, CWE-775, CWE-459, CWE-761, CWE-763, CWE-911, CWE-665",N,-1
60,60,182853,182853,,Remote,Not required,Complete,CVE-2019-11811,https://www.cvedetails.com/cve/CVE-2019-11811/,CWE-416,Low,Complete,Complete,,2019-05-07,10.0,"An issue was discovered in the Linux kernel before 5.0.4. There is a use-after-free upon attempted read access to /proc/ioports after the ipmi_si module is removed, related to drivers/char/ipmi/ipmi_si_intf.c, drivers/char/ipmi/ipmi_si_mem_io.c, and drivers/char/ipmi/ipmi_si_port_io.c.",2019-05-31,,3,https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4,401e7e88d4ef80188ffa07095ac00456f901b8c4,"ipmi_si: fix use-after-free of resource->name

When we excute the following commands, we got oops
rmmod ipmi_si
cat /proc/ioports

[ 1623.482380] Unable to handle kernel paging request at virtual address ffff00000901d478
[ 1623.482382] Mem abort info:
[ 1623.482383]   ESR = 0x96000007
[ 1623.482385]   Exception class = DABT (current EL), IL = 32 bits
[ 1623.482386]   SET = 0, FnV = 0
[ 1623.482387]   EA = 0, S1PTW = 0
[ 1623.482388] Data abort info:
[ 1623.482389]   ISV = 0, ISS = 0x00000007
[ 1623.482390]   CM = 0, WnR = 0
[ 1623.482393] swapper pgtable: 4k pages, 48-bit VAs, pgdp = 00000000d7d94a66
[ 1623.482395] [ffff00000901d478] pgd=000000dffbfff003, pud=000000dffbffe003, pmd=0000003f5d06e003, pte=0000000000000000
[ 1623.482399] Internal error: Oops: 96000007 [#1] SMP
[ 1623.487407] Modules linked in: ipmi_si(E) nls_utf8 isofs rpcrdma ib_iser ib_srpt target_core_mod ib_srp scsi_transport_srp ib_ipoib rdma_ucm ib_umad rdma_cm ib_cm dm_mirror dm_region_hash dm_log iw_cm dm_mod aes_ce_blk crypto_simd cryptd aes_ce_cipher ses ghash_ce sha2_ce enclosure sha256_arm64 sg sha1_ce hisi_sas_v2_hw hibmc_drm sbsa_gwdt hisi_sas_main ip_tables mlx5_ib ib_uverbs marvell ib_core mlx5_core ixgbe mdio hns_dsaf ipmi_devintf hns_enet_drv ipmi_msghandler hns_mdio [last unloaded: ipmi_si]
[ 1623.532410] CPU: 30 PID: 11438 Comm: cat Kdump: loaded Tainted: G            E     5.0.0-rc3+ #168
[ 1623.541498] Hardware name: Huawei TaiShan 2280 /BC11SPCD, BIOS 1.37 11/21/2017
[ 1623.548822] pstate: a0000005 (NzCv daif -PAN -UAO)
[ 1623.553684] pc : string+0x28/0x98
[ 1623.557040] lr : vsnprintf+0x368/0x5e8
[ 1623.560837] sp : ffff000013213a80
[ 1623.564191] x29: ffff000013213a80 x28: ffff00001138abb5
[ 1623.569577] x27: ffff000013213c18 x26: ffff805f67d06049
[ 1623.574963] x25: 0000000000000000 x24: ffff00001138abb5
[ 1623.580349] x23: 0000000000000fb7 x22: ffff0000117ed000
[ 1623.585734] x21: ffff000011188fd8 x20: ffff805f67d07000
[ 1623.591119] x19: ffff805f67d06061 x18: ffffffffffffffff
[ 1623.596505] x17: 0000000000000200 x16: 0000000000000000
[ 1623.601890] x15: ffff0000117ed748 x14: ffff805f67d07000
[ 1623.607276] x13: ffff805f67d0605e x12: 0000000000000000
[ 1623.612661] x11: 0000000000000000 x10: 0000000000000000
[ 1623.618046] x9 : 0000000000000000 x8 : 000000000000000f
[ 1623.623432] x7 : ffff805f67d06061 x6 : fffffffffffffffe
[ 1623.628817] x5 : 0000000000000012 x4 : ffff00000901d478
[ 1623.634203] x3 : ffff0a00ffffff04 x2 : ffff805f67d07000
[ 1623.639588] x1 : ffff805f67d07000 x0 : ffffffffffffffff
[ 1623.644974] Process cat (pid: 11438, stack limit = 0x000000008d4cbc10)
[ 1623.651592] Call trace:
[ 1623.654068]  string+0x28/0x98
[ 1623.657071]  vsnprintf+0x368/0x5e8
[ 1623.660517]  seq_vprintf+0x70/0x98
[ 1623.668009]  seq_printf+0x7c/0xa0
[ 1623.675530]  r_show+0xc8/0xf8
[ 1623.682558]  seq_read+0x330/0x440
[ 1623.689877]  proc_reg_read+0x78/0xd0
[ 1623.697346]  __vfs_read+0x60/0x1a0
[ 1623.704564]  vfs_read+0x94/0x150
[ 1623.711339]  ksys_read+0x6c/0xd8
[ 1623.717939]  __arm64_sys_read+0x24/0x30
[ 1623.725077]  el0_svc_common+0x120/0x148
[ 1623.732035]  el0_svc_handler+0x30/0x40
[ 1623.738757]  el0_svc+0x8/0xc
[ 1623.744520] Code: d1000406 aa0103e2 54000149 b4000080 (39400085)
[ 1623.753441] ---[ end trace f91b6a4937de9835 ]---
[ 1623.760871] Kernel panic - not syncing: Fatal exception
[ 1623.768935] SMP: stopping secondary CPUs
[ 1623.775718] Kernel Offset: disabled
[ 1623.781998] CPU features: 0x002,21006008
[ 1623.788777] Memory Limit: none
[ 1623.798329] Starting crashdump kernel...
[ 1623.805202] Bye!

If io_setup is called successful in try_smi_init() but try_smi_init()
goes out_err before calling ipmi_register_smi(), so ipmi_unregister_smi()
will not be called while removing module. It leads to the resource that
allocated in io_setup() can not be freed, but the name(DEVICE_NAME) of
resource is freed while removing the module. It causes use-after-free
when cat /proc/ioports.

Fix this by calling io_cleanup() while try_smi_init() goes to out_err.
and don't call io_cleanup() until io_setup() returns successful to avoid
warning prints.

Fixes: 93c303d2045b (""ipmi_si: Clean up shutdown a bit"")
Cc: stable@vger.kernel.org
Reported-by: NuoHan Qiao <qiaonuohan@huawei.com>
Suggested-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Yang Yingliang <yangyingliang@huawei.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>",1,drivers/char/ipmi/ipmi_si_mem_io.c,"{""sha"": ""f1b9fda6b9dfbc7e89b1d02b7a5777393923783f"", ""filename"": ""drivers/char/ipmi/ipmi_si_intf.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_intf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_intf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/ipmi/ipmi_si_intf.c?ref=401e7e88d4ef80188ffa07095ac00456f901b8c4"", ""patch"": ""@@ -2085,6 +2085,11 @@ static int try_smi_init(struct smi_info *new_smi)\n \tWARN_ON(new_smi->io.dev->init_name != NULL);\n \n  out_err:\n+\tif (rv && new_smi->io.io_cleanup) {\n+\t\tnew_smi->io.io_cleanup(&new_smi->io);\n+\t\tnew_smi->io.io_cleanup = NULL;\n+\t}\n+\n \tkfree(init_name);\n \treturn rv;\n }""}<_**next**_>{""sha"": ""75583612ab10551367cd74d727a0cbda958d0429"", ""filename"": ""drivers/char/ipmi/ipmi_si_mem_io.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_mem_io.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_mem_io.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/ipmi/ipmi_si_mem_io.c?ref=401e7e88d4ef80188ffa07095ac00456f901b8c4"", ""patch"": ""@@ -81,8 +81,6 @@ int ipmi_si_mem_setup(struct si_sm_io *io)\n \tif (!addr)\n \t\treturn -ENODEV;\n \n-\tio->io_cleanup = mem_cleanup;\n-\n \t/*\n \t * Figure out the actual readb/readw/readl/etc routine to use based\n \t * upon the register size.\n@@ -141,5 +139,8 @@ int ipmi_si_mem_setup(struct si_sm_io *io)\n \t\tmem_region_cleanup(io, io->io_size);\n \t\treturn -EIO;\n \t}\n+\n+\tio->io_cleanup = mem_cleanup;\n+\n \treturn 0;\n }""}<_**next**_>{""sha"": ""03924c32b6e98035ad3b873c4d19320d8aa89567"", ""filename"": ""drivers/char/ipmi/ipmi_si_port_io.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_port_io.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_port_io.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/ipmi/ipmi_si_port_io.c?ref=401e7e88d4ef80188ffa07095ac00456f901b8c4"", ""patch"": ""@@ -68,8 +68,6 @@ int ipmi_si_port_setup(struct si_sm_io *io)\n \tif (!addr)\n \t\treturn -ENODEV;\n \n-\tio->io_cleanup = port_cleanup;\n-\n \t/*\n \t * Figure out the actual inb/inw/inl/etc routine to use based\n \t * upon the register size.\n@@ -109,5 +107,8 @@ int ipmi_si_port_setup(struct si_sm_io *io)\n \t\t\treturn -EIO;\n \t\t}\n \t}\n+\n+\tio->io_cleanup = port_cleanup;\n+\n \treturn 0;\n }""}","int ipmi_si_mem_setup(struct si_sm_io *io)
{
	unsigned long addr = io->addr_data;
	int           mapsize, idx;

 	if (!addr)
 		return -ENODEV;
 
 	/*
 	 * Figure out the actual readb/readw/readl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = intf_mem_inb;
		io->outputb = intf_mem_outb;
		break;
	case 2:
		io->inputb = intf_mem_inw;
		io->outputb = intf_mem_outw;
		break;
	case 4:
		io->inputb = intf_mem_inl;
		io->outputb = intf_mem_outl;
		break;
#ifdef readq
	case 8:
		io->inputb = mem_inq;
		io->outputb = mem_outq;
		break;
#endif
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint memory regions in their ACPI
	 * tables.  This causes problems when trying to request the
	 * entire region.  Therefore we must request each register
	 * separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_mem_region(addr + idx * io->regspacing,
				       io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			mem_region_cleanup(io, idx);
			return -EIO;
		}
	}

	/*
	 * Calculate the total amount of memory to claim.  This is an
	 * unusual looking calculation, but it avoids claiming any
	 * more memory than it has to.  It will claim everything
	 * between the first address to the end of the last full
	 * register.
	 */
	mapsize = ((io->io_size * io->regspacing)
		   - (io->regspacing - io->regsize));
	io->addr = ioremap(addr, mapsize);
	if (io->addr == NULL) {
 		mem_region_cleanup(io, io->io_size);
 		return -EIO;
 	}

	io->io_cleanup = mem_cleanup;

 	return 0;
 }
","int ipmi_si_mem_setup(struct si_sm_io *io)
{
	unsigned long addr = io->addr_data;
	int           mapsize, idx;

 	if (!addr)
 		return -ENODEV;
 
	io->io_cleanup = mem_cleanup;
 	/*
 	 * Figure out the actual readb/readw/readl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = intf_mem_inb;
		io->outputb = intf_mem_outb;
		break;
	case 2:
		io->inputb = intf_mem_inw;
		io->outputb = intf_mem_outw;
		break;
	case 4:
		io->inputb = intf_mem_inl;
		io->outputb = intf_mem_outl;
		break;
#ifdef readq
	case 8:
		io->inputb = mem_inq;
		io->outputb = mem_outq;
		break;
#endif
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint memory regions in their ACPI
	 * tables.  This causes problems when trying to request the
	 * entire region.  Therefore we must request each register
	 * separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_mem_region(addr + idx * io->regspacing,
				       io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			mem_region_cleanup(io, idx);
			return -EIO;
		}
	}

	/*
	 * Calculate the total amount of memory to claim.  This is an
	 * unusual looking calculation, but it avoids claiming any
	 * more memory than it has to.  It will claim everything
	 * between the first address to the end of the last full
	 * register.
	 */
	mapsize = ((io->io_size * io->regspacing)
		   - (io->regspacing - io->regsize));
	io->addr = ioremap(addr, mapsize);
	if (io->addr == NULL) {
 		mem_region_cleanup(io, io->io_size);
 		return -EIO;
 	}
 	return 0;
 }
",C,"
	io->io_cleanup = mem_cleanup;

","	io->io_cleanup = mem_cleanup;
",,"@@ -81,8 +81,6 @@ int ipmi_si_mem_setup(struct si_sm_io *io)
 	if (!addr)
 		return -ENODEV;
 
-	io->io_cleanup = mem_cleanup;
-
 	/*
 	 * Figure out the actual readb/readw/readl/etc routine to use based
 	 * upon the register size.
@@ -141,5 +139,8 @@ int ipmi_si_mem_setup(struct si_sm_io *io)
 		mem_region_cleanup(io, io->io_size);
 		return -EIO;
 	}
+
+	io->io_cleanup = mem_cleanup;
+
 	return 0;
 }",linux,401e7e88d4ef80188ffa07095ac00456f901b8c4,df3865f8f56879b7e9f0ca47fa7bc5f2252df6d3,1,"int ipmi_si_mem_setup(struct si_sm_io *io)
{
	unsigned long addr = io->addr_data;
	int           mapsize, idx;

 	if (!addr)
 		return -ENODEV;
 
//flaw_line_below:
	io->io_cleanup = mem_cleanup;
//flaw_line_below:

 	/*
 	 * Figure out the actual readb/readw/readl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = intf_mem_inb;
		io->outputb = intf_mem_outb;
		break;
	case 2:
		io->inputb = intf_mem_inw;
		io->outputb = intf_mem_outw;
		break;
	case 4:
		io->inputb = intf_mem_inl;
		io->outputb = intf_mem_outl;
		break;
#ifdef readq
	case 8:
		io->inputb = mem_inq;
		io->outputb = mem_outq;
		break;
#endif
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint memory regions in their ACPI
	 * tables.  This causes problems when trying to request the
	 * entire region.  Therefore we must request each register
	 * separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_mem_region(addr + idx * io->regspacing,
				       io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			mem_region_cleanup(io, idx);
			return -EIO;
		}
	}

	/*
	 * Calculate the total amount of memory to claim.  This is an
	 * unusual looking calculation, but it avoids claiming any
	 * more memory than it has to.  It will claim everything
	 * between the first address to the end of the last full
	 * register.
	 */
	mapsize = ((io->io_size * io->regspacing)
		   - (io->regspacing - io->regsize));
	io->addr = ioremap(addr, mapsize);
	if (io->addr == NULL) {
 		mem_region_cleanup(io, io->io_size);
 		return -EIO;
 	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	io->io_cleanup = mem_cleanup;
//fix_flaw_line_below:
//
 	return 0;
 }
",182853,"int ipmi_si_mem_setup(struct si_sm_io *io)
{
	unsigned long addr = io->addr_data;
	int           mapsize, idx;

 	if (!addr)
 		return -ENODEV;
 
	io->io_cleanup = mem_cleanup;
 	/*
 	 * Figure out the actual readb/readw/readl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = intf_mem_inb;
		io->outputb = intf_mem_outb;
		break;
	case 2:
		io->inputb = intf_mem_inw;
		io->outputb = intf_mem_outw;
		break;
	case 4:
		io->inputb = intf_mem_inl;
		io->outputb = intf_mem_outl;
		break;
#ifdef readq
	case 8:
		io->inputb = mem_inq;
		io->outputb = mem_outq;
		break;
#endif
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint memory regions in their ACPI
	 * tables.  This causes problems when trying to request the
	 * entire region.  Therefore we must request each register
	 * separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_mem_region(addr + idx * io->regspacing,
				       io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			mem_region_cleanup(io, idx);
			return -EIO;
		}
	}

	/*
	 * Calculate the total amount of memory to claim.  This is an
	 * unusual looking calculation, but it avoids claiming any
	 * more memory than it has to.  It will claim everything
	 * between the first address to the end of the last full
	 * register.
	 */
	mapsize = ((io->io_size * io->regspacing)
		   - (io->regspacing - io->regsize));
	io->addr = ioremap(addr, mapsize);
	if (io->addr == NULL) {
 		mem_region_cleanup(io, io->io_size);
 		return -EIO;
 	}
 	return 0;
 }
","int ipmi_si_mem_setup(struct si_sm_io *io)
{
	unsigned long addr = io->addr_data;
	int           mapsize, idx;

 	if (!addr)
 		return -ENODEV;
 
 	/*
 	 * Figure out the actual readb/readw/readl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = intf_mem_inb;
		io->outputb = intf_mem_outb;
		break;
	case 2:
		io->inputb = intf_mem_inw;
		io->outputb = intf_mem_outw;
		break;
	case 4:
		io->inputb = intf_mem_inl;
		io->outputb = intf_mem_outl;
		break;
#ifdef readq
	case 8:
		io->inputb = mem_inq;
		io->outputb = mem_outq;
		break;
#endif
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint memory regions in their ACPI
	 * tables.  This causes problems when trying to request the
	 * entire region.  Therefore we must request each register
	 * separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_mem_region(addr + idx * io->regspacing,
				       io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			mem_region_cleanup(io, idx);
			return -EIO;
		}
	}

	/*
	 * Calculate the total amount of memory to claim.  This is an
	 * unusual looking calculation, but it avoids claiming any
	 * more memory than it has to.  It will claim everything
	 * between the first address to the end of the last full
	 * register.
	 */
	mapsize = ((io->io_size * io->regspacing)
		   - (io->regspacing - io->regsize));
	io->addr = ioremap(addr, mapsize);
	if (io->addr == NULL) {
 		mem_region_cleanup(io, io->io_size);
 		return -EIO;
 	}

	io->io_cleanup = mem_cleanup;

 	return 0;
 }
","The `ipmi_si_mem_setup` function initializes memory-mapped I/O for a device by setting up the appropriate read and write routines based on the specified register size. It first checks if the address is valid; if not, it returns an error. Depending on the register size (1, 2, 4, or 8 bytes), it assigns the corresponding input and output functions. The function then requests memory regions for each register individually to handle potential disjoint memory areas. Finally, it calculates the total memory to claim, maps the memory, and returns success or an error code if any step fails.","The code initializes memory-mapped I/O for a device by verifying the validity of the address and determining the appropriate read and write operations based on the size of the registers. It handles potential issues with disjoint memory regions by requesting each register's memory separately. After ensuring that all necessary memory regions are allocated, it calculates the total memory required for mapping and attempts to map this memory. If any step fails, it cleans up previously allocated resources and returns an error code; otherwise, it indicates successful initialization.","The vulnerability in the original code stemmed from a use-after-free condition, where resources allocated during the setup process were not properly released if an error occurred before the registration of the device. Specifically, if the setup function succeeded but the subsequent initialization failed, the cleanup function was not called, leading to a situation where the resource's name was freed while the resource itself remained allocated. The fix involved ensuring that the cleanup function is called if the initialization fails, thus preventing the use-after-free issue by ensuring all resources are properly released before exiting the function.","The vulnerability in the original code was a use-after-free issue that occurred when resources allocated during the initialization process were not properly released if an error happened before the device registration. Specifically, if the setup succeeded but the subsequent steps failed, the cleanup function was not called, leading to a situation where the resource's name was freed while the resource itself remained allocated. The fix involved ensuring that the cleanup function is invoked if an error occurs during initialization, thus preventing the use-after-free condition by ensuring all resources are released appropriately before exiting the function.","The vulnerability was fixed by modifying the error handling in the `try_smi_init` function. Specifically, the cleanup function `io_cleanup` is now called when the function encounters an error and goes to the `out_err` label, ensuring that any resources allocated during `io_setup` are properly released. Additionally, the cleanup function is only called after confirming that `io_setup` has successfully completed, preventing premature cleanup that could lead to warnings. This change ensures that resources are managed correctly, eliminating the use-after-free issue associated with the resource's name.","The vulnerability was addressed by enhancing the error handling mechanism during the initialization process. The cleanup routine is now invoked whenever an error occurs, ensuring that all allocated resources are properly released before exiting the function. This change prevents the situation where resources remain allocated while their associated names are freed, which could lead to accessing invalid memory. By ensuring that cleanup occurs only after successful resource allocation, the fix effectively eliminates the risk of use-after-free errors, thereby improving the overall stability and safety of the code.","CWE-401, CWE-404, CWE-416, CWE-672, CWE-415, CWE-763, CWE-773, CWE-226, CWE-459, CWE-460",N,-1
61,61,182854,182854,,Remote,Not required,Complete,CVE-2019-11811,https://www.cvedetails.com/cve/CVE-2019-11811/,CWE-416,Low,Complete,Complete,,2019-05-07,10.0,"An issue was discovered in the Linux kernel before 5.0.4. There is a use-after-free upon attempted read access to /proc/ioports after the ipmi_si module is removed, related to drivers/char/ipmi/ipmi_si_intf.c, drivers/char/ipmi/ipmi_si_mem_io.c, and drivers/char/ipmi/ipmi_si_port_io.c.",2019-05-31,,3,https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4,401e7e88d4ef80188ffa07095ac00456f901b8c4,"ipmi_si: fix use-after-free of resource->name

When we excute the following commands, we got oops
rmmod ipmi_si
cat /proc/ioports

[ 1623.482380] Unable to handle kernel paging request at virtual address ffff00000901d478
[ 1623.482382] Mem abort info:
[ 1623.482383]   ESR = 0x96000007
[ 1623.482385]   Exception class = DABT (current EL), IL = 32 bits
[ 1623.482386]   SET = 0, FnV = 0
[ 1623.482387]   EA = 0, S1PTW = 0
[ 1623.482388] Data abort info:
[ 1623.482389]   ISV = 0, ISS = 0x00000007
[ 1623.482390]   CM = 0, WnR = 0
[ 1623.482393] swapper pgtable: 4k pages, 48-bit VAs, pgdp = 00000000d7d94a66
[ 1623.482395] [ffff00000901d478] pgd=000000dffbfff003, pud=000000dffbffe003, pmd=0000003f5d06e003, pte=0000000000000000
[ 1623.482399] Internal error: Oops: 96000007 [#1] SMP
[ 1623.487407] Modules linked in: ipmi_si(E) nls_utf8 isofs rpcrdma ib_iser ib_srpt target_core_mod ib_srp scsi_transport_srp ib_ipoib rdma_ucm ib_umad rdma_cm ib_cm dm_mirror dm_region_hash dm_log iw_cm dm_mod aes_ce_blk crypto_simd cryptd aes_ce_cipher ses ghash_ce sha2_ce enclosure sha256_arm64 sg sha1_ce hisi_sas_v2_hw hibmc_drm sbsa_gwdt hisi_sas_main ip_tables mlx5_ib ib_uverbs marvell ib_core mlx5_core ixgbe mdio hns_dsaf ipmi_devintf hns_enet_drv ipmi_msghandler hns_mdio [last unloaded: ipmi_si]
[ 1623.532410] CPU: 30 PID: 11438 Comm: cat Kdump: loaded Tainted: G            E     5.0.0-rc3+ #168
[ 1623.541498] Hardware name: Huawei TaiShan 2280 /BC11SPCD, BIOS 1.37 11/21/2017
[ 1623.548822] pstate: a0000005 (NzCv daif -PAN -UAO)
[ 1623.553684] pc : string+0x28/0x98
[ 1623.557040] lr : vsnprintf+0x368/0x5e8
[ 1623.560837] sp : ffff000013213a80
[ 1623.564191] x29: ffff000013213a80 x28: ffff00001138abb5
[ 1623.569577] x27: ffff000013213c18 x26: ffff805f67d06049
[ 1623.574963] x25: 0000000000000000 x24: ffff00001138abb5
[ 1623.580349] x23: 0000000000000fb7 x22: ffff0000117ed000
[ 1623.585734] x21: ffff000011188fd8 x20: ffff805f67d07000
[ 1623.591119] x19: ffff805f67d06061 x18: ffffffffffffffff
[ 1623.596505] x17: 0000000000000200 x16: 0000000000000000
[ 1623.601890] x15: ffff0000117ed748 x14: ffff805f67d07000
[ 1623.607276] x13: ffff805f67d0605e x12: 0000000000000000
[ 1623.612661] x11: 0000000000000000 x10: 0000000000000000
[ 1623.618046] x9 : 0000000000000000 x8 : 000000000000000f
[ 1623.623432] x7 : ffff805f67d06061 x6 : fffffffffffffffe
[ 1623.628817] x5 : 0000000000000012 x4 : ffff00000901d478
[ 1623.634203] x3 : ffff0a00ffffff04 x2 : ffff805f67d07000
[ 1623.639588] x1 : ffff805f67d07000 x0 : ffffffffffffffff
[ 1623.644974] Process cat (pid: 11438, stack limit = 0x000000008d4cbc10)
[ 1623.651592] Call trace:
[ 1623.654068]  string+0x28/0x98
[ 1623.657071]  vsnprintf+0x368/0x5e8
[ 1623.660517]  seq_vprintf+0x70/0x98
[ 1623.668009]  seq_printf+0x7c/0xa0
[ 1623.675530]  r_show+0xc8/0xf8
[ 1623.682558]  seq_read+0x330/0x440
[ 1623.689877]  proc_reg_read+0x78/0xd0
[ 1623.697346]  __vfs_read+0x60/0x1a0
[ 1623.704564]  vfs_read+0x94/0x150
[ 1623.711339]  ksys_read+0x6c/0xd8
[ 1623.717939]  __arm64_sys_read+0x24/0x30
[ 1623.725077]  el0_svc_common+0x120/0x148
[ 1623.732035]  el0_svc_handler+0x30/0x40
[ 1623.738757]  el0_svc+0x8/0xc
[ 1623.744520] Code: d1000406 aa0103e2 54000149 b4000080 (39400085)
[ 1623.753441] ---[ end trace f91b6a4937de9835 ]---
[ 1623.760871] Kernel panic - not syncing: Fatal exception
[ 1623.768935] SMP: stopping secondary CPUs
[ 1623.775718] Kernel Offset: disabled
[ 1623.781998] CPU features: 0x002,21006008
[ 1623.788777] Memory Limit: none
[ 1623.798329] Starting crashdump kernel...
[ 1623.805202] Bye!

If io_setup is called successful in try_smi_init() but try_smi_init()
goes out_err before calling ipmi_register_smi(), so ipmi_unregister_smi()
will not be called while removing module. It leads to the resource that
allocated in io_setup() can not be freed, but the name(DEVICE_NAME) of
resource is freed while removing the module. It causes use-after-free
when cat /proc/ioports.

Fix this by calling io_cleanup() while try_smi_init() goes to out_err.
and don't call io_cleanup() until io_setup() returns successful to avoid
warning prints.

Fixes: 93c303d2045b (""ipmi_si: Clean up shutdown a bit"")
Cc: stable@vger.kernel.org
Reported-by: NuoHan Qiao <qiaonuohan@huawei.com>
Suggested-by: Corey Minyard <cminyard@mvista.com>
Signed-off-by: Yang Yingliang <yangyingliang@huawei.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>",1,drivers/char/ipmi/ipmi_si_port_io.c,"{""sha"": ""f1b9fda6b9dfbc7e89b1d02b7a5777393923783f"", ""filename"": ""drivers/char/ipmi/ipmi_si_intf.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_intf.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_intf.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/ipmi/ipmi_si_intf.c?ref=401e7e88d4ef80188ffa07095ac00456f901b8c4"", ""patch"": ""@@ -2085,6 +2085,11 @@ static int try_smi_init(struct smi_info *new_smi)\n \tWARN_ON(new_smi->io.dev->init_name != NULL);\n \n  out_err:\n+\tif (rv && new_smi->io.io_cleanup) {\n+\t\tnew_smi->io.io_cleanup(&new_smi->io);\n+\t\tnew_smi->io.io_cleanup = NULL;\n+\t}\n+\n \tkfree(init_name);\n \treturn rv;\n }""}<_**next**_>{""sha"": ""75583612ab10551367cd74d727a0cbda958d0429"", ""filename"": ""drivers/char/ipmi/ipmi_si_mem_io.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_mem_io.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_mem_io.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/ipmi/ipmi_si_mem_io.c?ref=401e7e88d4ef80188ffa07095ac00456f901b8c4"", ""patch"": ""@@ -81,8 +81,6 @@ int ipmi_si_mem_setup(struct si_sm_io *io)\n \tif (!addr)\n \t\treturn -ENODEV;\n \n-\tio->io_cleanup = mem_cleanup;\n-\n \t/*\n \t * Figure out the actual readb/readw/readl/etc routine to use based\n \t * upon the register size.\n@@ -141,5 +139,8 @@ int ipmi_si_mem_setup(struct si_sm_io *io)\n \t\tmem_region_cleanup(io, io->io_size);\n \t\treturn -EIO;\n \t}\n+\n+\tio->io_cleanup = mem_cleanup;\n+\n \treturn 0;\n }""}<_**next**_>{""sha"": ""03924c32b6e98035ad3b873c4d19320d8aa89567"", ""filename"": ""drivers/char/ipmi/ipmi_si_port_io.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_port_io.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/401e7e88d4ef80188ffa07095ac00456f901b8c4/drivers/char/ipmi/ipmi_si_port_io.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/ipmi/ipmi_si_port_io.c?ref=401e7e88d4ef80188ffa07095ac00456f901b8c4"", ""patch"": ""@@ -68,8 +68,6 @@ int ipmi_si_port_setup(struct si_sm_io *io)\n \tif (!addr)\n \t\treturn -ENODEV;\n \n-\tio->io_cleanup = port_cleanup;\n-\n \t/*\n \t * Figure out the actual inb/inw/inl/etc routine to use based\n \t * upon the register size.\n@@ -109,5 +107,8 @@ int ipmi_si_port_setup(struct si_sm_io *io)\n \t\t\treturn -EIO;\n \t\t}\n \t}\n+\n+\tio->io_cleanup = port_cleanup;\n+\n \treturn 0;\n }""}","int ipmi_si_port_setup(struct si_sm_io *io)
{
	unsigned int addr = io->addr_data;
	int          idx;

 	if (!addr)
 		return -ENODEV;
 
 	/*
 	 * Figure out the actual inb/inw/inl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = port_inb;
		io->outputb = port_outb;
		break;
	case 2:
		io->inputb = port_inw;
		io->outputb = port_outw;
		break;
	case 4:
		io->inputb = port_inl;
		io->outputb = port_outl;
		break;
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint I/O regions in their ACPI
	 * tables.  This causes problems when trying to register the
	 * entire I/O region.  Therefore we must register each I/O
	 * port separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_region(addr + idx * io->regspacing,
				   io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			while (idx--)
				release_region(addr + idx * io->regspacing,
					       io->regsize);
 			return -EIO;
 		}
 	}

	io->io_cleanup = port_cleanup;

 	return 0;
 }
","int ipmi_si_port_setup(struct si_sm_io *io)
{
	unsigned int addr = io->addr_data;
	int          idx;

 	if (!addr)
 		return -ENODEV;
 
	io->io_cleanup = port_cleanup;
 	/*
 	 * Figure out the actual inb/inw/inl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = port_inb;
		io->outputb = port_outb;
		break;
	case 2:
		io->inputb = port_inw;
		io->outputb = port_outw;
		break;
	case 4:
		io->inputb = port_inl;
		io->outputb = port_outl;
		break;
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint I/O regions in their ACPI
	 * tables.  This causes problems when trying to register the
	 * entire I/O region.  Therefore we must register each I/O
	 * port separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_region(addr + idx * io->regspacing,
				   io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			while (idx--)
				release_region(addr + idx * io->regspacing,
					       io->regsize);
 			return -EIO;
 		}
 	}
 	return 0;
 }
",C,"
	io->io_cleanup = port_cleanup;

","	io->io_cleanup = port_cleanup;
",,"@@ -68,8 +68,6 @@ int ipmi_si_port_setup(struct si_sm_io *io)
 	if (!addr)
 		return -ENODEV;
 
-	io->io_cleanup = port_cleanup;
-
 	/*
 	 * Figure out the actual inb/inw/inl/etc routine to use based
 	 * upon the register size.
@@ -109,5 +107,8 @@ int ipmi_si_port_setup(struct si_sm_io *io)
 			return -EIO;
 		}
 	}
+
+	io->io_cleanup = port_cleanup;
+
 	return 0;
 }",linux,401e7e88d4ef80188ffa07095ac00456f901b8c4,df3865f8f56879b7e9f0ca47fa7bc5f2252df6d3,1,"int ipmi_si_port_setup(struct si_sm_io *io)
{
	unsigned int addr = io->addr_data;
	int          idx;

 	if (!addr)
 		return -ENODEV;
 
//flaw_line_below:
	io->io_cleanup = port_cleanup;
//flaw_line_below:

 	/*
 	 * Figure out the actual inb/inw/inl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = port_inb;
		io->outputb = port_outb;
		break;
	case 2:
		io->inputb = port_inw;
		io->outputb = port_outw;
		break;
	case 4:
		io->inputb = port_inl;
		io->outputb = port_outl;
		break;
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint I/O regions in their ACPI
	 * tables.  This causes problems when trying to register the
	 * entire I/O region.  Therefore we must register each I/O
	 * port separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_region(addr + idx * io->regspacing,
				   io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			while (idx--)
				release_region(addr + idx * io->regspacing,
					       io->regsize);
 			return -EIO;
 		}
 	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	io->io_cleanup = port_cleanup;
//fix_flaw_line_below:
//
 	return 0;
 }
",182854,"int ipmi_si_port_setup(struct si_sm_io *io)
{
	unsigned int addr = io->addr_data;
	int          idx;

 	if (!addr)
 		return -ENODEV;
 
	io->io_cleanup = port_cleanup;
 	/*
 	 * Figure out the actual inb/inw/inl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = port_inb;
		io->outputb = port_outb;
		break;
	case 2:
		io->inputb = port_inw;
		io->outputb = port_outw;
		break;
	case 4:
		io->inputb = port_inl;
		io->outputb = port_outl;
		break;
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint I/O regions in their ACPI
	 * tables.  This causes problems when trying to register the
	 * entire I/O region.  Therefore we must register each I/O
	 * port separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_region(addr + idx * io->regspacing,
				   io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			while (idx--)
				release_region(addr + idx * io->regspacing,
					       io->regsize);
 			return -EIO;
 		}
 	}
 	return 0;
 }
","int ipmi_si_port_setup(struct si_sm_io *io)
{
	unsigned int addr = io->addr_data;
	int          idx;

 	if (!addr)
 		return -ENODEV;
 
 	/*
 	 * Figure out the actual inb/inw/inl/etc routine to use based
 	 * upon the register size.
	 */
	switch (io->regsize) {
	case 1:
		io->inputb = port_inb;
		io->outputb = port_outb;
		break;
	case 2:
		io->inputb = port_inw;
		io->outputb = port_outw;
		break;
	case 4:
		io->inputb = port_inl;
		io->outputb = port_outl;
		break;
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}

	/*
	 * Some BIOSes reserve disjoint I/O regions in their ACPI
	 * tables.  This causes problems when trying to register the
	 * entire I/O region.  Therefore we must register each I/O
	 * port separately.
	 */
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_region(addr + idx * io->regspacing,
				   io->regsize, DEVICE_NAME) == NULL) {
			/* Undo allocations */
			while (idx--)
				release_region(addr + idx * io->regspacing,
					       io->regsize);
 			return -EIO;
 		}
 	}

	io->io_cleanup = port_cleanup;

 	return 0;
 }
","The `ipmi_si_port_setup` function initializes the I/O port settings for a given hardware interface by configuring the appropriate input and output routines based on the specified register size. It first checks if the address is valid; if not, it returns an error. Depending on the register size (1, 2, or 4 bytes), it assigns the corresponding input and output functions. The function then attempts to register each I/O port individually to handle potential disjoint regions reserved by BIOS ACPI tables. If any registration fails, it releases previously allocated regions and returns an error code; otherwise, it returns success.","The code sets up the I/O port configuration for a hardware interface by first verifying the validity of the address. It determines the appropriate input and output routines based on the size of the registers being used. The function then registers each I/O port individually to accommodate potential gaps in the address space reserved by the BIOS. If any registration fails, it cleans up by releasing any previously allocated resources and returns an error. If all registrations are successful, the function concludes by returning a success status, indicating that the setup was completed without issues.","The vulnerability in the original code arises from a use-after-free condition, where resources allocated during the setup process are not properly released if an error occurs before the registration function is called. Specifically, if the setup function succeeds but the subsequent initialization fails, the cleanup function is not invoked, leading to a situation where the resource's name is freed while the resource itself remains allocated. This results in a crash when accessing the freed name. The fix addresses this by ensuring that the cleanup function is called if the setup fails, preventing the use-after-free scenario while maintaining proper resource management.","The vulnerability in the original code stems from a use-after-free issue, where resources allocated during the setup process are not properly released if an error occurs before the registration function is executed. Specifically, if the setup is successful but the subsequent initialization fails, the cleanup function is not called, leading to a situation where the resource's name is freed while the resource itself remains allocated. This results in a crash when attempting to access the freed name. The fix addresses this by ensuring that the cleanup function is invoked if the initialization fails, thus preventing the use-after-free condition and ensuring proper resource management.","The vulnerability was fixed by modifying the error handling in the `try_smi_init` function. Specifically, the cleanup function `io_cleanup` is now called if the initialization process encounters an error before reaching the `ipmi_register_smi` function. This ensures that any resources allocated during `io_setup` are properly released, preventing the use-after-free condition. Additionally, the cleanup function is only invoked after confirming that `io_setup` has successfully completed, which avoids unnecessary warnings. This change effectively ensures that resources are managed correctly, eliminating the risk of accessing freed memory.","The vulnerability was addressed by enhancing the error handling mechanism during the initialization process. The fix ensures that if an error occurs after resource allocation but before the registration step, the cleanup function is invoked to release any allocated resources. This prevents the situation where resources remain allocated while their associated names are freed, which could lead to accessing invalid memory. By ensuring that cleanup occurs only after successful resource allocation, the fix effectively eliminates the risk of use-after-free errors, thereby improving the overall stability and safety of the code.","CWE-404, CWE-908, CWE-763, CWE-825, CWE-401, CWE-415, CWE-672, CWE-459, CWE-416, CWE-460",N,-1
62,62,182934,182934,,Local,Not required,Partial,CVE-2018-20856,https://www.cvedetails.com/cve/CVE-2018-20856/,CWE-416,Low,Partial,Partial,,2019-07-26,4.6,"An issue was discovered in the Linux kernel before 4.18.7. In block/blk-core.c, there is an __blk_drain_queue() use-after-free because a certain error case is mishandled.",2019-08-13,,1,https://github.com/torvalds/linux/commit/54648cf1ec2d7f4b6a71767799c45676a138ca24,54648cf1ec2d7f4b6a71767799c45676a138ca24,"block: blk_init_allocated_queue() set q->fq as NULL in the fail case

We find the memory use-after-free issue in __blk_drain_queue()
on the kernel 4.14. After read the latest kernel 4.18-rc6 we
think it has the same problem.

Memory is allocated for q->fq in the blk_init_allocated_queue().
If the elevator init function called with error return, it will
run into the fail case to free the q->fq.

Then the __blk_drain_queue() uses the same memory after the free
of the q->fq, it will lead to the unpredictable event.

The patch is to set q->fq as NULL in the fail case of
blk_init_allocated_queue().

Fixes: commit 7c94e1c157a2 (""block: introduce blk_flush_queue to drive flush machinery"")
Cc: <stable@vger.kernel.org>
Reviewed-by: Ming Lei <ming.lei@redhat.com>
Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
Signed-off-by: xiao jin <jin.xiao@intel.com>
Signed-off-by: Jens Axboe <axboe@kernel.dk>",0,block/blk-core.c,"{""sha"": ""23cd1b7770e706c1824cd819c8ec91209ab1cbd0"", ""filename"": ""block/blk-core.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/54648cf1ec2d7f4b6a71767799c45676a138ca24/block/blk-core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/54648cf1ec2d7f4b6a71767799c45676a138ca24/block/blk-core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/block/blk-core.c?ref=54648cf1ec2d7f4b6a71767799c45676a138ca24"", ""patch"": ""@@ -1184,6 +1184,7 @@ int blk_init_allocated_queue(struct request_queue *q)\n \t\tq->exit_rq_fn(q, q->fq->flush_rq);\n out_free_flush_queue:\n \tblk_free_flush_queue(q->fq);\n+\tq->fq = NULL;\n \treturn -ENOMEM;\n }\n EXPORT_SYMBOL(blk_init_allocated_queue);""}","int blk_init_allocated_queue(struct request_queue *q)
{
	WARN_ON_ONCE(q->mq_ops);

	q->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);
	if (!q->fq)
		return -ENOMEM;

	if (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))
		goto out_free_flush_queue;

	if (blk_init_rl(&q->root_rl, q, GFP_KERNEL))
		goto out_exit_flush_rq;

	INIT_WORK(&q->timeout_work, blk_timeout_work);
	q->queue_flags		|= QUEUE_FLAG_DEFAULT;

	/*
	 * This also sets hw/phys segments, boundary and size
	 */
	blk_queue_make_request(q, blk_queue_bio);

	q->sg_reserved_size = INT_MAX;

	if (elevator_init(q))
		goto out_exit_flush_rq;
	return 0;

out_exit_flush_rq:
	if (q->exit_rq_fn)
 		q->exit_rq_fn(q, q->fq->flush_rq);
 out_free_flush_queue:
 	blk_free_flush_queue(q->fq);
	q->fq = NULL;
 	return -ENOMEM;
 }
","int blk_init_allocated_queue(struct request_queue *q)
{
	WARN_ON_ONCE(q->mq_ops);

	q->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);
	if (!q->fq)
		return -ENOMEM;

	if (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))
		goto out_free_flush_queue;

	if (blk_init_rl(&q->root_rl, q, GFP_KERNEL))
		goto out_exit_flush_rq;

	INIT_WORK(&q->timeout_work, blk_timeout_work);
	q->queue_flags		|= QUEUE_FLAG_DEFAULT;

	/*
	 * This also sets hw/phys segments, boundary and size
	 */
	blk_queue_make_request(q, blk_queue_bio);

	q->sg_reserved_size = INT_MAX;

	if (elevator_init(q))
		goto out_exit_flush_rq;
	return 0;

out_exit_flush_rq:
	if (q->exit_rq_fn)
 		q->exit_rq_fn(q, q->fq->flush_rq);
 out_free_flush_queue:
 	blk_free_flush_queue(q->fq);
 	return -ENOMEM;
 }
",C,"	q->fq = NULL;
",,,"@@ -1184,6 +1184,7 @@ int blk_init_allocated_queue(struct request_queue *q)
 		q->exit_rq_fn(q, q->fq->flush_rq);
 out_free_flush_queue:
 	blk_free_flush_queue(q->fq);
+	q->fq = NULL;
 	return -ENOMEM;
 }
 EXPORT_SYMBOL(blk_init_allocated_queue);",linux,54648cf1ec2d7f4b6a71767799c45676a138ca24,f7f1fc363aab4601786d373569c1ae802ea593d0,1,"int blk_init_allocated_queue(struct request_queue *q)
{
	WARN_ON_ONCE(q->mq_ops);

	q->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);
	if (!q->fq)
		return -ENOMEM;

	if (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))
		goto out_free_flush_queue;

	if (blk_init_rl(&q->root_rl, q, GFP_KERNEL))
		goto out_exit_flush_rq;

	INIT_WORK(&q->timeout_work, blk_timeout_work);
	q->queue_flags		|= QUEUE_FLAG_DEFAULT;

	/*
	 * This also sets hw/phys segments, boundary and size
	 */
	blk_queue_make_request(q, blk_queue_bio);

	q->sg_reserved_size = INT_MAX;

	if (elevator_init(q))
		goto out_exit_flush_rq;
	return 0;

out_exit_flush_rq:
	if (q->exit_rq_fn)
 		q->exit_rq_fn(q, q->fq->flush_rq);
 out_free_flush_queue:
 	blk_free_flush_queue(q->fq);
//fix_flaw_line_below:
//	q->fq = NULL;
 	return -ENOMEM;
 }
",182934,"int blk_init_allocated_queue(struct request_queue *q)
{
	WARN_ON_ONCE(q->mq_ops);

	q->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);
	if (!q->fq)
		return -ENOMEM;

	if (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))
		goto out_free_flush_queue;

	if (blk_init_rl(&q->root_rl, q, GFP_KERNEL))
		goto out_exit_flush_rq;

	INIT_WORK(&q->timeout_work, blk_timeout_work);
	q->queue_flags		|= QUEUE_FLAG_DEFAULT;

	/*
	 * This also sets hw/phys segments, boundary and size
	 */
	blk_queue_make_request(q, blk_queue_bio);

	q->sg_reserved_size = INT_MAX;

	if (elevator_init(q))
		goto out_exit_flush_rq;
	return 0;

out_exit_flush_rq:
	if (q->exit_rq_fn)
 		q->exit_rq_fn(q, q->fq->flush_rq);
 out_free_flush_queue:
 	blk_free_flush_queue(q->fq);
 	return -ENOMEM;
 }
","int blk_init_allocated_queue(struct request_queue *q)
{
	WARN_ON_ONCE(q->mq_ops);

	q->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);
	if (!q->fq)
		return -ENOMEM;

	if (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))
		goto out_free_flush_queue;

	if (blk_init_rl(&q->root_rl, q, GFP_KERNEL))
		goto out_exit_flush_rq;

	INIT_WORK(&q->timeout_work, blk_timeout_work);
	q->queue_flags		|= QUEUE_FLAG_DEFAULT;

	/*
	 * This also sets hw/phys segments, boundary and size
	 */
	blk_queue_make_request(q, blk_queue_bio);

	q->sg_reserved_size = INT_MAX;

	if (elevator_init(q))
		goto out_exit_flush_rq;
	return 0;

out_exit_flush_rq:
	if (q->exit_rq_fn)
 		q->exit_rq_fn(q, q->fq->flush_rq);
 out_free_flush_queue:
 	blk_free_flush_queue(q->fq);
	q->fq = NULL;
 	return -ENOMEM;
 }
","The `blk_init_allocated_queue` function initializes a block request queue by first checking if the queue operations are already set. It allocates a flush queue and initializes it, handling memory allocation errors appropriately. If a request initialization function is provided, it is called to set up the flush request. The function also initializes a rate limiter, sets up a timeout work structure, and configures the queue's flags and request handling. If any initialization step fails, it cleans up by calling the exit function for the flush request and freeing the allocated flush queue before returning an error code.","The function initializes a block request queue by first ensuring that no operations are already assigned to it. It allocates a flush queue and checks for successful memory allocation. If a specific initialization function is provided, it is executed to set up the flush request. The function also establishes a rate limiter, configures a timeout mechanism, and sets default flags for the queue. If any step encounters an error, it performs necessary cleanup by invoking the exit function for the flush request and releasing the allocated resources before returning an error code.","The vulnerability in the original code arises from a potential use-after-free issue, where memory allocated for the flush queue could be accessed after it has been freed. Specifically, if the elevator initialization fails, the code frees the flush queue but does not nullify the pointer, leaving it pointing to deallocated memory. This can lead to unpredictable behavior when the flush queue is accessed later in the `__blk_drain_queue()` function. The fix addresses this by explicitly setting the flush queue pointer to NULL after it is freed, ensuring that any subsequent access attempts will not reference invalid memory.","The vulnerability in the original code stems from a use-after-free issue, where memory allocated for a specific resource could be accessed after it was freed. If an error occurred during the initialization process, the code would free the allocated memory but fail to nullify the pointer, leaving it pointing to deallocated memory. This could lead to unpredictable behavior when the freed memory was accessed later in another function. The fix involved explicitly setting the pointer to NULL after freeing the memory, ensuring that any subsequent attempts to access it would not reference invalid memory, thus preventing potential crashes or erratic behavior.","The vulnerability was fixed by modifying the error handling in the `blk_init_allocated_queue` function. After freeing the flush queue with `blk_free_flush_queue(q->fq)`, the code now sets the pointer `q->fq` to NULL. This change ensures that if the elevator initialization fails, and the flush queue is subsequently accessed in functions like `__blk_drain_queue()`, it will not reference the freed memory. By nullifying the pointer, any further attempts to use it will be safely handled, preventing unpredictable behavior and potential crashes associated with accessing invalid memory.","The vulnerability was addressed by enhancing the error handling mechanism within the initialization function. After freeing the allocated memory in the event of an error, the code now explicitly sets the pointer to NULL. This adjustment ensures that any subsequent attempts to access the memory will not reference the deallocated space, thereby preventing potential crashes or unpredictable behavior. By nullifying the pointer, the code effectively safeguards against use-after-free issues, ensuring that the system remains stable and reliable even when initialization fails. This change significantly improves memory management and error handling in the code.","CWE-416, CWE-476, CWE-825, CWE-415, CWE-404, CWE-763, CWE-908, CWE-761, CWE-666, CWE-465",Y,1
63,63,182954,182954,,Remote,Not required,Complete,CVE-2018-20836,https://www.cvedetails.com/cve/CVE-2018-20836/,CWE-416,Medium,Complete,Complete,,2019-05-07,9.3,"An issue was discovered in the Linux kernel before 4.20. There is a race condition in smp_task_timedout() and smp_task_done() in drivers/scsi/libsas/sas_expander.c, leading to a use-after-free.",2019-05-08,,1,https://github.com/torvalds/linux/commit/b90cd6f2b905905fb42671009dc0e27c310a16ae,b90cd6f2b905905fb42671009dc0e27c310a16ae,"scsi: libsas: fix a race condition when smp task timeout

When the lldd is processing the complete sas task in interrupt and set the
task stat as SAS_TASK_STATE_DONE, the smp timeout timer is able to be
triggered at the same time. And smp_task_timedout() will complete the task
wheter the SAS_TASK_STATE_DONE is set or not. Then the sas task may freed
before lldd end the interrupt process. Thus a use-after-free will happen.

Fix this by calling the complete() only when SAS_TASK_STATE_DONE is not
set. And remove the check of the return value of the del_timer(). Once the
LLDD sets DONE, it must call task->done(), which will call
smp_task_done()->complete() and the task will be completed and freed
correctly.

Reported-by: chenxiang <chenxiang66@hisilicon.com>
Signed-off-by: Jason Yan <yanaijie@huawei.com>
CC: John Garry <john.garry@huawei.com>
CC: Johannes Thumshirn <jthumshirn@suse.de>
CC: Ewan Milne <emilne@redhat.com>
CC: Christoph Hellwig <hch@lst.de>
CC: Tomas Henzl <thenzl@redhat.com>
CC: Dan Williams <dan.j.williams@intel.com>
CC: Hannes Reinecke <hare@suse.com>
Reviewed-by: Hannes Reinecke <hare@suse.com>
Reviewed-by: John Garry <john.garry@huawei.com>
Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>",2,drivers/scsi/libsas/sas_expander.c,"{""sha"": ""0d1f72752ca26e77869215809a542cf8db1906ce"", ""filename"": ""drivers/scsi/libsas/sas_expander.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/b90cd6f2b905905fb42671009dc0e27c310a16ae/drivers/scsi/libsas/sas_expander.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/b90cd6f2b905905fb42671009dc0e27c310a16ae/drivers/scsi/libsas/sas_expander.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/scsi/libsas/sas_expander.c?ref=b90cd6f2b905905fb42671009dc0e27c310a16ae"", ""patch"": ""@@ -48,17 +48,16 @@ static void smp_task_timedout(struct timer_list *t)\n \tunsigned long flags;\n \n \tspin_lock_irqsave(&task->task_state_lock, flags);\n-\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n+\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\n \t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n+\t\tcomplete(&task->slow_task->completion);\n+\t}\n \tspin_unlock_irqrestore(&task->task_state_lock, flags);\n-\n-\tcomplete(&task->slow_task->completion);\n }\n \n static void smp_task_done(struct sas_task *task)\n {\n-\tif (!del_timer(&task->slow_task->timer))\n-\t\treturn;\n+\tdel_timer(&task->slow_task->timer);\n \tcomplete(&task->slow_task->completion);\n }\n ""}"," static void smp_task_done(struct sas_task *task)
 {
	del_timer(&task->slow_task->timer);
 	complete(&task->slow_task->completion);
 }
"," static void smp_task_done(struct sas_task *task)
 {
	if (!del_timer(&task->slow_task->timer))
		return;
 	complete(&task->slow_task->completion);
 }
",C,"	del_timer(&task->slow_task->timer);
","	if (!del_timer(&task->slow_task->timer))
		return;
",,"@@ -48,17 +48,16 @@ static void smp_task_timedout(struct timer_list *t)
 	unsigned long flags;
 
 	spin_lock_irqsave(&task->task_state_lock, flags);
-	if (!(task->task_state_flags & SAS_TASK_STATE_DONE))
+	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
 		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
+		complete(&task->slow_task->completion);
+	}
 	spin_unlock_irqrestore(&task->task_state_lock, flags);
-
-	complete(&task->slow_task->completion);
 }
 
 static void smp_task_done(struct sas_task *task)
 {
-	if (!del_timer(&task->slow_task->timer))
-		return;
+	del_timer(&task->slow_task->timer);
 	complete(&task->slow_task->completion);
 }
 ",linux,b90cd6f2b905905fb42671009dc0e27c310a16ae,437207d3697f500f34f126a8ab1c29417ba4a184,1," static void smp_task_done(struct sas_task *task)
 {
//flaw_line_below:
	if (!del_timer(&task->slow_task->timer))
//flaw_line_below:
		return;
//fix_flaw_line_below:
//	del_timer(&task->slow_task->timer);
 	complete(&task->slow_task->completion);
 }
",182954," static void smp_task_done(struct sas_task *task)
 {
	if (!del_timer(&task->slow_task->timer))
		return;
 	complete(&task->slow_task->completion);
 }
"," static void smp_task_done(struct sas_task *task)
 {
	del_timer(&task->slow_task->timer);
 	complete(&task->slow_task->completion);
 }
","The provided code defines a static function `smp_task_done` that is responsible for finalizing a SAS (Serial Attached SCSI) task. It takes a pointer to a `sas_task` structure as an argument. The function first attempts to delete a timer associated with the task's `slow_task` member. If the timer is successfully deleted (indicated by a return value of true), it then signals the completion of the `slow_task` by calling the `complete` function on its `completion` member. This effectively notifies any waiting processes that the task has been completed, allowing for proper synchronization in concurrent environments.","The code defines a function that finalizes a specific task by managing a timer associated with it. Initially, the function attempts to remove the timer, which is used to track the task's execution duration. If the timer is successfully removed, the function then signals that the task has been completed, allowing any processes waiting for this task to proceed. This mechanism ensures proper synchronization in a concurrent environment, enabling efficient task management and resource handling by notifying other components when the task has finished its execution.","The vulnerability in the original code stemmed from a race condition where the timeout timer could trigger while the task was being processed, potentially leading to a use-after-free scenario. Specifically, if the task's state was set to indicate completion while the timer was still active, the completion function could be called prematurely, resulting in the task being freed before the interrupt processing was finished. The fix involved ensuring that the completion function is only called if the task's state is not set to indicate completion, thus preventing the race condition and ensuring proper task management and memory safety.","The vulnerability in the original code arose from a race condition where a timeout could occur while a task was being processed, leading to the task being marked as complete even if it was still in use. This situation could result in the task being freed prematurely, causing a use-after-free error. The fix addressed this issue by ensuring that the completion function is only invoked if the task is not already marked as complete. Additionally, the unnecessary check for the timer's return value was removed, streamlining the process and ensuring that task management occurs safely and correctly.","The vulnerability was fixed by modifying the `smp_task_done` function to call the `complete` function only when the task's state is not set to `SAS_TASK_STATE_DONE`. This change prevents the completion signal from being sent if the task is already marked as complete, thereby avoiding the race condition that could lead to a use-after-free error. Additionally, the check for the return value of `del_timer` was removed, simplifying the code. This ensures that once the low-level driver sets the task state to done, it will correctly call the task's done function, managing task completion and memory safety effectively.","The vulnerability was addressed by ensuring that the completion signal is only triggered when the task is not already marked as complete, effectively preventing premature signaling that could lead to memory safety issues. Additionally, the code was simplified by removing an unnecessary check related to timer management, which streamlined the process. This approach guarantees that once the task is designated as complete by the low-level driver, the appropriate completion handling occurs without risking the task being freed while still in use, thereby enhancing overall task management and preventing potential errors in concurrent execution.","CWE-664,CWE-362,CWE-667,CWE-666,CWE-675,CWE-404,CWE-672,CWE-826,CWE-911,CWE-833",N,-1
64,64,182955,182955,,Remote,Not required,Complete,CVE-2018-20836,https://www.cvedetails.com/cve/CVE-2018-20836/,CWE-416,Medium,Complete,Complete,,2019-05-07,9.3,"An issue was discovered in the Linux kernel before 4.20. There is a race condition in smp_task_timedout() and smp_task_done() in drivers/scsi/libsas/sas_expander.c, leading to a use-after-free.",2019-05-08,,3,https://github.com/torvalds/linux/commit/b90cd6f2b905905fb42671009dc0e27c310a16ae,b90cd6f2b905905fb42671009dc0e27c310a16ae,"scsi: libsas: fix a race condition when smp task timeout

When the lldd is processing the complete sas task in interrupt and set the
task stat as SAS_TASK_STATE_DONE, the smp timeout timer is able to be
triggered at the same time. And smp_task_timedout() will complete the task
wheter the SAS_TASK_STATE_DONE is set or not. Then the sas task may freed
before lldd end the interrupt process. Thus a use-after-free will happen.

Fix this by calling the complete() only when SAS_TASK_STATE_DONE is not
set. And remove the check of the return value of the del_timer(). Once the
LLDD sets DONE, it must call task->done(), which will call
smp_task_done()->complete() and the task will be completed and freed
correctly.

Reported-by: chenxiang <chenxiang66@hisilicon.com>
Signed-off-by: Jason Yan <yanaijie@huawei.com>
CC: John Garry <john.garry@huawei.com>
CC: Johannes Thumshirn <jthumshirn@suse.de>
CC: Ewan Milne <emilne@redhat.com>
CC: Christoph Hellwig <hch@lst.de>
CC: Tomas Henzl <thenzl@redhat.com>
CC: Dan Williams <dan.j.williams@intel.com>
CC: Hannes Reinecke <hare@suse.com>
Reviewed-by: Hannes Reinecke <hare@suse.com>
Reviewed-by: John Garry <john.garry@huawei.com>
Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>",2,drivers/scsi/libsas/sas_expander.c,"{""sha"": ""0d1f72752ca26e77869215809a542cf8db1906ce"", ""filename"": ""drivers/scsi/libsas/sas_expander.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/b90cd6f2b905905fb42671009dc0e27c310a16ae/drivers/scsi/libsas/sas_expander.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/b90cd6f2b905905fb42671009dc0e27c310a16ae/drivers/scsi/libsas/sas_expander.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/scsi/libsas/sas_expander.c?ref=b90cd6f2b905905fb42671009dc0e27c310a16ae"", ""patch"": ""@@ -48,17 +48,16 @@ static void smp_task_timedout(struct timer_list *t)\n \tunsigned long flags;\n \n \tspin_lock_irqsave(&task->task_state_lock, flags);\n-\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n+\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\n \t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n+\t\tcomplete(&task->slow_task->completion);\n+\t}\n \tspin_unlock_irqrestore(&task->task_state_lock, flags);\n-\n-\tcomplete(&task->slow_task->completion);\n }\n \n static void smp_task_done(struct sas_task *task)\n {\n-\tif (!del_timer(&task->slow_task->timer))\n-\t\treturn;\n+\tdel_timer(&task->slow_task->timer);\n \tcomplete(&task->slow_task->completion);\n }\n ""}","static void smp_task_timedout(struct timer_list *t)
{
	struct sas_task_slow *slow = from_timer(slow, t, timer);
	struct sas_task *task = slow->task;
 	unsigned long flags;
 
 	spin_lock_irqsave(&task->task_state_lock, flags);
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
 		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
		complete(&task->slow_task->completion);
	}
 	spin_unlock_irqrestore(&task->task_state_lock, flags);
 }
","static void smp_task_timedout(struct timer_list *t)
{
	struct sas_task_slow *slow = from_timer(slow, t, timer);
	struct sas_task *task = slow->task;
 	unsigned long flags;
 
 	spin_lock_irqsave(&task->task_state_lock, flags);
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE))
 		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
 	spin_unlock_irqrestore(&task->task_state_lock, flags);
	complete(&task->slow_task->completion);
 }
",C,"	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
		complete(&task->slow_task->completion);
	}
","	if (!(task->task_state_flags & SAS_TASK_STATE_DONE))
	complete(&task->slow_task->completion);
",,"@@ -48,17 +48,16 @@ static void smp_task_timedout(struct timer_list *t)
 	unsigned long flags;
 
 	spin_lock_irqsave(&task->task_state_lock, flags);
-	if (!(task->task_state_flags & SAS_TASK_STATE_DONE))
+	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
 		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
+		complete(&task->slow_task->completion);
+	}
 	spin_unlock_irqrestore(&task->task_state_lock, flags);
-
-	complete(&task->slow_task->completion);
 }
 
 static void smp_task_done(struct sas_task *task)
 {
-	if (!del_timer(&task->slow_task->timer))
-		return;
+	del_timer(&task->slow_task->timer);
 	complete(&task->slow_task->completion);
 }
 ",linux,b90cd6f2b905905fb42671009dc0e27c310a16ae,437207d3697f500f34f126a8ab1c29417ba4a184,1,"static void smp_task_timedout(struct timer_list *t)
{
	struct sas_task_slow *slow = from_timer(slow, t, timer);
	struct sas_task *task = slow->task;
 	unsigned long flags;
 
 	spin_lock_irqsave(&task->task_state_lock, flags);
//flaw_line_below:
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE))
//fix_flaw_line_below:
//	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
 		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
//fix_flaw_line_below:
//		complete(&task->slow_task->completion);
//fix_flaw_line_below:
//	}
 	spin_unlock_irqrestore(&task->task_state_lock, flags);
//flaw_line_below:

//flaw_line_below:
	complete(&task->slow_task->completion);
 }
",182955,"static void smp_task_timedout(struct timer_list *t)
{
	struct sas_task_slow *slow = from_timer(slow, t, timer);
	struct sas_task *task = slow->task;
 	unsigned long flags;
 
 	spin_lock_irqsave(&task->task_state_lock, flags);
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE))
 		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
 	spin_unlock_irqrestore(&task->task_state_lock, flags);
	complete(&task->slow_task->completion);
 }
","static void smp_task_timedout(struct timer_list *t)
{
	struct sas_task_slow *slow = from_timer(slow, t, timer);
	struct sas_task *task = slow->task;
 	unsigned long flags;
 
 	spin_lock_irqsave(&task->task_state_lock, flags);
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
 		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
		complete(&task->slow_task->completion);
	}
 	spin_unlock_irqrestore(&task->task_state_lock, flags);
 }
","The `smp_task_timedout` function is a timer callback that handles the timeout of a SAS (Serial Attached SCSI) task. When invoked, it retrieves the associated `sas_task_slow` structure from the timer context and accesses the corresponding `sas_task`. The function then acquires a spinlock to safely check and update the task's state flags; if the task is not already marked as done, it sets the task's state to aborted. Finally, it releases the spinlock and signals the completion of the slow task, indicating that the timeout has been processed.","The provided code defines a function that is triggered when a specific task times out. It retrieves the relevant task information and ensures thread safety by acquiring a lock before checking the task's completion status. If the task is still in progress, it updates its state to indicate that it has been aborted. After modifying the task's state, the function releases the lock and signals that the associated slow task has completed. This mechanism helps manage task timeouts effectively, ensuring that resources are properly released and that the system can respond to task failures.","The vulnerability in the original code arises from a race condition where the timeout handler can be triggered while the low-level device driver (lldd) is processing a completed SAS task. If the lldd sets the task state to indicate completion, the timeout function may still execute and attempt to complete the task, leading to a use-after-free scenario if the task is freed before the lldd finishes its processing. The fix addresses this by ensuring that the completion function is only called if the task state is not marked as done, thus preventing premature completion and ensuring proper task management.","The vulnerability in the original code stems from a race condition where a timeout handler could be executed concurrently with the completion of a task by the low-level device driver. This situation could lead to the task being marked as completed while the timeout handler still attempted to finalize it, resulting in a use-after-free error if the task was freed before the driver finished its operations. The fix addresses this issue by ensuring that the completion function is only invoked if the task is not already marked as completed, thereby preventing premature access to freed resources and ensuring proper task lifecycle management.","The vulnerability was fixed by modifying the condition under which the completion function is called within the timeout handler. In the updated code, the completion function is only invoked if the task's state flags do not indicate that the task is done. Specifically, the check for the task state ensures that the completion function is called only when the task is not marked with the done state. This change prevents the timeout handler from completing a task that has already been finalized by the low-level device driver, thus eliminating the risk of a use-after-free error.","The vulnerability was addressed by implementing a conditional check that ensures the completion function is only executed if the task is not already marked as completed. This adjustment prevents the timeout handler from finalizing a task that has been processed by the low-level device driver, thereby avoiding the scenario where the task could be freed while still being accessed. By enforcing this check, the code ensures that the task's lifecycle is properly managed, eliminating the risk of accessing freed memory and thus preventing potential use-after-free errors.","CWE-416, CWE-825, CWE-415, CWE-672, CWE-666, CWE-675, CWE-826, CWE-908, CWE-911, CWE-404",Y,1
65,65,183184,183184,,Local,Not required,Complete,CVE-2017-16525,https://www.cvedetails.com/cve/CVE-2017-16525/,CWE-416,Low,Complete,Complete,,2017-11-03,7.2,"The usb_serial_console_disconnect function in drivers/usb/serial/console.c in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device, related to disconnection and failed setup.",2018-03-15,DoS ,1,https://github.com/torvalds/linux/commit/bd998c2e0df0469707503023d50d46cf0b10c787,bd998c2e0df0469707503023d50d46cf0b10c787,"USB: serial: console: fix use-after-free on disconnect

A clean-up patch removing two redundant NULL-checks from the console
disconnect handler inadvertently also removed a third check. This could
lead to the struct usb_serial being prematurely freed by the console
code when a driver accepts but does not register any ports for an
interface which also lacks endpoint descriptors.

Fixes: 0e517c93dc02 (""USB: serial: console: clean up sanity checks"")
Cc: stable <stable@vger.kernel.org>     # 4.11
Reported-by: Andrey Konovalov <andreyknvl@google.com>
Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Johan Hovold <johan@kernel.org>",1,drivers/usb/serial/console.c,"{""sha"": ""ed8ba3ef5c794fdf97ce2cd7b28b48bef17f642c"", ""filename"": ""drivers/usb/serial/console.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/bd998c2e0df0469707503023d50d46cf0b10c787/drivers/usb/serial/console.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bd998c2e0df0469707503023d50d46cf0b10c787/drivers/usb/serial/console.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/serial/console.c?ref=bd998c2e0df0469707503023d50d46cf0b10c787"", ""patch"": ""@@ -265,7 +265,7 @@ static struct console usbcons = {\n \n void usb_serial_console_disconnect(struct usb_serial *serial)\n {\n-\tif (serial->port[0] == usbcons_info.port) {\n+\tif (serial->port[0] && serial->port[0] == usbcons_info.port) {\n \t\tusb_serial_console_exit();\n \t\tusb_serial_put(serial);\n \t}""}"," void usb_serial_console_disconnect(struct usb_serial *serial)
 {
	if (serial->port[0] && serial->port[0] == usbcons_info.port) {
 		usb_serial_console_exit();
 		usb_serial_put(serial);
 	}
}
"," void usb_serial_console_disconnect(struct usb_serial *serial)
 {
	if (serial->port[0] == usbcons_info.port) {
 		usb_serial_console_exit();
 		usb_serial_put(serial);
 	}
}
",C,"	if (serial->port[0] && serial->port[0] == usbcons_info.port) {
","	if (serial->port[0] == usbcons_info.port) {
",,"@@ -265,7 +265,7 @@ static struct console usbcons = {
 
 void usb_serial_console_disconnect(struct usb_serial *serial)
 {
-	if (serial->port[0] == usbcons_info.port) {
+	if (serial->port[0] && serial->port[0] == usbcons_info.port) {
 		usb_serial_console_exit();
 		usb_serial_put(serial);
 	}",linux,bd998c2e0df0469707503023d50d46cf0b10c787,f5d9644c5fca7d8e8972268598bb516a7eae17f9,1," void usb_serial_console_disconnect(struct usb_serial *serial)
 {
//flaw_line_below:
	if (serial->port[0] == usbcons_info.port) {
//fix_flaw_line_below:
//	if (serial->port[0] && serial->port[0] == usbcons_info.port) {
 		usb_serial_console_exit();
 		usb_serial_put(serial);
 	}
}
",183184," void usb_serial_console_disconnect(struct usb_serial *serial)
 {
	if (serial->port[0] == usbcons_info.port) {
 		usb_serial_console_exit();
 		usb_serial_put(serial);
 	}
}
"," void usb_serial_console_disconnect(struct usb_serial *serial)
 {
	if (serial->port[0] && serial->port[0] == usbcons_info.port) {
 		usb_serial_console_exit();
 		usb_serial_put(serial);
 	}
}
","The provided code defines a function `usb_serial_console_disconnect` that handles the disconnection of a USB serial device. It checks if the first port of the given `serial` object matches a predefined `usbcons_info.port`. If they match, it calls `usb_serial_console_exit()` to perform necessary cleanup operations related to the USB console, and subsequently calls `usb_serial_put(serial)` to decrement the reference count of the `serial` object, ensuring proper resource management and preventing memory leaks. This function is crucial for maintaining the integrity of the USB serial connection during disconnection events.","The code defines a function that manages the disconnection of a USB serial device by checking if a specific port is being disconnected. If the condition is met, it initiates a cleanup process to properly exit the USB console, ensuring that any resources associated with the console are released. Following this, it decreases the reference count of the serial object to manage memory effectively and prevent leaks. This functionality is essential for maintaining system stability and resource integrity during the disconnection of USB serial devices.","The vulnerability in the original code stemmed from the lack of a NULL check for the first port of the `serial` object, which could lead to a use-after-free condition if the `serial` structure was prematurely freed. This situation could occur when a driver accepted an interface but did not register any ports, resulting in the code attempting to access a freed memory location. The fix introduced an additional check to ensure that the first port is not NULL before comparing it to the predefined port, thereby preventing the potential dereference of a NULL pointer and ensuring safe memory access during disconnection.","The vulnerability in the original code arose from the removal of a critical NULL check during a cleanup process, which could result in accessing a memory structure that had already been freed. This situation was particularly problematic when a driver accepted an interface but failed to register any ports, leading to potential dereferencing of a NULL pointer. The fix reinstated the necessary check to ensure that the memory structure was valid before any operations were performed, thereby preventing the use-after-free condition and ensuring safe memory access during the disconnection of USB serial devices.","The vulnerability was fixed by reintroducing a NULL check for the first port of the `serial` object in the disconnect function. The updated code now verifies that `serial->port[0]` is not NULL before comparing it to `usbcons_info.port`. This additional check ensures that the function only proceeds with the cleanup operations, such as calling `usb_serial_console_exit()` and `usb_serial_put(serial)`, if the first port is valid. By preventing the dereference of a NULL pointer, the fix effectively mitigates the risk of a use-after-free condition during the disconnection process.","The vulnerability was fixed by reintroducing a critical check to ensure that the first port of the serial object is valid before proceeding with any operations. This additional validation prevents the code from attempting to access or manipulate a memory structure that may have already been freed, thereby avoiding potential dereferencing of a NULL pointer. By ensuring that the cleanup operations are only executed when the port is properly initialized, the fix effectively safeguards against the use-after-free condition, enhancing the stability and reliability of the disconnection process for USB serial devices.","CWE-416, CWE-825, CWE-476, CWE-415, CWE-672, CWE-908, CWE-825, CWE-119, CWE-404, CWE-754",Y,1
66,66,184958,184958,,Remote,Not required,Partial,CVE-2013-2873,https://www.cvedetails.com/cve/CVE-2013-2873/,CWE-416,Low,Partial,Partial,,2013-07-10,7.5,Use-after-free vulnerability in Google Chrome before 28.0.1500.71 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving a 404 HTTP status code during the loading of resources.,2017-09-18,DoS ,1,https://github.com/chromium/chromium/commit/370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef,370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef,"Protect WebURLLoaderImpl::Context while receiving responses.

A client's didReceiveResponse can cancel a request; by protecting the
Context we avoid a use after free in this case.

Interestingly, we really had very good warning about this problem, see 
https://codereview.chromium.org/11900002/ back in January.

R=darin
BUG=241139

Review URL: https://chromiumcodereview.appspot.com/15738007

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@202821 0039d316-1c4b-4281-b951-d872f2087c98",0,webkit/glue/weburlloader_impl.cc,"{""sha"": ""24c24a60caa575c4012321aec8f108a3456cdd69"", ""filename"": ""content/browser/webkit_browsertest.cc"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 0, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef/content/browser/webkit_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef/content/browser/webkit_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/webkit_browsertest.cc?ref=370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef"", ""patch"": ""@@ -76,4 +76,19 @@ IN_PROC_BROWSER_TEST_F(WebKitBrowserTest, PrerenderNoCrash) {\n   EXPECT_FALSE(shell()->web_contents()->IsCrashed());\n }\n \n+// This is a browser test because DumpRenderTree doesn't run nested message\n+// loops. The failure case was that a nested message triggered from an element\n+// that has signalled an error but had an open request would receive a body for\n+// the request and crash/fail an assertion.\n+const char kErrorBodyNoCrash[] =\n+    \""files/error-body-no-crash.html\"";\n+IN_PROC_BROWSER_TEST_F(WebKitBrowserTest, ErrorBodyNoCrash) {\n+  ASSERT_TRUE(test_server()->Start());\n+  GURL url = test_server()->GetURL(kErrorBodyNoCrash);\n+\n+  NavigateToURL(shell(), url);\n+\n+  EXPECT_FALSE(shell()->web_contents()->IsCrashed());\n+}\n+\n }  // namespace content""}<_**next**_>{""sha"": ""cf0b32c79952ca8960f8aa792c8e2545d4a2bb44"", ""filename"": ""content/test/data/error-body-no-crash.html"", ""status"": ""added"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef/content/test/data/error-body-no-crash.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef/content/test/data/error-body-no-crash.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/test/data/error-body-no-crash.html?ref=370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef"", ""patch"": ""@@ -0,0 +1,6 @@\n+<!-- The showModalDialog call will force a nested message loop, which will\n+     receive the 404 body and crash. -->\n+<script src=\""page404.html\""></script>\n+<script>\n+window.showModalDialog(\""javascript:window.close();\"");\n+</script>""}<_**next**_>{""sha"": ""853d4373eed1f209fc7fbc790a314ce12a1db05e"", ""filename"": ""webkit/glue/weburlloader_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef/webkit/glue/weburlloader_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef/webkit/glue/weburlloader_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/glue/weburlloader_impl.cc?ref=370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef"", ""patch"": ""@@ -637,6 +637,7 @@ void WebURLLoaderImpl::Context::OnReceivedResponse(\n     }\n   }\n \n+  scoped_refptr<Context> protect(this);\n   client_->didReceiveResponse(loader_, response);\n \n   // We may have been cancelled after didReceiveResponse, which would leave us""}","void WebURLLoaderImpl::Context::OnReceivedResponse(
    const ResourceResponseInfo& info) {
  if (!client_)
    return;

  WebURLResponse response;
  response.initialize();
  PopulateURLResponse(request_.url(), info, &response);

  bool show_raw_listing = (GURL(request_.url()).query() == ""raw"");

  if (info.mime_type == ""text/vnd.chromium.ftp-dir"") {
    if (show_raw_listing) {
      response.setMIMEType(""text/plain"");
    } else {
      response.setMIMEType(""text/html"");
     }
   }
 
  scoped_refptr<Context> protect(this);
   client_->didReceiveResponse(loader_, response);
 
  if (!client_)
    return;

  DCHECK(!ftp_listing_delegate_.get());
  DCHECK(!multipart_delegate_.get());
  if (info.headers && info.mime_type == ""multipart/x-mixed-replace"") {
    std::string content_type;
    info.headers->EnumerateHeader(NULL, ""content-type"", &content_type);

    std::string mime_type;
    std::string charset;
    bool had_charset = false;
    std::string boundary;
    net::HttpUtil::ParseContentType(content_type, &mime_type, &charset,
                                    &had_charset, &boundary);
    TrimString(boundary, "" \"""", &boundary);

    if (!boundary.empty()) {
      multipart_delegate_.reset(
          new MultipartResponseDelegate(client_, loader_, response, boundary));
    }
  } else if (info.mime_type == ""text/vnd.chromium.ftp-dir"" &&
             !show_raw_listing) {
    ftp_listing_delegate_.reset(
        new FtpDirectoryListingResponseDelegate(client_, loader_, response));
  }
}
","void WebURLLoaderImpl::Context::OnReceivedResponse(
    const ResourceResponseInfo& info) {
  if (!client_)
    return;

  WebURLResponse response;
  response.initialize();
  PopulateURLResponse(request_.url(), info, &response);

  bool show_raw_listing = (GURL(request_.url()).query() == ""raw"");

  if (info.mime_type == ""text/vnd.chromium.ftp-dir"") {
    if (show_raw_listing) {
      response.setMIMEType(""text/plain"");
    } else {
      response.setMIMEType(""text/html"");
     }
   }
 
   client_->didReceiveResponse(loader_, response);
 
  if (!client_)
    return;

  DCHECK(!ftp_listing_delegate_.get());
  DCHECK(!multipart_delegate_.get());
  if (info.headers && info.mime_type == ""multipart/x-mixed-replace"") {
    std::string content_type;
    info.headers->EnumerateHeader(NULL, ""content-type"", &content_type);

    std::string mime_type;
    std::string charset;
    bool had_charset = false;
    std::string boundary;
    net::HttpUtil::ParseContentType(content_type, &mime_type, &charset,
                                    &had_charset, &boundary);
    TrimString(boundary, "" \"""", &boundary);

    if (!boundary.empty()) {
      multipart_delegate_.reset(
          new MultipartResponseDelegate(client_, loader_, response, boundary));
    }
  } else if (info.mime_type == ""text/vnd.chromium.ftp-dir"" &&
             !show_raw_listing) {
    ftp_listing_delegate_.reset(
        new FtpDirectoryListingResponseDelegate(client_, loader_, response));
  }
}
",C,"  scoped_refptr<Context> protect(this);
",,,"@@ -637,6 +637,7 @@ void WebURLLoaderImpl::Context::OnReceivedResponse(
     }
   }
 
+  scoped_refptr<Context> protect(this);
   client_->didReceiveResponse(loader_, response);
 
   // We may have been cancelled after didReceiveResponse, which would leave us",Chrome,370bd9b522d2ccd4a3113d6c93d30cdf8ca502ef,02a0911dfa3567e3597492b41c94dc7d48fb209c,1,"void WebURLLoaderImpl::Context::OnReceivedResponse(
    const ResourceResponseInfo& info) {
  if (!client_)
    return;

  WebURLResponse response;
  response.initialize();
  PopulateURLResponse(request_.url(), info, &response);

  bool show_raw_listing = (GURL(request_.url()).query() == ""raw"");

  if (info.mime_type == ""text/vnd.chromium.ftp-dir"") {
    if (show_raw_listing) {
      // Set the MIME type to plain text to prevent any active content.
      response.setMIMEType(""text/plain"");
    } else {
      // We're going to produce a parsed listing in HTML.
      response.setMIMEType(""text/html"");
     }
   }
 
//fix_flaw_line_below:
//  scoped_refptr<Context> protect(this);
   client_->didReceiveResponse(loader_, response);
 
   // We may have been cancelled after didReceiveResponse, which would leave us
  // without a client and therefore without much need to do further handling.
  if (!client_)
    return;

  DCHECK(!ftp_listing_delegate_.get());
  DCHECK(!multipart_delegate_.get());
  if (info.headers && info.mime_type == ""multipart/x-mixed-replace"") {
    std::string content_type;
    info.headers->EnumerateHeader(NULL, ""content-type"", &content_type);

    std::string mime_type;
    std::string charset;
    bool had_charset = false;
    std::string boundary;
    net::HttpUtil::ParseContentType(content_type, &mime_type, &charset,
                                    &had_charset, &boundary);
    TrimString(boundary, "" \"""", &boundary);

    // If there's no boundary, just handle the request normally.  In the gecko
    // code, nsMultiMixedConv::OnStartRequest throws an exception.
    if (!boundary.empty()) {
      multipart_delegate_.reset(
          new MultipartResponseDelegate(client_, loader_, response, boundary));
    }
  } else if (info.mime_type == ""text/vnd.chromium.ftp-dir"" &&
             !show_raw_listing) {
    ftp_listing_delegate_.reset(
        new FtpDirectoryListingResponseDelegate(client_, loader_, response));
  }
}
",184958,"void WebURLLoaderImpl::Context::OnReceivedResponse(
    const ResourceResponseInfo& info) {
  if (!client_)
    return;

  WebURLResponse response;
  response.initialize();
  PopulateURLResponse(request_.url(), info, &response);

  bool show_raw_listing = (GURL(request_.url()).query() == ""raw"");

  if (info.mime_type == ""text/vnd.chromium.ftp-dir"") {
    if (show_raw_listing) {
      response.setMIMEType(""text/plain"");
    } else {
      response.setMIMEType(""text/html"");
     }
   }
 
   client_->didReceiveResponse(loader_, response);
 
  if (!client_)
    return;

  DCHECK(!ftp_listing_delegate_.get());
  DCHECK(!multipart_delegate_.get());
  if (info.headers && info.mime_type == ""multipart/x-mixed-replace"") {
    std::string content_type;
    info.headers->EnumerateHeader(NULL, ""content-type"", &content_type);

    std::string mime_type;
    std::string charset;
    bool had_charset = false;
    std::string boundary;
    net::HttpUtil::ParseContentType(content_type, &mime_type, &charset,
                                    &had_charset, &boundary);
    TrimString(boundary, "" \"""", &boundary);

    if (!boundary.empty()) {
      multipart_delegate_.reset(
          new MultipartResponseDelegate(client_, loader_, response, boundary));
    }
  } else if (info.mime_type == ""text/vnd.chromium.ftp-dir"" &&
             !show_raw_listing) {
    ftp_listing_delegate_.reset(
        new FtpDirectoryListingResponseDelegate(client_, loader_, response));
  }
}
","void WebURLLoaderImpl::Context::OnReceivedResponse(
    const ResourceResponseInfo& info) {
  if (!client_)
    return;

  WebURLResponse response;
  response.initialize();
  PopulateURLResponse(request_.url(), info, &response);

  bool show_raw_listing = (GURL(request_.url()).query() == ""raw"");

  if (info.mime_type == ""text/vnd.chromium.ftp-dir"") {
    if (show_raw_listing) {
      response.setMIMEType(""text/plain"");
    } else {
      response.setMIMEType(""text/html"");
     }
   }
 
  scoped_refptr<Context> protect(this);
   client_->didReceiveResponse(loader_, response);
 
  if (!client_)
    return;

  DCHECK(!ftp_listing_delegate_.get());
  DCHECK(!multipart_delegate_.get());
  if (info.headers && info.mime_type == ""multipart/x-mixed-replace"") {
    std::string content_type;
    info.headers->EnumerateHeader(NULL, ""content-type"", &content_type);

    std::string mime_type;
    std::string charset;
    bool had_charset = false;
    std::string boundary;
    net::HttpUtil::ParseContentType(content_type, &mime_type, &charset,
                                    &had_charset, &boundary);
    TrimString(boundary, "" \"""", &boundary);

    if (!boundary.empty()) {
      multipart_delegate_.reset(
          new MultipartResponseDelegate(client_, loader_, response, boundary));
    }
  } else if (info.mime_type == ""text/vnd.chromium.ftp-dir"" &&
             !show_raw_listing) {
    ftp_listing_delegate_.reset(
        new FtpDirectoryListingResponseDelegate(client_, loader_, response));
  }
}
","The `OnReceivedResponse` function in the `WebURLLoaderImpl::Context` class processes incoming responses for web requests. It first checks if a client exists and initializes a `WebURLResponse` object with the request URL and response information. Depending on the MIME type and query parameters, it sets the appropriate MIME type for FTP directory listings. The function then notifies the client of the received response. Additionally, it handles multipart responses by parsing the content type to create a `MultipartResponseDelegate` if a boundary is present. For non-raw FTP directory listings, it initializes an `FtpDirectoryListingResponseDelegate`.","The provided code handles the processing of web responses within a specific context. It begins by checking for the presence of a client and initializes a response object based on the incoming information. Depending on the content type and query parameters, it sets the appropriate format for directory listings. The code then notifies the client about the received response. Additionally, it manages multipart responses by extracting relevant details to create a delegate for handling such content. For standard directory listings, it initializes a separate delegate to manage the response appropriately, ensuring proper handling of different content types.","The vulnerability in the original code arises from the potential for a use-after-free error when the client's `didReceiveResponse` method is called, which could cancel the request and invalidate the context. This situation occurs because the context may be deleted while still being referenced, leading to undefined behavior. The fix introduces a scoped reference to the context using `scoped_refptr<Context> protect(this);`, ensuring that the context remains valid for the duration of the response handling. This change prevents the context from being freed prematurely, thereby eliminating the risk of accessing invalid memory after the client callback.","The vulnerability in the original code stems from the risk of a use-after-free error, which occurs when a request is canceled by the client's callback, potentially leading to the context being deleted while still in use. This situation can result in accessing invalid memory, causing crashes or unpredictable behavior. The fix addresses this issue by introducing a mechanism to maintain a reference to the context during the response handling process. This ensures that the context remains valid and prevents it from being freed prematurely, thereby safeguarding against the risk of accessing deallocated memory after the client callback is executed.","The vulnerability was fixed by introducing a scoped reference to the context using `scoped_refptr<Context> protect(this);` before calling the client's `didReceiveResponse` method. This change ensures that the context remains valid for the duration of the response handling, preventing it from being deleted while still in use. By maintaining this reference, the code avoids the use-after-free issue that could occur if the client canceled the request during the callback. This safeguard effectively protects the context from premature deallocation, ensuring safe access to its resources throughout the response processing.","The vulnerability was fixed by implementing a mechanism that maintains a reference to the context during the response handling process. This approach ensures that the context remains valid and is not prematurely deleted while still being accessed. By protecting the context in this manner, the code prevents potential use-after-free errors that could arise if a request is canceled during the execution of a callback. This safeguard effectively eliminates the risk of accessing invalid memory, thereby enhancing the stability and reliability of the response handling logic.","CWE-416, CWE-825, CWE-415, CWE-672, CWE-404, CWE-666, CWE-664, CWE-913, CWE-665, CWE-911",Y,1
67,67,185017,185017,,Remote,Not required,Partial,CVE-2013-2857,https://www.cvedetails.com/cve/CVE-2013-2857/,CWE-416,Low,Partial,Partial,,2013-06-04,7.5,Use-after-free vulnerability in Google Chrome before 27.0.1453.110 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the handling of images.,2017-09-18,DoS ,2,https://github.com/chromium/chromium/commit/7d085fbb43b21e959900b94f191588fd10546a94,7d085fbb43b21e959900b94f191588fd10546a94,"Error event was fired synchronously blowing away the input element from underneath. Remove the FIXME and fire it asynchronously using errorEventSender().

BUG=240124

Review URL: https://chromiumcodereview.appspot.com/14741011

git-svn-id: svn://svn.chromium.org/blink/trunk@150232 bbb929c8-8fbe-4397-9dbb-9b2b20218538",1,third_party/WebKit/Source/core/loader/ImageLoader.cpp,"{""sha"": ""c6f20fc986a03efbe20be6bfe8e1add665d719fa"", ""filename"": ""third_party/WebKit/LayoutTests/fast/forms/image/image-error-event-crash-expected.txt"", ""status"": ""added"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/7d085fbb43b21e959900b94f191588fd10546a94/third_party/WebKit/LayoutTests/fast/forms/image/image-error-event-crash-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7d085fbb43b21e959900b94f191588fd10546a94/third_party/WebKit/LayoutTests/fast/forms/image/image-error-event-crash-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/forms/image/image-error-event-crash-expected.txt?ref=7d085fbb43b21e959900b94f191588fd10546a94"", ""patch"": ""@@ -0,0 +1 @@\n+Test passes if it does not crash. ""}<_**next**_>{""sha"": ""340a971d1697bfbe396cee40cd1dde6ded0b9d62"", ""filename"": ""third_party/WebKit/LayoutTests/fast/forms/image/image-error-event-crash.html"", ""status"": ""added"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/7d085fbb43b21e959900b94f191588fd10546a94/third_party/WebKit/LayoutTests/fast/forms/image/image-error-event-crash.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7d085fbb43b21e959900b94f191588fd10546a94/third_party/WebKit/LayoutTests/fast/forms/image/image-error-event-crash.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/forms/image/image-error-event-crash.html?ref=7d085fbb43b21e959900b94f191588fd10546a94"", ""patch"": ""@@ -0,0 +1,11 @@\n+<!DOCTYPE html>\n+<html>\n+<body>\n+Test passes if it does not crash.\n+<input id=\""x\"" type=\""image\"" onerror=\""x.type=''\"" src=\""\"" />\n+<script>\n+if (window.testRunner)\n+    testRunner.dumpAsText();\n+</script>\n+</body>\n+</html>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""dd3f34aa274a60c23614d41f5d7a822598c5ac95"", ""filename"": ""third_party/WebKit/Source/core/loader/ImageLoader.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/7d085fbb43b21e959900b94f191588fd10546a94/third_party/WebKit/Source/core/loader/ImageLoader.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7d085fbb43b21e959900b94f191588fd10546a94/third_party/WebKit/Source/core/loader/ImageLoader.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/ImageLoader.cpp?ref=7d085fbb43b21e959900b94f191588fd10546a94"", ""patch"": ""@@ -211,8 +211,8 @@ void ImageLoader::updateFromElement()\n             clearFailedLoadURL();\n     } else if (!attr.isNull()) {\n         // Fire an error event if the url is empty.\n-        // FIXME: Should we fire this event asynchronoulsy via errorEventSender()?\n-        m_element->dispatchEvent(Event::create(eventNames().errorEvent, false, false));\n+        m_hasPendingErrorEvent = true;\n+        errorEventSender().dispatchEventSoon(this);\n     }\n     \n     CachedImage* oldImage = m_image.get();""}","void ImageLoader::updateFromElement()
{
    Document* document = m_element->document();
    if (!document->renderer())
        return;

    AtomicString attr = m_element->imageSourceURL();

    if (attr == m_failedLoadURL)
        return;

    CachedResourceHandle<CachedImage> newImage = 0;
    if (!attr.isNull() && !stripLeadingAndTrailingHTMLSpaces(attr).isEmpty()) {
        CachedResourceRequest request(ResourceRequest(document->completeURL(sourceURI(attr))));
        request.setInitiator(element());

        String crossOriginMode = m_element->fastGetAttribute(HTMLNames::crossoriginAttr);
        if (!crossOriginMode.isNull()) {
            StoredCredentials allowCredentials = equalIgnoringCase(crossOriginMode, ""use-credentials"") ? AllowStoredCredentials : DoNotAllowStoredCredentials;
            updateRequestForAccessControl(request.mutableResourceRequest(), document->securityOrigin(), allowCredentials);
        }

        if (m_loadManually) {
            bool autoLoadOtherImages = document->cachedResourceLoader()->autoLoadImages();
            document->cachedResourceLoader()->setAutoLoadImages(false);
            newImage = new CachedImage(request.resourceRequest());
            newImage->setLoading(true);
            newImage->setOwningCachedResourceLoader(document->cachedResourceLoader());
            document->cachedResourceLoader()->m_documentResources.set(newImage->url(), newImage.get());
            document->cachedResourceLoader()->setAutoLoadImages(autoLoadOtherImages);
        } else
            newImage = document->cachedResourceLoader()->requestImage(request);

        if (!newImage && !pageIsBeingDismissed(document)) {
            m_failedLoadURL = attr;
            m_hasPendingErrorEvent = true;
            errorEventSender().dispatchEventSoon(this);
        } else
             clearFailedLoadURL();
     } else if (!attr.isNull()) {
        m_hasPendingErrorEvent = true;
        errorEventSender().dispatchEventSoon(this);
     }
     
     CachedImage* oldImage = m_image.get();
    if (newImage != oldImage) {
        if (m_hasPendingBeforeLoadEvent) {
            beforeLoadEventSender().cancelEvent(this);
            m_hasPendingBeforeLoadEvent = false;
        }
        if (m_hasPendingLoadEvent) {
            loadEventSender().cancelEvent(this);
            m_hasPendingLoadEvent = false;
        }

        if (m_hasPendingErrorEvent && newImage) {
            errorEventSender().cancelEvent(this);
            m_hasPendingErrorEvent = false;
        }

        m_image = newImage;
        m_hasPendingBeforeLoadEvent = !m_element->document()->isImageDocument() && newImage;
        m_hasPendingLoadEvent = newImage;
        m_imageComplete = !newImage;

        if (newImage) {
            if (!m_element->document()->isImageDocument()) {
                if (!m_element->document()->hasListenerType(Document::BEFORELOAD_LISTENER))
                    dispatchPendingBeforeLoadEvent();
                else
                    beforeLoadEventSender().dispatchEventSoon(this);
            } else
                updateRenderer();

            newImage->addClient(this);
        }
        if (oldImage)
            oldImage->removeClient(this);
    }

    if (RenderImageResource* imageResource = renderImageResource())
        imageResource->resetAnimation();

    updatedHasPendingEvent();
}
","void ImageLoader::updateFromElement()
{
    Document* document = m_element->document();
    if (!document->renderer())
        return;

    AtomicString attr = m_element->imageSourceURL();

    if (attr == m_failedLoadURL)
        return;

    CachedResourceHandle<CachedImage> newImage = 0;
    if (!attr.isNull() && !stripLeadingAndTrailingHTMLSpaces(attr).isEmpty()) {
        CachedResourceRequest request(ResourceRequest(document->completeURL(sourceURI(attr))));
        request.setInitiator(element());

        String crossOriginMode = m_element->fastGetAttribute(HTMLNames::crossoriginAttr);
        if (!crossOriginMode.isNull()) {
            StoredCredentials allowCredentials = equalIgnoringCase(crossOriginMode, ""use-credentials"") ? AllowStoredCredentials : DoNotAllowStoredCredentials;
            updateRequestForAccessControl(request.mutableResourceRequest(), document->securityOrigin(), allowCredentials);
        }

        if (m_loadManually) {
            bool autoLoadOtherImages = document->cachedResourceLoader()->autoLoadImages();
            document->cachedResourceLoader()->setAutoLoadImages(false);
            newImage = new CachedImage(request.resourceRequest());
            newImage->setLoading(true);
            newImage->setOwningCachedResourceLoader(document->cachedResourceLoader());
            document->cachedResourceLoader()->m_documentResources.set(newImage->url(), newImage.get());
            document->cachedResourceLoader()->setAutoLoadImages(autoLoadOtherImages);
        } else
            newImage = document->cachedResourceLoader()->requestImage(request);

        if (!newImage && !pageIsBeingDismissed(document)) {
            m_failedLoadURL = attr;
            m_hasPendingErrorEvent = true;
            errorEventSender().dispatchEventSoon(this);
        } else
             clearFailedLoadURL();
     } else if (!attr.isNull()) {
        m_element->dispatchEvent(Event::create(eventNames().errorEvent, false, false));
     }
     
     CachedImage* oldImage = m_image.get();
    if (newImage != oldImage) {
        if (m_hasPendingBeforeLoadEvent) {
            beforeLoadEventSender().cancelEvent(this);
            m_hasPendingBeforeLoadEvent = false;
        }
        if (m_hasPendingLoadEvent) {
            loadEventSender().cancelEvent(this);
            m_hasPendingLoadEvent = false;
        }

        if (m_hasPendingErrorEvent && newImage) {
            errorEventSender().cancelEvent(this);
            m_hasPendingErrorEvent = false;
        }

        m_image = newImage;
        m_hasPendingBeforeLoadEvent = !m_element->document()->isImageDocument() && newImage;
        m_hasPendingLoadEvent = newImage;
        m_imageComplete = !newImage;

        if (newImage) {
            if (!m_element->document()->isImageDocument()) {
                if (!m_element->document()->hasListenerType(Document::BEFORELOAD_LISTENER))
                    dispatchPendingBeforeLoadEvent();
                else
                    beforeLoadEventSender().dispatchEventSoon(this);
            } else
                updateRenderer();

            newImage->addClient(this);
        }
        if (oldImage)
            oldImage->removeClient(this);
    }

    if (RenderImageResource* imageResource = renderImageResource())
        imageResource->resetAnimation();

    updatedHasPendingEvent();
}
",C,"        m_hasPendingErrorEvent = true;
        errorEventSender().dispatchEventSoon(this);
","        m_element->dispatchEvent(Event::create(eventNames().errorEvent, false, false));
",,"@@ -211,8 +211,8 @@ void ImageLoader::updateFromElement()
             clearFailedLoadURL();
     } else if (!attr.isNull()) {
         // Fire an error event if the url is empty.
-        // FIXME: Should we fire this event asynchronoulsy via errorEventSender()?
-        m_element->dispatchEvent(Event::create(eventNames().errorEvent, false, false));
+        m_hasPendingErrorEvent = true;
+        errorEventSender().dispatchEventSoon(this);
     }
     
     CachedImage* oldImage = m_image.get();",Chrome,7d085fbb43b21e959900b94f191588fd10546a94,4eac37ac2a1f601598a02475971e43a03f85fc2e,1,"void ImageLoader::updateFromElement()
{
    // If we're not making renderers for the page, then don't load images.  We don't want to slow
    // down the raw HTML parsing case by loading images we don't intend to display.
    Document* document = m_element->document();
    if (!document->renderer())
        return;

    AtomicString attr = m_element->imageSourceURL();

    if (attr == m_failedLoadURL)
        return;

    // Do not load any image if the 'src' attribute is missing or if it is
    // an empty string.
    CachedResourceHandle<CachedImage> newImage = 0;
    if (!attr.isNull() && !stripLeadingAndTrailingHTMLSpaces(attr).isEmpty()) {
        CachedResourceRequest request(ResourceRequest(document->completeURL(sourceURI(attr))));
        request.setInitiator(element());

        String crossOriginMode = m_element->fastGetAttribute(HTMLNames::crossoriginAttr);
        if (!crossOriginMode.isNull()) {
            StoredCredentials allowCredentials = equalIgnoringCase(crossOriginMode, ""use-credentials"") ? AllowStoredCredentials : DoNotAllowStoredCredentials;
            updateRequestForAccessControl(request.mutableResourceRequest(), document->securityOrigin(), allowCredentials);
        }

        if (m_loadManually) {
            bool autoLoadOtherImages = document->cachedResourceLoader()->autoLoadImages();
            document->cachedResourceLoader()->setAutoLoadImages(false);
            newImage = new CachedImage(request.resourceRequest());
            newImage->setLoading(true);
            newImage->setOwningCachedResourceLoader(document->cachedResourceLoader());
            document->cachedResourceLoader()->m_documentResources.set(newImage->url(), newImage.get());
            document->cachedResourceLoader()->setAutoLoadImages(autoLoadOtherImages);
        } else
            newImage = document->cachedResourceLoader()->requestImage(request);

        // If we do not have an image here, it means that a cross-site
        // violation occurred, or that the image was blocked via Content
        // Security Policy, or the page is being dismissed. Trigger an
        // error event if the page is not being dismissed.
        if (!newImage && !pageIsBeingDismissed(document)) {
            m_failedLoadURL = attr;
            m_hasPendingErrorEvent = true;
            errorEventSender().dispatchEventSoon(this);
        } else
             clearFailedLoadURL();
     } else if (!attr.isNull()) {
         // Fire an error event if the url is empty.
//flaw_line_below:
        // FIXME: Should we fire this event asynchronoulsy via errorEventSender()?
//flaw_line_below:
        m_element->dispatchEvent(Event::create(eventNames().errorEvent, false, false));
//fix_flaw_line_below:
//        m_hasPendingErrorEvent = true;
//fix_flaw_line_below:
//        errorEventSender().dispatchEventSoon(this);
     }
     
     CachedImage* oldImage = m_image.get();
    if (newImage != oldImage) {
        if (m_hasPendingBeforeLoadEvent) {
            beforeLoadEventSender().cancelEvent(this);
            m_hasPendingBeforeLoadEvent = false;
        }
        if (m_hasPendingLoadEvent) {
            loadEventSender().cancelEvent(this);
            m_hasPendingLoadEvent = false;
        }

        // Cancel error events that belong to the previous load, which is now cancelled by changing the src attribute.
        // If newImage is null and m_hasPendingErrorEvent is true, we know the error event has been just posted by
        // this load and we should not cancel the event.
        // FIXME: If both previous load and this one got blocked with an error, we can receive one error event instead of two.
        if (m_hasPendingErrorEvent && newImage) {
            errorEventSender().cancelEvent(this);
            m_hasPendingErrorEvent = false;
        }

        m_image = newImage;
        m_hasPendingBeforeLoadEvent = !m_element->document()->isImageDocument() && newImage;
        m_hasPendingLoadEvent = newImage;
        m_imageComplete = !newImage;

        if (newImage) {
            if (!m_element->document()->isImageDocument()) {
                if (!m_element->document()->hasListenerType(Document::BEFORELOAD_LISTENER))
                    dispatchPendingBeforeLoadEvent();
                else
                    beforeLoadEventSender().dispatchEventSoon(this);
            } else
                updateRenderer();

            // If newImage is cached, addClient() will result in the load event
            // being queued to fire. Ensure this happens after beforeload is
            // dispatched.
            newImage->addClient(this);
        }
        if (oldImage)
            oldImage->removeClient(this);
    }

    if (RenderImageResource* imageResource = renderImageResource())
        imageResource->resetAnimation();

    // Only consider updating the protection ref-count of the Element immediately before returning
    // from this function as doing so might result in the destruction of this ImageLoader.
    updatedHasPendingEvent();
}
",185017,"void ImageLoader::updateFromElement()
{
    Document* document = m_element->document();
    if (!document->renderer())
        return;

    AtomicString attr = m_element->imageSourceURL();

    if (attr == m_failedLoadURL)
        return;

    CachedResourceHandle<CachedImage> newImage = 0;
    if (!attr.isNull() && !stripLeadingAndTrailingHTMLSpaces(attr).isEmpty()) {
        CachedResourceRequest request(ResourceRequest(document->completeURL(sourceURI(attr))));
        request.setInitiator(element());

        String crossOriginMode = m_element->fastGetAttribute(HTMLNames::crossoriginAttr);
        if (!crossOriginMode.isNull()) {
            StoredCredentials allowCredentials = equalIgnoringCase(crossOriginMode, ""use-credentials"") ? AllowStoredCredentials : DoNotAllowStoredCredentials;
            updateRequestForAccessControl(request.mutableResourceRequest(), document->securityOrigin(), allowCredentials);
        }

        if (m_loadManually) {
            bool autoLoadOtherImages = document->cachedResourceLoader()->autoLoadImages();
            document->cachedResourceLoader()->setAutoLoadImages(false);
            newImage = new CachedImage(request.resourceRequest());
            newImage->setLoading(true);
            newImage->setOwningCachedResourceLoader(document->cachedResourceLoader());
            document->cachedResourceLoader()->m_documentResources.set(newImage->url(), newImage.get());
            document->cachedResourceLoader()->setAutoLoadImages(autoLoadOtherImages);
        } else
            newImage = document->cachedResourceLoader()->requestImage(request);

        if (!newImage && !pageIsBeingDismissed(document)) {
            m_failedLoadURL = attr;
            m_hasPendingErrorEvent = true;
            errorEventSender().dispatchEventSoon(this);
        } else
             clearFailedLoadURL();
     } else if (!attr.isNull()) {
        m_element->dispatchEvent(Event::create(eventNames().errorEvent, false, false));
     }
     
     CachedImage* oldImage = m_image.get();
    if (newImage != oldImage) {
        if (m_hasPendingBeforeLoadEvent) {
            beforeLoadEventSender().cancelEvent(this);
            m_hasPendingBeforeLoadEvent = false;
        }
        if (m_hasPendingLoadEvent) {
            loadEventSender().cancelEvent(this);
            m_hasPendingLoadEvent = false;
        }

        if (m_hasPendingErrorEvent && newImage) {
            errorEventSender().cancelEvent(this);
            m_hasPendingErrorEvent = false;
        }

        m_image = newImage;
        m_hasPendingBeforeLoadEvent = !m_element->document()->isImageDocument() && newImage;
        m_hasPendingLoadEvent = newImage;
        m_imageComplete = !newImage;

        if (newImage) {
            if (!m_element->document()->isImageDocument()) {
                if (!m_element->document()->hasListenerType(Document::BEFORELOAD_LISTENER))
                    dispatchPendingBeforeLoadEvent();
                else
                    beforeLoadEventSender().dispatchEventSoon(this);
            } else
                updateRenderer();

            newImage->addClient(this);
        }
        if (oldImage)
            oldImage->removeClient(this);
    }

    if (RenderImageResource* imageResource = renderImageResource())
        imageResource->resetAnimation();

    updatedHasPendingEvent();
}
","void ImageLoader::updateFromElement()
{
    Document* document = m_element->document();
    if (!document->renderer())
        return;

    AtomicString attr = m_element->imageSourceURL();

    if (attr == m_failedLoadURL)
        return;

    CachedResourceHandle<CachedImage> newImage = 0;
    if (!attr.isNull() && !stripLeadingAndTrailingHTMLSpaces(attr).isEmpty()) {
        CachedResourceRequest request(ResourceRequest(document->completeURL(sourceURI(attr))));
        request.setInitiator(element());

        String crossOriginMode = m_element->fastGetAttribute(HTMLNames::crossoriginAttr);
        if (!crossOriginMode.isNull()) {
            StoredCredentials allowCredentials = equalIgnoringCase(crossOriginMode, ""use-credentials"") ? AllowStoredCredentials : DoNotAllowStoredCredentials;
            updateRequestForAccessControl(request.mutableResourceRequest(), document->securityOrigin(), allowCredentials);
        }

        if (m_loadManually) {
            bool autoLoadOtherImages = document->cachedResourceLoader()->autoLoadImages();
            document->cachedResourceLoader()->setAutoLoadImages(false);
            newImage = new CachedImage(request.resourceRequest());
            newImage->setLoading(true);
            newImage->setOwningCachedResourceLoader(document->cachedResourceLoader());
            document->cachedResourceLoader()->m_documentResources.set(newImage->url(), newImage.get());
            document->cachedResourceLoader()->setAutoLoadImages(autoLoadOtherImages);
        } else
            newImage = document->cachedResourceLoader()->requestImage(request);

        if (!newImage && !pageIsBeingDismissed(document)) {
            m_failedLoadURL = attr;
            m_hasPendingErrorEvent = true;
            errorEventSender().dispatchEventSoon(this);
        } else
             clearFailedLoadURL();
     } else if (!attr.isNull()) {
        m_hasPendingErrorEvent = true;
        errorEventSender().dispatchEventSoon(this);
     }
     
     CachedImage* oldImage = m_image.get();
    if (newImage != oldImage) {
        if (m_hasPendingBeforeLoadEvent) {
            beforeLoadEventSender().cancelEvent(this);
            m_hasPendingBeforeLoadEvent = false;
        }
        if (m_hasPendingLoadEvent) {
            loadEventSender().cancelEvent(this);
            m_hasPendingLoadEvent = false;
        }

        if (m_hasPendingErrorEvent && newImage) {
            errorEventSender().cancelEvent(this);
            m_hasPendingErrorEvent = false;
        }

        m_image = newImage;
        m_hasPendingBeforeLoadEvent = !m_element->document()->isImageDocument() && newImage;
        m_hasPendingLoadEvent = newImage;
        m_imageComplete = !newImage;

        if (newImage) {
            if (!m_element->document()->isImageDocument()) {
                if (!m_element->document()->hasListenerType(Document::BEFORELOAD_LISTENER))
                    dispatchPendingBeforeLoadEvent();
                else
                    beforeLoadEventSender().dispatchEventSoon(this);
            } else
                updateRenderer();

            newImage->addClient(this);
        }
        if (oldImage)
            oldImage->removeClient(this);
    }

    if (RenderImageResource* imageResource = renderImageResource())
        imageResource->resetAnimation();

    updatedHasPendingEvent();
}
","The `ImageLoader::updateFromElement` function is responsible for managing the loading and updating of an image resource associated with a specific HTML element. It first checks if the document has a renderer and retrieves the image source URL. If the URL has failed to load previously, it exits early. The function constructs a resource request, potentially adjusting for cross-origin settings, and either manually loads the image or requests it from the document's cached resource loader. It handles various events related to loading, such as error and before-load events, and updates the current image while managing client references to ensure proper resource management and event dispatching.","The function manages the loading and updating of an image resource linked to an HTML element. It begins by verifying the presence of a document renderer and retrieves the image source URL, avoiding previously failed URLs. A resource request is created, considering cross-origin settings, and the image is either loaded manually or requested from a cache. The function handles various loading events, including errors, and updates the current image while ensuring proper management of client references. It also resets any associated animations and updates the state of pending events to reflect the current loading status.","The vulnerability in the original code stemmed from firing an error event synchronously, which could disrupt the state of the input element, potentially leading to unexpected behavior or crashes. Specifically, when an image failed to load, the error event was dispatched immediately, causing issues with the element's lifecycle. The fix involved changing the error event handling to be asynchronous by utilizing `errorEventSender().dispatchEventSoon(this)`, ensuring that the event is queued for later execution rather than executed immediately. This adjustment prevents interference with the input element's state, enhancing stability and reliability in the image loading process.","The vulnerability in the original code arose from the synchronous firing of an error event when an image failed to load, which could disrupt the state of the associated input element, leading to instability or crashes. This immediate execution risked altering the element's lifecycle unexpectedly. The fix addressed this issue by changing the error event handling to be asynchronous, allowing the event to be queued for later execution instead of being processed immediately. This adjustment ensures that the input element's state remains intact during the error handling process, thereby improving the overall stability and reliability of the image loading functionality.","The vulnerability was fixed by modifying the error event handling mechanism to be asynchronous. In the original code, the error event was dispatched immediately, which could disrupt the input element's state. The change involved replacing the synchronous error event firing with a call to `errorEventSender().dispatchEventSoon(this)`, allowing the error event to be queued for later execution. This adjustment ensures that the input element remains stable and unaffected during the error handling process, preventing any unintended consequences that could arise from immediate event dispatching and enhancing the overall robustness of the image loading functionality.","The vulnerability was addressed by changing the error event handling from synchronous to asynchronous execution. Previously, firing the error event immediately could disrupt the state of the associated input element, leading to instability. The fix involved queuing the error event for later execution, allowing the system to maintain the integrity of the input element during the error handling process. This adjustment ensures that the element's lifecycle is preserved, preventing unintended side effects and enhancing the overall stability and reliability of the image loading functionality within the application.","CWE-362, CWE-664, CWE-364, CWE-366, CWE-367, CWE-835, CWE-404, CWE-821, CWE-662, CWE-371",N,-1
68,68,185339,185339,,Remote,Not required,Partial,CVE-2014-3191,https://www.cvedetails.com/cve/CVE-2014-3191/,CWE-416,Low,Partial,Partial,,2014-10-08,7.5,"Use-after-free vulnerability in Blink, as used in Google Chrome before 38.0.2125.101, allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted JavaScript code that triggers a widget-position update that improperly interacts with the render tree, related to the FrameView::updateLayoutAndStyleForPainting function in core/frame/FrameView.cpp and the RenderLayerScrollableArea::setScrollOffset function in core/rendering/RenderLayerScrollableArea.cpp.",2016-11-28,DoS ,2,https://github.com/chromium/chromium/commit/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95,11a4cc4a6d6e665d9a118fada4b7c658d6f70d95,"Defer call to updateWidgetPositions() outside of RenderLayerScrollableArea.

updateWidgetPositions() can destroy the render tree, so it should never
be called from inside RenderLayerScrollableArea. Leaving it there allows
for the potential of use-after-free bugs.

BUG=402407
R=vollick@chromium.org

Review URL: https://codereview.chromium.org/490473003

git-svn-id: svn://svn.chromium.org/blink/trunk@180681 bbb929c8-8fbe-4397-9dbb-9b2b20218538",0,third_party/WebKit/Source/core/frame/FrameView.cpp,"{""sha"": ""139597f9cb07c5d48bed18984ec4747f4b4f3438"", ""filename"": ""third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions-expected.txt"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions-expected.txt?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -0,0 +1,2 @@\n+\n+""}<_**next**_>{""sha"": ""8f4d71cc76ae3093b28ae3f6a6171df7c1f37863"", ""filename"": ""third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions.html"", ""status"": ""added"", ""additions"": 60, ""deletions"": 0, ""changes"": 60, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions.html?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -0,0 +1,60 @@\n+<!DOCTYPE html>\n+<!-- This test is to catch a flakey use-after-free for ASAN bots. (see crbug.com/402407) -->\n+<script>\n+  function start() {\n+    svgIframe = document.createElement('iframe');\n+    svgIframe.src = 'resources/do-not-crash-use-after-free-update-widget-positions.svg';\n+\n+    bodyElement = document.body;\n+\n+    articleElement = document.createElement('article');\n+    acronymElement = document.createElement('acronym');\n+\n+    bodyElement.style.overflow = 'scroll';\n+\n+    selectionRange = document.createRange();\n+    selectionRange.selectNodeContents(articleElement);\n+    selectionRange.surroundContents(bodyElement);\n+\n+    w3Iframe = document.createElementNS('http://www.w3.org/1999/xhtml', 'iframe');\n+    w3Iframe.src = 'resources/do-not-crash-use-after-free-update-widget-positions-iframe.html';\n+    w3Iframe.onload = iframeOnLoad;\n+    document.documentElement.appendChild(w3Iframe);\n+\n+    selectionRange.insertNode(svgIframe);\n+    bodyElement.style.position = 'fixed';\n+\n+    while (svgIframe.parentNode) {\n+      svgIframe = svgIframe.parentNode;\n+    }\n+\n+    svgIframe.createElement;\n+\n+    document.documentElement.appendChild(svgIframe);\n+\n+    acronymElement.style.position = 'absolute';\n+  }\n+\n+  function iframeOnLoad() {\n+    bodyElement.appendChild(acronymElement);\n+    acronymElement.offsetWidth;\n+\n+    acronymElement.appendChild(w3Iframe);\n+    w3Iframe.offsetWidth;\n+\n+    window.setTimeout('window.iframeCallback()', 50);\n+  }\n+\n+  function iframeCallback() {\n+    bodyElement.style.cssText = null;\n+\n+    w3Iframe.contentDocument.location.hash = 'element0';\n+  }\n+\n+  if (window.testRunner) {\n+    testRunner.dumpAsText();\n+  }\n+</script>\n+<body onload = \""start()\"">\n+  This test passes if it doesn't crash.\n+</body>""}<_**next**_>{""sha"": ""93cd657e822e58345e3f98b8b61112d939d19ea8"", ""filename"": ""third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions-iframe.html"", ""status"": ""added"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions-iframe.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions-iframe.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions-iframe.html?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -0,0 +1,4 @@\n+<!DOCTYPE html>\n+<body id=\""element0\"">\n+</body>\n+""}<_**next**_>{""sha"": ""bb5dd22510b2bbd51b2b4023e1a75c95f264d7c1"", ""filename"": ""third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions.svg"", ""status"": ""added"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions.svg"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions.svg"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions.svg?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -0,0 +1,7 @@\n+<?xml version=\""1.0\""?>\n+<svg id=\""element0\"" xmlns=\""http://www.w3.org/2000/svg\"">\n+  <rect>\n+    <animate from=\""10px\""  to=\""100px\"" />\n+    <animate attributeName=\""height\"" to=\""10px\"" dur=\""10s\"" />\n+  </rect>\n+</svg>""}<_**next**_>{""sha"": ""b7540d9fe937adc128d4c3ed672d330b822a5258"", ""filename"": ""third_party/WebKit/Source/core/frame/FrameView.cpp"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/frame/FrameView.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/frame/FrameView.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/FrameView.cpp?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -118,6 +118,7 @@ FrameView::FrameView(LocalFrame* frame)\n     , m_inputEventsScaleFactorForEmulation(1)\n     , m_layoutSizeFixedToFrameSize(true)\n     , m_didScrollTimer(this, &FrameView::didScrollTimerFired)\n+    , m_needsUpdateWidgetPositions(false)\n {\n     ASSERT(m_frame);\n     init();\n@@ -2545,13 +2546,25 @@ void FrameView::paintOverhangAreas(GraphicsContext* context, const IntRect& hori\n     ScrollView::paintOverhangAreas(context, horizontalOverhangArea, verticalOverhangArea, dirtyRect);\n }\n \n+void FrameView::updateWidgetPositionsIfNeeded()\n+{\n+    if (!m_needsUpdateWidgetPositions)\n+        return;\n+\n+    m_needsUpdateWidgetPositions = false;\n+\n+    updateWidgetPositions();\n+}\n+\n void FrameView::updateLayoutAndStyleForPainting()\n {\n     // Updating layout can run script, which can tear down the FrameView.\n     RefPtr<FrameView> protector(this);\n \n     updateLayoutAndStyleIfNeededRecursive();\n \n+    updateWidgetPositionsIfNeeded();\n+\n     if (RenderView* view = renderView()) {\n         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(\""devtools.timeline\""), \""UpdateLayerTree\"", \""frame\"", m_frame.get());\n         // FIXME(361045): remove InspectorInstrumentation calls once DevTools Timeline migrates to tracing.""}<_**next**_>{""sha"": ""15f88afb4861a50b770e8ce54cedd35ecc08ddb5"", ""filename"": ""third_party/WebKit/Source/core/frame/FrameView.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/frame/FrameView.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/frame/FrameView.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/FrameView.h?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -103,6 +103,8 @@ class FrameView FINAL : public ScrollView {\n     bool needsLayout() const;\n     void setNeedsLayout();\n \n+    void setNeedsUpdateWidgetPositions() { m_needsUpdateWidgetPositions = true; }\n+\n     // Methods for getting/setting the size Blink should use to layout the contents.\n     IntSize layoutSize(IncludeScrollbarsInRect = ExcludeScrollbars) const;\n     void setLayoutSize(const IntSize&);\n@@ -370,6 +372,8 @@ class FrameView FINAL : public ScrollView {\n     virtual IntPoint convertToContainingView(const IntPoint&) const OVERRIDE;\n     virtual IntPoint convertFromContainingView(const IntPoint&) const OVERRIDE;\n \n+    void updateWidgetPositionsIfNeeded();\n+\n     void sendResizeEventIfNeeded();\n \n     void updateScrollableAreaSet();\n@@ -490,6 +494,8 @@ class FrameView FINAL : public ScrollView {\n     Timer<FrameView> m_didScrollTimer;\n \n     Vector<IntRect> m_tickmarks;\n+\n+    bool m_needsUpdateWidgetPositions;\n };\n \n inline void FrameView::incrementVisuallyNonEmptyCharacterCount(unsigned count)""}<_**next**_>{""sha"": ""d6a56bf0a5bb016c8732d23fbfd53dbcb809a82d"", ""filename"": ""third_party/WebKit/Source/core/rendering/RenderLayerScrollableArea.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 4, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/rendering/RenderLayerScrollableArea.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/rendering/RenderLayerScrollableArea.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/rendering/RenderLayerScrollableArea.cpp?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -366,10 +366,7 @@ void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)\n         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));\n         // Update regions, scrolling may change the clip of a particular region.\n         frameView->updateAnnotatedRegions();\n-        // FIXME: We shouldn't call updateWidgetPositions() here since it might tear down the render tree,\n-        // for now we just crash to avoid allowing an attacker to use after free.\n-        frameView->updateWidgetPositions();\n-        RELEASE_ASSERT(frameView->renderView());\n+        frameView->setNeedsUpdateWidgetPositions();\n         updateCompositingLayersAfterScroll();\n     }\n ""}"," void FrameView::updateLayoutAndStyleForPainting()
 {
     RefPtr<FrameView> protector(this);
 
     updateLayoutAndStyleIfNeededRecursive();
 
    updateWidgetPositionsIfNeeded();

     if (RenderView* view = renderView()) {
         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""UpdateLayerTree"", ""frame"", m_frame.get());
        InspectorInstrumentation::willUpdateLayerTree(m_frame.get());

        view->compositor()->updateIfNeededRecursive();

        if (view->compositor()->inCompositingMode() && m_frame->isLocalRoot())
            m_frame->page()->scrollingCoordinator()->updateAfterCompositingChangeIfNeeded();

        updateCompositedSelectionBoundsIfNeeded();

        InspectorInstrumentation::didUpdateLayerTree(m_frame.get());

        invalidateTreeIfNeededRecursive();
    }

    scrollContentsIfNeededRecursive();
    ASSERT(lifecycle().state() == DocumentLifecycle::PaintInvalidationClean);
}
"," void FrameView::updateLayoutAndStyleForPainting()
 {
     RefPtr<FrameView> protector(this);
 
     updateLayoutAndStyleIfNeededRecursive();
 
     if (RenderView* view = renderView()) {
         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""UpdateLayerTree"", ""frame"", m_frame.get());
        InspectorInstrumentation::willUpdateLayerTree(m_frame.get());

        view->compositor()->updateIfNeededRecursive();

        if (view->compositor()->inCompositingMode() && m_frame->isLocalRoot())
            m_frame->page()->scrollingCoordinator()->updateAfterCompositingChangeIfNeeded();

        updateCompositedSelectionBoundsIfNeeded();

        InspectorInstrumentation::didUpdateLayerTree(m_frame.get());

        invalidateTreeIfNeededRecursive();
    }

    scrollContentsIfNeededRecursive();
    ASSERT(lifecycle().state() == DocumentLifecycle::PaintInvalidationClean);
}
",C,"    updateWidgetPositionsIfNeeded();

",,,"@@ -118,6 +118,7 @@ FrameView::FrameView(LocalFrame* frame)
     , m_inputEventsScaleFactorForEmulation(1)
     , m_layoutSizeFixedToFrameSize(true)
     , m_didScrollTimer(this, &FrameView::didScrollTimerFired)
+    , m_needsUpdateWidgetPositions(false)
 {
     ASSERT(m_frame);
     init();
@@ -2545,13 +2546,25 @@ void FrameView::paintOverhangAreas(GraphicsContext* context, const IntRect& hori
     ScrollView::paintOverhangAreas(context, horizontalOverhangArea, verticalOverhangArea, dirtyRect);
 }
 
+void FrameView::updateWidgetPositionsIfNeeded()
+{
+    if (!m_needsUpdateWidgetPositions)
+        return;
+
+    m_needsUpdateWidgetPositions = false;
+
+    updateWidgetPositions();
+}
+
 void FrameView::updateLayoutAndStyleForPainting()
 {
     // Updating layout can run script, which can tear down the FrameView.
     RefPtr<FrameView> protector(this);
 
     updateLayoutAndStyleIfNeededRecursive();
 
+    updateWidgetPositionsIfNeeded();
+
     if (RenderView* view = renderView()) {
         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""UpdateLayerTree"", ""frame"", m_frame.get());
         // FIXME(361045): remove InspectorInstrumentation calls once DevTools Timeline migrates to tracing.",Chrome,11a4cc4a6d6e665d9a118fada4b7c658d6f70d95,09298a5df529dfb55d846f5f85df4df437fac052,1," void FrameView::updateLayoutAndStyleForPainting()
 {
     // Updating layout can run script, which can tear down the FrameView.
     RefPtr<FrameView> protector(this);
 
     updateLayoutAndStyleIfNeededRecursive();
 
//fix_flaw_line_below:
//    updateWidgetPositionsIfNeeded();
//fix_flaw_line_below:
//
     if (RenderView* view = renderView()) {
         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""UpdateLayerTree"", ""frame"", m_frame.get());
         // FIXME(361045): remove InspectorInstrumentation calls once DevTools Timeline migrates to tracing.
        InspectorInstrumentation::willUpdateLayerTree(m_frame.get());

        view->compositor()->updateIfNeededRecursive();

        if (view->compositor()->inCompositingMode() && m_frame->isLocalRoot())
            m_frame->page()->scrollingCoordinator()->updateAfterCompositingChangeIfNeeded();

        updateCompositedSelectionBoundsIfNeeded();

        InspectorInstrumentation::didUpdateLayerTree(m_frame.get());

        invalidateTreeIfNeededRecursive();
    }

    scrollContentsIfNeededRecursive();
    ASSERT(lifecycle().state() == DocumentLifecycle::PaintInvalidationClean);
}
",185339," void FrameView::updateLayoutAndStyleForPainting()
 {
     RefPtr<FrameView> protector(this);
 
     updateLayoutAndStyleIfNeededRecursive();
 
     if (RenderView* view = renderView()) {
         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""UpdateLayerTree"", ""frame"", m_frame.get());
        InspectorInstrumentation::willUpdateLayerTree(m_frame.get());

        view->compositor()->updateIfNeededRecursive();

        if (view->compositor()->inCompositingMode() && m_frame->isLocalRoot())
            m_frame->page()->scrollingCoordinator()->updateAfterCompositingChangeIfNeeded();

        updateCompositedSelectionBoundsIfNeeded();

        InspectorInstrumentation::didUpdateLayerTree(m_frame.get());

        invalidateTreeIfNeededRecursive();
    }

    scrollContentsIfNeededRecursive();
    ASSERT(lifecycle().state() == DocumentLifecycle::PaintInvalidationClean);
}
"," void FrameView::updateLayoutAndStyleForPainting()
 {
     RefPtr<FrameView> protector(this);
 
     updateLayoutAndStyleIfNeededRecursive();
 
    updateWidgetPositionsIfNeeded();

     if (RenderView* view = renderView()) {
         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""UpdateLayerTree"", ""frame"", m_frame.get());
        InspectorInstrumentation::willUpdateLayerTree(m_frame.get());

        view->compositor()->updateIfNeededRecursive();

        if (view->compositor()->inCompositingMode() && m_frame->isLocalRoot())
            m_frame->page()->scrollingCoordinator()->updateAfterCompositingChangeIfNeeded();

        updateCompositedSelectionBoundsIfNeeded();

        InspectorInstrumentation::didUpdateLayerTree(m_frame.get());

        invalidateTreeIfNeededRecursive();
    }

    scrollContentsIfNeededRecursive();
    ASSERT(lifecycle().state() == DocumentLifecycle::PaintInvalidationClean);
}
","The `FrameView::updateLayoutAndStyleForPainting` function is responsible for preparing the layout and style of a frame for painting in a graphical user interface. It begins by ensuring that the layout and style are updated recursively if necessary. If a valid `RenderView` is present, it triggers a series of updates, including notifying the inspector about layer tree updates, managing compositing changes, and updating selection bounds. The function also checks if the frame is in a valid state for painting, ensuring that any necessary invalidations are handled recursively, and finally, it scrolls the contents if required, maintaining the integrity of the document's lifecycle state.","The function is designed to prepare a graphical frame for rendering by updating its layout and style as needed. It begins by ensuring that any necessary updates are applied recursively. If a rendering context is available, it performs a series of operations to manage layer updates, notify relevant components about changes, and handle any compositing adjustments. Additionally, it updates selection boundaries if required and checks the state of the document to ensure it is ready for painting. Finally, it addresses any scrolling needs, maintaining the overall integrity of the rendering process.","The vulnerability in the original code stemmed from the call to `updateWidgetPositions()` within the `RenderLayerScrollableArea`, which could potentially destroy the render tree, leading to use-after-free bugs. This situation arises when the code attempts to access memory that has already been freed, resulting in undefined behavior. The fix involved deferring the call to `updateWidgetPositions()` to ensure it is executed outside of the `RenderLayerScrollableArea`, thereby preventing any unintended destruction of the render tree during critical rendering operations. This change enhances the stability and safety of the rendering process by avoiding potential memory access issues.","The vulnerability in the original code arose from a function call that could potentially destroy the render tree while still within a critical rendering context, leading to use-after-free issues. This situation occurs when the code attempts to access memory that has already been released, resulting in unpredictable behavior and crashes. The fix involved moving the function call outside of the critical rendering context, ensuring that the render tree remains intact during essential operations. This change effectively mitigates the risk of memory access violations, enhancing the overall stability and safety of the rendering process.","The vulnerability was fixed by deferring the call to `updateWidgetPositions()` so that it occurs outside of the `RenderLayerScrollableArea`. In the original code, calling `updateWidgetPositions()` within this context could lead to the destruction of the render tree, creating a risk of use-after-free bugs. By relocating this function call, the integrity of the render tree is preserved during critical rendering operations, thus preventing any potential memory access violations. This adjustment ensures that the rendering process remains stable and safe, effectively addressing the identified vulnerability.","The vulnerability was addressed by relocating a specific function call to occur outside of a critical rendering context where the render tree could be compromised. This adjustment prevents the potential destruction of the render tree during essential operations, thereby mitigating the risk of accessing freed memory, which could lead to unpredictable behavior and crashes. By ensuring that this function is executed in a safer context, the overall stability and integrity of the rendering process are maintained, effectively eliminating the identified risk of memory access violations. This change enhances the robustness of the code.","CWE-416, CWE-825, CWE-672, CWE-415, CWE-476, CWE-462, CWE-119, CWE-763, CWE-824, CWE-773",Y,1
69,69,185340,185340,,Remote,Not required,Partial,CVE-2014-3191,https://www.cvedetails.com/cve/CVE-2014-3191/,CWE-416,Low,Partial,Partial,,2014-10-08,7.5,"Use-after-free vulnerability in Blink, as used in Google Chrome before 38.0.2125.101, allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted JavaScript code that triggers a widget-position update that improperly interacts with the render tree, related to the FrameView::updateLayoutAndStyleForPainting function in core/frame/FrameView.cpp and the RenderLayerScrollableArea::setScrollOffset function in core/rendering/RenderLayerScrollableArea.cpp.",2016-11-28,DoS ,1,https://github.com/chromium/chromium/commit/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95,11a4cc4a6d6e665d9a118fada4b7c658d6f70d95,"Defer call to updateWidgetPositions() outside of RenderLayerScrollableArea.

updateWidgetPositions() can destroy the render tree, so it should never
be called from inside RenderLayerScrollableArea. Leaving it there allows
for the potential of use-after-free bugs.

BUG=402407
R=vollick@chromium.org

Review URL: https://codereview.chromium.org/490473003

git-svn-id: svn://svn.chromium.org/blink/trunk@180681 bbb929c8-8fbe-4397-9dbb-9b2b20218538",2,third_party/WebKit/Source/core/rendering/RenderLayerScrollableArea.cpp,"{""sha"": ""139597f9cb07c5d48bed18984ec4747f4b4f3438"", ""filename"": ""third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions-expected.txt"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions-expected.txt?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -0,0 +1,2 @@\n+\n+""}<_**next**_>{""sha"": ""8f4d71cc76ae3093b28ae3f6a6171df7c1f37863"", ""filename"": ""third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions.html"", ""status"": ""added"", ""additions"": 60, ""deletions"": 0, ""changes"": 60, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/compositing/overflow/do-not-crash-use-after-free-update-widget-positions.html?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -0,0 +1,60 @@\n+<!DOCTYPE html>\n+<!-- This test is to catch a flakey use-after-free for ASAN bots. (see crbug.com/402407) -->\n+<script>\n+  function start() {\n+    svgIframe = document.createElement('iframe');\n+    svgIframe.src = 'resources/do-not-crash-use-after-free-update-widget-positions.svg';\n+\n+    bodyElement = document.body;\n+\n+    articleElement = document.createElement('article');\n+    acronymElement = document.createElement('acronym');\n+\n+    bodyElement.style.overflow = 'scroll';\n+\n+    selectionRange = document.createRange();\n+    selectionRange.selectNodeContents(articleElement);\n+    selectionRange.surroundContents(bodyElement);\n+\n+    w3Iframe = document.createElementNS('http://www.w3.org/1999/xhtml', 'iframe');\n+    w3Iframe.src = 'resources/do-not-crash-use-after-free-update-widget-positions-iframe.html';\n+    w3Iframe.onload = iframeOnLoad;\n+    document.documentElement.appendChild(w3Iframe);\n+\n+    selectionRange.insertNode(svgIframe);\n+    bodyElement.style.position = 'fixed';\n+\n+    while (svgIframe.parentNode) {\n+      svgIframe = svgIframe.parentNode;\n+    }\n+\n+    svgIframe.createElement;\n+\n+    document.documentElement.appendChild(svgIframe);\n+\n+    acronymElement.style.position = 'absolute';\n+  }\n+\n+  function iframeOnLoad() {\n+    bodyElement.appendChild(acronymElement);\n+    acronymElement.offsetWidth;\n+\n+    acronymElement.appendChild(w3Iframe);\n+    w3Iframe.offsetWidth;\n+\n+    window.setTimeout('window.iframeCallback()', 50);\n+  }\n+\n+  function iframeCallback() {\n+    bodyElement.style.cssText = null;\n+\n+    w3Iframe.contentDocument.location.hash = 'element0';\n+  }\n+\n+  if (window.testRunner) {\n+    testRunner.dumpAsText();\n+  }\n+</script>\n+<body onload = \""start()\"">\n+  This test passes if it doesn't crash.\n+</body>""}<_**next**_>{""sha"": ""93cd657e822e58345e3f98b8b61112d939d19ea8"", ""filename"": ""third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions-iframe.html"", ""status"": ""added"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions-iframe.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions-iframe.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions-iframe.html?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -0,0 +1,4 @@\n+<!DOCTYPE html>\n+<body id=\""element0\"">\n+</body>\n+""}<_**next**_>{""sha"": ""bb5dd22510b2bbd51b2b4023e1a75c95f264d7c1"", ""filename"": ""third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions.svg"", ""status"": ""added"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions.svg"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions.svg"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/compositing/overflow/resources/do-not-crash-use-after-free-update-widget-positions.svg?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -0,0 +1,7 @@\n+<?xml version=\""1.0\""?>\n+<svg id=\""element0\"" xmlns=\""http://www.w3.org/2000/svg\"">\n+  <rect>\n+    <animate from=\""10px\""  to=\""100px\"" />\n+    <animate attributeName=\""height\"" to=\""10px\"" dur=\""10s\"" />\n+  </rect>\n+</svg>""}<_**next**_>{""sha"": ""b7540d9fe937adc128d4c3ed672d330b822a5258"", ""filename"": ""third_party/WebKit/Source/core/frame/FrameView.cpp"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/frame/FrameView.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/frame/FrameView.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/FrameView.cpp?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -118,6 +118,7 @@ FrameView::FrameView(LocalFrame* frame)\n     , m_inputEventsScaleFactorForEmulation(1)\n     , m_layoutSizeFixedToFrameSize(true)\n     , m_didScrollTimer(this, &FrameView::didScrollTimerFired)\n+    , m_needsUpdateWidgetPositions(false)\n {\n     ASSERT(m_frame);\n     init();\n@@ -2545,13 +2546,25 @@ void FrameView::paintOverhangAreas(GraphicsContext* context, const IntRect& hori\n     ScrollView::paintOverhangAreas(context, horizontalOverhangArea, verticalOverhangArea, dirtyRect);\n }\n \n+void FrameView::updateWidgetPositionsIfNeeded()\n+{\n+    if (!m_needsUpdateWidgetPositions)\n+        return;\n+\n+    m_needsUpdateWidgetPositions = false;\n+\n+    updateWidgetPositions();\n+}\n+\n void FrameView::updateLayoutAndStyleForPainting()\n {\n     // Updating layout can run script, which can tear down the FrameView.\n     RefPtr<FrameView> protector(this);\n \n     updateLayoutAndStyleIfNeededRecursive();\n \n+    updateWidgetPositionsIfNeeded();\n+\n     if (RenderView* view = renderView()) {\n         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(\""devtools.timeline\""), \""UpdateLayerTree\"", \""frame\"", m_frame.get());\n         // FIXME(361045): remove InspectorInstrumentation calls once DevTools Timeline migrates to tracing.""}<_**next**_>{""sha"": ""15f88afb4861a50b770e8ce54cedd35ecc08ddb5"", ""filename"": ""third_party/WebKit/Source/core/frame/FrameView.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/frame/FrameView.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/frame/FrameView.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/FrameView.h?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -103,6 +103,8 @@ class FrameView FINAL : public ScrollView {\n     bool needsLayout() const;\n     void setNeedsLayout();\n \n+    void setNeedsUpdateWidgetPositions() { m_needsUpdateWidgetPositions = true; }\n+\n     // Methods for getting/setting the size Blink should use to layout the contents.\n     IntSize layoutSize(IncludeScrollbarsInRect = ExcludeScrollbars) const;\n     void setLayoutSize(const IntSize&);\n@@ -370,6 +372,8 @@ class FrameView FINAL : public ScrollView {\n     virtual IntPoint convertToContainingView(const IntPoint&) const OVERRIDE;\n     virtual IntPoint convertFromContainingView(const IntPoint&) const OVERRIDE;\n \n+    void updateWidgetPositionsIfNeeded();\n+\n     void sendResizeEventIfNeeded();\n \n     void updateScrollableAreaSet();\n@@ -490,6 +494,8 @@ class FrameView FINAL : public ScrollView {\n     Timer<FrameView> m_didScrollTimer;\n \n     Vector<IntRect> m_tickmarks;\n+\n+    bool m_needsUpdateWidgetPositions;\n };\n \n inline void FrameView::incrementVisuallyNonEmptyCharacterCount(unsigned count)""}<_**next**_>{""sha"": ""d6a56bf0a5bb016c8732d23fbfd53dbcb809a82d"", ""filename"": ""third_party/WebKit/Source/core/rendering/RenderLayerScrollableArea.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 4, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/rendering/RenderLayerScrollableArea.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/11a4cc4a6d6e665d9a118fada4b7c658d6f70d95/third_party/WebKit/Source/core/rendering/RenderLayerScrollableArea.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/rendering/RenderLayerScrollableArea.cpp?ref=11a4cc4a6d6e665d9a118fada4b7c658d6f70d95"", ""patch"": ""@@ -366,10 +366,7 @@ void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)\n         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));\n         // Update regions, scrolling may change the clip of a particular region.\n         frameView->updateAnnotatedRegions();\n-        // FIXME: We shouldn't call updateWidgetPositions() here since it might tear down the render tree,\n-        // for now we just crash to avoid allowing an attacker to use after free.\n-        frameView->updateWidgetPositions();\n-        RELEASE_ASSERT(frameView->renderView());\n+        frameView->setNeedsUpdateWidgetPositions();\n         updateCompositingLayersAfterScroll();\n     }\n ""}","void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)
{
    if (!box().isMarquee()) {
        if (m_scrollDimensionsDirty)
            computeScrollDimensions();
    }

    if (scrollOffset() == toIntSize(newScrollOffset))
        return;

    setScrollOffset(toIntSize(newScrollOffset));

    LocalFrame* frame = box().frame();
    ASSERT(frame);

    RefPtr<FrameView> frameView = box().frameView();

    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""ScrollLayer"", ""data"", InspectorScrollLayerEvent::data(&box()));
    InspectorInstrumentation::willScrollLayer(&box());

    const RenderLayerModelObject* paintInvalidationContainer = box().containerForPaintInvalidation();

    if (!frameView->isInPerformLayout()) {
        layer()->clipper().clearClipRectsIncludingDescendants();
         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));
         frameView->updateAnnotatedRegions();
        frameView->setNeedsUpdateWidgetPositions();
         updateCompositingLayersAfterScroll();
     }
 
    frame->selection().setCaretRectNeedsUpdate();

    FloatQuad quadForFakeMouseMoveEvent = FloatQuad(layer()->renderer()->previousPaintInvalidationRect());

    quadForFakeMouseMoveEvent = paintInvalidationContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);
    frame->eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);

    bool requiresPaintInvalidation = true;

    if (!box().isMarquee() && box().view()->compositor()->inCompositingMode()) {
        DisableCompositingQueryAsserts disabler;
        bool onlyScrolledCompositedLayers = scrollsOverflow()
            && !layer()->hasVisibleNonLayerContent()
            && !layer()->hasNonCompositedChild()
            && !layer()->hasBlockSelectionGapBounds()
            && box().style()->backgroundLayers().attachment() != LocalBackgroundAttachment;

        if (usesCompositedScrolling() || onlyScrolledCompositedLayers)
            requiresPaintInvalidation = false;
    }

    if (requiresPaintInvalidation) {
        if (box().frameView()->isInPerformLayout())
            box().setShouldDoFullPaintInvalidation(true);
        else
            box().invalidatePaintUsingContainer(paintInvalidationContainer, layer()->renderer()->previousPaintInvalidationRect(), InvalidationScroll);
    }

    if (box().node())
        box().node()->document().enqueueScrollEventForNode(box().node());

    if (AXObjectCache* cache = box().document().existingAXObjectCache())
        cache->handleScrollPositionChanged(&box());

    InspectorInstrumentation::didScrollLayer(&box());
}
","void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)
{
    if (!box().isMarquee()) {
        if (m_scrollDimensionsDirty)
            computeScrollDimensions();
    }

    if (scrollOffset() == toIntSize(newScrollOffset))
        return;

    setScrollOffset(toIntSize(newScrollOffset));

    LocalFrame* frame = box().frame();
    ASSERT(frame);

    RefPtr<FrameView> frameView = box().frameView();

    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""ScrollLayer"", ""data"", InspectorScrollLayerEvent::data(&box()));
    InspectorInstrumentation::willScrollLayer(&box());

    const RenderLayerModelObject* paintInvalidationContainer = box().containerForPaintInvalidation();

    if (!frameView->isInPerformLayout()) {
        layer()->clipper().clearClipRectsIncludingDescendants();
         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));
         frameView->updateAnnotatedRegions();
        frameView->updateWidgetPositions();
        RELEASE_ASSERT(frameView->renderView());
         updateCompositingLayersAfterScroll();
     }
 
    frame->selection().setCaretRectNeedsUpdate();

    FloatQuad quadForFakeMouseMoveEvent = FloatQuad(layer()->renderer()->previousPaintInvalidationRect());

    quadForFakeMouseMoveEvent = paintInvalidationContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);
    frame->eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);

    bool requiresPaintInvalidation = true;

    if (!box().isMarquee() && box().view()->compositor()->inCompositingMode()) {
        DisableCompositingQueryAsserts disabler;
        bool onlyScrolledCompositedLayers = scrollsOverflow()
            && !layer()->hasVisibleNonLayerContent()
            && !layer()->hasNonCompositedChild()
            && !layer()->hasBlockSelectionGapBounds()
            && box().style()->backgroundLayers().attachment() != LocalBackgroundAttachment;

        if (usesCompositedScrolling() || onlyScrolledCompositedLayers)
            requiresPaintInvalidation = false;
    }

    if (requiresPaintInvalidation) {
        if (box().frameView()->isInPerformLayout())
            box().setShouldDoFullPaintInvalidation(true);
        else
            box().invalidatePaintUsingContainer(paintInvalidationContainer, layer()->renderer()->previousPaintInvalidationRect(), InvalidationScroll);
    }

    if (box().node())
        box().node()->document().enqueueScrollEventForNode(box().node());

    if (AXObjectCache* cache = box().document().existingAXObjectCache())
        cache->handleScrollPositionChanged(&box());

    InspectorInstrumentation::didScrollLayer(&box());
}
",C,"        frameView->setNeedsUpdateWidgetPositions();
","        frameView->updateWidgetPositions();
        RELEASE_ASSERT(frameView->renderView());
",,"@@ -366,10 +366,7 @@ void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)
         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));
         // Update regions, scrolling may change the clip of a particular region.
         frameView->updateAnnotatedRegions();
-        // FIXME: We shouldn't call updateWidgetPositions() here since it might tear down the render tree,
-        // for now we just crash to avoid allowing an attacker to use after free.
-        frameView->updateWidgetPositions();
-        RELEASE_ASSERT(frameView->renderView());
+        frameView->setNeedsUpdateWidgetPositions();
         updateCompositingLayersAfterScroll();
     }
 ",Chrome,11a4cc4a6d6e665d9a118fada4b7c658d6f70d95,09298a5df529dfb55d846f5f85df4df437fac052,1,"void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)
{
    if (!box().isMarquee()) {
        // Ensure that the dimensions will be computed if they need to be (for overflow:hidden blocks).
        if (m_scrollDimensionsDirty)
            computeScrollDimensions();
    }

    if (scrollOffset() == toIntSize(newScrollOffset))
        return;

    setScrollOffset(toIntSize(newScrollOffset));

    LocalFrame* frame = box().frame();
    ASSERT(frame);

    RefPtr<FrameView> frameView = box().frameView();

    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""ScrollLayer"", ""data"", InspectorScrollLayerEvent::data(&box()));
    // FIXME(361045): remove InspectorInstrumentation calls once DevTools Timeline migrates to tracing.
    InspectorInstrumentation::willScrollLayer(&box());

    const RenderLayerModelObject* paintInvalidationContainer = box().containerForPaintInvalidation();

    // Update the positions of our child layers (if needed as only fixed layers should be impacted by a scroll).
    // We don't update compositing layers, because we need to do a deep update from the compositing ancestor.
    if (!frameView->isInPerformLayout()) {
        // If we're in the middle of layout, we'll just update layers once layout has finished.
        layer()->clipper().clearClipRectsIncludingDescendants();
         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));
         // Update regions, scrolling may change the clip of a particular region.
         frameView->updateAnnotatedRegions();
//flaw_line_below:
        // FIXME: We shouldn't call updateWidgetPositions() here since it might tear down the render tree,
//flaw_line_below:
        // for now we just crash to avoid allowing an attacker to use after free.
//flaw_line_below:
        frameView->updateWidgetPositions();
//flaw_line_below:
        RELEASE_ASSERT(frameView->renderView());
//fix_flaw_line_below:
//        frameView->setNeedsUpdateWidgetPositions();
         updateCompositingLayersAfterScroll();
     }
 
    // The caret rect needs to be invalidated after scrolling
    frame->selection().setCaretRectNeedsUpdate();

    FloatQuad quadForFakeMouseMoveEvent = FloatQuad(layer()->renderer()->previousPaintInvalidationRect());

    quadForFakeMouseMoveEvent = paintInvalidationContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);
    frame->eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);

    bool requiresPaintInvalidation = true;

    if (!box().isMarquee() && box().view()->compositor()->inCompositingMode()) {
        // Hits in virtual/gpu/fast/canvas/canvas-scroll-path-into-view.html.
        DisableCompositingQueryAsserts disabler;
        bool onlyScrolledCompositedLayers = scrollsOverflow()
            && !layer()->hasVisibleNonLayerContent()
            && !layer()->hasNonCompositedChild()
            && !layer()->hasBlockSelectionGapBounds()
            && box().style()->backgroundLayers().attachment() != LocalBackgroundAttachment;

        if (usesCompositedScrolling() || onlyScrolledCompositedLayers)
            requiresPaintInvalidation = false;
    }

    // Just schedule a full paint invalidation of our object.
    if (requiresPaintInvalidation) {
        if (box().frameView()->isInPerformLayout())
            box().setShouldDoFullPaintInvalidation(true);
        else
            box().invalidatePaintUsingContainer(paintInvalidationContainer, layer()->renderer()->previousPaintInvalidationRect(), InvalidationScroll);
    }

    // Schedule the scroll DOM event.
    if (box().node())
        box().node()->document().enqueueScrollEventForNode(box().node());

    if (AXObjectCache* cache = box().document().existingAXObjectCache())
        cache->handleScrollPositionChanged(&box());

    InspectorInstrumentation::didScrollLayer(&box());
}
",185340,"void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)
{
    if (!box().isMarquee()) {
        if (m_scrollDimensionsDirty)
            computeScrollDimensions();
    }

    if (scrollOffset() == toIntSize(newScrollOffset))
        return;

    setScrollOffset(toIntSize(newScrollOffset));

    LocalFrame* frame = box().frame();
    ASSERT(frame);

    RefPtr<FrameView> frameView = box().frameView();

    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""ScrollLayer"", ""data"", InspectorScrollLayerEvent::data(&box()));
    InspectorInstrumentation::willScrollLayer(&box());

    const RenderLayerModelObject* paintInvalidationContainer = box().containerForPaintInvalidation();

    if (!frameView->isInPerformLayout()) {
        layer()->clipper().clearClipRectsIncludingDescendants();
         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));
         frameView->updateAnnotatedRegions();
        frameView->updateWidgetPositions();
        RELEASE_ASSERT(frameView->renderView());
         updateCompositingLayersAfterScroll();
     }
 
    frame->selection().setCaretRectNeedsUpdate();

    FloatQuad quadForFakeMouseMoveEvent = FloatQuad(layer()->renderer()->previousPaintInvalidationRect());

    quadForFakeMouseMoveEvent = paintInvalidationContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);
    frame->eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);

    bool requiresPaintInvalidation = true;

    if (!box().isMarquee() && box().view()->compositor()->inCompositingMode()) {
        DisableCompositingQueryAsserts disabler;
        bool onlyScrolledCompositedLayers = scrollsOverflow()
            && !layer()->hasVisibleNonLayerContent()
            && !layer()->hasNonCompositedChild()
            && !layer()->hasBlockSelectionGapBounds()
            && box().style()->backgroundLayers().attachment() != LocalBackgroundAttachment;

        if (usesCompositedScrolling() || onlyScrolledCompositedLayers)
            requiresPaintInvalidation = false;
    }

    if (requiresPaintInvalidation) {
        if (box().frameView()->isInPerformLayout())
            box().setShouldDoFullPaintInvalidation(true);
        else
            box().invalidatePaintUsingContainer(paintInvalidationContainer, layer()->renderer()->previousPaintInvalidationRect(), InvalidationScroll);
    }

    if (box().node())
        box().node()->document().enqueueScrollEventForNode(box().node());

    if (AXObjectCache* cache = box().document().existingAXObjectCache())
        cache->handleScrollPositionChanged(&box());

    InspectorInstrumentation::didScrollLayer(&box());
}
","void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)
{
    if (!box().isMarquee()) {
        if (m_scrollDimensionsDirty)
            computeScrollDimensions();
    }

    if (scrollOffset() == toIntSize(newScrollOffset))
        return;

    setScrollOffset(toIntSize(newScrollOffset));

    LocalFrame* frame = box().frame();
    ASSERT(frame);

    RefPtr<FrameView> frameView = box().frameView();

    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""), ""ScrollLayer"", ""data"", InspectorScrollLayerEvent::data(&box()));
    InspectorInstrumentation::willScrollLayer(&box());

    const RenderLayerModelObject* paintInvalidationContainer = box().containerForPaintInvalidation();

    if (!frameView->isInPerformLayout()) {
        layer()->clipper().clearClipRectsIncludingDescendants();
         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));
         frameView->updateAnnotatedRegions();
        frameView->setNeedsUpdateWidgetPositions();
         updateCompositingLayersAfterScroll();
     }
 
    frame->selection().setCaretRectNeedsUpdate();

    FloatQuad quadForFakeMouseMoveEvent = FloatQuad(layer()->renderer()->previousPaintInvalidationRect());

    quadForFakeMouseMoveEvent = paintInvalidationContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);
    frame->eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);

    bool requiresPaintInvalidation = true;

    if (!box().isMarquee() && box().view()->compositor()->inCompositingMode()) {
        DisableCompositingQueryAsserts disabler;
        bool onlyScrolledCompositedLayers = scrollsOverflow()
            && !layer()->hasVisibleNonLayerContent()
            && !layer()->hasNonCompositedChild()
            && !layer()->hasBlockSelectionGapBounds()
            && box().style()->backgroundLayers().attachment() != LocalBackgroundAttachment;

        if (usesCompositedScrolling() || onlyScrolledCompositedLayers)
            requiresPaintInvalidation = false;
    }

    if (requiresPaintInvalidation) {
        if (box().frameView()->isInPerformLayout())
            box().setShouldDoFullPaintInvalidation(true);
        else
            box().invalidatePaintUsingContainer(paintInvalidationContainer, layer()->renderer()->previousPaintInvalidationRect(), InvalidationScroll);
    }

    if (box().node())
        box().node()->document().enqueueScrollEventForNode(box().node());

    if (AXObjectCache* cache = box().document().existingAXObjectCache())
        cache->handleScrollPositionChanged(&box());

    InspectorInstrumentation::didScrollLayer(&box());
}
","The `setScrollOffset` function updates the scroll position of a scrollable area in a rendering layer, ensuring that the scroll dimensions are computed if they are marked as dirty. It checks if the new scroll offset differs from the current one before proceeding. The function manages paint invalidation and updates the layout if necessary, dispatching a fake mouse move event to simulate user interaction. It also handles accessibility updates and may trigger a full paint invalidation based on the compositing state and scrolling conditions. Finally, it logs the scrolling event for instrumentation purposes, ensuring proper tracking of user interactions.","The function updates the scroll position of a rendering layer while ensuring that the necessary dimensions are recalculated if they are outdated. It checks for changes in the scroll offset before proceeding with updates, managing paint invalidation and layout adjustments as needed. The function simulates user interaction by dispatching a fake mouse move event and handles accessibility updates related to the scroll position. It determines whether a full paint invalidation is required based on the compositing state and scrolling conditions, while also logging the scrolling event for tracking purposes, ensuring a responsive and accurate rendering experience.","The vulnerability in the original code stemmed from the call to `updateWidgetPositions()` within the `RenderLayerScrollableArea`, which could potentially destroy the render tree, leading to use-after-free bugs. This risk arose because the function was executed while still within the context of the rendering layer, where the state of the objects could change unexpectedly. The fix involved deferring the call to `updateWidgetPositions()` to ensure it is executed outside of the `RenderLayerScrollableArea`, thereby preventing any unintended destruction of objects that could result in accessing invalid memory and ensuring safer memory management during rendering operations.","The vulnerability in the original code arose from a function call that could potentially destroy the render tree while still operating within a specific rendering context, leading to use-after-free issues. This situation created a risk of accessing invalid memory, as the state of objects could change unexpectedly during execution. The fix involved deferring this function call to ensure it occurs outside the rendering context, thereby preventing any unintended destruction of objects. This change enhances memory safety by ensuring that the rendering operations do not interfere with the integrity of the object lifecycle, mitigating the risk of accessing freed memory.","The vulnerability was fixed by moving the call to `updateWidgetPositions()` outside of the `RenderLayerScrollableArea`. In the original code, this function was executed while still within the rendering context, which could lead to the destruction of the render tree and potential use-after-free bugs. By deferring this call, the updated code ensures that the rendering operations complete before any modifications to the widget positions occur, thus maintaining the integrity of the object lifecycle. This change effectively mitigates the risk of accessing invalid memory, enhancing overall memory safety during rendering processes.","The vulnerability was addressed by relocating a critical function call that could disrupt the rendering context, which previously posed a risk of memory access issues. By deferring this call to occur outside the specific rendering area, the updated code ensures that the rendering operations are completed before any changes to the widget positions are made. This adjustment prevents the potential destruction of objects while they are still in use, thereby safeguarding against accessing invalid memory. Overall, this change enhances memory safety and stability during rendering processes, effectively mitigating the risk of use-after-free errors.","CWE-416,CWE-825,CWE-672,CWE-415,CWE-562,CWE-119,CWE-125,CWE-754,CWE-666,CWE-404",Y,1
70,70,185959,185959,,Remote,Not required,Partial,CVE-2016-5170,https://www.cvedetails.com/cve/CVE-2016-5170/,CWE-416,Medium,Partial,Partial,,2016-09-25,6.8,"WebKit/Source/bindings/modules/v8/V8BindingForModules.cpp in Blink, as used in Google Chrome before 53.0.2785.113, does not properly consider getter side effects during array key conversion, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted Indexed Database (aka IndexedDB) API calls.",2018-01-04,DoS ,20,https://github.com/chromium/chromium/commit/c3957448cfc6e299165196a33cd954b790875fdb,c3957448cfc6e299165196a33cd954b790875fdb,"Cleanup and remove dead code in SetFocusedElement

This early-out was added in:

https://crrev.com/ce8ea3446283965c7eabab592cbffe223b1cf2bc

Back then, we applied fragment focus in LayoutUpdated() which could
cause this issue. This got cleaned up in:

https://crrev.com/45236fd563e9df53dc45579be1f3d0b4784885a2

so that focus is no longer applied after layout.

+Cleanup: Goto considered harmful

Bug: 795381
Change-Id: Ifeb4d2e03e872fd48cca6720b1d4de36ad1ecbb7
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1524417
Commit-Queue: David Bokan <bokan@chromium.org>
Reviewed-by: Stefan Zager <szager@chromium.org>
Cr-Commit-Position: refs/heads/master@{#641101}",15,third_party/blink/renderer/core/dom/document.cc,"{""sha"": ""b8cbfdeaf170bccecb7699477657284b11dddae9"", ""filename"": ""third_party/blink/renderer/core/dom/document.cc"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 18, ""changes"": 38, ""blob_url"": ""https://github.com/chromium/chromium/blob/c3957448cfc6e299165196a33cd954b790875fdb/third_party/blink/renderer/core/dom/document.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c3957448cfc6e299165196a33cd954b790875fdb/third_party/blink/renderer/core/dom/document.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/dom/document.cc?ref=c3957448cfc6e299165196a33cd954b790875fdb"", ""patch"": ""@@ -4657,8 +4657,10 @@ bool Document::SetFocusedElement(Element* new_focused_element,\n     if (IsRootEditableElement(*new_focused_element) &&\n         !AcceptsEditingFocus(*new_focused_element)) {\n       // delegate blocks focus change\n-      focus_change_blocked = true;\n-      goto SetFocusedElementDone;\n+      UpdateStyleAndLayoutTree();\n+      if (LocalFrame* frame = GetFrame())\n+        frame->Selection().DidChangeFocus();\n+      return false;\n     }\n     // Set focus on the new node\n     focused_element_ = new_focused_element;\n@@ -4673,18 +4675,13 @@ bool Document::SetFocusedElement(Element* new_focused_element,\n \n     // Element::setFocused for frames can dispatch events.\n     if (focused_element_ != new_focused_element) {\n-      focus_change_blocked = true;\n-      goto SetFocusedElementDone;\n+      UpdateStyleAndLayoutTree();\n+      if (LocalFrame* frame = GetFrame())\n+        frame->Selection().DidChangeFocus();\n+      return false;\n     }\n     CancelFocusAppearanceUpdate();\n     EnsurePaintLocationDataValidForNode(focused_element_);\n-    // UpdateStyleAndLayout can call SetFocusedElement (through\n-    // InvokeFragmentAnchor called in Document::LayoutUpdated) and clear\n-    // focused_element_.\n-    if (focused_element_ != new_focused_element) {\n-      focus_change_blocked = true;\n-      goto SetFocusedElementDone;\n-    }\n     focused_element_->UpdateFocusAppearanceWithOptions(\n         params.selection_behavior, params.options);\n \n@@ -4698,8 +4695,10 @@ bool Document::SetFocusedElement(Element* new_focused_element,\n \n       if (focused_element_ != new_focused_element) {\n         // handler shifted focus\n-        focus_change_blocked = true;\n-        goto SetFocusedElementDone;\n+        UpdateStyleAndLayoutTree();\n+        if (LocalFrame* frame = GetFrame())\n+          frame->Selection().DidChangeFocus();\n+        return false;\n       }\n       // DOM level 3 bubbling focus event.\n       focused_element_->DispatchFocusInEvent(event_type_names::kFocusin,\n@@ -4708,8 +4707,10 @@ bool Document::SetFocusedElement(Element* new_focused_element,\n \n       if (focused_element_ != new_focused_element) {\n         // handler shifted focus\n-        focus_change_blocked = true;\n-        goto SetFocusedElementDone;\n+        UpdateStyleAndLayoutTree();\n+        if (LocalFrame* frame = GetFrame())\n+          frame->Selection().DidChangeFocus();\n+        return false;\n       }\n \n       // For DOM level 2 compatibility.\n@@ -4721,8 +4722,10 @@ bool Document::SetFocusedElement(Element* new_focused_element,\n \n       if (focused_element_ != new_focused_element) {\n         // handler shifted focus\n-        focus_change_blocked = true;\n-        goto SetFocusedElementDone;\n+        UpdateStyleAndLayoutTree();\n+        if (LocalFrame* frame = GetFrame())\n+          frame->Selection().DidChangeFocus();\n+        return false;\n       }\n     }\n   }\n@@ -4741,7 +4744,6 @@ bool Document::SetFocusedElement(Element* new_focused_element,\n                                                     focused_element_.Get());\n   }\n \n-SetFocusedElementDone:\n   UpdateStyleAndLayoutTree();\n   if (LocalFrame* frame = GetFrame())\n     frame->Selection().DidChangeFocus();""}","bool Document::SetFocusedElement(Element* new_focused_element,
                                 const FocusParams& params) {
  DCHECK(!lifecycle_.InDetach());

  clear_focused_element_timer_.Stop();

  if (new_focused_element && (new_focused_element->GetDocument() != this))
    return true;

  if (NodeChildRemovalTracker::IsBeingRemoved(new_focused_element))
    return true;

  if (focused_element_ == new_focused_element)
    return true;

  bool focus_change_blocked = false;
  Element* old_focused_element = focused_element_;
  focused_element_ = nullptr;

  UpdateDistributionForFlatTreeTraversal();
  Node* ancestor = (old_focused_element && old_focused_element->isConnected() &&
                    new_focused_element)
                       ? FlatTreeTraversal::CommonAncestor(*old_focused_element,
                                                           *new_focused_element)
                       : nullptr;

  if (old_focused_element) {
    old_focused_element->SetFocused(false, params.type);
    old_focused_element->SetHasFocusWithinUpToAncestor(false, ancestor);

    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      old_focused_element->DispatchBlurEvent(new_focused_element, params.type,
                                             params.source_capabilities);
      if (focused_element_) {
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }

      old_focused_element->DispatchFocusOutEvent(event_type_names::kFocusout,
                                                 new_focused_element,
                                                 params.source_capabilities);
      old_focused_element->DispatchFocusOutEvent(event_type_names::kDOMFocusOut,
                                                 new_focused_element,
                                                 params.source_capabilities);

      if (focused_element_) {
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }
    }
  }

  if (new_focused_element)
    UpdateStyleAndLayoutTreeForNode(new_focused_element);
  if (new_focused_element && new_focused_element->IsFocusable()) {
     if (IsRootEditableElement(*new_focused_element) &&
         !AcceptsEditingFocus(*new_focused_element)) {
      UpdateStyleAndLayoutTree();
      if (LocalFrame* frame = GetFrame())
        frame->Selection().DidChangeFocus();
      return false;
     }
     focused_element_ = new_focused_element;
    SetSequentialFocusNavigationStartingPoint(focused_element_.Get());

    if (params.type != kWebFocusTypeNone)
      last_focus_type_ = params.type;

    focused_element_->SetFocused(true, params.type);
    focused_element_->SetHasFocusWithinUpToAncestor(true, ancestor);
 
     if (focused_element_ != new_focused_element) {
      UpdateStyleAndLayoutTree();
      if (LocalFrame* frame = GetFrame())
        frame->Selection().DidChangeFocus();
      return false;
     }
     CancelFocusAppearanceUpdate();
     EnsurePaintLocationDataValidForNode(focused_element_);
     focused_element_->UpdateFocusAppearanceWithOptions(
         params.selection_behavior, params.options);
 
    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      focused_element_->DispatchFocusEvent(old_focused_element, params.type,
                                           params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
       }
       focused_element_->DispatchFocusInEvent(event_type_names::kFocusin,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
       }
 
      focused_element_->DispatchFocusInEvent(event_type_names::kDOMFocusIn,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
       }
     }
   }

  if (!focus_change_blocked && focused_element_) {
    if (AXObjectCache* cache = ExistingAXObjectCache()) {
      cache->HandleFocusedUIElementChanged(old_focused_element,
                                           new_focused_element);
    }
  }

  if (!focus_change_blocked && GetPage()) {
    GetPage()->GetChromeClient().FocusedNodeChanged(old_focused_element,
                                                     focused_element_.Get());
   }
 
   UpdateStyleAndLayoutTree();
   if (LocalFrame* frame = GetFrame())
     frame->Selection().DidChangeFocus();
  return !focus_change_blocked;
}
","bool Document::SetFocusedElement(Element* new_focused_element,
                                 const FocusParams& params) {
  DCHECK(!lifecycle_.InDetach());

  clear_focused_element_timer_.Stop();

  if (new_focused_element && (new_focused_element->GetDocument() != this))
    return true;

  if (NodeChildRemovalTracker::IsBeingRemoved(new_focused_element))
    return true;

  if (focused_element_ == new_focused_element)
    return true;

  bool focus_change_blocked = false;
  Element* old_focused_element = focused_element_;
  focused_element_ = nullptr;

  UpdateDistributionForFlatTreeTraversal();
  Node* ancestor = (old_focused_element && old_focused_element->isConnected() &&
                    new_focused_element)
                       ? FlatTreeTraversal::CommonAncestor(*old_focused_element,
                                                           *new_focused_element)
                       : nullptr;

  if (old_focused_element) {
    old_focused_element->SetFocused(false, params.type);
    old_focused_element->SetHasFocusWithinUpToAncestor(false, ancestor);

    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      old_focused_element->DispatchBlurEvent(new_focused_element, params.type,
                                             params.source_capabilities);
      if (focused_element_) {
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }

      old_focused_element->DispatchFocusOutEvent(event_type_names::kFocusout,
                                                 new_focused_element,
                                                 params.source_capabilities);
      old_focused_element->DispatchFocusOutEvent(event_type_names::kDOMFocusOut,
                                                 new_focused_element,
                                                 params.source_capabilities);

      if (focused_element_) {
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }
    }
  }

  if (new_focused_element)
    UpdateStyleAndLayoutTreeForNode(new_focused_element);
  if (new_focused_element && new_focused_element->IsFocusable()) {
     if (IsRootEditableElement(*new_focused_element) &&
         !AcceptsEditingFocus(*new_focused_element)) {
      focus_change_blocked = true;
      goto SetFocusedElementDone;
     }
     focused_element_ = new_focused_element;
    SetSequentialFocusNavigationStartingPoint(focused_element_.Get());

    if (params.type != kWebFocusTypeNone)
      last_focus_type_ = params.type;

    focused_element_->SetFocused(true, params.type);
    focused_element_->SetHasFocusWithinUpToAncestor(true, ancestor);
 
     if (focused_element_ != new_focused_element) {
      focus_change_blocked = true;
      goto SetFocusedElementDone;
     }
     CancelFocusAppearanceUpdate();
     EnsurePaintLocationDataValidForNode(focused_element_);
    if (focused_element_ != new_focused_element) {
      focus_change_blocked = true;
      goto SetFocusedElementDone;
    }
     focused_element_->UpdateFocusAppearanceWithOptions(
         params.selection_behavior, params.options);
 
    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      focused_element_->DispatchFocusEvent(old_focused_element, params.type,
                                           params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        focus_change_blocked = true;
        goto SetFocusedElementDone;
       }
       focused_element_->DispatchFocusInEvent(event_type_names::kFocusin,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        focus_change_blocked = true;
        goto SetFocusedElementDone;
       }
 
      focused_element_->DispatchFocusInEvent(event_type_names::kDOMFocusIn,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        focus_change_blocked = true;
        goto SetFocusedElementDone;
       }
     }
   }

  if (!focus_change_blocked && focused_element_) {
    if (AXObjectCache* cache = ExistingAXObjectCache()) {
      cache->HandleFocusedUIElementChanged(old_focused_element,
                                           new_focused_element);
    }
  }

  if (!focus_change_blocked && GetPage()) {
    GetPage()->GetChromeClient().FocusedNodeChanged(old_focused_element,
                                                     focused_element_.Get());
   }
 
SetFocusedElementDone:
   UpdateStyleAndLayoutTree();
   if (LocalFrame* frame = GetFrame())
     frame->Selection().DidChangeFocus();
  return !focus_change_blocked;
}
",C,"      UpdateStyleAndLayoutTree();
      if (LocalFrame* frame = GetFrame())
        frame->Selection().DidChangeFocus();
      return false;
      UpdateStyleAndLayoutTree();
      if (LocalFrame* frame = GetFrame())
        frame->Selection().DidChangeFocus();
      return false;
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
","      focus_change_blocked = true;
      goto SetFocusedElementDone;
      focus_change_blocked = true;
      goto SetFocusedElementDone;
    if (focused_element_ != new_focused_element) {
      focus_change_blocked = true;
      goto SetFocusedElementDone;
    }
        focus_change_blocked = true;
        goto SetFocusedElementDone;
        focus_change_blocked = true;
        goto SetFocusedElementDone;
        focus_change_blocked = true;
        goto SetFocusedElementDone;
SetFocusedElementDone:
",,"@@ -4657,8 +4657,10 @@ bool Document::SetFocusedElement(Element* new_focused_element,
     if (IsRootEditableElement(*new_focused_element) &&
         !AcceptsEditingFocus(*new_focused_element)) {
       // delegate blocks focus change
-      focus_change_blocked = true;
-      goto SetFocusedElementDone;
+      UpdateStyleAndLayoutTree();
+      if (LocalFrame* frame = GetFrame())
+        frame->Selection().DidChangeFocus();
+      return false;
     }
     // Set focus on the new node
     focused_element_ = new_focused_element;
@@ -4673,18 +4675,13 @@ bool Document::SetFocusedElement(Element* new_focused_element,
 
     // Element::setFocused for frames can dispatch events.
     if (focused_element_ != new_focused_element) {
-      focus_change_blocked = true;
-      goto SetFocusedElementDone;
+      UpdateStyleAndLayoutTree();
+      if (LocalFrame* frame = GetFrame())
+        frame->Selection().DidChangeFocus();
+      return false;
     }
     CancelFocusAppearanceUpdate();
     EnsurePaintLocationDataValidForNode(focused_element_);
-    // UpdateStyleAndLayout can call SetFocusedElement (through
-    // InvokeFragmentAnchor called in Document::LayoutUpdated) and clear
-    // focused_element_.
-    if (focused_element_ != new_focused_element) {
-      focus_change_blocked = true;
-      goto SetFocusedElementDone;
-    }
     focused_element_->UpdateFocusAppearanceWithOptions(
         params.selection_behavior, params.options);
 
@@ -4698,8 +4695,10 @@ bool Document::SetFocusedElement(Element* new_focused_element,
 
       if (focused_element_ != new_focused_element) {
         // handler shifted focus
-        focus_change_blocked = true;
-        goto SetFocusedElementDone;
+        UpdateStyleAndLayoutTree();
+        if (LocalFrame* frame = GetFrame())
+          frame->Selection().DidChangeFocus();
+        return false;
       }
       // DOM level 3 bubbling focus event.
       focused_element_->DispatchFocusInEvent(event_type_names::kFocusin,
@@ -4708,8 +4707,10 @@ bool Document::SetFocusedElement(Element* new_focused_element,
 
       if (focused_element_ != new_focused_element) {
         // handler shifted focus
-        focus_change_blocked = true;
-        goto SetFocusedElementDone;
+        UpdateStyleAndLayoutTree();
+        if (LocalFrame* frame = GetFrame())
+          frame->Selection().DidChangeFocus();
+        return false;
       }
 
       // For DOM level 2 compatibility.
@@ -4721,8 +4722,10 @@ bool Document::SetFocusedElement(Element* new_focused_element,
 
       if (focused_element_ != new_focused_element) {
         // handler shifted focus
-        focus_change_blocked = true;
-        goto SetFocusedElementDone;
+        UpdateStyleAndLayoutTree();
+        if (LocalFrame* frame = GetFrame())
+          frame->Selection().DidChangeFocus();
+        return false;
       }
     }
   }
@@ -4741,7 +4744,6 @@ bool Document::SetFocusedElement(Element* new_focused_element,
                                                     focused_element_.Get());
   }
 
-SetFocusedElementDone:
   UpdateStyleAndLayoutTree();
   if (LocalFrame* frame = GetFrame())
     frame->Selection().DidChangeFocus();",Chrome,c3957448cfc6e299165196a33cd954b790875fdb,ded259df83e1e4bac3b20f8f28a7e21a7d88e752,1,"bool Document::SetFocusedElement(Element* new_focused_element,
                                 const FocusParams& params) {
  DCHECK(!lifecycle_.InDetach());

  clear_focused_element_timer_.Stop();

  // Make sure newFocusedNode is actually in this document
  if (new_focused_element && (new_focused_element->GetDocument() != this))
    return true;

  if (NodeChildRemovalTracker::IsBeingRemoved(new_focused_element))
    return true;

  if (focused_element_ == new_focused_element)
    return true;

  bool focus_change_blocked = false;
  Element* old_focused_element = focused_element_;
  focused_element_ = nullptr;

  UpdateDistributionForFlatTreeTraversal();
  Node* ancestor = (old_focused_element && old_focused_element->isConnected() &&
                    new_focused_element)
                       ? FlatTreeTraversal::CommonAncestor(*old_focused_element,
                                                           *new_focused_element)
                       : nullptr;

  // Remove focus from the existing focus node (if any)
  if (old_focused_element) {
    old_focused_element->SetFocused(false, params.type);
    old_focused_element->SetHasFocusWithinUpToAncestor(false, ancestor);

    // Dispatch the blur event and let the node do any other blur related
    // activities (important for text fields)
    // If page lost focus, blur event will have already been dispatched
    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      old_focused_element->DispatchBlurEvent(new_focused_element, params.type,
                                             params.source_capabilities);
      if (focused_element_) {
        // handler shifted focus
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }

      // 'focusout' is a DOM level 3 name for the bubbling blur event.
      old_focused_element->DispatchFocusOutEvent(event_type_names::kFocusout,
                                                 new_focused_element,
                                                 params.source_capabilities);
      // 'DOMFocusOut' is a DOM level 2 name for compatibility.
      // FIXME: We should remove firing DOMFocusOutEvent event when we are sure
      // no content depends on it, probably when <rdar://problem/8503958> is
      // resolved.
      old_focused_element->DispatchFocusOutEvent(event_type_names::kDOMFocusOut,
                                                 new_focused_element,
                                                 params.source_capabilities);

      if (focused_element_) {
        // handler shifted focus
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }
    }
  }

  if (new_focused_element)
    UpdateStyleAndLayoutTreeForNode(new_focused_element);
  if (new_focused_element && new_focused_element->IsFocusable()) {
     if (IsRootEditableElement(*new_focused_element) &&
         !AcceptsEditingFocus(*new_focused_element)) {
       // delegate blocks focus change
//flaw_line_below:
      focus_change_blocked = true;
//flaw_line_below:
      goto SetFocusedElementDone;
//fix_flaw_line_below:
//      UpdateStyleAndLayoutTree();
//fix_flaw_line_below:
//      if (LocalFrame* frame = GetFrame())
//fix_flaw_line_below:
//        frame->Selection().DidChangeFocus();
//fix_flaw_line_below:
//      return false;
     }
     // Set focus on the new node
     focused_element_ = new_focused_element;
    SetSequentialFocusNavigationStartingPoint(focused_element_.Get());

    // Keep track of last focus from user interaction, ignoring focus from code.
    if (params.type != kWebFocusTypeNone)
      last_focus_type_ = params.type;

    focused_element_->SetFocused(true, params.type);
    focused_element_->SetHasFocusWithinUpToAncestor(true, ancestor);
 
     // Element::setFocused for frames can dispatch events.
     if (focused_element_ != new_focused_element) {
//flaw_line_below:
      focus_change_blocked = true;
//flaw_line_below:
      goto SetFocusedElementDone;
//fix_flaw_line_below:
//      UpdateStyleAndLayoutTree();
//fix_flaw_line_below:
//      if (LocalFrame* frame = GetFrame())
//fix_flaw_line_below:
//        frame->Selection().DidChangeFocus();
//fix_flaw_line_below:
//      return false;
     }
     CancelFocusAppearanceUpdate();
     EnsurePaintLocationDataValidForNode(focused_element_);
//flaw_line_below:
    // UpdateStyleAndLayout can call SetFocusedElement (through
//flaw_line_below:
    // InvokeFragmentAnchor called in Document::LayoutUpdated) and clear
//flaw_line_below:
    // focused_element_.
//flaw_line_below:
    if (focused_element_ != new_focused_element) {
//flaw_line_below:
      focus_change_blocked = true;
//flaw_line_below:
      goto SetFocusedElementDone;
//flaw_line_below:
    }
     focused_element_->UpdateFocusAppearanceWithOptions(
         params.selection_behavior, params.options);
 
    // Dispatch the focus event and let the node do any other focus related
    // activities (important for text fields)
    // If page lost focus, event will be dispatched on page focus, don't
    // duplicate
    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      focused_element_->DispatchFocusEvent(old_focused_element, params.type,
                                           params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
         // handler shifted focus
//flaw_line_below:
        focus_change_blocked = true;
//flaw_line_below:
        goto SetFocusedElementDone;
//fix_flaw_line_below:
//        UpdateStyleAndLayoutTree();
//fix_flaw_line_below:
//        if (LocalFrame* frame = GetFrame())
//fix_flaw_line_below:
//          frame->Selection().DidChangeFocus();
//fix_flaw_line_below:
//        return false;
       }
       // DOM level 3 bubbling focus event.
       focused_element_->DispatchFocusInEvent(event_type_names::kFocusin,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
         // handler shifted focus
//flaw_line_below:
        focus_change_blocked = true;
//flaw_line_below:
        goto SetFocusedElementDone;
//fix_flaw_line_below:
//        UpdateStyleAndLayoutTree();
//fix_flaw_line_below:
//        if (LocalFrame* frame = GetFrame())
//fix_flaw_line_below:
//          frame->Selection().DidChangeFocus();
//fix_flaw_line_below:
//        return false;
       }
 
       // For DOM level 2 compatibility.
      // FIXME: We should remove firing DOMFocusInEvent event when we are sure
      // no content depends on it, probably when <rdar://problem/8503958> is m.
      focused_element_->DispatchFocusInEvent(event_type_names::kDOMFocusIn,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
         // handler shifted focus
//flaw_line_below:
        focus_change_blocked = true;
//flaw_line_below:
        goto SetFocusedElementDone;
//fix_flaw_line_below:
//        UpdateStyleAndLayoutTree();
//fix_flaw_line_below:
//        if (LocalFrame* frame = GetFrame())
//fix_flaw_line_below:
//          frame->Selection().DidChangeFocus();
//fix_flaw_line_below:
//        return false;
       }
     }
   }

  if (!focus_change_blocked && focused_element_) {
    // Create the AXObject cache in a focus change because Chromium relies on
    // it.
    if (AXObjectCache* cache = ExistingAXObjectCache()) {
      cache->HandleFocusedUIElementChanged(old_focused_element,
                                           new_focused_element);
    }
  }

  if (!focus_change_blocked && GetPage()) {
    GetPage()->GetChromeClient().FocusedNodeChanged(old_focused_element,
                                                     focused_element_.Get());
   }
 
//flaw_line_below:
SetFocusedElementDone:
   UpdateStyleAndLayoutTree();
   if (LocalFrame* frame = GetFrame())
     frame->Selection().DidChangeFocus();
  return !focus_change_blocked;
}
",185959,"bool Document::SetFocusedElement(Element* new_focused_element,
                                 const FocusParams& params) {
  DCHECK(!lifecycle_.InDetach());

  clear_focused_element_timer_.Stop();

  if (new_focused_element && (new_focused_element->GetDocument() != this))
    return true;

  if (NodeChildRemovalTracker::IsBeingRemoved(new_focused_element))
    return true;

  if (focused_element_ == new_focused_element)
    return true;

  bool focus_change_blocked = false;
  Element* old_focused_element = focused_element_;
  focused_element_ = nullptr;

  UpdateDistributionForFlatTreeTraversal();
  Node* ancestor = (old_focused_element && old_focused_element->isConnected() &&
                    new_focused_element)
                       ? FlatTreeTraversal::CommonAncestor(*old_focused_element,
                                                           *new_focused_element)
                       : nullptr;

  if (old_focused_element) {
    old_focused_element->SetFocused(false, params.type);
    old_focused_element->SetHasFocusWithinUpToAncestor(false, ancestor);

    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      old_focused_element->DispatchBlurEvent(new_focused_element, params.type,
                                             params.source_capabilities);
      if (focused_element_) {
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }

      old_focused_element->DispatchFocusOutEvent(event_type_names::kFocusout,
                                                 new_focused_element,
                                                 params.source_capabilities);
      old_focused_element->DispatchFocusOutEvent(event_type_names::kDOMFocusOut,
                                                 new_focused_element,
                                                 params.source_capabilities);

      if (focused_element_) {
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }
    }
  }

  if (new_focused_element)
    UpdateStyleAndLayoutTreeForNode(new_focused_element);
  if (new_focused_element && new_focused_element->IsFocusable()) {
     if (IsRootEditableElement(*new_focused_element) &&
         !AcceptsEditingFocus(*new_focused_element)) {
      focus_change_blocked = true;
      goto SetFocusedElementDone;
     }
     focused_element_ = new_focused_element;
    SetSequentialFocusNavigationStartingPoint(focused_element_.Get());

    if (params.type != kWebFocusTypeNone)
      last_focus_type_ = params.type;

    focused_element_->SetFocused(true, params.type);
    focused_element_->SetHasFocusWithinUpToAncestor(true, ancestor);
 
     if (focused_element_ != new_focused_element) {
      focus_change_blocked = true;
      goto SetFocusedElementDone;
     }
     CancelFocusAppearanceUpdate();
     EnsurePaintLocationDataValidForNode(focused_element_);
    if (focused_element_ != new_focused_element) {
      focus_change_blocked = true;
      goto SetFocusedElementDone;
    }
     focused_element_->UpdateFocusAppearanceWithOptions(
         params.selection_behavior, params.options);
 
    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      focused_element_->DispatchFocusEvent(old_focused_element, params.type,
                                           params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        focus_change_blocked = true;
        goto SetFocusedElementDone;
       }
       focused_element_->DispatchFocusInEvent(event_type_names::kFocusin,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        focus_change_blocked = true;
        goto SetFocusedElementDone;
       }
 
      focused_element_->DispatchFocusInEvent(event_type_names::kDOMFocusIn,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        focus_change_blocked = true;
        goto SetFocusedElementDone;
       }
     }
   }

  if (!focus_change_blocked && focused_element_) {
    if (AXObjectCache* cache = ExistingAXObjectCache()) {
      cache->HandleFocusedUIElementChanged(old_focused_element,
                                           new_focused_element);
    }
  }

  if (!focus_change_blocked && GetPage()) {
    GetPage()->GetChromeClient().FocusedNodeChanged(old_focused_element,
                                                     focused_element_.Get());
   }
 
SetFocusedElementDone:
   UpdateStyleAndLayoutTree();
   if (LocalFrame* frame = GetFrame())
     frame->Selection().DidChangeFocus();
  return !focus_change_blocked;
}
","bool Document::SetFocusedElement(Element* new_focused_element,
                                 const FocusParams& params) {
  DCHECK(!lifecycle_.InDetach());

  clear_focused_element_timer_.Stop();

  if (new_focused_element && (new_focused_element->GetDocument() != this))
    return true;

  if (NodeChildRemovalTracker::IsBeingRemoved(new_focused_element))
    return true;

  if (focused_element_ == new_focused_element)
    return true;

  bool focus_change_blocked = false;
  Element* old_focused_element = focused_element_;
  focused_element_ = nullptr;

  UpdateDistributionForFlatTreeTraversal();
  Node* ancestor = (old_focused_element && old_focused_element->isConnected() &&
                    new_focused_element)
                       ? FlatTreeTraversal::CommonAncestor(*old_focused_element,
                                                           *new_focused_element)
                       : nullptr;

  if (old_focused_element) {
    old_focused_element->SetFocused(false, params.type);
    old_focused_element->SetHasFocusWithinUpToAncestor(false, ancestor);

    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      old_focused_element->DispatchBlurEvent(new_focused_element, params.type,
                                             params.source_capabilities);
      if (focused_element_) {
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }

      old_focused_element->DispatchFocusOutEvent(event_type_names::kFocusout,
                                                 new_focused_element,
                                                 params.source_capabilities);
      old_focused_element->DispatchFocusOutEvent(event_type_names::kDOMFocusOut,
                                                 new_focused_element,
                                                 params.source_capabilities);

      if (focused_element_) {
        focus_change_blocked = true;
        new_focused_element = nullptr;
      }
    }
  }

  if (new_focused_element)
    UpdateStyleAndLayoutTreeForNode(new_focused_element);
  if (new_focused_element && new_focused_element->IsFocusable()) {
     if (IsRootEditableElement(*new_focused_element) &&
         !AcceptsEditingFocus(*new_focused_element)) {
      UpdateStyleAndLayoutTree();
      if (LocalFrame* frame = GetFrame())
        frame->Selection().DidChangeFocus();
      return false;
     }
     focused_element_ = new_focused_element;
    SetSequentialFocusNavigationStartingPoint(focused_element_.Get());

    if (params.type != kWebFocusTypeNone)
      last_focus_type_ = params.type;

    focused_element_->SetFocused(true, params.type);
    focused_element_->SetHasFocusWithinUpToAncestor(true, ancestor);
 
     if (focused_element_ != new_focused_element) {
      UpdateStyleAndLayoutTree();
      if (LocalFrame* frame = GetFrame())
        frame->Selection().DidChangeFocus();
      return false;
     }
     CancelFocusAppearanceUpdate();
     EnsurePaintLocationDataValidForNode(focused_element_);
     focused_element_->UpdateFocusAppearanceWithOptions(
         params.selection_behavior, params.options);
 
    if (GetPage() && (GetPage()->GetFocusController().IsFocused())) {
      focused_element_->DispatchFocusEvent(old_focused_element, params.type,
                                           params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
       }
       focused_element_->DispatchFocusInEvent(event_type_names::kFocusin,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
       }
 
      focused_element_->DispatchFocusInEvent(event_type_names::kDOMFocusIn,
                                             old_focused_element, params.type,
                                             params.source_capabilities);
 
       if (focused_element_ != new_focused_element) {
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
       }
     }
   }

  if (!focus_change_blocked && focused_element_) {
    if (AXObjectCache* cache = ExistingAXObjectCache()) {
      cache->HandleFocusedUIElementChanged(old_focused_element,
                                           new_focused_element);
    }
  }

  if (!focus_change_blocked && GetPage()) {
    GetPage()->GetChromeClient().FocusedNodeChanged(old_focused_element,
                                                     focused_element_.Get());
   }
 
   UpdateStyleAndLayoutTree();
   if (LocalFrame* frame = GetFrame())
     frame->Selection().DidChangeFocus();
  return !focus_change_blocked;
}
","The `SetFocusedElement` function in the `Document` class manages the focus state of elements within a document. It first checks if the new element is valid and not part of a removal process. If the new element is the same as the currently focused one, it exits early. The function then updates the focus state of the old element, dispatches relevant blur and focus events, and checks if the new element is focusable. If focus can be changed, it updates the focused element, manages focus appearance, and notifies any accessibility caches or page clients about the focus change. Finally, it updates the layout and selection state before returning a success status.","The provided code manages the focus state of elements within a document, ensuring that focus transitions are handled correctly. It first verifies the validity of the new element and checks if it is being removed or is the same as the current focus. If a change is necessary, it updates the focus state of the previous element, dispatches appropriate events, and checks if the new element can receive focus. If focus is successfully changed, it updates the visual appearance and notifies relevant components about the change, while also ensuring the layout and selection state are refreshed before concluding the operation.","The vulnerability in the original code stemmed from an early exit condition that allowed focus to be applied incorrectly after layout updates, potentially leading to inconsistent focus states. Specifically, the checks for whether the new focused element was valid or being removed did not adequately prevent focus changes when the document's layout was still being processed. The fix involved removing unnecessary early-out conditions and ensuring that focus changes only occur when the layout is stable, thus preventing focus from being applied inappropriately. This cleanup improved the overall reliability of focus management within the document.","The vulnerability in the original code arose from an early exit condition that allowed focus changes to occur even when the document's layout was still being updated, potentially leading to inconsistent focus states. This issue was exacerbated by a previous implementation that applied focus during layout updates, which was later deemed problematic. The fix involved removing the unnecessary early-out checks and ensuring that focus changes only happen when the layout is stable, thereby preventing inappropriate focus application and enhancing the reliability of focus management within the document.","The vulnerability was fixed by removing the early-out conditions that allowed focus changes to occur during layout updates. Specifically, the checks for the new focused element's validity and removal status were adjusted to ensure that focus is only applied when the layout is stable. The code now ensures that focus changes are contingent upon the document's state, particularly by eliminating the application of focus in the `LayoutUpdated()` function. This change prevents the focus from being incorrectly set during ongoing layout processes, thereby enhancing the overall reliability of the focus management system.","The vulnerability was fixed by eliminating unnecessary early exit conditions that allowed focus changes to occur during unstable layout states. The revised code ensures that focus is only applied when the document's layout is fully updated and stable, preventing inconsistent focus behavior. By removing checks that previously permitted focus changes even when the layout was still processing, the fix enhances the reliability of focus management. This adjustment ensures that focus transitions are handled appropriately, thereby preventing potential issues related to incorrect focus application during layout updates.","CWE-754, CWE-705, CWE-666, CWE-436, CWE-404, CWE-371, CWE-364, CWE-362, CWE-339, CWE-333",N,-1
71,71,185973,185973,,Remote,Not required,Partial,CVE-2016-5156,https://www.cvedetails.com/cve/CVE-2016-5156/,CWE-416,Medium,Partial,Partial,,2016-09-11,6.8,"extensions/renderer/event_bindings.cc in the event bindings in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux attempts to process filtered events after failure to add an event matcher, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via unknown vectors.",2018-10-30,DoS ,7,https://github.com/chromium/chromium/commit/ba011d9f8322c62633a069a59c2c5525e3ff46cc,ba011d9f8322c62633a069a59c2c5525e3ff46cc,"Ignore filtered event if an event matcher cannot be added.

BUG=625404

Review-Url: https://codereview.chromium.org/2236133002
Cr-Commit-Position: refs/heads/master@{#411472}",1,extensions/renderer/event_bindings.cc,"{""sha"": ""db5fb60f428af90a3ce4ba3edcfee6a77b1a6729"", ""filename"": ""extensions/renderer/event_bindings.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 3, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/ba011d9f8322c62633a069a59c2c5525e3ff46cc/extensions/renderer/event_bindings.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ba011d9f8322c62633a069a59c2c5525e3ff46cc/extensions/renderer/event_bindings.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/renderer/event_bindings.cc?ref=ba011d9f8322c62633a069a59c2c5525e3ff46cc"", ""patch"": ""@@ -272,14 +272,18 @@ void EventBindings::AttachFilteredEvent(\n     filter = base::DictionaryValue::From(std::move(filter_value));\n   }\n \n-  // Hold onto a weak reference to |filter| so that it can be used after passing\n-  // ownership to |event_filter|.\n-  base::DictionaryValue* filter_weak = filter.get();\n   int id = g_event_filter.Get().AddEventMatcher(\n       event_name, ParseEventMatcher(std::move(filter)));\n+  if (id == -1) {\n+    args.GetReturnValue().Set(static_cast<int32_t>(-1));\n+    return;\n+  }\n   attached_matcher_ids_.insert(id);\n \n   // Only send IPCs the first time a filter gets added.\n+  const EventMatcher* matcher = g_event_filter.Get().GetEventMatcher(id);\n+  DCHECK(matcher);\n+  base::DictionaryValue* filter_weak = matcher->value();\n   std::string extension_id = context()->GetExtensionID();\n   if (AddFilter(event_name, extension_id, *filter_weak)) {\n     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());""}","void EventBindings::AttachFilteredEvent(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK_EQ(2, args.Length());
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsObject());

  std::string event_name = *v8::String::Utf8Value(args[0]);
  if (!context()->HasAccessOrThrowError(event_name))
    return;

  std::unique_ptr<base::DictionaryValue> filter;
  {
    std::unique_ptr<content::V8ValueConverter> converter(
        content::V8ValueConverter::create());
    std::unique_ptr<base::Value> filter_value(converter->FromV8Value(
        v8::Local<v8::Object>::Cast(args[1]), context()->v8_context()));
    if (!filter_value || !filter_value->IsType(base::Value::TYPE_DICTIONARY)) {
      args.GetReturnValue().Set(static_cast<int32_t>(-1));
      return;
    }
     filter = base::DictionaryValue::From(std::move(filter_value));
   }
 
   int id = g_event_filter.Get().AddEventMatcher(
       event_name, ParseEventMatcher(std::move(filter)));
  if (id == -1) {
    args.GetReturnValue().Set(static_cast<int32_t>(-1));
    return;
  }
   attached_matcher_ids_.insert(id);
 
  const EventMatcher* matcher = g_event_filter.Get().GetEventMatcher(id);
  DCHECK(matcher);
  base::DictionaryValue* filter_weak = matcher->value();
   std::string extension_id = context()->GetExtensionID();
   if (AddFilter(event_name, extension_id, *filter_weak)) {
     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());
    content::RenderThread::Get()->Send(new ExtensionHostMsg_AddFilteredListener(
        extension_id, event_name, *filter_weak, lazy));
  }

  args.GetReturnValue().Set(static_cast<int32_t>(id));
}
","void EventBindings::AttachFilteredEvent(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK_EQ(2, args.Length());
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsObject());

  std::string event_name = *v8::String::Utf8Value(args[0]);
  if (!context()->HasAccessOrThrowError(event_name))
    return;

  std::unique_ptr<base::DictionaryValue> filter;
  {
    std::unique_ptr<content::V8ValueConverter> converter(
        content::V8ValueConverter::create());
    std::unique_ptr<base::Value> filter_value(converter->FromV8Value(
        v8::Local<v8::Object>::Cast(args[1]), context()->v8_context()));
    if (!filter_value || !filter_value->IsType(base::Value::TYPE_DICTIONARY)) {
      args.GetReturnValue().Set(static_cast<int32_t>(-1));
      return;
    }
     filter = base::DictionaryValue::From(std::move(filter_value));
   }
 
  base::DictionaryValue* filter_weak = filter.get();
   int id = g_event_filter.Get().AddEventMatcher(
       event_name, ParseEventMatcher(std::move(filter)));
   attached_matcher_ids_.insert(id);
 
   std::string extension_id = context()->GetExtensionID();
   if (AddFilter(event_name, extension_id, *filter_weak)) {
     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());
    content::RenderThread::Get()->Send(new ExtensionHostMsg_AddFilteredListener(
        extension_id, event_name, *filter_weak, lazy));
  }

  args.GetReturnValue().Set(static_cast<int32_t>(id));
}
",C,"  if (id == -1) {
    args.GetReturnValue().Set(static_cast<int32_t>(-1));
    return;
  }
  const EventMatcher* matcher = g_event_filter.Get().GetEventMatcher(id);
  DCHECK(matcher);
  base::DictionaryValue* filter_weak = matcher->value();
","  base::DictionaryValue* filter_weak = filter.get();
",,"@@ -272,14 +272,18 @@ void EventBindings::AttachFilteredEvent(
     filter = base::DictionaryValue::From(std::move(filter_value));
   }
 
-  // Hold onto a weak reference to |filter| so that it can be used after passing
-  // ownership to |event_filter|.
-  base::DictionaryValue* filter_weak = filter.get();
   int id = g_event_filter.Get().AddEventMatcher(
       event_name, ParseEventMatcher(std::move(filter)));
+  if (id == -1) {
+    args.GetReturnValue().Set(static_cast<int32_t>(-1));
+    return;
+  }
   attached_matcher_ids_.insert(id);
 
   // Only send IPCs the first time a filter gets added.
+  const EventMatcher* matcher = g_event_filter.Get().GetEventMatcher(id);
+  DCHECK(matcher);
+  base::DictionaryValue* filter_weak = matcher->value();
   std::string extension_id = context()->GetExtensionID();
   if (AddFilter(event_name, extension_id, *filter_weak)) {
     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());",Chrome,ba011d9f8322c62633a069a59c2c5525e3ff46cc,17a812f225abd54e84dbe4f74c9619d4bdab3cbf,1,"void EventBindings::AttachFilteredEvent(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK_EQ(2, args.Length());
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsObject());

  std::string event_name = *v8::String::Utf8Value(args[0]);
  if (!context()->HasAccessOrThrowError(event_name))
    return;

  std::unique_ptr<base::DictionaryValue> filter;
  {
    std::unique_ptr<content::V8ValueConverter> converter(
        content::V8ValueConverter::create());
    std::unique_ptr<base::Value> filter_value(converter->FromV8Value(
        v8::Local<v8::Object>::Cast(args[1]), context()->v8_context()));
    if (!filter_value || !filter_value->IsType(base::Value::TYPE_DICTIONARY)) {
      args.GetReturnValue().Set(static_cast<int32_t>(-1));
      return;
    }
     filter = base::DictionaryValue::From(std::move(filter_value));
   }
 
//flaw_line_below:
  // Hold onto a weak reference to |filter| so that it can be used after passing
//flaw_line_below:
  // ownership to |event_filter|.
//flaw_line_below:
  base::DictionaryValue* filter_weak = filter.get();
   int id = g_event_filter.Get().AddEventMatcher(
       event_name, ParseEventMatcher(std::move(filter)));
//fix_flaw_line_below:
//  if (id == -1) {
//fix_flaw_line_below:
//    args.GetReturnValue().Set(static_cast<int32_t>(-1));
//fix_flaw_line_below:
//    return;
//fix_flaw_line_below:
//  }
   attached_matcher_ids_.insert(id);
 
   // Only send IPCs the first time a filter gets added.
//fix_flaw_line_below:
//  const EventMatcher* matcher = g_event_filter.Get().GetEventMatcher(id);
//fix_flaw_line_below:
//  DCHECK(matcher);
//fix_flaw_line_below:
//  base::DictionaryValue* filter_weak = matcher->value();
   std::string extension_id = context()->GetExtensionID();
   if (AddFilter(event_name, extension_id, *filter_weak)) {
     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());
    content::RenderThread::Get()->Send(new ExtensionHostMsg_AddFilteredListener(
        extension_id, event_name, *filter_weak, lazy));
  }

  args.GetReturnValue().Set(static_cast<int32_t>(id));
}
",185973,"void EventBindings::AttachFilteredEvent(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK_EQ(2, args.Length());
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsObject());

  std::string event_name = *v8::String::Utf8Value(args[0]);
  if (!context()->HasAccessOrThrowError(event_name))
    return;

  std::unique_ptr<base::DictionaryValue> filter;
  {
    std::unique_ptr<content::V8ValueConverter> converter(
        content::V8ValueConverter::create());
    std::unique_ptr<base::Value> filter_value(converter->FromV8Value(
        v8::Local<v8::Object>::Cast(args[1]), context()->v8_context()));
    if (!filter_value || !filter_value->IsType(base::Value::TYPE_DICTIONARY)) {
      args.GetReturnValue().Set(static_cast<int32_t>(-1));
      return;
    }
     filter = base::DictionaryValue::From(std::move(filter_value));
   }
 
  base::DictionaryValue* filter_weak = filter.get();
   int id = g_event_filter.Get().AddEventMatcher(
       event_name, ParseEventMatcher(std::move(filter)));
   attached_matcher_ids_.insert(id);
 
   std::string extension_id = context()->GetExtensionID();
   if (AddFilter(event_name, extension_id, *filter_weak)) {
     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());
    content::RenderThread::Get()->Send(new ExtensionHostMsg_AddFilteredListener(
        extension_id, event_name, *filter_weak, lazy));
  }

  args.GetReturnValue().Set(static_cast<int32_t>(id));
}
","void EventBindings::AttachFilteredEvent(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK_EQ(2, args.Length());
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsObject());

  std::string event_name = *v8::String::Utf8Value(args[0]);
  if (!context()->HasAccessOrThrowError(event_name))
    return;

  std::unique_ptr<base::DictionaryValue> filter;
  {
    std::unique_ptr<content::V8ValueConverter> converter(
        content::V8ValueConverter::create());
    std::unique_ptr<base::Value> filter_value(converter->FromV8Value(
        v8::Local<v8::Object>::Cast(args[1]), context()->v8_context()));
    if (!filter_value || !filter_value->IsType(base::Value::TYPE_DICTIONARY)) {
      args.GetReturnValue().Set(static_cast<int32_t>(-1));
      return;
    }
     filter = base::DictionaryValue::From(std::move(filter_value));
   }
 
   int id = g_event_filter.Get().AddEventMatcher(
       event_name, ParseEventMatcher(std::move(filter)));
  if (id == -1) {
    args.GetReturnValue().Set(static_cast<int32_t>(-1));
    return;
  }
   attached_matcher_ids_.insert(id);
 
  const EventMatcher* matcher = g_event_filter.Get().GetEventMatcher(id);
  DCHECK(matcher);
  base::DictionaryValue* filter_weak = matcher->value();
   std::string extension_id = context()->GetExtensionID();
   if (AddFilter(event_name, extension_id, *filter_weak)) {
     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());
    content::RenderThread::Get()->Send(new ExtensionHostMsg_AddFilteredListener(
        extension_id, event_name, *filter_weak, lazy));
  }

  args.GetReturnValue().Set(static_cast<int32_t>(id));
}
","The `AttachFilteredEvent` function in the `EventBindings` class is designed to attach an event listener with a specified filter in a V8 JavaScript context. It first checks that exactly two arguments are provided: a string representing the event name and an object for the filter. If the event name is valid and accessible, it converts the filter object into a `DictionaryValue`. The function then adds an event matcher using the event name and the parsed filter, storing the matcher ID. Finally, it sends a message to the render thread to register the filtered listener and returns the matcher ID, or -1 if the filter is invalid.","The provided function is responsible for attaching an event listener with a specified filter in a JavaScript context. It begins by verifying that two arguments are passed: a string for the event name and an object for the filter. If the event name is valid, it converts the filter object into a specific format. The function then registers an event matcher using the event name and the filter, storing the corresponding identifier. Additionally, it communicates with the render thread to register the filtered listener and returns the identifier, or an error code if the filter is invalid.","The vulnerability in the original code arises from the lack of validation after attempting to add an event matcher, which could lead to undefined behavior if the addition fails. Specifically, if `g_event_filter.Get().AddEventMatcher` returns an invalid identifier, the code proceeds to use this identifier without checking its validity, potentially causing crashes or security issues. The fix addresses this by introducing a check for the return value of `AddEventMatcher`. If the identifier is -1, indicating failure, the function now returns early, preventing further execution and ensuring that only valid matchers are processed.","The vulnerability in the original code stems from the lack of error handling after attempting to add an event matcher, which could lead to the use of an invalid identifier. If the addition fails, the code would continue executing, potentially causing crashes or unintended behavior due to reliance on an invalid state. The fix addresses this issue by implementing a check for the success of the addition process. If the addition fails, the function now exits early, ensuring that only valid matchers are processed and preventing any further operations that could lead to instability or security risks.","The vulnerability was fixed by adding a validation check for the return value of the `AddEventMatcher` function. After attempting to add the event matcher, the code now checks if the returned identifier is -1, which indicates a failure in adding the matcher. If this condition is met, the function immediately returns, preventing any further execution that relies on an invalid matcher. This change ensures that only valid matchers are processed, thereby enhancing the stability and security of the code by avoiding potential crashes or undefined behavior associated with using an invalid identifier.","The vulnerability was fixed by introducing a validation step after attempting to add an event matcher. The code now checks if the addition was successful by verifying the returned identifier. If the addition fails, indicated by a specific error value, the function exits early, preventing any further operations that could rely on an invalid state. This change ensures that only valid matchers are processed, thereby enhancing the overall stability and security of the code by avoiding potential crashes or unintended behavior that could arise from using an invalid identifier.","CWE-754, CWE-457, CWE-476, CWE-665, CWE-248, CWE-460, CWE-252, CWE-253, CWE-690, CWE-703",N,-1
72,72,186562,186562,,Remote,Not required,Partial,CVE-2018-18337,https://www.cvedetails.com/cve/CVE-2018-18337/,CWE-416,Medium,Partial,Partial,,2018-12-11,6.8,Incorrect handling of stylesheets leading to a use after free in Blink in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.,2019-08-17,,3,https://github.com/chromium/chromium/commit/2f8e481c12c9e8de107b73508b6c283569d4df5b,2f8e481c12c9e8de107b73508b6c283569d4df5b,"Avoid crash when setting rel=stylesheet on <link> in shadow root.

Link elements in shadow roots without rel=stylesheet are currently not
added as stylesheet candidates upon insertion. This causes a crash if
rel=stylesheet is set (and then loaded) later.

R=futhark@chromium.org

Bug: 886753
Change-Id: Ia0de2c1edf43407950f973982ee1c262a909d220
Reviewed-on: https://chromium-review.googlesource.com/1242463
Commit-Queue: Anders Ruud <andruud@chromium.org>
Reviewed-by: Rune Lillesveen <futhark@chromium.org>
Cr-Commit-Position: refs/heads/master@{#593907}",1,third_party/blink/renderer/core/html/html_link_element.cc,"{""sha"": ""ffc31d6a0e987abc3687ad4a1664eedc2fd5f191"", ""filename"": ""third_party/WebKit/LayoutTests/fast/dom/shadow/link-without-rel-crash.html"", ""status"": ""added"", ""additions"": 22, ""deletions"": 0, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/2f8e481c12c9e8de107b73508b6c283569d4df5b/third_party/WebKit/LayoutTests/fast/dom/shadow/link-without-rel-crash.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2f8e481c12c9e8de107b73508b6c283569d4df5b/third_party/WebKit/LayoutTests/fast/dom/shadow/link-without-rel-crash.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/dom/shadow/link-without-rel-crash.html?ref=2f8e481c12c9e8de107b73508b6c283569d4df5b"", ""patch"": ""@@ -0,0 +1,22 @@\n+<!DOCTYPE html>\n+<script src=\""../../../resources/testharness.js\""></script>\n+<script src=\""../../../resources/testharnessreport.js\""></script>\n+<script>\n+\n+let t = async_test('Setting rel=stylesheet on link in shadow root does not crash');\n+\n+function run() {\n+  t.step(() => {\n+    let link = document.createElement('link');\n+    link.setAttribute('href', 'empty.css');\n+    let div = document.createElement('div');\n+    let shadowRoot = div.attachShadow({mode: 'open'});\n+    document.body.append(div);\n+    shadowRoot.append(link);\n+    link.setAttribute('rel','stylesheet');\n+  });\n+  t.done();\n+}\n+\n+</script>\n+<body onload=\""run()\""></body>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""a182923316fb315cce47318ffcf1aa06c77f2994"", ""filename"": ""third_party/blink/renderer/core/html/html_link_element.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/2f8e481c12c9e8de107b73508b6c283569d4df5b/third_party/blink/renderer/core/html/html_link_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2f8e481c12c9e8de107b73508b6c283569d4df5b/third_party/blink/renderer/core/html/html_link_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/html_link_element.cc?ref=2f8e481c12c9e8de107b73508b6c283569d4df5b"", ""patch"": ""@@ -218,15 +218,16 @@ Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(\n   if (!insertion_point.isConnected())\n     return kInsertionDone;\n   DCHECK(isConnected());\n+\n+  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);\n+\n   if (!ShouldLoadLink() && IsInShadowTree()) {\n     String message = \""HTML element <link> is ignored in shadow tree.\"";\n     GetDocument().AddConsoleMessage(ConsoleMessage::Create(\n         kJSMessageSource, kWarningMessageLevel, message));\n     return kInsertionDone;\n   }\n \n-  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);\n-\n   Process();\n \n   if (link_)""}","Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(
    ContainerNode& insertion_point) {
  HTMLElement::InsertedInto(insertion_point);
  LogAddElementIfIsolatedWorldAndInDocument(""link"", relAttr, hrefAttr);
   if (!insertion_point.isConnected())
     return kInsertionDone;
   DCHECK(isConnected());

  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);

   if (!ShouldLoadLink() && IsInShadowTree()) {
     String message = ""HTML element <link> is ignored in shadow tree."";
     GetDocument().AddConsoleMessage(ConsoleMessage::Create(
         kJSMessageSource, kWarningMessageLevel, message));
     return kInsertionDone;
   }
 
   Process();
 
   if (link_)
    link_->OwnerInserted();

  return kInsertionDone;
}
","Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(
    ContainerNode& insertion_point) {
  HTMLElement::InsertedInto(insertion_point);
  LogAddElementIfIsolatedWorldAndInDocument(""link"", relAttr, hrefAttr);
   if (!insertion_point.isConnected())
     return kInsertionDone;
   DCHECK(isConnected());
   if (!ShouldLoadLink() && IsInShadowTree()) {
     String message = ""HTML element <link> is ignored in shadow tree."";
     GetDocument().AddConsoleMessage(ConsoleMessage::Create(
         kJSMessageSource, kWarningMessageLevel, message));
     return kInsertionDone;
   }
 
  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);
   Process();
 
   if (link_)
    link_->OwnerInserted();

  return kInsertionDone;
}
",C,"
  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);

","  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);
",,"@@ -218,15 +218,16 @@ Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(
   if (!insertion_point.isConnected())
     return kInsertionDone;
   DCHECK(isConnected());
+
+  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);
+
   if (!ShouldLoadLink() && IsInShadowTree()) {
     String message = ""HTML element <link> is ignored in shadow tree."";
     GetDocument().AddConsoleMessage(ConsoleMessage::Create(
         kJSMessageSource, kWarningMessageLevel, message));
     return kInsertionDone;
   }
 
-  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);
-
   Process();
 
   if (link_)",Chrome,2f8e481c12c9e8de107b73508b6c283569d4df5b,156306624e3e37c10456dbafbc1b301c291a89e0,1,"Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(
    ContainerNode& insertion_point) {
  HTMLElement::InsertedInto(insertion_point);
  LogAddElementIfIsolatedWorldAndInDocument(""link"", relAttr, hrefAttr);
   if (!insertion_point.isConnected())
     return kInsertionDone;
   DCHECK(isConnected());
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);
//fix_flaw_line_below:
//
   if (!ShouldLoadLink() && IsInShadowTree()) {
     String message = ""HTML element <link> is ignored in shadow tree."";
     GetDocument().AddConsoleMessage(ConsoleMessage::Create(
         kJSMessageSource, kWarningMessageLevel, message));
     return kInsertionDone;
   }
 
//flaw_line_below:
  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);
//flaw_line_below:

   Process();
 
   if (link_)
    link_->OwnerInserted();

  return kInsertionDone;
}
",186562,"Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(
    ContainerNode& insertion_point) {
  HTMLElement::InsertedInto(insertion_point);
  LogAddElementIfIsolatedWorldAndInDocument(""link"", relAttr, hrefAttr);
   if (!insertion_point.isConnected())
     return kInsertionDone;
   DCHECK(isConnected());
   if (!ShouldLoadLink() && IsInShadowTree()) {
     String message = ""HTML element <link> is ignored in shadow tree."";
     GetDocument().AddConsoleMessage(ConsoleMessage::Create(
         kJSMessageSource, kWarningMessageLevel, message));
     return kInsertionDone;
   }
 
  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);
   Process();
 
   if (link_)
    link_->OwnerInserted();

  return kInsertionDone;
}
","Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(
    ContainerNode& insertion_point) {
  HTMLElement::InsertedInto(insertion_point);
  LogAddElementIfIsolatedWorldAndInDocument(""link"", relAttr, hrefAttr);
   if (!insertion_point.isConnected())
     return kInsertionDone;
   DCHECK(isConnected());

  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);

   if (!ShouldLoadLink() && IsInShadowTree()) {
     String message = ""HTML element <link> is ignored in shadow tree."";
     GetDocument().AddConsoleMessage(ConsoleMessage::Create(
         kJSMessageSource, kWarningMessageLevel, message));
     return kInsertionDone;
   }
 
   Process();
 
   if (link_)
    link_->OwnerInserted();

  return kInsertionDone;
}
","The `InsertedInto` function is a method of the `HTMLLinkElement` class that handles the insertion of a link element into a specified container node. Upon insertion, it first calls the base class method to perform standard operations and logs the addition of the element if it is part of an isolated world and in the document. If the insertion point is not connected, it returns immediately. If the link is in a shadow tree and should not load, it logs a warning message. Otherwise, it adds the link element as a stylesheet candidate to the document's style engine and processes it, notifying the owner if applicable before concluding the operation.","The provided code defines a method that manages the insertion of a link element into a specified container. It begins by executing standard insertion procedures and logging the addition if certain conditions are met. If the container is not connected, the method exits early. If the link is part of a shadow tree and should not be loaded, a warning message is logged. If the link is valid for processing, it is added as a candidate for stylesheets, and any necessary processing is performed, including notifying the owner of the link about its insertion before completing the operation.",The vulnerability in the original code arises from the failure to add link elements in shadow roots as stylesheet candidates when they do not have the `rel=stylesheet` attribute. This oversight could lead to a crash if the `rel` attribute is later set to `stylesheet` and the link is subsequently loaded. The fixed code addresses this issue by ensuring that the link element is always added as a stylesheet candidate before checking if it should load or if it is in a shadow tree. This change prevents the crash by maintaining the integrity of the stylesheet handling process regardless of the `rel` attribute's state.,"The vulnerability in the original code stems from the failure to register link elements in shadow roots as candidates for stylesheets when they lack the `rel=stylesheet` attribute. This oversight could lead to a crash if the `rel` attribute is later set to `stylesheet` and the link is subsequently loaded, as the system would attempt to process an unregistered element. The fixed code resolves this issue by ensuring that link elements are added as stylesheet candidates upon insertion, regardless of their `rel` attribute, thereby preventing potential crashes and maintaining stability in stylesheet management.","The vulnerability was fixed by modifying the order of operations in the code. In the updated implementation, the method now calls `GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);` immediately after confirming that the insertion point is connected, regardless of the `rel` attribute. This ensures that link elements are registered as stylesheet candidates upon insertion, even if they do not initially have `rel=stylesheet`. The subsequent check for whether the link should load and if it is in a shadow tree now occurs after this registration, preventing crashes when the `rel` attribute is later set to `stylesheet`.","The vulnerability was fixed by adjusting the sequence of operations in the code to ensure that link elements are registered as candidates for stylesheets immediately upon insertion, regardless of their initial attributes. This change guarantees that even if the link does not have the appropriate attribute at the time of insertion, it will still be recognized as a valid candidate. The subsequent checks for loading conditions and shadow tree status are performed after this registration, effectively preventing any crashes that could occur if the attributes were modified later, thus enhancing the stability and reliability of the stylesheet handling process.","CWE-456, CWE-665, CWE-666, CWE-667, CWE-822, CWE-362, CWE-821, CWE-367, CWE-364, CWE-371",N,-1
73,73,186642,186642,,Remote,Not required,Partial,CVE-2018-6031,https://www.cvedetails.com/cve/CVE-2018-6031/,CWE-416,Medium,Partial,Partial,,2018-09-25,6.8,Use after free in PDFium in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file.,2018-11-20,,8,https://github.com/chromium/chromium/commit/01c9a7e71ca435651723e8cbcab0b3ad4c5351e2,01c9a7e71ca435651723e8cbcab0b3ad4c5351e2,"[pdf] Use a temporary list when unloading pages

When traversing the |deferred_page_unloads_| list and handling the
unloads it's possible for new pages to get added to the list which will
invalidate the iterator.

This CL swaps the list with an empty list and does the iteration on the
list copy. New items that are unloaded while handling the defers will be
unloaded at a later point.

Bug: 780450
Change-Id: Ic7ced1c82227109784fb536ce19a4dd51b9119ac
Reviewed-on: https://chromium-review.googlesource.com/758916
Commit-Queue: dsinclair <dsinclair@chromium.org>
Reviewed-by: Lei Zhang <thestig@chromium.org>
Cr-Commit-Position: refs/heads/master@{#515056}",2,pdf/pdfium/pdfium_engine.cc,"{""sha"": ""7c6b7da1c70f4071d071d2f111be90a01b1233b3"", ""filename"": ""pdf/pdfium/pdfium_engine.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 2, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/01c9a7e71ca435651723e8cbcab0b3ad4c5351e2/pdf/pdfium/pdfium_engine.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/01c9a7e71ca435651723e8cbcab0b3ad4c5351e2/pdf/pdfium/pdfium_engine.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/pdf/pdfium/pdfium_engine.cc?ref=01c9a7e71ca435651723e8cbcab0b3ad4c5351e2"", ""patch"": ""@@ -1405,9 +1405,15 @@ bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {\n \n   DCHECK(defer_page_unload_);\n   defer_page_unload_ = false;\n-  for (int page_index : deferred_page_unloads_)\n+\n+  // Store the pages to unload away because the act of unloading pages can cause\n+  // there to be more pages to unload. We leave those extra pages to be unloaded\n+  // on the next go around.\n+  std::vector<int> pages_to_unload;\n+  std::swap(pages_to_unload, deferred_page_unloads_);\n+  for (int page_index : pages_to_unload)\n     pages_[page_index]->Unload();\n-  deferred_page_unloads_.clear();\n+\n   return rv;\n }\n ""}","bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {
  DCHECK(!defer_page_unload_);
  defer_page_unload_ = true;
  bool rv = false;
  switch (event.GetType()) {
    case PP_INPUTEVENT_TYPE_MOUSEDOWN:
      rv = OnMouseDown(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEUP:
      rv = OnMouseUp(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEMOVE:
      rv = OnMouseMove(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYDOWN:
      rv = OnKeyDown(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYUP:
      rv = OnKeyUp(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_CHAR:
      rv = OnChar(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_TOUCHSTART: {
      KillTouchTimer(next_touch_timer_id_);

      pp::TouchInputEvent touch_event(event);
      if (touch_event.GetTouchCount(PP_TOUCHLIST_TYPE_TARGETTOUCHES) == 1)
        ScheduleTouchTimer(touch_event);
      break;
    }
    case PP_INPUTEVENT_TYPE_TOUCHEND:
      KillTouchTimer(next_touch_timer_id_);
      break;
    case PP_INPUTEVENT_TYPE_TOUCHMOVE:
      KillTouchTimer(next_touch_timer_id_);
    default:
      break;
  }
 
   DCHECK(defer_page_unload_);
   defer_page_unload_ = false;

  // Store the pages to unload away because the act of unloading pages can cause
  // there to be more pages to unload. We leave those extra pages to be unloaded
  // on the next go around.
  std::vector<int> pages_to_unload;
  std::swap(pages_to_unload, deferred_page_unloads_);
  for (int page_index : pages_to_unload)
     pages_[page_index]->Unload();

   return rv;
 }
","bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {
  DCHECK(!defer_page_unload_);
  defer_page_unload_ = true;
  bool rv = false;
  switch (event.GetType()) {
    case PP_INPUTEVENT_TYPE_MOUSEDOWN:
      rv = OnMouseDown(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEUP:
      rv = OnMouseUp(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEMOVE:
      rv = OnMouseMove(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYDOWN:
      rv = OnKeyDown(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYUP:
      rv = OnKeyUp(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_CHAR:
      rv = OnChar(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_TOUCHSTART: {
      KillTouchTimer(next_touch_timer_id_);

      pp::TouchInputEvent touch_event(event);
      if (touch_event.GetTouchCount(PP_TOUCHLIST_TYPE_TARGETTOUCHES) == 1)
        ScheduleTouchTimer(touch_event);
      break;
    }
    case PP_INPUTEVENT_TYPE_TOUCHEND:
      KillTouchTimer(next_touch_timer_id_);
      break;
    case PP_INPUTEVENT_TYPE_TOUCHMOVE:
      KillTouchTimer(next_touch_timer_id_);
    default:
      break;
  }
 
   DCHECK(defer_page_unload_);
   defer_page_unload_ = false;
  for (int page_index : deferred_page_unloads_)
     pages_[page_index]->Unload();
  deferred_page_unloads_.clear();
   return rv;
 }
",C,"
  // Store the pages to unload away because the act of unloading pages can cause
  // there to be more pages to unload. We leave those extra pages to be unloaded
  // on the next go around.
  std::vector<int> pages_to_unload;
  std::swap(pages_to_unload, deferred_page_unloads_);
  for (int page_index : pages_to_unload)

","  for (int page_index : deferred_page_unloads_)
  deferred_page_unloads_.clear();
",,"@@ -1405,9 +1405,15 @@ bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {
 
   DCHECK(defer_page_unload_);
   defer_page_unload_ = false;
-  for (int page_index : deferred_page_unloads_)
+
+  // Store the pages to unload away because the act of unloading pages can cause
+  // there to be more pages to unload. We leave those extra pages to be unloaded
+  // on the next go around.
+  std::vector<int> pages_to_unload;
+  std::swap(pages_to_unload, deferred_page_unloads_);
+  for (int page_index : pages_to_unload)
     pages_[page_index]->Unload();
-  deferred_page_unloads_.clear();
+
   return rv;
 }
 ",Chrome,01c9a7e71ca435651723e8cbcab0b3ad4c5351e2,345dab421e9ff30af4f11fc0b55ab02bdd7d1011,1,"bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {
  DCHECK(!defer_page_unload_);
  defer_page_unload_ = true;
  bool rv = false;
  switch (event.GetType()) {
    case PP_INPUTEVENT_TYPE_MOUSEDOWN:
      rv = OnMouseDown(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEUP:
      rv = OnMouseUp(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEMOVE:
      rv = OnMouseMove(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYDOWN:
      rv = OnKeyDown(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYUP:
      rv = OnKeyUp(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_CHAR:
      rv = OnChar(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_TOUCHSTART: {
      KillTouchTimer(next_touch_timer_id_);

      pp::TouchInputEvent touch_event(event);
      if (touch_event.GetTouchCount(PP_TOUCHLIST_TYPE_TARGETTOUCHES) == 1)
        ScheduleTouchTimer(touch_event);
      break;
    }
    case PP_INPUTEVENT_TYPE_TOUCHEND:
      KillTouchTimer(next_touch_timer_id_);
      break;
    case PP_INPUTEVENT_TYPE_TOUCHMOVE:
      // TODO(dsinclair): This should allow a little bit of movement (up to the
      // touch radii) to account for finger jiggle.
      KillTouchTimer(next_touch_timer_id_);
    default:
      break;
  }
 
   DCHECK(defer_page_unload_);
   defer_page_unload_ = false;
//flaw_line_below:
  for (int page_index : deferred_page_unloads_)
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  // Store the pages to unload away because the act of unloading pages can cause
//fix_flaw_line_below:
//  // there to be more pages to unload. We leave those extra pages to be unloaded
//fix_flaw_line_below:
//  // on the next go around.
//fix_flaw_line_below:
//  std::vector<int> pages_to_unload;
//fix_flaw_line_below:
//  std::swap(pages_to_unload, deferred_page_unloads_);
//fix_flaw_line_below:
//  for (int page_index : pages_to_unload)
     pages_[page_index]->Unload();
//flaw_line_below:
  deferred_page_unloads_.clear();
//fix_flaw_line_below:
//
   return rv;
 }
",186642,"bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {
  DCHECK(!defer_page_unload_);
  defer_page_unload_ = true;
  bool rv = false;
  switch (event.GetType()) {
    case PP_INPUTEVENT_TYPE_MOUSEDOWN:
      rv = OnMouseDown(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEUP:
      rv = OnMouseUp(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEMOVE:
      rv = OnMouseMove(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYDOWN:
      rv = OnKeyDown(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYUP:
      rv = OnKeyUp(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_CHAR:
      rv = OnChar(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_TOUCHSTART: {
      KillTouchTimer(next_touch_timer_id_);

      pp::TouchInputEvent touch_event(event);
      if (touch_event.GetTouchCount(PP_TOUCHLIST_TYPE_TARGETTOUCHES) == 1)
        ScheduleTouchTimer(touch_event);
      break;
    }
    case PP_INPUTEVENT_TYPE_TOUCHEND:
      KillTouchTimer(next_touch_timer_id_);
      break;
    case PP_INPUTEVENT_TYPE_TOUCHMOVE:
      KillTouchTimer(next_touch_timer_id_);
    default:
      break;
  }
 
   DCHECK(defer_page_unload_);
   defer_page_unload_ = false;
  for (int page_index : deferred_page_unloads_)
     pages_[page_index]->Unload();
  deferred_page_unloads_.clear();
   return rv;
 }
","bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {
  DCHECK(!defer_page_unload_);
  defer_page_unload_ = true;
  bool rv = false;
  switch (event.GetType()) {
    case PP_INPUTEVENT_TYPE_MOUSEDOWN:
      rv = OnMouseDown(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEUP:
      rv = OnMouseUp(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_MOUSEMOVE:
      rv = OnMouseMove(pp::MouseInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYDOWN:
      rv = OnKeyDown(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_KEYUP:
      rv = OnKeyUp(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_CHAR:
      rv = OnChar(pp::KeyboardInputEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_TOUCHSTART: {
      KillTouchTimer(next_touch_timer_id_);

      pp::TouchInputEvent touch_event(event);
      if (touch_event.GetTouchCount(PP_TOUCHLIST_TYPE_TARGETTOUCHES) == 1)
        ScheduleTouchTimer(touch_event);
      break;
    }
    case PP_INPUTEVENT_TYPE_TOUCHEND:
      KillTouchTimer(next_touch_timer_id_);
      break;
    case PP_INPUTEVENT_TYPE_TOUCHMOVE:
      KillTouchTimer(next_touch_timer_id_);
    default:
      break;
  }
 
   DCHECK(defer_page_unload_);
   defer_page_unload_ = false;

  // Store the pages to unload away because the act of unloading pages can cause
  // there to be more pages to unload. We leave those extra pages to be unloaded
  // on the next go around.
  std::vector<int> pages_to_unload;
  std::swap(pages_to_unload, deferred_page_unloads_);
  for (int page_index : pages_to_unload)
     pages_[page_index]->Unload();

   return rv;
 }
","The `HandleEvent` function in the `PDFiumEngine` class processes various input events, such as mouse actions, keyboard inputs, and touch interactions. Initially, it sets a flag to defer page unloading, ensuring that the current event is handled before any page unloads occur. Depending on the type of input event received, it calls specific handler functions for mouse down, mouse up, mouse move, key down, key up, character input, and touch events. After processing the event, it resets the defer flag and unloads any pages that were marked for deferred unloading, returning a boolean indicating the success of the event handling.","The provided code defines a function that handles various types of input events, including mouse actions, keyboard inputs, and touch interactions. It begins by setting a flag to prevent page unloading while processing the current event. Based on the event type, it invokes specific handlers to manage the corresponding input. For touch events, it manages timers to ensure proper handling of touch interactions. After processing the event, the function resets the defer flag and proceeds to unload any pages that were previously marked for deferred unloading, ultimately returning a status indicating whether the event was successfully handled.","The vulnerability in the original code arises from the potential modification of the `deferred_page_unloads_` list while iterating through it to unload pages, which could lead to iterator invalidation and undefined behavior. This issue occurs because unloading a page may trigger the addition of new pages to the list during the iteration. The fix involves creating a temporary list, `pages_to_unload`, by swapping it with `deferred_page_unloads_`, allowing the iteration to occur on a stable copy. This ensures that any new pages added during the unload process are handled in subsequent iterations, thus preventing the iterator invalidation issue.","The vulnerability in the original code stems from the risk of modifying a list while iterating through it, which can lead to iterator invalidation and unpredictable behavior. Specifically, as pages are unloaded, new entries could be added to the list, disrupting the iteration process. The fix addresses this issue by creating a temporary copy of the list to iterate over, ensuring that any modifications made during the unloading process do not affect the iteration. This approach allows for safe handling of the unloads while deferring any new entries to be processed in subsequent iterations, thus maintaining stability and preventing errors.","The vulnerability was fixed by introducing a temporary list, `pages_to_unload`, which is created by swapping it with the `deferred_page_unloads_` list. This ensures that the iteration for unloading pages occurs on a stable copy, preventing any modifications to the original list during the unloading process from affecting the iteration. By iterating over `pages_to_unload`, the code safely unloads the pages without the risk of iterator invalidation, while any new pages added during the unloads will be handled in future iterations, thus maintaining the integrity of the unloading process.","The vulnerability was addressed by creating a temporary copy of the list used for unloading pages, which prevents modifications during iteration from affecting the process. By swapping the original list with an empty one, the code ensures that the iteration occurs on a stable version of the list, thereby avoiding any issues related to iterator invalidation. This approach allows for safe unloading of pages while deferring any new entries that may be added during the unload process, ensuring that they will be processed in subsequent iterations without disrupting the current operation.","CWE-664, CWE-366, CWE-462, CWE-665, CWE-476, CWE-374, CWE-362, CWE-668, CWE-765, CWE-367",N,-1
74,74,186672,186672,,Remote,Not required,Partial,CVE-2018-6054,https://www.cvedetails.com/cve/CVE-2018-6054/,CWE-416,Medium,Partial,Partial,,2018-09-25,6.8,Use after free in WebUI in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to potentially exploit heap corruption via a crafted Chrome Extension.,2018-11-20,,7,https://github.com/chromium/chromium/commit/90585e657db48f93bd73bc45d4caa975323da41b,90585e657db48f93bd73bc45d4caa975323da41b,"Validate frame after conversion in chrome.send

BUG=797511
TEST=Manually, see https://crbug.com/797511#c1

Change-Id: Ib1a99db4d7648fb1325eb6d7af4ef111d6dda4cb
Reviewed-on: https://chromium-review.googlesource.com/844076
Commit-Queue: Rob Wu <rob@robwu.nl>
Reviewed-by: Kentaro Hara <haraken@chromium.org>
Cr-Commit-Position: refs/heads/master@{#526197}",0,content/renderer/web_ui_extension.cc,"{""sha"": ""93ff2804839fa9314e4022c704e41c1260756c85"", ""filename"": ""content/renderer/web_ui_extension.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/90585e657db48f93bd73bc45d4caa975323da41b/content/renderer/web_ui_extension.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/90585e657db48f93bd73bc45d4caa975323da41b/content/renderer/web_ui_extension.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/web_ui_extension.cc?ref=90585e657db48f93bd73bc45d4caa975323da41b"", ""patch"": ""@@ -120,6 +120,13 @@ void WebUIExtension::Send(gin::Arguments* args) {\n     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(\n         obj, frame->MainWorldScriptContext()));\n     DCHECK(content);\n+    // The conversion of |obj| could have triggered arbitrary JavaScript code,\n+    // so check that the frame is still valid to avoid dereferencing a stale\n+    // pointer.\n+    if (frame != blink::WebLocalFrame::FrameForCurrentContext()) {\n+      NOTREACHED();\n+      return;\n+    }\n   }\n \n   // Send the message up to the browser.""}","void WebUIExtension::Send(gin::Arguments* args) {
  blink::WebLocalFrame* frame;
  RenderFrame* render_frame;
  if (!ShouldRespondToRequest(&frame, &render_frame))
    return;

  std::string message;
  if (!args->GetNext(&message)) {
    args->ThrowError();
    return;
  }

  if (base::EndsWith(message, ""RequiringGesture"",
                     base::CompareCase::SENSITIVE) &&
      !blink::WebUserGestureIndicator::IsProcessingUserGesture(frame)) {
    NOTREACHED();
    return;
  }

  std::unique_ptr<base::ListValue> content;
  if (args->PeekNext().IsEmpty() || args->PeekNext()->IsUndefined()) {
    content.reset(new base::ListValue());
  } else {
    v8::Local<v8::Object> obj;
    if (!args->GetNext(&obj)) {
      args->ThrowError();
      return;
    }

     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(
         obj, frame->MainWorldScriptContext()));
     DCHECK(content);
    // The conversion of |obj| could have triggered arbitrary JavaScript code,
    // so check that the frame is still valid to avoid dereferencing a stale
    // pointer.
    if (frame != blink::WebLocalFrame::FrameForCurrentContext()) {
      NOTREACHED();
      return;
    }
   }
 
  render_frame->Send(new FrameHostMsg_WebUISend(render_frame->GetRoutingID(),
                                                frame->GetDocument().Url(),
                                                message, *content));
}
","void WebUIExtension::Send(gin::Arguments* args) {
  blink::WebLocalFrame* frame;
  RenderFrame* render_frame;
  if (!ShouldRespondToRequest(&frame, &render_frame))
    return;

  std::string message;
  if (!args->GetNext(&message)) {
    args->ThrowError();
    return;
  }

  if (base::EndsWith(message, ""RequiringGesture"",
                     base::CompareCase::SENSITIVE) &&
      !blink::WebUserGestureIndicator::IsProcessingUserGesture(frame)) {
    NOTREACHED();
    return;
  }

  std::unique_ptr<base::ListValue> content;
  if (args->PeekNext().IsEmpty() || args->PeekNext()->IsUndefined()) {
    content.reset(new base::ListValue());
  } else {
    v8::Local<v8::Object> obj;
    if (!args->GetNext(&obj)) {
      args->ThrowError();
      return;
    }

     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(
         obj, frame->MainWorldScriptContext()));
     DCHECK(content);
   }
 
  render_frame->Send(new FrameHostMsg_WebUISend(render_frame->GetRoutingID(),
                                                frame->GetDocument().Url(),
                                                message, *content));
}
",C,"    // The conversion of |obj| could have triggered arbitrary JavaScript code,
    // so check that the frame is still valid to avoid dereferencing a stale
    // pointer.
    if (frame != blink::WebLocalFrame::FrameForCurrentContext()) {
      NOTREACHED();
      return;
    }
",,,"@@ -120,6 +120,13 @@ void WebUIExtension::Send(gin::Arguments* args) {
     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(
         obj, frame->MainWorldScriptContext()));
     DCHECK(content);
+    // The conversion of |obj| could have triggered arbitrary JavaScript code,
+    // so check that the frame is still valid to avoid dereferencing a stale
+    // pointer.
+    if (frame != blink::WebLocalFrame::FrameForCurrentContext()) {
+      NOTREACHED();
+      return;
+    }
   }
 
   // Send the message up to the browser.",Chrome,90585e657db48f93bd73bc45d4caa975323da41b,ab8d0ea46daf7673a53524a3708f0ffd1ea9ee2d,1,"void WebUIExtension::Send(gin::Arguments* args) {
  blink::WebLocalFrame* frame;
  RenderFrame* render_frame;
  if (!ShouldRespondToRequest(&frame, &render_frame))
    return;

  std::string message;
  if (!args->GetNext(&message)) {
    args->ThrowError();
    return;
  }

  if (base::EndsWith(message, ""RequiringGesture"",
                     base::CompareCase::SENSITIVE) &&
      !blink::WebUserGestureIndicator::IsProcessingUserGesture(frame)) {
    NOTREACHED();
    return;
  }

  // If they've provided an optional message parameter, convert that into a
  // Value to send to the browser process.
  std::unique_ptr<base::ListValue> content;
  if (args->PeekNext().IsEmpty() || args->PeekNext()->IsUndefined()) {
    content.reset(new base::ListValue());
  } else {
    v8::Local<v8::Object> obj;
    if (!args->GetNext(&obj)) {
      args->ThrowError();
      return;
    }

     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(
         obj, frame->MainWorldScriptContext()));
     DCHECK(content);
//fix_flaw_line_below:
//    // The conversion of |obj| could have triggered arbitrary JavaScript code,
//fix_flaw_line_below:
//    // so check that the frame is still valid to avoid dereferencing a stale
//fix_flaw_line_below:
//    // pointer.
//fix_flaw_line_below:
//    if (frame != blink::WebLocalFrame::FrameForCurrentContext()) {
//fix_flaw_line_below:
//      NOTREACHED();
//fix_flaw_line_below:
//      return;
//fix_flaw_line_below:
//    }
   }
 
   // Send the message up to the browser.
  render_frame->Send(new FrameHostMsg_WebUISend(render_frame->GetRoutingID(),
                                                frame->GetDocument().Url(),
                                                message, *content));
}
",186672,"void WebUIExtension::Send(gin::Arguments* args) {
  blink::WebLocalFrame* frame;
  RenderFrame* render_frame;
  if (!ShouldRespondToRequest(&frame, &render_frame))
    return;

  std::string message;
  if (!args->GetNext(&message)) {
    args->ThrowError();
    return;
  }

  if (base::EndsWith(message, ""RequiringGesture"",
                     base::CompareCase::SENSITIVE) &&
      !blink::WebUserGestureIndicator::IsProcessingUserGesture(frame)) {
    NOTREACHED();
    return;
  }

  std::unique_ptr<base::ListValue> content;
  if (args->PeekNext().IsEmpty() || args->PeekNext()->IsUndefined()) {
    content.reset(new base::ListValue());
  } else {
    v8::Local<v8::Object> obj;
    if (!args->GetNext(&obj)) {
      args->ThrowError();
      return;
    }

     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(
         obj, frame->MainWorldScriptContext()));
     DCHECK(content);
   }
 
  render_frame->Send(new FrameHostMsg_WebUISend(render_frame->GetRoutingID(),
                                                frame->GetDocument().Url(),
                                                message, *content));
}
","void WebUIExtension::Send(gin::Arguments* args) {
  blink::WebLocalFrame* frame;
  RenderFrame* render_frame;
  if (!ShouldRespondToRequest(&frame, &render_frame))
    return;

  std::string message;
  if (!args->GetNext(&message)) {
    args->ThrowError();
    return;
  }

  if (base::EndsWith(message, ""RequiringGesture"",
                     base::CompareCase::SENSITIVE) &&
      !blink::WebUserGestureIndicator::IsProcessingUserGesture(frame)) {
    NOTREACHED();
    return;
  }

  std::unique_ptr<base::ListValue> content;
  if (args->PeekNext().IsEmpty() || args->PeekNext()->IsUndefined()) {
    content.reset(new base::ListValue());
  } else {
    v8::Local<v8::Object> obj;
    if (!args->GetNext(&obj)) {
      args->ThrowError();
      return;
    }

     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(
         obj, frame->MainWorldScriptContext()));
     DCHECK(content);
    // The conversion of |obj| could have triggered arbitrary JavaScript code,
    // so check that the frame is still valid to avoid dereferencing a stale
    // pointer.
    if (frame != blink::WebLocalFrame::FrameForCurrentContext()) {
      NOTREACHED();
      return;
    }
   }
 
  render_frame->Send(new FrameHostMsg_WebUISend(render_frame->GetRoutingID(),
                                                frame->GetDocument().Url(),
                                                message, *content));
}
","The `Send` function in the `WebUIExtension` class is designed to handle messages sent from a web UI, ensuring that requests are valid and appropriately formatted. It first checks if the request should be processed by verifying the frame and render frame. If a message is retrieved from the arguments, it checks for specific conditions, such as whether the message ends with ""RequiringGesture"" and if a user gesture is being processed. It then prepares a content object, either initializing it as an empty list or converting a provided V8 object into a ListValue. Finally, it sends a message to the render frame with the relevant details.","The provided code defines a function that processes messages from a web user interface. It first checks if the current request is valid and can be handled. If a message is successfully retrieved, the function verifies specific conditions related to user gestures. It then prepares a content object, either as an empty list or by converting a provided object into a suitable format. Finally, the function sends a message to the appropriate render frame, including the necessary details such as the message content and the associated URL, ensuring proper communication within the web environment.","The vulnerability in the original code arises from the potential for dereferencing a stale pointer to the frame after converting a V8 object, which could lead to accessing invalid memory and executing arbitrary JavaScript code. This risk is mitigated in the fixed code by adding a validation check after the conversion of the object. Specifically, it verifies that the frame is still valid by comparing it to the current context using `blink::WebLocalFrame::FrameForCurrentContext()`. If the frame is no longer valid, the function triggers a failure condition, preventing unsafe operations and enhancing overall security.","The vulnerability in the original code stems from the risk of dereferencing a potentially stale pointer after converting an object, which could lead to executing arbitrary code or accessing invalid memory. This issue arises because the validity of the frame was not checked after the conversion process. The fix implemented in the updated code introduces a validation step that ensures the frame remains valid by comparing it to the current context. This additional check prevents unsafe operations and mitigates the risk of memory corruption or unintended code execution, thereby enhancing the security of the function.","The vulnerability was fixed by adding a validation check for the frame after the conversion of the V8 object. Specifically, the code now includes a comparison using `blink::WebLocalFrame::FrameForCurrentContext()` to ensure that the frame is still valid and has not become stale. If the frame does not match the current context, the code triggers a failure condition with `NOTREACHED()`, preventing any further operations that could lead to dereferencing an invalid pointer. This enhancement effectively mitigates the risk of executing arbitrary JavaScript code and accessing invalid memory, thereby improving the overall security of the function.","The vulnerability was addressed by introducing a validation step that checks the integrity of the frame after an object conversion. This check ensures that the frame remains valid and has not become stale, which could lead to unsafe memory access or the execution of arbitrary code. If the frame is found to be invalid, the code triggers a failure condition, effectively halting any further operations that could compromise security. This additional layer of verification significantly reduces the risk of memory corruption and enhances the overall safety of the function's execution.","CWE-119, CWE-416, CWE-476, CWE-825, CWE-415, CWE-763, CWE-125, CWE-787, CWE-457, CWE-94",N,-1
75,75,186677,186677,,Remote,Not required,Partial,CVE-2018-6086,https://www.cvedetails.com/cve/CVE-2018-6086/,CWE-416,Medium,Partial,Partial,,2018-12-04,6.8,A double-eviction in the Incognito mode cache that lead to a user-after-free in Networking Disk Cache in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to execute arbitrary code via a crafted HTML page.,2019-01-09,Exec Code ,7,https://github.com/chromium/chromium/commit/c9d673b54832afde658f214d7da7d0453fa89774,c9d673b54832afde658f214d7da7d0453fa89774,"[MemCache] Fix bug while iterating LRU list in eviction

It was possible to reanalyze a previously doomed entry.

Bug: 827492
Change-Id: I5d34d2ae87c96e0d2099e926e6eb2c1b30b01d63
Reviewed-on: https://chromium-review.googlesource.com/987919
Commit-Queue: Josh Karlin <jkarlin@chromium.org>
Reviewed-by: Maks Orlovich <morlovich@chromium.org>
Cr-Commit-Position: refs/heads/master@{#547236}",1,net/disk_cache/memory/mem_backend_impl.cc,"{""sha"": ""8b46ef251bde36f768ec04d9ff36b3aac30c21ea"", ""filename"": ""net/disk_cache/backend_unittest.cc"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 0, ""changes"": 39, ""blob_url"": ""https://github.com/chromium/chromium/blob/c9d673b54832afde658f214d7da7d0453fa89774/net/disk_cache/backend_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c9d673b54832afde658f214d7da7d0453fa89774/net/disk_cache/backend_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/disk_cache/backend_unittest.cc?ref=c9d673b54832afde658f214d7da7d0453fa89774"", ""patch"": ""@@ -1930,6 +1930,45 @@ TEST_F(DiskCacheBackendTest, DoomAllSparse) {\n   EXPECT_EQ(0, cache_->GetEntryCount());\n }\n \n+// This test is for https://crbug.com/827492.\n+TEST_F(DiskCacheBackendTest, InMemorySparseEvict) {\n+  const int kMaxSize = 512;\n+\n+  SetMaxSize(kMaxSize);\n+  SetMemoryOnlyMode();\n+  InitCache();\n+\n+  scoped_refptr<net::IOBuffer> buffer(new net::IOBuffer(64));\n+  CacheTestFillBuffer(buffer->data(), 64, false /* no_nulls */);\n+\n+  std::vector<disk_cache::ScopedEntryPtr> entries;\n+\n+  disk_cache::Entry* entry = nullptr;\n+  // Create a bunch of entries\n+  for (size_t i = 0; i < 14; i++) {\n+    std::string name = \""http://www.\"" + std::to_string(i) + \"".com/\"";\n+    ASSERT_THAT(CreateEntry(name, &entry), IsOk());\n+    entries.push_back(disk_cache::ScopedEntryPtr(entry));\n+  }\n+\n+  // Create several sparse entries and fill with enough data to\n+  // pass eviction threshold\n+  ASSERT_EQ(64, WriteSparseData(entries[0].get(), 0, buffer.get(), 64));\n+  ASSERT_EQ(net::ERR_FAILED,\n+            WriteSparseData(entries[0].get(), 10000, buffer.get(), 4));\n+  ASSERT_EQ(63, WriteSparseData(entries[1].get(), 0, buffer.get(), 63));\n+  ASSERT_EQ(64, WriteSparseData(entries[2].get(), 0, buffer.get(), 64));\n+  ASSERT_EQ(64, WriteSparseData(entries[3].get(), 0, buffer.get(), 64));\n+\n+  // Close all the entries, leaving a populated LRU list\n+  // with all entries having refcount 0 (doom implies deletion)\n+  entries.clear();\n+\n+  // Create a new entry, triggering buggy eviction\n+  ASSERT_THAT(CreateEntry(\""http://www.14.com/\"", &entry), IsOk());\n+  entry->Close();\n+}\n+\n void DiskCacheBackendTest::BackendDoomBetween() {\n   InitCache();\n ""}<_**next**_>{""sha"": ""9f09f9084f496f498fb356f27b4d67210f1b1516"", ""filename"": ""net/disk_cache/memory/mem_backend_impl.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c9d673b54832afde658f214d7da7d0453fa89774/net/disk_cache/memory/mem_backend_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c9d673b54832afde658f214d7da7d0453fa89774/net/disk_cache/memory/mem_backend_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/disk_cache/memory/mem_backend_impl.cc?ref=c9d673b54832afde658f214d7da7d0453fa89774"", ""patch"": ""@@ -332,7 +332,13 @@ void MemBackendImpl::EvictIfNeeded() {\n   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();\n   while (current_size_ > target_size && entry != lru_list_.end()) {\n     MemEntryImpl* to_doom = entry->value();\n-    entry = entry->next();\n+\n+    do {\n+      entry = entry->next();\n+      // It's possible that entry now points to a child of to_doom, and the\n+      // parent is about to be deleted. Skip past any child entries.\n+    } while (entry != lru_list_.end() && entry->value()->parent() == to_doom);\n+\n     if (!to_doom->InUse())\n       to_doom->Doom();\n   }""}","void MemBackendImpl::EvictIfNeeded() {
  if (current_size_ <= max_size_)
    return;

  int target_size = std::max(0, max_size_ - kDefaultEvictionSize);

   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();
   while (current_size_ > target_size && entry != lru_list_.end()) {
     MemEntryImpl* to_doom = entry->value();

    do {
      entry = entry->next();
      // It's possible that entry now points to a child of to_doom, and the
      // parent is about to be deleted. Skip past any child entries.
    } while (entry != lru_list_.end() && entry->value()->parent() == to_doom);

     if (!to_doom->InUse())
       to_doom->Doom();
   }
}
","void MemBackendImpl::EvictIfNeeded() {
  if (current_size_ <= max_size_)
    return;

  int target_size = std::max(0, max_size_ - kDefaultEvictionSize);

   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();
   while (current_size_ > target_size && entry != lru_list_.end()) {
     MemEntryImpl* to_doom = entry->value();
    entry = entry->next();
     if (!to_doom->InUse())
       to_doom->Doom();
   }
}
",C,"
    do {
      entry = entry->next();
      // It's possible that entry now points to a child of to_doom, and the
      // parent is about to be deleted. Skip past any child entries.
    } while (entry != lru_list_.end() && entry->value()->parent() == to_doom);

","    entry = entry->next();
",,"@@ -332,7 +332,13 @@ void MemBackendImpl::EvictIfNeeded() {
   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();
   while (current_size_ > target_size && entry != lru_list_.end()) {
     MemEntryImpl* to_doom = entry->value();
-    entry = entry->next();
+
+    do {
+      entry = entry->next();
+      // It's possible that entry now points to a child of to_doom, and the
+      // parent is about to be deleted. Skip past any child entries.
+    } while (entry != lru_list_.end() && entry->value()->parent() == to_doom);
+
     if (!to_doom->InUse())
       to_doom->Doom();
   }",Chrome,c9d673b54832afde658f214d7da7d0453fa89774,db579a7be98ed19502005f8ff27bce942cf393d4,1,"void MemBackendImpl::EvictIfNeeded() {
  if (current_size_ <= max_size_)
    return;

  int target_size = std::max(0, max_size_ - kDefaultEvictionSize);

   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();
   while (current_size_ > target_size && entry != lru_list_.end()) {
     MemEntryImpl* to_doom = entry->value();
//flaw_line_below:
    entry = entry->next();
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    do {
//fix_flaw_line_below:
//      entry = entry->next();
//fix_flaw_line_below:
//      // It's possible that entry now points to a child of to_doom, and the
//fix_flaw_line_below:
//      // parent is about to be deleted. Skip past any child entries.
//fix_flaw_line_below:
//    } while (entry != lru_list_.end() && entry->value()->parent() == to_doom);
//fix_flaw_line_below:
//
     if (!to_doom->InUse())
       to_doom->Doom();
   }
}
",186677,"void MemBackendImpl::EvictIfNeeded() {
  if (current_size_ <= max_size_)
    return;

  int target_size = std::max(0, max_size_ - kDefaultEvictionSize);

   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();
   while (current_size_ > target_size && entry != lru_list_.end()) {
     MemEntryImpl* to_doom = entry->value();
    entry = entry->next();
     if (!to_doom->InUse())
       to_doom->Doom();
   }
}
","void MemBackendImpl::EvictIfNeeded() {
  if (current_size_ <= max_size_)
    return;

  int target_size = std::max(0, max_size_ - kDefaultEvictionSize);

   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();
   while (current_size_ > target_size && entry != lru_list_.end()) {
     MemEntryImpl* to_doom = entry->value();

    do {
      entry = entry->next();
      // It's possible that entry now points to a child of to_doom, and the
      // parent is about to be deleted. Skip past any child entries.
    } while (entry != lru_list_.end() && entry->value()->parent() == to_doom);

     if (!to_doom->InUse())
       to_doom->Doom();
   }
}
","The `EvictIfNeeded` function in the `MemBackendImpl` class manages memory eviction to maintain the current size of memory usage within a specified limit. It first checks if the current memory size exceeds the maximum allowed size; if not, it exits early. If eviction is necessary, it calculates a target size by subtracting a default eviction size from the maximum size. The function then iterates through a least recently used (LRU) list of memory entries, evicting (or ""dooming"") entries that are not in use until the current size is reduced to the target size, ensuring efficient memory management.","The provided code implements a memory management function that ensures the current memory usage does not exceed a predefined limit. It first checks if the current usage is within acceptable bounds; if so, it terminates without making changes. If the usage exceeds the limit, it calculates a target size for memory usage. The function then traverses a list of memory entries, removing those that are not actively in use until the memory usage is reduced to the target size. This process helps maintain efficient memory utilization by evicting less important data when necessary.","The vulnerability in the original code arose from the potential for reanalyzing a previously doomed entry while iterating through the least recently used (LRU) list. Specifically, when an entry was marked for eviction, the iteration could inadvertently point to a child of that doomed entry, leading to incorrect behavior or double eviction attempts. The fix implemented in the updated code introduces a loop that skips over any child entries of the doomed entry, ensuring that the iteration only processes valid entries. This change prevents the reanalysis of doomed entries, thereby enhancing the robustness of the eviction process.","The vulnerability in the original code stemmed from the risk of reanalyzing entries that had already been marked for eviction during the iteration process. This could lead to unintended behavior, such as attempting to evict an entry multiple times or processing entries that should no longer be considered. The fix addressed this issue by introducing a mechanism to skip over any child entries of a doomed entry during iteration. This adjustment ensures that the iteration only continues with valid entries, thereby preventing the reanalysis of already doomed entries and enhancing the overall integrity of the eviction process.","The vulnerability was fixed by adding a loop that checks for child entries of a doomed entry during the iteration through the least recently used (LRU) list. Specifically, after retrieving the entry to be evicted, the code now includes a `do-while` loop that advances the iterator to skip any child entries associated with the doomed entry. This ensures that if the current entry points to a child of the doomed entry, it will continue iterating until it finds a valid entry that is not a child. This change effectively prevents the reanalysis of previously doomed entries, enhancing the eviction process's reliability.","The vulnerability was fixed by implementing a mechanism that skips over any child entries of an already doomed entry during the iteration process. This adjustment ensures that when an entry is marked for eviction, the iteration does not inadvertently point to its child entries, which could lead to incorrect processing or double eviction attempts. By introducing a loop that checks for and bypasses these child entries, the code maintains the integrity of the eviction process, ensuring that only valid, non-doomed entries are considered for eviction, thereby enhancing overall reliability and correctness.","CWE-404, CWE-416, CWE-415, CWE-672, CWE-825, CWE-459, CWE-460, CWE-674, CWE-911, CWE-911",N,-1
76,76,186772,186772,,Remote,Not required,Partial,CVE-2018-6060,https://www.cvedetails.com/cve/CVE-2018-6060/,CWE-416,Medium,Partial,Partial,,2018-11-14,6.8,Use after free in WebAudio in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.,2018-12-21,,1,https://github.com/chromium/chromium/commit/fd6a5115103b3e6a52ce15858c5ad4956df29300,fd6a5115103b3e6a52ce15858c5ad4956df29300,"Revert ""Keep AudioHandlers alive until they can be safely deleted.""

This reverts commit 071df33edf2c8b4375fa432a83953359f93ea9e4.

Reason for revert:
This CL seems to cause an AudioNode leak on the Linux leak bot.
The log is:
https://ci.chromium.org/buildbot/chromium.webkit/WebKit%20Linux%20Trusty%20Leak/14252
* webaudio/AudioNode/audionode-connect-method-chaining.html
* webaudio/Panner/pannernode-basic.html
* webaudio/dom-exceptions.html

Original change's description:
> Keep AudioHandlers alive until they can be safely deleted.
> 
> When an AudioNode is disposed, the handler is also disposed.  But add
> the handler to the orphan list so that the handler stays alive until
> the context can safely delete it.  If we don't do this, the handler
> may get deleted while the audio thread is processing the handler (due
> to, say, channel count changes and such).
> 
> For an realtime context, always save the handler just in case the
> audio thread is running after the context is marked as closed (because
> the audio thread doesn't instantly stop when requested).
> 
> For an offline context, only need to do this when the context is
> running because the context is guaranteed to be stopped if we're not
> in the running state.  Hence, there's no possibility of deleting the
> handler while the graph is running.
> 
> This is a revert of
> https://chromium-review.googlesource.com/c/chromium/src/+/860779, with
> a fix for the leak.
> 
> Bug: 780919
> Change-Id: Ifb6b5fcf3fbc373f5779256688731245771da33c
> Reviewed-on: https://chromium-review.googlesource.com/862723
> Reviewed-by: Hongchan Choi <hongchan@chromium.org>
> Commit-Queue: Raymond Toy <rtoy@chromium.org>
> Cr-Commit-Position: refs/heads/master@{#528829}

TBR=rtoy@chromium.org,hongchan@chromium.org

Change-Id: Ibf406bf6ed34ea1f03e86a64a1e5ba6de0970c6f
No-Presubmit: true
No-Tree-Checks: true
No-Try: true
Bug: 780919
Reviewed-on: https://chromium-review.googlesource.com/863402
Reviewed-by: Taiju Tsuiki <tzik@chromium.org>
Commit-Queue: Taiju Tsuiki <tzik@chromium.org>
Cr-Commit-Position: refs/heads/master@{#528888}",6,third_party/WebKit/Source/modules/webaudio/AudioNode.cpp,"{""sha"": ""a5caec8a5f19a463bdfb99754eaf193a757ea4f0"", ""filename"": ""third_party/WebKit/Source/modules/webaudio/AudioNode.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 16, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/fd6a5115103b3e6a52ce15858c5ad4956df29300/third_party/WebKit/Source/modules/webaudio/AudioNode.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fd6a5115103b3e6a52ce15858c5ad4956df29300/third_party/WebKit/Source/modules/webaudio/AudioNode.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/webaudio/AudioNode.cpp?ref=fd6a5115103b3e6a52ce15858c5ad4956df29300"", ""patch"": ""@@ -542,24 +542,9 @@ void AudioNode::Dispose() {\n #endif\n   BaseAudioContext::GraphAutoLocker locker(context());\n   Handler().Dispose();\n-\n-  if (context()->HasRealtimeConstraint()) {\n-    // Always add the handler to the orphan list because the audio\n-    // thread could still be running (for a short time) even when the\n-    // context is closed.  These will get cleaned up in the post\n-    // render task if audio thread is running or when the context is\n-    // colleced (in the worst case).\n+  if (context()->ContextState() == BaseAudioContext::kRunning) {\n     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(\n         std::move(handler_));\n-  } else {\n-    // For an offline context, only need to save the handler when the\n-    // context is running.  The change in the context state is\n-    // synchronous with the main thread (even though the offline\n-    // thread is not synchronized to the main thread).\n-    if (context()->ContextState() == BaseAudioContext::kRunning) {\n-      context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(\n-          std::move(handler_));\n-    }\n   }\n }\n ""}","void AudioNode::Dispose() {
  DCHECK(IsMainThread());
#if DEBUG_AUDIONODE_REFERENCES
  fprintf(stderr, ""[%16p]: %16p: %2d: AudioNode::dispose %16p\n"", context(),
          this, Handler().GetNodeType(), handler_.get());
 #endif
   BaseAudioContext::GraphAutoLocker locker(context());
   Handler().Dispose();
  if (context()->ContextState() == BaseAudioContext::kRunning) {
     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
         std::move(handler_));
   }
 }
","void AudioNode::Dispose() {
  DCHECK(IsMainThread());
#if DEBUG_AUDIONODE_REFERENCES
  fprintf(stderr, ""[%16p]: %16p: %2d: AudioNode::dispose %16p\n"", context(),
          this, Handler().GetNodeType(), handler_.get());
 #endif
   BaseAudioContext::GraphAutoLocker locker(context());
   Handler().Dispose();
  if (context()->HasRealtimeConstraint()) {
     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
         std::move(handler_));
  } else {
    if (context()->ContextState() == BaseAudioContext::kRunning) {
      context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
          std::move(handler_));
    }
   }
 }
",C,"  if (context()->ContextState() == BaseAudioContext::kRunning) {
","  if (context()->HasRealtimeConstraint()) {
  } else {
    if (context()->ContextState() == BaseAudioContext::kRunning) {
      context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
          std::move(handler_));
    }
",,"@@ -542,24 +542,9 @@ void AudioNode::Dispose() {
 #endif
   BaseAudioContext::GraphAutoLocker locker(context());
   Handler().Dispose();
-
-  if (context()->HasRealtimeConstraint()) {
-    // Always add the handler to the orphan list because the audio
-    // thread could still be running (for a short time) even when the
-    // context is closed.  These will get cleaned up in the post
-    // render task if audio thread is running or when the context is
-    // colleced (in the worst case).
+  if (context()->ContextState() == BaseAudioContext::kRunning) {
     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
         std::move(handler_));
-  } else {
-    // For an offline context, only need to save the handler when the
-    // context is running.  The change in the context state is
-    // synchronous with the main thread (even though the offline
-    // thread is not synchronized to the main thread).
-    if (context()->ContextState() == BaseAudioContext::kRunning) {
-      context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
-          std::move(handler_));
-    }
   }
 }
 ",Chrome,fd6a5115103b3e6a52ce15858c5ad4956df29300,85d6fbb387514e6cc81fabb6ef2e61f7d879566e,1,"void AudioNode::Dispose() {
  DCHECK(IsMainThread());
#if DEBUG_AUDIONODE_REFERENCES
  fprintf(stderr, ""[%16p]: %16p: %2d: AudioNode::dispose %16p\n"", context(),
          this, Handler().GetNodeType(), handler_.get());
 #endif
   BaseAudioContext::GraphAutoLocker locker(context());
   Handler().Dispose();
//flaw_line_below:

//flaw_line_below:
  if (context()->HasRealtimeConstraint()) {
//flaw_line_below:
    // Always add the handler to the orphan list because the audio
//flaw_line_below:
    // thread could still be running (for a short time) even when the
//flaw_line_below:
    // context is closed.  These will get cleaned up in the post
//flaw_line_below:
    // render task if audio thread is running or when the context is
//flaw_line_below:
    // colleced (in the worst case).
//fix_flaw_line_below:
//  if (context()->ContextState() == BaseAudioContext::kRunning) {
     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
         std::move(handler_));
//flaw_line_below:
  } else {
//flaw_line_below:
    // For an offline context, only need to save the handler when the
//flaw_line_below:
    // context is running.  The change in the context state is
//flaw_line_below:
    // synchronous with the main thread (even though the offline
//flaw_line_below:
    // thread is not synchronized to the main thread).
//flaw_line_below:
    if (context()->ContextState() == BaseAudioContext::kRunning) {
//flaw_line_below:
      context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
//flaw_line_below:
          std::move(handler_));
//flaw_line_below:
    }
   }
 }
",186772,"void AudioNode::Dispose() {
  DCHECK(IsMainThread());
#if DEBUG_AUDIONODE_REFERENCES
  fprintf(stderr, ""[%16p]: %16p: %2d: AudioNode::dispose %16p\n"", context(),
          this, Handler().GetNodeType(), handler_.get());
 #endif
   BaseAudioContext::GraphAutoLocker locker(context());
   Handler().Dispose();
  if (context()->HasRealtimeConstraint()) {
     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
         std::move(handler_));
  } else {
    if (context()->ContextState() == BaseAudioContext::kRunning) {
      context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
          std::move(handler_));
    }
   }
 }
","void AudioNode::Dispose() {
  DCHECK(IsMainThread());
#if DEBUG_AUDIONODE_REFERENCES
  fprintf(stderr, ""[%16p]: %16p: %2d: AudioNode::dispose %16p\n"", context(),
          this, Handler().GetNodeType(), handler_.get());
 #endif
   BaseAudioContext::GraphAutoLocker locker(context());
   Handler().Dispose();
  if (context()->ContextState() == BaseAudioContext::kRunning) {
     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
         std::move(handler_));
   }
 }
","The `AudioNode::Dispose` function is responsible for cleaning up an audio node in a multimedia context. It first checks that the function is being executed on the main thread and, if in debug mode, logs relevant information about the audio node. It then acquires a lock on the audio context's graph to ensure thread safety during disposal. The function calls the `Dispose` method on the node's handler, and depending on whether the audio context has a real-time constraint or is in a running state, it adds the handler to a deferred task handler for further processing, effectively managing resources and preventing memory leaks.","The provided code defines a method that manages the cleanup of an audio processing component within a multimedia framework. It ensures that the method is executed on the main thread and logs relevant information for debugging purposes. The method acquires a lock to maintain thread safety during the cleanup process. It then invokes a disposal routine on the component's handler. Depending on specific conditions related to the audio context's state, it schedules the handler for deferred processing, effectively managing resources and preventing potential memory leaks while ensuring proper handling of audio tasks.","The vulnerability in the original code stemmed from the improper management of audio handlers during the disposal of an audio node, which could lead to memory leaks. Specifically, the code kept the handler alive by adding it to an orphan list, but this approach failed to ensure that the handler was safely deleted after the audio thread finished processing, resulting in leaks on certain platforms. The fix involved reverting this change, thereby removing the orphan handling logic and ensuring that the handler is only added to the deferred task handler when the audio context is in a running state, thus preventing premature deletion and potential leaks.","The vulnerability in the original code arose from the approach of keeping audio handlers alive by adding them to an orphan list during the disposal of an audio node. This method inadvertently led to memory leaks, particularly on certain platforms, as it did not guarantee that the handlers would be safely deleted after the audio thread finished processing. The fix involved reverting this change, which eliminated the orphan handling logic and ensured that handlers were only retained under specific conditions, thereby preventing premature deletion and effectively addressing the memory leak issue.","The vulnerability was fixed by reverting the previous change that kept audio handlers alive by adding them to an orphan list. In the updated code, the logic was simplified to only add the handler to the deferred task handler when the audio context's state is running. This change ensures that handlers are not unnecessarily retained, thus preventing memory leaks. By removing the orphan list management, the code now guarantees that handlers are disposed of correctly without risking their deletion while the audio thread is still processing, thereby enhancing resource management and stability within the audio processing framework.","The vulnerability was fixed by reverting the previous approach that retained audio handlers in an orphan list during the disposal process. The updated code now simplifies the management of these handlers by ensuring they are only retained under specific conditions related to the state of the audio context. This change eliminates unnecessary retention of handlers, thereby preventing memory leaks. By focusing on proper disposal without the risk of premature deletion while processing, the fix enhances resource management and stability within the audio processing framework, ensuring that handlers are managed more effectively.","CWE-401, CWE-459, CWE-404, CWE-772, CWE-775, CWE-400, CWE-415, CWE-911, CWE-226, CWE-673",N,-1
77,77,186901,186901,,Remote,Not required,Partial,CVE-2017-15411,https://www.cvedetails.com/cve/CVE-2017-15411/,CWE-416,Medium,Partial,Partial,,2018-08-28,6.8,Use after free in PDFium in Google Chrome prior to 63.0.3239.84 allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file.,2018-10-30,,1,https://github.com/chromium/chromium/commit/9d81094d7b0bfc8be6bba2f5084e790677e527c8,9d81094d7b0bfc8be6bba2f5084e790677e527c8,"[Reland #1] Add Android OOP HP end-to-end tests.

The original CL added a javatest and its dependencies to the apk_under_test.
This causes the dependencies to be stripped from the instrumentation_apk, which
causes issue. This CL updates the build configuration so that the javatest and
its dependencies are only added to the instrumentation_apk.

This is a reland of e0b4355f0651adb1ebc2c513dc4410471af712f5
Original change's description:
> Add Android OOP HP end-to-end tests.
>
> This CL has three components:
>   1) The bulk of the logic in OOP HP was refactored into ProfilingTestDriver.
>   2) Adds a java instrumentation test, along with a JNI shim that forwards into
>   ProfilingTestDriver.
>   3) Creates a new apk: chrome_public_apk_for_test that contains the same
>   content as chrome_public_apk, as well as native files needed for (2).
>   chrome_public_apk_test now targets chrome_public_apk_for_test instead of
>   chrome_public_apk.
>
> Other ideas, discarded:
>   * Originally, I attempted to make the browser_tests target runnable on
>   Android. The primary problem is that native test harness cannot fork
>   or spawn processes. This is difficult to solve.
>
> More details on each of the components:
> (1) ProfilingTestDriver
>   * The TracingController test was migrated to use ProfilingTestDriver, but the
>   write-to-file test was left as-is. The latter behavior will likely be phased
>   out, but I'll clean that up in a future CL.
>   * gtest isn't supported for Android instrumentation tests. ProfilingTestDriver
>   has a single function RunTest that returns a 'bool' indicating success. On
>   failure, the class uses LOG(ERROR) to print the nature of the error. This will
>   cause the error to be printed out on browser_test error. On instrumentation
>   test failure, the error will be forwarded to logcat, which is available on all
>   infra bot test runs.
> (2) Instrumentation test
>   * For now, I only added a single test for the ""browser"" mode. Furthermore, I'm
>   only testing the start with command-line path.
> (3) New apk
>   * libchromefortest is a new shared library that contains all content from
>   libchrome, but also contains native sources for the JNI shim.
>   * chrome_public_apk_for_test is a new apk that contains all content from
>   chrome_public_apk, but uses a single shared library libchromefortest rather
>   than libchrome. This also contains java sources for the JNI shim.
>   * There is no way to just add a second shared library to chrome_public_apk
>   that just contains the native sources from the JNI shim without causing ODR
>   issues.
>   * chrome_public_test_apk now has apk_under_test = chrome_public_apk_for_test.
>   * There is no way to add native JNI sources as a shared library to
>   chrome_public_test_apk without causing ODR issues.
>
> Finally, this CL drastically increases the timeout to wait for native
> initialization. The previous timeout was 2 *
> CriteriaHelper.DEFAULT_MAX_TIME_TO_POLL, which flakily failed for this test.
> This suggests that this step/timeout is generally flaky. I increased the timeout
> to 20 * CriteriaHelper.DEFAULT_MAX_TIME_TO_POLL.
>
> Bug: 753218
> Change-Id: Ic224b7314fff57f1770a4048aa5753f54e040b55
> Reviewed-on: https://chromium-review.googlesource.com/770148
> Commit-Queue: Erik Chen <erikchen@chromium.org>
> Reviewed-by: John Budorick <jbudorick@chromium.org>
> Reviewed-by: Brett Wilson <brettw@chromium.org>
> Cr-Commit-Position: refs/heads/master@{#517541}

Bug: 753218
TBR: brettw@chromium.org
Change-Id: Ic6aafb34c2467253f75cc85da48200d19f3bc9af
Reviewed-on: https://chromium-review.googlesource.com/777697
Commit-Queue: Erik Chen <erikchen@chromium.org>
Reviewed-by: John Budorick <jbudorick@chromium.org>
Cr-Commit-Position: refs/heads/master@{#517850}",12,chrome/browser/profiling_host/profiling_process_host.cc,"{""sha"": ""bf2e946584796934c88c495d3915d6ebfbb742d7"", ""filename"": ""chrome/android/BUILD.gn"", ""status"": ""modified"", ""additions"": 74, ""deletions"": 26, ""changes"": 100, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/android/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/android/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/BUILD.gn?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -727,39 +727,68 @@ jinja_template_resources(\""chrome_sync_shell_apk_template_resources\"") {\n   variables = chrome_sync_shell_jinja_variables\n }\n \n-shared_library(\""libchrome\"") {\n+# This template contains common code for both libchrome and libchromefortest.\n+# The former is used in chrome_public_apk. The latter is used in\n+# chrome_public_apk_for_test. The distinction is necessary because the latter\n+# requires additional native sources for JNI shims only used by tests.\n+template(\""chrome_shared_library\"") {\n+  shared_library(target_name) {\n+    forward_variables_from(invoker, \""*\"")\n+\n+    deps += [\n+      \""//build/config:exe_and_shlib_deps\"",\n+      \""//chrome:chrome_android_core\"",\n+    ]\n+\n+    if (enable_vr) {\n+      # Ensure libgvr static library appears before gcc library in linking order.\n+      # See https://crbug.com/704305 for details.\n+      libs = [ \""//third_party/gvr-android-sdk/libgvr_shim_static_${current_cpu}.a\"" ]\n+    }\n+\n+    if (use_order_profiling) {\n+      deps += [ \""//tools/cygprofile\"" ]\n+    }\n+\n+    # See crbug.com/705088, crbug.com/717815.\n+    if (target_cpu == \""arm\"" && (is_asan || use_order_profiling)) {\n+      ldflags = [ \""-Wl,--long-plt\"" ]\n+    }\n+\n+    if (chromium_linker_supported && use_lld) {\n+      configs += [ \""//build/config/android:lld_pack_relocations\"" ]\n+    }\n+\n+    public_configs = extra_chrome_shared_library_configs\n+    deps += extra_chrome_shared_library_deps\n+  }\n+}\n+\n+chrome_shared_library(\""libchrome\"") {\n   sources = [\n     \""../app/android/chrome_main_delegate_android_initializer.cc\"",\n     \""../browser/android/chrome_entry_point.cc\"",\n   ]\n   deps = [\n     \"":chrome_jni_registration($default_toolchain)\"",\n-    \""//build/config:exe_and_shlib_deps\"",\n-    \""//chrome:chrome_android_core\"",\n   ]\n+}\n \n-  if (enable_vr) {\n-    # Ensure libgvr static library appears before gcc library in linking order.\n-    # See https://crbug.com/704305 for details.\n-    libs =\n-        [ \""//third_party/gvr-android-sdk/libgvr_shim_static_${current_cpu}.a\"" ]\n-  }\n-\n-  if (use_order_profiling) {\n-    deps += [ \""//tools/cygprofile\"" ]\n-  }\n-\n-  # See crbug.com/705088, crbug.com/717815.\n-  if (target_cpu == \""arm\"" && (is_asan || use_order_profiling)) {\n-    ldflags = [ \""-Wl,--long-plt\"" ]\n-  }\n-\n-  if (chromium_linker_supported && use_lld) {\n-    configs += [ \""//build/config/android:lld_pack_relocations\"" ]\n-  }\n-\n-  public_configs = extra_chrome_shared_library_configs\n-  deps += extra_chrome_shared_library_deps\n+chrome_shared_library(\""libchromefortest\"") {\n+  testonly = true\n+  sources = [\n+    \""../app/android/chrome_main_delegate_android_initializer.cc\"",\n+    \""../browser/android/chrome_entry_point_for_test.cc\"",\n+    \""../browser/profiling_host/profiling_test_driver.cc\"",\n+    \""../browser/profiling_host/profiling_test_driver.h\"",\n+    \""../browser/profiling_host/test_android_shim.cc\"",\n+    \""../browser/profiling_host/test_android_shim.h\"",\n+  ]\n+  deps = [\n+    \"":chrome_jni_for_test_registration($default_toolchain)\"",\n+    \""//base/test:test_support\"",\n+    \""//chrome/browser/profiling_host:jni_headers\"",\n+  ]\n }\n \n # Ensure that .pak files are built only once (build them in the default\n@@ -772,6 +801,13 @@ if (current_toolchain == default_toolchain) {\n     exception_files = jni_exception_files\n   }\n \n+  generate_jni_registration(\""chrome_jni_for_test_registration\"") {\n+    testonly = true\n+    target = \"":chrome_public_apk_for_test\""\n+    output = \""$root_gen_dir/chrome/browser/android/${target_name}.h\""\n+    exception_files = jni_exception_files\n+  }\n+\n   generate_jni_registration(\""chrome_sync_shell_jni_registration\"") {\n     testonly = true\n     target = \"":chrome_sync_shell_apk\""\n@@ -996,6 +1032,17 @@ chrome_public_apk_tmpl_shared(\""chrome_public_apk\"") {\n   shared_libraries = [ \"":libchrome\"" ]\n }\n \n+chrome_public_apk_tmpl_shared(\""chrome_public_apk_for_test\"") {\n+  testonly = true\n+  android_manifest = chrome_public_android_manifest\n+  android_manifest_dep = \"":chrome_public_android_manifest\""\n+  apk_name = \""ChromePublicForTest\""\n+  shared_libraries = [ \"":libchromefortest\"" ]\n+  deps = [\n+    \""//chrome/browser/profiling_host:profiling_host_java_test_support\"",\n+  ]\n+}\n+\n chrome_public_apk_tmpl_shared(\""chrome_modern_public_apk\"") {\n   android_manifest = chrome_modern_public_android_manifest\n   android_manifest_dep = \"":chrome_modern_public_android_manifest\""\n@@ -1090,7 +1137,7 @@ jinja_template(\""chrome_sync_shell_test_apk_manifest\"") {\n \n instrumentation_test_apk(\""chrome_public_test_apk\"") {\n   apk_name = \""ChromePublicTest\""\n-  apk_under_test = \"":chrome_public_apk\""\n+  apk_under_test = \"":chrome_public_apk_for_test\""\n   android_manifest = chrome_public_test_apk_manifest\n   android_manifest_dep = \"":chrome_public_test_apk_manifest\""\n \n@@ -1099,6 +1146,7 @@ instrumentation_test_apk(\""chrome_public_test_apk\"") {\n     \""//chrome/android/webapk/libs/runtime_library:runtime_library_javatests\"",\n     \""//chrome/android/webapk/shell_apk:shell_apk_javatests\"",\n     \""//chrome/android/webapk/shell_apk:webapk_javatests\"",\n+    \""//chrome/browser/profiling_host:profiling_host_javatests\"",\n     \""//third_party/android_support_test_runner:runner_java\"",\n   ]\n   additional_apks = [""}<_**next**_>{""sha"": ""99a54e93f91b79715a86f47b38d9a116d5dcec3f"", ""filename"": ""chrome/android/javatests/src/org/chromium/chrome/browser/profiling_host/ProfilingProcessHostAndroidTest.java"", ""status"": ""added"", ""additions"": 45, ""deletions"": 0, ""changes"": 45, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/android/javatests/src/org/chromium/chrome/browser/profiling_host/ProfilingProcessHostAndroidTest.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/android/javatests/src/org/chromium/chrome/browser/profiling_host/ProfilingProcessHostAndroidTest.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/javatests/src/org/chromium/chrome/browser/profiling_host/ProfilingProcessHostAndroidTest.java?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -0,0 +1,45 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium.chrome.browser.profiling_host;\n+\n+import android.support.test.filters.MediumTest;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.chromium.base.test.util.CommandLineFlags;\n+import org.chromium.chrome.browser.ChromeActivity;\n+import org.chromium.chrome.browser.ChromeSwitches;\n+import org.chromium.chrome.test.ChromeActivityTestRule;\n+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;\n+\n+/**\n+ * Test suite for out of process heap profiling.\n+ */\n+@RunWith(ChromeJUnit4ClassRunner.class)\n+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE,\n+        ChromeActivityTestRule.DISABLE_NETWORK_PREDICTION_FLAG})\n+public class ProfilingProcessHostAndroidTest {\n+    private static final String TAG = \""ProfilingProcessHostAndroidTest\"";\n+    @Rule\n+    public ChromeActivityTestRule<ChromeActivity> mActivityTestRule =\n+            new ChromeActivityTestRule<>(ChromeActivity.class);\n+\n+    @Before\n+    public void setUp() throws InterruptedException {\n+        mActivityTestRule.startMainActivityOnBlankPage();\n+    }\n+\n+    @Test\n+    @MediumTest\n+    @CommandLineFlags.Add({\""memlog=browser\""})\n+    public void testModeBrowser() throws Exception {\n+        TestAndroidShim profilingProcessHost = new TestAndroidShim();\n+        Assert.assertTrue(profilingProcessHost.runTestForMode(\""browser\""));\n+    }\n+}""}<_**next**_>{""sha"": ""8679d6fd3240a217e99c4b4641fbd1a9bd11a31d"", ""filename"": ""chrome/android/javatests/src/org/chromium/chrome/browser/profiling_host/TestAndroidShim.java"", ""status"": ""added"", ""additions"": 38, ""deletions"": 0, ""changes"": 38, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/android/javatests/src/org/chromium/chrome/browser/profiling_host/TestAndroidShim.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/android/javatests/src/org/chromium/chrome/browser/profiling_host/TestAndroidShim.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/javatests/src/org/chromium/chrome/browser/profiling_host/TestAndroidShim.java?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -0,0 +1,38 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+package org.chromium.chrome.browser.profiling_host;\n+\n+import org.chromium.base.annotations.MainDex;\n+\n+/**\n+ * Provides direct access to test_android_shim, which in turn forwards to\n+ * ProfilingTestDriver. Only used for testing.\n+ */\n+@MainDex\n+public class TestAndroidShim {\n+    public TestAndroidShim() {\n+        mNativeTestAndroidShim = nativeInit();\n+    }\n+\n+    public boolean runTestForMode(String mode) {\n+        return nativeRunTestForMode(mNativeTestAndroidShim, mode);\n+    }\n+\n+    /**\n+     * Clean up the C++ side of this class.\n+     * After the call, this class instance shouldn't be used.\n+     */\n+    public void destroy() {\n+        if (mNativeTestAndroidShim != 0) {\n+            nativeDestroy(mNativeTestAndroidShim);\n+            mNativeTestAndroidShim = 0;\n+        }\n+    }\n+\n+    private long mNativeTestAndroidShim;\n+    private native long nativeInit();\n+    private native void nativeDestroy(long nativeTestAndroidShim);\n+    private native boolean nativeRunTestForMode(long nativeTestAndroidShim, String mode);\n+}""}<_**next**_>{""sha"": ""1eb8e02b99e9bfe3bd64ebc1030794f2f0c9ba62"", ""filename"": ""chrome/browser/android/chrome_entry_point_for_test.cc"", ""status"": ""added"", ""additions"": 43, ""deletions"": 0, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/android/chrome_entry_point_for_test.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/android/chrome_entry_point_for_test.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/chrome_entry_point_for_test.cc?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -0,0 +1,43 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""base/android/jni_android.h\""\n+#include \""base/android/jni_utils.h\""\n+#include \""base/android/library_loader/library_loader_hooks.h\""\n+#include \""base/bind.h\""\n+#include \""base/test/test_support_android.h\""\n+#include \""chrome/app/android/chrome_jni_onload.h\""\n+#include \""chrome/browser/android/chrome_jni_for_test_registration.h\""\n+\n+namespace {\n+\n+bool NativeInit() {\n+  return android::OnJNIOnLoadInit();\n+}\n+\n+}  // namespace\n+\n+// This is called by the VM when the shared library is first loaded.\n+JNI_EXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) {\n+  // By default, all JNI methods are registered. However, since render processes\n+  // don't need very much Java code, we enable selective JNI registration on the\n+  // Java side and only register a subset of JNI methods.\n+  base::android::InitVM(vm);\n+  JNIEnv* env = base::android::AttachCurrentThread();\n+\n+  if (!base::android::IsSelectiveJniRegistrationEnabled(env) &&\n+      !RegisterNonMainDexNatives(env)) {\n+    return -1;\n+  }\n+\n+  if (!RegisterMainDexNatives(env)) {\n+    return -1;\n+  }\n+\n+  if (!android::OnJNIOnLoadRegisterJNI(env)) {\n+    return -1;\n+  }\n+  base::android::SetNativeInitializationHook(NativeInit);\n+  return JNI_VERSION_1_4;\n+}""}<_**next**_>{""sha"": ""9d7dbf3ddc1b24cb886f59af4739c3fd030d2591"", ""filename"": ""chrome/browser/profiling_host/BUILD.gn"", ""status"": ""modified"", ""additions"": 41, ""deletions"": 0, ""changes"": 41, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profiling_host/BUILD.gn?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -8,6 +8,8 @@ if (!is_android) {\n \n     sources = [\n       \""memlog_browsertest.cc\"",\n+      \""profiling_test_driver.cc\"",\n+      \""profiling_test_driver.h\"",\n     ]\n \n     defines = [ \""HAS_OUT_OF_PROC_TEST_RUNNER\"" ]\n@@ -21,7 +23,46 @@ if (!is_android) {\n     ]\n   }\n } else {\n+  import(\""//build/config/android/rules.gni\"")\n+\n   # In-process browser tests aren't supported on Android.\n   group(\""profiling_browsertests\"") {\n   }\n+\n+  generate_jni(\""jni_headers\"") {\n+    sources = [\n+      \""../../android/javatests/src/org/chromium/chrome/browser/profiling_host/TestAndroidShim.java\"",\n+    ]\n+    jni_package = \""chrome_profiling_host\""\n+  }\n+\n+  # This library must be included by the apk_under_test in order for the JNI\n+  # shim to function correctly.\n+  android_library(\""profiling_host_java_test_support\"") {\n+    testonly = true\n+    java_files = [ \""../../android/javatests/src/org/chromium/chrome/browser/profiling_host/TestAndroidShim.java\"" ]\n+    deps = [\n+      \""//base:base_java\"",\n+    ]\n+  }\n+\n+  # This library must be included by the instrumentation_test. It must not be\n+  # included by the apk_under_test, since in debug builds, java classes that\n+  # appear in the apk_under_test are stripped from the instrumentation_test.\n+  # This library contains dependencies that must not be stripped from the\n+  # instrumentation_test.\n+  android_library(\""profiling_host_javatests\"") {\n+    testonly = true\n+    java_files = [ \""../../android/javatests/src/org/chromium/chrome/browser/profiling_host/ProfilingProcessHostAndroidTest.java\"" ]\n+    deps = [\n+      \"":profiling_host_java_test_support\"",\n+      \""//base:base_java\"",\n+      \""//base:base_java_test_support\"",\n+      \""//chrome/android:chrome_java\"",\n+      \""//chrome/test/android:chrome_java_test_support\"",\n+      \""//third_party/android_support_test_runner:rules_java\"",\n+      \""//third_party/android_support_test_runner:runner_java\"",\n+      \""//third_party/junit\"",\n+    ]\n+  }\n }""}<_**next**_>{""sha"": ""3fd613843960657ebcfc519e17a4ebc9a40fdf86"", ""filename"": ""chrome/browser/profiling_host/memlog_browsertest.cc"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 60, ""changes"": 70, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/memlog_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/memlog_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profiling_host/memlog_browsertest.cc?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -3,25 +3,20 @@\n // found in the LICENSE file.\n \n #include \""base/allocator/features.h\""\n-#include \""base/allocator/partition_allocator/partition_alloc.h\""\n #include \""base/json/json_reader.h\""\n-#include \""base/memory/ref_counted_memory.h\""\n-#include \""base/run_loop.h\""\n-#include \""base/task_scheduler/post_task.h\""\n #include \""base/threading/thread_restrictions.h\""\n #include \""base/trace_event/trace_buffer.h\""\n-#include \""base/trace_event/trace_config_memory_test_util.h\""\n #include \""base/trace_event/trace_log.h\""\n #include \""build/build_config.h\""\n #include \""chrome/browser/profiling_host/profiling_process_host.h\""\n+#include \""chrome/browser/profiling_host/profiling_test_driver.h\""\n #include \""chrome/browser/ui/browser.h\""\n #include \""chrome/browser/ui/tabs/tab_strip_model.h\""\n #include \""chrome/common/chrome_switches.h\""\n #include \""chrome/test/base/in_process_browser_test.h\""\n #include \""chrome/test/base/ui_test_utils.h\""\n #include \""content/public/browser/render_frame_host.h\""\n #include \""content/public/browser/render_process_host.h\""\n-#include \""content/public/browser/tracing_controller.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""content/public/test/browser_test.h\""\n #include \""net/test/embedded_test_server/embedded_test_server.h\""\n@@ -408,60 +403,15 @@ IN_PROC_BROWSER_TEST_P(MemlogBrowserTest, EndToEnd) {\n // Ensure invocations via TracingController can generate a valid JSON file with\n // expected data.\n IN_PROC_BROWSER_TEST_P(MemlogBrowserTest, TracingControllerEndToEnd) {\n-  if (!GetParam()) {\n-    // Test that nothing has been started if the flag is not passed. Then early\n-    // exit.\n-    ASSERT_FALSE(profiling::ProfilingProcessHost::has_started());\n-    return;\n-  } else {\n-    ASSERT_TRUE(profiling::ProfilingProcessHost::has_started());\n-  }\n-\n-  MakeTestAllocations();\n-\n-  base::RunLoop run_loop;\n-  scoped_refptr<base::RefCountedString> result;\n-\n-  // Once the ProfilingProcessHost has dumped to the trace, stop the trace and\n-  // collate the results into |result|, then quit the nested run loop.\n-  auto finish_sink_callback = base::Bind(\n-      [](scoped_refptr<base::RefCountedString>* result, base::Closure finished,\n-         std::unique_ptr<const base::DictionaryValue> metadata,\n-         base::RefCountedString* in) {\n-        *result = in;\n-        std::move(finished).Run();\n-      },\n-      &result, run_loop.QuitClosure());\n-  scoped_refptr<content::TracingController::TraceDataEndpoint> sink =\n-      content::TracingController::CreateStringEndpoint(\n-          std::move(finish_sink_callback));\n-  base::OnceClosure stop_tracing_closure = base::BindOnce(\n-      base::IgnoreResult<bool (content::TracingController::*)(  // NOLINT\n-          const scoped_refptr<content::TracingController::TraceDataEndpoint>&)>(\n-          &content::TracingController::StopTracing),\n-      base::Unretained(content::TracingController::GetInstance()), sink);\n-  base::OnceClosure stop_tracing_ui_thread_closure =\n-      base::BindOnce(base::IgnoreResult(&base::TaskRunner::PostTask),\n-                     base::ThreadTaskRunnerHandle::Get(), FROM_HERE,\n-                     std::move(stop_tracing_closure));\n-  profiling::ProfilingProcessHost::GetInstance()\n-      ->SetDumpProcessForTracingCallback(\n-          std::move(stop_tracing_ui_thread_closure));\n-\n-  // Spin a nested RunLoop until the heap dump has been added to the trace.\n-  content::TracingController::GetInstance()->StartTracing(\n-      base::trace_event::TraceConfig(\n-          base::trace_event::TraceConfigMemoryTestUtil::\n-              GetTraceConfig_PeriodicTriggers(100000, 100000)),\n-      base::Closure());\n-  run_loop.Run();\n-\n-  std::unique_ptr<base::Value> dump_json =\n-      base::JSONReader::Read(result->data());\n-  ASSERT_TRUE(dump_json);\n-  ValidateBrowserAllocations(dump_json.get());\n-  ValidateRendererAllocations(dump_json.get());\n-  // TODO(ajwong): Test GPU dumps  http://crbug.com/780955\n+  profiling::ProfilingTestDriver driver;\n+  profiling::ProfilingTestDriver::Options options;\n+  options.mode =\n+      GetParam()\n+          ? profiling::ProfilingProcessHost::ConvertStringToMode(GetParam())\n+          : profiling::ProfilingProcessHost::Mode::kNone;\n+  options.profiling_already_started = true;\n+\n+  EXPECT_TRUE(driver.RunTest(options));\n }\n \n // TODO(ajwong): Test what happens if profiling process crashes.""}<_**next**_>{""sha"": ""bfda42d05b19d8902be350ce8257b9010eb3cbe0"", ""filename"": ""chrome/browser/profiling_host/profiling_process_host.cc"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 13, ""changes"": 32, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/profiling_process_host.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/profiling_process_host.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profiling_host/profiling_process_host.cc?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -371,19 +371,7 @@ ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {\n           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);\n     }\n \n-    if (mode == switches::kMemlogModeAll)\n-      return Mode::kAll;\n-    if (mode == switches::kMemlogModeMinimal)\n-      return Mode::kMinimal;\n-    if (mode == switches::kMemlogModeBrowser)\n-      return Mode::kBrowser;\n-    if (mode == switches::kMemlogModeGpu)\n-      return Mode::kGpu;\n-    if (mode == switches::kMemlogModeRendererSampling)\n-      return Mode::kRendererSampling;\n-\n-    DLOG(ERROR) << \""Unsupported value: \\\""\"" << mode << \""\\\"" passed to --\""\n-                << switches::kMemlog;\n+    return ConvertStringToMode(mode);\n   }\n   return Mode::kNone;\n #else\n@@ -395,6 +383,24 @@ ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {\n #endif\n }\n \n+// static\n+ProfilingProcessHost::Mode ProfilingProcessHost::ConvertStringToMode(\n+    const std::string& mode) {\n+  if (mode == switches::kMemlogModeAll)\n+    return Mode::kAll;\n+  if (mode == switches::kMemlogModeMinimal)\n+    return Mode::kMinimal;\n+  if (mode == switches::kMemlogModeBrowser)\n+    return Mode::kBrowser;\n+  if (mode == switches::kMemlogModeGpu)\n+    return Mode::kGpu;\n+  if (mode == switches::kMemlogModeRendererSampling)\n+    return Mode::kRendererSampling;\n+  DLOG(ERROR) << \""Unsupported value: \\\""\"" << mode << \""\\\"" passed to --\""\n+              << switches::kMemlog;\n+  return Mode::kNone;\n+}\n+\n // static\n ProfilingProcessHost* ProfilingProcessHost::Start(\n     content::ServiceManagerConnection* connection,""}<_**next**_>{""sha"": ""94cc7a91d5c87d5f7b29085287ccfa46f131aa10"", ""filename"": ""chrome/browser/profiling_host/profiling_process_host.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/profiling_process_host.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/profiling_process_host.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profiling_host/profiling_process_host.h?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -89,6 +89,7 @@ class ProfilingProcessHost : public content::BrowserChildProcessObserver,\n \n   // Returns the mode set on the current process' command line.\n   static Mode GetCurrentMode();\n+  static Mode ConvertStringToMode(const std::string& input);\n   bool ShouldProfileProcessType(int process_type);\n \n   // Launches the profiling process and returns a pointer to it.\n@@ -123,6 +124,7 @@ class ProfilingProcessHost : public content::BrowserChildProcessObserver,\n   friend struct base::DefaultSingletonTraits<ProfilingProcessHost>;\n   friend class BackgroundProfilingTriggersTest;\n   friend class MemlogBrowserTest;\n+  friend class ProfilingTestDriver;\n   FRIEND_TEST_ALL_PREFIXES(ProfilingProcessHost, ShouldProfileNewRenderer);\n \n   ProfilingProcessHost();""}<_**next**_>{""sha"": ""653946162cb6db49dc4504a3c1a8a3eab2ad433a"", ""filename"": ""chrome/browser/profiling_host/profiling_test_driver.cc"", ""status"": ""added"", ""additions"": 502, ""deletions"": 0, ""changes"": 502, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/profiling_test_driver.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/profiling_test_driver.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profiling_host/profiling_test_driver.cc?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -0,0 +1,502 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""chrome/browser/profiling_host/profiling_test_driver.h\""\n+\n+#include <string>\n+\n+#include \""base/bind.h\""\n+#include \""base/command_line.h\""\n+#include \""base/json/json_reader.h\""\n+#include \""base/process/process_handle.h\""\n+#include \""base/run_loop.h\""\n+#include \""base/task_scheduler/post_task.h\""\n+#include \""base/trace_event/trace_config_memory_test_util.h\""\n+#include \""base/values.h\""\n+#include \""build/build_config.h\""\n+#include \""content/public/browser/browser_thread.h\""\n+#include \""content/public/browser/tracing_controller.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n+\n+namespace profiling {\n+\n+namespace {\n+\n+// Make some specific allocations in Browser to do a deeper test of the\n+// allocation tracking.\n+constexpr int kMallocAllocSize = 7907;\n+constexpr int kMallocAllocCount = 157;\n+\n+constexpr int kVariadicAllocCount = 157;\n+\n+// Test fixed-size partition alloc. The size must be aligned to system pointer\n+// size.\n+constexpr int kPartitionAllocSize = 8 * 23;\n+constexpr int kPartitionAllocCount = 107;\n+static const char* kPartitionAllocTypeName = \""kPartitionAllocTypeName\"";\n+\n+// On success, populates |pid|.\n+int NumProcessesWithName(base::Value* dump_json, std::string name, int* pid) {\n+  int num_processes = 0;\n+  base::Value* events = dump_json->FindKey(\""traceEvents\"");\n+  for (base::Value& event : events->GetList()) {\n+    const base::Value* found_name =\n+        event.FindKeyOfType(\""name\"", base::Value::Type::STRING);\n+    if (!found_name)\n+      continue;\n+    if (found_name->GetString() != \""process_name\"")\n+      continue;\n+    const base::Value* found_args =\n+        event.FindKeyOfType(\""args\"", base::Value::Type::DICTIONARY);\n+    if (!found_args)\n+      continue;\n+    const base::Value* found_process_name =\n+        found_args->FindKeyOfType(\""name\"", base::Value::Type::STRING);\n+    if (!found_process_name)\n+      continue;\n+    if (found_process_name->GetString() != name)\n+      continue;\n+\n+    if (pid) {\n+      const base::Value* found_pid =\n+          event.FindKeyOfType(\""pid\"", base::Value::Type::INTEGER);\n+      if (!found_pid) {\n+        LOG(ERROR) << \""Process missing pid.\"";\n+        return 0;\n+      }\n+      *pid = found_pid->GetInt();\n+    }\n+\n+    ++num_processes;\n+  }\n+  return num_processes;\n+}\n+\n+base::Value* FindHeapsV2(base::ProcessId pid, base::Value* dump_json) {\n+  base::Value* events = dump_json->FindKey(\""traceEvents\"");\n+  base::Value* dumps = nullptr;\n+  base::Value* heaps_v2 = nullptr;\n+  for (base::Value& event : events->GetList()) {\n+    const base::Value* found_name =\n+        event.FindKeyOfType(\""name\"", base::Value::Type::STRING);\n+    if (!found_name)\n+      continue;\n+    if (found_name->GetString() != \""periodic_interval\"")\n+      continue;\n+    const base::Value* found_pid =\n+        event.FindKeyOfType(\""pid\"", base::Value::Type::INTEGER);\n+    if (!found_pid)\n+      continue;\n+    if (static_cast<base::ProcessId>(found_pid->GetInt()) != pid)\n+      continue;\n+    dumps = &event;\n+    heaps_v2 = dumps->FindPath({\""args\"", \""dumps\"", \""heaps_v2\""});\n+    if (heaps_v2)\n+      return heaps_v2;\n+  }\n+  return nullptr;\n+}\n+\n+// Verify expectations are present in heap dump.\n+bool ValidateDump(base::Value* heaps_v2,\n+                  int expected_alloc_size,\n+                  int expected_alloc_count,\n+                  const char* allocator_name,\n+                  const char* type_name) {\n+  base::Value* sizes =\n+      heaps_v2->FindPath({\""allocators\"", allocator_name, \""sizes\""});\n+  if (!sizes) {\n+    LOG(ERROR) << \""Failed to find path: 'allocators.\"" << allocator_name\n+               << \"".sizes' in heaps v2\"";\n+    return false;\n+  }\n+\n+  const base::Value::ListStorage& sizes_list = sizes->GetList();\n+  if (sizes_list.empty()) {\n+    LOG(ERROR) << \""'allocators.\"" << allocator_name\n+               << \"".sizes' is an empty list\"";\n+    return false;\n+  }\n+\n+  base::Value* counts =\n+      heaps_v2->FindPath({\""allocators\"", allocator_name, \""counts\""});\n+  if (!counts) {\n+    LOG(ERROR) << \""Failed to find path: 'allocators.\"" << allocator_name\n+               << \"".counts' in heaps v2\"";\n+    return false;\n+  }\n+\n+  const base::Value::ListStorage& counts_list = counts->GetList();\n+  if (sizes_list.size() != counts_list.size()) {\n+    LOG(ERROR)\n+        << \""'allocators.\"" << allocator_name\n+        << \"".sizes' does not have the same number of elements as *.counts\"";\n+    return false;\n+  }\n+\n+  base::Value* types =\n+      heaps_v2->FindPath({\""allocators\"", allocator_name, \""types\""});\n+  if (!types) {\n+    LOG(ERROR) << \""Failed to find path: 'allocators.\"" << allocator_name\n+               << \"".types' in heaps v2\"";\n+    return false;\n+  }\n+\n+  const base::Value::ListStorage& types_list = types->GetList();\n+  if (types_list.empty()) {\n+    LOG(ERROR) << \""'allocators.\"" << allocator_name\n+               << \"".types' is an empty list\"";\n+    return false;\n+  }\n+\n+  if (sizes_list.size() != types_list.size()) {\n+    LOG(ERROR)\n+        << \""'allocators.\"" << allocator_name\n+        << \"".types' does not have the same number of elements as *.sizes\"";\n+    return false;\n+  }\n+\n+  bool found_browser_alloc = false;\n+  size_t browser_alloc_index = 0;\n+  for (size_t i = 0; i < sizes_list.size(); i++) {\n+    if (counts_list[i].GetInt() == expected_alloc_count &&\n+        sizes_list[i].GetInt() != expected_alloc_size) {\n+      LOG(WARNING) << \""Allocation candidate (size:\"" << sizes_list[i].GetInt()\n+                   << \"" count:\"" << counts_list[i].GetInt() << \"")\"";\n+    }\n+    if (sizes_list[i].GetInt() == expected_alloc_size &&\n+        counts_list[i].GetInt() == expected_alloc_count) {\n+      browser_alloc_index = i;\n+      found_browser_alloc = true;\n+      break;\n+    }\n+  }\n+\n+  if (!found_browser_alloc) {\n+    LOG(ERROR) << \""Failed to find an allocation of the \""\n+                  \""appropriate size. Did the send buffer \""\n+                  \""not flush? (size: \""\n+               << expected_alloc_size << \"" count:\"" << expected_alloc_count\n+               << \"")\"";\n+    return false;\n+  }\n+\n+  // Find the type, if an expectation was passed in.\n+  if (type_name) {\n+    bool found = false;\n+    int type = types_list[browser_alloc_index].GetInt();\n+    base::Value* strings = heaps_v2->FindPath({\""maps\"", \""strings\""});\n+    for (base::Value& dict : strings->GetList()) {\n+      // Each dict has the format {\""id\"":1,\""string\"":\""kPartitionAllocTypeName\""}\n+      int id = dict.FindKey(\""id\"")->GetInt();\n+      if (id == type) {\n+        found = true;\n+        std::string name = dict.FindKey(\""string\"")->GetString();\n+        if (name != type_name) {\n+          LOG(ERROR) << \""actual name: \"" << name\n+                     << \"" expected name: \"" << type_name;\n+          return false;\n+        }\n+        break;\n+      }\n+    }\n+    if (!found) {\n+      LOG(ERROR) << \""Failed to find type name string: \"" << type_name;\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+}  // namespace\n+\n+ProfilingTestDriver::ProfilingTestDriver()\n+    : wait_for_ui_thread_(base::WaitableEvent::ResetPolicy::AUTOMATIC,\n+                          base::WaitableEvent::InitialState::NOT_SIGNALED) {\n+  partition_allocator_.init();\n+}\n+ProfilingTestDriver::~ProfilingTestDriver() {}\n+\n+bool ProfilingTestDriver::RunTest(const Options& options) {\n+  options_ = options;\n+\n+  running_on_ui_thread_ =\n+      content::BrowserThread::CurrentlyOn(content::BrowserThread::UI);\n+\n+  // The only thing to test for Mode::kNone is that profiling hasn't started.\n+  if (options_.mode == ProfilingProcessHost::Mode::kNone) {\n+    if (ProfilingProcessHost::has_started()) {\n+      LOG(ERROR) << \""Profiling should not have started\"";\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  if (running_on_ui_thread_) {\n+    if (!RunInitializationOnUIThread())\n+      return false;\n+    CollectResults(true);\n+  } else {\n+    content::BrowserThread::PostTask(\n+        content::BrowserThread::UI, FROM_HERE,\n+        base::Bind(&ProfilingTestDriver::RunInitializationOnUIThreadAndSignal,\n+                   base::Unretained(this)));\n+    wait_for_ui_thread_.Wait();\n+    if (!initialization_success_)\n+      return false;\n+    content::BrowserThread::PostTask(\n+        content::BrowserThread::UI, FROM_HERE,\n+        base::Bind(&ProfilingTestDriver::CollectResults, base::Unretained(this),\n+                   false));\n+    wait_for_ui_thread_.Wait();\n+  }\n+\n+  std::unique_ptr<base::Value> dump_json =\n+      base::JSONReader::Read(serialized_trace_->data());\n+  if (!dump_json) {\n+    LOG(ERROR) << \""Failed to deserialize trace.\"";\n+    return false;\n+  }\n+\n+  if (!ValidateBrowserAllocations(dump_json.get())) {\n+    LOG(ERROR) << \""Failed to validate browser allocations\"";\n+    return false;\n+  }\n+\n+  if (!ValidateRendererAllocations(dump_json.get())) {\n+    LOG(ERROR) << \""Failed to validate renderer allocations\"";\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+void ProfilingTestDriver::RunInitializationOnUIThreadAndSignal() {\n+  DCHECK(content::BrowserThread::CurrentlyOn(content::BrowserThread::UI));\n+  initialization_success_ = RunInitializationOnUIThread();\n+  wait_for_ui_thread_.Signal();\n+}\n+\n+bool ProfilingTestDriver::RunInitializationOnUIThread() {\n+  DCHECK(content::BrowserThread::CurrentlyOn(content::BrowserThread::UI));\n+\n+  if (options_.mode == ProfilingProcessHost::Mode::kRendererSampling) {\n+    profiling::ProfilingProcessHost::GetInstance()\n+        ->SetRendererSamplingAlwaysProfileForTest();\n+  }\n+\n+  LOG(ERROR) << \""RunInitializationOnUIThread: \""\n+             << base::CommandLine::ForCurrentProcess()->GetCommandLineString();\n+  if (!CheckOrStartProfiling())\n+    return false;\n+\n+  MakeTestAllocations();\n+  return true;\n+}\n+\n+bool ProfilingTestDriver::CheckOrStartProfiling() {\n+  if (options_.profiling_already_started) {\n+    if (ProfilingProcessHost::has_started())\n+      return true;\n+    LOG(ERROR) << \""Profiling should have been started, but wasn't\"";\n+    return false;\n+  }\n+\n+  content::ServiceManagerConnection* connection =\n+      content::ServiceManagerConnection::GetForProcess();\n+  if (!connection) {\n+    LOG(ERROR) << \""A ServiceManagerConnection was not available for the \""\n+                  \""current process.\"";\n+    return false;\n+  }\n+\n+  ProfilingProcessHost::Start(connection, options_.mode);\n+  return true;\n+}\n+\n+void ProfilingTestDriver::MakeTestAllocations() {\n+  leaks_.reserve(2 * kMallocAllocCount + kPartitionAllocSize);\n+  for (int i = 0; i < kMallocAllocCount; ++i) {\n+    leaks_.push_back(new char[kMallocAllocSize]);\n+  }\n+\n+  for (int i = 0; i < kPartitionAllocCount; ++i) {\n+    leaks_.push_back(static_cast<char*>(\n+        PartitionAllocGeneric(partition_allocator_.root(), kPartitionAllocSize,\n+                              kPartitionAllocTypeName)));\n+  }\n+\n+  for (int i = 0; i < kVariadicAllocCount; ++i) {\n+    leaks_.push_back(new char[i + 8000]);  // Variadic allocation.\n+    total_variadic_allocations_ += i + 8000;\n+  }\n+\n+  // // Navigate around to force allocations in the renderer.\n+  // ASSERT_TRUE(embedded_test_server()->Start());\n+  // ui_test_utils::NavigateToURL(\n+  //     browser(), embedded_test_server()->GetURL(\""/english_page.html\""));\n+  // // Vive la France!\n+  // ui_test_utils::NavigateToURL(\n+  //     browser(), embedded_test_server()->GetURL(\""/french_page.html\""));\n+}\n+\n+void ProfilingTestDriver::CollectResults(bool synchronous) {\n+  base::Closure finish_tracing_closure;\n+  std::unique_ptr<base::RunLoop> run_loop;\n+\n+  if (synchronous) {\n+    run_loop.reset(new base::RunLoop);\n+    finish_tracing_closure = run_loop->QuitClosure();\n+  } else {\n+    finish_tracing_closure = base::Bind(&base::WaitableEvent::Signal,\n+                                        base::Unretained(&wait_for_ui_thread_));\n+  }\n+\n+  // Once the ProfilingProcessHost has dumped to the trace, stop the trace and\n+  // collate the results into |result|, then quit the nested run loop.\n+  auto finish_sink_callback = base::Bind(\n+      [](scoped_refptr<base::RefCountedString>* result, base::Closure finished,\n+         std::unique_ptr<const base::DictionaryValue> metadata,\n+         base::RefCountedString* in) {\n+        *result = in;\n+        std::move(finished).Run();\n+      },\n+      &serialized_trace_, std::move(finish_tracing_closure));\n+\n+  scoped_refptr<content::TracingController::TraceDataEndpoint> sink =\n+      content::TracingController::CreateStringEndpoint(\n+          std::move(finish_sink_callback));\n+  base::OnceClosure stop_tracing_closure = base::BindOnce(\n+      base::IgnoreResult<bool (content::TracingController::*)(  // NOLINT\n+          const scoped_refptr<content::TracingController::TraceDataEndpoint>&)>(\n+          &content::TracingController::StopTracing),\n+      base::Unretained(content::TracingController::GetInstance()), sink);\n+  base::OnceClosure stop_tracing_ui_thread_closure =\n+      base::BindOnce(base::IgnoreResult(&base::TaskRunner::PostTask),\n+                     base::ThreadTaskRunnerHandle::Get(), FROM_HERE,\n+                     std::move(stop_tracing_closure));\n+  profiling::ProfilingProcessHost::GetInstance()\n+      ->SetDumpProcessForTracingCallback(\n+          std::move(stop_tracing_ui_thread_closure));\n+\n+  // Spin a nested RunLoop until the heap dump has been added to the trace.\n+  content::TracingController::GetInstance()->StartTracing(\n+      base::trace_event::TraceConfig(\n+          base::trace_event::TraceConfigMemoryTestUtil::\n+              GetTraceConfig_PeriodicTriggers(100000, 100000)),\n+      base::Closure());\n+\n+  if (synchronous)\n+    run_loop->Run();\n+}\n+\n+bool ProfilingTestDriver::ValidateBrowserAllocations(base::Value* dump_json) {\n+  base::Value* heaps_v2 =\n+      FindHeapsV2(base::Process::Current().Pid(), dump_json);\n+\n+  if (options_.mode != ProfilingProcessHost::Mode::kAll &&\n+      options_.mode != ProfilingProcessHost::Mode::kBrowser &&\n+      options_.mode != ProfilingProcessHost::Mode::kMinimal) {\n+    if (heaps_v2) {\n+      LOG(ERROR) << \""There should be no heap dump for the browser.\"";\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  bool result = false;\n+\n+// TODO(ajwong): This step fails on Nexus 5X devices running kit-kat. It works\n+// on Nexus 5X devices running oreo. The problem is that all allocations have\n+// the same [an effectively empty] backtrace and get glommed together. More\n+// investigation is necessary. For now, I'm turning this off for Android.\n+// https://crbug.com/786450.\n+#if !defined(OS_ANDROID)\n+  result = ValidateDump(heaps_v2, kMallocAllocSize * kMallocAllocCount,\n+                        kMallocAllocCount, \""malloc\"", nullptr);\n+  if (!result) {\n+    LOG(ERROR) << \""Failed to validate malloc fixed allocations\"";\n+    return false;\n+  }\n+\n+  result = ValidateDump(heaps_v2, total_variadic_allocations_,\n+                        kVariadicAllocCount, \""malloc\"", nullptr);\n+  if (!result) {\n+    LOG(ERROR) << \""Failed to validate malloc variadic allocations\"";\n+    return false;\n+  }\n+#endif\n+\n+  // TODO(ajwong): Like malloc, all Partition-Alloc allocations get glommed\n+  // together for some Android device/OS configurations. However, since there is\n+  // only one place that uses partition alloc in the browser process [this\n+  // test], the count is still valid. This should still be made more robust by\n+  // fixing backtrace. https://crbug.com/786450.\n+  result = ValidateDump(heaps_v2, kPartitionAllocSize * kPartitionAllocCount,\n+                        kPartitionAllocCount, \""partition_alloc\"",\n+                        kPartitionAllocTypeName);\n+  if (!result) {\n+    LOG(ERROR) << \""Failed to validate PA allocations\"";\n+    return false;\n+  }\n+\n+  int process_count = NumProcessesWithName(dump_json, \""Browser\"", nullptr);\n+  if (process_count != 1) {\n+    LOG(ERROR) << \""Found \"" << process_count\n+               << \"" processes with name: Browser. Expected 1.\"";\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+bool ProfilingTestDriver::ValidateRendererAllocations(base::Value* dump_json) {\n+  int pid;\n+  bool result = NumProcessesWithName(dump_json, \""Renderer\"", &pid) == 1;\n+  if (!result) {\n+    LOG(ERROR) << \""Failed to find process with name Renderer\"";\n+    return false;\n+  }\n+\n+  base::ProcessId renderer_pid = static_cast<base::ProcessId>(pid);\n+  base::Value* heaps_v2 = FindHeapsV2(renderer_pid, dump_json);\n+  if (options_.mode == ProfilingProcessHost::Mode::kAll ||\n+      options_.mode == ProfilingProcessHost::Mode::kRendererSampling) {\n+    if (!heaps_v2) {\n+      LOG(ERROR) << \""Failed to find heaps v2 for renderer\"";\n+      return false;\n+    }\n+\n+    // ValidateDump doesn't always succeed for the renderer, since we don't do\n+    // anything to flush allocations, there are very few allocations recorded\n+    // by the heap profiler. When we do a heap dump, we prune small\n+    // allocations...and this can cause all allocations to be pruned.\n+    // ASSERT_NO_FATAL_FAILURE(ValidateDump(dump_json.get(), 0, 0));\n+  } else {\n+    if (heaps_v2) {\n+      LOG(ERROR) << \""There should be no heap dump for the renderer.\"";\n+      return false;\n+    }\n+  }\n+\n+  // RendererSampling guarantees only 1 renderer is ever sampled at a time.\n+  if (options_.mode == ProfilingProcessHost::Mode::kRendererSampling) {\n+    if (NumProcessesWithName(dump_json, \""Renderer\"", nullptr) != 1) {\n+      LOG(ERROR) << \""There should be exactly 1 renderer dump\"";\n+      return false;\n+    }\n+  } else {\n+    if (NumProcessesWithName(dump_json, \""Renderer\"", nullptr) == 0) {\n+      LOG(ERROR) << \""There should be more than 1 renderer dump\"";\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+// Attempt to dump a gpu process.\n+// TODO(ajwong): Implement this.  http://crbug.com/780955\n+\n+}  // namespace profiling""}<_**next**_>{""sha"": ""3820e2a4a60faddc815643c0c47a5c86901c69d7"", ""filename"": ""chrome/browser/profiling_host/profiling_test_driver.h"", ""status"": ""added"", ""additions"": 118, ""deletions"": 0, ""changes"": 118, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/profiling_test_driver.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/profiling_test_driver.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profiling_host/profiling_test_driver.h?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -0,0 +1,118 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef CHROME_BROWSER_PROFILING_HOST_PROFILING_TEST_DRIVER_H_\n+#define CHROME_BROWSER_PROFILING_HOST_PROFILING_TEST_DRIVER_H_\n+\n+#include <vector>\n+\n+#include \""base/allocator/partition_allocator/partition_alloc.h\""\n+#include \""base/macros.h\""\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/synchronization/waitable_event.h\""\n+#include \""chrome/browser/profiling_host/profiling_process_host.h\""\n+\n+namespace base {\n+class Value;\n+}  // namespace base\n+\n+namespace profiling {\n+\n+// This class runs tests for the profiling service, a cross-platform,\n+// multi-process component. Chrome on Android does not support browser_tests. It\n+// does support content_browsertests, but those are not multi-process tests. On\n+// Android, processes have to be started via the Activity mechanism, and the\n+// test infrastructure does not support this.\n+//\n+// To avoid test-code duplication, all tests are pulled into this class.\n+// browser_tests will directly call this class. The android\n+// chrome_public_test_apk will invoke this class via a JNI shim. Since the\n+// latter is not running within the gtest framework, this class cannot use\n+// EXPECT* and ASSERT* macros. Instead, this class will return a bool indicating\n+// success of the entire test. On failure, errors will be output via LOG(ERROR).\n+// These will show up in the browser_tests output stream, and will be captured\n+// by logcat [the Android logging facility]. The latter is already the canonical\n+// mechanism for investigating test failures.\n+//\n+// Note: Outputting to stderr will not have the desired effect, since that is\n+// not captured by logcat.\n+class ProfilingTestDriver {\n+ public:\n+  struct Options {\n+    // The profiling mode to test.\n+    ProfilingProcessHost::Mode mode;\n+\n+    // Whether the caller has already started profiling with the given mode.\n+    // TODO(erikchen): Implement and test the case where this member is false.\n+    // Starting profiling is an asynchronous operation, so this requires adding\n+    // some more plumbing. https://crbug.com/753218.\n+    bool profiling_already_started;\n+  };\n+\n+  ProfilingTestDriver();\n+  ~ProfilingTestDriver();\n+\n+  // If this is called on the content::BrowserThread::UI thread, then the\n+  // platform must support nested message loops. [This is currently not\n+  // supported on Android].\n+  //\n+  // Returns whether the test run was successful. Expectation/Assertion failures\n+  // will be printed via LOG(ERROR).\n+  bool RunTest(const Options& options);\n+\n+ private:\n+  // Populates |initialization_success_| with the result of\n+  // |RunInitializationOnUIThread|, and then signals |wait_for_ui_thread_|.\n+  void RunInitializationOnUIThreadAndSignal();\n+\n+  // Starts profiling. Makes allocations.\n+  bool RunInitializationOnUIThread();\n+\n+  // If profiling is expected to already be started, confirm it.\n+  // Otherwise, start profiling with the given mode.\n+  bool CheckOrStartProfiling();\n+\n+  // Performs allocations. These are expected to be profiled.\n+  void MakeTestAllocations();\n+\n+  // Collects a trace that contains a heap dump. The result is stored in\n+  // |serialized_trace_|.\n+  //\n+  // When |synchronous| is true, this method spins a nested message loop. When\n+  // |synchronous| is false, this method posts some tasks that will eventually\n+  // signal |wait_for_ui_thread_|.\n+  void CollectResults(bool synchronous);\n+\n+  bool ValidateBrowserAllocations(base::Value* dump_json);\n+  bool ValidateRendererAllocations(base::Value* dump_json);\n+\n+  Options options_;\n+\n+  // Allocations made by this class. Intentionally leaked, since deallocating\n+  // them would trigger a large number of IPCs, which is slow.\n+  std::vector<char*> leaks_;\n+\n+  // Sum of size of all variadic allocations.\n+  size_t total_variadic_allocations_ = 0;\n+\n+  // Use to make PA allocations, which should also be shimmed.\n+  base::PartitionAllocatorGeneric partition_allocator_;\n+\n+  // Contains nothing until |CollectResults| has been called.\n+  scoped_refptr<base::RefCountedString> serialized_trace_;\n+\n+  // Whether the test was invoked on the ui thread.\n+  bool running_on_ui_thread_ = true;\n+\n+  // Whether an error has occurred.\n+  bool initialization_success_ = false;\n+\n+  base::WaitableEvent wait_for_ui_thread_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(ProfilingTestDriver);\n+};\n+\n+}  // namespace profiling\n+\n+#endif  // CHROME_BROWSER_PROFILING_HOST_PROFILING_TEST_DRIVER_H_""}<_**next**_>{""sha"": ""1d0bcaadd1bb6aacd2203cf2579819e150e79233"", ""filename"": ""chrome/browser/profiling_host/test_android_shim.cc"", ""status"": ""added"", ""additions"": 38, ""deletions"": 0, ""changes"": 38, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/test_android_shim.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/test_android_shim.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profiling_host/test_android_shim.cc?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -0,0 +1,38 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""chrome/browser/profiling_host/test_android_shim.h\""\n+\n+#include \""base/android/jni_string.h\""\n+#include \""chrome/browser/profiling_host/profiling_process_host.h\""\n+#include \""chrome/browser/profiling_host/profiling_test_driver.h\""\n+#include \""jni/TestAndroidShim_jni.h\""\n+\n+using base::android::JavaParamRef;\n+using base::android::ScopedJavaLocalRef;\n+\n+static jlong Init(JNIEnv* env, const JavaParamRef<jobject>& obj) {\n+  TestAndroidShim* profiler = new TestAndroidShim(env, obj);\n+  return reinterpret_cast<intptr_t>(profiler);\n+}\n+\n+TestAndroidShim::TestAndroidShim(JNIEnv* env, jobject obj) {}\n+\n+TestAndroidShim::~TestAndroidShim() {}\n+\n+void TestAndroidShim::Destroy(JNIEnv* env, const JavaParamRef<jobject>& obj) {\n+  delete this;\n+}\n+\n+jboolean TestAndroidShim::RunTestForMode(\n+    JNIEnv* env,\n+    const base::android::JavaParamRef<jobject>& obj,\n+    const base::android::JavaParamRef<jstring>& mode) {\n+  profiling::ProfilingTestDriver driver;\n+  profiling::ProfilingTestDriver::Options options;\n+  options.mode = profiling::ProfilingProcessHost::ConvertStringToMode(\n+      base::android::ConvertJavaStringToUTF8(mode));\n+  options.profiling_already_started = true;\n+  return driver.RunTest(options);\n+}""}<_**next**_>{""sha"": ""de6dd736477fd6beb1a8c02c96f66333f397a932"", ""filename"": ""chrome/browser/profiling_host/test_android_shim.h"", ""status"": ""added"", ""additions"": 30, ""deletions"": 0, ""changes"": 30, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/test_android_shim.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/browser/profiling_host/test_android_shim.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profiling_host/test_android_shim.h?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -0,0 +1,30 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef CHROME_BROWSER_PROFILING_HOST_TEST_ANDROID_SHIM_H_\n+#define CHROME_BROWSER_PROFILING_HOST_TEST_ANDROID_SHIM_H_\n+\n+#include \""base/android/jni_android.h\""\n+#include \""base/android/scoped_java_ref.h\""\n+#include \""base/macros.h\""\n+\n+// This class implements the native methods of TestAndroidShim.java,\n+// and acts as a bridge to ProfilingProcessHost. Note that this class is only\n+// used for testing.\n+class TestAndroidShim {\n+ public:\n+  TestAndroidShim(JNIEnv* env, jobject obj);\n+  void Destroy(JNIEnv* env, const base::android::JavaParamRef<jobject>& obj);\n+\n+  jboolean RunTestForMode(JNIEnv* env,\n+                          const base::android::JavaParamRef<jobject>& obj,\n+                          const base::android::JavaParamRef<jstring>&);\n+\n+ private:\n+  ~TestAndroidShim();\n+\n+  DISALLOW_COPY_AND_ASSIGN(TestAndroidShim);\n+};\n+\n+#endif  // CHROME_BROWSER_PROFILING_HOST_TEST_ANDROID_SHIM_H_""}<_**next**_>{""sha"": ""6f19fc5ff1c10a8b89fb6cbb93f05582bd4b4872"", ""filename"": ""chrome/test/android/javatests/src/org/chromium/chrome/test/ChromeActivityTestRule.java"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 3, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/test/android/javatests/src/org/chromium/chrome/test/ChromeActivityTestRule.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9d81094d7b0bfc8be6bba2f5084e790677e527c8/chrome/test/android/javatests/src/org/chromium/chrome/test/ChromeActivityTestRule.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/test/android/javatests/src/org/chromium/chrome/test/ChromeActivityTestRule.java?ref=9d81094d7b0bfc8be6bba2f5084e790677e527c8"", ""patch"": ""@@ -411,9 +411,11 @@ public void startMainActivityFromIntent(Intent intent, String url) throws Interr\n      * Waits for the activity to fully finish it's native initialization.\n      */\n     public void waitForActivityNativeInitializationComplete() {\n-        CriteriaHelper.pollUiThread(() -> ChromeBrowserInitializer.getInstance(\n-                getActivity()).hasNativeInitializationCompleted(),\n-                \""Native initialization never finished\"", 2 * CriteriaHelper.DEFAULT_MAX_TIME_TO_POLL,\n+        CriteriaHelper.pollUiThread(()\n+                                            -> ChromeBrowserInitializer.getInstance(getActivity())\n+                                                       .hasNativeInitializationCompleted(),\n+                \""Native initialization never finished\"",\n+                20 * CriteriaHelper.DEFAULT_MAX_TIME_TO_POLL,\n                 CriteriaHelper.DEFAULT_POLLING_INTERVAL);\n \n         CriteriaHelper.pollUiThread(() -> getActivity().didFinishNativeInitialization(),""}","ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {
  const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();
#if BUILDFLAG(USE_ALLOCATOR_SHIM)
  if (cmdline->HasSwitch(switches::kMemlog) ||
      base::FeatureList::IsEnabled(kOOPHeapProfilingFeature)) {
    if (cmdline->HasSwitch(switches::kEnableHeapProfiling)) {
      LOG(ERROR) << ""--"" << switches::kEnableHeapProfiling
                 << "" specified with --"" << switches::kMemlog
                 << ""which are not compatible. Memlog will be disabled."";
      return Mode::kNone;
    }

    std::string mode;
    if (cmdline->HasSwitch(switches::kMemlog)) {
      mode = cmdline->GetSwitchValueASCII(switches::kMemlog);
    } else {
      mode = base::GetFieldTrialParamValueByFeature(
           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);
     }
 
    return ConvertStringToMode(mode);
   }
   return Mode::kNone;
 #else
  LOG_IF(ERROR, cmdline->HasSwitch(switches::kMemlog))
      << ""--"" << switches::kMemlog
      << "" specified but it will have no effect because the use_allocator_shim ""
      << ""is not available in this build."";
  return Mode::kNone;
 #endif
 }
","ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {
  const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();
#if BUILDFLAG(USE_ALLOCATOR_SHIM)
  if (cmdline->HasSwitch(switches::kMemlog) ||
      base::FeatureList::IsEnabled(kOOPHeapProfilingFeature)) {
    if (cmdline->HasSwitch(switches::kEnableHeapProfiling)) {
      LOG(ERROR) << ""--"" << switches::kEnableHeapProfiling
                 << "" specified with --"" << switches::kMemlog
                 << ""which are not compatible. Memlog will be disabled."";
      return Mode::kNone;
    }

    std::string mode;
    if (cmdline->HasSwitch(switches::kMemlog)) {
      mode = cmdline->GetSwitchValueASCII(switches::kMemlog);
    } else {
      mode = base::GetFieldTrialParamValueByFeature(
           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);
     }
 
    if (mode == switches::kMemlogModeAll)
      return Mode::kAll;
    if (mode == switches::kMemlogModeMinimal)
      return Mode::kMinimal;
    if (mode == switches::kMemlogModeBrowser)
      return Mode::kBrowser;
    if (mode == switches::kMemlogModeGpu)
      return Mode::kGpu;
    if (mode == switches::kMemlogModeRendererSampling)
      return Mode::kRendererSampling;
    DLOG(ERROR) << ""Unsupported value: \"""" << mode << ""\"" passed to --""
                << switches::kMemlog;
   }
   return Mode::kNone;
 #else
  LOG_IF(ERROR, cmdline->HasSwitch(switches::kMemlog))
      << ""--"" << switches::kMemlog
      << "" specified but it will have no effect because the use_allocator_shim ""
      << ""is not available in this build."";
  return Mode::kNone;
 #endif
 }
",C,"    return ConvertStringToMode(mode);
","    if (mode == switches::kMemlogModeAll)
      return Mode::kAll;
    if (mode == switches::kMemlogModeMinimal)
      return Mode::kMinimal;
    if (mode == switches::kMemlogModeBrowser)
      return Mode::kBrowser;
    if (mode == switches::kMemlogModeGpu)
      return Mode::kGpu;
    if (mode == switches::kMemlogModeRendererSampling)
      return Mode::kRendererSampling;
    DLOG(ERROR) << ""Unsupported value: \"""" << mode << ""\"" passed to --""
                << switches::kMemlog;
",,"@@ -371,19 +371,7 @@ ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {
           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);
     }
 
-    if (mode == switches::kMemlogModeAll)
-      return Mode::kAll;
-    if (mode == switches::kMemlogModeMinimal)
-      return Mode::kMinimal;
-    if (mode == switches::kMemlogModeBrowser)
-      return Mode::kBrowser;
-    if (mode == switches::kMemlogModeGpu)
-      return Mode::kGpu;
-    if (mode == switches::kMemlogModeRendererSampling)
-      return Mode::kRendererSampling;
-
-    DLOG(ERROR) << ""Unsupported value: \"""" << mode << ""\"" passed to --""
-                << switches::kMemlog;
+    return ConvertStringToMode(mode);
   }
   return Mode::kNone;
 #else
@@ -395,6 +383,24 @@ ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {
 #endif
 }
 
+// static
+ProfilingProcessHost::Mode ProfilingProcessHost::ConvertStringToMode(
+    const std::string& mode) {
+  if (mode == switches::kMemlogModeAll)
+    return Mode::kAll;
+  if (mode == switches::kMemlogModeMinimal)
+    return Mode::kMinimal;
+  if (mode == switches::kMemlogModeBrowser)
+    return Mode::kBrowser;
+  if (mode == switches::kMemlogModeGpu)
+    return Mode::kGpu;
+  if (mode == switches::kMemlogModeRendererSampling)
+    return Mode::kRendererSampling;
+  DLOG(ERROR) << ""Unsupported value: \"""" << mode << ""\"" passed to --""
+              << switches::kMemlog;
+  return Mode::kNone;
+}
+
 // static
 ProfilingProcessHost* ProfilingProcessHost::Start(
     content::ServiceManagerConnection* connection,",Chrome,9d81094d7b0bfc8be6bba2f5084e790677e527c8,e9192c1e1bc0225603014ba83948a8cd2f1c64f4,1,"ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {
  const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();
#if BUILDFLAG(USE_ALLOCATOR_SHIM)
  if (cmdline->HasSwitch(switches::kMemlog) ||
      base::FeatureList::IsEnabled(kOOPHeapProfilingFeature)) {
    if (cmdline->HasSwitch(switches::kEnableHeapProfiling)) {
      // PartitionAlloc doesn't support chained allocation hooks so we can't
      // run both heap profilers at the same time.
      LOG(ERROR) << ""--"" << switches::kEnableHeapProfiling
                 << "" specified with --"" << switches::kMemlog
                 << ""which are not compatible. Memlog will be disabled."";
      return Mode::kNone;
    }

    std::string mode;
    // Respect the commandline switch above the field trial.
    if (cmdline->HasSwitch(switches::kMemlog)) {
      mode = cmdline->GetSwitchValueASCII(switches::kMemlog);
    } else {
      mode = base::GetFieldTrialParamValueByFeature(
           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);
     }
 
//flaw_line_below:
    if (mode == switches::kMemlogModeAll)
//flaw_line_below:
      return Mode::kAll;
//flaw_line_below:
    if (mode == switches::kMemlogModeMinimal)
//flaw_line_below:
      return Mode::kMinimal;
//flaw_line_below:
    if (mode == switches::kMemlogModeBrowser)
//flaw_line_below:
      return Mode::kBrowser;
//flaw_line_below:
    if (mode == switches::kMemlogModeGpu)
//flaw_line_below:
      return Mode::kGpu;
//flaw_line_below:
    if (mode == switches::kMemlogModeRendererSampling)
//flaw_line_below:
      return Mode::kRendererSampling;
//flaw_line_below:

//flaw_line_below:
    DLOG(ERROR) << ""Unsupported value: \"""" << mode << ""\"" passed to --""
//flaw_line_below:
                << switches::kMemlog;
//fix_flaw_line_below:
//    return ConvertStringToMode(mode);
   }
   return Mode::kNone;
 #else
  LOG_IF(ERROR, cmdline->HasSwitch(switches::kMemlog))
      << ""--"" << switches::kMemlog
      << "" specified but it will have no effect because the use_allocator_shim ""
      << ""is not available in this build."";
  return Mode::kNone;
 #endif
 }
",186901,"ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {
  const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();
#if BUILDFLAG(USE_ALLOCATOR_SHIM)
  if (cmdline->HasSwitch(switches::kMemlog) ||
      base::FeatureList::IsEnabled(kOOPHeapProfilingFeature)) {
    if (cmdline->HasSwitch(switches::kEnableHeapProfiling)) {
      LOG(ERROR) << ""--"" << switches::kEnableHeapProfiling
                 << "" specified with --"" << switches::kMemlog
                 << ""which are not compatible. Memlog will be disabled."";
      return Mode::kNone;
    }

    std::string mode;
    if (cmdline->HasSwitch(switches::kMemlog)) {
      mode = cmdline->GetSwitchValueASCII(switches::kMemlog);
    } else {
      mode = base::GetFieldTrialParamValueByFeature(
           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);
     }
 
    if (mode == switches::kMemlogModeAll)
      return Mode::kAll;
    if (mode == switches::kMemlogModeMinimal)
      return Mode::kMinimal;
    if (mode == switches::kMemlogModeBrowser)
      return Mode::kBrowser;
    if (mode == switches::kMemlogModeGpu)
      return Mode::kGpu;
    if (mode == switches::kMemlogModeRendererSampling)
      return Mode::kRendererSampling;
    DLOG(ERROR) << ""Unsupported value: \"""" << mode << ""\"" passed to --""
                << switches::kMemlog;
   }
   return Mode::kNone;
 #else
  LOG_IF(ERROR, cmdline->HasSwitch(switches::kMemlog))
      << ""--"" << switches::kMemlog
      << "" specified but it will have no effect because the use_allocator_shim ""
      << ""is not available in this build."";
  return Mode::kNone;
 #endif
 }
","ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {
  const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();
#if BUILDFLAG(USE_ALLOCATOR_SHIM)
  if (cmdline->HasSwitch(switches::kMemlog) ||
      base::FeatureList::IsEnabled(kOOPHeapProfilingFeature)) {
    if (cmdline->HasSwitch(switches::kEnableHeapProfiling)) {
      LOG(ERROR) << ""--"" << switches::kEnableHeapProfiling
                 << "" specified with --"" << switches::kMemlog
                 << ""which are not compatible. Memlog will be disabled."";
      return Mode::kNone;
    }

    std::string mode;
    if (cmdline->HasSwitch(switches::kMemlog)) {
      mode = cmdline->GetSwitchValueASCII(switches::kMemlog);
    } else {
      mode = base::GetFieldTrialParamValueByFeature(
           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);
     }
 
    return ConvertStringToMode(mode);
   }
   return Mode::kNone;
 #else
  LOG_IF(ERROR, cmdline->HasSwitch(switches::kMemlog))
      << ""--"" << switches::kMemlog
      << "" specified but it will have no effect because the use_allocator_shim ""
      << ""is not available in this build."";
  return Mode::kNone;
 #endif
 }
","The `GetCurrentMode` function determines the profiling mode for the current process based on command-line switches and feature flags. It first checks if the allocator shim is enabled; if so, it evaluates the presence of the `--memlog` switch and the `--enable-heap-profiling` switch, logging an error if both are specified, as they are incompatible. Depending on the value of the `--memlog` switch or a related feature parameter, it returns a corresponding profiling mode (e.g., `kAll`, `kMinimal`, etc.). If the allocator shim is not available, it logs an error indicating that the `--memlog` switch is ineffective and returns `kNone`.","The provided code determines the current profiling mode for a process based on command-line arguments and feature settings. It first checks if a specific memory allocation feature is enabled and then evaluates the presence of certain command-line switches. If conflicting switches are found, an error is logged, and a default mode is returned. Depending on the specified arguments, the code identifies and returns various profiling modes, such as all, minimal, or specific to components like the browser or GPU. If the memory allocation feature is not available, a warning is logged, and a default mode is returned.","The vulnerability in the original code stemmed from the lack of proper handling for conflicting command-line switches, specifically when both memory logging and heap profiling were enabled. This could lead to unexpected behavior or crashes if incompatible modes were activated simultaneously. The fixed code addresses this by introducing a dedicated function to convert the string representation of the mode into an enumerated type, ensuring that only valid modes are returned. Additionally, it maintains error logging for unsupported values, enhancing robustness and preventing potential misuse of the profiling features. This change improves the overall stability and reliability of the profiling process.","The vulnerability in the original code arose from improper handling of dependencies when adding a Java test to the Android build configuration, which led to essential components being stripped from the instrumentation APK. This could result in incomplete or malfunctioning tests, undermining the reliability of the profiling features. The fix involved updating the build configuration to ensure that the Java test and its dependencies were correctly included in the instrumentation APK without affecting the main APK. This change not only resolved the dependency issues but also improved the overall integrity and functionality of the testing framework.","The vulnerability was fixed by modifying the build configuration to ensure that the Java test and its dependencies were added exclusively to the `instrumentation_apk`, preventing them from being stripped from the APK under test. This change involved creating a new APK, `chrome_public_apk_for_test`, which contains the necessary content and native files for the Java instrumentation test. Additionally, the `apk_under_test` was updated to target this new APK instead of the original `chrome_public_apk`, ensuring that all required components were available during testing, thus enhancing the reliability of the profiling features.","The vulnerability was addressed by updating the build configuration to ensure that the Java test and its dependencies were correctly included in the instrumentation package without affecting the main application package. This involved creating a new testing package that contained all necessary components and native files required for the Java instrumentation test. By redirecting the testing framework to utilize this new package, the issue of essential dependencies being stripped was resolved, thereby enhancing the integrity and reliability of the testing process and ensuring that all required elements were available during execution.","CWE-701, CWE-758, CWE-913, CWE-1241, CWE-439, CWE-440, CWE-441, CWE-426, CWE-427, CWE-1277",N,-1
78,78,186920,186920,,Remote,Not required,Partial,CVE-2017-5129,https://www.cvedetails.com/cve/CVE-2017-5129/,CWE-416,Medium,Partial,Partial,,2018-02-07,6.8,A use after free in WebAudio in Blink in Google Chrome prior to 62.0.3202.62 allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page.,2018-02-22,,10,https://github.com/chromium/chromium/commit/783c28d59c4c748ef9b787d4717882c90c5b227b,783c28d59c4c748ef9b787d4717882c90c5b227b,"Keep ScriptProcessorHandler alive across threads

When posting a task from the ScriptProcessorHandler::Process to fire a
process event, we need to keep the handler alive in case the
ScriptProcessorNode goes away (because it has no onaudioprocess
handler) and removes the its handler.

Bug: 765495
Test: 
Change-Id: Ib4fa39d7b112c7051897700a1eff9f59a4a7a054
Reviewed-on: https://chromium-review.googlesource.com/677137
Reviewed-by: Hongchan Choi <hongchan@chromium.org>
Reviewed-by: Kentaro Hara <haraken@chromium.org>
Commit-Queue: Raymond Toy <rtoy@chromium.org>
Cr-Commit-Position: refs/heads/master@{#503629}",10,third_party/WebKit/Source/modules/webaudio/ScriptProcessorNode.cpp,"{""sha"": ""b731acf63f4e784fc72a7ad568e85bcb80c7e3f5"", ""filename"": ""third_party/WebKit/Source/modules/webaudio/ScriptProcessorNode.cpp"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 10, ""changes"": 20, ""blob_url"": ""https://github.com/chromium/chromium/blob/783c28d59c4c748ef9b787d4717882c90c5b227b/third_party/WebKit/Source/modules/webaudio/ScriptProcessorNode.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/783c28d59c4c748ef9b787d4717882c90c5b227b/third_party/WebKit/Source/modules/webaudio/ScriptProcessorNode.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/modules/webaudio/ScriptProcessorNode.cpp?ref=783c28d59c4c748ef9b787d4717882c90c5b227b"", ""patch"": ""@@ -216,10 +216,10 @@ void ScriptProcessorHandler::Process(size_t frames_to_process) {\n         // index.\n         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,\n                               Context()->GetExecutionContext())\n-            ->PostTask(BLINK_FROM_HERE,\n-                       CrossThreadBind(\n-                           &ScriptProcessorHandler::FireProcessEvent,\n-                           CrossThreadUnretained(this), double_buffer_index_));\n+            ->PostTask(\n+                BLINK_FROM_HERE,\n+                CrossThreadBind(&ScriptProcessorHandler::FireProcessEvent,\n+                                WrapRefPtr(this), double_buffer_index_));\n       } else {\n         // If this node is in the offline audio context, use the\n         // waitable event to synchronize to the offline rendering thread.\n@@ -228,12 +228,12 @@ void ScriptProcessorHandler::Process(size_t frames_to_process) {\n \n         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,\n                               Context()->GetExecutionContext())\n-            ->PostTask(BLINK_FROM_HERE,\n-                       CrossThreadBind(\n-                           &ScriptProcessorHandler::\n-                               FireProcessEventForOfflineAudioContext,\n-                           CrossThreadUnretained(this), double_buffer_index_,\n-                           CrossThreadUnretained(waitable_event.get())));\n+            ->PostTask(\n+                BLINK_FROM_HERE,\n+                CrossThreadBind(&ScriptProcessorHandler::\n+                                    FireProcessEventForOfflineAudioContext,\n+                                WrapRefPtr(this), double_buffer_index_,\n+                                CrossThreadUnretained(waitable_event.get())));\n \n         // Okay to block the offline audio rendering thread since it is\n         // not the actual audio device thread.""}","void ScriptProcessorHandler::Process(size_t frames_to_process) {

  AudioBus* input_bus = Input(0).Bus();
  AudioBus* output_bus = Output(0).Bus();

  unsigned double_buffer_index = this->DoubleBufferIndex();
  bool is_double_buffer_index_good =
      double_buffer_index < 2 && double_buffer_index < input_buffers_.size() &&
      double_buffer_index < output_buffers_.size();
  DCHECK(is_double_buffer_index_good);
  if (!is_double_buffer_index_good)
    return;

  AudioBuffer* input_buffer = input_buffers_[double_buffer_index].Get();
  AudioBuffer* output_buffer = output_buffers_[double_buffer_index].Get();

  unsigned number_of_input_channels = internal_input_bus_->NumberOfChannels();
  bool buffers_are_good =
      output_buffer && BufferSize() == output_buffer->length() &&
      buffer_read_write_index_ + frames_to_process <= BufferSize();

  if (internal_input_bus_->NumberOfChannels())
    buffers_are_good = buffers_are_good && input_buffer &&
                       BufferSize() == input_buffer->length();

  DCHECK(buffers_are_good);
  if (!buffers_are_good)
    return;

  bool is_frames_to_process_good = frames_to_process &&
                                   BufferSize() >= frames_to_process &&
                                   !(BufferSize() % frames_to_process);
  DCHECK(is_frames_to_process_good);
  if (!is_frames_to_process_good)
    return;

  unsigned number_of_output_channels = output_bus->NumberOfChannels();

  bool channels_are_good =
      (number_of_input_channels == number_of_input_channels_) &&
      (number_of_output_channels == number_of_output_channels_);
  DCHECK(channels_are_good);
  if (!channels_are_good)
    return;

  for (unsigned i = 0; i < number_of_input_channels; ++i)
    internal_input_bus_->SetChannelMemory(
        i,
        input_buffer->getChannelData(i).View()->Data() +
            buffer_read_write_index_,
        frames_to_process);

  if (number_of_input_channels)
    internal_input_bus_->CopyFrom(*input_bus);

  for (unsigned i = 0; i < number_of_output_channels; ++i) {
    memcpy(output_bus->Channel(i)->MutableData(),
           output_buffer->getChannelData(i).View()->Data() +
               buffer_read_write_index_,
           sizeof(float) * frames_to_process);
  }

  buffer_read_write_index_ =
      (buffer_read_write_index_ + frames_to_process) % BufferSize();

  if (!buffer_read_write_index_) {
    MutexTryLocker try_locker(process_event_lock_);
    if (!try_locker.Locked()) {
      output_buffer->Zero();
    } else if (Context()->GetExecutionContext()) {
      if (Context()->HasRealtimeConstraint()) {
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
            ->PostTask(
                BLINK_FROM_HERE,
                CrossThreadBind(&ScriptProcessorHandler::FireProcessEvent,
                                WrapRefPtr(this), double_buffer_index_));
       } else {
        std::unique_ptr<WaitableEvent> waitable_event =
            WTF::MakeUnique<WaitableEvent>();
 
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
            ->PostTask(
                BLINK_FROM_HERE,
                CrossThreadBind(&ScriptProcessorHandler::
                                    FireProcessEventForOfflineAudioContext,
                                WrapRefPtr(this), double_buffer_index_,
                                CrossThreadUnretained(waitable_event.get())));
 
        waitable_event->Wait();
      }
    }

    SwapBuffers();
  }
}
","void ScriptProcessorHandler::Process(size_t frames_to_process) {

  AudioBus* input_bus = Input(0).Bus();
  AudioBus* output_bus = Output(0).Bus();

  unsigned double_buffer_index = this->DoubleBufferIndex();
  bool is_double_buffer_index_good =
      double_buffer_index < 2 && double_buffer_index < input_buffers_.size() &&
      double_buffer_index < output_buffers_.size();
  DCHECK(is_double_buffer_index_good);
  if (!is_double_buffer_index_good)
    return;

  AudioBuffer* input_buffer = input_buffers_[double_buffer_index].Get();
  AudioBuffer* output_buffer = output_buffers_[double_buffer_index].Get();

  unsigned number_of_input_channels = internal_input_bus_->NumberOfChannels();
  bool buffers_are_good =
      output_buffer && BufferSize() == output_buffer->length() &&
      buffer_read_write_index_ + frames_to_process <= BufferSize();

  if (internal_input_bus_->NumberOfChannels())
    buffers_are_good = buffers_are_good && input_buffer &&
                       BufferSize() == input_buffer->length();

  DCHECK(buffers_are_good);
  if (!buffers_are_good)
    return;

  bool is_frames_to_process_good = frames_to_process &&
                                   BufferSize() >= frames_to_process &&
                                   !(BufferSize() % frames_to_process);
  DCHECK(is_frames_to_process_good);
  if (!is_frames_to_process_good)
    return;

  unsigned number_of_output_channels = output_bus->NumberOfChannels();

  bool channels_are_good =
      (number_of_input_channels == number_of_input_channels_) &&
      (number_of_output_channels == number_of_output_channels_);
  DCHECK(channels_are_good);
  if (!channels_are_good)
    return;

  for (unsigned i = 0; i < number_of_input_channels; ++i)
    internal_input_bus_->SetChannelMemory(
        i,
        input_buffer->getChannelData(i).View()->Data() +
            buffer_read_write_index_,
        frames_to_process);

  if (number_of_input_channels)
    internal_input_bus_->CopyFrom(*input_bus);

  for (unsigned i = 0; i < number_of_output_channels; ++i) {
    memcpy(output_bus->Channel(i)->MutableData(),
           output_buffer->getChannelData(i).View()->Data() +
               buffer_read_write_index_,
           sizeof(float) * frames_to_process);
  }

  buffer_read_write_index_ =
      (buffer_read_write_index_ + frames_to_process) % BufferSize();

  if (!buffer_read_write_index_) {
    MutexTryLocker try_locker(process_event_lock_);
    if (!try_locker.Locked()) {
      output_buffer->Zero();
    } else if (Context()->GetExecutionContext()) {
      if (Context()->HasRealtimeConstraint()) {
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
            ->PostTask(BLINK_FROM_HERE,
                       CrossThreadBind(
                           &ScriptProcessorHandler::FireProcessEvent,
                           CrossThreadUnretained(this), double_buffer_index_));
       } else {
        std::unique_ptr<WaitableEvent> waitable_event =
            WTF::MakeUnique<WaitableEvent>();
 
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
            ->PostTask(BLINK_FROM_HERE,
                       CrossThreadBind(
                           &ScriptProcessorHandler::
                               FireProcessEventForOfflineAudioContext,
                           CrossThreadUnretained(this), double_buffer_index_,
                           CrossThreadUnretained(waitable_event.get())));
 
        waitable_event->Wait();
      }
    }

    SwapBuffers();
  }
}
",C,"            ->PostTask(
                BLINK_FROM_HERE,
                CrossThreadBind(&ScriptProcessorHandler::FireProcessEvent,
                                WrapRefPtr(this), double_buffer_index_));
            ->PostTask(
                BLINK_FROM_HERE,
                CrossThreadBind(&ScriptProcessorHandler::
                                    FireProcessEventForOfflineAudioContext,
                                WrapRefPtr(this), double_buffer_index_,
                                CrossThreadUnretained(waitable_event.get())));
","            ->PostTask(BLINK_FROM_HERE,
                       CrossThreadBind(
                           &ScriptProcessorHandler::FireProcessEvent,
                           CrossThreadUnretained(this), double_buffer_index_));
            ->PostTask(BLINK_FROM_HERE,
                       CrossThreadBind(
                           &ScriptProcessorHandler::
                               FireProcessEventForOfflineAudioContext,
                           CrossThreadUnretained(this), double_buffer_index_,
                           CrossThreadUnretained(waitable_event.get())));
",,"@@ -216,10 +216,10 @@ void ScriptProcessorHandler::Process(size_t frames_to_process) {
         // index.
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
-            ->PostTask(BLINK_FROM_HERE,
-                       CrossThreadBind(
-                           &ScriptProcessorHandler::FireProcessEvent,
-                           CrossThreadUnretained(this), double_buffer_index_));
+            ->PostTask(
+                BLINK_FROM_HERE,
+                CrossThreadBind(&ScriptProcessorHandler::FireProcessEvent,
+                                WrapRefPtr(this), double_buffer_index_));
       } else {
         // If this node is in the offline audio context, use the
         // waitable event to synchronize to the offline rendering thread.
@@ -228,12 +228,12 @@ void ScriptProcessorHandler::Process(size_t frames_to_process) {
 
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
-            ->PostTask(BLINK_FROM_HERE,
-                       CrossThreadBind(
-                           &ScriptProcessorHandler::
-                               FireProcessEventForOfflineAudioContext,
-                           CrossThreadUnretained(this), double_buffer_index_,
-                           CrossThreadUnretained(waitable_event.get())));
+            ->PostTask(
+                BLINK_FROM_HERE,
+                CrossThreadBind(&ScriptProcessorHandler::
+                                    FireProcessEventForOfflineAudioContext,
+                                WrapRefPtr(this), double_buffer_index_,
+                                CrossThreadUnretained(waitable_event.get())));
 
         // Okay to block the offline audio rendering thread since it is
         // not the actual audio device thread.",Chrome,783c28d59c4c748ef9b787d4717882c90c5b227b,ee2b98599aa8ee52b90efa40fc7c9ebecf42d548,1,"void ScriptProcessorHandler::Process(size_t frames_to_process) {
  // Discussion about inputs and outputs:
  // As in other AudioNodes, ScriptProcessorNode uses an AudioBus for its input
  // and output (see inputBus and outputBus below).  Additionally, there is a
  // double-buffering for input and output which is exposed directly to
  // JavaScript (see inputBuffer and outputBuffer below).  This node is the
  // producer for inputBuffer and the consumer for outputBuffer.  The JavaScript
  // code is the consumer of inputBuffer and the producer for outputBuffer.

  // Get input and output busses.
  AudioBus* input_bus = Input(0).Bus();
  AudioBus* output_bus = Output(0).Bus();

  // Get input and output buffers. We double-buffer both the input and output
  // sides.
  unsigned double_buffer_index = this->DoubleBufferIndex();
  bool is_double_buffer_index_good =
      double_buffer_index < 2 && double_buffer_index < input_buffers_.size() &&
      double_buffer_index < output_buffers_.size();
  DCHECK(is_double_buffer_index_good);
  if (!is_double_buffer_index_good)
    return;

  AudioBuffer* input_buffer = input_buffers_[double_buffer_index].Get();
  AudioBuffer* output_buffer = output_buffers_[double_buffer_index].Get();

  // Check the consistency of input and output buffers.
  unsigned number_of_input_channels = internal_input_bus_->NumberOfChannels();
  bool buffers_are_good =
      output_buffer && BufferSize() == output_buffer->length() &&
      buffer_read_write_index_ + frames_to_process <= BufferSize();

  // If the number of input channels is zero, it's ok to have inputBuffer = 0.
  if (internal_input_bus_->NumberOfChannels())
    buffers_are_good = buffers_are_good && input_buffer &&
                       BufferSize() == input_buffer->length();

  DCHECK(buffers_are_good);
  if (!buffers_are_good)
    return;

  // We assume that bufferSize() is evenly divisible by framesToProcess - should
  // always be true, but we should still check.
  bool is_frames_to_process_good = frames_to_process &&
                                   BufferSize() >= frames_to_process &&
                                   !(BufferSize() % frames_to_process);
  DCHECK(is_frames_to_process_good);
  if (!is_frames_to_process_good)
    return;

  unsigned number_of_output_channels = output_bus->NumberOfChannels();

  bool channels_are_good =
      (number_of_input_channels == number_of_input_channels_) &&
      (number_of_output_channels == number_of_output_channels_);
  DCHECK(channels_are_good);
  if (!channels_are_good)
    return;

  for (unsigned i = 0; i < number_of_input_channels; ++i)
    internal_input_bus_->SetChannelMemory(
        i,
        input_buffer->getChannelData(i).View()->Data() +
            buffer_read_write_index_,
        frames_to_process);

  if (number_of_input_channels)
    internal_input_bus_->CopyFrom(*input_bus);

  // Copy from the output buffer to the output.
  for (unsigned i = 0; i < number_of_output_channels; ++i) {
    memcpy(output_bus->Channel(i)->MutableData(),
           output_buffer->getChannelData(i).View()->Data() +
               buffer_read_write_index_,
           sizeof(float) * frames_to_process);
  }

  // Update the buffering index.
  buffer_read_write_index_ =
      (buffer_read_write_index_ + frames_to_process) % BufferSize();

  // m_bufferReadWriteIndex will wrap back around to 0 when the current input
  // and output buffers are full.
  // When this happens, fire an event and swap buffers.
  if (!buffer_read_write_index_) {
    // Avoid building up requests on the main thread to fire process events when
    // they're not being handled.  This could be a problem if the main thread is
    // very busy doing other things and is being held up handling previous
    // requests.  The audio thread can't block on this lock, so we call
    // tryLock() instead.
    MutexTryLocker try_locker(process_event_lock_);
    if (!try_locker.Locked()) {
      // We're late in handling the previous request. The main thread must be
      // very busy.  The best we can do is clear out the buffer ourself here.
      output_buffer->Zero();
    } else if (Context()->GetExecutionContext()) {
      // With the realtime context, execute the script code asynchronously
      // and do not wait.
      if (Context()->HasRealtimeConstraint()) {
        // Fire the event on the main thread with the appropriate buffer
         // index.
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
//flaw_line_below:
            ->PostTask(BLINK_FROM_HERE,
//flaw_line_below:
                       CrossThreadBind(
//flaw_line_below:
                           &ScriptProcessorHandler::FireProcessEvent,
//flaw_line_below:
                           CrossThreadUnretained(this), double_buffer_index_));
//fix_flaw_line_below:
//            ->PostTask(
//fix_flaw_line_below:
//                BLINK_FROM_HERE,
//fix_flaw_line_below:
//                CrossThreadBind(&ScriptProcessorHandler::FireProcessEvent,
//fix_flaw_line_below:
//                                WrapRefPtr(this), double_buffer_index_));
       } else {
         // If this node is in the offline audio context, use the
         // waitable event to synchronize to the offline rendering thread.
        std::unique_ptr<WaitableEvent> waitable_event =
            WTF::MakeUnique<WaitableEvent>();
 
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
//flaw_line_below:
            ->PostTask(BLINK_FROM_HERE,
//flaw_line_below:
                       CrossThreadBind(
//flaw_line_below:
                           &ScriptProcessorHandler::
//flaw_line_below:
                               FireProcessEventForOfflineAudioContext,
//flaw_line_below:
                           CrossThreadUnretained(this), double_buffer_index_,
//flaw_line_below:
                           CrossThreadUnretained(waitable_event.get())));
//fix_flaw_line_below:
//            ->PostTask(
//fix_flaw_line_below:
//                BLINK_FROM_HERE,
//fix_flaw_line_below:
//                CrossThreadBind(&ScriptProcessorHandler::
//fix_flaw_line_below:
//                                    FireProcessEventForOfflineAudioContext,
//fix_flaw_line_below:
//                                WrapRefPtr(this), double_buffer_index_,
//fix_flaw_line_below:
//                                CrossThreadUnretained(waitable_event.get())));
 
         // Okay to block the offline audio rendering thread since it is
         // not the actual audio device thread.
        waitable_event->Wait();
      }
    }

    SwapBuffers();
  }
}
",186920,"void ScriptProcessorHandler::Process(size_t frames_to_process) {

  AudioBus* input_bus = Input(0).Bus();
  AudioBus* output_bus = Output(0).Bus();

  unsigned double_buffer_index = this->DoubleBufferIndex();
  bool is_double_buffer_index_good =
      double_buffer_index < 2 && double_buffer_index < input_buffers_.size() &&
      double_buffer_index < output_buffers_.size();
  DCHECK(is_double_buffer_index_good);
  if (!is_double_buffer_index_good)
    return;

  AudioBuffer* input_buffer = input_buffers_[double_buffer_index].Get();
  AudioBuffer* output_buffer = output_buffers_[double_buffer_index].Get();

  unsigned number_of_input_channels = internal_input_bus_->NumberOfChannels();
  bool buffers_are_good =
      output_buffer && BufferSize() == output_buffer->length() &&
      buffer_read_write_index_ + frames_to_process <= BufferSize();

  if (internal_input_bus_->NumberOfChannels())
    buffers_are_good = buffers_are_good && input_buffer &&
                       BufferSize() == input_buffer->length();

  DCHECK(buffers_are_good);
  if (!buffers_are_good)
    return;

  bool is_frames_to_process_good = frames_to_process &&
                                   BufferSize() >= frames_to_process &&
                                   !(BufferSize() % frames_to_process);
  DCHECK(is_frames_to_process_good);
  if (!is_frames_to_process_good)
    return;

  unsigned number_of_output_channels = output_bus->NumberOfChannels();

  bool channels_are_good =
      (number_of_input_channels == number_of_input_channels_) &&
      (number_of_output_channels == number_of_output_channels_);
  DCHECK(channels_are_good);
  if (!channels_are_good)
    return;

  for (unsigned i = 0; i < number_of_input_channels; ++i)
    internal_input_bus_->SetChannelMemory(
        i,
        input_buffer->getChannelData(i).View()->Data() +
            buffer_read_write_index_,
        frames_to_process);

  if (number_of_input_channels)
    internal_input_bus_->CopyFrom(*input_bus);

  for (unsigned i = 0; i < number_of_output_channels; ++i) {
    memcpy(output_bus->Channel(i)->MutableData(),
           output_buffer->getChannelData(i).View()->Data() +
               buffer_read_write_index_,
           sizeof(float) * frames_to_process);
  }

  buffer_read_write_index_ =
      (buffer_read_write_index_ + frames_to_process) % BufferSize();

  if (!buffer_read_write_index_) {
    MutexTryLocker try_locker(process_event_lock_);
    if (!try_locker.Locked()) {
      output_buffer->Zero();
    } else if (Context()->GetExecutionContext()) {
      if (Context()->HasRealtimeConstraint()) {
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
            ->PostTask(BLINK_FROM_HERE,
                       CrossThreadBind(
                           &ScriptProcessorHandler::FireProcessEvent,
                           CrossThreadUnretained(this), double_buffer_index_));
       } else {
        std::unique_ptr<WaitableEvent> waitable_event =
            WTF::MakeUnique<WaitableEvent>();
 
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
            ->PostTask(BLINK_FROM_HERE,
                       CrossThreadBind(
                           &ScriptProcessorHandler::
                               FireProcessEventForOfflineAudioContext,
                           CrossThreadUnretained(this), double_buffer_index_,
                           CrossThreadUnretained(waitable_event.get())));
 
        waitable_event->Wait();
      }
    }

    SwapBuffers();
  }
}
","void ScriptProcessorHandler::Process(size_t frames_to_process) {

  AudioBus* input_bus = Input(0).Bus();
  AudioBus* output_bus = Output(0).Bus();

  unsigned double_buffer_index = this->DoubleBufferIndex();
  bool is_double_buffer_index_good =
      double_buffer_index < 2 && double_buffer_index < input_buffers_.size() &&
      double_buffer_index < output_buffers_.size();
  DCHECK(is_double_buffer_index_good);
  if (!is_double_buffer_index_good)
    return;

  AudioBuffer* input_buffer = input_buffers_[double_buffer_index].Get();
  AudioBuffer* output_buffer = output_buffers_[double_buffer_index].Get();

  unsigned number_of_input_channels = internal_input_bus_->NumberOfChannels();
  bool buffers_are_good =
      output_buffer && BufferSize() == output_buffer->length() &&
      buffer_read_write_index_ + frames_to_process <= BufferSize();

  if (internal_input_bus_->NumberOfChannels())
    buffers_are_good = buffers_are_good && input_buffer &&
                       BufferSize() == input_buffer->length();

  DCHECK(buffers_are_good);
  if (!buffers_are_good)
    return;

  bool is_frames_to_process_good = frames_to_process &&
                                   BufferSize() >= frames_to_process &&
                                   !(BufferSize() % frames_to_process);
  DCHECK(is_frames_to_process_good);
  if (!is_frames_to_process_good)
    return;

  unsigned number_of_output_channels = output_bus->NumberOfChannels();

  bool channels_are_good =
      (number_of_input_channels == number_of_input_channels_) &&
      (number_of_output_channels == number_of_output_channels_);
  DCHECK(channels_are_good);
  if (!channels_are_good)
    return;

  for (unsigned i = 0; i < number_of_input_channels; ++i)
    internal_input_bus_->SetChannelMemory(
        i,
        input_buffer->getChannelData(i).View()->Data() +
            buffer_read_write_index_,
        frames_to_process);

  if (number_of_input_channels)
    internal_input_bus_->CopyFrom(*input_bus);

  for (unsigned i = 0; i < number_of_output_channels; ++i) {
    memcpy(output_bus->Channel(i)->MutableData(),
           output_buffer->getChannelData(i).View()->Data() +
               buffer_read_write_index_,
           sizeof(float) * frames_to_process);
  }

  buffer_read_write_index_ =
      (buffer_read_write_index_ + frames_to_process) % BufferSize();

  if (!buffer_read_write_index_) {
    MutexTryLocker try_locker(process_event_lock_);
    if (!try_locker.Locked()) {
      output_buffer->Zero();
    } else if (Context()->GetExecutionContext()) {
      if (Context()->HasRealtimeConstraint()) {
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
            ->PostTask(
                BLINK_FROM_HERE,
                CrossThreadBind(&ScriptProcessorHandler::FireProcessEvent,
                                WrapRefPtr(this), double_buffer_index_));
       } else {
        std::unique_ptr<WaitableEvent> waitable_event =
            WTF::MakeUnique<WaitableEvent>();
 
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
            ->PostTask(
                BLINK_FROM_HERE,
                CrossThreadBind(&ScriptProcessorHandler::
                                    FireProcessEventForOfflineAudioContext,
                                WrapRefPtr(this), double_buffer_index_,
                                CrossThreadUnretained(waitable_event.get())));
 
        waitable_event->Wait();
      }
    }

    SwapBuffers();
  }
}
","The `Process` function in the `ScriptProcessorHandler` class manages audio processing by handling input and output audio buffers. It first verifies the validity of the double buffer index and checks the integrity of input and output buffers, ensuring they match expected sizes and channel counts. If all conditions are met, it copies audio data from the input buffer to an internal bus and subsequently to the output bus. The function updates the read/write index for buffer management and, upon reaching the end of the buffer, may trigger an event to notify the context of the processing completion, while also handling potential locking for thread safety.","The provided code processes audio data by managing input and output buffers within a script processor. It first checks the validity of buffer indices and ensures that the buffers are correctly sized and contain the expected number of channels. If all conditions are satisfied, it transfers audio data from the input to an internal representation and then to the output. The code also updates the position for reading and writing data in the buffers. Upon reaching the end of the buffer, it may trigger an event to notify the surrounding context of the processing completion, ensuring thread safety during this operation.","The vulnerability in the original code stemmed from the potential for the `ScriptProcessorHandler` to be destroyed while a task was posted to fire a process event, leading to a dangling reference and possible crashes. This issue arose because the handler could be removed if it had no associated audio processing function. The fix involved using `WrapRefPtr(this)` when posting tasks, ensuring that the handler remains alive across threads until the task is completed. This change prevents premature destruction of the handler, thereby maintaining stability and preventing access to invalid memory during concurrent operations.","The vulnerability in the original code arose from the risk of the handler being destroyed while a task was still pending, which could lead to accessing invalid memory and potential crashes. This situation could occur if the associated node was removed due to the absence of an audio processing function. The fix involved ensuring that the handler remains alive across threads when posting tasks, thereby preventing its premature destruction. This change guarantees that the handler is valid for the duration of the task execution, thus enhancing stability and preventing errors related to dangling references in concurrent environments.","The vulnerability was fixed by using `WrapRefPtr(this)` when posting tasks to fire process events, which ensures that the `ScriptProcessorHandler` remains alive across threads. This approach prevents the handler from being prematurely destroyed while a task is still pending, addressing the issue where the associated node could be removed if it lacked an audio processing function. By maintaining a reference to the handler during task execution, the code mitigates the risk of accessing invalid memory, thereby enhancing stability and preventing crashes related to dangling references in concurrent operations.","The vulnerability was fixed by implementing a mechanism that ensures the handler remains valid and alive during the execution of posted tasks. This was achieved by maintaining a reference to the handler when tasks are dispatched, preventing its premature destruction while tasks are still pending. As a result, the code safeguards against accessing invalid memory, which could lead to crashes. This change enhances the stability of the system by ensuring that the handler is not removed unexpectedly, thereby allowing for safe concurrent operations without the risk of dangling references.","CWE-416, CWE-825, CWE-672, CWE-415, CWE-476, CWE-843, CWE-910, CWE-666, CWE-667, CWE-668",Y,1
79,79,186942,186942,,Remote,Not required,Partial,CVE-2019-5828,https://www.cvedetails.com/cve/CVE-2019-5828/,CWE-416,Medium,Partial,Partial,,2019-06-27,6.8,Object lifecycle issue in ServiceWorker in Google Chrome prior to 75.0.3770.80 allowed a remote attacker to potentially perform out of bounds memory access via a crafted HTML page.,2019-07-25,,0,https://github.com/chromium/chromium/commit/761d65ebcac0cdb730fd27b87e207201ac38e3b4,761d65ebcac0cdb730fd27b87e207201ac38e3b4,"[Payment Handler] Don't wait for response from closed payment app.

Before this patch, tapping the back button on top of the payment handler
window on desktop would not affect the |response_helper_|, which would
continue waiting for a response from the payment app. The service worker
of the closed payment app could timeout after 5 minutes and invoke the
|response_helper_|. Depending on what else the user did afterwards, in
the best case scenario, the payment sheet would display a ""Transaction
failed"" error message. In the worst case scenario, the
|response_helper_| would be used after free.

This patch clears the |response_helper_| in the PaymentRequestState and
in the ServiceWorkerPaymentInstrument after the payment app is closed.

After this patch, the cancelled payment app does not show ""Transaction
failed"" and does not use memory after it was freed.

Bug: 956597
Change-Id: I64134b911a4f8c154cb56d537a8243a68a806394
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1588682
Reviewed-by: anthonyvd <anthonyvd@chromium.org>
Commit-Queue: Rouslan Solomakhin <rouslan@chromium.org>
Cr-Commit-Position: refs/heads/master@{#654995}",1,components/payments/content/service_worker_payment_instrument.cc,"{""sha"": ""69d1e0a1b5e3a0c8117b3d2e40391ec728019455"", ""filename"": ""chrome/browser/ui/views/payments/payment_handler_web_flow_view_controller.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/761d65ebcac0cdb730fd27b87e207201ac38e3b4/chrome/browser/ui/views/payments/payment_handler_web_flow_view_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/761d65ebcac0cdb730fd27b87e207201ac38e3b4/chrome/browser/ui/views/payments/payment_handler_web_flow_view_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/payments/payment_handler_web_flow_view_controller.cc?ref=761d65ebcac0cdb730fd27b87e207201ac38e3b4"", ""patch"": ""@@ -188,7 +188,9 @@ PaymentHandlerWebFlowViewController::PaymentHandlerWebFlowViewController(\n       ui::NativeTheme::kColorId_SeparatorColor));\n }\n \n-PaymentHandlerWebFlowViewController::~PaymentHandlerWebFlowViewController() {}\n+PaymentHandlerWebFlowViewController::~PaymentHandlerWebFlowViewController() {\n+  state()->OnPaymentAppWindowClosed();\n+}\n \n base::string16 PaymentHandlerWebFlowViewController::GetSheetTitle() {\n   return GetPaymentHandlerDialogTitle(web_contents(), https_prefix_);""}<_**next**_>{""sha"": ""26f8b78aa7fe960306bc7edfec2558f2edf46851"", ""filename"": ""components/payments/content/payment_request_state.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/content/payment_request_state.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/content/payment_request_state.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/payments/content/payment_request_state.cc?ref=761d65ebcac0cdb730fd27b87e207201ac38e3b4"", ""patch"": ""@@ -304,6 +304,12 @@ void PaymentRequestState::GeneratePaymentResponse() {\n       selected_shipping_profile_, selected_contact_profile_, this);\n }\n \n+void PaymentRequestState::OnPaymentAppWindowClosed() {\n+  DCHECK(selected_instrument_);\n+  response_helper_.reset();\n+  selected_instrument_->OnPaymentAppWindowClosed();\n+}\n+\n void PaymentRequestState::RecordUseStats() {\n   if (spec_->request_shipping()) {\n     DCHECK(selected_shipping_profile_);""}<_**next**_>{""sha"": ""75aaec22ae6dae9c00f0cca45639424b3218567c"", ""filename"": ""components/payments/content/payment_request_state.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/content/payment_request_state.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/content/payment_request_state.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/payments/content/payment_request_state.h?ref=761d65ebcac0cdb730fd27b87e207201ac38e3b4"", ""patch"": ""@@ -126,6 +126,9 @@ class PaymentRequestState : public PaymentResponseHelper::Delegate,\n   // |is_ready_to_pay|, which is inexpensive.\n   void GeneratePaymentResponse();\n \n+  // Cancels the generation of the PaymentResponse.\n+  void OnPaymentAppWindowClosed();\n+\n   // Record the use of the data models that were used in the Payment Request.\n   void RecordUseStats();\n ""}<_**next**_>{""sha"": ""1c088228521f52e0a701c47d2c4dab4482d8644a"", ""filename"": ""components/payments/content/service_worker_payment_instrument.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/content/service_worker_payment_instrument.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/content/service_worker_payment_instrument.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/payments/content/service_worker_payment_instrument.cc?ref=761d65ebcac0cdb730fd27b87e207201ac38e3b4"", ""patch"": ""@@ -244,6 +244,10 @@ void ServiceWorkerPaymentInstrument::InvokePaymentApp(Delegate* delegate) {\n   payment_request_delegate_->ShowProcessingSpinner();\n }\n \n+void ServiceWorkerPaymentInstrument::OnPaymentAppWindowClosed() {\n+  delegate_ = nullptr;\n+}\n+\n mojom::PaymentRequestEventDataPtr\n ServiceWorkerPaymentInstrument::CreatePaymentRequestEventData() {\n   mojom::PaymentRequestEventDataPtr event_data =\n@@ -283,8 +287,6 @@ ServiceWorkerPaymentInstrument::CreatePaymentRequestEventData() {\n \n void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(\n     mojom::PaymentHandlerResponsePtr response) {\n-  DCHECK(delegate_);\n-\n   if (delegate_ != nullptr) {\n     delegate_->OnInstrumentDetailsReady(response->method_name,\n                                         response->stringified_details);""}<_**next**_>{""sha"": ""7dbb9e4732eee03504ae9c61dff0d3d8275c10e4"", ""filename"": ""components/payments/content/service_worker_payment_instrument.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/content/service_worker_payment_instrument.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/content/service_worker_payment_instrument.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/payments/content/service_worker_payment_instrument.h?ref=761d65ebcac0cdb730fd27b87e207201ac38e3b4"", ""patch"": ""@@ -62,6 +62,7 @@ class ServiceWorkerPaymentInstrument : public PaymentInstrument {\n \n   // PaymentInstrument:\n   void InvokePaymentApp(Delegate* delegate) override;\n+  void OnPaymentAppWindowClosed() override;\n   bool IsCompleteForPayment() const override;\n   bool IsExactlyMatchingMerchantRequest() const override;\n   base::string16 GetMissingInfoLabel() const override;""}<_**next**_>{""sha"": ""d2a6863f2e5d943cac40020a3ecd748a344b2fe4"", ""filename"": ""components/payments/core/payment_instrument.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/core/payment_instrument.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/761d65ebcac0cdb730fd27b87e207201ac38e3b4/components/payments/core/payment_instrument.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/payments/core/payment_instrument.h?ref=761d65ebcac0cdb730fd27b87e207201ac38e3b4"", ""patch"": ""@@ -40,6 +40,8 @@ class PaymentInstrument {\n \n   // Will call into the |delegate| (can't be null) on success or error.\n   virtual void InvokePaymentApp(Delegate* delegate) = 0;\n+  // Called when the payment app window has closed.\n+  virtual void OnPaymentAppWindowClosed() {}\n   // Returns whether the instrument is complete to be used as a payment method\n   // without further editing.\n   virtual bool IsCompleteForPayment() const = 0;""}"," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}
"," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
  DCHECK(delegate_);
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}
",C,,"  DCHECK(delegate_);
",,"@@ -244,6 +244,10 @@ void ServiceWorkerPaymentInstrument::InvokePaymentApp(Delegate* delegate) {
   payment_request_delegate_->ShowProcessingSpinner();
 }
 
+void ServiceWorkerPaymentInstrument::OnPaymentAppWindowClosed() {
+  delegate_ = nullptr;
+}
+
 mojom::PaymentRequestEventDataPtr
 ServiceWorkerPaymentInstrument::CreatePaymentRequestEventData() {
   mojom::PaymentRequestEventDataPtr event_data =
@@ -283,8 +287,6 @@ ServiceWorkerPaymentInstrument::CreatePaymentRequestEventData() {
 
 void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
-  DCHECK(delegate_);
-
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);",Chrome,761d65ebcac0cdb730fd27b87e207201ac38e3b4,e8938178b9fe8026b3ac222f4c522276c3f39379,1," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
//flaw_line_below:
  DCHECK(delegate_);
//flaw_line_below:

   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}
",186942," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
  DCHECK(delegate_);
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}
"," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}
","The `OnPaymentAppInvoked` function is a member of the `ServiceWorkerPaymentInstrument` class, designed to handle the invocation of a payment application. It first checks that the `delegate_` pointer is valid using `DCHECK`, ensuring that the delegate is not null. If the delegate is indeed valid, the function calls the `OnInstrumentDetailsReady` method on the delegate, passing it the payment method name and the associated stringified details from the `response` object. After processing, it sets the `delegate_` pointer to null, effectively indicating that the operation is complete and preventing further calls.","The provided code defines a function that responds to the activation of a payment application. It first verifies the existence of a delegate to ensure that it can safely proceed with the operation. If the delegate is present, the function retrieves specific details from a response object related to the payment method and its associated information. It then invokes a method on the delegate to pass these details for further processing. Finally, the function nullifies the delegate reference, indicating that the operation has been completed and preventing any subsequent calls to the delegate until it is reassigned.","The vulnerability in the original code stemmed from the fact that the `response_helper_` continued to wait for a response from a payment app even after the app was closed, which could lead to a timeout and potentially invoke the `response_helper_` after it had been freed. This situation could result in displaying a misleading ""Transaction failed"" error or, worse, using freed memory, leading to undefined behavior. The fix involved clearing the `response_helper_` in both the `PaymentRequestState` and `ServiceWorkerPaymentInstrument` classes when the payment app was closed, ensuring that no further actions were taken on a non-existent response, thus preventing memory misuse.","The vulnerability in the original code arose from the system's failure to stop waiting for a response from a payment application after it was closed, leading to potential timeouts and subsequent misuse of memory. This could result in misleading error messages or, in severe cases, operations on freed memory, causing undefined behavior. The fix implemented in the updated code involved ensuring that the waiting mechanism was properly cleared when the payment app was closed. This change effectively prevented any further actions on a non-existent response, eliminating the risk of displaying erroneous messages and safeguarding against memory misuse.","The vulnerability was fixed by clearing the `response_helper_` in both the `PaymentRequestState` and `ServiceWorkerPaymentInstrument` classes when the payment app was closed. This change ensures that the `response_helper_` no longer waits for a response from a closed application, thus preventing it from being invoked after a timeout. By nullifying the `response_helper_`, the code eliminates the risk of displaying misleading error messages, such as ""Transaction failed,"" and prevents any operations on freed memory, thereby enhancing the stability and security of the payment handling process.","The vulnerability was addressed by implementing a mechanism to clear the waiting process associated with the payment application when it was closed. This change ensured that the system would no longer expect a response from an application that was no longer active, effectively preventing any subsequent actions on a non-existent response. By removing the reference to the waiting process, the code eliminated the risk of displaying misleading error messages and safeguarded against potential memory misuse, thereby enhancing the overall stability and security of the payment handling functionality.","CWE-404, CWE-672, CWE-911, CWE-401, CWE-908, CWE-665, CWE-826, CWE-415, CWE-416, CWE-773",N,-1
80,80,187047,187047,,Remote,Not required,Partial,CVE-2019-5786,https://www.cvedetails.com/cve/CVE-2019-5786/,CWE-416,Medium,,,,2019-06-27,4.3,Object lifetime issue in Blink in Google Chrome prior to 72.0.3626.121 allowed a remote attacker to potentially perform out of bounds memory access via a crafted HTML page.,2019-07-01,,9,https://github.com/chromium/chromium/commit/ba9748e78ec7e9c0d594e7edf7b2c07ea2a90449,ba9748e78ec7e9c0d594e7edf7b2c07ea2a90449,"FileReader: Make a copy of the ArrayBuffer when returning partial results.

This is to avoid accidentally ending up with multiple references to the
same underlying ArrayBuffer. The extra performance overhead of this is
minimal as usage of partial results is very rare anyway (as can be seen
on https://www.chromestatus.com/metrics/feature/timeline/popularity/2158).

Bug: 936448
Change-Id: Icd1081adc1c889829fe7fa4af9cf4440097e8854
Reviewed-on: https://chromium-review.googlesource.com/c/1492873
Commit-Queue: Marijn Kruisselbrink <mek@chromium.org>
Reviewed-by: Adam Klein <adamk@chromium.org>
Cr-Commit-Position: refs/heads/master@{#636251}",7,third_party/blink/renderer/core/fileapi/file_reader_loader.cc,"{""sha"": ""f79e842dd02f8bfce1bb9f7fe0995e0cda2ae3ae"", ""filename"": ""third_party/blink/renderer/core/fileapi/file_reader_loader.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 7, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/ba9748e78ec7e9c0d594e7edf7b2c07ea2a90449/third_party/blink/renderer/core/fileapi/file_reader_loader.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ba9748e78ec7e9c0d594e7edf7b2c07ea2a90449/third_party/blink/renderer/core/fileapi/file_reader_loader.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/fileapi/file_reader_loader.cc?ref=ba9748e78ec7e9c0d594e7edf7b2c07ea2a90449"", ""patch"": ""@@ -139,14 +139,16 @@ DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {\n   if (!raw_data_ || error_code_ != FileErrorCode::kOK)\n     return nullptr;\n \n-  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());\n-  if (finished_loading_) {\n-    array_buffer_result_ = result;\n-    AdjustReportedMemoryUsageToV8(\n-        -1 * static_cast<int64_t>(raw_data_->ByteLength()));\n-    raw_data_.reset();\n+  if (!finished_loading_) {\n+    return DOMArrayBuffer::Create(\n+        ArrayBuffer::Create(raw_data_->Data(), raw_data_->ByteLength()));\n   }\n-  return result;\n+\n+  array_buffer_result_ = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());\n+  AdjustReportedMemoryUsageToV8(-1 *\n+                                static_cast<int64_t>(raw_data_->ByteLength()));\n+  raw_data_.reset();\n+  return array_buffer_result_;\n }\n \n String FileReaderLoader::StringResult() {""}","DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {
  DCHECK_EQ(read_type_, kReadAsArrayBuffer);
  if (array_buffer_result_)
    return array_buffer_result_;

   if (!raw_data_ || error_code_ != FileErrorCode::kOK)
     return nullptr;
 
  if (!finished_loading_) {
    return DOMArrayBuffer::Create(
        ArrayBuffer::Create(raw_data_->Data(), raw_data_->ByteLength()));
   }

  array_buffer_result_ = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
  AdjustReportedMemoryUsageToV8(-1 *
                                static_cast<int64_t>(raw_data_->ByteLength()));
  raw_data_.reset();
  return array_buffer_result_;
 }
","DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {
  DCHECK_EQ(read_type_, kReadAsArrayBuffer);
  if (array_buffer_result_)
    return array_buffer_result_;

   if (!raw_data_ || error_code_ != FileErrorCode::kOK)
     return nullptr;
 
  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
  if (finished_loading_) {
    array_buffer_result_ = result;
    AdjustReportedMemoryUsageToV8(
        -1 * static_cast<int64_t>(raw_data_->ByteLength()));
    raw_data_.reset();
   }
  return result;
 }
",C,"  if (!finished_loading_) {
    return DOMArrayBuffer::Create(
        ArrayBuffer::Create(raw_data_->Data(), raw_data_->ByteLength()));

  array_buffer_result_ = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
  AdjustReportedMemoryUsageToV8(-1 *
                                static_cast<int64_t>(raw_data_->ByteLength()));
  raw_data_.reset();
  return array_buffer_result_;
","  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
  if (finished_loading_) {
    array_buffer_result_ = result;
    AdjustReportedMemoryUsageToV8(
        -1 * static_cast<int64_t>(raw_data_->ByteLength()));
    raw_data_.reset();
  return result;
",,"@@ -139,14 +139,16 @@ DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {
   if (!raw_data_ || error_code_ != FileErrorCode::kOK)
     return nullptr;
 
-  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
-  if (finished_loading_) {
-    array_buffer_result_ = result;
-    AdjustReportedMemoryUsageToV8(
-        -1 * static_cast<int64_t>(raw_data_->ByteLength()));
-    raw_data_.reset();
+  if (!finished_loading_) {
+    return DOMArrayBuffer::Create(
+        ArrayBuffer::Create(raw_data_->Data(), raw_data_->ByteLength()));
   }
-  return result;
+
+  array_buffer_result_ = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
+  AdjustReportedMemoryUsageToV8(-1 *
+                                static_cast<int64_t>(raw_data_->ByteLength()));
+  raw_data_.reset();
+  return array_buffer_result_;
 }
 
 String FileReaderLoader::StringResult() {",Chrome,ba9748e78ec7e9c0d594e7edf7b2c07ea2a90449,9f3fccdba567f30ea39b08f57d8d5b49cd832b4a,1,"DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {
  DCHECK_EQ(read_type_, kReadAsArrayBuffer);
  if (array_buffer_result_)
    return array_buffer_result_;

  // If the loading is not started or an error occurs, return an empty result.
   if (!raw_data_ || error_code_ != FileErrorCode::kOK)
     return nullptr;
 
//flaw_line_below:
  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
//flaw_line_below:
  if (finished_loading_) {
//flaw_line_below:
    array_buffer_result_ = result;
//flaw_line_below:
    AdjustReportedMemoryUsageToV8(
//flaw_line_below:
        -1 * static_cast<int64_t>(raw_data_->ByteLength()));
//flaw_line_below:
    raw_data_.reset();
//fix_flaw_line_below:
//  if (!finished_loading_) {
//fix_flaw_line_below:
//    return DOMArrayBuffer::Create(
//fix_flaw_line_below:
//        ArrayBuffer::Create(raw_data_->Data(), raw_data_->ByteLength()));
   }
//flaw_line_below:
  return result;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  array_buffer_result_ = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
//fix_flaw_line_below:
//  AdjustReportedMemoryUsageToV8(-1 *
//fix_flaw_line_below:
//                                static_cast<int64_t>(raw_data_->ByteLength()));
//fix_flaw_line_below:
//  raw_data_.reset();
//fix_flaw_line_below:
//  return array_buffer_result_;
 }
",187047,"DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {
  DCHECK_EQ(read_type_, kReadAsArrayBuffer);
  if (array_buffer_result_)
    return array_buffer_result_;

   if (!raw_data_ || error_code_ != FileErrorCode::kOK)
     return nullptr;
 
  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
  if (finished_loading_) {
    array_buffer_result_ = result;
    AdjustReportedMemoryUsageToV8(
        -1 * static_cast<int64_t>(raw_data_->ByteLength()));
    raw_data_.reset();
   }
  return result;
 }
","DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {
  DCHECK_EQ(read_type_, kReadAsArrayBuffer);
  if (array_buffer_result_)
    return array_buffer_result_;

   if (!raw_data_ || error_code_ != FileErrorCode::kOK)
     return nullptr;
 
  if (!finished_loading_) {
    return DOMArrayBuffer::Create(
        ArrayBuffer::Create(raw_data_->Data(), raw_data_->ByteLength()));
   }

  array_buffer_result_ = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
  AdjustReportedMemoryUsageToV8(-1 *
                                static_cast<int64_t>(raw_data_->ByteLength()));
  raw_data_.reset();
  return array_buffer_result_;
 }
","The `ArrayBufferResult` function in the `FileReaderLoader` class is designed to return a `DOMArrayBuffer` object when the read type is set to `kReadAsArrayBuffer`. It first checks if an `array_buffer_result_` already exists; if so, it returns that. If there is no raw data or if an error has occurred, it returns `nullptr`. If the loading is complete, it creates a new `DOMArrayBuffer` from the raw data, updates the memory usage reported to V8, and resets the raw data. Finally, it returns the created `DOMArrayBuffer` or `nullptr` if conditions are not met.","The provided code defines a method that retrieves a specific type of data buffer when the reading process is set to a particular mode. It first checks if a previously created buffer exists and returns it if available. If there is no data or an error has occurred, it returns a null value. Upon successful completion of the loading process, it generates a new data buffer from the available raw data, adjusts the memory usage accordingly, and clears the raw data reference. Ultimately, it returns the newly created buffer or a null value if the conditions are not satisfied.","The vulnerability in the original code stemmed from the potential for multiple references to the same underlying data buffer when returning partial results, which could lead to unintended modifications or memory issues. In the fixed code, a check for the loading status was added, and when the loading was not finished, a new copy of the data buffer is created using the `ArrayBuffer::Create` method, ensuring that each call returns a distinct buffer. This change prevents the risk of shared references, thereby enhancing memory safety while incurring minimal performance overhead, as partial results are infrequently used.","The vulnerability in the original code arose from the risk of multiple references to the same underlying data buffer when returning partial results, which could lead to unintended side effects or data corruption. The fix involved creating a new copy of the data buffer when partial results are returned, ensuring that each result is independent and does not share references with others. This change effectively mitigates the risk of accidental modifications to the same buffer, enhancing memory safety while maintaining minimal performance overhead, as the occurrence of partial results is infrequent.","The vulnerability was fixed by introducing a conditional check for the loading status in the modified code. When the loading is not finished, the code now creates a new copy of the data buffer using `ArrayBuffer::Create(raw_data_->Data(), raw_data_->ByteLength())`, ensuring that a distinct buffer is returned instead of a reference to the original. This prevents multiple references to the same underlying buffer, thereby eliminating the risk of unintended modifications. Additionally, when loading is complete, the code still creates a buffer using `ToArrayBuffer()`, but now the handling of partial results is safer and more robust.","The vulnerability was addressed by implementing a mechanism to create a new, independent copy of the data buffer when partial results are returned. This change ensures that each result is distinct and does not share references with the original buffer, thereby preventing unintended modifications or data corruption. The updated logic includes a check for the loading status, allowing the system to handle both complete and partial results safely. As a result, the risk of multiple references to the same underlying data is eliminated, enhancing overall memory safety while maintaining minimal performance impact.","CWE-788, CWE-761, CWE-763, CWE-672, CWE-416, CWE-415, CWE-476, CWE-665, CWE-664, CWE-119",N,-1
81,81,187144,187144,,Local Network,Not required,,CVE-2018-6171,https://www.cvedetails.com/cve/CVE-2018-6171/,CWE-416,Medium,Partial,,,2019-06-27,2.9,Use after free in Bluetooth in Google Chrome prior to 68.0.3440.75 allowed an attacker who convinced a user to install a malicious extension to obtain potentially sensitive information from process memory via a crafted Chrome Extension.,2019-07-01,+Info ,5,https://github.com/chromium/chromium/commit/c5c6320f80159dc41dffc3cfbf0298925c7dcf1b,c5c6320f80159dc41dffc3cfbf0298925c7dcf1b,"chrome.bluetoothSocket: Fix regression in send()

In https://crrev.com/c/997098, params_ was changed to a local variable,
but it needs to last longer than that since net::WrappedIOBuffer may use
the data after the local variable goes out of scope.

This CL changed it back to be an instance variable.

Bug: 851799
Change-Id: I392f8acaef4c6473d6ea4fbee7209445aa09112e
Reviewed-on: https://chromium-review.googlesource.com/1103676
Reviewed-by: Toni Barzic <tbarzic@chromium.org>
Commit-Queue: Sonny Sasaka <sonnysasaka@chromium.org>
Cr-Commit-Position: refs/heads/master@{#568137}",5,extensions/browser/api/bluetooth_socket/bluetooth_socket_api.cc,"{""sha"": ""69134a8a2a88d4815ac353177cb77566a5bbbd42"", ""filename"": ""extensions/browser/api/bluetooth_socket/bluetooth_socket_api.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c5c6320f80159dc41dffc3cfbf0298925c7dcf1b/extensions/browser/api/bluetooth_socket/bluetooth_socket_api.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c5c6320f80159dc41dffc3cfbf0298925c7dcf1b/extensions/browser/api/bluetooth_socket/bluetooth_socket_api.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/browser/api/bluetooth_socket/bluetooth_socket_api.cc?ref=c5c6320f80159dc41dffc3cfbf0298925c7dcf1b"", ""patch"": ""@@ -545,13 +545,13 @@ BluetoothSocketSendFunction::~BluetoothSocketSendFunction() {}\n ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {\n   DCHECK_CURRENTLY_ON(work_thread_id());\n \n-  auto params = bluetooth_socket::Send::Params::Create(*args_);\n-  EXTENSION_FUNCTION_VALIDATE(params.get());\n+  params_ = bluetooth_socket::Send::Params::Create(*args_);\n+  EXTENSION_FUNCTION_VALIDATE(params_.get());\n \n-  io_buffer_size_ = params->data.size();\n-  io_buffer_ = new net::WrappedIOBuffer(params->data.data());\n+  io_buffer_size_ = params_->data.size();\n+  io_buffer_ = new net::WrappedIOBuffer(params_->data.data());\n \n-  BluetoothApiSocket* socket = GetSocket(params->socket_id);\n+  BluetoothApiSocket* socket = GetSocket(params_->socket_id);\n   if (!socket)\n     return RespondNow(Error(kSocketNotFoundError));\n ""}<_**next**_>{""sha"": ""bbab919aacbadbdccd0bcc429e9e3f23648df406"", ""filename"": ""extensions/browser/api/bluetooth_socket/bluetooth_socket_api.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/c5c6320f80159dc41dffc3cfbf0298925c7dcf1b/extensions/browser/api/bluetooth_socket/bluetooth_socket_api.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c5c6320f80159dc41dffc3cfbf0298925c7dcf1b/extensions/browser/api/bluetooth_socket/bluetooth_socket_api.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/extensions/browser/api/bluetooth_socket/bluetooth_socket_api.h?ref=c5c6320f80159dc41dffc3cfbf0298925c7dcf1b"", ""patch"": ""@@ -294,6 +294,7 @@ class BluetoothSocketSendFunction : public BluetoothSocketAsyncApiFunction {\n   void OnError(BluetoothApiSocket::ErrorReason reason,\n                const std::string& message);\n \n+  std::unique_ptr<bluetooth_socket::Send::Params> params_;\n   scoped_refptr<net::IOBuffer> io_buffer_;\n   size_t io_buffer_size_;\n ""}"," ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {
   DCHECK_CURRENTLY_ON(work_thread_id());
 
  params_ = bluetooth_socket::Send::Params::Create(*args_);
  EXTENSION_FUNCTION_VALIDATE(params_.get());
 
  io_buffer_size_ = params_->data.size();
  io_buffer_ = new net::WrappedIOBuffer(params_->data.data());
 
  BluetoothApiSocket* socket = GetSocket(params_->socket_id);
   if (!socket)
     return RespondNow(Error(kSocketNotFoundError));
 
  socket->Send(io_buffer_,
               io_buffer_size_,
               base::Bind(&BluetoothSocketSendFunction::OnSuccess, this),
               base::Bind(&BluetoothSocketSendFunction::OnError, this));
  return did_respond() ? AlreadyResponded() : RespondLater();
}
"," ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {
   DCHECK_CURRENTLY_ON(work_thread_id());
 
  auto params = bluetooth_socket::Send::Params::Create(*args_);
  EXTENSION_FUNCTION_VALIDATE(params.get());
 
  io_buffer_size_ = params->data.size();
  io_buffer_ = new net::WrappedIOBuffer(params->data.data());
 
  BluetoothApiSocket* socket = GetSocket(params->socket_id);
   if (!socket)
     return RespondNow(Error(kSocketNotFoundError));
 
  socket->Send(io_buffer_,
               io_buffer_size_,
               base::Bind(&BluetoothSocketSendFunction::OnSuccess, this),
               base::Bind(&BluetoothSocketSendFunction::OnError, this));
  return did_respond() ? AlreadyResponded() : RespondLater();
}
",C,"  params_ = bluetooth_socket::Send::Params::Create(*args_);
  EXTENSION_FUNCTION_VALIDATE(params_.get());
  io_buffer_size_ = params_->data.size();
  io_buffer_ = new net::WrappedIOBuffer(params_->data.data());
  BluetoothApiSocket* socket = GetSocket(params_->socket_id);
","  auto params = bluetooth_socket::Send::Params::Create(*args_);
  EXTENSION_FUNCTION_VALIDATE(params.get());
  io_buffer_size_ = params->data.size();
  io_buffer_ = new net::WrappedIOBuffer(params->data.data());
  BluetoothApiSocket* socket = GetSocket(params->socket_id);
",,"@@ -545,13 +545,13 @@ BluetoothSocketSendFunction::~BluetoothSocketSendFunction() {}
 ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {
   DCHECK_CURRENTLY_ON(work_thread_id());
 
-  auto params = bluetooth_socket::Send::Params::Create(*args_);
-  EXTENSION_FUNCTION_VALIDATE(params.get());
+  params_ = bluetooth_socket::Send::Params::Create(*args_);
+  EXTENSION_FUNCTION_VALIDATE(params_.get());
 
-  io_buffer_size_ = params->data.size();
-  io_buffer_ = new net::WrappedIOBuffer(params->data.data());
+  io_buffer_size_ = params_->data.size();
+  io_buffer_ = new net::WrappedIOBuffer(params_->data.data());
 
-  BluetoothApiSocket* socket = GetSocket(params->socket_id);
+  BluetoothApiSocket* socket = GetSocket(params_->socket_id);
   if (!socket)
     return RespondNow(Error(kSocketNotFoundError));
 ",Chrome,c5c6320f80159dc41dffc3cfbf0298925c7dcf1b,9e0b47c55c747f6cd6913f8b2431e443bc7b6129,1," ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {
   DCHECK_CURRENTLY_ON(work_thread_id());
 
//flaw_line_below:
  auto params = bluetooth_socket::Send::Params::Create(*args_);
//flaw_line_below:
  EXTENSION_FUNCTION_VALIDATE(params.get());
//fix_flaw_line_below:
//  params_ = bluetooth_socket::Send::Params::Create(*args_);
//fix_flaw_line_below:
//  EXTENSION_FUNCTION_VALIDATE(params_.get());
 
//flaw_line_below:
  io_buffer_size_ = params->data.size();
//flaw_line_below:
  io_buffer_ = new net::WrappedIOBuffer(params->data.data());
//fix_flaw_line_below:
//  io_buffer_size_ = params_->data.size();
//fix_flaw_line_below:
//  io_buffer_ = new net::WrappedIOBuffer(params_->data.data());
 
//flaw_line_below:
  BluetoothApiSocket* socket = GetSocket(params->socket_id);
//fix_flaw_line_below:
//  BluetoothApiSocket* socket = GetSocket(params_->socket_id);
   if (!socket)
     return RespondNow(Error(kSocketNotFoundError));
 
  socket->Send(io_buffer_,
               io_buffer_size_,
               base::Bind(&BluetoothSocketSendFunction::OnSuccess, this),
               base::Bind(&BluetoothSocketSendFunction::OnError, this));
  return did_respond() ? AlreadyResponded() : RespondLater();
}
",187144," ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {
   DCHECK_CURRENTLY_ON(work_thread_id());
 
  auto params = bluetooth_socket::Send::Params::Create(*args_);
  EXTENSION_FUNCTION_VALIDATE(params.get());
 
  io_buffer_size_ = params->data.size();
  io_buffer_ = new net::WrappedIOBuffer(params->data.data());
 
  BluetoothApiSocket* socket = GetSocket(params->socket_id);
   if (!socket)
     return RespondNow(Error(kSocketNotFoundError));
 
  socket->Send(io_buffer_,
               io_buffer_size_,
               base::Bind(&BluetoothSocketSendFunction::OnSuccess, this),
               base::Bind(&BluetoothSocketSendFunction::OnError, this));
  return did_respond() ? AlreadyResponded() : RespondLater();
}
"," ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {
   DCHECK_CURRENTLY_ON(work_thread_id());
 
  params_ = bluetooth_socket::Send::Params::Create(*args_);
  EXTENSION_FUNCTION_VALIDATE(params_.get());
 
  io_buffer_size_ = params_->data.size();
  io_buffer_ = new net::WrappedIOBuffer(params_->data.data());
 
  BluetoothApiSocket* socket = GetSocket(params_->socket_id);
   if (!socket)
     return RespondNow(Error(kSocketNotFoundError));
 
  socket->Send(io_buffer_,
               io_buffer_size_,
               base::Bind(&BluetoothSocketSendFunction::OnSuccess, this),
               base::Bind(&BluetoothSocketSendFunction::OnError, this));
  return did_respond() ? AlreadyResponded() : RespondLater();
}
","The `BluetoothSocketSendFunction::Run()` method is designed to handle sending data over a Bluetooth socket in a Chrome extension. It first checks that the function is being executed on the correct thread and then creates parameters from the provided arguments. The method validates these parameters and initializes a buffer with the data to be sent. It retrieves the Bluetooth socket using the provided socket ID, returning an error if the socket is not found. Finally, it attempts to send the data using the socket's `Send` method, binding success and error callbacks, and determines whether to respond immediately or later based on the response state.","The provided code defines a method that facilitates sending data over a Bluetooth socket within a Chrome extension. It begins by ensuring the method is executed on the appropriate thread and then processes the input parameters to extract the data to be sent. After validating these parameters, it allocates a buffer for the data. The method retrieves the corresponding Bluetooth socket and checks its validity, returning an error if it is not found. Finally, it attempts to send the data through the socket, setting up callbacks for success and error handling, while determining whether to respond immediately or defer the response.","The vulnerability in the original code arose from changing the `params_` variable to a local variable, which caused it to go out of scope before the `net::WrappedIOBuffer` could finish using the data. This could lead to undefined behavior or crashes, as the buffer might reference invalid memory. The fix involved reverting `params_` back to an instance variable, ensuring that it remains valid for the duration of the data's use by the `WrappedIOBuffer`. This change guarantees that the data remains accessible and properly managed throughout the execution of the send operation, thus resolving the regression.","The vulnerability in the original code stemmed from changing a critical parameter to a local variable, which led to potential memory access issues when the data was used after the variable went out of scope. This could result in undefined behavior or crashes, as the data might no longer be valid. The fix involved reverting this parameter back to an instance variable, ensuring that it remains in scope and accessible for the duration of its use. This change effectively resolved the regression by maintaining the integrity of the data throughout the execution of the send operation, preventing any memory-related errors.","The vulnerability was fixed by changing the `params_` variable back from a local variable to an instance variable. In the original code, the local variable could go out of scope before the `net::WrappedIOBuffer` finished using the data, leading to potential memory access issues. By restoring `params_` as an instance variable, it ensures that the data remains valid and accessible for the entire duration of its use, particularly during the execution of the `Send` method. This adjustment prevents undefined behavior and ensures the stability of the send operation, effectively resolving the regression.","The vulnerability was fixed by reverting a critical parameter from a local scope back to an instance scope. This change ensures that the data remains valid and accessible for the entire duration it is needed, particularly during operations that may reference it after the original scope would have ended. By maintaining the parameter as an instance variable, the code prevents potential memory access issues and undefined behavior that could arise from using data that has gone out of scope. This adjustment effectively stabilizes the operation and resolves the regression that was introduced in the previous implementation.","CWE-562, CWE-672, CWE-416, CWE-908, CWE-415, CWE-825, CWE-664, CWE-911, CWE-665, CWE-459",N,-1
82,82,187166,187166,,Remote,Not required,Partial,CVE-2018-16067,https://www.cvedetails.com/cve/CVE-2018-16067/,CWE-416,Medium,,,,2019-01-09,4.3,A use after free in WebAudio in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.,2019-01-15,,8,https://github.com/chromium/chromium/commit/ca1156974cbe707fd023a00ae62104528833a44e,ca1156974cbe707fd023a00ae62104528833a44e,"Audio thread should not access destination node

The AudioDestinationNode is an object managed by Oilpan so the audio
thread should not access it.  However, the audio thread needs
information (currentTime, etc) from the destination node. So instead
of accessing the audio destination handler (a scoped_refptr) via the
destination node, add a new member to the base audio context that
holds onto the destination handler.

The destination handler is not an oilpan object and lives at least as
long as the base audio context.

Bug: 860626, 860522, 863951
Test: Test case from 860522 doesn't crash on asan build
Change-Id: I3add844d4eb8fdc7e05b89292938b843a0abbb99
Reviewed-on: https://chromium-review.googlesource.com/1138974
Commit-Queue: Raymond Toy <rtoy@chromium.org>
Reviewed-by: Hongchan Choi <hongchan@chromium.org>
Cr-Commit-Position: refs/heads/master@{#575509}",0,third_party/blink/renderer/modules/webaudio/base_audio_context.cc,"{""sha"": ""f30bd880a15908c7783ecec8a0881a51e37f0891"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/ca1156974cbe707fd023a00ae62104528833a44e/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ca1156974cbe707fd023a00ae62104528833a44e/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.cc?ref=ca1156974cbe707fd023a00ae62104528833a44e"", ""patch"": ""@@ -120,6 +120,14 @@ void BaseAudioContext::Initialize() {\n \n   if (destination_node_) {\n     destination_node_->Handler().Initialize();\n+    // TODO(crbug.com/863951).  The audio thread needs some things from the\n+    // destination handler like the currentTime.  But the audio thread\n+    // shouldn't access the |destination_node_| since it's an Oilpan object.\n+    // Thus, get the destination handler, a non-oilpan object, so we can get\n+    // the items directly from the handler instead of through the destination\n+    // node.\n+    destination_handler_ = &destination_node_->GetAudioDestinationHandler();\n+\n     // The AudioParams in the listener need access to the destination node, so\n     // only create the listener if the destination node exists.\n     listener_ = AudioListener::Create(*this);""}<_**next**_>{""sha"": ""f55e32c4b70ac57b32d4ca17811fe10f47f5cb89"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 15, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/ca1156974cbe707fd023a00ae62104528833a44e/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ca1156974cbe707fd023a00ae62104528833a44e/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.h?ref=ca1156974cbe707fd023a00ae62104528833a44e"", ""patch"": ""@@ -127,24 +127,12 @@ class MODULES_EXPORT BaseAudioContext\n   AudioDestinationNode* destination() const;\n \n   size_t CurrentSampleFrame() const {\n-    // TODO(crbug.com/863951): |destination_node| is a GC-mananged object and\n-    // should not be touched by the audio rendering thread.\n-    return destination_node_ ? destination_node_->GetAudioDestinationHandler()\n-                                   .CurrentSampleFrame()\n-                             : 0;\n+    return destination_handler_->CurrentSampleFrame();\n   }\n \n-  double currentTime() const {\n-    // TODO(crbug.com/863951): |destination_node| is a GC-mananged object and\n-    // should not be touched by the audio rendering thread.\n-    return destination_node_\n-               ? destination_node_->GetAudioDestinationHandler().CurrentTime()\n-               : 0;\n-  }\n+  double currentTime() const { return destination_handler_->CurrentTime(); }\n \n-  float sampleRate() const {\n-    return destination_node_->GetAudioDestinationHandler().SampleRate();\n-  }\n+  float sampleRate() const { return destination_handler_->SampleRate(); }\n \n   String state() const;\n   AudioContextState ContextState() const { return context_state_; }\n@@ -453,6 +441,9 @@ class MODULES_EXPORT BaseAudioContext\n \n   AudioIOPosition output_position_;\n \n+  // The handler associated with the above |destination_node_|.\n+  scoped_refptr<AudioDestinationHandler> destination_handler_;\n+\n   Member<AudioWorklet> audio_worklet_;\n \n   // In order to update some information (e.g. current frame) in""}","void BaseAudioContext::Initialize() {
  if (IsDestinationInitialized())
    return;

  FFTFrame::Initialize();

  audio_worklet_ = AudioWorklet::Create(this);
 
   if (destination_node_) {
     destination_node_->Handler().Initialize();
    // TODO(crbug.com/863951).  The audio thread needs some things from the
    // destination handler like the currentTime.  But the audio thread
    // shouldn't access the |destination_node_| since it's an Oilpan object.
    // Thus, get the destination handler, a non-oilpan object, so we can get
    // the items directly from the handler instead of through the destination
    // node.
    destination_handler_ = &destination_node_->GetAudioDestinationHandler();

     listener_ = AudioListener::Create(*this);
  }
}
","void BaseAudioContext::Initialize() {
  if (IsDestinationInitialized())
    return;

  FFTFrame::Initialize();

  audio_worklet_ = AudioWorklet::Create(this);
 
   if (destination_node_) {
     destination_node_->Handler().Initialize();
     listener_ = AudioListener::Create(*this);
  }
}
",C,"    // TODO(crbug.com/863951).  The audio thread needs some things from the
    // destination handler like the currentTime.  But the audio thread
    // shouldn't access the |destination_node_| since it's an Oilpan object.
    // Thus, get the destination handler, a non-oilpan object, so we can get
    // the items directly from the handler instead of through the destination
    // node.
    destination_handler_ = &destination_node_->GetAudioDestinationHandler();

",,,"@@ -120,6 +120,14 @@ void BaseAudioContext::Initialize() {
 
   if (destination_node_) {
     destination_node_->Handler().Initialize();
+    // TODO(crbug.com/863951).  The audio thread needs some things from the
+    // destination handler like the currentTime.  But the audio thread
+    // shouldn't access the |destination_node_| since it's an Oilpan object.
+    // Thus, get the destination handler, a non-oilpan object, so we can get
+    // the items directly from the handler instead of through the destination
+    // node.
+    destination_handler_ = &destination_node_->GetAudioDestinationHandler();
+
     // The AudioParams in the listener need access to the destination node, so
     // only create the listener if the destination node exists.
     listener_ = AudioListener::Create(*this);",Chrome,ca1156974cbe707fd023a00ae62104528833a44e,9df3533884d2a5db7731c1af749b1e813dd1d528,1,"void BaseAudioContext::Initialize() {
  if (IsDestinationInitialized())
    return;

  FFTFrame::Initialize();

  audio_worklet_ = AudioWorklet::Create(this);
 
   if (destination_node_) {
     destination_node_->Handler().Initialize();
//fix_flaw_line_below:
//    // TODO(crbug.com/863951).  The audio thread needs some things from the
//fix_flaw_line_below:
//    // destination handler like the currentTime.  But the audio thread
//fix_flaw_line_below:
//    // shouldn't access the |destination_node_| since it's an Oilpan object.
//fix_flaw_line_below:
//    // Thus, get the destination handler, a non-oilpan object, so we can get
//fix_flaw_line_below:
//    // the items directly from the handler instead of through the destination
//fix_flaw_line_below:
//    // node.
//fix_flaw_line_below:
//    destination_handler_ = &destination_node_->GetAudioDestinationHandler();
//fix_flaw_line_below:
//
     // The AudioParams in the listener need access to the destination node, so
     // only create the listener if the destination node exists.
     listener_ = AudioListener::Create(*this);
  }
}
",187166,"void BaseAudioContext::Initialize() {
  if (IsDestinationInitialized())
    return;

  FFTFrame::Initialize();

  audio_worklet_ = AudioWorklet::Create(this);
 
   if (destination_node_) {
     destination_node_->Handler().Initialize();
     listener_ = AudioListener::Create(*this);
  }
}
","void BaseAudioContext::Initialize() {
  if (IsDestinationInitialized())
    return;

  FFTFrame::Initialize();

  audio_worklet_ = AudioWorklet::Create(this);
 
   if (destination_node_) {
     destination_node_->Handler().Initialize();
    // TODO(crbug.com/863951).  The audio thread needs some things from the
    // destination handler like the currentTime.  But the audio thread
    // shouldn't access the |destination_node_| since it's an Oilpan object.
    // Thus, get the destination handler, a non-oilpan object, so we can get
    // the items directly from the handler instead of through the destination
    // node.
    destination_handler_ = &destination_node_->GetAudioDestinationHandler();

     listener_ = AudioListener::Create(*this);
  }
}
","The `BaseAudioContext::Initialize` function is responsible for setting up the audio context within an application. It first checks if the audio destination has already been initialized; if so, it exits early to avoid redundant initialization. If not, it proceeds to initialize the Fast Fourier Transform (FFT) frame. The function then creates an audio worklet, which allows for custom audio processing. If a destination node exists, it initializes the handler for that node and creates an audio listener, enabling the application to capture and process audio input effectively. This setup is crucial for managing audio operations in a structured manner.","The provided code initializes an audio context by first checking if the audio destination is already set up, in which case it exits to prevent duplicate initialization. If the destination is not initialized, it proceeds to set up the necessary components for audio processing, including preparing a framework for frequency analysis. Additionally, it creates a processing unit that allows for custom audio manipulation. If a specific audio node is present, it initializes its handling mechanism and establishes an audio listener to capture and manage audio input, ensuring a comprehensive setup for audio operations within the application.","The vulnerability in the original code arises from the audio thread accessing the `destination_node_`, which is managed by the Oilpan garbage collector, potentially leading to unsafe memory access and crashes. To address this issue, the fixed code introduces a new member, `destination_handler_`, which directly references the audio destination handler instead of going through the `destination_node_`. This change ensures that the audio thread interacts with a non-Oilpan object, thus avoiding the risks associated with accessing Oilpan-managed objects. This modification allows the audio thread to safely retrieve necessary information, such as `currentTime`, without compromising memory safety.","The vulnerability in the original code stems from the audio thread accessing an object managed by a garbage collector, which could lead to unsafe memory access and potential crashes. This situation arises because the audio thread requires certain information from this object, creating a risk when it is accessed directly. The fix involves creating a new member that holds a reference to a handler associated with the object, which is not managed by the garbage collector. This change allows the audio thread to safely obtain the necessary information without risking memory safety, ensuring stable operation within the audio context.","The vulnerability was fixed by introducing a new member, `destination_handler_`, to the base audio context, which holds a reference to the audio destination handler instead of accessing it through the `destination_node_`. This change prevents the audio thread from directly interacting with the `destination_node_`, which is managed by the Oilpan garbage collector, thus avoiding unsafe memory access. By using the `destination_handler_`, the audio thread can safely retrieve necessary information, such as `currentTime`, without the risks associated with accessing an Oilpan object, ensuring both stability and memory safety in the audio processing workflow.","The vulnerability was addressed by creating a new member that directly references the audio destination handler, rather than accessing it through the object managed by the garbage collector. This adjustment ensures that the audio thread interacts with a stable, non-garbage-collected entity, thereby eliminating the risk of unsafe memory access and potential crashes. By establishing this direct reference, the audio thread can safely obtain necessary information without compromising memory safety, thus enhancing the overall stability and reliability of the audio processing system while adhering to proper memory management practices.","CWE-665, CWE-401, CWE-416, CWE-672, CWE-415, CWE-825, CWE-911, CWE-367, CWE-666, CWE-404",N,-1
