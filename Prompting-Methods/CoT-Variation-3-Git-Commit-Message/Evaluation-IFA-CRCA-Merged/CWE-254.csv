,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,T1_Top_10_CWE_IDs,T2_Correctly_Found_CWE,T3_IFA,G1_Clarity_C3_C5,G2_Relevance_C3_C5,G3_Completeness_C3_C5,G4_Actionability_C3_C5
0,0,177939,177939,,Remote,Not required,,CVE-2015-1793,https://www.cvedetails.com/cve/CVE-2015-1793/,CWE-254,Low,Partial,Partial,,2015-07-09,6.4,"The X509_verify_cert function in crypto/x509/x509_vfy.c in OpenSSL 1.0.1n, 1.0.1o, 1.0.2b, and 1.0.2c does not properly process X.509 Basic Constraints cA values during identification of alternative certificate chains, which allows remote attackers to spoof a Certification Authority role and trigger unintended certificate verifications via a valid leaf certificate.",2018-11-30,,1,https://git.openssl.org/?p=openssl.git;a=commit;h=9a0db453ba017ebcaccbee933ee6511a9ae4d1c8,9a0db453ba017ebcaccbee933ee6511a9ae4d1c8,,1,,,"int X509_verify_cert(X509_STORE_CTX *ctx)
{
    X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;
    int bad_chain = 0;
    X509_VERIFY_PARAM *param = ctx->param;
    int depth, i, ok = 0;
    int num, j, retry;
    int (*cb) (int xok, X509_STORE_CTX *xctx);
    STACK_OF(X509) *sktmp = NULL;
    if (ctx->cert == NULL) {
        X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);
        return -1;
    }

    cb = ctx->verify_cb;

    /*
     * first we make sure the chain we are going to build is present and that
     * the first entry is in place
     */
    if (ctx->chain == NULL) {
        if (((ctx->chain = sk_X509_new_null()) == NULL) ||
            (!sk_X509_push(ctx->chain, ctx->cert))) {
            X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
            goto end;
        }
        CRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509);
        ctx->last_untrusted = 1;
    }

    /* We use a temporary STACK so we can chop and hack at it */
    if (ctx->untrusted != NULL
        && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {
        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
        goto end;
    }

    num = sk_X509_num(ctx->chain);
    x = sk_X509_value(ctx->chain, num - 1);
    depth = param->depth;

    for (;;) {
        /* If we have enough, we break */
        if (depth < num)
            break;              /* FIXME: If this happens, we should take
                                 * note of it and, if appropriate, use the
                                 * X509_V_ERR_CERT_CHAIN_TOO_LONG error code
                                 * later. */

        /* If we are self signed, we break */
        if (ctx->check_issued(ctx, x, x))
            break;

        /* If we were passed a cert chain, use it first */
        if (ctx->untrusted != NULL) {
            xtmp = find_issuer(ctx, sktmp, x);
            if (xtmp != NULL) {
                if (!sk_X509_push(ctx->chain, xtmp)) {
                    X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
                    goto end;
                }
                CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);
                (void)sk_X509_delete_ptr(sktmp, xtmp);
                ctx->last_untrusted++;
                x = xtmp;
                num++;
                /*
                 * reparse the full chain for the next one
                 */
                continue;
            }
        }
        break;
    }

    /* Remember how many untrusted certs we have */
    j = num;
    /*
     * at this point, chain should contain a list of untrusted certificates.
     * We now need to add at least one trusted one, if possible, otherwise we
     * complain.
     */

    do {
        /*
         * Examine last certificate in chain and see if it is self signed.
         */
        i = sk_X509_num(ctx->chain);
        x = sk_X509_value(ctx->chain, i - 1);
        if (ctx->check_issued(ctx, x, x)) {
            /* we have a self signed certificate */
            if (sk_X509_num(ctx->chain) == 1) {
                /*
                 * We have a single self signed certificate: see if we can
                 * find it in the store. We must have an exact match to avoid
                 * possible impersonation.
                 */
                ok = ctx->get_issuer(&xtmp, ctx, x);
                if ((ok <= 0) || X509_cmp(x, xtmp)) {
                    ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
                    ctx->current_cert = x;
                    ctx->error_depth = i - 1;
                    if (ok == 1)
                        X509_free(xtmp);
                    bad_chain = 1;
                    ok = cb(0, ctx);
                    if (!ok)
                        goto end;
                } else {
                    /*
                     * We have a match: replace certificate with store
                     * version so we get any trust settings.
                     */
                    X509_free(x);
                    x = xtmp;
                    (void)sk_X509_set(ctx->chain, i - 1, x);
                    ctx->last_untrusted = 0;
                }
            } else {
                /*
                 * extract and save self signed certificate for later use
                 */
                chain_ss = sk_X509_pop(ctx->chain);
                ctx->last_untrusted--;
                num--;
                j--;
                x = sk_X509_value(ctx->chain, num - 1);
            }
        }
        /* We now lookup certs from the certificate store */
        for (;;) {
            /* If we have enough, we break */
            if (depth < num)
                break;
            /* If we are self signed, we break */
            if (ctx->check_issued(ctx, x, x))
                break;
            ok = ctx->get_issuer(&xtmp, ctx, x);
            if (ok < 0)
                return ok;
            if (ok == 0)
                break;
            x = xtmp;
            if (!sk_X509_push(ctx->chain, x)) {
                X509_free(xtmp);
                X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
                return 0;
            }
            num++;
        }

        /*
         * If we haven't got a least one certificate from our store then check
         * if there is an alternative chain that could be used.  We only do this
         * if the user hasn't switched off alternate chain checking
         */
        retry = 0;
        if (j == ctx->last_untrusted &&
            !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {
            while (j-- > 1) {
                xtmp2 = sk_X509_value(ctx->chain, j - 1);
                ok = ctx->get_issuer(&xtmp, ctx, xtmp2);
                if (ok < 0)
                    goto end;
                /* Check if we found an alternate chain */
                if (ok > 0) {
                    /*
                     * Free up the found cert we'll add it again later
                     */
                    X509_free(xtmp);

                    /*
                     * Dump all the certs above this point - we've found an
                     * alternate chain
                     */
                    while (num > j) {
                         xtmp = sk_X509_pop(ctx->chain);
                         X509_free(xtmp);
                         num--;
                     }
                    ctx->last_untrusted = sk_X509_num(ctx->chain);
                     retry = 1;
                     break;
                 }
            }
        }
    } while (retry);

    /* Is last certificate looked up self signed? */
    if (!ctx->check_issued(ctx, x, x)) {
        if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {
            if (ctx->last_untrusted >= num)
                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
            else
                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;
            ctx->current_cert = x;
        } else {

            sk_X509_push(ctx->chain, chain_ss);
            num++;
            ctx->last_untrusted = num;
            ctx->current_cert = chain_ss;
            ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;
            chain_ss = NULL;
        }

        ctx->error_depth = num - 1;
        bad_chain = 1;
        ok = cb(0, ctx);
        if (!ok)
            goto end;
    }

    /* We have the chain complete: now we need to check its purpose */
    ok = check_chain_extensions(ctx);

    if (!ok)
        goto end;

    /* Check name constraints */

    ok = check_name_constraints(ctx);

    if (!ok)
        goto end;

    /* The chain extensions are OK: check trust */

    if (param->trust > 0)
        ok = check_trust(ctx);

    if (!ok)
        goto end;

    /* We may as well copy down any DSA parameters that are required */
    X509_get_pubkey_parameters(NULL, ctx->chain);

    /*
     * Check revocation status: we do this after copying parameters because
     * they may be needed for CRL signature verification.
     */

    ok = ctx->check_revocation(ctx);
    if (!ok)
        goto end;

    /* At this point, we have a chain and need to verify it */
    if (ctx->verify != NULL)
        ok = ctx->verify(ctx);
    else
        ok = internal_verify(ctx);
    if (!ok)
        goto end;

#ifndef OPENSSL_NO_RFC3779
    /* RFC 3779 path validation, now that CRL check has been done */
    ok = v3_asid_validate_path(ctx);
    if (!ok)
        goto end;
    ok = v3_addr_validate_path(ctx);
    if (!ok)
        goto end;
#endif

    /* If we get this far evaluate policies */
    if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))
        ok = ctx->check_policy(ctx);
    if (!ok)
        goto end;
    if (0) {
 end:
        X509_get_pubkey_parameters(NULL, ctx->chain);
    }
    if (sktmp != NULL)
        sk_X509_free(sktmp);
    if (chain_ss != NULL)
        X509_free(chain_ss);
    return ok;
}
","int X509_verify_cert(X509_STORE_CTX *ctx)
{
    X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;
    int bad_chain = 0;
    X509_VERIFY_PARAM *param = ctx->param;
    int depth, i, ok = 0;
    int num, j, retry;
    int (*cb) (int xok, X509_STORE_CTX *xctx);
    STACK_OF(X509) *sktmp = NULL;
    if (ctx->cert == NULL) {
        X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);
        return -1;
    }

    cb = ctx->verify_cb;

    /*
     * first we make sure the chain we are going to build is present and that
     * the first entry is in place
     */
    if (ctx->chain == NULL) {
        if (((ctx->chain = sk_X509_new_null()) == NULL) ||
            (!sk_X509_push(ctx->chain, ctx->cert))) {
            X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
            goto end;
        }
        CRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509);
        ctx->last_untrusted = 1;
    }

    /* We use a temporary STACK so we can chop and hack at it */
    if (ctx->untrusted != NULL
        && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {
        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
        goto end;
    }

    num = sk_X509_num(ctx->chain);
    x = sk_X509_value(ctx->chain, num - 1);
    depth = param->depth;

    for (;;) {
        /* If we have enough, we break */
        if (depth < num)
            break;              /* FIXME: If this happens, we should take
                                 * note of it and, if appropriate, use the
                                 * X509_V_ERR_CERT_CHAIN_TOO_LONG error code
                                 * later. */

        /* If we are self signed, we break */
        if (ctx->check_issued(ctx, x, x))
            break;

        /* If we were passed a cert chain, use it first */
        if (ctx->untrusted != NULL) {
            xtmp = find_issuer(ctx, sktmp, x);
            if (xtmp != NULL) {
                if (!sk_X509_push(ctx->chain, xtmp)) {
                    X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
                    goto end;
                }
                CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);
                (void)sk_X509_delete_ptr(sktmp, xtmp);
                ctx->last_untrusted++;
                x = xtmp;
                num++;
                /*
                 * reparse the full chain for the next one
                 */
                continue;
            }
        }
        break;
    }

    /* Remember how many untrusted certs we have */
    j = num;
    /*
     * at this point, chain should contain a list of untrusted certificates.
     * We now need to add at least one trusted one, if possible, otherwise we
     * complain.
     */

    do {
        /*
         * Examine last certificate in chain and see if it is self signed.
         */
        i = sk_X509_num(ctx->chain);
        x = sk_X509_value(ctx->chain, i - 1);
        if (ctx->check_issued(ctx, x, x)) {
            /* we have a self signed certificate */
            if (sk_X509_num(ctx->chain) == 1) {
                /*
                 * We have a single self signed certificate: see if we can
                 * find it in the store. We must have an exact match to avoid
                 * possible impersonation.
                 */
                ok = ctx->get_issuer(&xtmp, ctx, x);
                if ((ok <= 0) || X509_cmp(x, xtmp)) {
                    ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
                    ctx->current_cert = x;
                    ctx->error_depth = i - 1;
                    if (ok == 1)
                        X509_free(xtmp);
                    bad_chain = 1;
                    ok = cb(0, ctx);
                    if (!ok)
                        goto end;
                } else {
                    /*
                     * We have a match: replace certificate with store
                     * version so we get any trust settings.
                     */
                    X509_free(x);
                    x = xtmp;
                    (void)sk_X509_set(ctx->chain, i - 1, x);
                    ctx->last_untrusted = 0;
                }
            } else {
                /*
                 * extract and save self signed certificate for later use
                 */
                chain_ss = sk_X509_pop(ctx->chain);
                ctx->last_untrusted--;
                num--;
                j--;
                x = sk_X509_value(ctx->chain, num - 1);
            }
        }
        /* We now lookup certs from the certificate store */
        for (;;) {
            /* If we have enough, we break */
            if (depth < num)
                break;
            /* If we are self signed, we break */
            if (ctx->check_issued(ctx, x, x))
                break;
            ok = ctx->get_issuer(&xtmp, ctx, x);
            if (ok < 0)
                return ok;
            if (ok == 0)
                break;
            x = xtmp;
            if (!sk_X509_push(ctx->chain, x)) {
                X509_free(xtmp);
                X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
                return 0;
            }
            num++;
        }

        /*
         * If we haven't got a least one certificate from our store then check
         * if there is an alternative chain that could be used.  We only do this
         * if the user hasn't switched off alternate chain checking
         */
        retry = 0;
        if (j == ctx->last_untrusted &&
            !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {
            while (j-- > 1) {
                xtmp2 = sk_X509_value(ctx->chain, j - 1);
                ok = ctx->get_issuer(&xtmp, ctx, xtmp2);
                if (ok < 0)
                    goto end;
                /* Check if we found an alternate chain */
                if (ok > 0) {
                    /*
                     * Free up the found cert we'll add it again later
                     */
                    X509_free(xtmp);

                    /*
                     * Dump all the certs above this point - we've found an
                     * alternate chain
                     */
                    while (num > j) {
                         xtmp = sk_X509_pop(ctx->chain);
                         X509_free(xtmp);
                         num--;
                        ctx->last_untrusted--;
                     }
                     retry = 1;
                     break;
                 }
            }
        }
    } while (retry);

    /* Is last certificate looked up self signed? */
    if (!ctx->check_issued(ctx, x, x)) {
        if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {
            if (ctx->last_untrusted >= num)
                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
            else
                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;
            ctx->current_cert = x;
        } else {

            sk_X509_push(ctx->chain, chain_ss);
            num++;
            ctx->last_untrusted = num;
            ctx->current_cert = chain_ss;
            ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;
            chain_ss = NULL;
        }

        ctx->error_depth = num - 1;
        bad_chain = 1;
        ok = cb(0, ctx);
        if (!ok)
            goto end;
    }

    /* We have the chain complete: now we need to check its purpose */
    ok = check_chain_extensions(ctx);

    if (!ok)
        goto end;

    /* Check name constraints */

    ok = check_name_constraints(ctx);

    if (!ok)
        goto end;

    /* The chain extensions are OK: check trust */

    if (param->trust > 0)
        ok = check_trust(ctx);

    if (!ok)
        goto end;

    /* We may as well copy down any DSA parameters that are required */
    X509_get_pubkey_parameters(NULL, ctx->chain);

    /*
     * Check revocation status: we do this after copying parameters because
     * they may be needed for CRL signature verification.
     */

    ok = ctx->check_revocation(ctx);
    if (!ok)
        goto end;

    /* At this point, we have a chain and need to verify it */
    if (ctx->verify != NULL)
        ok = ctx->verify(ctx);
    else
        ok = internal_verify(ctx);
    if (!ok)
        goto end;

#ifndef OPENSSL_NO_RFC3779
    /* RFC 3779 path validation, now that CRL check has been done */
    ok = v3_asid_validate_path(ctx);
    if (!ok)
        goto end;
    ok = v3_addr_validate_path(ctx);
    if (!ok)
        goto end;
#endif

    /* If we get this far evaluate policies */
    if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))
        ok = ctx->check_policy(ctx);
    if (!ok)
        goto end;
    if (0) {
 end:
        X509_get_pubkey_parameters(NULL, ctx->chain);
    }
    if (sktmp != NULL)
        sk_X509_free(sktmp);
    if (chain_ss != NULL)
        X509_free(chain_ss);
    return ok;
}
",C,"                    ctx->last_untrusted = sk_X509_num(ctx->chain);
","                        ctx->last_untrusted--;
",cb6e0ed17a61ae3711d385f517d61be2b4c33a55,"@@ -328,8 +328,8 @@ int X509_verify_cert(X509_STORE_CTX *ctx)
                         xtmp = sk_X509_pop(ctx->chain);
                         X509_free(xtmp);
                         num--;
-                        ctx->last_untrusted--;
                     }
+                    ctx->last_untrusted = sk_X509_num(ctx->chain);
                     retry = 1;
                     break;
                 }",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/x509/x509_vfy.c;h=a0083b552d3a53402ab6c751b95f8d45eeb0183e;hb=a0083b552d3a53402ab6c751b95f8d45eeb0183e,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/x509/x509_vfy.c;h=16db4c025a14539427f02eede2018bd7264660e3;hb=16db4c025a14539427f02eede2018bd7264660e3,1,"int X509_verify_cert(X509_STORE_CTX *ctx)
{
    X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;
    int bad_chain = 0;
    X509_VERIFY_PARAM *param = ctx->param;
    int depth, i, ok = 0;
    int num, j, retry;
    int (*cb) (int xok, X509_STORE_CTX *xctx);
    STACK_OF(X509) *sktmp = NULL;
    if (ctx->cert == NULL) {
        X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);
        return -1;
    }

    cb = ctx->verify_cb;

    /*
     * first we make sure the chain we are going to build is present and that
     * the first entry is in place
     */
    if (ctx->chain == NULL) {
        if (((ctx->chain = sk_X509_new_null()) == NULL) ||
            (!sk_X509_push(ctx->chain, ctx->cert))) {
            X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
            goto end;
        }
        CRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509);
        ctx->last_untrusted = 1;
    }

    /* We use a temporary STACK so we can chop and hack at it */
    if (ctx->untrusted != NULL
        && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {
        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
        goto end;
    }

    num = sk_X509_num(ctx->chain);
    x = sk_X509_value(ctx->chain, num - 1);
    depth = param->depth;

    for (;;) {
        /* If we have enough, we break */
        if (depth < num)
            break;              /* FIXME: If this happens, we should take
                                 * note of it and, if appropriate, use the
                                 * X509_V_ERR_CERT_CHAIN_TOO_LONG error code
                                 * later. */

        /* If we are self signed, we break */
        if (ctx->check_issued(ctx, x, x))
            break;

        /* If we were passed a cert chain, use it first */
        if (ctx->untrusted != NULL) {
            xtmp = find_issuer(ctx, sktmp, x);
            if (xtmp != NULL) {
                if (!sk_X509_push(ctx->chain, xtmp)) {
                    X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
                    goto end;
                }
                CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);
                (void)sk_X509_delete_ptr(sktmp, xtmp);
                ctx->last_untrusted++;
                x = xtmp;
                num++;
                /*
                 * reparse the full chain for the next one
                 */
                continue;
            }
        }
        break;
    }

    /* Remember how many untrusted certs we have */
    j = num;
    /*
     * at this point, chain should contain a list of untrusted certificates.
     * We now need to add at least one trusted one, if possible, otherwise we
     * complain.
     */

    do {
        /*
         * Examine last certificate in chain and see if it is self signed.
         */
        i = sk_X509_num(ctx->chain);
        x = sk_X509_value(ctx->chain, i - 1);
        if (ctx->check_issued(ctx, x, x)) {
            /* we have a self signed certificate */
            if (sk_X509_num(ctx->chain) == 1) {
                /*
                 * We have a single self signed certificate: see if we can
                 * find it in the store. We must have an exact match to avoid
                 * possible impersonation.
                 */
                ok = ctx->get_issuer(&xtmp, ctx, x);
                if ((ok <= 0) || X509_cmp(x, xtmp)) {
                    ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
                    ctx->current_cert = x;
                    ctx->error_depth = i - 1;
                    if (ok == 1)
                        X509_free(xtmp);
                    bad_chain = 1;
                    ok = cb(0, ctx);
                    if (!ok)
                        goto end;
                } else {
                    /*
                     * We have a match: replace certificate with store
                     * version so we get any trust settings.
                     */
                    X509_free(x);
                    x = xtmp;
                    (void)sk_X509_set(ctx->chain, i - 1, x);
                    ctx->last_untrusted = 0;
                }
            } else {
                /*
                 * extract and save self signed certificate for later use
                 */
                chain_ss = sk_X509_pop(ctx->chain);
                ctx->last_untrusted--;
                num--;
                j--;
                x = sk_X509_value(ctx->chain, num - 1);
            }
        }
        /* We now lookup certs from the certificate store */
        for (;;) {
            /* If we have enough, we break */
            if (depth < num)
                break;
            /* If we are self signed, we break */
            if (ctx->check_issued(ctx, x, x))
                break;
            ok = ctx->get_issuer(&xtmp, ctx, x);
            if (ok < 0)
                return ok;
            if (ok == 0)
                break;
            x = xtmp;
            if (!sk_X509_push(ctx->chain, x)) {
                X509_free(xtmp);
                X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
                return 0;
            }
            num++;
        }

        /*
         * If we haven't got a least one certificate from our store then check
         * if there is an alternative chain that could be used.  We only do this
         * if the user hasn't switched off alternate chain checking
         */
        retry = 0;
        if (j == ctx->last_untrusted &&
            !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {
            while (j-- > 1) {
                xtmp2 = sk_X509_value(ctx->chain, j - 1);
                ok = ctx->get_issuer(&xtmp, ctx, xtmp2);
                if (ok < 0)
                    goto end;
                /* Check if we found an alternate chain */
                if (ok > 0) {
                    /*
                     * Free up the found cert we'll add it again later
                     */
                    X509_free(xtmp);

                    /*
                     * Dump all the certs above this point - we've found an
                     * alternate chain
                     */
                    while (num > j) {
                         xtmp = sk_X509_pop(ctx->chain);
                         X509_free(xtmp);
                         num--;
//flaw_line_below:
                        ctx->last_untrusted--;
                     }
//fix_flaw_line_below:
//                    ctx->last_untrusted = sk_X509_num(ctx->chain);
                     retry = 1;
                     break;
                 }
            }
        }
    } while (retry);

    /* Is last certificate looked up self signed? */
    if (!ctx->check_issued(ctx, x, x)) {
        if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {
            if (ctx->last_untrusted >= num)
                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
            else
                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;
            ctx->current_cert = x;
        } else {

            sk_X509_push(ctx->chain, chain_ss);
            num++;
            ctx->last_untrusted = num;
            ctx->current_cert = chain_ss;
            ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;
            chain_ss = NULL;
        }

        ctx->error_depth = num - 1;
        bad_chain = 1;
        ok = cb(0, ctx);
        if (!ok)
            goto end;
    }

    /* We have the chain complete: now we need to check its purpose */
    ok = check_chain_extensions(ctx);

    if (!ok)
        goto end;

    /* Check name constraints */

    ok = check_name_constraints(ctx);

    if (!ok)
        goto end;

    /* The chain extensions are OK: check trust */

    if (param->trust > 0)
        ok = check_trust(ctx);

    if (!ok)
        goto end;

    /* We may as well copy down any DSA parameters that are required */
    X509_get_pubkey_parameters(NULL, ctx->chain);

    /*
     * Check revocation status: we do this after copying parameters because
     * they may be needed for CRL signature verification.
     */

    ok = ctx->check_revocation(ctx);
    if (!ok)
        goto end;

    /* At this point, we have a chain and need to verify it */
    if (ctx->verify != NULL)
        ok = ctx->verify(ctx);
    else
        ok = internal_verify(ctx);
    if (!ok)
        goto end;

#ifndef OPENSSL_NO_RFC3779
    /* RFC 3779 path validation, now that CRL check has been done */
    ok = v3_asid_validate_path(ctx);
    if (!ok)
        goto end;
    ok = v3_addr_validate_path(ctx);
    if (!ok)
        goto end;
#endif

    /* If we get this far evaluate policies */
    if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))
        ok = ctx->check_policy(ctx);
    if (!ok)
        goto end;
    if (0) {
 end:
        X509_get_pubkey_parameters(NULL, ctx->chain);
    }
    if (sktmp != NULL)
        sk_X509_free(sktmp);
    if (chain_ss != NULL)
        X509_free(chain_ss);
    return ok;
}
",177939,"int X509_verify_cert(X509_STORE_CTX *ctx)
{
    X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;
    int bad_chain = 0;
    X509_VERIFY_PARAM *param = ctx->param;
    int depth, i, ok = 0;
    int num, j, retry;
    int (*cb) (int xok, X509_STORE_CTX *xctx);
    STACK_OF(X509) *sktmp = NULL;
    if (ctx->cert == NULL) {
        X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);
        return -1;
    }

    cb = ctx->verify_cb;

    /*
     * first we make sure the chain we are going to build is present and that
     * the first entry is in place
     */
    if (ctx->chain == NULL) {
        if (((ctx->chain = sk_X509_new_null()) == NULL) ||
            (!sk_X509_push(ctx->chain, ctx->cert))) {
            X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
            goto end;
        }
        CRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509);
        ctx->last_untrusted = 1;
    }

    /* We use a temporary STACK so we can chop and hack at it */
    if (ctx->untrusted != NULL
        && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {
        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
        goto end;
    }

    num = sk_X509_num(ctx->chain);
    x = sk_X509_value(ctx->chain, num - 1);
    depth = param->depth;

    for (;;) {
        /* If we have enough, we break */
        if (depth < num)
            break;              /* FIXME: If this happens, we should take
                                 * note of it and, if appropriate, use the
                                 * X509_V_ERR_CERT_CHAIN_TOO_LONG error code
                                 * later. */

        /* If we are self signed, we break */
        if (ctx->check_issued(ctx, x, x))
            break;

        /* If we were passed a cert chain, use it first */
        if (ctx->untrusted != NULL) {
            xtmp = find_issuer(ctx, sktmp, x);
            if (xtmp != NULL) {
                if (!sk_X509_push(ctx->chain, xtmp)) {
                    X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
                    goto end;
                }
                CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);
                (void)sk_X509_delete_ptr(sktmp, xtmp);
                ctx->last_untrusted++;
                x = xtmp;
                num++;
                /*
                 * reparse the full chain for the next one
                 */
                continue;
            }
        }
        break;
    }

    /* Remember how many untrusted certs we have */
    j = num;
    /*
     * at this point, chain should contain a list of untrusted certificates.
     * We now need to add at least one trusted one, if possible, otherwise we
     * complain.
     */

    do {
        /*
         * Examine last certificate in chain and see if it is self signed.
         */
        i = sk_X509_num(ctx->chain);
        x = sk_X509_value(ctx->chain, i - 1);
        if (ctx->check_issued(ctx, x, x)) {
            /* we have a self signed certificate */
            if (sk_X509_num(ctx->chain) == 1) {
                /*
                 * We have a single self signed certificate: see if we can
                 * find it in the store. We must have an exact match to avoid
                 * possible impersonation.
                 */
                ok = ctx->get_issuer(&xtmp, ctx, x);
                if ((ok <= 0) || X509_cmp(x, xtmp)) {
                    ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
                    ctx->current_cert = x;
                    ctx->error_depth = i - 1;
                    if (ok == 1)
                        X509_free(xtmp);
                    bad_chain = 1;
                    ok = cb(0, ctx);
                    if (!ok)
                        goto end;
                } else {
                    /*
                     * We have a match: replace certificate with store
                     * version so we get any trust settings.
                     */
                    X509_free(x);
                    x = xtmp;
                    (void)sk_X509_set(ctx->chain, i - 1, x);
                    ctx->last_untrusted = 0;
                }
            } else {
                /*
                 * extract and save self signed certificate for later use
                 */
                chain_ss = sk_X509_pop(ctx->chain);
                ctx->last_untrusted--;
                num--;
                j--;
                x = sk_X509_value(ctx->chain, num - 1);
            }
        }
        /* We now lookup certs from the certificate store */
        for (;;) {
            /* If we have enough, we break */
            if (depth < num)
                break;
            /* If we are self signed, we break */
            if (ctx->check_issued(ctx, x, x))
                break;
            ok = ctx->get_issuer(&xtmp, ctx, x);
            if (ok < 0)
                return ok;
            if (ok == 0)
                break;
            x = xtmp;
            if (!sk_X509_push(ctx->chain, x)) {
                X509_free(xtmp);
                X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
                return 0;
            }
            num++;
        }

        /*
         * If we haven't got a least one certificate from our store then check
         * if there is an alternative chain that could be used.  We only do this
         * if the user hasn't switched off alternate chain checking
         */
        retry = 0;
        if (j == ctx->last_untrusted &&
            !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {
            while (j-- > 1) {
                xtmp2 = sk_X509_value(ctx->chain, j - 1);
                ok = ctx->get_issuer(&xtmp, ctx, xtmp2);
                if (ok < 0)
                    goto end;
                /* Check if we found an alternate chain */
                if (ok > 0) {
                    /*
                     * Free up the found cert we'll add it again later
                     */
                    X509_free(xtmp);

                    /*
                     * Dump all the certs above this point - we've found an
                     * alternate chain
                     */
                    while (num > j) {
                         xtmp = sk_X509_pop(ctx->chain);
                         X509_free(xtmp);
                         num--;
                        ctx->last_untrusted--;
                     }
                     retry = 1;
                     break;
                 }
            }
        }
    } while (retry);

    /* Is last certificate looked up self signed? */
    if (!ctx->check_issued(ctx, x, x)) {
        if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {
            if (ctx->last_untrusted >= num)
                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
            else
                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;
            ctx->current_cert = x;
        } else {

            sk_X509_push(ctx->chain, chain_ss);
            num++;
            ctx->last_untrusted = num;
            ctx->current_cert = chain_ss;
            ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;
            chain_ss = NULL;
        }

        ctx->error_depth = num - 1;
        bad_chain = 1;
        ok = cb(0, ctx);
        if (!ok)
            goto end;
    }

    /* We have the chain complete: now we need to check its purpose */
    ok = check_chain_extensions(ctx);

    if (!ok)
        goto end;

    /* Check name constraints */

    ok = check_name_constraints(ctx);

    if (!ok)
        goto end;

    /* The chain extensions are OK: check trust */

    if (param->trust > 0)
        ok = check_trust(ctx);

    if (!ok)
        goto end;

    /* We may as well copy down any DSA parameters that are required */
    X509_get_pubkey_parameters(NULL, ctx->chain);

    /*
     * Check revocation status: we do this after copying parameters because
     * they may be needed for CRL signature verification.
     */

    ok = ctx->check_revocation(ctx);
    if (!ok)
        goto end;

    /* At this point, we have a chain and need to verify it */
    if (ctx->verify != NULL)
        ok = ctx->verify(ctx);
    else
        ok = internal_verify(ctx);
    if (!ok)
        goto end;

#ifndef OPENSSL_NO_RFC3779
    /* RFC 3779 path validation, now that CRL check has been done */
    ok = v3_asid_validate_path(ctx);
    if (!ok)
        goto end;
    ok = v3_addr_validate_path(ctx);
    if (!ok)
        goto end;
#endif

    /* If we get this far evaluate policies */
    if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))
        ok = ctx->check_policy(ctx);
    if (!ok)
        goto end;
    if (0) {
 end:
        X509_get_pubkey_parameters(NULL, ctx->chain);
    }
    if (sktmp != NULL)
        sk_X509_free(sktmp);
    if (chain_ss != NULL)
        X509_free(chain_ss);
    return ok;
}
","int X509_verify_cert(X509_STORE_CTX *ctx)
{
    X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;
    int bad_chain = 0;
    X509_VERIFY_PARAM *param = ctx->param;
    int depth, i, ok = 0;
    int num, j, retry;
    int (*cb) (int xok, X509_STORE_CTX *xctx);
    STACK_OF(X509) *sktmp = NULL;
    if (ctx->cert == NULL) {
        X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);
        return -1;
    }

    cb = ctx->verify_cb;

    /*
     * first we make sure the chain we are going to build is present and that
     * the first entry is in place
     */
    if (ctx->chain == NULL) {
        if (((ctx->chain = sk_X509_new_null()) == NULL) ||
            (!sk_X509_push(ctx->chain, ctx->cert))) {
            X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
            goto end;
        }
        CRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509);
        ctx->last_untrusted = 1;
    }

    /* We use a temporary STACK so we can chop and hack at it */
    if (ctx->untrusted != NULL
        && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {
        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
        goto end;
    }

    num = sk_X509_num(ctx->chain);
    x = sk_X509_value(ctx->chain, num - 1);
    depth = param->depth;

    for (;;) {
        /* If we have enough, we break */
        if (depth < num)
            break;              /* FIXME: If this happens, we should take
                                 * note of it and, if appropriate, use the
                                 * X509_V_ERR_CERT_CHAIN_TOO_LONG error code
                                 * later. */

        /* If we are self signed, we break */
        if (ctx->check_issued(ctx, x, x))
            break;

        /* If we were passed a cert chain, use it first */
        if (ctx->untrusted != NULL) {
            xtmp = find_issuer(ctx, sktmp, x);
            if (xtmp != NULL) {
                if (!sk_X509_push(ctx->chain, xtmp)) {
                    X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
                    goto end;
                }
                CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);
                (void)sk_X509_delete_ptr(sktmp, xtmp);
                ctx->last_untrusted++;
                x = xtmp;
                num++;
                /*
                 * reparse the full chain for the next one
                 */
                continue;
            }
        }
        break;
    }

    /* Remember how many untrusted certs we have */
    j = num;
    /*
     * at this point, chain should contain a list of untrusted certificates.
     * We now need to add at least one trusted one, if possible, otherwise we
     * complain.
     */

    do {
        /*
         * Examine last certificate in chain and see if it is self signed.
         */
        i = sk_X509_num(ctx->chain);
        x = sk_X509_value(ctx->chain, i - 1);
        if (ctx->check_issued(ctx, x, x)) {
            /* we have a self signed certificate */
            if (sk_X509_num(ctx->chain) == 1) {
                /*
                 * We have a single self signed certificate: see if we can
                 * find it in the store. We must have an exact match to avoid
                 * possible impersonation.
                 */
                ok = ctx->get_issuer(&xtmp, ctx, x);
                if ((ok <= 0) || X509_cmp(x, xtmp)) {
                    ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
                    ctx->current_cert = x;
                    ctx->error_depth = i - 1;
                    if (ok == 1)
                        X509_free(xtmp);
                    bad_chain = 1;
                    ok = cb(0, ctx);
                    if (!ok)
                        goto end;
                } else {
                    /*
                     * We have a match: replace certificate with store
                     * version so we get any trust settings.
                     */
                    X509_free(x);
                    x = xtmp;
                    (void)sk_X509_set(ctx->chain, i - 1, x);
                    ctx->last_untrusted = 0;
                }
            } else {
                /*
                 * extract and save self signed certificate for later use
                 */
                chain_ss = sk_X509_pop(ctx->chain);
                ctx->last_untrusted--;
                num--;
                j--;
                x = sk_X509_value(ctx->chain, num - 1);
            }
        }
        /* We now lookup certs from the certificate store */
        for (;;) {
            /* If we have enough, we break */
            if (depth < num)
                break;
            /* If we are self signed, we break */
            if (ctx->check_issued(ctx, x, x))
                break;
            ok = ctx->get_issuer(&xtmp, ctx, x);
            if (ok < 0)
                return ok;
            if (ok == 0)
                break;
            x = xtmp;
            if (!sk_X509_push(ctx->chain, x)) {
                X509_free(xtmp);
                X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
                return 0;
            }
            num++;
        }

        /*
         * If we haven't got a least one certificate from our store then check
         * if there is an alternative chain that could be used.  We only do this
         * if the user hasn't switched off alternate chain checking
         */
        retry = 0;
        if (j == ctx->last_untrusted &&
            !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {
            while (j-- > 1) {
                xtmp2 = sk_X509_value(ctx->chain, j - 1);
                ok = ctx->get_issuer(&xtmp, ctx, xtmp2);
                if (ok < 0)
                    goto end;
                /* Check if we found an alternate chain */
                if (ok > 0) {
                    /*
                     * Free up the found cert we'll add it again later
                     */
                    X509_free(xtmp);

                    /*
                     * Dump all the certs above this point - we've found an
                     * alternate chain
                     */
                    while (num > j) {
                         xtmp = sk_X509_pop(ctx->chain);
                         X509_free(xtmp);
                         num--;
                     }
                    ctx->last_untrusted = sk_X509_num(ctx->chain);
                     retry = 1;
                     break;
                 }
            }
        }
    } while (retry);

    /* Is last certificate looked up self signed? */
    if (!ctx->check_issued(ctx, x, x)) {
        if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {
            if (ctx->last_untrusted >= num)
                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
            else
                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;
            ctx->current_cert = x;
        } else {

            sk_X509_push(ctx->chain, chain_ss);
            num++;
            ctx->last_untrusted = num;
            ctx->current_cert = chain_ss;
            ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;
            chain_ss = NULL;
        }

        ctx->error_depth = num - 1;
        bad_chain = 1;
        ok = cb(0, ctx);
        if (!ok)
            goto end;
    }

    /* We have the chain complete: now we need to check its purpose */
    ok = check_chain_extensions(ctx);

    if (!ok)
        goto end;

    /* Check name constraints */

    ok = check_name_constraints(ctx);

    if (!ok)
        goto end;

    /* The chain extensions are OK: check trust */

    if (param->trust > 0)
        ok = check_trust(ctx);

    if (!ok)
        goto end;

    /* We may as well copy down any DSA parameters that are required */
    X509_get_pubkey_parameters(NULL, ctx->chain);

    /*
     * Check revocation status: we do this after copying parameters because
     * they may be needed for CRL signature verification.
     */

    ok = ctx->check_revocation(ctx);
    if (!ok)
        goto end;

    /* At this point, we have a chain and need to verify it */
    if (ctx->verify != NULL)
        ok = ctx->verify(ctx);
    else
        ok = internal_verify(ctx);
    if (!ok)
        goto end;

#ifndef OPENSSL_NO_RFC3779
    /* RFC 3779 path validation, now that CRL check has been done */
    ok = v3_asid_validate_path(ctx);
    if (!ok)
        goto end;
    ok = v3_addr_validate_path(ctx);
    if (!ok)
        goto end;
#endif

    /* If we get this far evaluate policies */
    if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))
        ok = ctx->check_policy(ctx);
    if (!ok)
        goto end;
    if (0) {
 end:
        X509_get_pubkey_parameters(NULL, ctx->chain);
    }
    if (sktmp != NULL)
        sk_X509_free(sktmp);
    if (chain_ss != NULL)
        X509_free(chain_ss);
    return ok;
}
","The `X509_verify_cert` function is responsible for verifying a certificate chain in a given `X509_STORE_CTX` context. It begins by checking if a certificate is set for verification and initializes the chain if necessary. The function iteratively builds the certificate chain by finding issuers and adding certificates from both untrusted and trusted sources, while handling self-signed certificates appropriately. It performs various checks, including verifying extensions, name constraints, trust levels, and revocation status. Finally, it validates the complete chain and evaluates any applicable policies, returning a success or failure status based on the verification outcome.","The provided code implements a function that verifies a certificate chain within a specified context. It begins by ensuring a certificate is set for verification and initializes the chain if needed. The function iteratively builds the chain by adding certificates from both untrusted and trusted sources, while managing self-signed certificates. It performs a series of checks, including validating extensions, ensuring compliance with name constraints, assessing trust levels, and checking for revocation. Ultimately, it verifies the complete chain and evaluates any relevant policies, returning a success or failure status based on the verification results.","The vulnerability in the original code arises from inadequate handling of self-signed certificates, which could lead to improper verification of certificate chains. Specifically, if a self-signed certificate was the only certificate in the chain, the code did not ensure that it matched a trusted certificate in the store, potentially allowing impersonation. The fix in the updated code introduces a more robust check by ensuring that if a self-signed certificate is encountered, it must be verified against the trusted store using the `get_issuer` function. This ensures that only valid self-signed certificates are accepted, enhancing the overall security of the verification process.","The vulnerability in the original code stemmed from insufficient validation of self-signed certificates, which could allow an attacker to impersonate a trusted entity if the only certificate in the chain was self-signed. This lack of rigorous checks meant that self-signed certificates could be accepted without proper verification against trusted sources. The updated code addresses this issue by implementing a more stringent verification process for self-signed certificates, ensuring they are matched against trusted certificates in the store. This enhancement significantly improves the security of the certificate verification process by preventing unauthorized access through invalid self-signed certificates.","The vulnerability was fixed by enhancing the verification process for self-signed certificates. In the updated code, when a self-signed certificate is encountered, the `get_issuer` function is called to check if it matches a trusted certificate in the store. If the match fails, an error is set, preventing the acceptance of unverified self-signed certificates. Additionally, the code now ensures that if a self-signed certificate is the only one in the chain, it must be validated against the trusted store, thereby mitigating the risk of impersonation and ensuring that only legitimate certificates are accepted in the verification process.","The vulnerability was addressed by implementing a more rigorous validation process for self-signed certificates. The updated code ensures that when a self-signed certificate is encountered, it must be verified against trusted certificates in the store. If the self-signed certificate does not match a trusted counterpart, an error is generated, preventing its acceptance. This change ensures that self-signed certificates cannot be used to impersonate trusted entities, thereby enhancing the overall security of the certificate verification process and ensuring that only legitimate certificates are included in the chain.","CWE-295, CWE-296, CWE-297, CWE-322, CWE-299, CWE-326, CWE-347, CWE-295, CWE-300, CWE-345",N,-1.0,"5,4","4,4","4,4","4,4"
1,1,179981,179981,,Remote,Not required,,CVE-2014-8160,https://www.cvedetails.com/cve/CVE-2014-8160/,CWE-254,Low,,Partial,,2015-03-02,5.0,"net/netfilter/nf_conntrack_proto_generic.c in the Linux kernel before 3.18 generates incorrect conntrack entries during handling of certain iptables rule sets for the SCTP, DCCP, GRE, and UDP-Lite protocols, which allows remote attackers to bypass intended access restrictions via packets with disallowed port numbers.",2017-01-02,Bypass ,1,https://github.com/torvalds/linux/commit/db29a9508a9246e77087c5531e45b2c88ec6988b,db29a9508a9246e77087c5531e45b2c88ec6988b,"netfilter: conntrack: disable generic tracking for known protocols

Given following iptables ruleset:

-P FORWARD DROP
-A FORWARD -m sctp --dport 9 -j ACCEPT
-A FORWARD -p tcp --dport 80 -j ACCEPT
-A FORWARD -p tcp -m conntrack -m state ESTABLISHED,RELATED -j ACCEPT

One would assume that this allows SCTP on port 9 and TCP on port 80.
Unfortunately, if the SCTP conntrack module is not loaded, this allows
*all* SCTP communication, to pass though, i.e. -p sctp -j ACCEPT,
which we think is a security issue.

This is because on the first SCTP packet on port 9, we create a dummy
""generic l4"" conntrack entry without any port information (since
conntrack doesn't know how to extract this information).

All subsequent packets that are unknown will then be in established
state since they will fallback to proto_generic and will match the
'generic' entry.

Our originally proposed version [1] completely disabled generic protocol
tracking, but Jozsef suggests to not track protocols for which a more
suitable helper is available, hence we now mitigate the issue for in
tree known ct protocol helpers only, so that at least NAT and direction
information will still be preserved for others.

 [1] http://www.spinics.net/lists/netfilter-devel/msg33430.html

Joint work with Daniel Borkmann.

Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
Acked-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",1,net/netfilter/nf_conntrack_proto_generic.c,"{""sha"": ""957c1db6665254645f43d0c04456015a1d4df65c"", ""filename"": ""net/netfilter/nf_conntrack_proto_generic.c"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 1, ""changes"": 26, ""blob_url"": ""https://github.com/torvalds/linux/blob/db29a9508a9246e77087c5531e45b2c88ec6988b/net/netfilter/nf_conntrack_proto_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/db29a9508a9246e77087c5531e45b2c88ec6988b/net/netfilter/nf_conntrack_proto_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/netfilter/nf_conntrack_proto_generic.c?ref=db29a9508a9246e77087c5531e45b2c88ec6988b"", ""patch"": ""@@ -14,6 +14,30 @@\n \n static unsigned int nf_ct_generic_timeout __read_mostly = 600*HZ;\n \n+static bool nf_generic_should_process(u8 proto)\n+{\n+\tswitch (proto) {\n+#ifdef CONFIG_NF_CT_PROTO_SCTP_MODULE\n+\tcase IPPROTO_SCTP:\n+\t\treturn false;\n+#endif\n+#ifdef CONFIG_NF_CT_PROTO_DCCP_MODULE\n+\tcase IPPROTO_DCCP:\n+\t\treturn false;\n+#endif\n+#ifdef CONFIG_NF_CT_PROTO_GRE_MODULE\n+\tcase IPPROTO_GRE:\n+\t\treturn false;\n+#endif\n+#ifdef CONFIG_NF_CT_PROTO_UDPLITE_MODULE\n+\tcase IPPROTO_UDPLITE:\n+\t\treturn false;\n+#endif\n+\tdefault:\n+\t\treturn true;\n+\t}\n+}\n+\n static inline struct nf_generic_net *generic_pernet(struct net *net)\n {\n \treturn &net->ct.nf_ct_proto.generic;\n@@ -67,7 +91,7 @@ static int generic_packet(struct nf_conn *ct,\n static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n \t\t\tunsigned int dataoff, unsigned int *timeouts)\n {\n-\treturn true;\n+\treturn nf_generic_should_process(nf_ct_protonum(ct));\n }\n \n #if IS_ENABLED(CONFIG_NF_CT_NETLINK_TIMEOUT)""}"," static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,
 			unsigned int dataoff, unsigned int *timeouts)
 {
	return nf_generic_should_process(nf_ct_protonum(ct));
 }
"," static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,
 			unsigned int dataoff, unsigned int *timeouts)
 {
	return true;
 }
",C,"	return nf_generic_should_process(nf_ct_protonum(ct));
","	return true;
",,"@@ -14,6 +14,30 @@
 
 static unsigned int nf_ct_generic_timeout __read_mostly = 600*HZ;
 
+static bool nf_generic_should_process(u8 proto)
+{
+	switch (proto) {
+#ifdef CONFIG_NF_CT_PROTO_SCTP_MODULE
+	case IPPROTO_SCTP:
+		return false;
+#endif
+#ifdef CONFIG_NF_CT_PROTO_DCCP_MODULE
+	case IPPROTO_DCCP:
+		return false;
+#endif
+#ifdef CONFIG_NF_CT_PROTO_GRE_MODULE
+	case IPPROTO_GRE:
+		return false;
+#endif
+#ifdef CONFIG_NF_CT_PROTO_UDPLITE_MODULE
+	case IPPROTO_UDPLITE:
+		return false;
+#endif
+	default:
+		return true;
+	}
+}
+
 static inline struct nf_generic_net *generic_pernet(struct net *net)
 {
 	return &net->ct.nf_ct_proto.generic;
@@ -67,7 +91,7 @@ static int generic_packet(struct nf_conn *ct,
 static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,
 			unsigned int dataoff, unsigned int *timeouts)
 {
-	return true;
+	return nf_generic_should_process(nf_ct_protonum(ct));
 }
 
 #if IS_ENABLED(CONFIG_NF_CT_NETLINK_TIMEOUT)",linux,db29a9508a9246e77087c5531e45b2c88ec6988b,9363dc4b599949bde338cdaba1cf7cac243e4e97,1," static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,
 			unsigned int dataoff, unsigned int *timeouts)
 {
//flaw_line_below:
	return true;
//fix_flaw_line_below:
//	return nf_generic_should_process(nf_ct_protonum(ct));
 }
",179981," static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,
 			unsigned int dataoff, unsigned int *timeouts)
 {
	return true;
 }
"," static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,
 			unsigned int dataoff, unsigned int *timeouts)
 {
	return nf_generic_should_process(nf_ct_protonum(ct));
 }
","The provided code defines a static function named `generic_new`, which takes three parameters: a pointer to a `struct nf_conn`, a pointer to a `struct sk_buff`, and two unsigned integers representing data offset and timeouts. The function's purpose is to create a new network connection, as suggested by its name and parameters. However, it currently contains no implementation logic and simply returns `true`, indicating a successful operation. This placeholder functionality suggests that the function is intended for future development or integration within a larger network framework, likely related to connection tracking in networking contexts.","The code defines a function that is intended to handle the creation of a new network connection. It accepts parameters that represent a connection structure, a buffer containing network packet data, an offset for data processing, and a pointer for timeout values. Currently, the function does not implement any logic and simply returns a boolean value indicating success. This suggests that the function serves as a placeholder, potentially for future enhancements or integration within a broader networking framework, particularly in the context of managing and tracking network connections.","The vulnerability in the original code arises from the creation of a generic connection tracking entry for unknown protocols, which allows all SCTP communication to pass through unchecked if the SCTP conntrack module is not loaded. This occurs because the first SCTP packet creates a dummy entry without port information, leading to subsequent packets being incorrectly classified as established. The fix implemented in the updated code disables generic tracking for known protocols by using a specific function to determine if processing should occur based on the protocol number, thereby preventing the fallback to a generic entry and enhancing security by ensuring proper protocol handling.","The vulnerability in the original code stems from the creation of a generic connection tracking entry for unknown protocols, which inadvertently allows all SCTP traffic to bypass security measures if the corresponding conntrack module is not loaded. This occurs because the first packet generates a placeholder entry without specific port information, leading to subsequent packets being incorrectly classified as established. The fix implemented in the updated code disables generic tracking for known protocols, ensuring that only appropriate handlers are used for connection tracking, thereby preventing the fallback to a generic entry and enhancing overall security by enforcing stricter protocol handling.","The vulnerability was fixed by modifying the function to utilize `nf_generic_should_process`, which checks the protocol number of the connection before deciding whether to process it generically. This change ensures that generic tracking is disabled for known protocols, preventing the creation of a dummy ""generic l4"" connection tracking entry when the SCTP conntrack module is not loaded. By implementing this check, the code avoids falling back to the generic entry for unknown packets, thereby maintaining proper connection tracking and enhancing security by ensuring that only packets with suitable handlers are processed.","The vulnerability was addressed by implementing a check that determines whether to process connections generically based on the protocol number. This adjustment prevents the creation of a placeholder entry for unknown protocols, which previously allowed unrestricted traffic when the corresponding conntrack module was not loaded. By ensuring that only known protocols are tracked appropriately, the fix eliminates the risk of misclassifying subsequent packets as established, thereby enforcing stricter connection handling. This change enhances security by ensuring that only packets with suitable handlers are processed, thereby preventing unauthorized access through the connection tracking mechanism.","CWE-284,CWE-799,CWE-754,CWE-20,CWE-693,CWE-669,CWE-665,CWE-440,CWE-287,CWE-280",N,-1.0,"4,4","4, 4","4,4","4,4"
2,2,181625,181625,,Remote,Not required,,CVE-2016-10517,https://www.cvedetails.com/cve/CVE-2016-10517/,CWE-254,Medium,Partial,,,2017-10-24,4.3,"networking.c in Redis before 3.2.7 allows *Cross Protocol Scripting* because it lacks a check for POST and Host: strings, which are not valid in the Redis protocol (but commonly occur when an attack triggers an HTTP request to the Redis TCP port).",2018-08-08,,4,https://github.com/antirez/redis/commit/874804da0c014a7d704b3d285aa500098a931f50,874804da0c014a7d704b3d285aa500098a931f50,"Security: Cross Protocol Scripting protection.

This is an attempt at mitigating problems due to cross protocol
scripting, an attack targeting services using line oriented protocols
like Redis that can accept HTTP requests as valid protocol, by
discarding the invalid parts and accepting the payloads sent, for
example, via a POST request.

For this to be effective, when we detect POST and Host: and terminate
the connection asynchronously, the networking code was modified in order
to never process further input. It was later verified that in a
pipelined request containing a POST command, the successive commands are
not executed.",2,src/networking.c,"{""sha"": ""fb5341ecad122771dbc256b6cbb1124c7669e0be"", ""filename"": ""src/networking.c"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 2, ""changes"": 26, ""blob_url"": ""https://github.com/antirez/redis/blob/874804da0c014a7d704b3d285aa500098a931f50/src/networking.c"", ""raw_url"": ""https://github.com/antirez/redis/raw/874804da0c014a7d704b3d285aa500098a931f50/src/networking.c"", ""contents_url"": ""https://api.github.com/repos/antirez/redis/contents/src/networking.c?ref=874804da0c014a7d704b3d285aa500098a931f50"", ""patch"": ""@@ -1269,8 +1269,10 @@ void processInputBuffer(client *c) {\n \n         /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is\n          * written to the client. Make sure to not let the reply grow after\n-         * this flag has been set (i.e. don't process more commands). */\n-        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;\n+         * this flag has been set (i.e. don't process more commands).\n+         *\n+         * The same applies for clients we want to terminate ASAP. */\n+        if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;\n \n         /* Determine request type when unknown. */\n         if (!c->reqtype) {\n@@ -1637,6 +1639,26 @@ void clientCommand(client *c) {\n     }\n }\n \n+/* This callback is bound to POST and \""Host:\"" command names. Those are not\n+ * really commands, but are used in security attacks in order to talk to\n+ * Redis instances via HTTP, with a technique called \""cross protocol scripting\""\n+ * which exploits the fact that services like Redis will discard invalid\n+ * HTTP headers and will process what follows.\n+ *\n+ * As a protection against this attack, Redis will terminate the connection\n+ * when a POST or \""Host:\"" header is seen, and will log the event from\n+ * time to time (to avoid creating a DOS as a result of too many logs). */\n+void securityWarningCommand(client *c) {\n+    static time_t logged_time;\n+    time_t now = time(NULL);\n+\n+    if (labs(now-logged_time) > 60) {\n+        serverLog(LL_WARNING,\""Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted.\"");\n+        logged_time = now;\n+    }\n+    freeClientAsync(c);\n+}\n+\n /* Rewrite the command vector of the client. All the new objects ref count\n  * is incremented. The old command vector is freed, and the old objects\n  * ref count is decremented. */""}<_**next**_>{""sha"": ""71bcda7d5a315842976670f7a7e61264ecf3a1dd"", ""filename"": ""src/server.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/antirez/redis/blob/874804da0c014a7d704b3d285aa500098a931f50/src/server.c"", ""raw_url"": ""https://github.com/antirez/redis/raw/874804da0c014a7d704b3d285aa500098a931f50/src/server.c"", ""contents_url"": ""https://api.github.com/repos/antirez/redis/contents/src/server.c?ref=874804da0c014a7d704b3d285aa500098a931f50"", ""patch"": ""@@ -294,6 +294,8 @@ struct redisCommand redisCommandTable[] = {\n     {\""pfcount\"",pfcountCommand,-2,\""r\"",0,NULL,1,-1,1,0,0},\n     {\""pfmerge\"",pfmergeCommand,-2,\""wm\"",0,NULL,1,-1,1,0,0},\n     {\""pfdebug\"",pfdebugCommand,-3,\""w\"",0,NULL,0,0,0,0,0},\n+    {\""post\"",securityWarningCommand,-1,\""lt\"",0,NULL,0,0,0,0,0},\n+    {\""host:\"",securityWarningCommand,-1,\""lt\"",0,NULL,0,0,0,0,0},\n     {\""latency\"",latencyCommand,-2,\""aslt\"",0,NULL,0,0,0,0,0}\n };\n ""}<_**next**_>{""sha"": ""3fa7c3ac173f1bc17c42bf641ed39fc0cd607451"", ""filename"": ""src/server.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/antirez/redis/blob/874804da0c014a7d704b3d285aa500098a931f50/src/server.h"", ""raw_url"": ""https://github.com/antirez/redis/raw/874804da0c014a7d704b3d285aa500098a931f50/src/server.h"", ""contents_url"": ""https://api.github.com/repos/antirez/redis/contents/src/server.h?ref=874804da0c014a7d704b3d285aa500098a931f50"", ""patch"": ""@@ -1645,6 +1645,7 @@ void pfcountCommand(client *c);\n void pfmergeCommand(client *c);\n void pfdebugCommand(client *c);\n void latencyCommand(client *c);\n+void securityWarningCommand(client *c);\n \n #if defined(__GNUC__)\n void *calloc(size_t count, size_t size) __attribute__ ((deprecated));""}","void processInputBuffer(client *c) {
    server.current_client = c;
    /* Keep processing while there is something in the input buffer */
    while(sdslen(c->querybuf)) {
        /* Return if clients are paused. */
        if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;

        /* Immediately abort if the client is in the middle of something. */
        if (c->flags & CLIENT_BLOCKED) break;
 
         /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is
          * written to the client. Make sure to not let the reply grow after
         * this flag has been set (i.e. don't process more commands).
         *
         * The same applies for clients we want to terminate ASAP. */
        if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;
 
         /* Determine request type when unknown. */
         if (!c->reqtype) {
            if (c->querybuf[0] == '*') {
                c->reqtype = PROTO_REQ_MULTIBULK;
            } else {
                c->reqtype = PROTO_REQ_INLINE;
            }
        }

        if (c->reqtype == PROTO_REQ_INLINE) {
            if (processInlineBuffer(c) != C_OK) break;
        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {
            if (processMultibulkBuffer(c) != C_OK) break;
        } else {
            serverPanic(""Unknown request type"");
        }

        /* Multibulk processing could see a <= 0 length. */
        if (c->argc == 0) {
            resetClient(c);
        } else {
            /* Only reset the client when the command was executed. */
            if (processCommand(c) == C_OK)
                resetClient(c);
            /* freeMemoryIfNeeded may flush slave output buffers. This may result
             * into a slave, that may be the active client, to be freed. */
            if (server.current_client == NULL) break;
        }
    }
    server.current_client = NULL;
}
","void processInputBuffer(client *c) {
    server.current_client = c;
    /* Keep processing while there is something in the input buffer */
    while(sdslen(c->querybuf)) {
        /* Return if clients are paused. */
        if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;

        /* Immediately abort if the client is in the middle of something. */
        if (c->flags & CLIENT_BLOCKED) break;
 
         /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is
          * written to the client. Make sure to not let the reply grow after
         * this flag has been set (i.e. don't process more commands). */
        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;
 
         /* Determine request type when unknown. */
         if (!c->reqtype) {
            if (c->querybuf[0] == '*') {
                c->reqtype = PROTO_REQ_MULTIBULK;
            } else {
                c->reqtype = PROTO_REQ_INLINE;
            }
        }

        if (c->reqtype == PROTO_REQ_INLINE) {
            if (processInlineBuffer(c) != C_OK) break;
        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {
            if (processMultibulkBuffer(c) != C_OK) break;
        } else {
            serverPanic(""Unknown request type"");
        }

        /* Multibulk processing could see a <= 0 length. */
        if (c->argc == 0) {
            resetClient(c);
        } else {
            /* Only reset the client when the command was executed. */
            if (processCommand(c) == C_OK)
                resetClient(c);
            /* freeMemoryIfNeeded may flush slave output buffers. This may result
             * into a slave, that may be the active client, to be freed. */
            if (server.current_client == NULL) break;
        }
    }
    server.current_client = NULL;
}
",C,"         * this flag has been set (i.e. don't process more commands).
         *
         * The same applies for clients we want to terminate ASAP. */
        if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;
","         * this flag has been set (i.e. don't process more commands). */
        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;
",,"@@ -1269,8 +1269,10 @@ void processInputBuffer(client *c) {
 
         /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is
          * written to the client. Make sure to not let the reply grow after
-         * this flag has been set (i.e. don't process more commands). */
-        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;
+         * this flag has been set (i.e. don't process more commands).
+         *
+         * The same applies for clients we want to terminate ASAP. */
+        if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;
 
         /* Determine request type when unknown. */
         if (!c->reqtype) {
@@ -1637,6 +1639,26 @@ void clientCommand(client *c) {
     }
 }
 
+/* This callback is bound to POST and ""Host:"" command names. Those are not
+ * really commands, but are used in security attacks in order to talk to
+ * Redis instances via HTTP, with a technique called ""cross protocol scripting""
+ * which exploits the fact that services like Redis will discard invalid
+ * HTTP headers and will process what follows.
+ *
+ * As a protection against this attack, Redis will terminate the connection
+ * when a POST or ""Host:"" header is seen, and will log the event from
+ * time to time (to avoid creating a DOS as a result of too many logs). */
+void securityWarningCommand(client *c) {
+    static time_t logged_time;
+    time_t now = time(NULL);
+
+    if (labs(now-logged_time) > 60) {
+        serverLog(LL_WARNING,""Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted."");
+        logged_time = now;
+    }
+    freeClientAsync(c);
+}
+
 /* Rewrite the command vector of the client. All the new objects ref count
  * is incremented. The old command vector is freed, and the old objects
  * ref count is decremented. */",redis,874804da0c014a7d704b3d285aa500098a931f50,273cd7ff51ffa03cbef737aaadf537e828fb3e5d,1,"void processInputBuffer(client *c) {
    server.current_client = c;
    /* Keep processing while there is something in the input buffer */
    while(sdslen(c->querybuf)) {
        /* Return if clients are paused. */
        if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;

        /* Immediately abort if the client is in the middle of something. */
        if (c->flags & CLIENT_BLOCKED) break;
 
         /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is
          * written to the client. Make sure to not let the reply grow after
//flaw_line_below:
         * this flag has been set (i.e. don't process more commands). */
//flaw_line_below:
        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;
//fix_flaw_line_below:
//         * this flag has been set (i.e. don't process more commands).
//fix_flaw_line_below:
//         *
//fix_flaw_line_below:
//         * The same applies for clients we want to terminate ASAP. */
//fix_flaw_line_below:
//        if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;
 
         /* Determine request type when unknown. */
         if (!c->reqtype) {
            if (c->querybuf[0] == '*') {
                c->reqtype = PROTO_REQ_MULTIBULK;
            } else {
                c->reqtype = PROTO_REQ_INLINE;
            }
        }

        if (c->reqtype == PROTO_REQ_INLINE) {
            if (processInlineBuffer(c) != C_OK) break;
        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {
            if (processMultibulkBuffer(c) != C_OK) break;
        } else {
            serverPanic(""Unknown request type"");
        }

        /* Multibulk processing could see a <= 0 length. */
        if (c->argc == 0) {
            resetClient(c);
        } else {
            /* Only reset the client when the command was executed. */
            if (processCommand(c) == C_OK)
                resetClient(c);
            /* freeMemoryIfNeeded may flush slave output buffers. This may result
             * into a slave, that may be the active client, to be freed. */
            if (server.current_client == NULL) break;
        }
    }
    server.current_client = NULL;
}
",181625,"void processInputBuffer(client *c) {
    server.current_client = c;
    /* Keep processing while there is something in the input buffer */
    while(sdslen(c->querybuf)) {
        /* Return if clients are paused. */
        if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;

        /* Immediately abort if the client is in the middle of something. */
        if (c->flags & CLIENT_BLOCKED) break;
 
         /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is
          * written to the client. Make sure to not let the reply grow after
         * this flag has been set (i.e. don't process more commands). */
        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;
 
         /* Determine request type when unknown. */
         if (!c->reqtype) {
            if (c->querybuf[0] == '*') {
                c->reqtype = PROTO_REQ_MULTIBULK;
            } else {
                c->reqtype = PROTO_REQ_INLINE;
            }
        }

        if (c->reqtype == PROTO_REQ_INLINE) {
            if (processInlineBuffer(c) != C_OK) break;
        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {
            if (processMultibulkBuffer(c) != C_OK) break;
        } else {
            serverPanic(""Unknown request type"");
        }

        /* Multibulk processing could see a <= 0 length. */
        if (c->argc == 0) {
            resetClient(c);
        } else {
            /* Only reset the client when the command was executed. */
            if (processCommand(c) == C_OK)
                resetClient(c);
            /* freeMemoryIfNeeded may flush slave output buffers. This may result
             * into a slave, that may be the active client, to be freed. */
            if (server.current_client == NULL) break;
        }
    }
    server.current_client = NULL;
}
","void processInputBuffer(client *c) {
    server.current_client = c;
    /* Keep processing while there is something in the input buffer */
    while(sdslen(c->querybuf)) {
        /* Return if clients are paused. */
        if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;

        /* Immediately abort if the client is in the middle of something. */
        if (c->flags & CLIENT_BLOCKED) break;
 
         /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is
          * written to the client. Make sure to not let the reply grow after
         * this flag has been set (i.e. don't process more commands).
         *
         * The same applies for clients we want to terminate ASAP. */
        if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;
 
         /* Determine request type when unknown. */
         if (!c->reqtype) {
            if (c->querybuf[0] == '*') {
                c->reqtype = PROTO_REQ_MULTIBULK;
            } else {
                c->reqtype = PROTO_REQ_INLINE;
            }
        }

        if (c->reqtype == PROTO_REQ_INLINE) {
            if (processInlineBuffer(c) != C_OK) break;
        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {
            if (processMultibulkBuffer(c) != C_OK) break;
        } else {
            serverPanic(""Unknown request type"");
        }

        /* Multibulk processing could see a <= 0 length. */
        if (c->argc == 0) {
            resetClient(c);
        } else {
            /* Only reset the client when the command was executed. */
            if (processCommand(c) == C_OK)
                resetClient(c);
            /* freeMemoryIfNeeded may flush slave output buffers. This may result
             * into a slave, that may be the active client, to be freed. */
            if (server.current_client == NULL) break;
        }
    }
    server.current_client = NULL;
}
","The `processInputBuffer` function processes commands from a client's input buffer in a server environment. It first checks if the client is paused or blocked, and if so, it exits early. The function identifies the type of request (inline or multibulk) based on the first character of the query buffer. It then processes the command accordingly using helper functions for inline and multibulk requests. After executing a command, it resets the client state. The function ensures that if the client is marked for closure or if the command processing results in a state change, it appropriately handles memory and client management, maintaining server stability.","The provided code processes commands from a client's input buffer within a server framework. It continuously checks the client's state, ensuring it is not paused or blocked before proceeding. The code identifies the type of request based on the input format and processes it accordingly. After executing a command, it resets the client's state for future interactions. The function also manages client disconnection scenarios and ensures proper memory handling, maintaining the server's stability and responsiveness throughout the command processing cycle. Overall, it facilitates efficient communication between the server and connected clients.","The vulnerability in the original code stemmed from its inability to properly handle requests that could be sent in a different protocol format, such as HTTP, which could lead to cross-protocol scripting attacks. Specifically, the code did not adequately check for certain flags that indicated a client should not be processed further, allowing potentially malicious input to be executed. The fix introduced an additional check for the `CLIENT_CLOSE_ASAP` flag alongside `CLIENT_CLOSE_AFTER_REPLY`, ensuring that once a problematic request was detected, the server would immediately terminate the connection and prevent any further processing of input, thereby enhancing security against such attacks.","The vulnerability in the original code allowed for cross-protocol scripting attacks, where malicious HTTP requests could be processed as valid commands, potentially leading to unauthorized actions. This occurred because the code did not adequately check for specific conditions that would prevent further processing of invalid requests. The fix involved enhancing the connection termination logic to ensure that once an invalid request was detected, the server would immediately stop processing any additional input. This change effectively mitigated the risk by ensuring that no subsequent commands could be executed after a problematic request was identified.","The vulnerability was fixed by adding a check for the `CLIENT_CLOSE_ASAP` flag in conjunction with the existing `CLIENT_CLOSE_AFTER_REPLY` flag. This modification ensures that when a problematic request, such as a POST command, is detected, the server immediately breaks out of the input processing loop, preventing any further commands from being executed. Additionally, the networking code was adjusted to terminate the connection asynchronously, ensuring that invalid parts of the request are discarded and that the server does not process any additional input once an invalid request is identified, thereby enhancing overall security.","The vulnerability was addressed by implementing an additional check to ensure that once an invalid request was detected, the server would immediately halt any further processing of input. This involved enhancing the connection termination logic to include conditions that would trigger an immediate exit from the command processing loop. As a result, the server is now able to discard any invalid parts of a request and prevent the execution of subsequent commands, effectively mitigating the risk of cross-protocol scripting attacks and improving the overall security of the system.","CWE-74, CWE-20, CWE-436, CWE-116, CWE-287, CWE-78, CWE-79, CWE-913, CWE-114, CWE-22",N,-1.0,"5, 4","4,4","4,5","4,4"
3,3,182040,182040,,Local,Not required,,CVE-2015-7837,https://www.cvedetails.com/cve/CVE-2015-7837/,CWE-254,Low,,Partial,,2017-09-19,2.1,"The Linux kernel, as used in Red Hat Enterprise Linux 7, kernel-rt, and Enterprise MRG 2 and when booted with UEFI Secure Boot enabled, allows local users to bypass intended securelevel/secureboot restrictions by leveraging improper handling of secure_boot flag across kexec reboot.",2017-10-05,Bypass ,1,https://github.com/mjg59/linux/commit/4b2b64d5a6ebc84214755ebccd599baef7c1b798,4b2b64d5a6ebc84214755ebccd599baef7c1b798,"kexec/uefi: copy secure_boot flag in boot params across kexec reboot

Kexec reboot in case secure boot being enabled does not keep the secure
boot mode in new kernel, so later one can load unsigned kernel via legacy
kexec_load.  In this state, the system is missing the protections provided
by secure boot. Adding a patch to fix this by retain the secure_boot flag
in original kernel.

secure_boot flag in boot_params is set in EFI stub, but kexec bypasses the
stub. Fixing this issue by copying secure_boot flag across kexec reboot.

Signed-off-by: Dave Young <dyoung@redhat.com>",0,arch/x86/kernel/kexec-bzimage64.c,"{""sha"": ""61827eeb6881f429d2a7f625f541b6eaee4a05be"", ""filename"": ""arch/x86/kernel/kexec-bzimage64.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/mjg59/linux/blob/4b2b64d5a6ebc84214755ebccd599baef7c1b798/arch/x86/kernel/kexec-bzimage64.c"", ""raw_url"": ""https://github.com/mjg59/linux/raw/4b2b64d5a6ebc84214755ebccd599baef7c1b798/arch/x86/kernel/kexec-bzimage64.c"", ""contents_url"": ""https://api.github.com/repos/mjg59/linux/contents/arch/x86/kernel/kexec-bzimage64.c?ref=4b2b64d5a6ebc84214755ebccd599baef7c1b798"", ""patch"": ""@@ -180,6 +180,7 @@ setup_efi_state(struct boot_params *params, unsigned long params_load_addr,\n \tif (efi_enabled(EFI_OLD_MEMMAP))\n \t\treturn 0;\n \n+\tparams->secure_boot = boot_params.secure_boot;\n \tei->efi_loader_signature = current_ei->efi_loader_signature;\n \tei->efi_systab = current_ei->efi_systab;\n \tei->efi_systab_hi = current_ei->efi_systab_hi;""}","setup_efi_state(struct boot_params *params, unsigned long params_load_addr,
		unsigned int efi_map_offset, unsigned int efi_map_sz,
		unsigned int efi_setup_data_offset)
{
	struct efi_info *current_ei = &boot_params.efi_info;
	struct efi_info *ei = &params->efi_info;

	if (!current_ei->efi_memmap_size)
		return 0;

	/*
	 * If 1:1 mapping is not enabled, second kernel can not setup EFI
	 * and use EFI run time services. User space will have to pass
	 * acpi_rsdp=<addr> on kernel command line to make second kernel boot
	 * without efi.
	 */
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return 0;
 
	params->secure_boot = boot_params.secure_boot;
 	ei->efi_loader_signature = current_ei->efi_loader_signature;
 	ei->efi_systab = current_ei->efi_systab;
 	ei->efi_systab_hi = current_ei->efi_systab_hi;

	ei->efi_memdesc_version = current_ei->efi_memdesc_version;
	ei->efi_memdesc_size = efi_get_runtime_map_desc_size();

	setup_efi_info_memmap(params, params_load_addr, efi_map_offset,
			      efi_map_sz);
	prepare_add_efi_setup_data(params, params_load_addr,
				   efi_setup_data_offset);
	return 0;
}
","setup_efi_state(struct boot_params *params, unsigned long params_load_addr,
		unsigned int efi_map_offset, unsigned int efi_map_sz,
		unsigned int efi_setup_data_offset)
{
	struct efi_info *current_ei = &boot_params.efi_info;
	struct efi_info *ei = &params->efi_info;

	if (!current_ei->efi_memmap_size)
		return 0;

	/*
	 * If 1:1 mapping is not enabled, second kernel can not setup EFI
	 * and use EFI run time services. User space will have to pass
	 * acpi_rsdp=<addr> on kernel command line to make second kernel boot
	 * without efi.
	 */
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return 0;
 
 	ei->efi_loader_signature = current_ei->efi_loader_signature;
 	ei->efi_systab = current_ei->efi_systab;
 	ei->efi_systab_hi = current_ei->efi_systab_hi;

	ei->efi_memdesc_version = current_ei->efi_memdesc_version;
	ei->efi_memdesc_size = efi_get_runtime_map_desc_size();

	setup_efi_info_memmap(params, params_load_addr, efi_map_offset,
			      efi_map_sz);
	prepare_add_efi_setup_data(params, params_load_addr,
				   efi_setup_data_offset);
	return 0;
}
",C,"	params->secure_boot = boot_params.secure_boot;
",,,"@@ -180,6 +180,7 @@ setup_efi_state(struct boot_params *params, unsigned long params_load_addr,
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return 0;
 
+	params->secure_boot = boot_params.secure_boot;
 	ei->efi_loader_signature = current_ei->efi_loader_signature;
 	ei->efi_systab = current_ei->efi_systab;
 	ei->efi_systab_hi = current_ei->efi_systab_hi;",linux,4b2b64d5a6ebc84214755ebccd599baef7c1b798,500a87278c5c0608ba88ed8af7a35fcfa955c492,1,"setup_efi_state(struct boot_params *params, unsigned long params_load_addr,
		unsigned int efi_map_offset, unsigned int efi_map_sz,
		unsigned int efi_setup_data_offset)
{
	struct efi_info *current_ei = &boot_params.efi_info;
	struct efi_info *ei = &params->efi_info;

	if (!current_ei->efi_memmap_size)
		return 0;

	/*
	 * If 1:1 mapping is not enabled, second kernel can not setup EFI
	 * and use EFI run time services. User space will have to pass
	 * acpi_rsdp=<addr> on kernel command line to make second kernel boot
	 * without efi.
	 */
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return 0;
 
//fix_flaw_line_below:
//	params->secure_boot = boot_params.secure_boot;
 	ei->efi_loader_signature = current_ei->efi_loader_signature;
 	ei->efi_systab = current_ei->efi_systab;
 	ei->efi_systab_hi = current_ei->efi_systab_hi;

	ei->efi_memdesc_version = current_ei->efi_memdesc_version;
	ei->efi_memdesc_size = efi_get_runtime_map_desc_size();

	setup_efi_info_memmap(params, params_load_addr, efi_map_offset,
			      efi_map_sz);
	prepare_add_efi_setup_data(params, params_load_addr,
				   efi_setup_data_offset);
	return 0;
}
",182040,"setup_efi_state(struct boot_params *params, unsigned long params_load_addr,
		unsigned int efi_map_offset, unsigned int efi_map_sz,
		unsigned int efi_setup_data_offset)
{
	struct efi_info *current_ei = &boot_params.efi_info;
	struct efi_info *ei = &params->efi_info;

	if (!current_ei->efi_memmap_size)
		return 0;

	/*
	 * If 1:1 mapping is not enabled, second kernel can not setup EFI
	 * and use EFI run time services. User space will have to pass
	 * acpi_rsdp=<addr> on kernel command line to make second kernel boot
	 * without efi.
	 */
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return 0;
 
 	ei->efi_loader_signature = current_ei->efi_loader_signature;
 	ei->efi_systab = current_ei->efi_systab;
 	ei->efi_systab_hi = current_ei->efi_systab_hi;

	ei->efi_memdesc_version = current_ei->efi_memdesc_version;
	ei->efi_memdesc_size = efi_get_runtime_map_desc_size();

	setup_efi_info_memmap(params, params_load_addr, efi_map_offset,
			      efi_map_sz);
	prepare_add_efi_setup_data(params, params_load_addr,
				   efi_setup_data_offset);
	return 0;
}
","setup_efi_state(struct boot_params *params, unsigned long params_load_addr,
		unsigned int efi_map_offset, unsigned int efi_map_sz,
		unsigned int efi_setup_data_offset)
{
	struct efi_info *current_ei = &boot_params.efi_info;
	struct efi_info *ei = &params->efi_info;

	if (!current_ei->efi_memmap_size)
		return 0;

	/*
	 * If 1:1 mapping is not enabled, second kernel can not setup EFI
	 * and use EFI run time services. User space will have to pass
	 * acpi_rsdp=<addr> on kernel command line to make second kernel boot
	 * without efi.
	 */
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return 0;
 
	params->secure_boot = boot_params.secure_boot;
 	ei->efi_loader_signature = current_ei->efi_loader_signature;
 	ei->efi_systab = current_ei->efi_systab;
 	ei->efi_systab_hi = current_ei->efi_systab_hi;

	ei->efi_memdesc_version = current_ei->efi_memdesc_version;
	ei->efi_memdesc_size = efi_get_runtime_map_desc_size();

	setup_efi_info_memmap(params, params_load_addr, efi_map_offset,
			      efi_map_sz);
	prepare_add_efi_setup_data(params, params_load_addr,
				   efi_setup_data_offset);
	return 0;
}
","The `setup_efi_state` function initializes the EFI (Extensible Firmware Interface) state for a second kernel by populating the EFI information structure within the provided boot parameters. It first checks if the current EFI memory map size is valid; if not, it exits early. If the old memory map is enabled, it also exits, as the second kernel cannot utilize EFI runtime services. The function then copies essential EFI data, such as the loader signature and system table pointers, from the current EFI info to the new structure. Finally, it sets up the EFI memory map and prepares additional EFI setup data before returning.","The function initializes the EFI state for a secondary kernel by populating the EFI information structure within the provided boot parameters. It first verifies the validity of the current EFI memory map size and exits if it is not valid or if an old memory mapping is enabled, as this would prevent the second kernel from using EFI runtime services. If valid, it transfers essential EFI data from the current state to the new structure, sets up the EFI memory map, and prepares additional setup data, ensuring the secondary kernel can operate correctly within the EFI environment.","The vulnerability in the original code arises from the failure to retain the secure boot state during a kexec reboot, which could allow an unsigned kernel to be loaded, bypassing the protections of secure boot. This issue occurs because the secure boot flag is set in the EFI stub, but the kexec process does not preserve this flag when transitioning to the new kernel. The fix involves explicitly copying the secure boot flag from the original boot parameters to the new parameters, ensuring that the secure boot state is maintained and preventing the potential loading of unsigned kernels during kexec reboots.","The vulnerability in the original code stems from the inability to maintain the secure boot state during a kexec reboot, which could allow the system to load unsigned kernels, thereby undermining the security protections that secure boot provides. This issue arises because the secure boot flag is established in the EFI stub, but the kexec process does not carry this flag over to the new kernel. The fix addresses this by explicitly copying the secure boot flag from the original boot parameters to the new parameters during the kexec reboot, ensuring that the secure boot protections remain intact and effective.","The vulnerability was fixed by adding a line of code to copy the secure boot flag from the original boot parameters to the new parameters during the execution of the kexec reboot. Specifically, the line `params->secure_boot = boot_params.secure_boot;` was introduced to ensure that the secure boot state is preserved. This change guarantees that the secure boot flag is retained across the transition to the new kernel, preventing the potential loading of unsigned kernels and maintaining the security protections that secure boot provides, thus addressing the issue of bypassing the EFI stub during the kexec process.","The vulnerability was fixed by implementing a mechanism to explicitly transfer the secure boot state from the original boot parameters to the new parameters during the kexec reboot process. This adjustment ensures that the secure boot flag, which is crucial for maintaining system security, is preserved when transitioning to the new kernel. By retaining this flag, the system can continue to enforce secure boot protections, thereby preventing the loading of unsigned kernels and mitigating the risk of security breaches that could occur if the secure boot state were lost during the reboot process.","CWE-693,CWE-119,CWE-284,CWE-732,CWE-287,CWE-757,CWE-266,CWE-733,CWE-669,CWE-295",N,-1.0,"4,5","5,5","4,4","4,3"
4,4,183035,183035,,Remote,Not required,,CVE-2016-10746,https://www.cvedetails.com/cve/CVE-2016-10746/,CWE-254,Low,,Partial,,2019-04-18,5.0,"libvirt-domain.c in libvirt before 1.3.1 supports virDomainGetTime API calls by guest agents with an RO connection, even though an RW connection was supposed to be required, a different vulnerability than CVE-2019-3886.",2019-05-01,,1,https://github.com/libvirt/libvirt/commit/506e9d6c2d4baaf580d489fff0690c0ff2ff588f,506e9d6c2d4baaf580d489fff0690c0ff2ff588f,"virDomainGetTime: Deny on RO connections

We have a policy that if API may end up talking to a guest agent
it should require RW connection. We don't obey the rule in
virDomainGetTime().

Signed-off-by: Michal Privoznik <mprivozn@redhat.com>",0,src/libvirt-domain.c,"{""sha"": ""9491845758570c879e28b18c4b4133ec76a48e90"", ""filename"": ""src/libvirt-domain.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/libvirt/libvirt/blob/506e9d6c2d4baaf580d489fff0690c0ff2ff588f/src/libvirt-domain.c"", ""raw_url"": ""https://github.com/libvirt/libvirt/raw/506e9d6c2d4baaf580d489fff0690c0ff2ff588f/src/libvirt-domain.c"", ""contents_url"": ""https://api.github.com/repos/libvirt/libvirt/contents/src/libvirt-domain.c?ref=506e9d6c2d4baaf580d489fff0690c0ff2ff588f"", ""patch"": ""@@ -10934,6 +10934,7 @@ virDomainGetTime(virDomainPtr dom,\n     virResetLastError();\n \n     virCheckDomainReturn(dom, -1);\n+    virCheckReadOnlyGoto(dom->conn->flags, error);\n \n     if (dom->conn->driver->domainGetTime) {\n         int ret = dom->conn->driver->domainGetTime(dom, seconds,""}","virDomainGetTime(virDomainPtr dom,
                 long long *seconds,
                 unsigned int *nseconds,
                 unsigned int flags)
{
    VIR_DOMAIN_DEBUG(dom, ""seconds=%p, nseconds=%p, flags=%x"",
                     seconds, nseconds, flags);

     virResetLastError();
 
     virCheckDomainReturn(dom, -1);
    virCheckReadOnlyGoto(dom->conn->flags, error);
 
     if (dom->conn->driver->domainGetTime) {
         int ret = dom->conn->driver->domainGetTime(dom, seconds,
                                                   nseconds, flags);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(dom->conn);
    return -1;
}
","virDomainGetTime(virDomainPtr dom,
                 long long *seconds,
                 unsigned int *nseconds,
                 unsigned int flags)
{
    VIR_DOMAIN_DEBUG(dom, ""seconds=%p, nseconds=%p, flags=%x"",
                     seconds, nseconds, flags);

     virResetLastError();
 
     virCheckDomainReturn(dom, -1);
 
     if (dom->conn->driver->domainGetTime) {
         int ret = dom->conn->driver->domainGetTime(dom, seconds,
                                                   nseconds, flags);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(dom->conn);
    return -1;
}
",C,"    virCheckReadOnlyGoto(dom->conn->flags, error);
",,,"@@ -10934,6 +10934,7 @@ virDomainGetTime(virDomainPtr dom,
     virResetLastError();
 
     virCheckDomainReturn(dom, -1);
+    virCheckReadOnlyGoto(dom->conn->flags, error);
 
     if (dom->conn->driver->domainGetTime) {
         int ret = dom->conn->driver->domainGetTime(dom, seconds,",libvirt,506e9d6c2d4baaf580d489fff0690c0ff2ff588f,95c370f0eead8ab0bedf333d54019f55aa001116,1,"virDomainGetTime(virDomainPtr dom,
                 long long *seconds,
                 unsigned int *nseconds,
                 unsigned int flags)
{
    VIR_DOMAIN_DEBUG(dom, ""seconds=%p, nseconds=%p, flags=%x"",
                     seconds, nseconds, flags);

     virResetLastError();
 
     virCheckDomainReturn(dom, -1);
//fix_flaw_line_below:
//    virCheckReadOnlyGoto(dom->conn->flags, error);
 
     if (dom->conn->driver->domainGetTime) {
         int ret = dom->conn->driver->domainGetTime(dom, seconds,
                                                   nseconds, flags);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(dom->conn);
    return -1;
}
",183035,"virDomainGetTime(virDomainPtr dom,
                 long long *seconds,
                 unsigned int *nseconds,
                 unsigned int flags)
{
    VIR_DOMAIN_DEBUG(dom, ""seconds=%p, nseconds=%p, flags=%x"",
                     seconds, nseconds, flags);

     virResetLastError();
 
     virCheckDomainReturn(dom, -1);
 
     if (dom->conn->driver->domainGetTime) {
         int ret = dom->conn->driver->domainGetTime(dom, seconds,
                                                   nseconds, flags);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(dom->conn);
    return -1;
}
","virDomainGetTime(virDomainPtr dom,
                 long long *seconds,
                 unsigned int *nseconds,
                 unsigned int flags)
{
    VIR_DOMAIN_DEBUG(dom, ""seconds=%p, nseconds=%p, flags=%x"",
                     seconds, nseconds, flags);

     virResetLastError();
 
     virCheckDomainReturn(dom, -1);
    virCheckReadOnlyGoto(dom->conn->flags, error);
 
     if (dom->conn->driver->domainGetTime) {
         int ret = dom->conn->driver->domainGetTime(dom, seconds,
                                                   nseconds, flags);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(dom->conn);
    return -1;
}
","The `virDomainGetTime` function retrieves the current time of a specified virtual domain, represented by the `virDomainPtr` pointer `dom`. It takes pointers to `long long` and `unsigned int` variables to store the seconds and nanoseconds, respectively, along with a `flags` parameter for additional options. The function first logs the input parameters and resets any previous errors. It checks if the domain's connection driver supports the time retrieval operation; if so, it calls the appropriate driver function. If the operation fails or is unsupported, it reports an error and returns -1, indicating failure.","The provided code defines a function that retrieves the current time of a specified virtual machine. It accepts parameters to store the time in seconds and nanoseconds, along with an option for additional settings. The function begins by logging the input details and resetting any previous error states. It checks if the underlying system supports the time retrieval operation; if it does, it invokes the appropriate method to obtain the time. In cases where the operation fails or is not supported, the function reports an error and returns a failure indication, ensuring robust error handling throughout the process.","The vulnerability in the original code arises from the lack of a check to ensure that the connection to the virtual machine is not read-only before attempting to retrieve the time. This oversight could allow unauthorized access to sensitive information from a guest agent, violating security policies. The fix introduces a new check using `virCheckReadOnlyGoto(dom->conn->flags, error)`, which verifies that the connection is read-write. If the connection is read-only, the function will redirect to the error handling section, thereby preventing any operations that could compromise the system's integrity or security.","The vulnerability in the original code stems from the absence of a check to ensure that the connection to the virtual machine is not read-only before executing operations that could interact with a guest agent. This oversight could potentially expose sensitive information or allow unauthorized actions, violating established security policies. The fix addresses this issue by implementing a verification step that confirms the connection is read-write. If the connection is found to be read-only, the function redirects to an error handling routine, effectively preventing any unauthorized access and ensuring compliance with security protocols.","The vulnerability was fixed by adding a check for the connection's read-only status using the `virCheckReadOnlyGoto(dom->conn->flags, error)` function. This new line ensures that if the connection is read-only, the function will immediately redirect to the error handling section, preventing any further execution of the time retrieval operation. By enforcing this policy, the code now adheres to the established security requirement that any API capable of interacting with a guest agent must operate over a read-write connection. This change effectively mitigates the risk of unauthorized access to sensitive information.","The vulnerability was addressed by introducing a verification step that checks whether the connection to the virtual machine is read-only. This additional check ensures that the function will not proceed with operations that could potentially interact with a guest agent unless the connection is confirmed to be read-write. If the connection is found to be read-only, the function redirects to an error handling routine, effectively preventing unauthorized access and ensuring compliance with security policies. This fix enhances the overall security of the system by safeguarding sensitive information from being accessed inappropriately.","CWE-284,CWE-285,CWE-732,CWE-269,CWE-264,CWE-668,CWE-287,CWE-266,CWE-250,CWE-434",N,-1.0,"5,5","5,5","4,5","5, 4"
5,5,186204,186204,,Remote,Not required,,CVE-2016-1616,https://www.cvedetails.com/cve/CVE-2016-1616/,CWE-254,Medium,,Partial,,2016-01-25,4.3,The CustomButton::AcceleratorPressed function in ui/views/controls/button/custom_button.cc in Google Chrome before 48.0.2564.82 allows remote attackers to spoof URLs via vectors involving an unfocused custom button.,2016-12-07,,7,https://github.com/chromium/chromium/commit/297ae873b471a46929ea39697b121c0b411434ee,297ae873b471a46929ea39697b121c0b411434ee,"Custom buttons should only handle accelerators when focused.

BUG=541415

Review URL: https://codereview.chromium.org/1437523005

Cr-Commit-Position: refs/heads/master@{#360130}",0,ui/views/controls/button/custom_button.cc,"{""sha"": ""aafbf2d65a63aa32810d6da8d352f9bf1663f8af"", ""filename"": ""ui/views/controls/button/custom_button.cc"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 0, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/297ae873b471a46929ea39697b121c0b411434ee/ui/views/controls/button/custom_button.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/297ae873b471a46929ea39697b121c0b411434ee/ui/views/controls/button/custom_button.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/views/controls/button/custom_button.cc?ref=297ae873b471a46929ea39697b121c0b411434ee"", ""patch"": ""@@ -251,6 +251,13 @@ void CustomButton::OnGestureEvent(ui::GestureEvent* event) {\n }\n \n bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) {\n+  // Should only handle accelerators when active. However, only top level\n+  // widgets can be active, so for child widgets check if they are focused\n+  // instead.\n+  if ((IsChildWidget() && !FocusInChildWidget()) ||\n+      (!IsChildWidget() && !GetWidget()->IsActive())) {\n+    return false;\n+  }\n   SetState(STATE_NORMAL);\n   // TODO(beng): remove once NotifyClick takes ui::Event.\n   ui::MouseEvent synthetic_event(\n@@ -378,4 +385,14 @@ void CustomButton::OnBlur() {\n     SetState(STATE_NORMAL);\n }\n \n+bool CustomButton::IsChildWidget() const {\n+  return GetWidget() && GetWidget()->GetTopLevelWidget() != GetWidget();\n+}\n+\n+bool CustomButton::FocusInChildWidget() const {\n+  return GetWidget() &&\n+         GetWidget()->GetRootView()->Contains(\n+             GetFocusManager()->GetFocusedView());\n+}\n+\n }  // namespace views""}<_**next**_>{""sha"": ""869bcd77af5dac05115312e726c984cf58aac1cf"", ""filename"": ""ui/views/controls/button/custom_button.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/297ae873b471a46929ea39697b121c0b411434ee/ui/views/controls/button/custom_button.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/297ae873b471a46929ea39697b121c0b411434ee/ui/views/controls/button/custom_button.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/views/controls/button/custom_button.h?ref=297ae873b471a46929ea39697b121c0b411434ee"", ""patch"": ""@@ -135,6 +135,11 @@ class VIEWS_EXPORT CustomButton : public Button,\n   scoped_ptr<gfx::ThrobAnimation> hover_animation_;\n \n  private:\n+  // Returns true if this is not a top level widget. Virtual for tests.\n+  virtual bool IsChildWidget() const;\n+  // Returns true if the focus is not in a top level widget. Virtual for tests.\n+  virtual bool FocusInChildWidget() const;\n+\n   // Should we animate when the state changes? Defaults to true.\n   bool animate_on_state_change_;\n ""}<_**next**_>{""sha"": ""7a079fe7bba05f22de2c3e0b5209d16579e94b1b"", ""filename"": ""ui/views/controls/button/custom_button_unittest.cc"", ""status"": ""modified"", ""additions"": 54, ""deletions"": 3, ""changes"": 57, ""blob_url"": ""https://github.com/chromium/chromium/blob/297ae873b471a46929ea39697b121c0b411434ee/ui/views/controls/button/custom_button_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/297ae873b471a46929ea39697b121c0b411434ee/ui/views/controls/button/custom_button_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/views/controls/button/custom_button_unittest.cc?ref=297ae873b471a46929ea39697b121c0b411434ee"", ""patch"": ""@@ -43,12 +43,36 @@ class TestCustomButton : public CustomButton, public ButtonListener {\n \n   void Reset() { notified_ = false; }\n \n+  // CustomButton methods:\n+  bool IsChildWidget() const override { return is_child_widget_; }\n+  bool FocusInChildWidget() const override { return focus_in_child_widget_; }\n+\n+  void set_child_widget(bool b) { is_child_widget_ = b; }\n+  void set_focus_in_child_widget(bool b) { focus_in_child_widget_ = b; }\n+\n  private:\n   bool notified_ = false;\n+  bool is_child_widget_ = false;\n+  bool focus_in_child_widget_ = false;\n \n   DISALLOW_COPY_AND_ASSIGN(TestCustomButton);\n };\n \n+class TestWidget : public Widget {\n+ public:\n+  TestWidget() : Widget() {}\n+\n+  // Widget method:\n+  bool IsActive() const override { return active_; }\n+\n+  void set_active(bool active) { active_ = active; }\n+\n+ private:\n+  bool active_ = false;\n+\n+  DISALLOW_COPY_AND_ASSIGN(TestWidget);\n+};\n+\n class CustomButtonTest : public ViewsTestBase {\n  public:\n   CustomButtonTest() {}\n@@ -59,7 +83,7 @@ class CustomButtonTest : public ViewsTestBase {\n \n     // Create a widget so that the CustomButton can query the hover state\n     // correctly.\n-    widget_.reset(new Widget);\n+    widget_.reset(new TestWidget);\n     Widget::InitParams params = CreateParams(Widget::InitParams::TYPE_POPUP);\n     params.ownership = views::Widget::InitParams::WIDGET_OWNS_NATIVE_WIDGET;\n     params.bounds = gfx::Rect(0, 0, 650, 650);\n@@ -82,11 +106,11 @@ class CustomButtonTest : public ViewsTestBase {\n     ViewsTestBase::TearDown();\n   }\n \n-  Widget* widget() { return widget_.get(); }\n+  TestWidget* widget() { return widget_.get(); }\n   TestCustomButton* button() { return button_; }\n \n  private:\n-  scoped_ptr<Widget> widget_;\n+  scoped_ptr<TestWidget> widget_;\n   TestCustomButton* button_;\n \n   DISALLOW_COPY_AND_ASSIGN(CustomButtonTest);\n@@ -204,6 +228,33 @@ TEST_F(CustomButtonTest, NotifyAction) {\n   EXPECT_FALSE(button()->notified());\n }\n \n+TEST_F(CustomButtonTest, HandleAccelerator) {\n+  // Child widgets shouldn't handle accelerators when they are not focused.\n+  EXPECT_FALSE(button()->IsChildWidget());\n+  EXPECT_FALSE(button()->FocusInChildWidget());\n+  EXPECT_FALSE(widget()->IsActive());\n+  button()->AcceleratorPressed(ui::Accelerator(ui::VKEY_RETURN, ui::EF_NONE));\n+  EXPECT_FALSE(button()->notified());\n+  // Child without focus.\n+  button()->set_child_widget(true);\n+  button()->set_focus_in_child_widget(false);\n+  button()->AcceleratorPressed(ui::Accelerator(ui::VKEY_RETURN, ui::EF_NONE));\n+  EXPECT_FALSE(button()->notified());\n+  button()->Reset();\n+  // Child with focus.\n+  button()->set_child_widget(true);\n+  button()->set_focus_in_child_widget(true);\n+  button()->AcceleratorPressed(ui::Accelerator(ui::VKEY_RETURN, ui::EF_NONE));\n+  EXPECT_TRUE(button()->notified());\n+  button()->Reset();\n+  // Not a child, but active.\n+  button()->set_child_widget(false);\n+  button()->set_focus_in_child_widget(true);\n+  widget()->set_active(true);\n+  button()->AcceleratorPressed(ui::Accelerator(ui::VKEY_RETURN, ui::EF_NONE));\n+  EXPECT_TRUE(button()->notified());\n+}\n+\n // No touch on desktop Mac. Tracked in http://crbug.com/445520.\n #if !defined(OS_MACOSX) || defined(USE_AURA)\n ""}"," bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) {
  // Should only handle accelerators when active. However, only top level
  // widgets can be active, so for child widgets check if they are focused
  // instead.
  if ((IsChildWidget() && !FocusInChildWidget()) ||
      (!IsChildWidget() && !GetWidget()->IsActive())) {
    return false;
  }
   SetState(STATE_NORMAL);
   ui::MouseEvent synthetic_event(
      ui::ET_MOUSE_RELEASED, gfx::Point(), gfx::Point(), ui::EventTimeForNow(),
      ui::EF_LEFT_MOUSE_BUTTON, ui::EF_LEFT_MOUSE_BUTTON);
  NotifyClick(synthetic_event);
  return true;
}
"," bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) {
   SetState(STATE_NORMAL);
   ui::MouseEvent synthetic_event(
      ui::ET_MOUSE_RELEASED, gfx::Point(), gfx::Point(), ui::EventTimeForNow(),
      ui::EF_LEFT_MOUSE_BUTTON, ui::EF_LEFT_MOUSE_BUTTON);
  NotifyClick(synthetic_event);
  return true;
}
",C,"  // Should only handle accelerators when active. However, only top level
  // widgets can be active, so for child widgets check if they are focused
  // instead.
  if ((IsChildWidget() && !FocusInChildWidget()) ||
      (!IsChildWidget() && !GetWidget()->IsActive())) {
    return false;
  }
",,,"@@ -251,6 +251,13 @@ void CustomButton::OnGestureEvent(ui::GestureEvent* event) {
 }
 
 bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) {
+  // Should only handle accelerators when active. However, only top level
+  // widgets can be active, so for child widgets check if they are focused
+  // instead.
+  if ((IsChildWidget() && !FocusInChildWidget()) ||
+      (!IsChildWidget() && !GetWidget()->IsActive())) {
+    return false;
+  }
   SetState(STATE_NORMAL);
   // TODO(beng): remove once NotifyClick takes ui::Event.
   ui::MouseEvent synthetic_event(
@@ -378,4 +385,14 @@ void CustomButton::OnBlur() {
     SetState(STATE_NORMAL);
 }
 
+bool CustomButton::IsChildWidget() const {
+  return GetWidget() && GetWidget()->GetTopLevelWidget() != GetWidget();
+}
+
+bool CustomButton::FocusInChildWidget() const {
+  return GetWidget() &&
+         GetWidget()->GetRootView()->Contains(
+             GetFocusManager()->GetFocusedView());
+}
+
 }  // namespace views",Chrome,297ae873b471a46929ea39697b121c0b411434ee,597404d651817e8ab1886cba0a888361df320123,1," bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) {
//fix_flaw_line_below:
//  // Should only handle accelerators when active. However, only top level
//fix_flaw_line_below:
//  // widgets can be active, so for child widgets check if they are focused
//fix_flaw_line_below:
//  // instead.
//fix_flaw_line_below:
//  if ((IsChildWidget() && !FocusInChildWidget()) ||
//fix_flaw_line_below:
//      (!IsChildWidget() && !GetWidget()->IsActive())) {
//fix_flaw_line_below:
//    return false;
//fix_flaw_line_below:
//  }
   SetState(STATE_NORMAL);
   // TODO(beng): remove once NotifyClick takes ui::Event.
   ui::MouseEvent synthetic_event(
      ui::ET_MOUSE_RELEASED, gfx::Point(), gfx::Point(), ui::EventTimeForNow(),
      ui::EF_LEFT_MOUSE_BUTTON, ui::EF_LEFT_MOUSE_BUTTON);
  NotifyClick(synthetic_event);
  return true;
}
",186204," bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) {
   SetState(STATE_NORMAL);
   ui::MouseEvent synthetic_event(
      ui::ET_MOUSE_RELEASED, gfx::Point(), gfx::Point(), ui::EventTimeForNow(),
      ui::EF_LEFT_MOUSE_BUTTON, ui::EF_LEFT_MOUSE_BUTTON);
  NotifyClick(synthetic_event);
  return true;
}
"," bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) {
  // Should only handle accelerators when active. However, only top level
  // widgets can be active, so for child widgets check if they are focused
  // instead.
  if ((IsChildWidget() && !FocusInChildWidget()) ||
      (!IsChildWidget() && !GetWidget()->IsActive())) {
    return false;
  }
   SetState(STATE_NORMAL);
   ui::MouseEvent synthetic_event(
      ui::ET_MOUSE_RELEASED, gfx::Point(), gfx::Point(), ui::EventTimeForNow(),
      ui::EF_LEFT_MOUSE_BUTTON, ui::EF_LEFT_MOUSE_BUTTON);
  NotifyClick(synthetic_event);
  return true;
}
","The `AcceleratorPressed` function in the `CustomButton` class handles the event when a keyboard accelerator is triggered. It first resets the button's state to `STATE_NORMAL`, indicating that it is not currently pressed or activated. Then, it creates a synthetic mouse release event using the `ui::MouseEvent` constructor, simulating a left mouse button release at the current time and position. Finally, it calls the `NotifyClick` method with the synthetic event, effectively simulating a click action on the button, and returns `true` to indicate that the accelerator was successfully processed.","The provided code defines a function that responds to a specific keyboard shortcut by simulating a mouse click. When the shortcut is activated, the function first resets the button's visual state to indicate it is not pressed. It then generates a synthetic event that mimics the release of a mouse button, capturing the current time and position. This synthetic event is used to trigger a click notification, effectively simulating the action of a user clicking the button. The function concludes by confirming that the shortcut was successfully processed, allowing for further actions to be taken based on this input.","The vulnerability in the original code stemmed from the lack of checks to ensure that the button was active or focused before processing keyboard accelerators. This could allow unintended interactions when the button was not in a valid state, potentially leading to unexpected behavior or security issues. The fixed code addresses this by introducing a conditional check that verifies whether the button is part of a child widget and if it is focused, or if it is a top-level widget and active. This ensures that accelerators are only handled when the button is appropriately focused, enhancing the robustness of the interaction.","The vulnerability in the original code allowed keyboard accelerators to be processed even when the button was not in an active or focused state, potentially leading to unintended actions and security risks. This lack of validation could result in the button responding to inputs when it should not, causing confusion for users. The fixed code introduces checks to ensure that the button only handles accelerators when it is either part of a focused child widget or an active top-level widget. This change effectively restricts the processing of accelerators to appropriate contexts, thereby enhancing the overall reliability and security of the interaction.","The vulnerability was fixed by adding a conditional check at the beginning of the function to ensure that accelerators are only processed when the button is in a valid state. Specifically, the code now checks if the button is part of a child widget and whether it is focused using the `FocusInChildWidget` function, or if it is a top-level widget and active by calling `GetWidget()->IsActive()`. This ensures that the button will only handle accelerators when it is appropriately focused or active, preventing unintended interactions and enhancing the overall robustness of the button's behavior.","The vulnerability was fixed by implementing a validation mechanism that checks the button's state before processing keyboard accelerators. The updated code ensures that accelerators are only handled when the button is either part of a focused child widget or an active top-level widget. This added layer of verification prevents the button from responding to inputs when it is not in a valid state, thereby eliminating the risk of unintended actions. By enforcing these conditions, the code enhances the reliability and security of the button's interaction with user inputs.","CWE-749, CWE-20, CWE-284, CWE-732, CWE-285, CWE-269, CWE-287, CWE-601, CWE-290, CWE-693",N,-1.0,"5,5","5,5","4, 5","4,4"
6,6,186248,186248,,Remote,Not required,,CVE-2016-1657,https://www.cvedetails.com/cve/CVE-2016-1657/,CWE-254,Medium,,Partial,,2016-04-18,4.3,"The WebContentsImpl::FocusLocationBarByDefault function in content/browser/web_contents/web_contents_impl.cc in Google Chrome before 50.0.2661.75 mishandles focus for certain about:blank pages, which allows remote attackers to spoof the address bar via a crafted URL.",2018-10-30,,25,https://github.com/chromium/chromium/commit/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e,f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e,"Revert ""Update fontconfig to 6cc99d6a""

This reverts commit e6db40d91d0bd2afeb39f78f6d22404c3525b63c.

Reason for revert:

Findit (https://goo.gl/kROfz5) identified CL at revision 567445 as the
culprit for failures in the build cycles as shown on:
https://findit-for-me.appspot.com/waterfall/culprit?key=ag9zfmZpbmRpdC1mb3ItbWVyRAsSDVdmU3VzcGVjdGVkQ0wiMWNocm9taXVtL2U2ZGI0MGQ5MWQwYmQyYWZlYjM5Zjc4ZjZkMjI0MDRjMzUyNWI2M2MM

Sample Failed Build: https://ci.chromium.org/buildbot/chromium.linux/Linux%20Builder%20%28dbg%29%2832%29/83483

Sample Failed Step: compile

Original change's description:
> Update fontconfig to 6cc99d6a
> 
> Changelog [1].  This is necessary to pick up [2] for fixing undefined-shift
> UBSAN errors detected by clusterfuzz, [3] to allow removing a build workaround,
> [4] to fix a bug and clean up some log spam, [5] to fix CFI builds, and [6] to
> fix a use-after-free.
> 
> Fontconfig also now requires libuuid as a dependency, so whitelist it as a
> dependency since we statically link fontconfig.
> 
> [1] https://chromium.googlesource.com/external/fontconfig/+log/b546940435ebfb0df575bc7a2350d1e913919c34..6cc99d6a82ad67d2f5eac887b28bca13c0dfddde
> [2] https://chromium.googlesource.com/external/fontconfig/+/c60ed9ef66e59584f8b54323018e9e6c69925c7e
> [3] https://chromium.googlesource.com/external/fontconfig/+/b8a225b3c3495942480377b7b3404710c70be914
> [4] https://chromium.googlesource.com/external/fontconfig/+/7ad010e80bdf8e41303e322882ece908f5e04c74
> [5] https://chromium.googlesource.com/external/fontconfig/+/096e8019be595c2224aaabf98da630ee917ee51c
> [6] https://chromium.googlesource.com/external/fontconfig/+/6cc99d6a82ad67d2f5eac887b28bca13c0dfddde
> 
> BUG=831146,822737,787020,829890,847323
> TBR=thestig,dnicoara
> 
> Change-Id: Ic2d1bd19af8ca131c960a30d09246827c115ccec
> Reviewed-on: https://chromium-review.googlesource.com/1095538
> Commit-Queue: Thomas Anderson <thomasanderson@chromium.org>
> Reviewed-by: Thomas Anderson <thomasanderson@chromium.org>
> Reviewed-by: Lei Zhang <thestig@chromium.org>
> Reviewed-by: Daniel Nicoara <dnicoara@chromium.org>
> Cr-Commit-Position: refs/heads/master@{#567445}

No-Presubmit: true
No-Tree-Checks: true
No-Try: true
BUG=831146,822737,787020,829890,847323

Change-Id: I47d475941350efc76370fa5eb5043c80c5063495
Reviewed-on: https://chromium-review.googlesource.com/1101759
Cr-Commit-Position: refs/heads/master@{#567472}",17,base/test/fontconfig_util_linux.cc,"{""sha"": ""d99ebd2a596662303e935d9513c382c92211cb77"", ""filename"": ""DEPS"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/DEPS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/DEPS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/DEPS?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -588,7 +588,7 @@ deps = {\n \n   # Used for embedded builds. CrOS & Linux use the system version.\n   'src/third_party/fontconfig/src': {\n-      'url': Var('chromium_git') + '/external/fontconfig.git' + '@' + '6cc99d6a82ad67d2f5eac887b28bca13c0dfddde',\n+      'url': Var('chromium_git') + '/external/fontconfig.git' + '@' + 'b546940435ebfb0df575bc7a2350d1e913919c34',\n       'condition': 'checkout_linux',\n   },\n ""}<_**next**_>{""sha"": ""5c9bf5cee9589a1cb17c311acc0f72a012253979"", ""filename"": ""base/test/fontconfig_util_linux.cc"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 30, ""changes"": 55, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/base/test/fontconfig_util_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/base/test/fontconfig_util_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/test/fontconfig_util_linux.cc?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -7,7 +7,6 @@\n #include <fontconfig/fontconfig.h>\n \n #include \""base/base_paths.h\""\n-#include \""base/environment.h\""\n #include \""base/files/file_path.h\""\n #include \""base/files/file_util.h\""\n #include \""base/logging.h\""\n@@ -382,35 +381,31 @@ const char kFontsConfTemplate[] = R\""(<?xml version=\""1.0\""?>\n }  // namespace\n \n void SetUpFontconfig() {\n-  // TODO(thomasanderson): Use FONTCONFIG_SYSROOT to avoid having to write\n-  // a new fonts.conf with updated paths.\n-  std::unique_ptr<Environment> env = Environment::Create();\n-  if (!env->HasVar(\""FONTCONFIG_FILE\"")) {\n-    // fonts.conf must be generated on-the-fly since it contains absolute paths\n-    // which may be different if\n-    //   1. The user moves/renames their build directory (or any parent dirs).\n-    //   2. The build directory is mapped on a swarming bot at a location\n-    //      different from the one the buildbot used.\n-    FilePath dir_module;\n-    PathService::Get(DIR_MODULE, &dir_module);\n-    FilePath font_cache = dir_module.Append(\""fontconfig_caches\"");\n-    FilePath test_fonts = dir_module.Append(\""test_fonts\"");\n-    std::string fonts_conf = ReplaceStringPlaceholders(\n-        kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);\n-\n-    // Write the data to a different file and then atomically rename it to\n-    // fonts.conf.  This avoids the file being in a bad state when different\n-    // parallel tests call this function at the same time.\n-    FilePath fonts_conf_file_temp;\n-    CHECK(CreateTemporaryFileInDir(dir_module, &fonts_conf_file_temp));\n-    CHECK(\n-        WriteFile(fonts_conf_file_temp, fonts_conf.c_str(), fonts_conf.size()));\n-    FilePath fonts_conf_file = dir_module.Append(\""fonts.conf\"");\n-    CHECK(ReplaceFile(fonts_conf_file_temp, fonts_conf_file, nullptr));\n-    env->SetVar(\""FONTCONFIG_FILE\"", fonts_conf_file.value());\n-  }\n-\n-  CHECK(FcInit());\n+  FilePath dir_module;\n+  PathService::Get(DIR_MODULE, &dir_module);\n+  FilePath font_cache = dir_module.Append(\""fontconfig_caches\"");\n+  FilePath test_fonts = dir_module.Append(\""test_fonts\"");\n+  std::string fonts_conf = ReplaceStringPlaceholders(\n+      kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);\n+\n+  FcConfig* config = FcConfigCreate();\n+  CHECK(config);\n+#if FC_VERSION >= 21205\n+  CHECK(FcConfigParseAndLoadFromMemory(\n+      config, reinterpret_cast<const FcChar8*>(fonts_conf.c_str()), FcTrue));\n+#else\n+  FilePath temp;\n+  CHECK(CreateTemporaryFile(&temp));\n+  CHECK(WriteFile(temp, fonts_conf.c_str(), fonts_conf.size()));\n+  CHECK(FcConfigParseAndLoad(\n+      config, reinterpret_cast<const FcChar8*>(temp.value().c_str()), FcTrue));\n+  CHECK(DeleteFile(temp, false));\n+#endif\n+  CHECK(FcConfigBuildFonts(config));\n+  CHECK(FcConfigSetCurrent(config));\n+\n+  // Decrement the reference count for |config|.  It's now owned by fontconfig.\n+  FcConfigDestroy(config);\n }\n \n void TearDownFontconfig() {""}<_**next**_>{""sha"": ""9487fb2d3b944253b0eca5c2b48f0d5a4cf319d7"", ""filename"": ""chrome/installer/linux/debian/dist_package_versions.json"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 36, ""changes"": 66, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/chrome/installer/linux/debian/dist_package_versions.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/chrome/installer/linux/debian/dist_package_versions.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/installer/linux/debian/dist_package_versions.json?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -2,26 +2,25 @@\n     \""Debian 10 (Buster)\"": {\n         \""libappindicator3-1\"": \""0.4.92-5\"",\n         \""libasound2\"": \""1.1.3-5\"",\n-        \""libatk-bridge2.0-0\"": \""2.26.2-1\"",\n-        \""libatk1.0-0\"": \""2.28.1-1\"",\n-        \""libc6\"": \""2.27-3\"",\n-        \""libcairo2\"": \""1.15.10-1\"",\n-        \""libcups2\"": \""2.2.7-2\"",\n-        \""libdbus-1-3\"": \""1.12.6-2\"",\n+        \""libatk-bridge2.0-0\"": \""2.26.1-1\"",\n+        \""libatk1.0-0\"": \""2.26.1-3\"",\n+        \""libc6\"": \""2.26-4\"",\n+        \""libcairo2\"": \""1.15.8-3\"",\n+        \""libcups2\"": \""2.2.6-4\"",\n+        \""libdbus-1-3\"": \""1.12.2-1\"",\n         \""libexpat1\"": \""2.2.5-3\"",\n-        \""libgcc1\"": \""1:8-20180402-1\"",\n-        \""libgdk-pixbuf2.0-0\"": \""2.36.11-2\"",\n-        \""libglib2.0-0\"": \""2.56.0-4\"",\n-        \""libgtk-3-0\"": \""3.22.29-3\"",\n-        \""libnspr4\"": \""2:4.18-1\"",\n-        \""libnss3\"": \""2:3.35-2\"",\n-        \""libpango-1.0-0\"": \""1.42.0-1\"",\n-        \""libpangocairo-1.0-0\"": \""1.42.0-1\"",\n-        \""libstdc++6\"": \""8-20180402-1\"",\n-        \""libuuid1\"": \""2.31.1-0.5\"",\n-        \""libx11-6\"": \""2:1.6.5-1\"",\n-        \""libx11-xcb1\"": \""2:1.6.5-1\"",\n-        \""libxcb1\"": \""1.13-1\"",\n+        \""libgcc1\"": \""1:7.2.0-19\"",\n+        \""libgdk-pixbuf2.0-0\"": \""2.36.11-1\"",\n+        \""libglib2.0-0\"": \""2.54.3-2\"",\n+        \""libgtk-3-0\"": \""3.22.26-2\"",\n+        \""libnspr4\"": \""2:4.16-1+b1\"",\n+        \""libnss3\"": \""2:3.34.1-1\"",\n+        \""libpango-1.0-0\"": \""1.40.14-1\"",\n+        \""libpangocairo-1.0-0\"": \""1.40.14-1\"",\n+        \""libstdc++6\"": \""7.2.0-19\"",\n+        \""libx11-6\"": \""2:1.6.4-3\"",\n+        \""libx11-xcb1\"": \""2:1.6.4-3\"",\n+        \""libxcb1\"": \""1.12-1\"",\n         \""libxcomposite1\"": \""1:0.4.4-2\"",\n         \""libxcursor1\"": \""1:1.1.15-1\"",\n         \""libxdamage1\"": \""1:1.1.4-3\"",\n@@ -43,16 +42,15 @@\n         \""libcups2\"": \""1.7.5-11+deb8u1\"",\n         \""libdbus-1-3\"": \""1.8.22-0+deb8u1\"",\n         \""libexpat1\"": \""2.1.0-6+deb8u4\"",\n-        \""libgcc1\"": \""1:4.9.2-10+deb8u1\"",\n+        \""libgcc1\"": \""1:4.9.2-10\"",\n         \""libgdk-pixbuf2.0-0\"": \""2.31.1-2+deb8u7\"",\n         \""libglib2.0-0\"": \""2.42.1-1+b1\"",\n         \""libgtk-3-0\"": \""3.14.5-1+deb8u1\"",\n         \""libnspr4\"": \""2:4.12-1+debu8u1\"",\n         \""libnss3\"": \""2:3.26-1+debu8u3\"",\n         \""libpango-1.0-0\"": \""1.36.8-3\"",\n         \""libpangocairo-1.0-0\"": \""1.36.8-3\"",\n-        \""libstdc++6\"": \""4.9.2-10+deb8u1\"",\n-        \""libuuid1\"": \""2.25.2-6\"",\n+        \""libstdc++6\"": \""4.9.2-10\"",\n         \""libx11-6\"": \""2:1.6.2-3+deb8u1\"",\n         \""libx11-xcb1\"": \""2:1.6.2-3+deb8u1\"",\n         \""libxcb1\"": \""1.10-3+b1\"",\n@@ -74,19 +72,18 @@\n         \""libatk1.0-0\"": \""2.22.0-1\"",\n         \""libc6\"": \""2.24-11+deb9u1\"",\n         \""libcairo2\"": \""1.14.8-1\"",\n-        \""libcups2\"": \""2.2.1-8+deb9u1\"",\n-        \""libdbus-1-3\"": \""1.10.26-0+deb9u1\"",\n+        \""libcups2\"": \""2.2.1-8\"",\n+        \""libdbus-1-3\"": \""1.10.24-0+deb9u1\"",\n         \""libexpat1\"": \""2.2.0-2+deb9u1\"",\n-        \""libgcc1\"": \""1:6.3.0-18+deb9u1\"",\n+        \""libgcc1\"": \""1:6.3.0-18\"",\n         \""libgdk-pixbuf2.0-0\"": \""2.36.5-2+deb9u2\"",\n         \""libglib2.0-0\"": \""2.50.3-2\"",\n         \""libgtk-3-0\"": \""3.22.11-1\"",\n         \""libnspr4\"": \""2:4.12-6\"",\n         \""libnss3\"": \""2:3.26.2-1.1+deb9u1\"",\n         \""libpango-1.0-0\"": \""1.40.5-1\"",\n         \""libpangocairo-1.0-0\"": \""1.40.5-1\"",\n-        \""libstdc++6\"": \""6.3.0-18+deb9u1\"",\n-        \""libuuid1\"": \""2.29.2-1+deb9u1\"",\n+        \""libstdc++6\"": \""6.3.0-18\"",\n         \""libx11-6\"": \""2:1.6.4-3\"",\n         \""libx11-xcb1\"": \""2:1.6.4-3\"",\n         \""libxcb1\"": \""1.12-1\"",\n@@ -108,7 +105,7 @@\n         \""libatk1.0-0\"": \""2.10.0-2ubuntu2\"",\n         \""libc6\"": \""2.19-0ubuntu6.14\"",\n         \""libcairo2\"": \""1.13.0~20140204-0ubuntu1.1\"",\n-        \""libcups2\"": \""1.7.2-0ubuntu1.9\"",\n+        \""libcups2\"": \""1.7.2-0ubuntu1.7\"",\n         \""libdbus-1-3\"": \""1.6.18-0ubuntu4.4\"",\n         \""libexpat1\"": \""2.1.0-4ubuntu1.4\"",\n         \""libgcc1\"": \""1:4.9.3-0ubuntu4\"",\n@@ -119,8 +116,7 @@\n         \""libnss3\"": \""2:3.28.4-0ubuntu0.14.04.3\"",\n         \""libpango-1.0-0\"": \""1.36.3-1ubuntu1.1\"",\n         \""libpangocairo-1.0-0\"": \""1.36.3-1ubuntu1.1\"",\n-        \""libstdc++6\"": \""4.8.4-2ubuntu1~14.04.4\"",\n-        \""libuuid1\"": \""2.20.1-5.1ubuntu20.9\"",\n+        \""libstdc++6\"": \""4.8.4-2ubuntu1~14.04.3\"",\n         \""libx11-6\"": \""2:1.6.2-1ubuntu2\"",\n         \""libx11-xcb1\"": \""2:1.6.2-1ubuntu2\"",\n         \""libxcb1\"": \""1.10-2ubuntu1\"",\n@@ -142,7 +138,7 @@\n         \""libatk1.0-0\"": \""2.18.0-1\"",\n         \""libc6\"": \""2.23-0ubuntu10\"",\n         \""libcairo2\"": \""1.14.6-1\"",\n-        \""libcups2\"": \""2.1.3-4ubuntu0.4\"",\n+        \""libcups2\"": \""2.1.3-4ubuntu0.3\"",\n         \""libdbus-1-3\"": \""1.10.6-1ubuntu3.1\"",\n         \""libexpat1\"": \""2.1.0-7ubuntu0.16.04.3\"",\n         \""libgcc1\"": \""1:6.0.1-0ubuntu1\"",\n@@ -153,8 +149,7 @@\n         \""libnss3\"": \""2:3.28.4-0ubuntu0.16.04.3\"",\n         \""libpango-1.0-0\"": \""1.38.1-1\"",\n         \""libpangocairo-1.0-0\"": \""1.38.1-1\"",\n-        \""libstdc++6\"": \""5.4.0-6ubuntu1~16.04.9\"",\n-        \""libuuid1\"": \""2.27.1-6ubuntu3.4\"",\n+        \""libstdc++6\"": \""5.4.0-6ubuntu1~16.04.4\"",\n         \""libx11-6\"": \""2:1.6.3-1ubuntu2\"",\n         \""libx11-xcb1\"": \""2:1.6.3-1ubuntu2\"",\n         \""libxcb1\"": \""1.11.1-1ubuntu1\"",\n@@ -179,16 +174,15 @@\n         \""libcups2\"": \""2.2.4-7ubuntu3\"",\n         \""libdbus-1-3\"": \""1.10.22-1ubuntu1\"",\n         \""libexpat1\"": \""2.2.3-1\"",\n-        \""libgcc1\"": \""1:7.2.0-8ubuntu3.2\"",\n+        \""libgcc1\"": \""1:7.2.0-8ubuntu3\"",\n         \""libgdk-pixbuf2.0-0\"": \""2.36.11-1ubuntu0.1\"",\n         \""libglib2.0-0\"": \""2.54.1-1ubuntu1\"",\n         \""libgtk-3-0\"": \""3.22.25-0ubuntu0.1\"",\n         \""libnspr4\"": \""2:4.16-1ubuntu2\"",\n         \""libnss3\"": \""2:3.32-1ubuntu3\"",\n         \""libpango-1.0-0\"": \""1.40.12-1\"",\n         \""libpangocairo-1.0-0\"": \""1.40.12-1\"",\n-        \""libstdc++6\"": \""7.2.0-8ubuntu3.2\"",\n-        \""libuuid1\"": \""2.30.1-0ubuntu4.1\"",\n+        \""libstdc++6\"": \""7.2.0-8ubuntu3\"",\n         \""libx11-6\"": \""2:1.6.4-3\"",\n         \""libx11-xcb1\"": \""2:1.6.4-3\"",\n         \""libxcb1\"": \""1.12-1ubuntu1\"",""}<_**next**_>{""sha"": ""481dfd7b1930385ff44862dc9cd0ba112b422417"", ""filename"": ""chrome/installer/linux/debian/update_dist_package_versions.py"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/chrome/installer/linux/debian/update_dist_package_versions.py"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/chrome/installer/linux/debian/update_dist_package_versions.py"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/installer/linux/debian/update_dist_package_versions.py?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -52,7 +52,6 @@\n     \""libpango-1.0-0\"",\n     \""libpangocairo-1.0-0\"",\n     \""libstdc++6\"",\n-    \""libuuid1\"",\n     \""libx11-6\"",\n     \""libx11-xcb1\"",\n     \""libxcb1\"",""}<_**next**_>{""sha"": ""9edf127d28b20e6286e8c9ee12c8462aa270a487"", ""filename"": ""chrome/installer/linux/rpm/dist_package_provides.json"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 28, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/chrome/installer/linux/rpm/dist_package_provides.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/chrome/installer/linux/rpm/dist_package_provides.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/installer/linux/rpm/dist_package_provides.json?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -236,10 +236,6 @@\n         \""libstdc++.so.6(GLIBCXX_3.4.7)(64bit)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.8)(64bit)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.9)(64bit)\"",\n-        \""libuuid.so.1()(64bit)\"",\n-        \""libuuid.so.1(UUIDD_PRIVATE)(64bit)\"",\n-        \""libuuid.so.1(UUID_1.0)(64bit)\"",\n-        \""libuuid.so.1(UUID_2.20)(64bit)\"",\n         \""libxcb.so.1()(64bit)\"",\n         \""rtld(GNU_HASH)\""\n     ],\n@@ -486,10 +482,6 @@\n         \""libstdc++.so.6(GLIBCXX_3.4.7)(64bit)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.8)(64bit)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.9)(64bit)\"",\n-        \""libuuid.so.1()(64bit)\"",\n-        \""libuuid.so.1(UUIDD_PRIVATE)(64bit)\"",\n-        \""libuuid.so.1(UUID_1.0)(64bit)\"",\n-        \""libuuid.so.1(UUID_2.20)(64bit)\"",\n         \""libxcb.so.1()(64bit)\"",\n         \""rtld(GNU_HASH)\""\n     ],\n@@ -737,10 +729,6 @@\n         \""libstdc++.so.6(GLIBCXX_3.4.7)(64bit)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.8)(64bit)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.9)(64bit)\"",\n-        \""libuuid.so.1()(64bit)\"",\n-        \""libuuid.so.1(UUIDD_PRIVATE)(64bit)\"",\n-        \""libuuid.so.1(UUID_1.0)(64bit)\"",\n-        \""libuuid.so.1(UUID_2.20)(64bit)\"",\n         \""libxcb.so.1()(64bit)\"",\n         \""rtld(GNU_HASH)\""\n     ],\n@@ -1191,14 +1179,6 @@\n         \""libstdc++.so.6(GLIBCXX_3.4.8)(64bit)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.9)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.9)(64bit)\"",\n-        \""libuuid.so.1\"",\n-        \""libuuid.so.1()(64bit)\"",\n-        \""libuuid.so.1(UUIDD_PRIVATE)\"",\n-        \""libuuid.so.1(UUIDD_PRIVATE)(64bit)\"",\n-        \""libuuid.so.1(UUID_1.0)\"",\n-        \""libuuid.so.1(UUID_1.0)(64bit)\"",\n-        \""libuuid.so.1(UUID_2.20)\"",\n-        \""libuuid.so.1(UUID_2.20)(64bit)\"",\n         \""libxcb.so.1\"",\n         \""libxcb.so.1()(64bit)\"",\n         \""rtld(GNU_HASH)\""\n@@ -1658,14 +1638,6 @@\n         \""libstdc++.so.6(GLIBCXX_3.4.8)(64bit)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.9)\"",\n         \""libstdc++.so.6(GLIBCXX_3.4.9)(64bit)\"",\n-        \""libuuid.so.1\"",\n-        \""libuuid.so.1()(64bit)\"",\n-        \""libuuid.so.1(UUIDD_PRIVATE)\"",\n-        \""libuuid.so.1(UUIDD_PRIVATE)(64bit)\"",\n-        \""libuuid.so.1(UUID_1.0)\"",\n-        \""libuuid.so.1(UUID_1.0)(64bit)\"",\n-        \""libuuid.so.1(UUID_2.20)\"",\n-        \""libuuid.so.1(UUID_2.20)(64bit)\"",\n         \""libxcb.so.1\"",\n         \""libxcb.so.1()(64bit)\"",\n         \""rtld(GNU_HASH)\""""}<_**next**_>{""sha"": ""4ce30012357a32e1316dbb3930ce55ddf9acacfa"", ""filename"": ""chrome/installer/linux/rpm/update_package_provides.py"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/chrome/installer/linux/rpm/update_package_provides.py"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/chrome/installer/linux/rpm/update_package_provides.py"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/installer/linux/rpm/update_package_provides.py?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -54,7 +54,6 @@\n     \""librt.so\"",\n     \""libsmime3.so\"",\n     \""libstdc++.so\"",\n-    \""libuuid.so\"",\n     \""libxcb.so\"",\n     \""rtld(GNU_HASH)\"",\n ]""}<_**next**_>{""sha"": ""19c41003de611bd0727cfd4f3385c5041fac07bf"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/fast/text/unicode-fallback-font-expected.png"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 0, ""changes"": 0, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/WebKit/LayoutTests/platform/linux/fast/text/unicode-fallback-font-expected.png"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/WebKit/LayoutTests/platform/linux/fast/text/unicode-fallback-font-expected.png"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/fast/text/unicode-fallback-font-expected.png?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e""}<_**next**_>{""sha"": ""8ff1984a7df58ca5df821c1076a13c3483c40b20"", ""filename"": ""third_party/fontconfig/BUILD.gn"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 13, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/BUILD.gn?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -15,6 +15,7 @@ if (use_bundled_fontconfig) {\n     sources = [\n       \""src/src/fcarch.h\"",\n       \""src/src/fcatomic.c\"",\n+      \""src/src/fcblanks.c\"",\n       \""src/src/fccache.c\"",\n       \""src/src/fccfg.c\"",\n       \""src/src/fccharset.c\"",\n@@ -25,7 +26,6 @@ if (use_bundled_fontconfig) {\n       \""src/src/fcformat.c\"",\n       \""src/src/fcfreetype.c\"",\n       \""src/src/fcfs.c\"",\n-      \""src/src/fchash.c\"",\n       \""src/src/fcinit.c\"",\n       \""src/src/fclang.c\"",\n       \""src/src/fclist.c\"",\n@@ -34,7 +34,6 @@ if (use_bundled_fontconfig) {\n       \""src/src/fcname.c\"",\n       \""src/src/fcobjs.c\"",\n       \""src/src/fcpat.c\"",\n-      \""src/src/fcptrlist.c\"",\n       \""src/src/fcrange.c\"",\n       \""src/src/fcserialize.c\"",\n       \""src/src/fcstat.c\"",\n@@ -53,17 +52,14 @@ if (use_bundled_fontconfig) {\n     defines = [\n       \""HAVE_CONFIG_H\"",\n       \""FC_CACHEDIR=\\\""/var/cache/fontconfig\\\""\"",\n-      \""FC_TEMPLATEDIR=\\\""/usr/share/fontconfig/conf.avail\\\""\"",\n       \""FONTCONFIG_PATH=\\\""/etc/fonts\\\""\"",\n     ]\n \n-    # Fontconfig symbols should not be exported from chrome, nacl_helper, or\n-    # anything else.\n+    # This is a hack to remove visibility(\""default\"") annotations.  Fontconfig\n+    # symbols should not be exported from chrome, nacl_helper, or anything\n+    # else.\n     if (!is_component_build) {\n-      defines += [\n-        \""FC_ATTRIBUTE_VISIBILITY_HIDDEN=__attribute((visibility(\\\""hidden\\\"")))\"",\n-        \""FC_ATTRIBUTE_VISIBILITY_EXPORT=__attribute((visibility(\\\""hidden\\\"")))\"",\n-      ]\n+      defines += [ \""visibility(x)=\"" ]\n     }\n \n     deps = [\n@@ -86,10 +82,6 @@ if (use_bundled_fontconfig) {\n         \""-Wno-pointer-bool-conversion\"",\n       ]\n     }\n-\n-    if (!is_win) {\n-      libs = [ \""uuid\"" ]\n-    }\n   }\n } else {\n   config(\""fontconfig_config\"") {""}<_**next**_>{""sha"": ""82160d5ef526a87226c3551c2c4b41edb82ab1b9"", ""filename"": ""third_party/fontconfig/OWNERS"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/OWNERS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/OWNERS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/OWNERS?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -1,3 +1,2 @@\n spang@chromium.org\n dnicoara@chromium.org\n-thomasanderson@chromium.org""}<_**next**_>{""sha"": ""5a7a10c36e3fd1f50b10ff81cd3074f249ae74e5"", ""filename"": ""third_party/fontconfig/README.chromium"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 5, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/README.chromium"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/README.chromium"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/README.chromium?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -1,6 +1,6 @@\n Name: fontconfig\n URL: http://www.freedesktop.org/wiki/Software/fontconfig/\n-Version: 6cc99d6a82ad67d2f5eac887b28bca13c0dfddde\n+Version: 2.12.6\n License: MIT\n License File: src/COPYING\n Security Critical: yes\n@@ -12,11 +12,9 @@ Modifications:\n - None\n \n To import a new snapshot of fontconfig:\n-- Checkout the latest revision:\n-    git fetch origin master\n-    git checkout origin/master\n+- Checkout the latest release tag: git checkout 2.12.6\n - Change the DEPS entry to the newly checked out commit.\n - Update generated files:\n-    ./autogen.sh --enable-libxml2 --disable-docs && make\n+    ./autogen.sh --enable-libxml2 && make\n     rsync -R $(git ls-files --others '*.h' '*/*.h') ../include\n - Update this README to reflect the new version number.""}<_**next**_>{""sha"": ""82b0e6581bb118db13b04e4944dbadfd4424c544"", ""filename"": ""third_party/fontconfig/include/config.h"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 37, ""changes"": 55, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/config.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/config.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/include/config.h?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -13,10 +13,6 @@\n /* Use libxml2 instead of Expat */\n #define ENABLE_LIBXML2 1\n \n-/* Define to 1 if translation of program messages to the user's native\n-   language is requested. */\n-#define ENABLE_NLS 1\n-\n /* Additional font directories */\n #define FC_ADD_FONTS \""yes\""\n \n@@ -27,7 +23,7 @@\n #define FC_DEFAULT_FONTS \""/usr/share/fonts\""\n \n /* The type of len parameter of the gperf hash/lookup function */\n-#define FC_GPERF_SIZE_T size_t\n+#define FC_GPERF_SIZE_T unsigned int\n \n /* Define to nothing if C supports flexible array members, and to 1 if it does\n    not. That way, with a declaration like `struct s { int n; double\n@@ -38,21 +34,6 @@\n    MSVC and with C++ compilers. */\n #define FLEXIBLE_ARRAY_MEMBER /**/\n \n-/* Gettext package */\n-#define GETTEXT_PACKAGE \""fontconfig\""\n-\n-/* Define to 1 if you have the Mac OS X function CFLocaleCopyCurrent in the\n-   CoreFoundation framework. */\n-/* #undef HAVE_CFLOCALECOPYCURRENT */\n-\n-/* Define to 1 if you have the Mac OS X function CFPreferencesCopyAppValue in\n-   the CoreFoundation framework. */\n-/* #undef HAVE_CFPREFERENCESCOPYAPPVALUE */\n-\n-/* Define if the GNU dcgettext() function is already present or preinstalled.\n-   */\n-#define HAVE_DCGETTEXT 1\n-\n /* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.\n    */\n #define HAVE_DIRENT_H 1\n@@ -72,12 +53,15 @@\n /* Define to 1 if you have the `fstatvfs' function. */\n #define HAVE_FSTATVFS 1\n \n-/* Define to 1 if you have the `FT_Done_MM_Var' function. */\n-/* #undef HAVE_FT_DONE_MM_VAR */\n+/* FT_Bitmap_Size structure includes y_ppem field */\n+#define HAVE_FT_BITMAP_SIZE_Y_PPEM 1\n \n /* Define to 1 if you have the `FT_Get_BDF_Property' function. */\n #define HAVE_FT_GET_BDF_PROPERTY 1\n \n+/* Define to 1 if you have the `FT_Get_Next_Char' function. */\n+#define HAVE_FT_GET_NEXT_CHAR 1\n+\n /* Define to 1 if you have the `FT_Get_PS_Font_Info' function. */\n #define HAVE_FT_GET_PS_FONT_INFO 1\n \n@@ -87,6 +71,9 @@\n /* Define to 1 if you have the `FT_Has_PS_Glyph_Names' function. */\n #define HAVE_FT_HAS_PS_GLYPH_NAMES 1\n \n+/* Define to 1 if you have the `FT_Select_Size' function. */\n+#define HAVE_FT_SELECT_SIZE 1\n+\n /* Define to 1 if you have the `getexecname' function. */\n /* #undef HAVE_GETEXECNAME */\n \n@@ -102,12 +89,6 @@\n /* Define to 1 if you have the `getprogname' function. */\n /* #undef HAVE_GETPROGNAME */\n \n-/* Define if the GNU gettext() function is already present or preinstalled. */\n-#define HAVE_GETTEXT 1\n-\n-/* Define if you have the iconv() function and it works. */\n-/* #undef HAVE_ICONV */\n-\n /* Have Intel __sync_* atomic primitives */\n #define HAVE_INTEL_ATOMIC_PRIMITIVES 1\n \n@@ -180,12 +161,6 @@\n /* Define to 1 if you have the <stdlib.h> header file. */\n #define HAVE_STDLIB_H 1\n \n-/* Define to 1 if you have the `strerror' function. */\n-#define HAVE_STRERROR 1\n-\n-/* Define to 1 if you have the `strerror_r' function. */\n-#define HAVE_STRERROR_R 1\n-\n /* Define to 1 if you have the <strings.h> header file. */\n #define HAVE_STRINGS_H 1\n \n@@ -239,6 +214,12 @@\n /* Define to 1 if you have the <sys/vfs.h> header file. */\n #define HAVE_SYS_VFS_H 1\n \n+/* Define to 1 if `usLowerOpticalPointSize' is a member of `TT_OS2'. */\n+#define HAVE_TT_OS2_USLOWEROPTICALPOINTSIZE 1\n+\n+/* Define to 1 if `usUpperOpticalPointSize' is a member of `TT_OS2'. */\n+#define HAVE_TT_OS2_USUPPEROPTICALPOINTSIZE 1\n+\n /* Define to 1 if you have the <unistd.h> header file. */\n #define HAVE_UNISTD_H 1\n \n@@ -270,7 +251,7 @@\n #define PACKAGE_NAME \""fontconfig\""\n \n /* Define to the full name and version of this package. */\n-#define PACKAGE_STRING \""fontconfig 2.13.0\""\n+#define PACKAGE_STRING \""fontconfig 2.12.6\""\n \n /* Define to the one symbol short name of this package. */\n #define PACKAGE_TARNAME \""fontconfig\""\n@@ -279,7 +260,7 @@\n #define PACKAGE_URL \""\""\n \n /* Define to the version of this package. */\n-#define PACKAGE_VERSION \""2.13.0\""\n+#define PACKAGE_VERSION \""2.12.6\""\n \n /* Define to necessary symbol if this constant uses a non-standard name on\n    your system. */\n@@ -332,7 +313,7 @@\n \n \n /* Version number of package */\n-#define VERSION \""2.13.0\""\n+#define VERSION \""2.12.6\""\n \n /* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n    significant byte first (like Motorola and SPARC, unlike Intel). */""}<_**next**_>{""sha"": ""5be716d0c8468917ad5a755714757272f9d4aeba"", ""filename"": ""third_party/fontconfig/include/fc-case/fccase.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 5, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/fc-case/fccase.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/fc-case/fccase.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/include/fc-case/fccase.h?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -22,7 +22,7 @@\n  * PERFORMANCE OF THIS SOFTWARE.\n  */\n \n-#define FC_NUM_CASE_FOLD\t291\n+#define FC_NUM_CASE_FOLD\t288\n #define FC_NUM_CASE_FOLD_CHARS\t471\n #define FC_MAX_CASE_FOLD_CHARS\t6\n #define FC_MAX_CASE_FOLD_EXPAND\t4\n@@ -146,8 +146,6 @@ static const FcCaseFold    fcCaseFold[FC_NUM_CASE_FOLD] = {\n     { 0x00001c86, FC_CASE_FOLD_RANGE,    0x0001,  -6204 },\n     { 0x00001c87, FC_CASE_FOLD_RANGE,    0x0001,  -6180 },\n     { 0x00001c88, FC_CASE_FOLD_RANGE,    0x0001, -30269 },\n-    { 0x00001c90, FC_CASE_FOLD_RANGE,    0x002b,  -3008 },\n-    { 0x00001cbd, FC_CASE_FOLD_RANGE,    0x0003,  -3008 },\n     { 0x00001e00, FC_CASE_FOLD_EVEN_ODD, 0x0095,      1 },\n     { 0x00001e96, FC_CASE_FOLD_FULL,     0x0003,     27 },\n     { 0x00001e97, FC_CASE_FOLD_FULL,     0x0003,     30 },\n@@ -300,7 +298,7 @@ static const FcCaseFold    fcCaseFold[FC_NUM_CASE_FOLD] = {\n     { 0x0000a7b1, FC_CASE_FOLD_RANGE,    0x0001,  23254 },\n     { 0x0000a7b2, FC_CASE_FOLD_RANGE,    0x0001,  23275 },\n     { 0x0000a7b3, FC_CASE_FOLD_RANGE,    0x0001,    928 },\n-    { 0x0000a7b4, FC_CASE_FOLD_EVEN_ODD, 0x0005,      1 },\n+    { 0x0000a7b4, FC_CASE_FOLD_EVEN_ODD, 0x0003,      1 },\n     { 0x0000ab70, FC_CASE_FOLD_RANGE,    0x0050,  26672 },\n     { 0x0000fb00, FC_CASE_FOLD_FULL,     0x0002,    435 },\n     { 0x0000fb01, FC_CASE_FOLD_FULL,     0x0002,    437 },\n@@ -319,7 +317,6 @@ static const FcCaseFold    fcCaseFold[FC_NUM_CASE_FOLD] = {\n     { 0x000104b0, FC_CASE_FOLD_RANGE,    0x0024,     40 },\n     { 0x00010c80, FC_CASE_FOLD_RANGE,    0x0033,     64 },\n     { 0x000118a0, FC_CASE_FOLD_RANGE,    0x0020,     32 },\n-    { 0x00016e40, FC_CASE_FOLD_RANGE,    0x0020,     32 },\n     { 0x0001e900, FC_CASE_FOLD_RANGE,    0x0022,     34 },\n };\n ""}<_**next**_>{""sha"": ""153915847283ee51ce4105578bc1cef92dd32ecf"", ""filename"": ""third_party/fontconfig/include/src/fcalias.h"", ""status"": ""modified"", ""additions"": 207, ""deletions"": 241, ""changes"": 448, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcalias.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcalias.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/include/src/fcalias.h?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -1,448 +1,414 @@\n-extern __typeof (FcBlanksCreate) IA__FcBlanksCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcBlanksCreate) IA__FcBlanksCreate __attribute((visibility(\""hidden\"")));\n #define FcBlanksCreate IA__FcBlanksCreate\n-extern __typeof (FcBlanksDestroy) IA__FcBlanksDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcBlanksDestroy) IA__FcBlanksDestroy __attribute((visibility(\""hidden\"")));\n #define FcBlanksDestroy IA__FcBlanksDestroy\n-extern __typeof (FcBlanksAdd) IA__FcBlanksAdd FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcBlanksAdd) IA__FcBlanksAdd __attribute((visibility(\""hidden\"")));\n #define FcBlanksAdd IA__FcBlanksAdd\n-extern __typeof (FcBlanksIsMember) IA__FcBlanksIsMember FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcBlanksIsMember) IA__FcBlanksIsMember __attribute((visibility(\""hidden\"")));\n #define FcBlanksIsMember IA__FcBlanksIsMember\n-extern __typeof (FcCacheCopySet) IA__FcCacheCopySet FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCacheCopySet) IA__FcCacheCopySet __attribute((visibility(\""hidden\"")));\n #define FcCacheCopySet IA__FcCacheCopySet\n-extern __typeof (FcCacheNumSubdir) IA__FcCacheNumSubdir FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCacheNumSubdir) IA__FcCacheNumSubdir __attribute((visibility(\""hidden\"")));\n #define FcCacheNumSubdir IA__FcCacheNumSubdir\n-extern __typeof (FcCacheNumFont) IA__FcCacheNumFont FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCacheNumFont) IA__FcCacheNumFont __attribute((visibility(\""hidden\"")));\n #define FcCacheNumFont IA__FcCacheNumFont\n-extern __typeof (FcDirCacheUnlink) IA__FcDirCacheUnlink FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirCacheUnlink) IA__FcDirCacheUnlink __attribute((visibility(\""hidden\"")));\n #define FcDirCacheUnlink IA__FcDirCacheUnlink\n-extern __typeof (FcDirCacheValid) IA__FcDirCacheValid FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirCacheValid) IA__FcDirCacheValid __attribute((visibility(\""hidden\"")));\n #define FcDirCacheValid IA__FcDirCacheValid\n-extern __typeof (FcDirCacheClean) IA__FcDirCacheClean FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirCacheClean) IA__FcDirCacheClean __attribute((visibility(\""hidden\"")));\n #define FcDirCacheClean IA__FcDirCacheClean\n-extern __typeof (FcCacheCreateTagFile) IA__FcCacheCreateTagFile FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCacheCreateTagFile) IA__FcCacheCreateTagFile __attribute((visibility(\""hidden\"")));\n #define FcCacheCreateTagFile IA__FcCacheCreateTagFile\n-extern __typeof (FcDirCacheCreateUUID) IA__FcDirCacheCreateUUID FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcDirCacheCreateUUID IA__FcDirCacheCreateUUID\n-extern __typeof (FcDirCacheDeleteUUID) IA__FcDirCacheDeleteUUID FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcDirCacheDeleteUUID IA__FcDirCacheDeleteUUID\n-extern __typeof (FcConfigHome) IA__FcConfigHome FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigHome) IA__FcConfigHome __attribute((visibility(\""hidden\"")));\n #define FcConfigHome IA__FcConfigHome\n-extern __typeof (FcConfigEnableHome) IA__FcConfigEnableHome FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigEnableHome) IA__FcConfigEnableHome __attribute((visibility(\""hidden\"")));\n #define FcConfigEnableHome IA__FcConfigEnableHome\n-extern __typeof (FcConfigFilename) IA__FcConfigFilename FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigFilename) IA__FcConfigFilename __attribute((visibility(\""hidden\"")));\n #define FcConfigFilename IA__FcConfigFilename\n-extern __typeof (FcConfigCreate) IA__FcConfigCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigCreate) IA__FcConfigCreate __attribute((visibility(\""hidden\"")));\n #define FcConfigCreate IA__FcConfigCreate\n-extern __typeof (FcConfigReference) IA__FcConfigReference FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigReference) IA__FcConfigReference __attribute((visibility(\""hidden\"")));\n #define FcConfigReference IA__FcConfigReference\n-extern __typeof (FcConfigDestroy) IA__FcConfigDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigDestroy) IA__FcConfigDestroy __attribute((visibility(\""hidden\"")));\n #define FcConfigDestroy IA__FcConfigDestroy\n-extern __typeof (FcConfigSetCurrent) IA__FcConfigSetCurrent FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigSetCurrent) IA__FcConfigSetCurrent __attribute((visibility(\""hidden\"")));\n #define FcConfigSetCurrent IA__FcConfigSetCurrent\n-extern __typeof (FcConfigGetCurrent) IA__FcConfigGetCurrent FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetCurrent) IA__FcConfigGetCurrent __attribute((visibility(\""hidden\"")));\n #define FcConfigGetCurrent IA__FcConfigGetCurrent\n-extern __typeof (FcConfigUptoDate) IA__FcConfigUptoDate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigUptoDate) IA__FcConfigUptoDate __attribute((visibility(\""hidden\"")));\n #define FcConfigUptoDate IA__FcConfigUptoDate\n-extern __typeof (FcConfigBuildFonts) IA__FcConfigBuildFonts FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigBuildFonts) IA__FcConfigBuildFonts __attribute((visibility(\""hidden\"")));\n #define FcConfigBuildFonts IA__FcConfigBuildFonts\n-extern __typeof (FcConfigGetFontDirs) IA__FcConfigGetFontDirs FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetFontDirs) IA__FcConfigGetFontDirs __attribute((visibility(\""hidden\"")));\n #define FcConfigGetFontDirs IA__FcConfigGetFontDirs\n-extern __typeof (FcConfigGetConfigDirs) IA__FcConfigGetConfigDirs FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetConfigDirs) IA__FcConfigGetConfigDirs __attribute((visibility(\""hidden\"")));\n #define FcConfigGetConfigDirs IA__FcConfigGetConfigDirs\n-extern __typeof (FcConfigGetConfigFiles) IA__FcConfigGetConfigFiles FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetConfigFiles) IA__FcConfigGetConfigFiles __attribute((visibility(\""hidden\"")));\n #define FcConfigGetConfigFiles IA__FcConfigGetConfigFiles\n-extern __typeof (FcConfigGetCache) IA__FcConfigGetCache FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetCache) IA__FcConfigGetCache __attribute((visibility(\""hidden\"")));\n #define FcConfigGetCache IA__FcConfigGetCache\n-extern __typeof (FcConfigGetBlanks) IA__FcConfigGetBlanks FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetBlanks) IA__FcConfigGetBlanks __attribute((visibility(\""hidden\"")));\n #define FcConfigGetBlanks IA__FcConfigGetBlanks\n-extern __typeof (FcConfigGetCacheDirs) IA__FcConfigGetCacheDirs FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetCacheDirs) IA__FcConfigGetCacheDirs __attribute((visibility(\""hidden\"")));\n #define FcConfigGetCacheDirs IA__FcConfigGetCacheDirs\n-extern __typeof (FcConfigGetRescanInterval) IA__FcConfigGetRescanInterval FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetRescanInterval) IA__FcConfigGetRescanInterval __attribute((visibility(\""hidden\"")));\n #define FcConfigGetRescanInterval IA__FcConfigGetRescanInterval\n-extern __typeof (FcConfigSetRescanInterval) IA__FcConfigSetRescanInterval FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigSetRescanInterval) IA__FcConfigSetRescanInterval __attribute((visibility(\""hidden\"")));\n #define FcConfigSetRescanInterval IA__FcConfigSetRescanInterval\n-extern __typeof (FcConfigGetFonts) IA__FcConfigGetFonts FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetFonts) IA__FcConfigGetFonts __attribute((visibility(\""hidden\"")));\n #define FcConfigGetFonts IA__FcConfigGetFonts\n-extern __typeof (FcConfigAppFontAddFile) IA__FcConfigAppFontAddFile FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigAppFontAddFile) IA__FcConfigAppFontAddFile __attribute((visibility(\""hidden\"")));\n #define FcConfigAppFontAddFile IA__FcConfigAppFontAddFile\n-extern __typeof (FcConfigAppFontAddDir) IA__FcConfigAppFontAddDir FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigAppFontAddDir) IA__FcConfigAppFontAddDir __attribute((visibility(\""hidden\"")));\n #define FcConfigAppFontAddDir IA__FcConfigAppFontAddDir\n-extern __typeof (FcConfigAppFontClear) IA__FcConfigAppFontClear FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigAppFontClear) IA__FcConfigAppFontClear __attribute((visibility(\""hidden\"")));\n #define FcConfigAppFontClear IA__FcConfigAppFontClear\n-extern __typeof (FcConfigSubstituteWithPat) IA__FcConfigSubstituteWithPat FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigSubstituteWithPat) IA__FcConfigSubstituteWithPat __attribute((visibility(\""hidden\"")));\n #define FcConfigSubstituteWithPat IA__FcConfigSubstituteWithPat\n-extern __typeof (FcConfigSubstitute) IA__FcConfigSubstitute FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigSubstitute) IA__FcConfigSubstitute __attribute((visibility(\""hidden\"")));\n #define FcConfigSubstitute IA__FcConfigSubstitute\n-extern __typeof (FcConfigGetSysRoot) IA__FcConfigGetSysRoot FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetSysRoot) IA__FcConfigGetSysRoot __attribute((visibility(\""hidden\"")));\n #define FcConfigGetSysRoot IA__FcConfigGetSysRoot\n-extern __typeof (FcConfigSetSysRoot) IA__FcConfigSetSysRoot FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigSetSysRoot) IA__FcConfigSetSysRoot __attribute((visibility(\""hidden\"")));\n #define FcConfigSetSysRoot IA__FcConfigSetSysRoot\n-extern __typeof (FcConfigFileInfoIterInit) IA__FcConfigFileInfoIterInit FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcConfigFileInfoIterInit IA__FcConfigFileInfoIterInit\n-extern __typeof (FcConfigFileInfoIterNext) IA__FcConfigFileInfoIterNext FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcConfigFileInfoIterNext IA__FcConfigFileInfoIterNext\n-extern __typeof (FcConfigFileInfoIterGet) IA__FcConfigFileInfoIterGet FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcConfigFileInfoIterGet IA__FcConfigFileInfoIterGet\n-extern __typeof (FcCharSetCreate) IA__FcCharSetCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetCreate) IA__FcCharSetCreate __attribute((visibility(\""hidden\"")));\n #define FcCharSetCreate IA__FcCharSetCreate\n-extern __typeof (FcCharSetNew) IA__FcCharSetNew FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetNew) IA__FcCharSetNew __attribute((visibility(\""hidden\"")));\n #define FcCharSetNew IA__FcCharSetNew\n-extern __typeof (FcCharSetDestroy) IA__FcCharSetDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetDestroy) IA__FcCharSetDestroy __attribute((visibility(\""hidden\"")));\n #define FcCharSetDestroy IA__FcCharSetDestroy\n-extern __typeof (FcCharSetAddChar) IA__FcCharSetAddChar FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetAddChar) IA__FcCharSetAddChar __attribute((visibility(\""hidden\"")));\n #define FcCharSetAddChar IA__FcCharSetAddChar\n-extern __typeof (FcCharSetDelChar) IA__FcCharSetDelChar FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetDelChar) IA__FcCharSetDelChar __attribute((visibility(\""hidden\"")));\n #define FcCharSetDelChar IA__FcCharSetDelChar\n-extern __typeof (FcCharSetCopy) IA__FcCharSetCopy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetCopy) IA__FcCharSetCopy __attribute((visibility(\""hidden\"")));\n #define FcCharSetCopy IA__FcCharSetCopy\n-extern __typeof (FcCharSetEqual) IA__FcCharSetEqual FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetEqual) IA__FcCharSetEqual __attribute((visibility(\""hidden\"")));\n #define FcCharSetEqual IA__FcCharSetEqual\n-extern __typeof (FcCharSetIntersect) IA__FcCharSetIntersect FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetIntersect) IA__FcCharSetIntersect __attribute((visibility(\""hidden\"")));\n #define FcCharSetIntersect IA__FcCharSetIntersect\n-extern __typeof (FcCharSetUnion) IA__FcCharSetUnion FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetUnion) IA__FcCharSetUnion __attribute((visibility(\""hidden\"")));\n #define FcCharSetUnion IA__FcCharSetUnion\n-extern __typeof (FcCharSetSubtract) IA__FcCharSetSubtract FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetSubtract) IA__FcCharSetSubtract __attribute((visibility(\""hidden\"")));\n #define FcCharSetSubtract IA__FcCharSetSubtract\n-extern __typeof (FcCharSetMerge) IA__FcCharSetMerge FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetMerge) IA__FcCharSetMerge __attribute((visibility(\""hidden\"")));\n #define FcCharSetMerge IA__FcCharSetMerge\n-extern __typeof (FcCharSetHasChar) IA__FcCharSetHasChar FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetHasChar) IA__FcCharSetHasChar __attribute((visibility(\""hidden\"")));\n #define FcCharSetHasChar IA__FcCharSetHasChar\n-extern __typeof (FcCharSetCount) IA__FcCharSetCount FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetCount) IA__FcCharSetCount __attribute((visibility(\""hidden\"")));\n #define FcCharSetCount IA__FcCharSetCount\n-extern __typeof (FcCharSetIntersectCount) IA__FcCharSetIntersectCount FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetIntersectCount) IA__FcCharSetIntersectCount __attribute((visibility(\""hidden\"")));\n #define FcCharSetIntersectCount IA__FcCharSetIntersectCount\n-extern __typeof (FcCharSetSubtractCount) IA__FcCharSetSubtractCount FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetSubtractCount) IA__FcCharSetSubtractCount __attribute((visibility(\""hidden\"")));\n #define FcCharSetSubtractCount IA__FcCharSetSubtractCount\n-extern __typeof (FcCharSetIsSubset) IA__FcCharSetIsSubset FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetIsSubset) IA__FcCharSetIsSubset __attribute((visibility(\""hidden\"")));\n #define FcCharSetIsSubset IA__FcCharSetIsSubset\n-extern __typeof (FcCharSetFirstPage) IA__FcCharSetFirstPage FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetFirstPage) IA__FcCharSetFirstPage __attribute((visibility(\""hidden\"")));\n #define FcCharSetFirstPage IA__FcCharSetFirstPage\n-extern __typeof (FcCharSetNextPage) IA__FcCharSetNextPage FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetNextPage) IA__FcCharSetNextPage __attribute((visibility(\""hidden\"")));\n #define FcCharSetNextPage IA__FcCharSetNextPage\n-extern __typeof (FcCharSetCoverage) IA__FcCharSetCoverage FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcCharSetCoverage) IA__FcCharSetCoverage __attribute((visibility(\""hidden\"")));\n #define FcCharSetCoverage IA__FcCharSetCoverage\n-extern __typeof (FcValuePrint) IA__FcValuePrint FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcValuePrint) IA__FcValuePrint __attribute((visibility(\""hidden\"")));\n #define FcValuePrint IA__FcValuePrint\n-extern __typeof (FcPatternPrint) IA__FcPatternPrint FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternPrint) IA__FcPatternPrint __attribute((visibility(\""hidden\"")));\n #define FcPatternPrint IA__FcPatternPrint\n-extern __typeof (FcFontSetPrint) IA__FcFontSetPrint FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontSetPrint) IA__FcFontSetPrint __attribute((visibility(\""hidden\"")));\n #define FcFontSetPrint IA__FcFontSetPrint\n-extern __typeof (FcGetDefaultLangs) IA__FcGetDefaultLangs FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcGetDefaultLangs) IA__FcGetDefaultLangs __attribute((visibility(\""hidden\"")));\n #define FcGetDefaultLangs IA__FcGetDefaultLangs\n-extern __typeof (FcDefaultSubstitute) IA__FcDefaultSubstitute FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDefaultSubstitute) IA__FcDefaultSubstitute __attribute((visibility(\""hidden\"")));\n #define FcDefaultSubstitute IA__FcDefaultSubstitute\n-extern __typeof (FcFileIsDir) IA__FcFileIsDir FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFileIsDir) IA__FcFileIsDir __attribute((visibility(\""hidden\"")));\n #define FcFileIsDir IA__FcFileIsDir\n-extern __typeof (FcFileScan) IA__FcFileScan FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFileScan) IA__FcFileScan __attribute((visibility(\""hidden\"")));\n #define FcFileScan IA__FcFileScan\n-extern __typeof (FcDirScan) IA__FcDirScan FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirScan) IA__FcDirScan __attribute((visibility(\""hidden\"")));\n #define FcDirScan IA__FcDirScan\n-extern __typeof (FcDirSave) IA__FcDirSave FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirSave) IA__FcDirSave __attribute((visibility(\""hidden\"")));\n #define FcDirSave IA__FcDirSave\n-extern __typeof (FcDirCacheLoad) IA__FcDirCacheLoad FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirCacheLoad) IA__FcDirCacheLoad __attribute((visibility(\""hidden\"")));\n #define FcDirCacheLoad IA__FcDirCacheLoad\n-extern __typeof (FcDirCacheRescan) IA__FcDirCacheRescan FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirCacheRescan) IA__FcDirCacheRescan __attribute((visibility(\""hidden\"")));\n #define FcDirCacheRescan IA__FcDirCacheRescan\n-extern __typeof (FcDirCacheRead) IA__FcDirCacheRead FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirCacheRead) IA__FcDirCacheRead __attribute((visibility(\""hidden\"")));\n #define FcDirCacheRead IA__FcDirCacheRead\n-extern __typeof (FcDirCacheLoadFile) IA__FcDirCacheLoadFile FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirCacheLoadFile) IA__FcDirCacheLoadFile __attribute((visibility(\""hidden\"")));\n #define FcDirCacheLoadFile IA__FcDirCacheLoadFile\n-extern __typeof (FcDirCacheUnload) IA__FcDirCacheUnload FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcDirCacheUnload) IA__FcDirCacheUnload __attribute((visibility(\""hidden\"")));\n #define FcDirCacheUnload IA__FcDirCacheUnload\n-extern __typeof (FcFreeTypeQuery) IA__FcFreeTypeQuery FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFreeTypeQuery) IA__FcFreeTypeQuery __attribute((visibility(\""hidden\"")));\n #define FcFreeTypeQuery IA__FcFreeTypeQuery\n-extern __typeof (FcFreeTypeQueryAll) IA__FcFreeTypeQueryAll FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcFreeTypeQueryAll IA__FcFreeTypeQueryAll\n-extern __typeof (FcFontSetCreate) IA__FcFontSetCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontSetCreate) IA__FcFontSetCreate __attribute((visibility(\""hidden\"")));\n #define FcFontSetCreate IA__FcFontSetCreate\n-extern __typeof (FcFontSetDestroy) IA__FcFontSetDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontSetDestroy) IA__FcFontSetDestroy __attribute((visibility(\""hidden\"")));\n #define FcFontSetDestroy IA__FcFontSetDestroy\n-extern __typeof (FcFontSetAdd) IA__FcFontSetAdd FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontSetAdd) IA__FcFontSetAdd __attribute((visibility(\""hidden\"")));\n #define FcFontSetAdd IA__FcFontSetAdd\n-extern __typeof (FcInitLoadConfig) IA__FcInitLoadConfig FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcInitLoadConfig) IA__FcInitLoadConfig __attribute((visibility(\""hidden\"")));\n #define FcInitLoadConfig IA__FcInitLoadConfig\n-extern __typeof (FcInitLoadConfigAndFonts) IA__FcInitLoadConfigAndFonts FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcInitLoadConfigAndFonts) IA__FcInitLoadConfigAndFonts __attribute((visibility(\""hidden\"")));\n #define FcInitLoadConfigAndFonts IA__FcInitLoadConfigAndFonts\n-extern __typeof (FcInit) IA__FcInit FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcInit) IA__FcInit __attribute((visibility(\""hidden\"")));\n #define FcInit IA__FcInit\n-extern __typeof (FcFini) IA__FcFini FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFini) IA__FcFini __attribute((visibility(\""hidden\"")));\n #define FcFini IA__FcFini\n-extern __typeof (FcGetVersion) IA__FcGetVersion FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcGetVersion) IA__FcGetVersion __attribute((visibility(\""hidden\"")));\n #define FcGetVersion IA__FcGetVersion\n-extern __typeof (FcInitReinitialize) IA__FcInitReinitialize FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcInitReinitialize) IA__FcInitReinitialize __attribute((visibility(\""hidden\"")));\n #define FcInitReinitialize IA__FcInitReinitialize\n-extern __typeof (FcInitBringUptoDate) IA__FcInitBringUptoDate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcInitBringUptoDate) IA__FcInitBringUptoDate __attribute((visibility(\""hidden\"")));\n #define FcInitBringUptoDate IA__FcInitBringUptoDate\n-extern __typeof (FcGetLangs) IA__FcGetLangs FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcGetLangs) IA__FcGetLangs __attribute((visibility(\""hidden\"")));\n #define FcGetLangs IA__FcGetLangs\n-extern __typeof (FcLangNormalize) IA__FcLangNormalize FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangNormalize) IA__FcLangNormalize __attribute((visibility(\""hidden\"")));\n #define FcLangNormalize IA__FcLangNormalize\n-extern __typeof (FcLangGetCharSet) IA__FcLangGetCharSet FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangGetCharSet) IA__FcLangGetCharSet __attribute((visibility(\""hidden\"")));\n #define FcLangGetCharSet IA__FcLangGetCharSet\n-extern __typeof (FcLangSetCreate) IA__FcLangSetCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetCreate) IA__FcLangSetCreate __attribute((visibility(\""hidden\"")));\n #define FcLangSetCreate IA__FcLangSetCreate\n-extern __typeof (FcLangSetDestroy) IA__FcLangSetDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetDestroy) IA__FcLangSetDestroy __attribute((visibility(\""hidden\"")));\n #define FcLangSetDestroy IA__FcLangSetDestroy\n-extern __typeof (FcLangSetCopy) IA__FcLangSetCopy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetCopy) IA__FcLangSetCopy __attribute((visibility(\""hidden\"")));\n #define FcLangSetCopy IA__FcLangSetCopy\n-extern __typeof (FcLangSetAdd) IA__FcLangSetAdd FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetAdd) IA__FcLangSetAdd __attribute((visibility(\""hidden\"")));\n #define FcLangSetAdd IA__FcLangSetAdd\n-extern __typeof (FcLangSetDel) IA__FcLangSetDel FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetDel) IA__FcLangSetDel __attribute((visibility(\""hidden\"")));\n #define FcLangSetDel IA__FcLangSetDel\n-extern __typeof (FcLangSetHasLang) IA__FcLangSetHasLang FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetHasLang) IA__FcLangSetHasLang __attribute((visibility(\""hidden\"")));\n #define FcLangSetHasLang IA__FcLangSetHasLang\n-extern __typeof (FcLangSetCompare) IA__FcLangSetCompare FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetCompare) IA__FcLangSetCompare __attribute((visibility(\""hidden\"")));\n #define FcLangSetCompare IA__FcLangSetCompare\n-extern __typeof (FcLangSetContains) IA__FcLangSetContains FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetContains) IA__FcLangSetContains __attribute((visibility(\""hidden\"")));\n #define FcLangSetContains IA__FcLangSetContains\n-extern __typeof (FcLangSetEqual) IA__FcLangSetEqual FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetEqual) IA__FcLangSetEqual __attribute((visibility(\""hidden\"")));\n #define FcLangSetEqual IA__FcLangSetEqual\n-extern __typeof (FcLangSetHash) IA__FcLangSetHash FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetHash) IA__FcLangSetHash __attribute((visibility(\""hidden\"")));\n #define FcLangSetHash IA__FcLangSetHash\n-extern __typeof (FcLangSetGetLangs) IA__FcLangSetGetLangs FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetGetLangs) IA__FcLangSetGetLangs __attribute((visibility(\""hidden\"")));\n #define FcLangSetGetLangs IA__FcLangSetGetLangs\n-extern __typeof (FcLangSetUnion) IA__FcLangSetUnion FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetUnion) IA__FcLangSetUnion __attribute((visibility(\""hidden\"")));\n #define FcLangSetUnion IA__FcLangSetUnion\n-extern __typeof (FcLangSetSubtract) IA__FcLangSetSubtract FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcLangSetSubtract) IA__FcLangSetSubtract __attribute((visibility(\""hidden\"")));\n #define FcLangSetSubtract IA__FcLangSetSubtract\n-extern __typeof (FcObjectSetCreate) IA__FcObjectSetCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcObjectSetCreate) IA__FcObjectSetCreate __attribute((visibility(\""hidden\"")));\n #define FcObjectSetCreate IA__FcObjectSetCreate\n-extern __typeof (FcObjectSetAdd) IA__FcObjectSetAdd FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcObjectSetAdd) IA__FcObjectSetAdd __attribute((visibility(\""hidden\"")));\n #define FcObjectSetAdd IA__FcObjectSetAdd\n-extern __typeof (FcObjectSetDestroy) IA__FcObjectSetDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcObjectSetDestroy) IA__FcObjectSetDestroy __attribute((visibility(\""hidden\"")));\n #define FcObjectSetDestroy IA__FcObjectSetDestroy\n-extern __typeof (FcObjectSetVaBuild) IA__FcObjectSetVaBuild FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcObjectSetVaBuild) IA__FcObjectSetVaBuild __attribute((visibility(\""hidden\"")));\n #define FcObjectSetVaBuild IA__FcObjectSetVaBuild\n-extern __typeof (FcObjectSetBuild) IA__FcObjectSetBuild FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcObjectSetBuild) IA__FcObjectSetBuild __attribute((visibility(\""hidden\"")));\n #define FcObjectSetBuild IA__FcObjectSetBuild\n-extern __typeof (FcFontSetList) IA__FcFontSetList FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontSetList) IA__FcFontSetList __attribute((visibility(\""hidden\"")));\n #define FcFontSetList IA__FcFontSetList\n-extern __typeof (FcFontList) IA__FcFontList FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontList) IA__FcFontList __attribute((visibility(\""hidden\"")));\n #define FcFontList IA__FcFontList\n-extern __typeof (FcAtomicCreate) IA__FcAtomicCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcAtomicCreate) IA__FcAtomicCreate __attribute((visibility(\""hidden\"")));\n #define FcAtomicCreate IA__FcAtomicCreate\n-extern __typeof (FcAtomicLock) IA__FcAtomicLock FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcAtomicLock) IA__FcAtomicLock __attribute((visibility(\""hidden\"")));\n #define FcAtomicLock IA__FcAtomicLock\n-extern __typeof (FcAtomicNewFile) IA__FcAtomicNewFile FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcAtomicNewFile) IA__FcAtomicNewFile __attribute((visibility(\""hidden\"")));\n #define FcAtomicNewFile IA__FcAtomicNewFile\n-extern __typeof (FcAtomicOrigFile) IA__FcAtomicOrigFile FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcAtomicOrigFile) IA__FcAtomicOrigFile __attribute((visibility(\""hidden\"")));\n #define FcAtomicOrigFile IA__FcAtomicOrigFile\n-extern __typeof (FcAtomicReplaceOrig) IA__FcAtomicReplaceOrig FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcAtomicReplaceOrig) IA__FcAtomicReplaceOrig __attribute((visibility(\""hidden\"")));\n #define FcAtomicReplaceOrig IA__FcAtomicReplaceOrig\n-extern __typeof (FcAtomicDeleteNew) IA__FcAtomicDeleteNew FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcAtomicDeleteNew) IA__FcAtomicDeleteNew __attribute((visibility(\""hidden\"")));\n #define FcAtomicDeleteNew IA__FcAtomicDeleteNew\n-extern __typeof (FcAtomicUnlock) IA__FcAtomicUnlock FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcAtomicUnlock) IA__FcAtomicUnlock __attribute((visibility(\""hidden\"")));\n #define FcAtomicUnlock IA__FcAtomicUnlock\n-extern __typeof (FcAtomicDestroy) IA__FcAtomicDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcAtomicDestroy) IA__FcAtomicDestroy __attribute((visibility(\""hidden\"")));\n #define FcAtomicDestroy IA__FcAtomicDestroy\n-extern __typeof (FcFontSetMatch) IA__FcFontSetMatch FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontSetMatch) IA__FcFontSetMatch __attribute((visibility(\""hidden\"")));\n #define FcFontSetMatch IA__FcFontSetMatch\n-extern __typeof (FcFontMatch) IA__FcFontMatch FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontMatch) IA__FcFontMatch __attribute((visibility(\""hidden\"")));\n #define FcFontMatch IA__FcFontMatch\n-extern __typeof (FcFontRenderPrepare) IA__FcFontRenderPrepare FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontRenderPrepare) IA__FcFontRenderPrepare __attribute((visibility(\""hidden\"")));\n #define FcFontRenderPrepare IA__FcFontRenderPrepare\n-extern __typeof (FcFontSetSort) IA__FcFontSetSort FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontSetSort) IA__FcFontSetSort __attribute((visibility(\""hidden\"")));\n #define FcFontSetSort IA__FcFontSetSort\n-extern __typeof (FcFontSort) IA__FcFontSort FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontSort) IA__FcFontSort __attribute((visibility(\""hidden\"")));\n #define FcFontSort IA__FcFontSort\n-extern __typeof (FcFontSetSortDestroy) IA__FcFontSetSortDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFontSetSortDestroy) IA__FcFontSetSortDestroy __attribute((visibility(\""hidden\"")));\n #define FcFontSetSortDestroy IA__FcFontSetSortDestroy\n-extern __typeof (FcMatrixCopy) IA__FcMatrixCopy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcMatrixCopy) IA__FcMatrixCopy __attribute((visibility(\""hidden\"")));\n #define FcMatrixCopy IA__FcMatrixCopy\n-extern __typeof (FcMatrixEqual) IA__FcMatrixEqual FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcMatrixEqual) IA__FcMatrixEqual __attribute((visibility(\""hidden\"")));\n #define FcMatrixEqual IA__FcMatrixEqual\n-extern __typeof (FcMatrixMultiply) IA__FcMatrixMultiply FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcMatrixMultiply) IA__FcMatrixMultiply __attribute((visibility(\""hidden\"")));\n #define FcMatrixMultiply IA__FcMatrixMultiply\n-extern __typeof (FcMatrixRotate) IA__FcMatrixRotate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcMatrixRotate) IA__FcMatrixRotate __attribute((visibility(\""hidden\"")));\n #define FcMatrixRotate IA__FcMatrixRotate\n-extern __typeof (FcMatrixScale) IA__FcMatrixScale FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcMatrixScale) IA__FcMatrixScale __attribute((visibility(\""hidden\"")));\n #define FcMatrixScale IA__FcMatrixScale\n-extern __typeof (FcMatrixShear) IA__FcMatrixShear FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcMatrixShear) IA__FcMatrixShear __attribute((visibility(\""hidden\"")));\n #define FcMatrixShear IA__FcMatrixShear\n-extern __typeof (FcNameRegisterObjectTypes) IA__FcNameRegisterObjectTypes FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcNameRegisterObjectTypes) IA__FcNameRegisterObjectTypes __attribute((visibility(\""hidden\"")));\n #define FcNameRegisterObjectTypes IA__FcNameRegisterObjectTypes\n-extern __typeof (FcNameUnregisterObjectTypes) IA__FcNameUnregisterObjectTypes FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcNameUnregisterObjectTypes) IA__FcNameUnregisterObjectTypes __attribute((visibility(\""hidden\"")));\n #define FcNameUnregisterObjectTypes IA__FcNameUnregisterObjectTypes\n-extern __typeof (FcNameGetObjectType) IA__FcNameGetObjectType FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcNameGetObjectType) IA__FcNameGetObjectType __attribute((visibility(\""hidden\"")));\n #define FcNameGetObjectType IA__FcNameGetObjectType\n-extern __typeof (FcNameRegisterConstants) IA__FcNameRegisterConstants FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcNameRegisterConstants) IA__FcNameRegisterConstants __attribute((visibility(\""hidden\"")));\n #define FcNameRegisterConstants IA__FcNameRegisterConstants\n-extern __typeof (FcNameUnregisterConstants) IA__FcNameUnregisterConstants FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcNameUnregisterConstants) IA__FcNameUnregisterConstants __attribute((visibility(\""hidden\"")));\n #define FcNameUnregisterConstants IA__FcNameUnregisterConstants\n-extern __typeof (FcNameGetConstant) IA__FcNameGetConstant FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcNameGetConstant) IA__FcNameGetConstant __attribute((visibility(\""hidden\"")));\n #define FcNameGetConstant IA__FcNameGetConstant\n-extern __typeof (FcNameConstant) IA__FcNameConstant FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcNameConstant) IA__FcNameConstant __attribute((visibility(\""hidden\"")));\n #define FcNameConstant IA__FcNameConstant\n-extern __typeof (FcNameParse) IA__FcNameParse FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcNameParse) IA__FcNameParse __attribute((visibility(\""hidden\"")));\n #define FcNameParse IA__FcNameParse\n-extern __typeof (FcNameUnparse) IA__FcNameUnparse FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcNameUnparse) IA__FcNameUnparse __attribute((visibility(\""hidden\"")));\n #define FcNameUnparse IA__FcNameUnparse\n-extern __typeof (FcPatternCreate) IA__FcPatternCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternCreate) IA__FcPatternCreate __attribute((visibility(\""hidden\"")));\n #define FcPatternCreate IA__FcPatternCreate\n-extern __typeof (FcPatternDuplicate) IA__FcPatternDuplicate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternDuplicate) IA__FcPatternDuplicate __attribute((visibility(\""hidden\"")));\n #define FcPatternDuplicate IA__FcPatternDuplicate\n-extern __typeof (FcPatternReference) IA__FcPatternReference FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternReference) IA__FcPatternReference __attribute((visibility(\""hidden\"")));\n #define FcPatternReference IA__FcPatternReference\n-extern __typeof (FcPatternFilter) IA__FcPatternFilter FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternFilter) IA__FcPatternFilter __attribute((visibility(\""hidden\"")));\n #define FcPatternFilter IA__FcPatternFilter\n-extern __typeof (FcValueDestroy) IA__FcValueDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcValueDestroy) IA__FcValueDestroy __attribute((visibility(\""hidden\"")));\n #define FcValueDestroy IA__FcValueDestroy\n-extern __typeof (FcValueEqual) IA__FcValueEqual FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcValueEqual) IA__FcValueEqual __attribute((visibility(\""hidden\"")));\n #define FcValueEqual IA__FcValueEqual\n-extern __typeof (FcValueSave) IA__FcValueSave FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcValueSave) IA__FcValueSave __attribute((visibility(\""hidden\"")));\n #define FcValueSave IA__FcValueSave\n-extern __typeof (FcPatternDestroy) IA__FcPatternDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternDestroy) IA__FcPatternDestroy __attribute((visibility(\""hidden\"")));\n #define FcPatternDestroy IA__FcPatternDestroy\n-extern __typeof (FcPatternObjectCount) IA__FcPatternObjectCount FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcPatternObjectCount IA__FcPatternObjectCount\n-extern __typeof (FcPatternEqual) IA__FcPatternEqual FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternEqual) IA__FcPatternEqual __attribute((visibility(\""hidden\"")));\n #define FcPatternEqual IA__FcPatternEqual\n-extern __typeof (FcPatternEqualSubset) IA__FcPatternEqualSubset FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternEqualSubset) IA__FcPatternEqualSubset __attribute((visibility(\""hidden\"")));\n #define FcPatternEqualSubset IA__FcPatternEqualSubset\n-extern __typeof (FcPatternHash) IA__FcPatternHash FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternHash) IA__FcPatternHash __attribute((visibility(\""hidden\"")));\n #define FcPatternHash IA__FcPatternHash\n-extern __typeof (FcPatternAdd) IA__FcPatternAdd FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAdd) IA__FcPatternAdd __attribute((visibility(\""hidden\"")));\n #define FcPatternAdd IA__FcPatternAdd\n-extern __typeof (FcPatternAddWeak) IA__FcPatternAddWeak FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddWeak) IA__FcPatternAddWeak __attribute((visibility(\""hidden\"")));\n #define FcPatternAddWeak IA__FcPatternAddWeak\n-extern __typeof (FcPatternGet) IA__FcPatternGet FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGet) IA__FcPatternGet __attribute((visibility(\""hidden\"")));\n #define FcPatternGet IA__FcPatternGet\n-extern __typeof (FcPatternGetWithBinding) IA__FcPatternGetWithBinding FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetWithBinding) IA__FcPatternGetWithBinding __attribute((visibility(\""hidden\"")));\n #define FcPatternGetWithBinding IA__FcPatternGetWithBinding\n-extern __typeof (FcPatternDel) IA__FcPatternDel FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternDel) IA__FcPatternDel __attribute((visibility(\""hidden\"")));\n #define FcPatternDel IA__FcPatternDel\n-extern __typeof (FcPatternRemove) IA__FcPatternRemove FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternRemove) IA__FcPatternRemove __attribute((visibility(\""hidden\"")));\n #define FcPatternRemove IA__FcPatternRemove\n-extern __typeof (FcPatternAddInteger) IA__FcPatternAddInteger FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddInteger) IA__FcPatternAddInteger __attribute((visibility(\""hidden\"")));\n #define FcPatternAddInteger IA__FcPatternAddInteger\n-extern __typeof (FcPatternAddDouble) IA__FcPatternAddDouble FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddDouble) IA__FcPatternAddDouble __attribute((visibility(\""hidden\"")));\n #define FcPatternAddDouble IA__FcPatternAddDouble\n-extern __typeof (FcPatternAddString) IA__FcPatternAddString FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddString) IA__FcPatternAddString __attribute((visibility(\""hidden\"")));\n #define FcPatternAddString IA__FcPatternAddString\n-extern __typeof (FcPatternAddMatrix) IA__FcPatternAddMatrix FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddMatrix) IA__FcPatternAddMatrix __attribute((visibility(\""hidden\"")));\n #define FcPatternAddMatrix IA__FcPatternAddMatrix\n-extern __typeof (FcPatternAddCharSet) IA__FcPatternAddCharSet FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddCharSet) IA__FcPatternAddCharSet __attribute((visibility(\""hidden\"")));\n #define FcPatternAddCharSet IA__FcPatternAddCharSet\n-extern __typeof (FcPatternAddBool) IA__FcPatternAddBool FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddBool) IA__FcPatternAddBool __attribute((visibility(\""hidden\"")));\n #define FcPatternAddBool IA__FcPatternAddBool\n-extern __typeof (FcPatternAddLangSet) IA__FcPatternAddLangSet FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddLangSet) IA__FcPatternAddLangSet __attribute((visibility(\""hidden\"")));\n #define FcPatternAddLangSet IA__FcPatternAddLangSet\n-extern __typeof (FcPatternAddRange) IA__FcPatternAddRange FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddRange) IA__FcPatternAddRange __attribute((visibility(\""hidden\"")));\n #define FcPatternAddRange IA__FcPatternAddRange\n-extern __typeof (FcPatternGetInteger) IA__FcPatternGetInteger FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetInteger) IA__FcPatternGetInteger __attribute((visibility(\""hidden\"")));\n #define FcPatternGetInteger IA__FcPatternGetInteger\n-extern __typeof (FcPatternGetDouble) IA__FcPatternGetDouble FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetDouble) IA__FcPatternGetDouble __attribute((visibility(\""hidden\"")));\n #define FcPatternGetDouble IA__FcPatternGetDouble\n-extern __typeof (FcPatternGetString) IA__FcPatternGetString FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetString) IA__FcPatternGetString __attribute((visibility(\""hidden\"")));\n #define FcPatternGetString IA__FcPatternGetString\n-extern __typeof (FcPatternGetMatrix) IA__FcPatternGetMatrix FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetMatrix) IA__FcPatternGetMatrix __attribute((visibility(\""hidden\"")));\n #define FcPatternGetMatrix IA__FcPatternGetMatrix\n-extern __typeof (FcPatternGetCharSet) IA__FcPatternGetCharSet FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetCharSet) IA__FcPatternGetCharSet __attribute((visibility(\""hidden\"")));\n #define FcPatternGetCharSet IA__FcPatternGetCharSet\n-extern __typeof (FcPatternGetBool) IA__FcPatternGetBool FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetBool) IA__FcPatternGetBool __attribute((visibility(\""hidden\"")));\n #define FcPatternGetBool IA__FcPatternGetBool\n-extern __typeof (FcPatternGetLangSet) IA__FcPatternGetLangSet FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetLangSet) IA__FcPatternGetLangSet __attribute((visibility(\""hidden\"")));\n #define FcPatternGetLangSet IA__FcPatternGetLangSet\n-extern __typeof (FcPatternGetRange) IA__FcPatternGetRange FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetRange) IA__FcPatternGetRange __attribute((visibility(\""hidden\"")));\n #define FcPatternGetRange IA__FcPatternGetRange\n-extern __typeof (FcPatternVaBuild) IA__FcPatternVaBuild FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternVaBuild) IA__FcPatternVaBuild __attribute((visibility(\""hidden\"")));\n #define FcPatternVaBuild IA__FcPatternVaBuild\n-extern __typeof (FcPatternBuild) IA__FcPatternBuild FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternBuild) IA__FcPatternBuild __attribute((visibility(\""hidden\"")));\n #define FcPatternBuild IA__FcPatternBuild\n-extern __typeof (FcPatternFormat) IA__FcPatternFormat FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternFormat) IA__FcPatternFormat __attribute((visibility(\""hidden\"")));\n #define FcPatternFormat IA__FcPatternFormat\n-extern __typeof (FcRangeCreateDouble) IA__FcRangeCreateDouble FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcRangeCreateDouble) IA__FcRangeCreateDouble __attribute((visibility(\""hidden\"")));\n #define FcRangeCreateDouble IA__FcRangeCreateDouble\n-extern __typeof (FcRangeCreateInteger) IA__FcRangeCreateInteger FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcRangeCreateInteger) IA__FcRangeCreateInteger __attribute((visibility(\""hidden\"")));\n #define FcRangeCreateInteger IA__FcRangeCreateInteger\n-extern __typeof (FcRangeDestroy) IA__FcRangeDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcRangeDestroy) IA__FcRangeDestroy __attribute((visibility(\""hidden\"")));\n #define FcRangeDestroy IA__FcRangeDestroy\n-extern __typeof (FcRangeCopy) IA__FcRangeCopy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcRangeCopy) IA__FcRangeCopy __attribute((visibility(\""hidden\"")));\n #define FcRangeCopy IA__FcRangeCopy\n-extern __typeof (FcRangeGetDouble) IA__FcRangeGetDouble FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcRangeGetDouble) IA__FcRangeGetDouble __attribute((visibility(\""hidden\"")));\n #define FcRangeGetDouble IA__FcRangeGetDouble\n-extern __typeof (FcPatternIterStart) IA__FcPatternIterStart FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcPatternIterStart IA__FcPatternIterStart\n-extern __typeof (FcPatternIterNext) IA__FcPatternIterNext FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcPatternIterNext IA__FcPatternIterNext\n-extern __typeof (FcPatternIterEqual) IA__FcPatternIterEqual FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcPatternIterEqual IA__FcPatternIterEqual\n-extern __typeof (FcPatternFindIter) IA__FcPatternFindIter FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcPatternFindIter IA__FcPatternFindIter\n-extern __typeof (FcPatternIterIsValid) IA__FcPatternIterIsValid FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcPatternIterIsValid IA__FcPatternIterIsValid\n-extern __typeof (FcPatternIterGetObject) IA__FcPatternIterGetObject FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcPatternIterGetObject IA__FcPatternIterGetObject\n-extern __typeof (FcPatternIterValueCount) IA__FcPatternIterValueCount FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcPatternIterValueCount IA__FcPatternIterValueCount\n-extern __typeof (FcPatternIterGetValue) IA__FcPatternIterGetValue FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcPatternIterGetValue IA__FcPatternIterGetValue\n-extern __typeof (FcWeightFromOpenType) IA__FcWeightFromOpenType FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcWeightFromOpenType) IA__FcWeightFromOpenType __attribute((visibility(\""hidden\"")));\n #define FcWeightFromOpenType IA__FcWeightFromOpenType\n-extern __typeof (FcWeightFromOpenTypeDouble) IA__FcWeightFromOpenTypeDouble FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcWeightFromOpenTypeDouble IA__FcWeightFromOpenTypeDouble\n-extern __typeof (FcWeightToOpenType) IA__FcWeightToOpenType FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcWeightToOpenType) IA__FcWeightToOpenType __attribute((visibility(\""hidden\"")));\n #define FcWeightToOpenType IA__FcWeightToOpenType\n-extern __typeof (FcWeightToOpenTypeDouble) IA__FcWeightToOpenTypeDouble FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n-#define FcWeightToOpenTypeDouble IA__FcWeightToOpenTypeDouble\n-extern __typeof (FcStrCopy) IA__FcStrCopy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrCopy) IA__FcStrCopy __attribute((visibility(\""hidden\"")));\n #define FcStrCopy IA__FcStrCopy\n-extern __typeof (FcStrCopyFilename) IA__FcStrCopyFilename FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrCopyFilename) IA__FcStrCopyFilename __attribute((visibility(\""hidden\"")));\n #define FcStrCopyFilename IA__FcStrCopyFilename\n-extern __typeof (FcStrPlus) IA__FcStrPlus FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrPlus) IA__FcStrPlus __attribute((visibility(\""hidden\"")));\n #define FcStrPlus IA__FcStrPlus\n-extern __typeof (FcStrFree) IA__FcStrFree FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrFree) IA__FcStrFree __attribute((visibility(\""hidden\"")));\n #define FcStrFree IA__FcStrFree\n-extern __typeof (FcStrDowncase) IA__FcStrDowncase FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrDowncase) IA__FcStrDowncase __attribute((visibility(\""hidden\"")));\n #define FcStrDowncase IA__FcStrDowncase\n-extern __typeof (FcStrCmpIgnoreCase) IA__FcStrCmpIgnoreCase FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrCmpIgnoreCase) IA__FcStrCmpIgnoreCase __attribute((visibility(\""hidden\"")));\n #define FcStrCmpIgnoreCase IA__FcStrCmpIgnoreCase\n-extern __typeof (FcStrCmp) IA__FcStrCmp FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrCmp) IA__FcStrCmp __attribute((visibility(\""hidden\"")));\n #define FcStrCmp IA__FcStrCmp\n-extern __typeof (FcStrStrIgnoreCase) IA__FcStrStrIgnoreCase FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrStrIgnoreCase) IA__FcStrStrIgnoreCase __attribute((visibility(\""hidden\"")));\n #define FcStrStrIgnoreCase IA__FcStrStrIgnoreCase\n-extern __typeof (FcStrStr) IA__FcStrStr FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrStr) IA__FcStrStr __attribute((visibility(\""hidden\"")));\n #define FcStrStr IA__FcStrStr\n-extern __typeof (FcUtf8ToUcs4) IA__FcUtf8ToUcs4 FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcUtf8ToUcs4) IA__FcUtf8ToUcs4 __attribute((visibility(\""hidden\"")));\n #define FcUtf8ToUcs4 IA__FcUtf8ToUcs4\n-extern __typeof (FcUtf8Len) IA__FcUtf8Len FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcUtf8Len) IA__FcUtf8Len __attribute((visibility(\""hidden\"")));\n #define FcUtf8Len IA__FcUtf8Len\n-extern __typeof (FcUcs4ToUtf8) IA__FcUcs4ToUtf8 FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcUcs4ToUtf8) IA__FcUcs4ToUtf8 __attribute((visibility(\""hidden\"")));\n #define FcUcs4ToUtf8 IA__FcUcs4ToUtf8\n-extern __typeof (FcUtf16ToUcs4) IA__FcUtf16ToUcs4 FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcUtf16ToUcs4) IA__FcUtf16ToUcs4 __attribute((visibility(\""hidden\"")));\n #define FcUtf16ToUcs4 IA__FcUtf16ToUcs4\n-extern __typeof (FcUtf16Len) IA__FcUtf16Len FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcUtf16Len) IA__FcUtf16Len __attribute((visibility(\""hidden\"")));\n #define FcUtf16Len IA__FcUtf16Len\n-extern __typeof (FcStrDirname) IA__FcStrDirname FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrDirname) IA__FcStrDirname __attribute((visibility(\""hidden\"")));\n #define FcStrDirname IA__FcStrDirname\n-extern __typeof (FcStrBasename) IA__FcStrBasename FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrBasename) IA__FcStrBasename __attribute((visibility(\""hidden\"")));\n #define FcStrBasename IA__FcStrBasename\n-extern __typeof (FcStrSetCreate) IA__FcStrSetCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrSetCreate) IA__FcStrSetCreate __attribute((visibility(\""hidden\"")));\n #define FcStrSetCreate IA__FcStrSetCreate\n-extern __typeof (FcStrSetMember) IA__FcStrSetMember FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrSetMember) IA__FcStrSetMember __attribute((visibility(\""hidden\"")));\n #define FcStrSetMember IA__FcStrSetMember\n-extern __typeof (FcStrSetEqual) IA__FcStrSetEqual FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrSetEqual) IA__FcStrSetEqual __attribute((visibility(\""hidden\"")));\n #define FcStrSetEqual IA__FcStrSetEqual\n-extern __typeof (FcStrSetAdd) IA__FcStrSetAdd FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrSetAdd) IA__FcStrSetAdd __attribute((visibility(\""hidden\"")));\n #define FcStrSetAdd IA__FcStrSetAdd\n-extern __typeof (FcStrSetAddFilename) IA__FcStrSetAddFilename FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrSetAddFilename) IA__FcStrSetAddFilename __attribute((visibility(\""hidden\"")));\n #define FcStrSetAddFilename IA__FcStrSetAddFilename\n-extern __typeof (FcStrSetDel) IA__FcStrSetDel FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrSetDel) IA__FcStrSetDel __attribute((visibility(\""hidden\"")));\n #define FcStrSetDel IA__FcStrSetDel\n-extern __typeof (FcStrSetDestroy) IA__FcStrSetDestroy FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrSetDestroy) IA__FcStrSetDestroy __attribute((visibility(\""hidden\"")));\n #define FcStrSetDestroy IA__FcStrSetDestroy\n-extern __typeof (FcStrListCreate) IA__FcStrListCreate FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrListCreate) IA__FcStrListCreate __attribute((visibility(\""hidden\"")));\n #define FcStrListCreate IA__FcStrListCreate\n-extern __typeof (FcStrListFirst) IA__FcStrListFirst FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrListFirst) IA__FcStrListFirst __attribute((visibility(\""hidden\"")));\n #define FcStrListFirst IA__FcStrListFirst\n-extern __typeof (FcStrListNext) IA__FcStrListNext FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrListNext) IA__FcStrListNext __attribute((visibility(\""hidden\"")));\n #define FcStrListNext IA__FcStrListNext\n-extern __typeof (FcStrListDone) IA__FcStrListDone FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcStrListDone) IA__FcStrListDone __attribute((visibility(\""hidden\"")));\n #define FcStrListDone IA__FcStrListDone\n-extern __typeof (FcConfigParseAndLoad) IA__FcConfigParseAndLoad FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigParseAndLoad) IA__FcConfigParseAndLoad __attribute((visibility(\""hidden\"")));\n #define FcConfigParseAndLoad IA__FcConfigParseAndLoad\n-extern __typeof (FcConfigParseAndLoadFromMemory) IA__FcConfigParseAndLoadFromMemory FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigParseAndLoadFromMemory) IA__FcConfigParseAndLoadFromMemory __attribute((visibility(\""hidden\"")));\n #define FcConfigParseAndLoadFromMemory IA__FcConfigParseAndLoadFromMemory\n-extern __typeof (FcConfigGetRescanInverval) IA__FcConfigGetRescanInverval FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigGetRescanInverval) IA__FcConfigGetRescanInverval __attribute((visibility(\""hidden\"")));\n #define FcConfigGetRescanInverval IA__FcConfigGetRescanInverval\n-extern __typeof (FcConfigSetRescanInverval) IA__FcConfigSetRescanInverval FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcConfigSetRescanInverval) IA__FcConfigSetRescanInverval __attribute((visibility(\""hidden\"")));\n #define FcConfigSetRescanInverval IA__FcConfigSetRescanInverval""}<_**next**_>{""sha"": ""a46c8d0116475878b5638061b8bde001611a1e62"", ""filename"": ""third_party/fontconfig/include/src/fcaliastail.h"", ""status"": ""modified"", ""additions"": 209, ""deletions"": 245, ""changes"": 454, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcaliastail.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcaliastail.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/include/src/fcaliastail.h?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -1,504 +1,468 @@\n #if HAVE_GNUC_ATTRIBUTE\n-#ifdef __fccfg__\n+#ifdef __fcblanks__\n # undef FcBlanksCreate\n-extern __typeof (FcBlanksCreate) FcBlanksCreate __attribute((alias(\""IA__FcBlanksCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcBlanksCreate) FcBlanksCreate __attribute((alias(\""IA__FcBlanksCreate\""), visibility(\""default\"")));\n # undef FcBlanksDestroy\n-extern __typeof (FcBlanksDestroy) FcBlanksDestroy __attribute((alias(\""IA__FcBlanksDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcBlanksDestroy) FcBlanksDestroy __attribute((alias(\""IA__FcBlanksDestroy\""), visibility(\""default\"")));\n # undef FcBlanksAdd\n-extern __typeof (FcBlanksAdd) FcBlanksAdd __attribute((alias(\""IA__FcBlanksAdd\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcBlanksAdd) FcBlanksAdd __attribute((alias(\""IA__FcBlanksAdd\""), visibility(\""default\"")));\n # undef FcBlanksIsMember\n-extern __typeof (FcBlanksIsMember) FcBlanksIsMember __attribute((alias(\""IA__FcBlanksIsMember\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-#endif /* __fccfg__ */\n+extern __typeof (FcBlanksIsMember) FcBlanksIsMember __attribute((alias(\""IA__FcBlanksIsMember\""), visibility(\""default\"")));\n+#endif /* __fcblanks__ */\n #ifdef __fccache__\n # undef FcCacheCopySet\n-extern __typeof (FcCacheCopySet) FcCacheCopySet __attribute((alias(\""IA__FcCacheCopySet\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCacheCopySet) FcCacheCopySet __attribute((alias(\""IA__FcCacheCopySet\""), visibility(\""default\"")));\n # undef FcCacheNumSubdir\n-extern __typeof (FcCacheNumSubdir) FcCacheNumSubdir __attribute((alias(\""IA__FcCacheNumSubdir\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCacheNumSubdir) FcCacheNumSubdir __attribute((alias(\""IA__FcCacheNumSubdir\""), visibility(\""default\"")));\n # undef FcCacheNumFont\n-extern __typeof (FcCacheNumFont) FcCacheNumFont __attribute((alias(\""IA__FcCacheNumFont\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCacheNumFont) FcCacheNumFont __attribute((alias(\""IA__FcCacheNumFont\""), visibility(\""default\"")));\n # undef FcDirCacheUnlink\n-extern __typeof (FcDirCacheUnlink) FcDirCacheUnlink __attribute((alias(\""IA__FcDirCacheUnlink\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirCacheUnlink) FcDirCacheUnlink __attribute((alias(\""IA__FcDirCacheUnlink\""), visibility(\""default\"")));\n # undef FcDirCacheValid\n-extern __typeof (FcDirCacheValid) FcDirCacheValid __attribute((alias(\""IA__FcDirCacheValid\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirCacheValid) FcDirCacheValid __attribute((alias(\""IA__FcDirCacheValid\""), visibility(\""default\"")));\n # undef FcDirCacheClean\n-extern __typeof (FcDirCacheClean) FcDirCacheClean __attribute((alias(\""IA__FcDirCacheClean\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirCacheClean) FcDirCacheClean __attribute((alias(\""IA__FcDirCacheClean\""), visibility(\""default\"")));\n # undef FcCacheCreateTagFile\n-extern __typeof (FcCacheCreateTagFile) FcCacheCreateTagFile __attribute((alias(\""IA__FcCacheCreateTagFile\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcDirCacheCreateUUID\n-extern __typeof (FcDirCacheCreateUUID) FcDirCacheCreateUUID __attribute((alias(\""IA__FcDirCacheCreateUUID\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcDirCacheDeleteUUID\n-extern __typeof (FcDirCacheDeleteUUID) FcDirCacheDeleteUUID __attribute((alias(\""IA__FcDirCacheDeleteUUID\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCacheCreateTagFile) FcCacheCreateTagFile __attribute((alias(\""IA__FcCacheCreateTagFile\""), visibility(\""default\"")));\n #endif /* __fccache__ */\n #ifdef __fccfg__\n # undef FcConfigHome\n-extern __typeof (FcConfigHome) FcConfigHome __attribute((alias(\""IA__FcConfigHome\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigHome) FcConfigHome __attribute((alias(\""IA__FcConfigHome\""), visibility(\""default\"")));\n # undef FcConfigEnableHome\n-extern __typeof (FcConfigEnableHome) FcConfigEnableHome __attribute((alias(\""IA__FcConfigEnableHome\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigEnableHome) FcConfigEnableHome __attribute((alias(\""IA__FcConfigEnableHome\""), visibility(\""default\"")));\n # undef FcConfigFilename\n-extern __typeof (FcConfigFilename) FcConfigFilename __attribute((alias(\""IA__FcConfigFilename\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigFilename) FcConfigFilename __attribute((alias(\""IA__FcConfigFilename\""), visibility(\""default\"")));\n # undef FcConfigCreate\n-extern __typeof (FcConfigCreate) FcConfigCreate __attribute((alias(\""IA__FcConfigCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigCreate) FcConfigCreate __attribute((alias(\""IA__FcConfigCreate\""), visibility(\""default\"")));\n # undef FcConfigReference\n-extern __typeof (FcConfigReference) FcConfigReference __attribute((alias(\""IA__FcConfigReference\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigReference) FcConfigReference __attribute((alias(\""IA__FcConfigReference\""), visibility(\""default\"")));\n # undef FcConfigDestroy\n-extern __typeof (FcConfigDestroy) FcConfigDestroy __attribute((alias(\""IA__FcConfigDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigDestroy) FcConfigDestroy __attribute((alias(\""IA__FcConfigDestroy\""), visibility(\""default\"")));\n # undef FcConfigSetCurrent\n-extern __typeof (FcConfigSetCurrent) FcConfigSetCurrent __attribute((alias(\""IA__FcConfigSetCurrent\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigSetCurrent) FcConfigSetCurrent __attribute((alias(\""IA__FcConfigSetCurrent\""), visibility(\""default\"")));\n # undef FcConfigGetCurrent\n-extern __typeof (FcConfigGetCurrent) FcConfigGetCurrent __attribute((alias(\""IA__FcConfigGetCurrent\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetCurrent) FcConfigGetCurrent __attribute((alias(\""IA__FcConfigGetCurrent\""), visibility(\""default\"")));\n # undef FcConfigUptoDate\n-extern __typeof (FcConfigUptoDate) FcConfigUptoDate __attribute((alias(\""IA__FcConfigUptoDate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigUptoDate) FcConfigUptoDate __attribute((alias(\""IA__FcConfigUptoDate\""), visibility(\""default\"")));\n # undef FcConfigBuildFonts\n-extern __typeof (FcConfigBuildFonts) FcConfigBuildFonts __attribute((alias(\""IA__FcConfigBuildFonts\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigBuildFonts) FcConfigBuildFonts __attribute((alias(\""IA__FcConfigBuildFonts\""), visibility(\""default\"")));\n # undef FcConfigGetFontDirs\n-extern __typeof (FcConfigGetFontDirs) FcConfigGetFontDirs __attribute((alias(\""IA__FcConfigGetFontDirs\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetFontDirs) FcConfigGetFontDirs __attribute((alias(\""IA__FcConfigGetFontDirs\""), visibility(\""default\"")));\n # undef FcConfigGetConfigDirs\n-extern __typeof (FcConfigGetConfigDirs) FcConfigGetConfigDirs __attribute((alias(\""IA__FcConfigGetConfigDirs\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetConfigDirs) FcConfigGetConfigDirs __attribute((alias(\""IA__FcConfigGetConfigDirs\""), visibility(\""default\"")));\n # undef FcConfigGetConfigFiles\n-extern __typeof (FcConfigGetConfigFiles) FcConfigGetConfigFiles __attribute((alias(\""IA__FcConfigGetConfigFiles\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetConfigFiles) FcConfigGetConfigFiles __attribute((alias(\""IA__FcConfigGetConfigFiles\""), visibility(\""default\"")));\n # undef FcConfigGetCache\n-extern __typeof (FcConfigGetCache) FcConfigGetCache __attribute((alias(\""IA__FcConfigGetCache\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetCache) FcConfigGetCache __attribute((alias(\""IA__FcConfigGetCache\""), visibility(\""default\"")));\n # undef FcConfigGetBlanks\n-extern __typeof (FcConfigGetBlanks) FcConfigGetBlanks __attribute((alias(\""IA__FcConfigGetBlanks\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetBlanks) FcConfigGetBlanks __attribute((alias(\""IA__FcConfigGetBlanks\""), visibility(\""default\"")));\n # undef FcConfigGetCacheDirs\n-extern __typeof (FcConfigGetCacheDirs) FcConfigGetCacheDirs __attribute((alias(\""IA__FcConfigGetCacheDirs\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetCacheDirs) FcConfigGetCacheDirs __attribute((alias(\""IA__FcConfigGetCacheDirs\""), visibility(\""default\"")));\n # undef FcConfigGetRescanInterval\n-extern __typeof (FcConfigGetRescanInterval) FcConfigGetRescanInterval __attribute((alias(\""IA__FcConfigGetRescanInterval\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetRescanInterval) FcConfigGetRescanInterval __attribute((alias(\""IA__FcConfigGetRescanInterval\""), visibility(\""default\"")));\n # undef FcConfigSetRescanInterval\n-extern __typeof (FcConfigSetRescanInterval) FcConfigSetRescanInterval __attribute((alias(\""IA__FcConfigSetRescanInterval\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigSetRescanInterval) FcConfigSetRescanInterval __attribute((alias(\""IA__FcConfigSetRescanInterval\""), visibility(\""default\"")));\n # undef FcConfigGetFonts\n-extern __typeof (FcConfigGetFonts) FcConfigGetFonts __attribute((alias(\""IA__FcConfigGetFonts\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetFonts) FcConfigGetFonts __attribute((alias(\""IA__FcConfigGetFonts\""), visibility(\""default\"")));\n # undef FcConfigAppFontAddFile\n-extern __typeof (FcConfigAppFontAddFile) FcConfigAppFontAddFile __attribute((alias(\""IA__FcConfigAppFontAddFile\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigAppFontAddFile) FcConfigAppFontAddFile __attribute((alias(\""IA__FcConfigAppFontAddFile\""), visibility(\""default\"")));\n # undef FcConfigAppFontAddDir\n-extern __typeof (FcConfigAppFontAddDir) FcConfigAppFontAddDir __attribute((alias(\""IA__FcConfigAppFontAddDir\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigAppFontAddDir) FcConfigAppFontAddDir __attribute((alias(\""IA__FcConfigAppFontAddDir\""), visibility(\""default\"")));\n # undef FcConfigAppFontClear\n-extern __typeof (FcConfigAppFontClear) FcConfigAppFontClear __attribute((alias(\""IA__FcConfigAppFontClear\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigAppFontClear) FcConfigAppFontClear __attribute((alias(\""IA__FcConfigAppFontClear\""), visibility(\""default\"")));\n # undef FcConfigSubstituteWithPat\n-extern __typeof (FcConfigSubstituteWithPat) FcConfigSubstituteWithPat __attribute((alias(\""IA__FcConfigSubstituteWithPat\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigSubstituteWithPat) FcConfigSubstituteWithPat __attribute((alias(\""IA__FcConfigSubstituteWithPat\""), visibility(\""default\"")));\n # undef FcConfigSubstitute\n-extern __typeof (FcConfigSubstitute) FcConfigSubstitute __attribute((alias(\""IA__FcConfigSubstitute\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigSubstitute) FcConfigSubstitute __attribute((alias(\""IA__FcConfigSubstitute\""), visibility(\""default\"")));\n # undef FcConfigGetSysRoot\n-extern __typeof (FcConfigGetSysRoot) FcConfigGetSysRoot __attribute((alias(\""IA__FcConfigGetSysRoot\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetSysRoot) FcConfigGetSysRoot __attribute((alias(\""IA__FcConfigGetSysRoot\""), visibility(\""default\"")));\n # undef FcConfigSetSysRoot\n-extern __typeof (FcConfigSetSysRoot) FcConfigSetSysRoot __attribute((alias(\""IA__FcConfigSetSysRoot\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcConfigFileInfoIterInit\n-extern __typeof (FcConfigFileInfoIterInit) FcConfigFileInfoIterInit __attribute((alias(\""IA__FcConfigFileInfoIterInit\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcConfigFileInfoIterNext\n-extern __typeof (FcConfigFileInfoIterNext) FcConfigFileInfoIterNext __attribute((alias(\""IA__FcConfigFileInfoIterNext\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcConfigFileInfoIterGet\n-extern __typeof (FcConfigFileInfoIterGet) FcConfigFileInfoIterGet __attribute((alias(\""IA__FcConfigFileInfoIterGet\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigSetSysRoot) FcConfigSetSysRoot __attribute((alias(\""IA__FcConfigSetSysRoot\""), visibility(\""default\"")));\n #endif /* __fccfg__ */\n #ifdef __fccharset__\n # undef FcCharSetCreate\n-extern __typeof (FcCharSetCreate) FcCharSetCreate __attribute((alias(\""IA__FcCharSetCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetCreate) FcCharSetCreate __attribute((alias(\""IA__FcCharSetCreate\""), visibility(\""default\"")));\n # undef FcCharSetNew\n-extern __typeof (FcCharSetNew) FcCharSetNew __attribute((alias(\""IA__FcCharSetNew\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetNew) FcCharSetNew __attribute((alias(\""IA__FcCharSetNew\""), visibility(\""default\"")));\n # undef FcCharSetDestroy\n-extern __typeof (FcCharSetDestroy) FcCharSetDestroy __attribute((alias(\""IA__FcCharSetDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetDestroy) FcCharSetDestroy __attribute((alias(\""IA__FcCharSetDestroy\""), visibility(\""default\"")));\n # undef FcCharSetAddChar\n-extern __typeof (FcCharSetAddChar) FcCharSetAddChar __attribute((alias(\""IA__FcCharSetAddChar\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetAddChar) FcCharSetAddChar __attribute((alias(\""IA__FcCharSetAddChar\""), visibility(\""default\"")));\n # undef FcCharSetDelChar\n-extern __typeof (FcCharSetDelChar) FcCharSetDelChar __attribute((alias(\""IA__FcCharSetDelChar\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetDelChar) FcCharSetDelChar __attribute((alias(\""IA__FcCharSetDelChar\""), visibility(\""default\"")));\n # undef FcCharSetCopy\n-extern __typeof (FcCharSetCopy) FcCharSetCopy __attribute((alias(\""IA__FcCharSetCopy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetCopy) FcCharSetCopy __attribute((alias(\""IA__FcCharSetCopy\""), visibility(\""default\"")));\n # undef FcCharSetEqual\n-extern __typeof (FcCharSetEqual) FcCharSetEqual __attribute((alias(\""IA__FcCharSetEqual\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetEqual) FcCharSetEqual __attribute((alias(\""IA__FcCharSetEqual\""), visibility(\""default\"")));\n # undef FcCharSetIntersect\n-extern __typeof (FcCharSetIntersect) FcCharSetIntersect __attribute((alias(\""IA__FcCharSetIntersect\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetIntersect) FcCharSetIntersect __attribute((alias(\""IA__FcCharSetIntersect\""), visibility(\""default\"")));\n # undef FcCharSetUnion\n-extern __typeof (FcCharSetUnion) FcCharSetUnion __attribute((alias(\""IA__FcCharSetUnion\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetUnion) FcCharSetUnion __attribute((alias(\""IA__FcCharSetUnion\""), visibility(\""default\"")));\n # undef FcCharSetSubtract\n-extern __typeof (FcCharSetSubtract) FcCharSetSubtract __attribute((alias(\""IA__FcCharSetSubtract\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetSubtract) FcCharSetSubtract __attribute((alias(\""IA__FcCharSetSubtract\""), visibility(\""default\"")));\n # undef FcCharSetMerge\n-extern __typeof (FcCharSetMerge) FcCharSetMerge __attribute((alias(\""IA__FcCharSetMerge\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetMerge) FcCharSetMerge __attribute((alias(\""IA__FcCharSetMerge\""), visibility(\""default\"")));\n # undef FcCharSetHasChar\n-extern __typeof (FcCharSetHasChar) FcCharSetHasChar __attribute((alias(\""IA__FcCharSetHasChar\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetHasChar) FcCharSetHasChar __attribute((alias(\""IA__FcCharSetHasChar\""), visibility(\""default\"")));\n # undef FcCharSetCount\n-extern __typeof (FcCharSetCount) FcCharSetCount __attribute((alias(\""IA__FcCharSetCount\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetCount) FcCharSetCount __attribute((alias(\""IA__FcCharSetCount\""), visibility(\""default\"")));\n # undef FcCharSetIntersectCount\n-extern __typeof (FcCharSetIntersectCount) FcCharSetIntersectCount __attribute((alias(\""IA__FcCharSetIntersectCount\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetIntersectCount) FcCharSetIntersectCount __attribute((alias(\""IA__FcCharSetIntersectCount\""), visibility(\""default\"")));\n # undef FcCharSetSubtractCount\n-extern __typeof (FcCharSetSubtractCount) FcCharSetSubtractCount __attribute((alias(\""IA__FcCharSetSubtractCount\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetSubtractCount) FcCharSetSubtractCount __attribute((alias(\""IA__FcCharSetSubtractCount\""), visibility(\""default\"")));\n # undef FcCharSetIsSubset\n-extern __typeof (FcCharSetIsSubset) FcCharSetIsSubset __attribute((alias(\""IA__FcCharSetIsSubset\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetIsSubset) FcCharSetIsSubset __attribute((alias(\""IA__FcCharSetIsSubset\""), visibility(\""default\"")));\n # undef FcCharSetFirstPage\n-extern __typeof (FcCharSetFirstPage) FcCharSetFirstPage __attribute((alias(\""IA__FcCharSetFirstPage\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetFirstPage) FcCharSetFirstPage __attribute((alias(\""IA__FcCharSetFirstPage\""), visibility(\""default\"")));\n # undef FcCharSetNextPage\n-extern __typeof (FcCharSetNextPage) FcCharSetNextPage __attribute((alias(\""IA__FcCharSetNextPage\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetNextPage) FcCharSetNextPage __attribute((alias(\""IA__FcCharSetNextPage\""), visibility(\""default\"")));\n # undef FcCharSetCoverage\n-extern __typeof (FcCharSetCoverage) FcCharSetCoverage __attribute((alias(\""IA__FcCharSetCoverage\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcCharSetCoverage) FcCharSetCoverage __attribute((alias(\""IA__FcCharSetCoverage\""), visibility(\""default\"")));\n #endif /* __fccharset__ */\n #ifdef __fcdbg__\n # undef FcValuePrint\n-extern __typeof (FcValuePrint) FcValuePrint __attribute((alias(\""IA__FcValuePrint\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcValuePrint) FcValuePrint __attribute((alias(\""IA__FcValuePrint\""), visibility(\""default\"")));\n # undef FcPatternPrint\n-extern __typeof (FcPatternPrint) FcPatternPrint __attribute((alias(\""IA__FcPatternPrint\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternPrint) FcPatternPrint __attribute((alias(\""IA__FcPatternPrint\""), visibility(\""default\"")));\n # undef FcFontSetPrint\n-extern __typeof (FcFontSetPrint) FcFontSetPrint __attribute((alias(\""IA__FcFontSetPrint\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontSetPrint) FcFontSetPrint __attribute((alias(\""IA__FcFontSetPrint\""), visibility(\""default\"")));\n #endif /* __fcdbg__ */\n #ifdef __fcdefault__\n # undef FcGetDefaultLangs\n-extern __typeof (FcGetDefaultLangs) FcGetDefaultLangs __attribute((alias(\""IA__FcGetDefaultLangs\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcGetDefaultLangs) FcGetDefaultLangs __attribute((alias(\""IA__FcGetDefaultLangs\""), visibility(\""default\"")));\n # undef FcDefaultSubstitute\n-extern __typeof (FcDefaultSubstitute) FcDefaultSubstitute __attribute((alias(\""IA__FcDefaultSubstitute\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDefaultSubstitute) FcDefaultSubstitute __attribute((alias(\""IA__FcDefaultSubstitute\""), visibility(\""default\"")));\n #endif /* __fcdefault__ */\n #ifdef __fcdir__\n # undef FcFileIsDir\n-extern __typeof (FcFileIsDir) FcFileIsDir __attribute((alias(\""IA__FcFileIsDir\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFileIsDir) FcFileIsDir __attribute((alias(\""IA__FcFileIsDir\""), visibility(\""default\"")));\n # undef FcFileScan\n-extern __typeof (FcFileScan) FcFileScan __attribute((alias(\""IA__FcFileScan\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFileScan) FcFileScan __attribute((alias(\""IA__FcFileScan\""), visibility(\""default\"")));\n # undef FcDirScan\n-extern __typeof (FcDirScan) FcDirScan __attribute((alias(\""IA__FcDirScan\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirScan) FcDirScan __attribute((alias(\""IA__FcDirScan\""), visibility(\""default\"")));\n # undef FcDirSave\n-extern __typeof (FcDirSave) FcDirSave __attribute((alias(\""IA__FcDirSave\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirSave) FcDirSave __attribute((alias(\""IA__FcDirSave\""), visibility(\""default\"")));\n #endif /* __fcdir__ */\n #ifdef __fccache__\n # undef FcDirCacheLoad\n-extern __typeof (FcDirCacheLoad) FcDirCacheLoad __attribute((alias(\""IA__FcDirCacheLoad\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirCacheLoad) FcDirCacheLoad __attribute((alias(\""IA__FcDirCacheLoad\""), visibility(\""default\"")));\n #endif /* __fccache__ */\n #ifdef __fcdir__\n # undef FcDirCacheRescan\n-extern __typeof (FcDirCacheRescan) FcDirCacheRescan __attribute((alias(\""IA__FcDirCacheRescan\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirCacheRescan) FcDirCacheRescan __attribute((alias(\""IA__FcDirCacheRescan\""), visibility(\""default\"")));\n # undef FcDirCacheRead\n-extern __typeof (FcDirCacheRead) FcDirCacheRead __attribute((alias(\""IA__FcDirCacheRead\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirCacheRead) FcDirCacheRead __attribute((alias(\""IA__FcDirCacheRead\""), visibility(\""default\"")));\n #endif /* __fcdir__ */\n #ifdef __fccache__\n # undef FcDirCacheLoadFile\n-extern __typeof (FcDirCacheLoadFile) FcDirCacheLoadFile __attribute((alias(\""IA__FcDirCacheLoadFile\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirCacheLoadFile) FcDirCacheLoadFile __attribute((alias(\""IA__FcDirCacheLoadFile\""), visibility(\""default\"")));\n # undef FcDirCacheUnload\n-extern __typeof (FcDirCacheUnload) FcDirCacheUnload __attribute((alias(\""IA__FcDirCacheUnload\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcDirCacheUnload) FcDirCacheUnload __attribute((alias(\""IA__FcDirCacheUnload\""), visibility(\""default\"")));\n #endif /* __fccache__ */\n #ifdef __fcfreetype__\n # undef FcFreeTypeQuery\n-extern __typeof (FcFreeTypeQuery) FcFreeTypeQuery __attribute((alias(\""IA__FcFreeTypeQuery\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcFreeTypeQueryAll\n-extern __typeof (FcFreeTypeQueryAll) FcFreeTypeQueryAll __attribute((alias(\""IA__FcFreeTypeQueryAll\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFreeTypeQuery) FcFreeTypeQuery __attribute((alias(\""IA__FcFreeTypeQuery\""), visibility(\""default\"")));\n #endif /* __fcfreetype__ */\n #ifdef __fcfs__\n # undef FcFontSetCreate\n-extern __typeof (FcFontSetCreate) FcFontSetCreate __attribute((alias(\""IA__FcFontSetCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontSetCreate) FcFontSetCreate __attribute((alias(\""IA__FcFontSetCreate\""), visibility(\""default\"")));\n # undef FcFontSetDestroy\n-extern __typeof (FcFontSetDestroy) FcFontSetDestroy __attribute((alias(\""IA__FcFontSetDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontSetDestroy) FcFontSetDestroy __attribute((alias(\""IA__FcFontSetDestroy\""), visibility(\""default\"")));\n # undef FcFontSetAdd\n-extern __typeof (FcFontSetAdd) FcFontSetAdd __attribute((alias(\""IA__FcFontSetAdd\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontSetAdd) FcFontSetAdd __attribute((alias(\""IA__FcFontSetAdd\""), visibility(\""default\"")));\n #endif /* __fcfs__ */\n #ifdef __fcinit__\n # undef FcInitLoadConfig\n-extern __typeof (FcInitLoadConfig) FcInitLoadConfig __attribute((alias(\""IA__FcInitLoadConfig\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcInitLoadConfig) FcInitLoadConfig __attribute((alias(\""IA__FcInitLoadConfig\""), visibility(\""default\"")));\n # undef FcInitLoadConfigAndFonts\n-extern __typeof (FcInitLoadConfigAndFonts) FcInitLoadConfigAndFonts __attribute((alias(\""IA__FcInitLoadConfigAndFonts\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcInitLoadConfigAndFonts) FcInitLoadConfigAndFonts __attribute((alias(\""IA__FcInitLoadConfigAndFonts\""), visibility(\""default\"")));\n # undef FcInit\n-extern __typeof (FcInit) FcInit __attribute((alias(\""IA__FcInit\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcInit) FcInit __attribute((alias(\""IA__FcInit\""), visibility(\""default\"")));\n # undef FcFini\n-extern __typeof (FcFini) FcFini __attribute((alias(\""IA__FcFini\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFini) FcFini __attribute((alias(\""IA__FcFini\""), visibility(\""default\"")));\n # undef FcGetVersion\n-extern __typeof (FcGetVersion) FcGetVersion __attribute((alias(\""IA__FcGetVersion\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcGetVersion) FcGetVersion __attribute((alias(\""IA__FcGetVersion\""), visibility(\""default\"")));\n # undef FcInitReinitialize\n-extern __typeof (FcInitReinitialize) FcInitReinitialize __attribute((alias(\""IA__FcInitReinitialize\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcInitReinitialize) FcInitReinitialize __attribute((alias(\""IA__FcInitReinitialize\""), visibility(\""default\"")));\n # undef FcInitBringUptoDate\n-extern __typeof (FcInitBringUptoDate) FcInitBringUptoDate __attribute((alias(\""IA__FcInitBringUptoDate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcInitBringUptoDate) FcInitBringUptoDate __attribute((alias(\""IA__FcInitBringUptoDate\""), visibility(\""default\"")));\n #endif /* __fcinit__ */\n #ifdef __fclang__\n # undef FcGetLangs\n-extern __typeof (FcGetLangs) FcGetLangs __attribute((alias(\""IA__FcGetLangs\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcGetLangs) FcGetLangs __attribute((alias(\""IA__FcGetLangs\""), visibility(\""default\"")));\n # undef FcLangNormalize\n-extern __typeof (FcLangNormalize) FcLangNormalize __attribute((alias(\""IA__FcLangNormalize\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangNormalize) FcLangNormalize __attribute((alias(\""IA__FcLangNormalize\""), visibility(\""default\"")));\n # undef FcLangGetCharSet\n-extern __typeof (FcLangGetCharSet) FcLangGetCharSet __attribute((alias(\""IA__FcLangGetCharSet\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangGetCharSet) FcLangGetCharSet __attribute((alias(\""IA__FcLangGetCharSet\""), visibility(\""default\"")));\n # undef FcLangSetCreate\n-extern __typeof (FcLangSetCreate) FcLangSetCreate __attribute((alias(\""IA__FcLangSetCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetCreate) FcLangSetCreate __attribute((alias(\""IA__FcLangSetCreate\""), visibility(\""default\"")));\n # undef FcLangSetDestroy\n-extern __typeof (FcLangSetDestroy) FcLangSetDestroy __attribute((alias(\""IA__FcLangSetDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetDestroy) FcLangSetDestroy __attribute((alias(\""IA__FcLangSetDestroy\""), visibility(\""default\"")));\n # undef FcLangSetCopy\n-extern __typeof (FcLangSetCopy) FcLangSetCopy __attribute((alias(\""IA__FcLangSetCopy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetCopy) FcLangSetCopy __attribute((alias(\""IA__FcLangSetCopy\""), visibility(\""default\"")));\n # undef FcLangSetAdd\n-extern __typeof (FcLangSetAdd) FcLangSetAdd __attribute((alias(\""IA__FcLangSetAdd\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetAdd) FcLangSetAdd __attribute((alias(\""IA__FcLangSetAdd\""), visibility(\""default\"")));\n # undef FcLangSetDel\n-extern __typeof (FcLangSetDel) FcLangSetDel __attribute((alias(\""IA__FcLangSetDel\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetDel) FcLangSetDel __attribute((alias(\""IA__FcLangSetDel\""), visibility(\""default\"")));\n # undef FcLangSetHasLang\n-extern __typeof (FcLangSetHasLang) FcLangSetHasLang __attribute((alias(\""IA__FcLangSetHasLang\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetHasLang) FcLangSetHasLang __attribute((alias(\""IA__FcLangSetHasLang\""), visibility(\""default\"")));\n # undef FcLangSetCompare\n-extern __typeof (FcLangSetCompare) FcLangSetCompare __attribute((alias(\""IA__FcLangSetCompare\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetCompare) FcLangSetCompare __attribute((alias(\""IA__FcLangSetCompare\""), visibility(\""default\"")));\n # undef FcLangSetContains\n-extern __typeof (FcLangSetContains) FcLangSetContains __attribute((alias(\""IA__FcLangSetContains\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetContains) FcLangSetContains __attribute((alias(\""IA__FcLangSetContains\""), visibility(\""default\"")));\n # undef FcLangSetEqual\n-extern __typeof (FcLangSetEqual) FcLangSetEqual __attribute((alias(\""IA__FcLangSetEqual\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetEqual) FcLangSetEqual __attribute((alias(\""IA__FcLangSetEqual\""), visibility(\""default\"")));\n # undef FcLangSetHash\n-extern __typeof (FcLangSetHash) FcLangSetHash __attribute((alias(\""IA__FcLangSetHash\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetHash) FcLangSetHash __attribute((alias(\""IA__FcLangSetHash\""), visibility(\""default\"")));\n # undef FcLangSetGetLangs\n-extern __typeof (FcLangSetGetLangs) FcLangSetGetLangs __attribute((alias(\""IA__FcLangSetGetLangs\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetGetLangs) FcLangSetGetLangs __attribute((alias(\""IA__FcLangSetGetLangs\""), visibility(\""default\"")));\n # undef FcLangSetUnion\n-extern __typeof (FcLangSetUnion) FcLangSetUnion __attribute((alias(\""IA__FcLangSetUnion\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetUnion) FcLangSetUnion __attribute((alias(\""IA__FcLangSetUnion\""), visibility(\""default\"")));\n # undef FcLangSetSubtract\n-extern __typeof (FcLangSetSubtract) FcLangSetSubtract __attribute((alias(\""IA__FcLangSetSubtract\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcLangSetSubtract) FcLangSetSubtract __attribute((alias(\""IA__FcLangSetSubtract\""), visibility(\""default\"")));\n #endif /* __fclang__ */\n #ifdef __fclist__\n # undef FcObjectSetCreate\n-extern __typeof (FcObjectSetCreate) FcObjectSetCreate __attribute((alias(\""IA__FcObjectSetCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcObjectSetCreate) FcObjectSetCreate __attribute((alias(\""IA__FcObjectSetCreate\""), visibility(\""default\"")));\n # undef FcObjectSetAdd\n-extern __typeof (FcObjectSetAdd) FcObjectSetAdd __attribute((alias(\""IA__FcObjectSetAdd\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcObjectSetAdd) FcObjectSetAdd __attribute((alias(\""IA__FcObjectSetAdd\""), visibility(\""default\"")));\n # undef FcObjectSetDestroy\n-extern __typeof (FcObjectSetDestroy) FcObjectSetDestroy __attribute((alias(\""IA__FcObjectSetDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcObjectSetDestroy) FcObjectSetDestroy __attribute((alias(\""IA__FcObjectSetDestroy\""), visibility(\""default\"")));\n # undef FcObjectSetVaBuild\n-extern __typeof (FcObjectSetVaBuild) FcObjectSetVaBuild __attribute((alias(\""IA__FcObjectSetVaBuild\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcObjectSetVaBuild) FcObjectSetVaBuild __attribute((alias(\""IA__FcObjectSetVaBuild\""), visibility(\""default\"")));\n # undef FcObjectSetBuild\n-extern __typeof (FcObjectSetBuild) FcObjectSetBuild __attribute((alias(\""IA__FcObjectSetBuild\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcObjectSetBuild) FcObjectSetBuild __attribute((alias(\""IA__FcObjectSetBuild\""), visibility(\""default\"")));\n # undef FcFontSetList\n-extern __typeof (FcFontSetList) FcFontSetList __attribute((alias(\""IA__FcFontSetList\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontSetList) FcFontSetList __attribute((alias(\""IA__FcFontSetList\""), visibility(\""default\"")));\n # undef FcFontList\n-extern __typeof (FcFontList) FcFontList __attribute((alias(\""IA__FcFontList\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontList) FcFontList __attribute((alias(\""IA__FcFontList\""), visibility(\""default\"")));\n #endif /* __fclist__ */\n #ifdef __fcatomic__\n # undef FcAtomicCreate\n-extern __typeof (FcAtomicCreate) FcAtomicCreate __attribute((alias(\""IA__FcAtomicCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcAtomicCreate) FcAtomicCreate __attribute((alias(\""IA__FcAtomicCreate\""), visibility(\""default\"")));\n # undef FcAtomicLock\n-extern __typeof (FcAtomicLock) FcAtomicLock __attribute((alias(\""IA__FcAtomicLock\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcAtomicLock) FcAtomicLock __attribute((alias(\""IA__FcAtomicLock\""), visibility(\""default\"")));\n # undef FcAtomicNewFile\n-extern __typeof (FcAtomicNewFile) FcAtomicNewFile __attribute((alias(\""IA__FcAtomicNewFile\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcAtomicNewFile) FcAtomicNewFile __attribute((alias(\""IA__FcAtomicNewFile\""), visibility(\""default\"")));\n # undef FcAtomicOrigFile\n-extern __typeof (FcAtomicOrigFile) FcAtomicOrigFile __attribute((alias(\""IA__FcAtomicOrigFile\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcAtomicOrigFile) FcAtomicOrigFile __attribute((alias(\""IA__FcAtomicOrigFile\""), visibility(\""default\"")));\n # undef FcAtomicReplaceOrig\n-extern __typeof (FcAtomicReplaceOrig) FcAtomicReplaceOrig __attribute((alias(\""IA__FcAtomicReplaceOrig\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcAtomicReplaceOrig) FcAtomicReplaceOrig __attribute((alias(\""IA__FcAtomicReplaceOrig\""), visibility(\""default\"")));\n # undef FcAtomicDeleteNew\n-extern __typeof (FcAtomicDeleteNew) FcAtomicDeleteNew __attribute((alias(\""IA__FcAtomicDeleteNew\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcAtomicDeleteNew) FcAtomicDeleteNew __attribute((alias(\""IA__FcAtomicDeleteNew\""), visibility(\""default\"")));\n # undef FcAtomicUnlock\n-extern __typeof (FcAtomicUnlock) FcAtomicUnlock __attribute((alias(\""IA__FcAtomicUnlock\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcAtomicUnlock) FcAtomicUnlock __attribute((alias(\""IA__FcAtomicUnlock\""), visibility(\""default\"")));\n # undef FcAtomicDestroy\n-extern __typeof (FcAtomicDestroy) FcAtomicDestroy __attribute((alias(\""IA__FcAtomicDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcAtomicDestroy) FcAtomicDestroy __attribute((alias(\""IA__FcAtomicDestroy\""), visibility(\""default\"")));\n #endif /* __fcatomic__ */\n #ifdef __fcmatch__\n # undef FcFontSetMatch\n-extern __typeof (FcFontSetMatch) FcFontSetMatch __attribute((alias(\""IA__FcFontSetMatch\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontSetMatch) FcFontSetMatch __attribute((alias(\""IA__FcFontSetMatch\""), visibility(\""default\"")));\n # undef FcFontMatch\n-extern __typeof (FcFontMatch) FcFontMatch __attribute((alias(\""IA__FcFontMatch\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontMatch) FcFontMatch __attribute((alias(\""IA__FcFontMatch\""), visibility(\""default\"")));\n # undef FcFontRenderPrepare\n-extern __typeof (FcFontRenderPrepare) FcFontRenderPrepare __attribute((alias(\""IA__FcFontRenderPrepare\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontRenderPrepare) FcFontRenderPrepare __attribute((alias(\""IA__FcFontRenderPrepare\""), visibility(\""default\"")));\n # undef FcFontSetSort\n-extern __typeof (FcFontSetSort) FcFontSetSort __attribute((alias(\""IA__FcFontSetSort\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontSetSort) FcFontSetSort __attribute((alias(\""IA__FcFontSetSort\""), visibility(\""default\"")));\n # undef FcFontSort\n-extern __typeof (FcFontSort) FcFontSort __attribute((alias(\""IA__FcFontSort\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontSort) FcFontSort __attribute((alias(\""IA__FcFontSort\""), visibility(\""default\"")));\n # undef FcFontSetSortDestroy\n-extern __typeof (FcFontSetSortDestroy) FcFontSetSortDestroy __attribute((alias(\""IA__FcFontSetSortDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFontSetSortDestroy) FcFontSetSortDestroy __attribute((alias(\""IA__FcFontSetSortDestroy\""), visibility(\""default\"")));\n #endif /* __fcmatch__ */\n #ifdef __fcmatrix__\n # undef FcMatrixCopy\n-extern __typeof (FcMatrixCopy) FcMatrixCopy __attribute((alias(\""IA__FcMatrixCopy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcMatrixCopy) FcMatrixCopy __attribute((alias(\""IA__FcMatrixCopy\""), visibility(\""default\"")));\n # undef FcMatrixEqual\n-extern __typeof (FcMatrixEqual) FcMatrixEqual __attribute((alias(\""IA__FcMatrixEqual\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcMatrixEqual) FcMatrixEqual __attribute((alias(\""IA__FcMatrixEqual\""), visibility(\""default\"")));\n # undef FcMatrixMultiply\n-extern __typeof (FcMatrixMultiply) FcMatrixMultiply __attribute((alias(\""IA__FcMatrixMultiply\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcMatrixMultiply) FcMatrixMultiply __attribute((alias(\""IA__FcMatrixMultiply\""), visibility(\""default\"")));\n # undef FcMatrixRotate\n-extern __typeof (FcMatrixRotate) FcMatrixRotate __attribute((alias(\""IA__FcMatrixRotate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcMatrixRotate) FcMatrixRotate __attribute((alias(\""IA__FcMatrixRotate\""), visibility(\""default\"")));\n # undef FcMatrixScale\n-extern __typeof (FcMatrixScale) FcMatrixScale __attribute((alias(\""IA__FcMatrixScale\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcMatrixScale) FcMatrixScale __attribute((alias(\""IA__FcMatrixScale\""), visibility(\""default\"")));\n # undef FcMatrixShear\n-extern __typeof (FcMatrixShear) FcMatrixShear __attribute((alias(\""IA__FcMatrixShear\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcMatrixShear) FcMatrixShear __attribute((alias(\""IA__FcMatrixShear\""), visibility(\""default\"")));\n #endif /* __fcmatrix__ */\n #ifdef __fcname__\n # undef FcNameRegisterObjectTypes\n-extern __typeof (FcNameRegisterObjectTypes) FcNameRegisterObjectTypes __attribute((alias(\""IA__FcNameRegisterObjectTypes\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcNameRegisterObjectTypes) FcNameRegisterObjectTypes __attribute((alias(\""IA__FcNameRegisterObjectTypes\""), visibility(\""default\"")));\n # undef FcNameUnregisterObjectTypes\n-extern __typeof (FcNameUnregisterObjectTypes) FcNameUnregisterObjectTypes __attribute((alias(\""IA__FcNameUnregisterObjectTypes\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcNameUnregisterObjectTypes) FcNameUnregisterObjectTypes __attribute((alias(\""IA__FcNameUnregisterObjectTypes\""), visibility(\""default\"")));\n # undef FcNameGetObjectType\n-extern __typeof (FcNameGetObjectType) FcNameGetObjectType __attribute((alias(\""IA__FcNameGetObjectType\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcNameGetObjectType) FcNameGetObjectType __attribute((alias(\""IA__FcNameGetObjectType\""), visibility(\""default\"")));\n # undef FcNameRegisterConstants\n-extern __typeof (FcNameRegisterConstants) FcNameRegisterConstants __attribute((alias(\""IA__FcNameRegisterConstants\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcNameRegisterConstants) FcNameRegisterConstants __attribute((alias(\""IA__FcNameRegisterConstants\""), visibility(\""default\"")));\n # undef FcNameUnregisterConstants\n-extern __typeof (FcNameUnregisterConstants) FcNameUnregisterConstants __attribute((alias(\""IA__FcNameUnregisterConstants\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcNameUnregisterConstants) FcNameUnregisterConstants __attribute((alias(\""IA__FcNameUnregisterConstants\""), visibility(\""default\"")));\n # undef FcNameGetConstant\n-extern __typeof (FcNameGetConstant) FcNameGetConstant __attribute((alias(\""IA__FcNameGetConstant\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcNameGetConstant) FcNameGetConstant __attribute((alias(\""IA__FcNameGetConstant\""), visibility(\""default\"")));\n # undef FcNameConstant\n-extern __typeof (FcNameConstant) FcNameConstant __attribute((alias(\""IA__FcNameConstant\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcNameConstant) FcNameConstant __attribute((alias(\""IA__FcNameConstant\""), visibility(\""default\"")));\n # undef FcNameParse\n-extern __typeof (FcNameParse) FcNameParse __attribute((alias(\""IA__FcNameParse\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcNameParse) FcNameParse __attribute((alias(\""IA__FcNameParse\""), visibility(\""default\"")));\n # undef FcNameUnparse\n-extern __typeof (FcNameUnparse) FcNameUnparse __attribute((alias(\""IA__FcNameUnparse\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcNameUnparse) FcNameUnparse __attribute((alias(\""IA__FcNameUnparse\""), visibility(\""default\"")));\n #endif /* __fcname__ */\n #ifdef __fcpat__\n # undef FcPatternCreate\n-extern __typeof (FcPatternCreate) FcPatternCreate __attribute((alias(\""IA__FcPatternCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternCreate) FcPatternCreate __attribute((alias(\""IA__FcPatternCreate\""), visibility(\""default\"")));\n # undef FcPatternDuplicate\n-extern __typeof (FcPatternDuplicate) FcPatternDuplicate __attribute((alias(\""IA__FcPatternDuplicate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternDuplicate) FcPatternDuplicate __attribute((alias(\""IA__FcPatternDuplicate\""), visibility(\""default\"")));\n # undef FcPatternReference\n-extern __typeof (FcPatternReference) FcPatternReference __attribute((alias(\""IA__FcPatternReference\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternReference) FcPatternReference __attribute((alias(\""IA__FcPatternReference\""), visibility(\""default\"")));\n # undef FcPatternFilter\n-extern __typeof (FcPatternFilter) FcPatternFilter __attribute((alias(\""IA__FcPatternFilter\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternFilter) FcPatternFilter __attribute((alias(\""IA__FcPatternFilter\""), visibility(\""default\"")));\n # undef FcValueDestroy\n-extern __typeof (FcValueDestroy) FcValueDestroy __attribute((alias(\""IA__FcValueDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcValueDestroy) FcValueDestroy __attribute((alias(\""IA__FcValueDestroy\""), visibility(\""default\"")));\n # undef FcValueEqual\n-extern __typeof (FcValueEqual) FcValueEqual __attribute((alias(\""IA__FcValueEqual\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcValueEqual) FcValueEqual __attribute((alias(\""IA__FcValueEqual\""), visibility(\""default\"")));\n # undef FcValueSave\n-extern __typeof (FcValueSave) FcValueSave __attribute((alias(\""IA__FcValueSave\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcValueSave) FcValueSave __attribute((alias(\""IA__FcValueSave\""), visibility(\""default\"")));\n # undef FcPatternDestroy\n-extern __typeof (FcPatternDestroy) FcPatternDestroy __attribute((alias(\""IA__FcPatternDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcPatternObjectCount\n-extern __typeof (FcPatternObjectCount) FcPatternObjectCount __attribute((alias(\""IA__FcPatternObjectCount\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternDestroy) FcPatternDestroy __attribute((alias(\""IA__FcPatternDestroy\""), visibility(\""default\"")));\n # undef FcPatternEqual\n-extern __typeof (FcPatternEqual) FcPatternEqual __attribute((alias(\""IA__FcPatternEqual\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternEqual) FcPatternEqual __attribute((alias(\""IA__FcPatternEqual\""), visibility(\""default\"")));\n # undef FcPatternEqualSubset\n-extern __typeof (FcPatternEqualSubset) FcPatternEqualSubset __attribute((alias(\""IA__FcPatternEqualSubset\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternEqualSubset) FcPatternEqualSubset __attribute((alias(\""IA__FcPatternEqualSubset\""), visibility(\""default\"")));\n # undef FcPatternHash\n-extern __typeof (FcPatternHash) FcPatternHash __attribute((alias(\""IA__FcPatternHash\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternHash) FcPatternHash __attribute((alias(\""IA__FcPatternHash\""), visibility(\""default\"")));\n # undef FcPatternAdd\n-extern __typeof (FcPatternAdd) FcPatternAdd __attribute((alias(\""IA__FcPatternAdd\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAdd) FcPatternAdd __attribute((alias(\""IA__FcPatternAdd\""), visibility(\""default\"")));\n # undef FcPatternAddWeak\n-extern __typeof (FcPatternAddWeak) FcPatternAddWeak __attribute((alias(\""IA__FcPatternAddWeak\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddWeak) FcPatternAddWeak __attribute((alias(\""IA__FcPatternAddWeak\""), visibility(\""default\"")));\n # undef FcPatternGet\n-extern __typeof (FcPatternGet) FcPatternGet __attribute((alias(\""IA__FcPatternGet\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGet) FcPatternGet __attribute((alias(\""IA__FcPatternGet\""), visibility(\""default\"")));\n # undef FcPatternGetWithBinding\n-extern __typeof (FcPatternGetWithBinding) FcPatternGetWithBinding __attribute((alias(\""IA__FcPatternGetWithBinding\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetWithBinding) FcPatternGetWithBinding __attribute((alias(\""IA__FcPatternGetWithBinding\""), visibility(\""default\"")));\n # undef FcPatternDel\n-extern __typeof (FcPatternDel) FcPatternDel __attribute((alias(\""IA__FcPatternDel\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternDel) FcPatternDel __attribute((alias(\""IA__FcPatternDel\""), visibility(\""default\"")));\n # undef FcPatternRemove\n-extern __typeof (FcPatternRemove) FcPatternRemove __attribute((alias(\""IA__FcPatternRemove\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternRemove) FcPatternRemove __attribute((alias(\""IA__FcPatternRemove\""), visibility(\""default\"")));\n # undef FcPatternAddInteger\n-extern __typeof (FcPatternAddInteger) FcPatternAddInteger __attribute((alias(\""IA__FcPatternAddInteger\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddInteger) FcPatternAddInteger __attribute((alias(\""IA__FcPatternAddInteger\""), visibility(\""default\"")));\n # undef FcPatternAddDouble\n-extern __typeof (FcPatternAddDouble) FcPatternAddDouble __attribute((alias(\""IA__FcPatternAddDouble\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddDouble) FcPatternAddDouble __attribute((alias(\""IA__FcPatternAddDouble\""), visibility(\""default\"")));\n # undef FcPatternAddString\n-extern __typeof (FcPatternAddString) FcPatternAddString __attribute((alias(\""IA__FcPatternAddString\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddString) FcPatternAddString __attribute((alias(\""IA__FcPatternAddString\""), visibility(\""default\"")));\n # undef FcPatternAddMatrix\n-extern __typeof (FcPatternAddMatrix) FcPatternAddMatrix __attribute((alias(\""IA__FcPatternAddMatrix\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddMatrix) FcPatternAddMatrix __attribute((alias(\""IA__FcPatternAddMatrix\""), visibility(\""default\"")));\n # undef FcPatternAddCharSet\n-extern __typeof (FcPatternAddCharSet) FcPatternAddCharSet __attribute((alias(\""IA__FcPatternAddCharSet\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddCharSet) FcPatternAddCharSet __attribute((alias(\""IA__FcPatternAddCharSet\""), visibility(\""default\"")));\n # undef FcPatternAddBool\n-extern __typeof (FcPatternAddBool) FcPatternAddBool __attribute((alias(\""IA__FcPatternAddBool\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddBool) FcPatternAddBool __attribute((alias(\""IA__FcPatternAddBool\""), visibility(\""default\"")));\n # undef FcPatternAddLangSet\n-extern __typeof (FcPatternAddLangSet) FcPatternAddLangSet __attribute((alias(\""IA__FcPatternAddLangSet\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddLangSet) FcPatternAddLangSet __attribute((alias(\""IA__FcPatternAddLangSet\""), visibility(\""default\"")));\n # undef FcPatternAddRange\n-extern __typeof (FcPatternAddRange) FcPatternAddRange __attribute((alias(\""IA__FcPatternAddRange\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddRange) FcPatternAddRange __attribute((alias(\""IA__FcPatternAddRange\""), visibility(\""default\"")));\n # undef FcPatternGetInteger\n-extern __typeof (FcPatternGetInteger) FcPatternGetInteger __attribute((alias(\""IA__FcPatternGetInteger\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetInteger) FcPatternGetInteger __attribute((alias(\""IA__FcPatternGetInteger\""), visibility(\""default\"")));\n # undef FcPatternGetDouble\n-extern __typeof (FcPatternGetDouble) FcPatternGetDouble __attribute((alias(\""IA__FcPatternGetDouble\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetDouble) FcPatternGetDouble __attribute((alias(\""IA__FcPatternGetDouble\""), visibility(\""default\"")));\n # undef FcPatternGetString\n-extern __typeof (FcPatternGetString) FcPatternGetString __attribute((alias(\""IA__FcPatternGetString\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetString) FcPatternGetString __attribute((alias(\""IA__FcPatternGetString\""), visibility(\""default\"")));\n # undef FcPatternGetMatrix\n-extern __typeof (FcPatternGetMatrix) FcPatternGetMatrix __attribute((alias(\""IA__FcPatternGetMatrix\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetMatrix) FcPatternGetMatrix __attribute((alias(\""IA__FcPatternGetMatrix\""), visibility(\""default\"")));\n # undef FcPatternGetCharSet\n-extern __typeof (FcPatternGetCharSet) FcPatternGetCharSet __attribute((alias(\""IA__FcPatternGetCharSet\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetCharSet) FcPatternGetCharSet __attribute((alias(\""IA__FcPatternGetCharSet\""), visibility(\""default\"")));\n # undef FcPatternGetBool\n-extern __typeof (FcPatternGetBool) FcPatternGetBool __attribute((alias(\""IA__FcPatternGetBool\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetBool) FcPatternGetBool __attribute((alias(\""IA__FcPatternGetBool\""), visibility(\""default\"")));\n # undef FcPatternGetLangSet\n-extern __typeof (FcPatternGetLangSet) FcPatternGetLangSet __attribute((alias(\""IA__FcPatternGetLangSet\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetLangSet) FcPatternGetLangSet __attribute((alias(\""IA__FcPatternGetLangSet\""), visibility(\""default\"")));\n # undef FcPatternGetRange\n-extern __typeof (FcPatternGetRange) FcPatternGetRange __attribute((alias(\""IA__FcPatternGetRange\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetRange) FcPatternGetRange __attribute((alias(\""IA__FcPatternGetRange\""), visibility(\""default\"")));\n # undef FcPatternVaBuild\n-extern __typeof (FcPatternVaBuild) FcPatternVaBuild __attribute((alias(\""IA__FcPatternVaBuild\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternVaBuild) FcPatternVaBuild __attribute((alias(\""IA__FcPatternVaBuild\""), visibility(\""default\"")));\n # undef FcPatternBuild\n-extern __typeof (FcPatternBuild) FcPatternBuild __attribute((alias(\""IA__FcPatternBuild\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternBuild) FcPatternBuild __attribute((alias(\""IA__FcPatternBuild\""), visibility(\""default\"")));\n #endif /* __fcpat__ */\n #ifdef __fcformat__\n # undef FcPatternFormat\n-extern __typeof (FcPatternFormat) FcPatternFormat __attribute((alias(\""IA__FcPatternFormat\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternFormat) FcPatternFormat __attribute((alias(\""IA__FcPatternFormat\""), visibility(\""default\"")));\n #endif /* __fcformat__ */\n #ifdef __fcrange__\n # undef FcRangeCreateDouble\n-extern __typeof (FcRangeCreateDouble) FcRangeCreateDouble __attribute((alias(\""IA__FcRangeCreateDouble\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcRangeCreateDouble) FcRangeCreateDouble __attribute((alias(\""IA__FcRangeCreateDouble\""), visibility(\""default\"")));\n # undef FcRangeCreateInteger\n-extern __typeof (FcRangeCreateInteger) FcRangeCreateInteger __attribute((alias(\""IA__FcRangeCreateInteger\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcRangeCreateInteger) FcRangeCreateInteger __attribute((alias(\""IA__FcRangeCreateInteger\""), visibility(\""default\"")));\n # undef FcRangeDestroy\n-extern __typeof (FcRangeDestroy) FcRangeDestroy __attribute((alias(\""IA__FcRangeDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcRangeDestroy) FcRangeDestroy __attribute((alias(\""IA__FcRangeDestroy\""), visibility(\""default\"")));\n # undef FcRangeCopy\n-extern __typeof (FcRangeCopy) FcRangeCopy __attribute((alias(\""IA__FcRangeCopy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcRangeCopy) FcRangeCopy __attribute((alias(\""IA__FcRangeCopy\""), visibility(\""default\"")));\n # undef FcRangeGetDouble\n-extern __typeof (FcRangeGetDouble) FcRangeGetDouble __attribute((alias(\""IA__FcRangeGetDouble\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcRangeGetDouble) FcRangeGetDouble __attribute((alias(\""IA__FcRangeGetDouble\""), visibility(\""default\"")));\n #endif /* __fcrange__ */\n-#ifdef __fcpat__\n-# undef FcPatternIterStart\n-extern __typeof (FcPatternIterStart) FcPatternIterStart __attribute((alias(\""IA__FcPatternIterStart\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcPatternIterNext\n-extern __typeof (FcPatternIterNext) FcPatternIterNext __attribute((alias(\""IA__FcPatternIterNext\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcPatternIterEqual\n-extern __typeof (FcPatternIterEqual) FcPatternIterEqual __attribute((alias(\""IA__FcPatternIterEqual\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcPatternFindIter\n-extern __typeof (FcPatternFindIter) FcPatternFindIter __attribute((alias(\""IA__FcPatternFindIter\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcPatternIterIsValid\n-extern __typeof (FcPatternIterIsValid) FcPatternIterIsValid __attribute((alias(\""IA__FcPatternIterIsValid\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcPatternIterGetObject\n-extern __typeof (FcPatternIterGetObject) FcPatternIterGetObject __attribute((alias(\""IA__FcPatternIterGetObject\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcPatternIterValueCount\n-extern __typeof (FcPatternIterValueCount) FcPatternIterValueCount __attribute((alias(\""IA__FcPatternIterValueCount\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcPatternIterGetValue\n-extern __typeof (FcPatternIterGetValue) FcPatternIterGetValue __attribute((alias(\""IA__FcPatternIterGetValue\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-#endif /* __fcpat__ */\n #ifdef __fcweight__\n # undef FcWeightFromOpenType\n-extern __typeof (FcWeightFromOpenType) FcWeightFromOpenType __attribute((alias(\""IA__FcWeightFromOpenType\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcWeightFromOpenTypeDouble\n-extern __typeof (FcWeightFromOpenTypeDouble) FcWeightFromOpenTypeDouble __attribute((alias(\""IA__FcWeightFromOpenTypeDouble\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcWeightFromOpenType) FcWeightFromOpenType __attribute((alias(\""IA__FcWeightFromOpenType\""), visibility(\""default\"")));\n # undef FcWeightToOpenType\n-extern __typeof (FcWeightToOpenType) FcWeightToOpenType __attribute((alias(\""IA__FcWeightToOpenType\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n-# undef FcWeightToOpenTypeDouble\n-extern __typeof (FcWeightToOpenTypeDouble) FcWeightToOpenTypeDouble __attribute((alias(\""IA__FcWeightToOpenTypeDouble\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcWeightToOpenType) FcWeightToOpenType __attribute((alias(\""IA__FcWeightToOpenType\""), visibility(\""default\"")));\n #endif /* __fcweight__ */\n #ifdef __fcstr__\n # undef FcStrCopy\n-extern __typeof (FcStrCopy) FcStrCopy __attribute((alias(\""IA__FcStrCopy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrCopy) FcStrCopy __attribute((alias(\""IA__FcStrCopy\""), visibility(\""default\"")));\n # undef FcStrCopyFilename\n-extern __typeof (FcStrCopyFilename) FcStrCopyFilename __attribute((alias(\""IA__FcStrCopyFilename\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrCopyFilename) FcStrCopyFilename __attribute((alias(\""IA__FcStrCopyFilename\""), visibility(\""default\"")));\n # undef FcStrPlus\n-extern __typeof (FcStrPlus) FcStrPlus __attribute((alias(\""IA__FcStrPlus\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrPlus) FcStrPlus __attribute((alias(\""IA__FcStrPlus\""), visibility(\""default\"")));\n # undef FcStrFree\n-extern __typeof (FcStrFree) FcStrFree __attribute((alias(\""IA__FcStrFree\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrFree) FcStrFree __attribute((alias(\""IA__FcStrFree\""), visibility(\""default\"")));\n # undef FcStrDowncase\n-extern __typeof (FcStrDowncase) FcStrDowncase __attribute((alias(\""IA__FcStrDowncase\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrDowncase) FcStrDowncase __attribute((alias(\""IA__FcStrDowncase\""), visibility(\""default\"")));\n # undef FcStrCmpIgnoreCase\n-extern __typeof (FcStrCmpIgnoreCase) FcStrCmpIgnoreCase __attribute((alias(\""IA__FcStrCmpIgnoreCase\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrCmpIgnoreCase) FcStrCmpIgnoreCase __attribute((alias(\""IA__FcStrCmpIgnoreCase\""), visibility(\""default\"")));\n # undef FcStrCmp\n-extern __typeof (FcStrCmp) FcStrCmp __attribute((alias(\""IA__FcStrCmp\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrCmp) FcStrCmp __attribute((alias(\""IA__FcStrCmp\""), visibility(\""default\"")));\n # undef FcStrStrIgnoreCase\n-extern __typeof (FcStrStrIgnoreCase) FcStrStrIgnoreCase __attribute((alias(\""IA__FcStrStrIgnoreCase\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrStrIgnoreCase) FcStrStrIgnoreCase __attribute((alias(\""IA__FcStrStrIgnoreCase\""), visibility(\""default\"")));\n # undef FcStrStr\n-extern __typeof (FcStrStr) FcStrStr __attribute((alias(\""IA__FcStrStr\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrStr) FcStrStr __attribute((alias(\""IA__FcStrStr\""), visibility(\""default\"")));\n # undef FcUtf8ToUcs4\n-extern __typeof (FcUtf8ToUcs4) FcUtf8ToUcs4 __attribute((alias(\""IA__FcUtf8ToUcs4\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcUtf8ToUcs4) FcUtf8ToUcs4 __attribute((alias(\""IA__FcUtf8ToUcs4\""), visibility(\""default\"")));\n # undef FcUtf8Len\n-extern __typeof (FcUtf8Len) FcUtf8Len __attribute((alias(\""IA__FcUtf8Len\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcUtf8Len) FcUtf8Len __attribute((alias(\""IA__FcUtf8Len\""), visibility(\""default\"")));\n # undef FcUcs4ToUtf8\n-extern __typeof (FcUcs4ToUtf8) FcUcs4ToUtf8 __attribute((alias(\""IA__FcUcs4ToUtf8\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcUcs4ToUtf8) FcUcs4ToUtf8 __attribute((alias(\""IA__FcUcs4ToUtf8\""), visibility(\""default\"")));\n # undef FcUtf16ToUcs4\n-extern __typeof (FcUtf16ToUcs4) FcUtf16ToUcs4 __attribute((alias(\""IA__FcUtf16ToUcs4\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcUtf16ToUcs4) FcUtf16ToUcs4 __attribute((alias(\""IA__FcUtf16ToUcs4\""), visibility(\""default\"")));\n # undef FcUtf16Len\n-extern __typeof (FcUtf16Len) FcUtf16Len __attribute((alias(\""IA__FcUtf16Len\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcUtf16Len) FcUtf16Len __attribute((alias(\""IA__FcUtf16Len\""), visibility(\""default\"")));\n # undef FcStrDirname\n-extern __typeof (FcStrDirname) FcStrDirname __attribute((alias(\""IA__FcStrDirname\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrDirname) FcStrDirname __attribute((alias(\""IA__FcStrDirname\""), visibility(\""default\"")));\n # undef FcStrBasename\n-extern __typeof (FcStrBasename) FcStrBasename __attribute((alias(\""IA__FcStrBasename\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrBasename) FcStrBasename __attribute((alias(\""IA__FcStrBasename\""), visibility(\""default\"")));\n # undef FcStrSetCreate\n-extern __typeof (FcStrSetCreate) FcStrSetCreate __attribute((alias(\""IA__FcStrSetCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrSetCreate) FcStrSetCreate __attribute((alias(\""IA__FcStrSetCreate\""), visibility(\""default\"")));\n # undef FcStrSetMember\n-extern __typeof (FcStrSetMember) FcStrSetMember __attribute((alias(\""IA__FcStrSetMember\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrSetMember) FcStrSetMember __attribute((alias(\""IA__FcStrSetMember\""), visibility(\""default\"")));\n # undef FcStrSetEqual\n-extern __typeof (FcStrSetEqual) FcStrSetEqual __attribute((alias(\""IA__FcStrSetEqual\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrSetEqual) FcStrSetEqual __attribute((alias(\""IA__FcStrSetEqual\""), visibility(\""default\"")));\n # undef FcStrSetAdd\n-extern __typeof (FcStrSetAdd) FcStrSetAdd __attribute((alias(\""IA__FcStrSetAdd\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrSetAdd) FcStrSetAdd __attribute((alias(\""IA__FcStrSetAdd\""), visibility(\""default\"")));\n # undef FcStrSetAddFilename\n-extern __typeof (FcStrSetAddFilename) FcStrSetAddFilename __attribute((alias(\""IA__FcStrSetAddFilename\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrSetAddFilename) FcStrSetAddFilename __attribute((alias(\""IA__FcStrSetAddFilename\""), visibility(\""default\"")));\n # undef FcStrSetDel\n-extern __typeof (FcStrSetDel) FcStrSetDel __attribute((alias(\""IA__FcStrSetDel\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrSetDel) FcStrSetDel __attribute((alias(\""IA__FcStrSetDel\""), visibility(\""default\"")));\n # undef FcStrSetDestroy\n-extern __typeof (FcStrSetDestroy) FcStrSetDestroy __attribute((alias(\""IA__FcStrSetDestroy\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrSetDestroy) FcStrSetDestroy __attribute((alias(\""IA__FcStrSetDestroy\""), visibility(\""default\"")));\n # undef FcStrListCreate\n-extern __typeof (FcStrListCreate) FcStrListCreate __attribute((alias(\""IA__FcStrListCreate\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrListCreate) FcStrListCreate __attribute((alias(\""IA__FcStrListCreate\""), visibility(\""default\"")));\n # undef FcStrListFirst\n-extern __typeof (FcStrListFirst) FcStrListFirst __attribute((alias(\""IA__FcStrListFirst\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrListFirst) FcStrListFirst __attribute((alias(\""IA__FcStrListFirst\""), visibility(\""default\"")));\n # undef FcStrListNext\n-extern __typeof (FcStrListNext) FcStrListNext __attribute((alias(\""IA__FcStrListNext\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrListNext) FcStrListNext __attribute((alias(\""IA__FcStrListNext\""), visibility(\""default\"")));\n # undef FcStrListDone\n-extern __typeof (FcStrListDone) FcStrListDone __attribute((alias(\""IA__FcStrListDone\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcStrListDone) FcStrListDone __attribute((alias(\""IA__FcStrListDone\""), visibility(\""default\"")));\n #endif /* __fcstr__ */\n #ifdef __fcxml__\n # undef FcConfigParseAndLoad\n-extern __typeof (FcConfigParseAndLoad) FcConfigParseAndLoad __attribute((alias(\""IA__FcConfigParseAndLoad\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigParseAndLoad) FcConfigParseAndLoad __attribute((alias(\""IA__FcConfigParseAndLoad\""), visibility(\""default\"")));\n # undef FcConfigParseAndLoadFromMemory\n-extern __typeof (FcConfigParseAndLoadFromMemory) FcConfigParseAndLoadFromMemory __attribute((alias(\""IA__FcConfigParseAndLoadFromMemory\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigParseAndLoadFromMemory) FcConfigParseAndLoadFromMemory __attribute((alias(\""IA__FcConfigParseAndLoadFromMemory\""), visibility(\""default\"")));\n #endif /* __fcxml__ */\n #ifdef __fccfg__\n # undef FcConfigGetRescanInverval\n-extern __typeof (FcConfigGetRescanInverval) FcConfigGetRescanInverval __attribute((alias(\""IA__FcConfigGetRescanInverval\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigGetRescanInverval) FcConfigGetRescanInverval __attribute((alias(\""IA__FcConfigGetRescanInverval\""), visibility(\""default\"")));\n # undef FcConfigSetRescanInverval\n-extern __typeof (FcConfigSetRescanInverval) FcConfigSetRescanInverval __attribute((alias(\""IA__FcConfigSetRescanInverval\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcConfigSetRescanInverval) FcConfigSetRescanInverval __attribute((alias(\""IA__FcConfigSetRescanInverval\""), visibility(\""default\"")));\n #endif /*  */\n #endif /* HAVE_GNUC_ATTRIBUTE */""}<_**next**_>{""sha"": ""884eb4b2e4b59127dce6f91435d1f43e80fa3bdb"", ""filename"": ""third_party/fontconfig/include/src/fcftalias.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcftalias.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcftalias.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/include/src/fcftalias.h?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -1,12 +1,12 @@\n-extern __typeof (FcFreeTypeCharIndex) IA__FcFreeTypeCharIndex FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFreeTypeCharIndex) IA__FcFreeTypeCharIndex __attribute((visibility(\""hidden\"")));\n #define FcFreeTypeCharIndex IA__FcFreeTypeCharIndex\n-extern __typeof (FcFreeTypeCharSetAndSpacing) IA__FcFreeTypeCharSetAndSpacing FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFreeTypeCharSetAndSpacing) IA__FcFreeTypeCharSetAndSpacing __attribute((visibility(\""hidden\"")));\n #define FcFreeTypeCharSetAndSpacing IA__FcFreeTypeCharSetAndSpacing\n-extern __typeof (FcFreeTypeCharSet) IA__FcFreeTypeCharSet FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFreeTypeCharSet) IA__FcFreeTypeCharSet __attribute((visibility(\""hidden\"")));\n #define FcFreeTypeCharSet IA__FcFreeTypeCharSet\n-extern __typeof (FcPatternGetFTFace) IA__FcPatternGetFTFace FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternGetFTFace) IA__FcPatternGetFTFace __attribute((visibility(\""hidden\"")));\n #define FcPatternGetFTFace IA__FcPatternGetFTFace\n-extern __typeof (FcPatternAddFTFace) IA__FcPatternAddFTFace FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcPatternAddFTFace) IA__FcPatternAddFTFace __attribute((visibility(\""hidden\"")));\n #define FcPatternAddFTFace IA__FcPatternAddFTFace\n-extern __typeof (FcFreeTypeQueryFace) IA__FcFreeTypeQueryFace FC_ATTRIBUTE_VISIBILITY_HIDDEN;\n+extern __typeof (FcFreeTypeQueryFace) IA__FcFreeTypeQueryFace __attribute((visibility(\""hidden\"")));\n #define FcFreeTypeQueryFace IA__FcFreeTypeQueryFace""}<_**next**_>{""sha"": ""f5a537d9ce9a10d96baa093560761a8c3e4f5a0c"", ""filename"": ""third_party/fontconfig/include/src/fcftaliastail.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcftaliastail.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcftaliastail.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/include/src/fcftaliastail.h?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -1,20 +1,20 @@\n #if HAVE_GNUC_ATTRIBUTE\n #ifdef __fcfreetype__\n # undef FcFreeTypeCharIndex\n-extern __typeof (FcFreeTypeCharIndex) FcFreeTypeCharIndex __attribute((alias(\""IA__FcFreeTypeCharIndex\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFreeTypeCharIndex) FcFreeTypeCharIndex __attribute((alias(\""IA__FcFreeTypeCharIndex\""), visibility(\""default\"")));\n # undef FcFreeTypeCharSetAndSpacing\n-extern __typeof (FcFreeTypeCharSetAndSpacing) FcFreeTypeCharSetAndSpacing __attribute((alias(\""IA__FcFreeTypeCharSetAndSpacing\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFreeTypeCharSetAndSpacing) FcFreeTypeCharSetAndSpacing __attribute((alias(\""IA__FcFreeTypeCharSetAndSpacing\""), visibility(\""default\"")));\n # undef FcFreeTypeCharSet\n-extern __typeof (FcFreeTypeCharSet) FcFreeTypeCharSet __attribute((alias(\""IA__FcFreeTypeCharSet\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFreeTypeCharSet) FcFreeTypeCharSet __attribute((alias(\""IA__FcFreeTypeCharSet\""), visibility(\""default\"")));\n #endif /* __fcfreetype__ */\n #ifdef __fcpat__\n # undef FcPatternGetFTFace\n-extern __typeof (FcPatternGetFTFace) FcPatternGetFTFace __attribute((alias(\""IA__FcPatternGetFTFace\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternGetFTFace) FcPatternGetFTFace __attribute((alias(\""IA__FcPatternGetFTFace\""), visibility(\""default\"")));\n # undef FcPatternAddFTFace\n-extern __typeof (FcPatternAddFTFace) FcPatternAddFTFace __attribute((alias(\""IA__FcPatternAddFTFace\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcPatternAddFTFace) FcPatternAddFTFace __attribute((alias(\""IA__FcPatternAddFTFace\""), visibility(\""default\"")));\n #endif /* __fcpat__ */\n #ifdef __fcfreetype__\n # undef FcFreeTypeQueryFace\n-extern __typeof (FcFreeTypeQueryFace) FcFreeTypeQueryFace __attribute((alias(\""IA__FcFreeTypeQueryFace\""))) FC_ATTRIBUTE_VISIBILITY_EXPORT;\n+extern __typeof (FcFreeTypeQueryFace) FcFreeTypeQueryFace __attribute((alias(\""IA__FcFreeTypeQueryFace\""), visibility(\""default\"")));\n #endif /*  */\n #endif /* HAVE_GNUC_ATTRIBUTE */""}<_**next**_>{""sha"": ""7ca40966e2bc8679ada22e4ddf2f5b1ded4d8ebc"", ""filename"": ""third_party/fontconfig/include/src/fcobjshash.h"", ""status"": ""modified"", ""additions"": 165, ""deletions"": 169, ""changes"": 334, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcobjshash.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcobjshash.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/include/src/fcobjshash.h?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* ANSI-C code produced by gperf version 3.1 */\n+/* ANSI-C code produced by gperf version 3.0.4 */\n /* Command-line: gperf --pic -m 100 fcobjshash.gperf  */\n /* Computed positions: -k'2-3' */\n \n@@ -26,7 +26,7 @@\n       && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \\\n       && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))\n /* The character set is not based on ISO-646.  */\n-#error \""gperf generated tables don't work with this execution character set. Please report a bug to <bug-gperf@gnu.org>.\""\n+#error \""gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>.\""\n #endif\n \n #line 1 \""fcobjshash.gperf\""\n@@ -37,7 +37,7 @@ int name;\n int id;\n };\n #include <string.h>\n-/* maximum key range = 65, duplicates = 0 */\n+/* maximum key range = 56, duplicates = 0 */\n \n #ifdef __GNUC__\n __inline\n@@ -47,36 +47,36 @@ inline\n #endif\n #endif\n static unsigned int\n-FcObjectTypeHash (register const char *str, register size_t len)\n+FcObjectTypeHash (register const char *str, register unsigned int len)\n {\n   static const unsigned char asso_values[] =\n     {\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69,  9, 21, 18,\n-      33, 21, 69,  6, 36,  0, 69, 69,  0, 24,\n-       9,  0, 21, 69, 33, 15, 18,  0, 69, 69,\n-       0, 21,  6, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n-      69, 69, 69, 69, 69, 69\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 21, 30,  3,\n+      36, 45, 60,  3, 15,  0, 60, 60,  0,  9,\n+       9,  0, 21, 60,  0,  0, 15,  0, 60, 60,\n+       0, 15, 24, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n+      60, 60, 60, 60, 60, 60\n     };\n   return len + asso_values[(unsigned char)str[2]] + asso_values[(unsigned char)str[1]];\n }\n@@ -88,51 +88,49 @@ struct FcObjectTypeNamePool_t\n     char FcObjectTypeNamePool_str7[sizeof(\""foundry\"")];\n     char FcObjectTypeNamePool_str8[sizeof(\""fullname\"")];\n     char FcObjectTypeNamePool_str9[sizeof(\""pixelsize\"")];\n-    char FcObjectTypeNamePool_str10[sizeof(\""size\"")];\n+    char FcObjectTypeNamePool_str10[sizeof(\""prgname\"")];\n     char FcObjectTypeNamePool_str12[sizeof(\""fullnamelang\"")];\n     char FcObjectTypeNamePool_str13[sizeof(\""globaladvance\"")];\n-    char FcObjectTypeNamePool_str14[sizeof(\""slant\"")];\n+    char FcObjectTypeNamePool_str14[sizeof(\""postscriptname\"")];\n     char FcObjectTypeNamePool_str16[sizeof(\""hinting\"")];\n     char FcObjectTypeNamePool_str17[sizeof(\""minspace\"")];\n     char FcObjectTypeNamePool_str18[sizeof(\""hintstyle\"")];\n     char FcObjectTypeNamePool_str19[sizeof(\""fontformat\"")];\n     char FcObjectTypeNamePool_str20[sizeof(\""fontversion\"")];\n     char FcObjectTypeNamePool_str21[sizeof(\""fontfeatures\"")];\n-    char FcObjectTypeNamePool_str22[sizeof(\""lang\"")];\n-    char FcObjectTypeNamePool_str23[sizeof(\""fontvariations\"")];\n+    char FcObjectTypeNamePool_str22[sizeof(\""outline\"")];\n+    char FcObjectTypeNamePool_str23[sizeof(\""autohint\"")];\n     char FcObjectTypeNamePool_str24[sizeof(\""dpi\"")];\n-    char FcObjectTypeNamePool_str25[sizeof(\""outline\"")];\n-    char FcObjectTypeNamePool_str26[sizeof(\""autohint\"")];\n-    char FcObjectTypeNamePool_str27[sizeof(\""weight\"")];\n-    char FcObjectTypeNamePool_str28[sizeof(\""hash\"")];\n-    char FcObjectTypeNamePool_str29[sizeof(\""postscriptname\"")];\n-    char FcObjectTypeNamePool_str31[sizeof(\""rgba\"")];\n-    char FcObjectTypeNamePool_str32[sizeof(\""scale\"")];\n-    char FcObjectTypeNamePool_str33[sizeof(\""matrix\"")];\n-    char FcObjectTypeNamePool_str34[sizeof(\""rasterizer\"")];\n-    char FcObjectTypeNamePool_str35[sizeof(\""scalable\"")];\n-    char FcObjectTypeNamePool_str36[sizeof(\""antialias\"")];\n-    char FcObjectTypeNamePool_str37[sizeof(\""spacing\"")];\n-    char FcObjectTypeNamePool_str38[sizeof(\""width\"")];\n-    char FcObjectTypeNamePool_str39[sizeof(\""family\"")];\n-    char FcObjectTypeNamePool_str40[sizeof(\""capability\"")];\n-    char FcObjectTypeNamePool_str41[sizeof(\""namelang\"")];\n-    char FcObjectTypeNamePool_str42[sizeof(\""aspect\"")];\n-    char FcObjectTypeNamePool_str43[sizeof(\""familylang\"")];\n-    char FcObjectTypeNamePool_str44[sizeof(\""style\"")];\n-    char FcObjectTypeNamePool_str46[sizeof(\""prgname\"")];\n-    char FcObjectTypeNamePool_str47[sizeof(\""index\"")];\n-    char FcObjectTypeNamePool_str48[sizeof(\""stylelang\"")];\n-    char FcObjectTypeNamePool_str49[sizeof(\""decorative\"")];\n-    char FcObjectTypeNamePool_str50[sizeof(\""variable\"")];\n-    char FcObjectTypeNamePool_str51[sizeof(\""symbol\"")];\n-    char FcObjectTypeNamePool_str52[sizeof(\""charset\"")];\n-    char FcObjectTypeNamePool_str53[sizeof(\""embolden\"")];\n-    char FcObjectTypeNamePool_str54[sizeof(\""charwidth\"")];\n-    char FcObjectTypeNamePool_str55[sizeof(\""charheight\"")];\n-    char FcObjectTypeNamePool_str59[sizeof(\""embeddedbitmap\"")];\n-    char FcObjectTypeNamePool_str60[sizeof(\""lcdfilter\"")];\n-    char FcObjectTypeNamePool_str68[sizeof(\""verticallayout\"")];\n+    char FcObjectTypeNamePool_str25[sizeof(\""hash\"")];\n+    char FcObjectTypeNamePool_str26[sizeof(\""slant\"")];\n+    char FcObjectTypeNamePool_str27[sizeof(\""aspect\"")];\n+    char FcObjectTypeNamePool_str28[sizeof(\""size\"")];\n+    char FcObjectTypeNamePool_str29[sizeof(\""scale\"")];\n+    char FcObjectTypeNamePool_str30[sizeof(\""symbol\"")];\n+    char FcObjectTypeNamePool_str31[sizeof(\""rasterizer\"")];\n+    char FcObjectTypeNamePool_str32[sizeof(\""scalable\"")];\n+    char FcObjectTypeNamePool_str33[sizeof(\""antialias\"")];\n+    char FcObjectTypeNamePool_str34[sizeof(\""lang\"")];\n+    char FcObjectTypeNamePool_str35[sizeof(\""style\"")];\n+    char FcObjectTypeNamePool_str36[sizeof(\""family\"")];\n+    char FcObjectTypeNamePool_str37[sizeof(\""rgba\"")];\n+    char FcObjectTypeNamePool_str38[sizeof(\""namelang\"")];\n+    char FcObjectTypeNamePool_str39[sizeof(\""stylelang\"")];\n+    char FcObjectTypeNamePool_str40[sizeof(\""familylang\"")];\n+    char FcObjectTypeNamePool_str41[sizeof(\""width\"")];\n+    char FcObjectTypeNamePool_str42[sizeof(\""matrix\"")];\n+    char FcObjectTypeNamePool_str43[sizeof(\""charset\"")];\n+    char FcObjectTypeNamePool_str45[sizeof(\""charwidth\"")];\n+    char FcObjectTypeNamePool_str46[sizeof(\""charheight\"")];\n+    char FcObjectTypeNamePool_str47[sizeof(\""embolden\"")];\n+    char FcObjectTypeNamePool_str48[sizeof(\""lcdfilter\"")];\n+    char FcObjectTypeNamePool_str49[sizeof(\""spacing\"")];\n+    char FcObjectTypeNamePool_str50[sizeof(\""index\"")];\n+    char FcObjectTypeNamePool_str51[sizeof(\""weight\"")];\n+    char FcObjectTypeNamePool_str52[sizeof(\""capability\"")];\n+    char FcObjectTypeNamePool_str53[sizeof(\""embeddedbitmap\"")];\n+    char FcObjectTypeNamePool_str58[sizeof(\""decorative\"")];\n+    char FcObjectTypeNamePool_str59[sizeof(\""verticallayout\"")];\n   };\n static const struct FcObjectTypeNamePool_t FcObjectTypeNamePool_contents =\n   {\n@@ -141,182 +139,180 @@ static const struct FcObjectTypeNamePool_t FcObjectTypeNamePool_contents =\n     \""foundry\"",\n     \""fullname\"",\n     \""pixelsize\"",\n-    \""size\"",\n+    \""prgname\"",\n     \""fullnamelang\"",\n     \""globaladvance\"",\n-    \""slant\"",\n+    \""postscriptname\"",\n     \""hinting\"",\n     \""minspace\"",\n     \""hintstyle\"",\n     \""fontformat\"",\n     \""fontversion\"",\n     \""fontfeatures\"",\n-    \""lang\"",\n-    \""fontvariations\"",\n-    \""dpi\"",\n     \""outline\"",\n     \""autohint\"",\n-    \""weight\"",\n+    \""dpi\"",\n     \""hash\"",\n-    \""postscriptname\"",\n-    \""rgba\"",\n+    \""slant\"",\n+    \""aspect\"",\n+    \""size\"",\n     \""scale\"",\n-    \""matrix\"",\n+    \""symbol\"",\n     \""rasterizer\"",\n     \""scalable\"",\n     \""antialias\"",\n-    \""spacing\"",\n-    \""width\"",\n+    \""lang\"",\n+    \""style\"",\n     \""family\"",\n-    \""capability\"",\n+    \""rgba\"",\n     \""namelang\"",\n-    \""aspect\"",\n-    \""familylang\"",\n-    \""style\"",\n-    \""prgname\"",\n-    \""index\"",\n     \""stylelang\"",\n-    \""decorative\"",\n-    \""variable\"",\n-    \""symbol\"",\n+    \""familylang\"",\n+    \""width\"",\n+    \""matrix\"",\n     \""charset\"",\n-    \""embolden\"",\n     \""charwidth\"",\n     \""charheight\"",\n-    \""embeddedbitmap\"",\n+    \""embolden\"",\n     \""lcdfilter\"",\n+    \""spacing\"",\n+    \""index\"",\n+    \""weight\"",\n+    \""capability\"",\n+    \""embeddedbitmap\"",\n+    \""decorative\"",\n     \""verticallayout\""\n   };\n #define FcObjectTypeNamePool ((const char *) &FcObjectTypeNamePool_contents)\n+#ifdef __GNUC__\n+__inline\n+#if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__\n+__attribute__ ((__gnu_inline__))\n+#endif\n+#endif\n const struct FcObjectTypeInfo *\n-FcObjectTypeLookup (register const char *str, register size_t len)\n+FcObjectTypeLookup (register const char *str, register unsigned int len)\n {\n   enum\n     {\n-      TOTAL_KEYWORDS = 50,\n+      TOTAL_KEYWORDS = 48,\n       MIN_WORD_LENGTH = 3,\n       MAX_WORD_LENGTH = 14,\n       MIN_HASH_VALUE = 4,\n-      MAX_HASH_VALUE = 68\n+      MAX_HASH_VALUE = 59\n     };\n \n   static const struct FcObjectTypeInfo wordlist[] =\n     {\n       {-1}, {-1}, {-1}, {-1},\n #line 38 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str4,FC_FILE_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str4,FC_FILE_OBJECT},\n #line 64 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str5,FC_COLOR_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str5,FC_COLOR_OBJECT},\n       {-1},\n #line 31 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str7,FC_FOUNDRY_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str7,FC_FOUNDRY_OBJECT},\n #line 22 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str8,FC_FULLNAME_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str8,FC_FULLNAME_OBJECT},\n #line 29 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str9,FC_PIXEL_SIZE_OBJECT},\n-#line 27 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str10,FC_SIZE_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str9,FC_PIXEL_SIZE_OBJECT},\n+#line 61 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str10,FC_PRGNAME_OBJECT},\n       {-1},\n #line 23 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str12,FC_FULLNAMELANG_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str12,FC_FULLNAMELANG_OBJECT},\n #line 37 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str13,FC_GLOBAL_ADVANCE_OBJECT},\n-#line 24 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str14,FC_SLANT_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str13,FC_GLOBAL_ADVANCE_OBJECT},\n+#line 63 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str14,FC_POSTSCRIPT_NAME_OBJECT},\n       {-1},\n #line 34 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str16,FC_HINTING_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str16,FC_HINTING_OBJECT},\n #line 46 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str17,FC_MINSPACE_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str17,FC_MINSPACE_OBJECT},\n #line 33 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str18,FC_HINT_STYLE_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str18,FC_HINT_STYLE_OBJECT},\n #line 54 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str19,FC_FONTFORMAT_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str19,FC_FONTFORMAT_OBJECT},\n #line 52 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str20,FC_FONTVERSION_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str20,FC_FONTVERSION_OBJECT},\n #line 60 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str21,FC_FONT_FEATURES_OBJECT},\n-#line 51 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str22,FC_LANG_OBJECT},\n-#line 66 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str23,FC_FONT_VARIATIONS_OBJECT},\n-#line 43 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str24,FC_DPI_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str21,FC_FONT_FEATURES_OBJECT},\n #line 41 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str25,FC_OUTLINE_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str22,FC_OUTLINE_OBJECT},\n #line 36 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str26,FC_AUTOHINT_OBJECT},\n-#line 25 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str27,FC_WEIGHT_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str23,FC_AUTOHINT_OBJECT},\n+#line 43 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str24,FC_DPI_OBJECT},\n #line 62 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str28,FC_HASH_OBJECT},\n-#line 63 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str29,FC_POSTSCRIPT_NAME_OBJECT},\n-      {-1},\n-#line 44 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str31,FC_RGBA_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str25,FC_HASH_OBJECT},\n+#line 24 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str26,FC_SLANT_OBJECT},\n+#line 28 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str27,FC_ASPECT_OBJECT},\n+#line 27 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str28,FC_SIZE_OBJECT},\n #line 45 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str32,FC_SCALE_OBJECT},\n-#line 49 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str33,FC_MATRIX_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str29,FC_SCALE_OBJECT},\n+#line 65 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str30,FC_SYMBOL_OBJECT},\n #line 40 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str34,FC_RASTERIZER_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str31,FC_RASTERIZER_OBJECT},\n #line 42 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str35,FC_SCALABLE_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str32,FC_SCALABLE_OBJECT},\n #line 32 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str36,FC_ANTIALIAS_OBJECT},\n-#line 30 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str37,FC_SPACING_OBJECT},\n-#line 26 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str38,FC_WIDTH_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str33,FC_ANTIALIAS_OBJECT},\n+#line 51 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str34,FC_LANG_OBJECT},\n+#line 20 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str35,FC_STYLE_OBJECT},\n #line 18 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str39,FC_FAMILY_OBJECT},\n-#line 53 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str40,FC_CAPABILITY_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str36,FC_FAMILY_OBJECT},\n+#line 44 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str37,FC_RGBA_OBJECT},\n #line 59 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str41,FC_NAMELANG_OBJECT},\n-#line 28 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str42,FC_ASPECT_OBJECT},\n-#line 19 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str43,FC_FAMILYLANG_OBJECT},\n-#line 20 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str44,FC_STYLE_OBJECT},\n-      {-1},\n-#line 61 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str46,FC_PRGNAME_OBJECT},\n-#line 39 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str47,FC_INDEX_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str38,FC_NAMELANG_OBJECT},\n #line 21 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str48,FC_STYLELANG_OBJECT},\n-#line 57 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str49,FC_DECORATIVE_OBJECT},\n-#line 67 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str50,FC_VARIABLE_OBJECT},\n-#line 65 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str51,FC_SYMBOL_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str39,FC_STYLELANG_OBJECT},\n+#line 19 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str40,FC_FAMILYLANG_OBJECT},\n+#line 26 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str41,FC_WIDTH_OBJECT},\n+#line 49 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str42,FC_MATRIX_OBJECT},\n #line 50 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str52,FC_CHARSET_OBJECT},\n-#line 55 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str53,FC_EMBOLDEN_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str43,FC_CHARSET_OBJECT},\n+      {-1},\n #line 47 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str54,FC_CHARWIDTH_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str45,FC_CHARWIDTH_OBJECT},\n #line 48 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str55,FC_CHAR_HEIGHT_OBJECT},\n-      {-1}, {-1}, {-1},\n-#line 56 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str59,FC_EMBEDDED_BITMAP_OBJECT},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str46,FC_CHAR_HEIGHT_OBJECT},\n+#line 55 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str47,FC_EMBOLDEN_OBJECT},\n #line 58 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str60,FC_LCD_FILTER_OBJECT},\n-      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str48,FC_LCD_FILTER_OBJECT},\n+#line 30 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str49,FC_SPACING_OBJECT},\n+#line 39 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str50,FC_INDEX_OBJECT},\n+#line 25 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str51,FC_WEIGHT_OBJECT},\n+#line 53 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str52,FC_CAPABILITY_OBJECT},\n+#line 56 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str53,FC_EMBEDDED_BITMAP_OBJECT},\n+      {-1}, {-1}, {-1}, {-1},\n+#line 57 \""fcobjshash.gperf\""\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str58,FC_DECORATIVE_OBJECT},\n #line 35 \""fcobjshash.gperf\""\n-      {(int)(size_t)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str68,FC_VERTICAL_LAYOUT_OBJECT}\n+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str59,FC_VERTICAL_LAYOUT_OBJECT}\n     };\n \n   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n     {\n-      register unsigned int key = FcObjectTypeHash (str, len);\n+      register int key = FcObjectTypeHash (str, len);\n \n-      if (key <= MAX_HASH_VALUE)\n+      if (key <= MAX_HASH_VALUE && key >= 0)\n         {\n           register int o = wordlist[key].name;\n           if (o >= 0)""}<_**next**_>{""sha"": ""e2ded13c465a0f2730679b6e3eae5c4064e5557e"", ""filename"": ""third_party/fontconfig/include/src/fcstdint.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcstdint.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e/third_party/fontconfig/include/src/fcstdint.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/fontconfig/include/src/fcstdint.h?ref=f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e"", ""patch"": ""@@ -1,8 +1,8 @@\n #ifndef _FONTCONFIG_SRC_FCSTDINT_H\n #define _FONTCONFIG_SRC_FCSTDINT_H 1\n #ifndef _GENERATED_STDINT_H\n-#define _GENERATED_STDINT_H \""fontconfig 2.13.0\""\n-/* generated using gnu compiler gcc (Debian 7.3.0-21) 7.3.0 */\n+#define _GENERATED_STDINT_H \""fontconfig 2.12.6\""\n+/* generated using gnu compiler gcc (Debian 6.3.0-18) 6.3.0 20170516 */\n #define _STDINT_HAVE_STDINT_H 1\n #include <stdint.h>\n #endif""}"," void SetUpFontconfig() {
  FilePath dir_module;
  PathService::Get(DIR_MODULE, &dir_module);
  FilePath font_cache = dir_module.Append(""fontconfig_caches"");
  FilePath test_fonts = dir_module.Append(""test_fonts"");
  std::string fonts_conf = ReplaceStringPlaceholders(
      kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);

  FcConfig* config = FcConfigCreate();
  CHECK(config);
#if FC_VERSION >= 21205
  CHECK(FcConfigParseAndLoadFromMemory(
      config, reinterpret_cast<const FcChar8*>(fonts_conf.c_str()), FcTrue));
#else
  FilePath temp;
  CHECK(CreateTemporaryFile(&temp));
  CHECK(WriteFile(temp, fonts_conf.c_str(), fonts_conf.size()));
  CHECK(FcConfigParseAndLoad(
      config, reinterpret_cast<const FcChar8*>(temp.value().c_str()), FcTrue));
  CHECK(DeleteFile(temp, false));
#endif
  CHECK(FcConfigBuildFonts(config));
  CHECK(FcConfigSetCurrent(config));

  // Decrement the reference count for |config|.  It's now owned by fontconfig.
  FcConfigDestroy(config);
 }
"," void SetUpFontconfig() {
  std::unique_ptr<Environment> env = Environment::Create();
  if (!env->HasVar(""FONTCONFIG_FILE"")) {
    FilePath dir_module;
    PathService::Get(DIR_MODULE, &dir_module);
    FilePath font_cache = dir_module.Append(""fontconfig_caches"");
    FilePath test_fonts = dir_module.Append(""test_fonts"");
    std::string fonts_conf = ReplaceStringPlaceholders(
        kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);
    FilePath fonts_conf_file_temp;
    CHECK(CreateTemporaryFileInDir(dir_module, &fonts_conf_file_temp));
    CHECK(
        WriteFile(fonts_conf_file_temp, fonts_conf.c_str(), fonts_conf.size()));
    FilePath fonts_conf_file = dir_module.Append(""fonts.conf"");
    CHECK(ReplaceFile(fonts_conf_file_temp, fonts_conf_file, nullptr));
    env->SetVar(""FONTCONFIG_FILE"", fonts_conf_file.value());
  }
  CHECK(FcInit());
 }
",C,"  FilePath dir_module;
  PathService::Get(DIR_MODULE, &dir_module);
  FilePath font_cache = dir_module.Append(""fontconfig_caches"");
  FilePath test_fonts = dir_module.Append(""test_fonts"");
  std::string fonts_conf = ReplaceStringPlaceholders(
      kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);

  FcConfig* config = FcConfigCreate();
  CHECK(config);
#if FC_VERSION >= 21205
  CHECK(FcConfigParseAndLoadFromMemory(
      config, reinterpret_cast<const FcChar8*>(fonts_conf.c_str()), FcTrue));
#else
  FilePath temp;
  CHECK(CreateTemporaryFile(&temp));
  CHECK(WriteFile(temp, fonts_conf.c_str(), fonts_conf.size()));
  CHECK(FcConfigParseAndLoad(
      config, reinterpret_cast<const FcChar8*>(temp.value().c_str()), FcTrue));
  CHECK(DeleteFile(temp, false));
#endif
  CHECK(FcConfigBuildFonts(config));
  CHECK(FcConfigSetCurrent(config));

  // Decrement the reference count for |config|.  It's now owned by fontconfig.
  FcConfigDestroy(config);
","  std::unique_ptr<Environment> env = Environment::Create();
  if (!env->HasVar(""FONTCONFIG_FILE"")) {
    FilePath dir_module;
    PathService::Get(DIR_MODULE, &dir_module);
    FilePath font_cache = dir_module.Append(""fontconfig_caches"");
    FilePath test_fonts = dir_module.Append(""test_fonts"");
    std::string fonts_conf = ReplaceStringPlaceholders(
        kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);
    FilePath fonts_conf_file_temp;
    CHECK(CreateTemporaryFileInDir(dir_module, &fonts_conf_file_temp));
    CHECK(
        WriteFile(fonts_conf_file_temp, fonts_conf.c_str(), fonts_conf.size()));
    FilePath fonts_conf_file = dir_module.Append(""fonts.conf"");
    CHECK(ReplaceFile(fonts_conf_file_temp, fonts_conf_file, nullptr));
    env->SetVar(""FONTCONFIG_FILE"", fonts_conf_file.value());
  }
  CHECK(FcInit());
",,"@@ -7,7 +7,6 @@
 #include <fontconfig/fontconfig.h>
 
 #include ""base/base_paths.h""
-#include ""base/environment.h""
 #include ""base/files/file_path.h""
 #include ""base/files/file_util.h""
 #include ""base/logging.h""
@@ -382,35 +381,31 @@ const char kFontsConfTemplate[] = R""(<?xml version=""1.0""?>
 }  // namespace
 
 void SetUpFontconfig() {
-  // TODO(thomasanderson): Use FONTCONFIG_SYSROOT to avoid having to write
-  // a new fonts.conf with updated paths.
-  std::unique_ptr<Environment> env = Environment::Create();
-  if (!env->HasVar(""FONTCONFIG_FILE"")) {
-    // fonts.conf must be generated on-the-fly since it contains absolute paths
-    // which may be different if
-    //   1. The user moves/renames their build directory (or any parent dirs).
-    //   2. The build directory is mapped on a swarming bot at a location
-    //      different from the one the buildbot used.
-    FilePath dir_module;
-    PathService::Get(DIR_MODULE, &dir_module);
-    FilePath font_cache = dir_module.Append(""fontconfig_caches"");
-    FilePath test_fonts = dir_module.Append(""test_fonts"");
-    std::string fonts_conf = ReplaceStringPlaceholders(
-        kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);
-
-    // Write the data to a different file and then atomically rename it to
-    // fonts.conf.  This avoids the file being in a bad state when different
-    // parallel tests call this function at the same time.
-    FilePath fonts_conf_file_temp;
-    CHECK(CreateTemporaryFileInDir(dir_module, &fonts_conf_file_temp));
-    CHECK(
-        WriteFile(fonts_conf_file_temp, fonts_conf.c_str(), fonts_conf.size()));
-    FilePath fonts_conf_file = dir_module.Append(""fonts.conf"");
-    CHECK(ReplaceFile(fonts_conf_file_temp, fonts_conf_file, nullptr));
-    env->SetVar(""FONTCONFIG_FILE"", fonts_conf_file.value());
-  }
-
-  CHECK(FcInit());
+  FilePath dir_module;
+  PathService::Get(DIR_MODULE, &dir_module);
+  FilePath font_cache = dir_module.Append(""fontconfig_caches"");
+  FilePath test_fonts = dir_module.Append(""test_fonts"");
+  std::string fonts_conf = ReplaceStringPlaceholders(
+      kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);
+
+  FcConfig* config = FcConfigCreate();
+  CHECK(config);
+#if FC_VERSION >= 21205
+  CHECK(FcConfigParseAndLoadFromMemory(
+      config, reinterpret_cast<const FcChar8*>(fonts_conf.c_str()), FcTrue));
+#else
+  FilePath temp;
+  CHECK(CreateTemporaryFile(&temp));
+  CHECK(WriteFile(temp, fonts_conf.c_str(), fonts_conf.size()));
+  CHECK(FcConfigParseAndLoad(
+      config, reinterpret_cast<const FcChar8*>(temp.value().c_str()), FcTrue));
+  CHECK(DeleteFile(temp, false));
+#endif
+  CHECK(FcConfigBuildFonts(config));
+  CHECK(FcConfigSetCurrent(config));
+
+  // Decrement the reference count for |config|.  It's now owned by fontconfig.
+  FcConfigDestroy(config);
 }
 
 void TearDownFontconfig() {",Chrome,f5ad97cbf2b2b465dc61d8f93820c7e6cab49e4e,123d0536410a20de923a3c8931238979b838b90a,1," void SetUpFontconfig() {
//flaw_line_below:
  // TODO(thomasanderson): Use FONTCONFIG_SYSROOT to avoid having to write
//flaw_line_below:
  // a new fonts.conf with updated paths.
//flaw_line_below:
  std::unique_ptr<Environment> env = Environment::Create();
//flaw_line_below:
  if (!env->HasVar(""FONTCONFIG_FILE"")) {
//flaw_line_below:
    // fonts.conf must be generated on-the-fly since it contains absolute paths
//flaw_line_below:
    // which may be different if
//flaw_line_below:
    //   1. The user moves/renames their build directory (or any parent dirs).
//flaw_line_below:
    //   2. The build directory is mapped on a swarming bot at a location
//flaw_line_below:
    //      different from the one the buildbot used.
//flaw_line_below:
    FilePath dir_module;
//flaw_line_below:
    PathService::Get(DIR_MODULE, &dir_module);
//flaw_line_below:
    FilePath font_cache = dir_module.Append(""fontconfig_caches"");
//flaw_line_below:
    FilePath test_fonts = dir_module.Append(""test_fonts"");
//flaw_line_below:
    std::string fonts_conf = ReplaceStringPlaceholders(
//flaw_line_below:
        kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);
//flaw_line_below:

//flaw_line_below:
    // Write the data to a different file and then atomically rename it to
//flaw_line_below:
    // fonts.conf.  This avoids the file being in a bad state when different
//flaw_line_below:
    // parallel tests call this function at the same time.
//flaw_line_below:
    FilePath fonts_conf_file_temp;
//flaw_line_below:
    CHECK(CreateTemporaryFileInDir(dir_module, &fonts_conf_file_temp));
//flaw_line_below:
    CHECK(
//flaw_line_below:
        WriteFile(fonts_conf_file_temp, fonts_conf.c_str(), fonts_conf.size()));
//flaw_line_below:
    FilePath fonts_conf_file = dir_module.Append(""fonts.conf"");
//flaw_line_below:
    CHECK(ReplaceFile(fonts_conf_file_temp, fonts_conf_file, nullptr));
//flaw_line_below:
    env->SetVar(""FONTCONFIG_FILE"", fonts_conf_file.value());
//flaw_line_below:
  }
//flaw_line_below:

//flaw_line_below:
  CHECK(FcInit());
//fix_flaw_line_below:
//  FilePath dir_module;
//fix_flaw_line_below:
//  PathService::Get(DIR_MODULE, &dir_module);
//fix_flaw_line_below:
//  FilePath font_cache = dir_module.Append(""fontconfig_caches"");
//fix_flaw_line_below:
//  FilePath test_fonts = dir_module.Append(""test_fonts"");
//fix_flaw_line_below:
//  std::string fonts_conf = ReplaceStringPlaceholders(
//fix_flaw_line_below:
//      kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  FcConfig* config = FcConfigCreate();
//fix_flaw_line_below:
//  CHECK(config);
//fix_flaw_line_below:
//#if FC_VERSION >= 21205
//fix_flaw_line_below:
//  CHECK(FcConfigParseAndLoadFromMemory(
//fix_flaw_line_below:
//      config, reinterpret_cast<const FcChar8*>(fonts_conf.c_str()), FcTrue));
//fix_flaw_line_below:
//#else
//fix_flaw_line_below:
//  FilePath temp;
//fix_flaw_line_below:
//  CHECK(CreateTemporaryFile(&temp));
//fix_flaw_line_below:
//  CHECK(WriteFile(temp, fonts_conf.c_str(), fonts_conf.size()));
//fix_flaw_line_below:
//  CHECK(FcConfigParseAndLoad(
//fix_flaw_line_below:
//      config, reinterpret_cast<const FcChar8*>(temp.value().c_str()), FcTrue));
//fix_flaw_line_below:
//  CHECK(DeleteFile(temp, false));
//fix_flaw_line_below:
//#endif
//fix_flaw_line_below:
//  CHECK(FcConfigBuildFonts(config));
//fix_flaw_line_below:
//  CHECK(FcConfigSetCurrent(config));
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  // Decrement the reference count for |config|.  It's now owned by fontconfig.
//fix_flaw_line_below:
//  FcConfigDestroy(config);
 }
",186248," void SetUpFontconfig() {
  std::unique_ptr<Environment> env = Environment::Create();
  if (!env->HasVar(""FONTCONFIG_FILE"")) {
    FilePath dir_module;
    PathService::Get(DIR_MODULE, &dir_module);
    FilePath font_cache = dir_module.Append(""fontconfig_caches"");
    FilePath test_fonts = dir_module.Append(""test_fonts"");
    std::string fonts_conf = ReplaceStringPlaceholders(
        kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);
    FilePath fonts_conf_file_temp;
    CHECK(CreateTemporaryFileInDir(dir_module, &fonts_conf_file_temp));
    CHECK(
        WriteFile(fonts_conf_file_temp, fonts_conf.c_str(), fonts_conf.size()));
    FilePath fonts_conf_file = dir_module.Append(""fonts.conf"");
    CHECK(ReplaceFile(fonts_conf_file_temp, fonts_conf_file, nullptr));
    env->SetVar(""FONTCONFIG_FILE"", fonts_conf_file.value());
  }
  CHECK(FcInit());
 }
"," void SetUpFontconfig() {
  FilePath dir_module;
  PathService::Get(DIR_MODULE, &dir_module);
  FilePath font_cache = dir_module.Append(""fontconfig_caches"");
  FilePath test_fonts = dir_module.Append(""test_fonts"");
  std::string fonts_conf = ReplaceStringPlaceholders(
      kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);

  FcConfig* config = FcConfigCreate();
  CHECK(config);
#if FC_VERSION >= 21205
  CHECK(FcConfigParseAndLoadFromMemory(
      config, reinterpret_cast<const FcChar8*>(fonts_conf.c_str()), FcTrue));
#else
  FilePath temp;
  CHECK(CreateTemporaryFile(&temp));
  CHECK(WriteFile(temp, fonts_conf.c_str(), fonts_conf.size()));
  CHECK(FcConfigParseAndLoad(
      config, reinterpret_cast<const FcChar8*>(temp.value().c_str()), FcTrue));
  CHECK(DeleteFile(temp, false));
#endif
  CHECK(FcConfigBuildFonts(config));
  CHECK(FcConfigSetCurrent(config));

  // Decrement the reference count for |config|.  It's now owned by fontconfig.
  FcConfigDestroy(config);
 }
","The `SetUpFontconfig` function initializes the Fontconfig environment by first creating a unique pointer to an `Environment` object. It checks if the environment variable ""FONTCONFIG_FILE"" is set; if not, it constructs paths for font cache and test fonts using the module directory. A configuration string is generated from a template and written to a temporary file, which is then renamed to ""fonts.conf"" in the module directory. Finally, the function sets the ""FONTCONFIG_FILE"" variable to the path of the new configuration file and initializes Fontconfig with `FcInit()`, ensuring proper font management.","The function sets up the font configuration environment by creating an environment object and checking for a specific environment variable. If the variable is not present, it constructs paths for font cache and test fonts based on the module's directory. A configuration string is generated and written to a temporary file, which is then renamed to a standard configuration file in the module directory. The function then assigns the path of this configuration file to the environment variable and initializes the font management system, ensuring that fonts are properly configured for use.","The vulnerability in the original code stemmed from the lack of proper handling of font configuration, which could lead to issues such as memory leaks or use-after-free errors. Specifically, the code did not create a dedicated configuration object, relying instead on global state, which could result in undefined behavior if the configuration was modified elsewhere. The fixed code addresses this by explicitly creating a configuration object using `FcConfigCreate()`, ensuring that the configuration is properly managed. Additionally, it includes checks for successful parsing and loading of the configuration, and it properly destroys the configuration object with `FcConfigDestroy(config)` to prevent memory leaks.","The vulnerability in the original code arose from improper management of font configuration, which could lead to memory issues such as use-after-free errors. This was primarily due to the reliance on global state without creating a dedicated configuration object, making it susceptible to unintended modifications. The fixed code addresses this by explicitly creating a configuration object, ensuring that it is properly initialized and managed. It includes checks for successful loading of the configuration and ensures that the object is destroyed correctly, thereby preventing memory leaks and enhancing overall stability in font management.","The vulnerability was fixed by introducing a dedicated configuration object created with `FcConfigCreate()`, which ensures proper management of font settings. The code now checks for successful creation of this configuration object and uses `FcConfigParseAndLoadFromMemory` or `FcConfigParseAndLoad` to load the font configuration from memory or a temporary file, respectively. This approach prevents unintended modifications to global state. Additionally, the code includes a call to `FcConfigDestroy(config)` at the end, which properly deallocates the configuration object, thus preventing memory leaks and ensuring that resources are managed correctly.","The vulnerability was addressed by implementing a dedicated configuration object that ensures proper management of font settings, thereby preventing issues related to memory misuse. The updated code includes checks to confirm the successful creation and loading of this configuration, which mitigates the risk of unintended modifications to shared resources. Additionally, the code ensures that the configuration object is properly deallocated at the end of its lifecycle, which prevents memory leaks and enhances overall stability. This structured approach to resource management significantly reduces the likelihood of errors and improves the reliability of the font handling process.","CWE-404, CWE-401, CWE-119, CWE-789, CWE-908, CWE-772, CWE-415, CWE-416, CWE-457, CWE-665",N,-1.0,"4,4","5,5","4,4","4,4"
7,7,186540,186540,,Remote,Not required,,CVE-2016-1664,https://www.cvedetails.com/cve/CVE-2016-1664/,CWE-254,Medium,,Partial,,2016-05-14,4.3,"The HistoryController::UpdateForCommit function in content/renderer/history_controller.cc in Google Chrome before 50.0.2661.94 mishandles the interaction between subframe forward navigations and other forward navigations, which allows remote attackers to spoof the address bar via a crafted web site.",2018-10-30,,8,https://github.com/chromium/chromium/commit/bb3548ef2fcdb58f9bc638bb5a3c379320fdd0e0,bb3548ef2fcdb58f9bc638bb5a3c379320fdd0e0,"Fix HistoryEntry corruption when commit isn't for provisional entry.

BUG=597322
TEST=See bug for repro steps.

Review URL: https://codereview.chromium.org/1848103004

Cr-Commit-Position: refs/heads/master@{#384659}",1,content/renderer/history_controller.cc,"{""sha"": ""0a6cd634f3546944f4ee4dc7a8bdad8bc6a80168"", ""filename"": ""content/renderer/history_controller.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 1, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/bb3548ef2fcdb58f9bc638bb5a3c379320fdd0e0/content/renderer/history_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bb3548ef2fcdb58f9bc638bb5a3c379320fdd0e0/content/renderer/history_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/history_controller.cc?ref=bb3548ef2fcdb58f9bc638bb5a3c379320fdd0e0"", ""patch"": ""@@ -187,7 +187,14 @@ void HistoryController::UpdateForCommit(RenderFrameImpl* frame,\n     case blink::WebBackForwardCommit:\n       if (!provisional_entry_)\n         return;\n-      current_entry_.reset(provisional_entry_.release());\n+      // Commit the provisional entry, but only if this back/forward item\n+      // matches it.  Otherwise it could be a commit from an earlier attempt to\n+      // go back/forward, and we should leave the provisional entry in place.\n+      if (HistoryEntry::HistoryNode* node =\n+              provisional_entry_->GetHistoryNodeForFrame(frame)) {\n+        if (node->item().itemSequenceNumber() == item.itemSequenceNumber())\n+          current_entry_.reset(provisional_entry_.release());\n+      }\n       if (HistoryEntry::HistoryNode* node =\n               current_entry_->GetHistoryNodeForFrame(frame)) {\n         node->set_item(item);""}","void HistoryController::UpdateForCommit(RenderFrameImpl* frame,
                                        const WebHistoryItem& item,
                                        WebHistoryCommitType commit_type,
                                        bool navigation_within_page) {
  switch (commit_type) {
     case blink::WebBackForwardCommit:
       if (!provisional_entry_)
         return;
      // Commit the provisional entry, but only if this back/forward item
      // matches it.  Otherwise it could be a commit from an earlier attempt to
      // go back/forward, and we should leave the provisional entry in place.
      if (HistoryEntry::HistoryNode* node =
              provisional_entry_->GetHistoryNodeForFrame(frame)) {
        if (node->item().itemSequenceNumber() == item.itemSequenceNumber())
          current_entry_.reset(provisional_entry_.release());
      }
       if (HistoryEntry::HistoryNode* node =
               current_entry_->GetHistoryNodeForFrame(frame)) {
         node->set_item(item);
      }
      break;
    case blink::WebStandardCommit:
      CreateNewBackForwardItem(frame, item, navigation_within_page);
      break;
    case blink::WebInitialCommitInChildFrame:
      UpdateForInitialLoadInChildFrame(frame, item);
      break;
    case blink::WebHistoryInertCommit:
      if (current_entry_) {
        if (HistoryEntry::HistoryNode* node =
                current_entry_->GetHistoryNodeForFrame(frame)) {
          if (!navigation_within_page)
            node->RemoveChildren();
          node->set_item(item);
        }
      }
      break;
    default:
      NOTREACHED() << ""Invalid commit type: "" << commit_type;
  }
}
","void HistoryController::UpdateForCommit(RenderFrameImpl* frame,
                                        const WebHistoryItem& item,
                                        WebHistoryCommitType commit_type,
                                        bool navigation_within_page) {
  switch (commit_type) {
     case blink::WebBackForwardCommit:
       if (!provisional_entry_)
         return;
      current_entry_.reset(provisional_entry_.release());
       if (HistoryEntry::HistoryNode* node =
               current_entry_->GetHistoryNodeForFrame(frame)) {
         node->set_item(item);
      }
      break;
    case blink::WebStandardCommit:
      CreateNewBackForwardItem(frame, item, navigation_within_page);
      break;
    case blink::WebInitialCommitInChildFrame:
      UpdateForInitialLoadInChildFrame(frame, item);
      break;
    case blink::WebHistoryInertCommit:
      if (current_entry_) {
        if (HistoryEntry::HistoryNode* node =
                current_entry_->GetHistoryNodeForFrame(frame)) {
          if (!navigation_within_page)
            node->RemoveChildren();
          node->set_item(item);
        }
      }
      break;
    default:
      NOTREACHED() << ""Invalid commit type: "" << commit_type;
  }
}
",C,"      // Commit the provisional entry, but only if this back/forward item
      // matches it.  Otherwise it could be a commit from an earlier attempt to
      // go back/forward, and we should leave the provisional entry in place.
      if (HistoryEntry::HistoryNode* node =
              provisional_entry_->GetHistoryNodeForFrame(frame)) {
        if (node->item().itemSequenceNumber() == item.itemSequenceNumber())
          current_entry_.reset(provisional_entry_.release());
      }
","      current_entry_.reset(provisional_entry_.release());
",,"@@ -187,7 +187,14 @@ void HistoryController::UpdateForCommit(RenderFrameImpl* frame,
     case blink::WebBackForwardCommit:
       if (!provisional_entry_)
         return;
-      current_entry_.reset(provisional_entry_.release());
+      // Commit the provisional entry, but only if this back/forward item
+      // matches it.  Otherwise it could be a commit from an earlier attempt to
+      // go back/forward, and we should leave the provisional entry in place.
+      if (HistoryEntry::HistoryNode* node =
+              provisional_entry_->GetHistoryNodeForFrame(frame)) {
+        if (node->item().itemSequenceNumber() == item.itemSequenceNumber())
+          current_entry_.reset(provisional_entry_.release());
+      }
       if (HistoryEntry::HistoryNode* node =
               current_entry_->GetHistoryNodeForFrame(frame)) {
         node->set_item(item);",Chrome,bb3548ef2fcdb58f9bc638bb5a3c379320fdd0e0,66605a610bce190e818ebfc73913a126c025ffb3,1,"void HistoryController::UpdateForCommit(RenderFrameImpl* frame,
                                        const WebHistoryItem& item,
                                        WebHistoryCommitType commit_type,
                                        bool navigation_within_page) {
  switch (commit_type) {
     case blink::WebBackForwardCommit:
       if (!provisional_entry_)
         return;
//flaw_line_below:
      current_entry_.reset(provisional_entry_.release());
//fix_flaw_line_below:
//      // Commit the provisional entry, but only if this back/forward item
//fix_flaw_line_below:
//      // matches it.  Otherwise it could be a commit from an earlier attempt to
//fix_flaw_line_below:
//      // go back/forward, and we should leave the provisional entry in place.
//fix_flaw_line_below:
//      if (HistoryEntry::HistoryNode* node =
//fix_flaw_line_below:
//              provisional_entry_->GetHistoryNodeForFrame(frame)) {
//fix_flaw_line_below:
//        if (node->item().itemSequenceNumber() == item.itemSequenceNumber())
//fix_flaw_line_below:
//          current_entry_.reset(provisional_entry_.release());
//fix_flaw_line_below:
//      }
       if (HistoryEntry::HistoryNode* node =
               current_entry_->GetHistoryNodeForFrame(frame)) {
         node->set_item(item);
      }
      break;
    case blink::WebStandardCommit:
      CreateNewBackForwardItem(frame, item, navigation_within_page);
      break;
    case blink::WebInitialCommitInChildFrame:
      UpdateForInitialLoadInChildFrame(frame, item);
      break;
    case blink::WebHistoryInertCommit:
      // Even for inert commits (e.g., location.replace, client redirects), make
      // sure the current entry gets updated, if there is one.
      if (current_entry_) {
        if (HistoryEntry::HistoryNode* node =
                current_entry_->GetHistoryNodeForFrame(frame)) {
          // Inert commits that reset the page without changing the item (e.g.,
          // reloads, location.replace) shouldn't keep the old subtree.
          if (!navigation_within_page)
            node->RemoveChildren();
          node->set_item(item);
        }
      }
      break;
    default:
      NOTREACHED() << ""Invalid commit type: "" << commit_type;
  }
}
",186540,"void HistoryController::UpdateForCommit(RenderFrameImpl* frame,
                                        const WebHistoryItem& item,
                                        WebHistoryCommitType commit_type,
                                        bool navigation_within_page) {
  switch (commit_type) {
     case blink::WebBackForwardCommit:
       if (!provisional_entry_)
         return;
      current_entry_.reset(provisional_entry_.release());
       if (HistoryEntry::HistoryNode* node =
               current_entry_->GetHistoryNodeForFrame(frame)) {
         node->set_item(item);
      }
      break;
    case blink::WebStandardCommit:
      CreateNewBackForwardItem(frame, item, navigation_within_page);
      break;
    case blink::WebInitialCommitInChildFrame:
      UpdateForInitialLoadInChildFrame(frame, item);
      break;
    case blink::WebHistoryInertCommit:
      if (current_entry_) {
        if (HistoryEntry::HistoryNode* node =
                current_entry_->GetHistoryNodeForFrame(frame)) {
          if (!navigation_within_page)
            node->RemoveChildren();
          node->set_item(item);
        }
      }
      break;
    default:
      NOTREACHED() << ""Invalid commit type: "" << commit_type;
  }
}
","void HistoryController::UpdateForCommit(RenderFrameImpl* frame,
                                        const WebHistoryItem& item,
                                        WebHistoryCommitType commit_type,
                                        bool navigation_within_page) {
  switch (commit_type) {
     case blink::WebBackForwardCommit:
       if (!provisional_entry_)
         return;
      // Commit the provisional entry, but only if this back/forward item
      // matches it.  Otherwise it could be a commit from an earlier attempt to
      // go back/forward, and we should leave the provisional entry in place.
      if (HistoryEntry::HistoryNode* node =
              provisional_entry_->GetHistoryNodeForFrame(frame)) {
        if (node->item().itemSequenceNumber() == item.itemSequenceNumber())
          current_entry_.reset(provisional_entry_.release());
      }
       if (HistoryEntry::HistoryNode* node =
               current_entry_->GetHistoryNodeForFrame(frame)) {
         node->set_item(item);
      }
      break;
    case blink::WebStandardCommit:
      CreateNewBackForwardItem(frame, item, navigation_within_page);
      break;
    case blink::WebInitialCommitInChildFrame:
      UpdateForInitialLoadInChildFrame(frame, item);
      break;
    case blink::WebHistoryInertCommit:
      if (current_entry_) {
        if (HistoryEntry::HistoryNode* node =
                current_entry_->GetHistoryNodeForFrame(frame)) {
          if (!navigation_within_page)
            node->RemoveChildren();
          node->set_item(item);
        }
      }
      break;
    default:
      NOTREACHED() << ""Invalid commit type: "" << commit_type;
  }
}
","The `UpdateForCommit` function in the `HistoryController` class manages the updating of web history entries based on the type of commit that occurs during navigation. It handles four commit types: `WebBackForwardCommit`, which updates the current entry with a provisional entry's data; `WebStandardCommit`, which creates a new history item; `WebInitialCommitInChildFrame`, which processes initial loads in child frames; and `WebHistoryInertCommit`, which updates the current entry while potentially removing child nodes if navigation is not within the same page. The function ensures that the appropriate history updates are made based on the context of the navigation.","The provided code defines a method that updates web history entries based on different types of navigation events. It processes four distinct scenarios: one that updates the current entry with provisional data, another that creates a new history item for standard navigation, a third that handles initial loads in child frames, and a fourth that updates the current entry while managing child nodes based on whether the navigation is within the same page. The method ensures that the history is accurately maintained according to the context of the user's navigation actions.","The vulnerability in the original code stemmed from the lack of validation when committing a provisional entry during back or forward navigation. Specifically, if the commit type was `WebBackForwardCommit`, the code would reset the current entry without ensuring that the provisional entry matched the intended navigation item, potentially leading to history corruption. The fix introduced a check to compare the sequence number of the item in the provisional entry with the current item before resetting the current entry. This ensures that only valid commits are processed, preventing unintended history modifications and maintaining the integrity of the navigation history.","The vulnerability in the original code arose from the improper handling of navigation events, specifically when committing a provisional entry during back or forward navigation. Without adequate validation, the code could inadvertently reset the current history entry even if the commit did not correspond to the intended provisional entry, leading to potential corruption of the navigation history. The fix implemented a validation step to ensure that the commit only occurs if the provisional entry matches the current navigation item, thereby safeguarding the integrity of the history and preventing unintended modifications during navigation events.","The vulnerability was fixed by adding a validation check before resetting the current entry during a `WebBackForwardCommit`. The updated code now verifies that the sequence number of the item in the provisional entry matches the sequence number of the current item. This is done by retrieving the history node for the frame from the provisional entry and comparing the sequence numbers. If they match, the current entry is reset with the provisional entry; otherwise, the provisional entry remains intact. This ensures that only valid commits are processed, preventing history corruption during navigation.","The vulnerability was addressed by introducing a validation step that checks the integrity of the provisional entry before committing it to the current history. Specifically, the fix ensures that the commit only occurs if the provisional entry corresponds to the intended navigation action, thereby preventing the accidental resetting of the current history entry with an incorrect provisional entry. This additional check safeguards against unintended modifications and maintains the accuracy of the navigation history, ensuring that only valid and relevant entries are processed during back or forward navigation events.","CWE-20, CWE-287, CWE-285, CWE-345, CWE-346, CWE-284, CWE-732, CWE-434, CWE-306, CWE-436",N,-1.0,"4, 4","5, 5","5,4","4,5"
8,8,187149,187149,,Remote,Not required,,CVE-2018-6178,https://www.cvedetails.com/cve/CVE-2018-6178/,CWE-254,Medium,,Partial,,2019-01-09,4.3,Eliding from the wrong side in an infobar in DevTools in Google Chrome prior to 68.0.3440.75 allowed an attacker who convinced a user to install a malicious extension to Hide Chrome Security UI via a crafted Chrome Extension.,2019-01-16,,1,https://github.com/chromium/chromium/commit/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311,fbeba958bb83c05ec8cc54e285a4a9ca10d1b311,"Allow to specify elide behavior for confrim infobar message

Used in ""<extension name> is debugging this browser"" infobar.

Bug: 823194
Change-Id: Iff6627097c020cccca8f7cc3e21a803a41fd8f2c
Reviewed-on: https://chromium-review.googlesource.com/1048064
Commit-Queue: Dmitry Gozman <dgozman@chromium.org>
Reviewed-by: Devlin <rdevlin.cronin@chromium.org>
Reviewed-by: Peter Kasting <pkasting@chromium.org>
Cr-Commit-Position: refs/heads/master@{#557245}",0,chrome/browser/ui/views/infobars/confirm_infobar.cc,"{""sha"": ""d283a99766a4dcf93c3011b9baec4644c81e5590"", ""filename"": ""chrome/browser/devtools/global_confirm_info_bar.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/chrome/browser/devtools/global_confirm_info_bar.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/chrome/browser/devtools/global_confirm_info_bar.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/devtools/global_confirm_info_bar.cc?ref=fbeba958bb83c05ec8cc54e285a4a9ca10d1b311"", ""patch"": ""@@ -28,6 +28,7 @@ class GlobalConfirmInfoBar::DelegateProxy : public ConfirmInfoBarDelegate {\n   // ConfirmInfoBarDelegate overrides\n   infobars::InfoBarDelegate::InfoBarIdentifier GetIdentifier() const override;\n   base::string16 GetMessageText() const override;\n+  gfx::ElideBehavior GetMessageElideBehavior() const override;\n   int GetButtons() const override;\n   base::string16 GetButtonLabel(InfoBarButton button) const override;\n   bool Accept() override;\n@@ -63,6 +64,13 @@ base::string16 GlobalConfirmInfoBar::DelegateProxy::GetMessageText() const {\n                           : base::string16();\n }\n \n+gfx::ElideBehavior\n+GlobalConfirmInfoBar::DelegateProxy::GetMessageElideBehavior() const {\n+  return global_info_bar_\n+             ? global_info_bar_->delegate_->GetMessageElideBehavior()\n+             : ConfirmInfoBarDelegate::GetMessageElideBehavior();\n+}\n+\n int GlobalConfirmInfoBar::DelegateProxy::GetButtons() const {\n   return global_info_bar_ ? global_info_bar_->delegate_->GetButtons()\n                           : 0;""}<_**next**_>{""sha"": ""fdc19ab8c5535dc9c29fe36a73dcf15d5a22830f"", ""filename"": ""chrome/browser/extensions/api/debugger/extension_dev_tools_infobar.cc"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 0, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/chrome/browser/extensions/api/debugger/extension_dev_tools_infobar.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/chrome/browser/extensions/api/debugger/extension_dev_tools_infobar.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/api/debugger/extension_dev_tools_infobar.cc?ref=fbeba958bb83c05ec8cc54e285a4a9ca10d1b311"", ""patch"": ""@@ -30,6 +30,8 @@ class ExtensionDevToolsInfoBarDelegate : public ConfirmInfoBarDelegate {\n   bool ShouldExpire(const NavigationDetails& details) const override;\n   void InfoBarDismissed() override;\n   base::string16 GetMessageText() const override;\n+  gfx::ElideBehavior GetMessageElideBehavior() const override;\n+\n   int GetButtons() const override;\n   bool Cancel() override;\n \n@@ -69,6 +71,14 @@ base::string16 ExtensionDevToolsInfoBarDelegate::GetMessageText() const {\n   return l10n_util::GetStringFUTF16(IDS_DEV_TOOLS_INFOBAR_LABEL, client_name_);\n }\n \n+gfx::ElideBehavior ExtensionDevToolsInfoBarDelegate::GetMessageElideBehavior()\n+    const {\n+  // The important part of the message text above is at the end:\n+  // \""... is debugging the browser\"". If the extension name is very long,\n+  // we'd rather truncate it instead. See https://crbug.com/823194.\n+  return gfx::ELIDE_HEAD;\n+}\n+\n int ExtensionDevToolsInfoBarDelegate::GetButtons() const {\n   return BUTTON_CANCEL;\n }""}<_**next**_>{""sha"": ""883e78dadc6c9e66219f817ffdae97b5324dd6f4"", ""filename"": ""chrome/browser/ui/views/infobars/confirm_infobar.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/chrome/browser/ui/views/infobars/confirm_infobar.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/chrome/browser/ui/views/infobars/confirm_infobar.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/infobars/confirm_infobar.cc?ref=fbeba958bb83c05ec8cc54e285a4a9ca10d1b311"", ""patch"": ""@@ -39,6 +39,7 @@ ConfirmInfoBar::ConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate> delegate)\n     : InfoBarView(std::move(delegate)) {\n   auto* delegate_ptr = GetDelegate();\n   label_ = CreateLabel(delegate_ptr->GetMessageText());\n+  label_->SetElideBehavior(delegate_ptr->GetMessageElideBehavior());\n   AddChildView(label_);\n \n   const auto buttons = delegate_ptr->GetButtons();""}<_**next**_>{""sha"": ""d33f23e6367f84af95d1419704198996177d009d"", ""filename"": ""components/infobars/core/confirm_infobar_delegate.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/components/infobars/core/confirm_infobar_delegate.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/components/infobars/core/confirm_infobar_delegate.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/infobars/core/confirm_infobar_delegate.cc?ref=fbeba958bb83c05ec8cc54e285a4a9ca10d1b311"", ""patch"": ""@@ -19,6 +19,10 @@ InfoBarDelegate::InfoBarAutomationType\n   return CONFIRM_INFOBAR;\n }\n \n+gfx::ElideBehavior ConfirmInfoBarDelegate::GetMessageElideBehavior() const {\n+  return gfx::ELIDE_TAIL;\n+}\n+\n int ConfirmInfoBarDelegate::GetButtons() const {\n   return BUTTON_OK | BUTTON_CANCEL;\n }""}<_**next**_>{""sha"": ""8d0a89a2968a41f1999a77f623a7676ecaeb80c6"", ""filename"": ""components/infobars/core/confirm_infobar_delegate.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/components/infobars/core/confirm_infobar_delegate.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fbeba958bb83c05ec8cc54e285a4a9ca10d1b311/components/infobars/core/confirm_infobar_delegate.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/infobars/core/confirm_infobar_delegate.h?ref=fbeba958bb83c05ec8cc54e285a4a9ca10d1b311"", ""patch"": ""@@ -9,6 +9,7 @@\n #include \""base/strings/string16.h\""\n #include \""components/infobars/core/infobar_delegate.h\""\n #include \""components/infobars/core/infobar_manager.h\""\n+#include \""ui/gfx/text_constants.h\""\n #include \""url/gurl.h\""\n \n namespace infobars {\n@@ -33,6 +34,10 @@ class ConfirmInfoBarDelegate : public infobars::InfoBarDelegate {\n   // Returns the message string to be displayed for the InfoBar.\n   virtual base::string16 GetMessageText() const = 0;\n \n+  // Returns the elide behavior for the message string.\n+  // Not supported on Android.\n+  virtual gfx::ElideBehavior GetMessageElideBehavior() const;\n+\n   // Returns the buttons to be shown for this InfoBar.\n   virtual int GetButtons() const;\n ""}","ConfirmInfoBar::ConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate> delegate)
     : InfoBarView(std::move(delegate)) {
   auto* delegate_ptr = GetDelegate();
   label_ = CreateLabel(delegate_ptr->GetMessageText());
  label_->SetElideBehavior(delegate_ptr->GetMessageElideBehavior());
   AddChildView(label_);
 
   const auto buttons = delegate_ptr->GetButtons();
  if (buttons & ConfirmInfoBarDelegate::BUTTON_OK) {
    ok_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_OK);
    ok_button_->SetProminent(true);
    if (delegate_ptr->OKButtonTriggersUACPrompt()) {
      elevation_icon_setter_.reset(new ElevationIconSetter(
          ok_button_,
          base::BindOnce(&ConfirmInfoBar::Layout, base::Unretained(this))));
    }
  }

  if (buttons & ConfirmInfoBarDelegate::BUTTON_CANCEL) {
    cancel_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_CANCEL);
    if (buttons == ConfirmInfoBarDelegate::BUTTON_CANCEL)
      cancel_button_->SetProminent(true);
  }

  link_ = CreateLink(delegate_ptr->GetLinkText(), this);
  AddChildView(link_);
}
","ConfirmInfoBar::ConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate> delegate)
     : InfoBarView(std::move(delegate)) {
   auto* delegate_ptr = GetDelegate();
   label_ = CreateLabel(delegate_ptr->GetMessageText());
   AddChildView(label_);
 
   const auto buttons = delegate_ptr->GetButtons();
  if (buttons & ConfirmInfoBarDelegate::BUTTON_OK) {
    ok_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_OK);
    ok_button_->SetProminent(true);
    if (delegate_ptr->OKButtonTriggersUACPrompt()) {
      elevation_icon_setter_.reset(new ElevationIconSetter(
          ok_button_,
          base::BindOnce(&ConfirmInfoBar::Layout, base::Unretained(this))));
    }
  }

  if (buttons & ConfirmInfoBarDelegate::BUTTON_CANCEL) {
    cancel_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_CANCEL);
    if (buttons == ConfirmInfoBarDelegate::BUTTON_CANCEL)
      cancel_button_->SetProminent(true);
  }

  link_ = CreateLink(delegate_ptr->GetLinkText(), this);
  AddChildView(link_);
}
",C,"  label_->SetElideBehavior(delegate_ptr->GetMessageElideBehavior());
",,,"@@ -39,6 +39,7 @@ ConfirmInfoBar::ConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate> delegate)
     : InfoBarView(std::move(delegate)) {
   auto* delegate_ptr = GetDelegate();
   label_ = CreateLabel(delegate_ptr->GetMessageText());
+  label_->SetElideBehavior(delegate_ptr->GetMessageElideBehavior());
   AddChildView(label_);
 
   const auto buttons = delegate_ptr->GetButtons();",Chrome,fbeba958bb83c05ec8cc54e285a4a9ca10d1b311,6ed800438a7d678b14ed09b983d7f439031b8896,1,"ConfirmInfoBar::ConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate> delegate)
     : InfoBarView(std::move(delegate)) {
   auto* delegate_ptr = GetDelegate();
   label_ = CreateLabel(delegate_ptr->GetMessageText());
//fix_flaw_line_below:
//  label_->SetElideBehavior(delegate_ptr->GetMessageElideBehavior());
   AddChildView(label_);
 
   const auto buttons = delegate_ptr->GetButtons();
  if (buttons & ConfirmInfoBarDelegate::BUTTON_OK) {
    ok_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_OK);
    ok_button_->SetProminent(true);
    if (delegate_ptr->OKButtonTriggersUACPrompt()) {
      elevation_icon_setter_.reset(new ElevationIconSetter(
          ok_button_,
          base::BindOnce(&ConfirmInfoBar::Layout, base::Unretained(this))));
    }
  }

  if (buttons & ConfirmInfoBarDelegate::BUTTON_CANCEL) {
    cancel_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_CANCEL);
    if (buttons == ConfirmInfoBarDelegate::BUTTON_CANCEL)
      cancel_button_->SetProminent(true);
  }

  link_ = CreateLink(delegate_ptr->GetLinkText(), this);
  AddChildView(link_);
}
",187149,"ConfirmInfoBar::ConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate> delegate)
     : InfoBarView(std::move(delegate)) {
   auto* delegate_ptr = GetDelegate();
   label_ = CreateLabel(delegate_ptr->GetMessageText());
   AddChildView(label_);
 
   const auto buttons = delegate_ptr->GetButtons();
  if (buttons & ConfirmInfoBarDelegate::BUTTON_OK) {
    ok_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_OK);
    ok_button_->SetProminent(true);
    if (delegate_ptr->OKButtonTriggersUACPrompt()) {
      elevation_icon_setter_.reset(new ElevationIconSetter(
          ok_button_,
          base::BindOnce(&ConfirmInfoBar::Layout, base::Unretained(this))));
    }
  }

  if (buttons & ConfirmInfoBarDelegate::BUTTON_CANCEL) {
    cancel_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_CANCEL);
    if (buttons == ConfirmInfoBarDelegate::BUTTON_CANCEL)
      cancel_button_->SetProminent(true);
  }

  link_ = CreateLink(delegate_ptr->GetLinkText(), this);
  AddChildView(link_);
}
","ConfirmInfoBar::ConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate> delegate)
     : InfoBarView(std::move(delegate)) {
   auto* delegate_ptr = GetDelegate();
   label_ = CreateLabel(delegate_ptr->GetMessageText());
  label_->SetElideBehavior(delegate_ptr->GetMessageElideBehavior());
   AddChildView(label_);
 
   const auto buttons = delegate_ptr->GetButtons();
  if (buttons & ConfirmInfoBarDelegate::BUTTON_OK) {
    ok_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_OK);
    ok_button_->SetProminent(true);
    if (delegate_ptr->OKButtonTriggersUACPrompt()) {
      elevation_icon_setter_.reset(new ElevationIconSetter(
          ok_button_,
          base::BindOnce(&ConfirmInfoBar::Layout, base::Unretained(this))));
    }
  }

  if (buttons & ConfirmInfoBarDelegate::BUTTON_CANCEL) {
    cancel_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_CANCEL);
    if (buttons == ConfirmInfoBarDelegate::BUTTON_CANCEL)
      cancel_button_->SetProminent(true);
  }

  link_ = CreateLink(delegate_ptr->GetLinkText(), this);
  AddChildView(link_);
}
","The `ConfirmInfoBar` class constructor initializes an information bar with a message and buttons based on the provided delegate. It creates a label displaying the message text retrieved from the delegate and adds it to the info bar. Depending on the button configuration, it conditionally creates and styles OK and Cancel buttons, with the OK button being prominent and potentially triggering a User Account Control (UAC) prompt. Additionally, a link is created and added to the info bar, using text specified by the delegate. This setup allows for a customizable confirmation interface in a user interface context.","The provided code defines a constructor for a confirmation information bar that initializes its visual components based on a delegate. It creates a label to display a message and adds it to the bar. Depending on the specified button options, it conditionally generates and styles OK and Cancel buttons, with the OK button being highlighted and potentially linked to a security prompt. Additionally, a clickable link is created and incorporated into the bar, allowing for user interaction. This setup facilitates a customizable confirmation dialog within a user interface, enhancing user experience and interaction.","The vulnerability in the original code stemmed from the lack of control over how the message text was displayed, potentially leading to overflow or improper rendering if the message was too long. This could result in a poor user experience or even information leakage. The fix introduced a method to specify the elide behavior for the message text by adding a call to `SetElideBehavior` using the behavior retrieved from the delegate. This enhancement ensures that long messages are appropriately truncated or displayed, thereby improving the visual integrity and usability of the confirmation information bar.","The vulnerability in the original code was related to the handling of message text in the confirmation information bar, which could lead to display issues when the text was too lengthy. This could result in overflow or improper rendering, negatively impacting user experience. The fix addressed this issue by allowing the specification of how the message text should be truncated or displayed when it exceeds the available space. This enhancement ensures that long messages are managed appropriately, improving the visual presentation and usability of the information bar while preventing potential information leakage or confusion.","The vulnerability was fixed by introducing a call to `SetElideBehavior` on the label created for the message text. This method allows the specification of how the message should be truncated or displayed when it exceeds the available space, using the behavior retrieved from the delegate. By implementing this change, the code ensures that long messages are handled appropriately, preventing overflow and ensuring that the information bar maintains a clean and user-friendly appearance. This enhancement directly addresses the potential display issues that could arise from lengthy message text, thereby improving overall usability.","The vulnerability was fixed by implementing a mechanism that allows for the specification of how message text should be truncated or displayed when it exceeds the available space. This enhancement ensures that lengthy messages are managed appropriately, preventing issues such as overflow or improper rendering that could negatively impact user experience. By allowing for customizable text display behavior, the solution improves the visual integrity of the information bar, ensuring that it remains user-friendly and clear, while also mitigating the risk of information leakage or confusion caused by overly long messages.","CWE-119, CWE-200, CWE-120, CWE-20, CWE-116, CWE-216, CWE-610, CWE-319, CWE-209, CWE-226",N,-1.0,"4,4","5,5","4, 4","4,4"
9,9,187954,187954,,Remote,Not required,,CVE-2016-0829,https://www.cvedetails.com/cve/CVE-2016-0829/,CWE-254,Low,Partial,,,2016-03-12,5.0,"The BnGraphicBufferProducer::onTransact function in libs/gui/IGraphicBufferConsumer.cpp in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not initialize a certain output data structure, which allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, by triggering a QUEUE_BUFFER action, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26338109.",2016-11-28,Bypass +Info ,1,https://android.googlesource.com/platform/frameworks/native/+/d06421fd37fbb7fd07002e6738fac3a223cb1a62,d06421fd37fbb7fd07002e6738fac3a223cb1a62,"IGraphicBufferProducer: fix QUEUE_BUFFER info leak

Bug: 26338109
Change-Id: I8a979469bfe1e317ebdefa43685e19f9302baea8
",0,libs/gui/IGraphicBufferProducer.cpp,"{""filename"": ""libs/gui/IGraphicBufferProducer.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/d06421fd37fbb7fd07002e6738fac3a223cb1a62/libs/gui/IGraphicBufferProducer.cpp"", ""patch"": ""@@ -219,6 +219,7 @@\n\n             QueueBufferOutput* const output =\n                     reinterpret_cast<QueueBufferOutput *>(\n                             reply->writeInplace(sizeof(QueueBufferOutput)));\n+            memset(output, 0, sizeof(QueueBufferOutput));\n             status_t result = queueBuffer(buf, input, output);\n             reply->writeInt32(result);\n             return NO_ERROR;\n""}","status_t BnGraphicBufferProducer::onTransact(
 uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
 switch(code) {
 case REQUEST_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int bufferIdx   = data.readInt32();
            sp<GraphicBuffer> buffer;
 int result = requestBuffer(bufferIdx, &buffer);
            reply->writeInt32(buffer != 0);
 if (buffer != 0) {
                reply->write(*buffer);
 }
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int bufferCount = data.readInt32();
 int result = setBufferCount(bufferCount);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DEQUEUE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 bool async      = data.readInt32();
 uint32_t w      = data.readInt32();
 uint32_t h      = data.readInt32();
 uint32_t format = data.readInt32();
 uint32_t usage  = data.readInt32();
 int buf = 0;
            sp<Fence> fence;
 int result = dequeueBuffer(&buf, &fence, async, w, h, format, usage);
            reply->writeInt32(buf);
            reply->writeInt32(fence != NULL);
 if (fence != NULL) {
                reply->write(*fence);
 }
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case QUEUE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int buf = data.readInt32();
 QueueBufferInput input(data);

             QueueBufferOutput* const output =
                     reinterpret_cast<QueueBufferOutput *>(
                             reply->writeInplace(sizeof(QueueBufferOutput)));
            memset(output, 0, sizeof(QueueBufferOutput));
             status_t result = queueBuffer(buf, input, output);
             reply->writeInt32(result);
             return NO_ERROR;
 } break;
 case CANCEL_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int buf = data.readInt32();
            sp<Fence> fence = new Fence();
            data.read(*fence.get());
            cancelBuffer(buf, fence);
 return NO_ERROR;
 } break;
 case QUERY: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int value = 0;
 int what = data.readInt32();
 int res = query(what, &value);
            reply->writeInt32(value);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 case CONNECT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
            sp<IBinder> token = data.readStrongBinder();
 int api = data.readInt32();
 bool producerControlledByApp = data.readInt32();
 QueueBufferOutput* const output =
 reinterpret_cast<QueueBufferOutput *>(
                            reply->writeInplace(sizeof(QueueBufferOutput)));
 status_t res = connect(token, api, producerControlledByApp, output);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 case DISCONNECT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int api = data.readInt32();
 status_t res = disconnect(api);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 }
 return BBinder::onTransact(code, data, reply, flags);
}
","status_t BnGraphicBufferProducer::onTransact(
 uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
 switch(code) {
 case REQUEST_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int bufferIdx   = data.readInt32();
            sp<GraphicBuffer> buffer;
 int result = requestBuffer(bufferIdx, &buffer);
            reply->writeInt32(buffer != 0);
 if (buffer != 0) {
                reply->write(*buffer);
 }
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int bufferCount = data.readInt32();
 int result = setBufferCount(bufferCount);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DEQUEUE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 bool async      = data.readInt32();
 uint32_t w      = data.readInt32();
 uint32_t h      = data.readInt32();
 uint32_t format = data.readInt32();
 uint32_t usage  = data.readInt32();
 int buf = 0;
            sp<Fence> fence;
 int result = dequeueBuffer(&buf, &fence, async, w, h, format, usage);
            reply->writeInt32(buf);
            reply->writeInt32(fence != NULL);
 if (fence != NULL) {
                reply->write(*fence);
 }
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case QUEUE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int buf = data.readInt32();
 QueueBufferInput input(data);

             QueueBufferOutput* const output =
                     reinterpret_cast<QueueBufferOutput *>(
                             reply->writeInplace(sizeof(QueueBufferOutput)));
             status_t result = queueBuffer(buf, input, output);
             reply->writeInt32(result);
             return NO_ERROR;
 } break;
 case CANCEL_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int buf = data.readInt32();
            sp<Fence> fence = new Fence();
            data.read(*fence.get());
            cancelBuffer(buf, fence);
 return NO_ERROR;
 } break;
 case QUERY: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int value = 0;
 int what = data.readInt32();
 int res = query(what, &value);
            reply->writeInt32(value);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 case CONNECT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
            sp<IBinder> token = data.readStrongBinder();
 int api = data.readInt32();
 bool producerControlledByApp = data.readInt32();
 QueueBufferOutput* const output =
 reinterpret_cast<QueueBufferOutput *>(
                            reply->writeInplace(sizeof(QueueBufferOutput)));
 status_t res = connect(token, api, producerControlledByApp, output);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 case DISCONNECT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int api = data.readInt32();
 status_t res = disconnect(api);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 }
 return BBinder::onTransact(code, data, reply, flags);
}
",C,"            memset(output, 0, sizeof(QueueBufferOutput));
",,,"@@ -219,6 +219,7 @@

             QueueBufferOutput* const output =
                     reinterpret_cast<QueueBufferOutput *>(
                             reply->writeInplace(sizeof(QueueBufferOutput)));
+            memset(output, 0, sizeof(QueueBufferOutput));
             status_t result = queueBuffer(buf, input, output);
             reply->writeInt32(result);
             return NO_ERROR;
",Android,https://android.googlesource.com/platform/frameworks/native/+/d06421fd37fbb7fd07002e6738fac3a223cb1a62/,https://android.googlesource.com/platform/frameworks/native/+/d06421fd37fbb7fd07002e6738fac3a223cb1a62%5E/,1,"status_t BnGraphicBufferProducer::onTransact(
 uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
 switch(code) {
 case REQUEST_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int bufferIdx   = data.readInt32();
            sp<GraphicBuffer> buffer;
 int result = requestBuffer(bufferIdx, &buffer);
            reply->writeInt32(buffer != 0);
 if (buffer != 0) {
                reply->write(*buffer);
 }
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int bufferCount = data.readInt32();
 int result = setBufferCount(bufferCount);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DEQUEUE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 bool async      = data.readInt32();
 uint32_t w      = data.readInt32();
 uint32_t h      = data.readInt32();
 uint32_t format = data.readInt32();
 uint32_t usage  = data.readInt32();
 int buf = 0;
            sp<Fence> fence;
 int result = dequeueBuffer(&buf, &fence, async, w, h, format, usage);
            reply->writeInt32(buf);
            reply->writeInt32(fence != NULL);
 if (fence != NULL) {
                reply->write(*fence);
 }
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case QUEUE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int buf = data.readInt32();
 QueueBufferInput input(data);

             QueueBufferOutput* const output =
                     reinterpret_cast<QueueBufferOutput *>(
                             reply->writeInplace(sizeof(QueueBufferOutput)));
//fix_flaw_line_below:
//            memset(output, 0, sizeof(QueueBufferOutput));
             status_t result = queueBuffer(buf, input, output);
             reply->writeInt32(result);
             return NO_ERROR;
 } break;
 case CANCEL_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int buf = data.readInt32();
            sp<Fence> fence = new Fence();
            data.read(*fence.get());
            cancelBuffer(buf, fence);
 return NO_ERROR;
 } break;
 case QUERY: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int value = 0;
 int what = data.readInt32();
 int res = query(what, &value);
            reply->writeInt32(value);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 case CONNECT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
            sp<IBinder> token = data.readStrongBinder();
 int api = data.readInt32();
 bool producerControlledByApp = data.readInt32();
 QueueBufferOutput* const output =
 reinterpret_cast<QueueBufferOutput *>(
                            reply->writeInplace(sizeof(QueueBufferOutput)));
 status_t res = connect(token, api, producerControlledByApp, output);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 case DISCONNECT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int api = data.readInt32();
 status_t res = disconnect(api);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 }
 return BBinder::onTransact(code, data, reply, flags);
}
",187954,"status_t BnGraphicBufferProducer::onTransact(
 uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
 switch(code) {
 case REQUEST_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int bufferIdx   = data.readInt32();
            sp<GraphicBuffer> buffer;
 int result = requestBuffer(bufferIdx, &buffer);
            reply->writeInt32(buffer != 0);
 if (buffer != 0) {
                reply->write(*buffer);
 }
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int bufferCount = data.readInt32();
 int result = setBufferCount(bufferCount);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DEQUEUE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 bool async      = data.readInt32();
 uint32_t w      = data.readInt32();
 uint32_t h      = data.readInt32();
 uint32_t format = data.readInt32();
 uint32_t usage  = data.readInt32();
 int buf = 0;
            sp<Fence> fence;
 int result = dequeueBuffer(&buf, &fence, async, w, h, format, usage);
            reply->writeInt32(buf);
            reply->writeInt32(fence != NULL);
 if (fence != NULL) {
                reply->write(*fence);
 }
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case QUEUE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int buf = data.readInt32();
 QueueBufferInput input(data);

             QueueBufferOutput* const output =
                     reinterpret_cast<QueueBufferOutput *>(
                             reply->writeInplace(sizeof(QueueBufferOutput)));
             status_t result = queueBuffer(buf, input, output);
             reply->writeInt32(result);
             return NO_ERROR;
 } break;
 case CANCEL_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int buf = data.readInt32();
            sp<Fence> fence = new Fence();
            data.read(*fence.get());
            cancelBuffer(buf, fence);
 return NO_ERROR;
 } break;
 case QUERY: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int value = 0;
 int what = data.readInt32();
 int res = query(what, &value);
            reply->writeInt32(value);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 case CONNECT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
            sp<IBinder> token = data.readStrongBinder();
 int api = data.readInt32();
 bool producerControlledByApp = data.readInt32();
 QueueBufferOutput* const output =
 reinterpret_cast<QueueBufferOutput *>(
                            reply->writeInplace(sizeof(QueueBufferOutput)));
 status_t res = connect(token, api, producerControlledByApp, output);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 case DISCONNECT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int api = data.readInt32();
 status_t res = disconnect(api);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 }
 return BBinder::onTransact(code, data, reply, flags);
}
","status_t BnGraphicBufferProducer::onTransact(
 uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
 switch(code) {
 case REQUEST_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int bufferIdx   = data.readInt32();
            sp<GraphicBuffer> buffer;
 int result = requestBuffer(bufferIdx, &buffer);
            reply->writeInt32(buffer != 0);
 if (buffer != 0) {
                reply->write(*buffer);
 }
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int bufferCount = data.readInt32();
 int result = setBufferCount(bufferCount);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DEQUEUE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 bool async      = data.readInt32();
 uint32_t w      = data.readInt32();
 uint32_t h      = data.readInt32();
 uint32_t format = data.readInt32();
 uint32_t usage  = data.readInt32();
 int buf = 0;
            sp<Fence> fence;
 int result = dequeueBuffer(&buf, &fence, async, w, h, format, usage);
            reply->writeInt32(buf);
            reply->writeInt32(fence != NULL);
 if (fence != NULL) {
                reply->write(*fence);
 }
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case QUEUE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int buf = data.readInt32();
 QueueBufferInput input(data);

             QueueBufferOutput* const output =
                     reinterpret_cast<QueueBufferOutput *>(
                             reply->writeInplace(sizeof(QueueBufferOutput)));
            memset(output, 0, sizeof(QueueBufferOutput));
             status_t result = queueBuffer(buf, input, output);
             reply->writeInt32(result);
             return NO_ERROR;
 } break;
 case CANCEL_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int buf = data.readInt32();
            sp<Fence> fence = new Fence();
            data.read(*fence.get());
            cancelBuffer(buf, fence);
 return NO_ERROR;
 } break;
 case QUERY: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int value = 0;
 int what = data.readInt32();
 int res = query(what, &value);
            reply->writeInt32(value);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 case CONNECT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
            sp<IBinder> token = data.readStrongBinder();
 int api = data.readInt32();
 bool producerControlledByApp = data.readInt32();
 QueueBufferOutput* const output =
 reinterpret_cast<QueueBufferOutput *>(
                            reply->writeInplace(sizeof(QueueBufferOutput)));
 status_t res = connect(token, api, producerControlledByApp, output);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 case DISCONNECT: {
            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
 int api = data.readInt32();
 status_t res = disconnect(api);
            reply->writeInt32(res);
 return NO_ERROR;
 } break;
 }
 return BBinder::onTransact(code, data, reply, flags);
}
","The `BnGraphicBufferProducer::onTransact` function handles various requests related to graphic buffer management by processing different transaction codes. It checks the interface for validity and executes specific actions based on the received code, such as requesting a buffer, setting the buffer count, dequeuing or queuing buffers, canceling buffers, querying properties, and connecting or disconnecting clients. Each case reads necessary parameters from the input `Parcel`, performs the corresponding operation, and writes the results back to the output `Parcel`, ensuring proper communication between the client and the graphic buffer producer service.","The provided code defines a function that manages communication between a client and a graphic buffer producer service by processing various transaction requests. It validates the interface and executes specific actions based on the request type, such as allocating or configuring buffers, managing buffer queues, and handling client connections and disconnections. Each request involves reading parameters from an input data structure, performing the necessary operations, and returning results or status information to the client through an output data structure, ensuring efficient interaction and resource management within the graphic buffer system.","The vulnerability in the original code stemmed from an information leak in the `QUEUE_BUFFER` case, where the output structure was not properly initialized before being used. This could allow uninitialized memory to be sent back to the client, potentially exposing sensitive data. The fix involved adding a call to `memset(output, 0, sizeof(QueueBufferOutput));` right after the output structure was allocated. This ensured that the memory was cleared, preventing any residual data from being sent back, thus mitigating the risk of leaking sensitive information and enhancing the overall security of the graphic buffer producer service.","The vulnerability in the original code was an information leak that occurred when uninitialized memory was returned to the client in response to a buffer queue request. This could inadvertently expose sensitive data from previous operations. The fix addressed this issue by ensuring that the memory allocated for the output structure was properly initialized to zero before being used. This change effectively eliminated the risk of leaking residual data, thereby enhancing the security of the graphic buffer producer service and ensuring that only relevant and safe information is communicated back to the client.","The vulnerability was fixed by adding a call to `memset(output, 0, sizeof(QueueBufferOutput));` immediately after the output structure was allocated in the `QUEUE_BUFFER` case. This ensured that the memory for the `QueueBufferOutput` structure was initialized to zero, preventing any uninitialized data from being sent back to the client. By clearing the memory, the fix mitigated the risk of leaking sensitive information that could have been present in the residual data, thereby enhancing the security of the graphic buffer producer service and ensuring safe communication with clients.","The vulnerability was fixed by ensuring that the memory allocated for the output structure was properly initialized to zero before being used. This step was crucial in preventing any uninitialized data from being returned to the client, which could have exposed sensitive information. By clearing the memory, the fix effectively eliminated the risk of leaking residual data from previous operations, thereby enhancing the overall security of the service. This change ensured that only safe and relevant information was communicated back to the client, addressing the information leak issue effectively.","CWE-908, CWE-665, CWE-200, CWE-244, CWE-252, CWE-457, CWE-895, CWE-909, CWE-456, CWE-14",N,-1.0,"5,4","5,5","4, 4","5, 5"
10,10,187955,187955,,Remote,Not required,,CVE-2016-0828,https://www.cvedetails.com/cve/CVE-2016-0828/,CWE-254,Low,Partial,,,2016-03-12,5.0,"The BnGraphicBufferConsumer::onTransact function in libs/gui/IGraphicBufferConsumer.cpp in mediaserver in Android 5.x before 5.1.1 LMY49H and 6.x before 2016-03-01 does not initialize a certain slot variable, which allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, by triggering an ATTACH_BUFFER action, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26338113.",2016-11-28,Bypass +Info ,1,https://android.googlesource.com/platform/frameworks/native/+/dded8fdbb700d6cc498debc69a780915bc34d755,dded8fdbb700d6cc498debc69a780915bc34d755,"IGraphicBufferConsumer: fix ATTACH_BUFFER info leak

Bug: 26338113
Change-Id: I019c4df2c6adbc944122df96968ddd11a02ebe33
",1,libs/gui/IGraphicBufferConsumer.cpp,"{""filename"": ""libs/gui/IGraphicBufferConsumer.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/native/+/dded8fdbb700d6cc498debc69a780915bc34d755/libs/gui/IGraphicBufferConsumer.cpp"", ""patch"": ""@@ -444,7 +444,7 @@\n\n             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n             sp<GraphicBuffer> buffer = new GraphicBuffer();\n             data.read(*buffer.get());\n-            int slot;\n+            int slot = -1;\n             int result = attachBuffer(&slot, buffer);\n             reply->writeInt32(slot);\n             reply->writeInt32(result);\n""}","status_t BnGraphicBufferConsumer::onTransact(
 uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
 switch(code) {
 case ACQUIRE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 BufferItem item;
 int64_t presentWhen = data.readInt64();
 status_t result = acquireBuffer(&item, presentWhen);
 status_t err = reply->write(item);
 if (err) return err;
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DETACH_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 int slot = data.readInt32();
 int result = detachBuffer(slot);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case ATTACH_BUFFER: {

             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             sp<GraphicBuffer> buffer = new GraphicBuffer();
             data.read(*buffer.get());
            int slot = -1;
             int result = attachBuffer(&slot, buffer);
             reply->writeInt32(slot);
             reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case RELEASE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 int buf = data.readInt32();
 uint64_t frameNumber = data.readInt64();
            sp<Fence> releaseFence = new Fence();
 status_t err = data.read(*releaseFence);
 if (err) return err;
 status_t result = releaseBuffer(buf, frameNumber,
                    EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, releaseFence);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case CONSUMER_CONNECT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
            sp<IConsumerListener> consumer = IConsumerListener::asInterface( data.readStrongBinder() );
 bool controlledByApp = data.readInt32();
 status_t result = consumerConnect(consumer, controlledByApp);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case CONSUMER_DISCONNECT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 status_t result = consumerDisconnect();
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case GET_RELEASED_BUFFERS: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint64_t slotMask;
 status_t result = getReleasedBuffers(&slotMask);
            reply->writeInt64(slotMask);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_DEFAULT_BUFFER_SIZE: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t w = data.readInt32();
 uint32_t h = data.readInt32();
 status_t result = setDefaultBufferSize(w, h);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_DEFAULT_MAX_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t bufferCount = data.readInt32();
 status_t result = setDefaultMaxBufferCount(bufferCount);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DISABLE_ASYNC_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 status_t result = disableAsyncBuffer();
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_MAX_ACQUIRED_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t maxAcquiredBuffers = data.readInt32();
 status_t result = setMaxAcquiredBufferCount(maxAcquiredBuffers);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_CONSUMER_NAME: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
            setConsumerName( data.readString8() );
 return NO_ERROR;
 } break;
 case SET_DEFAULT_BUFFER_FORMAT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t defaultFormat = data.readInt32();
 status_t result = setDefaultBufferFormat(defaultFormat);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_CONSUMER_USAGE_BITS: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t usage = data.readInt32();
 status_t result = setConsumerUsageBits(usage);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_TRANSFORM_HINT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t hint = data.readInt32();
 status_t result = setTransformHint(hint);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DUMP: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 String8 result = data.readString8();
 String8 prefix = data.readString8();
 static_cast<IGraphicBufferConsumer*>(this)->dump(result, prefix);
            reply->writeString8(result);
 return NO_ERROR;
 }
 }
 return BBinder::onTransact(code, data, reply, flags);
}
","status_t BnGraphicBufferConsumer::onTransact(
 uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
 switch(code) {
 case ACQUIRE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 BufferItem item;
 int64_t presentWhen = data.readInt64();
 status_t result = acquireBuffer(&item, presentWhen);
 status_t err = reply->write(item);
 if (err) return err;
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DETACH_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 int slot = data.readInt32();
 int result = detachBuffer(slot);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case ATTACH_BUFFER: {

             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             sp<GraphicBuffer> buffer = new GraphicBuffer();
             data.read(*buffer.get());
            int slot;
             int result = attachBuffer(&slot, buffer);
             reply->writeInt32(slot);
             reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case RELEASE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 int buf = data.readInt32();
 uint64_t frameNumber = data.readInt64();
            sp<Fence> releaseFence = new Fence();
 status_t err = data.read(*releaseFence);
 if (err) return err;
 status_t result = releaseBuffer(buf, frameNumber,
                    EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, releaseFence);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case CONSUMER_CONNECT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
            sp<IConsumerListener> consumer = IConsumerListener::asInterface( data.readStrongBinder() );
 bool controlledByApp = data.readInt32();
 status_t result = consumerConnect(consumer, controlledByApp);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case CONSUMER_DISCONNECT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 status_t result = consumerDisconnect();
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case GET_RELEASED_BUFFERS: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint64_t slotMask;
 status_t result = getReleasedBuffers(&slotMask);
            reply->writeInt64(slotMask);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_DEFAULT_BUFFER_SIZE: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t w = data.readInt32();
 uint32_t h = data.readInt32();
 status_t result = setDefaultBufferSize(w, h);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_DEFAULT_MAX_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t bufferCount = data.readInt32();
 status_t result = setDefaultMaxBufferCount(bufferCount);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DISABLE_ASYNC_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 status_t result = disableAsyncBuffer();
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_MAX_ACQUIRED_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t maxAcquiredBuffers = data.readInt32();
 status_t result = setMaxAcquiredBufferCount(maxAcquiredBuffers);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_CONSUMER_NAME: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
            setConsumerName( data.readString8() );
 return NO_ERROR;
 } break;
 case SET_DEFAULT_BUFFER_FORMAT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t defaultFormat = data.readInt32();
 status_t result = setDefaultBufferFormat(defaultFormat);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_CONSUMER_USAGE_BITS: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t usage = data.readInt32();
 status_t result = setConsumerUsageBits(usage);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_TRANSFORM_HINT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t hint = data.readInt32();
 status_t result = setTransformHint(hint);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DUMP: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 String8 result = data.readString8();
 String8 prefix = data.readString8();
 static_cast<IGraphicBufferConsumer*>(this)->dump(result, prefix);
            reply->writeString8(result);
 return NO_ERROR;
 }
 }
 return BBinder::onTransact(code, data, reply, flags);
}
",C,"            int slot = -1;
","            int slot;
",,"@@ -444,7 +444,7 @@

             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             sp<GraphicBuffer> buffer = new GraphicBuffer();
             data.read(*buffer.get());
-            int slot;
+            int slot = -1;
             int result = attachBuffer(&slot, buffer);
             reply->writeInt32(slot);
             reply->writeInt32(result);
",Android,https://android.googlesource.com/platform/frameworks/native/+/dded8fdbb700d6cc498debc69a780915bc34d755/,https://android.googlesource.com/platform/frameworks/native/+/dded8fdbb700d6cc498debc69a780915bc34d755%5E/,1,"status_t BnGraphicBufferConsumer::onTransact(
 uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
 switch(code) {
 case ACQUIRE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 BufferItem item;
 int64_t presentWhen = data.readInt64();
 status_t result = acquireBuffer(&item, presentWhen);
 status_t err = reply->write(item);
 if (err) return err;
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DETACH_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 int slot = data.readInt32();
 int result = detachBuffer(slot);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case ATTACH_BUFFER: {

             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             sp<GraphicBuffer> buffer = new GraphicBuffer();
             data.read(*buffer.get());
//flaw_line_below:
            int slot;
//fix_flaw_line_below:
//            int slot = -1;
             int result = attachBuffer(&slot, buffer);
             reply->writeInt32(slot);
             reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case RELEASE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 int buf = data.readInt32();
 uint64_t frameNumber = data.readInt64();
            sp<Fence> releaseFence = new Fence();
 status_t err = data.read(*releaseFence);
 if (err) return err;
 status_t result = releaseBuffer(buf, frameNumber,
                    EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, releaseFence);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case CONSUMER_CONNECT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
            sp<IConsumerListener> consumer = IConsumerListener::asInterface( data.readStrongBinder() );
 bool controlledByApp = data.readInt32();
 status_t result = consumerConnect(consumer, controlledByApp);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case CONSUMER_DISCONNECT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 status_t result = consumerDisconnect();
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case GET_RELEASED_BUFFERS: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint64_t slotMask;
 status_t result = getReleasedBuffers(&slotMask);
            reply->writeInt64(slotMask);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_DEFAULT_BUFFER_SIZE: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t w = data.readInt32();
 uint32_t h = data.readInt32();
 status_t result = setDefaultBufferSize(w, h);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_DEFAULT_MAX_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t bufferCount = data.readInt32();
 status_t result = setDefaultMaxBufferCount(bufferCount);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DISABLE_ASYNC_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 status_t result = disableAsyncBuffer();
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_MAX_ACQUIRED_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t maxAcquiredBuffers = data.readInt32();
 status_t result = setMaxAcquiredBufferCount(maxAcquiredBuffers);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_CONSUMER_NAME: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
            setConsumerName( data.readString8() );
 return NO_ERROR;
 } break;
 case SET_DEFAULT_BUFFER_FORMAT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t defaultFormat = data.readInt32();
 status_t result = setDefaultBufferFormat(defaultFormat);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_CONSUMER_USAGE_BITS: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t usage = data.readInt32();
 status_t result = setConsumerUsageBits(usage);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_TRANSFORM_HINT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t hint = data.readInt32();
 status_t result = setTransformHint(hint);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DUMP: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 String8 result = data.readString8();
 String8 prefix = data.readString8();
 static_cast<IGraphicBufferConsumer*>(this)->dump(result, prefix);
            reply->writeString8(result);
 return NO_ERROR;
 }
 }
 return BBinder::onTransact(code, data, reply, flags);
}
",187955,"status_t BnGraphicBufferConsumer::onTransact(
 uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
 switch(code) {
 case ACQUIRE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 BufferItem item;
 int64_t presentWhen = data.readInt64();
 status_t result = acquireBuffer(&item, presentWhen);
 status_t err = reply->write(item);
 if (err) return err;
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DETACH_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 int slot = data.readInt32();
 int result = detachBuffer(slot);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case ATTACH_BUFFER: {

             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             sp<GraphicBuffer> buffer = new GraphicBuffer();
             data.read(*buffer.get());
            int slot;
             int result = attachBuffer(&slot, buffer);
             reply->writeInt32(slot);
             reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case RELEASE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 int buf = data.readInt32();
 uint64_t frameNumber = data.readInt64();
            sp<Fence> releaseFence = new Fence();
 status_t err = data.read(*releaseFence);
 if (err) return err;
 status_t result = releaseBuffer(buf, frameNumber,
                    EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, releaseFence);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case CONSUMER_CONNECT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
            sp<IConsumerListener> consumer = IConsumerListener::asInterface( data.readStrongBinder() );
 bool controlledByApp = data.readInt32();
 status_t result = consumerConnect(consumer, controlledByApp);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case CONSUMER_DISCONNECT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 status_t result = consumerDisconnect();
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case GET_RELEASED_BUFFERS: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint64_t slotMask;
 status_t result = getReleasedBuffers(&slotMask);
            reply->writeInt64(slotMask);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_DEFAULT_BUFFER_SIZE: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t w = data.readInt32();
 uint32_t h = data.readInt32();
 status_t result = setDefaultBufferSize(w, h);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_DEFAULT_MAX_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t bufferCount = data.readInt32();
 status_t result = setDefaultMaxBufferCount(bufferCount);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DISABLE_ASYNC_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 status_t result = disableAsyncBuffer();
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_MAX_ACQUIRED_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t maxAcquiredBuffers = data.readInt32();
 status_t result = setMaxAcquiredBufferCount(maxAcquiredBuffers);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_CONSUMER_NAME: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
            setConsumerName( data.readString8() );
 return NO_ERROR;
 } break;
 case SET_DEFAULT_BUFFER_FORMAT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t defaultFormat = data.readInt32();
 status_t result = setDefaultBufferFormat(defaultFormat);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_CONSUMER_USAGE_BITS: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t usage = data.readInt32();
 status_t result = setConsumerUsageBits(usage);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_TRANSFORM_HINT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t hint = data.readInt32();
 status_t result = setTransformHint(hint);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DUMP: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 String8 result = data.readString8();
 String8 prefix = data.readString8();
 static_cast<IGraphicBufferConsumer*>(this)->dump(result, prefix);
            reply->writeString8(result);
 return NO_ERROR;
 }
 }
 return BBinder::onTransact(code, data, reply, flags);
}
","status_t BnGraphicBufferConsumer::onTransact(
 uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
 switch(code) {
 case ACQUIRE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 BufferItem item;
 int64_t presentWhen = data.readInt64();
 status_t result = acquireBuffer(&item, presentWhen);
 status_t err = reply->write(item);
 if (err) return err;
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DETACH_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 int slot = data.readInt32();
 int result = detachBuffer(slot);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case ATTACH_BUFFER: {

             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             sp<GraphicBuffer> buffer = new GraphicBuffer();
             data.read(*buffer.get());
            int slot = -1;
             int result = attachBuffer(&slot, buffer);
             reply->writeInt32(slot);
             reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case RELEASE_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 int buf = data.readInt32();
 uint64_t frameNumber = data.readInt64();
            sp<Fence> releaseFence = new Fence();
 status_t err = data.read(*releaseFence);
 if (err) return err;
 status_t result = releaseBuffer(buf, frameNumber,
                    EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, releaseFence);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case CONSUMER_CONNECT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
            sp<IConsumerListener> consumer = IConsumerListener::asInterface( data.readStrongBinder() );
 bool controlledByApp = data.readInt32();
 status_t result = consumerConnect(consumer, controlledByApp);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case CONSUMER_DISCONNECT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 status_t result = consumerDisconnect();
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case GET_RELEASED_BUFFERS: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint64_t slotMask;
 status_t result = getReleasedBuffers(&slotMask);
            reply->writeInt64(slotMask);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_DEFAULT_BUFFER_SIZE: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t w = data.readInt32();
 uint32_t h = data.readInt32();
 status_t result = setDefaultBufferSize(w, h);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_DEFAULT_MAX_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t bufferCount = data.readInt32();
 status_t result = setDefaultMaxBufferCount(bufferCount);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DISABLE_ASYNC_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 status_t result = disableAsyncBuffer();
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_MAX_ACQUIRED_BUFFER_COUNT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t maxAcquiredBuffers = data.readInt32();
 status_t result = setMaxAcquiredBufferCount(maxAcquiredBuffers);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_CONSUMER_NAME: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
            setConsumerName( data.readString8() );
 return NO_ERROR;
 } break;
 case SET_DEFAULT_BUFFER_FORMAT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t defaultFormat = data.readInt32();
 status_t result = setDefaultBufferFormat(defaultFormat);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_CONSUMER_USAGE_BITS: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t usage = data.readInt32();
 status_t result = setConsumerUsageBits(usage);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case SET_TRANSFORM_HINT: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 uint32_t hint = data.readInt32();
 status_t result = setTransformHint(hint);
            reply->writeInt32(result);
 return NO_ERROR;
 } break;
 case DUMP: {
            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
 String8 result = data.readString8();
 String8 prefix = data.readString8();
 static_cast<IGraphicBufferConsumer*>(this)->dump(result, prefix);
            reply->writeString8(result);
 return NO_ERROR;
 }
 }
 return BBinder::onTransact(code, data, reply, flags);
}
","The `onTransact` function in the `BnGraphicBufferConsumer` class handles various operations related to graphic buffer management through a switch-case structure based on the provided `code`. Each case corresponds to a specific command, such as acquiring, attaching, detaching, releasing buffers, connecting or disconnecting consumers, and setting various buffer parameters (like size, format, and usage). The function reads input data from a `Parcel`, performs the requested operation, and writes the result back to the `reply` parcel. It ensures proper interface checks and returns appropriate status codes, facilitating communication between different components in a graphics processing system.","The provided code defines a method that processes various commands related to graphic buffer management. It uses a switch-case structure to handle different operations, such as acquiring, attaching, detaching, and releasing buffers, as well as connecting and disconnecting consumers. Each command reads input data, performs the corresponding action, and writes the result back to a response object. The method ensures that the correct interface is being used and returns appropriate status codes for each operation, facilitating effective communication and management of graphic resources within a system.","The vulnerability in the original code stemmed from the `ATTACH_BUFFER` case, where the buffer was read without proper validation, potentially leading to an information leak. Specifically, the code did not ensure that the buffer was correctly initialized or that the data read from the input was valid, which could allow unauthorized access to sensitive information. The fix involved initializing the slot variable to -1 before calling the `attachBuffer` function, ensuring that any uninitialized or invalid data would not be processed, thus preventing the information leak and enhancing the overall security of the buffer management operations.","The vulnerability in the original code was related to an information leak during the buffer attachment process, where uninitialized or improperly validated data could be exposed, potentially allowing unauthorized access to sensitive information. This issue arose because the code did not adequately check the integrity of the data being processed. The fix involved ensuring that a specific variable was initialized to a known state before being used in the attachment operation, thereby preventing the processing of any invalid or uninitialized data and effectively mitigating the risk of information leakage in the buffer management system.","The vulnerability was fixed by initializing the `slot` variable to -1 in the `ATTACH_BUFFER` case before calling the `attachBuffer` function. This change ensures that the `slot` variable has a defined state, preventing any uninitialized or invalid data from being processed during the buffer attachment. Additionally, the code now reads the buffer data into a properly allocated `GraphicBuffer` object, ensuring that the data is valid and secure. By implementing these changes, the risk of information leakage is significantly reduced, enhancing the overall security of the buffer management operations.","The vulnerability was addressed by ensuring that a specific variable was initialized to a known state before being used in the buffer attachment process. This initialization prevents the use of any uninitialized or invalid data, which could lead to information leakage. Additionally, the code was modified to read the buffer data into a properly allocated object, ensuring that the data being processed is valid and secure. These changes collectively enhance the integrity of the buffer management operations, significantly reducing the risk of unauthorized access to sensitive information.","CWE-457, CWE-908, CWE-665, CWE-119, CWE-200, CWE-824, CWE-456, CWE-822, CWE-415, CWE-762",N,-1.0,"5,4","5, 5","3, 4","4, 4"
