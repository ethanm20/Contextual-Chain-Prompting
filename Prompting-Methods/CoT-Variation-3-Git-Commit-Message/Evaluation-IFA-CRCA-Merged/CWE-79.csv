,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,T1_Top_10_CWE_IDs,T2_Correctly_Found_CWE,T3_IFA,G1_Clarity_C3_C5,G2_Relevance_C3_C5,G3_Completeness_C3_C5,G4_Actionability_C3_C5
0,0,182200,182200,,Remote,Not required,,CVE-2018-17082,https://www.cvedetails.com/cve/CVE-2018-17082/,CWE-79,Medium,,Partial,,2018-09-16,4.3,"The Apache2 component in PHP before 5.6.38, 7.0.x before 7.0.32, 7.1.x before 7.1.22, and 7.2.x before 7.2.10 allows XSS via the body of a *Transfer-Encoding: chunked* request, because the bucket brigade is mishandled in the php_handler function in sapi/apache2handler/sapi_apache2.c.",2019-08-19,XSS ,1,https://github.com/php/php-src/commit/23b057742e3cf199612fa8050ae86cae675e214e,23b057742e3cf199612fa8050ae86cae675e214e,"Fix for bug #76582

The brigade seems to end up in a messed up state if something fails
in shutdown, so we clean it up.",0,sapi/apache2handler/sapi_apache2.c,"{""sha"": ""0ebca9bca863909aef3fd3417bb3baad1605df34"", ""filename"": ""sapi/apache2handler/sapi_apache2.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/php/php-src/blob/23b057742e3cf199612fa8050ae86cae675e214e/sapi/apache2handler/sapi_apache2.c"", ""raw_url"": ""https://github.com/php/php-src/raw/23b057742e3cf199612fa8050ae86cae675e214e/sapi/apache2handler/sapi_apache2.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/sapi/apache2handler/sapi_apache2.c?ref=23b057742e3cf199612fa8050ae86cae675e214e"", ""patch"": ""@@ -678,6 +678,7 @@ zend_first_try {\n \tif (!parent_req) {\n \t\tphp_apache_request_dtor(r TSRMLS_CC);\n \t\tctx->request_processed = 1;\n+\t\tapr_brigade_cleanup(brigade);\n \t\tbucket = apr_bucket_eos_create(r->connection->bucket_alloc);\n \t\tAPR_BRIGADE_INSERT_TAIL(brigade, bucket);\n ""}","static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
		apr_brigade_cleanup(brigade);
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}
","static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}
",C,"		apr_brigade_cleanup(brigade);
",,,"@@ -678,6 +678,7 @@ zend_first_try {
 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
+		apr_brigade_cleanup(brigade);
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 ",php-src,23b057742e3cf199612fa8050ae86cae675e214e,1ba3314335b8bb7c86c24443588d5ef9c55d4a44,1,"static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
//fix_flaw_line_below:
//		apr_brigade_cleanup(brigade);
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}
",182200,"static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}
","static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
		apr_brigade_cleanup(brigade);
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}
","The provided code defines a function `php_handler` that processes incoming HTTP requests for PHP scripts in an Apache server environment. It initializes a context for the PHP request, checks various conditions such as the request handler type and file existence, and sets up CGI variables. The function handles different scenarios, including executing PHP scripts or highlighting source code, while managing memory and cleanup operations. It also logs errors for missing scripts or directory access attempts. Finally, it passes the output to the next filter in the Apache processing chain and ensures proper cleanup of resources after the request is processed.","The code defines a function that handles HTTP requests for PHP scripts within an Apache server. It initializes a context for the request, checks the request type and file validity, and sets up necessary environment variables. The function processes the request by either executing the PHP script or displaying its source code, while managing memory and logging errors for issues like missing files or unauthorized access. After processing, it passes the output to the next stage in the server's filter chain and ensures proper cleanup of resources to maintain server stability and performance.","The vulnerability in the original code arises from improper handling of the `brigade` variable, which can lead to a corrupted state if an error occurs during the shutdown process. Specifically, if the request fails, the `brigade` may not be cleaned up correctly, potentially causing memory leaks or undefined behavior. The fix addresses this issue by ensuring that the `apr_brigade_cleanup(brigade)` function is called to clean up the `brigade` before it is used again or after the request is processed. This guarantees that the `brigade` is in a valid state, thus enhancing the stability and reliability of the code.","The vulnerability in the original code stems from inadequate management of a data structure that can become corrupted if an error occurs during the shutdown process. This corruption can lead to memory leaks or unpredictable behavior, compromising the stability of the application. The fix addresses this issue by implementing a cleanup procedure to ensure that the data structure is properly reset and freed before it is reused or after the request is completed. This proactive cleanup prevents the potential for corrupted states, thereby enhancing the overall reliability and performance of the application.","The vulnerability was fixed by adding a call to `apr_brigade_cleanup(brigade)` to ensure that the `brigade` variable is properly cleaned up after each request, particularly in cases where an error occurs during shutdown. This cleanup is crucial to prevent the `brigade` from ending up in a corrupted state, which could lead to memory leaks or undefined behavior. Additionally, the code ensures that the `brigade` is initialized correctly before use, and it is registered for cleanup with the appropriate pool, thereby maintaining the integrity of the memory management throughout the request lifecycle.","The vulnerability was addressed by implementing a cleanup procedure to ensure that the data structure is properly reset and freed after each request, particularly in error scenarios. This proactive approach prevents the data structure from becoming corrupted, which could lead to memory leaks or unpredictable behavior. By ensuring that the cleanup occurs consistently, the code enhances memory management and maintains the integrity of the application. This fix ultimately improves the stability and reliability of the system, safeguarding it against potential issues arising from improper handling of resources during the shutdown process.","CWE-401, CWE-404, CWE-459, CWE-761, CWE-772, CWE-775, CWE-226, CWE-762, CWE-908, CWE-415",N,-1.0,"4, 4","5,5","4,5","4,4"
1,1,184492,184492,,Remote,Not required,,CVE-2012-2872,https://www.cvedetails.com/cve/CVE-2012-2872/,CWE-79,Medium,,Partial,,2012-08-31,4.3,Cross-site scripting (XSS) vulnerability in an SSL interstitial page in Google Chrome before 21.0.1180.89 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.,2018-10-30,XSS ,3,https://github.com/chromium/chromium/commit/68b6502084af7e2021f7321633f5fbb5f997a58b,68b6502084af7e2021f7321633f5fbb5f997a58b,"Properly EscapeForHTML potentially malicious input from X.509 certificates.

BUG=142956

TEST=Create an X.509 certificate with a CN field that contains JavaScript.
When you get the SSL error screen, check that the HTML + JavaScript is
escape instead of being treated as HTML and/or script.

Review URL: https://chromiumcodereview.appspot.com/10827364

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@152210 0039d316-1c4b-4281-b951-d872f2087c98",2,chrome/browser/ssl/ssl_error_info.cc,"{""sha"": ""d33960e55ff85b6899415bd0be1f0f9e14daca04"", ""filename"": ""chrome/browser/ssl/ssl_error_info.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/68b6502084af7e2021f7321633f5fbb5f997a58b/chrome/browser/ssl/ssl_error_info.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/68b6502084af7e2021f7321633f5fbb5f997a58b/chrome/browser/ssl/ssl_error_info.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ssl/ssl_error_info.cc?ref=68b6502084af7e2021f7321633f5fbb5f997a58b"", ""patch"": ""@@ -12,6 +12,7 @@\n #include \""grit/chromium_strings.h\""\n #include \""grit/generated_resources.h\""\n #include \""net/base/cert_status_flags.h\""\n+#include \""net/base/escape.h\""\n #include \""net/base/net_errors.h\""\n #include \""net/base/ssl_info.h\""\n #include \""ui/base/l10n/l10n_util.h\""\n@@ -55,7 +56,8 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,\n       details =\n           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,\n                                      UTF8ToUTF16(request_url.host()),\n-                                     UTF8ToUTF16(dns_names[i]),\n+                                     net::EscapeForHTML(\n+                                         UTF8ToUTF16(dns_names[i])),\n                                      UTF8ToUTF16(request_url.host()));\n       short_description = l10n_util::GetStringUTF16(\n           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);\n@@ -64,7 +66,7 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,\n       extra_info.push_back(\n           l10n_util::GetStringFUTF16(\n               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,\n-              UTF8ToUTF16(cert->subject().common_name),\n+              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),\n               UTF8ToUTF16(request_url.host())));\n       break;\n     }""}","SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
                                     net::EscapeForHTML(
                                         UTF8ToUTF16(dns_names[i])),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}
","SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
                                     UTF8ToUTF16(dns_names[i]),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
              UTF8ToUTF16(cert->subject().common_name),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}
",C,"                                     net::EscapeForHTML(
                                         UTF8ToUTF16(dns_names[i])),
              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
","                                     UTF8ToUTF16(dns_names[i]),
              UTF8ToUTF16(cert->subject().common_name),
",,"@@ -12,6 +12,7 @@
 #include ""grit/chromium_strings.h""
 #include ""grit/generated_resources.h""
 #include ""net/base/cert_status_flags.h""
+#include ""net/base/escape.h""
 #include ""net/base/net_errors.h""
 #include ""net/base/ssl_info.h""
 #include ""ui/base/l10n/l10n_util.h""
@@ -55,7 +56,8 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
-                                     UTF8ToUTF16(dns_names[i]),
+                                     net::EscapeForHTML(
+                                         UTF8ToUTF16(dns_names[i])),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
@@ -64,7 +66,7 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
-              UTF8ToUTF16(cert->subject().common_name),
+              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
               UTF8ToUTF16(request_url.host())));
       break;
     }",Chrome,68b6502084af7e2021f7321633f5fbb5f997a58b,4150ecc30d10d0f211033346f10611e3c6083160,1,"SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      // If the certificate contains multiple DNS names, we choose the most
      // representative one -- either the DNS name that's also in the subject
      // field, or the first one.  If this heuristic turns out to be
      // inadequate, we can consider choosing the DNS name that is the
      // ""closest match"" to the host name in the request URL, or listing all
      // the DNS names with an HTML <ul>.
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
//flaw_line_below:
                                     UTF8ToUTF16(dns_names[i]),
//fix_flaw_line_below:
//                                     net::EscapeForHTML(
//fix_flaw_line_below:
//                                         UTF8ToUTF16(dns_names[i])),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
//flaw_line_below:
              UTF8ToUTF16(cert->subject().common_name),
//fix_flaw_line_below:
//              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        // Then it must be not yet valid.  We don't check that it is not yet
        // valid as there is still a very unlikely chance that the cert might
        // have become valid since the error occurred.
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}
",184492,"SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
                                     UTF8ToUTF16(dns_names[i]),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
              UTF8ToUTF16(cert->subject().common_name),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}
","SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
                                     net::EscapeForHTML(
                                         UTF8ToUTF16(dns_names[i])),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}
","The `SSLErrorInfo::CreateError` function generates detailed error information related to SSL certificate issues based on the specified `ErrorType`. It constructs a title, detailed message, short description, and additional information tailored to various error types, such as invalid common names, expired certificates, or weak keys. The function retrieves relevant data from the provided `X509Certificate` and `request_url`, ensuring that the error messages are localized using the `l10n_util` utility. Finally, it returns an `SSLErrorInfo` object encapsulating all the generated information, facilitating user-friendly error reporting in SSL contexts.","The provided code defines a function that generates detailed error information related to SSL certificate issues based on specific error types. It constructs a title, detailed message, short description, and additional context tailored to various certificate problems, such as invalid names, expiration, or weak security. The function retrieves necessary data from a certificate and a request URL, ensuring that the messages are appropriately localized for user comprehension. Ultimately, it returns an object containing all the generated information, enabling effective and user-friendly error reporting in SSL-related scenarios.","The vulnerability in the original code stemmed from the lack of proper escaping of potentially malicious input from X.509 certificates, specifically in the common name field. This oversight could allow an attacker to inject JavaScript or other harmful content, which would be executed in the context of the user's browser when displaying SSL error messages. The fix involved using an escaping function to sanitize the common name and DNS names before including them in the error details. This ensures that any potentially harmful characters are converted to their HTML-safe equivalents, preventing script execution and enhancing security.","The vulnerability in the original code arose from the failure to properly escape potentially malicious input from X.509 certificates, particularly in the common name field. This oversight could allow an attacker to inject JavaScript, which would be executed in the user's browser when displaying SSL error messages, leading to cross-site scripting attacks. The fix involved implementing an escaping mechanism to sanitize the common name and related fields before they were included in the error messages. This ensures that any harmful characters are converted to their HTML-safe equivalents, effectively preventing script execution and enhancing overall security.","The vulnerability was fixed by incorporating the `net::EscapeForHTML` function to sanitize potentially malicious input from the X.509 certificate's common name and DNS names. In the updated code, this function is applied to the common name and the selected DNS name before they are included in the error details and extra information. By escaping these values, any harmful characters are converted to their HTML-safe equivalents, preventing the execution of injected JavaScript when displaying SSL error messages. This change effectively mitigates the risk of cross-site scripting attacks in the error reporting process.","The vulnerability was fixed by implementing a mechanism to sanitize potentially harmful input from the X.509 certificate's common name and DNS names before they were displayed in error messages. This involved escaping any characters that could be interpreted as HTML or JavaScript, ensuring that any malicious content would be rendered harmless when shown to users. By converting these inputs into their safe HTML representations, the fix effectively prevented the execution of injected scripts, thereby mitigating the risk of cross-site scripting attacks and enhancing the overall security of the error reporting process.","CWE-79,CWE-80,CWE-116,CWE-74,CWE-83,CWE-87,CWE-85,CWE-84,CWE-82,CWE-81",Y,1.0,"4,5","3, 3","5, 4","4,4"
2,2,185960,185960,,Remote,Not required,,CVE-2016-5147,https://www.cvedetails.com/cve/CVE-2016-5147/,CWE-79,Medium,,Partial,,2016-09-11,4.3,"Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, mishandles deferred page loads, which allows remote attackers to inject arbitrary web script or HTML via a crafted web site, aka *Universal XSS (UXSS).*",2017-08-12,XSS ,3,https://github.com/chromium/chromium/commit/5472db1c7eca35822219d03be5c817d9a9258c11,5472db1c7eca35822219d03be5c817d9a9258c11,"Always call UpdateCompositedScrollOffset, not just for the root layer

Bug: 927560
Change-Id: I1d5522aae4f11dd3f5b8947bb089bac1bf19bdb4
Reviewed-on: https://chromium-review.googlesource.com/c/1452701
Reviewed-by: Chris Harrelson <chrishtr@chromium.org>
Commit-Queue: Mason Freed <masonfreed@chromium.org>
Cr-Commit-Position: refs/heads/master@{#628942}",1,third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc,"{""sha"": ""7f1f0a4890e03135c6d704b67d0de508ffda6c7d"", ""filename"": ""third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/5472db1c7eca35822219d03be5c817d9a9258c11/third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5472db1c7eca35822219d03be5c817d9a9258c11/third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc?ref=5472db1c7eca35822219d03be5c817d9a9258c11"", ""patch"": ""@@ -2159,7 +2159,9 @@ void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {\n     DCHECK(Layer()->HasCompositedLayerMapping());\n     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();\n     bool handled_scroll =\n-        Layer()->IsRootLayer() && scrolling_coordinator &&\n+        (Layer()->IsRootLayer() ||\n+         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&\n+        scrolling_coordinator &&\n         scrolling_coordinator->UpdateCompositedScrollOffset(this);\n \n     if (!handled_scroll) {""}","void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        (Layer()->IsRootLayer() ||
         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
        scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
","void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        Layer()->IsRootLayer() && scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
",C,"        (Layer()->IsRootLayer() ||
         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
        scrolling_coordinator &&
","        Layer()->IsRootLayer() && scrolling_coordinator &&
",,"@@ -2159,7 +2159,9 @@ void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
-        Layer()->IsRootLayer() && scrolling_coordinator &&
+        (Layer()->IsRootLayer() ||
+         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
+        scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {",Chrome,5472db1c7eca35822219d03be5c817d9a9258c11,756828f7b127d39fb9863dc0c5db67640a88724f,1,"void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
//flaw_line_below:
        Layer()->IsRootLayer() && scrolling_coordinator &&
//fix_flaw_line_below:
//        (Layer()->IsRootLayer() ||
//fix_flaw_line_below:
//         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
//fix_flaw_line_below:
//        scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        // In non-BGPT mode, we need to do a full sub-tree update here, because
        // we need to update the position property to compute
        // offset_to_transform_parent. For more context, see the comment from
        // chrishtr@ here:
        // https://chromium-review.googlesource.com/c/chromium/src/+/1403639/6/third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    // If we have fixed elements and we scroll the root layer we might
    // change compositing since the fixed elements might now overlap a
    // composited layer.
    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
",185960,"void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        Layer()->IsRootLayer() && scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
","void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        (Layer()->IsRootLayer() ||
         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
        scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
","The `UpdateCompositingLayersAfterScroll` function is responsible for managing the update of compositing layers in a scrollable area after a scroll event occurs. It first checks if the compositor is in compositing mode and whether composited scrolling is being used. If so, it attempts to update the scroll offset for the root layer via the scrolling coordinator. If the scroll is not handled, it marks the layer for a graphics update unless certain runtime features are enabled. Additionally, if the layer is the root layer and the associated frame has viewport-constrained objects, it requests an update for compositing inputs, ensuring that the visual representation remains accurate after scrolling.","The function manages updates to compositing layers following a scroll event in a scrollable area. It first verifies if the compositor is active and whether composited scrolling is in use. If so, it attempts to adjust the scroll offset for the primary layer. If the adjustment is unsuccessful, it marks the layer for a graphics update unless specific features are enabled. Additionally, if the primary layer is involved and the associated frame contains constrained objects, it requests an update for compositing inputs, ensuring that the visual output accurately reflects any changes resulting from the scroll action.","The vulnerability in the original code stemmed from the conditional check that only allowed the scroll offset to be updated for the root layer, potentially leaving other layers unresponsive to scroll events. This could lead to inconsistent rendering and user experience issues. The fix involved modifying the condition to always call the scroll offset update function, regardless of whether the layer is the root layer or not, while still considering specific runtime features. This change ensures that all relevant layers are updated appropriately, enhancing the robustness of the compositing process and preventing rendering inconsistencies.","The vulnerability in the original code arose from the limitation that only the primary layer could update its scroll offset, which could result in other layers not responding to scroll events. This oversight could lead to rendering inconsistencies and a poor user experience, as some layers might not reflect the intended visual changes after scrolling. The fix addressed this issue by ensuring that the scroll offset update function is called for all relevant layers, not just the primary one. This change enhances the overall responsiveness and accuracy of the rendering process, ensuring that all layers are properly updated during scrolling.","The vulnerability was fixed by modifying the condition that determines when to call the `UpdateCompositedScrollOffset` function. In the original code, this function was only invoked for the root layer, which limited the responsiveness of other layers to scroll events. The updated code now checks if the layer is either the root layer or if specific runtime features are enabled, ensuring that the scroll offset is updated for all relevant layers. This change guarantees that all layers can respond appropriately to scrolling, thereby improving the consistency and accuracy of the rendering process across the entire compositing structure.","The vulnerability was fixed by broadening the conditions under which the scroll offset update function is called. Previously, the update was restricted to only the primary layer, which could lead to unresponsive behavior in other layers during scrolling. The revised code now allows the update function to be invoked for all relevant layers, ensuring that they can all respond to scroll events appropriately. This enhancement improves the overall rendering consistency and responsiveness, allowing for a more accurate visual representation during scrolling actions across the entire compositing structure.","CWE-664, CWE-821, CWE-669, CWE-706, CWE-691, CWE-682, CWE-695, CWE-665, CWE-693, CWE-710",N,-1.0,"4,5","5,5","4,4","3, 4"
3,3,186016,186016,,Remote,Not required,,CVE-2016-5191,https://www.cvedetails.com/cve/CVE-2016-5191/,CWE-79,Medium,,Partial,,2016-12-17,4.3,"Bookmark handling in Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android had insufficient validation of supplied data, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via crafted HTML pages, as demonstrated by an interpretation conflict between userinfo and scheme in an http://javascript:",2018-01-04,XSS ,12,https://github.com/chromium/chromium/commit/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4,fa34e547d6ee25ea0692436ba7462ed0a0ef45f4,"Prevent interpretating userinfo as url scheme when editing bookmarks

Chrome's Edit Bookmark dialog formats urls for display such that a
url of http://javascript:scripttext@host.com is later converted to a
javascript url scheme, allowing persistence of a script injection
attack within the user's bookmarks.

This fix prevents such misinterpretations by always showing the
scheme when a userinfo component is present within the url.

BUG=639126

Review-Url: https://codereview.chromium.org/2368593002
Cr-Commit-Position: refs/heads/master@{#422467}",4,chrome/browser/ui/bookmarks/bookmark_utils.cc,"{""sha"": ""ffebacaa0f6864fd57e0d0cda9b2dbb08552a13c"", ""filename"": ""chrome/browser/ui/bookmarks/bookmark_utils.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 5, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/bookmarks/bookmark_utils.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/bookmarks/bookmark_utils.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/bookmarks/bookmark_utils.cc?ref=fa34e547d6ee25ea0692436ba7462ed0a0ef45f4"", ""patch"": ""@@ -126,13 +126,20 @@ void ToggleBookmarkBarWhenVisible(content::BrowserContext* browser_context) {\n \n base::string16 FormatBookmarkURLForDisplay(const GURL& url) {\n   // Because this gets re-parsed by FixupURL(), it's safe to omit the scheme\n-  // and trailing slash, and unescape most characters.  However, it's\n+  // and trailing slash, and unescape most characters. However, it's\n   // important not to drop any username/password, or unescape anything that\n   // changes the URL's meaning.\n-  return url_formatter::FormatUrl(\n-      url, url_formatter::kFormatUrlOmitAll &\n-               ~url_formatter::kFormatUrlOmitUsernamePassword,\n-      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);\n+  url_formatter::FormatUrlTypes format_types =\n+      url_formatter::kFormatUrlOmitAll &\n+      ~url_formatter::kFormatUrlOmitUsernamePassword;\n+\n+  // If username is present, we must not omit the scheme because FixupURL() will\n+  // subsequently interpret the username as a scheme. crbug.com/639126\n+  if (url.has_username())\n+    format_types &= ~url_formatter::kFormatUrlOmitHTTP;\n+\n+  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,\n+                                  nullptr, nullptr, nullptr);\n }\n \n bool IsAppsShortcutEnabled(Profile* profile) {""}<_**next**_>{""sha"": ""1a5bf29d3599fce20c987c7c997a9c80aa331c7a"", ""filename"": ""chrome/browser/ui/bookmarks/bookmark_utils.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/bookmarks/bookmark_utils.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/bookmarks/bookmark_utils.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/bookmarks/bookmark_utils.h?ref=fa34e547d6ee25ea0692436ba7462ed0a0ef45f4"", ""patch"": ""@@ -53,9 +53,8 @@ void GetURLAndTitleToBookmark(content::WebContents* web_contents,\n // all tabs. This is a preference modifier, not a visual modifier.\n void ToggleBookmarkBarWhenVisible(content::BrowserContext* browser_context);\n \n-// Returns a formatted version of |url| appropriate to display to a user with\n-// the given |prefs|, which may be NULL.  When re-parsing this URL, clients\n-// should call url_formatter::FixupURL().\n+// Returns a formatted version of |url| appropriate to display to a user.\n+// When re-parsing this URL, clients should call url_formatter::FixupURL().\n base::string16 FormatBookmarkURLForDisplay(const GURL& url);\n \n // Returns whether the Apps shortcut is enabled. If true, then the visibility""}<_**next**_>{""sha"": ""4098467fc081af1263246bbe49d32fbea47d7ae9"", ""filename"": ""chrome/browser/ui/cocoa/bookmarks/bookmark_editor_controller_unittest.mm"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 0, ""changes"": 39, ""blob_url"": ""https://github.com/chromium/chromium/blob/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/cocoa/bookmarks/bookmark_editor_controller_unittest.mm"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/cocoa/bookmarks/bookmark_editor_controller_unittest.mm"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/cocoa/bookmarks/bookmark_editor_controller_unittest.mm?ref=fa34e547d6ee25ea0692436ba7462ed0a0ef45f4"", ""patch"": ""@@ -259,6 +259,45 @@ void TearDown() override {\n   [controller_ cancel:nil];\n }\n \n+using BookmarkEditorControllerEditKeepsSchemeTest = CocoaProfileTest;\n+TEST_F(BookmarkEditorControllerEditKeepsSchemeTest, EditKeepsScheme) {\n+  // Edits the bookmark and ensures resulting URL keeps the same scheme, even\n+  // when userinfo is present in the URL\n+  ASSERT_TRUE(profile());\n+\n+  BookmarkModel* model = BookmarkModelFactory::GetForBrowserContext(profile());\n+  const BookmarkNode* kParent = model->bookmark_bar_node();\n+  const base::string16 kTitle = ASCIIToUTF16(\""EditingKeepsScheme\"");\n+\n+  const GURL kUrl = GURL(\""http://javascript:scripttext@example.com/\"");\n+  const BookmarkNode* kNode = model->AddURL(kParent, 0, base::string16(), kUrl);\n+\n+  BookmarkEditorController* controller = [[BookmarkEditorController alloc]\n+      initWithParentWindow:test_window()\n+                   profile:profile()\n+                    parent:kParent\n+                      node:kNode\n+                       url:GURL()\n+                     title:base::string16()\n+             configuration:BookmarkEditor::SHOW_TREE];\n+\n+  [controller runAsModalSheet];\n+\n+  // We expect only the trailing / to be trimmed when userinfo is present\n+  EXPECT_NSEQ(base::SysUTF8ToNSString(kUrl.spec()),\n+              [[controller displayURL] stringByAppendingString:@\""/\""]);\n+\n+  [controller setDisplayName:base::SysUTF16ToNSString(kTitle)];\n+\n+  EXPECT_TRUE([controller okButtonEnabled]);\n+  [controller ok:nil];\n+\n+  ASSERT_EQ(1, kParent->child_count());\n+  const BookmarkNode* kChild = kParent->GetChild(0);\n+  EXPECT_EQ(kTitle, kChild->GetTitle());\n+  EXPECT_EQ(kUrl, kChild->url());\n+}\n+\n class BookmarkEditorControllerTreeTest : public CocoaProfileTest {\n \n  public:""}<_**next**_>{""sha"": ""2abe3d77823e2f144ab3c2c62b5117ac182d68d0"", ""filename"": ""chrome/browser/ui/views/bookmarks/bookmark_editor_view_unittest.cc"", ""status"": ""modified"", ""additions"": 35, ""deletions"": 0, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/views/bookmarks/bookmark_editor_view_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fa34e547d6ee25ea0692436ba7462ed0a0ef45f4/chrome/browser/ui/views/bookmarks/bookmark_editor_view_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/bookmarks/bookmark_editor_view_unittest.cc?ref=fa34e547d6ee25ea0692436ba7462ed0a0ef45f4"", ""patch"": ""@@ -73,6 +73,13 @@ class BookmarkEditorViewTest : public testing::Test {\n       editor_->url_tf_->SetText(text);\n   }\n \n+  base::string16 GetURLText() const {\n+    if (editor_->details_.type != BookmarkEditor::EditDetails::NEW_FOLDER)\n+      return editor_->url_tf_->text();\n+\n+    return base::string16();\n+  }\n+\n   void ApplyEdits() {\n     editor_->ApplyEdits();\n   }\n@@ -332,6 +339,34 @@ TEST_F(BookmarkEditorViewTest, ChangeTitleNoTree) {\n   EXPECT_EQ(ASCIIToUTF16(\""new_a\""), new_node->GetTitle());\n }\n \n+// Edits the bookmark and ensures resulting URL keeps the same scheme, even\n+// when userinfo is present in the URL\n+TEST_F(BookmarkEditorViewTest, EditKeepsScheme) {\n+  const BookmarkNode* kBBNode = model_->bookmark_bar_node();\n+\n+  const GURL kUrl = GURL(\""http://javascript:scripttext@example.com/\"");\n+\n+  CreateEditor(profile_.get(), kBBNode,\n+               BookmarkEditor::EditDetails::AddNodeInFolder(kBBNode, 1, kUrl,\n+                                                            base::string16()),\n+               BookmarkEditorView::SHOW_TREE);\n+\n+  // We expect only the trailing / to be trimmed when userinfo is present\n+  EXPECT_EQ(ASCIIToUTF16(kUrl.spec()), GetURLText() + ASCIIToUTF16(\""/\""));\n+\n+  const base::string16& kTitle = ASCIIToUTF16(\""EditingKeepsScheme\"");\n+  SetTitleText(kTitle);\n+\n+  ApplyEdits(editor_tree_model()->GetRoot()->GetChild(0));\n+\n+  ASSERT_EQ(4, kBBNode->child_count());\n+\n+  const BookmarkNode* kNewNode = kBBNode->GetChild(1);\n+\n+  EXPECT_EQ(kTitle, kNewNode->GetTitle());\n+  EXPECT_EQ(kUrl, kNewNode->url());\n+}\n+\n // Creates a new folder.\n TEST_F(BookmarkEditorViewTest, NewFolder) {\n   const BookmarkNode* bb_node = model_->bookmark_bar_node();""}"," base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
  // and trailing slash, and unescape most characters. However, it's
  url_formatter::FormatUrlTypes format_types =
      url_formatter::kFormatUrlOmitAll &
      ~url_formatter::kFormatUrlOmitUsernamePassword;

  // If username is present, we must not omit the scheme because FixupURL() will
  // subsequently interpret the username as a scheme. crbug.com/639126
  if (url.has_username())
    format_types &= ~url_formatter::kFormatUrlOmitHTTP;

  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
                                  nullptr, nullptr, nullptr);
 }
"," base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
  return url_formatter::FormatUrl(
      url, url_formatter::kFormatUrlOmitAll &
               ~url_formatter::kFormatUrlOmitUsernamePassword,
      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
 }
",C,"  // and trailing slash, and unescape most characters. However, it's
  url_formatter::FormatUrlTypes format_types =
      url_formatter::kFormatUrlOmitAll &
      ~url_formatter::kFormatUrlOmitUsernamePassword;

  // If username is present, we must not omit the scheme because FixupURL() will
  // subsequently interpret the username as a scheme. crbug.com/639126
  if (url.has_username())
    format_types &= ~url_formatter::kFormatUrlOmitHTTP;

  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
                                  nullptr, nullptr, nullptr);
","  return url_formatter::FormatUrl(
      url, url_formatter::kFormatUrlOmitAll &
               ~url_formatter::kFormatUrlOmitUsernamePassword,
      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
",,"@@ -126,13 +126,20 @@ void ToggleBookmarkBarWhenVisible(content::BrowserContext* browser_context) {
 
 base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
   // Because this gets re-parsed by FixupURL(), it's safe to omit the scheme
-  // and trailing slash, and unescape most characters.  However, it's
+  // and trailing slash, and unescape most characters. However, it's
   // important not to drop any username/password, or unescape anything that
   // changes the URL's meaning.
-  return url_formatter::FormatUrl(
-      url, url_formatter::kFormatUrlOmitAll &
-               ~url_formatter::kFormatUrlOmitUsernamePassword,
-      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
+  url_formatter::FormatUrlTypes format_types =
+      url_formatter::kFormatUrlOmitAll &
+      ~url_formatter::kFormatUrlOmitUsernamePassword;
+
+  // If username is present, we must not omit the scheme because FixupURL() will
+  // subsequently interpret the username as a scheme. crbug.com/639126
+  if (url.has_username())
+    format_types &= ~url_formatter::kFormatUrlOmitHTTP;
+
+  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
+                                  nullptr, nullptr, nullptr);
 }
 
 bool IsAppsShortcutEnabled(Profile* profile) {",Chrome,fa34e547d6ee25ea0692436ba7462ed0a0ef45f4,60cf29f2af9a364c215f71c9ac8fdd92c16b82b4,1," base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
   // Because this gets re-parsed by FixupURL(), it's safe to omit the scheme
//flaw_line_below:
  // and trailing slash, and unescape most characters.  However, it's
//fix_flaw_line_below:
//  // and trailing slash, and unescape most characters. However, it's
   // important not to drop any username/password, or unescape anything that
   // changes the URL's meaning.
//flaw_line_below:
  return url_formatter::FormatUrl(
//flaw_line_below:
      url, url_formatter::kFormatUrlOmitAll &
//flaw_line_below:
               ~url_formatter::kFormatUrlOmitUsernamePassword,
//flaw_line_below:
      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
//fix_flaw_line_below:
//  url_formatter::FormatUrlTypes format_types =
//fix_flaw_line_below:
//      url_formatter::kFormatUrlOmitAll &
//fix_flaw_line_below:
//      ~url_formatter::kFormatUrlOmitUsernamePassword;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  // If username is present, we must not omit the scheme because FixupURL() will
//fix_flaw_line_below:
//  // subsequently interpret the username as a scheme. crbug.com/639126
//fix_flaw_line_below:
//  if (url.has_username())
//fix_flaw_line_below:
//    format_types &= ~url_formatter::kFormatUrlOmitHTTP;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
//fix_flaw_line_below:
//                                  nullptr, nullptr, nullptr);
 }
",186016," base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
  return url_formatter::FormatUrl(
      url, url_formatter::kFormatUrlOmitAll &
               ~url_formatter::kFormatUrlOmitUsernamePassword,
      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
 }
"," base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
  // and trailing slash, and unescape most characters. However, it's
  url_formatter::FormatUrlTypes format_types =
      url_formatter::kFormatUrlOmitAll &
      ~url_formatter::kFormatUrlOmitUsernamePassword;

  // If username is present, we must not omit the scheme because FixupURL() will
  // subsequently interpret the username as a scheme. crbug.com/639126
  if (url.has_username())
    format_types &= ~url_formatter::kFormatUrlOmitHTTP;

  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
                                  nullptr, nullptr, nullptr);
 }
","The provided code defines a function, `FormatBookmarkURLForDisplay`, which takes a `GURL` object representing a URL as input and formats it for display purposes. It utilizes the `url_formatter::FormatUrl` function to format the URL while omitting certain components, specifically all parts except for the username and password. The formatting rules also include unescaping spaces in the URL. The function returns a `string16` type, which is a string representation suitable for displaying the formatted URL, ensuring that sensitive information like username and password is not included in the output.","The code defines a function that formats a given URL for display by applying specific formatting rules. It omits certain components of the URL, ensuring that sensitive information, such as usernames and passwords, is not included in the output. Additionally, the function handles spaces in the URL by unescaping them, making the final output more user-friendly. The result is a string representation of the formatted URL, tailored for presentation purposes, while maintaining the integrity of the original URL structure without exposing sensitive data.","The vulnerability in the original code arises from the potential misinterpretation of userinfo components, such as usernames, as URL schemes when formatting URLs for display. This could allow for script injection attacks, where a URL like `http://javascript:scripttext@host.com` could be incorrectly processed, leading to security risks. The fixed code addresses this issue by checking if the URL contains a username and ensuring that the scheme is not omitted in such cases. By modifying the `format_types` to include the scheme when userinfo is present, the fix prevents the misinterpretation and enhances the security of the bookmark editing process.","The vulnerability in the original code stems from the potential for userinfo components, such as usernames, to be misinterpreted as URL schemes during the formatting process. This could lead to security issues, such as script injection attacks, where malicious URLs could be executed when bookmarks are edited. The fix addresses this vulnerability by ensuring that the URL scheme is always included in the display formatting whenever a userinfo component is present. This change prevents the misinterpretation of the URL structure, thereby enhancing security and protecting users from potential attacks through their bookmarks.","The vulnerability was fixed by modifying the `format_types` variable to ensure that the URL scheme is not omitted when a username is present in the URL. In the changed code, a conditional check was added to determine if the URL contains a username, and if so, the `kFormatUrlOmitHTTP` flag is removed from `format_types`. This adjustment guarantees that the scheme is always displayed, preventing the misinterpretation of userinfo as a scheme, which could lead to script injection attacks. Consequently, the formatting process now securely handles URLs with userinfo components during bookmark editing.","The vulnerability was addressed by implementing a check to ensure that the URL scheme is always included when a username is present in the URL. This was achieved by modifying the formatting rules to remove the restriction that would omit the scheme in such cases. As a result, the updated code prevents the misinterpretation of userinfo components as URL schemes, which could lead to security risks like script injection attacks. By ensuring that the scheme is displayed alongside any userinfo, the fix enhances the security of the bookmark editing process and protects users from potential exploits.","CWE-73,CWE-74,CWE-20,CWE-79,CWE-116,CWE-707,CWE-159,CWE-641,CWE-644,CWE-646",Y,4.0,"5,4","4, 4","4,5","4,4"
4,4,186246,186246,,Remote,Not required,,CVE-2016-1652,https://www.cvedetails.com/cve/CVE-2016-1652/,CWE-79,Medium,,Partial,,2016-04-18,4.3,"Cross-site scripting (XSS) vulnerability in the ModuleSystem::RequireForJsInner function in extensions/renderer/module_system.cc in the Extensions subsystem in Google Chrome before 50.0.2661.75 allows remote attackers to inject arbitrary web script or HTML via a crafted web site, aka *Universal XSS (UXSS).*",2018-10-30,XSS ,5,https://github.com/chromium/chromium/commit/7c5aa07be11cd63d953fbe66370c5869a52170bf,7c5aa07be11cd63d953fbe66370c5869a52170bf,"Use install_static::GetAppGuid instead of the hardcoded string in BrandcodeConfigFetcher.

Bug: 769756
Change-Id: Ifdcb0a5145ffad1d563562e2b2ea2390ff074cdc
Reviewed-on: https://chromium-review.googlesource.com/1213178
Reviewed-by: Dominic Battré <battre@chromium.org>
Commit-Queue: Vasilii Sukhanov <vasilii@chromium.org>
Cr-Commit-Position: refs/heads/master@{#590275}",6,chrome/browser/profile_resetter/brandcode_config_fetcher.cc,"{""sha"": ""c15c60c3ac2815695cc024d1e7891827c18383c5"", ""filename"": ""chrome/browser/profile_resetter/brandcode_config_fetcher.cc"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 10, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/7c5aa07be11cd63d953fbe66370c5869a52170bf/chrome/browser/profile_resetter/brandcode_config_fetcher.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7c5aa07be11cd63d953fbe66370c5869a52170bf/chrome/browser/profile_resetter/brandcode_config_fetcher.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/profile_resetter/brandcode_config_fetcher.cc?ref=7c5aa07be11cd63d953fbe66370c5869a52170bf"", ""patch"": ""@@ -9,7 +9,9 @@\n \n #include \""base/callback_helpers.h\""\n #include \""base/macros.h\""\n+#include \""base/strings/stringprintf.h\""\n #include \""base/strings/utf_string_conversions.h\""\n+#include \""build/build_config.h\""\n #include \""chrome/browser/browser_process.h\""\n #include \""chrome/browser/profile_resetter/brandcoded_default_settings.h\""\n #include \""libxml/parser.h\""\n@@ -20,30 +22,34 @@\n #include \""services/network/public/cpp/simple_url_loader.h\""\n #include \""services/network/public/mojom/url_loader_factory.mojom.h\""\n \n+#if defined(OS_WIN)\n+#include \""chrome/install_static/install_util.h\""\n+#endif  // defined(OS_WIN)\n+\n namespace {\n \n-const int kDownloadTimeoutSec = 10;\n-const char kPostXml[] =\n+constexpr char kDefaultAppID[] = \""{8A69D345-D564-463C-AFF1-A69D9E530F96}\"";\n+constexpr int kDownloadTimeoutSec = 10;\n+constexpr char kPostXml[] =\n     \""<?xml version=\\\""1.0\\\"" encoding=\\\""UTF-8\\\""?>\""\n     \""<request\""\n     \""    version=\\\""chromeprofilereset-1.1\\\""\""\n     \""    protocol=\\\""3.0\\\""\""\n     \""    installsource=\\\""profilereset\\\"">\""\n-    \""  <app appid=\\\""{8A69D345-D564-463C-AFF1-A69D9E530F96}\\\"">\""\n-    \""    <data name=\\\""install\\\"" index=\\\""__BRANDCODE_PLACEHOLDER__\\\""/>\""\n+    \""  <app appid=\\\""%s\\\"">\""\n+    \""    <data name=\\\""install\\\"" index=\\\""%s\\\""/>\""\n     \""  </app>\""\n     \""</request>\"";\n \n // Returns the query to the server which can be used to retrieve the config.\n // |brand| is a brand code, it mustn't be empty.\n std::string GetUploadData(const std::string& brand) {\n+  std::string app_id(kDefaultAppID);\n+#if defined(OS_WIN)\n+  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());\n+#endif  // defined(OS_WIN)\n   DCHECK(!brand.empty());\n-  std::string data(kPostXml);\n-  const std::string placeholder(\""__BRANDCODE_PLACEHOLDER__\"");\n-  size_t placeholder_pos = data.find(placeholder);\n-  DCHECK(placeholder_pos != std::string::npos);\n-  data.replace(placeholder_pos, placeholder.size(), brand);\n-  return data;\n+  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());\n }\n \n // Extracts json master prefs from xml.""}"," std::string GetUploadData(const std::string& brand) {
  std::string app_id(kDefaultAppID);
#if defined(OS_WIN)
  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
#endif  // defined(OS_WIN)
   DCHECK(!brand.empty());
  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
 }
"," std::string GetUploadData(const std::string& brand) {
   DCHECK(!brand.empty());
  std::string data(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = data.find(placeholder);
  DCHECK(placeholder_pos != std::string::npos);
  data.replace(placeholder_pos, placeholder.size(), brand);
  return data;
 }
",C,"  std::string app_id(kDefaultAppID);
#if defined(OS_WIN)
  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
#endif  // defined(OS_WIN)
  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
","  std::string data(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = data.find(placeholder);
  DCHECK(placeholder_pos != std::string::npos);
  data.replace(placeholder_pos, placeholder.size(), brand);
  return data;
",,"@@ -9,7 +9,9 @@
 
 #include ""base/callback_helpers.h""
 #include ""base/macros.h""
+#include ""base/strings/stringprintf.h""
 #include ""base/strings/utf_string_conversions.h""
+#include ""build/build_config.h""
 #include ""chrome/browser/browser_process.h""
 #include ""chrome/browser/profile_resetter/brandcoded_default_settings.h""
 #include ""libxml/parser.h""
@@ -20,30 +22,34 @@
 #include ""services/network/public/cpp/simple_url_loader.h""
 #include ""services/network/public/mojom/url_loader_factory.mojom.h""
 
+#if defined(OS_WIN)
+#include ""chrome/install_static/install_util.h""
+#endif  // defined(OS_WIN)
+
 namespace {
 
-const int kDownloadTimeoutSec = 10;
-const char kPostXml[] =
+constexpr char kDefaultAppID[] = ""{8A69D345-D564-463C-AFF1-A69D9E530F96}"";
+constexpr int kDownloadTimeoutSec = 10;
+constexpr char kPostXml[] =
     ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>""
     ""<request""
     ""    version=\""chromeprofilereset-1.1\""""
     ""    protocol=\""3.0\""""
     ""    installsource=\""profilereset\"">""
-    ""  <app appid=\""{8A69D345-D564-463C-AFF1-A69D9E530F96}\"">""
-    ""    <data name=\""install\"" index=\""__BRANDCODE_PLACEHOLDER__\""/>""
+    ""  <app appid=\""%s\"">""
+    ""    <data name=\""install\"" index=\""%s\""/>""
     ""  </app>""
     ""</request>"";
 
 // Returns the query to the server which can be used to retrieve the config.
 // |brand| is a brand code, it mustn't be empty.
 std::string GetUploadData(const std::string& brand) {
+  std::string app_id(kDefaultAppID);
+#if defined(OS_WIN)
+  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
+#endif  // defined(OS_WIN)
   DCHECK(!brand.empty());
-  std::string data(kPostXml);
-  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
-  size_t placeholder_pos = data.find(placeholder);
-  DCHECK(placeholder_pos != std::string::npos);
-  data.replace(placeholder_pos, placeholder.size(), brand);
-  return data;
+  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
 }
 
 // Extracts json master prefs from xml.",Chrome,7c5aa07be11cd63d953fbe66370c5869a52170bf,32582f5489e1e45821e4583886ba5c19845bb2ac,1," std::string GetUploadData(const std::string& brand) {
//fix_flaw_line_below:
//  std::string app_id(kDefaultAppID);
//fix_flaw_line_below:
//#if defined(OS_WIN)
//fix_flaw_line_below:
//  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
//fix_flaw_line_below:
//#endif  // defined(OS_WIN)
   DCHECK(!brand.empty());
//flaw_line_below:
  std::string data(kPostXml);
//flaw_line_below:
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
//flaw_line_below:
  size_t placeholder_pos = data.find(placeholder);
//flaw_line_below:
  DCHECK(placeholder_pos != std::string::npos);
//flaw_line_below:
  data.replace(placeholder_pos, placeholder.size(), brand);
//flaw_line_below:
  return data;
//fix_flaw_line_below:
//  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
 }
",186246," std::string GetUploadData(const std::string& brand) {
   DCHECK(!brand.empty());
  std::string data(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = data.find(placeholder);
  DCHECK(placeholder_pos != std::string::npos);
  data.replace(placeholder_pos, placeholder.size(), brand);
  return data;
 }
"," std::string GetUploadData(const std::string& brand) {
  std::string app_id(kDefaultAppID);
#if defined(OS_WIN)
  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
#endif  // defined(OS_WIN)
   DCHECK(!brand.empty());
  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
 }
","The `GetUploadData` function generates a string containing XML data for uploading, where it replaces a specific placeholder with a provided brand code. It first checks that the input `brand` is not empty using a debug assertion. The function initializes a string `data` with a predefined XML template (`kPostXml`) and searches for the placeholder `__BRANDCODE_PLACEHOLDER__` within this template. Upon finding the placeholder, it replaces it with the actual `brand` value. Finally, the modified XML string is returned, ready for use in an upload operation.","The code defines a function that generates a string formatted as XML for upload purposes, incorporating a specific brand code. It begins by ensuring that the input brand is not empty, which is crucial for data integrity. The function then initializes a string with a predefined XML template and searches for a designated placeholder within this template. Once the placeholder is located, it is replaced with the provided brand code. The final output is the modified XML string, which is ready to be used in an upload operation, ensuring that the brand information is correctly included.","The vulnerability in the original code stemmed from the use of a hardcoded string for the brand code, which could lead to security risks such as exposure to injection attacks or misuse of the application. In the fixed code, this issue was addressed by replacing the hardcoded string with a dynamic value obtained from `install_static::GetAppGuid()`, ensuring that the application ID is generated at runtime and is specific to the installation. This change enhances security by preventing the use of predictable or static values, thereby reducing the risk of exploitation.","The vulnerability in the original code arose from the use of a hardcoded string for a critical identifier, which posed risks such as potential exposure to injection attacks or unauthorized access due to predictability. This static value could be easily exploited by malicious actors. The fix involved replacing the hardcoded string with a dynamically generated identifier that is specific to the application's installation context. This change enhances security by ensuring that the identifier is unique and less predictable, thereby mitigating the risk of exploitation and improving the overall robustness of the application.","The vulnerability was fixed by replacing the hardcoded string used for the application ID with a dynamically generated value obtained from the `install_static::GetAppGuid()` function. This change ensures that the application ID is unique to each installation, reducing the risk of exploitation associated with predictable static values. Additionally, the code now initializes the application ID with a default value and only updates it on Windows systems, enhancing security across different platforms. By using a runtime-generated identifier instead of a fixed string, the code improves its resilience against potential injection attacks and unauthorized access.","The vulnerability was addressed by replacing the hardcoded identifier with a dynamically generated value that is specific to the application's installation context. This change ensures that the identifier is unique for each installation, significantly reducing the risk of exploitation associated with predictable static values. The updated approach allows the application to retrieve the identifier at runtime, enhancing security by making it less susceptible to injection attacks or unauthorized access. Overall, this fix improves the robustness of the application by ensuring that sensitive information is not easily guessable or accessible to malicious actors.","CWE-259, CWE-798, CWE-321, CWE-547, CWE-256, CWE-522, CWE-922, CWE-200, CWE-284, CWE-287",N,-1.0,"4, 5","5, 4","4,5","4,5"
5,5,186366,186366,,Remote,Not required,,CVE-2017-5069,https://www.cvedetails.com/cve/CVE-2017-5069/,CWE-79,Medium,,Partial,,2017-10-27,4.3,"Incorrect MIME type of XSS-Protection reports in Blink in Google Chrome prior to 58.0.3029.81 for Linux, Windows, and Mac, and 58.0.3029.83 for Android, allowed a remote attacker to circumvent Cross-Origin Resource Sharing checks via a crafted HTML page.",2019-10-02,XSS ,1,https://github.com/chromium/chromium/commit/7a0dee9d17d0ee7fd1b40b017442f4952384a7c2,7a0dee9d17d0ee7fd1b40b017442f4952384a7c2,"Prevent regular mode session startup pref type turning to default.

When user loses past session tabs of regular mode after
invoking a new window from the incognito mode.

This was happening because the SessionStartUpPref type was being set
to default, from last, for regular user mode. This was happening in
the RestoreIfNecessary method where the restoration was taking place
for users whose SessionStartUpPref type was set to last.

The fix was to make the protocol of changing the pref type to
default more explicit to incognito users and not regular users
of pref type last.

Bug: 481373
Change-Id: I96efb4cf196949312181c83c6dcd45986ddded13
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1774441
Reviewed-by: Tommy Martino <tmartino@chromium.org>
Reviewed-by: Ramin Halavati <rhalavati@chromium.org>
Commit-Queue: Rohit Agarwal <roagarwal@chromium.org>
Cr-Commit-Position: refs/heads/master@{#691726}",2,chrome/browser/ui/startup/startup_browser_creator.cc,"{""sha"": ""f118e6d27ecca45fecfc48580608159a47d2de24"", ""filename"": ""chrome/browser/ui/startup/startup_browser_creator.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/7a0dee9d17d0ee7fd1b40b017442f4952384a7c2/chrome/browser/ui/startup/startup_browser_creator.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/7a0dee9d17d0ee7fd1b40b017442f4952384a7c2/chrome/browser/ui/startup/startup_browser_creator.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/startup/startup_browser_creator.cc?ref=7a0dee9d17d0ee7fd1b40b017442f4952384a7c2"", ""patch"": ""@@ -468,8 +468,7 @@ SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(\n       pref.type = SessionStartupPref::LAST;\n   }\n \n-  if (pref.type == SessionStartupPref::LAST &&\n-      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {\n+  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {\n     // We don't store session information when incognito. If the user has\n     // chosen to restore last session and launched incognito, fallback to\n     // default launch behavior.""}","SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
    const base::CommandLine& command_line,
    Profile* profile) {
  DCHECK(profile);
  PrefService* prefs = profile->GetPrefs();
  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);

#if defined(OS_CHROMEOS)
  const bool is_first_run =
      user_manager::UserManager::Get()->IsCurrentUserNew();
  const bool did_restart = false;
  StartupBrowserCreator::WasRestarted();
#else
  const bool is_first_run = first_run::IsChromeFirstRun();
  const bool did_restart = StartupBrowserCreator::WasRestarted();
#endif

  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))
    pref.type = SessionStartupPref::DEFAULT;

  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&
      !profile->IsNewProfile()) {
    pref.type = SessionStartupPref::LAST;
  }

  if (!profile->IsGuestSession()) {
    ProfileAttributesEntry* entry = nullptr;
    bool has_entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath(), &entry);

    if (has_entry && entry->IsSigninRequired())
       pref.type = SessionStartupPref::LAST;
   }
 
  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
    pref.type = SessionStartupPref::DEFAULT;
  }

  return pref;
}
","SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
    const base::CommandLine& command_line,
    Profile* profile) {
  DCHECK(profile);
  PrefService* prefs = profile->GetPrefs();
  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);

#if defined(OS_CHROMEOS)
  const bool is_first_run =
      user_manager::UserManager::Get()->IsCurrentUserNew();
  const bool did_restart = false;
  StartupBrowserCreator::WasRestarted();
#else
  const bool is_first_run = first_run::IsChromeFirstRun();
  const bool did_restart = StartupBrowserCreator::WasRestarted();
#endif

  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))
    pref.type = SessionStartupPref::DEFAULT;

  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&
      !profile->IsNewProfile()) {
    pref.type = SessionStartupPref::LAST;
  }

  if (!profile->IsGuestSession()) {
    ProfileAttributesEntry* entry = nullptr;
    bool has_entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath(), &entry);

    if (has_entry && entry->IsSigninRequired())
       pref.type = SessionStartupPref::LAST;
   }
 
  if (pref.type == SessionStartupPref::LAST &&
      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {
    pref.type = SessionStartupPref::DEFAULT;
  }

  return pref;
}
",C,"  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
","  if (pref.type == SessionStartupPref::LAST &&
      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {
",,"@@ -468,8 +468,7 @@ SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
       pref.type = SessionStartupPref::LAST;
   }
 
-  if (pref.type == SessionStartupPref::LAST &&
-      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {
+  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
     // We don't store session information when incognito. If the user has
     // chosen to restore last session and launched incognito, fallback to
     // default launch behavior.",Chrome,7a0dee9d17d0ee7fd1b40b017442f4952384a7c2,278e05fafb1fc77c5d23425c3c1c5ee5a4082f17,1,"SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
    const base::CommandLine& command_line,
    Profile* profile) {
  DCHECK(profile);
  PrefService* prefs = profile->GetPrefs();
  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);

  // IsChromeFirstRun() looks for a sentinel file to determine whether the user
  // is starting Chrome for the first time. On Chrome OS, the sentinel is stored
  // in a location shared by all users and the check is meaningless. Query the
  // UserManager instead to determine whether the user is new.
#if defined(OS_CHROMEOS)
  const bool is_first_run =
      user_manager::UserManager::Get()->IsCurrentUserNew();
  // On ChromeOS restarts force the user to login again. The expectation is that
  // after a login the user gets clean state. For this reason we ignore
  // StartupBrowserCreator::WasRestarted(). However
  // StartupBrowserCreator::WasRestarted has to be called in order to correctly
  // update pref values.
  const bool did_restart = false;
  StartupBrowserCreator::WasRestarted();
#else
  const bool is_first_run = first_run::IsChromeFirstRun();
  const bool did_restart = StartupBrowserCreator::WasRestarted();
#endif

  // The pref has an OS-dependent default value. For the first run only, this
  // default is overridden with SessionStartupPref::DEFAULT so that first run
  // behavior (sync promo, welcome page) is consistently invoked.
  // This applies only if the pref is still at its default and has not been
  // set by the user, managed prefs or policy.
  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))
    pref.type = SessionStartupPref::DEFAULT;

  // The switches::kRestoreLastSession command line switch is used to restore
  // sessions after a browser self restart (e.g. after a Chrome upgrade).
  // However, new profiles can be created from a browser process that has this
  // switch so do not set the session pref to SessionStartupPref::LAST for
  // those as there is nothing to restore.
  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&
      !profile->IsNewProfile()) {
    pref.type = SessionStartupPref::LAST;
  }

  // A browser starting for a profile being unlocked should always restore.
  if (!profile->IsGuestSession()) {
    ProfileAttributesEntry* entry = nullptr;
    bool has_entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath(), &entry);

    if (has_entry && entry->IsSigninRequired())
       pref.type = SessionStartupPref::LAST;
   }
 
//flaw_line_below:
  if (pref.type == SessionStartupPref::LAST &&
//flaw_line_below:
      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {
//fix_flaw_line_below:
//  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
     // We don't store session information when incognito. If the user has
     // chosen to restore last session and launched incognito, fallback to
     // default launch behavior.
    pref.type = SessionStartupPref::DEFAULT;
  }

  return pref;
}
",186366,"SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
    const base::CommandLine& command_line,
    Profile* profile) {
  DCHECK(profile);
  PrefService* prefs = profile->GetPrefs();
  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);

#if defined(OS_CHROMEOS)
  const bool is_first_run =
      user_manager::UserManager::Get()->IsCurrentUserNew();
  const bool did_restart = false;
  StartupBrowserCreator::WasRestarted();
#else
  const bool is_first_run = first_run::IsChromeFirstRun();
  const bool did_restart = StartupBrowserCreator::WasRestarted();
#endif

  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))
    pref.type = SessionStartupPref::DEFAULT;

  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&
      !profile->IsNewProfile()) {
    pref.type = SessionStartupPref::LAST;
  }

  if (!profile->IsGuestSession()) {
    ProfileAttributesEntry* entry = nullptr;
    bool has_entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath(), &entry);

    if (has_entry && entry->IsSigninRequired())
       pref.type = SessionStartupPref::LAST;
   }
 
  if (pref.type == SessionStartupPref::LAST &&
      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {
    pref.type = SessionStartupPref::DEFAULT;
  }

  return pref;
}
","SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
    const base::CommandLine& command_line,
    Profile* profile) {
  DCHECK(profile);
  PrefService* prefs = profile->GetPrefs();
  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);

#if defined(OS_CHROMEOS)
  const bool is_first_run =
      user_manager::UserManager::Get()->IsCurrentUserNew();
  const bool did_restart = false;
  StartupBrowserCreator::WasRestarted();
#else
  const bool is_first_run = first_run::IsChromeFirstRun();
  const bool did_restart = StartupBrowserCreator::WasRestarted();
#endif

  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))
    pref.type = SessionStartupPref::DEFAULT;

  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&
      !profile->IsNewProfile()) {
    pref.type = SessionStartupPref::LAST;
  }

  if (!profile->IsGuestSession()) {
    ProfileAttributesEntry* entry = nullptr;
    bool has_entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath(), &entry);

    if (has_entry && entry->IsSigninRequired())
       pref.type = SessionStartupPref::LAST;
   }
 
  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
    pref.type = SessionStartupPref::DEFAULT;
  }

  return pref;
}
","The provided code defines a function that determines the session startup preferences for a browser based on various conditions, such as whether it's the first run, if the browser was restarted, and the profile type. It retrieves the user's preferences and checks command-line switches to decide if the last session should be restored. Additionally, it considers whether the profile requires sign-in and whether incognito mode should be launched. The function ultimately returns a `SessionStartupPref` object that indicates how the browser should start, ensuring a tailored experience based on user context and settings.","The code defines a function that determines how a browser session should start based on user preferences and specific conditions. It checks if the current user is new or if the browser has been restarted, which influences the startup behavior. The function assesses whether to restore the last session or use default settings, taking into account the profile type and whether sign-in is required. Additionally, it evaluates if incognito mode should be launched based on user preferences and command-line inputs. Ultimately, the function returns a configuration that dictates the browser's startup behavior tailored to the user's context.","The vulnerability in the original code arose from the improper handling of session startup preferences, where the type could inadvertently switch from ""last"" to ""default"" for regular user sessions when incognito mode was invoked. This led to users losing their previous session tabs. The fix explicitly checks if the profile is off-the-record before changing the preference type to ""default,"" ensuring that this behavior only applies to incognito users. By refining the conditions under which the preference type is modified, the code now prevents regular users from experiencing unintended session loss when opening new windows from incognito mode.","The vulnerability in the original code allowed the session startup preference to incorrectly switch from ""last"" to ""default"" for regular users when a new window was opened from incognito mode, resulting in the loss of previously open tabs. This issue occurred during the restoration process, where the preference type was not adequately protected against unintended changes for regular sessions. The fix involved clarifying the conditions under which the preference type could be modified, ensuring that only incognito users would have their preferences changed to ""default,"" thereby preserving the session state for regular users and preventing tab loss.","The vulnerability was fixed by adding a specific check for whether the profile is off-the-record before changing the session startup preference type. In the modified code, the condition that previously allowed the preference type to switch from ""last"" to ""default"" was refined to ensure that this change only occurs for incognito users. By explicitly checking the profile's state, the code prevents the unintended alteration of the preference type for regular users, thereby safeguarding their session tabs. This adjustment ensures that the restoration process respects the user's intended session state, maintaining continuity for regular profiles.","The vulnerability was addressed by implementing a specific condition that restricts the alteration of session startup preferences based on the user's profile type. The fix ensures that the preference type is only changed to ""default"" for incognito users, preventing regular users from experiencing unintended changes that could lead to the loss of their previously open tabs. By clarifying the circumstances under which the preference can be modified, the solution effectively preserves the session state for regular users, maintaining their browsing continuity and preventing disruptions when transitioning between regular and incognito modes.","CWE-284, CWE-287, CWE-288, CWE-269, CWE-732, CWE-642, CWE-488, CWE-285, CWE-266, CWE-639",N,-1.0,"5,4","5, 5","5, 4","4, 4"
6,6,186418,186418,,Remote,Not required,,CVE-2017-5008,https://www.cvedetails.com/cve/CVE-2017-5008/,CWE-79,Medium,,Partial,,2017-02-17,4.3,"Blink in Google Chrome prior to 56.0.2924.76 for Linux, Windows and Mac, and 56.0.2924.87 for Android, allowed attacker controlled JavaScript to be run during the invocation of a private script method, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via a crafted HTML page.",2018-01-04,XSS ,6,https://github.com/chromium/chromium/commit/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9,c093b7a74ddce32dd3b0e0be60f31becc6ce32f9,"Don't touch the prototype chain to get the private script controller.

Prior to this patch, private scripts attempted to get the
""privateScriptController"" property off the global object without verifying if
the property actually exists on the global. If the property hasn't been set yet,
this operation could descend into the prototype chain and potentially return
a named property from the WindowProperties object, leading to release asserts
and general confusion.

BUG=668552

Review-Url: https://codereview.chromium.org/2529163002
Cr-Commit-Position: refs/heads/master@{#434627}",6,third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp,"{""sha"": ""1560d1019cd74abcf6c6d6d16fc0ed9e83f91c1b"", ""filename"": ""third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash-expected.txt"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash-expected.txt?ref=c093b7a74ddce32dd3b0e0be60f31becc6ce32f9"", ""patch"": ""@@ -0,0 +1,2 @@\n+ \n+Test that a named property doesn't interfere with a private script (https://crbug.com/668552). If the test is successful, it should not crash.""}<_**next**_>{""sha"": ""1e410c0447a83fab2da5eb9fb6693d754719d9e8"", ""filename"": ""third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash.html"", ""status"": ""added"", ""additions"": 15, ""deletions"": 0, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/dom/marquee-named-property-crash.html?ref=c093b7a74ddce32dd3b0e0be60f31becc6ce32f9"", ""patch"": ""@@ -0,0 +1,15 @@\n+<!DOCTYPE html>\n+<html>\n+<body>\n+<script>\n+if (window.testRunner)\n+    testRunner.dumpAsText();\n+</script>\n+<img name=\""privateScriptController\"">\n+<marquee></marquee>\n+<div>\n+Test that a named property doesn't interfere with a private script (https://crbug.com/668552).\n+If the test is successful, it should not crash.\n+</div>\n+</body>\n+</html>""}<_**next**_>{""sha"": ""eb4974e91d06882361bb7a1470c0d82fbb358bd7"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.cpp?ref=c093b7a74ddce32dd3b0e0be60f31becc6ce32f9"", ""patch"": ""@@ -57,12 +57,12 @@ static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,\n \n   v8::Local<v8::Context> context = scriptState->context();\n   v8::Local<v8::Object> global = context->Global();\n-  v8::Local<v8::Value> privateScriptController =\n-      global->Get(context, v8String(isolate, \""privateScriptController\""))\n-          .ToLocalChecked();\n-  RELEASE_ASSERT(privateScriptController->IsUndefined() ||\n-                 privateScriptController->IsObject());\n-  if (privateScriptController->IsObject()) {\n+  v8::Local<v8::String> key = v8String(isolate, \""privateScriptController\"");\n+\n+  if (global->HasOwnProperty(context, key).ToChecked()) {\n+    v8::Local<v8::Value> privateScriptController =\n+        global->Get(context, key).ToLocalChecked();\n+    CHECK(privateScriptController->IsObject());\n     v8::Local<v8::Object> privateScriptControllerObject =\n         privateScriptController.As<v8::Object>();\n     v8::Local<v8::Value> importFunctionValue =""}<_**next**_>{""sha"": ""e2571f43f7722dbf99cb78d37b6c9948ff06e6aa"", ""filename"": ""third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.js"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c093b7a74ddce32dd3b0e0be60f31becc6ce32f9/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/bindings/core/v8/PrivateScriptRunner.js?ref=c093b7a74ddce32dd3b0e0be60f31becc6ce32f9"", ""patch"": ""@@ -139,7 +139,7 @@ PrivateScriptController.prototype = {\n     },\n }\n \n-if (typeof window.privateScriptController === 'undefined')\n+if (!window.hasOwnProperty(\""privateScriptController\""))\n     window.privateScriptController = new PrivateScriptController();\n \n // This line must be the last statement of this JS file.""}","static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
                                                       String scriptClassName,
                                                       const char* source,
                                                       size_t size) {
  v8::Isolate* isolate = scriptState->isolate();
  v8::TryCatch block(isolate);
  String sourceString(source, size);
  String fileName = scriptClassName + "".js"";
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
  v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");

  if (global->HasOwnProperty(context, key).ToChecked()) {
    v8::Local<v8::Value> privateScriptController =
        global->Get(context, key).ToLocalChecked();
    CHECK(privateScriptController->IsObject());
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =
        privateScriptControllerObject->Get(context, v8String(isolate, ""import""))
            .ToLocalChecked();
    if (importFunctionValue->IsUndefined()) {
      v8::Local<v8::Function> function;
      if (!v8::FunctionTemplate::New(isolate, importFunction)
               ->GetFunction(context)
               .ToLocal(&function) ||
          !v8CallBoolean(privateScriptControllerObject->Set(
              context, v8String(isolate, ""import""), function))) {
        dumpV8Message(context, block.Message());
        LOG(FATAL)
            << ""Private script error: Setting import function failed. (Class ""
               ""name = ""
            << scriptClassName.utf8().data() << "")"";
      }
    }
  }

  v8::Local<v8::Script> script;
  if (!v8Call(V8ScriptRunner::compileScript(
                  v8String(isolate, sourceString), fileName, String(),
                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,
                  nullptr, NotSharableCrossOrigin),
              script, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: Compile failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }

  v8::Local<v8::Value> result;
  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),
              result, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: installClass() failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }
  return result;
}
","static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
                                                       String scriptClassName,
                                                       const char* source,
                                                       size_t size) {
  v8::Isolate* isolate = scriptState->isolate();
  v8::TryCatch block(isolate);
  String sourceString(source, size);
  String fileName = scriptClassName + "".js"";
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
  v8::Local<v8::Value> privateScriptController =
      global->Get(context, v8String(isolate, ""privateScriptController""))
          .ToLocalChecked();
  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
                 privateScriptController->IsObject());
  if (privateScriptController->IsObject()) {
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =
        privateScriptControllerObject->Get(context, v8String(isolate, ""import""))
            .ToLocalChecked();
    if (importFunctionValue->IsUndefined()) {
      v8::Local<v8::Function> function;
      if (!v8::FunctionTemplate::New(isolate, importFunction)
               ->GetFunction(context)
               .ToLocal(&function) ||
          !v8CallBoolean(privateScriptControllerObject->Set(
              context, v8String(isolate, ""import""), function))) {
        dumpV8Message(context, block.Message());
        LOG(FATAL)
            << ""Private script error: Setting import function failed. (Class ""
               ""name = ""
            << scriptClassName.utf8().data() << "")"";
      }
    }
  }

  v8::Local<v8::Script> script;
  if (!v8Call(V8ScriptRunner::compileScript(
                  v8String(isolate, sourceString), fileName, String(),
                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,
                  nullptr, NotSharableCrossOrigin),
              script, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: Compile failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }

  v8::Local<v8::Value> result;
  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),
              result, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: installClass() failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }
  return result;
}
",C,"  v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");

  if (global->HasOwnProperty(context, key).ToChecked()) {
    v8::Local<v8::Value> privateScriptController =
        global->Get(context, key).ToLocalChecked();
    CHECK(privateScriptController->IsObject());
","  v8::Local<v8::Value> privateScriptController =
      global->Get(context, v8String(isolate, ""privateScriptController""))
          .ToLocalChecked();
  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
                 privateScriptController->IsObject());
  if (privateScriptController->IsObject()) {
",,"@@ -57,12 +57,12 @@ static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
-  v8::Local<v8::Value> privateScriptController =
-      global->Get(context, v8String(isolate, ""privateScriptController""))
-          .ToLocalChecked();
-  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
-                 privateScriptController->IsObject());
-  if (privateScriptController->IsObject()) {
+  v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");
+
+  if (global->HasOwnProperty(context, key).ToChecked()) {
+    v8::Local<v8::Value> privateScriptController =
+        global->Get(context, key).ToLocalChecked();
+    CHECK(privateScriptController->IsObject());
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =",Chrome,c093b7a74ddce32dd3b0e0be60f31becc6ce32f9,42839ee8c1195b25fbe327057e10c54f592b6693,1,"static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
                                                       String scriptClassName,
                                                       const char* source,
                                                       size_t size) {
  v8::Isolate* isolate = scriptState->isolate();
  v8::TryCatch block(isolate);
  String sourceString(source, size);
  String fileName = scriptClassName + "".js"";
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
//flaw_line_below:
  v8::Local<v8::Value> privateScriptController =
//flaw_line_below:
      global->Get(context, v8String(isolate, ""privateScriptController""))
//flaw_line_below:
          .ToLocalChecked();
//flaw_line_below:
  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
//flaw_line_below:
                 privateScriptController->IsObject());
//flaw_line_below:
  if (privateScriptController->IsObject()) {
//fix_flaw_line_below:
//  v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  if (global->HasOwnProperty(context, key).ToChecked()) {
//fix_flaw_line_below:
//    v8::Local<v8::Value> privateScriptController =
//fix_flaw_line_below:
//        global->Get(context, key).ToLocalChecked();
//fix_flaw_line_below:
//    CHECK(privateScriptController->IsObject());
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =
        privateScriptControllerObject->Get(context, v8String(isolate, ""import""))
            .ToLocalChecked();
    if (importFunctionValue->IsUndefined()) {
      v8::Local<v8::Function> function;
      // This is a memory leak, FunctionTemplates are eternal.
      if (!v8::FunctionTemplate::New(isolate, importFunction)
               ->GetFunction(context)
               .ToLocal(&function) ||
          !v8CallBoolean(privateScriptControllerObject->Set(
              context, v8String(isolate, ""import""), function))) {
        dumpV8Message(context, block.Message());
        LOG(FATAL)
            << ""Private script error: Setting import function failed. (Class ""
               ""name = ""
            << scriptClassName.utf8().data() << "")"";
      }
    }
  }

  v8::Local<v8::Script> script;
  if (!v8Call(V8ScriptRunner::compileScript(
                  v8String(isolate, sourceString), fileName, String(),
                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,
                  nullptr, NotSharableCrossOrigin),
              script, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: Compile failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }

  v8::Local<v8::Value> result;
  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),
              result, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: installClass() failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }
  return result;
}
",186418,"static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
                                                       String scriptClassName,
                                                       const char* source,
                                                       size_t size) {
  v8::Isolate* isolate = scriptState->isolate();
  v8::TryCatch block(isolate);
  String sourceString(source, size);
  String fileName = scriptClassName + "".js"";
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
  v8::Local<v8::Value> privateScriptController =
      global->Get(context, v8String(isolate, ""privateScriptController""))
          .ToLocalChecked();
  RELEASE_ASSERT(privateScriptController->IsUndefined() ||
                 privateScriptController->IsObject());
  if (privateScriptController->IsObject()) {
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =
        privateScriptControllerObject->Get(context, v8String(isolate, ""import""))
            .ToLocalChecked();
    if (importFunctionValue->IsUndefined()) {
      v8::Local<v8::Function> function;
      if (!v8::FunctionTemplate::New(isolate, importFunction)
               ->GetFunction(context)
               .ToLocal(&function) ||
          !v8CallBoolean(privateScriptControllerObject->Set(
              context, v8String(isolate, ""import""), function))) {
        dumpV8Message(context, block.Message());
        LOG(FATAL)
            << ""Private script error: Setting import function failed. (Class ""
               ""name = ""
            << scriptClassName.utf8().data() << "")"";
      }
    }
  }

  v8::Local<v8::Script> script;
  if (!v8Call(V8ScriptRunner::compileScript(
                  v8String(isolate, sourceString), fileName, String(),
                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,
                  nullptr, NotSharableCrossOrigin),
              script, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: Compile failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }

  v8::Local<v8::Value> result;
  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),
              result, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: installClass() failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }
  return result;
}
","static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,
                                                       String scriptClassName,
                                                       const char* source,
                                                       size_t size) {
  v8::Isolate* isolate = scriptState->isolate();
  v8::TryCatch block(isolate);
  String sourceString(source, size);
  String fileName = scriptClassName + "".js"";
 
   v8::Local<v8::Context> context = scriptState->context();
   v8::Local<v8::Object> global = context->Global();
  v8::Local<v8::String> key = v8String(isolate, ""privateScriptController"");

  if (global->HasOwnProperty(context, key).ToChecked()) {
    v8::Local<v8::Value> privateScriptController =
        global->Get(context, key).ToLocalChecked();
    CHECK(privateScriptController->IsObject());
     v8::Local<v8::Object> privateScriptControllerObject =
         privateScriptController.As<v8::Object>();
     v8::Local<v8::Value> importFunctionValue =
        privateScriptControllerObject->Get(context, v8String(isolate, ""import""))
            .ToLocalChecked();
    if (importFunctionValue->IsUndefined()) {
      v8::Local<v8::Function> function;
      if (!v8::FunctionTemplate::New(isolate, importFunction)
               ->GetFunction(context)
               .ToLocal(&function) ||
          !v8CallBoolean(privateScriptControllerObject->Set(
              context, v8String(isolate, ""import""), function))) {
        dumpV8Message(context, block.Message());
        LOG(FATAL)
            << ""Private script error: Setting import function failed. (Class ""
               ""name = ""
            << scriptClassName.utf8().data() << "")"";
      }
    }
  }

  v8::Local<v8::Script> script;
  if (!v8Call(V8ScriptRunner::compileScript(
                  v8String(isolate, sourceString), fileName, String(),
                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,
                  nullptr, NotSharableCrossOrigin),
              script, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: Compile failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }

  v8::Local<v8::Value> result;
  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),
              result, block)) {
    dumpV8Message(context, block.Message());
    LOG(FATAL) << ""Private script error: installClass() failed. (Class name = ""
               << scriptClassName.utf8().data() << "")"";
  }
  return result;
}
","The `compileAndRunPrivateScript` function compiles and executes a JavaScript script within a specified V8 context, utilizing a provided script class name and source code. It first retrieves a global object, checks for a `privateScriptController`, and sets an `import` function if it is undefined. The function then compiles the script using the V8 engine, handling any compilation errors by logging them. Finally, it runs the compiled script and returns the result, ensuring that any runtime errors are also captured and logged, thus facilitating the execution of private scripts in a controlled environment.","The function compiles and executes a JavaScript script within a specific execution context, using a provided class name and source code. It first checks for a controller object in the global context and sets an import function if it is not already defined. The script is then compiled, with error handling to log any issues that arise during this process. After successful compilation, the function runs the script and captures the result, ensuring that any runtime errors are also logged, thereby enabling the execution of private scripts in a secure and managed manner.","The vulnerability in the original code stemmed from directly accessing the ""privateScriptController"" property on the global object without verifying its existence, which could inadvertently traverse the prototype chain. This behavior risked returning a property from the prototype, leading to unexpected results and potential release assertions. The fix implemented a check using `global->HasOwnProperty(context, key).ToChecked()` to ensure that the property exists on the global object itself before attempting to access it. This change prevents unintended prototype chain access, thereby enhancing the reliability and security of the script execution process.","The vulnerability in the original code arose from accessing a specific property on the global object without confirming its existence, which could lead to unintended behavior by traversing the prototype chain. This could result in retrieving a property from a parent object, causing unexpected values and potential errors during execution. The fix involved implementing a check to ensure that the property is defined directly on the global object before attempting to access it. This change effectively prevents the code from descending into the prototype chain, thereby enhancing the reliability and clarity of the script execution process.","The vulnerability was fixed by adding a check to verify the existence of the ""privateScriptController"" property on the global object using `global->HasOwnProperty(context, key).ToChecked()`. This ensures that the code only attempts to access the property if it is defined directly on the global object, preventing any unintended traversal of the prototype chain. By implementing this check, the code avoids returning properties from parent objects, which could lead to unexpected behavior and errors. This change enhances the robustness of the script execution process by ensuring that only valid properties are accessed.","The vulnerability was fixed by introducing a verification step to ensure that the specific property exists directly on the global object before attempting to access it. This check prevents the code from inadvertently traversing the prototype chain, which could lead to retrieving unintended properties from parent objects. By confirming the property's existence first, the code avoids potential errors and unexpected behavior during execution. This enhancement improves the reliability of the script execution process, ensuring that only valid and intended properties are accessed, thereby mitigating the risk of confusion and assertion failures.","CWE-264, CWE-915, CWE-267, CWE-269, CWE-416, CWE-754, CWE-707, CWE-704, CWE-470, CWE-265",N,-1.0,"4,4","5,5","4,4","4,4"
7,7,186670,186670,,Remote,Not required,,CVE-2018-6051,https://www.cvedetails.com/cve/CVE-2018-6051/,CWE-79,Medium,Partial,,,2018-09-25,4.3,"XSS Auditor in Google Chrome prior to 64.0.3282.119, did not ensure the reporting URL was in the same origin as the page it was on, which allowed a remote attacker to obtain referrer details via a crafted HTML page.",2018-11-15,XSS ,7,https://github.com/chromium/chromium/commit/0da6dcdbe8e34740133773d20cc466b89d399d0a,0da6dcdbe8e34740133773d20cc466b89d399d0a,"Restrict the xss audit report URL to same origin

BUG=441275
R=tsepez@chromium.org,mkwst@chromium.org

Change-Id: I27bc8e251b9ad962c3b4fdebf084a2b9152f915d
Reviewed-on: https://chromium-review.googlesource.com/768367
Reviewed-by: Tom Sepez <tsepez@chromium.org>
Reviewed-by: Mike West <mkwst@chromium.org>
Commit-Queue: Jochen Eisinger <jochen@chromium.org>
Cr-Commit-Position: refs/heads/master@{#516666}",0,third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp,"{""sha"": ""f991b2454bb8761dcd41fdcbfccaba4aab310f42"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin-expected.txt"", ""status"": ""added"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin-expected.txt?ref=0da6dcdbe8e34740133773d20cc466b89d399d0a"", ""patch"": ""@@ -0,0 +1,11 @@\n+CONSOLE ERROR: Error parsing header X-XSS-Protection: 1; report=http://localhost:8080/security/contentSecurityPolicy/resources/save-report.php?test=report-script-tag.html: reporting URL is not same scheme, host, and port as page at character position 10. The default protections will be applied.\n+CONSOLE ERROR: line 4: The XSS Auditor blocked access to 'http://127.0.0.1:8000/security/xssAuditor/resources/echo-intertag.pl?test=report-script-tag.html&echo-report=1&enable-report-cross-origin=1&q=%3Cscript%3Ealert(String.fromCharCode(0x58,0x53,0x53))%3C/script%3E%3Cp%3EIf%20you%20see%20this%20message,%20no%20JavaScript%20alert(),%20and%20not%20dump%20of%20a%20report%20is%20displayed%20below,%20then%20the%20test%20PASSED.%3C/p%3E' because the source code of a script was found within the request. The server sent an 'X-XSS-Protection' header requesting this behavior.\n+This tests that the X-XSS-Protection reports are sent out properly\n+\n+\n+\n+--------\n+Frame: 'frame'\n+--------\n+Could not load the requested resource.\n+Error code: -28 (net::ERR_BLOCKED_BY_XSS_AUDITOR)""}<_**next**_>{""sha"": ""ca8a315df359e6b57849c3d798aa87496719b89f"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin.html"", ""status"": ""added"", ""additions"": 25, ""deletions"": 0, ""changes"": 25, ""blob_url"": ""https://github.com/chromium/chromium/blob/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/report-script-tag-cross-origin.html?ref=0da6dcdbe8e34740133773d20cc466b89d399d0a"", ""patch"": ""@@ -0,0 +1,25 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+<script src=\""http://localhost:8000/security/xssAuditor/resources/utilities.js\""></script>\n+<script>\n+if (window.testRunner) {\n+    testRunner.dumpAsText();\n+    testRunner.dumpChildFramesAsText();\n+    testRunner.waitUntilDone();\n+    testRunner.setXSSAuditorEnabled(true);\n+}\n+\n+function notify() {\n+  if (window.testRunner) {\n+    setTimeout(testRunner.notifyDone.bind(testRunner), 0);\n+  }\n+}\n+</script>\n+</head>\n+<body>\n+<p>This tests that the X-XSS-Protection reports are sent out properly</p>\n+<iframe onload=\""notify()\"" name=\""frame\"" src=\""http://127.0.0.1:8000/security/xssAuditor/resources/echo-intertag.pl?test=report-script-tag.html&echo-report=1&enable-report-cross-origin=1&q=<script>alert(String.fromCharCode(0x58,0x53,0x53))</script><p>If you see this message, no JavaScript alert(), and not dump of a report is displayed below, then the test PASSED.</p>\"">\n+</iframe>\n+</body>\n+</html>""}<_**next**_>{""sha"": ""d3cb1524857b6ca8557df334e6feeb380123f922"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/resources/echo-intertag.pl"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/resources/echo-intertag.pl"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/resources/echo-intertag.pl"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/xssAuditor/resources/echo-intertag.pl?ref=0da6dcdbe8e34740133773d20cc466b89d399d0a"", ""patch"": ""@@ -13,6 +13,8 @@\n     print \""X-XSS-Protection: 1; mode=block\\n\"";\n } elsif ($cgi->param('enable-report')) {\n     print \""X-XSS-Protection: 1; report=/security/contentSecurityPolicy/resources/save-report.php?test=\"" . $cgi->param('test') . \""\\n\"";\n+} elsif ($cgi->param('enable-report-cross-origin')) {\n+    print \""X-XSS-Protection: 1; report=http://localhost:8080/security/contentSecurityPolicy/resources/save-report.php?test=\"" . $cgi->param('test') . \""\\n\"";\n } elsif ($cgi->param('enable-full-block-report')) {\n     print \""X-XSS-Protection: 1; mode=block; report=/security/contentSecurityPolicy/resources/save-report.php?test=\"" . $cgi->param('test') . \""\\n\"";\n } elsif ($cgi->param('valid-header')) {""}<_**next**_>{""sha"": ""4005f3b4c046b0d63dd7c2dfdc71790ee4849bdf"", ""filename"": ""third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0da6dcdbe8e34740133773d20cc466b89d399d0a/third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/html/parser/XSSAuditor.cpp?ref=0da6dcdbe8e34740133773d20cc466b89d399d0a"", ""patch"": ""@@ -425,6 +425,13 @@ void XSSAuditor::Init(Document* document,\n          xss_protection_header == kBlockReflectedXSS) &&\n         !report_url.IsEmpty()) {\n       xss_protection_report_url = document->CompleteURL(report_url);\n+      if (!SecurityOrigin::Create(xss_protection_report_url)\n+               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {\n+        error_details =\n+            \""reporting URL is not same scheme, host, and port as page\"";\n+        xss_protection_header = kReflectedXSSInvalid;\n+        xss_protection_report_url = KURL();\n+      }\n       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),\n                                               xss_protection_report_url)) {\n         error_details = \""insecure reporting URL for secure page\"";""}","void XSSAuditor::Init(Document* document,
                      XSSAuditorDelegate* auditor_delegate) {
  DCHECK(IsMainThread());
  if (state_ != kUninitialized)
    return;
  state_ = kFilteringTokens;

  if (Settings* settings = document->GetSettings())
    is_enabled_ = settings->GetXSSAuditorEnabled();

  if (!is_enabled_)
    return;

  document_url_ = document->Url().Copy();

  if (!document->GetFrame()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.IsEmpty()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.ProtocolIsData()) {
    is_enabled_ = false;
    return;
  }

  if (document->Encoding().IsValid())
    encoding_ = document->Encoding();

  if (DocumentLoader* document_loader =
          document->GetFrame()->Loader().GetDocumentLoader()) {
    const AtomicString& header_value =
        document_loader->GetResponse().HttpHeaderField(
            HTTPNames::X_XSS_Protection);
    String error_details;
    unsigned error_position = 0;
    String report_url;
    KURL xss_protection_report_url;

    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(
        header_value, error_details, error_position, report_url);

    if (xss_protection_header == kAllowReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);
    else if (xss_protection_header == kFilterReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);
    else if (xss_protection_header == kBlockReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);
    else if (xss_protection_header == kReflectedXSSInvalid)
      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);

    did_send_valid_xss_protection_header_ =
        xss_protection_header != kReflectedXSSUnset &&
        xss_protection_header != kReflectedXSSInvalid;
    if ((xss_protection_header == kFilterReflectedXSS ||
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
      if (!SecurityOrigin::Create(xss_protection_report_url)
               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {
        error_details =
            ""reporting URL is not same scheme, host, and port as page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
    }
    if (xss_protection_header == kReflectedXSSInvalid) {
      document->AddConsoleMessage(ConsoleMessage::Create(
          kSecurityMessageSource, kErrorMessageLevel,
          ""Error parsing header X-XSS-Protection: "" + header_value + "": "" +
              error_details + "" at character position "" +
              String::Format(""%u"", error_position) +
              "". The default protections will be applied.""));
    }

    xss_protection_ = xss_protection_header;
    if (xss_protection_ == kReflectedXSSInvalid ||
        xss_protection_ == kReflectedXSSUnset) {
      xss_protection_ = kBlockReflectedXSS;
    }

    if (auditor_delegate)
      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());

    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();
    if (http_body && !http_body->IsEmpty())
      http_body_as_string_ = http_body->FlattenToString();
  }

  SetEncoding(encoding_);
}
","void XSSAuditor::Init(Document* document,
                      XSSAuditorDelegate* auditor_delegate) {
  DCHECK(IsMainThread());
  if (state_ != kUninitialized)
    return;
  state_ = kFilteringTokens;

  if (Settings* settings = document->GetSettings())
    is_enabled_ = settings->GetXSSAuditorEnabled();

  if (!is_enabled_)
    return;

  document_url_ = document->Url().Copy();

  if (!document->GetFrame()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.IsEmpty()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.ProtocolIsData()) {
    is_enabled_ = false;
    return;
  }

  if (document->Encoding().IsValid())
    encoding_ = document->Encoding();

  if (DocumentLoader* document_loader =
          document->GetFrame()->Loader().GetDocumentLoader()) {
    const AtomicString& header_value =
        document_loader->GetResponse().HttpHeaderField(
            HTTPNames::X_XSS_Protection);
    String error_details;
    unsigned error_position = 0;
    String report_url;
    KURL xss_protection_report_url;

    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(
        header_value, error_details, error_position, report_url);

    if (xss_protection_header == kAllowReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);
    else if (xss_protection_header == kFilterReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);
    else if (xss_protection_header == kBlockReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);
    else if (xss_protection_header == kReflectedXSSInvalid)
      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);

    did_send_valid_xss_protection_header_ =
        xss_protection_header != kReflectedXSSUnset &&
        xss_protection_header != kReflectedXSSInvalid;
    if ((xss_protection_header == kFilterReflectedXSS ||
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
    }
    if (xss_protection_header == kReflectedXSSInvalid) {
      document->AddConsoleMessage(ConsoleMessage::Create(
          kSecurityMessageSource, kErrorMessageLevel,
          ""Error parsing header X-XSS-Protection: "" + header_value + "": "" +
              error_details + "" at character position "" +
              String::Format(""%u"", error_position) +
              "". The default protections will be applied.""));
    }

    xss_protection_ = xss_protection_header;
    if (xss_protection_ == kReflectedXSSInvalid ||
        xss_protection_ == kReflectedXSSUnset) {
      xss_protection_ = kBlockReflectedXSS;
    }

    if (auditor_delegate)
      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());

    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();
    if (http_body && !http_body->IsEmpty())
      http_body_as_string_ = http_body->FlattenToString();
  }

  SetEncoding(encoding_);
}
",C,"      if (!SecurityOrigin::Create(xss_protection_report_url)
               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {
        error_details =
            ""reporting URL is not same scheme, host, and port as page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
",,,"@@ -425,6 +425,13 @@ void XSSAuditor::Init(Document* document,
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
+      if (!SecurityOrigin::Create(xss_protection_report_url)
+               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {
+        error_details =
+            ""reporting URL is not same scheme, host, and port as page"";
+        xss_protection_header = kReflectedXSSInvalid;
+        xss_protection_report_url = KURL();
+      }
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";",Chrome,0da6dcdbe8e34740133773d20cc466b89d399d0a,c99c6fa1c62d04fb36be582fae389b9f34c2c089,1,"void XSSAuditor::Init(Document* document,
                      XSSAuditorDelegate* auditor_delegate) {
  DCHECK(IsMainThread());
  if (state_ != kUninitialized)
    return;
  state_ = kFilteringTokens;

  if (Settings* settings = document->GetSettings())
    is_enabled_ = settings->GetXSSAuditorEnabled();

  if (!is_enabled_)
    return;

  document_url_ = document->Url().Copy();

  // In theory, the Document could have detached from the LocalFrame after the
  // XSSAuditor was constructed.
  if (!document->GetFrame()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.IsEmpty()) {
    // The URL can be empty when opening a new browser window or calling
    // window.open("""").
    is_enabled_ = false;
    return;
  }

  if (document_url_.ProtocolIsData()) {
    is_enabled_ = false;
    return;
  }

  if (document->Encoding().IsValid())
    encoding_ = document->Encoding();

  if (DocumentLoader* document_loader =
          document->GetFrame()->Loader().GetDocumentLoader()) {
    const AtomicString& header_value =
        document_loader->GetResponse().HttpHeaderField(
            HTTPNames::X_XSS_Protection);
    String error_details;
    unsigned error_position = 0;
    String report_url;
    KURL xss_protection_report_url;

    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(
        header_value, error_details, error_position, report_url);

    if (xss_protection_header == kAllowReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);
    else if (xss_protection_header == kFilterReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);
    else if (xss_protection_header == kBlockReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);
    else if (xss_protection_header == kReflectedXSSInvalid)
      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);

    did_send_valid_xss_protection_header_ =
        xss_protection_header != kReflectedXSSUnset &&
        xss_protection_header != kReflectedXSSInvalid;
    if ((xss_protection_header == kFilterReflectedXSS ||
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
//fix_flaw_line_below:
//      if (!SecurityOrigin::Create(xss_protection_report_url)
//fix_flaw_line_below:
//               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {
//fix_flaw_line_below:
//        error_details =
//fix_flaw_line_below:
//            ""reporting URL is not same scheme, host, and port as page"";
//fix_flaw_line_below:
//        xss_protection_header = kReflectedXSSInvalid;
//fix_flaw_line_below:
//        xss_protection_report_url = KURL();
//fix_flaw_line_below:
//      }
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
    }
    if (xss_protection_header == kReflectedXSSInvalid) {
      document->AddConsoleMessage(ConsoleMessage::Create(
          kSecurityMessageSource, kErrorMessageLevel,
          ""Error parsing header X-XSS-Protection: "" + header_value + "": "" +
              error_details + "" at character position "" +
              String::Format(""%u"", error_position) +
              "". The default protections will be applied.""));
    }

    xss_protection_ = xss_protection_header;
    if (xss_protection_ == kReflectedXSSInvalid ||
        xss_protection_ == kReflectedXSSUnset) {
      xss_protection_ = kBlockReflectedXSS;
    }

    if (auditor_delegate)
      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());

    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();
    if (http_body && !http_body->IsEmpty())
      http_body_as_string_ = http_body->FlattenToString();
  }

  SetEncoding(encoding_);
}
",186670,"void XSSAuditor::Init(Document* document,
                      XSSAuditorDelegate* auditor_delegate) {
  DCHECK(IsMainThread());
  if (state_ != kUninitialized)
    return;
  state_ = kFilteringTokens;

  if (Settings* settings = document->GetSettings())
    is_enabled_ = settings->GetXSSAuditorEnabled();

  if (!is_enabled_)
    return;

  document_url_ = document->Url().Copy();

  if (!document->GetFrame()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.IsEmpty()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.ProtocolIsData()) {
    is_enabled_ = false;
    return;
  }

  if (document->Encoding().IsValid())
    encoding_ = document->Encoding();

  if (DocumentLoader* document_loader =
          document->GetFrame()->Loader().GetDocumentLoader()) {
    const AtomicString& header_value =
        document_loader->GetResponse().HttpHeaderField(
            HTTPNames::X_XSS_Protection);
    String error_details;
    unsigned error_position = 0;
    String report_url;
    KURL xss_protection_report_url;

    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(
        header_value, error_details, error_position, report_url);

    if (xss_protection_header == kAllowReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);
    else if (xss_protection_header == kFilterReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);
    else if (xss_protection_header == kBlockReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);
    else if (xss_protection_header == kReflectedXSSInvalid)
      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);

    did_send_valid_xss_protection_header_ =
        xss_protection_header != kReflectedXSSUnset &&
        xss_protection_header != kReflectedXSSInvalid;
    if ((xss_protection_header == kFilterReflectedXSS ||
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
    }
    if (xss_protection_header == kReflectedXSSInvalid) {
      document->AddConsoleMessage(ConsoleMessage::Create(
          kSecurityMessageSource, kErrorMessageLevel,
          ""Error parsing header X-XSS-Protection: "" + header_value + "": "" +
              error_details + "" at character position "" +
              String::Format(""%u"", error_position) +
              "". The default protections will be applied.""));
    }

    xss_protection_ = xss_protection_header;
    if (xss_protection_ == kReflectedXSSInvalid ||
        xss_protection_ == kReflectedXSSUnset) {
      xss_protection_ = kBlockReflectedXSS;
    }

    if (auditor_delegate)
      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());

    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();
    if (http_body && !http_body->IsEmpty())
      http_body_as_string_ = http_body->FlattenToString();
  }

  SetEncoding(encoding_);
}
","void XSSAuditor::Init(Document* document,
                      XSSAuditorDelegate* auditor_delegate) {
  DCHECK(IsMainThread());
  if (state_ != kUninitialized)
    return;
  state_ = kFilteringTokens;

  if (Settings* settings = document->GetSettings())
    is_enabled_ = settings->GetXSSAuditorEnabled();

  if (!is_enabled_)
    return;

  document_url_ = document->Url().Copy();

  if (!document->GetFrame()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.IsEmpty()) {
    is_enabled_ = false;
    return;
  }

  if (document_url_.ProtocolIsData()) {
    is_enabled_ = false;
    return;
  }

  if (document->Encoding().IsValid())
    encoding_ = document->Encoding();

  if (DocumentLoader* document_loader =
          document->GetFrame()->Loader().GetDocumentLoader()) {
    const AtomicString& header_value =
        document_loader->GetResponse().HttpHeaderField(
            HTTPNames::X_XSS_Protection);
    String error_details;
    unsigned error_position = 0;
    String report_url;
    KURL xss_protection_report_url;

    ReflectedXSSDisposition xss_protection_header = ParseXSSProtectionHeader(
        header_value, error_details, error_position, report_url);

    if (xss_protection_header == kAllowReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorDisabled);
    else if (xss_protection_header == kFilterReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledFilter);
    else if (xss_protection_header == kBlockReflectedXSS)
      UseCounter::Count(*document, WebFeature::kXSSAuditorEnabledBlock);
    else if (xss_protection_header == kReflectedXSSInvalid)
      UseCounter::Count(*document, WebFeature::kXSSAuditorInvalid);

    did_send_valid_xss_protection_header_ =
        xss_protection_header != kReflectedXSSUnset &&
        xss_protection_header != kReflectedXSSInvalid;
    if ((xss_protection_header == kFilterReflectedXSS ||
          xss_protection_header == kBlockReflectedXSS) &&
         !report_url.IsEmpty()) {
       xss_protection_report_url = document->CompleteURL(report_url);
      if (!SecurityOrigin::Create(xss_protection_report_url)
               ->IsSameSchemeHostPort(document->GetSecurityOrigin())) {
        error_details =
            ""reporting URL is not same scheme, host, and port as page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
       if (MixedContentChecker::IsMixedContent(document->GetSecurityOrigin(),
                                               xss_protection_report_url)) {
         error_details = ""insecure reporting URL for secure page"";
        xss_protection_header = kReflectedXSSInvalid;
        xss_protection_report_url = KURL();
      }
    }
    if (xss_protection_header == kReflectedXSSInvalid) {
      document->AddConsoleMessage(ConsoleMessage::Create(
          kSecurityMessageSource, kErrorMessageLevel,
          ""Error parsing header X-XSS-Protection: "" + header_value + "": "" +
              error_details + "" at character position "" +
              String::Format(""%u"", error_position) +
              "". The default protections will be applied.""));
    }

    xss_protection_ = xss_protection_header;
    if (xss_protection_ == kReflectedXSSInvalid ||
        xss_protection_ == kReflectedXSSUnset) {
      xss_protection_ = kBlockReflectedXSS;
    }

    if (auditor_delegate)
      auditor_delegate->SetReportURL(xss_protection_report_url.Copy());

    EncodedFormData* http_body = document_loader->GetRequest().HttpBody();
    if (http_body && !http_body->IsEmpty())
      http_body_as_string_ = http_body->FlattenToString();
  }

  SetEncoding(encoding_);
}
","The `XSSAuditor::Init` function initializes the XSS auditor for a given document, ensuring it operates on the main thread and is in an uninitialized state. It checks if the XSS auditor is enabled based on document settings and validates the document's URL and frame. The function parses the `X-XSS-Protection` HTTP header to determine the appropriate XSS protection strategy, counting usage metrics accordingly. It handles potential errors in header parsing, sets a reporting URL if applicable, and processes any HTTP body data. Finally, it sets the document's encoding, preparing the auditor for subsequent operations.","The code initializes an XSS auditor for a document, ensuring it runs on the main thread and is in the correct state. It checks if the auditor is enabled based on document settings and validates the document's URL and frame. The code then analyzes a specific HTTP header to determine the appropriate XSS protection strategy, while also tracking usage metrics. It handles any errors in header parsing and sets a reporting URL if necessary. Additionally, it processes any HTTP body data and configures the document's encoding, preparing the auditor for its intended functionality.","The vulnerability in the original code stemmed from the lack of validation for the reporting URL associated with the XSS protection header, which could allow an attacker to specify a malicious URL, potentially leading to data leakage or other security issues. The fixed code addresses this by adding a check to ensure that the reporting URL has the same scheme, host, and port as the document's origin, using the `SecurityOrigin::Create` function. This restriction prevents cross-origin reporting URLs, thereby enhancing the security of the XSS auditor by ensuring that reports are sent only to trusted origins.","The vulnerability in the original code allowed for the possibility of a malicious reporting URL being specified in the XSS protection header, which could lead to data exposure or exploitation by redirecting sensitive information to an untrusted origin. The fix implemented in the updated code restricts the reporting URL to ensure it matches the same origin as the document, thereby preventing cross-origin requests. This change enhances security by ensuring that any reports generated by the XSS auditor are sent only to trusted locations, mitigating the risk of data leakage or unauthorized access.","The vulnerability was fixed by adding a validation check for the reporting URL to ensure it matches the same scheme, host, and port as the document's origin. This was accomplished using the `SecurityOrigin::Create` function to create a security origin from the reporting URL and then comparing it with the document's security origin. If the origins did not match, an error message was generated, and the reporting URL was invalidated. This change effectively prevents the use of cross-origin reporting URLs, thereby enhancing the security of the XSS auditor by ensuring that reports are sent only to trusted origins.","The vulnerability was fixed by implementing a validation mechanism that ensures the reporting URL specified in the XSS protection header matches the same origin as the document. This involves checking that the scheme, host, and port of the reporting URL align with those of the document's origin. If the origins do not match, the reporting URL is deemed invalid, preventing the potential for malicious exploitation through cross-origin requests. This enhancement significantly improves security by ensuring that any reports generated are sent only to trusted locations, thereby mitigating risks associated with data leakage or unauthorized access.","CWE-79, CWE-346, CWE-1021, CWE-20, CWE-16, CWE-941, CWE-287, CWE-200, CWE-610, CWE-345",Y,1.0,"5,5","5,5","4,4","4,5"
8,8,186873,186873,,Remote,Not required,,CVE-2018-6070,https://www.cvedetails.com/cve/CVE-2018-6070/,CWE-79,Medium,,Partial,,2018-11-14,4.3,Lack of CSP enforcement on WebUI pages in Bink in Google Chrome prior to 65.0.3325.146 allowed an attacker who convinced a user to install a malicious extension to bypass content security policy via a crafted Chrome Extension.,2019-10-02,XSS Bypass ,0,https://github.com/chromium/chromium/commit/f283cdf7c850f3db923a5303c7e01bd929d4117f,f283cdf7c850f3db923a5303c7e01bd929d4117f,"Move Initialize() to VaapiImageDecoder parent class.

This CL moves the implementation of Initialize() to VaapiImageDecoder,
since it is common to all implementing classes.

Bug: 877694
Test: jpeg_decode_accelerator_unittest
Change-Id: Ic99601953ae1c7a572ba8a0b0bf43675b2b0969d
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1654249
Commit-Queue: Gil Dekel <gildekel@chromium.org>
Reviewed-by: Andres Calderon Jaramillo <andrescj@chromium.org>
Reviewed-by: Miguel Casas <mcasas@chromium.org>
Cr-Commit-Position: refs/heads/master@{#668645}",8,media/gpu/vaapi/vaapi_jpeg_decoder.cc,"{""sha"": ""7671f22290878c00f91af2e1d87d9de0140ae980"", ""filename"": ""media/gpu/vaapi/OWNERS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/OWNERS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/OWNERS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/OWNERS?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -4,3 +4,6 @@ posciak@chromium.org\n \n # (M)JPEG related stuff\n per-file *jpeg*=andrescj@chromium.org\n+\n+# General VA-API decoding related stuff\n+per-file *image_decoder*=andrescj@chromium.org""}<_**next**_>{""sha"": ""5bafbd695cceeb07b4e15d0812f1e3ecfb60573a"", ""filename"": ""media/gpu/vaapi/vaapi_image_decoder.cc"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_image_decoder.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_image_decoder.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/vaapi_image_decoder.cc?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -6,13 +6,37 @@\n \n #include <va/va.h>\n \n+#include \""base/logging.h\""\n #include \""media/gpu/vaapi/vaapi_wrapper.h\""\n \n namespace media {\n \n+namespace {\n+\n+VAProfile ConvertToVAProfile(VaapiImageDecoder::Type type) {\n+  switch (type) {\n+    case VaapiImageDecoder::Type::kJpeg:\n+      return VAProfileJPEGBaseline;\n+    case VaapiImageDecoder::Type::kWebP:\n+      return VAProfileVP8Version0_3;\n+    default:\n+      NOTREACHED() << \""Undefined Type value\"";\n+      return VAProfileNone;\n+  }\n+}\n+\n+}  // namespace\n+\n VaapiImageDecoder::VaapiImageDecoder()\n     : va_surface_id_(VA_INVALID_SURFACE), va_rt_format_(kInvalidVaRtFormat) {}\n \n VaapiImageDecoder::~VaapiImageDecoder() = default;\n \n+bool VaapiImageDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {\n+  const VAProfile va_profile = ConvertToVAProfile(GetType());\n+  vaapi_wrapper_ =\n+      VaapiWrapper::Create(VaapiWrapper::kDecode, va_profile, error_uma_cb);\n+  return !!vaapi_wrapper_;\n+}\n+\n }  // namespace media""}<_**next**_>{""sha"": ""68eaf26e7e53f695f831bf805696d423cb2da451"", ""filename"": ""media/gpu/vaapi/vaapi_image_decoder.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 3, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_image_decoder.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_image_decoder.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/vaapi_image_decoder.h?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -50,11 +50,17 @@ enum class VaapiImageDecodeStatus : uint32_t {\n // more implementing classes are added (e.g. VaapiWebPDecoder).\n class VaapiImageDecoder {\n  public:\n+  // Type of image decoder.\n+  enum class Type {\n+    kJpeg,\n+    kWebP,\n+  };\n+\n   virtual ~VaapiImageDecoder();\n \n-  // Initializes |vaapi_wrapper_| in kDecode mode with the appropriate VAAPI\n-  // profile and |error_uma_cb| for error reporting.\n-  virtual bool Initialize(const base::RepeatingClosure& error_uma_cb) = 0;\n+  // Uses GetType() to initialize |vaapi_wrapper_| in kDecode mode with the\n+  // appropriate VAAPI profile and |error_uma_cb| for error reporting.\n+  bool Initialize(const base::RepeatingClosure& error_uma_cb);\n \n   // Decodes a picture. It will fill VA-API parameters and call the\n   // corresponding VA-API methods according to the image in |encoded_image|.\n@@ -66,6 +72,9 @@ class VaapiImageDecoder {\n       base::span<const uint8_t> encoded_image,\n       VaapiImageDecodeStatus* status) = 0;\n \n+  // Returns the type of the current decoder.\n+  virtual Type GetType() const = 0;\n+\n  protected:\n   VaapiImageDecoder();\n ""}<_**next**_>{""sha"": ""53b26a84045c8af0fb54071850b5be48e0bad649"", ""filename"": ""media/gpu/vaapi/vaapi_jpeg_decoder.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 10, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_jpeg_decoder.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_jpeg_decoder.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/vaapi_jpeg_decoder.cc?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -217,16 +217,6 @@ VaapiJpegDecoder::~VaapiJpegDecoder() {\n   }\n }\n \n-bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {\n-  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,\n-                                        VAProfileJPEGBaseline, error_uma_cb);\n-  if (!vaapi_wrapper_) {\n-    VLOGF(1) << \""Failed initializing VAAPI\"";\n-    return false;\n-  }\n-  return true;\n-}\n-\n scoped_refptr<VASurface> VaapiJpegDecoder::Decode(\n     base::span<const uint8_t> encoded_image,\n     VaapiImageDecodeStatus* status) {\n@@ -342,6 +332,10 @@ scoped_refptr<VASurface> VaapiJpegDecoder::Decode(\n                                          base::DoNothing() /* release_cb */);\n }\n \n+VaapiImageDecoder::Type VaapiJpegDecoder::GetType() const {\n+  return VaapiImageDecoder::Type::kJpeg;\n+}\n+\n std::unique_ptr<ScopedVAImage> VaapiJpegDecoder::GetImage(\n     uint32_t preferred_image_fourcc,\n     VaapiImageDecodeStatus* status) {""}<_**next**_>{""sha"": ""270a7481b9e75f7c4ce657b5c84b6a5d059c12e5"", ""filename"": ""media/gpu/vaapi/vaapi_jpeg_decoder.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_jpeg_decoder.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f283cdf7c850f3db923a5303c7e01bd929d4117f/media/gpu/vaapi/vaapi_jpeg_decoder.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/gpu/vaapi/vaapi_jpeg_decoder.h?ref=f283cdf7c850f3db923a5303c7e01bd929d4117f"", ""patch"": ""@@ -30,9 +30,9 @@ class VaapiJpegDecoder : public VaapiImageDecoder {\n   ~VaapiJpegDecoder() override;\n \n   // VaapiImageDecoder implementation.\n-  bool Initialize(const base::RepeatingClosure& error_uma_cb) override;\n   scoped_refptr<VASurface> Decode(base::span<const uint8_t> encoded_image,\n                                   VaapiImageDecodeStatus* status) override;\n+  Type GetType() const override;\n \n   // Get the decoded data from the last Decode() call as a ScopedVAImage. The\n   // VAImage's format will be either |preferred_image_fourcc| if the conversion""}","bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
","bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,
                                        VAProfileJPEGBaseline, error_uma_cb);
  if (!vaapi_wrapper_) {
    VLOGF(1) << ""Failed initializing VAAPI"";
    return false;
  }
  return true;
}
",C,,"  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,
                                        VAProfileJPEGBaseline, error_uma_cb);
  if (!vaapi_wrapper_) {
    VLOGF(1) << ""Failed initializing VAAPI"";
    return false;
  }
  return true;
}
",,"@@ -217,16 +217,6 @@ VaapiJpegDecoder::~VaapiJpegDecoder() {
   }
 }
 
-bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
-  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,
-                                        VAProfileJPEGBaseline, error_uma_cb);
-  if (!vaapi_wrapper_) {
-    VLOGF(1) << ""Failed initializing VAAPI"";
-    return false;
-  }
-  return true;
-}
-
 scoped_refptr<VASurface> VaapiJpegDecoder::Decode(
     base::span<const uint8_t> encoded_image,
     VaapiImageDecodeStatus* status) {
@@ -342,6 +332,10 @@ scoped_refptr<VASurface> VaapiJpegDecoder::Decode(
                                          base::DoNothing() /* release_cb */);
 }
 
+VaapiImageDecoder::Type VaapiJpegDecoder::GetType() const {
+  return VaapiImageDecoder::Type::kJpeg;
+}
+
 std::unique_ptr<ScopedVAImage> VaapiJpegDecoder::GetImage(
     uint32_t preferred_image_fourcc,
     VaapiImageDecodeStatus* status) {",Chrome,f283cdf7c850f3db923a5303c7e01bd929d4117f,4f67ec23d9cf3ea7ab718a8dc7cd618674317472,1,"bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
//flaw_line_below:
  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,
//flaw_line_below:
                                        VAProfileJPEGBaseline, error_uma_cb);
//flaw_line_below:
  if (!vaapi_wrapper_) {
//flaw_line_below:
    VLOGF(1) << ""Failed initializing VAAPI"";
//flaw_line_below:
    return false;
//flaw_line_below:
  }
//flaw_line_below:
  return true;
//flaw_line_below:
}
",186873,"bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,
                                        VAProfileJPEGBaseline, error_uma_cb);
  if (!vaapi_wrapper_) {
    VLOGF(1) << ""Failed initializing VAAPI"";
    return false;
  }
  return true;
}
","bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {
","The `Initialize` function in the `VaapiJpegDecoder` class is responsible for setting up a VAAPI (Video Acceleration API) wrapper for JPEG decoding. It attempts to create a `VaapiWrapper` instance configured for decoding with the baseline JPEG profile, using a callback for error reporting. If the creation of the `vaapi_wrapper_` fails, it logs an error message and returns `false`, indicating unsuccessful initialization. Conversely, if the wrapper is successfully created, the function returns `true`, signaling that the decoder is ready for use. This function is crucial for ensuring that the decoder can leverage hardware acceleration for JPEG processing.","The provided code defines a method that initializes a video decoding component specifically for JPEG images using a hardware acceleration framework. It attempts to create an instance of a wrapper designed for decoding, while also incorporating a callback function for error handling. If the creation of this wrapper fails, an error message is logged, and the method returns a failure status. Conversely, if the initialization is successful, the method returns a success status, indicating that the decoding component is ready to process JPEG images efficiently using the available hardware resources.","The vulnerability in the original code stemmed from the `Initialize` function being implemented separately in multiple classes, which could lead to inconsistent initialization logic and potential security flaws if any subclass failed to properly handle error conditions. By moving the `Initialize` function to the parent class `VaapiImageDecoder`, the fixed code ensures that all implementing classes share a consistent and secure initialization process. This change reduces the risk of errors and vulnerabilities by centralizing the logic, allowing for better maintenance and testing, as evidenced by the associated unit test for JPEG decoding.","The vulnerability in the original code arose from the `Initialize` function being implemented separately in multiple subclasses, which could lead to inconsistent handling of initialization logic and error conditions, increasing the risk of security flaws. By moving this function to a common parent class, the revised code ensures that all subclasses utilize a unified and secure initialization process. This centralization not only enhances consistency and maintainability but also allows for comprehensive testing across all implementations, thereby reducing the likelihood of errors and vulnerabilities in the initialization logic.","The vulnerability was fixed by relocating the `Initialize` function from the individual subclasses to the parent class `VaapiImageDecoder`. This change ensures that all implementing classes share a single, consistent implementation of the `Initialize` function, which reduces the risk of inconsistent error handling and initialization logic. By centralizing the code, any necessary updates or fixes can be applied in one place, enhancing maintainability and security. Additionally, the associated unit test for JPEG decoding was likely updated to validate the new shared implementation, further ensuring that the initialization process is robust and reliable across all subclasses.","The vulnerability was addressed by consolidating the initialization logic into a single parent class, ensuring that all subclasses utilize a uniform implementation. This centralization eliminates the risk of inconsistent error handling and initialization processes that could arise from separate implementations in each subclass. By having a shared method, any necessary updates or security enhancements can be applied universally, improving maintainability and reducing the likelihood of errors. Additionally, the associated testing framework was likely adjusted to validate the new unified approach, further reinforcing the reliability and security of the initialization process across all implementations.","CWE-544, CWE-665, CWE-459, CWE-1281, CWE-457, CWE-1290, CWE-913, CWE-580, CWE-915, CWE-669",N,-1.0,"5,4","5, 5","4,4","4,3"
9,9,186880,186880,,Remote,Not required,,CVE-2018-6076,https://www.cvedetails.com/cve/CVE-2018-6076/,CWE-79,Medium,,Partial,,2018-11-14,4.3,Insufficient encoding of URL fragment identifiers in Blink in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to perform a DOM based XSS attack via a crafted HTML page.,2018-12-19,XSS ,1,https://github.com/chromium/chromium/commit/f8f6ed59949be4451ee2f5443d8a313f102fde60,f8f6ed59949be4451ee2f5443d8a313f102fde60,"Percent-encode UTF8 characters in URL fragment identifiers.

This brings us into line with Firefox, Safari, and the spec.

Bug: 758523
Change-Id: I7e354ab441222d9fd08e45f0e70f91ad4e35fafe
Reviewed-on: https://chromium-review.googlesource.com/668363
Commit-Queue: Mike West <mkwst@chromium.org>
Reviewed-by: Jochen Eisinger <jochen@chromium.org>
Reviewed-by: Andy Paicu <andypaicu@chromium.org>
Cr-Commit-Position: refs/heads/master@{#507481}",3,url/url_canon_etc.cc,"{""sha"": ""fc7148cbdeb0750f0a4a6371d06f512679e0f321"", ""filename"": ""components/url_formatter/elide_url_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_formatter/elide_url_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_formatter/elide_url_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/url_formatter/elide_url_unittest.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -338,13 +338,14 @@ TEST(TextEliderTest, TestElisionSpecialCases) {\n \n       // Unescaping.\n       {\""http://www/%E4%BD%A0%E5%A5%BD?q=%E4%BD%A0%E5%A5%BD#\\xe4\\xbd\\xa0\"",\n-       \""www/\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd?q=\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd#\\xe4\\xbd\\xa0\""},\n+       \""www/\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd?q=\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd#\"" +\n+           kEllipsisStr},\n \n       // Invalid unescaping for path. The ref will always be valid UTF-8. We\n       // don't bother to do too many edge cases, since these are handled by the\n       // escaper unittest.\n       {\""http://www/%E4%A0%E5%A5%BD?q=%E4%BD%A0%E5%A5%BD#\\xe4\\xbd\\xa0\"",\n-       \""www/%E4%A0%E5%A5%BD?q=\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd#\\xe4\\xbd\\xa0\""},\n+       \""www/%E4%A0%E5%A5%BD?q=\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd#\"" + kEllipsisStr},\n   };\n \n   RunElisionTest(testcases);""}<_**next**_>{""sha"": ""522cb4576fc3fd45800effb5c5951d8914ef5a3a"", ""filename"": ""components/url_formatter/url_formatter_unittest.cc"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 19, ""changes"": 40, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_formatter/url_formatter_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_formatter/url_formatter_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/url_formatter/url_formatter_unittest.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -762,7 +762,7 @@ TEST(UrlFormatterTest, FormatUrl) {\n \n       {\""With a port number and a reference\"",\n        \""http://www.google.com:8080/#\\xE3\\x82\\xB0\"", default_format_type,\n-       net::UnescapeRule::NORMAL, L\""http://www.google.com:8080/#\\x30B0\"", 7},\n+       net::UnescapeRule::NORMAL, L\""http://www.google.com:8080/#%E3%82%B0\"", 7},\n \n       // -------- IDN tests --------\n       {\""Japanese IDN with ja\"", \""http://xn--l8jvb1ey91xtjb.jp\"",\n@@ -1027,9 +1027,10 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n                      \""%E3%82%B0/?q=%E3%82%B0#\\xE3\\x82\\xB0\""),\n                 kFormatUrlOmitNothing, net::UnescapeRule::NONE,\n                 &parsed, nullptr, nullptr);\n-  EXPECT_EQ(WideToUTF16(\n-      L\""http://%E3%82%B0:%E3%83%BC@\\x30B0\\x30FC\\x30B0\\x30EB.jp:8080\""\n-      L\""/%E3%82%B0/?q=%E3%82%B0#\\x30B0\""), formatted);\n+  EXPECT_EQ(\n+      WideToUTF16(L\""http://%E3%82%B0:%E3%83%BC@\\x30B0\\x30FC\\x30B0\\x30EB.jp:8080\""\n+                  L\""/%E3%82%B0/?q=%E3%82%B0#%E3%82%B0\""),\n+      formatted);\n   EXPECT_EQ(WideToUTF16(L\""%E3%82%B0\""),\n       formatted.substr(parsed.username.begin, parsed.username.len));\n   EXPECT_EQ(WideToUTF16(L\""%E3%83%BC\""),\n@@ -1042,8 +1043,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n       formatted.substr(parsed.path.begin, parsed.path.len));\n   EXPECT_EQ(WideToUTF16(L\""q=%E3%82%B0\""),\n       formatted.substr(parsed.query.begin, parsed.query.len));\n-  EXPECT_EQ(WideToUTF16(L\""\\x30B0\""),\n-      formatted.substr(parsed.ref.begin, parsed.ref.len));\n+  EXPECT_EQ(WideToUTF16(L\""%E3%82%B0\""),\n+            formatted.substr(parsed.ref.begin, parsed.ref.len));\n \n   // Unescape case.\n   formatted =\n@@ -1052,7 +1053,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n                 kFormatUrlOmitNothing, net::UnescapeRule::NORMAL, &parsed,\n                 nullptr, nullptr);\n   EXPECT_EQ(WideToUTF16(L\""http://\\x30B0:\\x30FC@\\x30B0\\x30FC\\x30B0\\x30EB.jp:8080\""\n-      L\""/\\x30B0/?q=\\x30B0#\\x30B0\""), formatted);\n+                        L\""/\\x30B0/?q=\\x30B0#%E3%82%B0\""),\n+            formatted);\n   EXPECT_EQ(WideToUTF16(L\""\\x30B0\""),\n       formatted.substr(parsed.username.begin, parsed.username.len));\n   EXPECT_EQ(WideToUTF16(L\""\\x30FC\""),\n@@ -1065,8 +1067,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n       formatted.substr(parsed.path.begin, parsed.path.len));\n   EXPECT_EQ(WideToUTF16(L\""q=\\x30B0\""),\n       formatted.substr(parsed.query.begin, parsed.query.len));\n-  EXPECT_EQ(WideToUTF16(L\""\\x30B0\""),\n-      formatted.substr(parsed.ref.begin, parsed.ref.len));\n+  EXPECT_EQ(WideToUTF16(L\""%E3%82%B0\""),\n+            formatted.substr(parsed.ref.begin, parsed.ref.len));\n \n   // Omit_username_password + unescape case.\n   formatted =\n@@ -1075,7 +1077,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n                 kFormatUrlOmitUsernamePassword, net::UnescapeRule::NORMAL,\n                 &parsed, nullptr, nullptr);\n   EXPECT_EQ(WideToUTF16(L\""http://\\x30B0\\x30FC\\x30B0\\x30EB.jp:8080\""\n-      L\""/\\x30B0/?q=\\x30B0#\\x30B0\""), formatted);\n+                        L\""/\\x30B0/?q=\\x30B0#%E3%82%B0\""),\n+            formatted);\n   EXPECT_FALSE(parsed.username.is_valid());\n   EXPECT_FALSE(parsed.password.is_valid());\n   EXPECT_EQ(WideToUTF16(L\""\\x30B0\\x30FC\\x30B0\\x30EB.jp\""),\n@@ -1086,8 +1089,8 @@ TEST(UrlFormatterTest, FormatUrlParsed) {\n       formatted.substr(parsed.path.begin, parsed.path.len));\n   EXPECT_EQ(WideToUTF16(L\""q=\\x30B0\""),\n       formatted.substr(parsed.query.begin, parsed.query.len));\n-  EXPECT_EQ(WideToUTF16(L\""\\x30B0\""),\n-      formatted.substr(parsed.ref.begin, parsed.ref.len));\n+  EXPECT_EQ(WideToUTF16(L\""%E3%82%B0\""),\n+            formatted.substr(parsed.ref.begin, parsed.ref.len));\n \n   // View-source case.\n   formatted =\n@@ -1320,14 +1323,13 @@ TEST(UrlFormatterTest, FormatUrlWithOffsets) {\n       kFormatUrlOmitNothing, net::UnescapeRule::SPACES, unescape_offsets);\n \n   const size_t ref_offsets[] = {\n-    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n-    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, kNpos, kNpos, 32, kNpos, kNpos,\n-    33\n-  };\n+      0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16,\n+      17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,\n+      34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49};\n   // Unescape to \""http://www.google.com/foo.html#\\x30B0\\x30B0z\"".\n-  CheckAdjustedOffsets(\n-      \""http://www.google.com/foo.html#\\xE3\\x82\\xB0\\xE3\\x82\\xB0z\"",\n-      kFormatUrlOmitNothing, net::UnescapeRule::NORMAL, ref_offsets);\n+  CheckAdjustedOffsets(\""http://www.google.com/foo.html#%E3%82%B0%E3%82%B0z\"",\n+                       kFormatUrlOmitNothing, net::UnescapeRule::NORMAL,\n+                       ref_offsets);\n \n   const size_t omit_http_offsets[] = {\n     0, kNpos, kNpos, kNpos, kNpos, kNpos, kNpos, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,""}<_**next**_>{""sha"": ""7672b12a6db0bdccdb4ea8940cda31afe9969a87"", ""filename"": ""components/url_matcher/url_matcher_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_matcher/url_matcher_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/components/url_matcher/url_matcher_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/url_matcher/url_matcher_unittest.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -168,7 +168,7 @@ TEST(URLMatcherConditionFactoryTest, GURLCharacterSet) {\n   EXPECT_TRUE(base::IsStringASCII(url.host()));\n   EXPECT_TRUE(base::IsStringASCII(url.path()));\n   EXPECT_TRUE(base::IsStringASCII(url.query()));\n-  EXPECT_FALSE(base::IsStringASCII(url.ref()));\n+  EXPECT_TRUE(base::IsStringASCII(url.ref()));\n }\n \n TEST(URLMatcherConditionFactoryTest, Criteria) {""}<_**next**_>{""sha"": ""46aa9d9fba31d9c3fec30db76a89ac7516a52dbc"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/url/url-setters-expected.txt"", ""status"": ""renamed"", ""additions"": 7, ""deletions"": 7, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/external/wpt/url/url-setters-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/external/wpt/url/url-setters-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/url/url-setters-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 574 tests; 248 PASS, 326 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 574 tests; 251 PASS, 323 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n FAIL URL: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged. assert_equals: expected \""a://example.net\"" but got \""file:///A://example.net\""\n FAIL <a>: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged. assert_equals: expected \""a://example.net\"" but got \""file:///A://example.net\""\n@@ -565,12 +565,12 @@ FAIL <area>: Setting <https://example.net?lang=en-US#nav>.hash = '#' assert_equa\n PASS URL: Setting <https://example.net?lang=en-US#nav>.hash = ''\n PASS <a>: Setting <https://example.net?lang=en-US#nav>.hash = ''\n PASS <area>: Setting <https://example.net?lang=en-US#nav>.hash = ''\n-FAIL URL: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9\""\n-FAIL <a>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9\""\n-FAIL <area>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9\""\n-FAIL URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n+FAIL URL: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n+FAIL <a>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n+FAIL <area>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""file:///A:/#%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n+PASS URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n PASS URL: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <a>: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <area>: Setting <javascript:alert(1)>.hash = 'castle'"", ""previous_filename"": ""third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-setters-expected.txt""}<_**next**_>{""sha"": ""5422190a3d98f83155961158319fe379a4c4c8b3"", ""filename"": ""third_party/WebKit/LayoutTests/fast/domurl/url-hash.html"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/domurl/url-hash.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/domurl/url-hash.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/domurl/url-hash.html?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -55,7 +55,7 @@\n     assert_equals(url.hash, '');\n \n     url.hash = '\\udc01\\ud802a';\n-    assert_equals(url.hash, '#\\ufffd\\ufffda');\n+    assert_equals(url.hash, '#%EF%BF%BD%EF%BF%BDa');\n }, 'hash with unmatched surrogates');\n \n </script>""}<_**next**_>{""sha"": ""6fe9c1b320ef5f270baf8b8ea1b45fed616bbcb9"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/anchor-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/anchor-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/anchor-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/anchor-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -4,11 +4,11 @@ On success, you will see a series of \""PASS\"" messages, followed by \""TEST COMPLETE\n \n \n PASS canonicalize('http://www.example.com/#hello, world') is 'http://www.example.com/#hello, world'\n-PASS canonicalize('http://www.example.com/#\u00c2\u00a9') is 'http://www.example.com/#\u00c2\u00a9'\n-PASS canonicalize('http://www.example.com/#\ud800\udf00ss') is 'http://www.example.com/#\ud800\udf00ss'\n+PASS canonicalize('http://www.example.com/#\u00c2\u00a9') is 'http://www.example.com/#%C3%82%C2%A9'\n+PASS canonicalize('http://www.example.com/#\ud800\udf00ss') is 'http://www.example.com/#%F0%90%8C%80ss'\n PASS canonicalize('http://www.example.com/#%41%a') is 'http://www.example.com/#%41%a'\n-PASS canonicalize('http://www.example.com/#\\ud800\\u597d') is 'http://www.example.com/#\\uFFFD\\u597D'\n-FAIL canonicalize('http://www.example.com/#a\\uFDD0') should be http://www.example.com/#a\ufdd0. Was http://www.example.com/#a\ufffd.\n+PASS canonicalize('http://www.example.com/#\\ud800\\u597d') is 'http://www.example.com/#%EF%BF%BD%E5%A5%BD'\n+PASS canonicalize('http://www.example.com/#a\\uFDD0') is 'http://www.example.com/#a%EF%BF%BD'\n PASS canonicalize('http://www.example.com/#asdf#qwer') is 'http://www.example.com/#asdf#qwer'\n PASS canonicalize('http://www.example.com/##asdf') is 'http://www.example.com/##asdf'\n PASS canonicalize('http://www.example.com/#a\\nb\\rc\\td') is 'http://www.example.com/#abcd'""}<_**next**_>{""sha"": ""08654b3fe5287df8683769c414c2b741081d29aa"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/file-http-base-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/file-http-base-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/file-http-base-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/file-http-base-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,8 +20,8 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n FAIL canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') should be file://7:////foo/bar.html. Was file:///7:////foo/bar.html.\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///filer/home/me.\n FAIL canonicalize('file:///C:/foo/../../../bar.html') should be file:///C:/bar.html. Was file:///bar.html.\n-PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#\\xc2'\n-PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#\u00c2'\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n+PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n PASS canonicalize('file:c:\\\\foo\\\\bar.html') is 'file:///c:/foo/bar.html'\n PASS canonicalize('file:c|//foo\\\\bar.html') is 'file:///c%7C//foo/bar.html'""}<_**next**_>{""sha"": ""2ad64ae1134a8b1bc2c2d40b9a0b3c9aa86ae481"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/anchor.js"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/anchor.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/anchor.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/anchor.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -2,11 +2,11 @@ description(\""Test URLs that have an anchor.\"");\n \n cases = [ \n   [\""hello, world\"", \""hello, world\""],\n-  [\""\\xc2\\xa9\"", \""\\xc2\\xa9\""],\n-  [\""\\ud800\\udf00ss\"", \""\\ud800\\udf00ss\""],\n+  [\""\\xc2\\xa9\"", \""%C3%82%C2%A9\""],\n+  [\""\\ud800\\udf00ss\"", \""%F0%90%8C%80ss\""],\n   [\""%41%a\"", \""%41%a\""],\n-  [\""\\\\ud800\\\\u597d\"", \""\\\\uFFFD\\\\u597D\""],\n-  [\""a\\\\uFDD0\"", \""a\\\\uFDD0\""],\n+  [\""\\\\ud800\\\\u597d\"", \""%EF%BF%BD%E5%A5%BD\""],\n+  [\""a\\\\uFDD0\"", \""a%EF%BF%BD\""],\n   [\""asdf#qwer\"", \""asdf#qwer\""],\n   [\""#asdf\"", \""#asdf\""],\n   [\""a\\\\nb\\\\rc\\\\td\"", \""abcd\""],""}<_**next**_>{""sha"": ""db9386372bec5d3ed93d777839f8eb630b282b86"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/file-http-base.js"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/file-http-base.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/file-http-base.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/file-http-base.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -36,8 +36,8 @@ cases = [\n     // Make sure relative paths can't go above the \""C:\""\n     [\""file:///C:/foo/../../../bar.html\"", \""file:///C:/bar.html\""],\n     // Busted refs shouldn't make the whole thing fail.\n-    [\""file:///C:/asdf#\\\\xc2\"", \""file:///C:/asdf#\\\\xc2\""],\n-    [\""file:///C:/asdf#\\xc2\"", \""file:///C:/asdf#\\xc2\""],\n+    [\""file:///C:/asdf#\\\\xc2\"", \""file:///C:/asdf#%C3%82\""],\n+    [\""file:///C:/asdf#\\xc2\"", \""file:///C:/asdf#%C3%82\""],\n \n     // Unix-style paths\n     [\""file:///home/me\"", \""file:///home/me\""],""}<_**next**_>{""sha"": ""0fc34b79acb7eb8b99cf001b750ef13f12f5f3b5"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/file.js"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/file.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/file.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/file.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -36,7 +36,7 @@ cases = [\n     // Make sure relative paths can't go above the \""C:\""\n     [\""file:///C:/foo/../../../bar.html\"", \""file:///C:/bar.html\""],\n     // Busted refs shouldn't make the whole thing fail.\n-    [\""file:///C:/asdf#\\\\xc2\"", \""file:///C:/asdf#\\\\xef\\\\xbf\\\\xbd\""],\n+    [\""file:///C:/asdf#\\\\xc2\"", \""file:///C:/asdf#%C3%82\""],\n \n     // Unix-style paths\n     [\""file:///home/me\"", \""file:///home/me\""],""}<_**next**_>{""sha"": ""af075a5c2c7ed601137bf0086f8efec691b7e3a7"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/segments.js"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/segments.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/segments.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/segments.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -98,7 +98,7 @@ cases = [\n   [\""/a%2fc\"",                                  [\""http:\"",\""example.org\"",\""\"",\""/a%2fc\"",\""\"",\""\""]],\n   [\""/a/%2f/c\"",                                [\""http:\"",\""example.org\"",\""\"",\""/a/%2f/c\"",\""\"",\""\""]],\n \n-  [\""#\\u03B2\"",                                 [\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#\\u03B2\""]],\n+  [\""#\\u03B2\"",                                 [\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#%CE%B2\""]],\n ];\n \n var originalBaseURL = canonicalize(\"".\"");""}<_**next**_>{""sha"": ""75e2422895ceeec756f849b049d4af98ab2b9f4c"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/script-tests/standard-url.js"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/standard-url.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/script-tests/standard-url.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/script-tests/standard-url.js?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -2,7 +2,7 @@ description(\""Canonicalization of standard URLs\"");\n \n cases = [\n   [\""http://www.google.com/foo?bar=baz#\"", \""http://www.google.com/foo?bar=baz#\""],\n-  [\""http://www.google.com/foo?bar=baz# \\u00bb\"", \""http://www.google.com/foo?bar=baz# \\u00bb\""],\n+  [\""http://www.google.com/foo?bar=baz# \\u00bb\"", \""http://www.google.com/foo?bar=baz# %C2%BB\""],\n   [\""http://[www.google.com]/\"", \""http://[www.google.com]/\""],\n   [\""http://www.google.com\"", \""http://www.google.com/\""],\n   // Disabled because whitespace gets treated different in this API.\n@@ -17,7 +17,7 @@ cases = [\n   // Backslashes should get converted to forward slashes.\n   [\""http:\\\\\\\\\\\\\\\\www.google.com\\\\\\\\foo\"", \""http://www.google.com/foo\""],\n   // Busted refs shouldn't make the whole thing fail.\n-  [\""http://www.google.com/asdf#\\\\ud800\"", \""http://www.google.com/asdf#\\\\uFFFD\""],\n+  [\""http://www.google.com/asdf#\\\\ud800\"", \""http://www.google.com/asdf#%EF%BF%BD\""],\n   // Basic port tests.\n   [\""http://foo:80/\"", \""http://foo/\""],\n   [\""http://foo:81/\"", \""http://foo:81/\""],""}<_**next**_>{""sha"": ""94e75e111e55c8e1bee9fd228b004991651df549"", ""filename"": ""third_party/WebKit/LayoutTests/fast/url/segments-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/segments-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/fast/url/segments-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/url/segments-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -97,7 +97,7 @@ PASS segments('/a/b/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/b/c\"",\""\"",\""\""]'\n PASS segments('/a/ /c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%20/c\"",\""\"",\""\""]'\n PASS segments('/a%2fc') is '[\""http:\"",\""example.org\"",\""\"",\""/a%2fc\"",\""\"",\""\""]'\n PASS segments('/a/%2f/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%2f/c\"",\""\"",\""\""]'\n-PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#\u03b2\""]'\n+PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#%CE%B2\""]'\n PASS successfullyParsed is true\n \n TEST COMPLETE""}<_**next**_>{""sha"": ""03c416b46404d8384da523031ab83e060ba769ef"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/uri/resolve-encoding-relative-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/http/tests/uri/resolve-encoding-relative-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/http/tests/uri/resolve-encoding-relative-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/uri/resolve-encoding-relative-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -2,8 +2,8 @@ Test how non-ASCII characters are encoded in relative URLs.\n \n 1 2 3 4 5\n 1. PASS\n-2. FAIL: http://127.0.0.1:8000/uri/resolve-encoding-relative.html#\u0444\u0440\u0430\u0433\u043c\u0435\u043d\u0442\n+2. PASS\n 3. PASS\n 4. PASS\n-5. FAIL: http://127.0.0.1:8000/%D0%BF%D1%83%D1%82%D1%8C?%E7%E0%EF%F0%EE%F1#\u0444\u0440\u0430\u0433\u043c\u0435\u043d\u0442\n+5. PASS\n ""}<_**next**_>{""sha"": ""cc508032946f6bab21f5e3371e4af78bc7646bbb"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 328 PASS, 181 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 331 PASS, 178 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""cc508032946f6bab21f5e3371e4af78bc7646bbb"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-xhtml-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-xhtml-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-xhtml-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/a-element-xhtml-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 328 PASS, 181 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 331 PASS, 178 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""6296888f4bb5fe59945fb2d94fa2af24b9a5ed05"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-constructor-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-constructor-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-constructor-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-constructor-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 513 tests; 398 PASS, 115 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 513 tests; 401 PASS, 112 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS URL.searchParams getter\n PASS URL.searchParams updating, clearing\n PASS URL.searchParams setter, invalid values\n@@ -107,7 +107,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -166,7 +166,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -272,7 +272,7 @@ PASS Parsing: <http://\ufdd0zyx.com> against <http://other.com/>\n PASS Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/>\n PASS Parsing: <https://\ufffd> against <about:blank>\n PASS Parsing: <https://%EF%BF%BD> against <about:blank>\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw""}<_**next**_>{""sha"": ""964048981fb6ae1cdc1bcd5734e523684b3b5c67"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-setters-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-setters-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-setters-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/external/wpt/url/url-setters-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 574 tests; 275 PASS, 299 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 574 tests; 278 PASS, 296 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS URL: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged.\n PASS <a>: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged.\n@@ -568,9 +568,9 @@ PASS <area>: Setting <https://example.net?lang=en-US#nav>.hash = ''\n FAIL URL: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n FAIL <a>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n FAIL <area>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n-FAIL URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n+PASS URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n PASS URL: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <a>: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <area>: Setting <javascript:alert(1)>.hash = 'castle'""}<_**next**_>{""sha"": ""3a61cfad77f97af1358a7a05eb5fe31abeeece0b"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/fast/url/file-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,7 +20,7 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n FAIL canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') should be file://7:////foo/bar.html. Was file:///7:////foo/bar.html.\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///tmp/mock/filer/home/me.\n FAIL canonicalize('file:///C:/foo/../../../bar.html') should be file:///C:/bar.html. Was file:///bar.html.\n-FAIL canonicalize('file:///C:/asdf#\\xc2') should be file:///C:/asdf#\u00ef\u00bf\u00bd. Was file:///C:/asdf#\u00c2.\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n FAIL canonicalize('file:c:\\\\foo\\\\bar.html') should be file:///c:/foo/bar.html. Was file:///tmp/mock/c:/foo/bar.html.\n FAIL canonicalize('file:c|//foo\\\\bar.html') should be file:///c%7C//foo/bar.html. Was file:///tmp/mock/c%7C//foo/bar.html.""}<_**next**_>{""sha"": ""08654b3fe5287df8683769c414c2b741081d29aa"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/fast/url/file-http-base-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-http-base-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-http-base-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/fast/url/file-http-base-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,8 +20,8 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n FAIL canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') should be file://7:////foo/bar.html. Was file:///7:////foo/bar.html.\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///filer/home/me.\n FAIL canonicalize('file:///C:/foo/../../../bar.html') should be file:///C:/bar.html. Was file:///bar.html.\n-PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#\\xc2'\n-PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#\u00c2'\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n+PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n PASS canonicalize('file:c:\\\\foo\\\\bar.html') is 'file:///c:/foo/bar.html'\n PASS canonicalize('file:c|//foo\\\\bar.html') is 'file:///c%7C//foo/bar.html'""}<_**next**_>{""sha"": ""94e75e111e55c8e1bee9fd228b004991651df549"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/fast/url/segments-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/segments-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/segments-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/fast/url/segments-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -97,7 +97,7 @@ PASS segments('/a/b/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/b/c\"",\""\"",\""\""]'\n PASS segments('/a/ /c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%20/c\"",\""\"",\""\""]'\n PASS segments('/a%2fc') is '[\""http:\"",\""example.org\"",\""\"",\""/a%2fc\"",\""\"",\""\""]'\n PASS segments('/a/%2f/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%2f/c\"",\""\"",\""\""]'\n-PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#\u03b2\""]'\n+PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#%CE%B2\""]'\n PASS successfullyParsed is true\n \n TEST COMPLETE""}<_**next**_>{""sha"": ""483f690834c953f23acf32886c9ac9fce8778ab5"", ""filename"": ""third_party/WebKit/LayoutTests/platform/linux/fast/url/standard-url-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/standard-url-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/linux/fast/url/standard-url-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/linux/fast/url/standard-url-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -4,7 +4,7 @@ On success, you will see a series of \""PASS\"" messages, followed by \""TEST COMPLETE\n \n \n PASS canonicalize('http://www.google.com/foo?bar=baz#') is 'http://www.google.com/foo?bar=baz#'\n-PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# \u00bb'\n+PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# %C2%BB'\n PASS canonicalize('http://[www.google.com]/') is 'http://[www.google.com]/'\n PASS canonicalize('http://www.google.com') is 'http://www.google.com/'\n PASS canonicalize('http:////////user:@google.com:99?foo') is 'http://user@google.com:99/?foo'\n@@ -13,7 +13,7 @@ PASS canonicalize('http://www/foo%2Ehtml') is 'http://www/foo.html'\n PASS canonicalize('http://user:pass@/') is 'http://user:pass@/'\n PASS canonicalize('http://%25DOMAIN:foobar@foodomain.com/') is 'http://%25DOMAIN:foobar@foodomain.com/'\n PASS canonicalize('http:\\\\\\\\www.google.com\\\\foo') is 'http://www.google.com/foo'\n-PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#\\uFFFD'\n+PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#%EF%BF%BD'\n PASS canonicalize('http://foo:80/') is 'http://foo/'\n PASS canonicalize('http://foo:81/') is 'http://foo:81/'\n PASS canonicalize('httpa://foo:80/') is 'httpa://foo:80/'""}<_**next**_>{""sha"": ""cc508032946f6bab21f5e3371e4af78bc7646bbb"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 328 PASS, 181 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 331 PASS, 178 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""cc508032946f6bab21f5e3371e4af78bc7646bbb"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-xhtml-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-xhtml-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-xhtml-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/a-element-xhtml-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 328 PASS, 181 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 331 PASS, 178 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""6296888f4bb5fe59945fb2d94fa2af24b9a5ed05"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-constructor-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-constructor-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-constructor-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-constructor-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 513 tests; 398 PASS, 115 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 513 tests; 401 PASS, 112 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS URL.searchParams getter\n PASS URL.searchParams updating, clearing\n PASS URL.searchParams setter, invalid values\n@@ -107,7 +107,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///tmp/mock/c:/foo/bar.html\""\n@@ -166,7 +166,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -272,7 +272,7 @@ PASS Parsing: <http://\ufdd0zyx.com> against <http://other.com/>\n PASS Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/>\n PASS Parsing: <https://\ufffd> against <about:blank>\n PASS Parsing: <https://%EF%BF%BD> against <about:blank>\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw""}<_**next**_>{""sha"": ""964048981fb6ae1cdc1bcd5734e523684b3b5c67"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-setters-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-setters-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-setters-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/external/wpt/url/url-setters-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 574 tests; 275 PASS, 299 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 574 tests; 278 PASS, 296 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS URL: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged.\n PASS <a>: Setting <a://example.net>.protocol = '' The empty string is not a valid scheme. Setter leaves the URL unchanged.\n@@ -568,9 +568,9 @@ PASS <area>: Setting <https://example.net?lang=en-US#nav>.hash = ''\n FAIL URL: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n FAIL <a>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n FAIL <area>: Setting <a:/>.hash = '\\0\u0001\t\\n\\r\u001f !\""#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\u007f\u0080\u0081\u00c9\u00e9' Simple percent-encoding; nuls, tabs, and newlines are removed assert_equals: expected \""a:/#%01%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~%7F%C2%80%C2%81%C3%89%C3%A9\"" but got \""a:/#%00%01%09%0A%0D%1F !\\\""#$%&'()*+,-./09:;<=>?@AZ[\\\\]^_`az{|}~\u007f%C2%80%C2%81%C3%89%C3%A9\""\n-FAIL URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n-FAIL <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is assert_equals: expected \""http://example.net/#%c3%89t%C3%A9\"" but got \""http://example.net/#%c3%89t\u00e9\""\n+PASS URL: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <a>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n+PASS <area>: Setting <http://example.net>.hash = '%c3%89t\u00e9' Bytes already percent-encoded are left as-is\n PASS URL: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <a>: Setting <javascript:alert(1)>.hash = 'castle'\n PASS <area>: Setting <javascript:alert(1)>.hash = 'castle'""}<_**next**_>{""sha"": ""3a61cfad77f97af1358a7a05eb5fe31abeeece0b"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/fast/url/file-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/fast/url/file-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/fast/url/file-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/fast/url/file-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,7 +20,7 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n FAIL canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') should be file://7:////foo/bar.html. Was file:///7:////foo/bar.html.\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///tmp/mock/filer/home/me.\n FAIL canonicalize('file:///C:/foo/../../../bar.html') should be file:///C:/bar.html. Was file:///bar.html.\n-FAIL canonicalize('file:///C:/asdf#\\xc2') should be file:///C:/asdf#\u00ef\u00bf\u00bd. Was file:///C:/asdf#\u00c2.\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n FAIL canonicalize('file:c:\\\\foo\\\\bar.html') should be file:///c:/foo/bar.html. Was file:///tmp/mock/c:/foo/bar.html.\n FAIL canonicalize('file:c|//foo\\\\bar.html') should be file:///c%7C//foo/bar.html. Was file:///tmp/mock/c%7C//foo/bar.html.""}<_**next**_>{""sha"": ""483f690834c953f23acf32886c9ac9fce8778ab5"", ""filename"": ""third_party/WebKit/LayoutTests/platform/mac/fast/url/standard-url-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/fast/url/standard-url-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/mac/fast/url/standard-url-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/mac/fast/url/standard-url-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -4,7 +4,7 @@ On success, you will see a series of \""PASS\"" messages, followed by \""TEST COMPLETE\n \n \n PASS canonicalize('http://www.google.com/foo?bar=baz#') is 'http://www.google.com/foo?bar=baz#'\n-PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# \u00bb'\n+PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# %C2%BB'\n PASS canonicalize('http://[www.google.com]/') is 'http://[www.google.com]/'\n PASS canonicalize('http://www.google.com') is 'http://www.google.com/'\n PASS canonicalize('http:////////user:@google.com:99?foo') is 'http://user@google.com:99/?foo'\n@@ -13,7 +13,7 @@ PASS canonicalize('http://www/foo%2Ehtml') is 'http://www/foo.html'\n PASS canonicalize('http://user:pass@/') is 'http://user:pass@/'\n PASS canonicalize('http://%25DOMAIN:foobar@foodomain.com/') is 'http://%25DOMAIN:foobar@foodomain.com/'\n PASS canonicalize('http:\\\\\\\\www.google.com\\\\foo') is 'http://www.google.com/foo'\n-PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#\\uFFFD'\n+PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#%EF%BF%BD'\n PASS canonicalize('http://foo:80/') is 'http://foo/'\n PASS canonicalize('http://foo:81/') is 'http://foo:81/'\n PASS canonicalize('httpa://foo:80/') is 'httpa://foo:80/'""}<_**next**_>{""sha"": ""e966f7357806b26bd6eb3e5d09b1bd46c52402fa"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 324 PASS, 185 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 327 PASS, 182 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///C:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""e966f7357806b26bd6eb3e5d09b1bd46c52402fa"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-xhtml-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-xhtml-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-xhtml-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/a-element-xhtml-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 509 tests; 324 PASS, 185 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 509 tests; 327 PASS, 182 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS Loading data\u2026\n PASS Parsing: <http://example\t.\\norg> against <http://example.org/foo/bar>\n PASS Parsing: <http://user:pass@foo:21/bar;par?b#c> against <http://example.org/foo/bar>\n@@ -103,7 +103,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///C:/foo/bar.html\""\n@@ -162,7 +162,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -268,7 +268,7 @@ FAIL Parsing: <http://\ufdd0zyx.com> against <http://other.com/> assert_equals: fai\n FAIL Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/> assert_equals: failure should set href to input expected \""http://%ef%b7%90zyx.com\"" but got \""http://%EF%BF%BDzyx.com/\""\n FAIL Parsing: <https://\ufffd> against <about:blank> assert_equals: failure should set href to input expected \""https://\\ufffd\"" but got \""https://%EF%BF%BD/\""\n FAIL Parsing: <https://%EF%BF%BD> against <about:blank> assert_equals: failure should set href to input expected \""https://%EF%BF%BD\"" but got \""https://%EF%BF%BD/\""\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_unreached: Expected URL to fail parsing Reached unreachable code""}<_**next**_>{""sha"": ""1b7414e269228933412bab601cbb152ec66e4200"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-constructor-expected.txt"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-constructor-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-constructor-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/external/wpt/url/url-constructor-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1,5 +1,5 @@\n This is a testharness.js-based test.\n-Found 513 tests; 392 PASS, 121 FAIL, 0 TIMEOUT, 0 NOTRUN.\n+Found 513 tests; 395 PASS, 118 FAIL, 0 TIMEOUT, 0 NOTRUN.\n PASS URL.searchParams getter\n PASS URL.searchParams updating, clearing\n PASS URL.searchParams setter, invalid values\n@@ -107,7 +107,7 @@ PASS Parsing: </a/b/c> against <http://example.org/foo/bar>\n PASS Parsing: </a/ /c> against <http://example.org/foo/bar>\n PASS Parsing: </a%2fc> against <http://example.org/foo/bar>\n PASS Parsing: </a/%2f/c> against <http://example.org/foo/bar>\n-FAIL Parsing: <#\u03b2> against <http://example.org/foo/bar> assert_equals: href expected \""http://example.org/foo/bar#%CE%B2\"" but got \""http://example.org/foo/bar#\u03b2\""\n+PASS Parsing: <#\u03b2> against <http://example.org/foo/bar>\n PASS Parsing: <data:text/html,test#test> against <http://example.org/foo/bar>\n PASS Parsing: <tel:1234567890> against <http://example.org/foo/bar>\n FAIL Parsing: <file:c:\\foo\\bar.html> against <file:///tmp/mock/path> assert_equals: href expected \""file:///c:/foo/bar.html\"" but got \""file:///C:/foo/bar.html\""\n@@ -166,7 +166,7 @@ PASS Parsing: <http://example.com/\u2025/foo> against <about:blank>\n PASS Parsing: <http://example.com/\ufeff/foo> against <about:blank>\n PASS Parsing: <http://example.com/\u202e/foo/\u202d/bar> against <about:blank>\n PASS Parsing: <http://www.google.com/foo?bar=baz#> against <about:blank>\n-FAIL Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank> assert_equals: href expected \""http://www.google.com/foo?bar=baz# %C2%BB\"" but got \""http://www.google.com/foo?bar=baz# \u00bb\""\n+PASS Parsing: <http://www.google.com/foo?bar=baz# \u00bb> against <about:blank>\n PASS Parsing: <data:test# \u00bb> against <about:blank>\n PASS Parsing: <http://www.google.com> against <about:blank>\n PASS Parsing: <http://192.0x00A80001> against <about:blank>\n@@ -272,7 +272,7 @@ PASS Parsing: <http://\ufdd0zyx.com> against <http://other.com/>\n PASS Parsing: <http://%ef%b7%90zyx.com> against <http://other.com/>\n PASS Parsing: <https://\ufffd> against <about:blank>\n PASS Parsing: <https://%EF%BF%BD> against <about:blank>\n-FAIL Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank> assert_equals: href expected \""https://x/%EF%BF%BD?%EF%BF%BD#%EF%BF%BD\"" but got \""https://x/%EF%BF%BD?%EF%BF%BD#\\ufffd\""\n+PASS Parsing: <https://x/\ufffd?\ufffd#\ufffd> against <about:blank>\n PASS Parsing: <http://\uff27\uff4f.com> against <http://other.com/>\n FAIL Parsing: <http://\uff05\uff14\uff11.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw\n FAIL Parsing: <http://%ef%bc%85%ef%bc%94%ef%bc%91.com> against <http://other.com/> assert_throws: function \""function () {\\n          bURL(expected.input, expected.base)\\n        }\"" did not throw""}<_**next**_>{""sha"": ""6c8cd6b4b4443053d60525e36956fee495b7b6f7"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/fast/url/file-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/file-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/file-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/fast/url/file-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,7 +20,7 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n PASS canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') is 'file://7:////foo/bar.html'\n FAIL canonicalize('file:filer/home\\\\me') should be file://filer/home/me. Was file:///tmp/mock/filer/home/me.\n PASS canonicalize('file:///C:/foo/../../../bar.html') is 'file:///C:/bar.html'\n-FAIL canonicalize('file:///C:/asdf#\\xc2') should be file:///C:/asdf#\u00ef\u00bf\u00bd. Was file:///C:/asdf#\u00c2.\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n FAIL canonicalize('file:c:\\\\foo\\\\bar.html') should be file:///c:/foo/bar.html. Was file:///C:/foo/bar.html.\n FAIL canonicalize('file:c|//foo\\\\bar.html') should be file:///c%7C//foo/bar.html. Was file:///C://foo/bar.html.""}<_**next**_>{""sha"": ""e331b5e2c7ad2956b78a496e1ae3723e6f7e358a"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/fast/url/file-http-base-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/file-http-base-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/file-http-base-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/fast/url/file-http-base-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -20,8 +20,8 @@ PASS canonicalize('file:///foo/bar.txt') is 'file:///foo/bar.txt'\n PASS canonicalize('FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html') is 'file://7:////foo/bar.html'\n PASS canonicalize('file:filer/home\\\\me') is 'file://filer/home/me'\n PASS canonicalize('file:///C:/foo/../../../bar.html') is 'file:///C:/bar.html'\n-PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#\\xc2'\n-PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#\u00c2'\n+PASS canonicalize('file:///C:/asdf#\\xc2') is 'file:///C:/asdf#%C3%82'\n+PASS canonicalize('file:///C:/asdf#\u00c2') is 'file:///C:/asdf#%C3%82'\n PASS canonicalize('file:///home/me') is 'file:///home/me'\n FAIL canonicalize('file:c:\\\\foo\\\\bar.html') should be file:///c:/foo/bar.html. Was file:///C:/foo/bar.html.\n FAIL canonicalize('file:c|//foo\\\\bar.html') should be file:///c%7C//foo/bar.html. Was file:///C://foo/bar.html.""}<_**next**_>{""sha"": ""0fb1a0301f109feb9e6dd386dbf83a00c0343f05"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/fast/url/segments-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/segments-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/segments-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/fast/url/segments-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -97,7 +97,7 @@ PASS segments('/a/b/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/b/c\"",\""\"",\""\""]'\n PASS segments('/a/ /c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%20/c\"",\""\"",\""\""]'\n PASS segments('/a%2fc') is '[\""http:\"",\""example.org\"",\""\"",\""/a%2fc\"",\""\"",\""\""]'\n PASS segments('/a/%2f/c') is '[\""http:\"",\""example.org\"",\""\"",\""/a/%2f/c\"",\""\"",\""\""]'\n-PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#\u03b2\""]'\n+PASS segments('#\u03b2') is '[\""http:\"",\""example.org\"",\""\"",\""/foo/bar\"",\""\"",\""#%CE%B2\""]'\n PASS successfullyParsed is true\n \n TEST COMPLETE""}<_**next**_>{""sha"": ""9373dcc8dfa2032009e78c8871ce6ddd45a5cbec"", ""filename"": ""third_party/WebKit/LayoutTests/platform/win/fast/url/standard-url-expected.txt"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/standard-url-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/LayoutTests/platform/win/fast/url/standard-url-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/platform/win/fast/url/standard-url-expected.txt?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -4,7 +4,7 @@ On success, you will see a series of \""PASS\"" messages, followed by \""TEST COMPLETE\n \n \n PASS canonicalize('http://www.google.com/foo?bar=baz#') is 'http://www.google.com/foo?bar=baz#'\n-PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# \u00bb'\n+PASS canonicalize('http://www.google.com/foo?bar=baz# \u00bb') is 'http://www.google.com/foo?bar=baz# %C2%BB'\n PASS canonicalize('http://[www.google.com]/') is 'http://[www.google.com]/'\n PASS canonicalize('http://www.google.com') is 'http://www.google.com/'\n PASS canonicalize('http:////////user:@google.com:99?foo') is 'http://user@google.com:99/?foo'\n@@ -13,7 +13,7 @@ PASS canonicalize('http://www/foo%2Ehtml') is 'http://www/foo.html'\n PASS canonicalize('http://user:pass@/') is 'http://user:pass@/'\n PASS canonicalize('http://%25DOMAIN:foobar@foodomain.com/') is 'http://%25DOMAIN:foobar@foodomain.com/'\n PASS canonicalize('http:\\\\\\\\www.google.com\\\\foo') is 'http://www.google.com/foo'\n-PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#\\uFFFD'\n+PASS canonicalize('http://www.google.com/asdf#\\ud800') is 'http://www.google.com/asdf#%EF%BF%BD'\n PASS canonicalize('http://foo:80/') is 'http://foo/'\n PASS canonicalize('http://foo:81/') is 'http://foo:81/'\n PASS canonicalize('httpa://foo:80/') is 'httpa://foo:80/'""}<_**next**_>{""sha"": ""dc386c57ab5f3083b1b77947dd1116c7612a248d"", ""filename"": ""third_party/WebKit/Source/platform/weborigin/KURLTest.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/Source/platform/weborigin/KURLTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/third_party/WebKit/Source/platform/weborigin/KURLTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/weborigin/KURLTest.cpp?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -61,7 +61,7 @@ TEST(KURLTest, Getters) {\n        // shouldn't return it in percent-encoded form.\n        \""http://www.google.com/foo/blah?bar=baz#\\xce\\xb1\\xce\\xb2\"", \""http\"",\n        \""www.google.com\"", 0, \""\"", 0, \""/foo/blah\"", \""blah\"", \""bar=baz\"",\n-       \""\\xce\\xb1\\xce\\xb2\"", true},\n+       \""%CE%B1%CE%B2\"", true},\n       {\""http://foo.com:1234/foo/bar/\"", \""http\"", \""foo.com\"", 1234, \""\"", 0,\n        \""/foo/bar/\"", \""bar\"", 0, 0, false},\n       {\""http://www.google.com?#\"", \""http\"", \""www.google.com\"", 0, \""\"", 0, \""/\"", 0,""}<_**next**_>{""sha"": ""5dc81052311965a922f571c59f9be0064328dc82"", ""filename"": ""url/url_canon_etc.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 7, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/url/url_canon_etc.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/url/url_canon_etc.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/url/url_canon_etc.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -275,13 +275,7 @@ void DoCanonicalizeRef(const CHAR* spec,\n       // Normal ASCII characters are just appended.\n       output->push_back(static_cast<char>(spec[i]));\n     } else {\n-      // Non-ASCII characters are appended unescaped, but only when they are\n-      // valid. Invalid Unicode characters are replaced with the \""invalid\n-      // character\"" as IE seems to (ReadUTFChar puts the unicode replacement\n-      // character in the output on failure for us).\n-      unsigned code_point;\n-      ReadUTFChar(spec, &i, end, &code_point);\n-      AppendUTF8Value(code_point, output);\n+      AppendUTF8EscapedChar(spec, &i, end, output);\n     }\n   }\n ""}<_**next**_>{""sha"": ""feac82c44b350d5be2be6ff8730ea7c9352c422a"", ""filename"": ""url/url_canon_unittest.cc"", ""status"": ""modified"", ""additions"": 83, ""deletions"": 58, ""changes"": 141, ""blob_url"": ""https://github.com/chromium/chromium/blob/f8f6ed59949be4451ee2f5443d8a313f102fde60/url/url_canon_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f8f6ed59949be4451ee2f5443d8a313f102fde60/url/url_canon_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/url/url_canon_unittest.cc?ref=f8f6ed59949be4451ee2f5443d8a313f102fde60"", ""patch"": ""@@ -1274,21 +1274,23 @@ TEST(URLCanonTest, Ref) {\n   // Refs are trivial, it just checks the encoding.\n   DualComponentCase ref_cases[] = {\n       // Regular one, we shouldn't escape spaces, et al.\n-    {\""hello, world\"", L\""hello, world\"", \""#hello, world\"", Component(1, 12), true},\n+      {\""hello, world\"", L\""hello, world\"", \""#hello, world\"", Component(1, 12),\n+       true},\n       // UTF-8/wide input should be preserved\n-    {\""\\xc2\\xa9\"", L\""\\xa9\"", \""#\\xc2\\xa9\"", Component(1, 2), true},\n+      {\""\\xc2\\xa9\"", L\""\\xa9\"", \""#%C2%A9\"", Component(1, 6), true},\n       // Test a characer that takes > 16 bits (U+10300 = old italic letter A)\n-    {\""\\xF0\\x90\\x8C\\x80ss\"", L\""\\xd800\\xdf00ss\"", \""#\\xF0\\x90\\x8C\\x80ss\"", Component(1, 6), true},\n+      {\""\\xF0\\x90\\x8C\\x80ss\"", L\""\\xd800\\xdf00ss\"", \""#%F0%90%8C%80ss\"",\n+       Component(1, 14), true},\n       // Escaping should be preserved unchanged, even invalid ones\n-    {\""%41%a\"", L\""%41%a\"", \""#%41%a\"", Component(1, 5), true},\n+      {\""%41%a\"", L\""%41%a\"", \""#%41%a\"", Component(1, 5), true},\n       // Invalid UTF-8/16 input should be flagged and the input made valid\n-    {\""\\xc2\"", NULL, \""#\\xef\\xbf\\xbd\"", Component(1, 3), true},\n-    {NULL, L\""\\xd800\\x597d\"", \""#\\xef\\xbf\\xbd\\xe5\\xa5\\xbd\"", Component(1, 6), true},\n+      {\""\\xc2\"", NULL, \""#%EF%BF%BD\"", Component(1, 9), true},\n+      {NULL, L\""\\xd800\\x597d\"", \""#%EF%BF%BD%E5%A5%BD\"", Component(1, 18), true},\n       // Test a Unicode invalid character.\n-    {\""a\\xef\\xb7\\x90\"", L\""a\\xfdd0\"", \""#a\\xef\\xbf\\xbd\"", Component(1, 4), true},\n+      {\""a\\xef\\xb7\\x90\"", L\""a\\xfdd0\"", \""#a%EF%BF%BD\"", Component(1, 10), true},\n       // Refs can have # signs and we should preserve them.\n-    {\""asdf#qwer\"", L\""asdf#qwer\"", \""#asdf#qwer\"", Component(1, 9), true},\n-    {\""#asdf\"", L\""#asdf\"", \""##asdf\"", Component(1, 5), true},\n+      {\""asdf#qwer\"", L\""asdf#qwer\"", \""#asdf#qwer\"", Component(1, 9), true},\n+      {\""#asdf\"", L\""#asdf\"", \""##asdf\"", Component(1, 5), true},\n   };\n \n   for (size_t i = 0; i < arraysize(ref_cases); i++) {\n@@ -1351,49 +1353,56 @@ TEST(URLCanonTest, CanonicalizeStandardURL) {\n     const char* expected;\n     bool expected_success;\n   } cases[] = {\n-    {\""http://www.google.com/foo?bar=baz#\"", \""http://www.google.com/foo?bar=baz#\"", true},\n-    {\""http://[www.google.com]/\"", \""http://[www.google.com]/\"", false},\n-    {\""ht\\ttp:@www.google.com:80/;p?#\"", \""ht%09tp://www.google.com:80/;p?#\"", false},\n-    {\""http:////////user:@google.com:99?foo\"", \""http://user@google.com:99/?foo\"", true},\n-    {\""www.google.com\"", \"":www.google.com/\"", false},\n-    {\""http://192.0x00A80001\"", \""http://192.168.0.1/\"", true},\n-    {\""http://www/foo%2Ehtml\"", \""http://www/foo.html\"", true},\n-    {\""http://user:pass@/\"", \""http://user:pass@/\"", false},\n-    {\""http://%25DOMAIN:foobar@foodomain.com/\"", \""http://%25DOMAIN:foobar@foodomain.com/\"", true},\n+      {\""http://www.google.com/foo?bar=baz#\"",\n+       \""http://www.google.com/foo?bar=baz#\"", true},\n+      {\""http://[www.google.com]/\"", \""http://[www.google.com]/\"", false},\n+      {\""ht\\ttp:@www.google.com:80/;p?#\"", \""ht%09tp://www.google.com:80/;p?#\"",\n+       false},\n+      {\""http:////////user:@google.com:99?foo\"", \""http://user@google.com:99/?foo\"",\n+       true},\n+      {\""www.google.com\"", \"":www.google.com/\"", false},\n+      {\""http://192.0x00A80001\"", \""http://192.168.0.1/\"", true},\n+      {\""http://www/foo%2Ehtml\"", \""http://www/foo.html\"", true},\n+      {\""http://user:pass@/\"", \""http://user:pass@/\"", false},\n+      {\""http://%25DOMAIN:foobar@foodomain.com/\"",\n+       \""http://%25DOMAIN:foobar@foodomain.com/\"", true},\n \n       // Backslashes should get converted to forward slashes.\n-    {\""http:\\\\\\\\www.google.com\\\\foo\"", \""http://www.google.com/foo\"", true},\n+      {\""http:\\\\\\\\www.google.com\\\\foo\"", \""http://www.google.com/foo\"", true},\n \n       // Busted refs shouldn't make the whole thing fail.\n-    {\""http://www.google.com/asdf#\\xc2\"", \""http://www.google.com/asdf#\\xef\\xbf\\xbd\"", true},\n+      {\""http://www.google.com/asdf#\\xc2\"",\n+       \""http://www.google.com/asdf#%EF%BF%BD\"", true},\n \n       // Basic port tests.\n-    {\""http://foo:80/\"", \""http://foo/\"", true},\n-    {\""http://foo:81/\"", \""http://foo:81/\"", true},\n-    {\""httpa://foo:80/\"", \""httpa://foo:80/\"", true},\n-    {\""http://foo:-80/\"", \""http://foo:-80/\"", false},\n-\n-    {\""https://foo:443/\"", \""https://foo/\"", true},\n-    {\""https://foo:80/\"", \""https://foo:80/\"", true},\n-    {\""ftp://foo:21/\"", \""ftp://foo/\"", true},\n-    {\""ftp://foo:80/\"", \""ftp://foo:80/\"", true},\n-    {\""gopher://foo:70/\"", \""gopher://foo/\"", true},\n-    {\""gopher://foo:443/\"", \""gopher://foo:443/\"", true},\n-    {\""ws://foo:80/\"", \""ws://foo/\"", true},\n-    {\""ws://foo:81/\"", \""ws://foo:81/\"", true},\n-    {\""ws://foo:443/\"", \""ws://foo:443/\"", true},\n-    {\""ws://foo:815/\"", \""ws://foo:815/\"", true},\n-    {\""wss://foo:80/\"", \""wss://foo:80/\"", true},\n-    {\""wss://foo:81/\"", \""wss://foo:81/\"", true},\n-    {\""wss://foo:443/\"", \""wss://foo/\"", true},\n-    {\""wss://foo:815/\"", \""wss://foo:815/\"", true},\n+      {\""http://foo:80/\"", \""http://foo/\"", true},\n+      {\""http://foo:81/\"", \""http://foo:81/\"", true},\n+      {\""httpa://foo:80/\"", \""httpa://foo:80/\"", true},\n+      {\""http://foo:-80/\"", \""http://foo:-80/\"", false},\n+\n+      {\""https://foo:443/\"", \""https://foo/\"", true},\n+      {\""https://foo:80/\"", \""https://foo:80/\"", true},\n+      {\""ftp://foo:21/\"", \""ftp://foo/\"", true},\n+      {\""ftp://foo:80/\"", \""ftp://foo:80/\"", true},\n+      {\""gopher://foo:70/\"", \""gopher://foo/\"", true},\n+      {\""gopher://foo:443/\"", \""gopher://foo:443/\"", true},\n+      {\""ws://foo:80/\"", \""ws://foo/\"", true},\n+      {\""ws://foo:81/\"", \""ws://foo:81/\"", true},\n+      {\""ws://foo:443/\"", \""ws://foo:443/\"", true},\n+      {\""ws://foo:815/\"", \""ws://foo:815/\"", true},\n+      {\""wss://foo:80/\"", \""wss://foo:80/\"", true},\n+      {\""wss://foo:81/\"", \""wss://foo:81/\"", true},\n+      {\""wss://foo:443/\"", \""wss://foo/\"", true},\n+      {\""wss://foo:815/\"", \""wss://foo:815/\"", true},\n \n       // This particular code path ends up \""backing up\"" to replace an invalid\n       // host ICU generated with an escaped version. Test that in the context\n       // of a full URL to make sure the backing up doesn't mess up the non-host\n       // parts of the URL. \""EF B9 AA\"" is U+FE6A which is a type of percent that\n       // ICU will convert to an ASCII one, generating \""%81\"".\n-    {\""ws:)W\\x1eW\\xef\\xb9\\xaa\""\""81:80/\"", \""ws://%29w%1ew%81/\"", false},\n+      {\""ws:)W\\x1eW\\xef\\xb9\\xaa\""\n+       \""81:80/\"",\n+       \""ws://%29w%1ew%81/\"", false},\n   };\n \n   for (size_t i = 0; i < arraysize(cases); i++) {\n@@ -1683,41 +1692,57 @@ TEST(URLCanonTest, CanonicalizeFileURL) {\n   } cases[] = {\n #ifdef _WIN32\n       // Windows-style paths\n-    {\""file:c:\\\\foo\\\\bar.html\"", \""file:///C:/foo/bar.html\"", true, Component(), Component(7, 16)},\n-    {\""  File:c|////foo\\\\bar.html\"", \""file:///C:////foo/bar.html\"", true, Component(), Component(7, 19)},\n-    {\""file:\"", \""file:///\"", true, Component(), Component(7, 1)},\n-    {\""file:UNChost/path\"", \""file://unchost/path\"", true, Component(7, 7), Component(14, 5)},\n+      {\""file:c:\\\\foo\\\\bar.html\"", \""file:///C:/foo/bar.html\"", true, Component(),\n+       Component(7, 16)},\n+      {\""  File:c|////foo\\\\bar.html\"", \""file:///C:////foo/bar.html\"", true,\n+       Component(), Component(7, 19)},\n+      {\""file:\"", \""file:///\"", true, Component(), Component(7, 1)},\n+      {\""file:UNChost/path\"", \""file://unchost/path\"", true, Component(7, 7),\n+       Component(14, 5)},\n       // CanonicalizeFileURL supports absolute Windows style paths for IE\n       // compatibility. Note that the caller must decide that this is a file\n       // URL itself so it can call the file canonicalizer. This is usually\n       // done automatically as part of relative URL resolving.\n-    {\""c:\\\\foo\\\\bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n-    {\""C|/foo/bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n-    {\""/C|\\\\foo\\\\bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n-    {\""//C|/foo/bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n-    {\""//server/file\"", \""file://server/file\"", true, Component(7, 6), Component(13, 5)},\n-    {\""\\\\\\\\server\\\\file\"", \""file://server/file\"", true, Component(7, 6), Component(13, 5)},\n-    {\""/\\\\server/file\"", \""file://server/file\"", true, Component(7, 6), Component(13, 5)},\n+      {\""c:\\\\foo\\\\bar\"", \""file:///C:/foo/bar\"", true, Component(),\n+       Component(7, 11)},\n+      {\""C|/foo/bar\"", \""file:///C:/foo/bar\"", true, Component(), Component(7, 11)},\n+      {\""/C|\\\\foo\\\\bar\"", \""file:///C:/foo/bar\"", true, Component(),\n+       Component(7, 11)},\n+      {\""//C|/foo/bar\"", \""file:///C:/foo/bar\"", true, Component(),\n+       Component(7, 11)},\n+      {\""//server/file\"", \""file://server/file\"", true, Component(7, 6),\n+       Component(13, 5)},\n+      {\""\\\\\\\\server\\\\file\"", \""file://server/file\"", true, Component(7, 6),\n+       Component(13, 5)},\n+      {\""/\\\\server/file\"", \""file://server/file\"", true, Component(7, 6),\n+       Component(13, 5)},\n       // We should preserve the number of slashes after the colon for IE\n       // compatibility, except when there is none, in which case we should\n       // add one.\n-    {\""file:c:foo/bar.html\"", \""file:///C:/foo/bar.html\"", true, Component(), Component(7, 16)},\n-    {\""file:/\\\\/\\\\C:\\\\\\\\//foo\\\\bar.html\"", \""file:///C:////foo/bar.html\"", true, Component(), Component(7, 19)},\n+      {\""file:c:foo/bar.html\"", \""file:///C:/foo/bar.html\"", true, Component(),\n+       Component(7, 16)},\n+      {\""file:/\\\\/\\\\C:\\\\\\\\//foo\\\\bar.html\"", \""file:///C:////foo/bar.html\"", true,\n+       Component(), Component(7, 19)},\n       // Three slashes should be non-UNC, even if there is no drive spec (IE\n       // does this, which makes the resulting request invalid).\n-    {\""file:///foo/bar.txt\"", \""file:///foo/bar.txt\"", true, Component(), Component(7, 12)},\n+      {\""file:///foo/bar.txt\"", \""file:///foo/bar.txt\"", true, Component(),\n+       Component(7, 12)},\n       // TODO(brettw) we should probably fail for invalid host names, which\n       // would change the expected result on this test. We also currently allow\n       // colon even though it's probably invalid, because its currently the\n       // \""natural\"" result of the way the canonicalizer is written. There doesn't\n       // seem to be a strong argument for why allowing it here would be bad, so\n       // we just tolerate it and the load will fail later.\n-    {\""FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html\"", \""file://7:////foo/bar.html\"", false, Component(7, 2), Component(9, 16)},\n-    {\""file:filer/home\\\\me\"", \""file://filer/home/me\"", true, Component(7, 5), Component(12, 8)},\n+      {\""FILE:/\\\\/\\\\7:\\\\\\\\//foo\\\\bar.html\"", \""file://7:////foo/bar.html\"", false,\n+       Component(7, 2), Component(9, 16)},\n+      {\""file:filer/home\\\\me\"", \""file://filer/home/me\"", true, Component(7, 5),\n+       Component(12, 8)},\n       // Make sure relative paths can't go above the \""C:\""\n-    {\""file:///C:/foo/../../../bar.html\"", \""file:///C:/bar.html\"", true, Component(), Component(7, 12)},\n+      {\""file:///C:/foo/../../../bar.html\"", \""file:///C:/bar.html\"", true,\n+       Component(), Component(7, 12)},\n       // Busted refs shouldn't make the whole thing fail.\n-    {\""file:///C:/asdf#\\xc2\"", \""file:///C:/asdf#\\xef\\xbf\\xbd\"", true, Component(), Component(7, 8)},\n+      {\""file:///C:/asdf#\\xc2\"", \""file:///C:/asdf#%EF%BF%BD\"", true, Component(),\n+       Component(7, 8)},\n #else\n       // Unix-style paths\n     {\""file:///home/me\"", \""file:///home/me\"", true, Component(), Component(7, 8)},""}","void DoCanonicalizeRef(const CHAR* spec,
                       const Component& ref,
                       CanonOutput* output,
                       Component* out_ref) {
  if (ref.len < 0) {
    *out_ref = Component();
    return;
  }

  output->push_back('#');
  out_ref->begin = output->length();

  int end = ref.end();
  for (int i = ref.begin; i < end; i++) {
    if (spec[i] == 0) {
      continue;
    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {
      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);
    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {
       output->push_back(static_cast<char>(spec[i]));
     } else {
      AppendUTF8EscapedChar(spec, &i, end, output);
     }
   }
 
  out_ref->len = output->length() - out_ref->begin;
}
","void DoCanonicalizeRef(const CHAR* spec,
                       const Component& ref,
                       CanonOutput* output,
                       Component* out_ref) {
  if (ref.len < 0) {
    *out_ref = Component();
    return;
  }

  output->push_back('#');
  out_ref->begin = output->length();

  int end = ref.end();
  for (int i = ref.begin; i < end; i++) {
    if (spec[i] == 0) {
      continue;
    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {
      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);
    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {
       output->push_back(static_cast<char>(spec[i]));
     } else {
      unsigned code_point;
      ReadUTFChar(spec, &i, end, &code_point);
      AppendUTF8Value(code_point, output);
     }
   }
 
  out_ref->len = output->length() - out_ref->begin;
}
",C,"      AppendUTF8EscapedChar(spec, &i, end, output);
","      unsigned code_point;
      ReadUTFChar(spec, &i, end, &code_point);
      AppendUTF8Value(code_point, output);
",,"@@ -275,13 +275,7 @@ void DoCanonicalizeRef(const CHAR* spec,
       // Normal ASCII characters are just appended.
       output->push_back(static_cast<char>(spec[i]));
     } else {
-      // Non-ASCII characters are appended unescaped, but only when they are
-      // valid. Invalid Unicode characters are replaced with the ""invalid
-      // character"" as IE seems to (ReadUTFChar puts the unicode replacement
-      // character in the output on failure for us).
-      unsigned code_point;
-      ReadUTFChar(spec, &i, end, &code_point);
-      AppendUTF8Value(code_point, output);
+      AppendUTF8EscapedChar(spec, &i, end, output);
     }
   }
 ",Chrome,f8f6ed59949be4451ee2f5443d8a313f102fde60,0a918e900a759b04f177cc5b8bca668140751136,1,"void DoCanonicalizeRef(const CHAR* spec,
                       const Component& ref,
                       CanonOutput* output,
                       Component* out_ref) {
  if (ref.len < 0) {
    // Common case of no ref.
    *out_ref = Component();
    return;
  }

  // Append the ref separator. Note that we need to do this even when the ref
  // is empty but present.
  output->push_back('#');
  out_ref->begin = output->length();

  // Now iterate through all the characters, converting to UTF-8 and validating.
  int end = ref.end();
  for (int i = ref.begin; i < end; i++) {
    if (spec[i] == 0) {
      // IE just strips NULLs, so we do too.
      continue;
    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {
      // Unline IE seems to, we escape control characters. This will probably
      // make the reference fragment unusable on a web page, but people
      // shouldn't be using control characters in their anchor names.
      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);
    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {
       // Normal ASCII characters are just appended.
       output->push_back(static_cast<char>(spec[i]));
     } else {
//flaw_line_below:
      // Non-ASCII characters are appended unescaped, but only when they are
//flaw_line_below:
      // valid. Invalid Unicode characters are replaced with the ""invalid
//flaw_line_below:
      // character"" as IE seems to (ReadUTFChar puts the unicode replacement
//flaw_line_below:
      // character in the output on failure for us).
//flaw_line_below:
      unsigned code_point;
//flaw_line_below:
      ReadUTFChar(spec, &i, end, &code_point);
//flaw_line_below:
      AppendUTF8Value(code_point, output);
//fix_flaw_line_below:
//      AppendUTF8EscapedChar(spec, &i, end, output);
     }
   }
 
  out_ref->len = output->length() - out_ref->begin;
}
",186880,"void DoCanonicalizeRef(const CHAR* spec,
                       const Component& ref,
                       CanonOutput* output,
                       Component* out_ref) {
  if (ref.len < 0) {
    *out_ref = Component();
    return;
  }

  output->push_back('#');
  out_ref->begin = output->length();

  int end = ref.end();
  for (int i = ref.begin; i < end; i++) {
    if (spec[i] == 0) {
      continue;
    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {
      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);
    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {
       output->push_back(static_cast<char>(spec[i]));
     } else {
      unsigned code_point;
      ReadUTFChar(spec, &i, end, &code_point);
      AppendUTF8Value(code_point, output);
     }
   }
 
  out_ref->len = output->length() - out_ref->begin;
}
","void DoCanonicalizeRef(const CHAR* spec,
                       const Component& ref,
                       CanonOutput* output,
                       Component* out_ref) {
  if (ref.len < 0) {
    *out_ref = Component();
    return;
  }

  output->push_back('#');
  out_ref->begin = output->length();

  int end = ref.end();
  for (int i = ref.begin; i < end; i++) {
    if (spec[i] == 0) {
      continue;
    } else if (static_cast<UCHAR>(spec[i]) < 0x20) {
      AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);
    } else if (static_cast<UCHAR>(spec[i]) < 0x80) {
       output->push_back(static_cast<char>(spec[i]));
     } else {
      AppendUTF8EscapedChar(spec, &i, end, output);
     }
   }
 
  out_ref->len = output->length() - out_ref->begin;
}
","The `DoCanonicalizeRef` function processes a given character specification (`spec`) and a reference component (`ref`) to generate a canonicalized output while handling special characters. If the length of `ref` is negative, it initializes `out_ref` to an empty component and exits. The function begins by appending a '#' character to the output and records the starting position of the reference. It then iterates through the characters in `spec`, escaping non-printable characters, directly appending printable ASCII characters, and converting UTF-8 characters as needed. Finally, it calculates and sets the length of the processed reference in `out_ref`.","The provided code processes a character specification and a reference component to create a canonicalized output. It first checks if the reference length is valid; if not, it initializes the output reference and exits. The code then appends a specific character to the output and records the starting position of the reference. It iterates through the characters in the specification, handling non-printable characters by escaping them, directly appending printable ASCII characters, and converting multi-byte characters as necessary. Finally, it calculates the length of the processed reference and updates the output reference accordingly.","The vulnerability in the original code stemmed from inadequate handling of multi-byte UTF-8 characters, which could lead to improper encoding in URL fragment identifiers. Specifically, the code did not escape these characters, potentially allowing for malformed URLs. The fix was implemented by replacing the original handling of multi-byte characters with a call to `AppendUTF8EscapedChar`, which ensures that all UTF-8 characters are properly percent-encoded. This change aligns the behavior with established standards and other browsers, thereby enhancing security and compliance with the specification.","The vulnerability in the original code was due to improper handling of multi-byte UTF-8 characters in URL fragment identifiers, which could result in malformed URLs and potential security issues. This lack of percent-encoding for such characters could lead to unexpected behavior when processing URLs. The fix addressed this issue by implementing a mechanism to ensure that all UTF-8 characters are correctly percent-encoded, thereby aligning the code's behavior with established web standards and practices used by other major browsers. This change enhances both security and compliance with the relevant specifications.","The vulnerability was fixed by replacing the original handling of multi-byte UTF-8 characters with a call to `AppendUTF8EscapedChar`. This function ensures that all UTF-8 characters are properly percent-encoded, addressing the issue of malformed URLs in fragment identifiers. The change was made within the loop that processes each character in the specification, specifically in the section that previously handled characters outside the ASCII range. By implementing this new encoding method, the code now aligns with web standards and improves security by preventing potential exploitation through improperly formatted URLs.","The vulnerability was fixed by implementing a mechanism to ensure that all multi-byte UTF-8 characters are properly percent-encoded during the processing of URL fragment identifiers. This change replaced the previous handling of such characters, which did not provide adequate encoding, potentially leading to malformed URLs. By introducing this new encoding approach, the code now correctly formats all characters according to web standards, thereby enhancing security and preventing issues related to improper URL construction. This adjustment aligns the functionality with established practices used by other major browsers, ensuring better compliance with specifications.","CWE-116,CWE-176,CWE-838,CWE-75,CWE-20,CWE-177,CWE-172,CWE-171,CWE-79,CWE-707",Y,9.0,"4, 5","4, 4","4,4","4,4"
10,10,186914,186914,,Remote,Not required,,CVE-2017-15427,https://www.cvedetails.com/cve/CVE-2017-15427/,CWE-79,Medium,,Partial,,2018-08-28,4.3,Insufficient policy enforcement in Omnibox in Google Chrome prior to 63.0.3239.84 allowed a socially engineered user to XSS themselves by dragging and dropping a javascript: URL into the URL bar.,2018-11-02,XSS ,2,https://github.com/chromium/chromium/commit/16c719e0e275d2ee5d5c69e4962b744bcaf0fe40,16c719e0e275d2ee5d5c69e4962b744bcaf0fe40,"Strip JavaScript schemas on Linux text drop

When dropping text onto the Omnibox, any leading JavaScript schemes
should be stripped to avoid a ""self-XSS"" attack. This stripping already
occurs in all cases except when plaintext is dropped on Linux. This CL
corrects that oversight.

Bug: 768910
Change-Id: I43af24ace4a13cf61d15a32eb9382dcdd498a062
Reviewed-on: https://chromium-review.googlesource.com/685638
Reviewed-by: Justin Donnelly <jdonnelly@chromium.org>
Commit-Queue: Eric Lawrence <elawrence@chromium.org>
Cr-Commit-Position: refs/heads/master@{#504695}",1,chrome/browser/ui/views/omnibox/omnibox_view_views.cc,"{""sha"": ""98a8ac9c38531ee785f98f7ce297dde52f5ad7fa"", ""filename"": ""chrome/browser/ui/views/omnibox/omnibox_view_views.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/16c719e0e275d2ee5d5c69e4962b744bcaf0fe40/chrome/browser/ui/views/omnibox/omnibox_view_views.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/16c719e0e275d2ee5d5c69e4962b744bcaf0fe40/chrome/browser/ui/views/omnibox/omnibox_view_views.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/omnibox/omnibox_view_views.cc?ref=16c719e0e275d2ee5d5c69e4962b744bcaf0fe40"", ""patch"": ""@@ -1098,7 +1098,8 @@ int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {\n   } else if (data.HasString()) {\n     base::string16 text;\n     if (data.GetString(&text)) {\n-      base::string16 collapsed_text(base::CollapseWhitespace(text, true));\n+      base::string16 collapsed_text(\n+          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));\n       if (model()->CanPasteAndGo(collapsed_text))\n         model()->PasteAndGo(collapsed_text);\n       return ui::DragDropTypes::DRAG_COPY;""}","int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
  if (HasTextBeingDragged())
    return ui::DragDropTypes::DRAG_NONE;

  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {
    GURL url;
    base::string16 title;
    if (data.GetURLAndTitle(
            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {
      base::string16 text(
          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));
      if (model()->CanPasteAndGo(text)) {
        model()->PasteAndGo(text);
        return ui::DragDropTypes::DRAG_COPY;
      }
    }
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
      base::string16 collapsed_text(
          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;
    }
  }

  return ui::DragDropTypes::DRAG_NONE;
}
","int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
  if (HasTextBeingDragged())
    return ui::DragDropTypes::DRAG_NONE;

  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {
    GURL url;
    base::string16 title;
    if (data.GetURLAndTitle(
            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {
      base::string16 text(
          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));
      if (model()->CanPasteAndGo(text)) {
        model()->PasteAndGo(text);
        return ui::DragDropTypes::DRAG_COPY;
      }
    }
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
      base::string16 collapsed_text(base::CollapseWhitespace(text, true));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;
    }
  }

  return ui::DragDropTypes::DRAG_NONE;
}
",C,"      base::string16 collapsed_text(
          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
","      base::string16 collapsed_text(base::CollapseWhitespace(text, true));
",,"@@ -1098,7 +1098,8 @@ int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
-      base::string16 collapsed_text(base::CollapseWhitespace(text, true));
+      base::string16 collapsed_text(
+          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;",Chrome,16c719e0e275d2ee5d5c69e4962b744bcaf0fe40,4a165e1b93e099fceb38de3ade51e368ce949075,1,"int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
  if (HasTextBeingDragged())
    return ui::DragDropTypes::DRAG_NONE;

  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {
    GURL url;
    base::string16 title;
    if (data.GetURLAndTitle(
            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {
      base::string16 text(
          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));
      if (model()->CanPasteAndGo(text)) {
        model()->PasteAndGo(text);
        return ui::DragDropTypes::DRAG_COPY;
      }
    }
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
//flaw_line_below:
      base::string16 collapsed_text(base::CollapseWhitespace(text, true));
//fix_flaw_line_below:
//      base::string16 collapsed_text(
//fix_flaw_line_below:
//          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;
    }
  }

  return ui::DragDropTypes::DRAG_NONE;
}
",186914,"int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
  if (HasTextBeingDragged())
    return ui::DragDropTypes::DRAG_NONE;

  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {
    GURL url;
    base::string16 title;
    if (data.GetURLAndTitle(
            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {
      base::string16 text(
          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));
      if (model()->CanPasteAndGo(text)) {
        model()->PasteAndGo(text);
        return ui::DragDropTypes::DRAG_COPY;
      }
    }
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
      base::string16 collapsed_text(base::CollapseWhitespace(text, true));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;
    }
  }

  return ui::DragDropTypes::DRAG_NONE;
}
","int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
  if (HasTextBeingDragged())
    return ui::DragDropTypes::DRAG_NONE;

  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {
    GURL url;
    base::string16 title;
    if (data.GetURLAndTitle(
            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {
      base::string16 text(
          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));
      if (model()->CanPasteAndGo(text)) {
        model()->PasteAndGo(text);
        return ui::DragDropTypes::DRAG_COPY;
      }
    }
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
      base::string16 collapsed_text(
          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;
    }
  }

  return ui::DragDropTypes::DRAG_NONE;
}
","The `OnDrop` function in the `OmniboxViewViews` class handles drag-and-drop operations for URLs and text within a user interface. It first checks if any text is currently being dragged; if so, it cancels the drop action. If the dropped data contains a URL, it retrieves the URL and its title, processes the URL to remove any JavaScript schemas, and checks if it can be pasted and navigated to. If valid, it performs the paste-and-go action. Similarly, if the data contains a string, it collapses whitespace and checks its validity before executing the paste-and-go. If neither condition is met, it returns a ""no drop"" status.","The provided code defines a function that manages the behavior of drag-and-drop actions within a user interface. It first checks if any text is being dragged; if so, it prevents the drop. If the dropped data includes a URL, the function retrieves and processes it, ensuring it is valid for navigation. If the URL is acceptable, it initiates a navigation action. The function also handles cases where a plain text string is dropped, collapsing any extra whitespace before validating and executing the navigation. If neither condition is satisfied, it indicates that the drop action is not allowed.","The vulnerability in the original code stemmed from the lack of stripping JavaScript schemas from plaintext dropped onto the Omnibox, which could lead to a ""self-XSS"" attack, allowing malicious scripts to execute in the user's context. The fixed code addresses this issue by incorporating the `StripJavascriptSchemas` function on the collapsed text obtained from the dropped string. This ensures that any leading JavaScript schemes are removed before validating and executing the paste-and-go action, thereby mitigating the risk of executing potentially harmful scripts when users drop text into the interface.","The vulnerability in the original code was due to the failure to strip leading JavaScript schemas from plaintext dropped onto the interface, which could enable a ""self-XSS"" attack, allowing malicious scripts to execute in the user's environment. The fix implemented in the updated code ensures that any dropped text is processed to remove these potentially harmful schemas before further validation and execution. This correction addresses the oversight specific to plaintext on Linux, thereby enhancing security by preventing the execution of unintended scripts when users interact with the text input feature.","The vulnerability was fixed by incorporating the `StripJavascriptSchemas` function on the collapsed text obtained from the dropped string. In the updated code, after retrieving the plaintext, the function now processes it to remove any leading JavaScript schemas before checking if it can be pasted and navigated to. This ensures that any potentially harmful scripts are stripped away, mitigating the risk of a ""self-XSS"" attack. By applying this stripping consistently, including for plaintext drops on Linux, the code enhances security and prevents the execution of malicious scripts in the user's context.","The vulnerability was fixed by ensuring that any dropped plaintext is processed to remove leading JavaScript schemas before further validation and execution. The updated code introduces a step that specifically addresses this oversight, which was previously only applied to URLs. By consistently stripping away potentially harmful scripts from the dropped text, the fix prevents the possibility of executing malicious code in the user's environment. This enhancement improves the overall security of the interface, particularly for users on Linux, by safeguarding against ""self-XSS"" attacks when interacting with the text input feature.","CWE-79, CWE-116, CWE-80, CWE-75, CWE-159, CWE-157, CWE-85, CWE-87, CWE-93, CWE-94",Y,1.0,"5, 4","5, 5","4, 4","4,4"
