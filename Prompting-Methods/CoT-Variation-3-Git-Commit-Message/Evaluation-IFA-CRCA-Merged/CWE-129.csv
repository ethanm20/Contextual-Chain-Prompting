,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,T1_Top_10_CWE_IDs,T2_Correctly_Found_CWE,T3_IFA,G1_Clarity_C3_C5,G2_Relevance_C3_C5,G3_Completeness_C3_C5,G4_Actionability_C3_C5
0,0,182331,182331,,Remote,Not required,Partial,CVE-2018-13302,https://www.cvedetails.com/cve/CVE-2018-13302/,CWE-129,Medium,Partial,Partial,,2018-07-05,6.8,"In FFmpeg 4.0.1, improper handling of frame types (other than EAC3_FRAME_TYPE_INDEPENDENT) that have multiple independent substreams in the handle_eac3 function in libavformat/movenc.c may trigger an out-of-array access while converting a crafted AVI file to MPEG4, leading to a denial of service or possibly unspecified other impact.",2019-10-02,DoS ,6,https://github.com/FFmpeg/FFmpeg/commit/ed22dc22216f74c75ee7901f82649e1ff725ba50,ed22dc22216f74c75ee7901f82649e1ff725ba50,"avformat/movenc: Check that frame_types other than EAC3_FRAME_TYPE_INDEPENDENT have a supported substream id

Fixes: out of array access
Fixes: ffmpeg_bof_1.avi

Found-by: Thuan Pham, Marcel BÃ¶hme, Andrew Santosa and Alexandru Razvan Caciulescu with AFLSmart
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",0,libavformat/movenc.c,"{""sha"": ""6eabf32fce319dadf84346a4d92dbc2b207a594e"", ""filename"": ""libavformat/movenc.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/FFmpeg/FFmpeg/blob/ed22dc22216f74c75ee7901f82649e1ff725ba50/libavformat/movenc.c"", ""raw_url"": ""https://github.com/FFmpeg/FFmpeg/raw/ed22dc22216f74c75ee7901f82649e1ff725ba50/libavformat/movenc.c"", ""contents_url"": ""https://api.github.com/repos/FFmpeg/FFmpeg/contents/libavformat/movenc.c?ref=ed22dc22216f74c75ee7901f82649e1ff725ba50"", ""patch"": ""@@ -437,6 +437,12 @@ static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)\n                 info->ec3_done = 1;\n                 goto concatenate;\n             }\n+        } else {\n+            if (hdr->substreamid != 0) {\n+                avpriv_request_sample(mov->fc, \""Multiple non EAC3 independent substreams\"");\n+                ret = AVERROR_PATCHWELCOME;\n+                goto end;\n+            }\n         }\n \n         /* fill the info needed for the \""dec3\"" atom */""}","static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)
{
    AC3HeaderInfo *hdr = NULL;
    struct eac3_info *info;
    int num_blocks, ret;

    if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))
        return AVERROR(ENOMEM);
    info = track->eac3_priv;

    if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {
        /* drop the packets until we see a good one */
        if (!track->entry) {
            av_log(mov, AV_LOG_WARNING, ""Dropping invalid packet from start of the stream\n"");
            ret = 0;
        } else
            ret = AVERROR_INVALIDDATA;
        goto end;
    }

    info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);
    num_blocks = hdr->num_blocks;

    if (!info->ec3_done) {
        /* AC-3 substream must be the first one */
        if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {
            ret = AVERROR(EINVAL);
            goto end;
        }

        /* this should always be the case, given that our AC-3 parser
         * concatenates dependent frames to their independent parent */
        if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {
            /* substream ids must be incremental */
            if (hdr->substreamid > info->num_ind_sub + 1) {
                ret = AVERROR(EINVAL);
                goto end;
            }

            if (hdr->substreamid == info->num_ind_sub + 1) {
                avpriv_request_sample(track->par, ""Multiple independent substreams"");
                ret = AVERROR_PATCHWELCOME;
                goto end;
            } else if (hdr->substreamid < info->num_ind_sub ||
                       hdr->substreamid == 0 && info->substream[0].bsid) {
                 info->ec3_done = 1;
                 goto concatenate;
             }
        } else {
            if (hdr->substreamid != 0) {
                avpriv_request_sample(mov->fc, ""Multiple non EAC3 independent substreams"");
                ret = AVERROR_PATCHWELCOME;
                goto end;
            }
         }
 
         /* fill the info needed for the ""dec3"" atom */
        info->substream[hdr->substreamid].fscod = hdr->sr_code;
        info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;
        info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;
        info->substream[hdr->substreamid].acmod = hdr->channel_mode;
        info->substream[hdr->substreamid].lfeon = hdr->lfe_on;

        /* Parse dependent substream(s), if any */
        if (pkt->size != hdr->frame_size) {
            int cumul_size = hdr->frame_size;
            int parent = hdr->substreamid;

            while (cumul_size != pkt->size) {
                GetBitContext gbc;
                int i;
                ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);
                if (ret < 0)
                    goto end;
                if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {
                    ret = AVERROR(EINVAL);
                    goto end;
                }
                info->substream[parent].num_dep_sub++;
                ret /= 8;

                /* header is parsed up to lfeon, but custom channel map may be needed */
                init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);
                /* skip bsid */
                skip_bits(&gbc, 5);
                /* skip volume control params */
                for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {
                    skip_bits(&gbc, 5); // skip dialog normalization
                    if (get_bits1(&gbc)) {
                        skip_bits(&gbc, 8); // skip compression gain word
                    }
                }
                /* get the dependent stream channel map, if exists */
                if (get_bits1(&gbc))
                    info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;
                else
                    info->substream[parent].chan_loc |= hdr->channel_mode;
                cumul_size += hdr->frame_size;
            }
        }
    }

concatenate:
    if (!info->num_blocks && num_blocks == 6) {
        ret = pkt->size;
        goto end;
    }
    else if (info->num_blocks + num_blocks > 6) {
        ret = AVERROR_INVALIDDATA;
        goto end;
    }

    if (!info->num_blocks) {
        ret = av_packet_ref(&info->pkt, pkt);
        if (!ret)
            info->num_blocks = num_blocks;
        goto end;
    } else {
        if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)
            goto end;
        memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);
        info->num_blocks += num_blocks;
        info->pkt.duration += pkt->duration;
        if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)
            goto end;
        if (info->num_blocks != 6)
            goto end;
        av_packet_unref(pkt);
        av_packet_move_ref(pkt, &info->pkt);
        info->num_blocks = 0;
    }
    ret = pkt->size;

end:
    av_free(hdr);

    return ret;
}
","static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)
{
    AC3HeaderInfo *hdr = NULL;
    struct eac3_info *info;
    int num_blocks, ret;

    if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))
        return AVERROR(ENOMEM);
    info = track->eac3_priv;

    if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {
        /* drop the packets until we see a good one */
        if (!track->entry) {
            av_log(mov, AV_LOG_WARNING, ""Dropping invalid packet from start of the stream\n"");
            ret = 0;
        } else
            ret = AVERROR_INVALIDDATA;
        goto end;
    }

    info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);
    num_blocks = hdr->num_blocks;

    if (!info->ec3_done) {
        /* AC-3 substream must be the first one */
        if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {
            ret = AVERROR(EINVAL);
            goto end;
        }

        /* this should always be the case, given that our AC-3 parser
         * concatenates dependent frames to their independent parent */
        if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {
            /* substream ids must be incremental */
            if (hdr->substreamid > info->num_ind_sub + 1) {
                ret = AVERROR(EINVAL);
                goto end;
            }

            if (hdr->substreamid == info->num_ind_sub + 1) {
                avpriv_request_sample(track->par, ""Multiple independent substreams"");
                ret = AVERROR_PATCHWELCOME;
                goto end;
            } else if (hdr->substreamid < info->num_ind_sub ||
                       hdr->substreamid == 0 && info->substream[0].bsid) {
                 info->ec3_done = 1;
                 goto concatenate;
             }
         }
 
         /* fill the info needed for the ""dec3"" atom */
        info->substream[hdr->substreamid].fscod = hdr->sr_code;
        info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;
        info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;
        info->substream[hdr->substreamid].acmod = hdr->channel_mode;
        info->substream[hdr->substreamid].lfeon = hdr->lfe_on;

        /* Parse dependent substream(s), if any */
        if (pkt->size != hdr->frame_size) {
            int cumul_size = hdr->frame_size;
            int parent = hdr->substreamid;

            while (cumul_size != pkt->size) {
                GetBitContext gbc;
                int i;
                ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);
                if (ret < 0)
                    goto end;
                if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {
                    ret = AVERROR(EINVAL);
                    goto end;
                }
                info->substream[parent].num_dep_sub++;
                ret /= 8;

                /* header is parsed up to lfeon, but custom channel map may be needed */
                init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);
                /* skip bsid */
                skip_bits(&gbc, 5);
                /* skip volume control params */
                for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {
                    skip_bits(&gbc, 5); // skip dialog normalization
                    if (get_bits1(&gbc)) {
                        skip_bits(&gbc, 8); // skip compression gain word
                    }
                }
                /* get the dependent stream channel map, if exists */
                if (get_bits1(&gbc))
                    info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;
                else
                    info->substream[parent].chan_loc |= hdr->channel_mode;
                cumul_size += hdr->frame_size;
            }
        }
    }

concatenate:
    if (!info->num_blocks && num_blocks == 6) {
        ret = pkt->size;
        goto end;
    }
    else if (info->num_blocks + num_blocks > 6) {
        ret = AVERROR_INVALIDDATA;
        goto end;
    }

    if (!info->num_blocks) {
        ret = av_packet_ref(&info->pkt, pkt);
        if (!ret)
            info->num_blocks = num_blocks;
        goto end;
    } else {
        if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)
            goto end;
        memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);
        info->num_blocks += num_blocks;
        info->pkt.duration += pkt->duration;
        if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)
            goto end;
        if (info->num_blocks != 6)
            goto end;
        av_packet_unref(pkt);
        av_packet_move_ref(pkt, &info->pkt);
        info->num_blocks = 0;
    }
    ret = pkt->size;

end:
    av_free(hdr);

    return ret;
}
",C,"        } else {
            if (hdr->substreamid != 0) {
                avpriv_request_sample(mov->fc, ""Multiple non EAC3 independent substreams"");
                ret = AVERROR_PATCHWELCOME;
                goto end;
            }
",,,"@@ -437,6 +437,12 @@ static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)
                 info->ec3_done = 1;
                 goto concatenate;
             }
+        } else {
+            if (hdr->substreamid != 0) {
+                avpriv_request_sample(mov->fc, ""Multiple non EAC3 independent substreams"");
+                ret = AVERROR_PATCHWELCOME;
+                goto end;
+            }
         }
 
         /* fill the info needed for the ""dec3"" atom */",FFmpeg,ed22dc22216f74c75ee7901f82649e1ff725ba50,75a2db552423295b509546f3b0f8b2b46d3424b1,1,"static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)
{
    AC3HeaderInfo *hdr = NULL;
    struct eac3_info *info;
    int num_blocks, ret;

    if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))
        return AVERROR(ENOMEM);
    info = track->eac3_priv;

    if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {
        /* drop the packets until we see a good one */
        if (!track->entry) {
            av_log(mov, AV_LOG_WARNING, ""Dropping invalid packet from start of the stream\n"");
            ret = 0;
        } else
            ret = AVERROR_INVALIDDATA;
        goto end;
    }

    info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);
    num_blocks = hdr->num_blocks;

    if (!info->ec3_done) {
        /* AC-3 substream must be the first one */
        if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {
            ret = AVERROR(EINVAL);
            goto end;
        }

        /* this should always be the case, given that our AC-3 parser
         * concatenates dependent frames to their independent parent */
        if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {
            /* substream ids must be incremental */
            if (hdr->substreamid > info->num_ind_sub + 1) {
                ret = AVERROR(EINVAL);
                goto end;
            }

            if (hdr->substreamid == info->num_ind_sub + 1) {
                //info->num_ind_sub++;
                avpriv_request_sample(track->par, ""Multiple independent substreams"");
                ret = AVERROR_PATCHWELCOME;
                goto end;
            } else if (hdr->substreamid < info->num_ind_sub ||
                       hdr->substreamid == 0 && info->substream[0].bsid) {
                 info->ec3_done = 1;
                 goto concatenate;
             }
//fix_flaw_line_below:
//        } else {
//fix_flaw_line_below:
//            if (hdr->substreamid != 0) {
//fix_flaw_line_below:
//                avpriv_request_sample(mov->fc, ""Multiple non EAC3 independent substreams"");
//fix_flaw_line_below:
//                ret = AVERROR_PATCHWELCOME;
//fix_flaw_line_below:
//                goto end;
//fix_flaw_line_below:
//            }
         }
 
         /* fill the info needed for the ""dec3"" atom */
        info->substream[hdr->substreamid].fscod = hdr->sr_code;
        info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;
        info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;
        info->substream[hdr->substreamid].acmod = hdr->channel_mode;
        info->substream[hdr->substreamid].lfeon = hdr->lfe_on;

        /* Parse dependent substream(s), if any */
        if (pkt->size != hdr->frame_size) {
            int cumul_size = hdr->frame_size;
            int parent = hdr->substreamid;

            while (cumul_size != pkt->size) {
                GetBitContext gbc;
                int i;
                ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);
                if (ret < 0)
                    goto end;
                if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {
                    ret = AVERROR(EINVAL);
                    goto end;
                }
                info->substream[parent].num_dep_sub++;
                ret /= 8;

                /* header is parsed up to lfeon, but custom channel map may be needed */
                init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);
                /* skip bsid */
                skip_bits(&gbc, 5);
                /* skip volume control params */
                for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {
                    skip_bits(&gbc, 5); // skip dialog normalization
                    if (get_bits1(&gbc)) {
                        skip_bits(&gbc, 8); // skip compression gain word
                    }
                }
                /* get the dependent stream channel map, if exists */
                if (get_bits1(&gbc))
                    info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;
                else
                    info->substream[parent].chan_loc |= hdr->channel_mode;
                cumul_size += hdr->frame_size;
            }
        }
    }

concatenate:
    if (!info->num_blocks && num_blocks == 6) {
        ret = pkt->size;
        goto end;
    }
    else if (info->num_blocks + num_blocks > 6) {
        ret = AVERROR_INVALIDDATA;
        goto end;
    }

    if (!info->num_blocks) {
        ret = av_packet_ref(&info->pkt, pkt);
        if (!ret)
            info->num_blocks = num_blocks;
        goto end;
    } else {
        if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)
            goto end;
        memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);
        info->num_blocks += num_blocks;
        info->pkt.duration += pkt->duration;
        if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)
            goto end;
        if (info->num_blocks != 6)
            goto end;
        av_packet_unref(pkt);
        av_packet_move_ref(pkt, &info->pkt);
        info->num_blocks = 0;
    }
    ret = pkt->size;

end:
    av_free(hdr);

    return ret;
}
",182331,"static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)
{
    AC3HeaderInfo *hdr = NULL;
    struct eac3_info *info;
    int num_blocks, ret;

    if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))
        return AVERROR(ENOMEM);
    info = track->eac3_priv;

    if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {
        /* drop the packets until we see a good one */
        if (!track->entry) {
            av_log(mov, AV_LOG_WARNING, ""Dropping invalid packet from start of the stream\n"");
            ret = 0;
        } else
            ret = AVERROR_INVALIDDATA;
        goto end;
    }

    info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);
    num_blocks = hdr->num_blocks;

    if (!info->ec3_done) {
        /* AC-3 substream must be the first one */
        if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {
            ret = AVERROR(EINVAL);
            goto end;
        }

        /* this should always be the case, given that our AC-3 parser
         * concatenates dependent frames to their independent parent */
        if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {
            /* substream ids must be incremental */
            if (hdr->substreamid > info->num_ind_sub + 1) {
                ret = AVERROR(EINVAL);
                goto end;
            }

            if (hdr->substreamid == info->num_ind_sub + 1) {
                //info->num_ind_sub++;
                avpriv_request_sample(track->par, ""Multiple independent substreams"");
                ret = AVERROR_PATCHWELCOME;
                goto end;
            } else if (hdr->substreamid < info->num_ind_sub ||
                       hdr->substreamid == 0 && info->substream[0].bsid) {
                info->ec3_done = 1;
                goto concatenate;
            }
        }

        /* fill the info needed for the ""dec3"" atom */
        info->substream[hdr->substreamid].fscod = hdr->sr_code;
        info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;
        info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;
        info->substream[hdr->substreamid].acmod = hdr->channel_mode;
        info->substream[hdr->substreamid].lfeon = hdr->lfe_on;

        /* Parse dependent substream(s), if any */
        if (pkt->size != hdr->frame_size) {
            int cumul_size = hdr->frame_size;
            int parent = hdr->substreamid;

            while (cumul_size != pkt->size) {
                GetBitContext gbc;
                int i;
                ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);
                if (ret < 0)
                    goto end;
                if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {
                    ret = AVERROR(EINVAL);
                    goto end;
                }
                info->substream[parent].num_dep_sub++;
                ret /= 8;

                /* header is parsed up to lfeon, but custom channel map may be needed */
                init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);
                /* skip bsid */
                skip_bits(&gbc, 5);
                /* skip volume control params */
                for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {
                    skip_bits(&gbc, 5); // skip dialog normalization
                    if (get_bits1(&gbc)) {
                        skip_bits(&gbc, 8); // skip compression gain word
                    }
                }
                /* get the dependent stream channel map, if exists */
                if (get_bits1(&gbc))
                    info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;
                else
                    info->substream[parent].chan_loc |= hdr->channel_mode;
                cumul_size += hdr->frame_size;
            }
        }
    }

concatenate:
    if (!info->num_blocks && num_blocks == 6) {
        ret = pkt->size;
        goto end;
    }
    else if (info->num_blocks + num_blocks > 6) {
        ret = AVERROR_INVALIDDATA;
        goto end;
    }

    if (!info->num_blocks) {
        ret = av_packet_ref(&info->pkt, pkt);
        if (!ret)
            info->num_blocks = num_blocks;
        goto end;
    } else {
        if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)
            goto end;
        memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);
        info->num_blocks += num_blocks;
        info->pkt.duration += pkt->duration;
        if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)
            goto end;
        if (info->num_blocks != 6)
            goto end;
        av_packet_unref(pkt);
        av_packet_move_ref(pkt, &info->pkt);
        info->num_blocks = 0;
    }
    ret = pkt->size;

end:
    av_free(hdr);

    return ret;
}","static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)
{
    AC3HeaderInfo *hdr = NULL;
    struct eac3_info *info;
    int num_blocks, ret;

    if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))
        return AVERROR(ENOMEM);
    info = track->eac3_priv;

    if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {
        /* drop the packets until we see a good one */
        if (!track->entry) {
            av_log(mov, AV_LOG_WARNING, ""Dropping invalid packet from start of the stream\n"");
            ret = 0;
        } else
            ret = AVERROR_INVALIDDATA;
        goto end;
    }

    info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);
    num_blocks = hdr->num_blocks;

    if (!info->ec3_done) {
        /* AC-3 substream must be the first one */
        if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {
            ret = AVERROR(EINVAL);
            goto end;
        }

        /* this should always be the case, given that our AC-3 parser
         * concatenates dependent frames to their independent parent */
        if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {
            /* substream ids must be incremental */
            if (hdr->substreamid > info->num_ind_sub + 1) {
                ret = AVERROR(EINVAL);
                goto end;
            }

            if (hdr->substreamid == info->num_ind_sub + 1) {
                avpriv_request_sample(track->par, ""Multiple independent substreams"");
                ret = AVERROR_PATCHWELCOME;
                goto end;
            } else if (hdr->substreamid < info->num_ind_sub ||
                       hdr->substreamid == 0 && info->substream[0].bsid) {
                 info->ec3_done = 1;
                 goto concatenate;
             }
        } else {
            if (hdr->substreamid != 0) {
                avpriv_request_sample(mov->fc, ""Multiple non EAC3 independent substreams"");
                ret = AVERROR_PATCHWELCOME;
                goto end;
            }
         }
 
         /* fill the info needed for the ""dec3"" atom */
        info->substream[hdr->substreamid].fscod = hdr->sr_code;
        info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;
        info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;
        info->substream[hdr->substreamid].acmod = hdr->channel_mode;
        info->substream[hdr->substreamid].lfeon = hdr->lfe_on;

        /* Parse dependent substream(s), if any */
        if (pkt->size != hdr->frame_size) {
            int cumul_size = hdr->frame_size;
            int parent = hdr->substreamid;

            while (cumul_size != pkt->size) {
                GetBitContext gbc;
                int i;
                ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);
                if (ret < 0)
                    goto end;
                if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {
                    ret = AVERROR(EINVAL);
                    goto end;
                }
                info->substream[parent].num_dep_sub++;
                ret /= 8;

                /* header is parsed up to lfeon, but custom channel map may be needed */
                init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);
                /* skip bsid */
                skip_bits(&gbc, 5);
                /* skip volume control params */
                for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {
                    skip_bits(&gbc, 5); // skip dialog normalization
                    if (get_bits1(&gbc)) {
                        skip_bits(&gbc, 8); // skip compression gain word
                    }
                }
                /* get the dependent stream channel map, if exists */
                if (get_bits1(&gbc))
                    info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;
                else
                    info->substream[parent].chan_loc |= hdr->channel_mode;
                cumul_size += hdr->frame_size;
            }
        }
    }

concatenate:
    if (!info->num_blocks && num_blocks == 6) {
        ret = pkt->size;
        goto end;
    }
    else if (info->num_blocks + num_blocks > 6) {
        ret = AVERROR_INVALIDDATA;
        goto end;
    }

    if (!info->num_blocks) {
        ret = av_packet_ref(&info->pkt, pkt);
        if (!ret)
            info->num_blocks = num_blocks;
        goto end;
    } else {
        if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)
            goto end;
        memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);
        info->num_blocks += num_blocks;
        info->pkt.duration += pkt->duration;
        if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)
            goto end;
        if (info->num_blocks != 6)
            goto end;
        av_packet_unref(pkt);
        av_packet_move_ref(pkt, &info->pkt);
        info->num_blocks = 0;
    }
    ret = pkt->size;

end:
    av_free(hdr);

    return ret;
}
","The `handle_eac3` function processes E-AC-3 audio packets within a multimedia context, managing the parsing and handling of audio stream headers and data. It initializes necessary structures for E-AC-3 information, validates packet headers, and ensures that independent and dependent substreams are correctly identified and processed. The function checks for valid data rates, substream IDs, and frame types, while also managing the concatenation of audio data across packets. It updates the packet's metadata, including duration and side data, and handles errors gracefully, returning appropriate error codes when invalid data is encountered.","The code processes audio packets in a multimedia context, specifically focusing on E-AC-3 audio streams. It initializes necessary structures for managing audio stream information and validates incoming packet headers to ensure they conform to expected formats. The functionality includes handling both independent and dependent audio substreams, updating metadata such as data rates and channel configurations, and managing the concatenation of audio data across multiple packets. Additionally, it gracefully handles errors by returning appropriate codes when invalid data is detected, ensuring robust processing of audio streams.","The vulnerability in the original code stemmed from insufficient validation of substream IDs for frame types other than independent, which could lead to out-of-bounds access in the substream array. Specifically, if a non-independent frame type was encountered with an unsupported substream ID, the code did not handle this case properly, risking memory corruption. The fix introduced a check to ensure that if the frame type is not independent, the substream ID must be zero, thereby preventing invalid accesses to the substream array. This additional validation ensures that only valid substream IDs are processed, enhancing the code's robustness against potential buffer overflows.","The vulnerability in the original code was due to inadequate validation of substream IDs associated with non-independent frame types, which could lead to out-of-bounds access in the substream array. This oversight posed a risk of memory corruption when invalid substream IDs were processed. The fix implemented a check to ensure that only valid substream IDs are accepted for frame types that are not independent, specifically requiring that such IDs be zero. This additional validation effectively prevents any out-of-bounds access, thereby enhancing the overall stability and security of the code.","The vulnerability was fixed by adding a validation check for substream IDs when the frame type is not independent. Specifically, the code now verifies that if the frame type is not equal to the expected independent type, the substream ID must be zero. This is implemented in the conditional statement that checks the frame type and substream ID, ensuring that any unsupported substream IDs trigger an error response. By enforcing this rule, the code prevents out-of-bounds access to the substream array, thereby mitigating the risk of memory corruption and enhancing the overall robustness of the audio processing logic.","The vulnerability was addressed by implementing a validation mechanism that checks the substream IDs associated with non-independent frame types. The fix ensures that if a frame type is not classified as independent, the corresponding substream ID must be zero. This additional check prevents the processing of invalid substream IDs, which could lead to out-of-bounds access in the underlying data structures. By enforcing this rule, the code effectively mitigates the risk of memory corruption and enhances the overall stability and security of the audio processing functionality.","CWE-119, CWE-125, CWE-126, CWE-789, CWE-822, CWE-824, CWE-129, CWE-20, CWE-131, CWE-787",N,-1.0,"5, 5","5,5","4,4","4,4"
1,1,182895,182895,,Local,Not required,Partial,CVE-2019-9162,https://www.cvedetails.com/cve/CVE-2019-9162/,CWE-129,Low,Partial,Partial,,2019-02-25,4.6,"In the Linux kernel before 4.20.12, net/ipv4/netfilter/nf_nat_snmp_basic_main.c in the SNMP NAT module has insufficient ASN.1 length checks (aka an array index error), making out-of-bounds read and write operations possible, leading to an OOPS or local privilege escalation. This affects snmp_version and snmp_helper.",2019-06-14,,4,https://github.com/torvalds/linux/commit/c4c07b4d6fa1f11880eab8e076d3d060ef3f55fc,c4c07b4d6fa1f11880eab8e076d3d060ef3f55fc,"netfilter: nf_nat_snmp_basic: add missing length checks in ASN.1 cbs

The generic ASN.1 decoder infrastructure doesn't guarantee that callbacks
will get as much data as they expect; callbacks have to check the `datalen`
parameter before looking at `data`. Make sure that snmp_version() and
snmp_helper() don't read/write beyond the end of the packet data.

(Also move the assignment to `pdata` down below the check to make it clear
that it isn't necessarily a pointer we can use before the `datalen` check.)

Fixes: cc2d58634e0f (""netfilter: nf_nat_snmp_basic: use asn1 decoder library"")
Signed-off-by: Jann Horn <jannh@google.com>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",1,net/ipv4/netfilter/nf_nat_snmp_basic_main.c,"{""sha"": ""0a8a60c1bf9af107ff88ea57569a687df666d5af"", ""filename"": ""net/ipv4/netfilter/nf_nat_snmp_basic_main.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/c4c07b4d6fa1f11880eab8e076d3d060ef3f55fc/net/ipv4/netfilter/nf_nat_snmp_basic_main.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c4c07b4d6fa1f11880eab8e076d3d060ef3f55fc/net/ipv4/netfilter/nf_nat_snmp_basic_main.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/netfilter/nf_nat_snmp_basic_main.c?ref=c4c07b4d6fa1f11880eab8e076d3d060ef3f55fc"", ""patch"": ""@@ -105,6 +105,8 @@ static void fast_csum(struct snmp_ctx *ctx, unsigned char offset)\n int snmp_version(void *context, size_t hdrlen, unsigned char tag,\n \t\t const void *data, size_t datalen)\n {\n+\tif (datalen != 1)\n+\t\treturn -EINVAL;\n \tif (*(unsigned char *)data > 1)\n \t\treturn -ENOTSUPP;\n \treturn 1;\n@@ -114,8 +116,11 @@ int snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n \t\tconst void *data, size_t datalen)\n {\n \tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n-\t__be32 *pdata = (__be32 *)data;\n+\t__be32 *pdata;\n \n+\tif (datalen != 4)\n+\t\treturn -EINVAL;\n+\tpdata = (__be32 *)data;\n \tif (*pdata == ctx->from) {\n \t\tpr_debug(\""%s: %pI4 to %pI4\\n\"", __func__,\n \t\t\t (void *)&ctx->from, (void *)&ctx->to);""}","int snmp_helper(void *context, size_t hdrlen, unsigned char tag,
 		const void *data, size_t datalen)
 {
 	struct snmp_ctx *ctx = (struct snmp_ctx *)context;
	__be32 *pdata;
 
	if (datalen != 4)
		return -EINVAL;
	pdata = (__be32 *)data;
 	if (*pdata == ctx->from) {
 		pr_debug(""%s: %pI4 to %pI4\n"", __func__,
 			 (void *)&ctx->from, (void *)&ctx->to);

		if (*ctx->check)
			fast_csum(ctx, (unsigned char *)data - ctx->begin);
		*pdata = ctx->to;
	}

	return 1;
}
","int snmp_helper(void *context, size_t hdrlen, unsigned char tag,
 		const void *data, size_t datalen)
 {
 	struct snmp_ctx *ctx = (struct snmp_ctx *)context;
	__be32 *pdata = (__be32 *)data;
 
 	if (*pdata == ctx->from) {
 		pr_debug(""%s: %pI4 to %pI4\n"", __func__,
 			 (void *)&ctx->from, (void *)&ctx->to);

		if (*ctx->check)
			fast_csum(ctx, (unsigned char *)data - ctx->begin);
		*pdata = ctx->to;
	}

	return 1;
}
",C,"	__be32 *pdata;
	if (datalen != 4)
		return -EINVAL;
	pdata = (__be32 *)data;
","	__be32 *pdata = (__be32 *)data;
",,"@@ -105,6 +105,8 @@ static void fast_csum(struct snmp_ctx *ctx, unsigned char offset)
 int snmp_version(void *context, size_t hdrlen, unsigned char tag,
 		 const void *data, size_t datalen)
 {
+	if (datalen != 1)
+		return -EINVAL;
 	if (*(unsigned char *)data > 1)
 		return -ENOTSUPP;
 	return 1;
@@ -114,8 +116,11 @@ int snmp_helper(void *context, size_t hdrlen, unsigned char tag,
 		const void *data, size_t datalen)
 {
 	struct snmp_ctx *ctx = (struct snmp_ctx *)context;
-	__be32 *pdata = (__be32 *)data;
+	__be32 *pdata;
 
+	if (datalen != 4)
+		return -EINVAL;
+	pdata = (__be32 *)data;
 	if (*pdata == ctx->from) {
 		pr_debug(""%s: %pI4 to %pI4\n"", __func__,
 			 (void *)&ctx->from, (void *)&ctx->to);",linux,c4c07b4d6fa1f11880eab8e076d3d060ef3f55fc,31b58ad0c3279817cd246eab27eaf53b626dfcde,1,"int snmp_helper(void *context, size_t hdrlen, unsigned char tag,
 		const void *data, size_t datalen)
 {
 	struct snmp_ctx *ctx = (struct snmp_ctx *)context;
//flaw_line_below:
	__be32 *pdata = (__be32 *)data;
//fix_flaw_line_below:
//	__be32 *pdata;
 
//fix_flaw_line_below:
//	if (datalen != 4)
//fix_flaw_line_below:
//		return -EINVAL;
//fix_flaw_line_below:
//	pdata = (__be32 *)data;
 	if (*pdata == ctx->from) {
 		pr_debug(""%s: %pI4 to %pI4\n"", __func__,
 			 (void *)&ctx->from, (void *)&ctx->to);

		if (*ctx->check)
			fast_csum(ctx, (unsigned char *)data - ctx->begin);
		*pdata = ctx->to;
	}

	return 1;
}
",182895,"int snmp_helper(void *context, size_t hdrlen, unsigned char tag,
 		const void *data, size_t datalen)
 {
 	struct snmp_ctx *ctx = (struct snmp_ctx *)context;
	__be32 *pdata = (__be32 *)data;
 
 	if (*pdata == ctx->from) {
 		pr_debug(""%s: %pI4 to %pI4\n"", __func__,
 			 (void *)&ctx->from, (void *)&ctx->to);

		if (*ctx->check)
			fast_csum(ctx, (unsigned char *)data - ctx->begin);
		*pdata = ctx->to;
	}

	return 1;
}
","int snmp_helper(void *context, size_t hdrlen, unsigned char tag,
 		const void *data, size_t datalen)
 {
 	struct snmp_ctx *ctx = (struct snmp_ctx *)context;
	__be32 *pdata;
 
	if (datalen != 4)
		return -EINVAL;
	pdata = (__be32 *)data;
 	if (*pdata == ctx->from) {
 		pr_debug(""%s: %pI4 to %pI4\n"", __func__,
 			 (void *)&ctx->from, (void *)&ctx->to);

		if (*ctx->check)
			fast_csum(ctx, (unsigned char *)data - ctx->begin);
		*pdata = ctx->to;
	}

	return 1;
}
","The `snmp_helper` function processes SNMP (Simple Network Management Protocol) messages by checking if the source address of the incoming data matches a predefined context address. It takes a context pointer, header length, a tag, and data with its length as parameters. If the source address (`*pdata`) equals the context's `from` address, it logs the source and destination addresses for debugging purposes. If a specific check condition is met, it performs a checksum operation on the data. Finally, it updates the source address to the context's `to` address and returns 1, indicating successful processing.","The provided code defines a function that processes network messages by verifying if the source address of the incoming data matches a specified address in the context. If there is a match, it logs the source and destination addresses for debugging purposes. Additionally, if a certain condition is satisfied, it performs a checksum operation on the data to ensure its integrity. After these checks and operations, the function updates the source address to a new specified address and returns a success indicator, signifying that the message has been processed correctly.","The vulnerability in the original code arises from the lack of a check on the `datalen` parameter before dereferencing the `data` pointer, which could lead to reading or writing beyond the allocated memory if the data length is less than expected. This could result in undefined behavior or memory corruption. The fixed code addresses this issue by adding a condition to verify that `datalen` equals 4 before proceeding with the pointer assignment to `pdata`. This ensures that the function only processes valid data, preventing potential buffer overflows and enhancing overall security.","The vulnerability in the original code stems from the absence of a check on the length of the incoming data before accessing it, which could lead to reading or writing outside the bounds of allocated memory. This oversight could result in undefined behavior, including potential crashes or security exploits. The fixed code resolves this issue by introducing a validation step to ensure that the length of the data matches the expected size before any operations are performed. Additionally, the assignment of the data pointer is moved to occur only after this check, clarifying that the pointer is only valid if the length condition is satisfied.","The vulnerability was fixed by adding a check for the `datalen` parameter to ensure it equals 4 before proceeding with any operations on the `data` pointer. This check prevents the function from accessing memory that is not allocated, thereby avoiding potential buffer overflows or undefined behavior. The assignment of the `pdata` pointer was also moved below this length check, making it clear that the pointer is only valid if the length condition is satisfied. This change enhances the robustness of the function by ensuring that it only processes valid data, thereby improving overall security.","The vulnerability was fixed by introducing a validation step to check the length of the incoming data before any operations are performed. This ensures that the function only processes data of the expected size, preventing access to memory that may not be allocated or valid. Additionally, the assignment of the data pointer was repositioned to occur after this length check, clarifying that the pointer is only utilized when the length condition is met. These changes collectively enhance the function's safety by safeguarding against potential buffer overflows and ensuring that only valid data is handled.","CWE-119, CWE-120, CWE-131, CWE-789, CWE-788, CWE-125, CWE-170, CWE-823, CWE-121, CWE-122",N,-1.0,"5,4","5,5","4,4","4, 4"
2,2,182896,182896,,Local,Not required,Partial,CVE-2019-9162,https://www.cvedetails.com/cve/CVE-2019-9162/,CWE-129,Low,Partial,Partial,,2019-02-25,4.6,"In the Linux kernel before 4.20.12, net/ipv4/netfilter/nf_nat_snmp_basic_main.c in the SNMP NAT module has insufficient ASN.1 length checks (aka an array index error), making out-of-bounds read and write operations possible, leading to an OOPS or local privilege escalation. This affects snmp_version and snmp_helper.",2019-06-14,,2,https://github.com/torvalds/linux/commit/c4c07b4d6fa1f11880eab8e076d3d060ef3f55fc,c4c07b4d6fa1f11880eab8e076d3d060ef3f55fc,"netfilter: nf_nat_snmp_basic: add missing length checks in ASN.1 cbs

The generic ASN.1 decoder infrastructure doesn't guarantee that callbacks
will get as much data as they expect; callbacks have to check the `datalen`
parameter before looking at `data`. Make sure that snmp_version() and
snmp_helper() don't read/write beyond the end of the packet data.

(Also move the assignment to `pdata` down below the check to make it clear
that it isn't necessarily a pointer we can use before the `datalen` check.)

Fixes: cc2d58634e0f (""netfilter: nf_nat_snmp_basic: use asn1 decoder library"")
Signed-off-by: Jann Horn <jannh@google.com>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",0,net/ipv4/netfilter/nf_nat_snmp_basic_main.c,"{""sha"": ""0a8a60c1bf9af107ff88ea57569a687df666d5af"", ""filename"": ""net/ipv4/netfilter/nf_nat_snmp_basic_main.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/c4c07b4d6fa1f11880eab8e076d3d060ef3f55fc/net/ipv4/netfilter/nf_nat_snmp_basic_main.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c4c07b4d6fa1f11880eab8e076d3d060ef3f55fc/net/ipv4/netfilter/nf_nat_snmp_basic_main.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/netfilter/nf_nat_snmp_basic_main.c?ref=c4c07b4d6fa1f11880eab8e076d3d060ef3f55fc"", ""patch"": ""@@ -105,6 +105,8 @@ static void fast_csum(struct snmp_ctx *ctx, unsigned char offset)\n int snmp_version(void *context, size_t hdrlen, unsigned char tag,\n \t\t const void *data, size_t datalen)\n {\n+\tif (datalen != 1)\n+\t\treturn -EINVAL;\n \tif (*(unsigned char *)data > 1)\n \t\treturn -ENOTSUPP;\n \treturn 1;\n@@ -114,8 +116,11 @@ int snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n \t\tconst void *data, size_t datalen)\n {\n \tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n-\t__be32 *pdata = (__be32 *)data;\n+\t__be32 *pdata;\n \n+\tif (datalen != 4)\n+\t\treturn -EINVAL;\n+\tpdata = (__be32 *)data;\n \tif (*pdata == ctx->from) {\n \t\tpr_debug(\""%s: %pI4 to %pI4\\n\"", __func__,\n \t\t\t (void *)&ctx->from, (void *)&ctx->to);""}"," int snmp_version(void *context, size_t hdrlen, unsigned char tag,
 		 const void *data, size_t datalen)
 {
	if (datalen != 1)
		return -EINVAL;
 	if (*(unsigned char *)data > 1)
 		return -ENOTSUPP;
 	return 1;
}
"," int snmp_version(void *context, size_t hdrlen, unsigned char tag,
 		 const void *data, size_t datalen)
 {
 	if (*(unsigned char *)data > 1)
 		return -ENOTSUPP;
 	return 1;
}
",C,"	if (datalen != 1)
		return -EINVAL;
",,,"@@ -105,6 +105,8 @@ static void fast_csum(struct snmp_ctx *ctx, unsigned char offset)
 int snmp_version(void *context, size_t hdrlen, unsigned char tag,
 		 const void *data, size_t datalen)
 {
+	if (datalen != 1)
+		return -EINVAL;
 	if (*(unsigned char *)data > 1)
 		return -ENOTSUPP;
 	return 1;
@@ -114,8 +116,11 @@ int snmp_helper(void *context, size_t hdrlen, unsigned char tag,
 		const void *data, size_t datalen)
 {
 	struct snmp_ctx *ctx = (struct snmp_ctx *)context;
-	__be32 *pdata = (__be32 *)data;
+	__be32 *pdata;
 
+	if (datalen != 4)
+		return -EINVAL;
+	pdata = (__be32 *)data;
 	if (*pdata == ctx->from) {
 		pr_debug(""%s: %pI4 to %pI4\n"", __func__,
 			 (void *)&ctx->from, (void *)&ctx->to);",linux,c4c07b4d6fa1f11880eab8e076d3d060ef3f55fc,31b58ad0c3279817cd246eab27eaf53b626dfcde,1," int snmp_version(void *context, size_t hdrlen, unsigned char tag,
 		 const void *data, size_t datalen)
 {
//fix_flaw_line_below:
//	if (datalen != 1)
//fix_flaw_line_below:
//		return -EINVAL;
 	if (*(unsigned char *)data > 1)
 		return -ENOTSUPP;
 	return 1;
}
",182896," int snmp_version(void *context, size_t hdrlen, unsigned char tag,
 		 const void *data, size_t datalen)
 {
 	if (*(unsigned char *)data > 1)
 		return -ENOTSUPP;
 	return 1;
}
"," int snmp_version(void *context, size_t hdrlen, unsigned char tag,
 		 const void *data, size_t datalen)
 {
	if (datalen != 1)
		return -EINVAL;
 	if (*(unsigned char *)data > 1)
 		return -ENOTSUPP;
 	return 1;
}
","The provided code defines a function `snmp_version` that checks the version of the Simple Network Management Protocol (SNMP) based on the input data. It takes four parameters: a context pointer, the length of the header, a tag, and a pointer to the data along with its length. The function examines the first byte of the data; if this byte (representing the SNMP version) is greater than 1, it returns an error code `-ENOTSUPP`, indicating that the version is not supported. If the version is valid (0 or 1), it returns 1, signaling successful validation.","The code defines a function that verifies the version of a network management protocol based on input data. It accepts parameters that include a context, header length, a tag, and a pointer to the data along with its length. The function checks the first byte of the data to determine the protocol version. If this byte exceeds a specified value, it indicates that the version is unsupported and returns an error code. Conversely, if the version is valid, it returns a success indicator, confirming that the version check has been successfully completed.","The vulnerability in the original code arises from the lack of a check on the length of the input data, which could lead to reading beyond the allocated memory if the data length is not as expected. Specifically, the function directly dereferences the `data` pointer without verifying that `datalen` is equal to 1, potentially causing buffer overflows. The fixed code addresses this issue by adding a condition that checks if `datalen` is not equal to 1, returning an error code if the check fails. This ensures that the function only processes valid data, preventing unsafe memory access.","The vulnerability in the original code stems from the absence of a check on the length of the input data, which could lead to unsafe memory access if the data provided is shorter than expected. This oversight could result in reading uninitialized memory or causing buffer overflows. The fixed code addresses this issue by implementing a length verification step before accessing the data, ensuring that the function only processes data of the correct size. This change prevents potential exploitation by safeguarding against reading or writing beyond the allocated memory, thereby enhancing the overall security of the code.","The vulnerability was fixed by adding a check for the `datalen` parameter in the modified code. Specifically, the condition `if (datalen != 1)` was introduced to ensure that the length of the input data matches the expected size before any dereferencing occurs. This prevents the function from accessing the `data` pointer if the length is incorrect, thereby avoiding potential buffer overflows or reading uninitialized memory. Additionally, the assignment to `pdata` was moved below this check to clarify that it should only be used after confirming the validity of the data length, further enhancing safety.","The vulnerability was fixed by introducing a validation step that checks the length of the input data before any access occurs. This ensures that the function only processes data of the expected size, preventing unsafe memory access that could lead to buffer overflows or reading uninitialized memory. Additionally, the assignment of a pointer to the data was repositioned to occur after the length check, making it clear that the pointer should only be used if the data length is confirmed to be valid. This change significantly enhances the safety and robustness of the code against potential exploitation.","CWE-119, CWE-120, CWE-125, CWE-131, CWE-789, CWE-788, CWE-122, CWE-787, CWE-126, CWE-129",N,-1.0,"4, 5","5,5","4,4","4, 5"
