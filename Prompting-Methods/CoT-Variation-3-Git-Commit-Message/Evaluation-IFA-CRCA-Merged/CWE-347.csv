,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix,idx,primevul_func_before_fix,primevul_func_after_fix,C1_Description_of_Functionality_In_Context,C2_Description_of_Functionality_Generic,C3_Explanation_of_Vulnerability_In_Context,C4_Explanation_of_Vulnerability_Generic,C5_Explanation_Vulnerability_Fixed_In_Context,C6_Explanation_Vulnerability_Fixed_Generic,T1_Top_10_CWE_IDs,T2_Correctly_Found_CWE,T3_IFA,G1_Clarity_C3_C5,G2_Relevance_C3_C5,G3_Completeness_C3_C5,G4_Actionability_C3_C5
0,0,177794,177794,,Remote,Not required,Partial,CVE-2017-16853,https://www.cvedetails.com/cve/CVE-2017-16853/,CWE-347,Medium,Partial,Partial,,2017-11-16,6.8,"The DynamicMetadataProvider class in saml/saml2/metadata/impl/DynamicMetadataProvider.cpp in OpenSAML-C in OpenSAML before 2.6.1 fails to properly configure itself with the MetadataFilter plugins and does not perform critical security checks such as signature verification, enforcement of validity periods, and other checks specific to deployments, aka CPPOST-105.",2018-02-03,,2,https://git.shibboleth.net/view/?p=cpp-opensaml.git;a=commit;h=6182b0acf2df670e75423c2ed7afe6950ef11c9d,6182b0acf2df670e75423c2ed7afe6950ef11c9d,,2,,," DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)
    : AbstractMetadataProvider(e), MetadataProvider(e),
       m_validate(XMLHelper::getAttrBool(e, false, validate)),
         m_id(XMLHelper::getAttrString(e, ""Dynamic"", id)),
         m_lock(RWLock::create()),
        m_refreshDelayFactor(0.75),
        m_minCacheDuration(XMLHelper::getAttrInt(e, 600, minCacheDuration)),
        m_maxCacheDuration(XMLHelper::getAttrInt(e, 28800, maxCacheDuration)),
        m_shutdown(false),
        m_cleanupInterval(XMLHelper::getAttrInt(e, 1800, cleanupInterval)),
        m_cleanupTimeout(XMLHelper::getAttrInt(e, 1800, cleanupTimeout)),
         m_cleanup_wait(nullptr), m_cleanup_thread(nullptr)
 {
     if (m_minCacheDuration > m_maxCacheDuration) {
        Category::getInstance(SAML_LOGCAT "".Metadata.Dynamic"").error(
             ""minCacheDuration setting exceeds maxCacheDuration setting, lowering to match it""
             );
         m_minCacheDuration = m_maxCacheDuration;
    }

    const XMLCh* delay = e ? e->getAttributeNS(nullptr, refreshDelayFactor) : nullptr;
    if (delay && *delay) {
        auto_ptr_char temp(delay);
        m_refreshDelayFactor = atof(temp.get());
        if (m_refreshDelayFactor <= 0.0 || m_refreshDelayFactor >= 1.0) {
            Category::getInstance(SAML_LOGCAT "".MetadataProvider.Dynamic"").error(
                ""invalid refreshDelayFactor setting, using default""
                );
            m_refreshDelayFactor = 0.75;
        }
    }

    if (m_cleanupInterval > 0) {
        if (m_cleanupTimeout < 0)
            m_cleanupTimeout = 0;
        m_cleanup_wait = CondWait::create();
        m_cleanup_thread = Thread::create(&cleanup_fn, this);
    }
}
"," DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)
    : AbstractMetadataProvider(e),
       m_validate(XMLHelper::getAttrBool(e, false, validate)),
         m_id(XMLHelper::getAttrString(e, ""Dynamic"", id)),
         m_lock(RWLock::create()),
        m_refreshDelayFactor(0.75),
        m_minCacheDuration(XMLHelper::getAttrInt(e, 600, minCacheDuration)),
        m_maxCacheDuration(XMLHelper::getAttrInt(e, 28800, maxCacheDuration)),
        m_shutdown(false),
        m_cleanupInterval(XMLHelper::getAttrInt(e, 1800, cleanupInterval)),
        m_cleanupTimeout(XMLHelper::getAttrInt(e, 1800, cleanupTimeout)),
         m_cleanup_wait(nullptr), m_cleanup_thread(nullptr)
 {
     if (m_minCacheDuration > m_maxCacheDuration) {
        Category::getInstance(SAML_LOGCAT "".MetadataProvider.Dynamic"").error(
             ""minCacheDuration setting exceeds maxCacheDuration setting, lowering to match it""
             );
         m_minCacheDuration = m_maxCacheDuration;
    }

    const XMLCh* delay = e ? e->getAttributeNS(nullptr, refreshDelayFactor) : nullptr;
    if (delay && *delay) {
        auto_ptr_char temp(delay);
        m_refreshDelayFactor = atof(temp.get());
        if (m_refreshDelayFactor <= 0.0 || m_refreshDelayFactor >= 1.0) {
            Category::getInstance(SAML_LOGCAT "".MetadataProvider.Dynamic"").error(
                ""invalid refreshDelayFactor setting, using default""
                );
            m_refreshDelayFactor = 0.75;
        }
    }

    if (m_cleanupInterval > 0) {
        if (m_cleanupTimeout < 0)
            m_cleanupTimeout = 0;
        m_cleanup_wait = CondWait::create();
        m_cleanup_thread = Thread::create(&cleanup_fn, this);
    }
}
",CPP,"    : AbstractMetadataProvider(e), MetadataProvider(e),
        Category::getInstance(SAML_LOGCAT "".Metadata.Dynamic"").error(
","    : AbstractMetadataProvider(e),
        Category::getInstance(SAML_LOGCAT "".MetadataProvider.Dynamic"").error(
",98724ab1055da940d15db628b63e3d06e0e34ba7,"@@ -79,7 +79,7 @@ namespace opensaml {
 };
 
 DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)
-    : AbstractMetadataProvider(e),
+    : AbstractMetadataProvider(e), MetadataProvider(e),
       m_validate(XMLHelper::getAttrBool(e, false, validate)),
         m_id(XMLHelper::getAttrString(e, ""Dynamic"", id)),
         m_lock(RWLock::create()),
@@ -92,7 +92,7 @@ DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)
         m_cleanup_wait(nullptr), m_cleanup_thread(nullptr)
 {
     if (m_minCacheDuration > m_maxCacheDuration) {
-        Category::getInstance(SAML_LOGCAT "".MetadataProvider.Dynamic"").error(
+        Category::getInstance(SAML_LOGCAT "".Metadata.Dynamic"").error(
             ""minCacheDuration setting exceeds maxCacheDuration setting, lowering to match it""
             );
         m_minCacheDuration = m_maxCacheDuration;",shibboleth,https://git.shibboleth.net/view/?p=cpp-opensaml.git;a=blob;f=saml/saml2/metadata/impl/DynamicMetadataProvider.cpp;h=af4e21c523fd2aacedab87157a8c45b6cde4c901;hb=af4e21c523fd2aacedab87157a8c45b6cde4c901,https://git.shibboleth.net/view/?p=cpp-opensaml.git;a=blob;f=saml/saml2/metadata/impl/DynamicMetadataProvider.cpp;h=ae09b26e6adc3c812ef8b61e02ad35b48a8f77db;hb=ae09b26e6adc3c812ef8b61e02ad35b48a8f77db,1," DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)
//flaw_line_below:
    : AbstractMetadataProvider(e),
//fix_flaw_line_below:
//    : AbstractMetadataProvider(e), MetadataProvider(e),
       m_validate(XMLHelper::getAttrBool(e, false, validate)),
         m_id(XMLHelper::getAttrString(e, ""Dynamic"", id)),
         m_lock(RWLock::create()),
        m_refreshDelayFactor(0.75),
        m_minCacheDuration(XMLHelper::getAttrInt(e, 600, minCacheDuration)),
        m_maxCacheDuration(XMLHelper::getAttrInt(e, 28800, maxCacheDuration)),
        m_shutdown(false),
        m_cleanupInterval(XMLHelper::getAttrInt(e, 1800, cleanupInterval)),
        m_cleanupTimeout(XMLHelper::getAttrInt(e, 1800, cleanupTimeout)),
         m_cleanup_wait(nullptr), m_cleanup_thread(nullptr)
 {
     if (m_minCacheDuration > m_maxCacheDuration) {
//flaw_line_below:
        Category::getInstance(SAML_LOGCAT "".MetadataProvider.Dynamic"").error(
//fix_flaw_line_below:
//        Category::getInstance(SAML_LOGCAT "".Metadata.Dynamic"").error(
             ""minCacheDuration setting exceeds maxCacheDuration setting, lowering to match it""
             );
         m_minCacheDuration = m_maxCacheDuration;
    }

    const XMLCh* delay = e ? e->getAttributeNS(nullptr, refreshDelayFactor) : nullptr;
    if (delay && *delay) {
        auto_ptr_char temp(delay);
        m_refreshDelayFactor = atof(temp.get());
        if (m_refreshDelayFactor <= 0.0 || m_refreshDelayFactor >= 1.0) {
            Category::getInstance(SAML_LOGCAT "".MetadataProvider.Dynamic"").error(
                ""invalid refreshDelayFactor setting, using default""
                );
            m_refreshDelayFactor = 0.75;
        }
    }

    if (m_cleanupInterval > 0) {
        if (m_cleanupTimeout < 0)
            m_cleanupTimeout = 0;
        m_cleanup_wait = CondWait::create();
        m_cleanup_thread = Thread::create(&cleanup_fn, this);
    }
}
",177794," DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)
    : AbstractMetadataProvider(e),
       m_validate(XMLHelper::getAttrBool(e, false, validate)),
         m_id(XMLHelper::getAttrString(e, ""Dynamic"", id)),
         m_lock(RWLock::create()),
        m_refreshDelayFactor(0.75),
        m_minCacheDuration(XMLHelper::getAttrInt(e, 600, minCacheDuration)),
        m_maxCacheDuration(XMLHelper::getAttrInt(e, 28800, maxCacheDuration)),
        m_shutdown(false),
        m_cleanupInterval(XMLHelper::getAttrInt(e, 1800, cleanupInterval)),
        m_cleanupTimeout(XMLHelper::getAttrInt(e, 1800, cleanupTimeout)),
         m_cleanup_wait(nullptr), m_cleanup_thread(nullptr)
 {
     if (m_minCacheDuration > m_maxCacheDuration) {
        Category::getInstance(SAML_LOGCAT "".MetadataProvider.Dynamic"").error(
             ""minCacheDuration setting exceeds maxCacheDuration setting, lowering to match it""
             );
         m_minCacheDuration = m_maxCacheDuration;
    }

    const XMLCh* delay = e ? e->getAttributeNS(nullptr, refreshDelayFactor) : nullptr;
    if (delay && *delay) {
        auto_ptr_char temp(delay);
        m_refreshDelayFactor = atof(temp.get());
        if (m_refreshDelayFactor <= 0.0 || m_refreshDelayFactor >= 1.0) {
            Category::getInstance(SAML_LOGCAT "".MetadataProvider.Dynamic"").error(
                ""invalid refreshDelayFactor setting, using default""
                );
            m_refreshDelayFactor = 0.75;
        }
    }

    if (m_cleanupInterval > 0) {
        if (m_cleanupTimeout < 0)
            m_cleanupTimeout = 0;
        m_cleanup_wait = CondWait::create();
        m_cleanup_thread = Thread::create(&cleanup_fn, this);
    }
}
"," DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)
    : AbstractMetadataProvider(e), MetadataProvider(e),
       m_validate(XMLHelper::getAttrBool(e, false, validate)),
         m_id(XMLHelper::getAttrString(e, ""Dynamic"", id)),
         m_lock(RWLock::create()),
        m_refreshDelayFactor(0.75),
        m_minCacheDuration(XMLHelper::getAttrInt(e, 600, minCacheDuration)),
        m_maxCacheDuration(XMLHelper::getAttrInt(e, 28800, maxCacheDuration)),
        m_shutdown(false),
        m_cleanupInterval(XMLHelper::getAttrInt(e, 1800, cleanupInterval)),
        m_cleanupTimeout(XMLHelper::getAttrInt(e, 1800, cleanupTimeout)),
         m_cleanup_wait(nullptr), m_cleanup_thread(nullptr)
 {
     if (m_minCacheDuration > m_maxCacheDuration) {
        Category::getInstance(SAML_LOGCAT "".Metadata.Dynamic"").error(
             ""minCacheDuration setting exceeds maxCacheDuration setting, lowering to match it""
             );
         m_minCacheDuration = m_maxCacheDuration;
    }

    const XMLCh* delay = e ? e->getAttributeNS(nullptr, refreshDelayFactor) : nullptr;
    if (delay && *delay) {
        auto_ptr_char temp(delay);
        m_refreshDelayFactor = atof(temp.get());
        if (m_refreshDelayFactor <= 0.0 || m_refreshDelayFactor >= 1.0) {
            Category::getInstance(SAML_LOGCAT "".MetadataProvider.Dynamic"").error(
                ""invalid refreshDelayFactor setting, using default""
                );
            m_refreshDelayFactor = 0.75;
        }
    }

    if (m_cleanupInterval > 0) {
        if (m_cleanupTimeout < 0)
            m_cleanupTimeout = 0;
        m_cleanup_wait = CondWait::create();
        m_cleanup_thread = Thread::create(&cleanup_fn, this);
    }
}
","The `DynamicMetadataProvider` constructor initializes an instance of the class by parsing attributes from a provided XML element. It sets various parameters such as validation, ID, cache durations, and cleanup intervals, ensuring that the minimum cache duration does not exceed the maximum. It also retrieves and validates a refresh delay factor, defaulting to 0.75 if the input is invalid. If a cleanup interval is specified, it initializes a condition wait and spawns a cleanup thread to manage resource cleanup. Error logging is implemented for configuration issues, ensuring robust handling of invalid settings.","The constructor initializes an instance of a dynamic metadata provider by extracting configuration settings from an XML element. It establishes parameters for validation, caching durations, and cleanup intervals, ensuring that the minimum cache duration does not exceed the maximum. Additionally, it retrieves a refresh delay factor, defaulting to a specific value if the input is invalid. If a cleanup interval is defined, it sets up a mechanism for waiting and starts a separate thread to handle cleanup tasks. The implementation includes error logging to address any configuration discrepancies, promoting stability and reliability in operation.","The vulnerability in the original code stemmed from the lack of proper initialization and validation of the `MetadataProvider` class, which could lead to undefined behavior or security issues when handling metadata. The fix involved explicitly calling the constructor of `MetadataProvider` in the updated code, ensuring that all necessary attributes and states are correctly initialized. This change enhances the robustness of the class by ensuring that it adheres to the expected behavior of its parent class, thereby mitigating potential risks associated with improper handling of metadata and improving overall stability and security.","The vulnerability in the original code arose from inadequate initialization and validation of critical components, which could lead to undefined behavior or security risks when processing metadata. The fix addressed this issue by ensuring that the parent class was properly initialized during the construction of the new instance. This change guarantees that all necessary attributes and states are set up correctly, thereby enhancing the robustness of the implementation. As a result, the updated code mitigates potential risks associated with improper handling of metadata, leading to improved stability and security in the overall system.","The vulnerability was fixed by explicitly invoking the constructor of the `MetadataProvider` class within the initialization list of the `DynamicMetadataProvider` constructor. This ensures that all attributes inherited from the parent class are properly initialized, addressing potential issues related to undefined behavior. Additionally, the error handling for the `minCacheDuration` and `maxCacheDuration` was improved, ensuring that the minimum value does not exceed the maximum. By enhancing the initialization process and validating critical parameters, the updated code strengthens the overall integrity and security of the metadata handling functionality.","The vulnerability was fixed by ensuring that the parent class was properly initialized during the construction of the new instance, which addresses potential issues related to undefined behavior. This change guarantees that all necessary attributes and states are correctly set up, enhancing the robustness of the implementation. Additionally, the error handling for configuration parameters was improved, ensuring that critical values are validated and adjusted as needed. By reinforcing the initialization process and implementing better validation, the updated code mitigates risks associated with improper handling of metadata, leading to enhanced stability and security.","CWE-665, CWE-415, CWE-908, CWE-456, CWE-457, CWE-909, CWE-459, CWE-455, CWE-824, CWE-911",N,-1.0,"4,5","5, 5","4,4","4,5"
1,1,177795,177795,,Remote,Not required,Partial,CVE-2017-16852,https://www.cvedetails.com/cve/CVE-2017-16852/,CWE-347,Medium,Partial,Partial,,2017-11-16,6.8,"shibsp/metadata/DynamicMetadataProvider.cpp in the Dynamic MetadataProvider plugin in Shibboleth Service Provider before 2.6.1 fails to properly configure itself with the MetadataFilter plugins and does not perform critical security checks such as signature verification, enforcement of validity periods, and other checks specific to deployments, aka SSPCPP-763.",2018-02-03,,1,https://git.shibboleth.net/view/?p=cpp-sp.git;a=commit;h=b66cceb0e992c351ad5e2c665229ede82f261b16,b66cceb0e992c351ad5e2c665229ede82f261b16,,1,,," DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)
    : saml2md::DynamicMetadataProvider(e), MetadataProvider(e),
         m_verifyHost(XMLHelper::getAttrBool(e, true, verifyHost)),
         m_ignoreTransport(XMLHelper::getAttrBool(e, false, ignoreTransport)),
         m_encoded(true), m_trust(nullptr)
{
    const DOMElement* child = XMLHelper::getFirstChildElement(e, Subst);
    if (child && child->hasChildNodes()) {
        auto_ptr_char s(child->getFirstChild()->getNodeValue());
        if (s.get() && *s.get()) {
            m_subst = s.get();
            m_encoded = XMLHelper::getAttrBool(child, true, encoded);
            m_hashed = XMLHelper::getAttrString(child, nullptr, hashed);
        }
    }

    if (m_subst.empty()) {
        child = XMLHelper::getFirstChildElement(e, Regex);
        if (child && child->hasChildNodes() && child->hasAttributeNS(nullptr, match)) {
            m_match = XMLHelper::getAttrString(child, nullptr, match);
            auto_ptr_char repl(child->getFirstChild()->getNodeValue());
            if (repl.get() && *repl.get())
                m_regex = repl.get();
        }
    }

    if (!m_ignoreTransport) {
        child = XMLHelper::getFirstChildElement(e, _TrustEngine);
        string t = XMLHelper::getAttrString(child, nullptr, _type);
        if (!t.empty()) {
            TrustEngine* trust = XMLToolingConfig::getConfig().TrustEngineManager.newPlugin(t.c_str(), child);
            if (!dynamic_cast<X509TrustEngine*>(trust)) {
                delete trust;
                throw ConfigurationException(""DynamicMetadataProvider requires an X509TrustEngine plugin."");
            }
            m_trust.reset(dynamic_cast<X509TrustEngine*>(trust));
            m_dummyCR.reset(XMLToolingConfig::getConfig().CredentialResolverManager.newPlugin(DUMMY_CREDENTIAL_RESOLVER, nullptr));
        }

        if (!m_trust.get() || !m_dummyCR.get())
            throw ConfigurationException(""DynamicMetadataProvider requires an X509TrustEngine plugin unless ignoreTransport is true."");
    }
}
"," DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)
    : saml2md::DynamicMetadataProvider(e),
         m_verifyHost(XMLHelper::getAttrBool(e, true, verifyHost)),
         m_ignoreTransport(XMLHelper::getAttrBool(e, false, ignoreTransport)),
         m_encoded(true), m_trust(nullptr)
{
    const DOMElement* child = XMLHelper::getFirstChildElement(e, Subst);
    if (child && child->hasChildNodes()) {
        auto_ptr_char s(child->getFirstChild()->getNodeValue());
        if (s.get() && *s.get()) {
            m_subst = s.get();
            m_encoded = XMLHelper::getAttrBool(child, true, encoded);
            m_hashed = XMLHelper::getAttrString(child, nullptr, hashed);
        }
    }

    if (m_subst.empty()) {
        child = XMLHelper::getFirstChildElement(e, Regex);
        if (child && child->hasChildNodes() && child->hasAttributeNS(nullptr, match)) {
            m_match = XMLHelper::getAttrString(child, nullptr, match);
            auto_ptr_char repl(child->getFirstChild()->getNodeValue());
            if (repl.get() && *repl.get())
                m_regex = repl.get();
        }
    }

    if (!m_ignoreTransport) {
        child = XMLHelper::getFirstChildElement(e, _TrustEngine);
        string t = XMLHelper::getAttrString(child, nullptr, _type);
        if (!t.empty()) {
            TrustEngine* trust = XMLToolingConfig::getConfig().TrustEngineManager.newPlugin(t.c_str(), child);
            if (!dynamic_cast<X509TrustEngine*>(trust)) {
                delete trust;
                throw ConfigurationException(""DynamicMetadataProvider requires an X509TrustEngine plugin."");
            }
            m_trust.reset(dynamic_cast<X509TrustEngine*>(trust));
            m_dummyCR.reset(XMLToolingConfig::getConfig().CredentialResolverManager.newPlugin(DUMMY_CREDENTIAL_RESOLVER, nullptr));
        }

        if (!m_trust.get() || !m_dummyCR.get())
            throw ConfigurationException(""DynamicMetadataProvider requires an X509TrustEngine plugin unless ignoreTransport is true."");
    }
}
",CPP,"    : saml2md::DynamicMetadataProvider(e), MetadataProvider(e),
","    : saml2md::DynamicMetadataProvider(e),
",3a4d2438e6ce0560756150a06f0108266973dc70,"@@ -95,7 +95,7 @@ namespace shibsp {
 };
 
 DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)
-    : saml2md::DynamicMetadataProvider(e),
+    : saml2md::DynamicMetadataProvider(e), MetadataProvider(e),
         m_verifyHost(XMLHelper::getAttrBool(e, true, verifyHost)),
         m_ignoreTransport(XMLHelper::getAttrBool(e, false, ignoreTransport)),
         m_encoded(true), m_trust(nullptr)",shibboleth,https://git.shibboleth.net/view/?p=cpp-sp.git;a=blob;f=shibsp/metadata/DynamicMetadataProvider.cpp;h=d416a00018c81063be7a22e5aa6ff33ca1841d57;hb=d416a00018c81063be7a22e5aa6ff33ca1841d57,https://git.shibboleth.net/view/?p=cpp-sp.git;a=blob;f=shibsp/metadata/DynamicMetadataProvider.cpp;h=8853acb475f1dcb0974d75f895235e3bd679f73f;hb=8853acb475f1dcb0974d75f895235e3bd679f73f,1," DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)
//flaw_line_below:
    : saml2md::DynamicMetadataProvider(e),
//fix_flaw_line_below:
//    : saml2md::DynamicMetadataProvider(e), MetadataProvider(e),
         m_verifyHost(XMLHelper::getAttrBool(e, true, verifyHost)),
         m_ignoreTransport(XMLHelper::getAttrBool(e, false, ignoreTransport)),
         m_encoded(true), m_trust(nullptr)
{
    const DOMElement* child = XMLHelper::getFirstChildElement(e, Subst);
    if (child && child->hasChildNodes()) {
        auto_ptr_char s(child->getFirstChild()->getNodeValue());
        if (s.get() && *s.get()) {
            m_subst = s.get();
            m_encoded = XMLHelper::getAttrBool(child, true, encoded);
            m_hashed = XMLHelper::getAttrString(child, nullptr, hashed);
        }
    }

    if (m_subst.empty()) {
        child = XMLHelper::getFirstChildElement(e, Regex);
        if (child && child->hasChildNodes() && child->hasAttributeNS(nullptr, match)) {
            m_match = XMLHelper::getAttrString(child, nullptr, match);
            auto_ptr_char repl(child->getFirstChild()->getNodeValue());
            if (repl.get() && *repl.get())
                m_regex = repl.get();
        }
    }

    if (!m_ignoreTransport) {
        child = XMLHelper::getFirstChildElement(e, _TrustEngine);
        string t = XMLHelper::getAttrString(child, nullptr, _type);
        if (!t.empty()) {
            TrustEngine* trust = XMLToolingConfig::getConfig().TrustEngineManager.newPlugin(t.c_str(), child);
            if (!dynamic_cast<X509TrustEngine*>(trust)) {
                delete trust;
                throw ConfigurationException(""DynamicMetadataProvider requires an X509TrustEngine plugin."");
            }
            m_trust.reset(dynamic_cast<X509TrustEngine*>(trust));
            m_dummyCR.reset(XMLToolingConfig::getConfig().CredentialResolverManager.newPlugin(DUMMY_CREDENTIAL_RESOLVER, nullptr));
        }

        if (!m_trust.get() || !m_dummyCR.get())
            throw ConfigurationException(""DynamicMetadataProvider requires an X509TrustEngine plugin unless ignoreTransport is true."");
    }
}
",177795," DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)
    : saml2md::DynamicMetadataProvider(e),
         m_verifyHost(XMLHelper::getAttrBool(e, true, verifyHost)),
         m_ignoreTransport(XMLHelper::getAttrBool(e, false, ignoreTransport)),
         m_encoded(true), m_trust(nullptr)
{
    const DOMElement* child = XMLHelper::getFirstChildElement(e, Subst);
    if (child && child->hasChildNodes()) {
        auto_ptr_char s(child->getFirstChild()->getNodeValue());
        if (s.get() && *s.get()) {
            m_subst = s.get();
            m_encoded = XMLHelper::getAttrBool(child, true, encoded);
            m_hashed = XMLHelper::getAttrString(child, nullptr, hashed);
        }
    }

    if (m_subst.empty()) {
        child = XMLHelper::getFirstChildElement(e, Regex);
        if (child && child->hasChildNodes() && child->hasAttributeNS(nullptr, match)) {
            m_match = XMLHelper::getAttrString(child, nullptr, match);
            auto_ptr_char repl(child->getFirstChild()->getNodeValue());
            if (repl.get() && *repl.get())
                m_regex = repl.get();
        }
    }

    if (!m_ignoreTransport) {
        child = XMLHelper::getFirstChildElement(e, _TrustEngine);
        string t = XMLHelper::getAttrString(child, nullptr, _type);
        if (!t.empty()) {
            TrustEngine* trust = XMLToolingConfig::getConfig().TrustEngineManager.newPlugin(t.c_str(), child);
            if (!dynamic_cast<X509TrustEngine*>(trust)) {
                delete trust;
                throw ConfigurationException(""DynamicMetadataProvider requires an X509TrustEngine plugin."");
            }
            m_trust.reset(dynamic_cast<X509TrustEngine*>(trust));
            m_dummyCR.reset(XMLToolingConfig::getConfig().CredentialResolverManager.newPlugin(DUMMY_CREDENTIAL_RESOLVER, nullptr));
        }

        if (!m_trust.get() || !m_dummyCR.get())
            throw ConfigurationException(""DynamicMetadataProvider requires an X509TrustEngine plugin unless ignoreTransport is true."");
    }
}
"," DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)
    : saml2md::DynamicMetadataProvider(e), MetadataProvider(e),
         m_verifyHost(XMLHelper::getAttrBool(e, true, verifyHost)),
         m_ignoreTransport(XMLHelper::getAttrBool(e, false, ignoreTransport)),
         m_encoded(true), m_trust(nullptr)
{
    const DOMElement* child = XMLHelper::getFirstChildElement(e, Subst);
    if (child && child->hasChildNodes()) {
        auto_ptr_char s(child->getFirstChild()->getNodeValue());
        if (s.get() && *s.get()) {
            m_subst = s.get();
            m_encoded = XMLHelper::getAttrBool(child, true, encoded);
            m_hashed = XMLHelper::getAttrString(child, nullptr, hashed);
        }
    }

    if (m_subst.empty()) {
        child = XMLHelper::getFirstChildElement(e, Regex);
        if (child && child->hasChildNodes() && child->hasAttributeNS(nullptr, match)) {
            m_match = XMLHelper::getAttrString(child, nullptr, match);
            auto_ptr_char repl(child->getFirstChild()->getNodeValue());
            if (repl.get() && *repl.get())
                m_regex = repl.get();
        }
    }

    if (!m_ignoreTransport) {
        child = XMLHelper::getFirstChildElement(e, _TrustEngine);
        string t = XMLHelper::getAttrString(child, nullptr, _type);
        if (!t.empty()) {
            TrustEngine* trust = XMLToolingConfig::getConfig().TrustEngineManager.newPlugin(t.c_str(), child);
            if (!dynamic_cast<X509TrustEngine*>(trust)) {
                delete trust;
                throw ConfigurationException(""DynamicMetadataProvider requires an X509TrustEngine plugin."");
            }
            m_trust.reset(dynamic_cast<X509TrustEngine*>(trust));
            m_dummyCR.reset(XMLToolingConfig::getConfig().CredentialResolverManager.newPlugin(DUMMY_CREDENTIAL_RESOLVER, nullptr));
        }

        if (!m_trust.get() || !m_dummyCR.get())
            throw ConfigurationException(""DynamicMetadataProvider requires an X509TrustEngine plugin unless ignoreTransport is true."");
    }
}
","The `DynamicMetadataProvider` constructor initializes an instance of the `DynamicMetadataProvider` class, inheriting from `saml2md::DynamicMetadataProvider`. It processes a given XML `DOMElement`, extracting attributes related to host verification, transport handling, and metadata encoding. The constructor retrieves and sets substitution and regex patterns from child elements, ensuring that if transport is not ignored, it initializes a trust engine, specifically requiring an `X509TrustEngine` plugin. If the necessary conditions are not met, it throws a `ConfigurationException`, ensuring robust error handling during the configuration of dynamic metadata.","The constructor initializes a dynamic metadata provider by processing an XML element to configure various attributes related to host verification, transport handling, and metadata encoding. It checks for child elements to extract substitution and regex patterns, ensuring that if transport is not ignored, a specific trust engine is instantiated. The implementation enforces that the trust engine must meet certain criteria, throwing an exception if these conditions are not satisfied. This approach ensures that the provider is correctly configured for dynamic metadata handling while maintaining robust error management throughout the initialization process.","The vulnerability in the original code stemmed from the lack of proper initialization and validation of the `MetadataProvider`, which could lead to undefined behavior or security issues if the provider was not correctly set up. The fix involved explicitly adding `MetadataProvider(e)` to the constructor's initializer list, ensuring that the base class is properly initialized. This change enhances the robustness of the code by ensuring that all necessary components are correctly configured before use, thereby mitigating potential risks associated with uninitialized or improperly configured metadata handling.","The vulnerability in the original code arose from the potential for improper initialization of a critical component, which could lead to undefined behavior or security risks if the component was not correctly set up. The fix addressed this issue by ensuring that the base class was explicitly initialized in the constructor's initializer list. This change guarantees that all necessary components are properly configured before they are used, thereby enhancing the overall robustness of the code and mitigating risks associated with uninitialized or misconfigured elements in the metadata handling process.","The vulnerability was fixed by adding `MetadataProvider(e)` to the constructor's initializer list, ensuring that the base class is properly initialized alongside the derived class. This change guarantees that the `DynamicMetadataProvider` has a valid state from the outset, preventing issues related to uninitialized components. Additionally, the code maintains checks for the trust engine and credential resolver, ensuring that they are correctly instantiated and configured. By enforcing these initializations, the fix enhances the overall stability and security of the metadata handling process, reducing the risk of undefined behavior or security vulnerabilities.","The vulnerability was fixed by ensuring that the base class was explicitly initialized in the constructor, which guarantees that all necessary components are set up correctly from the start. This change prevents potential issues related to uninitialized states that could lead to undefined behavior or security risks. Additionally, the code includes checks to confirm that critical elements are properly instantiated and configured, reinforcing the overall integrity of the system. By addressing these initialization concerns, the fix enhances the robustness and security of the metadata handling process, mitigating the risk of operational failures.","CWE-665, CWE-908, CWE-415, CWE-456, CWE-457, CWE-824, CWE-455, CWE-475, CWE-909, CWE-664",N,-1.0,"4,4","5,5","4,4","4,5"
2,2,182258,182258,,Remote,Not required,,CVE-2018-16253,https://www.cvedetails.com/cve/CVE-2018-16253/,CWE-347,Medium,,Partial,,2018-11-07,4.3,"In sig_verify() in x509.c in axTLS version 2.1.3 and before, the PKCS#1 v1.5 signature verification does not properly verify the ASN.1 metadata. Consequently, a remote attacker can forge signatures when small public exponents are being used, which could lead to impersonation through fake X.509 certificates. This is an even more permissive variant of CVE-2006-4790 and CVE-2014-1568.",2018-12-13,,57,https://github.com/igrr/axtls-8266/commit/5efe2947ab45e81d84b5f707c51d1c64be52f36c,5efe2947ab45e81d84b5f707c51d1c64be52f36c,"Apply CVE fixes for X509 parsing

Apply patches developed by Sze Yiu which correct a vulnerability in
X509 parsing.  See CVE-2018-16150 and CVE-2018-16149 for more info.",13,ssl/x509.c,"{""sha"": ""e0b9e46075979afecc22750f715d571399e946c7"", ""filename"": ""ssl/os_port.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/igrr/axtls-8266/blob/5efe2947ab45e81d84b5f707c51d1c64be52f36c/ssl/os_port.h"", ""raw_url"": ""https://github.com/igrr/axtls-8266/raw/5efe2947ab45e81d84b5f707c51d1c64be52f36c/ssl/os_port.h"", ""contents_url"": ""https://api.github.com/repos/igrr/axtls-8266/contents/ssl/os_port.h?ref=5efe2947ab45e81d84b5f707c51d1c64be52f36c"", ""patch"": ""@@ -142,6 +142,18 @@ static inline int strlen_P(const char *str) {\n     while (pgm_read_byte(str++)) cnt++;\n     return cnt;\n }\n+static inline int memcmp_P(const void *a1, const void *b1, size_t len) {\n+    const uint8_t* a = (const uint8_t*)(a1);\n+    uint8_t* b = (uint8_t*)(b1);\n+    for (size_t i=0; i<len; i++) {\n+        uint8_t d = pgm_read_byte(a) - pgm_read_byte(b);\n+        if (d) return d;\n+        a++;\n+        b++;\n+    }\n+    return 0;\n+}\n+\n #define printf(fmt, ...) do { static const char fstr[] PROGMEM = fmt; char rstr[sizeof(fmt)]; memcpy_P(rstr, fstr, sizeof(rstr)); ets_printf(rstr, ##__VA_ARGS__); } while (0)\n #define strcpy_P(dst, src) do { static const char fstr[] PROGMEM = src; memcpy_P(dst, fstr, sizeof(src)); } while (0)\n ""}<_**next**_>{""sha"": ""a51b948a9bd48587ce8d8d10dd62c5b3df6410bb"", ""filename"": ""ssl/x509.c"", ""status"": ""modified"", ""additions"": 64, ""deletions"": 38, ""changes"": 102, ""blob_url"": ""https://github.com/igrr/axtls-8266/blob/5efe2947ab45e81d84b5f707c51d1c64be52f36c/ssl/x509.c"", ""raw_url"": ""https://github.com/igrr/axtls-8266/raw/5efe2947ab45e81d84b5f707c51d1c64be52f36c/ssl/x509.c"", ""contents_url"": ""https://api.github.com/repos/igrr/axtls-8266/contents/ssl/x509.c?ref=5efe2947ab45e81d84b5f707c51d1c64be52f36c"", ""patch"": ""@@ -49,28 +49,6 @@ static int x509_v3_basic_constraints(const uint8_t *cert, int offset,\n         X509_CTX *x509_ctx);\n static int x509_v3_key_usage(const uint8_t *cert, int offset, \n         X509_CTX *x509_ctx);\n-\n-/**\n- * Retrieve the signature from a certificate.\n- */\n-static const uint8_t *get_signature(const uint8_t *asn1_sig, int *len)\n-{\n-    int offset = 0;\n-    const uint8_t *ptr = NULL;\n-\n-    if (asn1_next_obj(asn1_sig, &offset, ASN1_SEQUENCE) < 0 || \n-            asn1_skip_obj(asn1_sig, &offset, ASN1_SEQUENCE))\n-        goto end_get_sig;\n-\n-    if (asn1_sig[offset++] != ASN1_OCTET_STRING)\n-        goto end_get_sig;\n-    *len = get_asn1_length(asn1_sig, &offset);\n-    ptr = &asn1_sig[offset];          /* all ok */\n-\n-end_get_sig:\n-    return ptr;\n-}\n-\n #endif\n \n /**\n@@ -412,17 +390,56 @@ void x509_free(X509_CTX *x509_ctx)\n }\n \n #ifdef CONFIG_SSL_CERT_VERIFICATION\n+static const uint8_t sig_prefix_md5[] PROGMEM = {0x30, 0x20, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10};\n+static const uint8_t sig_prefix_sha1[] PROGMEM = {0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0x04, 0x14};\n+static const uint8_t sig_prefix_sha256[] PROGMEM = {0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20};\n+static const uint8_t sig_prefix_sha384[] PROGMEM = {0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30};\n+static const uint8_t sig_prefix_sha512[] PROGMEM = {0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40};\n+\n /**\n  * Take a signature and decrypt it.\n  */\n-static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,\n+static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len, uint8_t sig_type,\n         bigint *modulus, bigint *pub_exp)\n {\n-    int i, size;\n+    int i;\n     bigint *decrypted_bi, *dat_bi;\n     bigint *bir = NULL;\n     uint8_t *block = (uint8_t *)malloc(sig_len);\n \n+    const uint8_t *sig_prefix = NULL;\n+    uint8_t sig_prefix_size = 0, hash_len = 0;\n+    /* adjust our expections */\n+    switch (sig_type)\n+    {\n+        case SIG_TYPE_MD5:\n+            sig_prefix = sig_prefix_md5;\n+            sig_prefix_size = sizeof(sig_prefix_md5);\n+        break;\n+        case SIG_TYPE_SHA1:\n+            sig_prefix = sig_prefix_sha1;\n+            sig_prefix_size = sizeof(sig_prefix_sha1);\n+        break;\n+        case SIG_TYPE_SHA256:\n+            sig_prefix = sig_prefix_sha256;\n+            sig_prefix_size = sizeof(sig_prefix_sha256);\n+        break;\n+        case SIG_TYPE_SHA384:\n+            sig_prefix = sig_prefix_sha384;\n+            sig_prefix_size = sizeof(sig_prefix_sha384);\n+        break;\n+        case SIG_TYPE_SHA512:\n+            sig_prefix = sig_prefix_sha512;\n+            sig_prefix_size = sizeof(sig_prefix_sha512);\n+        break;\n+    }\n+    if (sig_prefix)\n+        hash_len = sig_prefix[sig_prefix_size - 1];\n+\n+    /* check length (#A) */\n+    if (sig_len < 2 + 8 + 1 + sig_prefix_size + hash_len)\n+        goto err;\n+\n     /* decrypt */\n     dat_bi = bi_import(ctx, sig, sig_len);\n     ctx->mod_offset = BIGINT_M_OFFSET;\n@@ -433,21 +450,30 @@ static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,\n     bi_export(ctx, decrypted_bi, block, sig_len);\n     ctx->mod_offset = BIGINT_M_OFFSET;\n \n-    i = 10; /* start at the first possible non-padded byte */\n-    while (block[i++] && i < sig_len);\n-    size = sig_len - i;\n-\n-    /* get only the bit we want */\n-    if (size > 0)\n-    {\n-        int len;\n-        const uint8_t *sig_ptr = get_signature(&block[i], &len);\n+    /* check the first 2 bytes */\n+    if (block[0] != 0 || block[1] != 1)\n+        goto err;\n \n-        if (sig_ptr)\n-        {\n-            bir = bi_import(ctx, sig_ptr, len);\n-        }\n+    /* check the padding */\n+    i = 2; /* start at the first padding byte */\n+    while (i < sig_len - 1 - sig_prefix_size - hash_len)\n+    { /* together with (#A), we require at least 8 bytes of padding */\n+        if (block[i++] != 0xFF)\n+            goto err;\n     }\n+\n+    /* check end of padding */\n+    if (block[i++] != 0)\n+        goto err;\n+\n+    /* check the ASN.1 metadata */\n+    if (memcmp_P(block+i, sig_prefix, sig_prefix_size))\n+        goto err;\n+\n+    /* now we can get the hash we need */\n+    bir = bi_import(ctx, block + i + sig_prefix_size, hash_len);\n+\n+err:\n     free(block);\n     /* save a few bytes of memory */\n     bi_clear_cache(ctx);\n@@ -600,7 +626,7 @@ int x509_verify(const CA_CERT_CTX *ca_cert_ctx, const X509_CTX *cert,\n     }\n \n     /* check the signature */\n-    cert_sig = sig_verify(ctx, cert->signature, cert->sig_len, \n+    cert_sig = sig_verify(ctx, cert->signature, cert->sig_len, cert->sig_type,\n                         bi_clone(ctx, mod), bi_clone(ctx, expn));\n \n     if (cert_sig && cert->digest)""}","static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,
static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len, uint8_t sig_type,
         bigint *modulus, bigint *pub_exp)
 {
    int i;
     bigint *decrypted_bi, *dat_bi;
     bigint *bir = NULL;
     uint8_t *block = (uint8_t *)malloc(sig_len);
 
    const uint8_t *sig_prefix = NULL;
    uint8_t sig_prefix_size = 0, hash_len = 0;
    /* adjust our expections */
    switch (sig_type)
    {
        case SIG_TYPE_MD5:
            sig_prefix = sig_prefix_md5;
            sig_prefix_size = sizeof(sig_prefix_md5);
        break;
        case SIG_TYPE_SHA1:
            sig_prefix = sig_prefix_sha1;
            sig_prefix_size = sizeof(sig_prefix_sha1);
        break;
        case SIG_TYPE_SHA256:
            sig_prefix = sig_prefix_sha256;
            sig_prefix_size = sizeof(sig_prefix_sha256);
        break;
        case SIG_TYPE_SHA384:
            sig_prefix = sig_prefix_sha384;
            sig_prefix_size = sizeof(sig_prefix_sha384);
        break;
        case SIG_TYPE_SHA512:
            sig_prefix = sig_prefix_sha512;
            sig_prefix_size = sizeof(sig_prefix_sha512);
        break;
    }
    if (sig_prefix)
        hash_len = sig_prefix[sig_prefix_size - 1];

    /* check length (#A) */
    if (sig_len < 2 + 8 + 1 + sig_prefix_size + hash_len)
        goto err;

     /* decrypt */
     dat_bi = bi_import(ctx, sig, sig_len);
     ctx->mod_offset = BIGINT_M_OFFSET;

    /* convert to a normal block */
    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);

     bi_export(ctx, decrypted_bi, block, sig_len);
     ctx->mod_offset = BIGINT_M_OFFSET;
 
    /* check the first 2 bytes */
    if (block[0] != 0 || block[1] != 1)
        goto err;
 
    /* check the padding */
    i = 2; /* start at the first padding byte */
    while (i < sig_len - 1 - sig_prefix_size - hash_len)
    { /* together with (#A), we require at least 8 bytes of padding */
        if (block[i++] != 0xFF)
            goto err;
     }

    /* check end of padding */
    if (block[i++] != 0)
        goto err;

    /* check the ASN.1 metadata */
    if (memcmp_P(block+i, sig_prefix, sig_prefix_size))
        goto err;

    /* now we can get the hash we need */
    bir = bi_import(ctx, block + i + sig_prefix_size, hash_len);

err:
     free(block);
     /* save a few bytes of memory */
     bi_clear_cache(ctx);
    return bir;
}
","static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,
         bigint *modulus, bigint *pub_exp)
 {
    int i, size;
     bigint *decrypted_bi, *dat_bi;
     bigint *bir = NULL;
     uint8_t *block = (uint8_t *)malloc(sig_len);
 
     /* decrypt */
     dat_bi = bi_import(ctx, sig, sig_len);
     ctx->mod_offset = BIGINT_M_OFFSET;

    /* convert to a normal block */
    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);

     bi_export(ctx, decrypted_bi, block, sig_len);
     ctx->mod_offset = BIGINT_M_OFFSET;
 
    i = 10; /* start at the first possible non-padded byte */
    while (block[i++] && i < sig_len);
    size = sig_len - i;
    /* get only the bit we want */
    if (size > 0)
    {
        int len;
        const uint8_t *sig_ptr = get_signature(&block[i], &len);
 
        if (sig_ptr)
        {
            bir = bi_import(ctx, sig_ptr, len);
        }
     }
     free(block);
     /* save a few bytes of memory */
     bi_clear_cache(ctx);
    return bir;
}
",C,"static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len, uint8_t sig_type,
    int i;
    const uint8_t *sig_prefix = NULL;
    uint8_t sig_prefix_size = 0, hash_len = 0;
    /* adjust our expections */
    switch (sig_type)
    {
        case SIG_TYPE_MD5:
            sig_prefix = sig_prefix_md5;
            sig_prefix_size = sizeof(sig_prefix_md5);
        break;
        case SIG_TYPE_SHA1:
            sig_prefix = sig_prefix_sha1;
            sig_prefix_size = sizeof(sig_prefix_sha1);
        break;
        case SIG_TYPE_SHA256:
            sig_prefix = sig_prefix_sha256;
            sig_prefix_size = sizeof(sig_prefix_sha256);
        break;
        case SIG_TYPE_SHA384:
            sig_prefix = sig_prefix_sha384;
            sig_prefix_size = sizeof(sig_prefix_sha384);
        break;
        case SIG_TYPE_SHA512:
            sig_prefix = sig_prefix_sha512;
            sig_prefix_size = sizeof(sig_prefix_sha512);
        break;
    }
    if (sig_prefix)
        hash_len = sig_prefix[sig_prefix_size - 1];

    /* check length (#A) */
    if (sig_len < 2 + 8 + 1 + sig_prefix_size + hash_len)
        goto err;

    /* check the first 2 bytes */
    if (block[0] != 0 || block[1] != 1)
        goto err;
    /* check the padding */
    i = 2; /* start at the first padding byte */
    while (i < sig_len - 1 - sig_prefix_size - hash_len)
    { /* together with (#A), we require at least 8 bytes of padding */
        if (block[i++] != 0xFF)
            goto err;

    /* check end of padding */
    if (block[i++] != 0)
        goto err;

    /* check the ASN.1 metadata */
    if (memcmp_P(block+i, sig_prefix, sig_prefix_size))
        goto err;

    /* now we can get the hash we need */
    bir = bi_import(ctx, block + i + sig_prefix_size, hash_len);

err:
","    int i, size;
    i = 10; /* start at the first possible non-padded byte */
    while (block[i++] && i < sig_len);
    size = sig_len - i;
    /* get only the bit we want */
    if (size > 0)
    {
        int len;
        const uint8_t *sig_ptr = get_signature(&block[i], &len);
        if (sig_ptr)
        {
            bir = bi_import(ctx, sig_ptr, len);
        }
",,"@@ -49,28 +49,6 @@ static int x509_v3_basic_constraints(const uint8_t *cert, int offset,
         X509_CTX *x509_ctx);
 static int x509_v3_key_usage(const uint8_t *cert, int offset, 
         X509_CTX *x509_ctx);
-
-/**
- * Retrieve the signature from a certificate.
- */
-static const uint8_t *get_signature(const uint8_t *asn1_sig, int *len)
-{
-    int offset = 0;
-    const uint8_t *ptr = NULL;
-
-    if (asn1_next_obj(asn1_sig, &offset, ASN1_SEQUENCE) < 0 || 
-            asn1_skip_obj(asn1_sig, &offset, ASN1_SEQUENCE))
-        goto end_get_sig;
-
-    if (asn1_sig[offset++] != ASN1_OCTET_STRING)
-        goto end_get_sig;
-    *len = get_asn1_length(asn1_sig, &offset);
-    ptr = &asn1_sig[offset];          /* all ok */
-
-end_get_sig:
-    return ptr;
-}
-
 #endif
 
 /**
@@ -412,17 +390,56 @@ void x509_free(X509_CTX *x509_ctx)
 }
 
 #ifdef CONFIG_SSL_CERT_VERIFICATION
+static const uint8_t sig_prefix_md5[] PROGMEM = {0x30, 0x20, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10};
+static const uint8_t sig_prefix_sha1[] PROGMEM = {0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0x04, 0x14};
+static const uint8_t sig_prefix_sha256[] PROGMEM = {0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20};
+static const uint8_t sig_prefix_sha384[] PROGMEM = {0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30};
+static const uint8_t sig_prefix_sha512[] PROGMEM = {0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40};
+
 /**
  * Take a signature and decrypt it.
  */
-static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,
+static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len, uint8_t sig_type,
         bigint *modulus, bigint *pub_exp)
 {
-    int i, size;
+    int i;
     bigint *decrypted_bi, *dat_bi;
     bigint *bir = NULL;
     uint8_t *block = (uint8_t *)malloc(sig_len);
 
+    const uint8_t *sig_prefix = NULL;
+    uint8_t sig_prefix_size = 0, hash_len = 0;
+    /* adjust our expections */
+    switch (sig_type)
+    {
+        case SIG_TYPE_MD5:
+            sig_prefix = sig_prefix_md5;
+            sig_prefix_size = sizeof(sig_prefix_md5);
+        break;
+        case SIG_TYPE_SHA1:
+            sig_prefix = sig_prefix_sha1;
+            sig_prefix_size = sizeof(sig_prefix_sha1);
+        break;
+        case SIG_TYPE_SHA256:
+            sig_prefix = sig_prefix_sha256;
+            sig_prefix_size = sizeof(sig_prefix_sha256);
+        break;
+        case SIG_TYPE_SHA384:
+            sig_prefix = sig_prefix_sha384;
+            sig_prefix_size = sizeof(sig_prefix_sha384);
+        break;
+        case SIG_TYPE_SHA512:
+            sig_prefix = sig_prefix_sha512;
+            sig_prefix_size = sizeof(sig_prefix_sha512);
+        break;
+    }
+    if (sig_prefix)
+        hash_len = sig_prefix[sig_prefix_size - 1];
+
+    /* check length (#A) */
+    if (sig_len < 2 + 8 + 1 + sig_prefix_size + hash_len)
+        goto err;
+
     /* decrypt */
     dat_bi = bi_import(ctx, sig, sig_len);
     ctx->mod_offset = BIGINT_M_OFFSET;
@@ -433,21 +450,30 @@ static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,
     bi_export(ctx, decrypted_bi, block, sig_len);
     ctx->mod_offset = BIGINT_M_OFFSET;
 
-    i = 10; /* start at the first possible non-padded byte */
-    while (block[i++] && i < sig_len);
-    size = sig_len - i;
-
-    /* get only the bit we want */
-    if (size > 0)
-    {
-        int len;
-        const uint8_t *sig_ptr = get_signature(&block[i], &len);
+    /* check the first 2 bytes */
+    if (block[0] != 0 || block[1] != 1)
+        goto err;
 
-        if (sig_ptr)
-        {
-            bir = bi_import(ctx, sig_ptr, len);
-        }
+    /* check the padding */
+    i = 2; /* start at the first padding byte */
+    while (i < sig_len - 1 - sig_prefix_size - hash_len)
+    { /* together with (#A), we require at least 8 bytes of padding */
+        if (block[i++] != 0xFF)
+            goto err;
     }
+
+    /* check end of padding */
+    if (block[i++] != 0)
+        goto err;
+
+    /* check the ASN.1 metadata */
+    if (memcmp_P(block+i, sig_prefix, sig_prefix_size))
+        goto err;
+
+    /* now we can get the hash we need */
+    bir = bi_import(ctx, block + i + sig_prefix_size, hash_len);
+
+err:
     free(block);
     /* save a few bytes of memory */
     bi_clear_cache(ctx);
@@ -600,7 +626,7 @@ int x509_verify(const CA_CERT_CTX *ca_cert_ctx, const X509_CTX *cert,
     }
 
     /* check the signature */
-    cert_sig = sig_verify(ctx, cert->signature, cert->sig_len, 
+    cert_sig = sig_verify(ctx, cert->signature, cert->sig_len, cert->sig_type,
                         bi_clone(ctx, mod), bi_clone(ctx, expn));
 
     if (cert_sig && cert->digest)",axtls-8266,5efe2947ab45e81d84b5f707c51d1c64be52f36c,e634adf0d4f668918e266192d9f09538cd3ffa42,1,"static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,
//fix_flaw_line_below:
//static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len, uint8_t sig_type,
         bigint *modulus, bigint *pub_exp)
 {
//flaw_line_below:
    int i, size;
//fix_flaw_line_below:
//    int i;
     bigint *decrypted_bi, *dat_bi;
     bigint *bir = NULL;
     uint8_t *block = (uint8_t *)malloc(sig_len);
 
//fix_flaw_line_below:
//    const uint8_t *sig_prefix = NULL;
//fix_flaw_line_below:
//    uint8_t sig_prefix_size = 0, hash_len = 0;
//fix_flaw_line_below:
//    /* adjust our expections */
//fix_flaw_line_below:
//    switch (sig_type)
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//        case SIG_TYPE_MD5:
//fix_flaw_line_below:
//            sig_prefix = sig_prefix_md5;
//fix_flaw_line_below:
//            sig_prefix_size = sizeof(sig_prefix_md5);
//fix_flaw_line_below:
//        break;
//fix_flaw_line_below:
//        case SIG_TYPE_SHA1:
//fix_flaw_line_below:
//            sig_prefix = sig_prefix_sha1;
//fix_flaw_line_below:
//            sig_prefix_size = sizeof(sig_prefix_sha1);
//fix_flaw_line_below:
//        break;
//fix_flaw_line_below:
//        case SIG_TYPE_SHA256:
//fix_flaw_line_below:
//            sig_prefix = sig_prefix_sha256;
//fix_flaw_line_below:
//            sig_prefix_size = sizeof(sig_prefix_sha256);
//fix_flaw_line_below:
//        break;
//fix_flaw_line_below:
//        case SIG_TYPE_SHA384:
//fix_flaw_line_below:
//            sig_prefix = sig_prefix_sha384;
//fix_flaw_line_below:
//            sig_prefix_size = sizeof(sig_prefix_sha384);
//fix_flaw_line_below:
//        break;
//fix_flaw_line_below:
//        case SIG_TYPE_SHA512:
//fix_flaw_line_below:
//            sig_prefix = sig_prefix_sha512;
//fix_flaw_line_below:
//            sig_prefix_size = sizeof(sig_prefix_sha512);
//fix_flaw_line_below:
//        break;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//    if (sig_prefix)
//fix_flaw_line_below:
//        hash_len = sig_prefix[sig_prefix_size - 1];
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    /* check length (#A) */
//fix_flaw_line_below:
//    if (sig_len < 2 + 8 + 1 + sig_prefix_size + hash_len)
//fix_flaw_line_below:
//        goto err;
//fix_flaw_line_below:
//
     /* decrypt */
     dat_bi = bi_import(ctx, sig, sig_len);
     ctx->mod_offset = BIGINT_M_OFFSET;

    /* convert to a normal block */
    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);

     bi_export(ctx, decrypted_bi, block, sig_len);
     ctx->mod_offset = BIGINT_M_OFFSET;
 
//flaw_line_below:
    i = 10; /* start at the first possible non-padded byte */
//flaw_line_below:
    while (block[i++] && i < sig_len);
//flaw_line_below:
    size = sig_len - i;
//flaw_line_below:

//flaw_line_below:
    /* get only the bit we want */
//flaw_line_below:
    if (size > 0)
//flaw_line_below:
    {
//flaw_line_below:
        int len;
//flaw_line_below:
        const uint8_t *sig_ptr = get_signature(&block[i], &len);
//fix_flaw_line_below:
//    /* check the first 2 bytes */
//fix_flaw_line_below:
//    if (block[0] != 0 || block[1] != 1)
//fix_flaw_line_below:
//        goto err;
 
//flaw_line_below:
        if (sig_ptr)
//flaw_line_below:
        {
//flaw_line_below:
            bir = bi_import(ctx, sig_ptr, len);
//flaw_line_below:
        }
//fix_flaw_line_below:
//    /* check the padding */
//fix_flaw_line_below:
//    i = 2; /* start at the first padding byte */
//fix_flaw_line_below:
//    while (i < sig_len - 1 - sig_prefix_size - hash_len)
//fix_flaw_line_below:
//    { /* together with (#A), we require at least 8 bytes of padding */
//fix_flaw_line_below:
//        if (block[i++] != 0xFF)
//fix_flaw_line_below:
//            goto err;
     }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    /* check end of padding */
//fix_flaw_line_below:
//    if (block[i++] != 0)
//fix_flaw_line_below:
//        goto err;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    /* check the ASN.1 metadata */
//fix_flaw_line_below:
//    if (memcmp_P(block+i, sig_prefix, sig_prefix_size))
//fix_flaw_line_below:
//        goto err;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    /* now we can get the hash we need */
//fix_flaw_line_below:
//    bir = bi_import(ctx, block + i + sig_prefix_size, hash_len);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//err:
     free(block);
     /* save a few bytes of memory */
     bi_clear_cache(ctx);
    return bir;
}
",182258,"static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,
         bigint *modulus, bigint *pub_exp)
 {
    int i, size;
     bigint *decrypted_bi, *dat_bi;
     bigint *bir = NULL;
     uint8_t *block = (uint8_t *)malloc(sig_len);
 
     /* decrypt */
     dat_bi = bi_import(ctx, sig, sig_len);
     ctx->mod_offset = BIGINT_M_OFFSET;

    /* convert to a normal block */
    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);

     bi_export(ctx, decrypted_bi, block, sig_len);
     ctx->mod_offset = BIGINT_M_OFFSET;
 
    i = 10; /* start at the first possible non-padded byte */
    while (block[i++] && i < sig_len);
    size = sig_len - i;
    /* get only the bit we want */
    if (size > 0)
    {
        int len;
        const uint8_t *sig_ptr = get_signature(&block[i], &len);
 
        if (sig_ptr)
        {
            bir = bi_import(ctx, sig_ptr, len);
        }
     }
     free(block);
     /* save a few bytes of memory */
     bi_clear_cache(ctx);
    return bir;
}
","static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,
static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len, uint8_t sig_type,
         bigint *modulus, bigint *pub_exp)
 {
    int i;
     bigint *decrypted_bi, *dat_bi;
     bigint *bir = NULL;
     uint8_t *block = (uint8_t *)malloc(sig_len);
 
    const uint8_t *sig_prefix = NULL;
    uint8_t sig_prefix_size = 0, hash_len = 0;
    /* adjust our expections */
    switch (sig_type)
    {
        case SIG_TYPE_MD5:
            sig_prefix = sig_prefix_md5;
            sig_prefix_size = sizeof(sig_prefix_md5);
        break;
        case SIG_TYPE_SHA1:
            sig_prefix = sig_prefix_sha1;
            sig_prefix_size = sizeof(sig_prefix_sha1);
        break;
        case SIG_TYPE_SHA256:
            sig_prefix = sig_prefix_sha256;
            sig_prefix_size = sizeof(sig_prefix_sha256);
        break;
        case SIG_TYPE_SHA384:
            sig_prefix = sig_prefix_sha384;
            sig_prefix_size = sizeof(sig_prefix_sha384);
        break;
        case SIG_TYPE_SHA512:
            sig_prefix = sig_prefix_sha512;
            sig_prefix_size = sizeof(sig_prefix_sha512);
        break;
    }
    if (sig_prefix)
        hash_len = sig_prefix[sig_prefix_size - 1];

    /* check length (#A) */
    if (sig_len < 2 + 8 + 1 + sig_prefix_size + hash_len)
        goto err;

     /* decrypt */
     dat_bi = bi_import(ctx, sig, sig_len);
     ctx->mod_offset = BIGINT_M_OFFSET;

    /* convert to a normal block */
    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);

     bi_export(ctx, decrypted_bi, block, sig_len);
     ctx->mod_offset = BIGINT_M_OFFSET;
 
    /* check the first 2 bytes */
    if (block[0] != 0 || block[1] != 1)
        goto err;
 
    /* check the padding */
    i = 2; /* start at the first padding byte */
    while (i < sig_len - 1 - sig_prefix_size - hash_len)
    { /* together with (#A), we require at least 8 bytes of padding */
        if (block[i++] != 0xFF)
            goto err;
     }

    /* check end of padding */
    if (block[i++] != 0)
        goto err;

    /* check the ASN.1 metadata */
    if (memcmp_P(block+i, sig_prefix, sig_prefix_size))
        goto err;

    /* now we can get the hash we need */
    bir = bi_import(ctx, block + i + sig_prefix_size, hash_len);

err:
     free(block);
     /* save a few bytes of memory */
     bi_clear_cache(ctx);
    return bir;
}
","The `sig_verify` function is designed to verify a digital signature by decrypting it using a public key. It takes a signature (`sig`), its length (`sig_len`), a modulus (`modulus`), and a public exponent (`pub_exp`) as inputs. The function first imports the signature into a bigint format and then decrypts it using modular exponentiation. It converts the decrypted bigint back into a byte array, searching for the first non-padded byte to determine the actual size of the signature data. If valid signature data is found, it imports this data into a bigint and returns it, while also managing memory efficiently by freeing allocated resources.","The provided code implements a function that verifies a digital signature by decrypting it using a public key. It begins by converting the signature into a specific numerical format and then performs modular exponentiation to decrypt the data. After decryption, the function converts the result back into a byte array and identifies the actual size of the signature data by locating the first non-padded byte. If valid data is found, it is converted back into the numerical format for further processing. The function also ensures efficient memory management by freeing allocated resources before returning the result.","The vulnerability in the original code stemmed from insufficient validation of the signature's structure, which could allow an attacker to exploit improper padding or malformed signatures, potentially leading to signature forgery. The fixed code addresses this by introducing a signature type parameter and validating the signature's length against expected values based on the hash type. It checks the first two bytes for specific values, ensures a minimum padding length, and verifies the ASN.1 metadata against predefined prefixes. These additional checks enhance the robustness of the signature verification process, mitigating the risks associated with the identified vulnerabilities.","The vulnerability in the original code was due to inadequate validation of the signature structure, which could allow attackers to exploit weaknesses in padding or malformed signatures, potentially leading to unauthorized signature verification. The fixed code enhances security by introducing checks for the signature's length based on the expected format, ensuring that it meets specific criteria. It also verifies the initial bytes for correct values, enforces a minimum padding requirement, and checks for proper metadata. These improvements significantly strengthen the signature verification process, addressing the identified vulnerabilities and preventing potential exploitation.","The vulnerability was fixed by adding comprehensive validation checks in the modified code. It introduced a signature type parameter to determine the expected prefix and hash length, which are critical for proper signature parsing. The code now checks the length of the signature against a calculated minimum requirement, ensuring it is sufficient for valid padding and metadata. It verifies that the first two bytes are correct, checks for a minimum number of padding bytes, and confirms the ASN.1 metadata matches the expected prefix using `memcmp_P`. These enhancements ensure that only properly formatted signatures are processed, mitigating the risk of exploitation.","The vulnerability was fixed by implementing a series of validation checks to ensure the integrity and structure of the signature. The updated code introduces a mechanism to determine the expected format based on the signature type, which helps in validating the length and structure of the signature. It enforces checks on the initial bytes to confirm they meet specific criteria, verifies the required padding, and ensures that the metadata conforms to expected standards. These enhancements collectively strengthen the signature verification process, preventing the acceptance of malformed or malicious signatures and thereby mitigating potential security risks.","CWE-347,CWE-295,CWE-310,CWE-287,CWE-354,CWE-345,CWE-330,CWE-326,CWE-322,CWE-294",Y,1.0,"4,4","4,4","4,5","4, 4"
3,3,182269,182269,,Remote,Not required,,CVE-2018-15836,https://www.cvedetails.com/cve/CVE-2018-15836/,CWE-347,Low,,Partial,,2018-09-26,5.0,"In verify_signed_hash() in lib/liboswkeys/signatures.c in Openswan before 2.6.50.1, the RSA implementation does not verify the value of padding string during PKCS#1 v1.5 signature verification. Consequently, a remote attacker can forge signatures when small public exponents are being used. IKEv2 signature verification is affected when RAW RSA keys are used.",2019-01-10,,15,https://github.com/xelerance/Openswan/commit/9eaa6c2a823c1d2b58913506a15f9474bf857a3d,9eaa6c2a823c1d2b58913506a15f9474bf857a3d,"wo#7449 . verify padding contents for IKEv2 RSA sig check

Special thanks to Sze Yiu Chau of Purdue University (schau@purdue.edu)
who reported the issue.",2,lib/liboswkeys/signatures.c,"{""sha"": ""7f0fb90fb4969167958f8d2b332d56c4150f6f22"", ""filename"": ""lib/liboswkeys/signatures.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 2, ""changes"": 17, ""blob_url"": ""https://github.com/xelerance/Openswan/blob/9eaa6c2a823c1d2b58913506a15f9474bf857a3d/lib/liboswkeys/signatures.c"", ""raw_url"": ""https://github.com/xelerance/Openswan/raw/9eaa6c2a823c1d2b58913506a15f9474bf857a3d/lib/liboswkeys/signatures.c"", ""contents_url"": ""https://api.github.com/repos/xelerance/Openswan/contents/lib/liboswkeys/signatures.c?ref=9eaa6c2a823c1d2b58913506a15f9474bf857a3d"", ""patch"": ""@@ -157,8 +157,21 @@ err_t verify_signed_hash(const struct RSA_public_key *k\n \treturn \""3\""\""SIG padding does not check out\"";\n     }\n \n-    s += padlen + 3;\n-    (*psig) = s;\n+    /* signature starts after ASN wrapped padding [00,01,FF..FF,00] */\n+    (*psig) = s + padlen + 3;\n+\n+    /* verify padding contents */\n+    {\n+        const u_char *p;\n+        size_t cnt_ffs = 0;\n+\n+        for (p = s+2; p < s+padlen+2; p++)\n+            if (*p == 0xFF)\n+                cnt_ffs ++;\n+\n+        if (cnt_ffs != padlen)\n+            return \""4\"" \""invalid Padding String\"";\n+    }\n \n     /* return SUCCESS */\n     return NULL;""}","err_t verify_signed_hash(const struct RSA_public_key *k
                         , u_char *s, unsigned int s_max_octets
                         , u_char **psig
                         , size_t hash_len
                         , const u_char *sig_val, size_t sig_len)
{
    unsigned int padlen;

    /* actual exponentiation; see PKCS#1 v2.0 5.1 */
    {
	chunk_t temp_s;
	MP_INT c;

	n_to_mpz(&c, sig_val, sig_len);
	oswcrypto.mod_exp(&c, &c, &k->e, &k->n);

	temp_s = mpz_to_n(&c, sig_len);	/* back to octets */
        if(s_max_octets < sig_len) {
            return ""2""""exponentiation failed; too many octets"";
        }
	memcpy(s, temp_s.ptr, sig_len);
	pfree(temp_s.ptr);
	mpz_clear(&c);
    }

    /* check signature contents */
    /* verify padding (not including any DER digest info! */
    padlen = sig_len - 3 - hash_len;
    /* now check padding */

    DBG(DBG_CRYPT,
	DBG_dump(""verify_sh decrypted SIG1:"", s, sig_len));
    DBG(DBG_CRYPT, DBG_log(""pad_len calculated: %d hash_len: %d"", padlen, (int)hash_len));

    /* skip padding */
    if(s[0]    != 0x00
       || s[1] != 0x01
       || s[padlen+2] != 0x00) {
 	return ""3""""SIG padding does not check out"";
     }
 
    /* signature starts after ASN wrapped padding [00,01,FF..FF,00] */
    (*psig) = s + padlen + 3;

    /* verify padding contents */
    {
        const u_char *p;
        size_t cnt_ffs = 0;

        for (p = s+2; p < s+padlen+2; p++)
            if (*p == 0xFF)
                cnt_ffs ++;

        if (cnt_ffs != padlen)
            return ""4"" ""invalid Padding String"";
    }
 
     /* return SUCCESS */
     return NULL;
}
","err_t verify_signed_hash(const struct RSA_public_key *k
                         , u_char *s, unsigned int s_max_octets
                         , u_char **psig
                         , size_t hash_len
                         , const u_char *sig_val, size_t sig_len)
{
    unsigned int padlen;

    /* actual exponentiation; see PKCS#1 v2.0 5.1 */
    {
	chunk_t temp_s;
	MP_INT c;

	n_to_mpz(&c, sig_val, sig_len);
	oswcrypto.mod_exp(&c, &c, &k->e, &k->n);

	temp_s = mpz_to_n(&c, sig_len);	/* back to octets */
        if(s_max_octets < sig_len) {
            return ""2""""exponentiation failed; too many octets"";
        }
	memcpy(s, temp_s.ptr, sig_len);
	pfree(temp_s.ptr);
	mpz_clear(&c);
    }

    /* check signature contents */
    /* verify padding (not including any DER digest info! */
    padlen = sig_len - 3 - hash_len;
    /* now check padding */

    DBG(DBG_CRYPT,
	DBG_dump(""verify_sh decrypted SIG1:"", s, sig_len));
    DBG(DBG_CRYPT, DBG_log(""pad_len calculated: %d hash_len: %d"", padlen, (int)hash_len));

    /* skip padding */
    if(s[0]    != 0x00
       || s[1] != 0x01
       || s[padlen+2] != 0x00) {
 	return ""3""""SIG padding does not check out"";
     }
 
    s += padlen + 3;
    (*psig) = s;
 
     /* return SUCCESS */
     return NULL;
}
",C,"    /* signature starts after ASN wrapped padding [00,01,FF..FF,00] */
    (*psig) = s + padlen + 3;

    /* verify padding contents */
    {
        const u_char *p;
        size_t cnt_ffs = 0;

        for (p = s+2; p < s+padlen+2; p++)
            if (*p == 0xFF)
                cnt_ffs ++;

        if (cnt_ffs != padlen)
            return ""4"" ""invalid Padding String"";
    }
","    s += padlen + 3;
    (*psig) = s;
",,"@@ -157,8 +157,21 @@ err_t verify_signed_hash(const struct RSA_public_key *k
 	return ""3""""SIG padding does not check out"";
     }
 
-    s += padlen + 3;
-    (*psig) = s;
+    /* signature starts after ASN wrapped padding [00,01,FF..FF,00] */
+    (*psig) = s + padlen + 3;
+
+    /* verify padding contents */
+    {
+        const u_char *p;
+        size_t cnt_ffs = 0;
+
+        for (p = s+2; p < s+padlen+2; p++)
+            if (*p == 0xFF)
+                cnt_ffs ++;
+
+        if (cnt_ffs != padlen)
+            return ""4"" ""invalid Padding String"";
+    }
 
     /* return SUCCESS */
     return NULL;",Openswan,9eaa6c2a823c1d2b58913506a15f9474bf857a3d,d28ef9e18903422a3d6cb912a8539ed8f0a24df5,1,"err_t verify_signed_hash(const struct RSA_public_key *k
                         , u_char *s, unsigned int s_max_octets
                         , u_char **psig
                         , size_t hash_len
                         , const u_char *sig_val, size_t sig_len)
{
    unsigned int padlen;

    /* actual exponentiation; see PKCS#1 v2.0 5.1 */
    {
	chunk_t temp_s;
	MP_INT c;

	n_to_mpz(&c, sig_val, sig_len);
	oswcrypto.mod_exp(&c, &c, &k->e, &k->n);

	temp_s = mpz_to_n(&c, sig_len);	/* back to octets */
        if(s_max_octets < sig_len) {
            return ""2""""exponentiation failed; too many octets"";
        }
	memcpy(s, temp_s.ptr, sig_len);
	pfree(temp_s.ptr);
	mpz_clear(&c);
    }

    /* check signature contents */
    /* verify padding (not including any DER digest info! */
    padlen = sig_len - 3 - hash_len;
    /* now check padding */

    DBG(DBG_CRYPT,
	DBG_dump(""verify_sh decrypted SIG1:"", s, sig_len));
    DBG(DBG_CRYPT, DBG_log(""pad_len calculated: %d hash_len: %d"", padlen, (int)hash_len));

    /* skip padding */
    if(s[0]    != 0x00
       || s[1] != 0x01
       || s[padlen+2] != 0x00) {
 	return ""3""""SIG padding does not check out"";
     }
 
//flaw_line_below:
    s += padlen + 3;
//flaw_line_below:
    (*psig) = s;
//fix_flaw_line_below:
//    /* signature starts after ASN wrapped padding [00,01,FF..FF,00] */
//fix_flaw_line_below:
//    (*psig) = s + padlen + 3;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    /* verify padding contents */
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//        const u_char *p;
//fix_flaw_line_below:
//        size_t cnt_ffs = 0;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        for (p = s+2; p < s+padlen+2; p++)
//fix_flaw_line_below:
//            if (*p == 0xFF)
//fix_flaw_line_below:
//                cnt_ffs ++;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        if (cnt_ffs != padlen)
//fix_flaw_line_below:
//            return ""4"" ""invalid Padding String"";
//fix_flaw_line_below:
//    }
 
     /* return SUCCESS */
     return NULL;
}
",182269,"err_t verify_signed_hash(const struct RSA_public_key *k
                         , u_char *s, unsigned int s_max_octets
                         , u_char **psig
                         , size_t hash_len
                         , const u_char *sig_val, size_t sig_len)
{
    unsigned int padlen;

    /* actual exponentiation; see PKCS#1 v2.0 5.1 */
    {
	chunk_t temp_s;
	MP_INT c;

	n_to_mpz(&c, sig_val, sig_len);
	oswcrypto.mod_exp(&c, &c, &k->e, &k->n);

	temp_s = mpz_to_n(&c, sig_len);	/* back to octets */
        if(s_max_octets < sig_len) {
            return ""2""""exponentiation failed; too many octets"";
        }
	memcpy(s, temp_s.ptr, sig_len);
	pfree(temp_s.ptr);
	mpz_clear(&c);
    }

    /* check signature contents */
    /* verify padding (not including any DER digest info! */
    padlen = sig_len - 3 - hash_len;
    /* now check padding */

    DBG(DBG_CRYPT,
	DBG_dump(""verify_sh decrypted SIG1:"", s, sig_len));
    DBG(DBG_CRYPT, DBG_log(""pad_len calculated: %d hash_len: %d"", padlen, (int)hash_len));

    /* skip padding */
    if(s[0]    != 0x00
       || s[1] != 0x01
       || s[padlen+2] != 0x00) {
 	return ""3""""SIG padding does not check out"";
     }
 
    s += padlen + 3;
    (*psig) = s;
 
     /* return SUCCESS */
     return NULL;
}
","err_t verify_signed_hash(const struct RSA_public_key *k
                         , u_char *s, unsigned int s_max_octets
                         , u_char **psig
                         , size_t hash_len
                         , const u_char *sig_val, size_t sig_len)
{
    unsigned int padlen;

    /* actual exponentiation; see PKCS#1 v2.0 5.1 */
    {
	chunk_t temp_s;
	MP_INT c;

	n_to_mpz(&c, sig_val, sig_len);
	oswcrypto.mod_exp(&c, &c, &k->e, &k->n);

	temp_s = mpz_to_n(&c, sig_len);	/* back to octets */
        if(s_max_octets < sig_len) {
            return ""2""""exponentiation failed; too many octets"";
        }
	memcpy(s, temp_s.ptr, sig_len);
	pfree(temp_s.ptr);
	mpz_clear(&c);
    }

    /* check signature contents */
    /* verify padding (not including any DER digest info! */
    padlen = sig_len - 3 - hash_len;
    /* now check padding */

    DBG(DBG_CRYPT,
	DBG_dump(""verify_sh decrypted SIG1:"", s, sig_len));
    DBG(DBG_CRYPT, DBG_log(""pad_len calculated: %d hash_len: %d"", padlen, (int)hash_len));

    /* skip padding */
    if(s[0]    != 0x00
       || s[1] != 0x01
       || s[padlen+2] != 0x00) {
 	return ""3""""SIG padding does not check out"";
     }
 
    /* signature starts after ASN wrapped padding [00,01,FF..FF,00] */
    (*psig) = s + padlen + 3;

    /* verify padding contents */
    {
        const u_char *p;
        size_t cnt_ffs = 0;

        for (p = s+2; p < s+padlen+2; p++)
            if (*p == 0xFF)
                cnt_ffs ++;

        if (cnt_ffs != padlen)
            return ""4"" ""invalid Padding String"";
    }
 
     /* return SUCCESS */
     return NULL;
}
","The `verify_signed_hash` function is designed to verify the integrity of a digital signature using RSA public key cryptography. It takes a public key, a buffer for the decrypted signature, and the signature value itself, along with its length and the expected hash length. The function performs modular exponentiation on the signature value to decrypt it, checks the padding format according to PKCS#1 standards, and ensures that the padding and hash values are correctly formatted. If the signature is valid, it updates the pointer to the signature data and returns success; otherwise, it returns an error message indicating the failure reason.","The function is responsible for verifying a digital signature using RSA public key cryptography. It takes a public key, a buffer for storing the decrypted signature, and the signature value along with its length and the expected hash length. The function performs modular exponentiation to decrypt the signature and checks the padding format according to established cryptographic standards. It ensures that the padding and hash values conform to the expected structure. If the signature is valid, it updates a pointer to the signature data and returns a success indication; otherwise, it returns an error message detailing the failure.","The vulnerability in the original code stemmed from inadequate verification of the padding contents after decrypting the signature, which could allow an attacker to exploit the padding structure and potentially forge signatures. Specifically, the code only checked the initial bytes for expected values but did not validate the padding bytes themselves. The fix introduced a loop that counts the number of padding bytes (0xFF) between the padding header and the signature, ensuring that the count matches the expected padding length. This additional check prevents padding oracle attacks by enforcing stricter validation of the signature's structure.","The vulnerability in the original code was due to insufficient verification of the padding structure in the decrypted signature, which could allow attackers to exploit the padding and potentially forge valid signatures. The code only checked the initial bytes for expected values without validating the actual padding bytes, making it susceptible to padding oracle attacks. The fix implemented a loop to count the number of padding bytes and ensured that this count matched the expected length, thereby enforcing stricter validation of the signature's padding. This enhancement significantly improves the security of the signature verification process.","The vulnerability was fixed by adding a verification step that checks the contents of the padding in the decrypted signature. Specifically, a loop was introduced to count the number of padding bytes (0xFF) between the padding header and the signature, using the pointer to traverse the relevant section of the decrypted data. The count of these padding bytes is then compared to the expected padding length, calculated as `padlen`. If the count does not match, the function returns an error indicating an invalid padding string, thereby preventing potential padding oracle attacks and enhancing the overall security of the signature verification process.","The vulnerability was addressed by implementing a thorough check of the padding contents in the decrypted signature. A new verification step was added that counts the number of padding bytes present between the padding header and the actual signature data. This count is then compared to the expected length of the padding, ensuring that they match. If there is a discrepancy, the function returns an error indicating invalid padding. This enhancement significantly strengthens the security of the signature verification process by preventing potential attacks that exploit weaknesses in the padding structure.","CWE-347, CWE-325, CWE-328, CWE-354, CWE-780, CWE-295, CWE-330, CWE-326, CWE-311, CWE-320",Y,1.0,"4, 4","5,5","4,4","4,4"
4,4,182647,182647,,Remote,Not required,Partial,CVE-2019-1010279,https://www.cvedetails.com/cve/CVE-2019-1010279/,CWE-347,Low,,,,2019-07-18,5.0,Open Information Security Foundation Suricata prior to version 4.1.3 is affected by: Denial of Service - TCP/HTTP detection bypass. The impact is: An attacker can evade a signature detection with a specialy formed sequence of network packets. The component is: detect.c (https://github.com/OISF/suricata/pull/3625/commits/d8634daf74c882356659addb65fb142b738a186b). The attack vector is: An attacker can trigger the vulnerability by a specifically crafted network TCP session. The fixed version is: 4.1.3.,2019-08-01,DoS Bypass ,3,https://github.com/OISF/suricata/pull/3625/commits/d8634daf74c882356659addb65fb142b738a186b,d8634daf74c882356659addb65fb142b738a186b,"stream: fix false negative on bad RST

If a bad RST was received the stream inspection would not happen
for that packet, but it would still move the 'raw progress' tracker
forward. Following good packets would then fail to detect anything
before the 'raw progress' position.

Bug #2770

Reported-by: Alexey Vishnyakov",1,src/detect.c,"{""sha"": ""5270b5649a43bff4e65c3b6f63075001348c49b5"", ""filename"": ""src/detect.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/OISF/suricata/blob/d8634daf74c882356659addb65fb142b738a186b/src/detect.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/d8634daf74c882356659addb65fb142b738a186b/src/detect.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/detect.c?ref=d8634daf74c882356659addb65fb142b738a186b"", ""patch"": ""@@ -1039,7 +1039,9 @@ static void DetectRunCleanup(DetectEngineThreadCtx *det_ctx,\n \n     if (pflow != NULL) {\n         /* update inspected tracker for raw reassembly */\n-        if (p->proto == IPPROTO_TCP && pflow->protoctx != NULL) {\n+        if (p->proto == IPPROTO_TCP && pflow->protoctx != NULL &&\n+            (p->flags & PKT_STREAM_EST))\n+        {\n             StreamReassembleRawUpdateProgress(pflow->protoctx, p,\n                     det_ctx->raw_stream_progress);\n ""}","static void DetectRunCleanup(DetectEngineThreadCtx *det_ctx,
        Packet *p, Flow * const pflow)
{
    PACKET_PROFILING_DETECT_START(p, PROF_DETECT_CLEANUP);
    /* cleanup pkt specific part of the patternmatcher */
    PacketPatternCleanup(det_ctx);
 
     if (pflow != NULL) {
         /* update inspected tracker for raw reassembly */
        if (p->proto == IPPROTO_TCP && pflow->protoctx != NULL &&
            (p->flags & PKT_STREAM_EST))
        {
             StreamReassembleRawUpdateProgress(pflow->protoctx, p,
                     det_ctx->raw_stream_progress);
 
            DetectEngineCleanHCBDBuffers(det_ctx);
        }
    }
    PACKET_PROFILING_DETECT_END(p, PROF_DETECT_CLEANUP);
    SCReturn;
}
","static void DetectRunCleanup(DetectEngineThreadCtx *det_ctx,
        Packet *p, Flow * const pflow)
{
    PACKET_PROFILING_DETECT_START(p, PROF_DETECT_CLEANUP);
    /* cleanup pkt specific part of the patternmatcher */
    PacketPatternCleanup(det_ctx);
 
     if (pflow != NULL) {
         /* update inspected tracker for raw reassembly */
        if (p->proto == IPPROTO_TCP && pflow->protoctx != NULL) {
             StreamReassembleRawUpdateProgress(pflow->protoctx, p,
                     det_ctx->raw_stream_progress);
 
            DetectEngineCleanHCBDBuffers(det_ctx);
        }
    }
    PACKET_PROFILING_DETECT_END(p, PROF_DETECT_CLEANUP);
    SCReturn;
}
",C,"        if (p->proto == IPPROTO_TCP && pflow->protoctx != NULL &&
            (p->flags & PKT_STREAM_EST))
        {
","        if (p->proto == IPPROTO_TCP && pflow->protoctx != NULL) {
",,"@@ -1039,7 +1039,9 @@ static void DetectRunCleanup(DetectEngineThreadCtx *det_ctx,
 
     if (pflow != NULL) {
         /* update inspected tracker for raw reassembly */
-        if (p->proto == IPPROTO_TCP && pflow->protoctx != NULL) {
+        if (p->proto == IPPROTO_TCP && pflow->protoctx != NULL &&
+            (p->flags & PKT_STREAM_EST))
+        {
             StreamReassembleRawUpdateProgress(pflow->protoctx, p,
                     det_ctx->raw_stream_progress);
 ",suricata,d8634daf74c882356659addb65fb142b738a186b,fb18a1655c15d4025d2f0d79daf089079de41232,1,"static void DetectRunCleanup(DetectEngineThreadCtx *det_ctx,
        Packet *p, Flow * const pflow)
{
    PACKET_PROFILING_DETECT_START(p, PROF_DETECT_CLEANUP);
    /* cleanup pkt specific part of the patternmatcher */
    PacketPatternCleanup(det_ctx);
 
     if (pflow != NULL) {
         /* update inspected tracker for raw reassembly */
//flaw_line_below:
        if (p->proto == IPPROTO_TCP && pflow->protoctx != NULL) {
//fix_flaw_line_below:
//        if (p->proto == IPPROTO_TCP && pflow->protoctx != NULL &&
//fix_flaw_line_below:
//            (p->flags & PKT_STREAM_EST))
//fix_flaw_line_below:
//        {
             StreamReassembleRawUpdateProgress(pflow->protoctx, p,
                     det_ctx->raw_stream_progress);
 
            DetectEngineCleanHCBDBuffers(det_ctx);
        }
    }
    PACKET_PROFILING_DETECT_END(p, PROF_DETECT_CLEANUP);
    SCReturn;
}
",182647,"static void DetectRunCleanup(DetectEngineThreadCtx *det_ctx,
        Packet *p, Flow * const pflow)
{
    PACKET_PROFILING_DETECT_START(p, PROF_DETECT_CLEANUP);
    /* cleanup pkt specific part of the patternmatcher */
    PacketPatternCleanup(det_ctx);
 
     if (pflow != NULL) {
         /* update inspected tracker for raw reassembly */
        if (p->proto == IPPROTO_TCP && pflow->protoctx != NULL) {
             StreamReassembleRawUpdateProgress(pflow->protoctx, p,
                     det_ctx->raw_stream_progress);
 
            DetectEngineCleanHCBDBuffers(det_ctx);
        }
    }
    PACKET_PROFILING_DETECT_END(p, PROF_DETECT_CLEANUP);
    SCReturn;
}
","static void DetectRunCleanup(DetectEngineThreadCtx *det_ctx,
        Packet *p, Flow * const pflow)
{
    PACKET_PROFILING_DETECT_START(p, PROF_DETECT_CLEANUP);
    /* cleanup pkt specific part of the patternmatcher */
    PacketPatternCleanup(det_ctx);
 
     if (pflow != NULL) {
         /* update inspected tracker for raw reassembly */
        if (p->proto == IPPROTO_TCP && pflow->protoctx != NULL &&
            (p->flags & PKT_STREAM_EST))
        {
             StreamReassembleRawUpdateProgress(pflow->protoctx, p,
                     det_ctx->raw_stream_progress);
 
            DetectEngineCleanHCBDBuffers(det_ctx);
        }
    }
    PACKET_PROFILING_DETECT_END(p, PROF_DETECT_CLEANUP);
    SCReturn;
}
","The `DetectRunCleanup` function is designed to perform cleanup operations for packet detection within a network analysis context. It begins by initiating profiling for the packet detection process. The function then calls `PacketPatternCleanup` to clear any packet-specific data from the pattern matcher. If a valid flow (`pflow`) is provided, it checks if the packet is TCP and updates the raw reassembly progress using `StreamReassembleRawUpdateProgress`. Finally, it cleans up any associated buffers with `DetectEngineCleanHCBDBuffers` before concluding the profiling and returning control to the caller.","The function is responsible for managing the cleanup process related to packet detection in a network analysis system. It starts by profiling the detection operation and then clears any specific data associated with the packet's pattern matching. If there is an active flow context, it checks if the packet is of a certain type and updates the progress of raw data reassembly accordingly. Additionally, it performs cleanup of any associated buffers to ensure efficient memory management. The function concludes by finalizing the profiling and returning control to the calling context.","The vulnerability in the original code stemmed from the lack of a check for specific packet flags when processing TCP packets, which could lead to false negatives in stream inspection. If a bad reset (RST) packet was received, the system would incorrectly advance the raw progress tracker without properly inspecting the packet, causing subsequent valid packets to be undetected. The fix introduced an additional condition to verify that the packet's flags include a specific stream establishment flag before updating the raw progress tracker, ensuring that only valid packets contribute to the progress and preventing the false negative issue.","The vulnerability in the original code arose from the failure to properly inspect packets when a bad reset was received, which allowed the system to incorrectly advance the progress tracker without validating the packet's integrity. This oversight meant that subsequent valid packets could be missed, leading to false negatives in detection. The fix addressed this issue by adding a condition to ensure that only packets with the appropriate flags would update the progress tracker. This change ensures that the tracker only advances for valid packets, thereby maintaining accurate detection and preventing the issue of missing valid data following problematic packets.","The vulnerability was fixed by adding a condition to check the packet's flags before updating the raw progress tracker. In the modified code, the check for the specific stream establishment flag was introduced alongside the existing conditions for the packet's protocol and flow context. This ensures that the `StreamReassembleRawUpdateProgress` function is only called when the packet is valid and properly established, preventing the progress tracker from advancing on bad reset packets. As a result, this change ensures that subsequent valid packets are accurately processed, thereby eliminating the false negative issue in stream inspection.","The vulnerability was fixed by introducing an additional condition to verify the integrity of packets before advancing the progress tracker. This change ensures that the system only updates the tracker for packets that meet specific criteria, particularly focusing on the validity of the packet's state. By implementing this check, the code prevents the progress tracker from advancing when encountering problematic packets, thereby ensuring that only valid packets contribute to the tracking process. This adjustment effectively eliminates the risk of missing subsequent valid packets, thereby improving the accuracy of the detection mechanism.","CWE-754, CWE-20, CWE-119, CWE-789, CWE-404, CWE-664, CWE-703, CWE-74, CWE-252, CWE-248",N,-1.0,"4,4","5,5","4,4","5,4"
